var FJ = Object.defineProperty;
var zJ = (e, t, n) => t in e ? FJ(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n;
var fh = (e, t, n) => zJ(e, typeof t != "symbol" ? t + "" : t, n);
import * as Be from "react";
import we, { createContext as Ke, useContext as ge, Children as lt, forwardRef as to, useState as k, useEffect as h, memo as ve, useRef as ut, useMemo as Cn, isValidElement as yi, cloneElement as bi, Component as Wu, PureComponent as pe, createRef as mo, useId as UJ, useCallback as Nn, useLayoutEffect as HJ, useReducer as $J, useSyncExternalStore as WJ } from "react";
import { Info as I6, AlertTriangle as VJ, XCircle as R6, CheckCircle2 as B6, Loader2 as Ts, Pause as ZJ, Play as qJ, RefreshCw as x1, Check as Zy, FileImage as GJ, FileAudio as KJ, FileArchive as YJ, File as XJ, ChevronDown as O1, X as E1, Search as N6, Image as JJ, Heading1 as QJ, Heading2 as eQ, Quote as tQ, Bold as nQ, Italic as rQ, Underline as oQ, Code as iQ, AlignLeft as sQ, AlignRight as aQ, AlignCenter as lQ, AlignJustify as uQ, ChevronRight as ZO, ChevronLeft as cQ, Ellipsis as FS, MapPinned as pQ } from "lucide-react";
import { useActionData as k1, useNavigation as F6, useFetchers as L1, useLocation as P1, Link as dQ, useNavigate as z6 } from "@remix-run/react";
import { InputMask as cl } from "@react-input/mask";
import { AnimatePresence as U6, motion as vd } from "framer-motion";
import * as wi from "react-dom";
import pl, { createPortal as or } from "react-dom";
var Xn = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function qy(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var qO = { exports: {} }, Hc = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var zS;
function fQ() {
  if (zS) return Hc;
  zS = 1;
  var e = we, t = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, o = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, i = { key: !0, ref: !0, __self: !0, __source: !0 };
  function a(s, l, u) {
    var c, p = {}, d = null, g = null;
    u !== void 0 && (d = "" + u), l.key !== void 0 && (d = "" + l.key), l.ref !== void 0 && (g = l.ref);
    for (c in l) r.call(l, c) && !i.hasOwnProperty(c) && (p[c] = l[c]);
    if (s && s.defaultProps) for (c in l = s.defaultProps, l) p[c] === void 0 && (p[c] = l[c]);
    return { $$typeof: t, type: s, key: d, ref: g, props: p, _owner: o.current };
  }
  return Hc.Fragment = n, Hc.jsx = a, Hc.jsxs = a, Hc;
}
var $c = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var US;
function hQ() {
  return US || (US = 1, process.env.NODE_ENV !== "production" && function() {
    var e = we, t = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), a = Symbol.for("react.provider"), s = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), c = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), d = Symbol.for("react.lazy"), g = Symbol.for("react.offscreen"), f = Symbol.iterator, m = "@@iterator";
    function v(b) {
      if (b === null || typeof b != "object")
        return null;
      var I = f && b[f] || b[m];
      return typeof I == "function" ? I : null;
    }
    var E = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function w(b) {
      {
        for (var I = arguments.length, G = new Array(I > 1 ? I - 1 : 0), ne = 1; ne < I; ne++)
          G[ne - 1] = arguments[ne];
        M("error", b, G);
      }
    }
    function M(b, I, G) {
      {
        var ne = E.ReactDebugCurrentFrame, le = ne.getStackAddendum();
        le !== "" && (I += "%s", G = G.concat([le]));
        var ce = G.map(function(se) {
          return String(se);
        });
        ce.unshift("Warning: " + I), Function.prototype.apply.call(console[b], console, ce);
      }
    }
    var O = !1, y = !1, C = !1, _ = !1, F = !1, L;
    L = Symbol.for("react.module.reference");
    function N(b) {
      return !!(typeof b == "string" || typeof b == "function" || b === r || b === i || F || b === o || b === u || b === c || _ || b === g || O || y || C || typeof b == "object" && b !== null && (b.$$typeof === d || b.$$typeof === p || b.$$typeof === a || b.$$typeof === s || b.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      b.$$typeof === L || b.getModuleId !== void 0));
    }
    function R(b, I, G) {
      var ne = b.displayName;
      if (ne)
        return ne;
      var le = I.displayName || I.name || "";
      return le !== "" ? G + "(" + le + ")" : G;
    }
    function W(b) {
      return b.displayName || "Context";
    }
    function V(b) {
      if (b == null)
        return null;
      if (typeof b.tag == "number" && w("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof b == "function")
        return b.displayName || b.name || null;
      if (typeof b == "string")
        return b;
      switch (b) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case i:
          return "Profiler";
        case o:
          return "StrictMode";
        case u:
          return "Suspense";
        case c:
          return "SuspenseList";
      }
      if (typeof b == "object")
        switch (b.$$typeof) {
          case s:
            var I = b;
            return W(I) + ".Consumer";
          case a:
            var G = b;
            return W(G._context) + ".Provider";
          case l:
            return R(b, b.render, "ForwardRef");
          case p:
            var ne = b.displayName || null;
            return ne !== null ? ne : V(b.type) || "Memo";
          case d: {
            var le = b, ce = le._payload, se = le._init;
            try {
              return V(se(ce));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var z = Object.assign, Z = 0, K, X, te, J, P, D, H;
    function S() {
    }
    S.__reactDisabledLog = !0;
    function $() {
      {
        if (Z === 0) {
          K = console.log, X = console.info, te = console.warn, J = console.error, P = console.group, D = console.groupCollapsed, H = console.groupEnd;
          var b = {
            configurable: !0,
            enumerable: !0,
            value: S,
            writable: !0
          };
          Object.defineProperties(console, {
            info: b,
            log: b,
            warn: b,
            error: b,
            group: b,
            groupCollapsed: b,
            groupEnd: b
          });
        }
        Z++;
      }
    }
    function x() {
      {
        if (Z--, Z === 0) {
          var b = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: z({}, b, {
              value: K
            }),
            info: z({}, b, {
              value: X
            }),
            warn: z({}, b, {
              value: te
            }),
            error: z({}, b, {
              value: J
            }),
            group: z({}, b, {
              value: P
            }),
            groupCollapsed: z({}, b, {
              value: D
            }),
            groupEnd: z({}, b, {
              value: H
            })
          });
        }
        Z < 0 && w("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var j = E.ReactCurrentDispatcher, U;
    function T(b, I, G) {
      {
        if (U === void 0)
          try {
            throw Error();
          } catch (le) {
            var ne = le.stack.trim().match(/\n( *(at )?)/);
            U = ne && ne[1] || "";
          }
        return `
` + U + b;
      }
    }
    var q = !1, A;
    {
      var Y = typeof WeakMap == "function" ? WeakMap : Map;
      A = new Y();
    }
    function B(b, I) {
      if (!b || q)
        return "";
      {
        var G = A.get(b);
        if (G !== void 0)
          return G;
      }
      var ne;
      q = !0;
      var le = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var ce;
      ce = j.current, j.current = null, $();
      try {
        if (I) {
          var se = function() {
            throw Error();
          };
          if (Object.defineProperty(se.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(se, []);
            } catch (je) {
              ne = je;
            }
            Reflect.construct(b, [], se);
          } else {
            try {
              se.call();
            } catch (je) {
              ne = je;
            }
            b.call(se.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (je) {
            ne = je;
          }
          b();
        }
      } catch (je) {
        if (je && ne && typeof je.stack == "string") {
          for (var ie = je.stack.split(`
`), Se = ne.stack.split(`
`), de = ie.length - 1, he = Se.length - 1; de >= 1 && he >= 0 && ie[de] !== Se[he]; )
            he--;
          for (; de >= 1 && he >= 0; de--, he--)
            if (ie[de] !== Se[he]) {
              if (de !== 1 || he !== 1)
                do
                  if (de--, he--, he < 0 || ie[de] !== Se[he]) {
                    var Ve = `
` + ie[de].replace(" at new ", " at ");
                    return b.displayName && Ve.includes("<anonymous>") && (Ve = Ve.replace("<anonymous>", b.displayName)), typeof b == "function" && A.set(b, Ve), Ve;
                  }
                while (de >= 1 && he >= 0);
              break;
            }
        }
      } finally {
        q = !1, j.current = ce, x(), Error.prepareStackTrace = le;
      }
      var xt = b ? b.displayName || b.name : "", vt = xt ? T(xt) : "";
      return typeof b == "function" && A.set(b, vt), vt;
    }
    function ue(b, I, G) {
      return B(b, !1);
    }
    function fe(b) {
      var I = b.prototype;
      return !!(I && I.isReactComponent);
    }
    function oe(b, I, G) {
      if (b == null)
        return "";
      if (typeof b == "function")
        return B(b, fe(b));
      if (typeof b == "string")
        return T(b);
      switch (b) {
        case u:
          return T("Suspense");
        case c:
          return T("SuspenseList");
      }
      if (typeof b == "object")
        switch (b.$$typeof) {
          case l:
            return ue(b.render);
          case p:
            return oe(b.type, I, G);
          case d: {
            var ne = b, le = ne._payload, ce = ne._init;
            try {
              return oe(ce(le), I, G);
            } catch {
            }
          }
        }
      return "";
    }
    var Ae = Object.prototype.hasOwnProperty, Ze = {}, Ge = E.ReactDebugCurrentFrame;
    function Ie(b) {
      if (b) {
        var I = b._owner, G = oe(b.type, b._source, I ? I.type : null);
        Ge.setExtraStackFrame(G);
      } else
        Ge.setExtraStackFrame(null);
    }
    function et(b, I, G, ne, le) {
      {
        var ce = Function.call.bind(Ae);
        for (var se in b)
          if (ce(b, se)) {
            var ie = void 0;
            try {
              if (typeof b[se] != "function") {
                var Se = Error((ne || "React class") + ": " + G + " type `" + se + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof b[se] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw Se.name = "Invariant Violation", Se;
              }
              ie = b[se](I, se, ne, G, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (de) {
              ie = de;
            }
            ie && !(ie instanceof Error) && (Ie(le), w("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", ne || "React class", G, se, typeof ie), Ie(null)), ie instanceof Error && !(ie.message in Ze) && (Ze[ie.message] = !0, Ie(le), w("Failed %s type: %s", G, ie.message), Ie(null));
          }
      }
    }
    var Ye = Array.isArray;
    function _e(b) {
      return Ye(b);
    }
    function Qe(b) {
      {
        var I = typeof Symbol == "function" && Symbol.toStringTag, G = I && b[Symbol.toStringTag] || b.constructor.name || "Object";
        return G;
      }
    }
    function at(b) {
      try {
        return Pe(b), !1;
      } catch {
        return !0;
      }
    }
    function Pe(b) {
      return "" + b;
    }
    function Me(b) {
      if (at(b))
        return w("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Qe(b)), Pe(b);
    }
    var Je = E.ReactCurrentOwner, We = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, Re, nt;
    function De(b) {
      if (Ae.call(b, "ref")) {
        var I = Object.getOwnPropertyDescriptor(b, "ref").get;
        if (I && I.isReactWarning)
          return !1;
      }
      return b.ref !== void 0;
    }
    function yt(b) {
      if (Ae.call(b, "key")) {
        var I = Object.getOwnPropertyDescriptor(b, "key").get;
        if (I && I.isReactWarning)
          return !1;
      }
      return b.key !== void 0;
    }
    function ot(b, I) {
      typeof b.ref == "string" && Je.current;
    }
    function st(b, I) {
      {
        var G = function() {
          Re || (Re = !0, w("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", I));
        };
        G.isReactWarning = !0, Object.defineProperty(b, "key", {
          get: G,
          configurable: !0
        });
      }
    }
    function ct(b, I) {
      {
        var G = function() {
          nt || (nt = !0, w("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", I));
        };
        G.isReactWarning = !0, Object.defineProperty(b, "ref", {
          get: G,
          configurable: !0
        });
      }
    }
    var bt = function(b, I, G, ne, le, ce, se) {
      var ie = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: b,
        key: I,
        ref: G,
        props: se,
        // Record the component responsible for creating this element.
        _owner: ce
      };
      return ie._store = {}, Object.defineProperty(ie._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(ie, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ne
      }), Object.defineProperty(ie, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: le
      }), Object.freeze && (Object.freeze(ie.props), Object.freeze(ie)), ie;
    };
    function pt(b, I, G, ne, le) {
      {
        var ce, se = {}, ie = null, Se = null;
        G !== void 0 && (Me(G), ie = "" + G), yt(I) && (Me(I.key), ie = "" + I.key), De(I) && (Se = I.ref, ot(I, le));
        for (ce in I)
          Ae.call(I, ce) && !We.hasOwnProperty(ce) && (se[ce] = I[ce]);
        if (b && b.defaultProps) {
          var de = b.defaultProps;
          for (ce in de)
            se[ce] === void 0 && (se[ce] = de[ce]);
        }
        if (ie || Se) {
          var he = typeof b == "function" ? b.displayName || b.name || "Unknown" : b;
          ie && st(se, he), Se && ct(se, he);
        }
        return bt(b, ie, Se, le, ne, Je.current, se);
      }
    }
    var dt = E.ReactCurrentOwner, tt = E.ReactDebugCurrentFrame;
    function Xe(b) {
      if (b) {
        var I = b._owner, G = oe(b.type, b._source, I ? I.type : null);
        tt.setExtraStackFrame(G);
      } else
        tt.setExtraStackFrame(null);
    }
    var wt;
    wt = !1;
    function Ct(b) {
      return typeof b == "object" && b !== null && b.$$typeof === t;
    }
    function ft() {
      {
        if (dt.current) {
          var b = V(dt.current.type);
          if (b)
            return `

Check the render method of \`` + b + "`.";
        }
        return "";
      }
    }
    function bn(b) {
      return "";
    }
    var ht = {};
    function wn(b) {
      {
        var I = ft();
        if (!I) {
          var G = typeof b == "string" ? b : b.displayName || b.name;
          G && (I = `

Check the top-level render call using <` + G + ">.");
        }
        return I;
      }
    }
    function gt(b, I) {
      {
        if (!b._store || b._store.validated || b.key != null)
          return;
        b._store.validated = !0;
        var G = wn(I);
        if (ht[G])
          return;
        ht[G] = !0;
        var ne = "";
        b && b._owner && b._owner !== dt.current && (ne = " It was passed a child from " + V(b._owner.type) + "."), Xe(b), w('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', G, ne), Xe(null);
      }
    }
    function Mt(b, I) {
      {
        if (typeof b != "object")
          return;
        if (_e(b))
          for (var G = 0; G < b.length; G++) {
            var ne = b[G];
            Ct(ne) && gt(ne, I);
          }
        else if (Ct(b))
          b._store && (b._store.validated = !0);
        else if (b) {
          var le = v(b);
          if (typeof le == "function" && le !== b.entries)
            for (var ce = le.call(b), se; !(se = ce.next()).done; )
              Ct(se.value) && gt(se.value, I);
        }
      }
    }
    function ir(b) {
      {
        var I = b.type;
        if (I == null || typeof I == "string")
          return;
        var G;
        if (typeof I == "function")
          G = I.propTypes;
        else if (typeof I == "object" && (I.$$typeof === l || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        I.$$typeof === p))
          G = I.propTypes;
        else
          return;
        if (G) {
          var ne = V(I);
          et(G, b.props, "prop", ne, b);
        } else if (I.PropTypes !== void 0 && !wt) {
          wt = !0;
          var le = V(I);
          w("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", le || "Unknown");
        }
        typeof I.getDefaultProps == "function" && !I.getDefaultProps.isReactClassApproved && w("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function mt(b) {
      {
        for (var I = Object.keys(b.props), G = 0; G < I.length; G++) {
          var ne = I[G];
          if (ne !== "children" && ne !== "key") {
            Xe(b), w("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", ne), Xe(null);
            break;
          }
        }
        b.ref !== null && (Xe(b), w("Invalid attribute `ref` supplied to `React.Fragment`."), Xe(null));
      }
    }
    var re = {};
    function vo(b, I, G, ne, le, ce) {
      {
        var se = N(b);
        if (!se) {
          var ie = "";
          (b === void 0 || typeof b == "object" && b !== null && Object.keys(b).length === 0) && (ie += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var Se = bn();
          Se ? ie += Se : ie += ft();
          var de;
          b === null ? de = "null" : _e(b) ? de = "array" : b !== void 0 && b.$$typeof === t ? (de = "<" + (V(b.type) || "Unknown") + " />", ie = " Did you accidentally export a JSX literal instead of a component?") : de = typeof b, w("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", de, ie);
        }
        var he = pt(b, I, G, le, ce);
        if (he == null)
          return he;
        if (se) {
          var Ve = I.children;
          if (Ve !== void 0)
            if (ne)
              if (_e(Ve)) {
                for (var xt = 0; xt < Ve.length; xt++)
                  Mt(Ve[xt], b);
                Object.freeze && Object.freeze(Ve);
              } else
                w("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Mt(Ve, b);
        }
        if (Ae.call(I, "key")) {
          var vt = V(b), je = Object.keys(I).filter(function(Li) {
            return Li !== "key";
          }), sr = je.length > 0 ? "{key: someKey, " + je.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!re[vt + sr]) {
            var ki = je.length > 0 ? "{" + je.join(": ..., ") + ": ...}" : "{}";
            w(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, sr, vt, ki, vt), re[vt + sr] = !0;
          }
        }
        return b === r ? mt(he) : ir(he), he;
      }
    }
    function Ci(b, I, G) {
      return vo(b, I, G, !0);
    }
    function xi(b, I, G) {
      return vo(b, I, G, !1);
    }
    var Oi = xi, Ei = Ci;
    $c.Fragment = r, $c.jsx = Oi, $c.jsxs = Ei;
  }()), $c;
}
process.env.NODE_ENV === "production" ? qO.exports = fQ() : qO.exports = hQ();
var Q = qO.exports;
function gQ(e) {
  const { className: t, ...n } = e, r = `arkynAlertTitle ${t}`;
  return /* @__PURE__ */ Q.jsx("div", { className: r.trim(), ...n });
}
const H6 = Ke({});
function mQ() {
  return ge(H6);
}
function p4e(e) {
  const { schema: t, children: n, className: r, ...o } = e, s = !((u) => {
    let c = !1;
    const p = (d) => {
      Array.isArray(d) ? d.forEach(p) : d && typeof d == "object" && "type" in d && (d.type === gQ ? c = !0 : d.props && d.props.children && p(d.props.children));
    };
    return p(u), c;
  })(n) ? "nonExistsAlertTitle" : "existsAlertTitle", l = `arkynAlertContainer ${t} ${s} ${r}`;
  return /* @__PURE__ */ Q.jsx(H6.Provider, { value: e, children: /* @__PURE__ */ Q.jsx("div", { className: l.trim(), ...o, children: n }) });
}
function d4e(e) {
  const { className: t, ...n } = e, r = `arkynAlertContent ${t}`;
  return /* @__PURE__ */ Q.jsx("div", { className: r.trim(), ...n });
}
function f4e(e) {
  const { className: t, ...n } = e, r = `arkynAlertDescription ${t}`;
  return /* @__PURE__ */ Q.jsx("div", { className: r.trim(), ...n });
}
function h4e(e) {
  const { className: t, ...n } = e, { schema: r } = mQ(), o = `arkynAlertIcon ${r} ${t}`;
  switch (r) {
    case "success":
      return /* @__PURE__ */ Q.jsx(B6, { className: o, ...n });
    case "danger":
      return /* @__PURE__ */ Q.jsx(R6, { className: o, ...n });
    case "warning":
      return /* @__PURE__ */ Q.jsx(VJ, { className: o, ...n });
    case "info":
      return /* @__PURE__ */ Q.jsx(I6, { className: o, ...n });
  }
}
function Fm(e, t) {
  return t ? /* @__PURE__ */ Q.jsx(t, { size: e, strokeWidth: 2.5 }) : /* @__PURE__ */ Q.jsx(Q.Fragment, {});
}
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function HS(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function Lo(e) {
  var t, n;
  return HS(e) === !1 ? !1 : (t = e.constructor, t === void 0 ? !0 : (n = t.prototype, !(HS(n) === !1 || n.hasOwnProperty("isPrototypeOf") === !1)));
}
var $6 = Symbol.for("immer-nothing"), $S = Symbol.for("immer-draftable"), zi = Symbol.for("immer-state"), vQ = process.env.NODE_ENV !== "production" ? [
  // All error codes, starting by 0:
  function(e) {
    return `The plugin for '${e}' has not been loaded into Immer. To enable the plugin, import and call \`enable${e}()\` when initializing your application.`;
  },
  function(e) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${e}'`;
  },
  "This object has been frozen and should not be mutated",
  function(e) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + e;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(e) {
    return `'current' expects a draft, got: ${e}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(e) {
    return `'original' expects a draft, got: ${e}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function oi(e, ...t) {
  if (process.env.NODE_ENV !== "production") {
    const n = vQ[e], r = typeof n == "function" ? n.apply(null, t) : n;
    throw new Error(`[Immer] ${r}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var dc = Object.getPrototypeOf;
function Ou(e) {
  return !!e && !!e[zi];
}
function Eu(e) {
  var t;
  return e ? W6(e) || Array.isArray(e) || !!e[$S] || !!((t = e.constructor) != null && t[$S]) || Ky(e) || Yy(e) : !1;
}
var yQ = Object.prototype.constructor.toString();
function W6(e) {
  if (!e || typeof e != "object")
    return !1;
  const t = dc(e);
  if (t === null)
    return !0;
  const n = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
  return n === Object ? !0 : typeof n == "function" && Function.toString.call(n) === yQ;
}
function zm(e, t) {
  Gy(e) === 0 ? Reflect.ownKeys(e).forEach((n) => {
    t(n, e[n], e);
  }) : e.forEach((n, r) => t(r, n, e));
}
function Gy(e) {
  const t = e[zi];
  return t ? t.type_ : Array.isArray(e) ? 1 : Ky(e) ? 2 : Yy(e) ? 3 : 0;
}
function GO(e, t) {
  return Gy(e) === 2 ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t);
}
function V6(e, t, n) {
  const r = Gy(e);
  r === 2 ? e.set(t, n) : r === 3 ? e.add(n) : e[t] = n;
}
function bQ(e, t) {
  return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && t !== t;
}
function Ky(e) {
  return e instanceof Map;
}
function Yy(e) {
  return e instanceof Set;
}
function Kl(e) {
  return e.copy_ || e.base_;
}
function KO(e, t) {
  if (Ky(e))
    return new Map(e);
  if (Yy(e))
    return new Set(e);
  if (Array.isArray(e))
    return Array.prototype.slice.call(e);
  const n = W6(e);
  if (t === !0 || t === "class_only" && !n) {
    const r = Object.getOwnPropertyDescriptors(e);
    delete r[zi];
    let o = Reflect.ownKeys(r);
    for (let i = 0; i < o.length; i++) {
      const a = o[i], s = r[a];
      s.writable === !1 && (s.writable = !0, s.configurable = !0), (s.get || s.set) && (r[a] = {
        configurable: !0,
        writable: !0,
        // could live with !!desc.set as well here...
        enumerable: s.enumerable,
        value: e[a]
      });
    }
    return Object.create(dc(e), r);
  } else {
    const r = dc(e);
    if (r !== null && n)
      return { ...e };
    const o = Object.create(r);
    return Object.assign(o, e);
  }
}
function _1(e, t = !1) {
  return Xy(e) || Ou(e) || !Eu(e) || (Gy(e) > 1 && (e.set = e.add = e.clear = e.delete = wQ), Object.freeze(e), t && Object.entries(e).forEach(([n, r]) => _1(r, !0))), e;
}
function wQ() {
  oi(2);
}
function Xy(e) {
  return Object.isFrozen(e);
}
var CQ = {};
function ku(e) {
  const t = CQ[e];
  return t || oi(0, e), t;
}
var yd;
function Z6() {
  return yd;
}
function xQ(e, t) {
  return {
    drafts_: [],
    parent_: e,
    immer_: t,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0
  };
}
function WS(e, t) {
  t && (ku("Patches"), e.patches_ = [], e.inversePatches_ = [], e.patchListener_ = t);
}
function YO(e) {
  XO(e), e.drafts_.forEach(OQ), e.drafts_ = null;
}
function XO(e) {
  e === yd && (yd = e.parent_);
}
function VS(e) {
  return yd = xQ(yd, e);
}
function OQ(e) {
  const t = e[zi];
  t.type_ === 0 || t.type_ === 1 ? t.revoke_() : t.revoked_ = !0;
}
function ZS(e, t) {
  t.unfinalizedDrafts_ = t.drafts_.length;
  const n = t.drafts_[0];
  return e !== void 0 && e !== n ? (n[zi].modified_ && (YO(t), oi(4)), Eu(e) && (e = Um(t, e), t.parent_ || Hm(t, e)), t.patches_ && ku("Patches").generateReplacementPatches_(
    n[zi].base_,
    e,
    t.patches_,
    t.inversePatches_
  )) : e = Um(t, n, []), YO(t), t.patches_ && t.patchListener_(t.patches_, t.inversePatches_), e !== $6 ? e : void 0;
}
function Um(e, t, n) {
  if (Xy(t))
    return t;
  const r = t[zi];
  if (!r)
    return zm(
      t,
      (o, i) => qS(e, r, t, o, i, n)
    ), t;
  if (r.scope_ !== e)
    return t;
  if (!r.modified_)
    return Hm(e, r.base_, !0), r.base_;
  if (!r.finalized_) {
    r.finalized_ = !0, r.scope_.unfinalizedDrafts_--;
    const o = r.copy_;
    let i = o, a = !1;
    r.type_ === 3 && (i = new Set(o), o.clear(), a = !0), zm(
      i,
      (s, l) => qS(e, r, o, s, l, n, a)
    ), Hm(e, o, !1), n && e.patches_ && ku("Patches").generatePatches_(
      r,
      n,
      e.patches_,
      e.inversePatches_
    );
  }
  return r.copy_;
}
function qS(e, t, n, r, o, i, a) {
  if (process.env.NODE_ENV !== "production" && o === n && oi(5), Ou(o)) {
    const s = i && t && t.type_ !== 3 && // Set objects are atomic since they have no keys.
    !GO(t.assigned_, r) ? i.concat(r) : void 0, l = Um(e, o, s);
    if (V6(n, r, l), Ou(l))
      e.canAutoFreeze_ = !1;
    else
      return;
  } else a && n.add(o);
  if (Eu(o) && !Xy(o)) {
    if (!e.immer_.autoFreeze_ && e.unfinalizedDrafts_ < 1)
      return;
    Um(e, o), (!t || !t.scope_.parent_) && typeof r != "symbol" && Object.prototype.propertyIsEnumerable.call(n, r) && Hm(e, o);
  }
}
function Hm(e, t, n = !1) {
  !e.parent_ && e.immer_.autoFreeze_ && e.canAutoFreeze_ && _1(t, n);
}
function EQ(e, t) {
  const n = Array.isArray(e), r = {
    type_: n ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: t ? t.scope_ : Z6(),
    // True for both shallow and deep changes.
    modified_: !1,
    // Used during finalization.
    finalized_: !1,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: t,
    // The base state.
    base_: e,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: !1
  };
  let o = r, i = S1;
  n && (o = [r], i = bd);
  const { revoke: a, proxy: s } = Proxy.revocable(o, i);
  return r.draft_ = s, r.revoke_ = a, s;
}
var S1 = {
  get(e, t) {
    if (t === zi)
      return e;
    const n = Kl(e);
    if (!GO(n, t))
      return kQ(e, n, t);
    const r = n[t];
    return e.finalized_ || !Eu(r) ? r : r === S0(e.base_, t) ? (M0(e), e.copy_[t] = QO(r, e)) : r;
  },
  has(e, t) {
    return t in Kl(e);
  },
  ownKeys(e) {
    return Reflect.ownKeys(Kl(e));
  },
  set(e, t, n) {
    const r = q6(Kl(e), t);
    if (r != null && r.set)
      return r.set.call(e.draft_, n), !0;
    if (!e.modified_) {
      const o = S0(Kl(e), t), i = o == null ? void 0 : o[zi];
      if (i && i.base_ === n)
        return e.copy_[t] = n, e.assigned_[t] = !1, !0;
      if (bQ(n, o) && (n !== void 0 || GO(e.base_, t)))
        return !0;
      M0(e), JO(e);
    }
    return e.copy_[t] === n && // special case: handle new props with value 'undefined'
    (n !== void 0 || t in e.copy_) || // special case: NaN
    Number.isNaN(n) && Number.isNaN(e.copy_[t]) || (e.copy_[t] = n, e.assigned_[t] = !0), !0;
  },
  deleteProperty(e, t) {
    return S0(e.base_, t) !== void 0 || t in e.base_ ? (e.assigned_[t] = !1, M0(e), JO(e)) : delete e.assigned_[t], e.copy_ && delete e.copy_[t], !0;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(e, t) {
    const n = Kl(e), r = Reflect.getOwnPropertyDescriptor(n, t);
    return r && {
      writable: !0,
      configurable: e.type_ !== 1 || t !== "length",
      enumerable: r.enumerable,
      value: n[t]
    };
  },
  defineProperty() {
    oi(11);
  },
  getPrototypeOf(e) {
    return dc(e.base_);
  },
  setPrototypeOf() {
    oi(12);
  }
}, bd = {};
zm(S1, (e, t) => {
  bd[e] = function() {
    return arguments[0] = arguments[0][0], t.apply(this, arguments);
  };
});
bd.deleteProperty = function(e, t) {
  return process.env.NODE_ENV !== "production" && isNaN(parseInt(t)) && oi(13), bd.set.call(this, e, t, void 0);
};
bd.set = function(e, t, n) {
  return process.env.NODE_ENV !== "production" && t !== "length" && isNaN(parseInt(t)) && oi(14), S1.set.call(this, e[0], t, n, e[0]);
};
function S0(e, t) {
  const n = e[zi];
  return (n ? Kl(n) : e)[t];
}
function kQ(e, t, n) {
  var o;
  const r = q6(t, n);
  return r ? "value" in r ? r.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (o = r.get) == null ? void 0 : o.call(e.draft_)
  ) : void 0;
}
function q6(e, t) {
  if (!(t in e))
    return;
  let n = dc(e);
  for (; n; ) {
    const r = Object.getOwnPropertyDescriptor(n, t);
    if (r)
      return r;
    n = dc(n);
  }
}
function JO(e) {
  e.modified_ || (e.modified_ = !0, e.parent_ && JO(e.parent_));
}
function M0(e) {
  e.copy_ || (e.copy_ = KO(
    e.base_,
    e.scope_.immer_.useStrictShallowCopy_
  ));
}
var LQ = class {
  constructor(e) {
    this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.produce = (t, n, r) => {
      if (typeof t == "function" && typeof n != "function") {
        const i = n;
        n = t;
        const a = this;
        return function(l = i, ...u) {
          return a.produce(l, (c) => n.call(this, c, ...u));
        };
      }
      typeof n != "function" && oi(6), r !== void 0 && typeof r != "function" && oi(7);
      let o;
      if (Eu(t)) {
        const i = VS(this), a = QO(t, void 0);
        let s = !0;
        try {
          o = n(a), s = !1;
        } finally {
          s ? YO(i) : XO(i);
        }
        return WS(i, r), ZS(o, i);
      } else if (!t || typeof t != "object") {
        if (o = n(t), o === void 0 && (o = t), o === $6 && (o = void 0), this.autoFreeze_ && _1(o, !0), r) {
          const i = [], a = [];
          ku("Patches").generateReplacementPatches_(t, o, i, a), r(i, a);
        }
        return o;
      } else
        oi(1, t);
    }, this.produceWithPatches = (t, n) => {
      if (typeof t == "function")
        return (a, ...s) => this.produceWithPatches(a, (l) => t(l, ...s));
      let r, o;
      return [this.produce(t, n, (a, s) => {
        r = a, o = s;
      }), r, o];
    }, typeof (e == null ? void 0 : e.autoFreeze) == "boolean" && this.setAutoFreeze(e.autoFreeze), typeof (e == null ? void 0 : e.useStrictShallowCopy) == "boolean" && this.setUseStrictShallowCopy(e.useStrictShallowCopy);
  }
  createDraft(e) {
    Eu(e) || oi(8), Ou(e) && (e = PQ(e));
    const t = VS(this), n = QO(e, void 0);
    return n[zi].isManual_ = !0, XO(t), n;
  }
  finishDraft(e, t) {
    const n = e && e[zi];
    (!n || !n.isManual_) && oi(9);
    const { scope_: r } = n;
    return WS(r, t), ZS(void 0, r);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(e) {
    this.autoFreeze_ = e;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(e) {
    this.useStrictShallowCopy_ = e;
  }
  applyPatches(e, t) {
    let n;
    for (n = t.length - 1; n >= 0; n--) {
      const o = t[n];
      if (o.path.length === 0 && o.op === "replace") {
        e = o.value;
        break;
      }
    }
    n > -1 && (t = t.slice(n + 1));
    const r = ku("Patches").applyPatches_;
    return Ou(e) ? r(e, t) : this.produce(
      e,
      (o) => r(o, t)
    );
  }
};
function QO(e, t) {
  const n = Ky(e) ? ku("MapSet").proxyMap_(e, t) : Yy(e) ? ku("MapSet").proxySet_(e, t) : EQ(e, t);
  return (t ? t.scope_ : Z6()).drafts_.push(n), n;
}
function PQ(e) {
  return Ou(e) || oi(10, e), G6(e);
}
function G6(e) {
  if (!Eu(e) || Xy(e))
    return e;
  const t = e[zi];
  let n;
  if (t) {
    if (!t.modified_)
      return t.base_;
    t.finalized_ = !0, n = KO(e, t.scope_.immer_.useStrictShallowCopy_);
  } else
    n = KO(e, !0);
  return zm(n, (r, o) => {
    V6(n, r, G6(o));
  }), t && (t.finalized_ = !1), n;
}
var Ui = new LQ(), M1 = Ui.produce;
Ui.produceWithPatches.bind(
  Ui
);
Ui.setAutoFreeze.bind(Ui);
Ui.setUseStrictShallowCopy.bind(Ui);
Ui.applyPatches.bind(Ui);
var GS = Ui.createDraft.bind(Ui), KS = Ui.finishDraft.bind(Ui), _Q = {
  transform(e, t) {
    var {
      current: n,
      affinity: r
    } = e;
    if (n != null) {
      var o = ae.transform(n, t, {
        affinity: r
      });
      e.current = o, o == null && e.unref();
    }
  }
}, SQ = {
  transform(e, t) {
    var {
      current: n,
      affinity: r
    } = e;
    if (n != null) {
      var o = Nt.transform(n, t, {
        affinity: r
      });
      e.current = o, o == null && e.unref();
    }
  }
}, MQ = {
  transform(e, t) {
    var {
      current: n,
      affinity: r
    } = e;
    if (n != null) {
      var o = me.transform(n, t, {
        affinity: r
      });
      e.current = o, o == null && e.unref();
    }
  }
}, $m = /* @__PURE__ */ new WeakMap(), Wm = /* @__PURE__ */ new WeakMap(), Fp = /* @__PURE__ */ new WeakMap(), K6 = /* @__PURE__ */ new WeakMap(), YS = /* @__PURE__ */ new WeakMap(), XS = /* @__PURE__ */ new WeakMap(), JS = /* @__PURE__ */ new WeakMap(), ae = {
  ancestors(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = ae.levels(e, t);
    return n ? r = r.slice(1) : r = r.slice(0, -1), r;
  },
  common(e, t) {
    for (var n = [], r = 0; r < e.length && r < t.length; r++) {
      var o = e[r], i = t[r];
      if (o !== i)
        break;
      n.push(o);
    }
    return n;
  },
  compare(e, t) {
    for (var n = Math.min(e.length, t.length), r = 0; r < n; r++) {
      if (e[r] < t[r]) return -1;
      if (e[r] > t[r]) return 1;
    }
    return 0;
  },
  endsAfter(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return ae.equals(r, o) && i > a;
  },
  endsAt(e, t) {
    var n = e.length, r = e.slice(0, n), o = t.slice(0, n);
    return ae.equals(r, o);
  },
  endsBefore(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return ae.equals(r, o) && i < a;
  },
  equals(e, t) {
    return e.length === t.length && e.every((n, r) => n === t[r]);
  },
  hasPrevious(e) {
    return e[e.length - 1] > 0;
  },
  isAfter(e, t) {
    return ae.compare(e, t) === 1;
  },
  isAncestor(e, t) {
    return e.length < t.length && ae.compare(e, t) === 0;
  },
  isBefore(e, t) {
    return ae.compare(e, t) === -1;
  },
  isChild(e, t) {
    return e.length === t.length + 1 && ae.compare(e, t) === 0;
  },
  isCommon(e, t) {
    return e.length <= t.length && ae.compare(e, t) === 0;
  },
  isDescendant(e, t) {
    return e.length > t.length && ae.compare(e, t) === 0;
  },
  isParent(e, t) {
    return e.length + 1 === t.length && ae.compare(e, t) === 0;
  },
  isPath(e) {
    return Array.isArray(e) && (e.length === 0 || typeof e[0] == "number");
  },
  isSibling(e, t) {
    if (e.length !== t.length)
      return !1;
    var n = e.slice(0, -1), r = t.slice(0, -1), o = e[e.length - 1], i = t[t.length - 1];
    return o !== i && ae.equals(n, r);
  },
  levels(e) {
    for (var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = [], o = 0; o <= e.length; o++)
      r.push(e.slice(0, o));
    return n && r.reverse(), r;
  },
  next(e) {
    if (e.length === 0)
      throw new Error("Cannot get the next path of a root path [".concat(e, "], because it has no next index."));
    var t = e[e.length - 1];
    return e.slice(0, -1).concat(t + 1);
  },
  operationCanTransformPath(e) {
    switch (e.type) {
      case "insert_node":
      case "remove_node":
      case "merge_node":
      case "split_node":
      case "move_node":
        return !0;
      default:
        return !1;
    }
  },
  parent(e) {
    if (e.length === 0)
      throw new Error("Cannot get the parent path of the root path [".concat(e, "]."));
    return e.slice(0, -1);
  },
  previous(e) {
    if (e.length === 0)
      throw new Error("Cannot get the previous path of a root path [".concat(e, "], because it has no previous index."));
    var t = e[e.length - 1];
    if (t <= 0)
      throw new Error("Cannot get the previous path of a first child path [".concat(e, "] because it would result in a negative index."));
    return e.slice(0, -1).concat(t - 1);
  },
  relative(e, t) {
    if (!ae.isAncestor(t, e) && !ae.equals(e, t))
      throw new Error("Cannot get the relative path of [".concat(e, "] inside ancestor [").concat(t, "], because it is not above or equal to the path."));
    return e.slice(t.length);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!e) return null;
    var r = [...e], {
      affinity: o = "forward"
    } = n;
    if (e.length === 0)
      return r;
    switch (t.type) {
      case "insert_node": {
        var {
          path: i
        } = t;
        (ae.equals(i, r) || ae.endsBefore(i, r) || ae.isAncestor(i, r)) && (r[i.length - 1] += 1);
        break;
      }
      case "remove_node": {
        var {
          path: a
        } = t;
        if (ae.equals(a, r) || ae.isAncestor(a, r))
          return null;
        ae.endsBefore(a, r) && (r[a.length - 1] -= 1);
        break;
      }
      case "merge_node": {
        var {
          path: s,
          position: l
        } = t;
        ae.equals(s, r) || ae.endsBefore(s, r) ? r[s.length - 1] -= 1 : ae.isAncestor(s, r) && (r[s.length - 1] -= 1, r[s.length] += l);
        break;
      }
      case "split_node": {
        var {
          path: u,
          position: c
        } = t;
        if (ae.equals(u, r)) {
          if (o === "forward")
            r[r.length - 1] += 1;
          else if (o !== "backward") return null;
        } else ae.endsBefore(u, r) ? r[u.length - 1] += 1 : ae.isAncestor(u, r) && e[u.length] >= c && (r[u.length - 1] += 1, r[u.length] -= c);
        break;
      }
      case "move_node": {
        var {
          path: p,
          newPath: d
        } = t;
        if (ae.equals(p, d))
          return r;
        if (ae.isAncestor(p, r) || ae.equals(p, r)) {
          var g = d.slice();
          return ae.endsBefore(p, d) && p.length < d.length && (g[p.length - 1] -= 1), g.concat(r.slice(p.length));
        } else ae.isSibling(p, d) && (ae.isAncestor(d, r) || ae.equals(d, r)) ? ae.endsBefore(p, r) ? r[p.length - 1] -= 1 : r[p.length - 1] += 1 : ae.endsBefore(d, r) || ae.equals(d, r) || ae.isAncestor(d, r) ? (ae.endsBefore(p, r) && (r[p.length - 1] -= 1), r[d.length - 1] += 1) : ae.endsBefore(p, r) && (ae.equals(d, r) && (r[d.length - 1] += 1), r[p.length - 1] -= 1);
        break;
      }
    }
    return r;
  }
};
function wd(e) {
  "@babel/helpers - typeof";
  return wd = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, wd(e);
}
function DQ(e, t) {
  if (wd(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (wd(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function TQ(e) {
  var t = DQ(e, "string");
  return wd(t) === "symbol" ? t : String(t);
}
function Go(e, t, n) {
  return t = TQ(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function QS(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Wc(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? QS(Object(n), !0).forEach(function(r) {
      Go(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : QS(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var jQ = (e, t, n) => {
  switch (n.type) {
    case "insert_node": {
      var {
        path: r,
        node: o
      } = n, i = qe.parent(e, r), a = r[r.length - 1];
      if (a > i.children.length)
        throw new Error('Cannot apply an "insert_node" operation at path ['.concat(r, "] because the destination is past the end of the node."));
      if (i.children.splice(a, 0, o), t)
        for (var [s, l] of me.points(t))
          t[l] = Nt.transform(s, n);
      break;
    }
    case "insert_text": {
      var {
        path: u,
        offset: c,
        text: p
      } = n;
      if (p.length === 0) break;
      var d = qe.leaf(e, u), g = d.text.slice(0, c), f = d.text.slice(c);
      if (d.text = g + p + f, t)
        for (var [m, v] of me.points(t))
          t[v] = Nt.transform(m, n);
      break;
    }
    case "merge_node": {
      var {
        path: E
      } = n, w = qe.get(e, E), M = ae.previous(E), O = qe.get(e, M), y = qe.parent(e, E), C = E[E.length - 1];
      if (it.isText(w) && it.isText(O))
        O.text += w.text;
      else if (!it.isText(w) && !it.isText(O))
        O.children.push(...w.children);
      else
        throw new Error('Cannot apply a "merge_node" operation at path ['.concat(E, "] to nodes of different interfaces: ").concat(ko.stringify(w), " ").concat(ko.stringify(O)));
      if (y.children.splice(C, 1), t)
        for (var [_, F] of me.points(t))
          t[F] = Nt.transform(_, n);
      break;
    }
    case "move_node": {
      var {
        path: L,
        newPath: N
      } = n;
      if (ae.isAncestor(L, N))
        throw new Error("Cannot move a path [".concat(L, "] to new path [").concat(N, "] because the destination is inside itself."));
      var R = qe.get(e, L), W = qe.parent(e, L), V = L[L.length - 1];
      W.children.splice(V, 1);
      var z = ae.transform(L, n), Z = qe.get(e, ae.parent(z)), K = z[z.length - 1];
      if (Z.children.splice(K, 0, R), t)
        for (var [X, te] of me.points(t))
          t[te] = Nt.transform(X, n);
      break;
    }
    case "remove_node": {
      var {
        path: J
      } = n, P = J[J.length - 1], D = qe.parent(e, J);
      if (D.children.splice(P, 1), t)
        for (var [H, S] of me.points(t)) {
          var $ = Nt.transform(H, n);
          if (t != null && $ != null)
            t[S] = $;
          else {
            var x = void 0, j = void 0;
            for (var [U, T] of qe.texts(e))
              if (ae.compare(T, J) === -1)
                x = [U, T];
              else {
                j = [U, T];
                break;
              }
            var q = !1;
            x && j && (ae.equals(j[1], J) ? q = !ae.hasPrevious(j[1]) : q = ae.common(x[1], J).length < ae.common(j[1], J).length), x && !q ? (H.path = x[1], H.offset = x[0].text.length) : j ? (H.path = j[1], H.offset = 0) : t = null;
          }
        }
      break;
    }
    case "remove_text": {
      var {
        path: A,
        offset: Y,
        text: B
      } = n;
      if (B.length === 0) break;
      var ue = qe.leaf(e, A), fe = ue.text.slice(0, Y), oe = ue.text.slice(Y + B.length);
      if (ue.text = fe + oe, t)
        for (var [Ae, Ze] of me.points(t))
          t[Ze] = Nt.transform(Ae, n);
      break;
    }
    case "set_node": {
      var {
        path: Ge,
        properties: Ie,
        newProperties: et
      } = n;
      if (Ge.length === 0)
        throw new Error("Cannot set properties on the root node!");
      var Ye = qe.get(e, Ge);
      for (var _e in et) {
        if (_e === "children" || _e === "text")
          throw new Error('Cannot set the "'.concat(_e, '" property of nodes!'));
        var Qe = et[_e];
        Qe == null ? delete Ye[_e] : Ye[_e] = Qe;
      }
      for (var at in Ie)
        et.hasOwnProperty(at) || delete Ye[at];
      break;
    }
    case "set_selection": {
      var {
        newProperties: Pe
      } = n;
      if (Pe == null)
        t = Pe;
      else {
        if (t == null) {
          if (!me.isRange(Pe))
            throw new Error('Cannot apply an incomplete "set_selection" operation properties '.concat(ko.stringify(Pe), " when there is no current selection."));
          t = Wc({}, Pe);
        }
        for (var Me in Pe) {
          var Je = Pe[Me];
          if (Je == null) {
            if (Me === "anchor" || Me === "focus")
              throw new Error('Cannot remove the "'.concat(Me, '" selection property'));
            delete t[Me];
          } else
            t[Me] = Je;
        }
      }
      break;
    }
    case "split_node": {
      var {
        path: We,
        position: Re,
        properties: nt
      } = n;
      if (We.length === 0)
        throw new Error('Cannot apply a "split_node" operation at path ['.concat(We, "] because the root node cannot be split."));
      var De = qe.get(e, We), yt = qe.parent(e, We), ot = We[We.length - 1], st;
      if (it.isText(De)) {
        var ct = De.text.slice(0, Re), bt = De.text.slice(Re);
        De.text = ct, st = Wc(Wc({}, nt), {}, {
          text: bt
        });
      } else {
        var pt = De.children.slice(0, Re), dt = De.children.slice(Re);
        De.children = pt, st = Wc(Wc({}, nt), {}, {
          children: dt
        });
      }
      if (yt.children.splice(ot + 1, 0, st), t)
        for (var [tt, Xe] of me.points(t))
          t[Xe] = Nt.transform(tt, n);
      break;
    }
  }
  return t;
}, AQ = {
  transform(e, t) {
    e.children = GS(e.children);
    var n = e.selection && GS(e.selection);
    try {
      n = jQ(e, n, t);
    } finally {
      e.children = KS(e.children), n ? e.selection = Ou(n) ? KS(n) : n : e.selection = null;
    }
  }
}, IQ = {
  insertNodes(e, t, n) {
    e.insertNodes(t, n);
  },
  liftNodes(e, t) {
    e.liftNodes(t);
  },
  mergeNodes(e, t) {
    e.mergeNodes(t);
  },
  moveNodes(e, t) {
    e.moveNodes(t);
  },
  removeNodes(e, t) {
    e.removeNodes(t);
  },
  setNodes(e, t, n) {
    e.setNodes(t, n);
  },
  splitNodes(e, t) {
    e.splitNodes(t);
  },
  unsetNodes(e, t, n) {
    e.unsetNodes(t, n);
  },
  unwrapNodes(e, t) {
    e.unwrapNodes(t);
  },
  wrapNodes(e, t, n) {
    e.wrapNodes(t, n);
  }
}, RQ = {
  collapse(e, t) {
    e.collapse(t);
  },
  deselect(e) {
    e.deselect();
  },
  move(e, t) {
    e.move(t);
  },
  select(e, t) {
    e.select(t);
  },
  setPoint(e, t, n) {
    e.setPoint(t, n);
  },
  setSelection(e, t) {
    e.setSelection(t);
  }
}, Y6 = (e, t) => {
  for (var n in e) {
    var r = e[n], o = t[n];
    if (Lo(r) && Lo(o)) {
      if (!Y6(r, o)) return !1;
    } else if (Array.isArray(r) && Array.isArray(o)) {
      if (r.length !== o.length) return !1;
      for (var i = 0; i < r.length; i++)
        if (r[i] !== o[i]) return !1;
    } else if (r !== o)
      return !1;
  }
  for (var a in t)
    if (e[a] === void 0 && t[a] !== void 0)
      return !1;
  return !0;
};
function BQ(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), o, i;
  for (i = 0; i < r.length; i++)
    o = r[i], !(t.indexOf(o) >= 0) && (n[o] = e[o]);
  return n;
}
function aa(e, t) {
  if (e == null) return {};
  var n = BQ(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (o = 0; o < i.length; o++)
      r = i[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
var NQ = ["anchor", "focus"];
function eM(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function FQ(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? eM(Object(n), !0).forEach(function(r) {
      Go(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : eM(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var me = {
  edges(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, {
      anchor: r,
      focus: o
    } = e;
    return me.isBackward(e) === n ? [r, o] : [o, r];
  },
  end(e) {
    var [, t] = me.edges(e);
    return t;
  },
  equals(e, t) {
    return Nt.equals(e.anchor, t.anchor) && Nt.equals(e.focus, t.focus);
  },
  includes(e, t) {
    if (me.isRange(t)) {
      if (me.includes(e, t.anchor) || me.includes(e, t.focus))
        return !0;
      var [n, r] = me.edges(e), [o, i] = me.edges(t);
      return Nt.isBefore(n, o) && Nt.isAfter(r, i);
    }
    var [a, s] = me.edges(e), l = !1, u = !1;
    return Nt.isPoint(t) ? (l = Nt.compare(t, a) >= 0, u = Nt.compare(t, s) <= 0) : (l = ae.compare(t, a.path) >= 0, u = ae.compare(t, s.path) <= 0), l && u;
  },
  intersection(e, t) {
    var n = aa(e, NQ), [r, o] = me.edges(e), [i, a] = me.edges(t), s = Nt.isBefore(r, i) ? i : r, l = Nt.isBefore(o, a) ? o : a;
    return Nt.isBefore(l, s) ? null : FQ({
      anchor: s,
      focus: l
    }, n);
  },
  isBackward(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return Nt.isAfter(t, n);
  },
  isCollapsed(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return Nt.equals(t, n);
  },
  isExpanded(e) {
    return !me.isCollapsed(e);
  },
  isForward(e) {
    return !me.isBackward(e);
  },
  isRange(e) {
    return Lo(e) && Nt.isPoint(e.anchor) && Nt.isPoint(e.focus);
  },
  *points(e) {
    yield [e.anchor, "anchor"], yield [e.focus, "focus"];
  },
  start(e) {
    var [t] = me.edges(e);
    return t;
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return M1(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "inward"
      } = n, i, a;
      if (o === "inward") {
        var s = me.isCollapsed(r);
        me.isForward(r) ? (i = "forward", a = s ? i : "backward") : (i = "backward", a = s ? i : "forward");
      } else o === "outward" ? me.isForward(r) ? (i = "backward", a = "forward") : (i = "forward", a = "backward") : (i = o, a = o);
      var l = Nt.transform(r.anchor, t, {
        affinity: i
      }), u = Nt.transform(r.focus, t, {
        affinity: a
      });
      if (!l || !u)
        return null;
      r.anchor = l, r.focus = u;
    });
  }
}, tM = (e) => Lo(e) && qe.isNodeList(e.children) && !ee.isEditor(e), rt = {
  isAncestor(e) {
    return Lo(e) && qe.isNodeList(e.children);
  },
  isElement: tM,
  isElementList(e) {
    return Array.isArray(e) && e.every((t) => rt.isElement(t));
  },
  isElementProps(e) {
    return e.children !== void 0;
  },
  isElementType: function(t, n) {
    var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "type";
    return tM(t) && t[r] === n;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "children" && e[n] !== t[n])
        return !1;
    return !0;
  }
}, zQ = ["children"], UQ = ["text"], nM = /* @__PURE__ */ new WeakMap(), qe = {
  ancestor(e, t) {
    var n = qe.get(e, t);
    if (it.isText(n))
      throw new Error("Cannot get the ancestor node at path [".concat(t, "] because it refers to a text node instead: ").concat(ko.stringify(n)));
    return n;
  },
  ancestors(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of ae.ancestors(t, n)) {
        var o = qe.ancestor(e, r), i = [o, r];
        yield i;
      }
    }();
  },
  child(e, t) {
    if (it.isText(e))
      throw new Error("Cannot get the child of a text node: ".concat(ko.stringify(e)));
    var n = e.children[t];
    if (n == null)
      throw new Error("Cannot get child at index `".concat(t, "` in node: ").concat(ko.stringify(e)));
    return n;
  },
  children(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var {
        reverse: r = !1
      } = n, o = qe.ancestor(e, t), {
        children: i
      } = o, a = r ? i.length - 1 : 0; r ? a >= 0 : a < i.length; ) {
        var s = qe.child(o, a), l = t.concat(a);
        yield [s, l], a = r ? a - 1 : a + 1;
      }
    }();
  },
  common(e, t, n) {
    var r = ae.common(t, n), o = qe.get(e, r);
    return [o, r];
  },
  descendant(e, t) {
    var n = qe.get(e, t);
    if (ee.isEditor(n))
      throw new Error("Cannot get the descendant node at path [".concat(t, "] because it refers to the root editor node instead: ").concat(ko.stringify(n)));
    return n;
  },
  descendants(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of qe.nodes(e, t))
        r.length !== 0 && (yield [n, r]);
    }();
  },
  elements(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of qe.nodes(e, t))
        rt.isElement(n) && (yield [n, r]);
    }();
  },
  extractProps(e) {
    if (rt.isAncestor(e)) {
      var t = aa(e, zQ);
      return t;
    } else {
      var t = aa(e, UQ);
      return t;
    }
  },
  first(e, t) {
    for (var n = t.slice(), r = qe.get(e, n); r && !(it.isText(r) || r.children.length === 0); )
      r = r.children[0], n.push(0);
    return [r, n];
  },
  fragment(e, t) {
    if (it.isText(e))
      throw new Error("Cannot get a fragment starting from a root text node: ".concat(ko.stringify(e)));
    var n = M1({
      children: e.children
    }, (r) => {
      var [o, i] = me.edges(t), a = qe.nodes(r, {
        reverse: !0,
        pass: (d) => {
          var [, g] = d;
          return !me.includes(t, g);
        }
      });
      for (var [, s] of a) {
        if (!me.includes(t, s)) {
          var l = qe.parent(r, s), u = s[s.length - 1];
          l.children.splice(u, 1);
        }
        if (ae.equals(s, i.path)) {
          var c = qe.leaf(r, s);
          c.text = c.text.slice(0, i.offset);
        }
        if (ae.equals(s, o.path)) {
          var p = qe.leaf(r, s);
          p.text = p.text.slice(o.offset);
        }
      }
      ee.isEditor(r) && (r.selection = null);
    });
    return n.children;
  },
  get(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (it.isText(n) || !n.children[o])
        throw new Error("Cannot find a descendant at path [".concat(t, "] in node: ").concat(ko.stringify(e)));
      n = n.children[o];
    }
    return n;
  },
  has(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (it.isText(n) || !n.children[o])
        return !1;
      n = n.children[o];
    }
    return !0;
  },
  isNode(e) {
    return it.isText(e) || rt.isElement(e) || ee.isEditor(e);
  },
  isNodeList(e) {
    if (!Array.isArray(e))
      return !1;
    var t = nM.get(e);
    if (t !== void 0)
      return t;
    var n = e.every((r) => qe.isNode(r));
    return nM.set(e, n), n;
  },
  last(e, t) {
    for (var n = t.slice(), r = qe.get(e, n); r && !(it.isText(r) || r.children.length === 0); ) {
      var o = r.children.length - 1;
      r = r.children[o], n.push(o);
    }
    return [r, n];
  },
  leaf(e, t) {
    var n = qe.get(e, t);
    if (!it.isText(n))
      throw new Error("Cannot get the leaf node at path [".concat(t, "] because it refers to a non-leaf node: ").concat(ko.stringify(n)));
    return n;
  },
  levels(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of ae.levels(t, n)) {
        var o = qe.get(e, r);
        yield [o, r];
      }
    }();
  },
  matches(e, t) {
    return rt.isElement(e) && rt.isElementProps(t) && rt.matches(e, t) || it.isText(e) && it.isTextProps(t) && it.matches(e, t);
  },
  nodes(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var {
        pass: n,
        reverse: r = !1
      } = t, {
        from: o = [],
        to: i
      } = t, a = /* @__PURE__ */ new Set(), s = [], l = e; !(i && (r ? ae.isBefore(s, i) : ae.isAfter(s, i))); ) {
        if (a.has(l) || (yield [l, s]), !a.has(l) && !it.isText(l) && l.children.length !== 0 && (n == null || n([l, s]) === !1)) {
          a.add(l);
          var u = r ? l.children.length - 1 : 0;
          ae.isAncestor(s, o) && (u = o[s.length]), s = s.concat(u), l = qe.get(e, s);
          continue;
        }
        if (s.length === 0)
          break;
        if (!r) {
          var c = ae.next(s);
          if (qe.has(e, c)) {
            s = c, l = qe.get(e, s);
            continue;
          }
        }
        if (r && s[s.length - 1] !== 0) {
          var p = ae.previous(s);
          s = p, l = qe.get(e, s);
          continue;
        }
        s = ae.parent(s), l = qe.get(e, s), a.add(l);
      }
    }();
  },
  parent(e, t) {
    var n = ae.parent(t), r = qe.get(e, n);
    if (it.isText(r))
      throw new Error("Cannot get the parent of path [".concat(t, "] because it does not exist in the root."));
    return r;
  },
  string(e) {
    return it.isText(e) ? e.text : e.children.map(qe.string).join("");
  },
  texts(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of qe.nodes(e, t))
        it.isText(n) && (yield [n, r]);
    }();
  }
};
function rM(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function br(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? rM(Object(n), !0).forEach(function(r) {
      Go(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : rM(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var sl = {
  isNodeOperation(e) {
    return sl.isOperation(e) && e.type.endsWith("_node");
  },
  isOperation(e) {
    if (!Lo(e))
      return !1;
    switch (e.type) {
      case "insert_node":
        return ae.isPath(e.path) && qe.isNode(e.node);
      case "insert_text":
        return typeof e.offset == "number" && typeof e.text == "string" && ae.isPath(e.path);
      case "merge_node":
        return typeof e.position == "number" && ae.isPath(e.path) && Lo(e.properties);
      case "move_node":
        return ae.isPath(e.path) && ae.isPath(e.newPath);
      case "remove_node":
        return ae.isPath(e.path) && qe.isNode(e.node);
      case "remove_text":
        return typeof e.offset == "number" && typeof e.text == "string" && ae.isPath(e.path);
      case "set_node":
        return ae.isPath(e.path) && Lo(e.properties) && Lo(e.newProperties);
      case "set_selection":
        return e.properties === null && me.isRange(e.newProperties) || e.newProperties === null && me.isRange(e.properties) || Lo(e.properties) && Lo(e.newProperties);
      case "split_node":
        return ae.isPath(e.path) && typeof e.position == "number" && Lo(e.properties);
      default:
        return !1;
    }
  },
  isOperationList(e) {
    return Array.isArray(e) && e.every((t) => sl.isOperation(t));
  },
  isSelectionOperation(e) {
    return sl.isOperation(e) && e.type.endsWith("_selection");
  },
  isTextOperation(e) {
    return sl.isOperation(e) && e.type.endsWith("_text");
  },
  inverse(e) {
    switch (e.type) {
      case "insert_node":
        return br(br({}, e), {}, {
          type: "remove_node"
        });
      case "insert_text":
        return br(br({}, e), {}, {
          type: "remove_text"
        });
      case "merge_node":
        return br(br({}, e), {}, {
          type: "split_node",
          path: ae.previous(e.path)
        });
      case "move_node": {
        var {
          newPath: t,
          path: n
        } = e;
        if (ae.equals(t, n))
          return e;
        if (ae.isSibling(n, t))
          return br(br({}, e), {}, {
            path: t,
            newPath: n
          });
        var r = ae.transform(n, e), o = ae.transform(ae.next(n), e);
        return br(br({}, e), {}, {
          path: r,
          newPath: o
        });
      }
      case "remove_node":
        return br(br({}, e), {}, {
          type: "insert_node"
        });
      case "remove_text":
        return br(br({}, e), {}, {
          type: "insert_text"
        });
      case "set_node": {
        var {
          properties: i,
          newProperties: a
        } = e;
        return br(br({}, e), {}, {
          properties: a,
          newProperties: i
        });
      }
      case "set_selection": {
        var {
          properties: s,
          newProperties: l
        } = e;
        return s == null ? br(br({}, e), {}, {
          properties: l,
          newProperties: null
        }) : l == null ? br(br({}, e), {}, {
          properties: null,
          newProperties: s
        }) : br(br({}, e), {}, {
          properties: l,
          newProperties: s
        });
      }
      case "split_node":
        return br(br({}, e), {}, {
          type: "merge_node",
          path: ae.next(e.path)
        });
    }
  }
}, oM = /* @__PURE__ */ new WeakMap(), HQ = (e) => {
  var t = oM.get(e);
  if (t !== void 0)
    return t;
  if (!Lo(e))
    return !1;
  var n = typeof e.addMark == "function" && typeof e.apply == "function" && typeof e.deleteFragment == "function" && typeof e.insertBreak == "function" && typeof e.insertSoftBreak == "function" && typeof e.insertFragment == "function" && typeof e.insertNode == "function" && typeof e.insertText == "function" && typeof e.isElementReadOnly == "function" && typeof e.isInline == "function" && typeof e.isSelectable == "function" && typeof e.isVoid == "function" && typeof e.normalizeNode == "function" && typeof e.onChange == "function" && typeof e.removeMark == "function" && typeof e.getDirtyPaths == "function" && (e.marks === null || Lo(e.marks)) && (e.selection === null || me.isRange(e.selection)) && qe.isNodeList(e.children) && sl.isOperationList(e.operations);
  return oM.set(e, n), n;
}, ee = {
  above(e, t) {
    return e.above(t);
  },
  addMark(e, t, n) {
    e.addMark(t, n);
  },
  after(e, t, n) {
    return e.after(t, n);
  },
  before(e, t, n) {
    return e.before(t, n);
  },
  deleteBackward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteBackward(n);
  },
  deleteForward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteForward(n);
  },
  deleteFragment(e, t) {
    e.deleteFragment(t);
  },
  edges(e, t) {
    return e.edges(t);
  },
  elementReadOnly(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return e.elementReadOnly(t);
  },
  end(e, t) {
    return e.end(t);
  },
  first(e, t) {
    return e.first(t);
  },
  fragment(e, t) {
    return e.fragment(t);
  },
  hasBlocks(e, t) {
    return e.hasBlocks(t);
  },
  hasInlines(e, t) {
    return e.hasInlines(t);
  },
  hasPath(e, t) {
    return e.hasPath(t);
  },
  hasTexts(e, t) {
    return e.hasTexts(t);
  },
  insertBreak(e) {
    e.insertBreak();
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertNode(e, t) {
    e.insertNode(t);
  },
  insertSoftBreak(e) {
    e.insertSoftBreak();
  },
  insertText(e, t) {
    e.insertText(t);
  },
  isBlock(e, t) {
    return e.isBlock(t);
  },
  isEdge(e, t, n) {
    return e.isEdge(t, n);
  },
  isEditor(e) {
    return HQ(e);
  },
  isElementReadOnly(e, t) {
    return e.isElementReadOnly(t);
  },
  isEmpty(e, t) {
    return e.isEmpty(t);
  },
  isEnd(e, t, n) {
    return e.isEnd(t, n);
  },
  isInline(e, t) {
    return e.isInline(t);
  },
  isNormalizing(e) {
    return e.isNormalizing();
  },
  isSelectable(e, t) {
    return e.isSelectable(t);
  },
  isStart(e, t, n) {
    return e.isStart(t, n);
  },
  isVoid(e, t) {
    return e.isVoid(t);
  },
  last(e, t) {
    return e.last(t);
  },
  leaf(e, t, n) {
    return e.leaf(t, n);
  },
  levels(e, t) {
    return e.levels(t);
  },
  marks(e) {
    return e.getMarks();
  },
  next(e, t) {
    return e.next(t);
  },
  node(e, t, n) {
    return e.node(t, n);
  },
  nodes(e, t) {
    return e.nodes(t);
  },
  normalize(e, t) {
    e.normalize(t);
  },
  parent(e, t, n) {
    return e.parent(t, n);
  },
  path(e, t, n) {
    return e.path(t, n);
  },
  pathRef(e, t, n) {
    return e.pathRef(t, n);
  },
  pathRefs(e) {
    return e.pathRefs();
  },
  point(e, t, n) {
    return e.point(t, n);
  },
  pointRef(e, t, n) {
    return e.pointRef(t, n);
  },
  pointRefs(e) {
    return e.pointRefs();
  },
  positions(e, t) {
    return e.positions(t);
  },
  previous(e, t) {
    return e.previous(t);
  },
  range(e, t, n) {
    return e.range(t, n);
  },
  rangeRef(e, t, n) {
    return e.rangeRef(t, n);
  },
  rangeRefs(e) {
    return e.rangeRefs();
  },
  removeMark(e, t) {
    e.removeMark(t);
  },
  setNormalizing(e, t) {
    e.setNormalizing(t);
  },
  start(e, t) {
    return e.start(t);
  },
  string(e, t, n) {
    return e.string(t, n);
  },
  unhangRange(e, t, n) {
    return e.unhangRange(t, n);
  },
  void(e, t) {
    return e.void(t);
  },
  withoutNormalizing(e, t) {
    e.withoutNormalizing(t);
  },
  shouldMergeNodesRemovePrevNode: (e, t, n) => e.shouldMergeNodesRemovePrevNode(t, n)
}, $Q = {
  isSpan(e) {
    return Array.isArray(e) && e.length === 2 && e.every(ae.isPath);
  }
};
function iM(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function sM(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? iM(Object(n), !0).forEach(function(r) {
      Go(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : iM(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Nt = {
  compare(e, t) {
    var n = ae.compare(e.path, t.path);
    return n === 0 ? e.offset < t.offset ? -1 : e.offset > t.offset ? 1 : 0 : n;
  },
  isAfter(e, t) {
    return Nt.compare(e, t) === 1;
  },
  isBefore(e, t) {
    return Nt.compare(e, t) === -1;
  },
  equals(e, t) {
    return e.offset === t.offset && ae.equals(e.path, t.path);
  },
  isPoint(e) {
    return Lo(e) && typeof e.offset == "number" && ae.isPath(e.path);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return M1(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "forward"
      } = n, {
        path: i,
        offset: a
      } = r;
      switch (t.type) {
        case "insert_node":
        case "move_node": {
          r.path = ae.transform(i, t, n);
          break;
        }
        case "insert_text": {
          ae.equals(t.path, i) && (t.offset < a || t.offset === a && o === "forward") && (r.offset += t.text.length);
          break;
        }
        case "merge_node": {
          ae.equals(t.path, i) && (r.offset += t.position), r.path = ae.transform(i, t, n);
          break;
        }
        case "remove_text": {
          ae.equals(t.path, i) && t.offset <= a && (r.offset -= Math.min(a - t.offset, t.text.length));
          break;
        }
        case "remove_node": {
          if (ae.equals(t.path, i) || ae.isAncestor(t.path, i))
            return null;
          r.path = ae.transform(i, t, n);
          break;
        }
        case "split_node": {
          if (ae.equals(t.path, i)) {
            if (t.position === a && o == null)
              return null;
            (t.position < a || t.position === a && o === "forward") && (r.offset -= t.position, r.path = ae.transform(i, t, sM(sM({}, n), {}, {
              affinity: "forward"
            })));
          } else
            r.path = ae.transform(i, t, n);
          break;
        }
      }
    });
  }
}, aM = void 0, ko = {
  setScrubber(e) {
    aM = e;
  },
  stringify(e) {
    return JSON.stringify(e, aM);
  }
}, WQ = ["text"], VQ = ["anchor", "focus"];
function lM(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function zs(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? lM(Object(n), !0).forEach(function(r) {
      Go(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : lM(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var it = {
  equals(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      loose: r = !1
    } = n;
    function o(i) {
      var a = aa(i, WQ);
      return a;
    }
    return Y6(r ? o(e) : e, r ? o(t) : t);
  },
  isText(e) {
    return Lo(e) && typeof e.text == "string";
  },
  isTextList(e) {
    return Array.isArray(e) && e.every((t) => it.isText(t));
  },
  isTextProps(e) {
    return e.text !== void 0;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "text" && (!e.hasOwnProperty(n) || e[n] !== t[n]))
        return !1;
    return !0;
  },
  decorations(e, t) {
    var n = [zs({}, e)];
    for (var r of t) {
      var o = aa(r, VQ), [i, a] = me.edges(r), s = [], l = 0, u = i.offset, c = a.offset;
      for (var p of n) {
        var {
          length: d
        } = p.text, g = l;
        if (l += d, u <= g && l <= c) {
          Object.assign(p, o), s.push(p);
          continue;
        }
        if (u !== c && (u === l || c === g) || u > l || c < g || c === g && g !== 0) {
          s.push(p);
          continue;
        }
        var f = p, m = void 0, v = void 0;
        if (c < l) {
          var E = c - g;
          v = zs(zs({}, f), {}, {
            text: f.text.slice(E)
          }), f = zs(zs({}, f), {}, {
            text: f.text.slice(0, E)
          });
        }
        if (u > g) {
          var w = u - g;
          m = zs(zs({}, f), {}, {
            text: f.text.slice(0, w)
          }), f = zs(zs({}, f), {}, {
            text: f.text.slice(w)
          });
        }
        Object.assign(f, o), m && s.push(m), s.push(f), v && s.push(v);
      }
      n = s;
    }
    return n;
  }
}, D1 = (e) => e.selection ? e.selection : e.children.length > 0 ? ee.end(e, []) : [0], Cc = (e, t) => {
  var [n] = ee.node(e, t);
  return (r) => r === n;
}, T1 = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, r = !n, o = n ? XQ(t) : t, i = Ot.None, a = Ot.None, s = 0, l = null, u = null;
  for (var c of o) {
    var p = c.codePointAt(0);
    if (!p) break;
    var d = uee(c, p);
    if ([i, a] = r ? [a, d] : [d, i], ec(i, Ot.ZWJ) && ec(a, Ot.ExtPict) && (r ? l = uM(t.substring(0, s)) : l = uM(t.substring(0, t.length - s)), !l) || ec(i, Ot.RI) && ec(a, Ot.RI) && (u !== null ? u = !u : r ? u = !0 : u = hee(t.substring(0, t.length - s)), !u) || i !== Ot.None && a !== Ot.None && pee(i, a))
      break;
    s += c.length;
  }
  return s || 1;
}, ZQ = /\s/, qQ = /[\u002B\u0021-\u0023\u0025-\u002A\u002C-\u002F\u003A\u003B\u003F\u0040\u005B-\u005D\u005F\u007B\u007D\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E3B\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]/, GQ = /['\u2018\u2019]/, KQ = function(t) {
  for (var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, r = 0, o = !1; t.length > 0; ) {
    var i = T1(t, n), [a, s] = j1(t, i, n);
    if (YQ(a, s, n))
      o = !0, r += i;
    else if (!o)
      r += i;
    else
      break;
    t = s;
  }
  return r;
}, j1 = (e, t, n) => {
  if (n) {
    var r = e.length - t;
    return [e.slice(r, e.length), e.slice(0, r)];
  }
  return [e.slice(0, t), e.slice(t)];
}, YQ = function e(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
  if (ZQ.test(t))
    return !1;
  if (GQ.test(t)) {
    var o = T1(n, r), [i, a] = j1(n, o, r);
    if (e(i, a, r))
      return !0;
  }
  return !qQ.test(t);
}, XQ = function* (t) {
  for (var n = t.length - 1, r = 0; r < t.length; r++) {
    var o = t.charAt(n - r);
    if (QQ(o.charCodeAt(0))) {
      var i = t.charAt(n - r - 1);
      if (JQ(i.charCodeAt(0))) {
        yield i + o, r++;
        continue;
      }
    }
    yield o;
  }
}, JQ = (e) => e >= 55296 && e <= 56319, QQ = (e) => e >= 56320 && e <= 57343, Ot;
(function(e) {
  e[e.None = 0] = "None", e[e.Extend = 1] = "Extend", e[e.ZWJ = 2] = "ZWJ", e[e.RI = 4] = "RI", e[e.Prepend = 8] = "Prepend", e[e.SpacingMark = 16] = "SpacingMark", e[e.L = 32] = "L", e[e.V = 64] = "V", e[e.T = 128] = "T", e[e.LV = 256] = "LV", e[e.LVT = 512] = "LVT", e[e.ExtPict = 1024] = "ExtPict", e[e.Any = 2048] = "Any";
})(Ot || (Ot = {}));
var eee = /^(?:[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09BE\u09C1-\u09C4\u09CD\u09D7\u09E2\u09E3\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01\u0B3C\u0B3E\u0B3F\u0B41-\u0B44\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B82\u0BBE\u0BC0\u0BCD\u0BD7\u0C00\u0C04\u0C3C\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CBF\u0CC2\u0CC6\u0CCC\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D3E\u0D41-\u0D44\u0D4D\u0D57\u0D62\u0D63\u0D81\u0DCA\u0DCF\u0DD2-\u0DD4\u0DD6\u0DDF\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732\u1733\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u180F\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ACE\u1B00-\u1B03\u1B34-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DFF\u200C\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA82C\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFF9E\uFF9F]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD803[\uDD24-\uDD27\uDEAB\uDEAC\uDEFD-\uDEFF\uDF46-\uDF50\uDF82-\uDF85]|\uD804[\uDC01\uDC38-\uDC46\uDC70\uDC73\uDC74\uDC7F-\uDC81\uDCB3-\uDCB6\uDCB9\uDCBA\uDCC2\uDD00-\uDD02\uDD27-\uDD2B\uDD2D-\uDD34\uDD73\uDD80\uDD81\uDDB6-\uDDBE\uDDC9-\uDDCC\uDDCF\uDE2F-\uDE31\uDE34\uDE36\uDE37\uDE3E\uDE41\uDEDF\uDEE3-\uDEEA\uDF00\uDF01\uDF3B\uDF3C\uDF3E\uDF40\uDF57\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC38-\uDC3F\uDC42-\uDC44\uDC46\uDC5E\uDCB0\uDCB3-\uDCB8\uDCBA\uDCBD\uDCBF\uDCC0\uDCC2\uDCC3\uDDAF\uDDB2-\uDDB5\uDDBC\uDDBD\uDDBF\uDDC0\uDDDC\uDDDD\uDE33-\uDE3A\uDE3D\uDE3F\uDE40\uDEAB\uDEAD\uDEB0-\uDEB5\uDEB7\uDF1D-\uDF1F\uDF22-\uDF25\uDF27-\uDF2B]|\uD806[\uDC2F-\uDC37\uDC39\uDC3A\uDD30\uDD3B\uDD3C\uDD3E\uDD43\uDDD4-\uDDD7\uDDDA\uDDDB\uDDE0\uDE01-\uDE0A\uDE33-\uDE38\uDE3B-\uDE3E\uDE47\uDE51-\uDE56\uDE59-\uDE5B\uDE8A-\uDE96\uDE98\uDE99]|\uD807[\uDC30-\uDC36\uDC38-\uDC3D\uDC3F\uDC92-\uDCA7\uDCAA-\uDCB0\uDCB2\uDCB3\uDCB5\uDCB6\uDD31-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD45\uDD47\uDD90\uDD91\uDD95\uDD97\uDEF3\uDEF4\uDF00\uDF01\uDF36-\uDF3A\uDF40\uDF42]|\uD80D[\uDC40\uDC47-\uDC55]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF4F\uDF8F-\uDF92\uDFE4]|\uD82F[\uDC9D\uDC9E]|\uD833[\uDF00-\uDF2D\uDF30-\uDF46]|\uD834[\uDD65\uDD67-\uDD69\uDD6E-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A\uDC8F\uDD30-\uDD36\uDEAE\uDEEC-\uDEEF]|\uD839[\uDCEC-\uDCEF]|\uD83A[\uDCD0-\uDCD6\uDD44-\uDD4A]|\uD83C[\uDFFB-\uDFFF]|\uDB40[\uDC20-\uDC7F\uDD00-\uDDEF])$/, tee = /^(?:[\u0600-\u0605\u06DD\u070F\u0890\u0891\u08E2\u0D4E]|\uD804[\uDCBD\uDCCD\uDDC2\uDDC3]|\uD806[\uDD3F\uDD41\uDE3A\uDE84-\uDE89]|\uD807\uDD46)$/, nee = /^(?:[\u0903\u093B\u093E-\u0940\u0949-\u094C\u094E\u094F\u0982\u0983\u09BF\u09C0\u09C7\u09C8\u09CB\u09CC\u0A03\u0A3E-\u0A40\u0A83\u0ABE-\u0AC0\u0AC9\u0ACB\u0ACC\u0B02\u0B03\u0B40\u0B47\u0B48\u0B4B\u0B4C\u0BBF\u0BC1\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCC\u0C01-\u0C03\u0C41-\u0C44\u0C82\u0C83\u0CBE\u0CC0\u0CC1\u0CC3\u0CC4\u0CC7\u0CC8\u0CCA\u0CCB\u0D02\u0D03\u0D3F\u0D40\u0D46-\u0D48\u0D4A-\u0D4C\u0D82\u0D83\u0DD0\u0DD1\u0DD8-\u0DDE\u0DF2\u0DF3\u0E33\u0EB3\u0F3E\u0F3F\u0F7F\u1031\u103B\u103C\u1056\u1057\u1084\u1715\u1734\u17B6\u17BE-\u17C5\u17C7\u17C8\u1923-\u1926\u1929-\u192B\u1930\u1931\u1933-\u1938\u1A19\u1A1A\u1A55\u1A57\u1A6D-\u1A72\u1B04\u1B3B\u1B3D-\u1B41\u1B43\u1B44\u1B82\u1BA1\u1BA6\u1BA7\u1BAA\u1BE7\u1BEA-\u1BEC\u1BEE\u1BF2\u1BF3\u1C24-\u1C2B\u1C34\u1C35\u1CE1\u1CF7\uA823\uA824\uA827\uA880\uA881\uA8B4-\uA8C3\uA952\uA953\uA983\uA9B4\uA9B5\uA9BA\uA9BB\uA9BE-\uA9C0\uAA2F\uAA30\uAA33\uAA34\uAA4D\uAAEB\uAAEE\uAAEF\uAAF5\uABE3\uABE4\uABE6\uABE7\uABE9\uABEA\uABEC]|\uD804[\uDC00\uDC02\uDC82\uDCB0-\uDCB2\uDCB7\uDCB8\uDD2C\uDD45\uDD46\uDD82\uDDB3-\uDDB5\uDDBF\uDDC0\uDDCE\uDE2C-\uDE2E\uDE32\uDE33\uDE35\uDEE0-\uDEE2\uDF02\uDF03\uDF3F\uDF41-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF62\uDF63]|\uD805[\uDC35-\uDC37\uDC40\uDC41\uDC45\uDCB1\uDCB2\uDCB9\uDCBB\uDCBC\uDCBE\uDCC1\uDDB0\uDDB1\uDDB8-\uDDBB\uDDBE\uDE30-\uDE32\uDE3B\uDE3C\uDE3E\uDEAC\uDEAE\uDEAF\uDEB6\uDF26]|\uD806[\uDC2C-\uDC2E\uDC38\uDD31-\uDD35\uDD37\uDD38\uDD3D\uDD40\uDD42\uDDD1-\uDDD3\uDDDC-\uDDDF\uDDE4\uDE39\uDE57\uDE58\uDE97]|\uD807[\uDC2F\uDC3E\uDCA9\uDCB1\uDCB4\uDD8A-\uDD8E\uDD93\uDD94\uDD96\uDEF5\uDEF6]|\uD81B[\uDF51-\uDF87\uDFF0\uDFF1]|\uD834[\uDD66\uDD6D])$/, ree = /^[\u1100-\u115F\uA960-\uA97C]$/, oee = /^[\u1160-\u11A7\uD7B0-\uD7C6]$/, iee = /^[\u11A8-\u11FF\uD7CB-\uD7FB]$/, see = /^[\uAC00\uAC1C\uAC38\uAC54\uAC70\uAC8C\uACA8\uACC4\uACE0\uACFC\uAD18\uAD34\uAD50\uAD6C\uAD88\uADA4\uADC0\uADDC\uADF8\uAE14\uAE30\uAE4C\uAE68\uAE84\uAEA0\uAEBC\uAED8\uAEF4\uAF10\uAF2C\uAF48\uAF64\uAF80\uAF9C\uAFB8\uAFD4\uAFF0\uB00C\uB028\uB044\uB060\uB07C\uB098\uB0B4\uB0D0\uB0EC\uB108\uB124\uB140\uB15C\uB178\uB194\uB1B0\uB1CC\uB1E8\uB204\uB220\uB23C\uB258\uB274\uB290\uB2AC\uB2C8\uB2E4\uB300\uB31C\uB338\uB354\uB370\uB38C\uB3A8\uB3C4\uB3E0\uB3FC\uB418\uB434\uB450\uB46C\uB488\uB4A4\uB4C0\uB4DC\uB4F8\uB514\uB530\uB54C\uB568\uB584\uB5A0\uB5BC\uB5D8\uB5F4\uB610\uB62C\uB648\uB664\uB680\uB69C\uB6B8\uB6D4\uB6F0\uB70C\uB728\uB744\uB760\uB77C\uB798\uB7B4\uB7D0\uB7EC\uB808\uB824\uB840\uB85C\uB878\uB894\uB8B0\uB8CC\uB8E8\uB904\uB920\uB93C\uB958\uB974\uB990\uB9AC\uB9C8\uB9E4\uBA00\uBA1C\uBA38\uBA54\uBA70\uBA8C\uBAA8\uBAC4\uBAE0\uBAFC\uBB18\uBB34\uBB50\uBB6C\uBB88\uBBA4\uBBC0\uBBDC\uBBF8\uBC14\uBC30\uBC4C\uBC68\uBC84\uBCA0\uBCBC\uBCD8\uBCF4\uBD10\uBD2C\uBD48\uBD64\uBD80\uBD9C\uBDB8\uBDD4\uBDF0\uBE0C\uBE28\uBE44\uBE60\uBE7C\uBE98\uBEB4\uBED0\uBEEC\uBF08\uBF24\uBF40\uBF5C\uBF78\uBF94\uBFB0\uBFCC\uBFE8\uC004\uC020\uC03C\uC058\uC074\uC090\uC0AC\uC0C8\uC0E4\uC100\uC11C\uC138\uC154\uC170\uC18C\uC1A8\uC1C4\uC1E0\uC1FC\uC218\uC234\uC250\uC26C\uC288\uC2A4\uC2C0\uC2DC\uC2F8\uC314\uC330\uC34C\uC368\uC384\uC3A0\uC3BC\uC3D8\uC3F4\uC410\uC42C\uC448\uC464\uC480\uC49C\uC4B8\uC4D4\uC4F0\uC50C\uC528\uC544\uC560\uC57C\uC598\uC5B4\uC5D0\uC5EC\uC608\uC624\uC640\uC65C\uC678\uC694\uC6B0\uC6CC\uC6E8\uC704\uC720\uC73C\uC758\uC774\uC790\uC7AC\uC7C8\uC7E4\uC800\uC81C\uC838\uC854\uC870\uC88C\uC8A8\uC8C4\uC8E0\uC8FC\uC918\uC934\uC950\uC96C\uC988\uC9A4\uC9C0\uC9DC\uC9F8\uCA14\uCA30\uCA4C\uCA68\uCA84\uCAA0\uCABC\uCAD8\uCAF4\uCB10\uCB2C\uCB48\uCB64\uCB80\uCB9C\uCBB8\uCBD4\uCBF0\uCC0C\uCC28\uCC44\uCC60\uCC7C\uCC98\uCCB4\uCCD0\uCCEC\uCD08\uCD24\uCD40\uCD5C\uCD78\uCD94\uCDB0\uCDCC\uCDE8\uCE04\uCE20\uCE3C\uCE58\uCE74\uCE90\uCEAC\uCEC8\uCEE4\uCF00\uCF1C\uCF38\uCF54\uCF70\uCF8C\uCFA8\uCFC4\uCFE0\uCFFC\uD018\uD034\uD050\uD06C\uD088\uD0A4\uD0C0\uD0DC\uD0F8\uD114\uD130\uD14C\uD168\uD184\uD1A0\uD1BC\uD1D8\uD1F4\uD210\uD22C\uD248\uD264\uD280\uD29C\uD2B8\uD2D4\uD2F0\uD30C\uD328\uD344\uD360\uD37C\uD398\uD3B4\uD3D0\uD3EC\uD408\uD424\uD440\uD45C\uD478\uD494\uD4B0\uD4CC\uD4E8\uD504\uD520\uD53C\uD558\uD574\uD590\uD5AC\uD5C8\uD5E4\uD600\uD61C\uD638\uD654\uD670\uD68C\uD6A8\uD6C4\uD6E0\uD6FC\uD718\uD734\uD750\uD76C\uD788]$/, aee = /^[\uAC01-\uAC1B\uAC1D-\uAC37\uAC39-\uAC53\uAC55-\uAC6F\uAC71-\uAC8B\uAC8D-\uACA7\uACA9-\uACC3\uACC5-\uACDF\uACE1-\uACFB\uACFD-\uAD17\uAD19-\uAD33\uAD35-\uAD4F\uAD51-\uAD6B\uAD6D-\uAD87\uAD89-\uADA3\uADA5-\uADBF\uADC1-\uADDB\uADDD-\uADF7\uADF9-\uAE13\uAE15-\uAE2F\uAE31-\uAE4B\uAE4D-\uAE67\uAE69-\uAE83\uAE85-\uAE9F\uAEA1-\uAEBB\uAEBD-\uAED7\uAED9-\uAEF3\uAEF5-\uAF0F\uAF11-\uAF2B\uAF2D-\uAF47\uAF49-\uAF63\uAF65-\uAF7F\uAF81-\uAF9B\uAF9D-\uAFB7\uAFB9-\uAFD3\uAFD5-\uAFEF\uAFF1-\uB00B\uB00D-\uB027\uB029-\uB043\uB045-\uB05F\uB061-\uB07B\uB07D-\uB097\uB099-\uB0B3\uB0B5-\uB0CF\uB0D1-\uB0EB\uB0ED-\uB107\uB109-\uB123\uB125-\uB13F\uB141-\uB15B\uB15D-\uB177\uB179-\uB193\uB195-\uB1AF\uB1B1-\uB1CB\uB1CD-\uB1E7\uB1E9-\uB203\uB205-\uB21F\uB221-\uB23B\uB23D-\uB257\uB259-\uB273\uB275-\uB28F\uB291-\uB2AB\uB2AD-\uB2C7\uB2C9-\uB2E3\uB2E5-\uB2FF\uB301-\uB31B\uB31D-\uB337\uB339-\uB353\uB355-\uB36F\uB371-\uB38B\uB38D-\uB3A7\uB3A9-\uB3C3\uB3C5-\uB3DF\uB3E1-\uB3FB\uB3FD-\uB417\uB419-\uB433\uB435-\uB44F\uB451-\uB46B\uB46D-\uB487\uB489-\uB4A3\uB4A5-\uB4BF\uB4C1-\uB4DB\uB4DD-\uB4F7\uB4F9-\uB513\uB515-\uB52F\uB531-\uB54B\uB54D-\uB567\uB569-\uB583\uB585-\uB59F\uB5A1-\uB5BB\uB5BD-\uB5D7\uB5D9-\uB5F3\uB5F5-\uB60F\uB611-\uB62B\uB62D-\uB647\uB649-\uB663\uB665-\uB67F\uB681-\uB69B\uB69D-\uB6B7\uB6B9-\uB6D3\uB6D5-\uB6EF\uB6F1-\uB70B\uB70D-\uB727\uB729-\uB743\uB745-\uB75F\uB761-\uB77B\uB77D-\uB797\uB799-\uB7B3\uB7B5-\uB7CF\uB7D1-\uB7EB\uB7ED-\uB807\uB809-\uB823\uB825-\uB83F\uB841-\uB85B\uB85D-\uB877\uB879-\uB893\uB895-\uB8AF\uB8B1-\uB8CB\uB8CD-\uB8E7\uB8E9-\uB903\uB905-\uB91F\uB921-\uB93B\uB93D-\uB957\uB959-\uB973\uB975-\uB98F\uB991-\uB9AB\uB9AD-\uB9C7\uB9C9-\uB9E3\uB9E5-\uB9FF\uBA01-\uBA1B\uBA1D-\uBA37\uBA39-\uBA53\uBA55-\uBA6F\uBA71-\uBA8B\uBA8D-\uBAA7\uBAA9-\uBAC3\uBAC5-\uBADF\uBAE1-\uBAFB\uBAFD-\uBB17\uBB19-\uBB33\uBB35-\uBB4F\uBB51-\uBB6B\uBB6D-\uBB87\uBB89-\uBBA3\uBBA5-\uBBBF\uBBC1-\uBBDB\uBBDD-\uBBF7\uBBF9-\uBC13\uBC15-\uBC2F\uBC31-\uBC4B\uBC4D-\uBC67\uBC69-\uBC83\uBC85-\uBC9F\uBCA1-\uBCBB\uBCBD-\uBCD7\uBCD9-\uBCF3\uBCF5-\uBD0F\uBD11-\uBD2B\uBD2D-\uBD47\uBD49-\uBD63\uBD65-\uBD7F\uBD81-\uBD9B\uBD9D-\uBDB7\uBDB9-\uBDD3\uBDD5-\uBDEF\uBDF1-\uBE0B\uBE0D-\uBE27\uBE29-\uBE43\uBE45-\uBE5F\uBE61-\uBE7B\uBE7D-\uBE97\uBE99-\uBEB3\uBEB5-\uBECF\uBED1-\uBEEB\uBEED-\uBF07\uBF09-\uBF23\uBF25-\uBF3F\uBF41-\uBF5B\uBF5D-\uBF77\uBF79-\uBF93\uBF95-\uBFAF\uBFB1-\uBFCB\uBFCD-\uBFE7\uBFE9-\uC003\uC005-\uC01F\uC021-\uC03B\uC03D-\uC057\uC059-\uC073\uC075-\uC08F\uC091-\uC0AB\uC0AD-\uC0C7\uC0C9-\uC0E3\uC0E5-\uC0FF\uC101-\uC11B\uC11D-\uC137\uC139-\uC153\uC155-\uC16F\uC171-\uC18B\uC18D-\uC1A7\uC1A9-\uC1C3\uC1C5-\uC1DF\uC1E1-\uC1FB\uC1FD-\uC217\uC219-\uC233\uC235-\uC24F\uC251-\uC26B\uC26D-\uC287\uC289-\uC2A3\uC2A5-\uC2BF\uC2C1-\uC2DB\uC2DD-\uC2F7\uC2F9-\uC313\uC315-\uC32F\uC331-\uC34B\uC34D-\uC367\uC369-\uC383\uC385-\uC39F\uC3A1-\uC3BB\uC3BD-\uC3D7\uC3D9-\uC3F3\uC3F5-\uC40F\uC411-\uC42B\uC42D-\uC447\uC449-\uC463\uC465-\uC47F\uC481-\uC49B\uC49D-\uC4B7\uC4B9-\uC4D3\uC4D5-\uC4EF\uC4F1-\uC50B\uC50D-\uC527\uC529-\uC543\uC545-\uC55F\uC561-\uC57B\uC57D-\uC597\uC599-\uC5B3\uC5B5-\uC5CF\uC5D1-\uC5EB\uC5ED-\uC607\uC609-\uC623\uC625-\uC63F\uC641-\uC65B\uC65D-\uC677\uC679-\uC693\uC695-\uC6AF\uC6B1-\uC6CB\uC6CD-\uC6E7\uC6E9-\uC703\uC705-\uC71F\uC721-\uC73B\uC73D-\uC757\uC759-\uC773\uC775-\uC78F\uC791-\uC7AB\uC7AD-\uC7C7\uC7C9-\uC7E3\uC7E5-\uC7FF\uC801-\uC81B\uC81D-\uC837\uC839-\uC853\uC855-\uC86F\uC871-\uC88B\uC88D-\uC8A7\uC8A9-\uC8C3\uC8C5-\uC8DF\uC8E1-\uC8FB\uC8FD-\uC917\uC919-\uC933\uC935-\uC94F\uC951-\uC96B\uC96D-\uC987\uC989-\uC9A3\uC9A5-\uC9BF\uC9C1-\uC9DB\uC9DD-\uC9F7\uC9F9-\uCA13\uCA15-\uCA2F\uCA31-\uCA4B\uCA4D-\uCA67\uCA69-\uCA83\uCA85-\uCA9F\uCAA1-\uCABB\uCABD-\uCAD7\uCAD9-\uCAF3\uCAF5-\uCB0F\uCB11-\uCB2B\uCB2D-\uCB47\uCB49-\uCB63\uCB65-\uCB7F\uCB81-\uCB9B\uCB9D-\uCBB7\uCBB9-\uCBD3\uCBD5-\uCBEF\uCBF1-\uCC0B\uCC0D-\uCC27\uCC29-\uCC43\uCC45-\uCC5F\uCC61-\uCC7B\uCC7D-\uCC97\uCC99-\uCCB3\uCCB5-\uCCCF\uCCD1-\uCCEB\uCCED-\uCD07\uCD09-\uCD23\uCD25-\uCD3F\uCD41-\uCD5B\uCD5D-\uCD77\uCD79-\uCD93\uCD95-\uCDAF\uCDB1-\uCDCB\uCDCD-\uCDE7\uCDE9-\uCE03\uCE05-\uCE1F\uCE21-\uCE3B\uCE3D-\uCE57\uCE59-\uCE73\uCE75-\uCE8F\uCE91-\uCEAB\uCEAD-\uCEC7\uCEC9-\uCEE3\uCEE5-\uCEFF\uCF01-\uCF1B\uCF1D-\uCF37\uCF39-\uCF53\uCF55-\uCF6F\uCF71-\uCF8B\uCF8D-\uCFA7\uCFA9-\uCFC3\uCFC5-\uCFDF\uCFE1-\uCFFB\uCFFD-\uD017\uD019-\uD033\uD035-\uD04F\uD051-\uD06B\uD06D-\uD087\uD089-\uD0A3\uD0A5-\uD0BF\uD0C1-\uD0DB\uD0DD-\uD0F7\uD0F9-\uD113\uD115-\uD12F\uD131-\uD14B\uD14D-\uD167\uD169-\uD183\uD185-\uD19F\uD1A1-\uD1BB\uD1BD-\uD1D7\uD1D9-\uD1F3\uD1F5-\uD20F\uD211-\uD22B\uD22D-\uD247\uD249-\uD263\uD265-\uD27F\uD281-\uD29B\uD29D-\uD2B7\uD2B9-\uD2D3\uD2D5-\uD2EF\uD2F1-\uD30B\uD30D-\uD327\uD329-\uD343\uD345-\uD35F\uD361-\uD37B\uD37D-\uD397\uD399-\uD3B3\uD3B5-\uD3CF\uD3D1-\uD3EB\uD3ED-\uD407\uD409-\uD423\uD425-\uD43F\uD441-\uD45B\uD45D-\uD477\uD479-\uD493\uD495-\uD4AF\uD4B1-\uD4CB\uD4CD-\uD4E7\uD4E9-\uD503\uD505-\uD51F\uD521-\uD53B\uD53D-\uD557\uD559-\uD573\uD575-\uD58F\uD591-\uD5AB\uD5AD-\uD5C7\uD5C9-\uD5E3\uD5E5-\uD5FF\uD601-\uD61B\uD61D-\uD637\uD639-\uD653\uD655-\uD66F\uD671-\uD68B\uD68D-\uD6A7\uD6A9-\uD6C3\uD6C5-\uD6DF\uD6E1-\uD6FB\uD6FD-\uD717\uD719-\uD733\uD735-\uD74F\uD751-\uD76B\uD76D-\uD787\uD789-\uD7A3]$/, lee = /^(?:[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u2388\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2605\u2607-\u2612\u2614-\u2685\u2690-\u2705\u2708-\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763-\u2767\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC00-\uDCFF\uDD0D-\uDD0F\uDD2F\uDD6C-\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDAD-\uDDE5\uDE01-\uDE0F\uDE1A\uDE2F\uDE32-\uDE3A\uDE3C-\uDE3F\uDE49-\uDFFA]|\uD83D[\uDC00-\uDD3D\uDD46-\uDE4F\uDE80-\uDEFF\uDF74-\uDF7F\uDFD5-\uDFFF]|\uD83E[\uDC0C-\uDC0F\uDC48-\uDC4F\uDC5A-\uDC5F\uDC88-\uDC8F\uDCAE-\uDCFF\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDEFF]|\uD83F[\uDC00-\uDFFD])$/, uee = (e, t) => {
  var n = Ot.Any;
  return e.search(eee) !== -1 && (n |= Ot.Extend), t === 8205 && (n |= Ot.ZWJ), t >= 127462 && t <= 127487 && (n |= Ot.RI), e.search(tee) !== -1 && (n |= Ot.Prepend), e.search(nee) !== -1 && (n |= Ot.SpacingMark), e.search(ree) !== -1 && (n |= Ot.L), e.search(oee) !== -1 && (n |= Ot.V), e.search(iee) !== -1 && (n |= Ot.T), e.search(see) !== -1 && (n |= Ot.LV), e.search(aee) !== -1 && (n |= Ot.LVT), e.search(lee) !== -1 && (n |= Ot.ExtPict), n;
};
function ec(e, t) {
  return (e & t) !== 0;
}
var cee = [
  // GB6
  [Ot.L, Ot.L | Ot.V | Ot.LV | Ot.LVT],
  // GB7
  [Ot.LV | Ot.V, Ot.V | Ot.T],
  // GB8
  [Ot.LVT | Ot.T, Ot.T],
  // GB9
  [Ot.Any, Ot.Extend | Ot.ZWJ],
  // GB9a
  [Ot.Any, Ot.SpacingMark],
  // GB9b
  [Ot.Prepend, Ot.Any],
  // GB11
  [Ot.ZWJ, Ot.ExtPict],
  // GB12 and GB13
  [Ot.RI, Ot.RI]
];
function pee(e, t) {
  return cee.findIndex((n) => ec(e, n[0]) && ec(t, n[1])) === -1;
}
var dee = /(?:[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u2388\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2605\u2607-\u2612\u2614-\u2685\u2690-\u2705\u2708-\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763-\u2767\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC00-\uDCFF\uDD0D-\uDD0F\uDD2F\uDD6C-\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDAD-\uDDE5\uDE01-\uDE0F\uDE1A\uDE2F\uDE32-\uDE3A\uDE3C-\uDE3F\uDE49-\uDFFA]|\uD83D[\uDC00-\uDD3D\uDD46-\uDE4F\uDE80-\uDEFF\uDF74-\uDF7F\uDFD5-\uDFFF]|\uD83E[\uDC0C-\uDC0F\uDC48-\uDC4F\uDC5A-\uDC5F\uDC88-\uDC8F\uDCAE-\uDCFF\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDEFF]|\uD83F[\uDC00-\uDFFD])(?:[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09BE\u09C1-\u09C4\u09CD\u09D7\u09E2\u09E3\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01\u0B3C\u0B3E\u0B3F\u0B41-\u0B44\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B82\u0BBE\u0BC0\u0BCD\u0BD7\u0C00\u0C04\u0C3C\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CBF\u0CC2\u0CC6\u0CCC\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D3E\u0D41-\u0D44\u0D4D\u0D57\u0D62\u0D63\u0D81\u0DCA\u0DCF\u0DD2-\u0DD4\u0DD6\u0DDF\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732\u1733\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u180F\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ACE\u1B00-\u1B03\u1B34-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DFF\u200C\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA82C\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFF9E\uFF9F]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD803[\uDD24-\uDD27\uDEAB\uDEAC\uDEFD-\uDEFF\uDF46-\uDF50\uDF82-\uDF85]|\uD804[\uDC01\uDC38-\uDC46\uDC70\uDC73\uDC74\uDC7F-\uDC81\uDCB3-\uDCB6\uDCB9\uDCBA\uDCC2\uDD00-\uDD02\uDD27-\uDD2B\uDD2D-\uDD34\uDD73\uDD80\uDD81\uDDB6-\uDDBE\uDDC9-\uDDCC\uDDCF\uDE2F-\uDE31\uDE34\uDE36\uDE37\uDE3E\uDE41\uDEDF\uDEE3-\uDEEA\uDF00\uDF01\uDF3B\uDF3C\uDF3E\uDF40\uDF57\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC38-\uDC3F\uDC42-\uDC44\uDC46\uDC5E\uDCB0\uDCB3-\uDCB8\uDCBA\uDCBD\uDCBF\uDCC0\uDCC2\uDCC3\uDDAF\uDDB2-\uDDB5\uDDBC\uDDBD\uDDBF\uDDC0\uDDDC\uDDDD\uDE33-\uDE3A\uDE3D\uDE3F\uDE40\uDEAB\uDEAD\uDEB0-\uDEB5\uDEB7\uDF1D-\uDF1F\uDF22-\uDF25\uDF27-\uDF2B]|\uD806[\uDC2F-\uDC37\uDC39\uDC3A\uDD30\uDD3B\uDD3C\uDD3E\uDD43\uDDD4-\uDDD7\uDDDA\uDDDB\uDDE0\uDE01-\uDE0A\uDE33-\uDE38\uDE3B-\uDE3E\uDE47\uDE51-\uDE56\uDE59-\uDE5B\uDE8A-\uDE96\uDE98\uDE99]|\uD807[\uDC30-\uDC36\uDC38-\uDC3D\uDC3F\uDC92-\uDCA7\uDCAA-\uDCB0\uDCB2\uDCB3\uDCB5\uDCB6\uDD31-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD45\uDD47\uDD90\uDD91\uDD95\uDD97\uDEF3\uDEF4\uDF00\uDF01\uDF36-\uDF3A\uDF40\uDF42]|\uD80D[\uDC40\uDC47-\uDC55]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF4F\uDF8F-\uDF92\uDFE4]|\uD82F[\uDC9D\uDC9E]|\uD833[\uDF00-\uDF2D\uDF30-\uDF46]|\uD834[\uDD65\uDD67-\uDD69\uDD6E-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A\uDC8F\uDD30-\uDD36\uDEAE\uDEEC-\uDEEF]|\uD839[\uDCEC-\uDCEF]|\uD83A[\uDCD0-\uDCD6\uDD44-\uDD4A]|\uD83C[\uDFFB-\uDFFF]|\uDB40[\uDC20-\uDC7F\uDD00-\uDDEF])*\u200D$/, uM = (e) => e.search(dee) !== -1, fee = /(?:\uD83C[\uDDE6-\uDDFF])+$/g, hee = (e) => {
  var t = e.match(fee);
  if (t === null)
    return !1;
  var n = t[0].length / 2;
  return n % 2 === 1;
}, gee = {
  delete(e, t) {
    e.delete(t);
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertText(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    ee.withoutNormalizing(e, () => {
      var {
        voids: r = !1
      } = n, {
        at: o = D1(e)
      } = n;
      if (ae.isPath(o) && (o = ee.range(e, o)), me.isRange(o))
        if (me.isCollapsed(o))
          o = o.anchor;
        else {
          var i = me.end(o);
          if (!r && ee.void(e, {
            at: i
          }))
            return;
          var a = me.start(o), s = ee.pointRef(e, a), l = ee.pointRef(e, i);
          Te.delete(e, {
            at: o,
            voids: r
          });
          var u = s.unref(), c = l.unref();
          o = u || c, Te.setSelection(e, {
            anchor: o,
            focus: o
          });
        }
      if (!(!r && ee.void(e, {
        at: o
      }) || ee.elementReadOnly(e, {
        at: o
      }))) {
        var {
          path: p,
          offset: d
        } = o;
        t.length > 0 && e.apply({
          type: "insert_text",
          path: p,
          offset: d,
          text: t
        });
      }
    });
  }
};
function cM(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function hh(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? cM(Object(n), !0).forEach(function(r) {
      Go(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : cM(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Te = hh(hh(hh(hh({}, AQ), IQ), RQ), gee), Lm = /* @__PURE__ */ new WeakMap(), mee = (e) => Lm.get(e) || !1, vee = (e, t, n) => {
  var r = Lm.get(e) || !1;
  Lm.set(e, !0);
  try {
    t(), n();
  } finally {
    Lm.set(e, r);
  }
};
function X6(e, t, n) {
  var r = $m.get(e) || [], o = Wm.get(e) || /* @__PURE__ */ new Set(), i, a, s = (p) => {
    if (p) {
      var d = p.join(",");
      a.has(d) || (a.add(d), i.push(p));
    }
  };
  if (n) {
    i = [], a = /* @__PURE__ */ new Set();
    for (var l of r) {
      var u = n(l);
      s(u);
    }
  } else
    i = r, a = o;
  for (var c of t)
    s(c);
  $m.set(e, i), Wm.set(e, a);
}
var yee = (e, t) => {
  for (var n of ee.pathRefs(e))
    _Q.transform(n, t);
  for (var r of ee.pointRefs(e))
    SQ.transform(r, t);
  for (var o of ee.rangeRefs(e))
    MQ.transform(o, t);
  if (!mee(e)) {
    var i = ae.operationCanTransformPath(t) ? (a) => ae.transform(a, t) : void 0;
    X6(e, e.getDirtyPaths(t), i);
  }
  Te.transform(e, t), e.operations.push(t), ee.normalize(e, {
    operation: t
  }), t.type === "set_selection" && (e.marks = null), Fp.get(e) || (Fp.set(e, !0), Promise.resolve().then(() => {
    Fp.set(e, !1), e.onChange({
      operation: t
    }), e.operations = [];
  }));
}, bee = (e, t) => {
  switch (t.type) {
    case "insert_text":
    case "remove_text":
    case "set_node": {
      var {
        path: n
      } = t;
      return ae.levels(n);
    }
    case "insert_node": {
      var {
        node: r,
        path: o
      } = t, i = ae.levels(o), a = it.isText(r) ? [] : Array.from(qe.nodes(r), (N) => {
        var [, R] = N;
        return o.concat(R);
      });
      return [...i, ...a];
    }
    case "merge_node": {
      var {
        path: s
      } = t, l = ae.ancestors(s), u = ae.previous(s);
      return [...l, u];
    }
    case "move_node": {
      var {
        path: c,
        newPath: p
      } = t;
      if (ae.equals(c, p))
        return [];
      var d = [], g = [];
      for (var f of ae.ancestors(c)) {
        var m = ae.transform(f, t);
        d.push(m);
      }
      for (var v of ae.ancestors(p)) {
        var E = ae.transform(v, t);
        g.push(E);
      }
      var w = g[g.length - 1], M = p[p.length - 1], O = w.concat(M);
      return [...d, ...g, O];
    }
    case "remove_node": {
      var {
        path: y
      } = t, C = ae.ancestors(y);
      return [...C];
    }
    case "split_node": {
      var {
        path: _
      } = t, F = ae.levels(_), L = ae.next(_);
      return [...F, L];
    }
    default:
      return [];
  }
}, wee = (e) => {
  var {
    selection: t
  } = e;
  return t ? qe.fragment(e, t) : [];
}, Cee = (e, t) => {
  var [n, r] = t;
  if (!it.isText(n)) {
    if (rt.isElement(n) && n.children.length === 0) {
      var o = {
        text: ""
      };
      Te.insertNodes(e, o, {
        at: r.concat(0),
        voids: !0
      });
      return;
    }
    for (var i = ee.isEditor(n) ? !1 : rt.isElement(n) && (e.isInline(n) || n.children.length === 0 || it.isText(n.children[0]) || e.isInline(n.children[0])), a = 0, s = 0; s < n.children.length; s++, a++) {
      var l = qe.get(e, r);
      if (!it.isText(l)) {
        var u = l.children[a], c = l.children[a - 1], p = s === n.children.length - 1, d = it.isText(u) || rt.isElement(u) && e.isInline(u);
        if (d !== i)
          Te.removeNodes(e, {
            at: r.concat(a),
            voids: !0
          }), a--;
        else if (rt.isElement(u)) {
          if (e.isInline(u)) {
            if (c == null || !it.isText(c)) {
              var g = {
                text: ""
              };
              Te.insertNodes(e, g, {
                at: r.concat(a),
                voids: !0
              }), a++;
            } else if (p) {
              var f = {
                text: ""
              };
              Te.insertNodes(e, f, {
                at: r.concat(a + 1),
                voids: !0
              }), a++;
            }
          }
        } else {
          if (!it.isText(u) && !("children" in u)) {
            var m = u;
            m.children = [];
          }
          c != null && it.isText(c) && (it.equals(u, c, {
            loose: !0
          }) ? (Te.mergeNodes(e, {
            at: r.concat(a),
            voids: !0
          }), a--) : c.text === "" ? (Te.removeNodes(e, {
            at: r.concat(a - 1),
            voids: !0
          }), a--) : u.text === "" && (Te.removeNodes(e, {
            at: r.concat(a),
            voids: !0
          }), a--));
        }
      }
    }
  }
}, xee = (e, t) => {
  var {
    iteration: n,
    initialDirtyPathsLength: r
  } = t, o = r * 42;
  if (n > o)
    throw new Error("Could not completely normalize the editor after ".concat(o, " iterations! This is usually due to incorrect normalization logic that leaves a node in an invalid state."));
  return !0;
}, Oee = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    voids: r = !1,
    mode: o = "lowest",
    at: i = t.selection,
    match: a
  } = n;
  if (i) {
    var s = ee.path(t, i), l = o === "lowest";
    for (var [u, c] of ee.levels(t, {
      at: s,
      voids: r,
      match: a,
      reverse: l
    }))
      if (!it.isText(u)) {
        if (me.isRange(i)) {
          if (ae.isAncestor(c, i.anchor.path) && ae.isAncestor(c, i.focus.path))
            return [u, c];
        } else if (!ae.equals(s, c))
          return [u, c];
      }
  }
};
function pM(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function dM(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? pM(Object(n), !0).forEach(function(r) {
      Go(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : pM(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Eee = (e, t, n) => {
  var {
    selection: r
  } = e;
  if (r) {
    var o = (p, d) => {
      if (!it.isText(p))
        return !1;
      var [g, f] = ee.parent(e, d);
      return !e.isVoid(g) || e.markableVoid(g);
    }, i = me.isExpanded(r), a = !1;
    if (!i) {
      var [s, l] = ee.node(e, r);
      if (s && o(s, l)) {
        var [u] = ee.parent(e, l);
        a = u && e.markableVoid(u);
      }
    }
    if (i || a)
      Te.setNodes(e, {
        [t]: n
      }, {
        match: o,
        split: !0,
        voids: !0
      });
    else {
      var c = dM(dM({}, ee.marks(e) || {}), {}, {
        [t]: n
      });
      e.marks = c, Fp.get(e) || e.onChange();
    }
  }
};
function fM(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function hM(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? fM(Object(n), !0).forEach(function(r) {
      Go(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : fM(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var kee = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, o = ee.point(t, n, {
    edge: "end"
  }), i = ee.end(t, []), a = {
    anchor: o,
    focus: i
  }, {
    distance: s = 1
  } = r, l = 0, u;
  for (var c of ee.positions(t, hM(hM({}, r), {}, {
    at: a
  }))) {
    if (l > s)
      break;
    l !== 0 && (u = c), l++;
  }
  return u;
};
function gM(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function mM(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? gM(Object(n), !0).forEach(function(r) {
      Go(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : gM(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Lee = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, o = ee.start(t, []), i = ee.point(t, n, {
    edge: "start"
  }), a = {
    anchor: o,
    focus: i
  }, {
    distance: s = 1
  } = r, l = 0, u;
  for (var c of ee.positions(t, mM(mM({}, r), {}, {
    at: a,
    reverse: !0
  }))) {
    if (l > s)
      break;
    l !== 0 && (u = c), l++;
  }
  return u;
}, Pee = (e, t) => {
  var {
    selection: n
  } = e;
  n && me.isCollapsed(n) && Te.delete(e, {
    unit: t,
    reverse: !0
  });
}, _ee = (e, t) => {
  var {
    selection: n
  } = e;
  n && me.isCollapsed(n) && Te.delete(e, {
    unit: t
  });
}, See = function(t) {
  var {
    direction: n = "forward"
  } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    selection: r
  } = t;
  r && me.isExpanded(r) && Te.delete(t, {
    reverse: n === "backward"
  });
}, Mee = (e, t) => [ee.start(e, t), ee.end(e, t)];
function vM(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function yM(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? vM(Object(n), !0).forEach(function(r) {
      Go(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : vM(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Dee = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return ee.above(t, yM(yM({}, n), {}, {
    match: (r) => rt.isElement(r) && ee.isElementReadOnly(t, r)
  }));
}, Tee = (e, t) => ee.point(e, t, {
  edge: "end"
}), jee = (e, t) => {
  var n = ee.path(e, t, {
    edge: "start"
  });
  return ee.node(e, n);
}, Aee = (e, t) => {
  var n = ee.range(e, t);
  return qe.fragment(e, n);
};
function bM(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function wM(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? bM(Object(n), !0).forEach(function(r) {
      Go(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : bM(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Iee = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return ee.above(t, wM(wM({}, n), {}, {
    match: (r) => rt.isElement(r) && ee.isVoid(t, r)
  }));
}, Ree = (e, t) => t.children.some((n) => rt.isElement(n) && ee.isBlock(e, n)), Bee = (e, t) => t.children.some((n) => it.isText(n) || ee.isInline(e, n)), Nee = (e, t) => qe.has(e, t), Fee = (e, t) => t.children.every((n) => it.isText(n)), zee = (e) => {
  Te.splitNodes(e, {
    always: !0
  });
}, Uee = (e, t, n) => {
  Te.insertNodes(e, t, n);
}, Hee = (e) => {
  Te.splitNodes(e, {
    always: !0
  });
};
function CM(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function $ee(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? CM(Object(n), !0).forEach(function(r) {
      Go(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : CM(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Wee = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    selection: o,
    marks: i
  } = t;
  if (o) {
    if (i) {
      var a = $ee({
        text: n
      }, i);
      Te.insertNodes(t, a, {
        at: r.at,
        voids: r.voids
      });
    } else
      Te.insertText(t, n, r);
    t.marks = null;
  }
}, Vee = (e, t) => !e.isInline(t), Zee = (e, t, n) => ee.isStart(e, t, n) || ee.isEnd(e, t, n), qee = (e, t) => {
  var {
    children: n
  } = t, [r] = n;
  return n.length === 0 || n.length === 1 && it.isText(r) && r.text === "" && !e.isVoid(t);
}, Gee = (e, t, n) => {
  var r = ee.end(e, n);
  return Nt.equals(t, r);
}, Kee = (e) => {
  var t = K6.get(e);
  return t === void 0 ? !0 : t;
}, Yee = (e, t, n) => {
  if (t.offset !== 0)
    return !1;
  var r = ee.start(e, n);
  return Nt.equals(t, r);
}, Xee = (e, t) => {
  var n = ee.path(e, t, {
    edge: "end"
  });
  return ee.node(e, n);
}, Jee = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, o = ee.path(t, n, r), i = qe.leaf(t, o);
  return [i, o];
};
function Qee(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return function* () {
    var {
      at: n = e.selection,
      reverse: r = !1,
      voids: o = !1
    } = t, {
      match: i
    } = t;
    if (i == null && (i = () => !0), !!n) {
      var a = [], s = ee.path(e, n);
      for (var [l, u] of qe.levels(e, s))
        if (i(l, u) && (a.push([l, u]), !o && rt.isElement(l) && ee.isVoid(e, l)))
          break;
      r && a.reverse(), yield* a;
    }
  }();
}
var ete = ["text"], tte = ["text"], nte = function(t) {
  var {
    marks: n,
    selection: r
  } = t;
  if (!r)
    return null;
  var {
    anchor: o,
    focus: i
  } = r;
  if (n)
    return n;
  if (me.isExpanded(r)) {
    var a = ee.isEnd(t, o, o.path);
    if (a) {
      var s = ee.after(t, o);
      s && (o = s);
    }
    var [l] = ee.nodes(t, {
      match: it.isText,
      at: {
        anchor: o,
        focus: i
      }
    });
    if (l) {
      var [u] = l, c = aa(u, ete);
      return c;
    } else
      return {};
  }
  var {
    path: p
  } = o, [d] = ee.leaf(t, p);
  if (o.offset === 0) {
    var g = ee.previous(t, {
      at: p,
      match: it.isText
    }), f = ee.above(t, {
      match: (O) => rt.isElement(O) && ee.isVoid(t, O) && t.markableVoid(O)
    });
    if (!f) {
      var m = ee.above(t, {
        match: (O) => rt.isElement(O) && ee.isBlock(t, O)
      });
      if (g && m) {
        var [v, E] = g, [, w] = m;
        ae.isAncestor(w, E) && (d = v);
      }
    }
  }
  var M = aa(d, tte);
  return M;
}, rte = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    mode: r = "lowest",
    voids: o = !1
  } = n, {
    match: i,
    at: a = t.selection
  } = n;
  if (a) {
    var s = ee.after(t, a, {
      voids: o
    });
    if (s) {
      var [, l] = ee.last(t, []), u = [s.path, l];
      if (ae.isPath(a) && a.length === 0)
        throw new Error("Cannot get the next node from the root node!");
      if (i == null)
        if (ae.isPath(a)) {
          var [c] = ee.parent(t, a);
          i = (d) => c.children.includes(d);
        } else
          i = () => !0;
      var [p] = ee.nodes(t, {
        at: u,
        match: i,
        mode: r,
        voids: o
      });
      return p;
    }
  }
}, ote = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, o = ee.path(t, n, r), i = qe.get(t, o);
  return [i, o];
};
function ite(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return function* () {
    var {
      at: n = e.selection,
      mode: r = "all",
      universal: o = !1,
      reverse: i = !1,
      voids: a = !1,
      ignoreNonSelectable: s = !1
    } = t, {
      match: l
    } = t;
    if (l || (l = () => !0), !!n) {
      var u, c;
      if ($Q.isSpan(n))
        u = n[0], c = n[1];
      else {
        var p = ee.path(e, n, {
          edge: "start"
        }), d = ee.path(e, n, {
          edge: "end"
        });
        u = i ? d : p, c = i ? p : d;
      }
      var g = qe.nodes(e, {
        reverse: i,
        from: u,
        to: c,
        pass: (O) => {
          var [y] = O;
          return rt.isElement(y) ? !!(!a && (ee.isVoid(e, y) || ee.isElementReadOnly(e, y)) || s && !ee.isSelectable(e, y)) : !1;
        }
      }), f = [], m;
      for (var [v, E] of g)
        if (!(s && rt.isElement(v) && !ee.isSelectable(e, v))) {
          var w = m && ae.compare(E, m[1]) === 0;
          if (!(r === "highest" && w)) {
            if (!l(v, E)) {
              if (o && !w && it.isText(v))
                return;
              continue;
            }
            if (r === "lowest" && w) {
              m = [v, E];
              continue;
            }
            var M = r === "lowest" ? m : [v, E];
            M && (o ? f.push(M) : yield M), m = [v, E];
          }
        }
      r === "lowest" && m && (o ? f.push(m) : yield m), o && (yield* f);
    }
  }();
}
var ste = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    force: r = !1,
    operation: o
  } = n, i = (c) => $m.get(c) || [], a = (c) => Wm.get(c) || /* @__PURE__ */ new Set(), s = (c) => {
    var p = i(c).pop(), d = p.join(",");
    return a(c).delete(d), p;
  };
  if (ee.isNormalizing(t)) {
    if (r) {
      var l = Array.from(qe.nodes(t), (c) => {
        var [, p] = c;
        return p;
      }), u = new Set(l.map((c) => c.join(",")));
      $m.set(t, l), Wm.set(t, u);
    }
    i(t).length !== 0 && ee.withoutNormalizing(t, () => {
      for (var c of i(t))
        if (qe.has(t, c)) {
          var p = ee.node(t, c), [d, g] = p;
          rt.isElement(d) && d.children.length === 0 && t.normalizeNode(p, {
            operation: o
          });
        }
      for (var f = i(t), m = f.length, v = 0; f.length !== 0; ) {
        if (!t.shouldNormalize({
          dirtyPaths: f,
          iteration: v,
          initialDirtyPathsLength: m,
          operation: o
        }))
          return;
        var E = s(t);
        if (qe.has(t, E)) {
          var w = ee.node(t, E);
          t.normalizeNode(w, {
            operation: o
          });
        }
        v++, f = i(t);
      }
    });
  }
}, ate = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, o = ee.path(t, n, r), i = ae.parent(o), a = ee.node(t, i);
  return a;
}, lte = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    affinity: o = "forward"
  } = r, i = {
    current: n,
    affinity: o,
    unref() {
      var {
        current: s
      } = i, l = ee.pathRefs(t);
      return l.delete(i), i.current = null, s;
    }
  }, a = ee.pathRefs(t);
  return a.add(i), i;
}, ute = (e) => {
  var t = YS.get(e);
  return t || (t = /* @__PURE__ */ new Set(), YS.set(e, t)), t;
}, cte = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    depth: o,
    edge: i
  } = r;
  if (ae.isPath(n)) {
    if (i === "start") {
      var [, a] = qe.first(t, n);
      n = a;
    } else if (i === "end") {
      var [, s] = qe.last(t, n);
      n = s;
    }
  }
  return me.isRange(n) && (i === "start" ? n = me.start(n) : i === "end" ? n = me.end(n) : n = ae.common(n.anchor.path, n.focus.path)), Nt.isPoint(n) && (n = n.path), o != null && (n = n.slice(0, o)), n;
}, pte = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    affinity: o = "forward"
  } = r, i = {
    current: n,
    affinity: o,
    unref() {
      var {
        current: s
      } = i, l = ee.pointRefs(t);
      return l.delete(i), i.current = null, s;
    }
  }, a = ee.pointRefs(t);
  return a.add(i), i;
}, dte = (e) => {
  var t = XS.get(e);
  return t || (t = /* @__PURE__ */ new Set(), XS.set(e, t)), t;
}, fte = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    edge: o = "start"
  } = r;
  if (ae.isPath(n)) {
    var i;
    if (o === "end") {
      var [, a] = qe.last(t, n);
      i = a;
    } else {
      var [, s] = qe.first(t, n);
      i = s;
    }
    var l = qe.get(t, i);
    if (!it.isText(l))
      throw new Error("Cannot get the ".concat(o, " point in the node at path [").concat(n, "] because it has no ").concat(o, " text node."));
    return {
      path: i,
      offset: o === "end" ? l.text.length : 0
    };
  }
  if (me.isRange(n)) {
    var [u, c] = me.edges(n);
    return o === "start" ? u : c;
  }
  return n;
};
function hte(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return function* () {
    var {
      at: n = e.selection,
      unit: r = "offset",
      reverse: o = !1,
      voids: i = !1,
      ignoreNonSelectable: a = !1
    } = t;
    if (!n)
      return;
    var s = ee.range(e, n), [l, u] = me.edges(s), c = o ? u : l, p = !1, d = "", g = 0, f = 0, m = 0;
    for (var [v, E] of ee.nodes(e, {
      at: n,
      reverse: o,
      voids: i,
      ignoreNonSelectable: a
    })) {
      if (rt.isElement(v)) {
        if (!i && (e.isVoid(v) || e.isElementReadOnly(v))) {
          yield ee.start(e, E);
          continue;
        }
        if (e.isInline(v)) continue;
        if (ee.hasInlines(e, v)) {
          var w = ae.isAncestor(E, u.path) ? u : ee.end(e, E), M = ae.isAncestor(E, l.path) ? l : ee.start(e, E);
          d = ee.string(e, {
            anchor: M,
            focus: w
          }, {
            voids: i
          }), p = !0;
        }
      }
      if (it.isText(v)) {
        var O = ae.equals(E, c.path);
        for (O ? (f = o ? c.offset : v.text.length - c.offset, m = c.offset) : (f = v.text.length, m = o ? f : 0), (O || p || r === "offset") && (yield {
          path: E,
          offset: m
        }, p = !1); ; ) {
          if (g === 0) {
            if (d === "") break;
            g = y(d, r, o), d = j1(d, g, o)[1];
          }
          if (m = o ? m - g : m + g, f = f - g, f < 0) {
            g = -f;
            break;
          }
          g = 0, yield {
            path: E,
            offset: m
          };
        }
      }
    }
    function y(C, _, F) {
      return _ === "character" ? T1(C, F) : _ === "word" ? KQ(C, F) : _ === "line" || _ === "block" ? C.length : 1;
    }
  }();
}
var gte = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    mode: r = "lowest",
    voids: o = !1
  } = n, {
    match: i,
    at: a = t.selection
  } = n;
  if (a) {
    var s = ee.before(t, a, {
      voids: o
    });
    if (s) {
      var [, l] = ee.first(t, []), u = [s.path, l];
      if (ae.isPath(a) && a.length === 0)
        throw new Error("Cannot get the previous node from the root node!");
      if (i == null)
        if (ae.isPath(a)) {
          var [c] = ee.parent(t, a);
          i = (d) => c.children.includes(d);
        } else
          i = () => !0;
      var [p] = ee.nodes(t, {
        reverse: !0,
        at: u,
        match: i,
        mode: r,
        voids: o
      });
      return p;
    }
  }
}, mte = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    affinity: o = "forward"
  } = r, i = {
    current: n,
    affinity: o,
    unref() {
      var {
        current: s
      } = i, l = ee.rangeRefs(t);
      return l.delete(i), i.current = null, s;
    }
  }, a = ee.rangeRefs(t);
  return a.add(i), i;
}, vte = (e) => {
  var t = JS.get(e);
  return t || (t = /* @__PURE__ */ new Set(), JS.set(e, t)), t;
}, yte = (e, t, n) => {
  if (me.isRange(t) && !n)
    return t;
  var r = ee.start(e, t), o = ee.end(e, n || t);
  return {
    anchor: r,
    focus: o
  };
};
function xM(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function bte(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? xM(Object(n), !0).forEach(function(r) {
      Go(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : xM(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var wte = (e, t) => {
  var {
    selection: n
  } = e;
  if (n) {
    var r = (c, p) => {
      if (!it.isText(c))
        return !1;
      var [d, g] = ee.parent(e, p);
      return !e.isVoid(d) || e.markableVoid(d);
    }, o = me.isExpanded(n), i = !1;
    if (!o) {
      var [a, s] = ee.node(e, n);
      if (a && r(a, s)) {
        var [l] = ee.parent(e, s);
        i = l && e.markableVoid(l);
      }
    }
    if (o || i)
      Te.unsetNodes(e, t, {
        match: r,
        split: !0,
        voids: !0
      });
    else {
      var u = bte({}, ee.marks(e) || {});
      delete u[t], e.marks = u, Fp.get(e) || e.onChange();
    }
  }
}, Cte = (e, t) => {
  K6.set(e, t);
}, xte = (e, t) => ee.point(e, t, {
  edge: "start"
}), Ote = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    voids: o = !1
  } = r, i = ee.range(t, n), [a, s] = me.edges(i), l = "";
  for (var [u, c] of ee.nodes(t, {
    at: i,
    match: it.isText,
    voids: o
  })) {
    var p = u.text;
    ae.equals(c, s.path) && (p = p.slice(0, s.offset)), ae.equals(c, a.path) && (p = p.slice(a.offset)), l += p;
  }
  return l;
}, Ete = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    voids: o = !1
  } = r, [i, a] = me.edges(n);
  if (i.offset !== 0 || a.offset !== 0 || me.isCollapsed(n) || ae.hasPrevious(a.path))
    return n;
  var s = ee.above(t, {
    at: a,
    match: (f) => rt.isElement(f) && ee.isBlock(t, f),
    voids: o
  }), l = s ? s[1] : [], u = ee.start(t, i), c = {
    anchor: u,
    focus: a
  }, p = !0;
  for (var [d, g] of ee.nodes(t, {
    at: c,
    match: it.isText,
    reverse: !0,
    voids: o
  })) {
    if (p) {
      p = !1;
      continue;
    }
    if (d.text !== "" || ae.isBefore(g, l)) {
      a = {
        path: g,
        offset: d.text.length
      };
      break;
    }
  }
  return {
    anchor: i,
    focus: a
  };
}, kte = (e, t) => {
  var n = ee.isNormalizing(e);
  ee.setNormalizing(e, !1);
  try {
    t();
  } finally {
    ee.setNormalizing(e, n);
  }
  ee.normalize(e);
}, Lte = (e, t, n) => {
  var [r, o] = t;
  return rt.isElement(r) && ee.isEmpty(e, r) || it.isText(r) && r.text === "" && o[o.length - 1] !== 0;
}, Pte = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  ee.withoutNormalizing(t, () => {
    var r, o, {
      reverse: i = !1,
      unit: a = "character",
      distance: s = 1,
      voids: l = !1
    } = n, {
      at: u = t.selection,
      hanging: c = !1
    } = n;
    if (u) {
      var p = !1;
      if (me.isRange(u) && me.isCollapsed(u) && (p = !0, u = u.anchor), Nt.isPoint(u)) {
        var d = ee.void(t, {
          at: u,
          mode: "highest"
        });
        if (!l && d) {
          var [, g] = d;
          u = g;
        } else {
          var f = {
            unit: a,
            distance: s
          }, m = i ? ee.before(t, u, f) || ee.start(t, []) : ee.after(t, u, f) || ee.end(t, []);
          u = {
            anchor: u,
            focus: m
          }, c = !0;
        }
      }
      if (ae.isPath(u)) {
        Te.removeNodes(t, {
          at: u,
          voids: l
        });
        return;
      }
      if (!me.isCollapsed(u)) {
        if (!c) {
          var [, v] = me.edges(u), E = ee.end(t, []);
          Nt.equals(v, E) || (u = ee.unhangRange(t, u, {
            voids: l
          }));
        }
        var [w, M] = me.edges(u), O = ee.above(t, {
          match: (fe) => rt.isElement(fe) && ee.isBlock(t, fe),
          at: w,
          voids: l
        }), y = ee.above(t, {
          match: (fe) => rt.isElement(fe) && ee.isBlock(t, fe),
          at: M,
          voids: l
        }), C = O && y && !ae.equals(O[1], y[1]), _ = ae.equals(w.path, M.path), F = l ? null : (r = ee.void(t, {
          at: w,
          mode: "highest"
        })) !== null && r !== void 0 ? r : ee.elementReadOnly(t, {
          at: w,
          mode: "highest"
        }), L = l ? null : (o = ee.void(t, {
          at: M,
          mode: "highest"
        })) !== null && o !== void 0 ? o : ee.elementReadOnly(t, {
          at: M,
          mode: "highest"
        });
        if (F) {
          var N = ee.before(t, w);
          N && O && ae.isAncestor(O[1], N.path) && (w = N);
        }
        if (L) {
          var R = ee.after(t, M);
          R && y && ae.isAncestor(y[1], R.path) && (M = R);
        }
        var W = [], V;
        for (var z of ee.nodes(t, {
          at: u,
          voids: l
        })) {
          var [Z, K] = z;
          V && ae.compare(K, V) === 0 || (!l && rt.isElement(Z) && (ee.isVoid(t, Z) || ee.isElementReadOnly(t, Z)) || !ae.isCommon(K, w.path) && !ae.isCommon(K, M.path)) && (W.push(z), V = K);
        }
        var X = Array.from(W, (fe) => {
          var [, oe] = fe;
          return ee.pathRef(t, oe);
        }), te = ee.pointRef(t, w), J = ee.pointRef(t, M), P = "";
        if (!_ && !F) {
          var D = te.current, [H] = ee.leaf(t, D), {
            path: S
          } = D, {
            offset: $
          } = w, x = H.text.slice($);
          x.length > 0 && (t.apply({
            type: "remove_text",
            path: S,
            offset: $,
            text: x
          }), P = x);
        }
        if (X.reverse().map((fe) => fe.unref()).filter((fe) => fe !== null).forEach((fe) => Te.removeNodes(t, {
          at: fe,
          voids: l
        })), !L) {
          var j = J.current, [U] = ee.leaf(t, j), {
            path: T
          } = j, q = _ ? w.offset : 0, A = U.text.slice(q, M.offset);
          A.length > 0 && (t.apply({
            type: "remove_text",
            path: T,
            offset: q,
            text: A
          }), P = A);
        }
        !_ && C && J.current && te.current && Te.mergeNodes(t, {
          at: J.current,
          hanging: !0,
          voids: l
        }), p && i && a === "character" && P.length > 1 && P.match(/[\u0E00-\u0E7F]+/) && Te.insertText(t, P.slice(0, P.length - s));
        var Y = te.unref(), B = J.unref(), ue = i ? Y || B : B || Y;
        n.at == null && ue && Te.select(t, ue);
      }
    }
  });
}, _te = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  ee.withoutNormalizing(t, () => {
    var {
      hanging: o = !1,
      voids: i = !1
    } = r, {
      at: a = D1(t),
      batchDirty: s = !0
    } = r;
    if (n.length) {
      if (me.isRange(a))
        if (o || (a = ee.unhangRange(t, a, {
          voids: i
        })), me.isCollapsed(a))
          a = a.anchor;
        else {
          var [, l] = me.edges(a);
          if (!i && ee.void(t, {
            at: l
          }))
            return;
          var u = ee.pointRef(t, l);
          Te.delete(t, {
            at: a
          }), a = u.unref();
        }
      else ae.isPath(a) && (a = ee.start(t, a));
      if (!(!i && ee.void(t, {
        at: a
      }))) {
        var c = ee.above(t, {
          at: a,
          match: (x) => rt.isElement(x) && ee.isInline(t, x),
          mode: "highest",
          voids: i
        });
        if (c) {
          var [, p] = c;
          if (ee.isEnd(t, a, p)) {
            var d = ee.after(t, p);
            a = d;
          } else if (ee.isStart(t, a, p)) {
            var g = ee.before(t, p);
            a = g;
          }
        }
        var f = ee.above(t, {
          match: (x) => rt.isElement(x) && ee.isBlock(t, x),
          at: a,
          voids: i
        }), [, m] = f, v = ee.isStart(t, a, m), E = ee.isEnd(t, a, m), w = v && E, M = !v || v && E, O = !E, [, y] = qe.first({
          children: n
        }, []), [, C] = qe.last({
          children: n
        }, []), _ = [], F = (x) => {
          var [j, U] = x, T = U.length === 0;
          return T ? !1 : w ? !0 : !(M && ae.isAncestor(U, y) && rt.isElement(j) && !t.isVoid(j) && !t.isInline(j) || O && ae.isAncestor(U, C) && rt.isElement(j) && !t.isVoid(j) && !t.isInline(j));
        };
        for (var L of qe.nodes({
          children: n
        }, {
          pass: F
        }))
          F(L) && _.push(L);
        var N = [], R = [], W = [], V = !0, z = !1;
        for (var [Z] of _)
          rt.isElement(Z) && !t.isInline(Z) ? (V = !1, z = !0, R.push(Z)) : V ? N.push(Z) : W.push(Z);
        var [K] = ee.nodes(t, {
          at: a,
          match: (x) => it.isText(x) || ee.isInline(t, x),
          mode: "highest",
          voids: i
        }), [, X] = K, te = ee.isStart(t, a, X), J = ee.isEnd(t, a, X), P = ee.pathRef(t, E && !W.length ? ae.next(m) : m), D = ee.pathRef(t, J ? ae.next(X) : X);
        Te.splitNodes(t, {
          at: a,
          match: (x) => z ? rt.isElement(x) && ee.isBlock(t, x) : it.isText(x) || ee.isInline(t, x),
          mode: z ? "lowest" : "highest",
          always: z && (!v || N.length > 0) && (!E || W.length > 0),
          voids: i
        });
        var H = ee.pathRef(t, !te || te && J ? ae.next(X) : X);
        if (Te.insertNodes(t, N, {
          at: H.current,
          match: (x) => it.isText(x) || ee.isInline(t, x),
          mode: "highest",
          voids: i,
          batchDirty: s
        }), w && !N.length && R.length && !W.length && Te.delete(t, {
          at: m,
          voids: i
        }), Te.insertNodes(t, R, {
          at: P.current,
          match: (x) => rt.isElement(x) && ee.isBlock(t, x),
          mode: "lowest",
          voids: i,
          batchDirty: s
        }), Te.insertNodes(t, W, {
          at: D.current,
          match: (x) => it.isText(x) || ee.isInline(t, x),
          mode: "highest",
          voids: i,
          batchDirty: s
        }), !r.at) {
          var S;
          if (W.length > 0 && D.current ? S = ae.previous(D.current) : R.length > 0 && P.current ? S = ae.previous(P.current) : H.current && (S = ae.previous(H.current)), S) {
            var $ = ee.end(t, S);
            Te.select(t, $);
          }
        }
        H.unref(), P.unref(), D.unref();
      }
    }
  });
}, Ste = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    edge: r = "anchor"
  } = n, {
    selection: o
  } = t;
  if (o) {
    if (r === "anchor")
      Te.select(t, o.anchor);
    else if (r === "focus")
      Te.select(t, o.focus);
    else if (r === "start") {
      var [i] = me.edges(o);
      Te.select(t, i);
    } else if (r === "end") {
      var [, a] = me.edges(o);
      Te.select(t, a);
    }
  } else return;
}, Mte = (e) => {
  var {
    selection: t
  } = e;
  t && e.apply({
    type: "set_selection",
    properties: t,
    newProperties: null
  });
}, Dte = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    selection: r
  } = t, {
    distance: o = 1,
    unit: i = "character",
    reverse: a = !1
  } = n, {
    edge: s = null
  } = n;
  if (r) {
    s === "start" && (s = me.isBackward(r) ? "focus" : "anchor"), s === "end" && (s = me.isBackward(r) ? "anchor" : "focus");
    var {
      anchor: l,
      focus: u
    } = r, c = {
      distance: o,
      unit: i,
      ignoreNonSelectable: !0
    }, p = {};
    if (s == null || s === "anchor") {
      var d = a ? ee.before(t, l, c) : ee.after(t, l, c);
      d && (p.anchor = d);
    }
    if (s == null || s === "focus") {
      var g = a ? ee.before(t, u, c) : ee.after(t, u, c);
      g && (p.focus = g);
    }
    Te.setSelection(t, p);
  }
}, Tte = (e, t) => {
  var {
    selection: n
  } = e;
  if (t = ee.range(e, t), n) {
    Te.setSelection(e, t);
    return;
  }
  if (!me.isRange(t))
    throw new Error("When setting the selection and the current selection is `null` you must provide at least an `anchor` and `focus`, but you passed: ".concat(ko.stringify(t)));
  e.apply({
    type: "set_selection",
    properties: n,
    newProperties: t
  });
};
function OM(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function EM(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? OM(Object(n), !0).forEach(function(r) {
      Go(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : OM(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var jte = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    selection: o
  } = t, {
    edge: i = "both"
  } = r;
  if (o) {
    i === "start" && (i = me.isBackward(o) ? "focus" : "anchor"), i === "end" && (i = me.isBackward(o) ? "anchor" : "focus");
    var {
      anchor: a,
      focus: s
    } = o, l = i === "anchor" ? a : s;
    Te.setSelection(t, {
      [i === "anchor" ? "anchor" : "focus"]: EM(EM({}, l), n)
    });
  }
}, Ate = (e, t) => {
  var {
    selection: n
  } = e, r = {}, o = {};
  if (n) {
    for (var i in t)
      (i === "anchor" && t.anchor != null && !Nt.equals(t.anchor, n.anchor) || i === "focus" && t.focus != null && !Nt.equals(t.focus, n.focus) || i !== "anchor" && i !== "focus" && t[i] !== n[i]) && (r[i] = n[i], o[i] = t[i]);
    Object.keys(r).length > 0 && e.apply({
      type: "set_selection",
      properties: r,
      newProperties: o
    });
  }
}, Ite = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  ee.withoutNormalizing(t, () => {
    var {
      hanging: o = !1,
      voids: i = !1,
      mode: a = "lowest",
      batchDirty: s = !0
    } = r, {
      at: l,
      match: u,
      select: c
    } = r;
    if (qe.isNode(n) && (n = [n]), n.length !== 0) {
      var [p] = n;
      if (l || (l = D1(t), c !== !1 && (c = !0)), c == null && (c = !1), me.isRange(l))
        if (o || (l = ee.unhangRange(t, l, {
          voids: i
        })), me.isCollapsed(l))
          l = l.anchor;
        else {
          var [, d] = me.edges(l), g = ee.pointRef(t, d);
          Te.delete(t, {
            at: l
          }), l = g.unref();
        }
      if (Nt.isPoint(l)) {
        u == null && (it.isText(p) ? u = (N) => it.isText(N) : t.isInline(p) ? u = (N) => it.isText(N) || ee.isInline(t, N) : u = (N) => rt.isElement(N) && ee.isBlock(t, N));
        var [f] = ee.nodes(t, {
          at: l.path,
          match: u,
          mode: a,
          voids: i
        });
        if (f) {
          var [, m] = f, v = ee.pathRef(t, m), E = ee.isEnd(t, l, m);
          Te.splitNodes(t, {
            at: l,
            match: u,
            mode: a,
            voids: i
          });
          var w = v.unref();
          l = E ? ae.next(w) : w;
        } else
          return;
      }
      var M = ae.parent(l), O = l[l.length - 1];
      if (!(!i && ee.void(t, {
        at: M
      }))) {
        if (s) {
          var y = [], C = ae.levels(M);
          vee(t, () => {
            var N = function() {
              var V = M.concat(O);
              O++;
              var z = {
                type: "insert_node",
                path: V,
                node: R
              };
              t.apply(z), l = ae.next(l), y.push(z), it.isText ? C.push(...Array.from(qe.nodes(R), (Z) => {
                var [, K] = Z;
                return V.concat(K);
              })) : C.push(V);
            };
            for (var R of n)
              N();
          }, () => {
            X6(t, C, (N) => {
              var R = N;
              for (var W of y)
                if (ae.operationCanTransformPath(W) && (R = ae.transform(R, W), !R))
                  return null;
              return R;
            });
          });
        } else
          for (var _ of n) {
            var F = M.concat(O);
            O++, t.apply({
              type: "insert_node",
              path: F,
              node: _
            }), l = ae.next(l);
          }
        if (l = ae.previous(l), c) {
          var L = ee.end(t, l);
          L && Te.select(t, L);
        }
      }
    }
  });
}, Rte = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  ee.withoutNormalizing(t, () => {
    var {
      at: r = t.selection,
      mode: o = "lowest",
      voids: i = !1
    } = n, {
      match: a
    } = n;
    if (a == null && (a = ae.isPath(r) ? Cc(t, r) : (O) => rt.isElement(O) && ee.isBlock(t, O)), !!r) {
      var s = ee.nodes(t, {
        at: r,
        match: a,
        mode: o,
        voids: i
      }), l = Array.from(s, (O) => {
        var [, y] = O;
        return ee.pathRef(t, y);
      });
      for (var u of l) {
        var c = u.unref();
        if (c.length < 2)
          throw new Error("Cannot lift node at a path [".concat(c, "] because it has a depth of less than `2`."));
        var p = ee.node(t, ae.parent(c)), [d, g] = p, f = c[c.length - 1], {
          length: m
        } = d.children;
        if (m === 1) {
          var v = ae.next(g);
          Te.moveNodes(t, {
            at: c,
            to: v,
            voids: i
          }), Te.removeNodes(t, {
            at: g,
            voids: i
          });
        } else if (f === 0)
          Te.moveNodes(t, {
            at: c,
            to: g,
            voids: i
          });
        else if (f === m - 1) {
          var E = ae.next(g);
          Te.moveNodes(t, {
            at: c,
            to: E,
            voids: i
          });
        } else {
          var w = ae.next(c), M = ae.next(g);
          Te.splitNodes(t, {
            at: w,
            voids: i
          }), Te.moveNodes(t, {
            at: c,
            to: M,
            voids: i
          });
        }
      }
    }
  });
}, Bte = ["text"], Nte = ["children"], J6 = (e, t) => {
  if (rt.isElement(t)) {
    var n = t;
    return ee.isVoid(e, t) ? !0 : n.children.length === 1 ? J6(e, n.children[0]) : !1;
  } else return !ee.isEditor(t);
}, Fte = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  ee.withoutNormalizing(t, () => {
    var {
      match: r,
      at: o = t.selection
    } = n, {
      hanging: i = !1,
      voids: a = !1,
      mode: s = "lowest"
    } = n;
    if (o) {
      if (r == null)
        if (ae.isPath(o)) {
          var [l] = ee.parent(t, o);
          r = (N) => l.children.includes(N);
        } else
          r = (N) => rt.isElement(N) && ee.isBlock(t, N);
      if (!i && me.isRange(o) && (o = ee.unhangRange(t, o, {
        voids: a
      })), me.isRange(o))
        if (me.isCollapsed(o))
          o = o.anchor;
        else {
          var [, u] = me.edges(o), c = ee.pointRef(t, u);
          Te.delete(t, {
            at: o
          }), o = c.unref(), n.at == null && Te.select(t, o);
        }
      var [p] = ee.nodes(t, {
        at: o,
        match: r,
        voids: a,
        mode: s
      }), d = ee.previous(t, {
        at: o,
        match: r,
        voids: a,
        mode: s
      });
      if (!(!p || !d)) {
        var [g, f] = p, [m, v] = d;
        if (!(f.length === 0 || v.length === 0)) {
          var E = ae.next(v), w = ae.common(f, v), M = ae.isSibling(f, v), O = Array.from(ee.levels(t, {
            at: f
          }), (N) => {
            var [R] = N;
            return R;
          }).slice(w.length).slice(0, -1), y = ee.above(t, {
            at: f,
            mode: "highest",
            match: (N) => O.includes(N) && J6(t, N)
          }), C = y && ee.pathRef(t, y[1]), _, F;
          if (it.isText(g) && it.isText(m)) {
            var L = aa(g, Bte);
            F = m.text.length, _ = L;
          } else if (rt.isElement(g) && rt.isElement(m)) {
            var L = aa(g, Nte);
            F = m.children.length, _ = L;
          } else
            throw new Error("Cannot merge the node at path [".concat(f, "] with the previous sibling because it is not the same kind: ").concat(ko.stringify(g), " ").concat(ko.stringify(m)));
          M || Te.moveNodes(t, {
            at: f,
            to: E,
            voids: a
          }), C && Te.removeNodes(t, {
            at: C.current,
            voids: a
          }), ee.shouldMergeNodesRemovePrevNode(t, d, p) ? Te.removeNodes(t, {
            at: v,
            voids: a
          }) : t.apply({
            type: "merge_node",
            path: E,
            position: F,
            properties: _
          }), C && C.unref();
        }
      }
    }
  });
}, zte = (e, t) => {
  ee.withoutNormalizing(e, () => {
    var {
      to: n,
      at: r = e.selection,
      mode: o = "lowest",
      voids: i = !1
    } = t, {
      match: a
    } = t;
    if (r) {
      a == null && (a = ae.isPath(r) ? Cc(e, r) : (g) => rt.isElement(g) && ee.isBlock(e, g));
      var s = ee.pathRef(e, n), l = ee.nodes(e, {
        at: r,
        match: a,
        mode: o,
        voids: i
      }), u = Array.from(l, (g) => {
        var [, f] = g;
        return ee.pathRef(e, f);
      });
      for (var c of u) {
        var p = c.unref(), d = s.current;
        p.length !== 0 && e.apply({
          type: "move_node",
          path: p,
          newPath: d
        }), s.current && ae.isSibling(d, p) && ae.isAfter(d, p) && (s.current = ae.next(s.current));
      }
      s.unref();
    }
  });
}, Ute = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  ee.withoutNormalizing(t, () => {
    var {
      hanging: r = !1,
      voids: o = !1,
      mode: i = "lowest"
    } = n, {
      at: a = t.selection,
      match: s
    } = n;
    if (a) {
      s == null && (s = ae.isPath(a) ? Cc(t, a) : (g) => rt.isElement(g) && ee.isBlock(t, g)), !r && me.isRange(a) && (a = ee.unhangRange(t, a, {
        voids: o
      }));
      var l = ee.nodes(t, {
        at: a,
        match: s,
        mode: i,
        voids: o
      }), u = Array.from(l, (g) => {
        var [, f] = g;
        return ee.pathRef(t, f);
      });
      for (var c of u) {
        var p = c.unref();
        if (p) {
          var [d] = ee.node(t, p);
          t.apply({
            type: "remove_node",
            path: p,
            node: d
          });
        }
      }
    }
  });
}, Hte = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  ee.withoutNormalizing(t, () => {
    var {
      match: o,
      at: i = t.selection,
      compare: a,
      merge: s
    } = r, {
      hanging: l = !1,
      mode: u = "lowest",
      split: c = !1,
      voids: p = !1
    } = r;
    if (i) {
      if (o == null && (o = ae.isPath(i) ? Cc(t, i) : (F) => rt.isElement(F) && ee.isBlock(t, F)), !l && me.isRange(i) && (i = ee.unhangRange(t, i, {
        voids: p
      })), c && me.isRange(i)) {
        if (me.isCollapsed(i) && ee.leaf(t, i.anchor)[0].text.length > 0)
          return;
        var d = ee.rangeRef(t, i, {
          affinity: "inward"
        }), [g, f] = me.edges(i), m = u === "lowest" ? "lowest" : "highest", v = ee.isEnd(t, f, f.path);
        Te.splitNodes(t, {
          at: f,
          match: o,
          mode: m,
          voids: p,
          always: !v
        });
        var E = ee.isStart(t, g, g.path);
        Te.splitNodes(t, {
          at: g,
          match: o,
          mode: m,
          voids: p,
          always: !E
        }), i = d.unref(), r.at == null && Te.select(t, i);
      }
      a || (a = (F, L) => F !== L);
      for (var [w, M] of ee.nodes(t, {
        at: i,
        match: o,
        mode: u,
        voids: p
      })) {
        var O = {}, y = {};
        if (M.length !== 0) {
          var C = !1;
          for (var _ in n)
            _ === "children" || _ === "text" || a(n[_], w[_]) && (C = !0, w.hasOwnProperty(_) && (O[_] = w[_]), s ? n[_] != null && (y[_] = s(w[_], n[_])) : n[_] != null && (y[_] = n[_]));
          C && t.apply({
            type: "set_node",
            path: M,
            properties: O,
            newProperties: y
          });
        }
      }
    }
  });
}, $te = (e, t) => {
  if (me.isCollapsed(t))
    return t.anchor;
  var [, n] = me.edges(t), r = ee.pointRef(e, n);
  return Te.delete(e, {
    at: t
  }), r.unref();
}, Wte = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  ee.withoutNormalizing(t, () => {
    var {
      mode: r = "lowest",
      voids: o = !1
    } = n, {
      match: i,
      at: a = t.selection,
      height: s = 0,
      always: l = !1
    } = n;
    if (i == null && (i = (J) => rt.isElement(J) && ee.isBlock(t, J)), me.isRange(a) && (a = $te(t, a)), ae.isPath(a)) {
      var u = a, c = ee.point(t, u), [p] = ee.parent(t, u);
      i = (J) => J === p, s = c.path.length - u.length + 1, a = c, l = !0;
    }
    if (a) {
      var d = ee.pointRef(t, a, {
        affinity: "backward"
      }), g;
      try {
        var [f] = ee.nodes(t, {
          at: a,
          match: i,
          mode: r,
          voids: o
        });
        if (!f)
          return;
        var m = ee.void(t, {
          at: a,
          mode: "highest"
        }), v = 0;
        if (!o && m) {
          var [E, w] = m;
          if (rt.isElement(E) && t.isInline(E)) {
            var M = ee.after(t, w);
            if (!M) {
              var O = {
                text: ""
              }, y = ae.next(w);
              Te.insertNodes(t, O, {
                at: y,
                voids: o
              }), M = ee.point(t, y);
            }
            a = M, l = !0;
          }
          var C = a.path.length - w.length;
          s = C + 1, l = !0;
        }
        g = ee.pointRef(t, a);
        var _ = a.path.length - s, [, F] = f, L = a.path.slice(0, _), N = s === 0 ? a.offset : a.path[_] + v;
        for (var [R, W] of ee.levels(t, {
          at: L,
          reverse: !0,
          voids: o
        })) {
          var V = !1;
          if (W.length < F.length || W.length === 0 || !o && rt.isElement(R) && ee.isVoid(t, R))
            break;
          var z = d.current, Z = ee.isEnd(t, z, W);
          if (l || !d || !ee.isEdge(t, z, W)) {
            V = !0;
            var K = qe.extractProps(R);
            t.apply({
              type: "split_node",
              path: W,
              position: N,
              properties: K
            });
          }
          N = W[W.length - 1] + (V || Z ? 1 : 0);
        }
        if (n.at == null) {
          var X = g.current || ee.end(t, []);
          Te.select(t, X);
        }
      } finally {
        var te;
        d.unref(), (te = g) === null || te === void 0 || te.unref();
      }
    }
  });
}, Vte = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Array.isArray(n) || (n = [n]);
  var o = {};
  for (var i of n)
    o[i] = null;
  Te.setNodes(t, o, r);
}, Zte = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  ee.withoutNormalizing(t, () => {
    var {
      mode: r = "lowest",
      split: o = !1,
      voids: i = !1
    } = n, {
      at: a = t.selection,
      match: s
    } = n;
    if (a) {
      s == null && (s = ae.isPath(a) ? Cc(t, a) : (g) => rt.isElement(g) && ee.isBlock(t, g)), ae.isPath(a) && (a = ee.range(t, a));
      var l = me.isRange(a) ? ee.rangeRef(t, a) : null, u = ee.nodes(t, {
        at: a,
        match: s,
        mode: r,
        voids: i
      }), c = Array.from(
        u,
        (g) => {
          var [, f] = g;
          return ee.pathRef(t, f);
        }
        // unwrapNode will call liftNode which does not support splitting the node when nested.
        // If we do not reverse the order and call it from top to the bottom, it will remove all blocks
        // that wrap target node. So we reverse the order.
      ).reverse(), p = function() {
        var f = d.unref(), [m] = ee.node(t, f), v = ee.range(t, f);
        o && l && (v = me.intersection(l.current, v)), Te.liftNodes(t, {
          at: v,
          match: (E) => rt.isAncestor(m) && m.children.includes(E),
          voids: i
        });
      };
      for (var d of c)
        p();
      l && l.unref();
    }
  });
};
function kM(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function LM(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? kM(Object(n), !0).forEach(function(r) {
      Go(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : kM(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var qte = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  ee.withoutNormalizing(t, () => {
    var {
      mode: o = "lowest",
      split: i = !1,
      voids: a = !1
    } = r, {
      match: s,
      at: l = t.selection
    } = r;
    if (l) {
      if (s == null && (ae.isPath(l) ? s = Cc(t, l) : t.isInline(n) ? s = (v) => rt.isElement(v) && ee.isInline(t, v) || it.isText(v) : s = (v) => rt.isElement(v) && ee.isBlock(t, v)), i && me.isRange(l)) {
        var [u, c] = me.edges(l), p = ee.rangeRef(t, l, {
          affinity: "inward"
        });
        Te.splitNodes(t, {
          at: c,
          match: s,
          voids: a
        }), Te.splitNodes(t, {
          at: u,
          match: s,
          voids: a
        }), l = p.unref(), r.at == null && Te.select(t, l);
      }
      var d = Array.from(ee.nodes(t, {
        at: l,
        match: t.isInline(n) ? (v) => rt.isElement(v) && ee.isBlock(t, v) : (v) => ee.isEditor(v),
        mode: "lowest",
        voids: a
      })), g = function() {
        var E = me.isRange(l) ? me.intersection(l, ee.range(t, m)) : l;
        if (!E)
          return 0;
        var w = Array.from(ee.nodes(t, {
          at: E,
          match: s,
          mode: o,
          voids: a
        }));
        if (w.length > 0) {
          var [M] = w, O = w[w.length - 1], [, y] = M, [, C] = O;
          if (y.length === 0 && C.length === 0)
            return 0;
          var _ = ae.equals(y, C) ? ae.parent(y) : ae.common(y, C), F = ee.range(t, y, C), L = ee.node(t, _), [N] = L, R = _.length + 1, W = ae.next(C.slice(0, R)), V = LM(LM({}, n), {}, {
            children: []
          });
          Te.insertNodes(t, V, {
            at: W,
            voids: a
          }), Te.moveNodes(t, {
            at: F,
            match: (z) => rt.isAncestor(N) && N.children.includes(z),
            to: W.concat(0),
            voids: a
          });
        }
      }, f;
      for (var [, m] of d)
        f = g();
    }
  });
}, Gte = () => {
  var e = {
    children: [],
    operations: [],
    selection: null,
    marks: null,
    isElementReadOnly: () => !1,
    isInline: () => !1,
    isSelectable: () => !0,
    isVoid: () => !1,
    markableVoid: () => !1,
    onChange: () => {
    },
    // Core
    apply: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return yee(e, ...r);
    },
    // Editor
    addMark: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Eee(e, ...r);
    },
    deleteBackward: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Pee(e, ...r);
    },
    deleteForward: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return _ee(e, ...r);
    },
    deleteFragment: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return See(e, ...r);
    },
    getFragment: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return wee(e, ...r);
    },
    insertBreak: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return zee(e, ...r);
    },
    insertSoftBreak: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Hee(e, ...r);
    },
    insertFragment: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return _te(e, ...r);
    },
    insertNode: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Uee(e, ...r);
    },
    insertText: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Wee(e, ...r);
    },
    normalizeNode: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Cee(e, ...r);
    },
    removeMark: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return wte(e, ...r);
    },
    getDirtyPaths: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return bee(e, ...r);
    },
    shouldNormalize: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return xee(e, ...r);
    },
    // Editor interface
    above: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Oee(e, ...r);
    },
    after: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return kee(e, ...r);
    },
    before: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Lee(e, ...r);
    },
    collapse: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Ste(e, ...r);
    },
    delete: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Pte(e, ...r);
    },
    deselect: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Mte(e, ...r);
    },
    edges: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Mee(e, ...r);
    },
    elementReadOnly: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Dee(e, ...r);
    },
    end: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Tee(e, ...r);
    },
    first: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return jee(e, ...r);
    },
    fragment: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Aee(e, ...r);
    },
    getMarks: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return nte(e, ...r);
    },
    hasBlocks: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Ree(e, ...r);
    },
    hasInlines: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Bee(e, ...r);
    },
    hasPath: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Nee(e, ...r);
    },
    hasTexts: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Fee(e, ...r);
    },
    insertNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Ite(e, ...r);
    },
    isBlock: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Vee(e, ...r);
    },
    isEdge: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Zee(e, ...r);
    },
    isEmpty: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return qee(e, ...r);
    },
    isEnd: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Gee(e, ...r);
    },
    isNormalizing: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Kee(e, ...r);
    },
    isStart: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Yee(e, ...r);
    },
    last: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Xee(e, ...r);
    },
    leaf: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Jee(e, ...r);
    },
    levels: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Qee(e, ...r);
    },
    liftNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Rte(e, ...r);
    },
    mergeNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Fte(e, ...r);
    },
    move: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Dte(e, ...r);
    },
    moveNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return zte(e, ...r);
    },
    next: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return rte(e, ...r);
    },
    node: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return ote(e, ...r);
    },
    nodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return ite(e, ...r);
    },
    normalize: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return ste(e, ...r);
    },
    parent: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return ate(e, ...r);
    },
    path: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return cte(e, ...r);
    },
    pathRef: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return lte(e, ...r);
    },
    pathRefs: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return ute(e, ...r);
    },
    point: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return fte(e, ...r);
    },
    pointRef: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return pte(e, ...r);
    },
    pointRefs: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return dte(e, ...r);
    },
    positions: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return hte(e, ...r);
    },
    previous: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return gte(e, ...r);
    },
    range: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return yte(e, ...r);
    },
    rangeRef: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return mte(e, ...r);
    },
    rangeRefs: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return vte(e, ...r);
    },
    removeNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Ute(e, ...r);
    },
    select: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Tte(e, ...r);
    },
    setNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Hte(e, ...r);
    },
    setNormalizing: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Cte(e, ...r);
    },
    setPoint: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return jte(e, ...r);
    },
    setSelection: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Ate(e, ...r);
    },
    splitNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Wte(e, ...r);
    },
    start: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return xte(e, ...r);
    },
    string: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Ote(e, ...r);
    },
    unhangRange: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Ete(e, ...r);
    },
    unsetNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Vte(e, ...r);
    },
    unwrapNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Zte(e, ...r);
    },
    void: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Iee(e, ...r);
    },
    withoutNormalizing: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return kte(e, ...r);
    },
    wrapNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return qte(e, ...r);
    },
    shouldMergeNodesRemovePrevNode: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Lte(e, ...r);
    }
  };
  return e;
};
const Q6 = (e) => {
  if (it.isText(e)) {
    let t = e.text;
    return e.bold && (t = `<strong>${t}</strong>`), e.code && (t = `<code>${t}</code>`), e.italic && (t = `<em>${t}</em>`), e.underline && (t = `<u>${t}</u>`), t;
  }
  if (rt.isElement(e)) {
    const t = e.children.map((r) => Q6(r)).join(""), n = e.align || "left";
    switch (e.type) {
      case "image":
        return `<img src="${e.src}" class="align_${n}" />`;
      case "paragraph":
        return `<p class="align_${n}">${t}</p>`;
      case "blockQuote":
        return `<blockquote class="align_${n}">${t}</blockquote>`;
      case "bulletedList":
        return `<ul class="align_${n}">${t}</ul>`;
      case "headingOne":
        return `<h1 class="align_${n}">${t}</h1>`;
      case "headingTwo":
        return `<h2 class="align_${n}">${t}</h2>`;
      case "listItem":
        return `<li class="align_${n}">${t}</li>`;
      case "numberedList":
        return `<ol class="align_${n}">${t}</ol>`;
      default:
        return t;
    }
  }
  return "";
}, g4e = (e) => e.map((t) => Q6(t)).join("");
var e8 = {}, A1 = {}, I1 = {}, Vu = {}, R1 = {}, B1 = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Doctype = e.CDATA = e.Tag = e.Style = e.Script = e.Comment = e.Directive = e.Text = e.Root = e.isTag = e.ElementType = void 0;
  var t;
  (function(r) {
    r.Root = "root", r.Text = "text", r.Directive = "directive", r.Comment = "comment", r.Script = "script", r.Style = "style", r.Tag = "tag", r.CDATA = "cdata", r.Doctype = "doctype";
  })(t = e.ElementType || (e.ElementType = {}));
  function n(r) {
    return r.type === t.Tag || r.type === t.Script || r.type === t.Style;
  }
  e.isTag = n, e.Root = t.Root, e.Text = t.Text, e.Directive = t.Directive, e.Comment = t.Comment, e.Script = t.Script, e.Style = t.Style, e.Tag = t.Tag, e.CDATA = t.CDATA, e.Doctype = t.Doctype;
})(B1);
var Zt = {}, dl = Xn && Xn.__extends || /* @__PURE__ */ function() {
  var e = function(t, n) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, o) {
      r.__proto__ = o;
    } || function(r, o) {
      for (var i in o) Object.prototype.hasOwnProperty.call(o, i) && (r[i] = o[i]);
    }, e(t, n);
  };
  return function(t, n) {
    if (typeof n != "function" && n !== null)
      throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
    e(t, n);
    function r() {
      this.constructor = t;
    }
    t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
  };
}(), zp = Xn && Xn.__assign || function() {
  return zp = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) {
      t = arguments[n];
      for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
    }
    return e;
  }, zp.apply(this, arguments);
};
Object.defineProperty(Zt, "__esModule", { value: !0 });
Zt.cloneNode = Zt.hasChildren = Zt.isDocument = Zt.isDirective = Zt.isComment = Zt.isText = Zt.isCDATA = Zt.isTag = Zt.Element = Zt.Document = Zt.CDATA = Zt.NodeWithChildren = Zt.ProcessingInstruction = Zt.Comment = Zt.Text = Zt.DataNode = Zt.Node = void 0;
var pi = B1, N1 = (
  /** @class */
  function() {
    function e() {
      this.parent = null, this.prev = null, this.next = null, this.startIndex = null, this.endIndex = null;
    }
    return Object.defineProperty(e.prototype, "parentNode", {
      // Read-write aliases for properties
      /**
       * Same as {@link parent}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.parent;
      },
      set: function(t) {
        this.parent = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "previousSibling", {
      /**
       * Same as {@link prev}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.prev;
      },
      set: function(t) {
        this.prev = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "nextSibling", {
      /**
       * Same as {@link next}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.next;
      },
      set: function(t) {
        this.next = t;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.cloneNode = function(t) {
      return t === void 0 && (t = !1), F1(this, t);
    }, e;
  }()
);
Zt.Node = N1;
var Jy = (
  /** @class */
  function(e) {
    dl(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.data = n, r;
    }
    return Object.defineProperty(t.prototype, "nodeValue", {
      /**
       * Same as {@link data}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.data;
      },
      set: function(n) {
        this.data = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(N1)
);
Zt.DataNode = Jy;
var t8 = (
  /** @class */
  function(e) {
    dl(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = pi.ElementType.Text, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 3;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Jy)
);
Zt.Text = t8;
var n8 = (
  /** @class */
  function(e) {
    dl(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = pi.ElementType.Comment, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 8;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Jy)
);
Zt.Comment = n8;
var r8 = (
  /** @class */
  function(e) {
    dl(t, e);
    function t(n, r) {
      var o = e.call(this, r) || this;
      return o.name = n, o.type = pi.ElementType.Directive, o;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Jy)
);
Zt.ProcessingInstruction = r8;
var Qy = (
  /** @class */
  function(e) {
    dl(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.children = n, r;
    }
    return Object.defineProperty(t.prototype, "firstChild", {
      // Aliases
      /** First child of the node. */
      get: function() {
        var n;
        return (n = this.children[0]) !== null && n !== void 0 ? n : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "lastChild", {
      /** Last child of the node. */
      get: function() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "childNodes", {
      /**
       * Same as {@link children}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.children;
      },
      set: function(n) {
        this.children = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(N1)
);
Zt.NodeWithChildren = Qy;
var o8 = (
  /** @class */
  function(e) {
    dl(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = pi.ElementType.CDATA, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 4;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Qy)
);
Zt.CDATA = o8;
var i8 = (
  /** @class */
  function(e) {
    dl(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = pi.ElementType.Root, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 9;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Qy)
);
Zt.Document = i8;
var s8 = (
  /** @class */
  function(e) {
    dl(t, e);
    function t(n, r, o, i) {
      o === void 0 && (o = []), i === void 0 && (i = n === "script" ? pi.ElementType.Script : n === "style" ? pi.ElementType.Style : pi.ElementType.Tag);
      var a = e.call(this, o) || this;
      return a.name = n, a.attribs = r, a.type = i, a;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "tagName", {
      // DOM Level 1 aliases
      /**
       * Same as {@link name}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.name;
      },
      set: function(n) {
        this.name = n;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "attributes", {
      get: function() {
        var n = this;
        return Object.keys(this.attribs).map(function(r) {
          var o, i;
          return {
            name: r,
            value: n.attribs[r],
            namespace: (o = n["x-attribsNamespace"]) === null || o === void 0 ? void 0 : o[r],
            prefix: (i = n["x-attribsPrefix"]) === null || i === void 0 ? void 0 : i[r]
          };
        });
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Qy)
);
Zt.Element = s8;
function a8(e) {
  return (0, pi.isTag)(e);
}
Zt.isTag = a8;
function l8(e) {
  return e.type === pi.ElementType.CDATA;
}
Zt.isCDATA = l8;
function u8(e) {
  return e.type === pi.ElementType.Text;
}
Zt.isText = u8;
function c8(e) {
  return e.type === pi.ElementType.Comment;
}
Zt.isComment = c8;
function p8(e) {
  return e.type === pi.ElementType.Directive;
}
Zt.isDirective = p8;
function d8(e) {
  return e.type === pi.ElementType.Root;
}
Zt.isDocument = d8;
function Kte(e) {
  return Object.prototype.hasOwnProperty.call(e, "children");
}
Zt.hasChildren = Kte;
function F1(e, t) {
  t === void 0 && (t = !1);
  var n;
  if (u8(e))
    n = new t8(e.data);
  else if (c8(e))
    n = new n8(e.data);
  else if (a8(e)) {
    var r = t ? D0(e.children) : [], o = new s8(e.name, zp({}, e.attribs), r);
    r.forEach(function(l) {
      return l.parent = o;
    }), e.namespace != null && (o.namespace = e.namespace), e["x-attribsNamespace"] && (o["x-attribsNamespace"] = zp({}, e["x-attribsNamespace"])), e["x-attribsPrefix"] && (o["x-attribsPrefix"] = zp({}, e["x-attribsPrefix"])), n = o;
  } else if (l8(e)) {
    var r = t ? D0(e.children) : [], i = new o8(r);
    r.forEach(function(u) {
      return u.parent = i;
    }), n = i;
  } else if (d8(e)) {
    var r = t ? D0(e.children) : [], a = new i8(r);
    r.forEach(function(u) {
      return u.parent = a;
    }), e["x-mode"] && (a["x-mode"] = e["x-mode"]), n = a;
  } else if (p8(e)) {
    var s = new r8(e.name, e.data);
    e["x-name"] != null && (s["x-name"] = e["x-name"], s["x-publicId"] = e["x-publicId"], s["x-systemId"] = e["x-systemId"]), n = s;
  } else
    throw new Error("Not implemented yet: ".concat(e.type));
  return n.startIndex = e.startIndex, n.endIndex = e.endIndex, e.sourceCodeLocation != null && (n.sourceCodeLocation = e.sourceCodeLocation), n;
}
Zt.cloneNode = F1;
function D0(e) {
  for (var t = e.map(function(r) {
    return F1(r, !0);
  }), n = 1; n < t.length; n++)
    t[n].prev = t[n - 1], t[n - 1].next = t[n];
  return t;
}
(function(e) {
  var t = Xn && Xn.__createBinding || (Object.create ? function(s, l, u, c) {
    c === void 0 && (c = u);
    var p = Object.getOwnPropertyDescriptor(l, u);
    (!p || ("get" in p ? !l.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
      return l[u];
    } }), Object.defineProperty(s, c, p);
  } : function(s, l, u, c) {
    c === void 0 && (c = u), s[c] = l[u];
  }), n = Xn && Xn.__exportStar || function(s, l) {
    for (var u in s) u !== "default" && !Object.prototype.hasOwnProperty.call(l, u) && t(l, s, u);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.DomHandler = void 0;
  var r = B1, o = Zt;
  n(Zt, e);
  var i = {
    withStartIndices: !1,
    withEndIndices: !1,
    xmlMode: !1
  }, a = (
    /** @class */
    function() {
      function s(l, u, c) {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null, typeof u == "function" && (c = u, u = i), typeof l == "object" && (u = l, l = void 0), this.callback = l ?? null, this.options = u ?? i, this.elementCB = c ?? null;
      }
      return s.prototype.onparserinit = function(l) {
        this.parser = l;
      }, s.prototype.onreset = function() {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null;
      }, s.prototype.onend = function() {
        this.done || (this.done = !0, this.parser = null, this.handleCallback(null));
      }, s.prototype.onerror = function(l) {
        this.handleCallback(l);
      }, s.prototype.onclosetag = function() {
        this.lastNode = null;
        var l = this.tagStack.pop();
        this.options.withEndIndices && (l.endIndex = this.parser.endIndex), this.elementCB && this.elementCB(l);
      }, s.prototype.onopentag = function(l, u) {
        var c = this.options.xmlMode ? r.ElementType.Tag : void 0, p = new o.Element(l, u, void 0, c);
        this.addNode(p), this.tagStack.push(p);
      }, s.prototype.ontext = function(l) {
        var u = this.lastNode;
        if (u && u.type === r.ElementType.Text)
          u.data += l, this.options.withEndIndices && (u.endIndex = this.parser.endIndex);
        else {
          var c = new o.Text(l);
          this.addNode(c), this.lastNode = c;
        }
      }, s.prototype.oncomment = function(l) {
        if (this.lastNode && this.lastNode.type === r.ElementType.Comment) {
          this.lastNode.data += l;
          return;
        }
        var u = new o.Comment(l);
        this.addNode(u), this.lastNode = u;
      }, s.prototype.oncommentend = function() {
        this.lastNode = null;
      }, s.prototype.oncdatastart = function() {
        var l = new o.Text(""), u = new o.CDATA([l]);
        this.addNode(u), l.parent = u, this.lastNode = l;
      }, s.prototype.oncdataend = function() {
        this.lastNode = null;
      }, s.prototype.onprocessinginstruction = function(l, u) {
        var c = new o.ProcessingInstruction(l, u);
        this.addNode(c);
      }, s.prototype.handleCallback = function(l) {
        if (typeof this.callback == "function")
          this.callback(l, this.dom);
        else if (l)
          throw l;
      }, s.prototype.addNode = function(l) {
        var u = this.tagStack[this.tagStack.length - 1], c = u.children[u.children.length - 1];
        this.options.withStartIndices && (l.startIndex = this.parser.startIndex), this.options.withEndIndices && (l.endIndex = this.parser.endIndex), u.children.push(l), c && (l.prev = c, c.next = l), l.parent = u, this.lastNode = null;
      }, s;
    }()
  );
  e.DomHandler = a, e.default = a;
})(R1);
var f8 = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CARRIAGE_RETURN_PLACEHOLDER_REGEX = e.CARRIAGE_RETURN_PLACEHOLDER = e.CARRIAGE_RETURN_REGEX = e.CARRIAGE_RETURN = e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES = void 0, e.CASE_SENSITIVE_TAG_NAMES = [
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "linearGradient",
    "radialGradient",
    "textPath"
  ], e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES.reduce(function(t, n) {
    return t[n.toLowerCase()] = n, t;
  }, {}), e.CARRIAGE_RETURN = "\r", e.CARRIAGE_RETURN_REGEX = new RegExp(e.CARRIAGE_RETURN, "g"), e.CARRIAGE_RETURN_PLACEHOLDER = "__HTML_DOM_PARSER_CARRIAGE_RETURN_PLACEHOLDER_".concat(Date.now(), "__"), e.CARRIAGE_RETURN_PLACEHOLDER_REGEX = new RegExp(e.CARRIAGE_RETURN_PLACEHOLDER, "g");
})(f8);
Object.defineProperty(Vu, "__esModule", { value: !0 });
Vu.formatAttributes = h8;
Vu.escapeSpecialCharacters = Jte;
Vu.revertEscapedCharacters = g8;
Vu.formatDOM = m8;
var gh = R1, Cd = f8;
function Yte(e) {
  return Cd.CASE_SENSITIVE_TAG_NAMES_MAP[e];
}
function h8(e) {
  for (var t = {}, n = 0, r = e.length; n < r; n++) {
    var o = e[n];
    t[o.name] = o.value;
  }
  return t;
}
function Xte(e) {
  e = e.toLowerCase();
  var t = Yte(e);
  return t || e;
}
function Jte(e) {
  return e.replace(Cd.CARRIAGE_RETURN_REGEX, Cd.CARRIAGE_RETURN_PLACEHOLDER);
}
function g8(e) {
  return e.replace(Cd.CARRIAGE_RETURN_PLACEHOLDER_REGEX, Cd.CARRIAGE_RETURN);
}
function m8(e, t, n) {
  t === void 0 && (t = null);
  for (var r = [], o, i = 0, a = e.length; i < a; i++) {
    var s = e[i];
    switch (s.nodeType) {
      case 1: {
        var l = Xte(s.nodeName);
        o = new gh.Element(l, h8(s.attributes)), o.children = m8(
          // template children are on content
          l === "template" ? s.content.childNodes : s.childNodes,
          o
        );
        break;
      }
      case 3:
        o = new gh.Text(g8(s.nodeValue));
        break;
      case 8:
        o = new gh.Comment(s.nodeValue);
        break;
      default:
        continue;
    }
    var u = r[i - 1] || null;
    u && (u.next = o), o.parent = t, o.prev = u, o.next = null, r.push(o);
  }
  return n && (o = new gh.ProcessingInstruction(n.substring(0, n.indexOf(" ")).toLowerCase(), n), o.next = r[0] || null, o.parent = t, r.unshift(o), r[1] && (r[1].prev = r[0])), r;
}
Object.defineProperty(I1, "__esModule", { value: !0 });
I1.default = rne;
var Qte = Vu, PM = "html", _M = "head", mh = "body", ene = /<([a-zA-Z]+[0-9]?)/, SM = /<head[^]*>/i, MM = /<body[^]*>/i, Vm = function(e, t) {
  throw new Error("This browser does not support `document.implementation.createHTMLDocument`");
}, eE = function(e, t) {
  throw new Error("This browser does not support `DOMParser.prototype.parseFromString`");
}, DM = typeof window == "object" && window.DOMParser;
if (typeof DM == "function") {
  var tne = new DM(), nne = "text/html";
  eE = function(e, t) {
    return t && (e = "<".concat(t, ">").concat(e, "</").concat(t, ">")), tne.parseFromString(e, nne);
  }, Vm = eE;
}
if (typeof document == "object" && document.implementation) {
  var vh = document.implementation.createHTMLDocument();
  Vm = function(e, t) {
    if (t) {
      var n = vh.documentElement.querySelector(t);
      return n && (n.innerHTML = e), vh;
    }
    return vh.documentElement.innerHTML = e, vh;
  };
}
var yh = typeof document == "object" && document.createElement("template"), tE;
yh && yh.content && (tE = function(e) {
  return yh.innerHTML = e, yh.content.childNodes;
});
function rne(e) {
  var t, n;
  e = (0, Qte.escapeSpecialCharacters)(e);
  var r = e.match(ene), o = r && r[1] ? r[1].toLowerCase() : "";
  switch (o) {
    case PM: {
      var i = eE(e);
      if (!SM.test(e)) {
        var a = i.querySelector(_M);
        (t = a == null ? void 0 : a.parentNode) === null || t === void 0 || t.removeChild(a);
      }
      if (!MM.test(e)) {
        var a = i.querySelector(mh);
        (n = a == null ? void 0 : a.parentNode) === null || n === void 0 || n.removeChild(a);
      }
      return i.querySelectorAll(PM);
    }
    case _M:
    case mh: {
      var s = Vm(e).querySelectorAll(o);
      return MM.test(e) && SM.test(e) ? s[0].parentNode.childNodes : s;
    }
    default: {
      if (tE)
        return tE(e);
      var a = Vm(e, mh).querySelector(mh);
      return a.childNodes;
    }
  }
}
var one = Xn && Xn.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(A1, "__esModule", { value: !0 });
A1.default = lne;
var ine = one(I1), sne = Vu, ane = /<(![a-zA-Z\s]+)>/;
function lne(e) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e)
    return [];
  var t = e.match(ane), n = t ? t[1] : void 0;
  return (0, sne.formatDOM)((0, ine.default)(e), null, n);
}
var eb = {}, cs = {}, tb = {}, une = 0;
tb.SAME = une;
var cne = 1;
tb.CAMELCASE = cne;
tb.possibleStandardNames = {
  accept: 0,
  acceptCharset: 1,
  "accept-charset": "acceptCharset",
  accessKey: 1,
  action: 0,
  allowFullScreen: 1,
  alt: 0,
  as: 0,
  async: 0,
  autoCapitalize: 1,
  autoComplete: 1,
  autoCorrect: 1,
  autoFocus: 1,
  autoPlay: 1,
  autoSave: 1,
  capture: 0,
  cellPadding: 1,
  cellSpacing: 1,
  challenge: 0,
  charSet: 1,
  checked: 0,
  children: 0,
  cite: 0,
  class: "className",
  classID: 1,
  className: 1,
  cols: 0,
  colSpan: 1,
  content: 0,
  contentEditable: 1,
  contextMenu: 1,
  controls: 0,
  controlsList: 1,
  coords: 0,
  crossOrigin: 1,
  dangerouslySetInnerHTML: 1,
  data: 0,
  dateTime: 1,
  default: 0,
  defaultChecked: 1,
  defaultValue: 1,
  defer: 0,
  dir: 0,
  disabled: 0,
  disablePictureInPicture: 1,
  disableRemotePlayback: 1,
  download: 0,
  draggable: 0,
  encType: 1,
  enterKeyHint: 1,
  for: "htmlFor",
  form: 0,
  formMethod: 1,
  formAction: 1,
  formEncType: 1,
  formNoValidate: 1,
  formTarget: 1,
  frameBorder: 1,
  headers: 0,
  height: 0,
  hidden: 0,
  high: 0,
  href: 0,
  hrefLang: 1,
  htmlFor: 1,
  httpEquiv: 1,
  "http-equiv": "httpEquiv",
  icon: 0,
  id: 0,
  innerHTML: 1,
  inputMode: 1,
  integrity: 0,
  is: 0,
  itemID: 1,
  itemProp: 1,
  itemRef: 1,
  itemScope: 1,
  itemType: 1,
  keyParams: 1,
  keyType: 1,
  kind: 0,
  label: 0,
  lang: 0,
  list: 0,
  loop: 0,
  low: 0,
  manifest: 0,
  marginWidth: 1,
  marginHeight: 1,
  max: 0,
  maxLength: 1,
  media: 0,
  mediaGroup: 1,
  method: 0,
  min: 0,
  minLength: 1,
  multiple: 0,
  muted: 0,
  name: 0,
  noModule: 1,
  nonce: 0,
  noValidate: 1,
  open: 0,
  optimum: 0,
  pattern: 0,
  placeholder: 0,
  playsInline: 1,
  poster: 0,
  preload: 0,
  profile: 0,
  radioGroup: 1,
  readOnly: 1,
  referrerPolicy: 1,
  rel: 0,
  required: 0,
  reversed: 0,
  role: 0,
  rows: 0,
  rowSpan: 1,
  sandbox: 0,
  scope: 0,
  scoped: 0,
  scrolling: 0,
  seamless: 0,
  selected: 0,
  shape: 0,
  size: 0,
  sizes: 0,
  span: 0,
  spellCheck: 1,
  src: 0,
  srcDoc: 1,
  srcLang: 1,
  srcSet: 1,
  start: 0,
  step: 0,
  style: 0,
  summary: 0,
  tabIndex: 1,
  target: 0,
  title: 0,
  type: 0,
  useMap: 1,
  value: 0,
  width: 0,
  wmode: 0,
  wrap: 0,
  about: 0,
  accentHeight: 1,
  "accent-height": "accentHeight",
  accumulate: 0,
  additive: 0,
  alignmentBaseline: 1,
  "alignment-baseline": "alignmentBaseline",
  allowReorder: 1,
  alphabetic: 0,
  amplitude: 0,
  arabicForm: 1,
  "arabic-form": "arabicForm",
  ascent: 0,
  attributeName: 1,
  attributeType: 1,
  autoReverse: 1,
  azimuth: 0,
  baseFrequency: 1,
  baselineShift: 1,
  "baseline-shift": "baselineShift",
  baseProfile: 1,
  bbox: 0,
  begin: 0,
  bias: 0,
  by: 0,
  calcMode: 1,
  capHeight: 1,
  "cap-height": "capHeight",
  clip: 0,
  clipPath: 1,
  "clip-path": "clipPath",
  clipPathUnits: 1,
  clipRule: 1,
  "clip-rule": "clipRule",
  color: 0,
  colorInterpolation: 1,
  "color-interpolation": "colorInterpolation",
  colorInterpolationFilters: 1,
  "color-interpolation-filters": "colorInterpolationFilters",
  colorProfile: 1,
  "color-profile": "colorProfile",
  colorRendering: 1,
  "color-rendering": "colorRendering",
  contentScriptType: 1,
  contentStyleType: 1,
  cursor: 0,
  cx: 0,
  cy: 0,
  d: 0,
  datatype: 0,
  decelerate: 0,
  descent: 0,
  diffuseConstant: 1,
  direction: 0,
  display: 0,
  divisor: 0,
  dominantBaseline: 1,
  "dominant-baseline": "dominantBaseline",
  dur: 0,
  dx: 0,
  dy: 0,
  edgeMode: 1,
  elevation: 0,
  enableBackground: 1,
  "enable-background": "enableBackground",
  end: 0,
  exponent: 0,
  externalResourcesRequired: 1,
  fill: 0,
  fillOpacity: 1,
  "fill-opacity": "fillOpacity",
  fillRule: 1,
  "fill-rule": "fillRule",
  filter: 0,
  filterRes: 1,
  filterUnits: 1,
  floodOpacity: 1,
  "flood-opacity": "floodOpacity",
  floodColor: 1,
  "flood-color": "floodColor",
  focusable: 0,
  fontFamily: 1,
  "font-family": "fontFamily",
  fontSize: 1,
  "font-size": "fontSize",
  fontSizeAdjust: 1,
  "font-size-adjust": "fontSizeAdjust",
  fontStretch: 1,
  "font-stretch": "fontStretch",
  fontStyle: 1,
  "font-style": "fontStyle",
  fontVariant: 1,
  "font-variant": "fontVariant",
  fontWeight: 1,
  "font-weight": "fontWeight",
  format: 0,
  from: 0,
  fx: 0,
  fy: 0,
  g1: 0,
  g2: 0,
  glyphName: 1,
  "glyph-name": "glyphName",
  glyphOrientationHorizontal: 1,
  "glyph-orientation-horizontal": "glyphOrientationHorizontal",
  glyphOrientationVertical: 1,
  "glyph-orientation-vertical": "glyphOrientationVertical",
  glyphRef: 1,
  gradientTransform: 1,
  gradientUnits: 1,
  hanging: 0,
  horizAdvX: 1,
  "horiz-adv-x": "horizAdvX",
  horizOriginX: 1,
  "horiz-origin-x": "horizOriginX",
  ideographic: 0,
  imageRendering: 1,
  "image-rendering": "imageRendering",
  in2: 0,
  in: 0,
  inlist: 0,
  intercept: 0,
  k1: 0,
  k2: 0,
  k3: 0,
  k4: 0,
  k: 0,
  kernelMatrix: 1,
  kernelUnitLength: 1,
  kerning: 0,
  keyPoints: 1,
  keySplines: 1,
  keyTimes: 1,
  lengthAdjust: 1,
  letterSpacing: 1,
  "letter-spacing": "letterSpacing",
  lightingColor: 1,
  "lighting-color": "lightingColor",
  limitingConeAngle: 1,
  local: 0,
  markerEnd: 1,
  "marker-end": "markerEnd",
  markerHeight: 1,
  markerMid: 1,
  "marker-mid": "markerMid",
  markerStart: 1,
  "marker-start": "markerStart",
  markerUnits: 1,
  markerWidth: 1,
  mask: 0,
  maskContentUnits: 1,
  maskUnits: 1,
  mathematical: 0,
  mode: 0,
  numOctaves: 1,
  offset: 0,
  opacity: 0,
  operator: 0,
  order: 0,
  orient: 0,
  orientation: 0,
  origin: 0,
  overflow: 0,
  overlinePosition: 1,
  "overline-position": "overlinePosition",
  overlineThickness: 1,
  "overline-thickness": "overlineThickness",
  paintOrder: 1,
  "paint-order": "paintOrder",
  panose1: 0,
  "panose-1": "panose1",
  pathLength: 1,
  patternContentUnits: 1,
  patternTransform: 1,
  patternUnits: 1,
  pointerEvents: 1,
  "pointer-events": "pointerEvents",
  points: 0,
  pointsAtX: 1,
  pointsAtY: 1,
  pointsAtZ: 1,
  prefix: 0,
  preserveAlpha: 1,
  preserveAspectRatio: 1,
  primitiveUnits: 1,
  property: 0,
  r: 0,
  radius: 0,
  refX: 1,
  refY: 1,
  renderingIntent: 1,
  "rendering-intent": "renderingIntent",
  repeatCount: 1,
  repeatDur: 1,
  requiredExtensions: 1,
  requiredFeatures: 1,
  resource: 0,
  restart: 0,
  result: 0,
  results: 0,
  rotate: 0,
  rx: 0,
  ry: 0,
  scale: 0,
  security: 0,
  seed: 0,
  shapeRendering: 1,
  "shape-rendering": "shapeRendering",
  slope: 0,
  spacing: 0,
  specularConstant: 1,
  specularExponent: 1,
  speed: 0,
  spreadMethod: 1,
  startOffset: 1,
  stdDeviation: 1,
  stemh: 0,
  stemv: 0,
  stitchTiles: 1,
  stopColor: 1,
  "stop-color": "stopColor",
  stopOpacity: 1,
  "stop-opacity": "stopOpacity",
  strikethroughPosition: 1,
  "strikethrough-position": "strikethroughPosition",
  strikethroughThickness: 1,
  "strikethrough-thickness": "strikethroughThickness",
  string: 0,
  stroke: 0,
  strokeDasharray: 1,
  "stroke-dasharray": "strokeDasharray",
  strokeDashoffset: 1,
  "stroke-dashoffset": "strokeDashoffset",
  strokeLinecap: 1,
  "stroke-linecap": "strokeLinecap",
  strokeLinejoin: 1,
  "stroke-linejoin": "strokeLinejoin",
  strokeMiterlimit: 1,
  "stroke-miterlimit": "strokeMiterlimit",
  strokeWidth: 1,
  "stroke-width": "strokeWidth",
  strokeOpacity: 1,
  "stroke-opacity": "strokeOpacity",
  suppressContentEditableWarning: 1,
  suppressHydrationWarning: 1,
  surfaceScale: 1,
  systemLanguage: 1,
  tableValues: 1,
  targetX: 1,
  targetY: 1,
  textAnchor: 1,
  "text-anchor": "textAnchor",
  textDecoration: 1,
  "text-decoration": "textDecoration",
  textLength: 1,
  textRendering: 1,
  "text-rendering": "textRendering",
  to: 0,
  transform: 0,
  typeof: 0,
  u1: 0,
  u2: 0,
  underlinePosition: 1,
  "underline-position": "underlinePosition",
  underlineThickness: 1,
  "underline-thickness": "underlineThickness",
  unicode: 0,
  unicodeBidi: 1,
  "unicode-bidi": "unicodeBidi",
  unicodeRange: 1,
  "unicode-range": "unicodeRange",
  unitsPerEm: 1,
  "units-per-em": "unitsPerEm",
  unselectable: 0,
  vAlphabetic: 1,
  "v-alphabetic": "vAlphabetic",
  values: 0,
  vectorEffect: 1,
  "vector-effect": "vectorEffect",
  version: 0,
  vertAdvY: 1,
  "vert-adv-y": "vertAdvY",
  vertOriginX: 1,
  "vert-origin-x": "vertOriginX",
  vertOriginY: 1,
  "vert-origin-y": "vertOriginY",
  vHanging: 1,
  "v-hanging": "vHanging",
  vIdeographic: 1,
  "v-ideographic": "vIdeographic",
  viewBox: 1,
  viewTarget: 1,
  visibility: 0,
  vMathematical: 1,
  "v-mathematical": "vMathematical",
  vocab: 0,
  widths: 0,
  wordSpacing: 1,
  "word-spacing": "wordSpacing",
  writingMode: 1,
  "writing-mode": "writingMode",
  x1: 0,
  x2: 0,
  x: 0,
  xChannelSelector: 1,
  xHeight: 1,
  "x-height": "xHeight",
  xlinkActuate: 1,
  "xlink:actuate": "xlinkActuate",
  xlinkArcrole: 1,
  "xlink:arcrole": "xlinkArcrole",
  xlinkHref: 1,
  "xlink:href": "xlinkHref",
  xlinkRole: 1,
  "xlink:role": "xlinkRole",
  xlinkShow: 1,
  "xlink:show": "xlinkShow",
  xlinkTitle: 1,
  "xlink:title": "xlinkTitle",
  xlinkType: 1,
  "xlink:type": "xlinkType",
  xmlBase: 1,
  "xml:base": "xmlBase",
  xmlLang: 1,
  "xml:lang": "xmlLang",
  xmlns: 0,
  "xml:space": "xmlSpace",
  xmlnsXlink: 1,
  "xmlns:xlink": "xmlnsXlink",
  xmlSpace: 1,
  y1: 0,
  y2: 0,
  y: 0,
  yChannelSelector: 1,
  z: 0,
  zoomAndPan: 1
};
const v8 = 0, fl = 1, nb = 2, rb = 3, z1 = 4, y8 = 5, b8 = 6;
function pne(e) {
  return To.hasOwnProperty(e) ? To[e] : null;
}
function Ko(e, t, n, r, o, i, a) {
  this.acceptsBooleans = t === nb || t === rb || t === z1, this.attributeName = r, this.attributeNamespace = o, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = i, this.removeEmptyString = a;
}
const To = {}, dne = [
  "children",
  "dangerouslySetInnerHTML",
  // TODO: This prevents the assignment of defaultValue to regular
  // elements (not just inputs). Now that ReactDOMInput assigns to the
  // defaultValue property -- do we need this?
  "defaultValue",
  "defaultChecked",
  "innerHTML",
  "suppressContentEditableWarning",
  "suppressHydrationWarning",
  "style"
];
dne.forEach((e) => {
  To[e] = new Ko(
    e,
    v8,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"]
].forEach(([e, t]) => {
  To[e] = new Ko(
    e,
    fl,
    !1,
    // mustUseProperty
    t,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["contentEditable", "draggable", "spellCheck", "value"].forEach((e) => {
  To[e] = new Ko(
    e,
    nb,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha"
].forEach((e) => {
  To[e] = new Ko(
    e,
    nb,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "allowFullScreen",
  "async",
  // Note: there is a special case that prevents it from being written to the DOM
  // on the client side because the browsers are inconsistent. Instead we call focus().
  "autoFocus",
  "autoPlay",
  "controls",
  "default",
  "defer",
  "disabled",
  "disablePictureInPicture",
  "disableRemotePlayback",
  "formNoValidate",
  "hidden",
  "loop",
  "noModule",
  "noValidate",
  "open",
  "playsInline",
  "readOnly",
  "required",
  "reversed",
  "scoped",
  "seamless",
  // Microdata
  "itemScope"
].forEach((e) => {
  To[e] = new Ko(
    e,
    rb,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "checked",
  // Note: `option.selected` is not updated if `select.multiple` is
  // disabled with `removeAttribute`. We have special logic for handling this.
  "multiple",
  "muted",
  "selected"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  To[e] = new Ko(
    e,
    rb,
    !0,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "capture",
  "download"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  To[e] = new Ko(
    e,
    z1,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "cols",
  "rows",
  "size",
  "span"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  To[e] = new Ko(
    e,
    b8,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["rowSpan", "start"].forEach((e) => {
  To[e] = new Ko(
    e,
    y8,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const U1 = /[\-\:]([a-z])/g, H1 = (e) => e[1].toUpperCase();
[
  "accent-height",
  "alignment-baseline",
  "arabic-form",
  "baseline-shift",
  "cap-height",
  "clip-path",
  "clip-rule",
  "color-interpolation",
  "color-interpolation-filters",
  "color-profile",
  "color-rendering",
  "dominant-baseline",
  "enable-background",
  "fill-opacity",
  "fill-rule",
  "flood-color",
  "flood-opacity",
  "font-family",
  "font-size",
  "font-size-adjust",
  "font-stretch",
  "font-style",
  "font-variant",
  "font-weight",
  "glyph-name",
  "glyph-orientation-horizontal",
  "glyph-orientation-vertical",
  "horiz-adv-x",
  "horiz-origin-x",
  "image-rendering",
  "letter-spacing",
  "lighting-color",
  "marker-end",
  "marker-mid",
  "marker-start",
  "overline-position",
  "overline-thickness",
  "paint-order",
  "panose-1",
  "pointer-events",
  "rendering-intent",
  "shape-rendering",
  "stop-color",
  "stop-opacity",
  "strikethrough-position",
  "strikethrough-thickness",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "text-anchor",
  "text-decoration",
  "text-rendering",
  "underline-position",
  "underline-thickness",
  "unicode-bidi",
  "unicode-range",
  "units-per-em",
  "v-alphabetic",
  "v-hanging",
  "v-ideographic",
  "v-mathematical",
  "vector-effect",
  "vert-adv-y",
  "vert-origin-x",
  "vert-origin-y",
  "word-spacing",
  "writing-mode",
  "xmlns:xlink",
  "x-height"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(U1, H1);
  To[t] = new Ko(
    t,
    fl,
    !1,
    // mustUseProperty
    e,
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xlink:actuate",
  "xlink:arcrole",
  "xlink:role",
  "xlink:show",
  "xlink:title",
  "xlink:type"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(U1, H1);
  To[t] = new Ko(
    t,
    fl,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/1999/xlink",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xml:base",
  "xml:lang",
  "xml:space"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(U1, H1);
  To[t] = new Ko(
    t,
    fl,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/XML/1998/namespace",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["tabIndex", "crossOrigin"].forEach((e) => {
  To[e] = new Ko(
    e,
    fl,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const fne = "xlinkHref";
To[fne] = new Ko(
  "xlinkHref",
  fl,
  !1,
  // mustUseProperty
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  // sanitizeURL
  !1
  // removeEmptyString
);
["src", "href", "action", "formAction"].forEach((e) => {
  To[e] = new Ko(
    e,
    fl,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !0,
    // sanitizeURL
    !0
    // removeEmptyString
  );
});
const {
  CAMELCASE: hne,
  SAME: gne,
  possibleStandardNames: TM
} = tb, mne = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", vne = mne + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", yne = RegExp.prototype.test.bind(
  // eslint-disable-next-line no-misleading-character-class
  new RegExp("^(data|aria)-[" + vne + "]*$")
), bne = Object.keys(
  TM
).reduce((e, t) => {
  const n = TM[t];
  return n === gne ? e[t] = t : n === hne ? e[t.toLowerCase()] = t : e[t] = n, e;
}, {});
cs.BOOLEAN = rb;
cs.BOOLEANISH_STRING = nb;
cs.NUMERIC = y8;
cs.OVERLOADED_BOOLEAN = z1;
cs.POSITIVE_NUMERIC = b8;
cs.RESERVED = v8;
cs.STRING = fl;
cs.getPropertyInfo = pne;
cs.isCustomAttribute = yne;
cs.possibleStandardNames = bne;
var $1 = {}, W1 = {}, jM = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, wne = /\n/g, Cne = /^\s*/, xne = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, One = /^:\s*/, Ene = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, kne = /^[;\s]*/, Lne = /^\s+|\s+$/g, Pne = `
`, AM = "/", IM = "*", ru = "", _ne = "comment", Sne = "declaration", Mne = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e) return [];
  t = t || {};
  var n = 1, r = 1;
  function o(f) {
    var m = f.match(wne);
    m && (n += m.length);
    var v = f.lastIndexOf(Pne);
    r = ~v ? f.length - v : r + f.length;
  }
  function i() {
    var f = { line: n, column: r };
    return function(m) {
      return m.position = new a(f), u(), m;
    };
  }
  function a(f) {
    this.start = f, this.end = { line: n, column: r }, this.source = t.source;
  }
  a.prototype.content = e;
  function s(f) {
    var m = new Error(
      t.source + ":" + n + ":" + r + ": " + f
    );
    if (m.reason = f, m.filename = t.source, m.line = n, m.column = r, m.source = e, !t.silent) throw m;
  }
  function l(f) {
    var m = f.exec(e);
    if (m) {
      var v = m[0];
      return o(v), e = e.slice(v.length), m;
    }
  }
  function u() {
    l(Cne);
  }
  function c(f) {
    var m;
    for (f = f || []; m = p(); )
      m !== !1 && f.push(m);
    return f;
  }
  function p() {
    var f = i();
    if (!(AM != e.charAt(0) || IM != e.charAt(1))) {
      for (var m = 2; ru != e.charAt(m) && (IM != e.charAt(m) || AM != e.charAt(m + 1)); )
        ++m;
      if (m += 2, ru === e.charAt(m - 1))
        return s("End of comment missing");
      var v = e.slice(2, m - 2);
      return r += 2, o(v), e = e.slice(m), r += 2, f({
        type: _ne,
        comment: v
      });
    }
  }
  function d() {
    var f = i(), m = l(xne);
    if (m) {
      if (p(), !l(One)) return s("property missing ':'");
      var v = l(Ene), E = f({
        type: Sne,
        property: RM(m[0].replace(jM, ru)),
        value: v ? RM(v[0].replace(jM, ru)) : ru
      });
      return l(kne), E;
    }
  }
  function g() {
    var f = [];
    c(f);
    for (var m; m = d(); )
      m !== !1 && (f.push(m), c(f));
    return f;
  }
  return u(), g();
};
function RM(e) {
  return e ? e.replace(Lne, ru) : ru;
}
var Dne = Xn && Xn.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(W1, "__esModule", { value: !0 });
W1.default = jne;
var Tne = Dne(Mne);
function jne(e, t) {
  var n = null;
  if (!e || typeof e != "string")
    return n;
  var r = (0, Tne.default)(e), o = typeof t == "function";
  return r.forEach(function(i) {
    if (i.type === "declaration") {
      var a = i.property, s = i.value;
      o ? t(a, s, i) : s && (n = n || {}, n[a] = s);
    }
  }), n;
}
var ob = {};
Object.defineProperty(ob, "__esModule", { value: !0 });
ob.camelCase = void 0;
var Ane = /^--[a-zA-Z0-9_-]+$/, Ine = /-([a-z])/g, Rne = /^[^-]+$/, Bne = /^-(webkit|moz|ms|o|khtml)-/, Nne = /^-(ms)-/, Fne = function(e) {
  return !e || Rne.test(e) || Ane.test(e);
}, zne = function(e, t) {
  return t.toUpperCase();
}, BM = function(e, t) {
  return "".concat(t, "-");
}, Une = function(e, t) {
  return t === void 0 && (t = {}), Fne(e) ? e : (e = e.toLowerCase(), t.reactCompat ? e = e.replace(Nne, BM) : e = e.replace(Bne, BM), e.replace(Ine, zne));
};
ob.camelCase = Une;
var Hne = Xn && Xn.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
}, $ne = Hne(W1), Wne = ob;
function nE(e, t) {
  var n = {};
  return !e || typeof e != "string" || (0, $ne.default)(e, function(r, o) {
    r && o && (n[(0, Wne.camelCase)(r, t)] = o);
  }), n;
}
nE.default = nE;
var Vne = nE;
(function(e) {
  var t = Xn && Xn.__importDefault || function(c) {
    return c && c.__esModule ? c : { default: c };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.returnFirstArg = e.canTextBeChildOfNode = e.ELEMENTS_WITH_NO_TEXT_CHILDREN = e.PRESERVE_CUSTOM_ATTRIBUTES = void 0, e.isCustomComponent = i, e.setStyleProp = s;
  var n = we, r = t(Vne), o = /* @__PURE__ */ new Set([
    "annotation-xml",
    "color-profile",
    "font-face",
    "font-face-src",
    "font-face-uri",
    "font-face-format",
    "font-face-name",
    "missing-glyph"
  ]);
  function i(c, p) {
    return c.includes("-") ? !o.has(c) : !!(p && typeof p.is == "string");
  }
  var a = {
    reactCompat: !0
  };
  function s(c, p) {
    if (typeof c == "string") {
      if (!c.trim()) {
        p.style = {};
        return;
      }
      try {
        p.style = (0, r.default)(c, a);
      } catch {
        p.style = {};
      }
    }
  }
  e.PRESERVE_CUSTOM_ATTRIBUTES = Number(n.version.split(".")[0]) >= 16, e.ELEMENTS_WITH_NO_TEXT_CHILDREN = /* @__PURE__ */ new Set([
    "tr",
    "tbody",
    "thead",
    "tfoot",
    "colgroup",
    "table",
    "head",
    "html",
    "frameset"
  ]);
  var l = function(c) {
    return !e.ELEMENTS_WITH_NO_TEXT_CHILDREN.has(c.name);
  };
  e.canTextBeChildOfNode = l;
  var u = function(c) {
    return c;
  };
  e.returnFirstArg = u;
})($1);
Object.defineProperty(eb, "__esModule", { value: !0 });
eb.default = Kne;
var Lp = cs, NM = $1, Zne = ["checked", "value"], qne = ["input", "select", "textarea"], Gne = {
  reset: !0,
  submit: !0
};
function Kne(e, t) {
  e === void 0 && (e = {});
  var n = {}, r = !!(e.type && Gne[e.type]);
  for (var o in e) {
    var i = e[o];
    if ((0, Lp.isCustomAttribute)(o)) {
      n[o] = i;
      continue;
    }
    var a = o.toLowerCase(), s = FM(a);
    if (s) {
      var l = (0, Lp.getPropertyInfo)(s);
      switch (Zne.includes(s) && qne.includes(t) && !r && (s = FM("default" + a)), n[s] = i, l && l.type) {
        case Lp.BOOLEAN:
          n[s] = !0;
          break;
        case Lp.OVERLOADED_BOOLEAN:
          i === "" && (n[s] = !0);
          break;
      }
      continue;
    }
    NM.PRESERVE_CUSTOM_ATTRIBUTES && (n[o] = i);
  }
  return (0, NM.setStyleProp)(e.style, n), n;
}
function FM(e) {
  return Lp.possibleStandardNames[e];
}
var V1 = {}, Yne = Xn && Xn.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(V1, "__esModule", { value: !0 });
V1.default = w8;
var T0 = we, Xne = Yne(eb), Up = $1, Jne = {
  cloneElement: T0.cloneElement,
  createElement: T0.createElement,
  isValidElement: T0.isValidElement
};
function w8(e, t) {
  t === void 0 && (t = {});
  for (var n = [], r = typeof t.replace == "function", o = t.transform || Up.returnFirstArg, i = t.library || Jne, a = i.cloneElement, s = i.createElement, l = i.isValidElement, u = e.length, c = 0; c < u; c++) {
    var p = e[c];
    if (r) {
      var d = t.replace(p, c);
      if (l(d)) {
        u > 1 && (d = a(d, {
          key: d.key || c
        })), n.push(o(d, p, c));
        continue;
      }
    }
    if (p.type === "text") {
      var g = !p.data.trim().length;
      if (g && p.parent && !(0, Up.canTextBeChildOfNode)(p.parent) || t.trim && g)
        continue;
      n.push(o(p.data, p, c));
      continue;
    }
    var f = p, m = {};
    Qne(f) ? ((0, Up.setStyleProp)(f.attribs.style, f.attribs), m = f.attribs) : f.attribs && (m = (0, Xne.default)(f.attribs, f.name));
    var v = void 0;
    switch (p.type) {
      case "script":
      case "style":
        p.children[0] && (m.dangerouslySetInnerHTML = {
          __html: p.children[0].data
        });
        break;
      case "tag":
        p.name === "textarea" && p.children[0] ? m.defaultValue = p.children[0].data : p.children && p.children.length && (v = w8(p.children, t));
        break;
      default:
        continue;
    }
    u > 1 && (m.key = c), n.push(o(s(p.name, m, v), p, c));
  }
  return n.length === 1 ? n[0] : n;
}
function Qne(e) {
  return Up.PRESERVE_CUSTOM_ATTRIBUTES && e.type === "tag" && (0, Up.isCustomComponent)(e.name, e.attribs);
}
(function(e) {
  var t = Xn && Xn.__importDefault || function(l) {
    return l && l.__esModule ? l : { default: l };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.htmlToDOM = e.domToReact = e.attributesToProps = e.Text = e.ProcessingInstruction = e.Element = e.Comment = void 0, e.default = s;
  var n = t(A1);
  e.htmlToDOM = n.default;
  var r = t(eb);
  e.attributesToProps = r.default;
  var o = t(V1);
  e.domToReact = o.default;
  var i = R1;
  Object.defineProperty(e, "Comment", { enumerable: !0, get: function() {
    return i.Comment;
  } }), Object.defineProperty(e, "Element", { enumerable: !0, get: function() {
    return i.Element;
  } }), Object.defineProperty(e, "ProcessingInstruction", { enumerable: !0, get: function() {
    return i.ProcessingInstruction;
  } }), Object.defineProperty(e, "Text", { enumerable: !0, get: function() {
    return i.Text;
  } });
  var a = { lowerCaseAttributeNames: !1 };
  function s(l, u) {
    if (typeof l != "string")
      throw new TypeError("First argument must be a string");
    return l ? (0, o.default)((0, n.default)(l, (u == null ? void 0 : u.htmlparser2) || a), u) : [];
  }
})(e8);
const zM = /* @__PURE__ */ qy(e8), ere = zM.default || zM, rE = (e) => {
  var r;
  if (typeof e == "string")
    return { text: e };
  const t = Array.isArray(e.props.children) ? e.props.children.map((o) => rE(o)) : [{ text: e.props.children || "" }], n = (r = e.props.className) == null ? void 0 : r.replace("align_", "");
  switch (e.type) {
    case "img":
      return {
        type: "image",
        align: n,
        src: e.props.src,
        children: [{ text: "" }]
      };
    case "p":
      return { type: "paragraph", align: n, children: t };
    case "blockquote":
      return { type: "blockQuote", align: n, children: t };
    case "ul":
      return { type: "bulletedList", align: n, children: t };
    case "ol":
      return { type: "numberedList", align: n, children: t };
    case "li":
      return { type: "listItem", align: n, children: t };
    case "h1":
      return { type: "headingOne", align: n, children: t };
    case "h2":
      return { type: "headingTwo", align: n, children: t };
    case "strong":
      return { text: e.props.children, bold: !0 };
    case "code":
      return { text: e.props.children, code: !0 };
    case "em":
      return { text: e.props.children, italic: !0 };
    case "u":
      return { text: e.props.children, underline: !0 };
    default:
      return { text: e.props.children || "" };
  }
}, m4e = (e) => {
  const t = ere(e);
  return Array.isArray(t) ? t.map((n) => typeof n == "string" ? { text: n } : rE(n)) : typeof t == "string" ? [{ text: t }] : [rE(t)];
}, v4e = (e) => /<\/?[a-z][\s\S]*>/i.test(e);
function C8(e, t, n) {
  if (!e) return /* @__PURE__ */ Q.jsx(Q.Fragment, {});
  if (typeof e == "string") return /* @__PURE__ */ Q.jsx("p", { className: n, children: e });
  const r = e;
  return /* @__PURE__ */ Q.jsx("p", { className: n, children: /* @__PURE__ */ Q.jsx(r, { color: "var(--secondary-600)", size: t, strokeWidth: 2.5 }) });
}
function y4e(e) {
  const {
    variant: t = "ghost",
    scheme: n = "primary",
    size: r = "md",
    leftIcon: o,
    rightIcon: i,
    className: a = "",
    children: s,
    ...l
  } = e, c = { md: 12, lg: 14 }[r], p = `arkynBadge ${t} ${n} ${r} ${a}`;
  return /* @__PURE__ */ Q.jsxs("div", { className: p.trim(), ...l, children: [
    Fm(c, o),
    s,
    Fm(c, i)
  ] });
}
function b4e(e) {
  const { className: t, ...n } = e, r = `arkynCard ${t}`;
  return /* @__PURE__ */ Q.jsx("div", { className: r.trim(), ...n });
}
function x8(e) {
  const {
    className: t,
    orientation: n = "horizontal",
    ...r
  } = e, o = `arkynDivider ${n} ${t}`;
  return /* @__PURE__ */ Q.jsx("div", { className: o.trim(), ...r });
}
function w4e(e) {
  const { className: t, ...n } = e, r = `arkynSkeleton ${t}`;
  return /* @__PURE__ */ Q.jsx("aside", { className: r.trim(), ...n });
}
function C4e(e) {
  const {
    emptyMessage: t = "Nenhum dado adicionado.",
    className: n,
    children: r,
    ...o
  } = e, i = `arkynTableBody ${n}`, a = lt.count(r) === 0;
  return /* @__PURE__ */ Q.jsx("tbody", { className: i.trim(), ...o, children: a ? /* @__PURE__ */ Q.jsx("tr", { className: "arkynTableBodyEmptyLine", children: /* @__PURE__ */ Q.jsx("td", { colSpan: 100, children: /* @__PURE__ */ Q.jsx("div", { children: t }) }) }) : r });
}
function x4e(e) {
  const { className: t, children: n, ...r } = e, o = `arkynTableCaption ${t}`;
  return /* @__PURE__ */ Q.jsx("caption", { className: o.trim(), ...r, children: /* @__PURE__ */ Q.jsx("div", { className: "arkynTableCaptionContent", children: n }) });
}
function O4e(e) {
  const { children: t, className: n, ...r } = e, o = `arkynTableContainer ${n}`;
  return /* @__PURE__ */ Q.jsx("div", { className: o.trim(), ...r, children: /* @__PURE__ */ Q.jsx("table", { children: t }) });
}
function E4e(e) {
  const { className: t, children: n, ...r } = e, o = `arkynTableFooter ${t}`;
  return /* @__PURE__ */ Q.jsxs("tfoot", { className: o.trim(), ...r, children: [
    /* @__PURE__ */ Q.jsx("tr", { className: "spacingRow" }),
    /* @__PURE__ */ Q.jsx("tr", { children: /* @__PURE__ */ Q.jsx("th", { colSpan: 100, children: /* @__PURE__ */ Q.jsx("div", { className: "arkynTableFooterContent", children: n }) }) })
  ] });
}
function k4e(e) {
  const { className: t, children: n, ...r } = e, o = `arkynTableHeader ${t}`;
  return /* @__PURE__ */ Q.jsxs("thead", { className: o.trim(), ...r, children: [
    /* @__PURE__ */ Q.jsx("tr", { children: n }),
    /* @__PURE__ */ Q.jsx("tr", { className: "spacingRow" })
  ] });
}
var Jn = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function tre(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var oE = { exports: {} }, Vc = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var UM;
function nre() {
  if (UM) return Vc;
  UM = 1;
  var e = we, t = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, o = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, i = { key: !0, ref: !0, __self: !0, __source: !0 };
  function a(s, l, u) {
    var c, p = {}, d = null, g = null;
    u !== void 0 && (d = "" + u), l.key !== void 0 && (d = "" + l.key), l.ref !== void 0 && (g = l.ref);
    for (c in l) r.call(l, c) && !i.hasOwnProperty(c) && (p[c] = l[c]);
    if (s && s.defaultProps) for (c in l = s.defaultProps, l) p[c] === void 0 && (p[c] = l[c]);
    return { $$typeof: t, type: s, key: d, ref: g, props: p, _owner: o.current };
  }
  return Vc.Fragment = n, Vc.jsx = a, Vc.jsxs = a, Vc;
}
var bh = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var HM;
function rre() {
  return HM || (HM = 1, process.env.NODE_ENV !== "production" && function() {
    var e = we, t = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), a = Symbol.for("react.provider"), s = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), c = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), d = Symbol.for("react.lazy"), g = Symbol.for("react.offscreen"), f = Symbol.iterator, m = "@@iterator";
    function v(b) {
      if (b === null || typeof b != "object")
        return null;
      var I = f && b[f] || b[m];
      return typeof I == "function" ? I : null;
    }
    var E = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function w(b) {
      {
        for (var I = arguments.length, G = new Array(I > 1 ? I - 1 : 0), ne = 1; ne < I; ne++)
          G[ne - 1] = arguments[ne];
        M("error", b, G);
      }
    }
    function M(b, I, G) {
      {
        var ne = E.ReactDebugCurrentFrame, le = ne.getStackAddendum();
        le !== "" && (I += "%s", G = G.concat([le]));
        var ce = G.map(function(se) {
          return String(se);
        });
        ce.unshift("Warning: " + I), Function.prototype.apply.call(console[b], console, ce);
      }
    }
    var O = !1, y = !1, C = !1, _ = !1, F = !1, L;
    L = Symbol.for("react.module.reference");
    function N(b) {
      return !!(typeof b == "string" || typeof b == "function" || b === r || b === i || F || b === o || b === u || b === c || _ || b === g || O || y || C || typeof b == "object" && b !== null && (b.$$typeof === d || b.$$typeof === p || b.$$typeof === a || b.$$typeof === s || b.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      b.$$typeof === L || b.getModuleId !== void 0));
    }
    function R(b, I, G) {
      var ne = b.displayName;
      if (ne)
        return ne;
      var le = I.displayName || I.name || "";
      return le !== "" ? G + "(" + le + ")" : G;
    }
    function W(b) {
      return b.displayName || "Context";
    }
    function V(b) {
      if (b == null)
        return null;
      if (typeof b.tag == "number" && w("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof b == "function")
        return b.displayName || b.name || null;
      if (typeof b == "string")
        return b;
      switch (b) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case i:
          return "Profiler";
        case o:
          return "StrictMode";
        case u:
          return "Suspense";
        case c:
          return "SuspenseList";
      }
      if (typeof b == "object")
        switch (b.$$typeof) {
          case s:
            var I = b;
            return W(I) + ".Consumer";
          case a:
            var G = b;
            return W(G._context) + ".Provider";
          case l:
            return R(b, b.render, "ForwardRef");
          case p:
            var ne = b.displayName || null;
            return ne !== null ? ne : V(b.type) || "Memo";
          case d: {
            var le = b, ce = le._payload, se = le._init;
            try {
              return V(se(ce));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var z = Object.assign, Z = 0, K, X, te, J, P, D, H;
    function S() {
    }
    S.__reactDisabledLog = !0;
    function $() {
      {
        if (Z === 0) {
          K = console.log, X = console.info, te = console.warn, J = console.error, P = console.group, D = console.groupCollapsed, H = console.groupEnd;
          var b = {
            configurable: !0,
            enumerable: !0,
            value: S,
            writable: !0
          };
          Object.defineProperties(console, {
            info: b,
            log: b,
            warn: b,
            error: b,
            group: b,
            groupCollapsed: b,
            groupEnd: b
          });
        }
        Z++;
      }
    }
    function x() {
      {
        if (Z--, Z === 0) {
          var b = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: z({}, b, {
              value: K
            }),
            info: z({}, b, {
              value: X
            }),
            warn: z({}, b, {
              value: te
            }),
            error: z({}, b, {
              value: J
            }),
            group: z({}, b, {
              value: P
            }),
            groupCollapsed: z({}, b, {
              value: D
            }),
            groupEnd: z({}, b, {
              value: H
            })
          });
        }
        Z < 0 && w("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var j = E.ReactCurrentDispatcher, U;
    function T(b, I, G) {
      {
        if (U === void 0)
          try {
            throw Error();
          } catch (le) {
            var ne = le.stack.trim().match(/\n( *(at )?)/);
            U = ne && ne[1] || "";
          }
        return `
` + U + b;
      }
    }
    var q = !1, A;
    {
      var Y = typeof WeakMap == "function" ? WeakMap : Map;
      A = new Y();
    }
    function B(b, I) {
      if (!b || q)
        return "";
      {
        var G = A.get(b);
        if (G !== void 0)
          return G;
      }
      var ne;
      q = !0;
      var le = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var ce;
      ce = j.current, j.current = null, $();
      try {
        if (I) {
          var se = function() {
            throw Error();
          };
          if (Object.defineProperty(se.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(se, []);
            } catch (je) {
              ne = je;
            }
            Reflect.construct(b, [], se);
          } else {
            try {
              se.call();
            } catch (je) {
              ne = je;
            }
            b.call(se.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (je) {
            ne = je;
          }
          b();
        }
      } catch (je) {
        if (je && ne && typeof je.stack == "string") {
          for (var ie = je.stack.split(`
`), Se = ne.stack.split(`
`), de = ie.length - 1, he = Se.length - 1; de >= 1 && he >= 0 && ie[de] !== Se[he]; )
            he--;
          for (; de >= 1 && he >= 0; de--, he--)
            if (ie[de] !== Se[he]) {
              if (de !== 1 || he !== 1)
                do
                  if (de--, he--, he < 0 || ie[de] !== Se[he]) {
                    var Ve = `
` + ie[de].replace(" at new ", " at ");
                    return b.displayName && Ve.includes("<anonymous>") && (Ve = Ve.replace("<anonymous>", b.displayName)), typeof b == "function" && A.set(b, Ve), Ve;
                  }
                while (de >= 1 && he >= 0);
              break;
            }
        }
      } finally {
        q = !1, j.current = ce, x(), Error.prepareStackTrace = le;
      }
      var xt = b ? b.displayName || b.name : "", vt = xt ? T(xt) : "";
      return typeof b == "function" && A.set(b, vt), vt;
    }
    function ue(b, I, G) {
      return B(b, !1);
    }
    function fe(b) {
      var I = b.prototype;
      return !!(I && I.isReactComponent);
    }
    function oe(b, I, G) {
      if (b == null)
        return "";
      if (typeof b == "function")
        return B(b, fe(b));
      if (typeof b == "string")
        return T(b);
      switch (b) {
        case u:
          return T("Suspense");
        case c:
          return T("SuspenseList");
      }
      if (typeof b == "object")
        switch (b.$$typeof) {
          case l:
            return ue(b.render);
          case p:
            return oe(b.type, I, G);
          case d: {
            var ne = b, le = ne._payload, ce = ne._init;
            try {
              return oe(ce(le), I, G);
            } catch {
            }
          }
        }
      return "";
    }
    var Ae = Object.prototype.hasOwnProperty, Ze = {}, Ge = E.ReactDebugCurrentFrame;
    function Ie(b) {
      if (b) {
        var I = b._owner, G = oe(b.type, b._source, I ? I.type : null);
        Ge.setExtraStackFrame(G);
      } else
        Ge.setExtraStackFrame(null);
    }
    function et(b, I, G, ne, le) {
      {
        var ce = Function.call.bind(Ae);
        for (var se in b)
          if (ce(b, se)) {
            var ie = void 0;
            try {
              if (typeof b[se] != "function") {
                var Se = Error((ne || "React class") + ": " + G + " type `" + se + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof b[se] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw Se.name = "Invariant Violation", Se;
              }
              ie = b[se](I, se, ne, G, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (de) {
              ie = de;
            }
            ie && !(ie instanceof Error) && (Ie(le), w("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", ne || "React class", G, se, typeof ie), Ie(null)), ie instanceof Error && !(ie.message in Ze) && (Ze[ie.message] = !0, Ie(le), w("Failed %s type: %s", G, ie.message), Ie(null));
          }
      }
    }
    var Ye = Array.isArray;
    function _e(b) {
      return Ye(b);
    }
    function Qe(b) {
      {
        var I = typeof Symbol == "function" && Symbol.toStringTag, G = I && b[Symbol.toStringTag] || b.constructor.name || "Object";
        return G;
      }
    }
    function at(b) {
      try {
        return Pe(b), !1;
      } catch {
        return !0;
      }
    }
    function Pe(b) {
      return "" + b;
    }
    function Me(b) {
      if (at(b))
        return w("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Qe(b)), Pe(b);
    }
    var Je = E.ReactCurrentOwner, We = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, Re, nt;
    function De(b) {
      if (Ae.call(b, "ref")) {
        var I = Object.getOwnPropertyDescriptor(b, "ref").get;
        if (I && I.isReactWarning)
          return !1;
      }
      return b.ref !== void 0;
    }
    function yt(b) {
      if (Ae.call(b, "key")) {
        var I = Object.getOwnPropertyDescriptor(b, "key").get;
        if (I && I.isReactWarning)
          return !1;
      }
      return b.key !== void 0;
    }
    function ot(b, I) {
      typeof b.ref == "string" && Je.current;
    }
    function st(b, I) {
      {
        var G = function() {
          Re || (Re = !0, w("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", I));
        };
        G.isReactWarning = !0, Object.defineProperty(b, "key", {
          get: G,
          configurable: !0
        });
      }
    }
    function ct(b, I) {
      {
        var G = function() {
          nt || (nt = !0, w("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", I));
        };
        G.isReactWarning = !0, Object.defineProperty(b, "ref", {
          get: G,
          configurable: !0
        });
      }
    }
    var bt = function(b, I, G, ne, le, ce, se) {
      var ie = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: b,
        key: I,
        ref: G,
        props: se,
        // Record the component responsible for creating this element.
        _owner: ce
      };
      return ie._store = {}, Object.defineProperty(ie._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(ie, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ne
      }), Object.defineProperty(ie, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: le
      }), Object.freeze && (Object.freeze(ie.props), Object.freeze(ie)), ie;
    };
    function pt(b, I, G, ne, le) {
      {
        var ce, se = {}, ie = null, Se = null;
        G !== void 0 && (Me(G), ie = "" + G), yt(I) && (Me(I.key), ie = "" + I.key), De(I) && (Se = I.ref, ot(I));
        for (ce in I)
          Ae.call(I, ce) && !We.hasOwnProperty(ce) && (se[ce] = I[ce]);
        if (b && b.defaultProps) {
          var de = b.defaultProps;
          for (ce in de)
            se[ce] === void 0 && (se[ce] = de[ce]);
        }
        if (ie || Se) {
          var he = typeof b == "function" ? b.displayName || b.name || "Unknown" : b;
          ie && st(se, he), Se && ct(se, he);
        }
        return bt(b, ie, Se, le, ne, Je.current, se);
      }
    }
    var dt = E.ReactCurrentOwner, tt = E.ReactDebugCurrentFrame;
    function Xe(b) {
      if (b) {
        var I = b._owner, G = oe(b.type, b._source, I ? I.type : null);
        tt.setExtraStackFrame(G);
      } else
        tt.setExtraStackFrame(null);
    }
    var wt;
    wt = !1;
    function Ct(b) {
      return typeof b == "object" && b !== null && b.$$typeof === t;
    }
    function ft() {
      {
        if (dt.current) {
          var b = V(dt.current.type);
          if (b)
            return `

Check the render method of \`` + b + "`.";
        }
        return "";
      }
    }
    function bn(b) {
      return "";
    }
    var ht = {};
    function wn(b) {
      {
        var I = ft();
        if (!I) {
          var G = typeof b == "string" ? b : b.displayName || b.name;
          G && (I = `

Check the top-level render call using <` + G + ">.");
        }
        return I;
      }
    }
    function gt(b, I) {
      {
        if (!b._store || b._store.validated || b.key != null)
          return;
        b._store.validated = !0;
        var G = wn(I);
        if (ht[G])
          return;
        ht[G] = !0;
        var ne = "";
        b && b._owner && b._owner !== dt.current && (ne = " It was passed a child from " + V(b._owner.type) + "."), Xe(b), w('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', G, ne), Xe(null);
      }
    }
    function Mt(b, I) {
      {
        if (typeof b != "object")
          return;
        if (_e(b))
          for (var G = 0; G < b.length; G++) {
            var ne = b[G];
            Ct(ne) && gt(ne, I);
          }
        else if (Ct(b))
          b._store && (b._store.validated = !0);
        else if (b) {
          var le = v(b);
          if (typeof le == "function" && le !== b.entries)
            for (var ce = le.call(b), se; !(se = ce.next()).done; )
              Ct(se.value) && gt(se.value, I);
        }
      }
    }
    function ir(b) {
      {
        var I = b.type;
        if (I == null || typeof I == "string")
          return;
        var G;
        if (typeof I == "function")
          G = I.propTypes;
        else if (typeof I == "object" && (I.$$typeof === l || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        I.$$typeof === p))
          G = I.propTypes;
        else
          return;
        if (G) {
          var ne = V(I);
          et(G, b.props, "prop", ne, b);
        } else if (I.PropTypes !== void 0 && !wt) {
          wt = !0;
          var le = V(I);
          w("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", le || "Unknown");
        }
        typeof I.getDefaultProps == "function" && !I.getDefaultProps.isReactClassApproved && w("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function mt(b) {
      {
        for (var I = Object.keys(b.props), G = 0; G < I.length; G++) {
          var ne = I[G];
          if (ne !== "children" && ne !== "key") {
            Xe(b), w("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", ne), Xe(null);
            break;
          }
        }
        b.ref !== null && (Xe(b), w("Invalid attribute `ref` supplied to `React.Fragment`."), Xe(null));
      }
    }
    var re = {};
    function vo(b, I, G, ne, le, ce) {
      {
        var se = N(b);
        if (!se) {
          var ie = "";
          (b === void 0 || typeof b == "object" && b !== null && Object.keys(b).length === 0) && (ie += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var Se = bn();
          Se ? ie += Se : ie += ft();
          var de;
          b === null ? de = "null" : _e(b) ? de = "array" : b !== void 0 && b.$$typeof === t ? (de = "<" + (V(b.type) || "Unknown") + " />", ie = " Did you accidentally export a JSX literal instead of a component?") : de = typeof b, w("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", de, ie);
        }
        var he = pt(b, I, G, le, ce);
        if (he == null)
          return he;
        if (se) {
          var Ve = I.children;
          if (Ve !== void 0)
            if (ne)
              if (_e(Ve)) {
                for (var xt = 0; xt < Ve.length; xt++)
                  Mt(Ve[xt], b);
                Object.freeze && Object.freeze(Ve);
              } else
                w("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Mt(Ve, b);
        }
        if (Ae.call(I, "key")) {
          var vt = V(b), je = Object.keys(I).filter(function(Li) {
            return Li !== "key";
          }), sr = je.length > 0 ? "{key: someKey, " + je.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!re[vt + sr]) {
            var ki = je.length > 0 ? "{" + je.join(": ..., ") + ": ...}" : "{}";
            w(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, sr, vt, ki, vt), re[vt + sr] = !0;
          }
        }
        return b === r ? mt(he) : ir(he), he;
      }
    }
    function Ci(b, I, G) {
      return vo(b, I, G, !0);
    }
    function xi(b, I, G) {
      return vo(b, I, G, !1);
    }
    var Oi = xi, Ei = Ci;
    bh.Fragment = r, bh.jsx = Oi, bh.jsxs = Ei;
  }()), bh;
}
process.env.NODE_ENV === "production" ? oE.exports = nre() : oE.exports = rre();
var Sn = oE.exports;
Ke({});
function $M(e, t) {
  return t ? /* @__PURE__ */ Sn.jsx(t, { size: e, strokeWidth: 2.5 }) : /* @__PURE__ */ Sn.jsx(Sn.Fragment, {});
}
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function WM(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function Fo(e) {
  var t, n;
  return WM(e) === !1 ? !1 : (t = e.constructor, t === void 0 ? !0 : (n = t.prototype, !(WM(n) === !1 || n.hasOwnProperty("isPrototypeOf") === !1)));
}
var O8 = Symbol.for("immer-nothing"), VM = Symbol.for("immer-draftable"), Hi = Symbol.for("immer-state"), ore = process.env.NODE_ENV !== "production" ? [
  // All error codes, starting by 0:
  function(e) {
    return `The plugin for '${e}' has not been loaded into Immer. To enable the plugin, import and call \`enable${e}()\` when initializing your application.`;
  },
  function(e) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${e}'`;
  },
  "This object has been frozen and should not be mutated",
  function(e) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + e;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(e) {
    return `'current' expects a draft, got: ${e}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(e) {
    return `'original' expects a draft, got: ${e}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function ii(e, ...t) {
  if (process.env.NODE_ENV !== "production") {
    const n = ore[e], r = typeof n == "function" ? n.apply(null, t) : n;
    throw new Error(`[Immer] ${r}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var fc = Object.getPrototypeOf;
function Lu(e) {
  return !!e && !!e[Hi];
}
function Pu(e) {
  var t;
  return e ? E8(e) || Array.isArray(e) || !!e[VM] || !!((t = e.constructor) != null && t[VM]) || sb(e) || ab(e) : !1;
}
var ire = Object.prototype.constructor.toString();
function E8(e) {
  if (!e || typeof e != "object")
    return !1;
  const t = fc(e);
  if (t === null)
    return !0;
  const n = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
  return n === Object ? !0 : typeof n == "function" && Function.toString.call(n) === ire;
}
function Zm(e, t) {
  ib(e) === 0 ? Reflect.ownKeys(e).forEach((n) => {
    t(n, e[n], e);
  }) : e.forEach((n, r) => t(r, n, e));
}
function ib(e) {
  const t = e[Hi];
  return t ? t.type_ : Array.isArray(e) ? 1 : sb(e) ? 2 : ab(e) ? 3 : 0;
}
function iE(e, t) {
  return ib(e) === 2 ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t);
}
function k8(e, t, n) {
  const r = ib(e);
  r === 2 ? e.set(t, n) : r === 3 ? e.add(n) : e[t] = n;
}
function sre(e, t) {
  return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && t !== t;
}
function sb(e) {
  return e instanceof Map;
}
function ab(e) {
  return e instanceof Set;
}
function Yl(e) {
  return e.copy_ || e.base_;
}
function sE(e, t) {
  if (sb(e))
    return new Map(e);
  if (ab(e))
    return new Set(e);
  if (Array.isArray(e))
    return Array.prototype.slice.call(e);
  const n = E8(e);
  if (t === !0 || t === "class_only" && !n) {
    const r = Object.getOwnPropertyDescriptors(e);
    delete r[Hi];
    let o = Reflect.ownKeys(r);
    for (let i = 0; i < o.length; i++) {
      const a = o[i], s = r[a];
      s.writable === !1 && (s.writable = !0, s.configurable = !0), (s.get || s.set) && (r[a] = {
        configurable: !0,
        writable: !0,
        // could live with !!desc.set as well here...
        enumerable: s.enumerable,
        value: e[a]
      });
    }
    return Object.create(fc(e), r);
  } else {
    const r = fc(e);
    if (r !== null && n)
      return { ...e };
    const o = Object.create(r);
    return Object.assign(o, e);
  }
}
function Z1(e, t = !1) {
  return lb(e) || Lu(e) || !Pu(e) || (ib(e) > 1 && (e.set = e.add = e.clear = e.delete = are), Object.freeze(e), t && Object.entries(e).forEach(([n, r]) => Z1(r, !0))), e;
}
function are() {
  ii(2);
}
function lb(e) {
  return Object.isFrozen(e);
}
var lre = {};
function _u(e) {
  const t = lre[e];
  return t || ii(0, e), t;
}
var xd;
function L8() {
  return xd;
}
function ure(e, t) {
  return {
    drafts_: [],
    parent_: e,
    immer_: t,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0
  };
}
function ZM(e, t) {
  t && (_u("Patches"), e.patches_ = [], e.inversePatches_ = [], e.patchListener_ = t);
}
function aE(e) {
  lE(e), e.drafts_.forEach(cre), e.drafts_ = null;
}
function lE(e) {
  e === xd && (xd = e.parent_);
}
function qM(e) {
  return xd = ure(xd, e);
}
function cre(e) {
  const t = e[Hi];
  t.type_ === 0 || t.type_ === 1 ? t.revoke_() : t.revoked_ = !0;
}
function GM(e, t) {
  t.unfinalizedDrafts_ = t.drafts_.length;
  const n = t.drafts_[0];
  return e !== void 0 && e !== n ? (n[Hi].modified_ && (aE(t), ii(4)), Pu(e) && (e = qm(t, e), t.parent_ || Gm(t, e)), t.patches_ && _u("Patches").generateReplacementPatches_(
    n[Hi].base_,
    e,
    t.patches_,
    t.inversePatches_
  )) : e = qm(t, n, []), aE(t), t.patches_ && t.patchListener_(t.patches_, t.inversePatches_), e !== O8 ? e : void 0;
}
function qm(e, t, n) {
  if (lb(t))
    return t;
  const r = t[Hi];
  if (!r)
    return Zm(
      t,
      (o, i) => KM(e, r, t, o, i, n)
    ), t;
  if (r.scope_ !== e)
    return t;
  if (!r.modified_)
    return Gm(e, r.base_, !0), r.base_;
  if (!r.finalized_) {
    r.finalized_ = !0, r.scope_.unfinalizedDrafts_--;
    const o = r.copy_;
    let i = o, a = !1;
    r.type_ === 3 && (i = new Set(o), o.clear(), a = !0), Zm(
      i,
      (s, l) => KM(e, r, o, s, l, n, a)
    ), Gm(e, o, !1), n && e.patches_ && _u("Patches").generatePatches_(
      r,
      n,
      e.patches_,
      e.inversePatches_
    );
  }
  return r.copy_;
}
function KM(e, t, n, r, o, i, a) {
  if (process.env.NODE_ENV !== "production" && o === n && ii(5), Lu(o)) {
    const s = i && t && t.type_ !== 3 && // Set objects are atomic since they have no keys.
    !iE(t.assigned_, r) ? i.concat(r) : void 0, l = qm(e, o, s);
    if (k8(n, r, l), Lu(l))
      e.canAutoFreeze_ = !1;
    else
      return;
  } else a && n.add(o);
  if (Pu(o) && !lb(o)) {
    if (!e.immer_.autoFreeze_ && e.unfinalizedDrafts_ < 1)
      return;
    qm(e, o), (!t || !t.scope_.parent_) && typeof r != "symbol" && Object.prototype.propertyIsEnumerable.call(n, r) && Gm(e, o);
  }
}
function Gm(e, t, n = !1) {
  !e.parent_ && e.immer_.autoFreeze_ && e.canAutoFreeze_ && Z1(t, n);
}
function pre(e, t) {
  const n = Array.isArray(e), r = {
    type_: n ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: t ? t.scope_ : L8(),
    // True for both shallow and deep changes.
    modified_: !1,
    // Used during finalization.
    finalized_: !1,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: t,
    // The base state.
    base_: e,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: !1
  };
  let o = r, i = q1;
  n && (o = [r], i = Od);
  const { revoke: a, proxy: s } = Proxy.revocable(o, i);
  return r.draft_ = s, r.revoke_ = a, s;
}
var q1 = {
  get(e, t) {
    if (t === Hi)
      return e;
    const n = Yl(e);
    if (!iE(n, t))
      return dre(e, n, t);
    const r = n[t];
    return e.finalized_ || !Pu(r) ? r : r === j0(e.base_, t) ? (A0(e), e.copy_[t] = cE(r, e)) : r;
  },
  has(e, t) {
    return t in Yl(e);
  },
  ownKeys(e) {
    return Reflect.ownKeys(Yl(e));
  },
  set(e, t, n) {
    const r = P8(Yl(e), t);
    if (r != null && r.set)
      return r.set.call(e.draft_, n), !0;
    if (!e.modified_) {
      const o = j0(Yl(e), t), i = o == null ? void 0 : o[Hi];
      if (i && i.base_ === n)
        return e.copy_[t] = n, e.assigned_[t] = !1, !0;
      if (sre(n, o) && (n !== void 0 || iE(e.base_, t)))
        return !0;
      A0(e), uE(e);
    }
    return e.copy_[t] === n && // special case: handle new props with value 'undefined'
    (n !== void 0 || t in e.copy_) || // special case: NaN
    Number.isNaN(n) && Number.isNaN(e.copy_[t]) || (e.copy_[t] = n, e.assigned_[t] = !0), !0;
  },
  deleteProperty(e, t) {
    return j0(e.base_, t) !== void 0 || t in e.base_ ? (e.assigned_[t] = !1, A0(e), uE(e)) : delete e.assigned_[t], e.copy_ && delete e.copy_[t], !0;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(e, t) {
    const n = Yl(e), r = Reflect.getOwnPropertyDescriptor(n, t);
    return r && {
      writable: !0,
      configurable: e.type_ !== 1 || t !== "length",
      enumerable: r.enumerable,
      value: n[t]
    };
  },
  defineProperty() {
    ii(11);
  },
  getPrototypeOf(e) {
    return fc(e.base_);
  },
  setPrototypeOf() {
    ii(12);
  }
}, Od = {};
Zm(q1, (e, t) => {
  Od[e] = function() {
    return arguments[0] = arguments[0][0], t.apply(this, arguments);
  };
});
Od.deleteProperty = function(e, t) {
  return process.env.NODE_ENV !== "production" && isNaN(parseInt(t)) && ii(13), Od.set.call(this, e, t, void 0);
};
Od.set = function(e, t, n) {
  return process.env.NODE_ENV !== "production" && t !== "length" && isNaN(parseInt(t)) && ii(14), q1.set.call(this, e[0], t, n, e[0]);
};
function j0(e, t) {
  const n = e[Hi];
  return (n ? Yl(n) : e)[t];
}
function dre(e, t, n) {
  var r;
  const o = P8(t, n);
  return o ? "value" in o ? o.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (r = o.get) == null ? void 0 : r.call(e.draft_)
  ) : void 0;
}
function P8(e, t) {
  if (!(t in e))
    return;
  let n = fc(e);
  for (; n; ) {
    const r = Object.getOwnPropertyDescriptor(n, t);
    if (r)
      return r;
    n = fc(n);
  }
}
function uE(e) {
  e.modified_ || (e.modified_ = !0, e.parent_ && uE(e.parent_));
}
function A0(e) {
  e.copy_ || (e.copy_ = sE(
    e.base_,
    e.scope_.immer_.useStrictShallowCopy_
  ));
}
var fre = class {
  constructor(e) {
    this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.produce = (t, n, r) => {
      if (typeof t == "function" && typeof n != "function") {
        const i = n;
        n = t;
        const a = this;
        return function(s = i, ...l) {
          return a.produce(s, (u) => n.call(this, u, ...l));
        };
      }
      typeof n != "function" && ii(6), r !== void 0 && typeof r != "function" && ii(7);
      let o;
      if (Pu(t)) {
        const i = qM(this), a = cE(t, void 0);
        let s = !0;
        try {
          o = n(a), s = !1;
        } finally {
          s ? aE(i) : lE(i);
        }
        return ZM(i, r), GM(o, i);
      } else if (!t || typeof t != "object") {
        if (o = n(t), o === void 0 && (o = t), o === O8 && (o = void 0), this.autoFreeze_ && Z1(o, !0), r) {
          const i = [], a = [];
          _u("Patches").generateReplacementPatches_(t, o, i, a), r(i, a);
        }
        return o;
      } else
        ii(1, t);
    }, this.produceWithPatches = (t, n) => {
      if (typeof t == "function")
        return (i, ...a) => this.produceWithPatches(i, (s) => t(s, ...a));
      let r, o;
      return [this.produce(t, n, (i, a) => {
        r = i, o = a;
      }), r, o];
    }, typeof (e == null ? void 0 : e.autoFreeze) == "boolean" && this.setAutoFreeze(e.autoFreeze), typeof (e == null ? void 0 : e.useStrictShallowCopy) == "boolean" && this.setUseStrictShallowCopy(e.useStrictShallowCopy);
  }
  createDraft(e) {
    Pu(e) || ii(8), Lu(e) && (e = hre(e));
    const t = qM(this), n = cE(e, void 0);
    return n[Hi].isManual_ = !0, lE(t), n;
  }
  finishDraft(e, t) {
    const n = e && e[Hi];
    (!n || !n.isManual_) && ii(9);
    const { scope_: r } = n;
    return ZM(r, t), GM(void 0, r);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(e) {
    this.autoFreeze_ = e;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(e) {
    this.useStrictShallowCopy_ = e;
  }
  applyPatches(e, t) {
    let n;
    for (n = t.length - 1; n >= 0; n--) {
      const o = t[n];
      if (o.path.length === 0 && o.op === "replace") {
        e = o.value;
        break;
      }
    }
    n > -1 && (t = t.slice(n + 1));
    const r = _u("Patches").applyPatches_;
    return Lu(e) ? r(e, t) : this.produce(
      e,
      (o) => r(o, t)
    );
  }
};
function cE(e, t) {
  const n = sb(e) ? _u("MapSet").proxyMap_(e, t) : ab(e) ? _u("MapSet").proxySet_(e, t) : pre(e, t);
  return (t ? t.scope_ : L8()).drafts_.push(n), n;
}
function hre(e) {
  return Lu(e) || ii(10, e), _8(e);
}
function _8(e) {
  if (!Pu(e) || lb(e))
    return e;
  const t = e[Hi];
  let n;
  if (t) {
    if (!t.modified_)
      return t.base_;
    t.finalized_ = !0, n = sE(e, t.scope_.immer_.useStrictShallowCopy_);
  } else
    n = sE(e, !0);
  return Zm(n, (r, o) => {
    k8(n, r, _8(o));
  }), t && (t.finalized_ = !1), n;
}
var $i = new fre(), G1 = $i.produce;
$i.produceWithPatches.bind(
  $i
);
$i.setAutoFreeze.bind($i);
$i.setUseStrictShallowCopy.bind($i);
$i.applyPatches.bind($i);
var YM = $i.createDraft.bind($i), XM = $i.finishDraft.bind($i), Ne = {
  ancestors(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = Ne.levels(e, t);
    return n ? r = r.slice(1) : r = r.slice(0, -1), r;
  },
  common(e, t) {
    for (var n = [], r = 0; r < e.length && r < t.length; r++) {
      var o = e[r], i = t[r];
      if (o !== i)
        break;
      n.push(o);
    }
    return n;
  },
  compare(e, t) {
    for (var n = Math.min(e.length, t.length), r = 0; r < n; r++) {
      if (e[r] < t[r]) return -1;
      if (e[r] > t[r]) return 1;
    }
    return 0;
  },
  endsAfter(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return Ne.equals(r, o) && i > a;
  },
  endsAt(e, t) {
    var n = e.length, r = e.slice(0, n), o = t.slice(0, n);
    return Ne.equals(r, o);
  },
  endsBefore(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return Ne.equals(r, o) && i < a;
  },
  equals(e, t) {
    return e.length === t.length && e.every((n, r) => n === t[r]);
  },
  hasPrevious(e) {
    return e[e.length - 1] > 0;
  },
  isAfter(e, t) {
    return Ne.compare(e, t) === 1;
  },
  isAncestor(e, t) {
    return e.length < t.length && Ne.compare(e, t) === 0;
  },
  isBefore(e, t) {
    return Ne.compare(e, t) === -1;
  },
  isChild(e, t) {
    return e.length === t.length + 1 && Ne.compare(e, t) === 0;
  },
  isCommon(e, t) {
    return e.length <= t.length && Ne.compare(e, t) === 0;
  },
  isDescendant(e, t) {
    return e.length > t.length && Ne.compare(e, t) === 0;
  },
  isParent(e, t) {
    return e.length + 1 === t.length && Ne.compare(e, t) === 0;
  },
  isPath(e) {
    return Array.isArray(e) && (e.length === 0 || typeof e[0] == "number");
  },
  isSibling(e, t) {
    if (e.length !== t.length)
      return !1;
    var n = e.slice(0, -1), r = t.slice(0, -1), o = e[e.length - 1], i = t[t.length - 1];
    return o !== i && Ne.equals(n, r);
  },
  levels(e) {
    for (var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = [], o = 0; o <= e.length; o++)
      r.push(e.slice(0, o));
    return n && r.reverse(), r;
  },
  next(e) {
    if (e.length === 0)
      throw new Error("Cannot get the next path of a root path [".concat(e, "], because it has no next index."));
    var t = e[e.length - 1];
    return e.slice(0, -1).concat(t + 1);
  },
  operationCanTransformPath(e) {
    switch (e.type) {
      case "insert_node":
      case "remove_node":
      case "merge_node":
      case "split_node":
      case "move_node":
        return !0;
      default:
        return !1;
    }
  },
  parent(e) {
    if (e.length === 0)
      throw new Error("Cannot get the parent path of the root path [".concat(e, "]."));
    return e.slice(0, -1);
  },
  previous(e) {
    if (e.length === 0)
      throw new Error("Cannot get the previous path of a root path [".concat(e, "], because it has no previous index."));
    var t = e[e.length - 1];
    if (t <= 0)
      throw new Error("Cannot get the previous path of a first child path [".concat(e, "] because it would result in a negative index."));
    return e.slice(0, -1).concat(t - 1);
  },
  relative(e, t) {
    if (!Ne.isAncestor(t, e) && !Ne.equals(e, t))
      throw new Error("Cannot get the relative path of [".concat(e, "] inside ancestor [").concat(t, "], because it is not above or equal to the path."));
    return e.slice(t.length);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!e) return null;
    var r = [...e], {
      affinity: o = "forward"
    } = n;
    if (e.length === 0)
      return r;
    switch (t.type) {
      case "insert_node": {
        var {
          path: i
        } = t;
        (Ne.equals(i, r) || Ne.endsBefore(i, r) || Ne.isAncestor(i, r)) && (r[i.length - 1] += 1);
        break;
      }
      case "remove_node": {
        var {
          path: a
        } = t;
        if (Ne.equals(a, r) || Ne.isAncestor(a, r))
          return null;
        Ne.endsBefore(a, r) && (r[a.length - 1] -= 1);
        break;
      }
      case "merge_node": {
        var {
          path: s,
          position: l
        } = t;
        Ne.equals(s, r) || Ne.endsBefore(s, r) ? r[s.length - 1] -= 1 : Ne.isAncestor(s, r) && (r[s.length - 1] -= 1, r[s.length] += l);
        break;
      }
      case "split_node": {
        var {
          path: u,
          position: c
        } = t;
        if (Ne.equals(u, r)) {
          if (o === "forward")
            r[r.length - 1] += 1;
          else if (o !== "backward") return null;
        } else Ne.endsBefore(u, r) ? r[u.length - 1] += 1 : Ne.isAncestor(u, r) && e[u.length] >= c && (r[u.length - 1] += 1, r[u.length] -= c);
        break;
      }
      case "move_node": {
        var {
          path: p,
          newPath: d
        } = t;
        if (Ne.equals(p, d))
          return r;
        if (Ne.isAncestor(p, r) || Ne.equals(p, r)) {
          var g = d.slice();
          return Ne.endsBefore(p, d) && p.length < d.length && (g[p.length - 1] -= 1), g.concat(r.slice(p.length));
        } else Ne.isSibling(p, d) && (Ne.isAncestor(d, r) || Ne.equals(d, r)) ? Ne.endsBefore(p, r) ? r[p.length - 1] -= 1 : r[p.length - 1] += 1 : Ne.endsBefore(d, r) || Ne.equals(d, r) || Ne.isAncestor(d, r) ? (Ne.endsBefore(p, r) && (r[p.length - 1] -= 1), r[d.length - 1] += 1) : Ne.endsBefore(p, r) && (Ne.equals(d, r) && (r[d.length - 1] += 1), r[p.length - 1] -= 1);
        break;
      }
    }
    return r;
  }
};
function Ed(e) {
  "@babel/helpers - typeof";
  return Ed = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Ed(e);
}
function gre(e, t) {
  if (Ed(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (Ed(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function mre(e) {
  var t = gre(e, "string");
  return Ed(t) === "symbol" ? t : String(t);
}
function xc(e, t, n) {
  return t = mre(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function JM(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Zc(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? JM(Object(n), !0).forEach(function(r) {
      xc(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : JM(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var vre = (e, t, n) => {
  switch (n.type) {
    case "insert_node": {
      var {
        path: r,
        node: o
      } = n, i = Et.parent(e, r), a = r[r.length - 1];
      if (a > i.children.length)
        throw new Error('Cannot apply an "insert_node" operation at path ['.concat(r, "] because the destination is past the end of the node."));
      if (i.children.splice(a, 0, o), t)
        for (var [s, l] of Ft.points(t))
          t[l] = fr.transform(s, n);
      break;
    }
    case "insert_text": {
      var {
        path: u,
        offset: c,
        text: p
      } = n;
      if (p.length === 0) break;
      var d = Et.leaf(e, u), g = d.text.slice(0, c), f = d.text.slice(c);
      if (d.text = g + p + f, t)
        for (var [m, v] of Ft.points(t))
          t[v] = fr.transform(m, n);
      break;
    }
    case "merge_node": {
      var {
        path: E
      } = n, w = Et.get(e, E), M = Ne.previous(E), O = Et.get(e, M), y = Et.parent(e, E), C = E[E.length - 1];
      if (no.isText(w) && no.isText(O))
        O.text += w.text;
      else if (!no.isText(w) && !no.isText(O))
        O.children.push(...w.children);
      else
        throw new Error('Cannot apply a "merge_node" operation at path ['.concat(E, "] to nodes of different interfaces: ").concat(Pi.stringify(w), " ").concat(Pi.stringify(O)));
      if (y.children.splice(C, 1), t)
        for (var [_, F] of Ft.points(t))
          t[F] = fr.transform(_, n);
      break;
    }
    case "move_node": {
      var {
        path: L,
        newPath: N
      } = n;
      if (Ne.isAncestor(L, N))
        throw new Error("Cannot move a path [".concat(L, "] to new path [").concat(N, "] because the destination is inside itself."));
      var R = Et.get(e, L), W = Et.parent(e, L), V = L[L.length - 1];
      W.children.splice(V, 1);
      var z = Ne.transform(L, n), Z = Et.get(e, Ne.parent(z)), K = z[z.length - 1];
      if (Z.children.splice(K, 0, R), t)
        for (var [X, te] of Ft.points(t))
          t[te] = fr.transform(X, n);
      break;
    }
    case "remove_node": {
      var {
        path: J
      } = n, P = J[J.length - 1], D = Et.parent(e, J);
      if (D.children.splice(P, 1), t)
        for (var [H, S] of Ft.points(t)) {
          var $ = fr.transform(H, n);
          if (t != null && $ != null)
            t[S] = $;
          else {
            var x = void 0, j = void 0;
            for (var [U, T] of Et.texts(e))
              if (Ne.compare(T, J) === -1)
                x = [U, T];
              else {
                j = [U, T];
                break;
              }
            var q = !1;
            x && j && (Ne.equals(j[1], J) ? q = !Ne.hasPrevious(j[1]) : q = Ne.common(x[1], J).length < Ne.common(j[1], J).length), x && !q ? (H.path = x[1], H.offset = x[0].text.length) : j ? (H.path = j[1], H.offset = 0) : t = null;
          }
        }
      break;
    }
    case "remove_text": {
      var {
        path: A,
        offset: Y,
        text: B
      } = n;
      if (B.length === 0) break;
      var ue = Et.leaf(e, A), fe = ue.text.slice(0, Y), oe = ue.text.slice(Y + B.length);
      if (ue.text = fe + oe, t)
        for (var [Ae, Ze] of Ft.points(t))
          t[Ze] = fr.transform(Ae, n);
      break;
    }
    case "set_node": {
      var {
        path: Ge,
        properties: Ie,
        newProperties: et
      } = n;
      if (Ge.length === 0)
        throw new Error("Cannot set properties on the root node!");
      var Ye = Et.get(e, Ge);
      for (var _e in et) {
        if (_e === "children" || _e === "text")
          throw new Error('Cannot set the "'.concat(_e, '" property of nodes!'));
        var Qe = et[_e];
        Qe == null ? delete Ye[_e] : Ye[_e] = Qe;
      }
      for (var at in Ie)
        et.hasOwnProperty(at) || delete Ye[at];
      break;
    }
    case "set_selection": {
      var {
        newProperties: Pe
      } = n;
      if (Pe == null)
        t = Pe;
      else {
        if (t == null) {
          if (!Ft.isRange(Pe))
            throw new Error('Cannot apply an incomplete "set_selection" operation properties '.concat(Pi.stringify(Pe), " when there is no current selection."));
          t = Zc({}, Pe);
        }
        for (var Me in Pe) {
          var Je = Pe[Me];
          if (Je == null) {
            if (Me === "anchor" || Me === "focus")
              throw new Error('Cannot remove the "'.concat(Me, '" selection property'));
            delete t[Me];
          } else
            t[Me] = Je;
        }
      }
      break;
    }
    case "split_node": {
      var {
        path: We,
        position: Re,
        properties: nt
      } = n;
      if (We.length === 0)
        throw new Error('Cannot apply a "split_node" operation at path ['.concat(We, "] because the root node cannot be split."));
      var De = Et.get(e, We), yt = Et.parent(e, We), ot = We[We.length - 1], st;
      if (no.isText(De)) {
        var ct = De.text.slice(0, Re), bt = De.text.slice(Re);
        De.text = ct, st = Zc(Zc({}, nt), {}, {
          text: bt
        });
      } else {
        var pt = De.children.slice(0, Re), dt = De.children.slice(Re);
        De.children = pt, st = Zc(Zc({}, nt), {}, {
          children: dt
        });
      }
      if (yt.children.splice(ot + 1, 0, st), t)
        for (var [tt, Xe] of Ft.points(t))
          t[Xe] = fr.transform(tt, n);
      break;
    }
  }
  return t;
}, yre = {
  transform(e, t) {
    e.children = YM(e.children);
    var n = e.selection && YM(e.selection);
    try {
      n = vre(e, n, t);
    } finally {
      e.children = XM(e.children), n ? e.selection = Lu(n) ? XM(n) : n : e.selection = null;
    }
  }
}, bre = {
  insertNodes(e, t, n) {
    e.insertNodes(t, n);
  },
  liftNodes(e, t) {
    e.liftNodes(t);
  },
  mergeNodes(e, t) {
    e.mergeNodes(t);
  },
  moveNodes(e, t) {
    e.moveNodes(t);
  },
  removeNodes(e, t) {
    e.removeNodes(t);
  },
  setNodes(e, t, n) {
    e.setNodes(t, n);
  },
  splitNodes(e, t) {
    e.splitNodes(t);
  },
  unsetNodes(e, t, n) {
    e.unsetNodes(t, n);
  },
  unwrapNodes(e, t) {
    e.unwrapNodes(t);
  },
  wrapNodes(e, t, n) {
    e.wrapNodes(t, n);
  }
}, wre = {
  collapse(e, t) {
    e.collapse(t);
  },
  deselect(e) {
    e.deselect();
  },
  move(e, t) {
    e.move(t);
  },
  select(e, t) {
    e.select(t);
  },
  setPoint(e, t, n) {
    e.setPoint(t, n);
  },
  setSelection(e, t) {
    e.setSelection(t);
  }
}, S8 = (e, t) => {
  for (var n in e) {
    var r = e[n], o = t[n];
    if (Fo(r) && Fo(o)) {
      if (!S8(r, o)) return !1;
    } else if (Array.isArray(r) && Array.isArray(o)) {
      if (r.length !== o.length) return !1;
      for (var i = 0; i < r.length; i++)
        if (r[i] !== o[i]) return !1;
    } else if (r !== o)
      return !1;
  }
  for (var a in t)
    if (e[a] === void 0 && t[a] !== void 0)
      return !1;
  return !0;
};
function Cre(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), o, i;
  for (i = 0; i < r.length; i++)
    o = r[i], !(t.indexOf(o) >= 0) && (n[o] = e[o]);
  return n;
}
function kd(e, t) {
  if (e == null) return {};
  var n = Cre(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (o = 0; o < i.length; o++)
      r = i[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
var xre = ["anchor", "focus"];
function QM(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Ore(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? QM(Object(n), !0).forEach(function(r) {
      xc(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : QM(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Ft = {
  edges(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, {
      anchor: r,
      focus: o
    } = e;
    return Ft.isBackward(e) === n ? [r, o] : [o, r];
  },
  end(e) {
    var [, t] = Ft.edges(e);
    return t;
  },
  equals(e, t) {
    return fr.equals(e.anchor, t.anchor) && fr.equals(e.focus, t.focus);
  },
  includes(e, t) {
    if (Ft.isRange(t)) {
      if (Ft.includes(e, t.anchor) || Ft.includes(e, t.focus))
        return !0;
      var [n, r] = Ft.edges(e), [o, i] = Ft.edges(t);
      return fr.isBefore(n, o) && fr.isAfter(r, i);
    }
    var [a, s] = Ft.edges(e), l = !1, u = !1;
    return fr.isPoint(t) ? (l = fr.compare(t, a) >= 0, u = fr.compare(t, s) <= 0) : (l = Ne.compare(t, a.path) >= 0, u = Ne.compare(t, s.path) <= 0), l && u;
  },
  intersection(e, t) {
    var n = kd(e, xre), [r, o] = Ft.edges(e), [i, a] = Ft.edges(t), s = fr.isBefore(r, i) ? i : r, l = fr.isBefore(o, a) ? o : a;
    return fr.isBefore(l, s) ? null : Ore({
      anchor: s,
      focus: l
    }, n);
  },
  isBackward(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return fr.isAfter(t, n);
  },
  isCollapsed(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return fr.equals(t, n);
  },
  isExpanded(e) {
    return !Ft.isCollapsed(e);
  },
  isForward(e) {
    return !Ft.isBackward(e);
  },
  isRange(e) {
    return Fo(e) && fr.isPoint(e.anchor) && fr.isPoint(e.focus);
  },
  *points(e) {
    yield [e.anchor, "anchor"], yield [e.focus, "focus"];
  },
  start(e) {
    var [t] = Ft.edges(e);
    return t;
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return G1(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "inward"
      } = n, i, a;
      if (o === "inward") {
        var s = Ft.isCollapsed(r);
        Ft.isForward(r) ? (i = "forward", a = s ? i : "backward") : (i = "backward", a = s ? i : "forward");
      } else o === "outward" ? Ft.isForward(r) ? (i = "backward", a = "forward") : (i = "forward", a = "backward") : (i = o, a = o);
      var l = fr.transform(r.anchor, t, {
        affinity: i
      }), u = fr.transform(r.focus, t, {
        affinity: a
      });
      if (!l || !u)
        return null;
      r.anchor = l, r.focus = u;
    });
  }
}, eD = (e) => Fo(e) && Et.isNodeList(e.children) && !Vn.isEditor(e), ea = {
  isAncestor(e) {
    return Fo(e) && Et.isNodeList(e.children);
  },
  isElement: eD,
  isElementList(e) {
    return Array.isArray(e) && e.every((t) => ea.isElement(t));
  },
  isElementProps(e) {
    return e.children !== void 0;
  },
  isElementType: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "type";
    return eD(e) && e[n] === t;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "children" && e[n] !== t[n])
        return !1;
    return !0;
  }
}, Ere = ["children"], kre = ["text"], tD = /* @__PURE__ */ new WeakMap(), Et = {
  ancestor(e, t) {
    var n = Et.get(e, t);
    if (no.isText(n))
      throw new Error("Cannot get the ancestor node at path [".concat(t, "] because it refers to a text node instead: ").concat(Pi.stringify(n)));
    return n;
  },
  ancestors(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of Ne.ancestors(t, n)) {
        var o = Et.ancestor(e, r), i = [o, r];
        yield i;
      }
    }();
  },
  child(e, t) {
    if (no.isText(e))
      throw new Error("Cannot get the child of a text node: ".concat(Pi.stringify(e)));
    var n = e.children[t];
    if (n == null)
      throw new Error("Cannot get child at index `".concat(t, "` in node: ").concat(Pi.stringify(e)));
    return n;
  },
  children(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var {
        reverse: r = !1
      } = n, o = Et.ancestor(e, t), {
        children: i
      } = o, a = r ? i.length - 1 : 0; r ? a >= 0 : a < i.length; ) {
        var s = Et.child(o, a), l = t.concat(a);
        yield [s, l], a = r ? a - 1 : a + 1;
      }
    }();
  },
  common(e, t, n) {
    var r = Ne.common(t, n), o = Et.get(e, r);
    return [o, r];
  },
  descendant(e, t) {
    var n = Et.get(e, t);
    if (Vn.isEditor(n))
      throw new Error("Cannot get the descendant node at path [".concat(t, "] because it refers to the root editor node instead: ").concat(Pi.stringify(n)));
    return n;
  },
  descendants(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Et.nodes(e, t))
        r.length !== 0 && (yield [n, r]);
    }();
  },
  elements(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Et.nodes(e, t))
        ea.isElement(n) && (yield [n, r]);
    }();
  },
  extractProps(e) {
    if (ea.isAncestor(e)) {
      var t = kd(e, Ere);
      return t;
    } else {
      var t = kd(e, kre);
      return t;
    }
  },
  first(e, t) {
    for (var n = t.slice(), r = Et.get(e, n); r && !(no.isText(r) || r.children.length === 0); )
      r = r.children[0], n.push(0);
    return [r, n];
  },
  fragment(e, t) {
    if (no.isText(e))
      throw new Error("Cannot get a fragment starting from a root text node: ".concat(Pi.stringify(e)));
    var n = G1({
      children: e.children
    }, (r) => {
      var [o, i] = Ft.edges(t), a = Et.nodes(r, {
        reverse: !0,
        pass: (d) => {
          var [, g] = d;
          return !Ft.includes(t, g);
        }
      });
      for (var [, s] of a) {
        if (!Ft.includes(t, s)) {
          var l = Et.parent(r, s), u = s[s.length - 1];
          l.children.splice(u, 1);
        }
        if (Ne.equals(s, i.path)) {
          var c = Et.leaf(r, s);
          c.text = c.text.slice(0, i.offset);
        }
        if (Ne.equals(s, o.path)) {
          var p = Et.leaf(r, s);
          p.text = p.text.slice(o.offset);
        }
      }
      Vn.isEditor(r) && (r.selection = null);
    });
    return n.children;
  },
  get(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (no.isText(n) || !n.children[o])
        throw new Error("Cannot find a descendant at path [".concat(t, "] in node: ").concat(Pi.stringify(e)));
      n = n.children[o];
    }
    return n;
  },
  has(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (no.isText(n) || !n.children[o])
        return !1;
      n = n.children[o];
    }
    return !0;
  },
  isNode(e) {
    return no.isText(e) || ea.isElement(e) || Vn.isEditor(e);
  },
  isNodeList(e) {
    if (!Array.isArray(e))
      return !1;
    var t = tD.get(e);
    if (t !== void 0)
      return t;
    var n = e.every((r) => Et.isNode(r));
    return tD.set(e, n), n;
  },
  last(e, t) {
    for (var n = t.slice(), r = Et.get(e, n); r && !(no.isText(r) || r.children.length === 0); ) {
      var o = r.children.length - 1;
      r = r.children[o], n.push(o);
    }
    return [r, n];
  },
  leaf(e, t) {
    var n = Et.get(e, t);
    if (!no.isText(n))
      throw new Error("Cannot get the leaf node at path [".concat(t, "] because it refers to a non-leaf node: ").concat(Pi.stringify(n)));
    return n;
  },
  levels(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of Ne.levels(t, n)) {
        var o = Et.get(e, r);
        yield [o, r];
      }
    }();
  },
  matches(e, t) {
    return ea.isElement(e) && ea.isElementProps(t) && ea.matches(e, t) || no.isText(e) && no.isTextProps(t) && no.matches(e, t);
  },
  nodes(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var {
        pass: n,
        reverse: r = !1
      } = t, {
        from: o = [],
        to: i
      } = t, a = /* @__PURE__ */ new Set(), s = [], l = e; !(i && (r ? Ne.isBefore(s, i) : Ne.isAfter(s, i))); ) {
        if (a.has(l) || (yield [l, s]), !a.has(l) && !no.isText(l) && l.children.length !== 0 && (n == null || n([l, s]) === !1)) {
          a.add(l);
          var u = r ? l.children.length - 1 : 0;
          Ne.isAncestor(s, o) && (u = o[s.length]), s = s.concat(u), l = Et.get(e, s);
          continue;
        }
        if (s.length === 0)
          break;
        if (!r) {
          var c = Ne.next(s);
          if (Et.has(e, c)) {
            s = c, l = Et.get(e, s);
            continue;
          }
        }
        if (r && s[s.length - 1] !== 0) {
          var p = Ne.previous(s);
          s = p, l = Et.get(e, s);
          continue;
        }
        s = Ne.parent(s), l = Et.get(e, s), a.add(l);
      }
    }();
  },
  parent(e, t) {
    var n = Ne.parent(t), r = Et.get(e, n);
    if (no.isText(r))
      throw new Error("Cannot get the parent of path [".concat(t, "] because it does not exist in the root."));
    return r;
  },
  string(e) {
    return no.isText(e) ? e.text : e.children.map(Et.string).join("");
  },
  texts(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Et.nodes(e, t))
        no.isText(n) && (yield [n, r]);
    }();
  }
};
function nD(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function wr(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? nD(Object(n), !0).forEach(function(r) {
      xc(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : nD(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Pp = {
  isNodeOperation(e) {
    return Pp.isOperation(e) && e.type.endsWith("_node");
  },
  isOperation(e) {
    if (!Fo(e))
      return !1;
    switch (e.type) {
      case "insert_node":
        return Ne.isPath(e.path) && Et.isNode(e.node);
      case "insert_text":
        return typeof e.offset == "number" && typeof e.text == "string" && Ne.isPath(e.path);
      case "merge_node":
        return typeof e.position == "number" && Ne.isPath(e.path) && Fo(e.properties);
      case "move_node":
        return Ne.isPath(e.path) && Ne.isPath(e.newPath);
      case "remove_node":
        return Ne.isPath(e.path) && Et.isNode(e.node);
      case "remove_text":
        return typeof e.offset == "number" && typeof e.text == "string" && Ne.isPath(e.path);
      case "set_node":
        return Ne.isPath(e.path) && Fo(e.properties) && Fo(e.newProperties);
      case "set_selection":
        return e.properties === null && Ft.isRange(e.newProperties) || e.newProperties === null && Ft.isRange(e.properties) || Fo(e.properties) && Fo(e.newProperties);
      case "split_node":
        return Ne.isPath(e.path) && typeof e.position == "number" && Fo(e.properties);
      default:
        return !1;
    }
  },
  isOperationList(e) {
    return Array.isArray(e) && e.every((t) => Pp.isOperation(t));
  },
  isSelectionOperation(e) {
    return Pp.isOperation(e) && e.type.endsWith("_selection");
  },
  isTextOperation(e) {
    return Pp.isOperation(e) && e.type.endsWith("_text");
  },
  inverse(e) {
    switch (e.type) {
      case "insert_node":
        return wr(wr({}, e), {}, {
          type: "remove_node"
        });
      case "insert_text":
        return wr(wr({}, e), {}, {
          type: "remove_text"
        });
      case "merge_node":
        return wr(wr({}, e), {}, {
          type: "split_node",
          path: Ne.previous(e.path)
        });
      case "move_node": {
        var {
          newPath: t,
          path: n
        } = e;
        if (Ne.equals(t, n))
          return e;
        if (Ne.isSibling(n, t))
          return wr(wr({}, e), {}, {
            path: t,
            newPath: n
          });
        var r = Ne.transform(n, e), o = Ne.transform(Ne.next(n), e);
        return wr(wr({}, e), {}, {
          path: r,
          newPath: o
        });
      }
      case "remove_node":
        return wr(wr({}, e), {}, {
          type: "insert_node"
        });
      case "remove_text":
        return wr(wr({}, e), {}, {
          type: "insert_text"
        });
      case "set_node": {
        var {
          properties: i,
          newProperties: a
        } = e;
        return wr(wr({}, e), {}, {
          properties: a,
          newProperties: i
        });
      }
      case "set_selection": {
        var {
          properties: s,
          newProperties: l
        } = e;
        return s == null ? wr(wr({}, e), {}, {
          properties: l,
          newProperties: null
        }) : l == null ? wr(wr({}, e), {}, {
          properties: null,
          newProperties: s
        }) : wr(wr({}, e), {}, {
          properties: l,
          newProperties: s
        });
      }
      case "split_node":
        return wr(wr({}, e), {}, {
          type: "merge_node",
          path: Ne.next(e.path)
        });
    }
  }
}, rD = /* @__PURE__ */ new WeakMap(), Lre = (e) => {
  var t = rD.get(e);
  if (t !== void 0)
    return t;
  if (!Fo(e))
    return !1;
  var n = typeof e.addMark == "function" && typeof e.apply == "function" && typeof e.deleteFragment == "function" && typeof e.insertBreak == "function" && typeof e.insertSoftBreak == "function" && typeof e.insertFragment == "function" && typeof e.insertNode == "function" && typeof e.insertText == "function" && typeof e.isElementReadOnly == "function" && typeof e.isInline == "function" && typeof e.isSelectable == "function" && typeof e.isVoid == "function" && typeof e.normalizeNode == "function" && typeof e.onChange == "function" && typeof e.removeMark == "function" && typeof e.getDirtyPaths == "function" && (e.marks === null || Fo(e.marks)) && (e.selection === null || Ft.isRange(e.selection)) && Et.isNodeList(e.children) && Pp.isOperationList(e.operations);
  return rD.set(e, n), n;
}, Vn = {
  above(e, t) {
    return e.above(t);
  },
  addMark(e, t, n) {
    e.addMark(t, n);
  },
  after(e, t, n) {
    return e.after(t, n);
  },
  before(e, t, n) {
    return e.before(t, n);
  },
  deleteBackward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteBackward(n);
  },
  deleteForward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteForward(n);
  },
  deleteFragment(e, t) {
    e.deleteFragment(t);
  },
  edges(e, t) {
    return e.edges(t);
  },
  elementReadOnly(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return e.elementReadOnly(t);
  },
  end(e, t) {
    return e.end(t);
  },
  first(e, t) {
    return e.first(t);
  },
  fragment(e, t) {
    return e.fragment(t);
  },
  hasBlocks(e, t) {
    return e.hasBlocks(t);
  },
  hasInlines(e, t) {
    return e.hasInlines(t);
  },
  hasPath(e, t) {
    return e.hasPath(t);
  },
  hasTexts(e, t) {
    return e.hasTexts(t);
  },
  insertBreak(e) {
    e.insertBreak();
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertNode(e, t) {
    e.insertNode(t);
  },
  insertSoftBreak(e) {
    e.insertSoftBreak();
  },
  insertText(e, t) {
    e.insertText(t);
  },
  isBlock(e, t) {
    return e.isBlock(t);
  },
  isEdge(e, t, n) {
    return e.isEdge(t, n);
  },
  isEditor(e) {
    return Lre(e);
  },
  isElementReadOnly(e, t) {
    return e.isElementReadOnly(t);
  },
  isEmpty(e, t) {
    return e.isEmpty(t);
  },
  isEnd(e, t, n) {
    return e.isEnd(t, n);
  },
  isInline(e, t) {
    return e.isInline(t);
  },
  isNormalizing(e) {
    return e.isNormalizing();
  },
  isSelectable(e, t) {
    return e.isSelectable(t);
  },
  isStart(e, t, n) {
    return e.isStart(t, n);
  },
  isVoid(e, t) {
    return e.isVoid(t);
  },
  last(e, t) {
    return e.last(t);
  },
  leaf(e, t, n) {
    return e.leaf(t, n);
  },
  levels(e, t) {
    return e.levels(t);
  },
  marks(e) {
    return e.getMarks();
  },
  next(e, t) {
    return e.next(t);
  },
  node(e, t, n) {
    return e.node(t, n);
  },
  nodes(e, t) {
    return e.nodes(t);
  },
  normalize(e, t) {
    e.normalize(t);
  },
  parent(e, t, n) {
    return e.parent(t, n);
  },
  path(e, t, n) {
    return e.path(t, n);
  },
  pathRef(e, t, n) {
    return e.pathRef(t, n);
  },
  pathRefs(e) {
    return e.pathRefs();
  },
  point(e, t, n) {
    return e.point(t, n);
  },
  pointRef(e, t, n) {
    return e.pointRef(t, n);
  },
  pointRefs(e) {
    return e.pointRefs();
  },
  positions(e, t) {
    return e.positions(t);
  },
  previous(e, t) {
    return e.previous(t);
  },
  range(e, t, n) {
    return e.range(t, n);
  },
  rangeRef(e, t, n) {
    return e.rangeRef(t, n);
  },
  rangeRefs(e) {
    return e.rangeRefs();
  },
  removeMark(e, t) {
    e.removeMark(t);
  },
  setNormalizing(e, t) {
    e.setNormalizing(t);
  },
  start(e, t) {
    return e.start(t);
  },
  string(e, t, n) {
    return e.string(t, n);
  },
  unhangRange(e, t, n) {
    return e.unhangRange(t, n);
  },
  void(e, t) {
    return e.void(t);
  },
  withoutNormalizing(e, t) {
    e.withoutNormalizing(t);
  },
  shouldMergeNodesRemovePrevNode: (e, t, n) => e.shouldMergeNodesRemovePrevNode(t, n)
};
function oD(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function iD(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? oD(Object(n), !0).forEach(function(r) {
      xc(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : oD(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var fr = {
  compare(e, t) {
    var n = Ne.compare(e.path, t.path);
    return n === 0 ? e.offset < t.offset ? -1 : e.offset > t.offset ? 1 : 0 : n;
  },
  isAfter(e, t) {
    return fr.compare(e, t) === 1;
  },
  isBefore(e, t) {
    return fr.compare(e, t) === -1;
  },
  equals(e, t) {
    return e.offset === t.offset && Ne.equals(e.path, t.path);
  },
  isPoint(e) {
    return Fo(e) && typeof e.offset == "number" && Ne.isPath(e.path);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return G1(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "forward"
      } = n, {
        path: i,
        offset: a
      } = r;
      switch (t.type) {
        case "insert_node":
        case "move_node": {
          r.path = Ne.transform(i, t, n);
          break;
        }
        case "insert_text": {
          Ne.equals(t.path, i) && (t.offset < a || t.offset === a && o === "forward") && (r.offset += t.text.length);
          break;
        }
        case "merge_node": {
          Ne.equals(t.path, i) && (r.offset += t.position), r.path = Ne.transform(i, t, n);
          break;
        }
        case "remove_text": {
          Ne.equals(t.path, i) && t.offset <= a && (r.offset -= Math.min(a - t.offset, t.text.length));
          break;
        }
        case "remove_node": {
          if (Ne.equals(t.path, i) || Ne.isAncestor(t.path, i))
            return null;
          r.path = Ne.transform(i, t, n);
          break;
        }
        case "split_node": {
          if (Ne.equals(t.path, i)) {
            if (t.position === a && o == null)
              return null;
            (t.position < a || t.position === a && o === "forward") && (r.offset -= t.position, r.path = Ne.transform(i, t, iD(iD({}, n), {}, {
              affinity: "forward"
            })));
          } else
            r.path = Ne.transform(i, t, n);
          break;
        }
      }
    });
  }
}, sD = void 0, Pi = {
  setScrubber(e) {
    sD = e;
  },
  stringify(e) {
    return JSON.stringify(e, sD);
  }
}, Pre = ["text"], _re = ["anchor", "focus"];
function aD(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Us(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? aD(Object(n), !0).forEach(function(r) {
      xc(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : aD(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var no = {
  equals(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      loose: r = !1
    } = n;
    function o(i) {
      var a = kd(i, Pre);
      return a;
    }
    return S8(r ? o(e) : e, r ? o(t) : t);
  },
  isText(e) {
    return Fo(e) && typeof e.text == "string";
  },
  isTextList(e) {
    return Array.isArray(e) && e.every((t) => no.isText(t));
  },
  isTextProps(e) {
    return e.text !== void 0;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "text" && (!e.hasOwnProperty(n) || e[n] !== t[n]))
        return !1;
    return !0;
  },
  decorations(e, t) {
    var n = [Us({}, e)];
    for (var r of t) {
      var o = kd(r, _re), [i, a] = Ft.edges(r), s = [], l = 0, u = i.offset, c = a.offset;
      for (var p of n) {
        var {
          length: d
        } = p.text, g = l;
        if (l += d, u <= g && l <= c) {
          Object.assign(p, o), s.push(p);
          continue;
        }
        if (u !== c && (u === l || c === g) || u > l || c < g || c === g && g !== 0) {
          s.push(p);
          continue;
        }
        var f = p, m = void 0, v = void 0;
        if (c < l) {
          var E = c - g;
          v = Us(Us({}, f), {}, {
            text: f.text.slice(E)
          }), f = Us(Us({}, f), {}, {
            text: f.text.slice(0, E)
          });
        }
        if (u > g) {
          var w = u - g;
          m = Us(Us({}, f), {}, {
            text: f.text.slice(0, w)
          }), f = Us(Us({}, f), {}, {
            text: f.text.slice(w)
          });
        }
        Object.assign(f, o), m && s.push(m), s.push(f), v && s.push(v);
      }
      n = s;
    }
    return n;
  }
}, Sre = (e) => e.selection ? e.selection : e.children.length > 0 ? Vn.end(e, []) : [0], ar;
(function(e) {
  e[e.None = 0] = "None", e[e.Extend = 1] = "Extend", e[e.ZWJ = 2] = "ZWJ", e[e.RI = 4] = "RI", e[e.Prepend = 8] = "Prepend", e[e.SpacingMark = 16] = "SpacingMark", e[e.L = 32] = "L", e[e.V = 64] = "V", e[e.T = 128] = "T", e[e.LV = 256] = "LV", e[e.LVT = 512] = "LVT", e[e.ExtPict = 1024] = "ExtPict", e[e.Any = 2048] = "Any";
})(ar || (ar = {}));
ar.L, ar.L | ar.V | ar.LV | ar.LVT, ar.LV | ar.V, ar.V | ar.T, ar.LVT | ar.T, ar.T, ar.Any, ar.Extend | ar.ZWJ, ar.Any, ar.SpacingMark, ar.Prepend, ar.Any, ar.ZWJ, ar.ExtPict, ar.RI, ar.RI;
var Mre = {
  delete(e, t) {
    e.delete(t);
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertText(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Vn.withoutNormalizing(e, () => {
      var {
        voids: r = !1
      } = n, {
        at: o = Sre(e)
      } = n;
      if (Ne.isPath(o) && (o = Vn.range(e, o)), Ft.isRange(o))
        if (Ft.isCollapsed(o))
          o = o.anchor;
        else {
          var i = Ft.end(o);
          if (!r && Vn.void(e, {
            at: i
          }))
            return;
          var a = Ft.start(o), s = Vn.pointRef(e, a), l = Vn.pointRef(e, i);
          Km.delete(e, {
            at: o,
            voids: r
          });
          var u = s.unref(), c = l.unref();
          o = u || c, Km.setSelection(e, {
            anchor: o,
            focus: o
          });
        }
      if (!(!r && Vn.void(e, {
        at: o
      }) || Vn.elementReadOnly(e, {
        at: o
      }))) {
        var {
          path: p,
          offset: d
        } = o;
        t.length > 0 && e.apply({
          type: "insert_text",
          path: p,
          offset: d,
          text: t
        });
      }
    });
  }
};
function lD(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function wh(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? lD(Object(n), !0).forEach(function(r) {
      xc(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : lD(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Km = wh(wh(wh(wh({}, yre), bre), wre), Mre), M8 = {}, K1 = {}, Y1 = {}, Zu = {}, X1 = {}, J1 = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Doctype = e.CDATA = e.Tag = e.Style = e.Script = e.Comment = e.Directive = e.Text = e.Root = e.isTag = e.ElementType = void 0;
  var t;
  (function(r) {
    r.Root = "root", r.Text = "text", r.Directive = "directive", r.Comment = "comment", r.Script = "script", r.Style = "style", r.Tag = "tag", r.CDATA = "cdata", r.Doctype = "doctype";
  })(t = e.ElementType || (e.ElementType = {}));
  function n(r) {
    return r.type === t.Tag || r.type === t.Script || r.type === t.Style;
  }
  e.isTag = n, e.Root = t.Root, e.Text = t.Text, e.Directive = t.Directive, e.Comment = t.Comment, e.Script = t.Script, e.Style = t.Style, e.Tag = t.Tag, e.CDATA = t.CDATA, e.Doctype = t.Doctype;
})(J1);
var qt = {}, hl = Jn && Jn.__extends || /* @__PURE__ */ function() {
  var e = function(t, n) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, o) {
      r.__proto__ = o;
    } || function(r, o) {
      for (var i in o) Object.prototype.hasOwnProperty.call(o, i) && (r[i] = o[i]);
    }, e(t, n);
  };
  return function(t, n) {
    if (typeof n != "function" && n !== null)
      throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
    e(t, n);
    function r() {
      this.constructor = t;
    }
    t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
  };
}(), Hp = Jn && Jn.__assign || function() {
  return Hp = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) {
      t = arguments[n];
      for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
    }
    return e;
  }, Hp.apply(this, arguments);
};
Object.defineProperty(qt, "__esModule", { value: !0 });
qt.cloneNode = qt.hasChildren = qt.isDocument = qt.isDirective = qt.isComment = qt.isText = qt.isCDATA = qt.isTag = qt.Element = qt.Document = qt.CDATA = qt.NodeWithChildren = qt.ProcessingInstruction = qt.Comment = qt.Text = qt.DataNode = qt.Node = void 0;
var di = J1, Q1 = (
  /** @class */
  function() {
    function e() {
      this.parent = null, this.prev = null, this.next = null, this.startIndex = null, this.endIndex = null;
    }
    return Object.defineProperty(e.prototype, "parentNode", {
      // Read-write aliases for properties
      /**
       * Same as {@link parent}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.parent;
      },
      set: function(t) {
        this.parent = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "previousSibling", {
      /**
       * Same as {@link prev}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.prev;
      },
      set: function(t) {
        this.prev = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "nextSibling", {
      /**
       * Same as {@link next}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.next;
      },
      set: function(t) {
        this.next = t;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.cloneNode = function(t) {
      return t === void 0 && (t = !1), eL(this, t);
    }, e;
  }()
);
qt.Node = Q1;
var ub = (
  /** @class */
  function(e) {
    hl(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.data = n, r;
    }
    return Object.defineProperty(t.prototype, "nodeValue", {
      /**
       * Same as {@link data}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.data;
      },
      set: function(n) {
        this.data = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Q1)
);
qt.DataNode = ub;
var D8 = (
  /** @class */
  function(e) {
    hl(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = di.ElementType.Text, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 3;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(ub)
);
qt.Text = D8;
var T8 = (
  /** @class */
  function(e) {
    hl(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = di.ElementType.Comment, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 8;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(ub)
);
qt.Comment = T8;
var j8 = (
  /** @class */
  function(e) {
    hl(t, e);
    function t(n, r) {
      var o = e.call(this, r) || this;
      return o.name = n, o.type = di.ElementType.Directive, o;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(ub)
);
qt.ProcessingInstruction = j8;
var cb = (
  /** @class */
  function(e) {
    hl(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.children = n, r;
    }
    return Object.defineProperty(t.prototype, "firstChild", {
      // Aliases
      /** First child of the node. */
      get: function() {
        var n;
        return (n = this.children[0]) !== null && n !== void 0 ? n : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "lastChild", {
      /** Last child of the node. */
      get: function() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "childNodes", {
      /**
       * Same as {@link children}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.children;
      },
      set: function(n) {
        this.children = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Q1)
);
qt.NodeWithChildren = cb;
var A8 = (
  /** @class */
  function(e) {
    hl(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = di.ElementType.CDATA, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 4;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(cb)
);
qt.CDATA = A8;
var I8 = (
  /** @class */
  function(e) {
    hl(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = di.ElementType.Root, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 9;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(cb)
);
qt.Document = I8;
var R8 = (
  /** @class */
  function(e) {
    hl(t, e);
    function t(n, r, o, i) {
      o === void 0 && (o = []), i === void 0 && (i = n === "script" ? di.ElementType.Script : n === "style" ? di.ElementType.Style : di.ElementType.Tag);
      var a = e.call(this, o) || this;
      return a.name = n, a.attribs = r, a.type = i, a;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "tagName", {
      // DOM Level 1 aliases
      /**
       * Same as {@link name}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.name;
      },
      set: function(n) {
        this.name = n;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "attributes", {
      get: function() {
        var n = this;
        return Object.keys(this.attribs).map(function(r) {
          var o, i;
          return {
            name: r,
            value: n.attribs[r],
            namespace: (o = n["x-attribsNamespace"]) === null || o === void 0 ? void 0 : o[r],
            prefix: (i = n["x-attribsPrefix"]) === null || i === void 0 ? void 0 : i[r]
          };
        });
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(cb)
);
qt.Element = R8;
function B8(e) {
  return (0, di.isTag)(e);
}
qt.isTag = B8;
function N8(e) {
  return e.type === di.ElementType.CDATA;
}
qt.isCDATA = N8;
function F8(e) {
  return e.type === di.ElementType.Text;
}
qt.isText = F8;
function z8(e) {
  return e.type === di.ElementType.Comment;
}
qt.isComment = z8;
function U8(e) {
  return e.type === di.ElementType.Directive;
}
qt.isDirective = U8;
function H8(e) {
  return e.type === di.ElementType.Root;
}
qt.isDocument = H8;
function Dre(e) {
  return Object.prototype.hasOwnProperty.call(e, "children");
}
qt.hasChildren = Dre;
function eL(e, t) {
  t === void 0 && (t = !1);
  var n;
  if (F8(e))
    n = new D8(e.data);
  else if (z8(e))
    n = new T8(e.data);
  else if (B8(e)) {
    var r = t ? I0(e.children) : [], o = new R8(e.name, Hp({}, e.attribs), r);
    r.forEach(function(l) {
      return l.parent = o;
    }), e.namespace != null && (o.namespace = e.namespace), e["x-attribsNamespace"] && (o["x-attribsNamespace"] = Hp({}, e["x-attribsNamespace"])), e["x-attribsPrefix"] && (o["x-attribsPrefix"] = Hp({}, e["x-attribsPrefix"])), n = o;
  } else if (N8(e)) {
    var r = t ? I0(e.children) : [], i = new A8(r);
    r.forEach(function(u) {
      return u.parent = i;
    }), n = i;
  } else if (H8(e)) {
    var r = t ? I0(e.children) : [], a = new I8(r);
    r.forEach(function(u) {
      return u.parent = a;
    }), e["x-mode"] && (a["x-mode"] = e["x-mode"]), n = a;
  } else if (U8(e)) {
    var s = new j8(e.name, e.data);
    e["x-name"] != null && (s["x-name"] = e["x-name"], s["x-publicId"] = e["x-publicId"], s["x-systemId"] = e["x-systemId"]), n = s;
  } else
    throw new Error("Not implemented yet: ".concat(e.type));
  return n.startIndex = e.startIndex, n.endIndex = e.endIndex, e.sourceCodeLocation != null && (n.sourceCodeLocation = e.sourceCodeLocation), n;
}
qt.cloneNode = eL;
function I0(e) {
  for (var t = e.map(function(r) {
    return eL(r, !0);
  }), n = 1; n < t.length; n++)
    t[n].prev = t[n - 1], t[n - 1].next = t[n];
  return t;
}
(function(e) {
  var t = Jn && Jn.__createBinding || (Object.create ? function(s, l, u, c) {
    c === void 0 && (c = u);
    var p = Object.getOwnPropertyDescriptor(l, u);
    (!p || ("get" in p ? !l.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
      return l[u];
    } }), Object.defineProperty(s, c, p);
  } : function(s, l, u, c) {
    c === void 0 && (c = u), s[c] = l[u];
  }), n = Jn && Jn.__exportStar || function(s, l) {
    for (var u in s) u !== "default" && !Object.prototype.hasOwnProperty.call(l, u) && t(l, s, u);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.DomHandler = void 0;
  var r = J1, o = qt;
  n(qt, e);
  var i = {
    withStartIndices: !1,
    withEndIndices: !1,
    xmlMode: !1
  }, a = (
    /** @class */
    function() {
      function s(l, u, c) {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null, typeof u == "function" && (c = u, u = i), typeof l == "object" && (u = l, l = void 0), this.callback = l ?? null, this.options = u ?? i, this.elementCB = c ?? null;
      }
      return s.prototype.onparserinit = function(l) {
        this.parser = l;
      }, s.prototype.onreset = function() {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null;
      }, s.prototype.onend = function() {
        this.done || (this.done = !0, this.parser = null, this.handleCallback(null));
      }, s.prototype.onerror = function(l) {
        this.handleCallback(l);
      }, s.prototype.onclosetag = function() {
        this.lastNode = null;
        var l = this.tagStack.pop();
        this.options.withEndIndices && (l.endIndex = this.parser.endIndex), this.elementCB && this.elementCB(l);
      }, s.prototype.onopentag = function(l, u) {
        var c = this.options.xmlMode ? r.ElementType.Tag : void 0, p = new o.Element(l, u, void 0, c);
        this.addNode(p), this.tagStack.push(p);
      }, s.prototype.ontext = function(l) {
        var u = this.lastNode;
        if (u && u.type === r.ElementType.Text)
          u.data += l, this.options.withEndIndices && (u.endIndex = this.parser.endIndex);
        else {
          var c = new o.Text(l);
          this.addNode(c), this.lastNode = c;
        }
      }, s.prototype.oncomment = function(l) {
        if (this.lastNode && this.lastNode.type === r.ElementType.Comment) {
          this.lastNode.data += l;
          return;
        }
        var u = new o.Comment(l);
        this.addNode(u), this.lastNode = u;
      }, s.prototype.oncommentend = function() {
        this.lastNode = null;
      }, s.prototype.oncdatastart = function() {
        var l = new o.Text(""), u = new o.CDATA([l]);
        this.addNode(u), l.parent = u, this.lastNode = l;
      }, s.prototype.oncdataend = function() {
        this.lastNode = null;
      }, s.prototype.onprocessinginstruction = function(l, u) {
        var c = new o.ProcessingInstruction(l, u);
        this.addNode(c);
      }, s.prototype.handleCallback = function(l) {
        if (typeof this.callback == "function")
          this.callback(l, this.dom);
        else if (l)
          throw l;
      }, s.prototype.addNode = function(l) {
        var u = this.tagStack[this.tagStack.length - 1], c = u.children[u.children.length - 1];
        this.options.withStartIndices && (l.startIndex = this.parser.startIndex), this.options.withEndIndices && (l.endIndex = this.parser.endIndex), u.children.push(l), c && (l.prev = c, c.next = l), l.parent = u, this.lastNode = null;
      }, s;
    }()
  );
  e.DomHandler = a, e.default = a;
})(X1);
var $8 = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CARRIAGE_RETURN_PLACEHOLDER_REGEX = e.CARRIAGE_RETURN_PLACEHOLDER = e.CARRIAGE_RETURN_REGEX = e.CARRIAGE_RETURN = e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES = void 0, e.CASE_SENSITIVE_TAG_NAMES = [
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "linearGradient",
    "radialGradient",
    "textPath"
  ], e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES.reduce(function(t, n) {
    return t[n.toLowerCase()] = n, t;
  }, {}), e.CARRIAGE_RETURN = "\r", e.CARRIAGE_RETURN_REGEX = new RegExp(e.CARRIAGE_RETURN, "g"), e.CARRIAGE_RETURN_PLACEHOLDER = "__HTML_DOM_PARSER_CARRIAGE_RETURN_PLACEHOLDER_".concat(Date.now(), "__"), e.CARRIAGE_RETURN_PLACEHOLDER_REGEX = new RegExp(e.CARRIAGE_RETURN_PLACEHOLDER, "g");
})($8);
Object.defineProperty(Zu, "__esModule", { value: !0 });
Zu.formatAttributes = W8;
Zu.escapeSpecialCharacters = Are;
Zu.revertEscapedCharacters = V8;
Zu.formatDOM = Z8;
var Ch = X1, Ld = $8;
function Tre(e) {
  return Ld.CASE_SENSITIVE_TAG_NAMES_MAP[e];
}
function W8(e) {
  for (var t = {}, n = 0, r = e.length; n < r; n++) {
    var o = e[n];
    t[o.name] = o.value;
  }
  return t;
}
function jre(e) {
  e = e.toLowerCase();
  var t = Tre(e);
  return t || e;
}
function Are(e) {
  return e.replace(Ld.CARRIAGE_RETURN_REGEX, Ld.CARRIAGE_RETURN_PLACEHOLDER);
}
function V8(e) {
  return e.replace(Ld.CARRIAGE_RETURN_PLACEHOLDER_REGEX, Ld.CARRIAGE_RETURN);
}
function Z8(e, t, n) {
  t === void 0 && (t = null);
  for (var r = [], o, i = 0, a = e.length; i < a; i++) {
    var s = e[i];
    switch (s.nodeType) {
      case 1: {
        var l = jre(s.nodeName);
        o = new Ch.Element(l, W8(s.attributes)), o.children = Z8(
          // template children are on content
          l === "template" ? s.content.childNodes : s.childNodes,
          o
        );
        break;
      }
      case 3:
        o = new Ch.Text(V8(s.nodeValue));
        break;
      case 8:
        o = new Ch.Comment(s.nodeValue);
        break;
      default:
        continue;
    }
    var u = r[i - 1] || null;
    u && (u.next = o), o.parent = t, o.prev = u, o.next = null, r.push(o);
  }
  return n && (o = new Ch.ProcessingInstruction(n.substring(0, n.indexOf(" ")).toLowerCase(), n), o.next = r[0] || null, o.parent = t, r.unshift(o), r[1] && (r[1].prev = r[0])), r;
}
Object.defineProperty(Y1, "__esModule", { value: !0 });
Y1.default = Fre;
var Ire = Zu, uD = "html", cD = "head", xh = "body", Rre = /<([a-zA-Z]+[0-9]?)/, pD = /<head[^]*>/i, dD = /<body[^]*>/i, Ym = function(e, t) {
  throw new Error("This browser does not support `document.implementation.createHTMLDocument`");
}, pE = function(e, t) {
  throw new Error("This browser does not support `DOMParser.prototype.parseFromString`");
}, fD = typeof window == "object" && window.DOMParser;
if (typeof fD == "function") {
  var Bre = new fD(), Nre = "text/html";
  pE = function(e, t) {
    return t && (e = "<".concat(t, ">").concat(e, "</").concat(t, ">")), Bre.parseFromString(e, Nre);
  }, Ym = pE;
}
if (typeof document == "object" && document.implementation) {
  var Oh = document.implementation.createHTMLDocument();
  Ym = function(e, t) {
    if (t) {
      var n = Oh.documentElement.querySelector(t);
      return n && (n.innerHTML = e), Oh;
    }
    return Oh.documentElement.innerHTML = e, Oh;
  };
}
var Eh = typeof document == "object" && document.createElement("template"), dE;
Eh && Eh.content && (dE = function(e) {
  return Eh.innerHTML = e, Eh.content.childNodes;
});
function Fre(e) {
  var t, n;
  e = (0, Ire.escapeSpecialCharacters)(e);
  var r = e.match(Rre), o = r && r[1] ? r[1].toLowerCase() : "";
  switch (o) {
    case uD: {
      var i = pE(e);
      if (!pD.test(e)) {
        var a = i.querySelector(cD);
        (t = a == null ? void 0 : a.parentNode) === null || t === void 0 || t.removeChild(a);
      }
      if (!dD.test(e)) {
        var a = i.querySelector(xh);
        (n = a == null ? void 0 : a.parentNode) === null || n === void 0 || n.removeChild(a);
      }
      return i.querySelectorAll(uD);
    }
    case cD:
    case xh: {
      var s = Ym(e).querySelectorAll(o);
      return dD.test(e) && pD.test(e) ? s[0].parentNode.childNodes : s;
    }
    default: {
      if (dE)
        return dE(e);
      var a = Ym(e, xh).querySelector(xh);
      return a.childNodes;
    }
  }
}
var zre = Jn && Jn.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(K1, "__esModule", { value: !0 });
K1.default = Wre;
var Ure = zre(Y1), Hre = Zu, $re = /<(![a-zA-Z\s]+)>/;
function Wre(e) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e)
    return [];
  var t = e.match($re), n = t ? t[1] : void 0;
  return (0, Hre.formatDOM)((0, Ure.default)(e), null, n);
}
var pb = {}, ps = {}, db = {}, Vre = 0;
db.SAME = Vre;
var Zre = 1;
db.CAMELCASE = Zre;
db.possibleStandardNames = {
  accept: 0,
  acceptCharset: 1,
  "accept-charset": "acceptCharset",
  accessKey: 1,
  action: 0,
  allowFullScreen: 1,
  alt: 0,
  as: 0,
  async: 0,
  autoCapitalize: 1,
  autoComplete: 1,
  autoCorrect: 1,
  autoFocus: 1,
  autoPlay: 1,
  autoSave: 1,
  capture: 0,
  cellPadding: 1,
  cellSpacing: 1,
  challenge: 0,
  charSet: 1,
  checked: 0,
  children: 0,
  cite: 0,
  class: "className",
  classID: 1,
  className: 1,
  cols: 0,
  colSpan: 1,
  content: 0,
  contentEditable: 1,
  contextMenu: 1,
  controls: 0,
  controlsList: 1,
  coords: 0,
  crossOrigin: 1,
  dangerouslySetInnerHTML: 1,
  data: 0,
  dateTime: 1,
  default: 0,
  defaultChecked: 1,
  defaultValue: 1,
  defer: 0,
  dir: 0,
  disabled: 0,
  disablePictureInPicture: 1,
  disableRemotePlayback: 1,
  download: 0,
  draggable: 0,
  encType: 1,
  enterKeyHint: 1,
  for: "htmlFor",
  form: 0,
  formMethod: 1,
  formAction: 1,
  formEncType: 1,
  formNoValidate: 1,
  formTarget: 1,
  frameBorder: 1,
  headers: 0,
  height: 0,
  hidden: 0,
  high: 0,
  href: 0,
  hrefLang: 1,
  htmlFor: 1,
  httpEquiv: 1,
  "http-equiv": "httpEquiv",
  icon: 0,
  id: 0,
  innerHTML: 1,
  inputMode: 1,
  integrity: 0,
  is: 0,
  itemID: 1,
  itemProp: 1,
  itemRef: 1,
  itemScope: 1,
  itemType: 1,
  keyParams: 1,
  keyType: 1,
  kind: 0,
  label: 0,
  lang: 0,
  list: 0,
  loop: 0,
  low: 0,
  manifest: 0,
  marginWidth: 1,
  marginHeight: 1,
  max: 0,
  maxLength: 1,
  media: 0,
  mediaGroup: 1,
  method: 0,
  min: 0,
  minLength: 1,
  multiple: 0,
  muted: 0,
  name: 0,
  noModule: 1,
  nonce: 0,
  noValidate: 1,
  open: 0,
  optimum: 0,
  pattern: 0,
  placeholder: 0,
  playsInline: 1,
  poster: 0,
  preload: 0,
  profile: 0,
  radioGroup: 1,
  readOnly: 1,
  referrerPolicy: 1,
  rel: 0,
  required: 0,
  reversed: 0,
  role: 0,
  rows: 0,
  rowSpan: 1,
  sandbox: 0,
  scope: 0,
  scoped: 0,
  scrolling: 0,
  seamless: 0,
  selected: 0,
  shape: 0,
  size: 0,
  sizes: 0,
  span: 0,
  spellCheck: 1,
  src: 0,
  srcDoc: 1,
  srcLang: 1,
  srcSet: 1,
  start: 0,
  step: 0,
  style: 0,
  summary: 0,
  tabIndex: 1,
  target: 0,
  title: 0,
  type: 0,
  useMap: 1,
  value: 0,
  width: 0,
  wmode: 0,
  wrap: 0,
  about: 0,
  accentHeight: 1,
  "accent-height": "accentHeight",
  accumulate: 0,
  additive: 0,
  alignmentBaseline: 1,
  "alignment-baseline": "alignmentBaseline",
  allowReorder: 1,
  alphabetic: 0,
  amplitude: 0,
  arabicForm: 1,
  "arabic-form": "arabicForm",
  ascent: 0,
  attributeName: 1,
  attributeType: 1,
  autoReverse: 1,
  azimuth: 0,
  baseFrequency: 1,
  baselineShift: 1,
  "baseline-shift": "baselineShift",
  baseProfile: 1,
  bbox: 0,
  begin: 0,
  bias: 0,
  by: 0,
  calcMode: 1,
  capHeight: 1,
  "cap-height": "capHeight",
  clip: 0,
  clipPath: 1,
  "clip-path": "clipPath",
  clipPathUnits: 1,
  clipRule: 1,
  "clip-rule": "clipRule",
  color: 0,
  colorInterpolation: 1,
  "color-interpolation": "colorInterpolation",
  colorInterpolationFilters: 1,
  "color-interpolation-filters": "colorInterpolationFilters",
  colorProfile: 1,
  "color-profile": "colorProfile",
  colorRendering: 1,
  "color-rendering": "colorRendering",
  contentScriptType: 1,
  contentStyleType: 1,
  cursor: 0,
  cx: 0,
  cy: 0,
  d: 0,
  datatype: 0,
  decelerate: 0,
  descent: 0,
  diffuseConstant: 1,
  direction: 0,
  display: 0,
  divisor: 0,
  dominantBaseline: 1,
  "dominant-baseline": "dominantBaseline",
  dur: 0,
  dx: 0,
  dy: 0,
  edgeMode: 1,
  elevation: 0,
  enableBackground: 1,
  "enable-background": "enableBackground",
  end: 0,
  exponent: 0,
  externalResourcesRequired: 1,
  fill: 0,
  fillOpacity: 1,
  "fill-opacity": "fillOpacity",
  fillRule: 1,
  "fill-rule": "fillRule",
  filter: 0,
  filterRes: 1,
  filterUnits: 1,
  floodOpacity: 1,
  "flood-opacity": "floodOpacity",
  floodColor: 1,
  "flood-color": "floodColor",
  focusable: 0,
  fontFamily: 1,
  "font-family": "fontFamily",
  fontSize: 1,
  "font-size": "fontSize",
  fontSizeAdjust: 1,
  "font-size-adjust": "fontSizeAdjust",
  fontStretch: 1,
  "font-stretch": "fontStretch",
  fontStyle: 1,
  "font-style": "fontStyle",
  fontVariant: 1,
  "font-variant": "fontVariant",
  fontWeight: 1,
  "font-weight": "fontWeight",
  format: 0,
  from: 0,
  fx: 0,
  fy: 0,
  g1: 0,
  g2: 0,
  glyphName: 1,
  "glyph-name": "glyphName",
  glyphOrientationHorizontal: 1,
  "glyph-orientation-horizontal": "glyphOrientationHorizontal",
  glyphOrientationVertical: 1,
  "glyph-orientation-vertical": "glyphOrientationVertical",
  glyphRef: 1,
  gradientTransform: 1,
  gradientUnits: 1,
  hanging: 0,
  horizAdvX: 1,
  "horiz-adv-x": "horizAdvX",
  horizOriginX: 1,
  "horiz-origin-x": "horizOriginX",
  ideographic: 0,
  imageRendering: 1,
  "image-rendering": "imageRendering",
  in2: 0,
  in: 0,
  inlist: 0,
  intercept: 0,
  k1: 0,
  k2: 0,
  k3: 0,
  k4: 0,
  k: 0,
  kernelMatrix: 1,
  kernelUnitLength: 1,
  kerning: 0,
  keyPoints: 1,
  keySplines: 1,
  keyTimes: 1,
  lengthAdjust: 1,
  letterSpacing: 1,
  "letter-spacing": "letterSpacing",
  lightingColor: 1,
  "lighting-color": "lightingColor",
  limitingConeAngle: 1,
  local: 0,
  markerEnd: 1,
  "marker-end": "markerEnd",
  markerHeight: 1,
  markerMid: 1,
  "marker-mid": "markerMid",
  markerStart: 1,
  "marker-start": "markerStart",
  markerUnits: 1,
  markerWidth: 1,
  mask: 0,
  maskContentUnits: 1,
  maskUnits: 1,
  mathematical: 0,
  mode: 0,
  numOctaves: 1,
  offset: 0,
  opacity: 0,
  operator: 0,
  order: 0,
  orient: 0,
  orientation: 0,
  origin: 0,
  overflow: 0,
  overlinePosition: 1,
  "overline-position": "overlinePosition",
  overlineThickness: 1,
  "overline-thickness": "overlineThickness",
  paintOrder: 1,
  "paint-order": "paintOrder",
  panose1: 0,
  "panose-1": "panose1",
  pathLength: 1,
  patternContentUnits: 1,
  patternTransform: 1,
  patternUnits: 1,
  pointerEvents: 1,
  "pointer-events": "pointerEvents",
  points: 0,
  pointsAtX: 1,
  pointsAtY: 1,
  pointsAtZ: 1,
  prefix: 0,
  preserveAlpha: 1,
  preserveAspectRatio: 1,
  primitiveUnits: 1,
  property: 0,
  r: 0,
  radius: 0,
  refX: 1,
  refY: 1,
  renderingIntent: 1,
  "rendering-intent": "renderingIntent",
  repeatCount: 1,
  repeatDur: 1,
  requiredExtensions: 1,
  requiredFeatures: 1,
  resource: 0,
  restart: 0,
  result: 0,
  results: 0,
  rotate: 0,
  rx: 0,
  ry: 0,
  scale: 0,
  security: 0,
  seed: 0,
  shapeRendering: 1,
  "shape-rendering": "shapeRendering",
  slope: 0,
  spacing: 0,
  specularConstant: 1,
  specularExponent: 1,
  speed: 0,
  spreadMethod: 1,
  startOffset: 1,
  stdDeviation: 1,
  stemh: 0,
  stemv: 0,
  stitchTiles: 1,
  stopColor: 1,
  "stop-color": "stopColor",
  stopOpacity: 1,
  "stop-opacity": "stopOpacity",
  strikethroughPosition: 1,
  "strikethrough-position": "strikethroughPosition",
  strikethroughThickness: 1,
  "strikethrough-thickness": "strikethroughThickness",
  string: 0,
  stroke: 0,
  strokeDasharray: 1,
  "stroke-dasharray": "strokeDasharray",
  strokeDashoffset: 1,
  "stroke-dashoffset": "strokeDashoffset",
  strokeLinecap: 1,
  "stroke-linecap": "strokeLinecap",
  strokeLinejoin: 1,
  "stroke-linejoin": "strokeLinejoin",
  strokeMiterlimit: 1,
  "stroke-miterlimit": "strokeMiterlimit",
  strokeWidth: 1,
  "stroke-width": "strokeWidth",
  strokeOpacity: 1,
  "stroke-opacity": "strokeOpacity",
  suppressContentEditableWarning: 1,
  suppressHydrationWarning: 1,
  surfaceScale: 1,
  systemLanguage: 1,
  tableValues: 1,
  targetX: 1,
  targetY: 1,
  textAnchor: 1,
  "text-anchor": "textAnchor",
  textDecoration: 1,
  "text-decoration": "textDecoration",
  textLength: 1,
  textRendering: 1,
  "text-rendering": "textRendering",
  to: 0,
  transform: 0,
  typeof: 0,
  u1: 0,
  u2: 0,
  underlinePosition: 1,
  "underline-position": "underlinePosition",
  underlineThickness: 1,
  "underline-thickness": "underlineThickness",
  unicode: 0,
  unicodeBidi: 1,
  "unicode-bidi": "unicodeBidi",
  unicodeRange: 1,
  "unicode-range": "unicodeRange",
  unitsPerEm: 1,
  "units-per-em": "unitsPerEm",
  unselectable: 0,
  vAlphabetic: 1,
  "v-alphabetic": "vAlphabetic",
  values: 0,
  vectorEffect: 1,
  "vector-effect": "vectorEffect",
  version: 0,
  vertAdvY: 1,
  "vert-adv-y": "vertAdvY",
  vertOriginX: 1,
  "vert-origin-x": "vertOriginX",
  vertOriginY: 1,
  "vert-origin-y": "vertOriginY",
  vHanging: 1,
  "v-hanging": "vHanging",
  vIdeographic: 1,
  "v-ideographic": "vIdeographic",
  viewBox: 1,
  viewTarget: 1,
  visibility: 0,
  vMathematical: 1,
  "v-mathematical": "vMathematical",
  vocab: 0,
  widths: 0,
  wordSpacing: 1,
  "word-spacing": "wordSpacing",
  writingMode: 1,
  "writing-mode": "writingMode",
  x1: 0,
  x2: 0,
  x: 0,
  xChannelSelector: 1,
  xHeight: 1,
  "x-height": "xHeight",
  xlinkActuate: 1,
  "xlink:actuate": "xlinkActuate",
  xlinkArcrole: 1,
  "xlink:arcrole": "xlinkArcrole",
  xlinkHref: 1,
  "xlink:href": "xlinkHref",
  xlinkRole: 1,
  "xlink:role": "xlinkRole",
  xlinkShow: 1,
  "xlink:show": "xlinkShow",
  xlinkTitle: 1,
  "xlink:title": "xlinkTitle",
  xlinkType: 1,
  "xlink:type": "xlinkType",
  xmlBase: 1,
  "xml:base": "xmlBase",
  xmlLang: 1,
  "xml:lang": "xmlLang",
  xmlns: 0,
  "xml:space": "xmlSpace",
  xmlnsXlink: 1,
  "xmlns:xlink": "xmlnsXlink",
  xmlSpace: 1,
  y1: 0,
  y2: 0,
  y: 0,
  yChannelSelector: 1,
  z: 0,
  zoomAndPan: 1
};
const q8 = 0, gl = 1, fb = 2, hb = 3, tL = 4, G8 = 5, K8 = 6;
function qre(e) {
  return jo.hasOwnProperty(e) ? jo[e] : null;
}
function Yo(e, t, n, r, o, i, a) {
  this.acceptsBooleans = t === fb || t === hb || t === tL, this.attributeName = r, this.attributeNamespace = o, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = i, this.removeEmptyString = a;
}
const jo = {}, Gre = [
  "children",
  "dangerouslySetInnerHTML",
  // TODO: This prevents the assignment of defaultValue to regular
  // elements (not just inputs). Now that ReactDOMInput assigns to the
  // defaultValue property -- do we need this?
  "defaultValue",
  "defaultChecked",
  "innerHTML",
  "suppressContentEditableWarning",
  "suppressHydrationWarning",
  "style"
];
Gre.forEach((e) => {
  jo[e] = new Yo(
    e,
    q8,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"]
].forEach(([e, t]) => {
  jo[e] = new Yo(
    e,
    gl,
    !1,
    // mustUseProperty
    t,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["contentEditable", "draggable", "spellCheck", "value"].forEach((e) => {
  jo[e] = new Yo(
    e,
    fb,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha"
].forEach((e) => {
  jo[e] = new Yo(
    e,
    fb,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "allowFullScreen",
  "async",
  // Note: there is a special case that prevents it from being written to the DOM
  // on the client side because the browsers are inconsistent. Instead we call focus().
  "autoFocus",
  "autoPlay",
  "controls",
  "default",
  "defer",
  "disabled",
  "disablePictureInPicture",
  "disableRemotePlayback",
  "formNoValidate",
  "hidden",
  "loop",
  "noModule",
  "noValidate",
  "open",
  "playsInline",
  "readOnly",
  "required",
  "reversed",
  "scoped",
  "seamless",
  // Microdata
  "itemScope"
].forEach((e) => {
  jo[e] = new Yo(
    e,
    hb,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "checked",
  // Note: `option.selected` is not updated if `select.multiple` is
  // disabled with `removeAttribute`. We have special logic for handling this.
  "multiple",
  "muted",
  "selected"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  jo[e] = new Yo(
    e,
    hb,
    !0,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "capture",
  "download"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  jo[e] = new Yo(
    e,
    tL,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "cols",
  "rows",
  "size",
  "span"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  jo[e] = new Yo(
    e,
    K8,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["rowSpan", "start"].forEach((e) => {
  jo[e] = new Yo(
    e,
    G8,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const nL = /[\-\:]([a-z])/g, rL = (e) => e[1].toUpperCase();
[
  "accent-height",
  "alignment-baseline",
  "arabic-form",
  "baseline-shift",
  "cap-height",
  "clip-path",
  "clip-rule",
  "color-interpolation",
  "color-interpolation-filters",
  "color-profile",
  "color-rendering",
  "dominant-baseline",
  "enable-background",
  "fill-opacity",
  "fill-rule",
  "flood-color",
  "flood-opacity",
  "font-family",
  "font-size",
  "font-size-adjust",
  "font-stretch",
  "font-style",
  "font-variant",
  "font-weight",
  "glyph-name",
  "glyph-orientation-horizontal",
  "glyph-orientation-vertical",
  "horiz-adv-x",
  "horiz-origin-x",
  "image-rendering",
  "letter-spacing",
  "lighting-color",
  "marker-end",
  "marker-mid",
  "marker-start",
  "overline-position",
  "overline-thickness",
  "paint-order",
  "panose-1",
  "pointer-events",
  "rendering-intent",
  "shape-rendering",
  "stop-color",
  "stop-opacity",
  "strikethrough-position",
  "strikethrough-thickness",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "text-anchor",
  "text-decoration",
  "text-rendering",
  "underline-position",
  "underline-thickness",
  "unicode-bidi",
  "unicode-range",
  "units-per-em",
  "v-alphabetic",
  "v-hanging",
  "v-ideographic",
  "v-mathematical",
  "vector-effect",
  "vert-adv-y",
  "vert-origin-x",
  "vert-origin-y",
  "word-spacing",
  "writing-mode",
  "xmlns:xlink",
  "x-height"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(nL, rL);
  jo[t] = new Yo(
    t,
    gl,
    !1,
    // mustUseProperty
    e,
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xlink:actuate",
  "xlink:arcrole",
  "xlink:role",
  "xlink:show",
  "xlink:title",
  "xlink:type"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(nL, rL);
  jo[t] = new Yo(
    t,
    gl,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/1999/xlink",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xml:base",
  "xml:lang",
  "xml:space"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(nL, rL);
  jo[t] = new Yo(
    t,
    gl,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/XML/1998/namespace",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["tabIndex", "crossOrigin"].forEach((e) => {
  jo[e] = new Yo(
    e,
    gl,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const Kre = "xlinkHref";
jo[Kre] = new Yo(
  "xlinkHref",
  gl,
  !1,
  // mustUseProperty
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  // sanitizeURL
  !1
  // removeEmptyString
);
["src", "href", "action", "formAction"].forEach((e) => {
  jo[e] = new Yo(
    e,
    gl,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !0,
    // sanitizeURL
    !0
    // removeEmptyString
  );
});
const {
  CAMELCASE: Yre,
  SAME: Xre,
  possibleStandardNames: hD
} = db, Jre = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", Qre = Jre + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", eoe = RegExp.prototype.test.bind(
  // eslint-disable-next-line no-misleading-character-class
  new RegExp("^(data|aria)-[" + Qre + "]*$")
), toe = Object.keys(
  hD
).reduce((e, t) => {
  const n = hD[t];
  return n === Xre ? e[t] = t : n === Yre ? e[t.toLowerCase()] = t : e[t] = n, e;
}, {});
ps.BOOLEAN = hb;
ps.BOOLEANISH_STRING = fb;
ps.NUMERIC = G8;
ps.OVERLOADED_BOOLEAN = tL;
ps.POSITIVE_NUMERIC = K8;
ps.RESERVED = q8;
ps.STRING = gl;
ps.getPropertyInfo = qre;
ps.isCustomAttribute = eoe;
ps.possibleStandardNames = toe;
var oL = {}, iL = {}, gD = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, noe = /\n/g, roe = /^\s*/, ooe = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, ioe = /^:\s*/, soe = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, aoe = /^[;\s]*/, loe = /^\s+|\s+$/g, uoe = `
`, mD = "/", vD = "*", ou = "", coe = "comment", poe = "declaration", doe = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e) return [];
  t = t || {};
  var n = 1, r = 1;
  function o(f) {
    var m = f.match(noe);
    m && (n += m.length);
    var v = f.lastIndexOf(uoe);
    r = ~v ? f.length - v : r + f.length;
  }
  function i() {
    var f = { line: n, column: r };
    return function(m) {
      return m.position = new a(f), u(), m;
    };
  }
  function a(f) {
    this.start = f, this.end = { line: n, column: r }, this.source = t.source;
  }
  a.prototype.content = e;
  function s(f) {
    var m = new Error(
      t.source + ":" + n + ":" + r + ": " + f
    );
    if (m.reason = f, m.filename = t.source, m.line = n, m.column = r, m.source = e, !t.silent) throw m;
  }
  function l(f) {
    var m = f.exec(e);
    if (m) {
      var v = m[0];
      return o(v), e = e.slice(v.length), m;
    }
  }
  function u() {
    l(roe);
  }
  function c(f) {
    var m;
    for (f = f || []; m = p(); )
      m !== !1 && f.push(m);
    return f;
  }
  function p() {
    var f = i();
    if (!(mD != e.charAt(0) || vD != e.charAt(1))) {
      for (var m = 2; ou != e.charAt(m) && (vD != e.charAt(m) || mD != e.charAt(m + 1)); )
        ++m;
      if (m += 2, ou === e.charAt(m - 1))
        return s("End of comment missing");
      var v = e.slice(2, m - 2);
      return r += 2, o(v), e = e.slice(m), r += 2, f({
        type: coe,
        comment: v
      });
    }
  }
  function d() {
    var f = i(), m = l(ooe);
    if (m) {
      if (p(), !l(ioe)) return s("property missing ':'");
      var v = l(soe), E = f({
        type: poe,
        property: yD(m[0].replace(gD, ou)),
        value: v ? yD(v[0].replace(gD, ou)) : ou
      });
      return l(aoe), E;
    }
  }
  function g() {
    var f = [];
    c(f);
    for (var m; m = d(); )
      m !== !1 && (f.push(m), c(f));
    return f;
  }
  return u(), g();
};
function yD(e) {
  return e ? e.replace(loe, ou) : ou;
}
var foe = Jn && Jn.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(iL, "__esModule", { value: !0 });
iL.default = goe;
var hoe = foe(doe);
function goe(e, t) {
  var n = null;
  if (!e || typeof e != "string")
    return n;
  var r = (0, hoe.default)(e), o = typeof t == "function";
  return r.forEach(function(i) {
    if (i.type === "declaration") {
      var a = i.property, s = i.value;
      o ? t(a, s, i) : s && (n = n || {}, n[a] = s);
    }
  }), n;
}
var gb = {};
Object.defineProperty(gb, "__esModule", { value: !0 });
gb.camelCase = void 0;
var moe = /^--[a-zA-Z0-9_-]+$/, voe = /-([a-z])/g, yoe = /^[^-]+$/, boe = /^-(webkit|moz|ms|o|khtml)-/, woe = /^-(ms)-/, Coe = function(e) {
  return !e || yoe.test(e) || moe.test(e);
}, xoe = function(e, t) {
  return t.toUpperCase();
}, bD = function(e, t) {
  return "".concat(t, "-");
}, Ooe = function(e, t) {
  return t === void 0 && (t = {}), Coe(e) ? e : (e = e.toLowerCase(), t.reactCompat ? e = e.replace(woe, bD) : e = e.replace(boe, bD), e.replace(voe, xoe));
};
gb.camelCase = Ooe;
var Eoe = Jn && Jn.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
}, koe = Eoe(iL), Loe = gb;
function fE(e, t) {
  var n = {};
  return !e || typeof e != "string" || (0, koe.default)(e, function(r, o) {
    r && o && (n[(0, Loe.camelCase)(r, t)] = o);
  }), n;
}
fE.default = fE;
var Poe = fE;
(function(e) {
  var t = Jn && Jn.__importDefault || function(c) {
    return c && c.__esModule ? c : { default: c };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.returnFirstArg = e.canTextBeChildOfNode = e.ELEMENTS_WITH_NO_TEXT_CHILDREN = e.PRESERVE_CUSTOM_ATTRIBUTES = void 0, e.isCustomComponent = i, e.setStyleProp = s;
  var n = we, r = t(Poe), o = /* @__PURE__ */ new Set([
    "annotation-xml",
    "color-profile",
    "font-face",
    "font-face-src",
    "font-face-uri",
    "font-face-format",
    "font-face-name",
    "missing-glyph"
  ]);
  function i(c, p) {
    return c.includes("-") ? !o.has(c) : !!(p && typeof p.is == "string");
  }
  var a = {
    reactCompat: !0
  };
  function s(c, p) {
    if (typeof c == "string") {
      if (!c.trim()) {
        p.style = {};
        return;
      }
      try {
        p.style = (0, r.default)(c, a);
      } catch {
        p.style = {};
      }
    }
  }
  e.PRESERVE_CUSTOM_ATTRIBUTES = Number(n.version.split(".")[0]) >= 16, e.ELEMENTS_WITH_NO_TEXT_CHILDREN = /* @__PURE__ */ new Set([
    "tr",
    "tbody",
    "thead",
    "tfoot",
    "colgroup",
    "table",
    "head",
    "html",
    "frameset"
  ]);
  var l = function(c) {
    return !e.ELEMENTS_WITH_NO_TEXT_CHILDREN.has(c.name);
  };
  e.canTextBeChildOfNode = l;
  var u = function(c) {
    return c;
  };
  e.returnFirstArg = u;
})(oL);
Object.defineProperty(pb, "__esModule", { value: !0 });
pb.default = Doe;
var _p = ps, wD = oL, _oe = ["checked", "value"], Soe = ["input", "select", "textarea"], Moe = {
  reset: !0,
  submit: !0
};
function Doe(e, t) {
  e === void 0 && (e = {});
  var n = {}, r = !!(e.type && Moe[e.type]);
  for (var o in e) {
    var i = e[o];
    if ((0, _p.isCustomAttribute)(o)) {
      n[o] = i;
      continue;
    }
    var a = o.toLowerCase(), s = CD(a);
    if (s) {
      var l = (0, _p.getPropertyInfo)(s);
      switch (_oe.includes(s) && Soe.includes(t) && !r && (s = CD("default" + a)), n[s] = i, l && l.type) {
        case _p.BOOLEAN:
          n[s] = !0;
          break;
        case _p.OVERLOADED_BOOLEAN:
          i === "" && (n[s] = !0);
          break;
      }
      continue;
    }
    wD.PRESERVE_CUSTOM_ATTRIBUTES && (n[o] = i);
  }
  return (0, wD.setStyleProp)(e.style, n), n;
}
function CD(e) {
  return _p.possibleStandardNames[e];
}
var sL = {}, Toe = Jn && Jn.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(sL, "__esModule", { value: !0 });
sL.default = Y8;
var R0 = we, joe = Toe(pb), $p = oL, Aoe = {
  cloneElement: R0.cloneElement,
  createElement: R0.createElement,
  isValidElement: R0.isValidElement
};
function Y8(e, t) {
  t === void 0 && (t = {});
  for (var n = [], r = typeof t.replace == "function", o = t.transform || $p.returnFirstArg, i = t.library || Aoe, a = i.cloneElement, s = i.createElement, l = i.isValidElement, u = e.length, c = 0; c < u; c++) {
    var p = e[c];
    if (r) {
      var d = t.replace(p, c);
      if (l(d)) {
        u > 1 && (d = a(d, {
          key: d.key || c
        })), n.push(o(d, p, c));
        continue;
      }
    }
    if (p.type === "text") {
      var g = !p.data.trim().length;
      if (g && p.parent && !(0, $p.canTextBeChildOfNode)(p.parent) || t.trim && g)
        continue;
      n.push(o(p.data, p, c));
      continue;
    }
    var f = p, m = {};
    Ioe(f) ? ((0, $p.setStyleProp)(f.attribs.style, f.attribs), m = f.attribs) : f.attribs && (m = (0, joe.default)(f.attribs, f.name));
    var v = void 0;
    switch (p.type) {
      case "script":
      case "style":
        p.children[0] && (m.dangerouslySetInnerHTML = {
          __html: p.children[0].data
        });
        break;
      case "tag":
        p.name === "textarea" && p.children[0] ? m.defaultValue = p.children[0].data : p.children && p.children.length && (v = Y8(p.children, t));
        break;
      default:
        continue;
    }
    u > 1 && (m.key = c), n.push(o(s(p.name, m, v), p, c));
  }
  return n.length === 1 ? n[0] : n;
}
function Ioe(e) {
  return $p.PRESERVE_CUSTOM_ATTRIBUTES && e.type === "tag" && (0, $p.isCustomComponent)(e.name, e.attribs);
}
(function(e) {
  var t = Jn && Jn.__importDefault || function(l) {
    return l && l.__esModule ? l : { default: l };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.htmlToDOM = e.domToReact = e.attributesToProps = e.Text = e.ProcessingInstruction = e.Element = e.Comment = void 0, e.default = s;
  var n = t(K1);
  e.htmlToDOM = n.default;
  var r = t(pb);
  e.attributesToProps = r.default;
  var o = t(sL);
  e.domToReact = o.default;
  var i = X1;
  Object.defineProperty(e, "Comment", { enumerable: !0, get: function() {
    return i.Comment;
  } }), Object.defineProperty(e, "Element", { enumerable: !0, get: function() {
    return i.Element;
  } }), Object.defineProperty(e, "ProcessingInstruction", { enumerable: !0, get: function() {
    return i.ProcessingInstruction;
  } }), Object.defineProperty(e, "Text", { enumerable: !0, get: function() {
    return i.Text;
  } });
  var a = { lowerCaseAttributeNames: !1 };
  function s(l, u) {
    if (typeof l != "string")
      throw new TypeError("First argument must be a string");
    return l ? (0, o.default)((0, n.default)(l, (u == null ? void 0 : u.htmlparser2) || a), u) : [];
  }
})(M8);
const xD = /* @__PURE__ */ tre(M8);
xD.default;
function Roe(e) {
  const {
    className: t,
    orientation: n = "horizontal",
    ...r
  } = e, o = `arkynDivider ${n} ${t}`;
  return /* @__PURE__ */ Sn.jsx("div", { className: o.trim(), ...r });
}
var Qn = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Boe(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var hE = { exports: {} }, qc = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var OD;
function Noe() {
  if (OD) return qc;
  OD = 1;
  var e = we, t = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, o = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, i = { key: !0, ref: !0, __self: !0, __source: !0 };
  function a(s, l, u) {
    var c, p = {}, d = null, g = null;
    u !== void 0 && (d = "" + u), l.key !== void 0 && (d = "" + l.key), l.ref !== void 0 && (g = l.ref);
    for (c in l) r.call(l, c) && !i.hasOwnProperty(c) && (p[c] = l[c]);
    if (s && s.defaultProps) for (c in l = s.defaultProps, l) p[c] === void 0 && (p[c] = l[c]);
    return { $$typeof: t, type: s, key: d, ref: g, props: p, _owner: o.current };
  }
  return qc.Fragment = n, qc.jsx = a, qc.jsxs = a, qc;
}
var kh = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var ED;
function Foe() {
  return ED || (ED = 1, process.env.NODE_ENV !== "production" && function() {
    var e = we, t = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), a = Symbol.for("react.provider"), s = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), c = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), d = Symbol.for("react.lazy"), g = Symbol.for("react.offscreen"), f = Symbol.iterator, m = "@@iterator";
    function v(b) {
      if (b === null || typeof b != "object")
        return null;
      var I = f && b[f] || b[m];
      return typeof I == "function" ? I : null;
    }
    var E = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function w(b) {
      {
        for (var I = arguments.length, G = new Array(I > 1 ? I - 1 : 0), ne = 1; ne < I; ne++)
          G[ne - 1] = arguments[ne];
        M("error", b, G);
      }
    }
    function M(b, I, G) {
      {
        var ne = E.ReactDebugCurrentFrame, le = ne.getStackAddendum();
        le !== "" && (I += "%s", G = G.concat([le]));
        var ce = G.map(function(se) {
          return String(se);
        });
        ce.unshift("Warning: " + I), Function.prototype.apply.call(console[b], console, ce);
      }
    }
    var O = !1, y = !1, C = !1, _ = !1, F = !1, L;
    L = Symbol.for("react.module.reference");
    function N(b) {
      return !!(typeof b == "string" || typeof b == "function" || b === r || b === i || F || b === o || b === u || b === c || _ || b === g || O || y || C || typeof b == "object" && b !== null && (b.$$typeof === d || b.$$typeof === p || b.$$typeof === a || b.$$typeof === s || b.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      b.$$typeof === L || b.getModuleId !== void 0));
    }
    function R(b, I, G) {
      var ne = b.displayName;
      if (ne)
        return ne;
      var le = I.displayName || I.name || "";
      return le !== "" ? G + "(" + le + ")" : G;
    }
    function W(b) {
      return b.displayName || "Context";
    }
    function V(b) {
      if (b == null)
        return null;
      if (typeof b.tag == "number" && w("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof b == "function")
        return b.displayName || b.name || null;
      if (typeof b == "string")
        return b;
      switch (b) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case i:
          return "Profiler";
        case o:
          return "StrictMode";
        case u:
          return "Suspense";
        case c:
          return "SuspenseList";
      }
      if (typeof b == "object")
        switch (b.$$typeof) {
          case s:
            var I = b;
            return W(I) + ".Consumer";
          case a:
            var G = b;
            return W(G._context) + ".Provider";
          case l:
            return R(b, b.render, "ForwardRef");
          case p:
            var ne = b.displayName || null;
            return ne !== null ? ne : V(b.type) || "Memo";
          case d: {
            var le = b, ce = le._payload, se = le._init;
            try {
              return V(se(ce));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var z = Object.assign, Z = 0, K, X, te, J, P, D, H;
    function S() {
    }
    S.__reactDisabledLog = !0;
    function $() {
      {
        if (Z === 0) {
          K = console.log, X = console.info, te = console.warn, J = console.error, P = console.group, D = console.groupCollapsed, H = console.groupEnd;
          var b = {
            configurable: !0,
            enumerable: !0,
            value: S,
            writable: !0
          };
          Object.defineProperties(console, {
            info: b,
            log: b,
            warn: b,
            error: b,
            group: b,
            groupCollapsed: b,
            groupEnd: b
          });
        }
        Z++;
      }
    }
    function x() {
      {
        if (Z--, Z === 0) {
          var b = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: z({}, b, {
              value: K
            }),
            info: z({}, b, {
              value: X
            }),
            warn: z({}, b, {
              value: te
            }),
            error: z({}, b, {
              value: J
            }),
            group: z({}, b, {
              value: P
            }),
            groupCollapsed: z({}, b, {
              value: D
            }),
            groupEnd: z({}, b, {
              value: H
            })
          });
        }
        Z < 0 && w("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var j = E.ReactCurrentDispatcher, U;
    function T(b, I, G) {
      {
        if (U === void 0)
          try {
            throw Error();
          } catch (le) {
            var ne = le.stack.trim().match(/\n( *(at )?)/);
            U = ne && ne[1] || "";
          }
        return `
` + U + b;
      }
    }
    var q = !1, A;
    {
      var Y = typeof WeakMap == "function" ? WeakMap : Map;
      A = new Y();
    }
    function B(b, I) {
      if (!b || q)
        return "";
      {
        var G = A.get(b);
        if (G !== void 0)
          return G;
      }
      var ne;
      q = !0;
      var le = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var ce;
      ce = j.current, j.current = null, $();
      try {
        if (I) {
          var se = function() {
            throw Error();
          };
          if (Object.defineProperty(se.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(se, []);
            } catch (je) {
              ne = je;
            }
            Reflect.construct(b, [], se);
          } else {
            try {
              se.call();
            } catch (je) {
              ne = je;
            }
            b.call(se.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (je) {
            ne = je;
          }
          b();
        }
      } catch (je) {
        if (je && ne && typeof je.stack == "string") {
          for (var ie = je.stack.split(`
`), Se = ne.stack.split(`
`), de = ie.length - 1, he = Se.length - 1; de >= 1 && he >= 0 && ie[de] !== Se[he]; )
            he--;
          for (; de >= 1 && he >= 0; de--, he--)
            if (ie[de] !== Se[he]) {
              if (de !== 1 || he !== 1)
                do
                  if (de--, he--, he < 0 || ie[de] !== Se[he]) {
                    var Ve = `
` + ie[de].replace(" at new ", " at ");
                    return b.displayName && Ve.includes("<anonymous>") && (Ve = Ve.replace("<anonymous>", b.displayName)), typeof b == "function" && A.set(b, Ve), Ve;
                  }
                while (de >= 1 && he >= 0);
              break;
            }
        }
      } finally {
        q = !1, j.current = ce, x(), Error.prepareStackTrace = le;
      }
      var xt = b ? b.displayName || b.name : "", vt = xt ? T(xt) : "";
      return typeof b == "function" && A.set(b, vt), vt;
    }
    function ue(b, I, G) {
      return B(b, !1);
    }
    function fe(b) {
      var I = b.prototype;
      return !!(I && I.isReactComponent);
    }
    function oe(b, I, G) {
      if (b == null)
        return "";
      if (typeof b == "function")
        return B(b, fe(b));
      if (typeof b == "string")
        return T(b);
      switch (b) {
        case u:
          return T("Suspense");
        case c:
          return T("SuspenseList");
      }
      if (typeof b == "object")
        switch (b.$$typeof) {
          case l:
            return ue(b.render);
          case p:
            return oe(b.type, I, G);
          case d: {
            var ne = b, le = ne._payload, ce = ne._init;
            try {
              return oe(ce(le), I, G);
            } catch {
            }
          }
        }
      return "";
    }
    var Ae = Object.prototype.hasOwnProperty, Ze = {}, Ge = E.ReactDebugCurrentFrame;
    function Ie(b) {
      if (b) {
        var I = b._owner, G = oe(b.type, b._source, I ? I.type : null);
        Ge.setExtraStackFrame(G);
      } else
        Ge.setExtraStackFrame(null);
    }
    function et(b, I, G, ne, le) {
      {
        var ce = Function.call.bind(Ae);
        for (var se in b)
          if (ce(b, se)) {
            var ie = void 0;
            try {
              if (typeof b[se] != "function") {
                var Se = Error((ne || "React class") + ": " + G + " type `" + se + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof b[se] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw Se.name = "Invariant Violation", Se;
              }
              ie = b[se](I, se, ne, G, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (de) {
              ie = de;
            }
            ie && !(ie instanceof Error) && (Ie(le), w("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", ne || "React class", G, se, typeof ie), Ie(null)), ie instanceof Error && !(ie.message in Ze) && (Ze[ie.message] = !0, Ie(le), w("Failed %s type: %s", G, ie.message), Ie(null));
          }
      }
    }
    var Ye = Array.isArray;
    function _e(b) {
      return Ye(b);
    }
    function Qe(b) {
      {
        var I = typeof Symbol == "function" && Symbol.toStringTag, G = I && b[Symbol.toStringTag] || b.constructor.name || "Object";
        return G;
      }
    }
    function at(b) {
      try {
        return Pe(b), !1;
      } catch {
        return !0;
      }
    }
    function Pe(b) {
      return "" + b;
    }
    function Me(b) {
      if (at(b))
        return w("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Qe(b)), Pe(b);
    }
    var Je = E.ReactCurrentOwner, We = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, Re, nt;
    function De(b) {
      if (Ae.call(b, "ref")) {
        var I = Object.getOwnPropertyDescriptor(b, "ref").get;
        if (I && I.isReactWarning)
          return !1;
      }
      return b.ref !== void 0;
    }
    function yt(b) {
      if (Ae.call(b, "key")) {
        var I = Object.getOwnPropertyDescriptor(b, "key").get;
        if (I && I.isReactWarning)
          return !1;
      }
      return b.key !== void 0;
    }
    function ot(b, I) {
      typeof b.ref == "string" && Je.current;
    }
    function st(b, I) {
      {
        var G = function() {
          Re || (Re = !0, w("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", I));
        };
        G.isReactWarning = !0, Object.defineProperty(b, "key", {
          get: G,
          configurable: !0
        });
      }
    }
    function ct(b, I) {
      {
        var G = function() {
          nt || (nt = !0, w("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", I));
        };
        G.isReactWarning = !0, Object.defineProperty(b, "ref", {
          get: G,
          configurable: !0
        });
      }
    }
    var bt = function(b, I, G, ne, le, ce, se) {
      var ie = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: b,
        key: I,
        ref: G,
        props: se,
        // Record the component responsible for creating this element.
        _owner: ce
      };
      return ie._store = {}, Object.defineProperty(ie._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(ie, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ne
      }), Object.defineProperty(ie, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: le
      }), Object.freeze && (Object.freeze(ie.props), Object.freeze(ie)), ie;
    };
    function pt(b, I, G, ne, le) {
      {
        var ce, se = {}, ie = null, Se = null;
        G !== void 0 && (Me(G), ie = "" + G), yt(I) && (Me(I.key), ie = "" + I.key), De(I) && (Se = I.ref, ot(I));
        for (ce in I)
          Ae.call(I, ce) && !We.hasOwnProperty(ce) && (se[ce] = I[ce]);
        if (b && b.defaultProps) {
          var de = b.defaultProps;
          for (ce in de)
            se[ce] === void 0 && (se[ce] = de[ce]);
        }
        if (ie || Se) {
          var he = typeof b == "function" ? b.displayName || b.name || "Unknown" : b;
          ie && st(se, he), Se && ct(se, he);
        }
        return bt(b, ie, Se, le, ne, Je.current, se);
      }
    }
    var dt = E.ReactCurrentOwner, tt = E.ReactDebugCurrentFrame;
    function Xe(b) {
      if (b) {
        var I = b._owner, G = oe(b.type, b._source, I ? I.type : null);
        tt.setExtraStackFrame(G);
      } else
        tt.setExtraStackFrame(null);
    }
    var wt;
    wt = !1;
    function Ct(b) {
      return typeof b == "object" && b !== null && b.$$typeof === t;
    }
    function ft() {
      {
        if (dt.current) {
          var b = V(dt.current.type);
          if (b)
            return `

Check the render method of \`` + b + "`.";
        }
        return "";
      }
    }
    function bn(b) {
      return "";
    }
    var ht = {};
    function wn(b) {
      {
        var I = ft();
        if (!I) {
          var G = typeof b == "string" ? b : b.displayName || b.name;
          G && (I = `

Check the top-level render call using <` + G + ">.");
        }
        return I;
      }
    }
    function gt(b, I) {
      {
        if (!b._store || b._store.validated || b.key != null)
          return;
        b._store.validated = !0;
        var G = wn(I);
        if (ht[G])
          return;
        ht[G] = !0;
        var ne = "";
        b && b._owner && b._owner !== dt.current && (ne = " It was passed a child from " + V(b._owner.type) + "."), Xe(b), w('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', G, ne), Xe(null);
      }
    }
    function Mt(b, I) {
      {
        if (typeof b != "object")
          return;
        if (_e(b))
          for (var G = 0; G < b.length; G++) {
            var ne = b[G];
            Ct(ne) && gt(ne, I);
          }
        else if (Ct(b))
          b._store && (b._store.validated = !0);
        else if (b) {
          var le = v(b);
          if (typeof le == "function" && le !== b.entries)
            for (var ce = le.call(b), se; !(se = ce.next()).done; )
              Ct(se.value) && gt(se.value, I);
        }
      }
    }
    function ir(b) {
      {
        var I = b.type;
        if (I == null || typeof I == "string")
          return;
        var G;
        if (typeof I == "function")
          G = I.propTypes;
        else if (typeof I == "object" && (I.$$typeof === l || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        I.$$typeof === p))
          G = I.propTypes;
        else
          return;
        if (G) {
          var ne = V(I);
          et(G, b.props, "prop", ne, b);
        } else if (I.PropTypes !== void 0 && !wt) {
          wt = !0;
          var le = V(I);
          w("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", le || "Unknown");
        }
        typeof I.getDefaultProps == "function" && !I.getDefaultProps.isReactClassApproved && w("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function mt(b) {
      {
        for (var I = Object.keys(b.props), G = 0; G < I.length; G++) {
          var ne = I[G];
          if (ne !== "children" && ne !== "key") {
            Xe(b), w("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", ne), Xe(null);
            break;
          }
        }
        b.ref !== null && (Xe(b), w("Invalid attribute `ref` supplied to `React.Fragment`."), Xe(null));
      }
    }
    var re = {};
    function vo(b, I, G, ne, le, ce) {
      {
        var se = N(b);
        if (!se) {
          var ie = "";
          (b === void 0 || typeof b == "object" && b !== null && Object.keys(b).length === 0) && (ie += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var Se = bn();
          Se ? ie += Se : ie += ft();
          var de;
          b === null ? de = "null" : _e(b) ? de = "array" : b !== void 0 && b.$$typeof === t ? (de = "<" + (V(b.type) || "Unknown") + " />", ie = " Did you accidentally export a JSX literal instead of a component?") : de = typeof b, w("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", de, ie);
        }
        var he = pt(b, I, G, le, ce);
        if (he == null)
          return he;
        if (se) {
          var Ve = I.children;
          if (Ve !== void 0)
            if (ne)
              if (_e(Ve)) {
                for (var xt = 0; xt < Ve.length; xt++)
                  Mt(Ve[xt], b);
                Object.freeze && Object.freeze(Ve);
              } else
                w("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Mt(Ve, b);
        }
        if (Ae.call(I, "key")) {
          var vt = V(b), je = Object.keys(I).filter(function(Li) {
            return Li !== "key";
          }), sr = je.length > 0 ? "{key: someKey, " + je.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!re[vt + sr]) {
            var ki = je.length > 0 ? "{" + je.join(": ..., ") + ": ...}" : "{}";
            w(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, sr, vt, ki, vt), re[vt + sr] = !0;
          }
        }
        return b === r ? mt(he) : ir(he), he;
      }
    }
    function Ci(b, I, G) {
      return vo(b, I, G, !0);
    }
    function xi(b, I, G) {
      return vo(b, I, G, !1);
    }
    var Oi = xi, Ei = Ci;
    kh.Fragment = r, kh.jsx = Oi, kh.jsxs = Ei;
  }()), kh;
}
process.env.NODE_ENV === "production" ? hE.exports = Noe() : hE.exports = Foe();
var Po = hE.exports;
Ke({});
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function kD(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function zo(e) {
  var t, n;
  return kD(e) === !1 ? !1 : (t = e.constructor, t === void 0 ? !0 : (n = t.prototype, !(kD(n) === !1 || n.hasOwnProperty("isPrototypeOf") === !1)));
}
var X8 = Symbol.for("immer-nothing"), LD = Symbol.for("immer-draftable"), Wi = Symbol.for("immer-state"), zoe = process.env.NODE_ENV !== "production" ? [
  // All error codes, starting by 0:
  function(e) {
    return `The plugin for '${e}' has not been loaded into Immer. To enable the plugin, import and call \`enable${e}()\` when initializing your application.`;
  },
  function(e) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${e}'`;
  },
  "This object has been frozen and should not be mutated",
  function(e) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + e;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(e) {
    return `'current' expects a draft, got: ${e}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(e) {
    return `'original' expects a draft, got: ${e}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function si(e, ...t) {
  if (process.env.NODE_ENV !== "production") {
    const n = zoe[e], r = typeof n == "function" ? n.apply(null, t) : n;
    throw new Error(`[Immer] ${r}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var hc = Object.getPrototypeOf;
function Su(e) {
  return !!e && !!e[Wi];
}
function Mu(e) {
  var t;
  return e ? J8(e) || Array.isArray(e) || !!e[LD] || !!((t = e.constructor) != null && t[LD]) || vb(e) || yb(e) : !1;
}
var Uoe = Object.prototype.constructor.toString();
function J8(e) {
  if (!e || typeof e != "object")
    return !1;
  const t = hc(e);
  if (t === null)
    return !0;
  const n = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
  return n === Object ? !0 : typeof n == "function" && Function.toString.call(n) === Uoe;
}
function Xm(e, t) {
  mb(e) === 0 ? Reflect.ownKeys(e).forEach((n) => {
    t(n, e[n], e);
  }) : e.forEach((n, r) => t(r, n, e));
}
function mb(e) {
  const t = e[Wi];
  return t ? t.type_ : Array.isArray(e) ? 1 : vb(e) ? 2 : yb(e) ? 3 : 0;
}
function gE(e, t) {
  return mb(e) === 2 ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t);
}
function Q8(e, t, n) {
  const r = mb(e);
  r === 2 ? e.set(t, n) : r === 3 ? e.add(n) : e[t] = n;
}
function Hoe(e, t) {
  return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && t !== t;
}
function vb(e) {
  return e instanceof Map;
}
function yb(e) {
  return e instanceof Set;
}
function Xl(e) {
  return e.copy_ || e.base_;
}
function mE(e, t) {
  if (vb(e))
    return new Map(e);
  if (yb(e))
    return new Set(e);
  if (Array.isArray(e))
    return Array.prototype.slice.call(e);
  const n = J8(e);
  if (t === !0 || t === "class_only" && !n) {
    const r = Object.getOwnPropertyDescriptors(e);
    delete r[Wi];
    let o = Reflect.ownKeys(r);
    for (let i = 0; i < o.length; i++) {
      const a = o[i], s = r[a];
      s.writable === !1 && (s.writable = !0, s.configurable = !0), (s.get || s.set) && (r[a] = {
        configurable: !0,
        writable: !0,
        // could live with !!desc.set as well here...
        enumerable: s.enumerable,
        value: e[a]
      });
    }
    return Object.create(hc(e), r);
  } else {
    const r = hc(e);
    if (r !== null && n)
      return { ...e };
    const o = Object.create(r);
    return Object.assign(o, e);
  }
}
function aL(e, t = !1) {
  return bb(e) || Su(e) || !Mu(e) || (mb(e) > 1 && (e.set = e.add = e.clear = e.delete = $oe), Object.freeze(e), t && Object.entries(e).forEach(([n, r]) => aL(r, !0))), e;
}
function $oe() {
  si(2);
}
function bb(e) {
  return Object.isFrozen(e);
}
var Woe = {};
function Du(e) {
  const t = Woe[e];
  return t || si(0, e), t;
}
var Pd;
function e5() {
  return Pd;
}
function Voe(e, t) {
  return {
    drafts_: [],
    parent_: e,
    immer_: t,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0
  };
}
function PD(e, t) {
  t && (Du("Patches"), e.patches_ = [], e.inversePatches_ = [], e.patchListener_ = t);
}
function vE(e) {
  yE(e), e.drafts_.forEach(Zoe), e.drafts_ = null;
}
function yE(e) {
  e === Pd && (Pd = e.parent_);
}
function _D(e) {
  return Pd = Voe(Pd, e);
}
function Zoe(e) {
  const t = e[Wi];
  t.type_ === 0 || t.type_ === 1 ? t.revoke_() : t.revoked_ = !0;
}
function SD(e, t) {
  t.unfinalizedDrafts_ = t.drafts_.length;
  const n = t.drafts_[0];
  return e !== void 0 && e !== n ? (n[Wi].modified_ && (vE(t), si(4)), Mu(e) && (e = Jm(t, e), t.parent_ || Qm(t, e)), t.patches_ && Du("Patches").generateReplacementPatches_(
    n[Wi].base_,
    e,
    t.patches_,
    t.inversePatches_
  )) : e = Jm(t, n, []), vE(t), t.patches_ && t.patchListener_(t.patches_, t.inversePatches_), e !== X8 ? e : void 0;
}
function Jm(e, t, n) {
  if (bb(t))
    return t;
  const r = t[Wi];
  if (!r)
    return Xm(
      t,
      (o, i) => MD(e, r, t, o, i, n)
    ), t;
  if (r.scope_ !== e)
    return t;
  if (!r.modified_)
    return Qm(e, r.base_, !0), r.base_;
  if (!r.finalized_) {
    r.finalized_ = !0, r.scope_.unfinalizedDrafts_--;
    const o = r.copy_;
    let i = o, a = !1;
    r.type_ === 3 && (i = new Set(o), o.clear(), a = !0), Xm(
      i,
      (s, l) => MD(e, r, o, s, l, n, a)
    ), Qm(e, o, !1), n && e.patches_ && Du("Patches").generatePatches_(
      r,
      n,
      e.patches_,
      e.inversePatches_
    );
  }
  return r.copy_;
}
function MD(e, t, n, r, o, i, a) {
  if (process.env.NODE_ENV !== "production" && o === n && si(5), Su(o)) {
    const s = i && t && t.type_ !== 3 && // Set objects are atomic since they have no keys.
    !gE(t.assigned_, r) ? i.concat(r) : void 0, l = Jm(e, o, s);
    if (Q8(n, r, l), Su(l))
      e.canAutoFreeze_ = !1;
    else
      return;
  } else a && n.add(o);
  if (Mu(o) && !bb(o)) {
    if (!e.immer_.autoFreeze_ && e.unfinalizedDrafts_ < 1)
      return;
    Jm(e, o), (!t || !t.scope_.parent_) && typeof r != "symbol" && Object.prototype.propertyIsEnumerable.call(n, r) && Qm(e, o);
  }
}
function Qm(e, t, n = !1) {
  !e.parent_ && e.immer_.autoFreeze_ && e.canAutoFreeze_ && aL(t, n);
}
function qoe(e, t) {
  const n = Array.isArray(e), r = {
    type_: n ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: t ? t.scope_ : e5(),
    // True for both shallow and deep changes.
    modified_: !1,
    // Used during finalization.
    finalized_: !1,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: t,
    // The base state.
    base_: e,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: !1
  };
  let o = r, i = lL;
  n && (o = [r], i = _d);
  const { revoke: a, proxy: s } = Proxy.revocable(o, i);
  return r.draft_ = s, r.revoke_ = a, s;
}
var lL = {
  get(e, t) {
    if (t === Wi)
      return e;
    const n = Xl(e);
    if (!gE(n, t))
      return Goe(e, n, t);
    const r = n[t];
    return e.finalized_ || !Mu(r) ? r : r === B0(e.base_, t) ? (N0(e), e.copy_[t] = wE(r, e)) : r;
  },
  has(e, t) {
    return t in Xl(e);
  },
  ownKeys(e) {
    return Reflect.ownKeys(Xl(e));
  },
  set(e, t, n) {
    const r = t5(Xl(e), t);
    if (r != null && r.set)
      return r.set.call(e.draft_, n), !0;
    if (!e.modified_) {
      const o = B0(Xl(e), t), i = o == null ? void 0 : o[Wi];
      if (i && i.base_ === n)
        return e.copy_[t] = n, e.assigned_[t] = !1, !0;
      if (Hoe(n, o) && (n !== void 0 || gE(e.base_, t)))
        return !0;
      N0(e), bE(e);
    }
    return e.copy_[t] === n && // special case: handle new props with value 'undefined'
    (n !== void 0 || t in e.copy_) || // special case: NaN
    Number.isNaN(n) && Number.isNaN(e.copy_[t]) || (e.copy_[t] = n, e.assigned_[t] = !0), !0;
  },
  deleteProperty(e, t) {
    return B0(e.base_, t) !== void 0 || t in e.base_ ? (e.assigned_[t] = !1, N0(e), bE(e)) : delete e.assigned_[t], e.copy_ && delete e.copy_[t], !0;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(e, t) {
    const n = Xl(e), r = Reflect.getOwnPropertyDescriptor(n, t);
    return r && {
      writable: !0,
      configurable: e.type_ !== 1 || t !== "length",
      enumerable: r.enumerable,
      value: n[t]
    };
  },
  defineProperty() {
    si(11);
  },
  getPrototypeOf(e) {
    return hc(e.base_);
  },
  setPrototypeOf() {
    si(12);
  }
}, _d = {};
Xm(lL, (e, t) => {
  _d[e] = function() {
    return arguments[0] = arguments[0][0], t.apply(this, arguments);
  };
});
_d.deleteProperty = function(e, t) {
  return process.env.NODE_ENV !== "production" && isNaN(parseInt(t)) && si(13), _d.set.call(this, e, t, void 0);
};
_d.set = function(e, t, n) {
  return process.env.NODE_ENV !== "production" && t !== "length" && isNaN(parseInt(t)) && si(14), lL.set.call(this, e[0], t, n, e[0]);
};
function B0(e, t) {
  const n = e[Wi];
  return (n ? Xl(n) : e)[t];
}
function Goe(e, t, n) {
  var r;
  const o = t5(t, n);
  return o ? "value" in o ? o.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (r = o.get) == null ? void 0 : r.call(e.draft_)
  ) : void 0;
}
function t5(e, t) {
  if (!(t in e))
    return;
  let n = hc(e);
  for (; n; ) {
    const r = Object.getOwnPropertyDescriptor(n, t);
    if (r)
      return r;
    n = hc(n);
  }
}
function bE(e) {
  e.modified_ || (e.modified_ = !0, e.parent_ && bE(e.parent_));
}
function N0(e) {
  e.copy_ || (e.copy_ = mE(
    e.base_,
    e.scope_.immer_.useStrictShallowCopy_
  ));
}
var Koe = class {
  constructor(e) {
    this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.produce = (t, n, r) => {
      if (typeof t == "function" && typeof n != "function") {
        const i = n;
        n = t;
        const a = this;
        return function(s = i, ...l) {
          return a.produce(s, (u) => n.call(this, u, ...l));
        };
      }
      typeof n != "function" && si(6), r !== void 0 && typeof r != "function" && si(7);
      let o;
      if (Mu(t)) {
        const i = _D(this), a = wE(t, void 0);
        let s = !0;
        try {
          o = n(a), s = !1;
        } finally {
          s ? vE(i) : yE(i);
        }
        return PD(i, r), SD(o, i);
      } else if (!t || typeof t != "object") {
        if (o = n(t), o === void 0 && (o = t), o === X8 && (o = void 0), this.autoFreeze_ && aL(o, !0), r) {
          const i = [], a = [];
          Du("Patches").generateReplacementPatches_(t, o, i, a), r(i, a);
        }
        return o;
      } else
        si(1, t);
    }, this.produceWithPatches = (t, n) => {
      if (typeof t == "function")
        return (i, ...a) => this.produceWithPatches(i, (s) => t(s, ...a));
      let r, o;
      return [this.produce(t, n, (i, a) => {
        r = i, o = a;
      }), r, o];
    }, typeof (e == null ? void 0 : e.autoFreeze) == "boolean" && this.setAutoFreeze(e.autoFreeze), typeof (e == null ? void 0 : e.useStrictShallowCopy) == "boolean" && this.setUseStrictShallowCopy(e.useStrictShallowCopy);
  }
  createDraft(e) {
    Mu(e) || si(8), Su(e) && (e = Yoe(e));
    const t = _D(this), n = wE(e, void 0);
    return n[Wi].isManual_ = !0, yE(t), n;
  }
  finishDraft(e, t) {
    const n = e && e[Wi];
    (!n || !n.isManual_) && si(9);
    const { scope_: r } = n;
    return PD(r, t), SD(void 0, r);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(e) {
    this.autoFreeze_ = e;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(e) {
    this.useStrictShallowCopy_ = e;
  }
  applyPatches(e, t) {
    let n;
    for (n = t.length - 1; n >= 0; n--) {
      const o = t[n];
      if (o.path.length === 0 && o.op === "replace") {
        e = o.value;
        break;
      }
    }
    n > -1 && (t = t.slice(n + 1));
    const r = Du("Patches").applyPatches_;
    return Su(e) ? r(e, t) : this.produce(
      e,
      (o) => r(o, t)
    );
  }
};
function wE(e, t) {
  const n = vb(e) ? Du("MapSet").proxyMap_(e, t) : yb(e) ? Du("MapSet").proxySet_(e, t) : qoe(e, t);
  return (t ? t.scope_ : e5()).drafts_.push(n), n;
}
function Yoe(e) {
  return Su(e) || si(10, e), n5(e);
}
function n5(e) {
  if (!Mu(e) || bb(e))
    return e;
  const t = e[Wi];
  let n;
  if (t) {
    if (!t.modified_)
      return t.base_;
    t.finalized_ = !0, n = mE(e, t.scope_.immer_.useStrictShallowCopy_);
  } else
    n = mE(e, !0);
  return Xm(n, (r, o) => {
    Q8(n, r, n5(o));
  }), t && (t.finalized_ = !1), n;
}
var Vi = new Koe(), uL = Vi.produce;
Vi.produceWithPatches.bind(
  Vi
);
Vi.setAutoFreeze.bind(Vi);
Vi.setUseStrictShallowCopy.bind(Vi);
Vi.applyPatches.bind(Vi);
var DD = Vi.createDraft.bind(Vi), TD = Vi.finishDraft.bind(Vi), Fe = {
  ancestors(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = Fe.levels(e, t);
    return n ? r = r.slice(1) : r = r.slice(0, -1), r;
  },
  common(e, t) {
    for (var n = [], r = 0; r < e.length && r < t.length; r++) {
      var o = e[r], i = t[r];
      if (o !== i)
        break;
      n.push(o);
    }
    return n;
  },
  compare(e, t) {
    for (var n = Math.min(e.length, t.length), r = 0; r < n; r++) {
      if (e[r] < t[r]) return -1;
      if (e[r] > t[r]) return 1;
    }
    return 0;
  },
  endsAfter(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return Fe.equals(r, o) && i > a;
  },
  endsAt(e, t) {
    var n = e.length, r = e.slice(0, n), o = t.slice(0, n);
    return Fe.equals(r, o);
  },
  endsBefore(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return Fe.equals(r, o) && i < a;
  },
  equals(e, t) {
    return e.length === t.length && e.every((n, r) => n === t[r]);
  },
  hasPrevious(e) {
    return e[e.length - 1] > 0;
  },
  isAfter(e, t) {
    return Fe.compare(e, t) === 1;
  },
  isAncestor(e, t) {
    return e.length < t.length && Fe.compare(e, t) === 0;
  },
  isBefore(e, t) {
    return Fe.compare(e, t) === -1;
  },
  isChild(e, t) {
    return e.length === t.length + 1 && Fe.compare(e, t) === 0;
  },
  isCommon(e, t) {
    return e.length <= t.length && Fe.compare(e, t) === 0;
  },
  isDescendant(e, t) {
    return e.length > t.length && Fe.compare(e, t) === 0;
  },
  isParent(e, t) {
    return e.length + 1 === t.length && Fe.compare(e, t) === 0;
  },
  isPath(e) {
    return Array.isArray(e) && (e.length === 0 || typeof e[0] == "number");
  },
  isSibling(e, t) {
    if (e.length !== t.length)
      return !1;
    var n = e.slice(0, -1), r = t.slice(0, -1), o = e[e.length - 1], i = t[t.length - 1];
    return o !== i && Fe.equals(n, r);
  },
  levels(e) {
    for (var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = [], o = 0; o <= e.length; o++)
      r.push(e.slice(0, o));
    return n && r.reverse(), r;
  },
  next(e) {
    if (e.length === 0)
      throw new Error("Cannot get the next path of a root path [".concat(e, "], because it has no next index."));
    var t = e[e.length - 1];
    return e.slice(0, -1).concat(t + 1);
  },
  operationCanTransformPath(e) {
    switch (e.type) {
      case "insert_node":
      case "remove_node":
      case "merge_node":
      case "split_node":
      case "move_node":
        return !0;
      default:
        return !1;
    }
  },
  parent(e) {
    if (e.length === 0)
      throw new Error("Cannot get the parent path of the root path [".concat(e, "]."));
    return e.slice(0, -1);
  },
  previous(e) {
    if (e.length === 0)
      throw new Error("Cannot get the previous path of a root path [".concat(e, "], because it has no previous index."));
    var t = e[e.length - 1];
    if (t <= 0)
      throw new Error("Cannot get the previous path of a first child path [".concat(e, "] because it would result in a negative index."));
    return e.slice(0, -1).concat(t - 1);
  },
  relative(e, t) {
    if (!Fe.isAncestor(t, e) && !Fe.equals(e, t))
      throw new Error("Cannot get the relative path of [".concat(e, "] inside ancestor [").concat(t, "], because it is not above or equal to the path."));
    return e.slice(t.length);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!e) return null;
    var r = [...e], {
      affinity: o = "forward"
    } = n;
    if (e.length === 0)
      return r;
    switch (t.type) {
      case "insert_node": {
        var {
          path: i
        } = t;
        (Fe.equals(i, r) || Fe.endsBefore(i, r) || Fe.isAncestor(i, r)) && (r[i.length - 1] += 1);
        break;
      }
      case "remove_node": {
        var {
          path: a
        } = t;
        if (Fe.equals(a, r) || Fe.isAncestor(a, r))
          return null;
        Fe.endsBefore(a, r) && (r[a.length - 1] -= 1);
        break;
      }
      case "merge_node": {
        var {
          path: s,
          position: l
        } = t;
        Fe.equals(s, r) || Fe.endsBefore(s, r) ? r[s.length - 1] -= 1 : Fe.isAncestor(s, r) && (r[s.length - 1] -= 1, r[s.length] += l);
        break;
      }
      case "split_node": {
        var {
          path: u,
          position: c
        } = t;
        if (Fe.equals(u, r)) {
          if (o === "forward")
            r[r.length - 1] += 1;
          else if (o !== "backward") return null;
        } else Fe.endsBefore(u, r) ? r[u.length - 1] += 1 : Fe.isAncestor(u, r) && e[u.length] >= c && (r[u.length - 1] += 1, r[u.length] -= c);
        break;
      }
      case "move_node": {
        var {
          path: p,
          newPath: d
        } = t;
        if (Fe.equals(p, d))
          return r;
        if (Fe.isAncestor(p, r) || Fe.equals(p, r)) {
          var g = d.slice();
          return Fe.endsBefore(p, d) && p.length < d.length && (g[p.length - 1] -= 1), g.concat(r.slice(p.length));
        } else Fe.isSibling(p, d) && (Fe.isAncestor(d, r) || Fe.equals(d, r)) ? Fe.endsBefore(p, r) ? r[p.length - 1] -= 1 : r[p.length - 1] += 1 : Fe.endsBefore(d, r) || Fe.equals(d, r) || Fe.isAncestor(d, r) ? (Fe.endsBefore(p, r) && (r[p.length - 1] -= 1), r[d.length - 1] += 1) : Fe.endsBefore(p, r) && (Fe.equals(d, r) && (r[d.length - 1] += 1), r[p.length - 1] -= 1);
        break;
      }
    }
    return r;
  }
};
function Sd(e) {
  "@babel/helpers - typeof";
  return Sd = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Sd(e);
}
function Xoe(e, t) {
  if (Sd(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (Sd(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function Joe(e) {
  var t = Xoe(e, "string");
  return Sd(t) === "symbol" ? t : String(t);
}
function Oc(e, t, n) {
  return t = Joe(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function jD(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Gc(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? jD(Object(n), !0).forEach(function(r) {
      Oc(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : jD(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Qoe = (e, t, n) => {
  switch (n.type) {
    case "insert_node": {
      var {
        path: r,
        node: o
      } = n, i = kt.parent(e, r), a = r[r.length - 1];
      if (a > i.children.length)
        throw new Error('Cannot apply an "insert_node" operation at path ['.concat(r, "] because the destination is past the end of the node."));
      if (i.children.splice(a, 0, o), t)
        for (var [s, l] of zt.points(t))
          t[l] = hr.transform(s, n);
      break;
    }
    case "insert_text": {
      var {
        path: u,
        offset: c,
        text: p
      } = n;
      if (p.length === 0) break;
      var d = kt.leaf(e, u), g = d.text.slice(0, c), f = d.text.slice(c);
      if (d.text = g + p + f, t)
        for (var [m, v] of zt.points(t))
          t[v] = hr.transform(m, n);
      break;
    }
    case "merge_node": {
      var {
        path: E
      } = n, w = kt.get(e, E), M = Fe.previous(E), O = kt.get(e, M), y = kt.parent(e, E), C = E[E.length - 1];
      if (ro.isText(w) && ro.isText(O))
        O.text += w.text;
      else if (!ro.isText(w) && !ro.isText(O))
        O.children.push(...w.children);
      else
        throw new Error('Cannot apply a "merge_node" operation at path ['.concat(E, "] to nodes of different interfaces: ").concat(_i.stringify(w), " ").concat(_i.stringify(O)));
      if (y.children.splice(C, 1), t)
        for (var [_, F] of zt.points(t))
          t[F] = hr.transform(_, n);
      break;
    }
    case "move_node": {
      var {
        path: L,
        newPath: N
      } = n;
      if (Fe.isAncestor(L, N))
        throw new Error("Cannot move a path [".concat(L, "] to new path [").concat(N, "] because the destination is inside itself."));
      var R = kt.get(e, L), W = kt.parent(e, L), V = L[L.length - 1];
      W.children.splice(V, 1);
      var z = Fe.transform(L, n), Z = kt.get(e, Fe.parent(z)), K = z[z.length - 1];
      if (Z.children.splice(K, 0, R), t)
        for (var [X, te] of zt.points(t))
          t[te] = hr.transform(X, n);
      break;
    }
    case "remove_node": {
      var {
        path: J
      } = n, P = J[J.length - 1], D = kt.parent(e, J);
      if (D.children.splice(P, 1), t)
        for (var [H, S] of zt.points(t)) {
          var $ = hr.transform(H, n);
          if (t != null && $ != null)
            t[S] = $;
          else {
            var x = void 0, j = void 0;
            for (var [U, T] of kt.texts(e))
              if (Fe.compare(T, J) === -1)
                x = [U, T];
              else {
                j = [U, T];
                break;
              }
            var q = !1;
            x && j && (Fe.equals(j[1], J) ? q = !Fe.hasPrevious(j[1]) : q = Fe.common(x[1], J).length < Fe.common(j[1], J).length), x && !q ? (H.path = x[1], H.offset = x[0].text.length) : j ? (H.path = j[1], H.offset = 0) : t = null;
          }
        }
      break;
    }
    case "remove_text": {
      var {
        path: A,
        offset: Y,
        text: B
      } = n;
      if (B.length === 0) break;
      var ue = kt.leaf(e, A), fe = ue.text.slice(0, Y), oe = ue.text.slice(Y + B.length);
      if (ue.text = fe + oe, t)
        for (var [Ae, Ze] of zt.points(t))
          t[Ze] = hr.transform(Ae, n);
      break;
    }
    case "set_node": {
      var {
        path: Ge,
        properties: Ie,
        newProperties: et
      } = n;
      if (Ge.length === 0)
        throw new Error("Cannot set properties on the root node!");
      var Ye = kt.get(e, Ge);
      for (var _e in et) {
        if (_e === "children" || _e === "text")
          throw new Error('Cannot set the "'.concat(_e, '" property of nodes!'));
        var Qe = et[_e];
        Qe == null ? delete Ye[_e] : Ye[_e] = Qe;
      }
      for (var at in Ie)
        et.hasOwnProperty(at) || delete Ye[at];
      break;
    }
    case "set_selection": {
      var {
        newProperties: Pe
      } = n;
      if (Pe == null)
        t = Pe;
      else {
        if (t == null) {
          if (!zt.isRange(Pe))
            throw new Error('Cannot apply an incomplete "set_selection" operation properties '.concat(_i.stringify(Pe), " when there is no current selection."));
          t = Gc({}, Pe);
        }
        for (var Me in Pe) {
          var Je = Pe[Me];
          if (Je == null) {
            if (Me === "anchor" || Me === "focus")
              throw new Error('Cannot remove the "'.concat(Me, '" selection property'));
            delete t[Me];
          } else
            t[Me] = Je;
        }
      }
      break;
    }
    case "split_node": {
      var {
        path: We,
        position: Re,
        properties: nt
      } = n;
      if (We.length === 0)
        throw new Error('Cannot apply a "split_node" operation at path ['.concat(We, "] because the root node cannot be split."));
      var De = kt.get(e, We), yt = kt.parent(e, We), ot = We[We.length - 1], st;
      if (ro.isText(De)) {
        var ct = De.text.slice(0, Re), bt = De.text.slice(Re);
        De.text = ct, st = Gc(Gc({}, nt), {}, {
          text: bt
        });
      } else {
        var pt = De.children.slice(0, Re), dt = De.children.slice(Re);
        De.children = pt, st = Gc(Gc({}, nt), {}, {
          children: dt
        });
      }
      if (yt.children.splice(ot + 1, 0, st), t)
        for (var [tt, Xe] of zt.points(t))
          t[Xe] = hr.transform(tt, n);
      break;
    }
  }
  return t;
}, eie = {
  transform(e, t) {
    e.children = DD(e.children);
    var n = e.selection && DD(e.selection);
    try {
      n = Qoe(e, n, t);
    } finally {
      e.children = TD(e.children), n ? e.selection = Su(n) ? TD(n) : n : e.selection = null;
    }
  }
}, tie = {
  insertNodes(e, t, n) {
    e.insertNodes(t, n);
  },
  liftNodes(e, t) {
    e.liftNodes(t);
  },
  mergeNodes(e, t) {
    e.mergeNodes(t);
  },
  moveNodes(e, t) {
    e.moveNodes(t);
  },
  removeNodes(e, t) {
    e.removeNodes(t);
  },
  setNodes(e, t, n) {
    e.setNodes(t, n);
  },
  splitNodes(e, t) {
    e.splitNodes(t);
  },
  unsetNodes(e, t, n) {
    e.unsetNodes(t, n);
  },
  unwrapNodes(e, t) {
    e.unwrapNodes(t);
  },
  wrapNodes(e, t, n) {
    e.wrapNodes(t, n);
  }
}, nie = {
  collapse(e, t) {
    e.collapse(t);
  },
  deselect(e) {
    e.deselect();
  },
  move(e, t) {
    e.move(t);
  },
  select(e, t) {
    e.select(t);
  },
  setPoint(e, t, n) {
    e.setPoint(t, n);
  },
  setSelection(e, t) {
    e.setSelection(t);
  }
}, r5 = (e, t) => {
  for (var n in e) {
    var r = e[n], o = t[n];
    if (zo(r) && zo(o)) {
      if (!r5(r, o)) return !1;
    } else if (Array.isArray(r) && Array.isArray(o)) {
      if (r.length !== o.length) return !1;
      for (var i = 0; i < r.length; i++)
        if (r[i] !== o[i]) return !1;
    } else if (r !== o)
      return !1;
  }
  for (var a in t)
    if (e[a] === void 0 && t[a] !== void 0)
      return !1;
  return !0;
};
function rie(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), o, i;
  for (i = 0; i < r.length; i++)
    o = r[i], !(t.indexOf(o) >= 0) && (n[o] = e[o]);
  return n;
}
function Md(e, t) {
  if (e == null) return {};
  var n = rie(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (o = 0; o < i.length; o++)
      r = i[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
var oie = ["anchor", "focus"];
function AD(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function iie(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? AD(Object(n), !0).forEach(function(r) {
      Oc(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : AD(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var zt = {
  edges(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, {
      anchor: r,
      focus: o
    } = e;
    return zt.isBackward(e) === n ? [r, o] : [o, r];
  },
  end(e) {
    var [, t] = zt.edges(e);
    return t;
  },
  equals(e, t) {
    return hr.equals(e.anchor, t.anchor) && hr.equals(e.focus, t.focus);
  },
  includes(e, t) {
    if (zt.isRange(t)) {
      if (zt.includes(e, t.anchor) || zt.includes(e, t.focus))
        return !0;
      var [n, r] = zt.edges(e), [o, i] = zt.edges(t);
      return hr.isBefore(n, o) && hr.isAfter(r, i);
    }
    var [a, s] = zt.edges(e), l = !1, u = !1;
    return hr.isPoint(t) ? (l = hr.compare(t, a) >= 0, u = hr.compare(t, s) <= 0) : (l = Fe.compare(t, a.path) >= 0, u = Fe.compare(t, s.path) <= 0), l && u;
  },
  intersection(e, t) {
    var n = Md(e, oie), [r, o] = zt.edges(e), [i, a] = zt.edges(t), s = hr.isBefore(r, i) ? i : r, l = hr.isBefore(o, a) ? o : a;
    return hr.isBefore(l, s) ? null : iie({
      anchor: s,
      focus: l
    }, n);
  },
  isBackward(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return hr.isAfter(t, n);
  },
  isCollapsed(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return hr.equals(t, n);
  },
  isExpanded(e) {
    return !zt.isCollapsed(e);
  },
  isForward(e) {
    return !zt.isBackward(e);
  },
  isRange(e) {
    return zo(e) && hr.isPoint(e.anchor) && hr.isPoint(e.focus);
  },
  *points(e) {
    yield [e.anchor, "anchor"], yield [e.focus, "focus"];
  },
  start(e) {
    var [t] = zt.edges(e);
    return t;
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return uL(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "inward"
      } = n, i, a;
      if (o === "inward") {
        var s = zt.isCollapsed(r);
        zt.isForward(r) ? (i = "forward", a = s ? i : "backward") : (i = "backward", a = s ? i : "forward");
      } else o === "outward" ? zt.isForward(r) ? (i = "backward", a = "forward") : (i = "forward", a = "backward") : (i = o, a = o);
      var l = hr.transform(r.anchor, t, {
        affinity: i
      }), u = hr.transform(r.focus, t, {
        affinity: a
      });
      if (!l || !u)
        return null;
      r.anchor = l, r.focus = u;
    });
  }
}, ID = (e) => zo(e) && kt.isNodeList(e.children) && !Zn.isEditor(e), ta = {
  isAncestor(e) {
    return zo(e) && kt.isNodeList(e.children);
  },
  isElement: ID,
  isElementList(e) {
    return Array.isArray(e) && e.every((t) => ta.isElement(t));
  },
  isElementProps(e) {
    return e.children !== void 0;
  },
  isElementType: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "type";
    return ID(e) && e[n] === t;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "children" && e[n] !== t[n])
        return !1;
    return !0;
  }
}, sie = ["children"], aie = ["text"], RD = /* @__PURE__ */ new WeakMap(), kt = {
  ancestor(e, t) {
    var n = kt.get(e, t);
    if (ro.isText(n))
      throw new Error("Cannot get the ancestor node at path [".concat(t, "] because it refers to a text node instead: ").concat(_i.stringify(n)));
    return n;
  },
  ancestors(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of Fe.ancestors(t, n)) {
        var o = kt.ancestor(e, r), i = [o, r];
        yield i;
      }
    }();
  },
  child(e, t) {
    if (ro.isText(e))
      throw new Error("Cannot get the child of a text node: ".concat(_i.stringify(e)));
    var n = e.children[t];
    if (n == null)
      throw new Error("Cannot get child at index `".concat(t, "` in node: ").concat(_i.stringify(e)));
    return n;
  },
  children(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var {
        reverse: r = !1
      } = n, o = kt.ancestor(e, t), {
        children: i
      } = o, a = r ? i.length - 1 : 0; r ? a >= 0 : a < i.length; ) {
        var s = kt.child(o, a), l = t.concat(a);
        yield [s, l], a = r ? a - 1 : a + 1;
      }
    }();
  },
  common(e, t, n) {
    var r = Fe.common(t, n), o = kt.get(e, r);
    return [o, r];
  },
  descendant(e, t) {
    var n = kt.get(e, t);
    if (Zn.isEditor(n))
      throw new Error("Cannot get the descendant node at path [".concat(t, "] because it refers to the root editor node instead: ").concat(_i.stringify(n)));
    return n;
  },
  descendants(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of kt.nodes(e, t))
        r.length !== 0 && (yield [n, r]);
    }();
  },
  elements(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of kt.nodes(e, t))
        ta.isElement(n) && (yield [n, r]);
    }();
  },
  extractProps(e) {
    if (ta.isAncestor(e)) {
      var t = Md(e, sie);
      return t;
    } else {
      var t = Md(e, aie);
      return t;
    }
  },
  first(e, t) {
    for (var n = t.slice(), r = kt.get(e, n); r && !(ro.isText(r) || r.children.length === 0); )
      r = r.children[0], n.push(0);
    return [r, n];
  },
  fragment(e, t) {
    if (ro.isText(e))
      throw new Error("Cannot get a fragment starting from a root text node: ".concat(_i.stringify(e)));
    var n = uL({
      children: e.children
    }, (r) => {
      var [o, i] = zt.edges(t), a = kt.nodes(r, {
        reverse: !0,
        pass: (d) => {
          var [, g] = d;
          return !zt.includes(t, g);
        }
      });
      for (var [, s] of a) {
        if (!zt.includes(t, s)) {
          var l = kt.parent(r, s), u = s[s.length - 1];
          l.children.splice(u, 1);
        }
        if (Fe.equals(s, i.path)) {
          var c = kt.leaf(r, s);
          c.text = c.text.slice(0, i.offset);
        }
        if (Fe.equals(s, o.path)) {
          var p = kt.leaf(r, s);
          p.text = p.text.slice(o.offset);
        }
      }
      Zn.isEditor(r) && (r.selection = null);
    });
    return n.children;
  },
  get(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (ro.isText(n) || !n.children[o])
        throw new Error("Cannot find a descendant at path [".concat(t, "] in node: ").concat(_i.stringify(e)));
      n = n.children[o];
    }
    return n;
  },
  has(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (ro.isText(n) || !n.children[o])
        return !1;
      n = n.children[o];
    }
    return !0;
  },
  isNode(e) {
    return ro.isText(e) || ta.isElement(e) || Zn.isEditor(e);
  },
  isNodeList(e) {
    if (!Array.isArray(e))
      return !1;
    var t = RD.get(e);
    if (t !== void 0)
      return t;
    var n = e.every((r) => kt.isNode(r));
    return RD.set(e, n), n;
  },
  last(e, t) {
    for (var n = t.slice(), r = kt.get(e, n); r && !(ro.isText(r) || r.children.length === 0); ) {
      var o = r.children.length - 1;
      r = r.children[o], n.push(o);
    }
    return [r, n];
  },
  leaf(e, t) {
    var n = kt.get(e, t);
    if (!ro.isText(n))
      throw new Error("Cannot get the leaf node at path [".concat(t, "] because it refers to a non-leaf node: ").concat(_i.stringify(n)));
    return n;
  },
  levels(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of Fe.levels(t, n)) {
        var o = kt.get(e, r);
        yield [o, r];
      }
    }();
  },
  matches(e, t) {
    return ta.isElement(e) && ta.isElementProps(t) && ta.matches(e, t) || ro.isText(e) && ro.isTextProps(t) && ro.matches(e, t);
  },
  nodes(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var {
        pass: n,
        reverse: r = !1
      } = t, {
        from: o = [],
        to: i
      } = t, a = /* @__PURE__ */ new Set(), s = [], l = e; !(i && (r ? Fe.isBefore(s, i) : Fe.isAfter(s, i))); ) {
        if (a.has(l) || (yield [l, s]), !a.has(l) && !ro.isText(l) && l.children.length !== 0 && (n == null || n([l, s]) === !1)) {
          a.add(l);
          var u = r ? l.children.length - 1 : 0;
          Fe.isAncestor(s, o) && (u = o[s.length]), s = s.concat(u), l = kt.get(e, s);
          continue;
        }
        if (s.length === 0)
          break;
        if (!r) {
          var c = Fe.next(s);
          if (kt.has(e, c)) {
            s = c, l = kt.get(e, s);
            continue;
          }
        }
        if (r && s[s.length - 1] !== 0) {
          var p = Fe.previous(s);
          s = p, l = kt.get(e, s);
          continue;
        }
        s = Fe.parent(s), l = kt.get(e, s), a.add(l);
      }
    }();
  },
  parent(e, t) {
    var n = Fe.parent(t), r = kt.get(e, n);
    if (ro.isText(r))
      throw new Error("Cannot get the parent of path [".concat(t, "] because it does not exist in the root."));
    return r;
  },
  string(e) {
    return ro.isText(e) ? e.text : e.children.map(kt.string).join("");
  },
  texts(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of kt.nodes(e, t))
        ro.isText(n) && (yield [n, r]);
    }();
  }
};
function BD(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Cr(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? BD(Object(n), !0).forEach(function(r) {
      Oc(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : BD(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Sp = {
  isNodeOperation(e) {
    return Sp.isOperation(e) && e.type.endsWith("_node");
  },
  isOperation(e) {
    if (!zo(e))
      return !1;
    switch (e.type) {
      case "insert_node":
        return Fe.isPath(e.path) && kt.isNode(e.node);
      case "insert_text":
        return typeof e.offset == "number" && typeof e.text == "string" && Fe.isPath(e.path);
      case "merge_node":
        return typeof e.position == "number" && Fe.isPath(e.path) && zo(e.properties);
      case "move_node":
        return Fe.isPath(e.path) && Fe.isPath(e.newPath);
      case "remove_node":
        return Fe.isPath(e.path) && kt.isNode(e.node);
      case "remove_text":
        return typeof e.offset == "number" && typeof e.text == "string" && Fe.isPath(e.path);
      case "set_node":
        return Fe.isPath(e.path) && zo(e.properties) && zo(e.newProperties);
      case "set_selection":
        return e.properties === null && zt.isRange(e.newProperties) || e.newProperties === null && zt.isRange(e.properties) || zo(e.properties) && zo(e.newProperties);
      case "split_node":
        return Fe.isPath(e.path) && typeof e.position == "number" && zo(e.properties);
      default:
        return !1;
    }
  },
  isOperationList(e) {
    return Array.isArray(e) && e.every((t) => Sp.isOperation(t));
  },
  isSelectionOperation(e) {
    return Sp.isOperation(e) && e.type.endsWith("_selection");
  },
  isTextOperation(e) {
    return Sp.isOperation(e) && e.type.endsWith("_text");
  },
  inverse(e) {
    switch (e.type) {
      case "insert_node":
        return Cr(Cr({}, e), {}, {
          type: "remove_node"
        });
      case "insert_text":
        return Cr(Cr({}, e), {}, {
          type: "remove_text"
        });
      case "merge_node":
        return Cr(Cr({}, e), {}, {
          type: "split_node",
          path: Fe.previous(e.path)
        });
      case "move_node": {
        var {
          newPath: t,
          path: n
        } = e;
        if (Fe.equals(t, n))
          return e;
        if (Fe.isSibling(n, t))
          return Cr(Cr({}, e), {}, {
            path: t,
            newPath: n
          });
        var r = Fe.transform(n, e), o = Fe.transform(Fe.next(n), e);
        return Cr(Cr({}, e), {}, {
          path: r,
          newPath: o
        });
      }
      case "remove_node":
        return Cr(Cr({}, e), {}, {
          type: "insert_node"
        });
      case "remove_text":
        return Cr(Cr({}, e), {}, {
          type: "insert_text"
        });
      case "set_node": {
        var {
          properties: i,
          newProperties: a
        } = e;
        return Cr(Cr({}, e), {}, {
          properties: a,
          newProperties: i
        });
      }
      case "set_selection": {
        var {
          properties: s,
          newProperties: l
        } = e;
        return s == null ? Cr(Cr({}, e), {}, {
          properties: l,
          newProperties: null
        }) : l == null ? Cr(Cr({}, e), {}, {
          properties: null,
          newProperties: s
        }) : Cr(Cr({}, e), {}, {
          properties: l,
          newProperties: s
        });
      }
      case "split_node":
        return Cr(Cr({}, e), {}, {
          type: "merge_node",
          path: Fe.next(e.path)
        });
    }
  }
}, ND = /* @__PURE__ */ new WeakMap(), lie = (e) => {
  var t = ND.get(e);
  if (t !== void 0)
    return t;
  if (!zo(e))
    return !1;
  var n = typeof e.addMark == "function" && typeof e.apply == "function" && typeof e.deleteFragment == "function" && typeof e.insertBreak == "function" && typeof e.insertSoftBreak == "function" && typeof e.insertFragment == "function" && typeof e.insertNode == "function" && typeof e.insertText == "function" && typeof e.isElementReadOnly == "function" && typeof e.isInline == "function" && typeof e.isSelectable == "function" && typeof e.isVoid == "function" && typeof e.normalizeNode == "function" && typeof e.onChange == "function" && typeof e.removeMark == "function" && typeof e.getDirtyPaths == "function" && (e.marks === null || zo(e.marks)) && (e.selection === null || zt.isRange(e.selection)) && kt.isNodeList(e.children) && Sp.isOperationList(e.operations);
  return ND.set(e, n), n;
}, Zn = {
  above(e, t) {
    return e.above(t);
  },
  addMark(e, t, n) {
    e.addMark(t, n);
  },
  after(e, t, n) {
    return e.after(t, n);
  },
  before(e, t, n) {
    return e.before(t, n);
  },
  deleteBackward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteBackward(n);
  },
  deleteForward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteForward(n);
  },
  deleteFragment(e, t) {
    e.deleteFragment(t);
  },
  edges(e, t) {
    return e.edges(t);
  },
  elementReadOnly(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return e.elementReadOnly(t);
  },
  end(e, t) {
    return e.end(t);
  },
  first(e, t) {
    return e.first(t);
  },
  fragment(e, t) {
    return e.fragment(t);
  },
  hasBlocks(e, t) {
    return e.hasBlocks(t);
  },
  hasInlines(e, t) {
    return e.hasInlines(t);
  },
  hasPath(e, t) {
    return e.hasPath(t);
  },
  hasTexts(e, t) {
    return e.hasTexts(t);
  },
  insertBreak(e) {
    e.insertBreak();
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertNode(e, t) {
    e.insertNode(t);
  },
  insertSoftBreak(e) {
    e.insertSoftBreak();
  },
  insertText(e, t) {
    e.insertText(t);
  },
  isBlock(e, t) {
    return e.isBlock(t);
  },
  isEdge(e, t, n) {
    return e.isEdge(t, n);
  },
  isEditor(e) {
    return lie(e);
  },
  isElementReadOnly(e, t) {
    return e.isElementReadOnly(t);
  },
  isEmpty(e, t) {
    return e.isEmpty(t);
  },
  isEnd(e, t, n) {
    return e.isEnd(t, n);
  },
  isInline(e, t) {
    return e.isInline(t);
  },
  isNormalizing(e) {
    return e.isNormalizing();
  },
  isSelectable(e, t) {
    return e.isSelectable(t);
  },
  isStart(e, t, n) {
    return e.isStart(t, n);
  },
  isVoid(e, t) {
    return e.isVoid(t);
  },
  last(e, t) {
    return e.last(t);
  },
  leaf(e, t, n) {
    return e.leaf(t, n);
  },
  levels(e, t) {
    return e.levels(t);
  },
  marks(e) {
    return e.getMarks();
  },
  next(e, t) {
    return e.next(t);
  },
  node(e, t, n) {
    return e.node(t, n);
  },
  nodes(e, t) {
    return e.nodes(t);
  },
  normalize(e, t) {
    e.normalize(t);
  },
  parent(e, t, n) {
    return e.parent(t, n);
  },
  path(e, t, n) {
    return e.path(t, n);
  },
  pathRef(e, t, n) {
    return e.pathRef(t, n);
  },
  pathRefs(e) {
    return e.pathRefs();
  },
  point(e, t, n) {
    return e.point(t, n);
  },
  pointRef(e, t, n) {
    return e.pointRef(t, n);
  },
  pointRefs(e) {
    return e.pointRefs();
  },
  positions(e, t) {
    return e.positions(t);
  },
  previous(e, t) {
    return e.previous(t);
  },
  range(e, t, n) {
    return e.range(t, n);
  },
  rangeRef(e, t, n) {
    return e.rangeRef(t, n);
  },
  rangeRefs(e) {
    return e.rangeRefs();
  },
  removeMark(e, t) {
    e.removeMark(t);
  },
  setNormalizing(e, t) {
    e.setNormalizing(t);
  },
  start(e, t) {
    return e.start(t);
  },
  string(e, t, n) {
    return e.string(t, n);
  },
  unhangRange(e, t, n) {
    return e.unhangRange(t, n);
  },
  void(e, t) {
    return e.void(t);
  },
  withoutNormalizing(e, t) {
    e.withoutNormalizing(t);
  },
  shouldMergeNodesRemovePrevNode: (e, t, n) => e.shouldMergeNodesRemovePrevNode(t, n)
};
function FD(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function zD(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? FD(Object(n), !0).forEach(function(r) {
      Oc(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : FD(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var hr = {
  compare(e, t) {
    var n = Fe.compare(e.path, t.path);
    return n === 0 ? e.offset < t.offset ? -1 : e.offset > t.offset ? 1 : 0 : n;
  },
  isAfter(e, t) {
    return hr.compare(e, t) === 1;
  },
  isBefore(e, t) {
    return hr.compare(e, t) === -1;
  },
  equals(e, t) {
    return e.offset === t.offset && Fe.equals(e.path, t.path);
  },
  isPoint(e) {
    return zo(e) && typeof e.offset == "number" && Fe.isPath(e.path);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return uL(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "forward"
      } = n, {
        path: i,
        offset: a
      } = r;
      switch (t.type) {
        case "insert_node":
        case "move_node": {
          r.path = Fe.transform(i, t, n);
          break;
        }
        case "insert_text": {
          Fe.equals(t.path, i) && (t.offset < a || t.offset === a && o === "forward") && (r.offset += t.text.length);
          break;
        }
        case "merge_node": {
          Fe.equals(t.path, i) && (r.offset += t.position), r.path = Fe.transform(i, t, n);
          break;
        }
        case "remove_text": {
          Fe.equals(t.path, i) && t.offset <= a && (r.offset -= Math.min(a - t.offset, t.text.length));
          break;
        }
        case "remove_node": {
          if (Fe.equals(t.path, i) || Fe.isAncestor(t.path, i))
            return null;
          r.path = Fe.transform(i, t, n);
          break;
        }
        case "split_node": {
          if (Fe.equals(t.path, i)) {
            if (t.position === a && o == null)
              return null;
            (t.position < a || t.position === a && o === "forward") && (r.offset -= t.position, r.path = Fe.transform(i, t, zD(zD({}, n), {}, {
              affinity: "forward"
            })));
          } else
            r.path = Fe.transform(i, t, n);
          break;
        }
      }
    });
  }
}, UD = void 0, _i = {
  setScrubber(e) {
    UD = e;
  },
  stringify(e) {
    return JSON.stringify(e, UD);
  }
}, uie = ["text"], cie = ["anchor", "focus"];
function HD(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Hs(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? HD(Object(n), !0).forEach(function(r) {
      Oc(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : HD(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var ro = {
  equals(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      loose: r = !1
    } = n;
    function o(i) {
      var a = Md(i, uie);
      return a;
    }
    return r5(r ? o(e) : e, r ? o(t) : t);
  },
  isText(e) {
    return zo(e) && typeof e.text == "string";
  },
  isTextList(e) {
    return Array.isArray(e) && e.every((t) => ro.isText(t));
  },
  isTextProps(e) {
    return e.text !== void 0;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "text" && (!e.hasOwnProperty(n) || e[n] !== t[n]))
        return !1;
    return !0;
  },
  decorations(e, t) {
    var n = [Hs({}, e)];
    for (var r of t) {
      var o = Md(r, cie), [i, a] = zt.edges(r), s = [], l = 0, u = i.offset, c = a.offset;
      for (var p of n) {
        var {
          length: d
        } = p.text, g = l;
        if (l += d, u <= g && l <= c) {
          Object.assign(p, o), s.push(p);
          continue;
        }
        if (u !== c && (u === l || c === g) || u > l || c < g || c === g && g !== 0) {
          s.push(p);
          continue;
        }
        var f = p, m = void 0, v = void 0;
        if (c < l) {
          var E = c - g;
          v = Hs(Hs({}, f), {}, {
            text: f.text.slice(E)
          }), f = Hs(Hs({}, f), {}, {
            text: f.text.slice(0, E)
          });
        }
        if (u > g) {
          var w = u - g;
          m = Hs(Hs({}, f), {}, {
            text: f.text.slice(0, w)
          }), f = Hs(Hs({}, f), {}, {
            text: f.text.slice(w)
          });
        }
        Object.assign(f, o), m && s.push(m), s.push(f), v && s.push(v);
      }
      n = s;
    }
    return n;
  }
}, pie = (e) => e.selection ? e.selection : e.children.length > 0 ? Zn.end(e, []) : [0], lr;
(function(e) {
  e[e.None = 0] = "None", e[e.Extend = 1] = "Extend", e[e.ZWJ = 2] = "ZWJ", e[e.RI = 4] = "RI", e[e.Prepend = 8] = "Prepend", e[e.SpacingMark = 16] = "SpacingMark", e[e.L = 32] = "L", e[e.V = 64] = "V", e[e.T = 128] = "T", e[e.LV = 256] = "LV", e[e.LVT = 512] = "LVT", e[e.ExtPict = 1024] = "ExtPict", e[e.Any = 2048] = "Any";
})(lr || (lr = {}));
lr.L, lr.L | lr.V | lr.LV | lr.LVT, lr.LV | lr.V, lr.V | lr.T, lr.LVT | lr.T, lr.T, lr.Any, lr.Extend | lr.ZWJ, lr.Any, lr.SpacingMark, lr.Prepend, lr.Any, lr.ZWJ, lr.ExtPict, lr.RI, lr.RI;
var die = {
  delete(e, t) {
    e.delete(t);
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertText(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Zn.withoutNormalizing(e, () => {
      var {
        voids: r = !1
      } = n, {
        at: o = pie(e)
      } = n;
      if (Fe.isPath(o) && (o = Zn.range(e, o)), zt.isRange(o))
        if (zt.isCollapsed(o))
          o = o.anchor;
        else {
          var i = zt.end(o);
          if (!r && Zn.void(e, {
            at: i
          }))
            return;
          var a = zt.start(o), s = Zn.pointRef(e, a), l = Zn.pointRef(e, i);
          ev.delete(e, {
            at: o,
            voids: r
          });
          var u = s.unref(), c = l.unref();
          o = u || c, ev.setSelection(e, {
            anchor: o,
            focus: o
          });
        }
      if (!(!r && Zn.void(e, {
        at: o
      }) || Zn.elementReadOnly(e, {
        at: o
      }))) {
        var {
          path: p,
          offset: d
        } = o;
        t.length > 0 && e.apply({
          type: "insert_text",
          path: p,
          offset: d,
          text: t
        });
      }
    });
  }
};
function $D(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Lh(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? $D(Object(n), !0).forEach(function(r) {
      Oc(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : $D(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var ev = Lh(Lh(Lh(Lh({}, eie), tie), nie), die), o5 = {}, cL = {}, pL = {}, qu = {}, dL = {}, fL = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Doctype = e.CDATA = e.Tag = e.Style = e.Script = e.Comment = e.Directive = e.Text = e.Root = e.isTag = e.ElementType = void 0;
  var t;
  (function(r) {
    r.Root = "root", r.Text = "text", r.Directive = "directive", r.Comment = "comment", r.Script = "script", r.Style = "style", r.Tag = "tag", r.CDATA = "cdata", r.Doctype = "doctype";
  })(t = e.ElementType || (e.ElementType = {}));
  function n(r) {
    return r.type === t.Tag || r.type === t.Script || r.type === t.Style;
  }
  e.isTag = n, e.Root = t.Root, e.Text = t.Text, e.Directive = t.Directive, e.Comment = t.Comment, e.Script = t.Script, e.Style = t.Style, e.Tag = t.Tag, e.CDATA = t.CDATA, e.Doctype = t.Doctype;
})(fL);
var Gt = {}, ml = Qn && Qn.__extends || /* @__PURE__ */ function() {
  var e = function(t, n) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, o) {
      r.__proto__ = o;
    } || function(r, o) {
      for (var i in o) Object.prototype.hasOwnProperty.call(o, i) && (r[i] = o[i]);
    }, e(t, n);
  };
  return function(t, n) {
    if (typeof n != "function" && n !== null)
      throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
    e(t, n);
    function r() {
      this.constructor = t;
    }
    t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
  };
}(), Wp = Qn && Qn.__assign || function() {
  return Wp = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) {
      t = arguments[n];
      for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
    }
    return e;
  }, Wp.apply(this, arguments);
};
Object.defineProperty(Gt, "__esModule", { value: !0 });
Gt.cloneNode = Gt.hasChildren = Gt.isDocument = Gt.isDirective = Gt.isComment = Gt.isText = Gt.isCDATA = Gt.isTag = Gt.Element = Gt.Document = Gt.CDATA = Gt.NodeWithChildren = Gt.ProcessingInstruction = Gt.Comment = Gt.Text = Gt.DataNode = Gt.Node = void 0;
var fi = fL, hL = (
  /** @class */
  function() {
    function e() {
      this.parent = null, this.prev = null, this.next = null, this.startIndex = null, this.endIndex = null;
    }
    return Object.defineProperty(e.prototype, "parentNode", {
      // Read-write aliases for properties
      /**
       * Same as {@link parent}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.parent;
      },
      set: function(t) {
        this.parent = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "previousSibling", {
      /**
       * Same as {@link prev}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.prev;
      },
      set: function(t) {
        this.prev = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "nextSibling", {
      /**
       * Same as {@link next}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.next;
      },
      set: function(t) {
        this.next = t;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.cloneNode = function(t) {
      return t === void 0 && (t = !1), gL(this, t);
    }, e;
  }()
);
Gt.Node = hL;
var wb = (
  /** @class */
  function(e) {
    ml(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.data = n, r;
    }
    return Object.defineProperty(t.prototype, "nodeValue", {
      /**
       * Same as {@link data}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.data;
      },
      set: function(n) {
        this.data = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(hL)
);
Gt.DataNode = wb;
var i5 = (
  /** @class */
  function(e) {
    ml(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = fi.ElementType.Text, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 3;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(wb)
);
Gt.Text = i5;
var s5 = (
  /** @class */
  function(e) {
    ml(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = fi.ElementType.Comment, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 8;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(wb)
);
Gt.Comment = s5;
var a5 = (
  /** @class */
  function(e) {
    ml(t, e);
    function t(n, r) {
      var o = e.call(this, r) || this;
      return o.name = n, o.type = fi.ElementType.Directive, o;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(wb)
);
Gt.ProcessingInstruction = a5;
var Cb = (
  /** @class */
  function(e) {
    ml(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.children = n, r;
    }
    return Object.defineProperty(t.prototype, "firstChild", {
      // Aliases
      /** First child of the node. */
      get: function() {
        var n;
        return (n = this.children[0]) !== null && n !== void 0 ? n : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "lastChild", {
      /** Last child of the node. */
      get: function() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "childNodes", {
      /**
       * Same as {@link children}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.children;
      },
      set: function(n) {
        this.children = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(hL)
);
Gt.NodeWithChildren = Cb;
var l5 = (
  /** @class */
  function(e) {
    ml(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = fi.ElementType.CDATA, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 4;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Cb)
);
Gt.CDATA = l5;
var u5 = (
  /** @class */
  function(e) {
    ml(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = fi.ElementType.Root, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 9;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Cb)
);
Gt.Document = u5;
var c5 = (
  /** @class */
  function(e) {
    ml(t, e);
    function t(n, r, o, i) {
      o === void 0 && (o = []), i === void 0 && (i = n === "script" ? fi.ElementType.Script : n === "style" ? fi.ElementType.Style : fi.ElementType.Tag);
      var a = e.call(this, o) || this;
      return a.name = n, a.attribs = r, a.type = i, a;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "tagName", {
      // DOM Level 1 aliases
      /**
       * Same as {@link name}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.name;
      },
      set: function(n) {
        this.name = n;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "attributes", {
      get: function() {
        var n = this;
        return Object.keys(this.attribs).map(function(r) {
          var o, i;
          return {
            name: r,
            value: n.attribs[r],
            namespace: (o = n["x-attribsNamespace"]) === null || o === void 0 ? void 0 : o[r],
            prefix: (i = n["x-attribsPrefix"]) === null || i === void 0 ? void 0 : i[r]
          };
        });
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Cb)
);
Gt.Element = c5;
function p5(e) {
  return (0, fi.isTag)(e);
}
Gt.isTag = p5;
function d5(e) {
  return e.type === fi.ElementType.CDATA;
}
Gt.isCDATA = d5;
function f5(e) {
  return e.type === fi.ElementType.Text;
}
Gt.isText = f5;
function h5(e) {
  return e.type === fi.ElementType.Comment;
}
Gt.isComment = h5;
function g5(e) {
  return e.type === fi.ElementType.Directive;
}
Gt.isDirective = g5;
function m5(e) {
  return e.type === fi.ElementType.Root;
}
Gt.isDocument = m5;
function fie(e) {
  return Object.prototype.hasOwnProperty.call(e, "children");
}
Gt.hasChildren = fie;
function gL(e, t) {
  t === void 0 && (t = !1);
  var n;
  if (f5(e))
    n = new i5(e.data);
  else if (h5(e))
    n = new s5(e.data);
  else if (p5(e)) {
    var r = t ? F0(e.children) : [], o = new c5(e.name, Wp({}, e.attribs), r);
    r.forEach(function(l) {
      return l.parent = o;
    }), e.namespace != null && (o.namespace = e.namespace), e["x-attribsNamespace"] && (o["x-attribsNamespace"] = Wp({}, e["x-attribsNamespace"])), e["x-attribsPrefix"] && (o["x-attribsPrefix"] = Wp({}, e["x-attribsPrefix"])), n = o;
  } else if (d5(e)) {
    var r = t ? F0(e.children) : [], i = new l5(r);
    r.forEach(function(u) {
      return u.parent = i;
    }), n = i;
  } else if (m5(e)) {
    var r = t ? F0(e.children) : [], a = new u5(r);
    r.forEach(function(u) {
      return u.parent = a;
    }), e["x-mode"] && (a["x-mode"] = e["x-mode"]), n = a;
  } else if (g5(e)) {
    var s = new a5(e.name, e.data);
    e["x-name"] != null && (s["x-name"] = e["x-name"], s["x-publicId"] = e["x-publicId"], s["x-systemId"] = e["x-systemId"]), n = s;
  } else
    throw new Error("Not implemented yet: ".concat(e.type));
  return n.startIndex = e.startIndex, n.endIndex = e.endIndex, e.sourceCodeLocation != null && (n.sourceCodeLocation = e.sourceCodeLocation), n;
}
Gt.cloneNode = gL;
function F0(e) {
  for (var t = e.map(function(r) {
    return gL(r, !0);
  }), n = 1; n < t.length; n++)
    t[n].prev = t[n - 1], t[n - 1].next = t[n];
  return t;
}
(function(e) {
  var t = Qn && Qn.__createBinding || (Object.create ? function(s, l, u, c) {
    c === void 0 && (c = u);
    var p = Object.getOwnPropertyDescriptor(l, u);
    (!p || ("get" in p ? !l.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
      return l[u];
    } }), Object.defineProperty(s, c, p);
  } : function(s, l, u, c) {
    c === void 0 && (c = u), s[c] = l[u];
  }), n = Qn && Qn.__exportStar || function(s, l) {
    for (var u in s) u !== "default" && !Object.prototype.hasOwnProperty.call(l, u) && t(l, s, u);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.DomHandler = void 0;
  var r = fL, o = Gt;
  n(Gt, e);
  var i = {
    withStartIndices: !1,
    withEndIndices: !1,
    xmlMode: !1
  }, a = (
    /** @class */
    function() {
      function s(l, u, c) {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null, typeof u == "function" && (c = u, u = i), typeof l == "object" && (u = l, l = void 0), this.callback = l ?? null, this.options = u ?? i, this.elementCB = c ?? null;
      }
      return s.prototype.onparserinit = function(l) {
        this.parser = l;
      }, s.prototype.onreset = function() {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null;
      }, s.prototype.onend = function() {
        this.done || (this.done = !0, this.parser = null, this.handleCallback(null));
      }, s.prototype.onerror = function(l) {
        this.handleCallback(l);
      }, s.prototype.onclosetag = function() {
        this.lastNode = null;
        var l = this.tagStack.pop();
        this.options.withEndIndices && (l.endIndex = this.parser.endIndex), this.elementCB && this.elementCB(l);
      }, s.prototype.onopentag = function(l, u) {
        var c = this.options.xmlMode ? r.ElementType.Tag : void 0, p = new o.Element(l, u, void 0, c);
        this.addNode(p), this.tagStack.push(p);
      }, s.prototype.ontext = function(l) {
        var u = this.lastNode;
        if (u && u.type === r.ElementType.Text)
          u.data += l, this.options.withEndIndices && (u.endIndex = this.parser.endIndex);
        else {
          var c = new o.Text(l);
          this.addNode(c), this.lastNode = c;
        }
      }, s.prototype.oncomment = function(l) {
        if (this.lastNode && this.lastNode.type === r.ElementType.Comment) {
          this.lastNode.data += l;
          return;
        }
        var u = new o.Comment(l);
        this.addNode(u), this.lastNode = u;
      }, s.prototype.oncommentend = function() {
        this.lastNode = null;
      }, s.prototype.oncdatastart = function() {
        var l = new o.Text(""), u = new o.CDATA([l]);
        this.addNode(u), l.parent = u, this.lastNode = l;
      }, s.prototype.oncdataend = function() {
        this.lastNode = null;
      }, s.prototype.onprocessinginstruction = function(l, u) {
        var c = new o.ProcessingInstruction(l, u);
        this.addNode(c);
      }, s.prototype.handleCallback = function(l) {
        if (typeof this.callback == "function")
          this.callback(l, this.dom);
        else if (l)
          throw l;
      }, s.prototype.addNode = function(l) {
        var u = this.tagStack[this.tagStack.length - 1], c = u.children[u.children.length - 1];
        this.options.withStartIndices && (l.startIndex = this.parser.startIndex), this.options.withEndIndices && (l.endIndex = this.parser.endIndex), u.children.push(l), c && (l.prev = c, c.next = l), l.parent = u, this.lastNode = null;
      }, s;
    }()
  );
  e.DomHandler = a, e.default = a;
})(dL);
var v5 = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CARRIAGE_RETURN_PLACEHOLDER_REGEX = e.CARRIAGE_RETURN_PLACEHOLDER = e.CARRIAGE_RETURN_REGEX = e.CARRIAGE_RETURN = e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES = void 0, e.CASE_SENSITIVE_TAG_NAMES = [
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "linearGradient",
    "radialGradient",
    "textPath"
  ], e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES.reduce(function(t, n) {
    return t[n.toLowerCase()] = n, t;
  }, {}), e.CARRIAGE_RETURN = "\r", e.CARRIAGE_RETURN_REGEX = new RegExp(e.CARRIAGE_RETURN, "g"), e.CARRIAGE_RETURN_PLACEHOLDER = "__HTML_DOM_PARSER_CARRIAGE_RETURN_PLACEHOLDER_".concat(Date.now(), "__"), e.CARRIAGE_RETURN_PLACEHOLDER_REGEX = new RegExp(e.CARRIAGE_RETURN_PLACEHOLDER, "g");
})(v5);
Object.defineProperty(qu, "__esModule", { value: !0 });
qu.formatAttributes = y5;
qu.escapeSpecialCharacters = mie;
qu.revertEscapedCharacters = b5;
qu.formatDOM = w5;
var Ph = dL, Dd = v5;
function hie(e) {
  return Dd.CASE_SENSITIVE_TAG_NAMES_MAP[e];
}
function y5(e) {
  for (var t = {}, n = 0, r = e.length; n < r; n++) {
    var o = e[n];
    t[o.name] = o.value;
  }
  return t;
}
function gie(e) {
  e = e.toLowerCase();
  var t = hie(e);
  return t || e;
}
function mie(e) {
  return e.replace(Dd.CARRIAGE_RETURN_REGEX, Dd.CARRIAGE_RETURN_PLACEHOLDER);
}
function b5(e) {
  return e.replace(Dd.CARRIAGE_RETURN_PLACEHOLDER_REGEX, Dd.CARRIAGE_RETURN);
}
function w5(e, t, n) {
  t === void 0 && (t = null);
  for (var r = [], o, i = 0, a = e.length; i < a; i++) {
    var s = e[i];
    switch (s.nodeType) {
      case 1: {
        var l = gie(s.nodeName);
        o = new Ph.Element(l, y5(s.attributes)), o.children = w5(
          // template children are on content
          l === "template" ? s.content.childNodes : s.childNodes,
          o
        );
        break;
      }
      case 3:
        o = new Ph.Text(b5(s.nodeValue));
        break;
      case 8:
        o = new Ph.Comment(s.nodeValue);
        break;
      default:
        continue;
    }
    var u = r[i - 1] || null;
    u && (u.next = o), o.parent = t, o.prev = u, o.next = null, r.push(o);
  }
  return n && (o = new Ph.ProcessingInstruction(n.substring(0, n.indexOf(" ")).toLowerCase(), n), o.next = r[0] || null, o.parent = t, r.unshift(o), r[1] && (r[1].prev = r[0])), r;
}
Object.defineProperty(pL, "__esModule", { value: !0 });
pL.default = Cie;
var vie = qu, WD = "html", VD = "head", _h = "body", yie = /<([a-zA-Z]+[0-9]?)/, ZD = /<head[^]*>/i, qD = /<body[^]*>/i, tv = function(e, t) {
  throw new Error("This browser does not support `document.implementation.createHTMLDocument`");
}, CE = function(e, t) {
  throw new Error("This browser does not support `DOMParser.prototype.parseFromString`");
}, GD = typeof window == "object" && window.DOMParser;
if (typeof GD == "function") {
  var bie = new GD(), wie = "text/html";
  CE = function(e, t) {
    return t && (e = "<".concat(t, ">").concat(e, "</").concat(t, ">")), bie.parseFromString(e, wie);
  }, tv = CE;
}
if (typeof document == "object" && document.implementation) {
  var Sh = document.implementation.createHTMLDocument();
  tv = function(e, t) {
    if (t) {
      var n = Sh.documentElement.querySelector(t);
      return n && (n.innerHTML = e), Sh;
    }
    return Sh.documentElement.innerHTML = e, Sh;
  };
}
var Mh = typeof document == "object" && document.createElement("template"), xE;
Mh && Mh.content && (xE = function(e) {
  return Mh.innerHTML = e, Mh.content.childNodes;
});
function Cie(e) {
  var t, n;
  e = (0, vie.escapeSpecialCharacters)(e);
  var r = e.match(yie), o = r && r[1] ? r[1].toLowerCase() : "";
  switch (o) {
    case WD: {
      var i = CE(e);
      if (!ZD.test(e)) {
        var a = i.querySelector(VD);
        (t = a == null ? void 0 : a.parentNode) === null || t === void 0 || t.removeChild(a);
      }
      if (!qD.test(e)) {
        var a = i.querySelector(_h);
        (n = a == null ? void 0 : a.parentNode) === null || n === void 0 || n.removeChild(a);
      }
      return i.querySelectorAll(WD);
    }
    case VD:
    case _h: {
      var s = tv(e).querySelectorAll(o);
      return qD.test(e) && ZD.test(e) ? s[0].parentNode.childNodes : s;
    }
    default: {
      if (xE)
        return xE(e);
      var a = tv(e, _h).querySelector(_h);
      return a.childNodes;
    }
  }
}
var xie = Qn && Qn.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(cL, "__esModule", { value: !0 });
cL.default = Lie;
var Oie = xie(pL), Eie = qu, kie = /<(![a-zA-Z\s]+)>/;
function Lie(e) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e)
    return [];
  var t = e.match(kie), n = t ? t[1] : void 0;
  return (0, Eie.formatDOM)((0, Oie.default)(e), null, n);
}
var xb = {}, ds = {}, Ob = {}, Pie = 0;
Ob.SAME = Pie;
var _ie = 1;
Ob.CAMELCASE = _ie;
Ob.possibleStandardNames = {
  accept: 0,
  acceptCharset: 1,
  "accept-charset": "acceptCharset",
  accessKey: 1,
  action: 0,
  allowFullScreen: 1,
  alt: 0,
  as: 0,
  async: 0,
  autoCapitalize: 1,
  autoComplete: 1,
  autoCorrect: 1,
  autoFocus: 1,
  autoPlay: 1,
  autoSave: 1,
  capture: 0,
  cellPadding: 1,
  cellSpacing: 1,
  challenge: 0,
  charSet: 1,
  checked: 0,
  children: 0,
  cite: 0,
  class: "className",
  classID: 1,
  className: 1,
  cols: 0,
  colSpan: 1,
  content: 0,
  contentEditable: 1,
  contextMenu: 1,
  controls: 0,
  controlsList: 1,
  coords: 0,
  crossOrigin: 1,
  dangerouslySetInnerHTML: 1,
  data: 0,
  dateTime: 1,
  default: 0,
  defaultChecked: 1,
  defaultValue: 1,
  defer: 0,
  dir: 0,
  disabled: 0,
  disablePictureInPicture: 1,
  disableRemotePlayback: 1,
  download: 0,
  draggable: 0,
  encType: 1,
  enterKeyHint: 1,
  for: "htmlFor",
  form: 0,
  formMethod: 1,
  formAction: 1,
  formEncType: 1,
  formNoValidate: 1,
  formTarget: 1,
  frameBorder: 1,
  headers: 0,
  height: 0,
  hidden: 0,
  high: 0,
  href: 0,
  hrefLang: 1,
  htmlFor: 1,
  httpEquiv: 1,
  "http-equiv": "httpEquiv",
  icon: 0,
  id: 0,
  innerHTML: 1,
  inputMode: 1,
  integrity: 0,
  is: 0,
  itemID: 1,
  itemProp: 1,
  itemRef: 1,
  itemScope: 1,
  itemType: 1,
  keyParams: 1,
  keyType: 1,
  kind: 0,
  label: 0,
  lang: 0,
  list: 0,
  loop: 0,
  low: 0,
  manifest: 0,
  marginWidth: 1,
  marginHeight: 1,
  max: 0,
  maxLength: 1,
  media: 0,
  mediaGroup: 1,
  method: 0,
  min: 0,
  minLength: 1,
  multiple: 0,
  muted: 0,
  name: 0,
  noModule: 1,
  nonce: 0,
  noValidate: 1,
  open: 0,
  optimum: 0,
  pattern: 0,
  placeholder: 0,
  playsInline: 1,
  poster: 0,
  preload: 0,
  profile: 0,
  radioGroup: 1,
  readOnly: 1,
  referrerPolicy: 1,
  rel: 0,
  required: 0,
  reversed: 0,
  role: 0,
  rows: 0,
  rowSpan: 1,
  sandbox: 0,
  scope: 0,
  scoped: 0,
  scrolling: 0,
  seamless: 0,
  selected: 0,
  shape: 0,
  size: 0,
  sizes: 0,
  span: 0,
  spellCheck: 1,
  src: 0,
  srcDoc: 1,
  srcLang: 1,
  srcSet: 1,
  start: 0,
  step: 0,
  style: 0,
  summary: 0,
  tabIndex: 1,
  target: 0,
  title: 0,
  type: 0,
  useMap: 1,
  value: 0,
  width: 0,
  wmode: 0,
  wrap: 0,
  about: 0,
  accentHeight: 1,
  "accent-height": "accentHeight",
  accumulate: 0,
  additive: 0,
  alignmentBaseline: 1,
  "alignment-baseline": "alignmentBaseline",
  allowReorder: 1,
  alphabetic: 0,
  amplitude: 0,
  arabicForm: 1,
  "arabic-form": "arabicForm",
  ascent: 0,
  attributeName: 1,
  attributeType: 1,
  autoReverse: 1,
  azimuth: 0,
  baseFrequency: 1,
  baselineShift: 1,
  "baseline-shift": "baselineShift",
  baseProfile: 1,
  bbox: 0,
  begin: 0,
  bias: 0,
  by: 0,
  calcMode: 1,
  capHeight: 1,
  "cap-height": "capHeight",
  clip: 0,
  clipPath: 1,
  "clip-path": "clipPath",
  clipPathUnits: 1,
  clipRule: 1,
  "clip-rule": "clipRule",
  color: 0,
  colorInterpolation: 1,
  "color-interpolation": "colorInterpolation",
  colorInterpolationFilters: 1,
  "color-interpolation-filters": "colorInterpolationFilters",
  colorProfile: 1,
  "color-profile": "colorProfile",
  colorRendering: 1,
  "color-rendering": "colorRendering",
  contentScriptType: 1,
  contentStyleType: 1,
  cursor: 0,
  cx: 0,
  cy: 0,
  d: 0,
  datatype: 0,
  decelerate: 0,
  descent: 0,
  diffuseConstant: 1,
  direction: 0,
  display: 0,
  divisor: 0,
  dominantBaseline: 1,
  "dominant-baseline": "dominantBaseline",
  dur: 0,
  dx: 0,
  dy: 0,
  edgeMode: 1,
  elevation: 0,
  enableBackground: 1,
  "enable-background": "enableBackground",
  end: 0,
  exponent: 0,
  externalResourcesRequired: 1,
  fill: 0,
  fillOpacity: 1,
  "fill-opacity": "fillOpacity",
  fillRule: 1,
  "fill-rule": "fillRule",
  filter: 0,
  filterRes: 1,
  filterUnits: 1,
  floodOpacity: 1,
  "flood-opacity": "floodOpacity",
  floodColor: 1,
  "flood-color": "floodColor",
  focusable: 0,
  fontFamily: 1,
  "font-family": "fontFamily",
  fontSize: 1,
  "font-size": "fontSize",
  fontSizeAdjust: 1,
  "font-size-adjust": "fontSizeAdjust",
  fontStretch: 1,
  "font-stretch": "fontStretch",
  fontStyle: 1,
  "font-style": "fontStyle",
  fontVariant: 1,
  "font-variant": "fontVariant",
  fontWeight: 1,
  "font-weight": "fontWeight",
  format: 0,
  from: 0,
  fx: 0,
  fy: 0,
  g1: 0,
  g2: 0,
  glyphName: 1,
  "glyph-name": "glyphName",
  glyphOrientationHorizontal: 1,
  "glyph-orientation-horizontal": "glyphOrientationHorizontal",
  glyphOrientationVertical: 1,
  "glyph-orientation-vertical": "glyphOrientationVertical",
  glyphRef: 1,
  gradientTransform: 1,
  gradientUnits: 1,
  hanging: 0,
  horizAdvX: 1,
  "horiz-adv-x": "horizAdvX",
  horizOriginX: 1,
  "horiz-origin-x": "horizOriginX",
  ideographic: 0,
  imageRendering: 1,
  "image-rendering": "imageRendering",
  in2: 0,
  in: 0,
  inlist: 0,
  intercept: 0,
  k1: 0,
  k2: 0,
  k3: 0,
  k4: 0,
  k: 0,
  kernelMatrix: 1,
  kernelUnitLength: 1,
  kerning: 0,
  keyPoints: 1,
  keySplines: 1,
  keyTimes: 1,
  lengthAdjust: 1,
  letterSpacing: 1,
  "letter-spacing": "letterSpacing",
  lightingColor: 1,
  "lighting-color": "lightingColor",
  limitingConeAngle: 1,
  local: 0,
  markerEnd: 1,
  "marker-end": "markerEnd",
  markerHeight: 1,
  markerMid: 1,
  "marker-mid": "markerMid",
  markerStart: 1,
  "marker-start": "markerStart",
  markerUnits: 1,
  markerWidth: 1,
  mask: 0,
  maskContentUnits: 1,
  maskUnits: 1,
  mathematical: 0,
  mode: 0,
  numOctaves: 1,
  offset: 0,
  opacity: 0,
  operator: 0,
  order: 0,
  orient: 0,
  orientation: 0,
  origin: 0,
  overflow: 0,
  overlinePosition: 1,
  "overline-position": "overlinePosition",
  overlineThickness: 1,
  "overline-thickness": "overlineThickness",
  paintOrder: 1,
  "paint-order": "paintOrder",
  panose1: 0,
  "panose-1": "panose1",
  pathLength: 1,
  patternContentUnits: 1,
  patternTransform: 1,
  patternUnits: 1,
  pointerEvents: 1,
  "pointer-events": "pointerEvents",
  points: 0,
  pointsAtX: 1,
  pointsAtY: 1,
  pointsAtZ: 1,
  prefix: 0,
  preserveAlpha: 1,
  preserveAspectRatio: 1,
  primitiveUnits: 1,
  property: 0,
  r: 0,
  radius: 0,
  refX: 1,
  refY: 1,
  renderingIntent: 1,
  "rendering-intent": "renderingIntent",
  repeatCount: 1,
  repeatDur: 1,
  requiredExtensions: 1,
  requiredFeatures: 1,
  resource: 0,
  restart: 0,
  result: 0,
  results: 0,
  rotate: 0,
  rx: 0,
  ry: 0,
  scale: 0,
  security: 0,
  seed: 0,
  shapeRendering: 1,
  "shape-rendering": "shapeRendering",
  slope: 0,
  spacing: 0,
  specularConstant: 1,
  specularExponent: 1,
  speed: 0,
  spreadMethod: 1,
  startOffset: 1,
  stdDeviation: 1,
  stemh: 0,
  stemv: 0,
  stitchTiles: 1,
  stopColor: 1,
  "stop-color": "stopColor",
  stopOpacity: 1,
  "stop-opacity": "stopOpacity",
  strikethroughPosition: 1,
  "strikethrough-position": "strikethroughPosition",
  strikethroughThickness: 1,
  "strikethrough-thickness": "strikethroughThickness",
  string: 0,
  stroke: 0,
  strokeDasharray: 1,
  "stroke-dasharray": "strokeDasharray",
  strokeDashoffset: 1,
  "stroke-dashoffset": "strokeDashoffset",
  strokeLinecap: 1,
  "stroke-linecap": "strokeLinecap",
  strokeLinejoin: 1,
  "stroke-linejoin": "strokeLinejoin",
  strokeMiterlimit: 1,
  "stroke-miterlimit": "strokeMiterlimit",
  strokeWidth: 1,
  "stroke-width": "strokeWidth",
  strokeOpacity: 1,
  "stroke-opacity": "strokeOpacity",
  suppressContentEditableWarning: 1,
  suppressHydrationWarning: 1,
  surfaceScale: 1,
  systemLanguage: 1,
  tableValues: 1,
  targetX: 1,
  targetY: 1,
  textAnchor: 1,
  "text-anchor": "textAnchor",
  textDecoration: 1,
  "text-decoration": "textDecoration",
  textLength: 1,
  textRendering: 1,
  "text-rendering": "textRendering",
  to: 0,
  transform: 0,
  typeof: 0,
  u1: 0,
  u2: 0,
  underlinePosition: 1,
  "underline-position": "underlinePosition",
  underlineThickness: 1,
  "underline-thickness": "underlineThickness",
  unicode: 0,
  unicodeBidi: 1,
  "unicode-bidi": "unicodeBidi",
  unicodeRange: 1,
  "unicode-range": "unicodeRange",
  unitsPerEm: 1,
  "units-per-em": "unitsPerEm",
  unselectable: 0,
  vAlphabetic: 1,
  "v-alphabetic": "vAlphabetic",
  values: 0,
  vectorEffect: 1,
  "vector-effect": "vectorEffect",
  version: 0,
  vertAdvY: 1,
  "vert-adv-y": "vertAdvY",
  vertOriginX: 1,
  "vert-origin-x": "vertOriginX",
  vertOriginY: 1,
  "vert-origin-y": "vertOriginY",
  vHanging: 1,
  "v-hanging": "vHanging",
  vIdeographic: 1,
  "v-ideographic": "vIdeographic",
  viewBox: 1,
  viewTarget: 1,
  visibility: 0,
  vMathematical: 1,
  "v-mathematical": "vMathematical",
  vocab: 0,
  widths: 0,
  wordSpacing: 1,
  "word-spacing": "wordSpacing",
  writingMode: 1,
  "writing-mode": "writingMode",
  x1: 0,
  x2: 0,
  x: 0,
  xChannelSelector: 1,
  xHeight: 1,
  "x-height": "xHeight",
  xlinkActuate: 1,
  "xlink:actuate": "xlinkActuate",
  xlinkArcrole: 1,
  "xlink:arcrole": "xlinkArcrole",
  xlinkHref: 1,
  "xlink:href": "xlinkHref",
  xlinkRole: 1,
  "xlink:role": "xlinkRole",
  xlinkShow: 1,
  "xlink:show": "xlinkShow",
  xlinkTitle: 1,
  "xlink:title": "xlinkTitle",
  xlinkType: 1,
  "xlink:type": "xlinkType",
  xmlBase: 1,
  "xml:base": "xmlBase",
  xmlLang: 1,
  "xml:lang": "xmlLang",
  xmlns: 0,
  "xml:space": "xmlSpace",
  xmlnsXlink: 1,
  "xmlns:xlink": "xmlnsXlink",
  xmlSpace: 1,
  y1: 0,
  y2: 0,
  y: 0,
  yChannelSelector: 1,
  z: 0,
  zoomAndPan: 1
};
const C5 = 0, vl = 1, Eb = 2, kb = 3, mL = 4, x5 = 5, O5 = 6;
function Sie(e) {
  return Ao.hasOwnProperty(e) ? Ao[e] : null;
}
function Xo(e, t, n, r, o, i, a) {
  this.acceptsBooleans = t === Eb || t === kb || t === mL, this.attributeName = r, this.attributeNamespace = o, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = i, this.removeEmptyString = a;
}
const Ao = {}, Mie = [
  "children",
  "dangerouslySetInnerHTML",
  // TODO: This prevents the assignment of defaultValue to regular
  // elements (not just inputs). Now that ReactDOMInput assigns to the
  // defaultValue property -- do we need this?
  "defaultValue",
  "defaultChecked",
  "innerHTML",
  "suppressContentEditableWarning",
  "suppressHydrationWarning",
  "style"
];
Mie.forEach((e) => {
  Ao[e] = new Xo(
    e,
    C5,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"]
].forEach(([e, t]) => {
  Ao[e] = new Xo(
    e,
    vl,
    !1,
    // mustUseProperty
    t,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["contentEditable", "draggable", "spellCheck", "value"].forEach((e) => {
  Ao[e] = new Xo(
    e,
    Eb,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha"
].forEach((e) => {
  Ao[e] = new Xo(
    e,
    Eb,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "allowFullScreen",
  "async",
  // Note: there is a special case that prevents it from being written to the DOM
  // on the client side because the browsers are inconsistent. Instead we call focus().
  "autoFocus",
  "autoPlay",
  "controls",
  "default",
  "defer",
  "disabled",
  "disablePictureInPicture",
  "disableRemotePlayback",
  "formNoValidate",
  "hidden",
  "loop",
  "noModule",
  "noValidate",
  "open",
  "playsInline",
  "readOnly",
  "required",
  "reversed",
  "scoped",
  "seamless",
  // Microdata
  "itemScope"
].forEach((e) => {
  Ao[e] = new Xo(
    e,
    kb,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "checked",
  // Note: `option.selected` is not updated if `select.multiple` is
  // disabled with `removeAttribute`. We have special logic for handling this.
  "multiple",
  "muted",
  "selected"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Ao[e] = new Xo(
    e,
    kb,
    !0,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "capture",
  "download"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Ao[e] = new Xo(
    e,
    mL,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "cols",
  "rows",
  "size",
  "span"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Ao[e] = new Xo(
    e,
    O5,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["rowSpan", "start"].forEach((e) => {
  Ao[e] = new Xo(
    e,
    x5,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const vL = /[\-\:]([a-z])/g, yL = (e) => e[1].toUpperCase();
[
  "accent-height",
  "alignment-baseline",
  "arabic-form",
  "baseline-shift",
  "cap-height",
  "clip-path",
  "clip-rule",
  "color-interpolation",
  "color-interpolation-filters",
  "color-profile",
  "color-rendering",
  "dominant-baseline",
  "enable-background",
  "fill-opacity",
  "fill-rule",
  "flood-color",
  "flood-opacity",
  "font-family",
  "font-size",
  "font-size-adjust",
  "font-stretch",
  "font-style",
  "font-variant",
  "font-weight",
  "glyph-name",
  "glyph-orientation-horizontal",
  "glyph-orientation-vertical",
  "horiz-adv-x",
  "horiz-origin-x",
  "image-rendering",
  "letter-spacing",
  "lighting-color",
  "marker-end",
  "marker-mid",
  "marker-start",
  "overline-position",
  "overline-thickness",
  "paint-order",
  "panose-1",
  "pointer-events",
  "rendering-intent",
  "shape-rendering",
  "stop-color",
  "stop-opacity",
  "strikethrough-position",
  "strikethrough-thickness",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "text-anchor",
  "text-decoration",
  "text-rendering",
  "underline-position",
  "underline-thickness",
  "unicode-bidi",
  "unicode-range",
  "units-per-em",
  "v-alphabetic",
  "v-hanging",
  "v-ideographic",
  "v-mathematical",
  "vector-effect",
  "vert-adv-y",
  "vert-origin-x",
  "vert-origin-y",
  "word-spacing",
  "writing-mode",
  "xmlns:xlink",
  "x-height"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(vL, yL);
  Ao[t] = new Xo(
    t,
    vl,
    !1,
    // mustUseProperty
    e,
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xlink:actuate",
  "xlink:arcrole",
  "xlink:role",
  "xlink:show",
  "xlink:title",
  "xlink:type"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(vL, yL);
  Ao[t] = new Xo(
    t,
    vl,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/1999/xlink",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xml:base",
  "xml:lang",
  "xml:space"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(vL, yL);
  Ao[t] = new Xo(
    t,
    vl,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/XML/1998/namespace",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["tabIndex", "crossOrigin"].forEach((e) => {
  Ao[e] = new Xo(
    e,
    vl,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const Die = "xlinkHref";
Ao[Die] = new Xo(
  "xlinkHref",
  vl,
  !1,
  // mustUseProperty
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  // sanitizeURL
  !1
  // removeEmptyString
);
["src", "href", "action", "formAction"].forEach((e) => {
  Ao[e] = new Xo(
    e,
    vl,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !0,
    // sanitizeURL
    !0
    // removeEmptyString
  );
});
const {
  CAMELCASE: Tie,
  SAME: jie,
  possibleStandardNames: KD
} = Ob, Aie = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", Iie = Aie + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", Rie = RegExp.prototype.test.bind(
  // eslint-disable-next-line no-misleading-character-class
  new RegExp("^(data|aria)-[" + Iie + "]*$")
), Bie = Object.keys(
  KD
).reduce((e, t) => {
  const n = KD[t];
  return n === jie ? e[t] = t : n === Tie ? e[t.toLowerCase()] = t : e[t] = n, e;
}, {});
ds.BOOLEAN = kb;
ds.BOOLEANISH_STRING = Eb;
ds.NUMERIC = x5;
ds.OVERLOADED_BOOLEAN = mL;
ds.POSITIVE_NUMERIC = O5;
ds.RESERVED = C5;
ds.STRING = vl;
ds.getPropertyInfo = Sie;
ds.isCustomAttribute = Rie;
ds.possibleStandardNames = Bie;
var bL = {}, wL = {}, YD = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, Nie = /\n/g, Fie = /^\s*/, zie = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, Uie = /^:\s*/, Hie = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, $ie = /^[;\s]*/, Wie = /^\s+|\s+$/g, Vie = `
`, XD = "/", JD = "*", iu = "", Zie = "comment", qie = "declaration", Gie = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e) return [];
  t = t || {};
  var n = 1, r = 1;
  function o(f) {
    var m = f.match(Nie);
    m && (n += m.length);
    var v = f.lastIndexOf(Vie);
    r = ~v ? f.length - v : r + f.length;
  }
  function i() {
    var f = { line: n, column: r };
    return function(m) {
      return m.position = new a(f), u(), m;
    };
  }
  function a(f) {
    this.start = f, this.end = { line: n, column: r }, this.source = t.source;
  }
  a.prototype.content = e;
  function s(f) {
    var m = new Error(
      t.source + ":" + n + ":" + r + ": " + f
    );
    if (m.reason = f, m.filename = t.source, m.line = n, m.column = r, m.source = e, !t.silent) throw m;
  }
  function l(f) {
    var m = f.exec(e);
    if (m) {
      var v = m[0];
      return o(v), e = e.slice(v.length), m;
    }
  }
  function u() {
    l(Fie);
  }
  function c(f) {
    var m;
    for (f = f || []; m = p(); )
      m !== !1 && f.push(m);
    return f;
  }
  function p() {
    var f = i();
    if (!(XD != e.charAt(0) || JD != e.charAt(1))) {
      for (var m = 2; iu != e.charAt(m) && (JD != e.charAt(m) || XD != e.charAt(m + 1)); )
        ++m;
      if (m += 2, iu === e.charAt(m - 1))
        return s("End of comment missing");
      var v = e.slice(2, m - 2);
      return r += 2, o(v), e = e.slice(m), r += 2, f({
        type: Zie,
        comment: v
      });
    }
  }
  function d() {
    var f = i(), m = l(zie);
    if (m) {
      if (p(), !l(Uie)) return s("property missing ':'");
      var v = l(Hie), E = f({
        type: qie,
        property: QD(m[0].replace(YD, iu)),
        value: v ? QD(v[0].replace(YD, iu)) : iu
      });
      return l($ie), E;
    }
  }
  function g() {
    var f = [];
    c(f);
    for (var m; m = d(); )
      m !== !1 && (f.push(m), c(f));
    return f;
  }
  return u(), g();
};
function QD(e) {
  return e ? e.replace(Wie, iu) : iu;
}
var Kie = Qn && Qn.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(wL, "__esModule", { value: !0 });
wL.default = Xie;
var Yie = Kie(Gie);
function Xie(e, t) {
  var n = null;
  if (!e || typeof e != "string")
    return n;
  var r = (0, Yie.default)(e), o = typeof t == "function";
  return r.forEach(function(i) {
    if (i.type === "declaration") {
      var a = i.property, s = i.value;
      o ? t(a, s, i) : s && (n = n || {}, n[a] = s);
    }
  }), n;
}
var Lb = {};
Object.defineProperty(Lb, "__esModule", { value: !0 });
Lb.camelCase = void 0;
var Jie = /^--[a-zA-Z0-9_-]+$/, Qie = /-([a-z])/g, ese = /^[^-]+$/, tse = /^-(webkit|moz|ms|o|khtml)-/, nse = /^-(ms)-/, rse = function(e) {
  return !e || ese.test(e) || Jie.test(e);
}, ose = function(e, t) {
  return t.toUpperCase();
}, eT = function(e, t) {
  return "".concat(t, "-");
}, ise = function(e, t) {
  return t === void 0 && (t = {}), rse(e) ? e : (e = e.toLowerCase(), t.reactCompat ? e = e.replace(nse, eT) : e = e.replace(tse, eT), e.replace(Qie, ose));
};
Lb.camelCase = ise;
var sse = Qn && Qn.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
}, ase = sse(wL), lse = Lb;
function OE(e, t) {
  var n = {};
  return !e || typeof e != "string" || (0, ase.default)(e, function(r, o) {
    r && o && (n[(0, lse.camelCase)(r, t)] = o);
  }), n;
}
OE.default = OE;
var use = OE;
(function(e) {
  var t = Qn && Qn.__importDefault || function(c) {
    return c && c.__esModule ? c : { default: c };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.returnFirstArg = e.canTextBeChildOfNode = e.ELEMENTS_WITH_NO_TEXT_CHILDREN = e.PRESERVE_CUSTOM_ATTRIBUTES = void 0, e.isCustomComponent = i, e.setStyleProp = s;
  var n = we, r = t(use), o = /* @__PURE__ */ new Set([
    "annotation-xml",
    "color-profile",
    "font-face",
    "font-face-src",
    "font-face-uri",
    "font-face-format",
    "font-face-name",
    "missing-glyph"
  ]);
  function i(c, p) {
    return c.includes("-") ? !o.has(c) : !!(p && typeof p.is == "string");
  }
  var a = {
    reactCompat: !0
  };
  function s(c, p) {
    if (typeof c == "string") {
      if (!c.trim()) {
        p.style = {};
        return;
      }
      try {
        p.style = (0, r.default)(c, a);
      } catch {
        p.style = {};
      }
    }
  }
  e.PRESERVE_CUSTOM_ATTRIBUTES = Number(n.version.split(".")[0]) >= 16, e.ELEMENTS_WITH_NO_TEXT_CHILDREN = /* @__PURE__ */ new Set([
    "tr",
    "tbody",
    "thead",
    "tfoot",
    "colgroup",
    "table",
    "head",
    "html",
    "frameset"
  ]);
  var l = function(c) {
    return !e.ELEMENTS_WITH_NO_TEXT_CHILDREN.has(c.name);
  };
  e.canTextBeChildOfNode = l;
  var u = function(c) {
    return c;
  };
  e.returnFirstArg = u;
})(bL);
Object.defineProperty(xb, "__esModule", { value: !0 });
xb.default = fse;
var Mp = ds, tT = bL, cse = ["checked", "value"], pse = ["input", "select", "textarea"], dse = {
  reset: !0,
  submit: !0
};
function fse(e, t) {
  e === void 0 && (e = {});
  var n = {}, r = !!(e.type && dse[e.type]);
  for (var o in e) {
    var i = e[o];
    if ((0, Mp.isCustomAttribute)(o)) {
      n[o] = i;
      continue;
    }
    var a = o.toLowerCase(), s = nT(a);
    if (s) {
      var l = (0, Mp.getPropertyInfo)(s);
      switch (cse.includes(s) && pse.includes(t) && !r && (s = nT("default" + a)), n[s] = i, l && l.type) {
        case Mp.BOOLEAN:
          n[s] = !0;
          break;
        case Mp.OVERLOADED_BOOLEAN:
          i === "" && (n[s] = !0);
          break;
      }
      continue;
    }
    tT.PRESERVE_CUSTOM_ATTRIBUTES && (n[o] = i);
  }
  return (0, tT.setStyleProp)(e.style, n), n;
}
function nT(e) {
  return Mp.possibleStandardNames[e];
}
var CL = {}, hse = Qn && Qn.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(CL, "__esModule", { value: !0 });
CL.default = E5;
var z0 = we, gse = hse(xb), Vp = bL, mse = {
  cloneElement: z0.cloneElement,
  createElement: z0.createElement,
  isValidElement: z0.isValidElement
};
function E5(e, t) {
  t === void 0 && (t = {});
  for (var n = [], r = typeof t.replace == "function", o = t.transform || Vp.returnFirstArg, i = t.library || mse, a = i.cloneElement, s = i.createElement, l = i.isValidElement, u = e.length, c = 0; c < u; c++) {
    var p = e[c];
    if (r) {
      var d = t.replace(p, c);
      if (l(d)) {
        u > 1 && (d = a(d, {
          key: d.key || c
        })), n.push(o(d, p, c));
        continue;
      }
    }
    if (p.type === "text") {
      var g = !p.data.trim().length;
      if (g && p.parent && !(0, Vp.canTextBeChildOfNode)(p.parent) || t.trim && g)
        continue;
      n.push(o(p.data, p, c));
      continue;
    }
    var f = p, m = {};
    vse(f) ? ((0, Vp.setStyleProp)(f.attribs.style, f.attribs), m = f.attribs) : f.attribs && (m = (0, gse.default)(f.attribs, f.name));
    var v = void 0;
    switch (p.type) {
      case "script":
      case "style":
        p.children[0] && (m.dangerouslySetInnerHTML = {
          __html: p.children[0].data
        });
        break;
      case "tag":
        p.name === "textarea" && p.children[0] ? m.defaultValue = p.children[0].data : p.children && p.children.length && (v = E5(p.children, t));
        break;
      default:
        continue;
    }
    u > 1 && (m.key = c), n.push(o(s(p.name, m, v), p, c));
  }
  return n.length === 1 ? n[0] : n;
}
function vse(e) {
  return Vp.PRESERVE_CUSTOM_ATTRIBUTES && e.type === "tag" && (0, Vp.isCustomComponent)(e.name, e.attribs);
}
(function(e) {
  var t = Qn && Qn.__importDefault || function(l) {
    return l && l.__esModule ? l : { default: l };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.htmlToDOM = e.domToReact = e.attributesToProps = e.Text = e.ProcessingInstruction = e.Element = e.Comment = void 0, e.default = s;
  var n = t(cL);
  e.htmlToDOM = n.default;
  var r = t(xb);
  e.attributesToProps = r.default;
  var o = t(CL);
  e.domToReact = o.default;
  var i = dL;
  Object.defineProperty(e, "Comment", { enumerable: !0, get: function() {
    return i.Comment;
  } }), Object.defineProperty(e, "Element", { enumerable: !0, get: function() {
    return i.Element;
  } }), Object.defineProperty(e, "ProcessingInstruction", { enumerable: !0, get: function() {
    return i.ProcessingInstruction;
  } }), Object.defineProperty(e, "Text", { enumerable: !0, get: function() {
    return i.Text;
  } });
  var a = { lowerCaseAttributeNames: !1 };
  function s(l, u) {
    if (typeof l != "string")
      throw new TypeError("First argument must be a string");
    return l ? (0, o.default)((0, n.default)(l, (u == null ? void 0 : u.htmlparser2) || a), u) : [];
  }
})(o5);
const yse = /* @__PURE__ */ Boe(o5);
yse.default;
var er = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function bse(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var EE = { exports: {} }, Kc = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var rT;
function wse() {
  if (rT) return Kc;
  rT = 1;
  var e = we, t = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, o = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, i = { key: !0, ref: !0, __self: !0, __source: !0 };
  function a(s, l, u) {
    var c, p = {}, d = null, g = null;
    u !== void 0 && (d = "" + u), l.key !== void 0 && (d = "" + l.key), l.ref !== void 0 && (g = l.ref);
    for (c in l) r.call(l, c) && !i.hasOwnProperty(c) && (p[c] = l[c]);
    if (s && s.defaultProps) for (c in l = s.defaultProps, l) p[c] === void 0 && (p[c] = l[c]);
    return { $$typeof: t, type: s, key: d, ref: g, props: p, _owner: o.current };
  }
  return Kc.Fragment = n, Kc.jsx = a, Kc.jsxs = a, Kc;
}
var Dh = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var oT;
function Cse() {
  return oT || (oT = 1, process.env.NODE_ENV !== "production" && function() {
    var e = we, t = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), a = Symbol.for("react.provider"), s = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), c = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), d = Symbol.for("react.lazy"), g = Symbol.for("react.offscreen"), f = Symbol.iterator, m = "@@iterator";
    function v(b) {
      if (b === null || typeof b != "object")
        return null;
      var I = f && b[f] || b[m];
      return typeof I == "function" ? I : null;
    }
    var E = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function w(b) {
      {
        for (var I = arguments.length, G = new Array(I > 1 ? I - 1 : 0), ne = 1; ne < I; ne++)
          G[ne - 1] = arguments[ne];
        M("error", b, G);
      }
    }
    function M(b, I, G) {
      {
        var ne = E.ReactDebugCurrentFrame, le = ne.getStackAddendum();
        le !== "" && (I += "%s", G = G.concat([le]));
        var ce = G.map(function(se) {
          return String(se);
        });
        ce.unshift("Warning: " + I), Function.prototype.apply.call(console[b], console, ce);
      }
    }
    var O = !1, y = !1, C = !1, _ = !1, F = !1, L;
    L = Symbol.for("react.module.reference");
    function N(b) {
      return !!(typeof b == "string" || typeof b == "function" || b === r || b === i || F || b === o || b === u || b === c || _ || b === g || O || y || C || typeof b == "object" && b !== null && (b.$$typeof === d || b.$$typeof === p || b.$$typeof === a || b.$$typeof === s || b.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      b.$$typeof === L || b.getModuleId !== void 0));
    }
    function R(b, I, G) {
      var ne = b.displayName;
      if (ne)
        return ne;
      var le = I.displayName || I.name || "";
      return le !== "" ? G + "(" + le + ")" : G;
    }
    function W(b) {
      return b.displayName || "Context";
    }
    function V(b) {
      if (b == null)
        return null;
      if (typeof b.tag == "number" && w("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof b == "function")
        return b.displayName || b.name || null;
      if (typeof b == "string")
        return b;
      switch (b) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case i:
          return "Profiler";
        case o:
          return "StrictMode";
        case u:
          return "Suspense";
        case c:
          return "SuspenseList";
      }
      if (typeof b == "object")
        switch (b.$$typeof) {
          case s:
            var I = b;
            return W(I) + ".Consumer";
          case a:
            var G = b;
            return W(G._context) + ".Provider";
          case l:
            return R(b, b.render, "ForwardRef");
          case p:
            var ne = b.displayName || null;
            return ne !== null ? ne : V(b.type) || "Memo";
          case d: {
            var le = b, ce = le._payload, se = le._init;
            try {
              return V(se(ce));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var z = Object.assign, Z = 0, K, X, te, J, P, D, H;
    function S() {
    }
    S.__reactDisabledLog = !0;
    function $() {
      {
        if (Z === 0) {
          K = console.log, X = console.info, te = console.warn, J = console.error, P = console.group, D = console.groupCollapsed, H = console.groupEnd;
          var b = {
            configurable: !0,
            enumerable: !0,
            value: S,
            writable: !0
          };
          Object.defineProperties(console, {
            info: b,
            log: b,
            warn: b,
            error: b,
            group: b,
            groupCollapsed: b,
            groupEnd: b
          });
        }
        Z++;
      }
    }
    function x() {
      {
        if (Z--, Z === 0) {
          var b = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: z({}, b, {
              value: K
            }),
            info: z({}, b, {
              value: X
            }),
            warn: z({}, b, {
              value: te
            }),
            error: z({}, b, {
              value: J
            }),
            group: z({}, b, {
              value: P
            }),
            groupCollapsed: z({}, b, {
              value: D
            }),
            groupEnd: z({}, b, {
              value: H
            })
          });
        }
        Z < 0 && w("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var j = E.ReactCurrentDispatcher, U;
    function T(b, I, G) {
      {
        if (U === void 0)
          try {
            throw Error();
          } catch (le) {
            var ne = le.stack.trim().match(/\n( *(at )?)/);
            U = ne && ne[1] || "";
          }
        return `
` + U + b;
      }
    }
    var q = !1, A;
    {
      var Y = typeof WeakMap == "function" ? WeakMap : Map;
      A = new Y();
    }
    function B(b, I) {
      if (!b || q)
        return "";
      {
        var G = A.get(b);
        if (G !== void 0)
          return G;
      }
      var ne;
      q = !0;
      var le = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var ce;
      ce = j.current, j.current = null, $();
      try {
        if (I) {
          var se = function() {
            throw Error();
          };
          if (Object.defineProperty(se.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(se, []);
            } catch (je) {
              ne = je;
            }
            Reflect.construct(b, [], se);
          } else {
            try {
              se.call();
            } catch (je) {
              ne = je;
            }
            b.call(se.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (je) {
            ne = je;
          }
          b();
        }
      } catch (je) {
        if (je && ne && typeof je.stack == "string") {
          for (var ie = je.stack.split(`
`), Se = ne.stack.split(`
`), de = ie.length - 1, he = Se.length - 1; de >= 1 && he >= 0 && ie[de] !== Se[he]; )
            he--;
          for (; de >= 1 && he >= 0; de--, he--)
            if (ie[de] !== Se[he]) {
              if (de !== 1 || he !== 1)
                do
                  if (de--, he--, he < 0 || ie[de] !== Se[he]) {
                    var Ve = `
` + ie[de].replace(" at new ", " at ");
                    return b.displayName && Ve.includes("<anonymous>") && (Ve = Ve.replace("<anonymous>", b.displayName)), typeof b == "function" && A.set(b, Ve), Ve;
                  }
                while (de >= 1 && he >= 0);
              break;
            }
        }
      } finally {
        q = !1, j.current = ce, x(), Error.prepareStackTrace = le;
      }
      var xt = b ? b.displayName || b.name : "", vt = xt ? T(xt) : "";
      return typeof b == "function" && A.set(b, vt), vt;
    }
    function ue(b, I, G) {
      return B(b, !1);
    }
    function fe(b) {
      var I = b.prototype;
      return !!(I && I.isReactComponent);
    }
    function oe(b, I, G) {
      if (b == null)
        return "";
      if (typeof b == "function")
        return B(b, fe(b));
      if (typeof b == "string")
        return T(b);
      switch (b) {
        case u:
          return T("Suspense");
        case c:
          return T("SuspenseList");
      }
      if (typeof b == "object")
        switch (b.$$typeof) {
          case l:
            return ue(b.render);
          case p:
            return oe(b.type, I, G);
          case d: {
            var ne = b, le = ne._payload, ce = ne._init;
            try {
              return oe(ce(le), I, G);
            } catch {
            }
          }
        }
      return "";
    }
    var Ae = Object.prototype.hasOwnProperty, Ze = {}, Ge = E.ReactDebugCurrentFrame;
    function Ie(b) {
      if (b) {
        var I = b._owner, G = oe(b.type, b._source, I ? I.type : null);
        Ge.setExtraStackFrame(G);
      } else
        Ge.setExtraStackFrame(null);
    }
    function et(b, I, G, ne, le) {
      {
        var ce = Function.call.bind(Ae);
        for (var se in b)
          if (ce(b, se)) {
            var ie = void 0;
            try {
              if (typeof b[se] != "function") {
                var Se = Error((ne || "React class") + ": " + G + " type `" + se + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof b[se] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw Se.name = "Invariant Violation", Se;
              }
              ie = b[se](I, se, ne, G, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (de) {
              ie = de;
            }
            ie && !(ie instanceof Error) && (Ie(le), w("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", ne || "React class", G, se, typeof ie), Ie(null)), ie instanceof Error && !(ie.message in Ze) && (Ze[ie.message] = !0, Ie(le), w("Failed %s type: %s", G, ie.message), Ie(null));
          }
      }
    }
    var Ye = Array.isArray;
    function _e(b) {
      return Ye(b);
    }
    function Qe(b) {
      {
        var I = typeof Symbol == "function" && Symbol.toStringTag, G = I && b[Symbol.toStringTag] || b.constructor.name || "Object";
        return G;
      }
    }
    function at(b) {
      try {
        return Pe(b), !1;
      } catch {
        return !0;
      }
    }
    function Pe(b) {
      return "" + b;
    }
    function Me(b) {
      if (at(b))
        return w("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Qe(b)), Pe(b);
    }
    var Je = E.ReactCurrentOwner, We = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, Re, nt;
    function De(b) {
      if (Ae.call(b, "ref")) {
        var I = Object.getOwnPropertyDescriptor(b, "ref").get;
        if (I && I.isReactWarning)
          return !1;
      }
      return b.ref !== void 0;
    }
    function yt(b) {
      if (Ae.call(b, "key")) {
        var I = Object.getOwnPropertyDescriptor(b, "key").get;
        if (I && I.isReactWarning)
          return !1;
      }
      return b.key !== void 0;
    }
    function ot(b, I) {
      typeof b.ref == "string" && Je.current;
    }
    function st(b, I) {
      {
        var G = function() {
          Re || (Re = !0, w("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", I));
        };
        G.isReactWarning = !0, Object.defineProperty(b, "key", {
          get: G,
          configurable: !0
        });
      }
    }
    function ct(b, I) {
      {
        var G = function() {
          nt || (nt = !0, w("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", I));
        };
        G.isReactWarning = !0, Object.defineProperty(b, "ref", {
          get: G,
          configurable: !0
        });
      }
    }
    var bt = function(b, I, G, ne, le, ce, se) {
      var ie = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: b,
        key: I,
        ref: G,
        props: se,
        // Record the component responsible for creating this element.
        _owner: ce
      };
      return ie._store = {}, Object.defineProperty(ie._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(ie, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ne
      }), Object.defineProperty(ie, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: le
      }), Object.freeze && (Object.freeze(ie.props), Object.freeze(ie)), ie;
    };
    function pt(b, I, G, ne, le) {
      {
        var ce, se = {}, ie = null, Se = null;
        G !== void 0 && (Me(G), ie = "" + G), yt(I) && (Me(I.key), ie = "" + I.key), De(I) && (Se = I.ref, ot(I));
        for (ce in I)
          Ae.call(I, ce) && !We.hasOwnProperty(ce) && (se[ce] = I[ce]);
        if (b && b.defaultProps) {
          var de = b.defaultProps;
          for (ce in de)
            se[ce] === void 0 && (se[ce] = de[ce]);
        }
        if (ie || Se) {
          var he = typeof b == "function" ? b.displayName || b.name || "Unknown" : b;
          ie && st(se, he), Se && ct(se, he);
        }
        return bt(b, ie, Se, le, ne, Je.current, se);
      }
    }
    var dt = E.ReactCurrentOwner, tt = E.ReactDebugCurrentFrame;
    function Xe(b) {
      if (b) {
        var I = b._owner, G = oe(b.type, b._source, I ? I.type : null);
        tt.setExtraStackFrame(G);
      } else
        tt.setExtraStackFrame(null);
    }
    var wt;
    wt = !1;
    function Ct(b) {
      return typeof b == "object" && b !== null && b.$$typeof === t;
    }
    function ft() {
      {
        if (dt.current) {
          var b = V(dt.current.type);
          if (b)
            return `

Check the render method of \`` + b + "`.";
        }
        return "";
      }
    }
    function bn(b) {
      return "";
    }
    var ht = {};
    function wn(b) {
      {
        var I = ft();
        if (!I) {
          var G = typeof b == "string" ? b : b.displayName || b.name;
          G && (I = `

Check the top-level render call using <` + G + ">.");
        }
        return I;
      }
    }
    function gt(b, I) {
      {
        if (!b._store || b._store.validated || b.key != null)
          return;
        b._store.validated = !0;
        var G = wn(I);
        if (ht[G])
          return;
        ht[G] = !0;
        var ne = "";
        b && b._owner && b._owner !== dt.current && (ne = " It was passed a child from " + V(b._owner.type) + "."), Xe(b), w('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', G, ne), Xe(null);
      }
    }
    function Mt(b, I) {
      {
        if (typeof b != "object")
          return;
        if (_e(b))
          for (var G = 0; G < b.length; G++) {
            var ne = b[G];
            Ct(ne) && gt(ne, I);
          }
        else if (Ct(b))
          b._store && (b._store.validated = !0);
        else if (b) {
          var le = v(b);
          if (typeof le == "function" && le !== b.entries)
            for (var ce = le.call(b), se; !(se = ce.next()).done; )
              Ct(se.value) && gt(se.value, I);
        }
      }
    }
    function ir(b) {
      {
        var I = b.type;
        if (I == null || typeof I == "string")
          return;
        var G;
        if (typeof I == "function")
          G = I.propTypes;
        else if (typeof I == "object" && (I.$$typeof === l || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        I.$$typeof === p))
          G = I.propTypes;
        else
          return;
        if (G) {
          var ne = V(I);
          et(G, b.props, "prop", ne, b);
        } else if (I.PropTypes !== void 0 && !wt) {
          wt = !0;
          var le = V(I);
          w("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", le || "Unknown");
        }
        typeof I.getDefaultProps == "function" && !I.getDefaultProps.isReactClassApproved && w("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function mt(b) {
      {
        for (var I = Object.keys(b.props), G = 0; G < I.length; G++) {
          var ne = I[G];
          if (ne !== "children" && ne !== "key") {
            Xe(b), w("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", ne), Xe(null);
            break;
          }
        }
        b.ref !== null && (Xe(b), w("Invalid attribute `ref` supplied to `React.Fragment`."), Xe(null));
      }
    }
    var re = {};
    function vo(b, I, G, ne, le, ce) {
      {
        var se = N(b);
        if (!se) {
          var ie = "";
          (b === void 0 || typeof b == "object" && b !== null && Object.keys(b).length === 0) && (ie += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var Se = bn();
          Se ? ie += Se : ie += ft();
          var de;
          b === null ? de = "null" : _e(b) ? de = "array" : b !== void 0 && b.$$typeof === t ? (de = "<" + (V(b.type) || "Unknown") + " />", ie = " Did you accidentally export a JSX literal instead of a component?") : de = typeof b, w("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", de, ie);
        }
        var he = pt(b, I, G, le, ce);
        if (he == null)
          return he;
        if (se) {
          var Ve = I.children;
          if (Ve !== void 0)
            if (ne)
              if (_e(Ve)) {
                for (var xt = 0; xt < Ve.length; xt++)
                  Mt(Ve[xt], b);
                Object.freeze && Object.freeze(Ve);
              } else
                w("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Mt(Ve, b);
        }
        if (Ae.call(I, "key")) {
          var vt = V(b), je = Object.keys(I).filter(function(Li) {
            return Li !== "key";
          }), sr = je.length > 0 ? "{key: someKey, " + je.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!re[vt + sr]) {
            var ki = je.length > 0 ? "{" + je.join(": ..., ") + ": ...}" : "{}";
            w(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, sr, vt, ki, vt), re[vt + sr] = !0;
          }
        }
        return b === r ? mt(he) : ir(he), he;
      }
    }
    function Ci(b, I, G) {
      return vo(b, I, G, !0);
    }
    function xi(b, I, G) {
      return vo(b, I, G, !1);
    }
    var Oi = xi, Ei = Ci;
    Dh.Fragment = r, Dh.jsx = Oi, Dh.jsxs = Ei;
  }()), Dh;
}
process.env.NODE_ENV === "production" ? EE.exports = wse() : EE.exports = Cse();
var _o = EE.exports;
Ke({});
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function iT(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function Uo(e) {
  var t, n;
  return iT(e) === !1 ? !1 : (t = e.constructor, t === void 0 ? !0 : (n = t.prototype, !(iT(n) === !1 || n.hasOwnProperty("isPrototypeOf") === !1)));
}
var k5 = Symbol.for("immer-nothing"), sT = Symbol.for("immer-draftable"), Zi = Symbol.for("immer-state"), xse = process.env.NODE_ENV !== "production" ? [
  // All error codes, starting by 0:
  function(e) {
    return `The plugin for '${e}' has not been loaded into Immer. To enable the plugin, import and call \`enable${e}()\` when initializing your application.`;
  },
  function(e) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${e}'`;
  },
  "This object has been frozen and should not be mutated",
  function(e) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + e;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(e) {
    return `'current' expects a draft, got: ${e}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(e) {
    return `'original' expects a draft, got: ${e}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function ai(e, ...t) {
  if (process.env.NODE_ENV !== "production") {
    const n = xse[e], r = typeof n == "function" ? n.apply(null, t) : n;
    throw new Error(`[Immer] ${r}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var gc = Object.getPrototypeOf;
function Tu(e) {
  return !!e && !!e[Zi];
}
function ju(e) {
  var t;
  return e ? L5(e) || Array.isArray(e) || !!e[sT] || !!((t = e.constructor) != null && t[sT]) || _b(e) || Sb(e) : !1;
}
var Ose = Object.prototype.constructor.toString();
function L5(e) {
  if (!e || typeof e != "object")
    return !1;
  const t = gc(e);
  if (t === null)
    return !0;
  const n = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
  return n === Object ? !0 : typeof n == "function" && Function.toString.call(n) === Ose;
}
function nv(e, t) {
  Pb(e) === 0 ? Reflect.ownKeys(e).forEach((n) => {
    t(n, e[n], e);
  }) : e.forEach((n, r) => t(r, n, e));
}
function Pb(e) {
  const t = e[Zi];
  return t ? t.type_ : Array.isArray(e) ? 1 : _b(e) ? 2 : Sb(e) ? 3 : 0;
}
function kE(e, t) {
  return Pb(e) === 2 ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t);
}
function P5(e, t, n) {
  const r = Pb(e);
  r === 2 ? e.set(t, n) : r === 3 ? e.add(n) : e[t] = n;
}
function Ese(e, t) {
  return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && t !== t;
}
function _b(e) {
  return e instanceof Map;
}
function Sb(e) {
  return e instanceof Set;
}
function Jl(e) {
  return e.copy_ || e.base_;
}
function LE(e, t) {
  if (_b(e))
    return new Map(e);
  if (Sb(e))
    return new Set(e);
  if (Array.isArray(e))
    return Array.prototype.slice.call(e);
  const n = L5(e);
  if (t === !0 || t === "class_only" && !n) {
    const r = Object.getOwnPropertyDescriptors(e);
    delete r[Zi];
    let o = Reflect.ownKeys(r);
    for (let i = 0; i < o.length; i++) {
      const a = o[i], s = r[a];
      s.writable === !1 && (s.writable = !0, s.configurable = !0), (s.get || s.set) && (r[a] = {
        configurable: !0,
        writable: !0,
        // could live with !!desc.set as well here...
        enumerable: s.enumerable,
        value: e[a]
      });
    }
    return Object.create(gc(e), r);
  } else {
    const r = gc(e);
    if (r !== null && n)
      return { ...e };
    const o = Object.create(r);
    return Object.assign(o, e);
  }
}
function xL(e, t = !1) {
  return Mb(e) || Tu(e) || !ju(e) || (Pb(e) > 1 && (e.set = e.add = e.clear = e.delete = kse), Object.freeze(e), t && Object.entries(e).forEach(([n, r]) => xL(r, !0))), e;
}
function kse() {
  ai(2);
}
function Mb(e) {
  return Object.isFrozen(e);
}
var Lse = {};
function Au(e) {
  const t = Lse[e];
  return t || ai(0, e), t;
}
var Td;
function _5() {
  return Td;
}
function Pse(e, t) {
  return {
    drafts_: [],
    parent_: e,
    immer_: t,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0
  };
}
function aT(e, t) {
  t && (Au("Patches"), e.patches_ = [], e.inversePatches_ = [], e.patchListener_ = t);
}
function PE(e) {
  _E(e), e.drafts_.forEach(_se), e.drafts_ = null;
}
function _E(e) {
  e === Td && (Td = e.parent_);
}
function lT(e) {
  return Td = Pse(Td, e);
}
function _se(e) {
  const t = e[Zi];
  t.type_ === 0 || t.type_ === 1 ? t.revoke_() : t.revoked_ = !0;
}
function uT(e, t) {
  t.unfinalizedDrafts_ = t.drafts_.length;
  const n = t.drafts_[0];
  return e !== void 0 && e !== n ? (n[Zi].modified_ && (PE(t), ai(4)), ju(e) && (e = rv(t, e), t.parent_ || ov(t, e)), t.patches_ && Au("Patches").generateReplacementPatches_(
    n[Zi].base_,
    e,
    t.patches_,
    t.inversePatches_
  )) : e = rv(t, n, []), PE(t), t.patches_ && t.patchListener_(t.patches_, t.inversePatches_), e !== k5 ? e : void 0;
}
function rv(e, t, n) {
  if (Mb(t))
    return t;
  const r = t[Zi];
  if (!r)
    return nv(
      t,
      (o, i) => cT(e, r, t, o, i, n)
    ), t;
  if (r.scope_ !== e)
    return t;
  if (!r.modified_)
    return ov(e, r.base_, !0), r.base_;
  if (!r.finalized_) {
    r.finalized_ = !0, r.scope_.unfinalizedDrafts_--;
    const o = r.copy_;
    let i = o, a = !1;
    r.type_ === 3 && (i = new Set(o), o.clear(), a = !0), nv(
      i,
      (s, l) => cT(e, r, o, s, l, n, a)
    ), ov(e, o, !1), n && e.patches_ && Au("Patches").generatePatches_(
      r,
      n,
      e.patches_,
      e.inversePatches_
    );
  }
  return r.copy_;
}
function cT(e, t, n, r, o, i, a) {
  if (process.env.NODE_ENV !== "production" && o === n && ai(5), Tu(o)) {
    const s = i && t && t.type_ !== 3 && // Set objects are atomic since they have no keys.
    !kE(t.assigned_, r) ? i.concat(r) : void 0, l = rv(e, o, s);
    if (P5(n, r, l), Tu(l))
      e.canAutoFreeze_ = !1;
    else
      return;
  } else a && n.add(o);
  if (ju(o) && !Mb(o)) {
    if (!e.immer_.autoFreeze_ && e.unfinalizedDrafts_ < 1)
      return;
    rv(e, o), (!t || !t.scope_.parent_) && typeof r != "symbol" && Object.prototype.propertyIsEnumerable.call(n, r) && ov(e, o);
  }
}
function ov(e, t, n = !1) {
  !e.parent_ && e.immer_.autoFreeze_ && e.canAutoFreeze_ && xL(t, n);
}
function Sse(e, t) {
  const n = Array.isArray(e), r = {
    type_: n ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: t ? t.scope_ : _5(),
    // True for both shallow and deep changes.
    modified_: !1,
    // Used during finalization.
    finalized_: !1,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: t,
    // The base state.
    base_: e,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: !1
  };
  let o = r, i = OL;
  n && (o = [r], i = jd);
  const { revoke: a, proxy: s } = Proxy.revocable(o, i);
  return r.draft_ = s, r.revoke_ = a, s;
}
var OL = {
  get(e, t) {
    if (t === Zi)
      return e;
    const n = Jl(e);
    if (!kE(n, t))
      return Mse(e, n, t);
    const r = n[t];
    return e.finalized_ || !ju(r) ? r : r === U0(e.base_, t) ? (H0(e), e.copy_[t] = ME(r, e)) : r;
  },
  has(e, t) {
    return t in Jl(e);
  },
  ownKeys(e) {
    return Reflect.ownKeys(Jl(e));
  },
  set(e, t, n) {
    const r = S5(Jl(e), t);
    if (r != null && r.set)
      return r.set.call(e.draft_, n), !0;
    if (!e.modified_) {
      const o = U0(Jl(e), t), i = o == null ? void 0 : o[Zi];
      if (i && i.base_ === n)
        return e.copy_[t] = n, e.assigned_[t] = !1, !0;
      if (Ese(n, o) && (n !== void 0 || kE(e.base_, t)))
        return !0;
      H0(e), SE(e);
    }
    return e.copy_[t] === n && // special case: handle new props with value 'undefined'
    (n !== void 0 || t in e.copy_) || // special case: NaN
    Number.isNaN(n) && Number.isNaN(e.copy_[t]) || (e.copy_[t] = n, e.assigned_[t] = !0), !0;
  },
  deleteProperty(e, t) {
    return U0(e.base_, t) !== void 0 || t in e.base_ ? (e.assigned_[t] = !1, H0(e), SE(e)) : delete e.assigned_[t], e.copy_ && delete e.copy_[t], !0;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(e, t) {
    const n = Jl(e), r = Reflect.getOwnPropertyDescriptor(n, t);
    return r && {
      writable: !0,
      configurable: e.type_ !== 1 || t !== "length",
      enumerable: r.enumerable,
      value: n[t]
    };
  },
  defineProperty() {
    ai(11);
  },
  getPrototypeOf(e) {
    return gc(e.base_);
  },
  setPrototypeOf() {
    ai(12);
  }
}, jd = {};
nv(OL, (e, t) => {
  jd[e] = function() {
    return arguments[0] = arguments[0][0], t.apply(this, arguments);
  };
});
jd.deleteProperty = function(e, t) {
  return process.env.NODE_ENV !== "production" && isNaN(parseInt(t)) && ai(13), jd.set.call(this, e, t, void 0);
};
jd.set = function(e, t, n) {
  return process.env.NODE_ENV !== "production" && t !== "length" && isNaN(parseInt(t)) && ai(14), OL.set.call(this, e[0], t, n, e[0]);
};
function U0(e, t) {
  const n = e[Zi];
  return (n ? Jl(n) : e)[t];
}
function Mse(e, t, n) {
  var r;
  const o = S5(t, n);
  return o ? "value" in o ? o.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (r = o.get) == null ? void 0 : r.call(e.draft_)
  ) : void 0;
}
function S5(e, t) {
  if (!(t in e))
    return;
  let n = gc(e);
  for (; n; ) {
    const r = Object.getOwnPropertyDescriptor(n, t);
    if (r)
      return r;
    n = gc(n);
  }
}
function SE(e) {
  e.modified_ || (e.modified_ = !0, e.parent_ && SE(e.parent_));
}
function H0(e) {
  e.copy_ || (e.copy_ = LE(
    e.base_,
    e.scope_.immer_.useStrictShallowCopy_
  ));
}
var Dse = class {
  constructor(e) {
    this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.produce = (t, n, r) => {
      if (typeof t == "function" && typeof n != "function") {
        const i = n;
        n = t;
        const a = this;
        return function(s = i, ...l) {
          return a.produce(s, (u) => n.call(this, u, ...l));
        };
      }
      typeof n != "function" && ai(6), r !== void 0 && typeof r != "function" && ai(7);
      let o;
      if (ju(t)) {
        const i = lT(this), a = ME(t, void 0);
        let s = !0;
        try {
          o = n(a), s = !1;
        } finally {
          s ? PE(i) : _E(i);
        }
        return aT(i, r), uT(o, i);
      } else if (!t || typeof t != "object") {
        if (o = n(t), o === void 0 && (o = t), o === k5 && (o = void 0), this.autoFreeze_ && xL(o, !0), r) {
          const i = [], a = [];
          Au("Patches").generateReplacementPatches_(t, o, i, a), r(i, a);
        }
        return o;
      } else
        ai(1, t);
    }, this.produceWithPatches = (t, n) => {
      if (typeof t == "function")
        return (i, ...a) => this.produceWithPatches(i, (s) => t(s, ...a));
      let r, o;
      return [this.produce(t, n, (i, a) => {
        r = i, o = a;
      }), r, o];
    }, typeof (e == null ? void 0 : e.autoFreeze) == "boolean" && this.setAutoFreeze(e.autoFreeze), typeof (e == null ? void 0 : e.useStrictShallowCopy) == "boolean" && this.setUseStrictShallowCopy(e.useStrictShallowCopy);
  }
  createDraft(e) {
    ju(e) || ai(8), Tu(e) && (e = Tse(e));
    const t = lT(this), n = ME(e, void 0);
    return n[Zi].isManual_ = !0, _E(t), n;
  }
  finishDraft(e, t) {
    const n = e && e[Zi];
    (!n || !n.isManual_) && ai(9);
    const { scope_: r } = n;
    return aT(r, t), uT(void 0, r);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(e) {
    this.autoFreeze_ = e;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(e) {
    this.useStrictShallowCopy_ = e;
  }
  applyPatches(e, t) {
    let n;
    for (n = t.length - 1; n >= 0; n--) {
      const o = t[n];
      if (o.path.length === 0 && o.op === "replace") {
        e = o.value;
        break;
      }
    }
    n > -1 && (t = t.slice(n + 1));
    const r = Au("Patches").applyPatches_;
    return Tu(e) ? r(e, t) : this.produce(
      e,
      (o) => r(o, t)
    );
  }
};
function ME(e, t) {
  const n = _b(e) ? Au("MapSet").proxyMap_(e, t) : Sb(e) ? Au("MapSet").proxySet_(e, t) : Sse(e, t);
  return (t ? t.scope_ : _5()).drafts_.push(n), n;
}
function Tse(e) {
  return Tu(e) || ai(10, e), M5(e);
}
function M5(e) {
  if (!ju(e) || Mb(e))
    return e;
  const t = e[Zi];
  let n;
  if (t) {
    if (!t.modified_)
      return t.base_;
    t.finalized_ = !0, n = LE(e, t.scope_.immer_.useStrictShallowCopy_);
  } else
    n = LE(e, !0);
  return nv(n, (r, o) => {
    P5(n, r, M5(o));
  }), t && (t.finalized_ = !1), n;
}
var qi = new Dse(), EL = qi.produce;
qi.produceWithPatches.bind(
  qi
);
qi.setAutoFreeze.bind(qi);
qi.setUseStrictShallowCopy.bind(qi);
qi.applyPatches.bind(qi);
var pT = qi.createDraft.bind(qi), dT = qi.finishDraft.bind(qi), ze = {
  ancestors(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = ze.levels(e, t);
    return n ? r = r.slice(1) : r = r.slice(0, -1), r;
  },
  common(e, t) {
    for (var n = [], r = 0; r < e.length && r < t.length; r++) {
      var o = e[r], i = t[r];
      if (o !== i)
        break;
      n.push(o);
    }
    return n;
  },
  compare(e, t) {
    for (var n = Math.min(e.length, t.length), r = 0; r < n; r++) {
      if (e[r] < t[r]) return -1;
      if (e[r] > t[r]) return 1;
    }
    return 0;
  },
  endsAfter(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return ze.equals(r, o) && i > a;
  },
  endsAt(e, t) {
    var n = e.length, r = e.slice(0, n), o = t.slice(0, n);
    return ze.equals(r, o);
  },
  endsBefore(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return ze.equals(r, o) && i < a;
  },
  equals(e, t) {
    return e.length === t.length && e.every((n, r) => n === t[r]);
  },
  hasPrevious(e) {
    return e[e.length - 1] > 0;
  },
  isAfter(e, t) {
    return ze.compare(e, t) === 1;
  },
  isAncestor(e, t) {
    return e.length < t.length && ze.compare(e, t) === 0;
  },
  isBefore(e, t) {
    return ze.compare(e, t) === -1;
  },
  isChild(e, t) {
    return e.length === t.length + 1 && ze.compare(e, t) === 0;
  },
  isCommon(e, t) {
    return e.length <= t.length && ze.compare(e, t) === 0;
  },
  isDescendant(e, t) {
    return e.length > t.length && ze.compare(e, t) === 0;
  },
  isParent(e, t) {
    return e.length + 1 === t.length && ze.compare(e, t) === 0;
  },
  isPath(e) {
    return Array.isArray(e) && (e.length === 0 || typeof e[0] == "number");
  },
  isSibling(e, t) {
    if (e.length !== t.length)
      return !1;
    var n = e.slice(0, -1), r = t.slice(0, -1), o = e[e.length - 1], i = t[t.length - 1];
    return o !== i && ze.equals(n, r);
  },
  levels(e) {
    for (var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = [], o = 0; o <= e.length; o++)
      r.push(e.slice(0, o));
    return n && r.reverse(), r;
  },
  next(e) {
    if (e.length === 0)
      throw new Error("Cannot get the next path of a root path [".concat(e, "], because it has no next index."));
    var t = e[e.length - 1];
    return e.slice(0, -1).concat(t + 1);
  },
  operationCanTransformPath(e) {
    switch (e.type) {
      case "insert_node":
      case "remove_node":
      case "merge_node":
      case "split_node":
      case "move_node":
        return !0;
      default:
        return !1;
    }
  },
  parent(e) {
    if (e.length === 0)
      throw new Error("Cannot get the parent path of the root path [".concat(e, "]."));
    return e.slice(0, -1);
  },
  previous(e) {
    if (e.length === 0)
      throw new Error("Cannot get the previous path of a root path [".concat(e, "], because it has no previous index."));
    var t = e[e.length - 1];
    if (t <= 0)
      throw new Error("Cannot get the previous path of a first child path [".concat(e, "] because it would result in a negative index."));
    return e.slice(0, -1).concat(t - 1);
  },
  relative(e, t) {
    if (!ze.isAncestor(t, e) && !ze.equals(e, t))
      throw new Error("Cannot get the relative path of [".concat(e, "] inside ancestor [").concat(t, "], because it is not above or equal to the path."));
    return e.slice(t.length);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!e) return null;
    var r = [...e], {
      affinity: o = "forward"
    } = n;
    if (e.length === 0)
      return r;
    switch (t.type) {
      case "insert_node": {
        var {
          path: i
        } = t;
        (ze.equals(i, r) || ze.endsBefore(i, r) || ze.isAncestor(i, r)) && (r[i.length - 1] += 1);
        break;
      }
      case "remove_node": {
        var {
          path: a
        } = t;
        if (ze.equals(a, r) || ze.isAncestor(a, r))
          return null;
        ze.endsBefore(a, r) && (r[a.length - 1] -= 1);
        break;
      }
      case "merge_node": {
        var {
          path: s,
          position: l
        } = t;
        ze.equals(s, r) || ze.endsBefore(s, r) ? r[s.length - 1] -= 1 : ze.isAncestor(s, r) && (r[s.length - 1] -= 1, r[s.length] += l);
        break;
      }
      case "split_node": {
        var {
          path: u,
          position: c
        } = t;
        if (ze.equals(u, r)) {
          if (o === "forward")
            r[r.length - 1] += 1;
          else if (o !== "backward") return null;
        } else ze.endsBefore(u, r) ? r[u.length - 1] += 1 : ze.isAncestor(u, r) && e[u.length] >= c && (r[u.length - 1] += 1, r[u.length] -= c);
        break;
      }
      case "move_node": {
        var {
          path: p,
          newPath: d
        } = t;
        if (ze.equals(p, d))
          return r;
        if (ze.isAncestor(p, r) || ze.equals(p, r)) {
          var g = d.slice();
          return ze.endsBefore(p, d) && p.length < d.length && (g[p.length - 1] -= 1), g.concat(r.slice(p.length));
        } else ze.isSibling(p, d) && (ze.isAncestor(d, r) || ze.equals(d, r)) ? ze.endsBefore(p, r) ? r[p.length - 1] -= 1 : r[p.length - 1] += 1 : ze.endsBefore(d, r) || ze.equals(d, r) || ze.isAncestor(d, r) ? (ze.endsBefore(p, r) && (r[p.length - 1] -= 1), r[d.length - 1] += 1) : ze.endsBefore(p, r) && (ze.equals(d, r) && (r[d.length - 1] += 1), r[p.length - 1] -= 1);
        break;
      }
    }
    return r;
  }
};
function Ad(e) {
  "@babel/helpers - typeof";
  return Ad = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Ad(e);
}
function jse(e, t) {
  if (Ad(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (Ad(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function Ase(e) {
  var t = jse(e, "string");
  return Ad(t) === "symbol" ? t : String(t);
}
function Ec(e, t, n) {
  return t = Ase(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function fT(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Yc(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? fT(Object(n), !0).forEach(function(r) {
      Ec(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : fT(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Ise = (e, t, n) => {
  switch (n.type) {
    case "insert_node": {
      var {
        path: r,
        node: o
      } = n, i = Lt.parent(e, r), a = r[r.length - 1];
      if (a > i.children.length)
        throw new Error('Cannot apply an "insert_node" operation at path ['.concat(r, "] because the destination is past the end of the node."));
      if (i.children.splice(a, 0, o), t)
        for (var [s, l] of Ut.points(t))
          t[l] = gr.transform(s, n);
      break;
    }
    case "insert_text": {
      var {
        path: u,
        offset: c,
        text: p
      } = n;
      if (p.length === 0) break;
      var d = Lt.leaf(e, u), g = d.text.slice(0, c), f = d.text.slice(c);
      if (d.text = g + p + f, t)
        for (var [m, v] of Ut.points(t))
          t[v] = gr.transform(m, n);
      break;
    }
    case "merge_node": {
      var {
        path: E
      } = n, w = Lt.get(e, E), M = ze.previous(E), O = Lt.get(e, M), y = Lt.parent(e, E), C = E[E.length - 1];
      if (oo.isText(w) && oo.isText(O))
        O.text += w.text;
      else if (!oo.isText(w) && !oo.isText(O))
        O.children.push(...w.children);
      else
        throw new Error('Cannot apply a "merge_node" operation at path ['.concat(E, "] to nodes of different interfaces: ").concat(Si.stringify(w), " ").concat(Si.stringify(O)));
      if (y.children.splice(C, 1), t)
        for (var [_, F] of Ut.points(t))
          t[F] = gr.transform(_, n);
      break;
    }
    case "move_node": {
      var {
        path: L,
        newPath: N
      } = n;
      if (ze.isAncestor(L, N))
        throw new Error("Cannot move a path [".concat(L, "] to new path [").concat(N, "] because the destination is inside itself."));
      var R = Lt.get(e, L), W = Lt.parent(e, L), V = L[L.length - 1];
      W.children.splice(V, 1);
      var z = ze.transform(L, n), Z = Lt.get(e, ze.parent(z)), K = z[z.length - 1];
      if (Z.children.splice(K, 0, R), t)
        for (var [X, te] of Ut.points(t))
          t[te] = gr.transform(X, n);
      break;
    }
    case "remove_node": {
      var {
        path: J
      } = n, P = J[J.length - 1], D = Lt.parent(e, J);
      if (D.children.splice(P, 1), t)
        for (var [H, S] of Ut.points(t)) {
          var $ = gr.transform(H, n);
          if (t != null && $ != null)
            t[S] = $;
          else {
            var x = void 0, j = void 0;
            for (var [U, T] of Lt.texts(e))
              if (ze.compare(T, J) === -1)
                x = [U, T];
              else {
                j = [U, T];
                break;
              }
            var q = !1;
            x && j && (ze.equals(j[1], J) ? q = !ze.hasPrevious(j[1]) : q = ze.common(x[1], J).length < ze.common(j[1], J).length), x && !q ? (H.path = x[1], H.offset = x[0].text.length) : j ? (H.path = j[1], H.offset = 0) : t = null;
          }
        }
      break;
    }
    case "remove_text": {
      var {
        path: A,
        offset: Y,
        text: B
      } = n;
      if (B.length === 0) break;
      var ue = Lt.leaf(e, A), fe = ue.text.slice(0, Y), oe = ue.text.slice(Y + B.length);
      if (ue.text = fe + oe, t)
        for (var [Ae, Ze] of Ut.points(t))
          t[Ze] = gr.transform(Ae, n);
      break;
    }
    case "set_node": {
      var {
        path: Ge,
        properties: Ie,
        newProperties: et
      } = n;
      if (Ge.length === 0)
        throw new Error("Cannot set properties on the root node!");
      var Ye = Lt.get(e, Ge);
      for (var _e in et) {
        if (_e === "children" || _e === "text")
          throw new Error('Cannot set the "'.concat(_e, '" property of nodes!'));
        var Qe = et[_e];
        Qe == null ? delete Ye[_e] : Ye[_e] = Qe;
      }
      for (var at in Ie)
        et.hasOwnProperty(at) || delete Ye[at];
      break;
    }
    case "set_selection": {
      var {
        newProperties: Pe
      } = n;
      if (Pe == null)
        t = Pe;
      else {
        if (t == null) {
          if (!Ut.isRange(Pe))
            throw new Error('Cannot apply an incomplete "set_selection" operation properties '.concat(Si.stringify(Pe), " when there is no current selection."));
          t = Yc({}, Pe);
        }
        for (var Me in Pe) {
          var Je = Pe[Me];
          if (Je == null) {
            if (Me === "anchor" || Me === "focus")
              throw new Error('Cannot remove the "'.concat(Me, '" selection property'));
            delete t[Me];
          } else
            t[Me] = Je;
        }
      }
      break;
    }
    case "split_node": {
      var {
        path: We,
        position: Re,
        properties: nt
      } = n;
      if (We.length === 0)
        throw new Error('Cannot apply a "split_node" operation at path ['.concat(We, "] because the root node cannot be split."));
      var De = Lt.get(e, We), yt = Lt.parent(e, We), ot = We[We.length - 1], st;
      if (oo.isText(De)) {
        var ct = De.text.slice(0, Re), bt = De.text.slice(Re);
        De.text = ct, st = Yc(Yc({}, nt), {}, {
          text: bt
        });
      } else {
        var pt = De.children.slice(0, Re), dt = De.children.slice(Re);
        De.children = pt, st = Yc(Yc({}, nt), {}, {
          children: dt
        });
      }
      if (yt.children.splice(ot + 1, 0, st), t)
        for (var [tt, Xe] of Ut.points(t))
          t[Xe] = gr.transform(tt, n);
      break;
    }
  }
  return t;
}, Rse = {
  transform(e, t) {
    e.children = pT(e.children);
    var n = e.selection && pT(e.selection);
    try {
      n = Ise(e, n, t);
    } finally {
      e.children = dT(e.children), n ? e.selection = Tu(n) ? dT(n) : n : e.selection = null;
    }
  }
}, Bse = {
  insertNodes(e, t, n) {
    e.insertNodes(t, n);
  },
  liftNodes(e, t) {
    e.liftNodes(t);
  },
  mergeNodes(e, t) {
    e.mergeNodes(t);
  },
  moveNodes(e, t) {
    e.moveNodes(t);
  },
  removeNodes(e, t) {
    e.removeNodes(t);
  },
  setNodes(e, t, n) {
    e.setNodes(t, n);
  },
  splitNodes(e, t) {
    e.splitNodes(t);
  },
  unsetNodes(e, t, n) {
    e.unsetNodes(t, n);
  },
  unwrapNodes(e, t) {
    e.unwrapNodes(t);
  },
  wrapNodes(e, t, n) {
    e.wrapNodes(t, n);
  }
}, Nse = {
  collapse(e, t) {
    e.collapse(t);
  },
  deselect(e) {
    e.deselect();
  },
  move(e, t) {
    e.move(t);
  },
  select(e, t) {
    e.select(t);
  },
  setPoint(e, t, n) {
    e.setPoint(t, n);
  },
  setSelection(e, t) {
    e.setSelection(t);
  }
}, D5 = (e, t) => {
  for (var n in e) {
    var r = e[n], o = t[n];
    if (Uo(r) && Uo(o)) {
      if (!D5(r, o)) return !1;
    } else if (Array.isArray(r) && Array.isArray(o)) {
      if (r.length !== o.length) return !1;
      for (var i = 0; i < r.length; i++)
        if (r[i] !== o[i]) return !1;
    } else if (r !== o)
      return !1;
  }
  for (var a in t)
    if (e[a] === void 0 && t[a] !== void 0)
      return !1;
  return !0;
};
function Fse(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), o, i;
  for (i = 0; i < r.length; i++)
    o = r[i], !(t.indexOf(o) >= 0) && (n[o] = e[o]);
  return n;
}
function Id(e, t) {
  if (e == null) return {};
  var n = Fse(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (o = 0; o < i.length; o++)
      r = i[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
var zse = ["anchor", "focus"];
function hT(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Use(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? hT(Object(n), !0).forEach(function(r) {
      Ec(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : hT(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Ut = {
  edges(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, {
      anchor: r,
      focus: o
    } = e;
    return Ut.isBackward(e) === n ? [r, o] : [o, r];
  },
  end(e) {
    var [, t] = Ut.edges(e);
    return t;
  },
  equals(e, t) {
    return gr.equals(e.anchor, t.anchor) && gr.equals(e.focus, t.focus);
  },
  includes(e, t) {
    if (Ut.isRange(t)) {
      if (Ut.includes(e, t.anchor) || Ut.includes(e, t.focus))
        return !0;
      var [n, r] = Ut.edges(e), [o, i] = Ut.edges(t);
      return gr.isBefore(n, o) && gr.isAfter(r, i);
    }
    var [a, s] = Ut.edges(e), l = !1, u = !1;
    return gr.isPoint(t) ? (l = gr.compare(t, a) >= 0, u = gr.compare(t, s) <= 0) : (l = ze.compare(t, a.path) >= 0, u = ze.compare(t, s.path) <= 0), l && u;
  },
  intersection(e, t) {
    var n = Id(e, zse), [r, o] = Ut.edges(e), [i, a] = Ut.edges(t), s = gr.isBefore(r, i) ? i : r, l = gr.isBefore(o, a) ? o : a;
    return gr.isBefore(l, s) ? null : Use({
      anchor: s,
      focus: l
    }, n);
  },
  isBackward(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return gr.isAfter(t, n);
  },
  isCollapsed(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return gr.equals(t, n);
  },
  isExpanded(e) {
    return !Ut.isCollapsed(e);
  },
  isForward(e) {
    return !Ut.isBackward(e);
  },
  isRange(e) {
    return Uo(e) && gr.isPoint(e.anchor) && gr.isPoint(e.focus);
  },
  *points(e) {
    yield [e.anchor, "anchor"], yield [e.focus, "focus"];
  },
  start(e) {
    var [t] = Ut.edges(e);
    return t;
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return EL(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "inward"
      } = n, i, a;
      if (o === "inward") {
        var s = Ut.isCollapsed(r);
        Ut.isForward(r) ? (i = "forward", a = s ? i : "backward") : (i = "backward", a = s ? i : "forward");
      } else o === "outward" ? Ut.isForward(r) ? (i = "backward", a = "forward") : (i = "forward", a = "backward") : (i = o, a = o);
      var l = gr.transform(r.anchor, t, {
        affinity: i
      }), u = gr.transform(r.focus, t, {
        affinity: a
      });
      if (!l || !u)
        return null;
      r.anchor = l, r.focus = u;
    });
  }
}, gT = (e) => Uo(e) && Lt.isNodeList(e.children) && !qn.isEditor(e), na = {
  isAncestor(e) {
    return Uo(e) && Lt.isNodeList(e.children);
  },
  isElement: gT,
  isElementList(e) {
    return Array.isArray(e) && e.every((t) => na.isElement(t));
  },
  isElementProps(e) {
    return e.children !== void 0;
  },
  isElementType: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "type";
    return gT(e) && e[n] === t;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "children" && e[n] !== t[n])
        return !1;
    return !0;
  }
}, Hse = ["children"], $se = ["text"], mT = /* @__PURE__ */ new WeakMap(), Lt = {
  ancestor(e, t) {
    var n = Lt.get(e, t);
    if (oo.isText(n))
      throw new Error("Cannot get the ancestor node at path [".concat(t, "] because it refers to a text node instead: ").concat(Si.stringify(n)));
    return n;
  },
  ancestors(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of ze.ancestors(t, n)) {
        var o = Lt.ancestor(e, r), i = [o, r];
        yield i;
      }
    }();
  },
  child(e, t) {
    if (oo.isText(e))
      throw new Error("Cannot get the child of a text node: ".concat(Si.stringify(e)));
    var n = e.children[t];
    if (n == null)
      throw new Error("Cannot get child at index `".concat(t, "` in node: ").concat(Si.stringify(e)));
    return n;
  },
  children(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var {
        reverse: r = !1
      } = n, o = Lt.ancestor(e, t), {
        children: i
      } = o, a = r ? i.length - 1 : 0; r ? a >= 0 : a < i.length; ) {
        var s = Lt.child(o, a), l = t.concat(a);
        yield [s, l], a = r ? a - 1 : a + 1;
      }
    }();
  },
  common(e, t, n) {
    var r = ze.common(t, n), o = Lt.get(e, r);
    return [o, r];
  },
  descendant(e, t) {
    var n = Lt.get(e, t);
    if (qn.isEditor(n))
      throw new Error("Cannot get the descendant node at path [".concat(t, "] because it refers to the root editor node instead: ").concat(Si.stringify(n)));
    return n;
  },
  descendants(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Lt.nodes(e, t))
        r.length !== 0 && (yield [n, r]);
    }();
  },
  elements(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Lt.nodes(e, t))
        na.isElement(n) && (yield [n, r]);
    }();
  },
  extractProps(e) {
    if (na.isAncestor(e)) {
      var t = Id(e, Hse);
      return t;
    } else {
      var t = Id(e, $se);
      return t;
    }
  },
  first(e, t) {
    for (var n = t.slice(), r = Lt.get(e, n); r && !(oo.isText(r) || r.children.length === 0); )
      r = r.children[0], n.push(0);
    return [r, n];
  },
  fragment(e, t) {
    if (oo.isText(e))
      throw new Error("Cannot get a fragment starting from a root text node: ".concat(Si.stringify(e)));
    var n = EL({
      children: e.children
    }, (r) => {
      var [o, i] = Ut.edges(t), a = Lt.nodes(r, {
        reverse: !0,
        pass: (d) => {
          var [, g] = d;
          return !Ut.includes(t, g);
        }
      });
      for (var [, s] of a) {
        if (!Ut.includes(t, s)) {
          var l = Lt.parent(r, s), u = s[s.length - 1];
          l.children.splice(u, 1);
        }
        if (ze.equals(s, i.path)) {
          var c = Lt.leaf(r, s);
          c.text = c.text.slice(0, i.offset);
        }
        if (ze.equals(s, o.path)) {
          var p = Lt.leaf(r, s);
          p.text = p.text.slice(o.offset);
        }
      }
      qn.isEditor(r) && (r.selection = null);
    });
    return n.children;
  },
  get(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (oo.isText(n) || !n.children[o])
        throw new Error("Cannot find a descendant at path [".concat(t, "] in node: ").concat(Si.stringify(e)));
      n = n.children[o];
    }
    return n;
  },
  has(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (oo.isText(n) || !n.children[o])
        return !1;
      n = n.children[o];
    }
    return !0;
  },
  isNode(e) {
    return oo.isText(e) || na.isElement(e) || qn.isEditor(e);
  },
  isNodeList(e) {
    if (!Array.isArray(e))
      return !1;
    var t = mT.get(e);
    if (t !== void 0)
      return t;
    var n = e.every((r) => Lt.isNode(r));
    return mT.set(e, n), n;
  },
  last(e, t) {
    for (var n = t.slice(), r = Lt.get(e, n); r && !(oo.isText(r) || r.children.length === 0); ) {
      var o = r.children.length - 1;
      r = r.children[o], n.push(o);
    }
    return [r, n];
  },
  leaf(e, t) {
    var n = Lt.get(e, t);
    if (!oo.isText(n))
      throw new Error("Cannot get the leaf node at path [".concat(t, "] because it refers to a non-leaf node: ").concat(Si.stringify(n)));
    return n;
  },
  levels(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of ze.levels(t, n)) {
        var o = Lt.get(e, r);
        yield [o, r];
      }
    }();
  },
  matches(e, t) {
    return na.isElement(e) && na.isElementProps(t) && na.matches(e, t) || oo.isText(e) && oo.isTextProps(t) && oo.matches(e, t);
  },
  nodes(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var {
        pass: n,
        reverse: r = !1
      } = t, {
        from: o = [],
        to: i
      } = t, a = /* @__PURE__ */ new Set(), s = [], l = e; !(i && (r ? ze.isBefore(s, i) : ze.isAfter(s, i))); ) {
        if (a.has(l) || (yield [l, s]), !a.has(l) && !oo.isText(l) && l.children.length !== 0 && (n == null || n([l, s]) === !1)) {
          a.add(l);
          var u = r ? l.children.length - 1 : 0;
          ze.isAncestor(s, o) && (u = o[s.length]), s = s.concat(u), l = Lt.get(e, s);
          continue;
        }
        if (s.length === 0)
          break;
        if (!r) {
          var c = ze.next(s);
          if (Lt.has(e, c)) {
            s = c, l = Lt.get(e, s);
            continue;
          }
        }
        if (r && s[s.length - 1] !== 0) {
          var p = ze.previous(s);
          s = p, l = Lt.get(e, s);
          continue;
        }
        s = ze.parent(s), l = Lt.get(e, s), a.add(l);
      }
    }();
  },
  parent(e, t) {
    var n = ze.parent(t), r = Lt.get(e, n);
    if (oo.isText(r))
      throw new Error("Cannot get the parent of path [".concat(t, "] because it does not exist in the root."));
    return r;
  },
  string(e) {
    return oo.isText(e) ? e.text : e.children.map(Lt.string).join("");
  },
  texts(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Lt.nodes(e, t))
        oo.isText(n) && (yield [n, r]);
    }();
  }
};
function vT(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function xr(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? vT(Object(n), !0).forEach(function(r) {
      Ec(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : vT(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Dp = {
  isNodeOperation(e) {
    return Dp.isOperation(e) && e.type.endsWith("_node");
  },
  isOperation(e) {
    if (!Uo(e))
      return !1;
    switch (e.type) {
      case "insert_node":
        return ze.isPath(e.path) && Lt.isNode(e.node);
      case "insert_text":
        return typeof e.offset == "number" && typeof e.text == "string" && ze.isPath(e.path);
      case "merge_node":
        return typeof e.position == "number" && ze.isPath(e.path) && Uo(e.properties);
      case "move_node":
        return ze.isPath(e.path) && ze.isPath(e.newPath);
      case "remove_node":
        return ze.isPath(e.path) && Lt.isNode(e.node);
      case "remove_text":
        return typeof e.offset == "number" && typeof e.text == "string" && ze.isPath(e.path);
      case "set_node":
        return ze.isPath(e.path) && Uo(e.properties) && Uo(e.newProperties);
      case "set_selection":
        return e.properties === null && Ut.isRange(e.newProperties) || e.newProperties === null && Ut.isRange(e.properties) || Uo(e.properties) && Uo(e.newProperties);
      case "split_node":
        return ze.isPath(e.path) && typeof e.position == "number" && Uo(e.properties);
      default:
        return !1;
    }
  },
  isOperationList(e) {
    return Array.isArray(e) && e.every((t) => Dp.isOperation(t));
  },
  isSelectionOperation(e) {
    return Dp.isOperation(e) && e.type.endsWith("_selection");
  },
  isTextOperation(e) {
    return Dp.isOperation(e) && e.type.endsWith("_text");
  },
  inverse(e) {
    switch (e.type) {
      case "insert_node":
        return xr(xr({}, e), {}, {
          type: "remove_node"
        });
      case "insert_text":
        return xr(xr({}, e), {}, {
          type: "remove_text"
        });
      case "merge_node":
        return xr(xr({}, e), {}, {
          type: "split_node",
          path: ze.previous(e.path)
        });
      case "move_node": {
        var {
          newPath: t,
          path: n
        } = e;
        if (ze.equals(t, n))
          return e;
        if (ze.isSibling(n, t))
          return xr(xr({}, e), {}, {
            path: t,
            newPath: n
          });
        var r = ze.transform(n, e), o = ze.transform(ze.next(n), e);
        return xr(xr({}, e), {}, {
          path: r,
          newPath: o
        });
      }
      case "remove_node":
        return xr(xr({}, e), {}, {
          type: "insert_node"
        });
      case "remove_text":
        return xr(xr({}, e), {}, {
          type: "insert_text"
        });
      case "set_node": {
        var {
          properties: i,
          newProperties: a
        } = e;
        return xr(xr({}, e), {}, {
          properties: a,
          newProperties: i
        });
      }
      case "set_selection": {
        var {
          properties: s,
          newProperties: l
        } = e;
        return s == null ? xr(xr({}, e), {}, {
          properties: l,
          newProperties: null
        }) : l == null ? xr(xr({}, e), {}, {
          properties: null,
          newProperties: s
        }) : xr(xr({}, e), {}, {
          properties: l,
          newProperties: s
        });
      }
      case "split_node":
        return xr(xr({}, e), {}, {
          type: "merge_node",
          path: ze.next(e.path)
        });
    }
  }
}, yT = /* @__PURE__ */ new WeakMap(), Wse = (e) => {
  var t = yT.get(e);
  if (t !== void 0)
    return t;
  if (!Uo(e))
    return !1;
  var n = typeof e.addMark == "function" && typeof e.apply == "function" && typeof e.deleteFragment == "function" && typeof e.insertBreak == "function" && typeof e.insertSoftBreak == "function" && typeof e.insertFragment == "function" && typeof e.insertNode == "function" && typeof e.insertText == "function" && typeof e.isElementReadOnly == "function" && typeof e.isInline == "function" && typeof e.isSelectable == "function" && typeof e.isVoid == "function" && typeof e.normalizeNode == "function" && typeof e.onChange == "function" && typeof e.removeMark == "function" && typeof e.getDirtyPaths == "function" && (e.marks === null || Uo(e.marks)) && (e.selection === null || Ut.isRange(e.selection)) && Lt.isNodeList(e.children) && Dp.isOperationList(e.operations);
  return yT.set(e, n), n;
}, qn = {
  above(e, t) {
    return e.above(t);
  },
  addMark(e, t, n) {
    e.addMark(t, n);
  },
  after(e, t, n) {
    return e.after(t, n);
  },
  before(e, t, n) {
    return e.before(t, n);
  },
  deleteBackward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteBackward(n);
  },
  deleteForward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteForward(n);
  },
  deleteFragment(e, t) {
    e.deleteFragment(t);
  },
  edges(e, t) {
    return e.edges(t);
  },
  elementReadOnly(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return e.elementReadOnly(t);
  },
  end(e, t) {
    return e.end(t);
  },
  first(e, t) {
    return e.first(t);
  },
  fragment(e, t) {
    return e.fragment(t);
  },
  hasBlocks(e, t) {
    return e.hasBlocks(t);
  },
  hasInlines(e, t) {
    return e.hasInlines(t);
  },
  hasPath(e, t) {
    return e.hasPath(t);
  },
  hasTexts(e, t) {
    return e.hasTexts(t);
  },
  insertBreak(e) {
    e.insertBreak();
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertNode(e, t) {
    e.insertNode(t);
  },
  insertSoftBreak(e) {
    e.insertSoftBreak();
  },
  insertText(e, t) {
    e.insertText(t);
  },
  isBlock(e, t) {
    return e.isBlock(t);
  },
  isEdge(e, t, n) {
    return e.isEdge(t, n);
  },
  isEditor(e) {
    return Wse(e);
  },
  isElementReadOnly(e, t) {
    return e.isElementReadOnly(t);
  },
  isEmpty(e, t) {
    return e.isEmpty(t);
  },
  isEnd(e, t, n) {
    return e.isEnd(t, n);
  },
  isInline(e, t) {
    return e.isInline(t);
  },
  isNormalizing(e) {
    return e.isNormalizing();
  },
  isSelectable(e, t) {
    return e.isSelectable(t);
  },
  isStart(e, t, n) {
    return e.isStart(t, n);
  },
  isVoid(e, t) {
    return e.isVoid(t);
  },
  last(e, t) {
    return e.last(t);
  },
  leaf(e, t, n) {
    return e.leaf(t, n);
  },
  levels(e, t) {
    return e.levels(t);
  },
  marks(e) {
    return e.getMarks();
  },
  next(e, t) {
    return e.next(t);
  },
  node(e, t, n) {
    return e.node(t, n);
  },
  nodes(e, t) {
    return e.nodes(t);
  },
  normalize(e, t) {
    e.normalize(t);
  },
  parent(e, t, n) {
    return e.parent(t, n);
  },
  path(e, t, n) {
    return e.path(t, n);
  },
  pathRef(e, t, n) {
    return e.pathRef(t, n);
  },
  pathRefs(e) {
    return e.pathRefs();
  },
  point(e, t, n) {
    return e.point(t, n);
  },
  pointRef(e, t, n) {
    return e.pointRef(t, n);
  },
  pointRefs(e) {
    return e.pointRefs();
  },
  positions(e, t) {
    return e.positions(t);
  },
  previous(e, t) {
    return e.previous(t);
  },
  range(e, t, n) {
    return e.range(t, n);
  },
  rangeRef(e, t, n) {
    return e.rangeRef(t, n);
  },
  rangeRefs(e) {
    return e.rangeRefs();
  },
  removeMark(e, t) {
    e.removeMark(t);
  },
  setNormalizing(e, t) {
    e.setNormalizing(t);
  },
  start(e, t) {
    return e.start(t);
  },
  string(e, t, n) {
    return e.string(t, n);
  },
  unhangRange(e, t, n) {
    return e.unhangRange(t, n);
  },
  void(e, t) {
    return e.void(t);
  },
  withoutNormalizing(e, t) {
    e.withoutNormalizing(t);
  },
  shouldMergeNodesRemovePrevNode: (e, t, n) => e.shouldMergeNodesRemovePrevNode(t, n)
};
function bT(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function wT(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? bT(Object(n), !0).forEach(function(r) {
      Ec(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : bT(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var gr = {
  compare(e, t) {
    var n = ze.compare(e.path, t.path);
    return n === 0 ? e.offset < t.offset ? -1 : e.offset > t.offset ? 1 : 0 : n;
  },
  isAfter(e, t) {
    return gr.compare(e, t) === 1;
  },
  isBefore(e, t) {
    return gr.compare(e, t) === -1;
  },
  equals(e, t) {
    return e.offset === t.offset && ze.equals(e.path, t.path);
  },
  isPoint(e) {
    return Uo(e) && typeof e.offset == "number" && ze.isPath(e.path);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return EL(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "forward"
      } = n, {
        path: i,
        offset: a
      } = r;
      switch (t.type) {
        case "insert_node":
        case "move_node": {
          r.path = ze.transform(i, t, n);
          break;
        }
        case "insert_text": {
          ze.equals(t.path, i) && (t.offset < a || t.offset === a && o === "forward") && (r.offset += t.text.length);
          break;
        }
        case "merge_node": {
          ze.equals(t.path, i) && (r.offset += t.position), r.path = ze.transform(i, t, n);
          break;
        }
        case "remove_text": {
          ze.equals(t.path, i) && t.offset <= a && (r.offset -= Math.min(a - t.offset, t.text.length));
          break;
        }
        case "remove_node": {
          if (ze.equals(t.path, i) || ze.isAncestor(t.path, i))
            return null;
          r.path = ze.transform(i, t, n);
          break;
        }
        case "split_node": {
          if (ze.equals(t.path, i)) {
            if (t.position === a && o == null)
              return null;
            (t.position < a || t.position === a && o === "forward") && (r.offset -= t.position, r.path = ze.transform(i, t, wT(wT({}, n), {}, {
              affinity: "forward"
            })));
          } else
            r.path = ze.transform(i, t, n);
          break;
        }
      }
    });
  }
}, CT = void 0, Si = {
  setScrubber(e) {
    CT = e;
  },
  stringify(e) {
    return JSON.stringify(e, CT);
  }
}, Vse = ["text"], Zse = ["anchor", "focus"];
function xT(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function $s(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? xT(Object(n), !0).forEach(function(r) {
      Ec(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : xT(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var oo = {
  equals(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      loose: r = !1
    } = n;
    function o(i) {
      var a = Id(i, Vse);
      return a;
    }
    return D5(r ? o(e) : e, r ? o(t) : t);
  },
  isText(e) {
    return Uo(e) && typeof e.text == "string";
  },
  isTextList(e) {
    return Array.isArray(e) && e.every((t) => oo.isText(t));
  },
  isTextProps(e) {
    return e.text !== void 0;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "text" && (!e.hasOwnProperty(n) || e[n] !== t[n]))
        return !1;
    return !0;
  },
  decorations(e, t) {
    var n = [$s({}, e)];
    for (var r of t) {
      var o = Id(r, Zse), [i, a] = Ut.edges(r), s = [], l = 0, u = i.offset, c = a.offset;
      for (var p of n) {
        var {
          length: d
        } = p.text, g = l;
        if (l += d, u <= g && l <= c) {
          Object.assign(p, o), s.push(p);
          continue;
        }
        if (u !== c && (u === l || c === g) || u > l || c < g || c === g && g !== 0) {
          s.push(p);
          continue;
        }
        var f = p, m = void 0, v = void 0;
        if (c < l) {
          var E = c - g;
          v = $s($s({}, f), {}, {
            text: f.text.slice(E)
          }), f = $s($s({}, f), {}, {
            text: f.text.slice(0, E)
          });
        }
        if (u > g) {
          var w = u - g;
          m = $s($s({}, f), {}, {
            text: f.text.slice(0, w)
          }), f = $s($s({}, f), {}, {
            text: f.text.slice(w)
          });
        }
        Object.assign(f, o), m && s.push(m), s.push(f), v && s.push(v);
      }
      n = s;
    }
    return n;
  }
}, qse = (e) => e.selection ? e.selection : e.children.length > 0 ? qn.end(e, []) : [0], ur;
(function(e) {
  e[e.None = 0] = "None", e[e.Extend = 1] = "Extend", e[e.ZWJ = 2] = "ZWJ", e[e.RI = 4] = "RI", e[e.Prepend = 8] = "Prepend", e[e.SpacingMark = 16] = "SpacingMark", e[e.L = 32] = "L", e[e.V = 64] = "V", e[e.T = 128] = "T", e[e.LV = 256] = "LV", e[e.LVT = 512] = "LVT", e[e.ExtPict = 1024] = "ExtPict", e[e.Any = 2048] = "Any";
})(ur || (ur = {}));
ur.L, ur.L | ur.V | ur.LV | ur.LVT, ur.LV | ur.V, ur.V | ur.T, ur.LVT | ur.T, ur.T, ur.Any, ur.Extend | ur.ZWJ, ur.Any, ur.SpacingMark, ur.Prepend, ur.Any, ur.ZWJ, ur.ExtPict, ur.RI, ur.RI;
var Gse = {
  delete(e, t) {
    e.delete(t);
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertText(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    qn.withoutNormalizing(e, () => {
      var {
        voids: r = !1
      } = n, {
        at: o = qse(e)
      } = n;
      if (ze.isPath(o) && (o = qn.range(e, o)), Ut.isRange(o))
        if (Ut.isCollapsed(o))
          o = o.anchor;
        else {
          var i = Ut.end(o);
          if (!r && qn.void(e, {
            at: i
          }))
            return;
          var a = Ut.start(o), s = qn.pointRef(e, a), l = qn.pointRef(e, i);
          iv.delete(e, {
            at: o,
            voids: r
          });
          var u = s.unref(), c = l.unref();
          o = u || c, iv.setSelection(e, {
            anchor: o,
            focus: o
          });
        }
      if (!(!r && qn.void(e, {
        at: o
      }) || qn.elementReadOnly(e, {
        at: o
      }))) {
        var {
          path: p,
          offset: d
        } = o;
        t.length > 0 && e.apply({
          type: "insert_text",
          path: p,
          offset: d,
          text: t
        });
      }
    });
  }
};
function OT(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Th(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? OT(Object(n), !0).forEach(function(r) {
      Ec(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : OT(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var iv = Th(Th(Th(Th({}, Rse), Bse), Nse), Gse), T5 = {}, kL = {}, LL = {}, Gu = {}, PL = {}, _L = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Doctype = e.CDATA = e.Tag = e.Style = e.Script = e.Comment = e.Directive = e.Text = e.Root = e.isTag = e.ElementType = void 0;
  var t;
  (function(r) {
    r.Root = "root", r.Text = "text", r.Directive = "directive", r.Comment = "comment", r.Script = "script", r.Style = "style", r.Tag = "tag", r.CDATA = "cdata", r.Doctype = "doctype";
  })(t = e.ElementType || (e.ElementType = {}));
  function n(r) {
    return r.type === t.Tag || r.type === t.Script || r.type === t.Style;
  }
  e.isTag = n, e.Root = t.Root, e.Text = t.Text, e.Directive = t.Directive, e.Comment = t.Comment, e.Script = t.Script, e.Style = t.Style, e.Tag = t.Tag, e.CDATA = t.CDATA, e.Doctype = t.Doctype;
})(_L);
var Kt = {}, yl = er && er.__extends || /* @__PURE__ */ function() {
  var e = function(t, n) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, o) {
      r.__proto__ = o;
    } || function(r, o) {
      for (var i in o) Object.prototype.hasOwnProperty.call(o, i) && (r[i] = o[i]);
    }, e(t, n);
  };
  return function(t, n) {
    if (typeof n != "function" && n !== null)
      throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
    e(t, n);
    function r() {
      this.constructor = t;
    }
    t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
  };
}(), Zp = er && er.__assign || function() {
  return Zp = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) {
      t = arguments[n];
      for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
    }
    return e;
  }, Zp.apply(this, arguments);
};
Object.defineProperty(Kt, "__esModule", { value: !0 });
Kt.cloneNode = Kt.hasChildren = Kt.isDocument = Kt.isDirective = Kt.isComment = Kt.isText = Kt.isCDATA = Kt.isTag = Kt.Element = Kt.Document = Kt.CDATA = Kt.NodeWithChildren = Kt.ProcessingInstruction = Kt.Comment = Kt.Text = Kt.DataNode = Kt.Node = void 0;
var hi = _L, SL = (
  /** @class */
  function() {
    function e() {
      this.parent = null, this.prev = null, this.next = null, this.startIndex = null, this.endIndex = null;
    }
    return Object.defineProperty(e.prototype, "parentNode", {
      // Read-write aliases for properties
      /**
       * Same as {@link parent}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.parent;
      },
      set: function(t) {
        this.parent = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "previousSibling", {
      /**
       * Same as {@link prev}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.prev;
      },
      set: function(t) {
        this.prev = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "nextSibling", {
      /**
       * Same as {@link next}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.next;
      },
      set: function(t) {
        this.next = t;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.cloneNode = function(t) {
      return t === void 0 && (t = !1), ML(this, t);
    }, e;
  }()
);
Kt.Node = SL;
var Db = (
  /** @class */
  function(e) {
    yl(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.data = n, r;
    }
    return Object.defineProperty(t.prototype, "nodeValue", {
      /**
       * Same as {@link data}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.data;
      },
      set: function(n) {
        this.data = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(SL)
);
Kt.DataNode = Db;
var j5 = (
  /** @class */
  function(e) {
    yl(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = hi.ElementType.Text, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 3;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Db)
);
Kt.Text = j5;
var A5 = (
  /** @class */
  function(e) {
    yl(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = hi.ElementType.Comment, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 8;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Db)
);
Kt.Comment = A5;
var I5 = (
  /** @class */
  function(e) {
    yl(t, e);
    function t(n, r) {
      var o = e.call(this, r) || this;
      return o.name = n, o.type = hi.ElementType.Directive, o;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Db)
);
Kt.ProcessingInstruction = I5;
var Tb = (
  /** @class */
  function(e) {
    yl(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.children = n, r;
    }
    return Object.defineProperty(t.prototype, "firstChild", {
      // Aliases
      /** First child of the node. */
      get: function() {
        var n;
        return (n = this.children[0]) !== null && n !== void 0 ? n : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "lastChild", {
      /** Last child of the node. */
      get: function() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "childNodes", {
      /**
       * Same as {@link children}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.children;
      },
      set: function(n) {
        this.children = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(SL)
);
Kt.NodeWithChildren = Tb;
var R5 = (
  /** @class */
  function(e) {
    yl(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = hi.ElementType.CDATA, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 4;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Tb)
);
Kt.CDATA = R5;
var B5 = (
  /** @class */
  function(e) {
    yl(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = hi.ElementType.Root, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 9;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Tb)
);
Kt.Document = B5;
var N5 = (
  /** @class */
  function(e) {
    yl(t, e);
    function t(n, r, o, i) {
      o === void 0 && (o = []), i === void 0 && (i = n === "script" ? hi.ElementType.Script : n === "style" ? hi.ElementType.Style : hi.ElementType.Tag);
      var a = e.call(this, o) || this;
      return a.name = n, a.attribs = r, a.type = i, a;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "tagName", {
      // DOM Level 1 aliases
      /**
       * Same as {@link name}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.name;
      },
      set: function(n) {
        this.name = n;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "attributes", {
      get: function() {
        var n = this;
        return Object.keys(this.attribs).map(function(r) {
          var o, i;
          return {
            name: r,
            value: n.attribs[r],
            namespace: (o = n["x-attribsNamespace"]) === null || o === void 0 ? void 0 : o[r],
            prefix: (i = n["x-attribsPrefix"]) === null || i === void 0 ? void 0 : i[r]
          };
        });
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Tb)
);
Kt.Element = N5;
function F5(e) {
  return (0, hi.isTag)(e);
}
Kt.isTag = F5;
function z5(e) {
  return e.type === hi.ElementType.CDATA;
}
Kt.isCDATA = z5;
function U5(e) {
  return e.type === hi.ElementType.Text;
}
Kt.isText = U5;
function H5(e) {
  return e.type === hi.ElementType.Comment;
}
Kt.isComment = H5;
function $5(e) {
  return e.type === hi.ElementType.Directive;
}
Kt.isDirective = $5;
function W5(e) {
  return e.type === hi.ElementType.Root;
}
Kt.isDocument = W5;
function Kse(e) {
  return Object.prototype.hasOwnProperty.call(e, "children");
}
Kt.hasChildren = Kse;
function ML(e, t) {
  t === void 0 && (t = !1);
  var n;
  if (U5(e))
    n = new j5(e.data);
  else if (H5(e))
    n = new A5(e.data);
  else if (F5(e)) {
    var r = t ? $0(e.children) : [], o = new N5(e.name, Zp({}, e.attribs), r);
    r.forEach(function(l) {
      return l.parent = o;
    }), e.namespace != null && (o.namespace = e.namespace), e["x-attribsNamespace"] && (o["x-attribsNamespace"] = Zp({}, e["x-attribsNamespace"])), e["x-attribsPrefix"] && (o["x-attribsPrefix"] = Zp({}, e["x-attribsPrefix"])), n = o;
  } else if (z5(e)) {
    var r = t ? $0(e.children) : [], i = new R5(r);
    r.forEach(function(u) {
      return u.parent = i;
    }), n = i;
  } else if (W5(e)) {
    var r = t ? $0(e.children) : [], a = new B5(r);
    r.forEach(function(u) {
      return u.parent = a;
    }), e["x-mode"] && (a["x-mode"] = e["x-mode"]), n = a;
  } else if ($5(e)) {
    var s = new I5(e.name, e.data);
    e["x-name"] != null && (s["x-name"] = e["x-name"], s["x-publicId"] = e["x-publicId"], s["x-systemId"] = e["x-systemId"]), n = s;
  } else
    throw new Error("Not implemented yet: ".concat(e.type));
  return n.startIndex = e.startIndex, n.endIndex = e.endIndex, e.sourceCodeLocation != null && (n.sourceCodeLocation = e.sourceCodeLocation), n;
}
Kt.cloneNode = ML;
function $0(e) {
  for (var t = e.map(function(r) {
    return ML(r, !0);
  }), n = 1; n < t.length; n++)
    t[n].prev = t[n - 1], t[n - 1].next = t[n];
  return t;
}
(function(e) {
  var t = er && er.__createBinding || (Object.create ? function(s, l, u, c) {
    c === void 0 && (c = u);
    var p = Object.getOwnPropertyDescriptor(l, u);
    (!p || ("get" in p ? !l.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
      return l[u];
    } }), Object.defineProperty(s, c, p);
  } : function(s, l, u, c) {
    c === void 0 && (c = u), s[c] = l[u];
  }), n = er && er.__exportStar || function(s, l) {
    for (var u in s) u !== "default" && !Object.prototype.hasOwnProperty.call(l, u) && t(l, s, u);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.DomHandler = void 0;
  var r = _L, o = Kt;
  n(Kt, e);
  var i = {
    withStartIndices: !1,
    withEndIndices: !1,
    xmlMode: !1
  }, a = (
    /** @class */
    function() {
      function s(l, u, c) {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null, typeof u == "function" && (c = u, u = i), typeof l == "object" && (u = l, l = void 0), this.callback = l ?? null, this.options = u ?? i, this.elementCB = c ?? null;
      }
      return s.prototype.onparserinit = function(l) {
        this.parser = l;
      }, s.prototype.onreset = function() {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null;
      }, s.prototype.onend = function() {
        this.done || (this.done = !0, this.parser = null, this.handleCallback(null));
      }, s.prototype.onerror = function(l) {
        this.handleCallback(l);
      }, s.prototype.onclosetag = function() {
        this.lastNode = null;
        var l = this.tagStack.pop();
        this.options.withEndIndices && (l.endIndex = this.parser.endIndex), this.elementCB && this.elementCB(l);
      }, s.prototype.onopentag = function(l, u) {
        var c = this.options.xmlMode ? r.ElementType.Tag : void 0, p = new o.Element(l, u, void 0, c);
        this.addNode(p), this.tagStack.push(p);
      }, s.prototype.ontext = function(l) {
        var u = this.lastNode;
        if (u && u.type === r.ElementType.Text)
          u.data += l, this.options.withEndIndices && (u.endIndex = this.parser.endIndex);
        else {
          var c = new o.Text(l);
          this.addNode(c), this.lastNode = c;
        }
      }, s.prototype.oncomment = function(l) {
        if (this.lastNode && this.lastNode.type === r.ElementType.Comment) {
          this.lastNode.data += l;
          return;
        }
        var u = new o.Comment(l);
        this.addNode(u), this.lastNode = u;
      }, s.prototype.oncommentend = function() {
        this.lastNode = null;
      }, s.prototype.oncdatastart = function() {
        var l = new o.Text(""), u = new o.CDATA([l]);
        this.addNode(u), l.parent = u, this.lastNode = l;
      }, s.prototype.oncdataend = function() {
        this.lastNode = null;
      }, s.prototype.onprocessinginstruction = function(l, u) {
        var c = new o.ProcessingInstruction(l, u);
        this.addNode(c);
      }, s.prototype.handleCallback = function(l) {
        if (typeof this.callback == "function")
          this.callback(l, this.dom);
        else if (l)
          throw l;
      }, s.prototype.addNode = function(l) {
        var u = this.tagStack[this.tagStack.length - 1], c = u.children[u.children.length - 1];
        this.options.withStartIndices && (l.startIndex = this.parser.startIndex), this.options.withEndIndices && (l.endIndex = this.parser.endIndex), u.children.push(l), c && (l.prev = c, c.next = l), l.parent = u, this.lastNode = null;
      }, s;
    }()
  );
  e.DomHandler = a, e.default = a;
})(PL);
var V5 = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CARRIAGE_RETURN_PLACEHOLDER_REGEX = e.CARRIAGE_RETURN_PLACEHOLDER = e.CARRIAGE_RETURN_REGEX = e.CARRIAGE_RETURN = e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES = void 0, e.CASE_SENSITIVE_TAG_NAMES = [
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "linearGradient",
    "radialGradient",
    "textPath"
  ], e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES.reduce(function(t, n) {
    return t[n.toLowerCase()] = n, t;
  }, {}), e.CARRIAGE_RETURN = "\r", e.CARRIAGE_RETURN_REGEX = new RegExp(e.CARRIAGE_RETURN, "g"), e.CARRIAGE_RETURN_PLACEHOLDER = "__HTML_DOM_PARSER_CARRIAGE_RETURN_PLACEHOLDER_".concat(Date.now(), "__"), e.CARRIAGE_RETURN_PLACEHOLDER_REGEX = new RegExp(e.CARRIAGE_RETURN_PLACEHOLDER, "g");
})(V5);
Object.defineProperty(Gu, "__esModule", { value: !0 });
Gu.formatAttributes = Z5;
Gu.escapeSpecialCharacters = Jse;
Gu.revertEscapedCharacters = q5;
Gu.formatDOM = G5;
var jh = PL, Rd = V5;
function Yse(e) {
  return Rd.CASE_SENSITIVE_TAG_NAMES_MAP[e];
}
function Z5(e) {
  for (var t = {}, n = 0, r = e.length; n < r; n++) {
    var o = e[n];
    t[o.name] = o.value;
  }
  return t;
}
function Xse(e) {
  e = e.toLowerCase();
  var t = Yse(e);
  return t || e;
}
function Jse(e) {
  return e.replace(Rd.CARRIAGE_RETURN_REGEX, Rd.CARRIAGE_RETURN_PLACEHOLDER);
}
function q5(e) {
  return e.replace(Rd.CARRIAGE_RETURN_PLACEHOLDER_REGEX, Rd.CARRIAGE_RETURN);
}
function G5(e, t, n) {
  t === void 0 && (t = null);
  for (var r = [], o, i = 0, a = e.length; i < a; i++) {
    var s = e[i];
    switch (s.nodeType) {
      case 1: {
        var l = Xse(s.nodeName);
        o = new jh.Element(l, Z5(s.attributes)), o.children = G5(
          // template children are on content
          l === "template" ? s.content.childNodes : s.childNodes,
          o
        );
        break;
      }
      case 3:
        o = new jh.Text(q5(s.nodeValue));
        break;
      case 8:
        o = new jh.Comment(s.nodeValue);
        break;
      default:
        continue;
    }
    var u = r[i - 1] || null;
    u && (u.next = o), o.parent = t, o.prev = u, o.next = null, r.push(o);
  }
  return n && (o = new jh.ProcessingInstruction(n.substring(0, n.indexOf(" ")).toLowerCase(), n), o.next = r[0] || null, o.parent = t, r.unshift(o), r[1] && (r[1].prev = r[0])), r;
}
Object.defineProperty(LL, "__esModule", { value: !0 });
LL.default = rae;
var Qse = Gu, ET = "html", kT = "head", Ah = "body", eae = /<([a-zA-Z]+[0-9]?)/, LT = /<head[^]*>/i, PT = /<body[^]*>/i, sv = function(e, t) {
  throw new Error("This browser does not support `document.implementation.createHTMLDocument`");
}, DE = function(e, t) {
  throw new Error("This browser does not support `DOMParser.prototype.parseFromString`");
}, _T = typeof window == "object" && window.DOMParser;
if (typeof _T == "function") {
  var tae = new _T(), nae = "text/html";
  DE = function(e, t) {
    return t && (e = "<".concat(t, ">").concat(e, "</").concat(t, ">")), tae.parseFromString(e, nae);
  }, sv = DE;
}
if (typeof document == "object" && document.implementation) {
  var Ih = document.implementation.createHTMLDocument();
  sv = function(e, t) {
    if (t) {
      var n = Ih.documentElement.querySelector(t);
      return n && (n.innerHTML = e), Ih;
    }
    return Ih.documentElement.innerHTML = e, Ih;
  };
}
var Rh = typeof document == "object" && document.createElement("template"), TE;
Rh && Rh.content && (TE = function(e) {
  return Rh.innerHTML = e, Rh.content.childNodes;
});
function rae(e) {
  var t, n;
  e = (0, Qse.escapeSpecialCharacters)(e);
  var r = e.match(eae), o = r && r[1] ? r[1].toLowerCase() : "";
  switch (o) {
    case ET: {
      var i = DE(e);
      if (!LT.test(e)) {
        var a = i.querySelector(kT);
        (t = a == null ? void 0 : a.parentNode) === null || t === void 0 || t.removeChild(a);
      }
      if (!PT.test(e)) {
        var a = i.querySelector(Ah);
        (n = a == null ? void 0 : a.parentNode) === null || n === void 0 || n.removeChild(a);
      }
      return i.querySelectorAll(ET);
    }
    case kT:
    case Ah: {
      var s = sv(e).querySelectorAll(o);
      return PT.test(e) && LT.test(e) ? s[0].parentNode.childNodes : s;
    }
    default: {
      if (TE)
        return TE(e);
      var a = sv(e, Ah).querySelector(Ah);
      return a.childNodes;
    }
  }
}
var oae = er && er.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(kL, "__esModule", { value: !0 });
kL.default = lae;
var iae = oae(LL), sae = Gu, aae = /<(![a-zA-Z\s]+)>/;
function lae(e) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e)
    return [];
  var t = e.match(aae), n = t ? t[1] : void 0;
  return (0, sae.formatDOM)((0, iae.default)(e), null, n);
}
var jb = {}, fs = {}, Ab = {}, uae = 0;
Ab.SAME = uae;
var cae = 1;
Ab.CAMELCASE = cae;
Ab.possibleStandardNames = {
  accept: 0,
  acceptCharset: 1,
  "accept-charset": "acceptCharset",
  accessKey: 1,
  action: 0,
  allowFullScreen: 1,
  alt: 0,
  as: 0,
  async: 0,
  autoCapitalize: 1,
  autoComplete: 1,
  autoCorrect: 1,
  autoFocus: 1,
  autoPlay: 1,
  autoSave: 1,
  capture: 0,
  cellPadding: 1,
  cellSpacing: 1,
  challenge: 0,
  charSet: 1,
  checked: 0,
  children: 0,
  cite: 0,
  class: "className",
  classID: 1,
  className: 1,
  cols: 0,
  colSpan: 1,
  content: 0,
  contentEditable: 1,
  contextMenu: 1,
  controls: 0,
  controlsList: 1,
  coords: 0,
  crossOrigin: 1,
  dangerouslySetInnerHTML: 1,
  data: 0,
  dateTime: 1,
  default: 0,
  defaultChecked: 1,
  defaultValue: 1,
  defer: 0,
  dir: 0,
  disabled: 0,
  disablePictureInPicture: 1,
  disableRemotePlayback: 1,
  download: 0,
  draggable: 0,
  encType: 1,
  enterKeyHint: 1,
  for: "htmlFor",
  form: 0,
  formMethod: 1,
  formAction: 1,
  formEncType: 1,
  formNoValidate: 1,
  formTarget: 1,
  frameBorder: 1,
  headers: 0,
  height: 0,
  hidden: 0,
  high: 0,
  href: 0,
  hrefLang: 1,
  htmlFor: 1,
  httpEquiv: 1,
  "http-equiv": "httpEquiv",
  icon: 0,
  id: 0,
  innerHTML: 1,
  inputMode: 1,
  integrity: 0,
  is: 0,
  itemID: 1,
  itemProp: 1,
  itemRef: 1,
  itemScope: 1,
  itemType: 1,
  keyParams: 1,
  keyType: 1,
  kind: 0,
  label: 0,
  lang: 0,
  list: 0,
  loop: 0,
  low: 0,
  manifest: 0,
  marginWidth: 1,
  marginHeight: 1,
  max: 0,
  maxLength: 1,
  media: 0,
  mediaGroup: 1,
  method: 0,
  min: 0,
  minLength: 1,
  multiple: 0,
  muted: 0,
  name: 0,
  noModule: 1,
  nonce: 0,
  noValidate: 1,
  open: 0,
  optimum: 0,
  pattern: 0,
  placeholder: 0,
  playsInline: 1,
  poster: 0,
  preload: 0,
  profile: 0,
  radioGroup: 1,
  readOnly: 1,
  referrerPolicy: 1,
  rel: 0,
  required: 0,
  reversed: 0,
  role: 0,
  rows: 0,
  rowSpan: 1,
  sandbox: 0,
  scope: 0,
  scoped: 0,
  scrolling: 0,
  seamless: 0,
  selected: 0,
  shape: 0,
  size: 0,
  sizes: 0,
  span: 0,
  spellCheck: 1,
  src: 0,
  srcDoc: 1,
  srcLang: 1,
  srcSet: 1,
  start: 0,
  step: 0,
  style: 0,
  summary: 0,
  tabIndex: 1,
  target: 0,
  title: 0,
  type: 0,
  useMap: 1,
  value: 0,
  width: 0,
  wmode: 0,
  wrap: 0,
  about: 0,
  accentHeight: 1,
  "accent-height": "accentHeight",
  accumulate: 0,
  additive: 0,
  alignmentBaseline: 1,
  "alignment-baseline": "alignmentBaseline",
  allowReorder: 1,
  alphabetic: 0,
  amplitude: 0,
  arabicForm: 1,
  "arabic-form": "arabicForm",
  ascent: 0,
  attributeName: 1,
  attributeType: 1,
  autoReverse: 1,
  azimuth: 0,
  baseFrequency: 1,
  baselineShift: 1,
  "baseline-shift": "baselineShift",
  baseProfile: 1,
  bbox: 0,
  begin: 0,
  bias: 0,
  by: 0,
  calcMode: 1,
  capHeight: 1,
  "cap-height": "capHeight",
  clip: 0,
  clipPath: 1,
  "clip-path": "clipPath",
  clipPathUnits: 1,
  clipRule: 1,
  "clip-rule": "clipRule",
  color: 0,
  colorInterpolation: 1,
  "color-interpolation": "colorInterpolation",
  colorInterpolationFilters: 1,
  "color-interpolation-filters": "colorInterpolationFilters",
  colorProfile: 1,
  "color-profile": "colorProfile",
  colorRendering: 1,
  "color-rendering": "colorRendering",
  contentScriptType: 1,
  contentStyleType: 1,
  cursor: 0,
  cx: 0,
  cy: 0,
  d: 0,
  datatype: 0,
  decelerate: 0,
  descent: 0,
  diffuseConstant: 1,
  direction: 0,
  display: 0,
  divisor: 0,
  dominantBaseline: 1,
  "dominant-baseline": "dominantBaseline",
  dur: 0,
  dx: 0,
  dy: 0,
  edgeMode: 1,
  elevation: 0,
  enableBackground: 1,
  "enable-background": "enableBackground",
  end: 0,
  exponent: 0,
  externalResourcesRequired: 1,
  fill: 0,
  fillOpacity: 1,
  "fill-opacity": "fillOpacity",
  fillRule: 1,
  "fill-rule": "fillRule",
  filter: 0,
  filterRes: 1,
  filterUnits: 1,
  floodOpacity: 1,
  "flood-opacity": "floodOpacity",
  floodColor: 1,
  "flood-color": "floodColor",
  focusable: 0,
  fontFamily: 1,
  "font-family": "fontFamily",
  fontSize: 1,
  "font-size": "fontSize",
  fontSizeAdjust: 1,
  "font-size-adjust": "fontSizeAdjust",
  fontStretch: 1,
  "font-stretch": "fontStretch",
  fontStyle: 1,
  "font-style": "fontStyle",
  fontVariant: 1,
  "font-variant": "fontVariant",
  fontWeight: 1,
  "font-weight": "fontWeight",
  format: 0,
  from: 0,
  fx: 0,
  fy: 0,
  g1: 0,
  g2: 0,
  glyphName: 1,
  "glyph-name": "glyphName",
  glyphOrientationHorizontal: 1,
  "glyph-orientation-horizontal": "glyphOrientationHorizontal",
  glyphOrientationVertical: 1,
  "glyph-orientation-vertical": "glyphOrientationVertical",
  glyphRef: 1,
  gradientTransform: 1,
  gradientUnits: 1,
  hanging: 0,
  horizAdvX: 1,
  "horiz-adv-x": "horizAdvX",
  horizOriginX: 1,
  "horiz-origin-x": "horizOriginX",
  ideographic: 0,
  imageRendering: 1,
  "image-rendering": "imageRendering",
  in2: 0,
  in: 0,
  inlist: 0,
  intercept: 0,
  k1: 0,
  k2: 0,
  k3: 0,
  k4: 0,
  k: 0,
  kernelMatrix: 1,
  kernelUnitLength: 1,
  kerning: 0,
  keyPoints: 1,
  keySplines: 1,
  keyTimes: 1,
  lengthAdjust: 1,
  letterSpacing: 1,
  "letter-spacing": "letterSpacing",
  lightingColor: 1,
  "lighting-color": "lightingColor",
  limitingConeAngle: 1,
  local: 0,
  markerEnd: 1,
  "marker-end": "markerEnd",
  markerHeight: 1,
  markerMid: 1,
  "marker-mid": "markerMid",
  markerStart: 1,
  "marker-start": "markerStart",
  markerUnits: 1,
  markerWidth: 1,
  mask: 0,
  maskContentUnits: 1,
  maskUnits: 1,
  mathematical: 0,
  mode: 0,
  numOctaves: 1,
  offset: 0,
  opacity: 0,
  operator: 0,
  order: 0,
  orient: 0,
  orientation: 0,
  origin: 0,
  overflow: 0,
  overlinePosition: 1,
  "overline-position": "overlinePosition",
  overlineThickness: 1,
  "overline-thickness": "overlineThickness",
  paintOrder: 1,
  "paint-order": "paintOrder",
  panose1: 0,
  "panose-1": "panose1",
  pathLength: 1,
  patternContentUnits: 1,
  patternTransform: 1,
  patternUnits: 1,
  pointerEvents: 1,
  "pointer-events": "pointerEvents",
  points: 0,
  pointsAtX: 1,
  pointsAtY: 1,
  pointsAtZ: 1,
  prefix: 0,
  preserveAlpha: 1,
  preserveAspectRatio: 1,
  primitiveUnits: 1,
  property: 0,
  r: 0,
  radius: 0,
  refX: 1,
  refY: 1,
  renderingIntent: 1,
  "rendering-intent": "renderingIntent",
  repeatCount: 1,
  repeatDur: 1,
  requiredExtensions: 1,
  requiredFeatures: 1,
  resource: 0,
  restart: 0,
  result: 0,
  results: 0,
  rotate: 0,
  rx: 0,
  ry: 0,
  scale: 0,
  security: 0,
  seed: 0,
  shapeRendering: 1,
  "shape-rendering": "shapeRendering",
  slope: 0,
  spacing: 0,
  specularConstant: 1,
  specularExponent: 1,
  speed: 0,
  spreadMethod: 1,
  startOffset: 1,
  stdDeviation: 1,
  stemh: 0,
  stemv: 0,
  stitchTiles: 1,
  stopColor: 1,
  "stop-color": "stopColor",
  stopOpacity: 1,
  "stop-opacity": "stopOpacity",
  strikethroughPosition: 1,
  "strikethrough-position": "strikethroughPosition",
  strikethroughThickness: 1,
  "strikethrough-thickness": "strikethroughThickness",
  string: 0,
  stroke: 0,
  strokeDasharray: 1,
  "stroke-dasharray": "strokeDasharray",
  strokeDashoffset: 1,
  "stroke-dashoffset": "strokeDashoffset",
  strokeLinecap: 1,
  "stroke-linecap": "strokeLinecap",
  strokeLinejoin: 1,
  "stroke-linejoin": "strokeLinejoin",
  strokeMiterlimit: 1,
  "stroke-miterlimit": "strokeMiterlimit",
  strokeWidth: 1,
  "stroke-width": "strokeWidth",
  strokeOpacity: 1,
  "stroke-opacity": "strokeOpacity",
  suppressContentEditableWarning: 1,
  suppressHydrationWarning: 1,
  surfaceScale: 1,
  systemLanguage: 1,
  tableValues: 1,
  targetX: 1,
  targetY: 1,
  textAnchor: 1,
  "text-anchor": "textAnchor",
  textDecoration: 1,
  "text-decoration": "textDecoration",
  textLength: 1,
  textRendering: 1,
  "text-rendering": "textRendering",
  to: 0,
  transform: 0,
  typeof: 0,
  u1: 0,
  u2: 0,
  underlinePosition: 1,
  "underline-position": "underlinePosition",
  underlineThickness: 1,
  "underline-thickness": "underlineThickness",
  unicode: 0,
  unicodeBidi: 1,
  "unicode-bidi": "unicodeBidi",
  unicodeRange: 1,
  "unicode-range": "unicodeRange",
  unitsPerEm: 1,
  "units-per-em": "unitsPerEm",
  unselectable: 0,
  vAlphabetic: 1,
  "v-alphabetic": "vAlphabetic",
  values: 0,
  vectorEffect: 1,
  "vector-effect": "vectorEffect",
  version: 0,
  vertAdvY: 1,
  "vert-adv-y": "vertAdvY",
  vertOriginX: 1,
  "vert-origin-x": "vertOriginX",
  vertOriginY: 1,
  "vert-origin-y": "vertOriginY",
  vHanging: 1,
  "v-hanging": "vHanging",
  vIdeographic: 1,
  "v-ideographic": "vIdeographic",
  viewBox: 1,
  viewTarget: 1,
  visibility: 0,
  vMathematical: 1,
  "v-mathematical": "vMathematical",
  vocab: 0,
  widths: 0,
  wordSpacing: 1,
  "word-spacing": "wordSpacing",
  writingMode: 1,
  "writing-mode": "writingMode",
  x1: 0,
  x2: 0,
  x: 0,
  xChannelSelector: 1,
  xHeight: 1,
  "x-height": "xHeight",
  xlinkActuate: 1,
  "xlink:actuate": "xlinkActuate",
  xlinkArcrole: 1,
  "xlink:arcrole": "xlinkArcrole",
  xlinkHref: 1,
  "xlink:href": "xlinkHref",
  xlinkRole: 1,
  "xlink:role": "xlinkRole",
  xlinkShow: 1,
  "xlink:show": "xlinkShow",
  xlinkTitle: 1,
  "xlink:title": "xlinkTitle",
  xlinkType: 1,
  "xlink:type": "xlinkType",
  xmlBase: 1,
  "xml:base": "xmlBase",
  xmlLang: 1,
  "xml:lang": "xmlLang",
  xmlns: 0,
  "xml:space": "xmlSpace",
  xmlnsXlink: 1,
  "xmlns:xlink": "xmlnsXlink",
  xmlSpace: 1,
  y1: 0,
  y2: 0,
  y: 0,
  yChannelSelector: 1,
  z: 0,
  zoomAndPan: 1
};
const K5 = 0, bl = 1, Ib = 2, Rb = 3, DL = 4, Y5 = 5, X5 = 6;
function pae(e) {
  return Io.hasOwnProperty(e) ? Io[e] : null;
}
function Jo(e, t, n, r, o, i, a) {
  this.acceptsBooleans = t === Ib || t === Rb || t === DL, this.attributeName = r, this.attributeNamespace = o, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = i, this.removeEmptyString = a;
}
const Io = {}, dae = [
  "children",
  "dangerouslySetInnerHTML",
  // TODO: This prevents the assignment of defaultValue to regular
  // elements (not just inputs). Now that ReactDOMInput assigns to the
  // defaultValue property -- do we need this?
  "defaultValue",
  "defaultChecked",
  "innerHTML",
  "suppressContentEditableWarning",
  "suppressHydrationWarning",
  "style"
];
dae.forEach((e) => {
  Io[e] = new Jo(
    e,
    K5,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"]
].forEach(([e, t]) => {
  Io[e] = new Jo(
    e,
    bl,
    !1,
    // mustUseProperty
    t,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["contentEditable", "draggable", "spellCheck", "value"].forEach((e) => {
  Io[e] = new Jo(
    e,
    Ib,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha"
].forEach((e) => {
  Io[e] = new Jo(
    e,
    Ib,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "allowFullScreen",
  "async",
  // Note: there is a special case that prevents it from being written to the DOM
  // on the client side because the browsers are inconsistent. Instead we call focus().
  "autoFocus",
  "autoPlay",
  "controls",
  "default",
  "defer",
  "disabled",
  "disablePictureInPicture",
  "disableRemotePlayback",
  "formNoValidate",
  "hidden",
  "loop",
  "noModule",
  "noValidate",
  "open",
  "playsInline",
  "readOnly",
  "required",
  "reversed",
  "scoped",
  "seamless",
  // Microdata
  "itemScope"
].forEach((e) => {
  Io[e] = new Jo(
    e,
    Rb,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "checked",
  // Note: `option.selected` is not updated if `select.multiple` is
  // disabled with `removeAttribute`. We have special logic for handling this.
  "multiple",
  "muted",
  "selected"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Io[e] = new Jo(
    e,
    Rb,
    !0,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "capture",
  "download"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Io[e] = new Jo(
    e,
    DL,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "cols",
  "rows",
  "size",
  "span"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Io[e] = new Jo(
    e,
    X5,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["rowSpan", "start"].forEach((e) => {
  Io[e] = new Jo(
    e,
    Y5,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const TL = /[\-\:]([a-z])/g, jL = (e) => e[1].toUpperCase();
[
  "accent-height",
  "alignment-baseline",
  "arabic-form",
  "baseline-shift",
  "cap-height",
  "clip-path",
  "clip-rule",
  "color-interpolation",
  "color-interpolation-filters",
  "color-profile",
  "color-rendering",
  "dominant-baseline",
  "enable-background",
  "fill-opacity",
  "fill-rule",
  "flood-color",
  "flood-opacity",
  "font-family",
  "font-size",
  "font-size-adjust",
  "font-stretch",
  "font-style",
  "font-variant",
  "font-weight",
  "glyph-name",
  "glyph-orientation-horizontal",
  "glyph-orientation-vertical",
  "horiz-adv-x",
  "horiz-origin-x",
  "image-rendering",
  "letter-spacing",
  "lighting-color",
  "marker-end",
  "marker-mid",
  "marker-start",
  "overline-position",
  "overline-thickness",
  "paint-order",
  "panose-1",
  "pointer-events",
  "rendering-intent",
  "shape-rendering",
  "stop-color",
  "stop-opacity",
  "strikethrough-position",
  "strikethrough-thickness",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "text-anchor",
  "text-decoration",
  "text-rendering",
  "underline-position",
  "underline-thickness",
  "unicode-bidi",
  "unicode-range",
  "units-per-em",
  "v-alphabetic",
  "v-hanging",
  "v-ideographic",
  "v-mathematical",
  "vector-effect",
  "vert-adv-y",
  "vert-origin-x",
  "vert-origin-y",
  "word-spacing",
  "writing-mode",
  "xmlns:xlink",
  "x-height"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(TL, jL);
  Io[t] = new Jo(
    t,
    bl,
    !1,
    // mustUseProperty
    e,
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xlink:actuate",
  "xlink:arcrole",
  "xlink:role",
  "xlink:show",
  "xlink:title",
  "xlink:type"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(TL, jL);
  Io[t] = new Jo(
    t,
    bl,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/1999/xlink",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xml:base",
  "xml:lang",
  "xml:space"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(TL, jL);
  Io[t] = new Jo(
    t,
    bl,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/XML/1998/namespace",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["tabIndex", "crossOrigin"].forEach((e) => {
  Io[e] = new Jo(
    e,
    bl,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const fae = "xlinkHref";
Io[fae] = new Jo(
  "xlinkHref",
  bl,
  !1,
  // mustUseProperty
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  // sanitizeURL
  !1
  // removeEmptyString
);
["src", "href", "action", "formAction"].forEach((e) => {
  Io[e] = new Jo(
    e,
    bl,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !0,
    // sanitizeURL
    !0
    // removeEmptyString
  );
});
const {
  CAMELCASE: hae,
  SAME: gae,
  possibleStandardNames: ST
} = Ab, mae = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", vae = mae + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", yae = RegExp.prototype.test.bind(
  // eslint-disable-next-line no-misleading-character-class
  new RegExp("^(data|aria)-[" + vae + "]*$")
), bae = Object.keys(
  ST
).reduce((e, t) => {
  const n = ST[t];
  return n === gae ? e[t] = t : n === hae ? e[t.toLowerCase()] = t : e[t] = n, e;
}, {});
fs.BOOLEAN = Rb;
fs.BOOLEANISH_STRING = Ib;
fs.NUMERIC = Y5;
fs.OVERLOADED_BOOLEAN = DL;
fs.POSITIVE_NUMERIC = X5;
fs.RESERVED = K5;
fs.STRING = bl;
fs.getPropertyInfo = pae;
fs.isCustomAttribute = yae;
fs.possibleStandardNames = bae;
var AL = {}, IL = {}, MT = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, wae = /\n/g, Cae = /^\s*/, xae = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, Oae = /^:\s*/, Eae = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, kae = /^[;\s]*/, Lae = /^\s+|\s+$/g, Pae = `
`, DT = "/", TT = "*", su = "", _ae = "comment", Sae = "declaration", Mae = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e) return [];
  t = t || {};
  var n = 1, r = 1;
  function o(f) {
    var m = f.match(wae);
    m && (n += m.length);
    var v = f.lastIndexOf(Pae);
    r = ~v ? f.length - v : r + f.length;
  }
  function i() {
    var f = { line: n, column: r };
    return function(m) {
      return m.position = new a(f), u(), m;
    };
  }
  function a(f) {
    this.start = f, this.end = { line: n, column: r }, this.source = t.source;
  }
  a.prototype.content = e;
  function s(f) {
    var m = new Error(
      t.source + ":" + n + ":" + r + ": " + f
    );
    if (m.reason = f, m.filename = t.source, m.line = n, m.column = r, m.source = e, !t.silent) throw m;
  }
  function l(f) {
    var m = f.exec(e);
    if (m) {
      var v = m[0];
      return o(v), e = e.slice(v.length), m;
    }
  }
  function u() {
    l(Cae);
  }
  function c(f) {
    var m;
    for (f = f || []; m = p(); )
      m !== !1 && f.push(m);
    return f;
  }
  function p() {
    var f = i();
    if (!(DT != e.charAt(0) || TT != e.charAt(1))) {
      for (var m = 2; su != e.charAt(m) && (TT != e.charAt(m) || DT != e.charAt(m + 1)); )
        ++m;
      if (m += 2, su === e.charAt(m - 1))
        return s("End of comment missing");
      var v = e.slice(2, m - 2);
      return r += 2, o(v), e = e.slice(m), r += 2, f({
        type: _ae,
        comment: v
      });
    }
  }
  function d() {
    var f = i(), m = l(xae);
    if (m) {
      if (p(), !l(Oae)) return s("property missing ':'");
      var v = l(Eae), E = f({
        type: Sae,
        property: jT(m[0].replace(MT, su)),
        value: v ? jT(v[0].replace(MT, su)) : su
      });
      return l(kae), E;
    }
  }
  function g() {
    var f = [];
    c(f);
    for (var m; m = d(); )
      m !== !1 && (f.push(m), c(f));
    return f;
  }
  return u(), g();
};
function jT(e) {
  return e ? e.replace(Lae, su) : su;
}
var Dae = er && er.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(IL, "__esModule", { value: !0 });
IL.default = jae;
var Tae = Dae(Mae);
function jae(e, t) {
  var n = null;
  if (!e || typeof e != "string")
    return n;
  var r = (0, Tae.default)(e), o = typeof t == "function";
  return r.forEach(function(i) {
    if (i.type === "declaration") {
      var a = i.property, s = i.value;
      o ? t(a, s, i) : s && (n = n || {}, n[a] = s);
    }
  }), n;
}
var Bb = {};
Object.defineProperty(Bb, "__esModule", { value: !0 });
Bb.camelCase = void 0;
var Aae = /^--[a-zA-Z0-9_-]+$/, Iae = /-([a-z])/g, Rae = /^[^-]+$/, Bae = /^-(webkit|moz|ms|o|khtml)-/, Nae = /^-(ms)-/, Fae = function(e) {
  return !e || Rae.test(e) || Aae.test(e);
}, zae = function(e, t) {
  return t.toUpperCase();
}, AT = function(e, t) {
  return "".concat(t, "-");
}, Uae = function(e, t) {
  return t === void 0 && (t = {}), Fae(e) ? e : (e = e.toLowerCase(), t.reactCompat ? e = e.replace(Nae, AT) : e = e.replace(Bae, AT), e.replace(Iae, zae));
};
Bb.camelCase = Uae;
var Hae = er && er.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
}, $ae = Hae(IL), Wae = Bb;
function jE(e, t) {
  var n = {};
  return !e || typeof e != "string" || (0, $ae.default)(e, function(r, o) {
    r && o && (n[(0, Wae.camelCase)(r, t)] = o);
  }), n;
}
jE.default = jE;
var Vae = jE;
(function(e) {
  var t = er && er.__importDefault || function(c) {
    return c && c.__esModule ? c : { default: c };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.returnFirstArg = e.canTextBeChildOfNode = e.ELEMENTS_WITH_NO_TEXT_CHILDREN = e.PRESERVE_CUSTOM_ATTRIBUTES = void 0, e.isCustomComponent = i, e.setStyleProp = s;
  var n = we, r = t(Vae), o = /* @__PURE__ */ new Set([
    "annotation-xml",
    "color-profile",
    "font-face",
    "font-face-src",
    "font-face-uri",
    "font-face-format",
    "font-face-name",
    "missing-glyph"
  ]);
  function i(c, p) {
    return c.includes("-") ? !o.has(c) : !!(p && typeof p.is == "string");
  }
  var a = {
    reactCompat: !0
  };
  function s(c, p) {
    if (typeof c == "string") {
      if (!c.trim()) {
        p.style = {};
        return;
      }
      try {
        p.style = (0, r.default)(c, a);
      } catch {
        p.style = {};
      }
    }
  }
  e.PRESERVE_CUSTOM_ATTRIBUTES = Number(n.version.split(".")[0]) >= 16, e.ELEMENTS_WITH_NO_TEXT_CHILDREN = /* @__PURE__ */ new Set([
    "tr",
    "tbody",
    "thead",
    "tfoot",
    "colgroup",
    "table",
    "head",
    "html",
    "frameset"
  ]);
  var l = function(c) {
    return !e.ELEMENTS_WITH_NO_TEXT_CHILDREN.has(c.name);
  };
  e.canTextBeChildOfNode = l;
  var u = function(c) {
    return c;
  };
  e.returnFirstArg = u;
})(AL);
Object.defineProperty(jb, "__esModule", { value: !0 });
jb.default = Kae;
var Tp = fs, IT = AL, Zae = ["checked", "value"], qae = ["input", "select", "textarea"], Gae = {
  reset: !0,
  submit: !0
};
function Kae(e, t) {
  e === void 0 && (e = {});
  var n = {}, r = !!(e.type && Gae[e.type]);
  for (var o in e) {
    var i = e[o];
    if ((0, Tp.isCustomAttribute)(o)) {
      n[o] = i;
      continue;
    }
    var a = o.toLowerCase(), s = RT(a);
    if (s) {
      var l = (0, Tp.getPropertyInfo)(s);
      switch (Zae.includes(s) && qae.includes(t) && !r && (s = RT("default" + a)), n[s] = i, l && l.type) {
        case Tp.BOOLEAN:
          n[s] = !0;
          break;
        case Tp.OVERLOADED_BOOLEAN:
          i === "" && (n[s] = !0);
          break;
      }
      continue;
    }
    IT.PRESERVE_CUSTOM_ATTRIBUTES && (n[o] = i);
  }
  return (0, IT.setStyleProp)(e.style, n), n;
}
function RT(e) {
  return Tp.possibleStandardNames[e];
}
var RL = {}, Yae = er && er.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(RL, "__esModule", { value: !0 });
RL.default = J5;
var W0 = we, Xae = Yae(jb), qp = AL, Jae = {
  cloneElement: W0.cloneElement,
  createElement: W0.createElement,
  isValidElement: W0.isValidElement
};
function J5(e, t) {
  t === void 0 && (t = {});
  for (var n = [], r = typeof t.replace == "function", o = t.transform || qp.returnFirstArg, i = t.library || Jae, a = i.cloneElement, s = i.createElement, l = i.isValidElement, u = e.length, c = 0; c < u; c++) {
    var p = e[c];
    if (r) {
      var d = t.replace(p, c);
      if (l(d)) {
        u > 1 && (d = a(d, {
          key: d.key || c
        })), n.push(o(d, p, c));
        continue;
      }
    }
    if (p.type === "text") {
      var g = !p.data.trim().length;
      if (g && p.parent && !(0, qp.canTextBeChildOfNode)(p.parent) || t.trim && g)
        continue;
      n.push(o(p.data, p, c));
      continue;
    }
    var f = p, m = {};
    Qae(f) ? ((0, qp.setStyleProp)(f.attribs.style, f.attribs), m = f.attribs) : f.attribs && (m = (0, Xae.default)(f.attribs, f.name));
    var v = void 0;
    switch (p.type) {
      case "script":
      case "style":
        p.children[0] && (m.dangerouslySetInnerHTML = {
          __html: p.children[0].data
        });
        break;
      case "tag":
        p.name === "textarea" && p.children[0] ? m.defaultValue = p.children[0].data : p.children && p.children.length && (v = J5(p.children, t));
        break;
      default:
        continue;
    }
    u > 1 && (m.key = c), n.push(o(s(p.name, m, v), p, c));
  }
  return n.length === 1 ? n[0] : n;
}
function Qae(e) {
  return qp.PRESERVE_CUSTOM_ATTRIBUTES && e.type === "tag" && (0, qp.isCustomComponent)(e.name, e.attribs);
}
(function(e) {
  var t = er && er.__importDefault || function(l) {
    return l && l.__esModule ? l : { default: l };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.htmlToDOM = e.domToReact = e.attributesToProps = e.Text = e.ProcessingInstruction = e.Element = e.Comment = void 0, e.default = s;
  var n = t(kL);
  e.htmlToDOM = n.default;
  var r = t(jb);
  e.attributesToProps = r.default;
  var o = t(RL);
  e.domToReact = o.default;
  var i = PL;
  Object.defineProperty(e, "Comment", { enumerable: !0, get: function() {
    return i.Comment;
  } }), Object.defineProperty(e, "Element", { enumerable: !0, get: function() {
    return i.Element;
  } }), Object.defineProperty(e, "ProcessingInstruction", { enumerable: !0, get: function() {
    return i.ProcessingInstruction;
  } }), Object.defineProperty(e, "Text", { enumerable: !0, get: function() {
    return i.Text;
  } });
  var a = { lowerCaseAttributeNames: !1 };
  function s(l, u) {
    if (typeof l != "string")
      throw new TypeError("First argument must be a string");
    return l ? (0, o.default)((0, n.default)(l, (u == null ? void 0 : u.htmlparser2) || a), u) : [];
  }
})(T5);
const ele = /* @__PURE__ */ bse(T5);
ele.default;
var tr = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function tle(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var AE = { exports: {} }, Xc = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var BT;
function nle() {
  if (BT) return Xc;
  BT = 1;
  var e = we, t = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, o = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, i = { key: !0, ref: !0, __self: !0, __source: !0 };
  function a(s, l, u) {
    var c, p = {}, d = null, g = null;
    u !== void 0 && (d = "" + u), l.key !== void 0 && (d = "" + l.key), l.ref !== void 0 && (g = l.ref);
    for (c in l) r.call(l, c) && !i.hasOwnProperty(c) && (p[c] = l[c]);
    if (s && s.defaultProps) for (c in l = s.defaultProps, l) p[c] === void 0 && (p[c] = l[c]);
    return { $$typeof: t, type: s, key: d, ref: g, props: p, _owner: o.current };
  }
  return Xc.Fragment = n, Xc.jsx = a, Xc.jsxs = a, Xc;
}
var Bh = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var NT;
function rle() {
  return NT || (NT = 1, process.env.NODE_ENV !== "production" && function() {
    var e = we, t = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), a = Symbol.for("react.provider"), s = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), c = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), d = Symbol.for("react.lazy"), g = Symbol.for("react.offscreen"), f = Symbol.iterator, m = "@@iterator";
    function v(b) {
      if (b === null || typeof b != "object")
        return null;
      var I = f && b[f] || b[m];
      return typeof I == "function" ? I : null;
    }
    var E = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function w(b) {
      {
        for (var I = arguments.length, G = new Array(I > 1 ? I - 1 : 0), ne = 1; ne < I; ne++)
          G[ne - 1] = arguments[ne];
        M("error", b, G);
      }
    }
    function M(b, I, G) {
      {
        var ne = E.ReactDebugCurrentFrame, le = ne.getStackAddendum();
        le !== "" && (I += "%s", G = G.concat([le]));
        var ce = G.map(function(se) {
          return String(se);
        });
        ce.unshift("Warning: " + I), Function.prototype.apply.call(console[b], console, ce);
      }
    }
    var O = !1, y = !1, C = !1, _ = !1, F = !1, L;
    L = Symbol.for("react.module.reference");
    function N(b) {
      return !!(typeof b == "string" || typeof b == "function" || b === r || b === i || F || b === o || b === u || b === c || _ || b === g || O || y || C || typeof b == "object" && b !== null && (b.$$typeof === d || b.$$typeof === p || b.$$typeof === a || b.$$typeof === s || b.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      b.$$typeof === L || b.getModuleId !== void 0));
    }
    function R(b, I, G) {
      var ne = b.displayName;
      if (ne)
        return ne;
      var le = I.displayName || I.name || "";
      return le !== "" ? G + "(" + le + ")" : G;
    }
    function W(b) {
      return b.displayName || "Context";
    }
    function V(b) {
      if (b == null)
        return null;
      if (typeof b.tag == "number" && w("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof b == "function")
        return b.displayName || b.name || null;
      if (typeof b == "string")
        return b;
      switch (b) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case i:
          return "Profiler";
        case o:
          return "StrictMode";
        case u:
          return "Suspense";
        case c:
          return "SuspenseList";
      }
      if (typeof b == "object")
        switch (b.$$typeof) {
          case s:
            var I = b;
            return W(I) + ".Consumer";
          case a:
            var G = b;
            return W(G._context) + ".Provider";
          case l:
            return R(b, b.render, "ForwardRef");
          case p:
            var ne = b.displayName || null;
            return ne !== null ? ne : V(b.type) || "Memo";
          case d: {
            var le = b, ce = le._payload, se = le._init;
            try {
              return V(se(ce));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var z = Object.assign, Z = 0, K, X, te, J, P, D, H;
    function S() {
    }
    S.__reactDisabledLog = !0;
    function $() {
      {
        if (Z === 0) {
          K = console.log, X = console.info, te = console.warn, J = console.error, P = console.group, D = console.groupCollapsed, H = console.groupEnd;
          var b = {
            configurable: !0,
            enumerable: !0,
            value: S,
            writable: !0
          };
          Object.defineProperties(console, {
            info: b,
            log: b,
            warn: b,
            error: b,
            group: b,
            groupCollapsed: b,
            groupEnd: b
          });
        }
        Z++;
      }
    }
    function x() {
      {
        if (Z--, Z === 0) {
          var b = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: z({}, b, {
              value: K
            }),
            info: z({}, b, {
              value: X
            }),
            warn: z({}, b, {
              value: te
            }),
            error: z({}, b, {
              value: J
            }),
            group: z({}, b, {
              value: P
            }),
            groupCollapsed: z({}, b, {
              value: D
            }),
            groupEnd: z({}, b, {
              value: H
            })
          });
        }
        Z < 0 && w("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var j = E.ReactCurrentDispatcher, U;
    function T(b, I, G) {
      {
        if (U === void 0)
          try {
            throw Error();
          } catch (le) {
            var ne = le.stack.trim().match(/\n( *(at )?)/);
            U = ne && ne[1] || "";
          }
        return `
` + U + b;
      }
    }
    var q = !1, A;
    {
      var Y = typeof WeakMap == "function" ? WeakMap : Map;
      A = new Y();
    }
    function B(b, I) {
      if (!b || q)
        return "";
      {
        var G = A.get(b);
        if (G !== void 0)
          return G;
      }
      var ne;
      q = !0;
      var le = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var ce;
      ce = j.current, j.current = null, $();
      try {
        if (I) {
          var se = function() {
            throw Error();
          };
          if (Object.defineProperty(se.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(se, []);
            } catch (je) {
              ne = je;
            }
            Reflect.construct(b, [], se);
          } else {
            try {
              se.call();
            } catch (je) {
              ne = je;
            }
            b.call(se.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (je) {
            ne = je;
          }
          b();
        }
      } catch (je) {
        if (je && ne && typeof je.stack == "string") {
          for (var ie = je.stack.split(`
`), Se = ne.stack.split(`
`), de = ie.length - 1, he = Se.length - 1; de >= 1 && he >= 0 && ie[de] !== Se[he]; )
            he--;
          for (; de >= 1 && he >= 0; de--, he--)
            if (ie[de] !== Se[he]) {
              if (de !== 1 || he !== 1)
                do
                  if (de--, he--, he < 0 || ie[de] !== Se[he]) {
                    var Ve = `
` + ie[de].replace(" at new ", " at ");
                    return b.displayName && Ve.includes("<anonymous>") && (Ve = Ve.replace("<anonymous>", b.displayName)), typeof b == "function" && A.set(b, Ve), Ve;
                  }
                while (de >= 1 && he >= 0);
              break;
            }
        }
      } finally {
        q = !1, j.current = ce, x(), Error.prepareStackTrace = le;
      }
      var xt = b ? b.displayName || b.name : "", vt = xt ? T(xt) : "";
      return typeof b == "function" && A.set(b, vt), vt;
    }
    function ue(b, I, G) {
      return B(b, !1);
    }
    function fe(b) {
      var I = b.prototype;
      return !!(I && I.isReactComponent);
    }
    function oe(b, I, G) {
      if (b == null)
        return "";
      if (typeof b == "function")
        return B(b, fe(b));
      if (typeof b == "string")
        return T(b);
      switch (b) {
        case u:
          return T("Suspense");
        case c:
          return T("SuspenseList");
      }
      if (typeof b == "object")
        switch (b.$$typeof) {
          case l:
            return ue(b.render);
          case p:
            return oe(b.type, I, G);
          case d: {
            var ne = b, le = ne._payload, ce = ne._init;
            try {
              return oe(ce(le), I, G);
            } catch {
            }
          }
        }
      return "";
    }
    var Ae = Object.prototype.hasOwnProperty, Ze = {}, Ge = E.ReactDebugCurrentFrame;
    function Ie(b) {
      if (b) {
        var I = b._owner, G = oe(b.type, b._source, I ? I.type : null);
        Ge.setExtraStackFrame(G);
      } else
        Ge.setExtraStackFrame(null);
    }
    function et(b, I, G, ne, le) {
      {
        var ce = Function.call.bind(Ae);
        for (var se in b)
          if (ce(b, se)) {
            var ie = void 0;
            try {
              if (typeof b[se] != "function") {
                var Se = Error((ne || "React class") + ": " + G + " type `" + se + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof b[se] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw Se.name = "Invariant Violation", Se;
              }
              ie = b[se](I, se, ne, G, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (de) {
              ie = de;
            }
            ie && !(ie instanceof Error) && (Ie(le), w("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", ne || "React class", G, se, typeof ie), Ie(null)), ie instanceof Error && !(ie.message in Ze) && (Ze[ie.message] = !0, Ie(le), w("Failed %s type: %s", G, ie.message), Ie(null));
          }
      }
    }
    var Ye = Array.isArray;
    function _e(b) {
      return Ye(b);
    }
    function Qe(b) {
      {
        var I = typeof Symbol == "function" && Symbol.toStringTag, G = I && b[Symbol.toStringTag] || b.constructor.name || "Object";
        return G;
      }
    }
    function at(b) {
      try {
        return Pe(b), !1;
      } catch {
        return !0;
      }
    }
    function Pe(b) {
      return "" + b;
    }
    function Me(b) {
      if (at(b))
        return w("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Qe(b)), Pe(b);
    }
    var Je = E.ReactCurrentOwner, We = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, Re, nt;
    function De(b) {
      if (Ae.call(b, "ref")) {
        var I = Object.getOwnPropertyDescriptor(b, "ref").get;
        if (I && I.isReactWarning)
          return !1;
      }
      return b.ref !== void 0;
    }
    function yt(b) {
      if (Ae.call(b, "key")) {
        var I = Object.getOwnPropertyDescriptor(b, "key").get;
        if (I && I.isReactWarning)
          return !1;
      }
      return b.key !== void 0;
    }
    function ot(b, I) {
      typeof b.ref == "string" && Je.current;
    }
    function st(b, I) {
      {
        var G = function() {
          Re || (Re = !0, w("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", I));
        };
        G.isReactWarning = !0, Object.defineProperty(b, "key", {
          get: G,
          configurable: !0
        });
      }
    }
    function ct(b, I) {
      {
        var G = function() {
          nt || (nt = !0, w("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", I));
        };
        G.isReactWarning = !0, Object.defineProperty(b, "ref", {
          get: G,
          configurable: !0
        });
      }
    }
    var bt = function(b, I, G, ne, le, ce, se) {
      var ie = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: b,
        key: I,
        ref: G,
        props: se,
        // Record the component responsible for creating this element.
        _owner: ce
      };
      return ie._store = {}, Object.defineProperty(ie._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(ie, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ne
      }), Object.defineProperty(ie, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: le
      }), Object.freeze && (Object.freeze(ie.props), Object.freeze(ie)), ie;
    };
    function pt(b, I, G, ne, le) {
      {
        var ce, se = {}, ie = null, Se = null;
        G !== void 0 && (Me(G), ie = "" + G), yt(I) && (Me(I.key), ie = "" + I.key), De(I) && (Se = I.ref, ot(I));
        for (ce in I)
          Ae.call(I, ce) && !We.hasOwnProperty(ce) && (se[ce] = I[ce]);
        if (b && b.defaultProps) {
          var de = b.defaultProps;
          for (ce in de)
            se[ce] === void 0 && (se[ce] = de[ce]);
        }
        if (ie || Se) {
          var he = typeof b == "function" ? b.displayName || b.name || "Unknown" : b;
          ie && st(se, he), Se && ct(se, he);
        }
        return bt(b, ie, Se, le, ne, Je.current, se);
      }
    }
    var dt = E.ReactCurrentOwner, tt = E.ReactDebugCurrentFrame;
    function Xe(b) {
      if (b) {
        var I = b._owner, G = oe(b.type, b._source, I ? I.type : null);
        tt.setExtraStackFrame(G);
      } else
        tt.setExtraStackFrame(null);
    }
    var wt;
    wt = !1;
    function Ct(b) {
      return typeof b == "object" && b !== null && b.$$typeof === t;
    }
    function ft() {
      {
        if (dt.current) {
          var b = V(dt.current.type);
          if (b)
            return `

Check the render method of \`` + b + "`.";
        }
        return "";
      }
    }
    function bn(b) {
      return "";
    }
    var ht = {};
    function wn(b) {
      {
        var I = ft();
        if (!I) {
          var G = typeof b == "string" ? b : b.displayName || b.name;
          G && (I = `

Check the top-level render call using <` + G + ">.");
        }
        return I;
      }
    }
    function gt(b, I) {
      {
        if (!b._store || b._store.validated || b.key != null)
          return;
        b._store.validated = !0;
        var G = wn(I);
        if (ht[G])
          return;
        ht[G] = !0;
        var ne = "";
        b && b._owner && b._owner !== dt.current && (ne = " It was passed a child from " + V(b._owner.type) + "."), Xe(b), w('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', G, ne), Xe(null);
      }
    }
    function Mt(b, I) {
      {
        if (typeof b != "object")
          return;
        if (_e(b))
          for (var G = 0; G < b.length; G++) {
            var ne = b[G];
            Ct(ne) && gt(ne, I);
          }
        else if (Ct(b))
          b._store && (b._store.validated = !0);
        else if (b) {
          var le = v(b);
          if (typeof le == "function" && le !== b.entries)
            for (var ce = le.call(b), se; !(se = ce.next()).done; )
              Ct(se.value) && gt(se.value, I);
        }
      }
    }
    function ir(b) {
      {
        var I = b.type;
        if (I == null || typeof I == "string")
          return;
        var G;
        if (typeof I == "function")
          G = I.propTypes;
        else if (typeof I == "object" && (I.$$typeof === l || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        I.$$typeof === p))
          G = I.propTypes;
        else
          return;
        if (G) {
          var ne = V(I);
          et(G, b.props, "prop", ne, b);
        } else if (I.PropTypes !== void 0 && !wt) {
          wt = !0;
          var le = V(I);
          w("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", le || "Unknown");
        }
        typeof I.getDefaultProps == "function" && !I.getDefaultProps.isReactClassApproved && w("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function mt(b) {
      {
        for (var I = Object.keys(b.props), G = 0; G < I.length; G++) {
          var ne = I[G];
          if (ne !== "children" && ne !== "key") {
            Xe(b), w("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", ne), Xe(null);
            break;
          }
        }
        b.ref !== null && (Xe(b), w("Invalid attribute `ref` supplied to `React.Fragment`."), Xe(null));
      }
    }
    var re = {};
    function vo(b, I, G, ne, le, ce) {
      {
        var se = N(b);
        if (!se) {
          var ie = "";
          (b === void 0 || typeof b == "object" && b !== null && Object.keys(b).length === 0) && (ie += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var Se = bn();
          Se ? ie += Se : ie += ft();
          var de;
          b === null ? de = "null" : _e(b) ? de = "array" : b !== void 0 && b.$$typeof === t ? (de = "<" + (V(b.type) || "Unknown") + " />", ie = " Did you accidentally export a JSX literal instead of a component?") : de = typeof b, w("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", de, ie);
        }
        var he = pt(b, I, G, le, ce);
        if (he == null)
          return he;
        if (se) {
          var Ve = I.children;
          if (Ve !== void 0)
            if (ne)
              if (_e(Ve)) {
                for (var xt = 0; xt < Ve.length; xt++)
                  Mt(Ve[xt], b);
                Object.freeze && Object.freeze(Ve);
              } else
                w("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Mt(Ve, b);
        }
        if (Ae.call(I, "key")) {
          var vt = V(b), je = Object.keys(I).filter(function(Li) {
            return Li !== "key";
          }), sr = je.length > 0 ? "{key: someKey, " + je.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!re[vt + sr]) {
            var ki = je.length > 0 ? "{" + je.join(": ..., ") + ": ...}" : "{}";
            w(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, sr, vt, ki, vt), re[vt + sr] = !0;
          }
        }
        return b === r ? mt(he) : ir(he), he;
      }
    }
    function Ci(b, I, G) {
      return vo(b, I, G, !0);
    }
    function xi(b, I, G) {
      return vo(b, I, G, !1);
    }
    var Oi = xi, Ei = Ci;
    Bh.Fragment = r, Bh.jsx = Oi, Bh.jsxs = Ei;
  }()), Bh;
}
process.env.NODE_ENV === "production" ? AE.exports = nle() : AE.exports = rle();
var So = AE.exports;
Ke({});
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function FT(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function Ho(e) {
  var t, n;
  return FT(e) === !1 ? !1 : (t = e.constructor, t === void 0 ? !0 : (n = t.prototype, !(FT(n) === !1 || n.hasOwnProperty("isPrototypeOf") === !1)));
}
var Q5 = Symbol.for("immer-nothing"), zT = Symbol.for("immer-draftable"), Gi = Symbol.for("immer-state"), ole = process.env.NODE_ENV !== "production" ? [
  // All error codes, starting by 0:
  function(e) {
    return `The plugin for '${e}' has not been loaded into Immer. To enable the plugin, import and call \`enable${e}()\` when initializing your application.`;
  },
  function(e) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${e}'`;
  },
  "This object has been frozen and should not be mutated",
  function(e) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + e;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(e) {
    return `'current' expects a draft, got: ${e}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(e) {
    return `'original' expects a draft, got: ${e}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function li(e, ...t) {
  if (process.env.NODE_ENV !== "production") {
    const n = ole[e], r = typeof n == "function" ? n.apply(null, t) : n;
    throw new Error(`[Immer] ${r}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var mc = Object.getPrototypeOf;
function Iu(e) {
  return !!e && !!e[Gi];
}
function Ru(e) {
  var t;
  return e ? e4(e) || Array.isArray(e) || !!e[zT] || !!((t = e.constructor) != null && t[zT]) || Fb(e) || zb(e) : !1;
}
var ile = Object.prototype.constructor.toString();
function e4(e) {
  if (!e || typeof e != "object")
    return !1;
  const t = mc(e);
  if (t === null)
    return !0;
  const n = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
  return n === Object ? !0 : typeof n == "function" && Function.toString.call(n) === ile;
}
function av(e, t) {
  Nb(e) === 0 ? Reflect.ownKeys(e).forEach((n) => {
    t(n, e[n], e);
  }) : e.forEach((n, r) => t(r, n, e));
}
function Nb(e) {
  const t = e[Gi];
  return t ? t.type_ : Array.isArray(e) ? 1 : Fb(e) ? 2 : zb(e) ? 3 : 0;
}
function IE(e, t) {
  return Nb(e) === 2 ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t);
}
function t4(e, t, n) {
  const r = Nb(e);
  r === 2 ? e.set(t, n) : r === 3 ? e.add(n) : e[t] = n;
}
function sle(e, t) {
  return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && t !== t;
}
function Fb(e) {
  return e instanceof Map;
}
function zb(e) {
  return e instanceof Set;
}
function Ql(e) {
  return e.copy_ || e.base_;
}
function RE(e, t) {
  if (Fb(e))
    return new Map(e);
  if (zb(e))
    return new Set(e);
  if (Array.isArray(e))
    return Array.prototype.slice.call(e);
  const n = e4(e);
  if (t === !0 || t === "class_only" && !n) {
    const r = Object.getOwnPropertyDescriptors(e);
    delete r[Gi];
    let o = Reflect.ownKeys(r);
    for (let i = 0; i < o.length; i++) {
      const a = o[i], s = r[a];
      s.writable === !1 && (s.writable = !0, s.configurable = !0), (s.get || s.set) && (r[a] = {
        configurable: !0,
        writable: !0,
        // could live with !!desc.set as well here...
        enumerable: s.enumerable,
        value: e[a]
      });
    }
    return Object.create(mc(e), r);
  } else {
    const r = mc(e);
    if (r !== null && n)
      return { ...e };
    const o = Object.create(r);
    return Object.assign(o, e);
  }
}
function BL(e, t = !1) {
  return Ub(e) || Iu(e) || !Ru(e) || (Nb(e) > 1 && (e.set = e.add = e.clear = e.delete = ale), Object.freeze(e), t && Object.entries(e).forEach(([n, r]) => BL(r, !0))), e;
}
function ale() {
  li(2);
}
function Ub(e) {
  return Object.isFrozen(e);
}
var lle = {};
function Bu(e) {
  const t = lle[e];
  return t || li(0, e), t;
}
var Bd;
function n4() {
  return Bd;
}
function ule(e, t) {
  return {
    drafts_: [],
    parent_: e,
    immer_: t,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0
  };
}
function UT(e, t) {
  t && (Bu("Patches"), e.patches_ = [], e.inversePatches_ = [], e.patchListener_ = t);
}
function BE(e) {
  NE(e), e.drafts_.forEach(cle), e.drafts_ = null;
}
function NE(e) {
  e === Bd && (Bd = e.parent_);
}
function HT(e) {
  return Bd = ule(Bd, e);
}
function cle(e) {
  const t = e[Gi];
  t.type_ === 0 || t.type_ === 1 ? t.revoke_() : t.revoked_ = !0;
}
function $T(e, t) {
  t.unfinalizedDrafts_ = t.drafts_.length;
  const n = t.drafts_[0];
  return e !== void 0 && e !== n ? (n[Gi].modified_ && (BE(t), li(4)), Ru(e) && (e = lv(t, e), t.parent_ || uv(t, e)), t.patches_ && Bu("Patches").generateReplacementPatches_(
    n[Gi].base_,
    e,
    t.patches_,
    t.inversePatches_
  )) : e = lv(t, n, []), BE(t), t.patches_ && t.patchListener_(t.patches_, t.inversePatches_), e !== Q5 ? e : void 0;
}
function lv(e, t, n) {
  if (Ub(t))
    return t;
  const r = t[Gi];
  if (!r)
    return av(
      t,
      (o, i) => WT(e, r, t, o, i, n)
    ), t;
  if (r.scope_ !== e)
    return t;
  if (!r.modified_)
    return uv(e, r.base_, !0), r.base_;
  if (!r.finalized_) {
    r.finalized_ = !0, r.scope_.unfinalizedDrafts_--;
    const o = r.copy_;
    let i = o, a = !1;
    r.type_ === 3 && (i = new Set(o), o.clear(), a = !0), av(
      i,
      (s, l) => WT(e, r, o, s, l, n, a)
    ), uv(e, o, !1), n && e.patches_ && Bu("Patches").generatePatches_(
      r,
      n,
      e.patches_,
      e.inversePatches_
    );
  }
  return r.copy_;
}
function WT(e, t, n, r, o, i, a) {
  if (process.env.NODE_ENV !== "production" && o === n && li(5), Iu(o)) {
    const s = i && t && t.type_ !== 3 && // Set objects are atomic since they have no keys.
    !IE(t.assigned_, r) ? i.concat(r) : void 0, l = lv(e, o, s);
    if (t4(n, r, l), Iu(l))
      e.canAutoFreeze_ = !1;
    else
      return;
  } else a && n.add(o);
  if (Ru(o) && !Ub(o)) {
    if (!e.immer_.autoFreeze_ && e.unfinalizedDrafts_ < 1)
      return;
    lv(e, o), (!t || !t.scope_.parent_) && typeof r != "symbol" && Object.prototype.propertyIsEnumerable.call(n, r) && uv(e, o);
  }
}
function uv(e, t, n = !1) {
  !e.parent_ && e.immer_.autoFreeze_ && e.canAutoFreeze_ && BL(t, n);
}
function ple(e, t) {
  const n = Array.isArray(e), r = {
    type_: n ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: t ? t.scope_ : n4(),
    // True for both shallow and deep changes.
    modified_: !1,
    // Used during finalization.
    finalized_: !1,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: t,
    // The base state.
    base_: e,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: !1
  };
  let o = r, i = NL;
  n && (o = [r], i = Nd);
  const { revoke: a, proxy: s } = Proxy.revocable(o, i);
  return r.draft_ = s, r.revoke_ = a, s;
}
var NL = {
  get(e, t) {
    if (t === Gi)
      return e;
    const n = Ql(e);
    if (!IE(n, t))
      return dle(e, n, t);
    const r = n[t];
    return e.finalized_ || !Ru(r) ? r : r === V0(e.base_, t) ? (Z0(e), e.copy_[t] = zE(r, e)) : r;
  },
  has(e, t) {
    return t in Ql(e);
  },
  ownKeys(e) {
    return Reflect.ownKeys(Ql(e));
  },
  set(e, t, n) {
    const r = r4(Ql(e), t);
    if (r != null && r.set)
      return r.set.call(e.draft_, n), !0;
    if (!e.modified_) {
      const o = V0(Ql(e), t), i = o == null ? void 0 : o[Gi];
      if (i && i.base_ === n)
        return e.copy_[t] = n, e.assigned_[t] = !1, !0;
      if (sle(n, o) && (n !== void 0 || IE(e.base_, t)))
        return !0;
      Z0(e), FE(e);
    }
    return e.copy_[t] === n && // special case: handle new props with value 'undefined'
    (n !== void 0 || t in e.copy_) || // special case: NaN
    Number.isNaN(n) && Number.isNaN(e.copy_[t]) || (e.copy_[t] = n, e.assigned_[t] = !0), !0;
  },
  deleteProperty(e, t) {
    return V0(e.base_, t) !== void 0 || t in e.base_ ? (e.assigned_[t] = !1, Z0(e), FE(e)) : delete e.assigned_[t], e.copy_ && delete e.copy_[t], !0;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(e, t) {
    const n = Ql(e), r = Reflect.getOwnPropertyDescriptor(n, t);
    return r && {
      writable: !0,
      configurable: e.type_ !== 1 || t !== "length",
      enumerable: r.enumerable,
      value: n[t]
    };
  },
  defineProperty() {
    li(11);
  },
  getPrototypeOf(e) {
    return mc(e.base_);
  },
  setPrototypeOf() {
    li(12);
  }
}, Nd = {};
av(NL, (e, t) => {
  Nd[e] = function() {
    return arguments[0] = arguments[0][0], t.apply(this, arguments);
  };
});
Nd.deleteProperty = function(e, t) {
  return process.env.NODE_ENV !== "production" && isNaN(parseInt(t)) && li(13), Nd.set.call(this, e, t, void 0);
};
Nd.set = function(e, t, n) {
  return process.env.NODE_ENV !== "production" && t !== "length" && isNaN(parseInt(t)) && li(14), NL.set.call(this, e[0], t, n, e[0]);
};
function V0(e, t) {
  const n = e[Gi];
  return (n ? Ql(n) : e)[t];
}
function dle(e, t, n) {
  var r;
  const o = r4(t, n);
  return o ? "value" in o ? o.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (r = o.get) == null ? void 0 : r.call(e.draft_)
  ) : void 0;
}
function r4(e, t) {
  if (!(t in e))
    return;
  let n = mc(e);
  for (; n; ) {
    const r = Object.getOwnPropertyDescriptor(n, t);
    if (r)
      return r;
    n = mc(n);
  }
}
function FE(e) {
  e.modified_ || (e.modified_ = !0, e.parent_ && FE(e.parent_));
}
function Z0(e) {
  e.copy_ || (e.copy_ = RE(
    e.base_,
    e.scope_.immer_.useStrictShallowCopy_
  ));
}
var fle = class {
  constructor(e) {
    this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.produce = (t, n, r) => {
      if (typeof t == "function" && typeof n != "function") {
        const i = n;
        n = t;
        const a = this;
        return function(s = i, ...l) {
          return a.produce(s, (u) => n.call(this, u, ...l));
        };
      }
      typeof n != "function" && li(6), r !== void 0 && typeof r != "function" && li(7);
      let o;
      if (Ru(t)) {
        const i = HT(this), a = zE(t, void 0);
        let s = !0;
        try {
          o = n(a), s = !1;
        } finally {
          s ? BE(i) : NE(i);
        }
        return UT(i, r), $T(o, i);
      } else if (!t || typeof t != "object") {
        if (o = n(t), o === void 0 && (o = t), o === Q5 && (o = void 0), this.autoFreeze_ && BL(o, !0), r) {
          const i = [], a = [];
          Bu("Patches").generateReplacementPatches_(t, o, i, a), r(i, a);
        }
        return o;
      } else
        li(1, t);
    }, this.produceWithPatches = (t, n) => {
      if (typeof t == "function")
        return (i, ...a) => this.produceWithPatches(i, (s) => t(s, ...a));
      let r, o;
      return [this.produce(t, n, (i, a) => {
        r = i, o = a;
      }), r, o];
    }, typeof (e == null ? void 0 : e.autoFreeze) == "boolean" && this.setAutoFreeze(e.autoFreeze), typeof (e == null ? void 0 : e.useStrictShallowCopy) == "boolean" && this.setUseStrictShallowCopy(e.useStrictShallowCopy);
  }
  createDraft(e) {
    Ru(e) || li(8), Iu(e) && (e = hle(e));
    const t = HT(this), n = zE(e, void 0);
    return n[Gi].isManual_ = !0, NE(t), n;
  }
  finishDraft(e, t) {
    const n = e && e[Gi];
    (!n || !n.isManual_) && li(9);
    const { scope_: r } = n;
    return UT(r, t), $T(void 0, r);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(e) {
    this.autoFreeze_ = e;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(e) {
    this.useStrictShallowCopy_ = e;
  }
  applyPatches(e, t) {
    let n;
    for (n = t.length - 1; n >= 0; n--) {
      const o = t[n];
      if (o.path.length === 0 && o.op === "replace") {
        e = o.value;
        break;
      }
    }
    n > -1 && (t = t.slice(n + 1));
    const r = Bu("Patches").applyPatches_;
    return Iu(e) ? r(e, t) : this.produce(
      e,
      (o) => r(o, t)
    );
  }
};
function zE(e, t) {
  const n = Fb(e) ? Bu("MapSet").proxyMap_(e, t) : zb(e) ? Bu("MapSet").proxySet_(e, t) : ple(e, t);
  return (t ? t.scope_ : n4()).drafts_.push(n), n;
}
function hle(e) {
  return Iu(e) || li(10, e), o4(e);
}
function o4(e) {
  if (!Ru(e) || Ub(e))
    return e;
  const t = e[Gi];
  let n;
  if (t) {
    if (!t.modified_)
      return t.base_;
    t.finalized_ = !0, n = RE(e, t.scope_.immer_.useStrictShallowCopy_);
  } else
    n = RE(e, !0);
  return av(n, (r, o) => {
    t4(n, r, o4(o));
  }), t && (t.finalized_ = !1), n;
}
var Ki = new fle(), FL = Ki.produce;
Ki.produceWithPatches.bind(
  Ki
);
Ki.setAutoFreeze.bind(Ki);
Ki.setUseStrictShallowCopy.bind(Ki);
Ki.applyPatches.bind(Ki);
var VT = Ki.createDraft.bind(Ki), ZT = Ki.finishDraft.bind(Ki), Ue = {
  ancestors(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = Ue.levels(e, t);
    return n ? r = r.slice(1) : r = r.slice(0, -1), r;
  },
  common(e, t) {
    for (var n = [], r = 0; r < e.length && r < t.length; r++) {
      var o = e[r], i = t[r];
      if (o !== i)
        break;
      n.push(o);
    }
    return n;
  },
  compare(e, t) {
    for (var n = Math.min(e.length, t.length), r = 0; r < n; r++) {
      if (e[r] < t[r]) return -1;
      if (e[r] > t[r]) return 1;
    }
    return 0;
  },
  endsAfter(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return Ue.equals(r, o) && i > a;
  },
  endsAt(e, t) {
    var n = e.length, r = e.slice(0, n), o = t.slice(0, n);
    return Ue.equals(r, o);
  },
  endsBefore(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return Ue.equals(r, o) && i < a;
  },
  equals(e, t) {
    return e.length === t.length && e.every((n, r) => n === t[r]);
  },
  hasPrevious(e) {
    return e[e.length - 1] > 0;
  },
  isAfter(e, t) {
    return Ue.compare(e, t) === 1;
  },
  isAncestor(e, t) {
    return e.length < t.length && Ue.compare(e, t) === 0;
  },
  isBefore(e, t) {
    return Ue.compare(e, t) === -1;
  },
  isChild(e, t) {
    return e.length === t.length + 1 && Ue.compare(e, t) === 0;
  },
  isCommon(e, t) {
    return e.length <= t.length && Ue.compare(e, t) === 0;
  },
  isDescendant(e, t) {
    return e.length > t.length && Ue.compare(e, t) === 0;
  },
  isParent(e, t) {
    return e.length + 1 === t.length && Ue.compare(e, t) === 0;
  },
  isPath(e) {
    return Array.isArray(e) && (e.length === 0 || typeof e[0] == "number");
  },
  isSibling(e, t) {
    if (e.length !== t.length)
      return !1;
    var n = e.slice(0, -1), r = t.slice(0, -1), o = e[e.length - 1], i = t[t.length - 1];
    return o !== i && Ue.equals(n, r);
  },
  levels(e) {
    for (var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = [], o = 0; o <= e.length; o++)
      r.push(e.slice(0, o));
    return n && r.reverse(), r;
  },
  next(e) {
    if (e.length === 0)
      throw new Error("Cannot get the next path of a root path [".concat(e, "], because it has no next index."));
    var t = e[e.length - 1];
    return e.slice(0, -1).concat(t + 1);
  },
  operationCanTransformPath(e) {
    switch (e.type) {
      case "insert_node":
      case "remove_node":
      case "merge_node":
      case "split_node":
      case "move_node":
        return !0;
      default:
        return !1;
    }
  },
  parent(e) {
    if (e.length === 0)
      throw new Error("Cannot get the parent path of the root path [".concat(e, "]."));
    return e.slice(0, -1);
  },
  previous(e) {
    if (e.length === 0)
      throw new Error("Cannot get the previous path of a root path [".concat(e, "], because it has no previous index."));
    var t = e[e.length - 1];
    if (t <= 0)
      throw new Error("Cannot get the previous path of a first child path [".concat(e, "] because it would result in a negative index."));
    return e.slice(0, -1).concat(t - 1);
  },
  relative(e, t) {
    if (!Ue.isAncestor(t, e) && !Ue.equals(e, t))
      throw new Error("Cannot get the relative path of [".concat(e, "] inside ancestor [").concat(t, "], because it is not above or equal to the path."));
    return e.slice(t.length);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!e) return null;
    var r = [...e], {
      affinity: o = "forward"
    } = n;
    if (e.length === 0)
      return r;
    switch (t.type) {
      case "insert_node": {
        var {
          path: i
        } = t;
        (Ue.equals(i, r) || Ue.endsBefore(i, r) || Ue.isAncestor(i, r)) && (r[i.length - 1] += 1);
        break;
      }
      case "remove_node": {
        var {
          path: a
        } = t;
        if (Ue.equals(a, r) || Ue.isAncestor(a, r))
          return null;
        Ue.endsBefore(a, r) && (r[a.length - 1] -= 1);
        break;
      }
      case "merge_node": {
        var {
          path: s,
          position: l
        } = t;
        Ue.equals(s, r) || Ue.endsBefore(s, r) ? r[s.length - 1] -= 1 : Ue.isAncestor(s, r) && (r[s.length - 1] -= 1, r[s.length] += l);
        break;
      }
      case "split_node": {
        var {
          path: u,
          position: c
        } = t;
        if (Ue.equals(u, r)) {
          if (o === "forward")
            r[r.length - 1] += 1;
          else if (o !== "backward") return null;
        } else Ue.endsBefore(u, r) ? r[u.length - 1] += 1 : Ue.isAncestor(u, r) && e[u.length] >= c && (r[u.length - 1] += 1, r[u.length] -= c);
        break;
      }
      case "move_node": {
        var {
          path: p,
          newPath: d
        } = t;
        if (Ue.equals(p, d))
          return r;
        if (Ue.isAncestor(p, r) || Ue.equals(p, r)) {
          var g = d.slice();
          return Ue.endsBefore(p, d) && p.length < d.length && (g[p.length - 1] -= 1), g.concat(r.slice(p.length));
        } else Ue.isSibling(p, d) && (Ue.isAncestor(d, r) || Ue.equals(d, r)) ? Ue.endsBefore(p, r) ? r[p.length - 1] -= 1 : r[p.length - 1] += 1 : Ue.endsBefore(d, r) || Ue.equals(d, r) || Ue.isAncestor(d, r) ? (Ue.endsBefore(p, r) && (r[p.length - 1] -= 1), r[d.length - 1] += 1) : Ue.endsBefore(p, r) && (Ue.equals(d, r) && (r[d.length - 1] += 1), r[p.length - 1] -= 1);
        break;
      }
    }
    return r;
  }
};
function Fd(e) {
  "@babel/helpers - typeof";
  return Fd = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Fd(e);
}
function gle(e, t) {
  if (Fd(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (Fd(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function mle(e) {
  var t = gle(e, "string");
  return Fd(t) === "symbol" ? t : String(t);
}
function kc(e, t, n) {
  return t = mle(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function qT(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Jc(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? qT(Object(n), !0).forEach(function(r) {
      kc(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : qT(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var vle = (e, t, n) => {
  switch (n.type) {
    case "insert_node": {
      var {
        path: r,
        node: o
      } = n, i = Pt.parent(e, r), a = r[r.length - 1];
      if (a > i.children.length)
        throw new Error('Cannot apply an "insert_node" operation at path ['.concat(r, "] because the destination is past the end of the node."));
      if (i.children.splice(a, 0, o), t)
        for (var [s, l] of Ht.points(t))
          t[l] = mr.transform(s, n);
      break;
    }
    case "insert_text": {
      var {
        path: u,
        offset: c,
        text: p
      } = n;
      if (p.length === 0) break;
      var d = Pt.leaf(e, u), g = d.text.slice(0, c), f = d.text.slice(c);
      if (d.text = g + p + f, t)
        for (var [m, v] of Ht.points(t))
          t[v] = mr.transform(m, n);
      break;
    }
    case "merge_node": {
      var {
        path: E
      } = n, w = Pt.get(e, E), M = Ue.previous(E), O = Pt.get(e, M), y = Pt.parent(e, E), C = E[E.length - 1];
      if (io.isText(w) && io.isText(O))
        O.text += w.text;
      else if (!io.isText(w) && !io.isText(O))
        O.children.push(...w.children);
      else
        throw new Error('Cannot apply a "merge_node" operation at path ['.concat(E, "] to nodes of different interfaces: ").concat(Mi.stringify(w), " ").concat(Mi.stringify(O)));
      if (y.children.splice(C, 1), t)
        for (var [_, F] of Ht.points(t))
          t[F] = mr.transform(_, n);
      break;
    }
    case "move_node": {
      var {
        path: L,
        newPath: N
      } = n;
      if (Ue.isAncestor(L, N))
        throw new Error("Cannot move a path [".concat(L, "] to new path [").concat(N, "] because the destination is inside itself."));
      var R = Pt.get(e, L), W = Pt.parent(e, L), V = L[L.length - 1];
      W.children.splice(V, 1);
      var z = Ue.transform(L, n), Z = Pt.get(e, Ue.parent(z)), K = z[z.length - 1];
      if (Z.children.splice(K, 0, R), t)
        for (var [X, te] of Ht.points(t))
          t[te] = mr.transform(X, n);
      break;
    }
    case "remove_node": {
      var {
        path: J
      } = n, P = J[J.length - 1], D = Pt.parent(e, J);
      if (D.children.splice(P, 1), t)
        for (var [H, S] of Ht.points(t)) {
          var $ = mr.transform(H, n);
          if (t != null && $ != null)
            t[S] = $;
          else {
            var x = void 0, j = void 0;
            for (var [U, T] of Pt.texts(e))
              if (Ue.compare(T, J) === -1)
                x = [U, T];
              else {
                j = [U, T];
                break;
              }
            var q = !1;
            x && j && (Ue.equals(j[1], J) ? q = !Ue.hasPrevious(j[1]) : q = Ue.common(x[1], J).length < Ue.common(j[1], J).length), x && !q ? (H.path = x[1], H.offset = x[0].text.length) : j ? (H.path = j[1], H.offset = 0) : t = null;
          }
        }
      break;
    }
    case "remove_text": {
      var {
        path: A,
        offset: Y,
        text: B
      } = n;
      if (B.length === 0) break;
      var ue = Pt.leaf(e, A), fe = ue.text.slice(0, Y), oe = ue.text.slice(Y + B.length);
      if (ue.text = fe + oe, t)
        for (var [Ae, Ze] of Ht.points(t))
          t[Ze] = mr.transform(Ae, n);
      break;
    }
    case "set_node": {
      var {
        path: Ge,
        properties: Ie,
        newProperties: et
      } = n;
      if (Ge.length === 0)
        throw new Error("Cannot set properties on the root node!");
      var Ye = Pt.get(e, Ge);
      for (var _e in et) {
        if (_e === "children" || _e === "text")
          throw new Error('Cannot set the "'.concat(_e, '" property of nodes!'));
        var Qe = et[_e];
        Qe == null ? delete Ye[_e] : Ye[_e] = Qe;
      }
      for (var at in Ie)
        et.hasOwnProperty(at) || delete Ye[at];
      break;
    }
    case "set_selection": {
      var {
        newProperties: Pe
      } = n;
      if (Pe == null)
        t = Pe;
      else {
        if (t == null) {
          if (!Ht.isRange(Pe))
            throw new Error('Cannot apply an incomplete "set_selection" operation properties '.concat(Mi.stringify(Pe), " when there is no current selection."));
          t = Jc({}, Pe);
        }
        for (var Me in Pe) {
          var Je = Pe[Me];
          if (Je == null) {
            if (Me === "anchor" || Me === "focus")
              throw new Error('Cannot remove the "'.concat(Me, '" selection property'));
            delete t[Me];
          } else
            t[Me] = Je;
        }
      }
      break;
    }
    case "split_node": {
      var {
        path: We,
        position: Re,
        properties: nt
      } = n;
      if (We.length === 0)
        throw new Error('Cannot apply a "split_node" operation at path ['.concat(We, "] because the root node cannot be split."));
      var De = Pt.get(e, We), yt = Pt.parent(e, We), ot = We[We.length - 1], st;
      if (io.isText(De)) {
        var ct = De.text.slice(0, Re), bt = De.text.slice(Re);
        De.text = ct, st = Jc(Jc({}, nt), {}, {
          text: bt
        });
      } else {
        var pt = De.children.slice(0, Re), dt = De.children.slice(Re);
        De.children = pt, st = Jc(Jc({}, nt), {}, {
          children: dt
        });
      }
      if (yt.children.splice(ot + 1, 0, st), t)
        for (var [tt, Xe] of Ht.points(t))
          t[Xe] = mr.transform(tt, n);
      break;
    }
  }
  return t;
}, yle = {
  transform(e, t) {
    e.children = VT(e.children);
    var n = e.selection && VT(e.selection);
    try {
      n = vle(e, n, t);
    } finally {
      e.children = ZT(e.children), n ? e.selection = Iu(n) ? ZT(n) : n : e.selection = null;
    }
  }
}, ble = {
  insertNodes(e, t, n) {
    e.insertNodes(t, n);
  },
  liftNodes(e, t) {
    e.liftNodes(t);
  },
  mergeNodes(e, t) {
    e.mergeNodes(t);
  },
  moveNodes(e, t) {
    e.moveNodes(t);
  },
  removeNodes(e, t) {
    e.removeNodes(t);
  },
  setNodes(e, t, n) {
    e.setNodes(t, n);
  },
  splitNodes(e, t) {
    e.splitNodes(t);
  },
  unsetNodes(e, t, n) {
    e.unsetNodes(t, n);
  },
  unwrapNodes(e, t) {
    e.unwrapNodes(t);
  },
  wrapNodes(e, t, n) {
    e.wrapNodes(t, n);
  }
}, wle = {
  collapse(e, t) {
    e.collapse(t);
  },
  deselect(e) {
    e.deselect();
  },
  move(e, t) {
    e.move(t);
  },
  select(e, t) {
    e.select(t);
  },
  setPoint(e, t, n) {
    e.setPoint(t, n);
  },
  setSelection(e, t) {
    e.setSelection(t);
  }
}, i4 = (e, t) => {
  for (var n in e) {
    var r = e[n], o = t[n];
    if (Ho(r) && Ho(o)) {
      if (!i4(r, o)) return !1;
    } else if (Array.isArray(r) && Array.isArray(o)) {
      if (r.length !== o.length) return !1;
      for (var i = 0; i < r.length; i++)
        if (r[i] !== o[i]) return !1;
    } else if (r !== o)
      return !1;
  }
  for (var a in t)
    if (e[a] === void 0 && t[a] !== void 0)
      return !1;
  return !0;
};
function Cle(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), o, i;
  for (i = 0; i < r.length; i++)
    o = r[i], !(t.indexOf(o) >= 0) && (n[o] = e[o]);
  return n;
}
function zd(e, t) {
  if (e == null) return {};
  var n = Cle(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (o = 0; o < i.length; o++)
      r = i[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
var xle = ["anchor", "focus"];
function GT(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Ole(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? GT(Object(n), !0).forEach(function(r) {
      kc(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : GT(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Ht = {
  edges(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, {
      anchor: r,
      focus: o
    } = e;
    return Ht.isBackward(e) === n ? [r, o] : [o, r];
  },
  end(e) {
    var [, t] = Ht.edges(e);
    return t;
  },
  equals(e, t) {
    return mr.equals(e.anchor, t.anchor) && mr.equals(e.focus, t.focus);
  },
  includes(e, t) {
    if (Ht.isRange(t)) {
      if (Ht.includes(e, t.anchor) || Ht.includes(e, t.focus))
        return !0;
      var [n, r] = Ht.edges(e), [o, i] = Ht.edges(t);
      return mr.isBefore(n, o) && mr.isAfter(r, i);
    }
    var [a, s] = Ht.edges(e), l = !1, u = !1;
    return mr.isPoint(t) ? (l = mr.compare(t, a) >= 0, u = mr.compare(t, s) <= 0) : (l = Ue.compare(t, a.path) >= 0, u = Ue.compare(t, s.path) <= 0), l && u;
  },
  intersection(e, t) {
    var n = zd(e, xle), [r, o] = Ht.edges(e), [i, a] = Ht.edges(t), s = mr.isBefore(r, i) ? i : r, l = mr.isBefore(o, a) ? o : a;
    return mr.isBefore(l, s) ? null : Ole({
      anchor: s,
      focus: l
    }, n);
  },
  isBackward(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return mr.isAfter(t, n);
  },
  isCollapsed(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return mr.equals(t, n);
  },
  isExpanded(e) {
    return !Ht.isCollapsed(e);
  },
  isForward(e) {
    return !Ht.isBackward(e);
  },
  isRange(e) {
    return Ho(e) && mr.isPoint(e.anchor) && mr.isPoint(e.focus);
  },
  *points(e) {
    yield [e.anchor, "anchor"], yield [e.focus, "focus"];
  },
  start(e) {
    var [t] = Ht.edges(e);
    return t;
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return FL(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "inward"
      } = n, i, a;
      if (o === "inward") {
        var s = Ht.isCollapsed(r);
        Ht.isForward(r) ? (i = "forward", a = s ? i : "backward") : (i = "backward", a = s ? i : "forward");
      } else o === "outward" ? Ht.isForward(r) ? (i = "backward", a = "forward") : (i = "forward", a = "backward") : (i = o, a = o);
      var l = mr.transform(r.anchor, t, {
        affinity: i
      }), u = mr.transform(r.focus, t, {
        affinity: a
      });
      if (!l || !u)
        return null;
      r.anchor = l, r.focus = u;
    });
  }
}, KT = (e) => Ho(e) && Pt.isNodeList(e.children) && !Gn.isEditor(e), ra = {
  isAncestor(e) {
    return Ho(e) && Pt.isNodeList(e.children);
  },
  isElement: KT,
  isElementList(e) {
    return Array.isArray(e) && e.every((t) => ra.isElement(t));
  },
  isElementProps(e) {
    return e.children !== void 0;
  },
  isElementType: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "type";
    return KT(e) && e[n] === t;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "children" && e[n] !== t[n])
        return !1;
    return !0;
  }
}, Ele = ["children"], kle = ["text"], YT = /* @__PURE__ */ new WeakMap(), Pt = {
  ancestor(e, t) {
    var n = Pt.get(e, t);
    if (io.isText(n))
      throw new Error("Cannot get the ancestor node at path [".concat(t, "] because it refers to a text node instead: ").concat(Mi.stringify(n)));
    return n;
  },
  ancestors(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of Ue.ancestors(t, n)) {
        var o = Pt.ancestor(e, r), i = [o, r];
        yield i;
      }
    }();
  },
  child(e, t) {
    if (io.isText(e))
      throw new Error("Cannot get the child of a text node: ".concat(Mi.stringify(e)));
    var n = e.children[t];
    if (n == null)
      throw new Error("Cannot get child at index `".concat(t, "` in node: ").concat(Mi.stringify(e)));
    return n;
  },
  children(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var {
        reverse: r = !1
      } = n, o = Pt.ancestor(e, t), {
        children: i
      } = o, a = r ? i.length - 1 : 0; r ? a >= 0 : a < i.length; ) {
        var s = Pt.child(o, a), l = t.concat(a);
        yield [s, l], a = r ? a - 1 : a + 1;
      }
    }();
  },
  common(e, t, n) {
    var r = Ue.common(t, n), o = Pt.get(e, r);
    return [o, r];
  },
  descendant(e, t) {
    var n = Pt.get(e, t);
    if (Gn.isEditor(n))
      throw new Error("Cannot get the descendant node at path [".concat(t, "] because it refers to the root editor node instead: ").concat(Mi.stringify(n)));
    return n;
  },
  descendants(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Pt.nodes(e, t))
        r.length !== 0 && (yield [n, r]);
    }();
  },
  elements(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Pt.nodes(e, t))
        ra.isElement(n) && (yield [n, r]);
    }();
  },
  extractProps(e) {
    if (ra.isAncestor(e)) {
      var t = zd(e, Ele);
      return t;
    } else {
      var t = zd(e, kle);
      return t;
    }
  },
  first(e, t) {
    for (var n = t.slice(), r = Pt.get(e, n); r && !(io.isText(r) || r.children.length === 0); )
      r = r.children[0], n.push(0);
    return [r, n];
  },
  fragment(e, t) {
    if (io.isText(e))
      throw new Error("Cannot get a fragment starting from a root text node: ".concat(Mi.stringify(e)));
    var n = FL({
      children: e.children
    }, (r) => {
      var [o, i] = Ht.edges(t), a = Pt.nodes(r, {
        reverse: !0,
        pass: (d) => {
          var [, g] = d;
          return !Ht.includes(t, g);
        }
      });
      for (var [, s] of a) {
        if (!Ht.includes(t, s)) {
          var l = Pt.parent(r, s), u = s[s.length - 1];
          l.children.splice(u, 1);
        }
        if (Ue.equals(s, i.path)) {
          var c = Pt.leaf(r, s);
          c.text = c.text.slice(0, i.offset);
        }
        if (Ue.equals(s, o.path)) {
          var p = Pt.leaf(r, s);
          p.text = p.text.slice(o.offset);
        }
      }
      Gn.isEditor(r) && (r.selection = null);
    });
    return n.children;
  },
  get(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (io.isText(n) || !n.children[o])
        throw new Error("Cannot find a descendant at path [".concat(t, "] in node: ").concat(Mi.stringify(e)));
      n = n.children[o];
    }
    return n;
  },
  has(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (io.isText(n) || !n.children[o])
        return !1;
      n = n.children[o];
    }
    return !0;
  },
  isNode(e) {
    return io.isText(e) || ra.isElement(e) || Gn.isEditor(e);
  },
  isNodeList(e) {
    if (!Array.isArray(e))
      return !1;
    var t = YT.get(e);
    if (t !== void 0)
      return t;
    var n = e.every((r) => Pt.isNode(r));
    return YT.set(e, n), n;
  },
  last(e, t) {
    for (var n = t.slice(), r = Pt.get(e, n); r && !(io.isText(r) || r.children.length === 0); ) {
      var o = r.children.length - 1;
      r = r.children[o], n.push(o);
    }
    return [r, n];
  },
  leaf(e, t) {
    var n = Pt.get(e, t);
    if (!io.isText(n))
      throw new Error("Cannot get the leaf node at path [".concat(t, "] because it refers to a non-leaf node: ").concat(Mi.stringify(n)));
    return n;
  },
  levels(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of Ue.levels(t, n)) {
        var o = Pt.get(e, r);
        yield [o, r];
      }
    }();
  },
  matches(e, t) {
    return ra.isElement(e) && ra.isElementProps(t) && ra.matches(e, t) || io.isText(e) && io.isTextProps(t) && io.matches(e, t);
  },
  nodes(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var {
        pass: n,
        reverse: r = !1
      } = t, {
        from: o = [],
        to: i
      } = t, a = /* @__PURE__ */ new Set(), s = [], l = e; !(i && (r ? Ue.isBefore(s, i) : Ue.isAfter(s, i))); ) {
        if (a.has(l) || (yield [l, s]), !a.has(l) && !io.isText(l) && l.children.length !== 0 && (n == null || n([l, s]) === !1)) {
          a.add(l);
          var u = r ? l.children.length - 1 : 0;
          Ue.isAncestor(s, o) && (u = o[s.length]), s = s.concat(u), l = Pt.get(e, s);
          continue;
        }
        if (s.length === 0)
          break;
        if (!r) {
          var c = Ue.next(s);
          if (Pt.has(e, c)) {
            s = c, l = Pt.get(e, s);
            continue;
          }
        }
        if (r && s[s.length - 1] !== 0) {
          var p = Ue.previous(s);
          s = p, l = Pt.get(e, s);
          continue;
        }
        s = Ue.parent(s), l = Pt.get(e, s), a.add(l);
      }
    }();
  },
  parent(e, t) {
    var n = Ue.parent(t), r = Pt.get(e, n);
    if (io.isText(r))
      throw new Error("Cannot get the parent of path [".concat(t, "] because it does not exist in the root."));
    return r;
  },
  string(e) {
    return io.isText(e) ? e.text : e.children.map(Pt.string).join("");
  },
  texts(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Pt.nodes(e, t))
        io.isText(n) && (yield [n, r]);
    }();
  }
};
function XT(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Or(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? XT(Object(n), !0).forEach(function(r) {
      kc(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : XT(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var jp = {
  isNodeOperation(e) {
    return jp.isOperation(e) && e.type.endsWith("_node");
  },
  isOperation(e) {
    if (!Ho(e))
      return !1;
    switch (e.type) {
      case "insert_node":
        return Ue.isPath(e.path) && Pt.isNode(e.node);
      case "insert_text":
        return typeof e.offset == "number" && typeof e.text == "string" && Ue.isPath(e.path);
      case "merge_node":
        return typeof e.position == "number" && Ue.isPath(e.path) && Ho(e.properties);
      case "move_node":
        return Ue.isPath(e.path) && Ue.isPath(e.newPath);
      case "remove_node":
        return Ue.isPath(e.path) && Pt.isNode(e.node);
      case "remove_text":
        return typeof e.offset == "number" && typeof e.text == "string" && Ue.isPath(e.path);
      case "set_node":
        return Ue.isPath(e.path) && Ho(e.properties) && Ho(e.newProperties);
      case "set_selection":
        return e.properties === null && Ht.isRange(e.newProperties) || e.newProperties === null && Ht.isRange(e.properties) || Ho(e.properties) && Ho(e.newProperties);
      case "split_node":
        return Ue.isPath(e.path) && typeof e.position == "number" && Ho(e.properties);
      default:
        return !1;
    }
  },
  isOperationList(e) {
    return Array.isArray(e) && e.every((t) => jp.isOperation(t));
  },
  isSelectionOperation(e) {
    return jp.isOperation(e) && e.type.endsWith("_selection");
  },
  isTextOperation(e) {
    return jp.isOperation(e) && e.type.endsWith("_text");
  },
  inverse(e) {
    switch (e.type) {
      case "insert_node":
        return Or(Or({}, e), {}, {
          type: "remove_node"
        });
      case "insert_text":
        return Or(Or({}, e), {}, {
          type: "remove_text"
        });
      case "merge_node":
        return Or(Or({}, e), {}, {
          type: "split_node",
          path: Ue.previous(e.path)
        });
      case "move_node": {
        var {
          newPath: t,
          path: n
        } = e;
        if (Ue.equals(t, n))
          return e;
        if (Ue.isSibling(n, t))
          return Or(Or({}, e), {}, {
            path: t,
            newPath: n
          });
        var r = Ue.transform(n, e), o = Ue.transform(Ue.next(n), e);
        return Or(Or({}, e), {}, {
          path: r,
          newPath: o
        });
      }
      case "remove_node":
        return Or(Or({}, e), {}, {
          type: "insert_node"
        });
      case "remove_text":
        return Or(Or({}, e), {}, {
          type: "insert_text"
        });
      case "set_node": {
        var {
          properties: i,
          newProperties: a
        } = e;
        return Or(Or({}, e), {}, {
          properties: a,
          newProperties: i
        });
      }
      case "set_selection": {
        var {
          properties: s,
          newProperties: l
        } = e;
        return s == null ? Or(Or({}, e), {}, {
          properties: l,
          newProperties: null
        }) : l == null ? Or(Or({}, e), {}, {
          properties: null,
          newProperties: s
        }) : Or(Or({}, e), {}, {
          properties: l,
          newProperties: s
        });
      }
      case "split_node":
        return Or(Or({}, e), {}, {
          type: "merge_node",
          path: Ue.next(e.path)
        });
    }
  }
}, JT = /* @__PURE__ */ new WeakMap(), Lle = (e) => {
  var t = JT.get(e);
  if (t !== void 0)
    return t;
  if (!Ho(e))
    return !1;
  var n = typeof e.addMark == "function" && typeof e.apply == "function" && typeof e.deleteFragment == "function" && typeof e.insertBreak == "function" && typeof e.insertSoftBreak == "function" && typeof e.insertFragment == "function" && typeof e.insertNode == "function" && typeof e.insertText == "function" && typeof e.isElementReadOnly == "function" && typeof e.isInline == "function" && typeof e.isSelectable == "function" && typeof e.isVoid == "function" && typeof e.normalizeNode == "function" && typeof e.onChange == "function" && typeof e.removeMark == "function" && typeof e.getDirtyPaths == "function" && (e.marks === null || Ho(e.marks)) && (e.selection === null || Ht.isRange(e.selection)) && Pt.isNodeList(e.children) && jp.isOperationList(e.operations);
  return JT.set(e, n), n;
}, Gn = {
  above(e, t) {
    return e.above(t);
  },
  addMark(e, t, n) {
    e.addMark(t, n);
  },
  after(e, t, n) {
    return e.after(t, n);
  },
  before(e, t, n) {
    return e.before(t, n);
  },
  deleteBackward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteBackward(n);
  },
  deleteForward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteForward(n);
  },
  deleteFragment(e, t) {
    e.deleteFragment(t);
  },
  edges(e, t) {
    return e.edges(t);
  },
  elementReadOnly(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return e.elementReadOnly(t);
  },
  end(e, t) {
    return e.end(t);
  },
  first(e, t) {
    return e.first(t);
  },
  fragment(e, t) {
    return e.fragment(t);
  },
  hasBlocks(e, t) {
    return e.hasBlocks(t);
  },
  hasInlines(e, t) {
    return e.hasInlines(t);
  },
  hasPath(e, t) {
    return e.hasPath(t);
  },
  hasTexts(e, t) {
    return e.hasTexts(t);
  },
  insertBreak(e) {
    e.insertBreak();
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertNode(e, t) {
    e.insertNode(t);
  },
  insertSoftBreak(e) {
    e.insertSoftBreak();
  },
  insertText(e, t) {
    e.insertText(t);
  },
  isBlock(e, t) {
    return e.isBlock(t);
  },
  isEdge(e, t, n) {
    return e.isEdge(t, n);
  },
  isEditor(e) {
    return Lle(e);
  },
  isElementReadOnly(e, t) {
    return e.isElementReadOnly(t);
  },
  isEmpty(e, t) {
    return e.isEmpty(t);
  },
  isEnd(e, t, n) {
    return e.isEnd(t, n);
  },
  isInline(e, t) {
    return e.isInline(t);
  },
  isNormalizing(e) {
    return e.isNormalizing();
  },
  isSelectable(e, t) {
    return e.isSelectable(t);
  },
  isStart(e, t, n) {
    return e.isStart(t, n);
  },
  isVoid(e, t) {
    return e.isVoid(t);
  },
  last(e, t) {
    return e.last(t);
  },
  leaf(e, t, n) {
    return e.leaf(t, n);
  },
  levels(e, t) {
    return e.levels(t);
  },
  marks(e) {
    return e.getMarks();
  },
  next(e, t) {
    return e.next(t);
  },
  node(e, t, n) {
    return e.node(t, n);
  },
  nodes(e, t) {
    return e.nodes(t);
  },
  normalize(e, t) {
    e.normalize(t);
  },
  parent(e, t, n) {
    return e.parent(t, n);
  },
  path(e, t, n) {
    return e.path(t, n);
  },
  pathRef(e, t, n) {
    return e.pathRef(t, n);
  },
  pathRefs(e) {
    return e.pathRefs();
  },
  point(e, t, n) {
    return e.point(t, n);
  },
  pointRef(e, t, n) {
    return e.pointRef(t, n);
  },
  pointRefs(e) {
    return e.pointRefs();
  },
  positions(e, t) {
    return e.positions(t);
  },
  previous(e, t) {
    return e.previous(t);
  },
  range(e, t, n) {
    return e.range(t, n);
  },
  rangeRef(e, t, n) {
    return e.rangeRef(t, n);
  },
  rangeRefs(e) {
    return e.rangeRefs();
  },
  removeMark(e, t) {
    e.removeMark(t);
  },
  setNormalizing(e, t) {
    e.setNormalizing(t);
  },
  start(e, t) {
    return e.start(t);
  },
  string(e, t, n) {
    return e.string(t, n);
  },
  unhangRange(e, t, n) {
    return e.unhangRange(t, n);
  },
  void(e, t) {
    return e.void(t);
  },
  withoutNormalizing(e, t) {
    e.withoutNormalizing(t);
  },
  shouldMergeNodesRemovePrevNode: (e, t, n) => e.shouldMergeNodesRemovePrevNode(t, n)
};
function QT(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ej(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? QT(Object(n), !0).forEach(function(r) {
      kc(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : QT(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var mr = {
  compare(e, t) {
    var n = Ue.compare(e.path, t.path);
    return n === 0 ? e.offset < t.offset ? -1 : e.offset > t.offset ? 1 : 0 : n;
  },
  isAfter(e, t) {
    return mr.compare(e, t) === 1;
  },
  isBefore(e, t) {
    return mr.compare(e, t) === -1;
  },
  equals(e, t) {
    return e.offset === t.offset && Ue.equals(e.path, t.path);
  },
  isPoint(e) {
    return Ho(e) && typeof e.offset == "number" && Ue.isPath(e.path);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return FL(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "forward"
      } = n, {
        path: i,
        offset: a
      } = r;
      switch (t.type) {
        case "insert_node":
        case "move_node": {
          r.path = Ue.transform(i, t, n);
          break;
        }
        case "insert_text": {
          Ue.equals(t.path, i) && (t.offset < a || t.offset === a && o === "forward") && (r.offset += t.text.length);
          break;
        }
        case "merge_node": {
          Ue.equals(t.path, i) && (r.offset += t.position), r.path = Ue.transform(i, t, n);
          break;
        }
        case "remove_text": {
          Ue.equals(t.path, i) && t.offset <= a && (r.offset -= Math.min(a - t.offset, t.text.length));
          break;
        }
        case "remove_node": {
          if (Ue.equals(t.path, i) || Ue.isAncestor(t.path, i))
            return null;
          r.path = Ue.transform(i, t, n);
          break;
        }
        case "split_node": {
          if (Ue.equals(t.path, i)) {
            if (t.position === a && o == null)
              return null;
            (t.position < a || t.position === a && o === "forward") && (r.offset -= t.position, r.path = Ue.transform(i, t, ej(ej({}, n), {}, {
              affinity: "forward"
            })));
          } else
            r.path = Ue.transform(i, t, n);
          break;
        }
      }
    });
  }
}, tj = void 0, Mi = {
  setScrubber(e) {
    tj = e;
  },
  stringify(e) {
    return JSON.stringify(e, tj);
  }
}, Ple = ["text"], _le = ["anchor", "focus"];
function nj(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Ws(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? nj(Object(n), !0).forEach(function(r) {
      kc(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : nj(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var io = {
  equals(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      loose: r = !1
    } = n;
    function o(i) {
      var a = zd(i, Ple);
      return a;
    }
    return i4(r ? o(e) : e, r ? o(t) : t);
  },
  isText(e) {
    return Ho(e) && typeof e.text == "string";
  },
  isTextList(e) {
    return Array.isArray(e) && e.every((t) => io.isText(t));
  },
  isTextProps(e) {
    return e.text !== void 0;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "text" && (!e.hasOwnProperty(n) || e[n] !== t[n]))
        return !1;
    return !0;
  },
  decorations(e, t) {
    var n = [Ws({}, e)];
    for (var r of t) {
      var o = zd(r, _le), [i, a] = Ht.edges(r), s = [], l = 0, u = i.offset, c = a.offset;
      for (var p of n) {
        var {
          length: d
        } = p.text, g = l;
        if (l += d, u <= g && l <= c) {
          Object.assign(p, o), s.push(p);
          continue;
        }
        if (u !== c && (u === l || c === g) || u > l || c < g || c === g && g !== 0) {
          s.push(p);
          continue;
        }
        var f = p, m = void 0, v = void 0;
        if (c < l) {
          var E = c - g;
          v = Ws(Ws({}, f), {}, {
            text: f.text.slice(E)
          }), f = Ws(Ws({}, f), {}, {
            text: f.text.slice(0, E)
          });
        }
        if (u > g) {
          var w = u - g;
          m = Ws(Ws({}, f), {}, {
            text: f.text.slice(0, w)
          }), f = Ws(Ws({}, f), {}, {
            text: f.text.slice(w)
          });
        }
        Object.assign(f, o), m && s.push(m), s.push(f), v && s.push(v);
      }
      n = s;
    }
    return n;
  }
}, Sle = (e) => e.selection ? e.selection : e.children.length > 0 ? Gn.end(e, []) : [0], cr;
(function(e) {
  e[e.None = 0] = "None", e[e.Extend = 1] = "Extend", e[e.ZWJ = 2] = "ZWJ", e[e.RI = 4] = "RI", e[e.Prepend = 8] = "Prepend", e[e.SpacingMark = 16] = "SpacingMark", e[e.L = 32] = "L", e[e.V = 64] = "V", e[e.T = 128] = "T", e[e.LV = 256] = "LV", e[e.LVT = 512] = "LVT", e[e.ExtPict = 1024] = "ExtPict", e[e.Any = 2048] = "Any";
})(cr || (cr = {}));
cr.L, cr.L | cr.V | cr.LV | cr.LVT, cr.LV | cr.V, cr.V | cr.T, cr.LVT | cr.T, cr.T, cr.Any, cr.Extend | cr.ZWJ, cr.Any, cr.SpacingMark, cr.Prepend, cr.Any, cr.ZWJ, cr.ExtPict, cr.RI, cr.RI;
var Mle = {
  delete(e, t) {
    e.delete(t);
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertText(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Gn.withoutNormalizing(e, () => {
      var {
        voids: r = !1
      } = n, {
        at: o = Sle(e)
      } = n;
      if (Ue.isPath(o) && (o = Gn.range(e, o)), Ht.isRange(o))
        if (Ht.isCollapsed(o))
          o = o.anchor;
        else {
          var i = Ht.end(o);
          if (!r && Gn.void(e, {
            at: i
          }))
            return;
          var a = Ht.start(o), s = Gn.pointRef(e, a), l = Gn.pointRef(e, i);
          cv.delete(e, {
            at: o,
            voids: r
          });
          var u = s.unref(), c = l.unref();
          o = u || c, cv.setSelection(e, {
            anchor: o,
            focus: o
          });
        }
      if (!(!r && Gn.void(e, {
        at: o
      }) || Gn.elementReadOnly(e, {
        at: o
      }))) {
        var {
          path: p,
          offset: d
        } = o;
        t.length > 0 && e.apply({
          type: "insert_text",
          path: p,
          offset: d,
          text: t
        });
      }
    });
  }
};
function rj(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Nh(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? rj(Object(n), !0).forEach(function(r) {
      kc(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : rj(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var cv = Nh(Nh(Nh(Nh({}, yle), ble), wle), Mle), s4 = {}, zL = {}, UL = {}, Ku = {}, HL = {}, $L = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Doctype = e.CDATA = e.Tag = e.Style = e.Script = e.Comment = e.Directive = e.Text = e.Root = e.isTag = e.ElementType = void 0;
  var t;
  (function(r) {
    r.Root = "root", r.Text = "text", r.Directive = "directive", r.Comment = "comment", r.Script = "script", r.Style = "style", r.Tag = "tag", r.CDATA = "cdata", r.Doctype = "doctype";
  })(t = e.ElementType || (e.ElementType = {}));
  function n(r) {
    return r.type === t.Tag || r.type === t.Script || r.type === t.Style;
  }
  e.isTag = n, e.Root = t.Root, e.Text = t.Text, e.Directive = t.Directive, e.Comment = t.Comment, e.Script = t.Script, e.Style = t.Style, e.Tag = t.Tag, e.CDATA = t.CDATA, e.Doctype = t.Doctype;
})($L);
var Yt = {}, wl = tr && tr.__extends || /* @__PURE__ */ function() {
  var e = function(t, n) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, o) {
      r.__proto__ = o;
    } || function(r, o) {
      for (var i in o) Object.prototype.hasOwnProperty.call(o, i) && (r[i] = o[i]);
    }, e(t, n);
  };
  return function(t, n) {
    if (typeof n != "function" && n !== null)
      throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
    e(t, n);
    function r() {
      this.constructor = t;
    }
    t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
  };
}(), Gp = tr && tr.__assign || function() {
  return Gp = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) {
      t = arguments[n];
      for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
    }
    return e;
  }, Gp.apply(this, arguments);
};
Object.defineProperty(Yt, "__esModule", { value: !0 });
Yt.cloneNode = Yt.hasChildren = Yt.isDocument = Yt.isDirective = Yt.isComment = Yt.isText = Yt.isCDATA = Yt.isTag = Yt.Element = Yt.Document = Yt.CDATA = Yt.NodeWithChildren = Yt.ProcessingInstruction = Yt.Comment = Yt.Text = Yt.DataNode = Yt.Node = void 0;
var gi = $L, WL = (
  /** @class */
  function() {
    function e() {
      this.parent = null, this.prev = null, this.next = null, this.startIndex = null, this.endIndex = null;
    }
    return Object.defineProperty(e.prototype, "parentNode", {
      // Read-write aliases for properties
      /**
       * Same as {@link parent}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.parent;
      },
      set: function(t) {
        this.parent = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "previousSibling", {
      /**
       * Same as {@link prev}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.prev;
      },
      set: function(t) {
        this.prev = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "nextSibling", {
      /**
       * Same as {@link next}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.next;
      },
      set: function(t) {
        this.next = t;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.cloneNode = function(t) {
      return t === void 0 && (t = !1), VL(this, t);
    }, e;
  }()
);
Yt.Node = WL;
var Hb = (
  /** @class */
  function(e) {
    wl(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.data = n, r;
    }
    return Object.defineProperty(t.prototype, "nodeValue", {
      /**
       * Same as {@link data}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.data;
      },
      set: function(n) {
        this.data = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(WL)
);
Yt.DataNode = Hb;
var a4 = (
  /** @class */
  function(e) {
    wl(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = gi.ElementType.Text, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 3;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Hb)
);
Yt.Text = a4;
var l4 = (
  /** @class */
  function(e) {
    wl(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = gi.ElementType.Comment, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 8;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Hb)
);
Yt.Comment = l4;
var u4 = (
  /** @class */
  function(e) {
    wl(t, e);
    function t(n, r) {
      var o = e.call(this, r) || this;
      return o.name = n, o.type = gi.ElementType.Directive, o;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Hb)
);
Yt.ProcessingInstruction = u4;
var $b = (
  /** @class */
  function(e) {
    wl(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.children = n, r;
    }
    return Object.defineProperty(t.prototype, "firstChild", {
      // Aliases
      /** First child of the node. */
      get: function() {
        var n;
        return (n = this.children[0]) !== null && n !== void 0 ? n : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "lastChild", {
      /** Last child of the node. */
      get: function() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "childNodes", {
      /**
       * Same as {@link children}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.children;
      },
      set: function(n) {
        this.children = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(WL)
);
Yt.NodeWithChildren = $b;
var c4 = (
  /** @class */
  function(e) {
    wl(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = gi.ElementType.CDATA, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 4;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }($b)
);
Yt.CDATA = c4;
var p4 = (
  /** @class */
  function(e) {
    wl(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = gi.ElementType.Root, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 9;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }($b)
);
Yt.Document = p4;
var d4 = (
  /** @class */
  function(e) {
    wl(t, e);
    function t(n, r, o, i) {
      o === void 0 && (o = []), i === void 0 && (i = n === "script" ? gi.ElementType.Script : n === "style" ? gi.ElementType.Style : gi.ElementType.Tag);
      var a = e.call(this, o) || this;
      return a.name = n, a.attribs = r, a.type = i, a;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "tagName", {
      // DOM Level 1 aliases
      /**
       * Same as {@link name}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.name;
      },
      set: function(n) {
        this.name = n;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "attributes", {
      get: function() {
        var n = this;
        return Object.keys(this.attribs).map(function(r) {
          var o, i;
          return {
            name: r,
            value: n.attribs[r],
            namespace: (o = n["x-attribsNamespace"]) === null || o === void 0 ? void 0 : o[r],
            prefix: (i = n["x-attribsPrefix"]) === null || i === void 0 ? void 0 : i[r]
          };
        });
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }($b)
);
Yt.Element = d4;
function f4(e) {
  return (0, gi.isTag)(e);
}
Yt.isTag = f4;
function h4(e) {
  return e.type === gi.ElementType.CDATA;
}
Yt.isCDATA = h4;
function g4(e) {
  return e.type === gi.ElementType.Text;
}
Yt.isText = g4;
function m4(e) {
  return e.type === gi.ElementType.Comment;
}
Yt.isComment = m4;
function v4(e) {
  return e.type === gi.ElementType.Directive;
}
Yt.isDirective = v4;
function y4(e) {
  return e.type === gi.ElementType.Root;
}
Yt.isDocument = y4;
function Dle(e) {
  return Object.prototype.hasOwnProperty.call(e, "children");
}
Yt.hasChildren = Dle;
function VL(e, t) {
  t === void 0 && (t = !1);
  var n;
  if (g4(e))
    n = new a4(e.data);
  else if (m4(e))
    n = new l4(e.data);
  else if (f4(e)) {
    var r = t ? q0(e.children) : [], o = new d4(e.name, Gp({}, e.attribs), r);
    r.forEach(function(l) {
      return l.parent = o;
    }), e.namespace != null && (o.namespace = e.namespace), e["x-attribsNamespace"] && (o["x-attribsNamespace"] = Gp({}, e["x-attribsNamespace"])), e["x-attribsPrefix"] && (o["x-attribsPrefix"] = Gp({}, e["x-attribsPrefix"])), n = o;
  } else if (h4(e)) {
    var r = t ? q0(e.children) : [], i = new c4(r);
    r.forEach(function(u) {
      return u.parent = i;
    }), n = i;
  } else if (y4(e)) {
    var r = t ? q0(e.children) : [], a = new p4(r);
    r.forEach(function(u) {
      return u.parent = a;
    }), e["x-mode"] && (a["x-mode"] = e["x-mode"]), n = a;
  } else if (v4(e)) {
    var s = new u4(e.name, e.data);
    e["x-name"] != null && (s["x-name"] = e["x-name"], s["x-publicId"] = e["x-publicId"], s["x-systemId"] = e["x-systemId"]), n = s;
  } else
    throw new Error("Not implemented yet: ".concat(e.type));
  return n.startIndex = e.startIndex, n.endIndex = e.endIndex, e.sourceCodeLocation != null && (n.sourceCodeLocation = e.sourceCodeLocation), n;
}
Yt.cloneNode = VL;
function q0(e) {
  for (var t = e.map(function(r) {
    return VL(r, !0);
  }), n = 1; n < t.length; n++)
    t[n].prev = t[n - 1], t[n - 1].next = t[n];
  return t;
}
(function(e) {
  var t = tr && tr.__createBinding || (Object.create ? function(s, l, u, c) {
    c === void 0 && (c = u);
    var p = Object.getOwnPropertyDescriptor(l, u);
    (!p || ("get" in p ? !l.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
      return l[u];
    } }), Object.defineProperty(s, c, p);
  } : function(s, l, u, c) {
    c === void 0 && (c = u), s[c] = l[u];
  }), n = tr && tr.__exportStar || function(s, l) {
    for (var u in s) u !== "default" && !Object.prototype.hasOwnProperty.call(l, u) && t(l, s, u);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.DomHandler = void 0;
  var r = $L, o = Yt;
  n(Yt, e);
  var i = {
    withStartIndices: !1,
    withEndIndices: !1,
    xmlMode: !1
  }, a = (
    /** @class */
    function() {
      function s(l, u, c) {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null, typeof u == "function" && (c = u, u = i), typeof l == "object" && (u = l, l = void 0), this.callback = l ?? null, this.options = u ?? i, this.elementCB = c ?? null;
      }
      return s.prototype.onparserinit = function(l) {
        this.parser = l;
      }, s.prototype.onreset = function() {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null;
      }, s.prototype.onend = function() {
        this.done || (this.done = !0, this.parser = null, this.handleCallback(null));
      }, s.prototype.onerror = function(l) {
        this.handleCallback(l);
      }, s.prototype.onclosetag = function() {
        this.lastNode = null;
        var l = this.tagStack.pop();
        this.options.withEndIndices && (l.endIndex = this.parser.endIndex), this.elementCB && this.elementCB(l);
      }, s.prototype.onopentag = function(l, u) {
        var c = this.options.xmlMode ? r.ElementType.Tag : void 0, p = new o.Element(l, u, void 0, c);
        this.addNode(p), this.tagStack.push(p);
      }, s.prototype.ontext = function(l) {
        var u = this.lastNode;
        if (u && u.type === r.ElementType.Text)
          u.data += l, this.options.withEndIndices && (u.endIndex = this.parser.endIndex);
        else {
          var c = new o.Text(l);
          this.addNode(c), this.lastNode = c;
        }
      }, s.prototype.oncomment = function(l) {
        if (this.lastNode && this.lastNode.type === r.ElementType.Comment) {
          this.lastNode.data += l;
          return;
        }
        var u = new o.Comment(l);
        this.addNode(u), this.lastNode = u;
      }, s.prototype.oncommentend = function() {
        this.lastNode = null;
      }, s.prototype.oncdatastart = function() {
        var l = new o.Text(""), u = new o.CDATA([l]);
        this.addNode(u), l.parent = u, this.lastNode = l;
      }, s.prototype.oncdataend = function() {
        this.lastNode = null;
      }, s.prototype.onprocessinginstruction = function(l, u) {
        var c = new o.ProcessingInstruction(l, u);
        this.addNode(c);
      }, s.prototype.handleCallback = function(l) {
        if (typeof this.callback == "function")
          this.callback(l, this.dom);
        else if (l)
          throw l;
      }, s.prototype.addNode = function(l) {
        var u = this.tagStack[this.tagStack.length - 1], c = u.children[u.children.length - 1];
        this.options.withStartIndices && (l.startIndex = this.parser.startIndex), this.options.withEndIndices && (l.endIndex = this.parser.endIndex), u.children.push(l), c && (l.prev = c, c.next = l), l.parent = u, this.lastNode = null;
      }, s;
    }()
  );
  e.DomHandler = a, e.default = a;
})(HL);
var b4 = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CARRIAGE_RETURN_PLACEHOLDER_REGEX = e.CARRIAGE_RETURN_PLACEHOLDER = e.CARRIAGE_RETURN_REGEX = e.CARRIAGE_RETURN = e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES = void 0, e.CASE_SENSITIVE_TAG_NAMES = [
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "linearGradient",
    "radialGradient",
    "textPath"
  ], e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES.reduce(function(t, n) {
    return t[n.toLowerCase()] = n, t;
  }, {}), e.CARRIAGE_RETURN = "\r", e.CARRIAGE_RETURN_REGEX = new RegExp(e.CARRIAGE_RETURN, "g"), e.CARRIAGE_RETURN_PLACEHOLDER = "__HTML_DOM_PARSER_CARRIAGE_RETURN_PLACEHOLDER_".concat(Date.now(), "__"), e.CARRIAGE_RETURN_PLACEHOLDER_REGEX = new RegExp(e.CARRIAGE_RETURN_PLACEHOLDER, "g");
})(b4);
Object.defineProperty(Ku, "__esModule", { value: !0 });
Ku.formatAttributes = w4;
Ku.escapeSpecialCharacters = Ale;
Ku.revertEscapedCharacters = C4;
Ku.formatDOM = x4;
var Fh = HL, Ud = b4;
function Tle(e) {
  return Ud.CASE_SENSITIVE_TAG_NAMES_MAP[e];
}
function w4(e) {
  for (var t = {}, n = 0, r = e.length; n < r; n++) {
    var o = e[n];
    t[o.name] = o.value;
  }
  return t;
}
function jle(e) {
  e = e.toLowerCase();
  var t = Tle(e);
  return t || e;
}
function Ale(e) {
  return e.replace(Ud.CARRIAGE_RETURN_REGEX, Ud.CARRIAGE_RETURN_PLACEHOLDER);
}
function C4(e) {
  return e.replace(Ud.CARRIAGE_RETURN_PLACEHOLDER_REGEX, Ud.CARRIAGE_RETURN);
}
function x4(e, t, n) {
  t === void 0 && (t = null);
  for (var r = [], o, i = 0, a = e.length; i < a; i++) {
    var s = e[i];
    switch (s.nodeType) {
      case 1: {
        var l = jle(s.nodeName);
        o = new Fh.Element(l, w4(s.attributes)), o.children = x4(
          // template children are on content
          l === "template" ? s.content.childNodes : s.childNodes,
          o
        );
        break;
      }
      case 3:
        o = new Fh.Text(C4(s.nodeValue));
        break;
      case 8:
        o = new Fh.Comment(s.nodeValue);
        break;
      default:
        continue;
    }
    var u = r[i - 1] || null;
    u && (u.next = o), o.parent = t, o.prev = u, o.next = null, r.push(o);
  }
  return n && (o = new Fh.ProcessingInstruction(n.substring(0, n.indexOf(" ")).toLowerCase(), n), o.next = r[0] || null, o.parent = t, r.unshift(o), r[1] && (r[1].prev = r[0])), r;
}
Object.defineProperty(UL, "__esModule", { value: !0 });
UL.default = Fle;
var Ile = Ku, oj = "html", ij = "head", zh = "body", Rle = /<([a-zA-Z]+[0-9]?)/, sj = /<head[^]*>/i, aj = /<body[^]*>/i, pv = function(e, t) {
  throw new Error("This browser does not support `document.implementation.createHTMLDocument`");
}, UE = function(e, t) {
  throw new Error("This browser does not support `DOMParser.prototype.parseFromString`");
}, lj = typeof window == "object" && window.DOMParser;
if (typeof lj == "function") {
  var Ble = new lj(), Nle = "text/html";
  UE = function(e, t) {
    return t && (e = "<".concat(t, ">").concat(e, "</").concat(t, ">")), Ble.parseFromString(e, Nle);
  }, pv = UE;
}
if (typeof document == "object" && document.implementation) {
  var Uh = document.implementation.createHTMLDocument();
  pv = function(e, t) {
    if (t) {
      var n = Uh.documentElement.querySelector(t);
      return n && (n.innerHTML = e), Uh;
    }
    return Uh.documentElement.innerHTML = e, Uh;
  };
}
var Hh = typeof document == "object" && document.createElement("template"), HE;
Hh && Hh.content && (HE = function(e) {
  return Hh.innerHTML = e, Hh.content.childNodes;
});
function Fle(e) {
  var t, n;
  e = (0, Ile.escapeSpecialCharacters)(e);
  var r = e.match(Rle), o = r && r[1] ? r[1].toLowerCase() : "";
  switch (o) {
    case oj: {
      var i = UE(e);
      if (!sj.test(e)) {
        var a = i.querySelector(ij);
        (t = a == null ? void 0 : a.parentNode) === null || t === void 0 || t.removeChild(a);
      }
      if (!aj.test(e)) {
        var a = i.querySelector(zh);
        (n = a == null ? void 0 : a.parentNode) === null || n === void 0 || n.removeChild(a);
      }
      return i.querySelectorAll(oj);
    }
    case ij:
    case zh: {
      var s = pv(e).querySelectorAll(o);
      return aj.test(e) && sj.test(e) ? s[0].parentNode.childNodes : s;
    }
    default: {
      if (HE)
        return HE(e);
      var a = pv(e, zh).querySelector(zh);
      return a.childNodes;
    }
  }
}
var zle = tr && tr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(zL, "__esModule", { value: !0 });
zL.default = Wle;
var Ule = zle(UL), Hle = Ku, $le = /<(![a-zA-Z\s]+)>/;
function Wle(e) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e)
    return [];
  var t = e.match($le), n = t ? t[1] : void 0;
  return (0, Hle.formatDOM)((0, Ule.default)(e), null, n);
}
var Wb = {}, hs = {}, Vb = {}, Vle = 0;
Vb.SAME = Vle;
var Zle = 1;
Vb.CAMELCASE = Zle;
Vb.possibleStandardNames = {
  accept: 0,
  acceptCharset: 1,
  "accept-charset": "acceptCharset",
  accessKey: 1,
  action: 0,
  allowFullScreen: 1,
  alt: 0,
  as: 0,
  async: 0,
  autoCapitalize: 1,
  autoComplete: 1,
  autoCorrect: 1,
  autoFocus: 1,
  autoPlay: 1,
  autoSave: 1,
  capture: 0,
  cellPadding: 1,
  cellSpacing: 1,
  challenge: 0,
  charSet: 1,
  checked: 0,
  children: 0,
  cite: 0,
  class: "className",
  classID: 1,
  className: 1,
  cols: 0,
  colSpan: 1,
  content: 0,
  contentEditable: 1,
  contextMenu: 1,
  controls: 0,
  controlsList: 1,
  coords: 0,
  crossOrigin: 1,
  dangerouslySetInnerHTML: 1,
  data: 0,
  dateTime: 1,
  default: 0,
  defaultChecked: 1,
  defaultValue: 1,
  defer: 0,
  dir: 0,
  disabled: 0,
  disablePictureInPicture: 1,
  disableRemotePlayback: 1,
  download: 0,
  draggable: 0,
  encType: 1,
  enterKeyHint: 1,
  for: "htmlFor",
  form: 0,
  formMethod: 1,
  formAction: 1,
  formEncType: 1,
  formNoValidate: 1,
  formTarget: 1,
  frameBorder: 1,
  headers: 0,
  height: 0,
  hidden: 0,
  high: 0,
  href: 0,
  hrefLang: 1,
  htmlFor: 1,
  httpEquiv: 1,
  "http-equiv": "httpEquiv",
  icon: 0,
  id: 0,
  innerHTML: 1,
  inputMode: 1,
  integrity: 0,
  is: 0,
  itemID: 1,
  itemProp: 1,
  itemRef: 1,
  itemScope: 1,
  itemType: 1,
  keyParams: 1,
  keyType: 1,
  kind: 0,
  label: 0,
  lang: 0,
  list: 0,
  loop: 0,
  low: 0,
  manifest: 0,
  marginWidth: 1,
  marginHeight: 1,
  max: 0,
  maxLength: 1,
  media: 0,
  mediaGroup: 1,
  method: 0,
  min: 0,
  minLength: 1,
  multiple: 0,
  muted: 0,
  name: 0,
  noModule: 1,
  nonce: 0,
  noValidate: 1,
  open: 0,
  optimum: 0,
  pattern: 0,
  placeholder: 0,
  playsInline: 1,
  poster: 0,
  preload: 0,
  profile: 0,
  radioGroup: 1,
  readOnly: 1,
  referrerPolicy: 1,
  rel: 0,
  required: 0,
  reversed: 0,
  role: 0,
  rows: 0,
  rowSpan: 1,
  sandbox: 0,
  scope: 0,
  scoped: 0,
  scrolling: 0,
  seamless: 0,
  selected: 0,
  shape: 0,
  size: 0,
  sizes: 0,
  span: 0,
  spellCheck: 1,
  src: 0,
  srcDoc: 1,
  srcLang: 1,
  srcSet: 1,
  start: 0,
  step: 0,
  style: 0,
  summary: 0,
  tabIndex: 1,
  target: 0,
  title: 0,
  type: 0,
  useMap: 1,
  value: 0,
  width: 0,
  wmode: 0,
  wrap: 0,
  about: 0,
  accentHeight: 1,
  "accent-height": "accentHeight",
  accumulate: 0,
  additive: 0,
  alignmentBaseline: 1,
  "alignment-baseline": "alignmentBaseline",
  allowReorder: 1,
  alphabetic: 0,
  amplitude: 0,
  arabicForm: 1,
  "arabic-form": "arabicForm",
  ascent: 0,
  attributeName: 1,
  attributeType: 1,
  autoReverse: 1,
  azimuth: 0,
  baseFrequency: 1,
  baselineShift: 1,
  "baseline-shift": "baselineShift",
  baseProfile: 1,
  bbox: 0,
  begin: 0,
  bias: 0,
  by: 0,
  calcMode: 1,
  capHeight: 1,
  "cap-height": "capHeight",
  clip: 0,
  clipPath: 1,
  "clip-path": "clipPath",
  clipPathUnits: 1,
  clipRule: 1,
  "clip-rule": "clipRule",
  color: 0,
  colorInterpolation: 1,
  "color-interpolation": "colorInterpolation",
  colorInterpolationFilters: 1,
  "color-interpolation-filters": "colorInterpolationFilters",
  colorProfile: 1,
  "color-profile": "colorProfile",
  colorRendering: 1,
  "color-rendering": "colorRendering",
  contentScriptType: 1,
  contentStyleType: 1,
  cursor: 0,
  cx: 0,
  cy: 0,
  d: 0,
  datatype: 0,
  decelerate: 0,
  descent: 0,
  diffuseConstant: 1,
  direction: 0,
  display: 0,
  divisor: 0,
  dominantBaseline: 1,
  "dominant-baseline": "dominantBaseline",
  dur: 0,
  dx: 0,
  dy: 0,
  edgeMode: 1,
  elevation: 0,
  enableBackground: 1,
  "enable-background": "enableBackground",
  end: 0,
  exponent: 0,
  externalResourcesRequired: 1,
  fill: 0,
  fillOpacity: 1,
  "fill-opacity": "fillOpacity",
  fillRule: 1,
  "fill-rule": "fillRule",
  filter: 0,
  filterRes: 1,
  filterUnits: 1,
  floodOpacity: 1,
  "flood-opacity": "floodOpacity",
  floodColor: 1,
  "flood-color": "floodColor",
  focusable: 0,
  fontFamily: 1,
  "font-family": "fontFamily",
  fontSize: 1,
  "font-size": "fontSize",
  fontSizeAdjust: 1,
  "font-size-adjust": "fontSizeAdjust",
  fontStretch: 1,
  "font-stretch": "fontStretch",
  fontStyle: 1,
  "font-style": "fontStyle",
  fontVariant: 1,
  "font-variant": "fontVariant",
  fontWeight: 1,
  "font-weight": "fontWeight",
  format: 0,
  from: 0,
  fx: 0,
  fy: 0,
  g1: 0,
  g2: 0,
  glyphName: 1,
  "glyph-name": "glyphName",
  glyphOrientationHorizontal: 1,
  "glyph-orientation-horizontal": "glyphOrientationHorizontal",
  glyphOrientationVertical: 1,
  "glyph-orientation-vertical": "glyphOrientationVertical",
  glyphRef: 1,
  gradientTransform: 1,
  gradientUnits: 1,
  hanging: 0,
  horizAdvX: 1,
  "horiz-adv-x": "horizAdvX",
  horizOriginX: 1,
  "horiz-origin-x": "horizOriginX",
  ideographic: 0,
  imageRendering: 1,
  "image-rendering": "imageRendering",
  in2: 0,
  in: 0,
  inlist: 0,
  intercept: 0,
  k1: 0,
  k2: 0,
  k3: 0,
  k4: 0,
  k: 0,
  kernelMatrix: 1,
  kernelUnitLength: 1,
  kerning: 0,
  keyPoints: 1,
  keySplines: 1,
  keyTimes: 1,
  lengthAdjust: 1,
  letterSpacing: 1,
  "letter-spacing": "letterSpacing",
  lightingColor: 1,
  "lighting-color": "lightingColor",
  limitingConeAngle: 1,
  local: 0,
  markerEnd: 1,
  "marker-end": "markerEnd",
  markerHeight: 1,
  markerMid: 1,
  "marker-mid": "markerMid",
  markerStart: 1,
  "marker-start": "markerStart",
  markerUnits: 1,
  markerWidth: 1,
  mask: 0,
  maskContentUnits: 1,
  maskUnits: 1,
  mathematical: 0,
  mode: 0,
  numOctaves: 1,
  offset: 0,
  opacity: 0,
  operator: 0,
  order: 0,
  orient: 0,
  orientation: 0,
  origin: 0,
  overflow: 0,
  overlinePosition: 1,
  "overline-position": "overlinePosition",
  overlineThickness: 1,
  "overline-thickness": "overlineThickness",
  paintOrder: 1,
  "paint-order": "paintOrder",
  panose1: 0,
  "panose-1": "panose1",
  pathLength: 1,
  patternContentUnits: 1,
  patternTransform: 1,
  patternUnits: 1,
  pointerEvents: 1,
  "pointer-events": "pointerEvents",
  points: 0,
  pointsAtX: 1,
  pointsAtY: 1,
  pointsAtZ: 1,
  prefix: 0,
  preserveAlpha: 1,
  preserveAspectRatio: 1,
  primitiveUnits: 1,
  property: 0,
  r: 0,
  radius: 0,
  refX: 1,
  refY: 1,
  renderingIntent: 1,
  "rendering-intent": "renderingIntent",
  repeatCount: 1,
  repeatDur: 1,
  requiredExtensions: 1,
  requiredFeatures: 1,
  resource: 0,
  restart: 0,
  result: 0,
  results: 0,
  rotate: 0,
  rx: 0,
  ry: 0,
  scale: 0,
  security: 0,
  seed: 0,
  shapeRendering: 1,
  "shape-rendering": "shapeRendering",
  slope: 0,
  spacing: 0,
  specularConstant: 1,
  specularExponent: 1,
  speed: 0,
  spreadMethod: 1,
  startOffset: 1,
  stdDeviation: 1,
  stemh: 0,
  stemv: 0,
  stitchTiles: 1,
  stopColor: 1,
  "stop-color": "stopColor",
  stopOpacity: 1,
  "stop-opacity": "stopOpacity",
  strikethroughPosition: 1,
  "strikethrough-position": "strikethroughPosition",
  strikethroughThickness: 1,
  "strikethrough-thickness": "strikethroughThickness",
  string: 0,
  stroke: 0,
  strokeDasharray: 1,
  "stroke-dasharray": "strokeDasharray",
  strokeDashoffset: 1,
  "stroke-dashoffset": "strokeDashoffset",
  strokeLinecap: 1,
  "stroke-linecap": "strokeLinecap",
  strokeLinejoin: 1,
  "stroke-linejoin": "strokeLinejoin",
  strokeMiterlimit: 1,
  "stroke-miterlimit": "strokeMiterlimit",
  strokeWidth: 1,
  "stroke-width": "strokeWidth",
  strokeOpacity: 1,
  "stroke-opacity": "strokeOpacity",
  suppressContentEditableWarning: 1,
  suppressHydrationWarning: 1,
  surfaceScale: 1,
  systemLanguage: 1,
  tableValues: 1,
  targetX: 1,
  targetY: 1,
  textAnchor: 1,
  "text-anchor": "textAnchor",
  textDecoration: 1,
  "text-decoration": "textDecoration",
  textLength: 1,
  textRendering: 1,
  "text-rendering": "textRendering",
  to: 0,
  transform: 0,
  typeof: 0,
  u1: 0,
  u2: 0,
  underlinePosition: 1,
  "underline-position": "underlinePosition",
  underlineThickness: 1,
  "underline-thickness": "underlineThickness",
  unicode: 0,
  unicodeBidi: 1,
  "unicode-bidi": "unicodeBidi",
  unicodeRange: 1,
  "unicode-range": "unicodeRange",
  unitsPerEm: 1,
  "units-per-em": "unitsPerEm",
  unselectable: 0,
  vAlphabetic: 1,
  "v-alphabetic": "vAlphabetic",
  values: 0,
  vectorEffect: 1,
  "vector-effect": "vectorEffect",
  version: 0,
  vertAdvY: 1,
  "vert-adv-y": "vertAdvY",
  vertOriginX: 1,
  "vert-origin-x": "vertOriginX",
  vertOriginY: 1,
  "vert-origin-y": "vertOriginY",
  vHanging: 1,
  "v-hanging": "vHanging",
  vIdeographic: 1,
  "v-ideographic": "vIdeographic",
  viewBox: 1,
  viewTarget: 1,
  visibility: 0,
  vMathematical: 1,
  "v-mathematical": "vMathematical",
  vocab: 0,
  widths: 0,
  wordSpacing: 1,
  "word-spacing": "wordSpacing",
  writingMode: 1,
  "writing-mode": "writingMode",
  x1: 0,
  x2: 0,
  x: 0,
  xChannelSelector: 1,
  xHeight: 1,
  "x-height": "xHeight",
  xlinkActuate: 1,
  "xlink:actuate": "xlinkActuate",
  xlinkArcrole: 1,
  "xlink:arcrole": "xlinkArcrole",
  xlinkHref: 1,
  "xlink:href": "xlinkHref",
  xlinkRole: 1,
  "xlink:role": "xlinkRole",
  xlinkShow: 1,
  "xlink:show": "xlinkShow",
  xlinkTitle: 1,
  "xlink:title": "xlinkTitle",
  xlinkType: 1,
  "xlink:type": "xlinkType",
  xmlBase: 1,
  "xml:base": "xmlBase",
  xmlLang: 1,
  "xml:lang": "xmlLang",
  xmlns: 0,
  "xml:space": "xmlSpace",
  xmlnsXlink: 1,
  "xmlns:xlink": "xmlnsXlink",
  xmlSpace: 1,
  y1: 0,
  y2: 0,
  y: 0,
  yChannelSelector: 1,
  z: 0,
  zoomAndPan: 1
};
const O4 = 0, Cl = 1, Zb = 2, qb = 3, ZL = 4, E4 = 5, k4 = 6;
function qle(e) {
  return Ro.hasOwnProperty(e) ? Ro[e] : null;
}
function Qo(e, t, n, r, o, i, a) {
  this.acceptsBooleans = t === Zb || t === qb || t === ZL, this.attributeName = r, this.attributeNamespace = o, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = i, this.removeEmptyString = a;
}
const Ro = {}, Gle = [
  "children",
  "dangerouslySetInnerHTML",
  // TODO: This prevents the assignment of defaultValue to regular
  // elements (not just inputs). Now that ReactDOMInput assigns to the
  // defaultValue property -- do we need this?
  "defaultValue",
  "defaultChecked",
  "innerHTML",
  "suppressContentEditableWarning",
  "suppressHydrationWarning",
  "style"
];
Gle.forEach((e) => {
  Ro[e] = new Qo(
    e,
    O4,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"]
].forEach(([e, t]) => {
  Ro[e] = new Qo(
    e,
    Cl,
    !1,
    // mustUseProperty
    t,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["contentEditable", "draggable", "spellCheck", "value"].forEach((e) => {
  Ro[e] = new Qo(
    e,
    Zb,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha"
].forEach((e) => {
  Ro[e] = new Qo(
    e,
    Zb,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "allowFullScreen",
  "async",
  // Note: there is a special case that prevents it from being written to the DOM
  // on the client side because the browsers are inconsistent. Instead we call focus().
  "autoFocus",
  "autoPlay",
  "controls",
  "default",
  "defer",
  "disabled",
  "disablePictureInPicture",
  "disableRemotePlayback",
  "formNoValidate",
  "hidden",
  "loop",
  "noModule",
  "noValidate",
  "open",
  "playsInline",
  "readOnly",
  "required",
  "reversed",
  "scoped",
  "seamless",
  // Microdata
  "itemScope"
].forEach((e) => {
  Ro[e] = new Qo(
    e,
    qb,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "checked",
  // Note: `option.selected` is not updated if `select.multiple` is
  // disabled with `removeAttribute`. We have special logic for handling this.
  "multiple",
  "muted",
  "selected"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Ro[e] = new Qo(
    e,
    qb,
    !0,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "capture",
  "download"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Ro[e] = new Qo(
    e,
    ZL,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "cols",
  "rows",
  "size",
  "span"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Ro[e] = new Qo(
    e,
    k4,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["rowSpan", "start"].forEach((e) => {
  Ro[e] = new Qo(
    e,
    E4,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const qL = /[\-\:]([a-z])/g, GL = (e) => e[1].toUpperCase();
[
  "accent-height",
  "alignment-baseline",
  "arabic-form",
  "baseline-shift",
  "cap-height",
  "clip-path",
  "clip-rule",
  "color-interpolation",
  "color-interpolation-filters",
  "color-profile",
  "color-rendering",
  "dominant-baseline",
  "enable-background",
  "fill-opacity",
  "fill-rule",
  "flood-color",
  "flood-opacity",
  "font-family",
  "font-size",
  "font-size-adjust",
  "font-stretch",
  "font-style",
  "font-variant",
  "font-weight",
  "glyph-name",
  "glyph-orientation-horizontal",
  "glyph-orientation-vertical",
  "horiz-adv-x",
  "horiz-origin-x",
  "image-rendering",
  "letter-spacing",
  "lighting-color",
  "marker-end",
  "marker-mid",
  "marker-start",
  "overline-position",
  "overline-thickness",
  "paint-order",
  "panose-1",
  "pointer-events",
  "rendering-intent",
  "shape-rendering",
  "stop-color",
  "stop-opacity",
  "strikethrough-position",
  "strikethrough-thickness",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "text-anchor",
  "text-decoration",
  "text-rendering",
  "underline-position",
  "underline-thickness",
  "unicode-bidi",
  "unicode-range",
  "units-per-em",
  "v-alphabetic",
  "v-hanging",
  "v-ideographic",
  "v-mathematical",
  "vector-effect",
  "vert-adv-y",
  "vert-origin-x",
  "vert-origin-y",
  "word-spacing",
  "writing-mode",
  "xmlns:xlink",
  "x-height"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(qL, GL);
  Ro[t] = new Qo(
    t,
    Cl,
    !1,
    // mustUseProperty
    e,
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xlink:actuate",
  "xlink:arcrole",
  "xlink:role",
  "xlink:show",
  "xlink:title",
  "xlink:type"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(qL, GL);
  Ro[t] = new Qo(
    t,
    Cl,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/1999/xlink",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xml:base",
  "xml:lang",
  "xml:space"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(qL, GL);
  Ro[t] = new Qo(
    t,
    Cl,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/XML/1998/namespace",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["tabIndex", "crossOrigin"].forEach((e) => {
  Ro[e] = new Qo(
    e,
    Cl,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const Kle = "xlinkHref";
Ro[Kle] = new Qo(
  "xlinkHref",
  Cl,
  !1,
  // mustUseProperty
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  // sanitizeURL
  !1
  // removeEmptyString
);
["src", "href", "action", "formAction"].forEach((e) => {
  Ro[e] = new Qo(
    e,
    Cl,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !0,
    // sanitizeURL
    !0
    // removeEmptyString
  );
});
const {
  CAMELCASE: Yle,
  SAME: Xle,
  possibleStandardNames: uj
} = Vb, Jle = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", Qle = Jle + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", eue = RegExp.prototype.test.bind(
  // eslint-disable-next-line no-misleading-character-class
  new RegExp("^(data|aria)-[" + Qle + "]*$")
), tue = Object.keys(
  uj
).reduce((e, t) => {
  const n = uj[t];
  return n === Xle ? e[t] = t : n === Yle ? e[t.toLowerCase()] = t : e[t] = n, e;
}, {});
hs.BOOLEAN = qb;
hs.BOOLEANISH_STRING = Zb;
hs.NUMERIC = E4;
hs.OVERLOADED_BOOLEAN = ZL;
hs.POSITIVE_NUMERIC = k4;
hs.RESERVED = O4;
hs.STRING = Cl;
hs.getPropertyInfo = qle;
hs.isCustomAttribute = eue;
hs.possibleStandardNames = tue;
var KL = {}, YL = {}, cj = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, nue = /\n/g, rue = /^\s*/, oue = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, iue = /^:\s*/, sue = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, aue = /^[;\s]*/, lue = /^\s+|\s+$/g, uue = `
`, pj = "/", dj = "*", au = "", cue = "comment", pue = "declaration", due = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e) return [];
  t = t || {};
  var n = 1, r = 1;
  function o(f) {
    var m = f.match(nue);
    m && (n += m.length);
    var v = f.lastIndexOf(uue);
    r = ~v ? f.length - v : r + f.length;
  }
  function i() {
    var f = { line: n, column: r };
    return function(m) {
      return m.position = new a(f), u(), m;
    };
  }
  function a(f) {
    this.start = f, this.end = { line: n, column: r }, this.source = t.source;
  }
  a.prototype.content = e;
  function s(f) {
    var m = new Error(
      t.source + ":" + n + ":" + r + ": " + f
    );
    if (m.reason = f, m.filename = t.source, m.line = n, m.column = r, m.source = e, !t.silent) throw m;
  }
  function l(f) {
    var m = f.exec(e);
    if (m) {
      var v = m[0];
      return o(v), e = e.slice(v.length), m;
    }
  }
  function u() {
    l(rue);
  }
  function c(f) {
    var m;
    for (f = f || []; m = p(); )
      m !== !1 && f.push(m);
    return f;
  }
  function p() {
    var f = i();
    if (!(pj != e.charAt(0) || dj != e.charAt(1))) {
      for (var m = 2; au != e.charAt(m) && (dj != e.charAt(m) || pj != e.charAt(m + 1)); )
        ++m;
      if (m += 2, au === e.charAt(m - 1))
        return s("End of comment missing");
      var v = e.slice(2, m - 2);
      return r += 2, o(v), e = e.slice(m), r += 2, f({
        type: cue,
        comment: v
      });
    }
  }
  function d() {
    var f = i(), m = l(oue);
    if (m) {
      if (p(), !l(iue)) return s("property missing ':'");
      var v = l(sue), E = f({
        type: pue,
        property: fj(m[0].replace(cj, au)),
        value: v ? fj(v[0].replace(cj, au)) : au
      });
      return l(aue), E;
    }
  }
  function g() {
    var f = [];
    c(f);
    for (var m; m = d(); )
      m !== !1 && (f.push(m), c(f));
    return f;
  }
  return u(), g();
};
function fj(e) {
  return e ? e.replace(lue, au) : au;
}
var fue = tr && tr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(YL, "__esModule", { value: !0 });
YL.default = gue;
var hue = fue(due);
function gue(e, t) {
  var n = null;
  if (!e || typeof e != "string")
    return n;
  var r = (0, hue.default)(e), o = typeof t == "function";
  return r.forEach(function(i) {
    if (i.type === "declaration") {
      var a = i.property, s = i.value;
      o ? t(a, s, i) : s && (n = n || {}, n[a] = s);
    }
  }), n;
}
var Gb = {};
Object.defineProperty(Gb, "__esModule", { value: !0 });
Gb.camelCase = void 0;
var mue = /^--[a-zA-Z0-9_-]+$/, vue = /-([a-z])/g, yue = /^[^-]+$/, bue = /^-(webkit|moz|ms|o|khtml)-/, wue = /^-(ms)-/, Cue = function(e) {
  return !e || yue.test(e) || mue.test(e);
}, xue = function(e, t) {
  return t.toUpperCase();
}, hj = function(e, t) {
  return "".concat(t, "-");
}, Oue = function(e, t) {
  return t === void 0 && (t = {}), Cue(e) ? e : (e = e.toLowerCase(), t.reactCompat ? e = e.replace(wue, hj) : e = e.replace(bue, hj), e.replace(vue, xue));
};
Gb.camelCase = Oue;
var Eue = tr && tr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
}, kue = Eue(YL), Lue = Gb;
function $E(e, t) {
  var n = {};
  return !e || typeof e != "string" || (0, kue.default)(e, function(r, o) {
    r && o && (n[(0, Lue.camelCase)(r, t)] = o);
  }), n;
}
$E.default = $E;
var Pue = $E;
(function(e) {
  var t = tr && tr.__importDefault || function(c) {
    return c && c.__esModule ? c : { default: c };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.returnFirstArg = e.canTextBeChildOfNode = e.ELEMENTS_WITH_NO_TEXT_CHILDREN = e.PRESERVE_CUSTOM_ATTRIBUTES = void 0, e.isCustomComponent = i, e.setStyleProp = s;
  var n = we, r = t(Pue), o = /* @__PURE__ */ new Set([
    "annotation-xml",
    "color-profile",
    "font-face",
    "font-face-src",
    "font-face-uri",
    "font-face-format",
    "font-face-name",
    "missing-glyph"
  ]);
  function i(c, p) {
    return c.includes("-") ? !o.has(c) : !!(p && typeof p.is == "string");
  }
  var a = {
    reactCompat: !0
  };
  function s(c, p) {
    if (typeof c == "string") {
      if (!c.trim()) {
        p.style = {};
        return;
      }
      try {
        p.style = (0, r.default)(c, a);
      } catch {
        p.style = {};
      }
    }
  }
  e.PRESERVE_CUSTOM_ATTRIBUTES = Number(n.version.split(".")[0]) >= 16, e.ELEMENTS_WITH_NO_TEXT_CHILDREN = /* @__PURE__ */ new Set([
    "tr",
    "tbody",
    "thead",
    "tfoot",
    "colgroup",
    "table",
    "head",
    "html",
    "frameset"
  ]);
  var l = function(c) {
    return !e.ELEMENTS_WITH_NO_TEXT_CHILDREN.has(c.name);
  };
  e.canTextBeChildOfNode = l;
  var u = function(c) {
    return c;
  };
  e.returnFirstArg = u;
})(KL);
Object.defineProperty(Wb, "__esModule", { value: !0 });
Wb.default = Due;
var Ap = hs, gj = KL, _ue = ["checked", "value"], Sue = ["input", "select", "textarea"], Mue = {
  reset: !0,
  submit: !0
};
function Due(e, t) {
  e === void 0 && (e = {});
  var n = {}, r = !!(e.type && Mue[e.type]);
  for (var o in e) {
    var i = e[o];
    if ((0, Ap.isCustomAttribute)(o)) {
      n[o] = i;
      continue;
    }
    var a = o.toLowerCase(), s = mj(a);
    if (s) {
      var l = (0, Ap.getPropertyInfo)(s);
      switch (_ue.includes(s) && Sue.includes(t) && !r && (s = mj("default" + a)), n[s] = i, l && l.type) {
        case Ap.BOOLEAN:
          n[s] = !0;
          break;
        case Ap.OVERLOADED_BOOLEAN:
          i === "" && (n[s] = !0);
          break;
      }
      continue;
    }
    gj.PRESERVE_CUSTOM_ATTRIBUTES && (n[o] = i);
  }
  return (0, gj.setStyleProp)(e.style, n), n;
}
function mj(e) {
  return Ap.possibleStandardNames[e];
}
var XL = {}, Tue = tr && tr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(XL, "__esModule", { value: !0 });
XL.default = L4;
var G0 = we, jue = Tue(Wb), Kp = KL, Aue = {
  cloneElement: G0.cloneElement,
  createElement: G0.createElement,
  isValidElement: G0.isValidElement
};
function L4(e, t) {
  t === void 0 && (t = {});
  for (var n = [], r = typeof t.replace == "function", o = t.transform || Kp.returnFirstArg, i = t.library || Aue, a = i.cloneElement, s = i.createElement, l = i.isValidElement, u = e.length, c = 0; c < u; c++) {
    var p = e[c];
    if (r) {
      var d = t.replace(p, c);
      if (l(d)) {
        u > 1 && (d = a(d, {
          key: d.key || c
        })), n.push(o(d, p, c));
        continue;
      }
    }
    if (p.type === "text") {
      var g = !p.data.trim().length;
      if (g && p.parent && !(0, Kp.canTextBeChildOfNode)(p.parent) || t.trim && g)
        continue;
      n.push(o(p.data, p, c));
      continue;
    }
    var f = p, m = {};
    Iue(f) ? ((0, Kp.setStyleProp)(f.attribs.style, f.attribs), m = f.attribs) : f.attribs && (m = (0, jue.default)(f.attribs, f.name));
    var v = void 0;
    switch (p.type) {
      case "script":
      case "style":
        p.children[0] && (m.dangerouslySetInnerHTML = {
          __html: p.children[0].data
        });
        break;
      case "tag":
        p.name === "textarea" && p.children[0] ? m.defaultValue = p.children[0].data : p.children && p.children.length && (v = L4(p.children, t));
        break;
      default:
        continue;
    }
    u > 1 && (m.key = c), n.push(o(s(p.name, m, v), p, c));
  }
  return n.length === 1 ? n[0] : n;
}
function Iue(e) {
  return Kp.PRESERVE_CUSTOM_ATTRIBUTES && e.type === "tag" && (0, Kp.isCustomComponent)(e.name, e.attribs);
}
(function(e) {
  var t = tr && tr.__importDefault || function(l) {
    return l && l.__esModule ? l : { default: l };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.htmlToDOM = e.domToReact = e.attributesToProps = e.Text = e.ProcessingInstruction = e.Element = e.Comment = void 0, e.default = s;
  var n = t(zL);
  e.htmlToDOM = n.default;
  var r = t(Wb);
  e.attributesToProps = r.default;
  var o = t(XL);
  e.domToReact = o.default;
  var i = HL;
  Object.defineProperty(e, "Comment", { enumerable: !0, get: function() {
    return i.Comment;
  } }), Object.defineProperty(e, "Element", { enumerable: !0, get: function() {
    return i.Element;
  } }), Object.defineProperty(e, "ProcessingInstruction", { enumerable: !0, get: function() {
    return i.ProcessingInstruction;
  } }), Object.defineProperty(e, "Text", { enumerable: !0, get: function() {
    return i.Text;
  } });
  var a = { lowerCaseAttributeNames: !1 };
  function s(l, u) {
    if (typeof l != "string")
      throw new TypeError("First argument must be a string");
    return l ? (0, o.default)((0, n.default)(l, (u == null ? void 0 : u.htmlparser2) || a), u) : [];
  }
})(s4);
const Rue = /* @__PURE__ */ tle(s4);
Rue.default;
var nr = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Bue(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var WE = { exports: {} }, Qc = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var vj;
function Nue() {
  if (vj) return Qc;
  vj = 1;
  var e = we, t = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, o = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, i = { key: !0, ref: !0, __self: !0, __source: !0 };
  function a(s, l, u) {
    var c, p = {}, d = null, g = null;
    u !== void 0 && (d = "" + u), l.key !== void 0 && (d = "" + l.key), l.ref !== void 0 && (g = l.ref);
    for (c in l) r.call(l, c) && !i.hasOwnProperty(c) && (p[c] = l[c]);
    if (s && s.defaultProps) for (c in l = s.defaultProps, l) p[c] === void 0 && (p[c] = l[c]);
    return { $$typeof: t, type: s, key: d, ref: g, props: p, _owner: o.current };
  }
  return Qc.Fragment = n, Qc.jsx = a, Qc.jsxs = a, Qc;
}
var $h = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var yj;
function Fue() {
  return yj || (yj = 1, process.env.NODE_ENV !== "production" && function() {
    var e = we, t = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), a = Symbol.for("react.provider"), s = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), c = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), d = Symbol.for("react.lazy"), g = Symbol.for("react.offscreen"), f = Symbol.iterator, m = "@@iterator";
    function v(b) {
      if (b === null || typeof b != "object")
        return null;
      var I = f && b[f] || b[m];
      return typeof I == "function" ? I : null;
    }
    var E = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function w(b) {
      {
        for (var I = arguments.length, G = new Array(I > 1 ? I - 1 : 0), ne = 1; ne < I; ne++)
          G[ne - 1] = arguments[ne];
        M("error", b, G);
      }
    }
    function M(b, I, G) {
      {
        var ne = E.ReactDebugCurrentFrame, le = ne.getStackAddendum();
        le !== "" && (I += "%s", G = G.concat([le]));
        var ce = G.map(function(se) {
          return String(se);
        });
        ce.unshift("Warning: " + I), Function.prototype.apply.call(console[b], console, ce);
      }
    }
    var O = !1, y = !1, C = !1, _ = !1, F = !1, L;
    L = Symbol.for("react.module.reference");
    function N(b) {
      return !!(typeof b == "string" || typeof b == "function" || b === r || b === i || F || b === o || b === u || b === c || _ || b === g || O || y || C || typeof b == "object" && b !== null && (b.$$typeof === d || b.$$typeof === p || b.$$typeof === a || b.$$typeof === s || b.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      b.$$typeof === L || b.getModuleId !== void 0));
    }
    function R(b, I, G) {
      var ne = b.displayName;
      if (ne)
        return ne;
      var le = I.displayName || I.name || "";
      return le !== "" ? G + "(" + le + ")" : G;
    }
    function W(b) {
      return b.displayName || "Context";
    }
    function V(b) {
      if (b == null)
        return null;
      if (typeof b.tag == "number" && w("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof b == "function")
        return b.displayName || b.name || null;
      if (typeof b == "string")
        return b;
      switch (b) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case i:
          return "Profiler";
        case o:
          return "StrictMode";
        case u:
          return "Suspense";
        case c:
          return "SuspenseList";
      }
      if (typeof b == "object")
        switch (b.$$typeof) {
          case s:
            var I = b;
            return W(I) + ".Consumer";
          case a:
            var G = b;
            return W(G._context) + ".Provider";
          case l:
            return R(b, b.render, "ForwardRef");
          case p:
            var ne = b.displayName || null;
            return ne !== null ? ne : V(b.type) || "Memo";
          case d: {
            var le = b, ce = le._payload, se = le._init;
            try {
              return V(se(ce));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var z = Object.assign, Z = 0, K, X, te, J, P, D, H;
    function S() {
    }
    S.__reactDisabledLog = !0;
    function $() {
      {
        if (Z === 0) {
          K = console.log, X = console.info, te = console.warn, J = console.error, P = console.group, D = console.groupCollapsed, H = console.groupEnd;
          var b = {
            configurable: !0,
            enumerable: !0,
            value: S,
            writable: !0
          };
          Object.defineProperties(console, {
            info: b,
            log: b,
            warn: b,
            error: b,
            group: b,
            groupCollapsed: b,
            groupEnd: b
          });
        }
        Z++;
      }
    }
    function x() {
      {
        if (Z--, Z === 0) {
          var b = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: z({}, b, {
              value: K
            }),
            info: z({}, b, {
              value: X
            }),
            warn: z({}, b, {
              value: te
            }),
            error: z({}, b, {
              value: J
            }),
            group: z({}, b, {
              value: P
            }),
            groupCollapsed: z({}, b, {
              value: D
            }),
            groupEnd: z({}, b, {
              value: H
            })
          });
        }
        Z < 0 && w("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var j = E.ReactCurrentDispatcher, U;
    function T(b, I, G) {
      {
        if (U === void 0)
          try {
            throw Error();
          } catch (le) {
            var ne = le.stack.trim().match(/\n( *(at )?)/);
            U = ne && ne[1] || "";
          }
        return `
` + U + b;
      }
    }
    var q = !1, A;
    {
      var Y = typeof WeakMap == "function" ? WeakMap : Map;
      A = new Y();
    }
    function B(b, I) {
      if (!b || q)
        return "";
      {
        var G = A.get(b);
        if (G !== void 0)
          return G;
      }
      var ne;
      q = !0;
      var le = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var ce;
      ce = j.current, j.current = null, $();
      try {
        if (I) {
          var se = function() {
            throw Error();
          };
          if (Object.defineProperty(se.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(se, []);
            } catch (je) {
              ne = je;
            }
            Reflect.construct(b, [], se);
          } else {
            try {
              se.call();
            } catch (je) {
              ne = je;
            }
            b.call(se.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (je) {
            ne = je;
          }
          b();
        }
      } catch (je) {
        if (je && ne && typeof je.stack == "string") {
          for (var ie = je.stack.split(`
`), Se = ne.stack.split(`
`), de = ie.length - 1, he = Se.length - 1; de >= 1 && he >= 0 && ie[de] !== Se[he]; )
            he--;
          for (; de >= 1 && he >= 0; de--, he--)
            if (ie[de] !== Se[he]) {
              if (de !== 1 || he !== 1)
                do
                  if (de--, he--, he < 0 || ie[de] !== Se[he]) {
                    var Ve = `
` + ie[de].replace(" at new ", " at ");
                    return b.displayName && Ve.includes("<anonymous>") && (Ve = Ve.replace("<anonymous>", b.displayName)), typeof b == "function" && A.set(b, Ve), Ve;
                  }
                while (de >= 1 && he >= 0);
              break;
            }
        }
      } finally {
        q = !1, j.current = ce, x(), Error.prepareStackTrace = le;
      }
      var xt = b ? b.displayName || b.name : "", vt = xt ? T(xt) : "";
      return typeof b == "function" && A.set(b, vt), vt;
    }
    function ue(b, I, G) {
      return B(b, !1);
    }
    function fe(b) {
      var I = b.prototype;
      return !!(I && I.isReactComponent);
    }
    function oe(b, I, G) {
      if (b == null)
        return "";
      if (typeof b == "function")
        return B(b, fe(b));
      if (typeof b == "string")
        return T(b);
      switch (b) {
        case u:
          return T("Suspense");
        case c:
          return T("SuspenseList");
      }
      if (typeof b == "object")
        switch (b.$$typeof) {
          case l:
            return ue(b.render);
          case p:
            return oe(b.type, I, G);
          case d: {
            var ne = b, le = ne._payload, ce = ne._init;
            try {
              return oe(ce(le), I, G);
            } catch {
            }
          }
        }
      return "";
    }
    var Ae = Object.prototype.hasOwnProperty, Ze = {}, Ge = E.ReactDebugCurrentFrame;
    function Ie(b) {
      if (b) {
        var I = b._owner, G = oe(b.type, b._source, I ? I.type : null);
        Ge.setExtraStackFrame(G);
      } else
        Ge.setExtraStackFrame(null);
    }
    function et(b, I, G, ne, le) {
      {
        var ce = Function.call.bind(Ae);
        for (var se in b)
          if (ce(b, se)) {
            var ie = void 0;
            try {
              if (typeof b[se] != "function") {
                var Se = Error((ne || "React class") + ": " + G + " type `" + se + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof b[se] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw Se.name = "Invariant Violation", Se;
              }
              ie = b[se](I, se, ne, G, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (de) {
              ie = de;
            }
            ie && !(ie instanceof Error) && (Ie(le), w("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", ne || "React class", G, se, typeof ie), Ie(null)), ie instanceof Error && !(ie.message in Ze) && (Ze[ie.message] = !0, Ie(le), w("Failed %s type: %s", G, ie.message), Ie(null));
          }
      }
    }
    var Ye = Array.isArray;
    function _e(b) {
      return Ye(b);
    }
    function Qe(b) {
      {
        var I = typeof Symbol == "function" && Symbol.toStringTag, G = I && b[Symbol.toStringTag] || b.constructor.name || "Object";
        return G;
      }
    }
    function at(b) {
      try {
        return Pe(b), !1;
      } catch {
        return !0;
      }
    }
    function Pe(b) {
      return "" + b;
    }
    function Me(b) {
      if (at(b))
        return w("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Qe(b)), Pe(b);
    }
    var Je = E.ReactCurrentOwner, We = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, Re, nt;
    function De(b) {
      if (Ae.call(b, "ref")) {
        var I = Object.getOwnPropertyDescriptor(b, "ref").get;
        if (I && I.isReactWarning)
          return !1;
      }
      return b.ref !== void 0;
    }
    function yt(b) {
      if (Ae.call(b, "key")) {
        var I = Object.getOwnPropertyDescriptor(b, "key").get;
        if (I && I.isReactWarning)
          return !1;
      }
      return b.key !== void 0;
    }
    function ot(b, I) {
      typeof b.ref == "string" && Je.current;
    }
    function st(b, I) {
      {
        var G = function() {
          Re || (Re = !0, w("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", I));
        };
        G.isReactWarning = !0, Object.defineProperty(b, "key", {
          get: G,
          configurable: !0
        });
      }
    }
    function ct(b, I) {
      {
        var G = function() {
          nt || (nt = !0, w("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", I));
        };
        G.isReactWarning = !0, Object.defineProperty(b, "ref", {
          get: G,
          configurable: !0
        });
      }
    }
    var bt = function(b, I, G, ne, le, ce, se) {
      var ie = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: b,
        key: I,
        ref: G,
        props: se,
        // Record the component responsible for creating this element.
        _owner: ce
      };
      return ie._store = {}, Object.defineProperty(ie._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(ie, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ne
      }), Object.defineProperty(ie, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: le
      }), Object.freeze && (Object.freeze(ie.props), Object.freeze(ie)), ie;
    };
    function pt(b, I, G, ne, le) {
      {
        var ce, se = {}, ie = null, Se = null;
        G !== void 0 && (Me(G), ie = "" + G), yt(I) && (Me(I.key), ie = "" + I.key), De(I) && (Se = I.ref, ot(I));
        for (ce in I)
          Ae.call(I, ce) && !We.hasOwnProperty(ce) && (se[ce] = I[ce]);
        if (b && b.defaultProps) {
          var de = b.defaultProps;
          for (ce in de)
            se[ce] === void 0 && (se[ce] = de[ce]);
        }
        if (ie || Se) {
          var he = typeof b == "function" ? b.displayName || b.name || "Unknown" : b;
          ie && st(se, he), Se && ct(se, he);
        }
        return bt(b, ie, Se, le, ne, Je.current, se);
      }
    }
    var dt = E.ReactCurrentOwner, tt = E.ReactDebugCurrentFrame;
    function Xe(b) {
      if (b) {
        var I = b._owner, G = oe(b.type, b._source, I ? I.type : null);
        tt.setExtraStackFrame(G);
      } else
        tt.setExtraStackFrame(null);
    }
    var wt;
    wt = !1;
    function Ct(b) {
      return typeof b == "object" && b !== null && b.$$typeof === t;
    }
    function ft() {
      {
        if (dt.current) {
          var b = V(dt.current.type);
          if (b)
            return `

Check the render method of \`` + b + "`.";
        }
        return "";
      }
    }
    function bn(b) {
      return "";
    }
    var ht = {};
    function wn(b) {
      {
        var I = ft();
        if (!I) {
          var G = typeof b == "string" ? b : b.displayName || b.name;
          G && (I = `

Check the top-level render call using <` + G + ">.");
        }
        return I;
      }
    }
    function gt(b, I) {
      {
        if (!b._store || b._store.validated || b.key != null)
          return;
        b._store.validated = !0;
        var G = wn(I);
        if (ht[G])
          return;
        ht[G] = !0;
        var ne = "";
        b && b._owner && b._owner !== dt.current && (ne = " It was passed a child from " + V(b._owner.type) + "."), Xe(b), w('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', G, ne), Xe(null);
      }
    }
    function Mt(b, I) {
      {
        if (typeof b != "object")
          return;
        if (_e(b))
          for (var G = 0; G < b.length; G++) {
            var ne = b[G];
            Ct(ne) && gt(ne, I);
          }
        else if (Ct(b))
          b._store && (b._store.validated = !0);
        else if (b) {
          var le = v(b);
          if (typeof le == "function" && le !== b.entries)
            for (var ce = le.call(b), se; !(se = ce.next()).done; )
              Ct(se.value) && gt(se.value, I);
        }
      }
    }
    function ir(b) {
      {
        var I = b.type;
        if (I == null || typeof I == "string")
          return;
        var G;
        if (typeof I == "function")
          G = I.propTypes;
        else if (typeof I == "object" && (I.$$typeof === l || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        I.$$typeof === p))
          G = I.propTypes;
        else
          return;
        if (G) {
          var ne = V(I);
          et(G, b.props, "prop", ne, b);
        } else if (I.PropTypes !== void 0 && !wt) {
          wt = !0;
          var le = V(I);
          w("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", le || "Unknown");
        }
        typeof I.getDefaultProps == "function" && !I.getDefaultProps.isReactClassApproved && w("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function mt(b) {
      {
        for (var I = Object.keys(b.props), G = 0; G < I.length; G++) {
          var ne = I[G];
          if (ne !== "children" && ne !== "key") {
            Xe(b), w("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", ne), Xe(null);
            break;
          }
        }
        b.ref !== null && (Xe(b), w("Invalid attribute `ref` supplied to `React.Fragment`."), Xe(null));
      }
    }
    var re = {};
    function vo(b, I, G, ne, le, ce) {
      {
        var se = N(b);
        if (!se) {
          var ie = "";
          (b === void 0 || typeof b == "object" && b !== null && Object.keys(b).length === 0) && (ie += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var Se = bn();
          Se ? ie += Se : ie += ft();
          var de;
          b === null ? de = "null" : _e(b) ? de = "array" : b !== void 0 && b.$$typeof === t ? (de = "<" + (V(b.type) || "Unknown") + " />", ie = " Did you accidentally export a JSX literal instead of a component?") : de = typeof b, w("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", de, ie);
        }
        var he = pt(b, I, G, le, ce);
        if (he == null)
          return he;
        if (se) {
          var Ve = I.children;
          if (Ve !== void 0)
            if (ne)
              if (_e(Ve)) {
                for (var xt = 0; xt < Ve.length; xt++)
                  Mt(Ve[xt], b);
                Object.freeze && Object.freeze(Ve);
              } else
                w("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Mt(Ve, b);
        }
        if (Ae.call(I, "key")) {
          var vt = V(b), je = Object.keys(I).filter(function(Li) {
            return Li !== "key";
          }), sr = je.length > 0 ? "{key: someKey, " + je.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!re[vt + sr]) {
            var ki = je.length > 0 ? "{" + je.join(": ..., ") + ": ...}" : "{}";
            w(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, sr, vt, ki, vt), re[vt + sr] = !0;
          }
        }
        return b === r ? mt(he) : ir(he), he;
      }
    }
    function Ci(b, I, G) {
      return vo(b, I, G, !0);
    }
    function xi(b, I, G) {
      return vo(b, I, G, !1);
    }
    var Oi = xi, Ei = Ci;
    $h.Fragment = r, $h.jsx = Oi, $h.jsxs = Ei;
  }()), $h;
}
process.env.NODE_ENV === "production" ? WE.exports = Nue() : WE.exports = Fue();
var Mo = WE.exports;
Ke({});
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function bj(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function $o(e) {
  var t, n;
  return bj(e) === !1 ? !1 : (t = e.constructor, t === void 0 ? !0 : (n = t.prototype, !(bj(n) === !1 || n.hasOwnProperty("isPrototypeOf") === !1)));
}
var P4 = Symbol.for("immer-nothing"), wj = Symbol.for("immer-draftable"), Yi = Symbol.for("immer-state"), zue = process.env.NODE_ENV !== "production" ? [
  // All error codes, starting by 0:
  function(e) {
    return `The plugin for '${e}' has not been loaded into Immer. To enable the plugin, import and call \`enable${e}()\` when initializing your application.`;
  },
  function(e) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${e}'`;
  },
  "This object has been frozen and should not be mutated",
  function(e) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + e;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(e) {
    return `'current' expects a draft, got: ${e}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(e) {
    return `'original' expects a draft, got: ${e}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function ui(e, ...t) {
  if (process.env.NODE_ENV !== "production") {
    const n = zue[e], r = typeof n == "function" ? n.apply(null, t) : n;
    throw new Error(`[Immer] ${r}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var vc = Object.getPrototypeOf;
function Nu(e) {
  return !!e && !!e[Yi];
}
function Fu(e) {
  var t;
  return e ? _4(e) || Array.isArray(e) || !!e[wj] || !!((t = e.constructor) != null && t[wj]) || Yb(e) || Xb(e) : !1;
}
var Uue = Object.prototype.constructor.toString();
function _4(e) {
  if (!e || typeof e != "object")
    return !1;
  const t = vc(e);
  if (t === null)
    return !0;
  const n = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
  return n === Object ? !0 : typeof n == "function" && Function.toString.call(n) === Uue;
}
function dv(e, t) {
  Kb(e) === 0 ? Reflect.ownKeys(e).forEach((n) => {
    t(n, e[n], e);
  }) : e.forEach((n, r) => t(r, n, e));
}
function Kb(e) {
  const t = e[Yi];
  return t ? t.type_ : Array.isArray(e) ? 1 : Yb(e) ? 2 : Xb(e) ? 3 : 0;
}
function VE(e, t) {
  return Kb(e) === 2 ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t);
}
function S4(e, t, n) {
  const r = Kb(e);
  r === 2 ? e.set(t, n) : r === 3 ? e.add(n) : e[t] = n;
}
function Hue(e, t) {
  return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && t !== t;
}
function Yb(e) {
  return e instanceof Map;
}
function Xb(e) {
  return e instanceof Set;
}
function eu(e) {
  return e.copy_ || e.base_;
}
function ZE(e, t) {
  if (Yb(e))
    return new Map(e);
  if (Xb(e))
    return new Set(e);
  if (Array.isArray(e))
    return Array.prototype.slice.call(e);
  const n = _4(e);
  if (t === !0 || t === "class_only" && !n) {
    const r = Object.getOwnPropertyDescriptors(e);
    delete r[Yi];
    let o = Reflect.ownKeys(r);
    for (let i = 0; i < o.length; i++) {
      const a = o[i], s = r[a];
      s.writable === !1 && (s.writable = !0, s.configurable = !0), (s.get || s.set) && (r[a] = {
        configurable: !0,
        writable: !0,
        // could live with !!desc.set as well here...
        enumerable: s.enumerable,
        value: e[a]
      });
    }
    return Object.create(vc(e), r);
  } else {
    const r = vc(e);
    if (r !== null && n)
      return { ...e };
    const o = Object.create(r);
    return Object.assign(o, e);
  }
}
function JL(e, t = !1) {
  return Jb(e) || Nu(e) || !Fu(e) || (Kb(e) > 1 && (e.set = e.add = e.clear = e.delete = $ue), Object.freeze(e), t && Object.entries(e).forEach(([n, r]) => JL(r, !0))), e;
}
function $ue() {
  ui(2);
}
function Jb(e) {
  return Object.isFrozen(e);
}
var Wue = {};
function zu(e) {
  const t = Wue[e];
  return t || ui(0, e), t;
}
var Hd;
function M4() {
  return Hd;
}
function Vue(e, t) {
  return {
    drafts_: [],
    parent_: e,
    immer_: t,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0
  };
}
function Cj(e, t) {
  t && (zu("Patches"), e.patches_ = [], e.inversePatches_ = [], e.patchListener_ = t);
}
function qE(e) {
  GE(e), e.drafts_.forEach(Zue), e.drafts_ = null;
}
function GE(e) {
  e === Hd && (Hd = e.parent_);
}
function xj(e) {
  return Hd = Vue(Hd, e);
}
function Zue(e) {
  const t = e[Yi];
  t.type_ === 0 || t.type_ === 1 ? t.revoke_() : t.revoked_ = !0;
}
function Oj(e, t) {
  t.unfinalizedDrafts_ = t.drafts_.length;
  const n = t.drafts_[0];
  return e !== void 0 && e !== n ? (n[Yi].modified_ && (qE(t), ui(4)), Fu(e) && (e = fv(t, e), t.parent_ || hv(t, e)), t.patches_ && zu("Patches").generateReplacementPatches_(
    n[Yi].base_,
    e,
    t.patches_,
    t.inversePatches_
  )) : e = fv(t, n, []), qE(t), t.patches_ && t.patchListener_(t.patches_, t.inversePatches_), e !== P4 ? e : void 0;
}
function fv(e, t, n) {
  if (Jb(t))
    return t;
  const r = t[Yi];
  if (!r)
    return dv(
      t,
      (o, i) => Ej(e, r, t, o, i, n)
    ), t;
  if (r.scope_ !== e)
    return t;
  if (!r.modified_)
    return hv(e, r.base_, !0), r.base_;
  if (!r.finalized_) {
    r.finalized_ = !0, r.scope_.unfinalizedDrafts_--;
    const o = r.copy_;
    let i = o, a = !1;
    r.type_ === 3 && (i = new Set(o), o.clear(), a = !0), dv(
      i,
      (s, l) => Ej(e, r, o, s, l, n, a)
    ), hv(e, o, !1), n && e.patches_ && zu("Patches").generatePatches_(
      r,
      n,
      e.patches_,
      e.inversePatches_
    );
  }
  return r.copy_;
}
function Ej(e, t, n, r, o, i, a) {
  if (process.env.NODE_ENV !== "production" && o === n && ui(5), Nu(o)) {
    const s = i && t && t.type_ !== 3 && // Set objects are atomic since they have no keys.
    !VE(t.assigned_, r) ? i.concat(r) : void 0, l = fv(e, o, s);
    if (S4(n, r, l), Nu(l))
      e.canAutoFreeze_ = !1;
    else
      return;
  } else a && n.add(o);
  if (Fu(o) && !Jb(o)) {
    if (!e.immer_.autoFreeze_ && e.unfinalizedDrafts_ < 1)
      return;
    fv(e, o), (!t || !t.scope_.parent_) && typeof r != "symbol" && Object.prototype.propertyIsEnumerable.call(n, r) && hv(e, o);
  }
}
function hv(e, t, n = !1) {
  !e.parent_ && e.immer_.autoFreeze_ && e.canAutoFreeze_ && JL(t, n);
}
function que(e, t) {
  const n = Array.isArray(e), r = {
    type_: n ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: t ? t.scope_ : M4(),
    // True for both shallow and deep changes.
    modified_: !1,
    // Used during finalization.
    finalized_: !1,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: t,
    // The base state.
    base_: e,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: !1
  };
  let o = r, i = QL;
  n && (o = [r], i = $d);
  const { revoke: a, proxy: s } = Proxy.revocable(o, i);
  return r.draft_ = s, r.revoke_ = a, s;
}
var QL = {
  get(e, t) {
    if (t === Yi)
      return e;
    const n = eu(e);
    if (!VE(n, t))
      return Gue(e, n, t);
    const r = n[t];
    return e.finalized_ || !Fu(r) ? r : r === K0(e.base_, t) ? (Y0(e), e.copy_[t] = YE(r, e)) : r;
  },
  has(e, t) {
    return t in eu(e);
  },
  ownKeys(e) {
    return Reflect.ownKeys(eu(e));
  },
  set(e, t, n) {
    const r = D4(eu(e), t);
    if (r != null && r.set)
      return r.set.call(e.draft_, n), !0;
    if (!e.modified_) {
      const o = K0(eu(e), t), i = o == null ? void 0 : o[Yi];
      if (i && i.base_ === n)
        return e.copy_[t] = n, e.assigned_[t] = !1, !0;
      if (Hue(n, o) && (n !== void 0 || VE(e.base_, t)))
        return !0;
      Y0(e), KE(e);
    }
    return e.copy_[t] === n && // special case: handle new props with value 'undefined'
    (n !== void 0 || t in e.copy_) || // special case: NaN
    Number.isNaN(n) && Number.isNaN(e.copy_[t]) || (e.copy_[t] = n, e.assigned_[t] = !0), !0;
  },
  deleteProperty(e, t) {
    return K0(e.base_, t) !== void 0 || t in e.base_ ? (e.assigned_[t] = !1, Y0(e), KE(e)) : delete e.assigned_[t], e.copy_ && delete e.copy_[t], !0;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(e, t) {
    const n = eu(e), r = Reflect.getOwnPropertyDescriptor(n, t);
    return r && {
      writable: !0,
      configurable: e.type_ !== 1 || t !== "length",
      enumerable: r.enumerable,
      value: n[t]
    };
  },
  defineProperty() {
    ui(11);
  },
  getPrototypeOf(e) {
    return vc(e.base_);
  },
  setPrototypeOf() {
    ui(12);
  }
}, $d = {};
dv(QL, (e, t) => {
  $d[e] = function() {
    return arguments[0] = arguments[0][0], t.apply(this, arguments);
  };
});
$d.deleteProperty = function(e, t) {
  return process.env.NODE_ENV !== "production" && isNaN(parseInt(t)) && ui(13), $d.set.call(this, e, t, void 0);
};
$d.set = function(e, t, n) {
  return process.env.NODE_ENV !== "production" && t !== "length" && isNaN(parseInt(t)) && ui(14), QL.set.call(this, e[0], t, n, e[0]);
};
function K0(e, t) {
  const n = e[Yi];
  return (n ? eu(n) : e)[t];
}
function Gue(e, t, n) {
  var r;
  const o = D4(t, n);
  return o ? "value" in o ? o.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (r = o.get) == null ? void 0 : r.call(e.draft_)
  ) : void 0;
}
function D4(e, t) {
  if (!(t in e))
    return;
  let n = vc(e);
  for (; n; ) {
    const r = Object.getOwnPropertyDescriptor(n, t);
    if (r)
      return r;
    n = vc(n);
  }
}
function KE(e) {
  e.modified_ || (e.modified_ = !0, e.parent_ && KE(e.parent_));
}
function Y0(e) {
  e.copy_ || (e.copy_ = ZE(
    e.base_,
    e.scope_.immer_.useStrictShallowCopy_
  ));
}
var Kue = class {
  constructor(e) {
    this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.produce = (t, n, r) => {
      if (typeof t == "function" && typeof n != "function") {
        const i = n;
        n = t;
        const a = this;
        return function(s = i, ...l) {
          return a.produce(s, (u) => n.call(this, u, ...l));
        };
      }
      typeof n != "function" && ui(6), r !== void 0 && typeof r != "function" && ui(7);
      let o;
      if (Fu(t)) {
        const i = xj(this), a = YE(t, void 0);
        let s = !0;
        try {
          o = n(a), s = !1;
        } finally {
          s ? qE(i) : GE(i);
        }
        return Cj(i, r), Oj(o, i);
      } else if (!t || typeof t != "object") {
        if (o = n(t), o === void 0 && (o = t), o === P4 && (o = void 0), this.autoFreeze_ && JL(o, !0), r) {
          const i = [], a = [];
          zu("Patches").generateReplacementPatches_(t, o, i, a), r(i, a);
        }
        return o;
      } else
        ui(1, t);
    }, this.produceWithPatches = (t, n) => {
      if (typeof t == "function")
        return (i, ...a) => this.produceWithPatches(i, (s) => t(s, ...a));
      let r, o;
      return [this.produce(t, n, (i, a) => {
        r = i, o = a;
      }), r, o];
    }, typeof (e == null ? void 0 : e.autoFreeze) == "boolean" && this.setAutoFreeze(e.autoFreeze), typeof (e == null ? void 0 : e.useStrictShallowCopy) == "boolean" && this.setUseStrictShallowCopy(e.useStrictShallowCopy);
  }
  createDraft(e) {
    Fu(e) || ui(8), Nu(e) && (e = Yue(e));
    const t = xj(this), n = YE(e, void 0);
    return n[Yi].isManual_ = !0, GE(t), n;
  }
  finishDraft(e, t) {
    const n = e && e[Yi];
    (!n || !n.isManual_) && ui(9);
    const { scope_: r } = n;
    return Cj(r, t), Oj(void 0, r);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(e) {
    this.autoFreeze_ = e;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(e) {
    this.useStrictShallowCopy_ = e;
  }
  applyPatches(e, t) {
    let n;
    for (n = t.length - 1; n >= 0; n--) {
      const o = t[n];
      if (o.path.length === 0 && o.op === "replace") {
        e = o.value;
        break;
      }
    }
    n > -1 && (t = t.slice(n + 1));
    const r = zu("Patches").applyPatches_;
    return Nu(e) ? r(e, t) : this.produce(
      e,
      (o) => r(o, t)
    );
  }
};
function YE(e, t) {
  const n = Yb(e) ? zu("MapSet").proxyMap_(e, t) : Xb(e) ? zu("MapSet").proxySet_(e, t) : que(e, t);
  return (t ? t.scope_ : M4()).drafts_.push(n), n;
}
function Yue(e) {
  return Nu(e) || ui(10, e), T4(e);
}
function T4(e) {
  if (!Fu(e) || Jb(e))
    return e;
  const t = e[Yi];
  let n;
  if (t) {
    if (!t.modified_)
      return t.base_;
    t.finalized_ = !0, n = ZE(e, t.scope_.immer_.useStrictShallowCopy_);
  } else
    n = ZE(e, !0);
  return dv(n, (r, o) => {
    S4(n, r, T4(o));
  }), t && (t.finalized_ = !1), n;
}
var Xi = new Kue(), eP = Xi.produce;
Xi.produceWithPatches.bind(
  Xi
);
Xi.setAutoFreeze.bind(Xi);
Xi.setUseStrictShallowCopy.bind(Xi);
Xi.applyPatches.bind(Xi);
var kj = Xi.createDraft.bind(Xi), Lj = Xi.finishDraft.bind(Xi), He = {
  ancestors(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = He.levels(e, t);
    return n ? r = r.slice(1) : r = r.slice(0, -1), r;
  },
  common(e, t) {
    for (var n = [], r = 0; r < e.length && r < t.length; r++) {
      var o = e[r], i = t[r];
      if (o !== i)
        break;
      n.push(o);
    }
    return n;
  },
  compare(e, t) {
    for (var n = Math.min(e.length, t.length), r = 0; r < n; r++) {
      if (e[r] < t[r]) return -1;
      if (e[r] > t[r]) return 1;
    }
    return 0;
  },
  endsAfter(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return He.equals(r, o) && i > a;
  },
  endsAt(e, t) {
    var n = e.length, r = e.slice(0, n), o = t.slice(0, n);
    return He.equals(r, o);
  },
  endsBefore(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return He.equals(r, o) && i < a;
  },
  equals(e, t) {
    return e.length === t.length && e.every((n, r) => n === t[r]);
  },
  hasPrevious(e) {
    return e[e.length - 1] > 0;
  },
  isAfter(e, t) {
    return He.compare(e, t) === 1;
  },
  isAncestor(e, t) {
    return e.length < t.length && He.compare(e, t) === 0;
  },
  isBefore(e, t) {
    return He.compare(e, t) === -1;
  },
  isChild(e, t) {
    return e.length === t.length + 1 && He.compare(e, t) === 0;
  },
  isCommon(e, t) {
    return e.length <= t.length && He.compare(e, t) === 0;
  },
  isDescendant(e, t) {
    return e.length > t.length && He.compare(e, t) === 0;
  },
  isParent(e, t) {
    return e.length + 1 === t.length && He.compare(e, t) === 0;
  },
  isPath(e) {
    return Array.isArray(e) && (e.length === 0 || typeof e[0] == "number");
  },
  isSibling(e, t) {
    if (e.length !== t.length)
      return !1;
    var n = e.slice(0, -1), r = t.slice(0, -1), o = e[e.length - 1], i = t[t.length - 1];
    return o !== i && He.equals(n, r);
  },
  levels(e) {
    for (var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = [], o = 0; o <= e.length; o++)
      r.push(e.slice(0, o));
    return n && r.reverse(), r;
  },
  next(e) {
    if (e.length === 0)
      throw new Error("Cannot get the next path of a root path [".concat(e, "], because it has no next index."));
    var t = e[e.length - 1];
    return e.slice(0, -1).concat(t + 1);
  },
  operationCanTransformPath(e) {
    switch (e.type) {
      case "insert_node":
      case "remove_node":
      case "merge_node":
      case "split_node":
      case "move_node":
        return !0;
      default:
        return !1;
    }
  },
  parent(e) {
    if (e.length === 0)
      throw new Error("Cannot get the parent path of the root path [".concat(e, "]."));
    return e.slice(0, -1);
  },
  previous(e) {
    if (e.length === 0)
      throw new Error("Cannot get the previous path of a root path [".concat(e, "], because it has no previous index."));
    var t = e[e.length - 1];
    if (t <= 0)
      throw new Error("Cannot get the previous path of a first child path [".concat(e, "] because it would result in a negative index."));
    return e.slice(0, -1).concat(t - 1);
  },
  relative(e, t) {
    if (!He.isAncestor(t, e) && !He.equals(e, t))
      throw new Error("Cannot get the relative path of [".concat(e, "] inside ancestor [").concat(t, "], because it is not above or equal to the path."));
    return e.slice(t.length);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!e) return null;
    var r = [...e], {
      affinity: o = "forward"
    } = n;
    if (e.length === 0)
      return r;
    switch (t.type) {
      case "insert_node": {
        var {
          path: i
        } = t;
        (He.equals(i, r) || He.endsBefore(i, r) || He.isAncestor(i, r)) && (r[i.length - 1] += 1);
        break;
      }
      case "remove_node": {
        var {
          path: a
        } = t;
        if (He.equals(a, r) || He.isAncestor(a, r))
          return null;
        He.endsBefore(a, r) && (r[a.length - 1] -= 1);
        break;
      }
      case "merge_node": {
        var {
          path: s,
          position: l
        } = t;
        He.equals(s, r) || He.endsBefore(s, r) ? r[s.length - 1] -= 1 : He.isAncestor(s, r) && (r[s.length - 1] -= 1, r[s.length] += l);
        break;
      }
      case "split_node": {
        var {
          path: u,
          position: c
        } = t;
        if (He.equals(u, r)) {
          if (o === "forward")
            r[r.length - 1] += 1;
          else if (o !== "backward") return null;
        } else He.endsBefore(u, r) ? r[u.length - 1] += 1 : He.isAncestor(u, r) && e[u.length] >= c && (r[u.length - 1] += 1, r[u.length] -= c);
        break;
      }
      case "move_node": {
        var {
          path: p,
          newPath: d
        } = t;
        if (He.equals(p, d))
          return r;
        if (He.isAncestor(p, r) || He.equals(p, r)) {
          var g = d.slice();
          return He.endsBefore(p, d) && p.length < d.length && (g[p.length - 1] -= 1), g.concat(r.slice(p.length));
        } else He.isSibling(p, d) && (He.isAncestor(d, r) || He.equals(d, r)) ? He.endsBefore(p, r) ? r[p.length - 1] -= 1 : r[p.length - 1] += 1 : He.endsBefore(d, r) || He.equals(d, r) || He.isAncestor(d, r) ? (He.endsBefore(p, r) && (r[p.length - 1] -= 1), r[d.length - 1] += 1) : He.endsBefore(p, r) && (He.equals(d, r) && (r[d.length - 1] += 1), r[p.length - 1] -= 1);
        break;
      }
    }
    return r;
  }
};
function Wd(e) {
  "@babel/helpers - typeof";
  return Wd = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Wd(e);
}
function Xue(e, t) {
  if (Wd(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (Wd(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function Jue(e) {
  var t = Xue(e, "string");
  return Wd(t) === "symbol" ? t : String(t);
}
function Lc(e, t, n) {
  return t = Jue(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function Pj(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ep(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Pj(Object(n), !0).forEach(function(r) {
      Lc(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Pj(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Que = (e, t, n) => {
  switch (n.type) {
    case "insert_node": {
      var {
        path: r,
        node: o
      } = n, i = _t.parent(e, r), a = r[r.length - 1];
      if (a > i.children.length)
        throw new Error('Cannot apply an "insert_node" operation at path ['.concat(r, "] because the destination is past the end of the node."));
      if (i.children.splice(a, 0, o), t)
        for (var [s, l] of $t.points(t))
          t[l] = vr.transform(s, n);
      break;
    }
    case "insert_text": {
      var {
        path: u,
        offset: c,
        text: p
      } = n;
      if (p.length === 0) break;
      var d = _t.leaf(e, u), g = d.text.slice(0, c), f = d.text.slice(c);
      if (d.text = g + p + f, t)
        for (var [m, v] of $t.points(t))
          t[v] = vr.transform(m, n);
      break;
    }
    case "merge_node": {
      var {
        path: E
      } = n, w = _t.get(e, E), M = He.previous(E), O = _t.get(e, M), y = _t.parent(e, E), C = E[E.length - 1];
      if (so.isText(w) && so.isText(O))
        O.text += w.text;
      else if (!so.isText(w) && !so.isText(O))
        O.children.push(...w.children);
      else
        throw new Error('Cannot apply a "merge_node" operation at path ['.concat(E, "] to nodes of different interfaces: ").concat(Di.stringify(w), " ").concat(Di.stringify(O)));
      if (y.children.splice(C, 1), t)
        for (var [_, F] of $t.points(t))
          t[F] = vr.transform(_, n);
      break;
    }
    case "move_node": {
      var {
        path: L,
        newPath: N
      } = n;
      if (He.isAncestor(L, N))
        throw new Error("Cannot move a path [".concat(L, "] to new path [").concat(N, "] because the destination is inside itself."));
      var R = _t.get(e, L), W = _t.parent(e, L), V = L[L.length - 1];
      W.children.splice(V, 1);
      var z = He.transform(L, n), Z = _t.get(e, He.parent(z)), K = z[z.length - 1];
      if (Z.children.splice(K, 0, R), t)
        for (var [X, te] of $t.points(t))
          t[te] = vr.transform(X, n);
      break;
    }
    case "remove_node": {
      var {
        path: J
      } = n, P = J[J.length - 1], D = _t.parent(e, J);
      if (D.children.splice(P, 1), t)
        for (var [H, S] of $t.points(t)) {
          var $ = vr.transform(H, n);
          if (t != null && $ != null)
            t[S] = $;
          else {
            var x = void 0, j = void 0;
            for (var [U, T] of _t.texts(e))
              if (He.compare(T, J) === -1)
                x = [U, T];
              else {
                j = [U, T];
                break;
              }
            var q = !1;
            x && j && (He.equals(j[1], J) ? q = !He.hasPrevious(j[1]) : q = He.common(x[1], J).length < He.common(j[1], J).length), x && !q ? (H.path = x[1], H.offset = x[0].text.length) : j ? (H.path = j[1], H.offset = 0) : t = null;
          }
        }
      break;
    }
    case "remove_text": {
      var {
        path: A,
        offset: Y,
        text: B
      } = n;
      if (B.length === 0) break;
      var ue = _t.leaf(e, A), fe = ue.text.slice(0, Y), oe = ue.text.slice(Y + B.length);
      if (ue.text = fe + oe, t)
        for (var [Ae, Ze] of $t.points(t))
          t[Ze] = vr.transform(Ae, n);
      break;
    }
    case "set_node": {
      var {
        path: Ge,
        properties: Ie,
        newProperties: et
      } = n;
      if (Ge.length === 0)
        throw new Error("Cannot set properties on the root node!");
      var Ye = _t.get(e, Ge);
      for (var _e in et) {
        if (_e === "children" || _e === "text")
          throw new Error('Cannot set the "'.concat(_e, '" property of nodes!'));
        var Qe = et[_e];
        Qe == null ? delete Ye[_e] : Ye[_e] = Qe;
      }
      for (var at in Ie)
        et.hasOwnProperty(at) || delete Ye[at];
      break;
    }
    case "set_selection": {
      var {
        newProperties: Pe
      } = n;
      if (Pe == null)
        t = Pe;
      else {
        if (t == null) {
          if (!$t.isRange(Pe))
            throw new Error('Cannot apply an incomplete "set_selection" operation properties '.concat(Di.stringify(Pe), " when there is no current selection."));
          t = ep({}, Pe);
        }
        for (var Me in Pe) {
          var Je = Pe[Me];
          if (Je == null) {
            if (Me === "anchor" || Me === "focus")
              throw new Error('Cannot remove the "'.concat(Me, '" selection property'));
            delete t[Me];
          } else
            t[Me] = Je;
        }
      }
      break;
    }
    case "split_node": {
      var {
        path: We,
        position: Re,
        properties: nt
      } = n;
      if (We.length === 0)
        throw new Error('Cannot apply a "split_node" operation at path ['.concat(We, "] because the root node cannot be split."));
      var De = _t.get(e, We), yt = _t.parent(e, We), ot = We[We.length - 1], st;
      if (so.isText(De)) {
        var ct = De.text.slice(0, Re), bt = De.text.slice(Re);
        De.text = ct, st = ep(ep({}, nt), {}, {
          text: bt
        });
      } else {
        var pt = De.children.slice(0, Re), dt = De.children.slice(Re);
        De.children = pt, st = ep(ep({}, nt), {}, {
          children: dt
        });
      }
      if (yt.children.splice(ot + 1, 0, st), t)
        for (var [tt, Xe] of $t.points(t))
          t[Xe] = vr.transform(tt, n);
      break;
    }
  }
  return t;
}, ece = {
  transform(e, t) {
    e.children = kj(e.children);
    var n = e.selection && kj(e.selection);
    try {
      n = Que(e, n, t);
    } finally {
      e.children = Lj(e.children), n ? e.selection = Nu(n) ? Lj(n) : n : e.selection = null;
    }
  }
}, tce = {
  insertNodes(e, t, n) {
    e.insertNodes(t, n);
  },
  liftNodes(e, t) {
    e.liftNodes(t);
  },
  mergeNodes(e, t) {
    e.mergeNodes(t);
  },
  moveNodes(e, t) {
    e.moveNodes(t);
  },
  removeNodes(e, t) {
    e.removeNodes(t);
  },
  setNodes(e, t, n) {
    e.setNodes(t, n);
  },
  splitNodes(e, t) {
    e.splitNodes(t);
  },
  unsetNodes(e, t, n) {
    e.unsetNodes(t, n);
  },
  unwrapNodes(e, t) {
    e.unwrapNodes(t);
  },
  wrapNodes(e, t, n) {
    e.wrapNodes(t, n);
  }
}, nce = {
  collapse(e, t) {
    e.collapse(t);
  },
  deselect(e) {
    e.deselect();
  },
  move(e, t) {
    e.move(t);
  },
  select(e, t) {
    e.select(t);
  },
  setPoint(e, t, n) {
    e.setPoint(t, n);
  },
  setSelection(e, t) {
    e.setSelection(t);
  }
}, j4 = (e, t) => {
  for (var n in e) {
    var r = e[n], o = t[n];
    if ($o(r) && $o(o)) {
      if (!j4(r, o)) return !1;
    } else if (Array.isArray(r) && Array.isArray(o)) {
      if (r.length !== o.length) return !1;
      for (var i = 0; i < r.length; i++)
        if (r[i] !== o[i]) return !1;
    } else if (r !== o)
      return !1;
  }
  for (var a in t)
    if (e[a] === void 0 && t[a] !== void 0)
      return !1;
  return !0;
};
function rce(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), o, i;
  for (i = 0; i < r.length; i++)
    o = r[i], !(t.indexOf(o) >= 0) && (n[o] = e[o]);
  return n;
}
function Vd(e, t) {
  if (e == null) return {};
  var n = rce(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (o = 0; o < i.length; o++)
      r = i[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
var oce = ["anchor", "focus"];
function _j(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ice(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? _j(Object(n), !0).forEach(function(r) {
      Lc(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : _j(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var $t = {
  edges(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, {
      anchor: r,
      focus: o
    } = e;
    return $t.isBackward(e) === n ? [r, o] : [o, r];
  },
  end(e) {
    var [, t] = $t.edges(e);
    return t;
  },
  equals(e, t) {
    return vr.equals(e.anchor, t.anchor) && vr.equals(e.focus, t.focus);
  },
  includes(e, t) {
    if ($t.isRange(t)) {
      if ($t.includes(e, t.anchor) || $t.includes(e, t.focus))
        return !0;
      var [n, r] = $t.edges(e), [o, i] = $t.edges(t);
      return vr.isBefore(n, o) && vr.isAfter(r, i);
    }
    var [a, s] = $t.edges(e), l = !1, u = !1;
    return vr.isPoint(t) ? (l = vr.compare(t, a) >= 0, u = vr.compare(t, s) <= 0) : (l = He.compare(t, a.path) >= 0, u = He.compare(t, s.path) <= 0), l && u;
  },
  intersection(e, t) {
    var n = Vd(e, oce), [r, o] = $t.edges(e), [i, a] = $t.edges(t), s = vr.isBefore(r, i) ? i : r, l = vr.isBefore(o, a) ? o : a;
    return vr.isBefore(l, s) ? null : ice({
      anchor: s,
      focus: l
    }, n);
  },
  isBackward(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return vr.isAfter(t, n);
  },
  isCollapsed(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return vr.equals(t, n);
  },
  isExpanded(e) {
    return !$t.isCollapsed(e);
  },
  isForward(e) {
    return !$t.isBackward(e);
  },
  isRange(e) {
    return $o(e) && vr.isPoint(e.anchor) && vr.isPoint(e.focus);
  },
  *points(e) {
    yield [e.anchor, "anchor"], yield [e.focus, "focus"];
  },
  start(e) {
    var [t] = $t.edges(e);
    return t;
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return eP(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "inward"
      } = n, i, a;
      if (o === "inward") {
        var s = $t.isCollapsed(r);
        $t.isForward(r) ? (i = "forward", a = s ? i : "backward") : (i = "backward", a = s ? i : "forward");
      } else o === "outward" ? $t.isForward(r) ? (i = "backward", a = "forward") : (i = "forward", a = "backward") : (i = o, a = o);
      var l = vr.transform(r.anchor, t, {
        affinity: i
      }), u = vr.transform(r.focus, t, {
        affinity: a
      });
      if (!l || !u)
        return null;
      r.anchor = l, r.focus = u;
    });
  }
}, Sj = (e) => $o(e) && _t.isNodeList(e.children) && !Kn.isEditor(e), oa = {
  isAncestor(e) {
    return $o(e) && _t.isNodeList(e.children);
  },
  isElement: Sj,
  isElementList(e) {
    return Array.isArray(e) && e.every((t) => oa.isElement(t));
  },
  isElementProps(e) {
    return e.children !== void 0;
  },
  isElementType: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "type";
    return Sj(e) && e[n] === t;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "children" && e[n] !== t[n])
        return !1;
    return !0;
  }
}, sce = ["children"], ace = ["text"], Mj = /* @__PURE__ */ new WeakMap(), _t = {
  ancestor(e, t) {
    var n = _t.get(e, t);
    if (so.isText(n))
      throw new Error("Cannot get the ancestor node at path [".concat(t, "] because it refers to a text node instead: ").concat(Di.stringify(n)));
    return n;
  },
  ancestors(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of He.ancestors(t, n)) {
        var o = _t.ancestor(e, r), i = [o, r];
        yield i;
      }
    }();
  },
  child(e, t) {
    if (so.isText(e))
      throw new Error("Cannot get the child of a text node: ".concat(Di.stringify(e)));
    var n = e.children[t];
    if (n == null)
      throw new Error("Cannot get child at index `".concat(t, "` in node: ").concat(Di.stringify(e)));
    return n;
  },
  children(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var {
        reverse: r = !1
      } = n, o = _t.ancestor(e, t), {
        children: i
      } = o, a = r ? i.length - 1 : 0; r ? a >= 0 : a < i.length; ) {
        var s = _t.child(o, a), l = t.concat(a);
        yield [s, l], a = r ? a - 1 : a + 1;
      }
    }();
  },
  common(e, t, n) {
    var r = He.common(t, n), o = _t.get(e, r);
    return [o, r];
  },
  descendant(e, t) {
    var n = _t.get(e, t);
    if (Kn.isEditor(n))
      throw new Error("Cannot get the descendant node at path [".concat(t, "] because it refers to the root editor node instead: ").concat(Di.stringify(n)));
    return n;
  },
  descendants(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of _t.nodes(e, t))
        r.length !== 0 && (yield [n, r]);
    }();
  },
  elements(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of _t.nodes(e, t))
        oa.isElement(n) && (yield [n, r]);
    }();
  },
  extractProps(e) {
    if (oa.isAncestor(e)) {
      var t = Vd(e, sce);
      return t;
    } else {
      var t = Vd(e, ace);
      return t;
    }
  },
  first(e, t) {
    for (var n = t.slice(), r = _t.get(e, n); r && !(so.isText(r) || r.children.length === 0); )
      r = r.children[0], n.push(0);
    return [r, n];
  },
  fragment(e, t) {
    if (so.isText(e))
      throw new Error("Cannot get a fragment starting from a root text node: ".concat(Di.stringify(e)));
    var n = eP({
      children: e.children
    }, (r) => {
      var [o, i] = $t.edges(t), a = _t.nodes(r, {
        reverse: !0,
        pass: (d) => {
          var [, g] = d;
          return !$t.includes(t, g);
        }
      });
      for (var [, s] of a) {
        if (!$t.includes(t, s)) {
          var l = _t.parent(r, s), u = s[s.length - 1];
          l.children.splice(u, 1);
        }
        if (He.equals(s, i.path)) {
          var c = _t.leaf(r, s);
          c.text = c.text.slice(0, i.offset);
        }
        if (He.equals(s, o.path)) {
          var p = _t.leaf(r, s);
          p.text = p.text.slice(o.offset);
        }
      }
      Kn.isEditor(r) && (r.selection = null);
    });
    return n.children;
  },
  get(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (so.isText(n) || !n.children[o])
        throw new Error("Cannot find a descendant at path [".concat(t, "] in node: ").concat(Di.stringify(e)));
      n = n.children[o];
    }
    return n;
  },
  has(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (so.isText(n) || !n.children[o])
        return !1;
      n = n.children[o];
    }
    return !0;
  },
  isNode(e) {
    return so.isText(e) || oa.isElement(e) || Kn.isEditor(e);
  },
  isNodeList(e) {
    if (!Array.isArray(e))
      return !1;
    var t = Mj.get(e);
    if (t !== void 0)
      return t;
    var n = e.every((r) => _t.isNode(r));
    return Mj.set(e, n), n;
  },
  last(e, t) {
    for (var n = t.slice(), r = _t.get(e, n); r && !(so.isText(r) || r.children.length === 0); ) {
      var o = r.children.length - 1;
      r = r.children[o], n.push(o);
    }
    return [r, n];
  },
  leaf(e, t) {
    var n = _t.get(e, t);
    if (!so.isText(n))
      throw new Error("Cannot get the leaf node at path [".concat(t, "] because it refers to a non-leaf node: ").concat(Di.stringify(n)));
    return n;
  },
  levels(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of He.levels(t, n)) {
        var o = _t.get(e, r);
        yield [o, r];
      }
    }();
  },
  matches(e, t) {
    return oa.isElement(e) && oa.isElementProps(t) && oa.matches(e, t) || so.isText(e) && so.isTextProps(t) && so.matches(e, t);
  },
  nodes(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var {
        pass: n,
        reverse: r = !1
      } = t, {
        from: o = [],
        to: i
      } = t, a = /* @__PURE__ */ new Set(), s = [], l = e; !(i && (r ? He.isBefore(s, i) : He.isAfter(s, i))); ) {
        if (a.has(l) || (yield [l, s]), !a.has(l) && !so.isText(l) && l.children.length !== 0 && (n == null || n([l, s]) === !1)) {
          a.add(l);
          var u = r ? l.children.length - 1 : 0;
          He.isAncestor(s, o) && (u = o[s.length]), s = s.concat(u), l = _t.get(e, s);
          continue;
        }
        if (s.length === 0)
          break;
        if (!r) {
          var c = He.next(s);
          if (_t.has(e, c)) {
            s = c, l = _t.get(e, s);
            continue;
          }
        }
        if (r && s[s.length - 1] !== 0) {
          var p = He.previous(s);
          s = p, l = _t.get(e, s);
          continue;
        }
        s = He.parent(s), l = _t.get(e, s), a.add(l);
      }
    }();
  },
  parent(e, t) {
    var n = He.parent(t), r = _t.get(e, n);
    if (so.isText(r))
      throw new Error("Cannot get the parent of path [".concat(t, "] because it does not exist in the root."));
    return r;
  },
  string(e) {
    return so.isText(e) ? e.text : e.children.map(_t.string).join("");
  },
  texts(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of _t.nodes(e, t))
        so.isText(n) && (yield [n, r]);
    }();
  }
};
function Dj(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Er(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Dj(Object(n), !0).forEach(function(r) {
      Lc(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Dj(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Ip = {
  isNodeOperation(e) {
    return Ip.isOperation(e) && e.type.endsWith("_node");
  },
  isOperation(e) {
    if (!$o(e))
      return !1;
    switch (e.type) {
      case "insert_node":
        return He.isPath(e.path) && _t.isNode(e.node);
      case "insert_text":
        return typeof e.offset == "number" && typeof e.text == "string" && He.isPath(e.path);
      case "merge_node":
        return typeof e.position == "number" && He.isPath(e.path) && $o(e.properties);
      case "move_node":
        return He.isPath(e.path) && He.isPath(e.newPath);
      case "remove_node":
        return He.isPath(e.path) && _t.isNode(e.node);
      case "remove_text":
        return typeof e.offset == "number" && typeof e.text == "string" && He.isPath(e.path);
      case "set_node":
        return He.isPath(e.path) && $o(e.properties) && $o(e.newProperties);
      case "set_selection":
        return e.properties === null && $t.isRange(e.newProperties) || e.newProperties === null && $t.isRange(e.properties) || $o(e.properties) && $o(e.newProperties);
      case "split_node":
        return He.isPath(e.path) && typeof e.position == "number" && $o(e.properties);
      default:
        return !1;
    }
  },
  isOperationList(e) {
    return Array.isArray(e) && e.every((t) => Ip.isOperation(t));
  },
  isSelectionOperation(e) {
    return Ip.isOperation(e) && e.type.endsWith("_selection");
  },
  isTextOperation(e) {
    return Ip.isOperation(e) && e.type.endsWith("_text");
  },
  inverse(e) {
    switch (e.type) {
      case "insert_node":
        return Er(Er({}, e), {}, {
          type: "remove_node"
        });
      case "insert_text":
        return Er(Er({}, e), {}, {
          type: "remove_text"
        });
      case "merge_node":
        return Er(Er({}, e), {}, {
          type: "split_node",
          path: He.previous(e.path)
        });
      case "move_node": {
        var {
          newPath: t,
          path: n
        } = e;
        if (He.equals(t, n))
          return e;
        if (He.isSibling(n, t))
          return Er(Er({}, e), {}, {
            path: t,
            newPath: n
          });
        var r = He.transform(n, e), o = He.transform(He.next(n), e);
        return Er(Er({}, e), {}, {
          path: r,
          newPath: o
        });
      }
      case "remove_node":
        return Er(Er({}, e), {}, {
          type: "insert_node"
        });
      case "remove_text":
        return Er(Er({}, e), {}, {
          type: "insert_text"
        });
      case "set_node": {
        var {
          properties: i,
          newProperties: a
        } = e;
        return Er(Er({}, e), {}, {
          properties: a,
          newProperties: i
        });
      }
      case "set_selection": {
        var {
          properties: s,
          newProperties: l
        } = e;
        return s == null ? Er(Er({}, e), {}, {
          properties: l,
          newProperties: null
        }) : l == null ? Er(Er({}, e), {}, {
          properties: null,
          newProperties: s
        }) : Er(Er({}, e), {}, {
          properties: l,
          newProperties: s
        });
      }
      case "split_node":
        return Er(Er({}, e), {}, {
          type: "merge_node",
          path: He.next(e.path)
        });
    }
  }
}, Tj = /* @__PURE__ */ new WeakMap(), lce = (e) => {
  var t = Tj.get(e);
  if (t !== void 0)
    return t;
  if (!$o(e))
    return !1;
  var n = typeof e.addMark == "function" && typeof e.apply == "function" && typeof e.deleteFragment == "function" && typeof e.insertBreak == "function" && typeof e.insertSoftBreak == "function" && typeof e.insertFragment == "function" && typeof e.insertNode == "function" && typeof e.insertText == "function" && typeof e.isElementReadOnly == "function" && typeof e.isInline == "function" && typeof e.isSelectable == "function" && typeof e.isVoid == "function" && typeof e.normalizeNode == "function" && typeof e.onChange == "function" && typeof e.removeMark == "function" && typeof e.getDirtyPaths == "function" && (e.marks === null || $o(e.marks)) && (e.selection === null || $t.isRange(e.selection)) && _t.isNodeList(e.children) && Ip.isOperationList(e.operations);
  return Tj.set(e, n), n;
}, Kn = {
  above(e, t) {
    return e.above(t);
  },
  addMark(e, t, n) {
    e.addMark(t, n);
  },
  after(e, t, n) {
    return e.after(t, n);
  },
  before(e, t, n) {
    return e.before(t, n);
  },
  deleteBackward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteBackward(n);
  },
  deleteForward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteForward(n);
  },
  deleteFragment(e, t) {
    e.deleteFragment(t);
  },
  edges(e, t) {
    return e.edges(t);
  },
  elementReadOnly(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return e.elementReadOnly(t);
  },
  end(e, t) {
    return e.end(t);
  },
  first(e, t) {
    return e.first(t);
  },
  fragment(e, t) {
    return e.fragment(t);
  },
  hasBlocks(e, t) {
    return e.hasBlocks(t);
  },
  hasInlines(e, t) {
    return e.hasInlines(t);
  },
  hasPath(e, t) {
    return e.hasPath(t);
  },
  hasTexts(e, t) {
    return e.hasTexts(t);
  },
  insertBreak(e) {
    e.insertBreak();
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertNode(e, t) {
    e.insertNode(t);
  },
  insertSoftBreak(e) {
    e.insertSoftBreak();
  },
  insertText(e, t) {
    e.insertText(t);
  },
  isBlock(e, t) {
    return e.isBlock(t);
  },
  isEdge(e, t, n) {
    return e.isEdge(t, n);
  },
  isEditor(e) {
    return lce(e);
  },
  isElementReadOnly(e, t) {
    return e.isElementReadOnly(t);
  },
  isEmpty(e, t) {
    return e.isEmpty(t);
  },
  isEnd(e, t, n) {
    return e.isEnd(t, n);
  },
  isInline(e, t) {
    return e.isInline(t);
  },
  isNormalizing(e) {
    return e.isNormalizing();
  },
  isSelectable(e, t) {
    return e.isSelectable(t);
  },
  isStart(e, t, n) {
    return e.isStart(t, n);
  },
  isVoid(e, t) {
    return e.isVoid(t);
  },
  last(e, t) {
    return e.last(t);
  },
  leaf(e, t, n) {
    return e.leaf(t, n);
  },
  levels(e, t) {
    return e.levels(t);
  },
  marks(e) {
    return e.getMarks();
  },
  next(e, t) {
    return e.next(t);
  },
  node(e, t, n) {
    return e.node(t, n);
  },
  nodes(e, t) {
    return e.nodes(t);
  },
  normalize(e, t) {
    e.normalize(t);
  },
  parent(e, t, n) {
    return e.parent(t, n);
  },
  path(e, t, n) {
    return e.path(t, n);
  },
  pathRef(e, t, n) {
    return e.pathRef(t, n);
  },
  pathRefs(e) {
    return e.pathRefs();
  },
  point(e, t, n) {
    return e.point(t, n);
  },
  pointRef(e, t, n) {
    return e.pointRef(t, n);
  },
  pointRefs(e) {
    return e.pointRefs();
  },
  positions(e, t) {
    return e.positions(t);
  },
  previous(e, t) {
    return e.previous(t);
  },
  range(e, t, n) {
    return e.range(t, n);
  },
  rangeRef(e, t, n) {
    return e.rangeRef(t, n);
  },
  rangeRefs(e) {
    return e.rangeRefs();
  },
  removeMark(e, t) {
    e.removeMark(t);
  },
  setNormalizing(e, t) {
    e.setNormalizing(t);
  },
  start(e, t) {
    return e.start(t);
  },
  string(e, t, n) {
    return e.string(t, n);
  },
  unhangRange(e, t, n) {
    return e.unhangRange(t, n);
  },
  void(e, t) {
    return e.void(t);
  },
  withoutNormalizing(e, t) {
    e.withoutNormalizing(t);
  },
  shouldMergeNodesRemovePrevNode: (e, t, n) => e.shouldMergeNodesRemovePrevNode(t, n)
};
function jj(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Aj(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? jj(Object(n), !0).forEach(function(r) {
      Lc(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : jj(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var vr = {
  compare(e, t) {
    var n = He.compare(e.path, t.path);
    return n === 0 ? e.offset < t.offset ? -1 : e.offset > t.offset ? 1 : 0 : n;
  },
  isAfter(e, t) {
    return vr.compare(e, t) === 1;
  },
  isBefore(e, t) {
    return vr.compare(e, t) === -1;
  },
  equals(e, t) {
    return e.offset === t.offset && He.equals(e.path, t.path);
  },
  isPoint(e) {
    return $o(e) && typeof e.offset == "number" && He.isPath(e.path);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return eP(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "forward"
      } = n, {
        path: i,
        offset: a
      } = r;
      switch (t.type) {
        case "insert_node":
        case "move_node": {
          r.path = He.transform(i, t, n);
          break;
        }
        case "insert_text": {
          He.equals(t.path, i) && (t.offset < a || t.offset === a && o === "forward") && (r.offset += t.text.length);
          break;
        }
        case "merge_node": {
          He.equals(t.path, i) && (r.offset += t.position), r.path = He.transform(i, t, n);
          break;
        }
        case "remove_text": {
          He.equals(t.path, i) && t.offset <= a && (r.offset -= Math.min(a - t.offset, t.text.length));
          break;
        }
        case "remove_node": {
          if (He.equals(t.path, i) || He.isAncestor(t.path, i))
            return null;
          r.path = He.transform(i, t, n);
          break;
        }
        case "split_node": {
          if (He.equals(t.path, i)) {
            if (t.position === a && o == null)
              return null;
            (t.position < a || t.position === a && o === "forward") && (r.offset -= t.position, r.path = He.transform(i, t, Aj(Aj({}, n), {}, {
              affinity: "forward"
            })));
          } else
            r.path = He.transform(i, t, n);
          break;
        }
      }
    });
  }
}, Ij = void 0, Di = {
  setScrubber(e) {
    Ij = e;
  },
  stringify(e) {
    return JSON.stringify(e, Ij);
  }
}, uce = ["text"], cce = ["anchor", "focus"];
function Rj(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Vs(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Rj(Object(n), !0).forEach(function(r) {
      Lc(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Rj(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var so = {
  equals(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      loose: r = !1
    } = n;
    function o(i) {
      var a = Vd(i, uce);
      return a;
    }
    return j4(r ? o(e) : e, r ? o(t) : t);
  },
  isText(e) {
    return $o(e) && typeof e.text == "string";
  },
  isTextList(e) {
    return Array.isArray(e) && e.every((t) => so.isText(t));
  },
  isTextProps(e) {
    return e.text !== void 0;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "text" && (!e.hasOwnProperty(n) || e[n] !== t[n]))
        return !1;
    return !0;
  },
  decorations(e, t) {
    var n = [Vs({}, e)];
    for (var r of t) {
      var o = Vd(r, cce), [i, a] = $t.edges(r), s = [], l = 0, u = i.offset, c = a.offset;
      for (var p of n) {
        var {
          length: d
        } = p.text, g = l;
        if (l += d, u <= g && l <= c) {
          Object.assign(p, o), s.push(p);
          continue;
        }
        if (u !== c && (u === l || c === g) || u > l || c < g || c === g && g !== 0) {
          s.push(p);
          continue;
        }
        var f = p, m = void 0, v = void 0;
        if (c < l) {
          var E = c - g;
          v = Vs(Vs({}, f), {}, {
            text: f.text.slice(E)
          }), f = Vs(Vs({}, f), {}, {
            text: f.text.slice(0, E)
          });
        }
        if (u > g) {
          var w = u - g;
          m = Vs(Vs({}, f), {}, {
            text: f.text.slice(0, w)
          }), f = Vs(Vs({}, f), {}, {
            text: f.text.slice(w)
          });
        }
        Object.assign(f, o), m && s.push(m), s.push(f), v && s.push(v);
      }
      n = s;
    }
    return n;
  }
}, pce = (e) => e.selection ? e.selection : e.children.length > 0 ? Kn.end(e, []) : [0], pr;
(function(e) {
  e[e.None = 0] = "None", e[e.Extend = 1] = "Extend", e[e.ZWJ = 2] = "ZWJ", e[e.RI = 4] = "RI", e[e.Prepend = 8] = "Prepend", e[e.SpacingMark = 16] = "SpacingMark", e[e.L = 32] = "L", e[e.V = 64] = "V", e[e.T = 128] = "T", e[e.LV = 256] = "LV", e[e.LVT = 512] = "LVT", e[e.ExtPict = 1024] = "ExtPict", e[e.Any = 2048] = "Any";
})(pr || (pr = {}));
pr.L, pr.L | pr.V | pr.LV | pr.LVT, pr.LV | pr.V, pr.V | pr.T, pr.LVT | pr.T, pr.T, pr.Any, pr.Extend | pr.ZWJ, pr.Any, pr.SpacingMark, pr.Prepend, pr.Any, pr.ZWJ, pr.ExtPict, pr.RI, pr.RI;
var dce = {
  delete(e, t) {
    e.delete(t);
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertText(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Kn.withoutNormalizing(e, () => {
      var {
        voids: r = !1
      } = n, {
        at: o = pce(e)
      } = n;
      if (He.isPath(o) && (o = Kn.range(e, o)), $t.isRange(o))
        if ($t.isCollapsed(o))
          o = o.anchor;
        else {
          var i = $t.end(o);
          if (!r && Kn.void(e, {
            at: i
          }))
            return;
          var a = $t.start(o), s = Kn.pointRef(e, a), l = Kn.pointRef(e, i);
          gv.delete(e, {
            at: o,
            voids: r
          });
          var u = s.unref(), c = l.unref();
          o = u || c, gv.setSelection(e, {
            anchor: o,
            focus: o
          });
        }
      if (!(!r && Kn.void(e, {
        at: o
      }) || Kn.elementReadOnly(e, {
        at: o
      }))) {
        var {
          path: p,
          offset: d
        } = o;
        t.length > 0 && e.apply({
          type: "insert_text",
          path: p,
          offset: d,
          text: t
        });
      }
    });
  }
};
function Bj(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Wh(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Bj(Object(n), !0).forEach(function(r) {
      Lc(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Bj(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var gv = Wh(Wh(Wh(Wh({}, ece), tce), nce), dce), A4 = {}, tP = {}, nP = {}, Yu = {}, rP = {}, oP = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Doctype = e.CDATA = e.Tag = e.Style = e.Script = e.Comment = e.Directive = e.Text = e.Root = e.isTag = e.ElementType = void 0;
  var t;
  (function(r) {
    r.Root = "root", r.Text = "text", r.Directive = "directive", r.Comment = "comment", r.Script = "script", r.Style = "style", r.Tag = "tag", r.CDATA = "cdata", r.Doctype = "doctype";
  })(t = e.ElementType || (e.ElementType = {}));
  function n(r) {
    return r.type === t.Tag || r.type === t.Script || r.type === t.Style;
  }
  e.isTag = n, e.Root = t.Root, e.Text = t.Text, e.Directive = t.Directive, e.Comment = t.Comment, e.Script = t.Script, e.Style = t.Style, e.Tag = t.Tag, e.CDATA = t.CDATA, e.Doctype = t.Doctype;
})(oP);
var Xt = {}, xl = nr && nr.__extends || /* @__PURE__ */ function() {
  var e = function(t, n) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, o) {
      r.__proto__ = o;
    } || function(r, o) {
      for (var i in o) Object.prototype.hasOwnProperty.call(o, i) && (r[i] = o[i]);
    }, e(t, n);
  };
  return function(t, n) {
    if (typeof n != "function" && n !== null)
      throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
    e(t, n);
    function r() {
      this.constructor = t;
    }
    t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
  };
}(), Yp = nr && nr.__assign || function() {
  return Yp = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) {
      t = arguments[n];
      for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
    }
    return e;
  }, Yp.apply(this, arguments);
};
Object.defineProperty(Xt, "__esModule", { value: !0 });
Xt.cloneNode = Xt.hasChildren = Xt.isDocument = Xt.isDirective = Xt.isComment = Xt.isText = Xt.isCDATA = Xt.isTag = Xt.Element = Xt.Document = Xt.CDATA = Xt.NodeWithChildren = Xt.ProcessingInstruction = Xt.Comment = Xt.Text = Xt.DataNode = Xt.Node = void 0;
var mi = oP, iP = (
  /** @class */
  function() {
    function e() {
      this.parent = null, this.prev = null, this.next = null, this.startIndex = null, this.endIndex = null;
    }
    return Object.defineProperty(e.prototype, "parentNode", {
      // Read-write aliases for properties
      /**
       * Same as {@link parent}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.parent;
      },
      set: function(t) {
        this.parent = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "previousSibling", {
      /**
       * Same as {@link prev}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.prev;
      },
      set: function(t) {
        this.prev = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "nextSibling", {
      /**
       * Same as {@link next}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.next;
      },
      set: function(t) {
        this.next = t;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.cloneNode = function(t) {
      return t === void 0 && (t = !1), sP(this, t);
    }, e;
  }()
);
Xt.Node = iP;
var Qb = (
  /** @class */
  function(e) {
    xl(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.data = n, r;
    }
    return Object.defineProperty(t.prototype, "nodeValue", {
      /**
       * Same as {@link data}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.data;
      },
      set: function(n) {
        this.data = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(iP)
);
Xt.DataNode = Qb;
var I4 = (
  /** @class */
  function(e) {
    xl(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = mi.ElementType.Text, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 3;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Qb)
);
Xt.Text = I4;
var R4 = (
  /** @class */
  function(e) {
    xl(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = mi.ElementType.Comment, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 8;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Qb)
);
Xt.Comment = R4;
var B4 = (
  /** @class */
  function(e) {
    xl(t, e);
    function t(n, r) {
      var o = e.call(this, r) || this;
      return o.name = n, o.type = mi.ElementType.Directive, o;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Qb)
);
Xt.ProcessingInstruction = B4;
var ew = (
  /** @class */
  function(e) {
    xl(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.children = n, r;
    }
    return Object.defineProperty(t.prototype, "firstChild", {
      // Aliases
      /** First child of the node. */
      get: function() {
        var n;
        return (n = this.children[0]) !== null && n !== void 0 ? n : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "lastChild", {
      /** Last child of the node. */
      get: function() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "childNodes", {
      /**
       * Same as {@link children}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.children;
      },
      set: function(n) {
        this.children = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(iP)
);
Xt.NodeWithChildren = ew;
var N4 = (
  /** @class */
  function(e) {
    xl(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = mi.ElementType.CDATA, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 4;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(ew)
);
Xt.CDATA = N4;
var F4 = (
  /** @class */
  function(e) {
    xl(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = mi.ElementType.Root, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 9;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(ew)
);
Xt.Document = F4;
var z4 = (
  /** @class */
  function(e) {
    xl(t, e);
    function t(n, r, o, i) {
      o === void 0 && (o = []), i === void 0 && (i = n === "script" ? mi.ElementType.Script : n === "style" ? mi.ElementType.Style : mi.ElementType.Tag);
      var a = e.call(this, o) || this;
      return a.name = n, a.attribs = r, a.type = i, a;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "tagName", {
      // DOM Level 1 aliases
      /**
       * Same as {@link name}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.name;
      },
      set: function(n) {
        this.name = n;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "attributes", {
      get: function() {
        var n = this;
        return Object.keys(this.attribs).map(function(r) {
          var o, i;
          return {
            name: r,
            value: n.attribs[r],
            namespace: (o = n["x-attribsNamespace"]) === null || o === void 0 ? void 0 : o[r],
            prefix: (i = n["x-attribsPrefix"]) === null || i === void 0 ? void 0 : i[r]
          };
        });
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(ew)
);
Xt.Element = z4;
function U4(e) {
  return (0, mi.isTag)(e);
}
Xt.isTag = U4;
function H4(e) {
  return e.type === mi.ElementType.CDATA;
}
Xt.isCDATA = H4;
function $4(e) {
  return e.type === mi.ElementType.Text;
}
Xt.isText = $4;
function W4(e) {
  return e.type === mi.ElementType.Comment;
}
Xt.isComment = W4;
function V4(e) {
  return e.type === mi.ElementType.Directive;
}
Xt.isDirective = V4;
function Z4(e) {
  return e.type === mi.ElementType.Root;
}
Xt.isDocument = Z4;
function fce(e) {
  return Object.prototype.hasOwnProperty.call(e, "children");
}
Xt.hasChildren = fce;
function sP(e, t) {
  t === void 0 && (t = !1);
  var n;
  if ($4(e))
    n = new I4(e.data);
  else if (W4(e))
    n = new R4(e.data);
  else if (U4(e)) {
    var r = t ? X0(e.children) : [], o = new z4(e.name, Yp({}, e.attribs), r);
    r.forEach(function(l) {
      return l.parent = o;
    }), e.namespace != null && (o.namespace = e.namespace), e["x-attribsNamespace"] && (o["x-attribsNamespace"] = Yp({}, e["x-attribsNamespace"])), e["x-attribsPrefix"] && (o["x-attribsPrefix"] = Yp({}, e["x-attribsPrefix"])), n = o;
  } else if (H4(e)) {
    var r = t ? X0(e.children) : [], i = new N4(r);
    r.forEach(function(u) {
      return u.parent = i;
    }), n = i;
  } else if (Z4(e)) {
    var r = t ? X0(e.children) : [], a = new F4(r);
    r.forEach(function(u) {
      return u.parent = a;
    }), e["x-mode"] && (a["x-mode"] = e["x-mode"]), n = a;
  } else if (V4(e)) {
    var s = new B4(e.name, e.data);
    e["x-name"] != null && (s["x-name"] = e["x-name"], s["x-publicId"] = e["x-publicId"], s["x-systemId"] = e["x-systemId"]), n = s;
  } else
    throw new Error("Not implemented yet: ".concat(e.type));
  return n.startIndex = e.startIndex, n.endIndex = e.endIndex, e.sourceCodeLocation != null && (n.sourceCodeLocation = e.sourceCodeLocation), n;
}
Xt.cloneNode = sP;
function X0(e) {
  for (var t = e.map(function(r) {
    return sP(r, !0);
  }), n = 1; n < t.length; n++)
    t[n].prev = t[n - 1], t[n - 1].next = t[n];
  return t;
}
(function(e) {
  var t = nr && nr.__createBinding || (Object.create ? function(s, l, u, c) {
    c === void 0 && (c = u);
    var p = Object.getOwnPropertyDescriptor(l, u);
    (!p || ("get" in p ? !l.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
      return l[u];
    } }), Object.defineProperty(s, c, p);
  } : function(s, l, u, c) {
    c === void 0 && (c = u), s[c] = l[u];
  }), n = nr && nr.__exportStar || function(s, l) {
    for (var u in s) u !== "default" && !Object.prototype.hasOwnProperty.call(l, u) && t(l, s, u);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.DomHandler = void 0;
  var r = oP, o = Xt;
  n(Xt, e);
  var i = {
    withStartIndices: !1,
    withEndIndices: !1,
    xmlMode: !1
  }, a = (
    /** @class */
    function() {
      function s(l, u, c) {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null, typeof u == "function" && (c = u, u = i), typeof l == "object" && (u = l, l = void 0), this.callback = l ?? null, this.options = u ?? i, this.elementCB = c ?? null;
      }
      return s.prototype.onparserinit = function(l) {
        this.parser = l;
      }, s.prototype.onreset = function() {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null;
      }, s.prototype.onend = function() {
        this.done || (this.done = !0, this.parser = null, this.handleCallback(null));
      }, s.prototype.onerror = function(l) {
        this.handleCallback(l);
      }, s.prototype.onclosetag = function() {
        this.lastNode = null;
        var l = this.tagStack.pop();
        this.options.withEndIndices && (l.endIndex = this.parser.endIndex), this.elementCB && this.elementCB(l);
      }, s.prototype.onopentag = function(l, u) {
        var c = this.options.xmlMode ? r.ElementType.Tag : void 0, p = new o.Element(l, u, void 0, c);
        this.addNode(p), this.tagStack.push(p);
      }, s.prototype.ontext = function(l) {
        var u = this.lastNode;
        if (u && u.type === r.ElementType.Text)
          u.data += l, this.options.withEndIndices && (u.endIndex = this.parser.endIndex);
        else {
          var c = new o.Text(l);
          this.addNode(c), this.lastNode = c;
        }
      }, s.prototype.oncomment = function(l) {
        if (this.lastNode && this.lastNode.type === r.ElementType.Comment) {
          this.lastNode.data += l;
          return;
        }
        var u = new o.Comment(l);
        this.addNode(u), this.lastNode = u;
      }, s.prototype.oncommentend = function() {
        this.lastNode = null;
      }, s.prototype.oncdatastart = function() {
        var l = new o.Text(""), u = new o.CDATA([l]);
        this.addNode(u), l.parent = u, this.lastNode = l;
      }, s.prototype.oncdataend = function() {
        this.lastNode = null;
      }, s.prototype.onprocessinginstruction = function(l, u) {
        var c = new o.ProcessingInstruction(l, u);
        this.addNode(c);
      }, s.prototype.handleCallback = function(l) {
        if (typeof this.callback == "function")
          this.callback(l, this.dom);
        else if (l)
          throw l;
      }, s.prototype.addNode = function(l) {
        var u = this.tagStack[this.tagStack.length - 1], c = u.children[u.children.length - 1];
        this.options.withStartIndices && (l.startIndex = this.parser.startIndex), this.options.withEndIndices && (l.endIndex = this.parser.endIndex), u.children.push(l), c && (l.prev = c, c.next = l), l.parent = u, this.lastNode = null;
      }, s;
    }()
  );
  e.DomHandler = a, e.default = a;
})(rP);
var q4 = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CARRIAGE_RETURN_PLACEHOLDER_REGEX = e.CARRIAGE_RETURN_PLACEHOLDER = e.CARRIAGE_RETURN_REGEX = e.CARRIAGE_RETURN = e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES = void 0, e.CASE_SENSITIVE_TAG_NAMES = [
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "linearGradient",
    "radialGradient",
    "textPath"
  ], e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES.reduce(function(t, n) {
    return t[n.toLowerCase()] = n, t;
  }, {}), e.CARRIAGE_RETURN = "\r", e.CARRIAGE_RETURN_REGEX = new RegExp(e.CARRIAGE_RETURN, "g"), e.CARRIAGE_RETURN_PLACEHOLDER = "__HTML_DOM_PARSER_CARRIAGE_RETURN_PLACEHOLDER_".concat(Date.now(), "__"), e.CARRIAGE_RETURN_PLACEHOLDER_REGEX = new RegExp(e.CARRIAGE_RETURN_PLACEHOLDER, "g");
})(q4);
Object.defineProperty(Yu, "__esModule", { value: !0 });
Yu.formatAttributes = G4;
Yu.escapeSpecialCharacters = mce;
Yu.revertEscapedCharacters = K4;
Yu.formatDOM = Y4;
var Vh = rP, Zd = q4;
function hce(e) {
  return Zd.CASE_SENSITIVE_TAG_NAMES_MAP[e];
}
function G4(e) {
  for (var t = {}, n = 0, r = e.length; n < r; n++) {
    var o = e[n];
    t[o.name] = o.value;
  }
  return t;
}
function gce(e) {
  e = e.toLowerCase();
  var t = hce(e);
  return t || e;
}
function mce(e) {
  return e.replace(Zd.CARRIAGE_RETURN_REGEX, Zd.CARRIAGE_RETURN_PLACEHOLDER);
}
function K4(e) {
  return e.replace(Zd.CARRIAGE_RETURN_PLACEHOLDER_REGEX, Zd.CARRIAGE_RETURN);
}
function Y4(e, t, n) {
  t === void 0 && (t = null);
  for (var r = [], o, i = 0, a = e.length; i < a; i++) {
    var s = e[i];
    switch (s.nodeType) {
      case 1: {
        var l = gce(s.nodeName);
        o = new Vh.Element(l, G4(s.attributes)), o.children = Y4(
          // template children are on content
          l === "template" ? s.content.childNodes : s.childNodes,
          o
        );
        break;
      }
      case 3:
        o = new Vh.Text(K4(s.nodeValue));
        break;
      case 8:
        o = new Vh.Comment(s.nodeValue);
        break;
      default:
        continue;
    }
    var u = r[i - 1] || null;
    u && (u.next = o), o.parent = t, o.prev = u, o.next = null, r.push(o);
  }
  return n && (o = new Vh.ProcessingInstruction(n.substring(0, n.indexOf(" ")).toLowerCase(), n), o.next = r[0] || null, o.parent = t, r.unshift(o), r[1] && (r[1].prev = r[0])), r;
}
Object.defineProperty(nP, "__esModule", { value: !0 });
nP.default = Cce;
var vce = Yu, Nj = "html", Fj = "head", Zh = "body", yce = /<([a-zA-Z]+[0-9]?)/, zj = /<head[^]*>/i, Uj = /<body[^]*>/i, mv = function(e, t) {
  throw new Error("This browser does not support `document.implementation.createHTMLDocument`");
}, XE = function(e, t) {
  throw new Error("This browser does not support `DOMParser.prototype.parseFromString`");
}, Hj = typeof window == "object" && window.DOMParser;
if (typeof Hj == "function") {
  var bce = new Hj(), wce = "text/html";
  XE = function(e, t) {
    return t && (e = "<".concat(t, ">").concat(e, "</").concat(t, ">")), bce.parseFromString(e, wce);
  }, mv = XE;
}
if (typeof document == "object" && document.implementation) {
  var qh = document.implementation.createHTMLDocument();
  mv = function(e, t) {
    if (t) {
      var n = qh.documentElement.querySelector(t);
      return n && (n.innerHTML = e), qh;
    }
    return qh.documentElement.innerHTML = e, qh;
  };
}
var Gh = typeof document == "object" && document.createElement("template"), JE;
Gh && Gh.content && (JE = function(e) {
  return Gh.innerHTML = e, Gh.content.childNodes;
});
function Cce(e) {
  var t, n;
  e = (0, vce.escapeSpecialCharacters)(e);
  var r = e.match(yce), o = r && r[1] ? r[1].toLowerCase() : "";
  switch (o) {
    case Nj: {
      var i = XE(e);
      if (!zj.test(e)) {
        var a = i.querySelector(Fj);
        (t = a == null ? void 0 : a.parentNode) === null || t === void 0 || t.removeChild(a);
      }
      if (!Uj.test(e)) {
        var a = i.querySelector(Zh);
        (n = a == null ? void 0 : a.parentNode) === null || n === void 0 || n.removeChild(a);
      }
      return i.querySelectorAll(Nj);
    }
    case Fj:
    case Zh: {
      var s = mv(e).querySelectorAll(o);
      return Uj.test(e) && zj.test(e) ? s[0].parentNode.childNodes : s;
    }
    default: {
      if (JE)
        return JE(e);
      var a = mv(e, Zh).querySelector(Zh);
      return a.childNodes;
    }
  }
}
var xce = nr && nr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(tP, "__esModule", { value: !0 });
tP.default = Lce;
var Oce = xce(nP), Ece = Yu, kce = /<(![a-zA-Z\s]+)>/;
function Lce(e) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e)
    return [];
  var t = e.match(kce), n = t ? t[1] : void 0;
  return (0, Ece.formatDOM)((0, Oce.default)(e), null, n);
}
var tw = {}, gs = {}, nw = {}, Pce = 0;
nw.SAME = Pce;
var _ce = 1;
nw.CAMELCASE = _ce;
nw.possibleStandardNames = {
  accept: 0,
  acceptCharset: 1,
  "accept-charset": "acceptCharset",
  accessKey: 1,
  action: 0,
  allowFullScreen: 1,
  alt: 0,
  as: 0,
  async: 0,
  autoCapitalize: 1,
  autoComplete: 1,
  autoCorrect: 1,
  autoFocus: 1,
  autoPlay: 1,
  autoSave: 1,
  capture: 0,
  cellPadding: 1,
  cellSpacing: 1,
  challenge: 0,
  charSet: 1,
  checked: 0,
  children: 0,
  cite: 0,
  class: "className",
  classID: 1,
  className: 1,
  cols: 0,
  colSpan: 1,
  content: 0,
  contentEditable: 1,
  contextMenu: 1,
  controls: 0,
  controlsList: 1,
  coords: 0,
  crossOrigin: 1,
  dangerouslySetInnerHTML: 1,
  data: 0,
  dateTime: 1,
  default: 0,
  defaultChecked: 1,
  defaultValue: 1,
  defer: 0,
  dir: 0,
  disabled: 0,
  disablePictureInPicture: 1,
  disableRemotePlayback: 1,
  download: 0,
  draggable: 0,
  encType: 1,
  enterKeyHint: 1,
  for: "htmlFor",
  form: 0,
  formMethod: 1,
  formAction: 1,
  formEncType: 1,
  formNoValidate: 1,
  formTarget: 1,
  frameBorder: 1,
  headers: 0,
  height: 0,
  hidden: 0,
  high: 0,
  href: 0,
  hrefLang: 1,
  htmlFor: 1,
  httpEquiv: 1,
  "http-equiv": "httpEquiv",
  icon: 0,
  id: 0,
  innerHTML: 1,
  inputMode: 1,
  integrity: 0,
  is: 0,
  itemID: 1,
  itemProp: 1,
  itemRef: 1,
  itemScope: 1,
  itemType: 1,
  keyParams: 1,
  keyType: 1,
  kind: 0,
  label: 0,
  lang: 0,
  list: 0,
  loop: 0,
  low: 0,
  manifest: 0,
  marginWidth: 1,
  marginHeight: 1,
  max: 0,
  maxLength: 1,
  media: 0,
  mediaGroup: 1,
  method: 0,
  min: 0,
  minLength: 1,
  multiple: 0,
  muted: 0,
  name: 0,
  noModule: 1,
  nonce: 0,
  noValidate: 1,
  open: 0,
  optimum: 0,
  pattern: 0,
  placeholder: 0,
  playsInline: 1,
  poster: 0,
  preload: 0,
  profile: 0,
  radioGroup: 1,
  readOnly: 1,
  referrerPolicy: 1,
  rel: 0,
  required: 0,
  reversed: 0,
  role: 0,
  rows: 0,
  rowSpan: 1,
  sandbox: 0,
  scope: 0,
  scoped: 0,
  scrolling: 0,
  seamless: 0,
  selected: 0,
  shape: 0,
  size: 0,
  sizes: 0,
  span: 0,
  spellCheck: 1,
  src: 0,
  srcDoc: 1,
  srcLang: 1,
  srcSet: 1,
  start: 0,
  step: 0,
  style: 0,
  summary: 0,
  tabIndex: 1,
  target: 0,
  title: 0,
  type: 0,
  useMap: 1,
  value: 0,
  width: 0,
  wmode: 0,
  wrap: 0,
  about: 0,
  accentHeight: 1,
  "accent-height": "accentHeight",
  accumulate: 0,
  additive: 0,
  alignmentBaseline: 1,
  "alignment-baseline": "alignmentBaseline",
  allowReorder: 1,
  alphabetic: 0,
  amplitude: 0,
  arabicForm: 1,
  "arabic-form": "arabicForm",
  ascent: 0,
  attributeName: 1,
  attributeType: 1,
  autoReverse: 1,
  azimuth: 0,
  baseFrequency: 1,
  baselineShift: 1,
  "baseline-shift": "baselineShift",
  baseProfile: 1,
  bbox: 0,
  begin: 0,
  bias: 0,
  by: 0,
  calcMode: 1,
  capHeight: 1,
  "cap-height": "capHeight",
  clip: 0,
  clipPath: 1,
  "clip-path": "clipPath",
  clipPathUnits: 1,
  clipRule: 1,
  "clip-rule": "clipRule",
  color: 0,
  colorInterpolation: 1,
  "color-interpolation": "colorInterpolation",
  colorInterpolationFilters: 1,
  "color-interpolation-filters": "colorInterpolationFilters",
  colorProfile: 1,
  "color-profile": "colorProfile",
  colorRendering: 1,
  "color-rendering": "colorRendering",
  contentScriptType: 1,
  contentStyleType: 1,
  cursor: 0,
  cx: 0,
  cy: 0,
  d: 0,
  datatype: 0,
  decelerate: 0,
  descent: 0,
  diffuseConstant: 1,
  direction: 0,
  display: 0,
  divisor: 0,
  dominantBaseline: 1,
  "dominant-baseline": "dominantBaseline",
  dur: 0,
  dx: 0,
  dy: 0,
  edgeMode: 1,
  elevation: 0,
  enableBackground: 1,
  "enable-background": "enableBackground",
  end: 0,
  exponent: 0,
  externalResourcesRequired: 1,
  fill: 0,
  fillOpacity: 1,
  "fill-opacity": "fillOpacity",
  fillRule: 1,
  "fill-rule": "fillRule",
  filter: 0,
  filterRes: 1,
  filterUnits: 1,
  floodOpacity: 1,
  "flood-opacity": "floodOpacity",
  floodColor: 1,
  "flood-color": "floodColor",
  focusable: 0,
  fontFamily: 1,
  "font-family": "fontFamily",
  fontSize: 1,
  "font-size": "fontSize",
  fontSizeAdjust: 1,
  "font-size-adjust": "fontSizeAdjust",
  fontStretch: 1,
  "font-stretch": "fontStretch",
  fontStyle: 1,
  "font-style": "fontStyle",
  fontVariant: 1,
  "font-variant": "fontVariant",
  fontWeight: 1,
  "font-weight": "fontWeight",
  format: 0,
  from: 0,
  fx: 0,
  fy: 0,
  g1: 0,
  g2: 0,
  glyphName: 1,
  "glyph-name": "glyphName",
  glyphOrientationHorizontal: 1,
  "glyph-orientation-horizontal": "glyphOrientationHorizontal",
  glyphOrientationVertical: 1,
  "glyph-orientation-vertical": "glyphOrientationVertical",
  glyphRef: 1,
  gradientTransform: 1,
  gradientUnits: 1,
  hanging: 0,
  horizAdvX: 1,
  "horiz-adv-x": "horizAdvX",
  horizOriginX: 1,
  "horiz-origin-x": "horizOriginX",
  ideographic: 0,
  imageRendering: 1,
  "image-rendering": "imageRendering",
  in2: 0,
  in: 0,
  inlist: 0,
  intercept: 0,
  k1: 0,
  k2: 0,
  k3: 0,
  k4: 0,
  k: 0,
  kernelMatrix: 1,
  kernelUnitLength: 1,
  kerning: 0,
  keyPoints: 1,
  keySplines: 1,
  keyTimes: 1,
  lengthAdjust: 1,
  letterSpacing: 1,
  "letter-spacing": "letterSpacing",
  lightingColor: 1,
  "lighting-color": "lightingColor",
  limitingConeAngle: 1,
  local: 0,
  markerEnd: 1,
  "marker-end": "markerEnd",
  markerHeight: 1,
  markerMid: 1,
  "marker-mid": "markerMid",
  markerStart: 1,
  "marker-start": "markerStart",
  markerUnits: 1,
  markerWidth: 1,
  mask: 0,
  maskContentUnits: 1,
  maskUnits: 1,
  mathematical: 0,
  mode: 0,
  numOctaves: 1,
  offset: 0,
  opacity: 0,
  operator: 0,
  order: 0,
  orient: 0,
  orientation: 0,
  origin: 0,
  overflow: 0,
  overlinePosition: 1,
  "overline-position": "overlinePosition",
  overlineThickness: 1,
  "overline-thickness": "overlineThickness",
  paintOrder: 1,
  "paint-order": "paintOrder",
  panose1: 0,
  "panose-1": "panose1",
  pathLength: 1,
  patternContentUnits: 1,
  patternTransform: 1,
  patternUnits: 1,
  pointerEvents: 1,
  "pointer-events": "pointerEvents",
  points: 0,
  pointsAtX: 1,
  pointsAtY: 1,
  pointsAtZ: 1,
  prefix: 0,
  preserveAlpha: 1,
  preserveAspectRatio: 1,
  primitiveUnits: 1,
  property: 0,
  r: 0,
  radius: 0,
  refX: 1,
  refY: 1,
  renderingIntent: 1,
  "rendering-intent": "renderingIntent",
  repeatCount: 1,
  repeatDur: 1,
  requiredExtensions: 1,
  requiredFeatures: 1,
  resource: 0,
  restart: 0,
  result: 0,
  results: 0,
  rotate: 0,
  rx: 0,
  ry: 0,
  scale: 0,
  security: 0,
  seed: 0,
  shapeRendering: 1,
  "shape-rendering": "shapeRendering",
  slope: 0,
  spacing: 0,
  specularConstant: 1,
  specularExponent: 1,
  speed: 0,
  spreadMethod: 1,
  startOffset: 1,
  stdDeviation: 1,
  stemh: 0,
  stemv: 0,
  stitchTiles: 1,
  stopColor: 1,
  "stop-color": "stopColor",
  stopOpacity: 1,
  "stop-opacity": "stopOpacity",
  strikethroughPosition: 1,
  "strikethrough-position": "strikethroughPosition",
  strikethroughThickness: 1,
  "strikethrough-thickness": "strikethroughThickness",
  string: 0,
  stroke: 0,
  strokeDasharray: 1,
  "stroke-dasharray": "strokeDasharray",
  strokeDashoffset: 1,
  "stroke-dashoffset": "strokeDashoffset",
  strokeLinecap: 1,
  "stroke-linecap": "strokeLinecap",
  strokeLinejoin: 1,
  "stroke-linejoin": "strokeLinejoin",
  strokeMiterlimit: 1,
  "stroke-miterlimit": "strokeMiterlimit",
  strokeWidth: 1,
  "stroke-width": "strokeWidth",
  strokeOpacity: 1,
  "stroke-opacity": "strokeOpacity",
  suppressContentEditableWarning: 1,
  suppressHydrationWarning: 1,
  surfaceScale: 1,
  systemLanguage: 1,
  tableValues: 1,
  targetX: 1,
  targetY: 1,
  textAnchor: 1,
  "text-anchor": "textAnchor",
  textDecoration: 1,
  "text-decoration": "textDecoration",
  textLength: 1,
  textRendering: 1,
  "text-rendering": "textRendering",
  to: 0,
  transform: 0,
  typeof: 0,
  u1: 0,
  u2: 0,
  underlinePosition: 1,
  "underline-position": "underlinePosition",
  underlineThickness: 1,
  "underline-thickness": "underlineThickness",
  unicode: 0,
  unicodeBidi: 1,
  "unicode-bidi": "unicodeBidi",
  unicodeRange: 1,
  "unicode-range": "unicodeRange",
  unitsPerEm: 1,
  "units-per-em": "unitsPerEm",
  unselectable: 0,
  vAlphabetic: 1,
  "v-alphabetic": "vAlphabetic",
  values: 0,
  vectorEffect: 1,
  "vector-effect": "vectorEffect",
  version: 0,
  vertAdvY: 1,
  "vert-adv-y": "vertAdvY",
  vertOriginX: 1,
  "vert-origin-x": "vertOriginX",
  vertOriginY: 1,
  "vert-origin-y": "vertOriginY",
  vHanging: 1,
  "v-hanging": "vHanging",
  vIdeographic: 1,
  "v-ideographic": "vIdeographic",
  viewBox: 1,
  viewTarget: 1,
  visibility: 0,
  vMathematical: 1,
  "v-mathematical": "vMathematical",
  vocab: 0,
  widths: 0,
  wordSpacing: 1,
  "word-spacing": "wordSpacing",
  writingMode: 1,
  "writing-mode": "writingMode",
  x1: 0,
  x2: 0,
  x: 0,
  xChannelSelector: 1,
  xHeight: 1,
  "x-height": "xHeight",
  xlinkActuate: 1,
  "xlink:actuate": "xlinkActuate",
  xlinkArcrole: 1,
  "xlink:arcrole": "xlinkArcrole",
  xlinkHref: 1,
  "xlink:href": "xlinkHref",
  xlinkRole: 1,
  "xlink:role": "xlinkRole",
  xlinkShow: 1,
  "xlink:show": "xlinkShow",
  xlinkTitle: 1,
  "xlink:title": "xlinkTitle",
  xlinkType: 1,
  "xlink:type": "xlinkType",
  xmlBase: 1,
  "xml:base": "xmlBase",
  xmlLang: 1,
  "xml:lang": "xmlLang",
  xmlns: 0,
  "xml:space": "xmlSpace",
  xmlnsXlink: 1,
  "xmlns:xlink": "xmlnsXlink",
  xmlSpace: 1,
  y1: 0,
  y2: 0,
  y: 0,
  yChannelSelector: 1,
  z: 0,
  zoomAndPan: 1
};
const X4 = 0, Ol = 1, rw = 2, ow = 3, aP = 4, J4 = 5, Q4 = 6;
function Sce(e) {
  return Bo.hasOwnProperty(e) ? Bo[e] : null;
}
function ei(e, t, n, r, o, i, a) {
  this.acceptsBooleans = t === rw || t === ow || t === aP, this.attributeName = r, this.attributeNamespace = o, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = i, this.removeEmptyString = a;
}
const Bo = {}, Mce = [
  "children",
  "dangerouslySetInnerHTML",
  // TODO: This prevents the assignment of defaultValue to regular
  // elements (not just inputs). Now that ReactDOMInput assigns to the
  // defaultValue property -- do we need this?
  "defaultValue",
  "defaultChecked",
  "innerHTML",
  "suppressContentEditableWarning",
  "suppressHydrationWarning",
  "style"
];
Mce.forEach((e) => {
  Bo[e] = new ei(
    e,
    X4,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"]
].forEach(([e, t]) => {
  Bo[e] = new ei(
    e,
    Ol,
    !1,
    // mustUseProperty
    t,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["contentEditable", "draggable", "spellCheck", "value"].forEach((e) => {
  Bo[e] = new ei(
    e,
    rw,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha"
].forEach((e) => {
  Bo[e] = new ei(
    e,
    rw,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "allowFullScreen",
  "async",
  // Note: there is a special case that prevents it from being written to the DOM
  // on the client side because the browsers are inconsistent. Instead we call focus().
  "autoFocus",
  "autoPlay",
  "controls",
  "default",
  "defer",
  "disabled",
  "disablePictureInPicture",
  "disableRemotePlayback",
  "formNoValidate",
  "hidden",
  "loop",
  "noModule",
  "noValidate",
  "open",
  "playsInline",
  "readOnly",
  "required",
  "reversed",
  "scoped",
  "seamless",
  // Microdata
  "itemScope"
].forEach((e) => {
  Bo[e] = new ei(
    e,
    ow,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "checked",
  // Note: `option.selected` is not updated if `select.multiple` is
  // disabled with `removeAttribute`. We have special logic for handling this.
  "multiple",
  "muted",
  "selected"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Bo[e] = new ei(
    e,
    ow,
    !0,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "capture",
  "download"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Bo[e] = new ei(
    e,
    aP,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "cols",
  "rows",
  "size",
  "span"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Bo[e] = new ei(
    e,
    Q4,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["rowSpan", "start"].forEach((e) => {
  Bo[e] = new ei(
    e,
    J4,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const lP = /[\-\:]([a-z])/g, uP = (e) => e[1].toUpperCase();
[
  "accent-height",
  "alignment-baseline",
  "arabic-form",
  "baseline-shift",
  "cap-height",
  "clip-path",
  "clip-rule",
  "color-interpolation",
  "color-interpolation-filters",
  "color-profile",
  "color-rendering",
  "dominant-baseline",
  "enable-background",
  "fill-opacity",
  "fill-rule",
  "flood-color",
  "flood-opacity",
  "font-family",
  "font-size",
  "font-size-adjust",
  "font-stretch",
  "font-style",
  "font-variant",
  "font-weight",
  "glyph-name",
  "glyph-orientation-horizontal",
  "glyph-orientation-vertical",
  "horiz-adv-x",
  "horiz-origin-x",
  "image-rendering",
  "letter-spacing",
  "lighting-color",
  "marker-end",
  "marker-mid",
  "marker-start",
  "overline-position",
  "overline-thickness",
  "paint-order",
  "panose-1",
  "pointer-events",
  "rendering-intent",
  "shape-rendering",
  "stop-color",
  "stop-opacity",
  "strikethrough-position",
  "strikethrough-thickness",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "text-anchor",
  "text-decoration",
  "text-rendering",
  "underline-position",
  "underline-thickness",
  "unicode-bidi",
  "unicode-range",
  "units-per-em",
  "v-alphabetic",
  "v-hanging",
  "v-ideographic",
  "v-mathematical",
  "vector-effect",
  "vert-adv-y",
  "vert-origin-x",
  "vert-origin-y",
  "word-spacing",
  "writing-mode",
  "xmlns:xlink",
  "x-height"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(lP, uP);
  Bo[t] = new ei(
    t,
    Ol,
    !1,
    // mustUseProperty
    e,
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xlink:actuate",
  "xlink:arcrole",
  "xlink:role",
  "xlink:show",
  "xlink:title",
  "xlink:type"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(lP, uP);
  Bo[t] = new ei(
    t,
    Ol,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/1999/xlink",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xml:base",
  "xml:lang",
  "xml:space"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(lP, uP);
  Bo[t] = new ei(
    t,
    Ol,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/XML/1998/namespace",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["tabIndex", "crossOrigin"].forEach((e) => {
  Bo[e] = new ei(
    e,
    Ol,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const Dce = "xlinkHref";
Bo[Dce] = new ei(
  "xlinkHref",
  Ol,
  !1,
  // mustUseProperty
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  // sanitizeURL
  !1
  // removeEmptyString
);
["src", "href", "action", "formAction"].forEach((e) => {
  Bo[e] = new ei(
    e,
    Ol,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !0,
    // sanitizeURL
    !0
    // removeEmptyString
  );
});
const {
  CAMELCASE: Tce,
  SAME: jce,
  possibleStandardNames: $j
} = nw, Ace = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", Ice = Ace + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", Rce = RegExp.prototype.test.bind(
  // eslint-disable-next-line no-misleading-character-class
  new RegExp("^(data|aria)-[" + Ice + "]*$")
), Bce = Object.keys(
  $j
).reduce((e, t) => {
  const n = $j[t];
  return n === jce ? e[t] = t : n === Tce ? e[t.toLowerCase()] = t : e[t] = n, e;
}, {});
gs.BOOLEAN = ow;
gs.BOOLEANISH_STRING = rw;
gs.NUMERIC = J4;
gs.OVERLOADED_BOOLEAN = aP;
gs.POSITIVE_NUMERIC = Q4;
gs.RESERVED = X4;
gs.STRING = Ol;
gs.getPropertyInfo = Sce;
gs.isCustomAttribute = Rce;
gs.possibleStandardNames = Bce;
var cP = {}, pP = {}, Wj = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, Nce = /\n/g, Fce = /^\s*/, zce = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, Uce = /^:\s*/, Hce = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, $ce = /^[;\s]*/, Wce = /^\s+|\s+$/g, Vce = `
`, Vj = "/", Zj = "*", lu = "", Zce = "comment", qce = "declaration", Gce = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e) return [];
  t = t || {};
  var n = 1, r = 1;
  function o(f) {
    var m = f.match(Nce);
    m && (n += m.length);
    var v = f.lastIndexOf(Vce);
    r = ~v ? f.length - v : r + f.length;
  }
  function i() {
    var f = { line: n, column: r };
    return function(m) {
      return m.position = new a(f), u(), m;
    };
  }
  function a(f) {
    this.start = f, this.end = { line: n, column: r }, this.source = t.source;
  }
  a.prototype.content = e;
  function s(f) {
    var m = new Error(
      t.source + ":" + n + ":" + r + ": " + f
    );
    if (m.reason = f, m.filename = t.source, m.line = n, m.column = r, m.source = e, !t.silent) throw m;
  }
  function l(f) {
    var m = f.exec(e);
    if (m) {
      var v = m[0];
      return o(v), e = e.slice(v.length), m;
    }
  }
  function u() {
    l(Fce);
  }
  function c(f) {
    var m;
    for (f = f || []; m = p(); )
      m !== !1 && f.push(m);
    return f;
  }
  function p() {
    var f = i();
    if (!(Vj != e.charAt(0) || Zj != e.charAt(1))) {
      for (var m = 2; lu != e.charAt(m) && (Zj != e.charAt(m) || Vj != e.charAt(m + 1)); )
        ++m;
      if (m += 2, lu === e.charAt(m - 1))
        return s("End of comment missing");
      var v = e.slice(2, m - 2);
      return r += 2, o(v), e = e.slice(m), r += 2, f({
        type: Zce,
        comment: v
      });
    }
  }
  function d() {
    var f = i(), m = l(zce);
    if (m) {
      if (p(), !l(Uce)) return s("property missing ':'");
      var v = l(Hce), E = f({
        type: qce,
        property: qj(m[0].replace(Wj, lu)),
        value: v ? qj(v[0].replace(Wj, lu)) : lu
      });
      return l($ce), E;
    }
  }
  function g() {
    var f = [];
    c(f);
    for (var m; m = d(); )
      m !== !1 && (f.push(m), c(f));
    return f;
  }
  return u(), g();
};
function qj(e) {
  return e ? e.replace(Wce, lu) : lu;
}
var Kce = nr && nr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(pP, "__esModule", { value: !0 });
pP.default = Xce;
var Yce = Kce(Gce);
function Xce(e, t) {
  var n = null;
  if (!e || typeof e != "string")
    return n;
  var r = (0, Yce.default)(e), o = typeof t == "function";
  return r.forEach(function(i) {
    if (i.type === "declaration") {
      var a = i.property, s = i.value;
      o ? t(a, s, i) : s && (n = n || {}, n[a] = s);
    }
  }), n;
}
var iw = {};
Object.defineProperty(iw, "__esModule", { value: !0 });
iw.camelCase = void 0;
var Jce = /^--[a-zA-Z0-9_-]+$/, Qce = /-([a-z])/g, epe = /^[^-]+$/, tpe = /^-(webkit|moz|ms|o|khtml)-/, npe = /^-(ms)-/, rpe = function(e) {
  return !e || epe.test(e) || Jce.test(e);
}, ope = function(e, t) {
  return t.toUpperCase();
}, Gj = function(e, t) {
  return "".concat(t, "-");
}, ipe = function(e, t) {
  return t === void 0 && (t = {}), rpe(e) ? e : (e = e.toLowerCase(), t.reactCompat ? e = e.replace(npe, Gj) : e = e.replace(tpe, Gj), e.replace(Qce, ope));
};
iw.camelCase = ipe;
var spe = nr && nr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
}, ape = spe(pP), lpe = iw;
function QE(e, t) {
  var n = {};
  return !e || typeof e != "string" || (0, ape.default)(e, function(r, o) {
    r && o && (n[(0, lpe.camelCase)(r, t)] = o);
  }), n;
}
QE.default = QE;
var upe = QE;
(function(e) {
  var t = nr && nr.__importDefault || function(c) {
    return c && c.__esModule ? c : { default: c };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.returnFirstArg = e.canTextBeChildOfNode = e.ELEMENTS_WITH_NO_TEXT_CHILDREN = e.PRESERVE_CUSTOM_ATTRIBUTES = void 0, e.isCustomComponent = i, e.setStyleProp = s;
  var n = we, r = t(upe), o = /* @__PURE__ */ new Set([
    "annotation-xml",
    "color-profile",
    "font-face",
    "font-face-src",
    "font-face-uri",
    "font-face-format",
    "font-face-name",
    "missing-glyph"
  ]);
  function i(c, p) {
    return c.includes("-") ? !o.has(c) : !!(p && typeof p.is == "string");
  }
  var a = {
    reactCompat: !0
  };
  function s(c, p) {
    if (typeof c == "string") {
      if (!c.trim()) {
        p.style = {};
        return;
      }
      try {
        p.style = (0, r.default)(c, a);
      } catch {
        p.style = {};
      }
    }
  }
  e.PRESERVE_CUSTOM_ATTRIBUTES = Number(n.version.split(".")[0]) >= 16, e.ELEMENTS_WITH_NO_TEXT_CHILDREN = /* @__PURE__ */ new Set([
    "tr",
    "tbody",
    "thead",
    "tfoot",
    "colgroup",
    "table",
    "head",
    "html",
    "frameset"
  ]);
  var l = function(c) {
    return !e.ELEMENTS_WITH_NO_TEXT_CHILDREN.has(c.name);
  };
  e.canTextBeChildOfNode = l;
  var u = function(c) {
    return c;
  };
  e.returnFirstArg = u;
})(cP);
Object.defineProperty(tw, "__esModule", { value: !0 });
tw.default = fpe;
var Rp = gs, Kj = cP, cpe = ["checked", "value"], ppe = ["input", "select", "textarea"], dpe = {
  reset: !0,
  submit: !0
};
function fpe(e, t) {
  e === void 0 && (e = {});
  var n = {}, r = !!(e.type && dpe[e.type]);
  for (var o in e) {
    var i = e[o];
    if ((0, Rp.isCustomAttribute)(o)) {
      n[o] = i;
      continue;
    }
    var a = o.toLowerCase(), s = Yj(a);
    if (s) {
      var l = (0, Rp.getPropertyInfo)(s);
      switch (cpe.includes(s) && ppe.includes(t) && !r && (s = Yj("default" + a)), n[s] = i, l && l.type) {
        case Rp.BOOLEAN:
          n[s] = !0;
          break;
        case Rp.OVERLOADED_BOOLEAN:
          i === "" && (n[s] = !0);
          break;
      }
      continue;
    }
    Kj.PRESERVE_CUSTOM_ATTRIBUTES && (n[o] = i);
  }
  return (0, Kj.setStyleProp)(e.style, n), n;
}
function Yj(e) {
  return Rp.possibleStandardNames[e];
}
var dP = {}, hpe = nr && nr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(dP, "__esModule", { value: !0 });
dP.default = e7;
var J0 = we, gpe = hpe(tw), Xp = cP, mpe = {
  cloneElement: J0.cloneElement,
  createElement: J0.createElement,
  isValidElement: J0.isValidElement
};
function e7(e, t) {
  t === void 0 && (t = {});
  for (var n = [], r = typeof t.replace == "function", o = t.transform || Xp.returnFirstArg, i = t.library || mpe, a = i.cloneElement, s = i.createElement, l = i.isValidElement, u = e.length, c = 0; c < u; c++) {
    var p = e[c];
    if (r) {
      var d = t.replace(p, c);
      if (l(d)) {
        u > 1 && (d = a(d, {
          key: d.key || c
        })), n.push(o(d, p, c));
        continue;
      }
    }
    if (p.type === "text") {
      var g = !p.data.trim().length;
      if (g && p.parent && !(0, Xp.canTextBeChildOfNode)(p.parent) || t.trim && g)
        continue;
      n.push(o(p.data, p, c));
      continue;
    }
    var f = p, m = {};
    vpe(f) ? ((0, Xp.setStyleProp)(f.attribs.style, f.attribs), m = f.attribs) : f.attribs && (m = (0, gpe.default)(f.attribs, f.name));
    var v = void 0;
    switch (p.type) {
      case "script":
      case "style":
        p.children[0] && (m.dangerouslySetInnerHTML = {
          __html: p.children[0].data
        });
        break;
      case "tag":
        p.name === "textarea" && p.children[0] ? m.defaultValue = p.children[0].data : p.children && p.children.length && (v = e7(p.children, t));
        break;
      default:
        continue;
    }
    u > 1 && (m.key = c), n.push(o(s(p.name, m, v), p, c));
  }
  return n.length === 1 ? n[0] : n;
}
function vpe(e) {
  return Xp.PRESERVE_CUSTOM_ATTRIBUTES && e.type === "tag" && (0, Xp.isCustomComponent)(e.name, e.attribs);
}
(function(e) {
  var t = nr && nr.__importDefault || function(l) {
    return l && l.__esModule ? l : { default: l };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.htmlToDOM = e.domToReact = e.attributesToProps = e.Text = e.ProcessingInstruction = e.Element = e.Comment = void 0, e.default = s;
  var n = t(tP);
  e.htmlToDOM = n.default;
  var r = t(tw);
  e.attributesToProps = r.default;
  var o = t(dP);
  e.domToReact = o.default;
  var i = rP;
  Object.defineProperty(e, "Comment", { enumerable: !0, get: function() {
    return i.Comment;
  } }), Object.defineProperty(e, "Element", { enumerable: !0, get: function() {
    return i.Element;
  } }), Object.defineProperty(e, "ProcessingInstruction", { enumerable: !0, get: function() {
    return i.ProcessingInstruction;
  } }), Object.defineProperty(e, "Text", { enumerable: !0, get: function() {
    return i.Text;
  } });
  var a = { lowerCaseAttributeNames: !1 };
  function s(l, u) {
    if (typeof l != "string")
      throw new TypeError("First argument must be a string");
    return l ? (0, o.default)((0, n.default)(l, (u == null ? void 0 : u.htmlparser2) || a), u) : [];
  }
})(A4);
const ype = /* @__PURE__ */ Bue(A4);
ype.default;
var rr = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function bpe(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var ek = { exports: {} }, tp = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Xj;
function wpe() {
  if (Xj) return tp;
  Xj = 1;
  var e = we, t = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, o = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, i = { key: !0, ref: !0, __self: !0, __source: !0 };
  function a(s, l, u) {
    var c, p = {}, d = null, g = null;
    u !== void 0 && (d = "" + u), l.key !== void 0 && (d = "" + l.key), l.ref !== void 0 && (g = l.ref);
    for (c in l) r.call(l, c) && !i.hasOwnProperty(c) && (p[c] = l[c]);
    if (s && s.defaultProps) for (c in l = s.defaultProps, l) p[c] === void 0 && (p[c] = l[c]);
    return { $$typeof: t, type: s, key: d, ref: g, props: p, _owner: o.current };
  }
  return tp.Fragment = n, tp.jsx = a, tp.jsxs = a, tp;
}
var Kh = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Jj;
function Cpe() {
  return Jj || (Jj = 1, process.env.NODE_ENV !== "production" && function() {
    var e = we, t = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), a = Symbol.for("react.provider"), s = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), c = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), d = Symbol.for("react.lazy"), g = Symbol.for("react.offscreen"), f = Symbol.iterator, m = "@@iterator";
    function v(b) {
      if (b === null || typeof b != "object")
        return null;
      var I = f && b[f] || b[m];
      return typeof I == "function" ? I : null;
    }
    var E = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function w(b) {
      {
        for (var I = arguments.length, G = new Array(I > 1 ? I - 1 : 0), ne = 1; ne < I; ne++)
          G[ne - 1] = arguments[ne];
        M("error", b, G);
      }
    }
    function M(b, I, G) {
      {
        var ne = E.ReactDebugCurrentFrame, le = ne.getStackAddendum();
        le !== "" && (I += "%s", G = G.concat([le]));
        var ce = G.map(function(se) {
          return String(se);
        });
        ce.unshift("Warning: " + I), Function.prototype.apply.call(console[b], console, ce);
      }
    }
    var O = !1, y = !1, C = !1, _ = !1, F = !1, L;
    L = Symbol.for("react.module.reference");
    function N(b) {
      return !!(typeof b == "string" || typeof b == "function" || b === r || b === i || F || b === o || b === u || b === c || _ || b === g || O || y || C || typeof b == "object" && b !== null && (b.$$typeof === d || b.$$typeof === p || b.$$typeof === a || b.$$typeof === s || b.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      b.$$typeof === L || b.getModuleId !== void 0));
    }
    function R(b, I, G) {
      var ne = b.displayName;
      if (ne)
        return ne;
      var le = I.displayName || I.name || "";
      return le !== "" ? G + "(" + le + ")" : G;
    }
    function W(b) {
      return b.displayName || "Context";
    }
    function V(b) {
      if (b == null)
        return null;
      if (typeof b.tag == "number" && w("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof b == "function")
        return b.displayName || b.name || null;
      if (typeof b == "string")
        return b;
      switch (b) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case i:
          return "Profiler";
        case o:
          return "StrictMode";
        case u:
          return "Suspense";
        case c:
          return "SuspenseList";
      }
      if (typeof b == "object")
        switch (b.$$typeof) {
          case s:
            var I = b;
            return W(I) + ".Consumer";
          case a:
            var G = b;
            return W(G._context) + ".Provider";
          case l:
            return R(b, b.render, "ForwardRef");
          case p:
            var ne = b.displayName || null;
            return ne !== null ? ne : V(b.type) || "Memo";
          case d: {
            var le = b, ce = le._payload, se = le._init;
            try {
              return V(se(ce));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var z = Object.assign, Z = 0, K, X, te, J, P, D, H;
    function S() {
    }
    S.__reactDisabledLog = !0;
    function $() {
      {
        if (Z === 0) {
          K = console.log, X = console.info, te = console.warn, J = console.error, P = console.group, D = console.groupCollapsed, H = console.groupEnd;
          var b = {
            configurable: !0,
            enumerable: !0,
            value: S,
            writable: !0
          };
          Object.defineProperties(console, {
            info: b,
            log: b,
            warn: b,
            error: b,
            group: b,
            groupCollapsed: b,
            groupEnd: b
          });
        }
        Z++;
      }
    }
    function x() {
      {
        if (Z--, Z === 0) {
          var b = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: z({}, b, {
              value: K
            }),
            info: z({}, b, {
              value: X
            }),
            warn: z({}, b, {
              value: te
            }),
            error: z({}, b, {
              value: J
            }),
            group: z({}, b, {
              value: P
            }),
            groupCollapsed: z({}, b, {
              value: D
            }),
            groupEnd: z({}, b, {
              value: H
            })
          });
        }
        Z < 0 && w("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var j = E.ReactCurrentDispatcher, U;
    function T(b, I, G) {
      {
        if (U === void 0)
          try {
            throw Error();
          } catch (le) {
            var ne = le.stack.trim().match(/\n( *(at )?)/);
            U = ne && ne[1] || "";
          }
        return `
` + U + b;
      }
    }
    var q = !1, A;
    {
      var Y = typeof WeakMap == "function" ? WeakMap : Map;
      A = new Y();
    }
    function B(b, I) {
      if (!b || q)
        return "";
      {
        var G = A.get(b);
        if (G !== void 0)
          return G;
      }
      var ne;
      q = !0;
      var le = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var ce;
      ce = j.current, j.current = null, $();
      try {
        if (I) {
          var se = function() {
            throw Error();
          };
          if (Object.defineProperty(se.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(se, []);
            } catch (je) {
              ne = je;
            }
            Reflect.construct(b, [], se);
          } else {
            try {
              se.call();
            } catch (je) {
              ne = je;
            }
            b.call(se.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (je) {
            ne = je;
          }
          b();
        }
      } catch (je) {
        if (je && ne && typeof je.stack == "string") {
          for (var ie = je.stack.split(`
`), Se = ne.stack.split(`
`), de = ie.length - 1, he = Se.length - 1; de >= 1 && he >= 0 && ie[de] !== Se[he]; )
            he--;
          for (; de >= 1 && he >= 0; de--, he--)
            if (ie[de] !== Se[he]) {
              if (de !== 1 || he !== 1)
                do
                  if (de--, he--, he < 0 || ie[de] !== Se[he]) {
                    var Ve = `
` + ie[de].replace(" at new ", " at ");
                    return b.displayName && Ve.includes("<anonymous>") && (Ve = Ve.replace("<anonymous>", b.displayName)), typeof b == "function" && A.set(b, Ve), Ve;
                  }
                while (de >= 1 && he >= 0);
              break;
            }
        }
      } finally {
        q = !1, j.current = ce, x(), Error.prepareStackTrace = le;
      }
      var xt = b ? b.displayName || b.name : "", vt = xt ? T(xt) : "";
      return typeof b == "function" && A.set(b, vt), vt;
    }
    function ue(b, I, G) {
      return B(b, !1);
    }
    function fe(b) {
      var I = b.prototype;
      return !!(I && I.isReactComponent);
    }
    function oe(b, I, G) {
      if (b == null)
        return "";
      if (typeof b == "function")
        return B(b, fe(b));
      if (typeof b == "string")
        return T(b);
      switch (b) {
        case u:
          return T("Suspense");
        case c:
          return T("SuspenseList");
      }
      if (typeof b == "object")
        switch (b.$$typeof) {
          case l:
            return ue(b.render);
          case p:
            return oe(b.type, I, G);
          case d: {
            var ne = b, le = ne._payload, ce = ne._init;
            try {
              return oe(ce(le), I, G);
            } catch {
            }
          }
        }
      return "";
    }
    var Ae = Object.prototype.hasOwnProperty, Ze = {}, Ge = E.ReactDebugCurrentFrame;
    function Ie(b) {
      if (b) {
        var I = b._owner, G = oe(b.type, b._source, I ? I.type : null);
        Ge.setExtraStackFrame(G);
      } else
        Ge.setExtraStackFrame(null);
    }
    function et(b, I, G, ne, le) {
      {
        var ce = Function.call.bind(Ae);
        for (var se in b)
          if (ce(b, se)) {
            var ie = void 0;
            try {
              if (typeof b[se] != "function") {
                var Se = Error((ne || "React class") + ": " + G + " type `" + se + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof b[se] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw Se.name = "Invariant Violation", Se;
              }
              ie = b[se](I, se, ne, G, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (de) {
              ie = de;
            }
            ie && !(ie instanceof Error) && (Ie(le), w("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", ne || "React class", G, se, typeof ie), Ie(null)), ie instanceof Error && !(ie.message in Ze) && (Ze[ie.message] = !0, Ie(le), w("Failed %s type: %s", G, ie.message), Ie(null));
          }
      }
    }
    var Ye = Array.isArray;
    function _e(b) {
      return Ye(b);
    }
    function Qe(b) {
      {
        var I = typeof Symbol == "function" && Symbol.toStringTag, G = I && b[Symbol.toStringTag] || b.constructor.name || "Object";
        return G;
      }
    }
    function at(b) {
      try {
        return Pe(b), !1;
      } catch {
        return !0;
      }
    }
    function Pe(b) {
      return "" + b;
    }
    function Me(b) {
      if (at(b))
        return w("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Qe(b)), Pe(b);
    }
    var Je = E.ReactCurrentOwner, We = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, Re, nt;
    function De(b) {
      if (Ae.call(b, "ref")) {
        var I = Object.getOwnPropertyDescriptor(b, "ref").get;
        if (I && I.isReactWarning)
          return !1;
      }
      return b.ref !== void 0;
    }
    function yt(b) {
      if (Ae.call(b, "key")) {
        var I = Object.getOwnPropertyDescriptor(b, "key").get;
        if (I && I.isReactWarning)
          return !1;
      }
      return b.key !== void 0;
    }
    function ot(b, I) {
      typeof b.ref == "string" && Je.current;
    }
    function st(b, I) {
      {
        var G = function() {
          Re || (Re = !0, w("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", I));
        };
        G.isReactWarning = !0, Object.defineProperty(b, "key", {
          get: G,
          configurable: !0
        });
      }
    }
    function ct(b, I) {
      {
        var G = function() {
          nt || (nt = !0, w("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", I));
        };
        G.isReactWarning = !0, Object.defineProperty(b, "ref", {
          get: G,
          configurable: !0
        });
      }
    }
    var bt = function(b, I, G, ne, le, ce, se) {
      var ie = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: b,
        key: I,
        ref: G,
        props: se,
        // Record the component responsible for creating this element.
        _owner: ce
      };
      return ie._store = {}, Object.defineProperty(ie._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(ie, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ne
      }), Object.defineProperty(ie, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: le
      }), Object.freeze && (Object.freeze(ie.props), Object.freeze(ie)), ie;
    };
    function pt(b, I, G, ne, le) {
      {
        var ce, se = {}, ie = null, Se = null;
        G !== void 0 && (Me(G), ie = "" + G), yt(I) && (Me(I.key), ie = "" + I.key), De(I) && (Se = I.ref, ot(I));
        for (ce in I)
          Ae.call(I, ce) && !We.hasOwnProperty(ce) && (se[ce] = I[ce]);
        if (b && b.defaultProps) {
          var de = b.defaultProps;
          for (ce in de)
            se[ce] === void 0 && (se[ce] = de[ce]);
        }
        if (ie || Se) {
          var he = typeof b == "function" ? b.displayName || b.name || "Unknown" : b;
          ie && st(se, he), Se && ct(se, he);
        }
        return bt(b, ie, Se, le, ne, Je.current, se);
      }
    }
    var dt = E.ReactCurrentOwner, tt = E.ReactDebugCurrentFrame;
    function Xe(b) {
      if (b) {
        var I = b._owner, G = oe(b.type, b._source, I ? I.type : null);
        tt.setExtraStackFrame(G);
      } else
        tt.setExtraStackFrame(null);
    }
    var wt;
    wt = !1;
    function Ct(b) {
      return typeof b == "object" && b !== null && b.$$typeof === t;
    }
    function ft() {
      {
        if (dt.current) {
          var b = V(dt.current.type);
          if (b)
            return `

Check the render method of \`` + b + "`.";
        }
        return "";
      }
    }
    function bn(b) {
      return "";
    }
    var ht = {};
    function wn(b) {
      {
        var I = ft();
        if (!I) {
          var G = typeof b == "string" ? b : b.displayName || b.name;
          G && (I = `

Check the top-level render call using <` + G + ">.");
        }
        return I;
      }
    }
    function gt(b, I) {
      {
        if (!b._store || b._store.validated || b.key != null)
          return;
        b._store.validated = !0;
        var G = wn(I);
        if (ht[G])
          return;
        ht[G] = !0;
        var ne = "";
        b && b._owner && b._owner !== dt.current && (ne = " It was passed a child from " + V(b._owner.type) + "."), Xe(b), w('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', G, ne), Xe(null);
      }
    }
    function Mt(b, I) {
      {
        if (typeof b != "object")
          return;
        if (_e(b))
          for (var G = 0; G < b.length; G++) {
            var ne = b[G];
            Ct(ne) && gt(ne, I);
          }
        else if (Ct(b))
          b._store && (b._store.validated = !0);
        else if (b) {
          var le = v(b);
          if (typeof le == "function" && le !== b.entries)
            for (var ce = le.call(b), se; !(se = ce.next()).done; )
              Ct(se.value) && gt(se.value, I);
        }
      }
    }
    function ir(b) {
      {
        var I = b.type;
        if (I == null || typeof I == "string")
          return;
        var G;
        if (typeof I == "function")
          G = I.propTypes;
        else if (typeof I == "object" && (I.$$typeof === l || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        I.$$typeof === p))
          G = I.propTypes;
        else
          return;
        if (G) {
          var ne = V(I);
          et(G, b.props, "prop", ne, b);
        } else if (I.PropTypes !== void 0 && !wt) {
          wt = !0;
          var le = V(I);
          w("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", le || "Unknown");
        }
        typeof I.getDefaultProps == "function" && !I.getDefaultProps.isReactClassApproved && w("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function mt(b) {
      {
        for (var I = Object.keys(b.props), G = 0; G < I.length; G++) {
          var ne = I[G];
          if (ne !== "children" && ne !== "key") {
            Xe(b), w("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", ne), Xe(null);
            break;
          }
        }
        b.ref !== null && (Xe(b), w("Invalid attribute `ref` supplied to `React.Fragment`."), Xe(null));
      }
    }
    var re = {};
    function vo(b, I, G, ne, le, ce) {
      {
        var se = N(b);
        if (!se) {
          var ie = "";
          (b === void 0 || typeof b == "object" && b !== null && Object.keys(b).length === 0) && (ie += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var Se = bn();
          Se ? ie += Se : ie += ft();
          var de;
          b === null ? de = "null" : _e(b) ? de = "array" : b !== void 0 && b.$$typeof === t ? (de = "<" + (V(b.type) || "Unknown") + " />", ie = " Did you accidentally export a JSX literal instead of a component?") : de = typeof b, w("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", de, ie);
        }
        var he = pt(b, I, G, le, ce);
        if (he == null)
          return he;
        if (se) {
          var Ve = I.children;
          if (Ve !== void 0)
            if (ne)
              if (_e(Ve)) {
                for (var xt = 0; xt < Ve.length; xt++)
                  Mt(Ve[xt], b);
                Object.freeze && Object.freeze(Ve);
              } else
                w("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Mt(Ve, b);
        }
        if (Ae.call(I, "key")) {
          var vt = V(b), je = Object.keys(I).filter(function(Li) {
            return Li !== "key";
          }), sr = je.length > 0 ? "{key: someKey, " + je.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!re[vt + sr]) {
            var ki = je.length > 0 ? "{" + je.join(": ..., ") + ": ...}" : "{}";
            w(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, sr, vt, ki, vt), re[vt + sr] = !0;
          }
        }
        return b === r ? mt(he) : ir(he), he;
      }
    }
    function Ci(b, I, G) {
      return vo(b, I, G, !0);
    }
    function xi(b, I, G) {
      return vo(b, I, G, !1);
    }
    var Oi = xi, Ei = Ci;
    Kh.Fragment = r, Kh.jsx = Oi, Kh.jsxs = Ei;
  }()), Kh;
}
process.env.NODE_ENV === "production" ? ek.exports = wpe() : ek.exports = Cpe();
var Do = ek.exports;
Ke({});
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function Qj(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function Wo(e) {
  var t, n;
  return Qj(e) === !1 ? !1 : (t = e.constructor, t === void 0 ? !0 : (n = t.prototype, !(Qj(n) === !1 || n.hasOwnProperty("isPrototypeOf") === !1)));
}
var t7 = Symbol.for("immer-nothing"), eA = Symbol.for("immer-draftable"), Ji = Symbol.for("immer-state"), xpe = process.env.NODE_ENV !== "production" ? [
  // All error codes, starting by 0:
  function(e) {
    return `The plugin for '${e}' has not been loaded into Immer. To enable the plugin, import and call \`enable${e}()\` when initializing your application.`;
  },
  function(e) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${e}'`;
  },
  "This object has been frozen and should not be mutated",
  function(e) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + e;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(e) {
    return `'current' expects a draft, got: ${e}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(e) {
    return `'original' expects a draft, got: ${e}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function ci(e, ...t) {
  if (process.env.NODE_ENV !== "production") {
    const n = xpe[e], r = typeof n == "function" ? n.apply(null, t) : n;
    throw new Error(`[Immer] ${r}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var yc = Object.getPrototypeOf;
function Uu(e) {
  return !!e && !!e[Ji];
}
function Hu(e) {
  var t;
  return e ? n7(e) || Array.isArray(e) || !!e[eA] || !!((t = e.constructor) != null && t[eA]) || aw(e) || lw(e) : !1;
}
var Ope = Object.prototype.constructor.toString();
function n7(e) {
  if (!e || typeof e != "object")
    return !1;
  const t = yc(e);
  if (t === null)
    return !0;
  const n = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
  return n === Object ? !0 : typeof n == "function" && Function.toString.call(n) === Ope;
}
function vv(e, t) {
  sw(e) === 0 ? Reflect.ownKeys(e).forEach((n) => {
    t(n, e[n], e);
  }) : e.forEach((n, r) => t(r, n, e));
}
function sw(e) {
  const t = e[Ji];
  return t ? t.type_ : Array.isArray(e) ? 1 : aw(e) ? 2 : lw(e) ? 3 : 0;
}
function tk(e, t) {
  return sw(e) === 2 ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t);
}
function r7(e, t, n) {
  const r = sw(e);
  r === 2 ? e.set(t, n) : r === 3 ? e.add(n) : e[t] = n;
}
function Epe(e, t) {
  return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && t !== t;
}
function aw(e) {
  return e instanceof Map;
}
function lw(e) {
  return e instanceof Set;
}
function tu(e) {
  return e.copy_ || e.base_;
}
function nk(e, t) {
  if (aw(e))
    return new Map(e);
  if (lw(e))
    return new Set(e);
  if (Array.isArray(e))
    return Array.prototype.slice.call(e);
  const n = n7(e);
  if (t === !0 || t === "class_only" && !n) {
    const r = Object.getOwnPropertyDescriptors(e);
    delete r[Ji];
    let o = Reflect.ownKeys(r);
    for (let i = 0; i < o.length; i++) {
      const a = o[i], s = r[a];
      s.writable === !1 && (s.writable = !0, s.configurable = !0), (s.get || s.set) && (r[a] = {
        configurable: !0,
        writable: !0,
        // could live with !!desc.set as well here...
        enumerable: s.enumerable,
        value: e[a]
      });
    }
    return Object.create(yc(e), r);
  } else {
    const r = yc(e);
    if (r !== null && n)
      return { ...e };
    const o = Object.create(r);
    return Object.assign(o, e);
  }
}
function fP(e, t = !1) {
  return uw(e) || Uu(e) || !Hu(e) || (sw(e) > 1 && (e.set = e.add = e.clear = e.delete = kpe), Object.freeze(e), t && Object.entries(e).forEach(([n, r]) => fP(r, !0))), e;
}
function kpe() {
  ci(2);
}
function uw(e) {
  return Object.isFrozen(e);
}
var Lpe = {};
function $u(e) {
  const t = Lpe[e];
  return t || ci(0, e), t;
}
var qd;
function o7() {
  return qd;
}
function Ppe(e, t) {
  return {
    drafts_: [],
    parent_: e,
    immer_: t,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0
  };
}
function tA(e, t) {
  t && ($u("Patches"), e.patches_ = [], e.inversePatches_ = [], e.patchListener_ = t);
}
function rk(e) {
  ok(e), e.drafts_.forEach(_pe), e.drafts_ = null;
}
function ok(e) {
  e === qd && (qd = e.parent_);
}
function nA(e) {
  return qd = Ppe(qd, e);
}
function _pe(e) {
  const t = e[Ji];
  t.type_ === 0 || t.type_ === 1 ? t.revoke_() : t.revoked_ = !0;
}
function rA(e, t) {
  t.unfinalizedDrafts_ = t.drafts_.length;
  const n = t.drafts_[0];
  return e !== void 0 && e !== n ? (n[Ji].modified_ && (rk(t), ci(4)), Hu(e) && (e = yv(t, e), t.parent_ || bv(t, e)), t.patches_ && $u("Patches").generateReplacementPatches_(
    n[Ji].base_,
    e,
    t.patches_,
    t.inversePatches_
  )) : e = yv(t, n, []), rk(t), t.patches_ && t.patchListener_(t.patches_, t.inversePatches_), e !== t7 ? e : void 0;
}
function yv(e, t, n) {
  if (uw(t))
    return t;
  const r = t[Ji];
  if (!r)
    return vv(
      t,
      (o, i) => oA(e, r, t, o, i, n)
    ), t;
  if (r.scope_ !== e)
    return t;
  if (!r.modified_)
    return bv(e, r.base_, !0), r.base_;
  if (!r.finalized_) {
    r.finalized_ = !0, r.scope_.unfinalizedDrafts_--;
    const o = r.copy_;
    let i = o, a = !1;
    r.type_ === 3 && (i = new Set(o), o.clear(), a = !0), vv(
      i,
      (s, l) => oA(e, r, o, s, l, n, a)
    ), bv(e, o, !1), n && e.patches_ && $u("Patches").generatePatches_(
      r,
      n,
      e.patches_,
      e.inversePatches_
    );
  }
  return r.copy_;
}
function oA(e, t, n, r, o, i, a) {
  if (process.env.NODE_ENV !== "production" && o === n && ci(5), Uu(o)) {
    const s = i && t && t.type_ !== 3 && // Set objects are atomic since they have no keys.
    !tk(t.assigned_, r) ? i.concat(r) : void 0, l = yv(e, o, s);
    if (r7(n, r, l), Uu(l))
      e.canAutoFreeze_ = !1;
    else
      return;
  } else a && n.add(o);
  if (Hu(o) && !uw(o)) {
    if (!e.immer_.autoFreeze_ && e.unfinalizedDrafts_ < 1)
      return;
    yv(e, o), (!t || !t.scope_.parent_) && typeof r != "symbol" && Object.prototype.propertyIsEnumerable.call(n, r) && bv(e, o);
  }
}
function bv(e, t, n = !1) {
  !e.parent_ && e.immer_.autoFreeze_ && e.canAutoFreeze_ && fP(t, n);
}
function Spe(e, t) {
  const n = Array.isArray(e), r = {
    type_: n ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: t ? t.scope_ : o7(),
    // True for both shallow and deep changes.
    modified_: !1,
    // Used during finalization.
    finalized_: !1,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: t,
    // The base state.
    base_: e,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: !1
  };
  let o = r, i = hP;
  n && (o = [r], i = Gd);
  const { revoke: a, proxy: s } = Proxy.revocable(o, i);
  return r.draft_ = s, r.revoke_ = a, s;
}
var hP = {
  get(e, t) {
    if (t === Ji)
      return e;
    const n = tu(e);
    if (!tk(n, t))
      return Mpe(e, n, t);
    const r = n[t];
    return e.finalized_ || !Hu(r) ? r : r === Q0(e.base_, t) ? (eC(e), e.copy_[t] = sk(r, e)) : r;
  },
  has(e, t) {
    return t in tu(e);
  },
  ownKeys(e) {
    return Reflect.ownKeys(tu(e));
  },
  set(e, t, n) {
    const r = i7(tu(e), t);
    if (r != null && r.set)
      return r.set.call(e.draft_, n), !0;
    if (!e.modified_) {
      const o = Q0(tu(e), t), i = o == null ? void 0 : o[Ji];
      if (i && i.base_ === n)
        return e.copy_[t] = n, e.assigned_[t] = !1, !0;
      if (Epe(n, o) && (n !== void 0 || tk(e.base_, t)))
        return !0;
      eC(e), ik(e);
    }
    return e.copy_[t] === n && // special case: handle new props with value 'undefined'
    (n !== void 0 || t in e.copy_) || // special case: NaN
    Number.isNaN(n) && Number.isNaN(e.copy_[t]) || (e.copy_[t] = n, e.assigned_[t] = !0), !0;
  },
  deleteProperty(e, t) {
    return Q0(e.base_, t) !== void 0 || t in e.base_ ? (e.assigned_[t] = !1, eC(e), ik(e)) : delete e.assigned_[t], e.copy_ && delete e.copy_[t], !0;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(e, t) {
    const n = tu(e), r = Reflect.getOwnPropertyDescriptor(n, t);
    return r && {
      writable: !0,
      configurable: e.type_ !== 1 || t !== "length",
      enumerable: r.enumerable,
      value: n[t]
    };
  },
  defineProperty() {
    ci(11);
  },
  getPrototypeOf(e) {
    return yc(e.base_);
  },
  setPrototypeOf() {
    ci(12);
  }
}, Gd = {};
vv(hP, (e, t) => {
  Gd[e] = function() {
    return arguments[0] = arguments[0][0], t.apply(this, arguments);
  };
});
Gd.deleteProperty = function(e, t) {
  return process.env.NODE_ENV !== "production" && isNaN(parseInt(t)) && ci(13), Gd.set.call(this, e, t, void 0);
};
Gd.set = function(e, t, n) {
  return process.env.NODE_ENV !== "production" && t !== "length" && isNaN(parseInt(t)) && ci(14), hP.set.call(this, e[0], t, n, e[0]);
};
function Q0(e, t) {
  const n = e[Ji];
  return (n ? tu(n) : e)[t];
}
function Mpe(e, t, n) {
  var r;
  const o = i7(t, n);
  return o ? "value" in o ? o.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (r = o.get) == null ? void 0 : r.call(e.draft_)
  ) : void 0;
}
function i7(e, t) {
  if (!(t in e))
    return;
  let n = yc(e);
  for (; n; ) {
    const r = Object.getOwnPropertyDescriptor(n, t);
    if (r)
      return r;
    n = yc(n);
  }
}
function ik(e) {
  e.modified_ || (e.modified_ = !0, e.parent_ && ik(e.parent_));
}
function eC(e) {
  e.copy_ || (e.copy_ = nk(
    e.base_,
    e.scope_.immer_.useStrictShallowCopy_
  ));
}
var Dpe = class {
  constructor(e) {
    this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.produce = (t, n, r) => {
      if (typeof t == "function" && typeof n != "function") {
        const i = n;
        n = t;
        const a = this;
        return function(s = i, ...l) {
          return a.produce(s, (u) => n.call(this, u, ...l));
        };
      }
      typeof n != "function" && ci(6), r !== void 0 && typeof r != "function" && ci(7);
      let o;
      if (Hu(t)) {
        const i = nA(this), a = sk(t, void 0);
        let s = !0;
        try {
          o = n(a), s = !1;
        } finally {
          s ? rk(i) : ok(i);
        }
        return tA(i, r), rA(o, i);
      } else if (!t || typeof t != "object") {
        if (o = n(t), o === void 0 && (o = t), o === t7 && (o = void 0), this.autoFreeze_ && fP(o, !0), r) {
          const i = [], a = [];
          $u("Patches").generateReplacementPatches_(t, o, i, a), r(i, a);
        }
        return o;
      } else
        ci(1, t);
    }, this.produceWithPatches = (t, n) => {
      if (typeof t == "function")
        return (i, ...a) => this.produceWithPatches(i, (s) => t(s, ...a));
      let r, o;
      return [this.produce(t, n, (i, a) => {
        r = i, o = a;
      }), r, o];
    }, typeof (e == null ? void 0 : e.autoFreeze) == "boolean" && this.setAutoFreeze(e.autoFreeze), typeof (e == null ? void 0 : e.useStrictShallowCopy) == "boolean" && this.setUseStrictShallowCopy(e.useStrictShallowCopy);
  }
  createDraft(e) {
    Hu(e) || ci(8), Uu(e) && (e = Tpe(e));
    const t = nA(this), n = sk(e, void 0);
    return n[Ji].isManual_ = !0, ok(t), n;
  }
  finishDraft(e, t) {
    const n = e && e[Ji];
    (!n || !n.isManual_) && ci(9);
    const { scope_: r } = n;
    return tA(r, t), rA(void 0, r);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(e) {
    this.autoFreeze_ = e;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(e) {
    this.useStrictShallowCopy_ = e;
  }
  applyPatches(e, t) {
    let n;
    for (n = t.length - 1; n >= 0; n--) {
      const o = t[n];
      if (o.path.length === 0 && o.op === "replace") {
        e = o.value;
        break;
      }
    }
    n > -1 && (t = t.slice(n + 1));
    const r = $u("Patches").applyPatches_;
    return Uu(e) ? r(e, t) : this.produce(
      e,
      (o) => r(o, t)
    );
  }
};
function sk(e, t) {
  const n = aw(e) ? $u("MapSet").proxyMap_(e, t) : lw(e) ? $u("MapSet").proxySet_(e, t) : Spe(e, t);
  return (t ? t.scope_ : o7()).drafts_.push(n), n;
}
function Tpe(e) {
  return Uu(e) || ci(10, e), s7(e);
}
function s7(e) {
  if (!Hu(e) || uw(e))
    return e;
  const t = e[Ji];
  let n;
  if (t) {
    if (!t.modified_)
      return t.base_;
    t.finalized_ = !0, n = nk(e, t.scope_.immer_.useStrictShallowCopy_);
  } else
    n = nk(e, !0);
  return vv(n, (r, o) => {
    r7(n, r, s7(o));
  }), t && (t.finalized_ = !1), n;
}
var Qi = new Dpe(), gP = Qi.produce;
Qi.produceWithPatches.bind(
  Qi
);
Qi.setAutoFreeze.bind(Qi);
Qi.setUseStrictShallowCopy.bind(Qi);
Qi.applyPatches.bind(Qi);
var iA = Qi.createDraft.bind(Qi), sA = Qi.finishDraft.bind(Qi), $e = {
  ancestors(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = $e.levels(e, t);
    return n ? r = r.slice(1) : r = r.slice(0, -1), r;
  },
  common(e, t) {
    for (var n = [], r = 0; r < e.length && r < t.length; r++) {
      var o = e[r], i = t[r];
      if (o !== i)
        break;
      n.push(o);
    }
    return n;
  },
  compare(e, t) {
    for (var n = Math.min(e.length, t.length), r = 0; r < n; r++) {
      if (e[r] < t[r]) return -1;
      if (e[r] > t[r]) return 1;
    }
    return 0;
  },
  endsAfter(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return $e.equals(r, o) && i > a;
  },
  endsAt(e, t) {
    var n = e.length, r = e.slice(0, n), o = t.slice(0, n);
    return $e.equals(r, o);
  },
  endsBefore(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return $e.equals(r, o) && i < a;
  },
  equals(e, t) {
    return e.length === t.length && e.every((n, r) => n === t[r]);
  },
  hasPrevious(e) {
    return e[e.length - 1] > 0;
  },
  isAfter(e, t) {
    return $e.compare(e, t) === 1;
  },
  isAncestor(e, t) {
    return e.length < t.length && $e.compare(e, t) === 0;
  },
  isBefore(e, t) {
    return $e.compare(e, t) === -1;
  },
  isChild(e, t) {
    return e.length === t.length + 1 && $e.compare(e, t) === 0;
  },
  isCommon(e, t) {
    return e.length <= t.length && $e.compare(e, t) === 0;
  },
  isDescendant(e, t) {
    return e.length > t.length && $e.compare(e, t) === 0;
  },
  isParent(e, t) {
    return e.length + 1 === t.length && $e.compare(e, t) === 0;
  },
  isPath(e) {
    return Array.isArray(e) && (e.length === 0 || typeof e[0] == "number");
  },
  isSibling(e, t) {
    if (e.length !== t.length)
      return !1;
    var n = e.slice(0, -1), r = t.slice(0, -1), o = e[e.length - 1], i = t[t.length - 1];
    return o !== i && $e.equals(n, r);
  },
  levels(e) {
    for (var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = [], o = 0; o <= e.length; o++)
      r.push(e.slice(0, o));
    return n && r.reverse(), r;
  },
  next(e) {
    if (e.length === 0)
      throw new Error("Cannot get the next path of a root path [".concat(e, "], because it has no next index."));
    var t = e[e.length - 1];
    return e.slice(0, -1).concat(t + 1);
  },
  operationCanTransformPath(e) {
    switch (e.type) {
      case "insert_node":
      case "remove_node":
      case "merge_node":
      case "split_node":
      case "move_node":
        return !0;
      default:
        return !1;
    }
  },
  parent(e) {
    if (e.length === 0)
      throw new Error("Cannot get the parent path of the root path [".concat(e, "]."));
    return e.slice(0, -1);
  },
  previous(e) {
    if (e.length === 0)
      throw new Error("Cannot get the previous path of a root path [".concat(e, "], because it has no previous index."));
    var t = e[e.length - 1];
    if (t <= 0)
      throw new Error("Cannot get the previous path of a first child path [".concat(e, "] because it would result in a negative index."));
    return e.slice(0, -1).concat(t - 1);
  },
  relative(e, t) {
    if (!$e.isAncestor(t, e) && !$e.equals(e, t))
      throw new Error("Cannot get the relative path of [".concat(e, "] inside ancestor [").concat(t, "], because it is not above or equal to the path."));
    return e.slice(t.length);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!e) return null;
    var r = [...e], {
      affinity: o = "forward"
    } = n;
    if (e.length === 0)
      return r;
    switch (t.type) {
      case "insert_node": {
        var {
          path: i
        } = t;
        ($e.equals(i, r) || $e.endsBefore(i, r) || $e.isAncestor(i, r)) && (r[i.length - 1] += 1);
        break;
      }
      case "remove_node": {
        var {
          path: a
        } = t;
        if ($e.equals(a, r) || $e.isAncestor(a, r))
          return null;
        $e.endsBefore(a, r) && (r[a.length - 1] -= 1);
        break;
      }
      case "merge_node": {
        var {
          path: s,
          position: l
        } = t;
        $e.equals(s, r) || $e.endsBefore(s, r) ? r[s.length - 1] -= 1 : $e.isAncestor(s, r) && (r[s.length - 1] -= 1, r[s.length] += l);
        break;
      }
      case "split_node": {
        var {
          path: u,
          position: c
        } = t;
        if ($e.equals(u, r)) {
          if (o === "forward")
            r[r.length - 1] += 1;
          else if (o !== "backward") return null;
        } else $e.endsBefore(u, r) ? r[u.length - 1] += 1 : $e.isAncestor(u, r) && e[u.length] >= c && (r[u.length - 1] += 1, r[u.length] -= c);
        break;
      }
      case "move_node": {
        var {
          path: p,
          newPath: d
        } = t;
        if ($e.equals(p, d))
          return r;
        if ($e.isAncestor(p, r) || $e.equals(p, r)) {
          var g = d.slice();
          return $e.endsBefore(p, d) && p.length < d.length && (g[p.length - 1] -= 1), g.concat(r.slice(p.length));
        } else $e.isSibling(p, d) && ($e.isAncestor(d, r) || $e.equals(d, r)) ? $e.endsBefore(p, r) ? r[p.length - 1] -= 1 : r[p.length - 1] += 1 : $e.endsBefore(d, r) || $e.equals(d, r) || $e.isAncestor(d, r) ? ($e.endsBefore(p, r) && (r[p.length - 1] -= 1), r[d.length - 1] += 1) : $e.endsBefore(p, r) && ($e.equals(d, r) && (r[d.length - 1] += 1), r[p.length - 1] -= 1);
        break;
      }
    }
    return r;
  }
};
function Kd(e) {
  "@babel/helpers - typeof";
  return Kd = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Kd(e);
}
function jpe(e, t) {
  if (Kd(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (Kd(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function Ape(e) {
  var t = jpe(e, "string");
  return Kd(t) === "symbol" ? t : String(t);
}
function Pc(e, t, n) {
  return t = Ape(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function aA(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function np(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? aA(Object(n), !0).forEach(function(r) {
      Pc(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : aA(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Ipe = (e, t, n) => {
  switch (n.type) {
    case "insert_node": {
      var {
        path: r,
        node: o
      } = n, i = St.parent(e, r), a = r[r.length - 1];
      if (a > i.children.length)
        throw new Error('Cannot apply an "insert_node" operation at path ['.concat(r, "] because the destination is past the end of the node."));
      if (i.children.splice(a, 0, o), t)
        for (var [s, l] of Wt.points(t))
          t[l] = yr.transform(s, n);
      break;
    }
    case "insert_text": {
      var {
        path: u,
        offset: c,
        text: p
      } = n;
      if (p.length === 0) break;
      var d = St.leaf(e, u), g = d.text.slice(0, c), f = d.text.slice(c);
      if (d.text = g + p + f, t)
        for (var [m, v] of Wt.points(t))
          t[v] = yr.transform(m, n);
      break;
    }
    case "merge_node": {
      var {
        path: E
      } = n, w = St.get(e, E), M = $e.previous(E), O = St.get(e, M), y = St.parent(e, E), C = E[E.length - 1];
      if (ao.isText(w) && ao.isText(O))
        O.text += w.text;
      else if (!ao.isText(w) && !ao.isText(O))
        O.children.push(...w.children);
      else
        throw new Error('Cannot apply a "merge_node" operation at path ['.concat(E, "] to nodes of different interfaces: ").concat(Ti.stringify(w), " ").concat(Ti.stringify(O)));
      if (y.children.splice(C, 1), t)
        for (var [_, F] of Wt.points(t))
          t[F] = yr.transform(_, n);
      break;
    }
    case "move_node": {
      var {
        path: L,
        newPath: N
      } = n;
      if ($e.isAncestor(L, N))
        throw new Error("Cannot move a path [".concat(L, "] to new path [").concat(N, "] because the destination is inside itself."));
      var R = St.get(e, L), W = St.parent(e, L), V = L[L.length - 1];
      W.children.splice(V, 1);
      var z = $e.transform(L, n), Z = St.get(e, $e.parent(z)), K = z[z.length - 1];
      if (Z.children.splice(K, 0, R), t)
        for (var [X, te] of Wt.points(t))
          t[te] = yr.transform(X, n);
      break;
    }
    case "remove_node": {
      var {
        path: J
      } = n, P = J[J.length - 1], D = St.parent(e, J);
      if (D.children.splice(P, 1), t)
        for (var [H, S] of Wt.points(t)) {
          var $ = yr.transform(H, n);
          if (t != null && $ != null)
            t[S] = $;
          else {
            var x = void 0, j = void 0;
            for (var [U, T] of St.texts(e))
              if ($e.compare(T, J) === -1)
                x = [U, T];
              else {
                j = [U, T];
                break;
              }
            var q = !1;
            x && j && ($e.equals(j[1], J) ? q = !$e.hasPrevious(j[1]) : q = $e.common(x[1], J).length < $e.common(j[1], J).length), x && !q ? (H.path = x[1], H.offset = x[0].text.length) : j ? (H.path = j[1], H.offset = 0) : t = null;
          }
        }
      break;
    }
    case "remove_text": {
      var {
        path: A,
        offset: Y,
        text: B
      } = n;
      if (B.length === 0) break;
      var ue = St.leaf(e, A), fe = ue.text.slice(0, Y), oe = ue.text.slice(Y + B.length);
      if (ue.text = fe + oe, t)
        for (var [Ae, Ze] of Wt.points(t))
          t[Ze] = yr.transform(Ae, n);
      break;
    }
    case "set_node": {
      var {
        path: Ge,
        properties: Ie,
        newProperties: et
      } = n;
      if (Ge.length === 0)
        throw new Error("Cannot set properties on the root node!");
      var Ye = St.get(e, Ge);
      for (var _e in et) {
        if (_e === "children" || _e === "text")
          throw new Error('Cannot set the "'.concat(_e, '" property of nodes!'));
        var Qe = et[_e];
        Qe == null ? delete Ye[_e] : Ye[_e] = Qe;
      }
      for (var at in Ie)
        et.hasOwnProperty(at) || delete Ye[at];
      break;
    }
    case "set_selection": {
      var {
        newProperties: Pe
      } = n;
      if (Pe == null)
        t = Pe;
      else {
        if (t == null) {
          if (!Wt.isRange(Pe))
            throw new Error('Cannot apply an incomplete "set_selection" operation properties '.concat(Ti.stringify(Pe), " when there is no current selection."));
          t = np({}, Pe);
        }
        for (var Me in Pe) {
          var Je = Pe[Me];
          if (Je == null) {
            if (Me === "anchor" || Me === "focus")
              throw new Error('Cannot remove the "'.concat(Me, '" selection property'));
            delete t[Me];
          } else
            t[Me] = Je;
        }
      }
      break;
    }
    case "split_node": {
      var {
        path: We,
        position: Re,
        properties: nt
      } = n;
      if (We.length === 0)
        throw new Error('Cannot apply a "split_node" operation at path ['.concat(We, "] because the root node cannot be split."));
      var De = St.get(e, We), yt = St.parent(e, We), ot = We[We.length - 1], st;
      if (ao.isText(De)) {
        var ct = De.text.slice(0, Re), bt = De.text.slice(Re);
        De.text = ct, st = np(np({}, nt), {}, {
          text: bt
        });
      } else {
        var pt = De.children.slice(0, Re), dt = De.children.slice(Re);
        De.children = pt, st = np(np({}, nt), {}, {
          children: dt
        });
      }
      if (yt.children.splice(ot + 1, 0, st), t)
        for (var [tt, Xe] of Wt.points(t))
          t[Xe] = yr.transform(tt, n);
      break;
    }
  }
  return t;
}, Rpe = {
  transform(e, t) {
    e.children = iA(e.children);
    var n = e.selection && iA(e.selection);
    try {
      n = Ipe(e, n, t);
    } finally {
      e.children = sA(e.children), n ? e.selection = Uu(n) ? sA(n) : n : e.selection = null;
    }
  }
}, Bpe = {
  insertNodes(e, t, n) {
    e.insertNodes(t, n);
  },
  liftNodes(e, t) {
    e.liftNodes(t);
  },
  mergeNodes(e, t) {
    e.mergeNodes(t);
  },
  moveNodes(e, t) {
    e.moveNodes(t);
  },
  removeNodes(e, t) {
    e.removeNodes(t);
  },
  setNodes(e, t, n) {
    e.setNodes(t, n);
  },
  splitNodes(e, t) {
    e.splitNodes(t);
  },
  unsetNodes(e, t, n) {
    e.unsetNodes(t, n);
  },
  unwrapNodes(e, t) {
    e.unwrapNodes(t);
  },
  wrapNodes(e, t, n) {
    e.wrapNodes(t, n);
  }
}, Npe = {
  collapse(e, t) {
    e.collapse(t);
  },
  deselect(e) {
    e.deselect();
  },
  move(e, t) {
    e.move(t);
  },
  select(e, t) {
    e.select(t);
  },
  setPoint(e, t, n) {
    e.setPoint(t, n);
  },
  setSelection(e, t) {
    e.setSelection(t);
  }
}, a7 = (e, t) => {
  for (var n in e) {
    var r = e[n], o = t[n];
    if (Wo(r) && Wo(o)) {
      if (!a7(r, o)) return !1;
    } else if (Array.isArray(r) && Array.isArray(o)) {
      if (r.length !== o.length) return !1;
      for (var i = 0; i < r.length; i++)
        if (r[i] !== o[i]) return !1;
    } else if (r !== o)
      return !1;
  }
  for (var a in t)
    if (e[a] === void 0 && t[a] !== void 0)
      return !1;
  return !0;
};
function Fpe(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), o, i;
  for (i = 0; i < r.length; i++)
    o = r[i], !(t.indexOf(o) >= 0) && (n[o] = e[o]);
  return n;
}
function Yd(e, t) {
  if (e == null) return {};
  var n = Fpe(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (o = 0; o < i.length; o++)
      r = i[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
var zpe = ["anchor", "focus"];
function lA(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Upe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? lA(Object(n), !0).forEach(function(r) {
      Pc(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : lA(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Wt = {
  edges(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, {
      anchor: r,
      focus: o
    } = e;
    return Wt.isBackward(e) === n ? [r, o] : [o, r];
  },
  end(e) {
    var [, t] = Wt.edges(e);
    return t;
  },
  equals(e, t) {
    return yr.equals(e.anchor, t.anchor) && yr.equals(e.focus, t.focus);
  },
  includes(e, t) {
    if (Wt.isRange(t)) {
      if (Wt.includes(e, t.anchor) || Wt.includes(e, t.focus))
        return !0;
      var [n, r] = Wt.edges(e), [o, i] = Wt.edges(t);
      return yr.isBefore(n, o) && yr.isAfter(r, i);
    }
    var [a, s] = Wt.edges(e), l = !1, u = !1;
    return yr.isPoint(t) ? (l = yr.compare(t, a) >= 0, u = yr.compare(t, s) <= 0) : (l = $e.compare(t, a.path) >= 0, u = $e.compare(t, s.path) <= 0), l && u;
  },
  intersection(e, t) {
    var n = Yd(e, zpe), [r, o] = Wt.edges(e), [i, a] = Wt.edges(t), s = yr.isBefore(r, i) ? i : r, l = yr.isBefore(o, a) ? o : a;
    return yr.isBefore(l, s) ? null : Upe({
      anchor: s,
      focus: l
    }, n);
  },
  isBackward(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return yr.isAfter(t, n);
  },
  isCollapsed(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return yr.equals(t, n);
  },
  isExpanded(e) {
    return !Wt.isCollapsed(e);
  },
  isForward(e) {
    return !Wt.isBackward(e);
  },
  isRange(e) {
    return Wo(e) && yr.isPoint(e.anchor) && yr.isPoint(e.focus);
  },
  *points(e) {
    yield [e.anchor, "anchor"], yield [e.focus, "focus"];
  },
  start(e) {
    var [t] = Wt.edges(e);
    return t;
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return gP(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "inward"
      } = n, i, a;
      if (o === "inward") {
        var s = Wt.isCollapsed(r);
        Wt.isForward(r) ? (i = "forward", a = s ? i : "backward") : (i = "backward", a = s ? i : "forward");
      } else o === "outward" ? Wt.isForward(r) ? (i = "backward", a = "forward") : (i = "forward", a = "backward") : (i = o, a = o);
      var l = yr.transform(r.anchor, t, {
        affinity: i
      }), u = yr.transform(r.focus, t, {
        affinity: a
      });
      if (!l || !u)
        return null;
      r.anchor = l, r.focus = u;
    });
  }
}, uA = (e) => Wo(e) && St.isNodeList(e.children) && !Yn.isEditor(e), ia = {
  isAncestor(e) {
    return Wo(e) && St.isNodeList(e.children);
  },
  isElement: uA,
  isElementList(e) {
    return Array.isArray(e) && e.every((t) => ia.isElement(t));
  },
  isElementProps(e) {
    return e.children !== void 0;
  },
  isElementType: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "type";
    return uA(e) && e[n] === t;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "children" && e[n] !== t[n])
        return !1;
    return !0;
  }
}, Hpe = ["children"], $pe = ["text"], cA = /* @__PURE__ */ new WeakMap(), St = {
  ancestor(e, t) {
    var n = St.get(e, t);
    if (ao.isText(n))
      throw new Error("Cannot get the ancestor node at path [".concat(t, "] because it refers to a text node instead: ").concat(Ti.stringify(n)));
    return n;
  },
  ancestors(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of $e.ancestors(t, n)) {
        var o = St.ancestor(e, r), i = [o, r];
        yield i;
      }
    }();
  },
  child(e, t) {
    if (ao.isText(e))
      throw new Error("Cannot get the child of a text node: ".concat(Ti.stringify(e)));
    var n = e.children[t];
    if (n == null)
      throw new Error("Cannot get child at index `".concat(t, "` in node: ").concat(Ti.stringify(e)));
    return n;
  },
  children(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var {
        reverse: r = !1
      } = n, o = St.ancestor(e, t), {
        children: i
      } = o, a = r ? i.length - 1 : 0; r ? a >= 0 : a < i.length; ) {
        var s = St.child(o, a), l = t.concat(a);
        yield [s, l], a = r ? a - 1 : a + 1;
      }
    }();
  },
  common(e, t, n) {
    var r = $e.common(t, n), o = St.get(e, r);
    return [o, r];
  },
  descendant(e, t) {
    var n = St.get(e, t);
    if (Yn.isEditor(n))
      throw new Error("Cannot get the descendant node at path [".concat(t, "] because it refers to the root editor node instead: ").concat(Ti.stringify(n)));
    return n;
  },
  descendants(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of St.nodes(e, t))
        r.length !== 0 && (yield [n, r]);
    }();
  },
  elements(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of St.nodes(e, t))
        ia.isElement(n) && (yield [n, r]);
    }();
  },
  extractProps(e) {
    if (ia.isAncestor(e)) {
      var t = Yd(e, Hpe);
      return t;
    } else {
      var t = Yd(e, $pe);
      return t;
    }
  },
  first(e, t) {
    for (var n = t.slice(), r = St.get(e, n); r && !(ao.isText(r) || r.children.length === 0); )
      r = r.children[0], n.push(0);
    return [r, n];
  },
  fragment(e, t) {
    if (ao.isText(e))
      throw new Error("Cannot get a fragment starting from a root text node: ".concat(Ti.stringify(e)));
    var n = gP({
      children: e.children
    }, (r) => {
      var [o, i] = Wt.edges(t), a = St.nodes(r, {
        reverse: !0,
        pass: (d) => {
          var [, g] = d;
          return !Wt.includes(t, g);
        }
      });
      for (var [, s] of a) {
        if (!Wt.includes(t, s)) {
          var l = St.parent(r, s), u = s[s.length - 1];
          l.children.splice(u, 1);
        }
        if ($e.equals(s, i.path)) {
          var c = St.leaf(r, s);
          c.text = c.text.slice(0, i.offset);
        }
        if ($e.equals(s, o.path)) {
          var p = St.leaf(r, s);
          p.text = p.text.slice(o.offset);
        }
      }
      Yn.isEditor(r) && (r.selection = null);
    });
    return n.children;
  },
  get(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (ao.isText(n) || !n.children[o])
        throw new Error("Cannot find a descendant at path [".concat(t, "] in node: ").concat(Ti.stringify(e)));
      n = n.children[o];
    }
    return n;
  },
  has(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (ao.isText(n) || !n.children[o])
        return !1;
      n = n.children[o];
    }
    return !0;
  },
  isNode(e) {
    return ao.isText(e) || ia.isElement(e) || Yn.isEditor(e);
  },
  isNodeList(e) {
    if (!Array.isArray(e))
      return !1;
    var t = cA.get(e);
    if (t !== void 0)
      return t;
    var n = e.every((r) => St.isNode(r));
    return cA.set(e, n), n;
  },
  last(e, t) {
    for (var n = t.slice(), r = St.get(e, n); r && !(ao.isText(r) || r.children.length === 0); ) {
      var o = r.children.length - 1;
      r = r.children[o], n.push(o);
    }
    return [r, n];
  },
  leaf(e, t) {
    var n = St.get(e, t);
    if (!ao.isText(n))
      throw new Error("Cannot get the leaf node at path [".concat(t, "] because it refers to a non-leaf node: ").concat(Ti.stringify(n)));
    return n;
  },
  levels(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of $e.levels(t, n)) {
        var o = St.get(e, r);
        yield [o, r];
      }
    }();
  },
  matches(e, t) {
    return ia.isElement(e) && ia.isElementProps(t) && ia.matches(e, t) || ao.isText(e) && ao.isTextProps(t) && ao.matches(e, t);
  },
  nodes(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var {
        pass: n,
        reverse: r = !1
      } = t, {
        from: o = [],
        to: i
      } = t, a = /* @__PURE__ */ new Set(), s = [], l = e; !(i && (r ? $e.isBefore(s, i) : $e.isAfter(s, i))); ) {
        if (a.has(l) || (yield [l, s]), !a.has(l) && !ao.isText(l) && l.children.length !== 0 && (n == null || n([l, s]) === !1)) {
          a.add(l);
          var u = r ? l.children.length - 1 : 0;
          $e.isAncestor(s, o) && (u = o[s.length]), s = s.concat(u), l = St.get(e, s);
          continue;
        }
        if (s.length === 0)
          break;
        if (!r) {
          var c = $e.next(s);
          if (St.has(e, c)) {
            s = c, l = St.get(e, s);
            continue;
          }
        }
        if (r && s[s.length - 1] !== 0) {
          var p = $e.previous(s);
          s = p, l = St.get(e, s);
          continue;
        }
        s = $e.parent(s), l = St.get(e, s), a.add(l);
      }
    }();
  },
  parent(e, t) {
    var n = $e.parent(t), r = St.get(e, n);
    if (ao.isText(r))
      throw new Error("Cannot get the parent of path [".concat(t, "] because it does not exist in the root."));
    return r;
  },
  string(e) {
    return ao.isText(e) ? e.text : e.children.map(St.string).join("");
  },
  texts(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of St.nodes(e, t))
        ao.isText(n) && (yield [n, r]);
    }();
  }
};
function pA(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function kr(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? pA(Object(n), !0).forEach(function(r) {
      Pc(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : pA(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Bp = {
  isNodeOperation(e) {
    return Bp.isOperation(e) && e.type.endsWith("_node");
  },
  isOperation(e) {
    if (!Wo(e))
      return !1;
    switch (e.type) {
      case "insert_node":
        return $e.isPath(e.path) && St.isNode(e.node);
      case "insert_text":
        return typeof e.offset == "number" && typeof e.text == "string" && $e.isPath(e.path);
      case "merge_node":
        return typeof e.position == "number" && $e.isPath(e.path) && Wo(e.properties);
      case "move_node":
        return $e.isPath(e.path) && $e.isPath(e.newPath);
      case "remove_node":
        return $e.isPath(e.path) && St.isNode(e.node);
      case "remove_text":
        return typeof e.offset == "number" && typeof e.text == "string" && $e.isPath(e.path);
      case "set_node":
        return $e.isPath(e.path) && Wo(e.properties) && Wo(e.newProperties);
      case "set_selection":
        return e.properties === null && Wt.isRange(e.newProperties) || e.newProperties === null && Wt.isRange(e.properties) || Wo(e.properties) && Wo(e.newProperties);
      case "split_node":
        return $e.isPath(e.path) && typeof e.position == "number" && Wo(e.properties);
      default:
        return !1;
    }
  },
  isOperationList(e) {
    return Array.isArray(e) && e.every((t) => Bp.isOperation(t));
  },
  isSelectionOperation(e) {
    return Bp.isOperation(e) && e.type.endsWith("_selection");
  },
  isTextOperation(e) {
    return Bp.isOperation(e) && e.type.endsWith("_text");
  },
  inverse(e) {
    switch (e.type) {
      case "insert_node":
        return kr(kr({}, e), {}, {
          type: "remove_node"
        });
      case "insert_text":
        return kr(kr({}, e), {}, {
          type: "remove_text"
        });
      case "merge_node":
        return kr(kr({}, e), {}, {
          type: "split_node",
          path: $e.previous(e.path)
        });
      case "move_node": {
        var {
          newPath: t,
          path: n
        } = e;
        if ($e.equals(t, n))
          return e;
        if ($e.isSibling(n, t))
          return kr(kr({}, e), {}, {
            path: t,
            newPath: n
          });
        var r = $e.transform(n, e), o = $e.transform($e.next(n), e);
        return kr(kr({}, e), {}, {
          path: r,
          newPath: o
        });
      }
      case "remove_node":
        return kr(kr({}, e), {}, {
          type: "insert_node"
        });
      case "remove_text":
        return kr(kr({}, e), {}, {
          type: "insert_text"
        });
      case "set_node": {
        var {
          properties: i,
          newProperties: a
        } = e;
        return kr(kr({}, e), {}, {
          properties: a,
          newProperties: i
        });
      }
      case "set_selection": {
        var {
          properties: s,
          newProperties: l
        } = e;
        return s == null ? kr(kr({}, e), {}, {
          properties: l,
          newProperties: null
        }) : l == null ? kr(kr({}, e), {}, {
          properties: null,
          newProperties: s
        }) : kr(kr({}, e), {}, {
          properties: l,
          newProperties: s
        });
      }
      case "split_node":
        return kr(kr({}, e), {}, {
          type: "merge_node",
          path: $e.next(e.path)
        });
    }
  }
}, dA = /* @__PURE__ */ new WeakMap(), Wpe = (e) => {
  var t = dA.get(e);
  if (t !== void 0)
    return t;
  if (!Wo(e))
    return !1;
  var n = typeof e.addMark == "function" && typeof e.apply == "function" && typeof e.deleteFragment == "function" && typeof e.insertBreak == "function" && typeof e.insertSoftBreak == "function" && typeof e.insertFragment == "function" && typeof e.insertNode == "function" && typeof e.insertText == "function" && typeof e.isElementReadOnly == "function" && typeof e.isInline == "function" && typeof e.isSelectable == "function" && typeof e.isVoid == "function" && typeof e.normalizeNode == "function" && typeof e.onChange == "function" && typeof e.removeMark == "function" && typeof e.getDirtyPaths == "function" && (e.marks === null || Wo(e.marks)) && (e.selection === null || Wt.isRange(e.selection)) && St.isNodeList(e.children) && Bp.isOperationList(e.operations);
  return dA.set(e, n), n;
}, Yn = {
  above(e, t) {
    return e.above(t);
  },
  addMark(e, t, n) {
    e.addMark(t, n);
  },
  after(e, t, n) {
    return e.after(t, n);
  },
  before(e, t, n) {
    return e.before(t, n);
  },
  deleteBackward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteBackward(n);
  },
  deleteForward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteForward(n);
  },
  deleteFragment(e, t) {
    e.deleteFragment(t);
  },
  edges(e, t) {
    return e.edges(t);
  },
  elementReadOnly(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return e.elementReadOnly(t);
  },
  end(e, t) {
    return e.end(t);
  },
  first(e, t) {
    return e.first(t);
  },
  fragment(e, t) {
    return e.fragment(t);
  },
  hasBlocks(e, t) {
    return e.hasBlocks(t);
  },
  hasInlines(e, t) {
    return e.hasInlines(t);
  },
  hasPath(e, t) {
    return e.hasPath(t);
  },
  hasTexts(e, t) {
    return e.hasTexts(t);
  },
  insertBreak(e) {
    e.insertBreak();
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertNode(e, t) {
    e.insertNode(t);
  },
  insertSoftBreak(e) {
    e.insertSoftBreak();
  },
  insertText(e, t) {
    e.insertText(t);
  },
  isBlock(e, t) {
    return e.isBlock(t);
  },
  isEdge(e, t, n) {
    return e.isEdge(t, n);
  },
  isEditor(e) {
    return Wpe(e);
  },
  isElementReadOnly(e, t) {
    return e.isElementReadOnly(t);
  },
  isEmpty(e, t) {
    return e.isEmpty(t);
  },
  isEnd(e, t, n) {
    return e.isEnd(t, n);
  },
  isInline(e, t) {
    return e.isInline(t);
  },
  isNormalizing(e) {
    return e.isNormalizing();
  },
  isSelectable(e, t) {
    return e.isSelectable(t);
  },
  isStart(e, t, n) {
    return e.isStart(t, n);
  },
  isVoid(e, t) {
    return e.isVoid(t);
  },
  last(e, t) {
    return e.last(t);
  },
  leaf(e, t, n) {
    return e.leaf(t, n);
  },
  levels(e, t) {
    return e.levels(t);
  },
  marks(e) {
    return e.getMarks();
  },
  next(e, t) {
    return e.next(t);
  },
  node(e, t, n) {
    return e.node(t, n);
  },
  nodes(e, t) {
    return e.nodes(t);
  },
  normalize(e, t) {
    e.normalize(t);
  },
  parent(e, t, n) {
    return e.parent(t, n);
  },
  path(e, t, n) {
    return e.path(t, n);
  },
  pathRef(e, t, n) {
    return e.pathRef(t, n);
  },
  pathRefs(e) {
    return e.pathRefs();
  },
  point(e, t, n) {
    return e.point(t, n);
  },
  pointRef(e, t, n) {
    return e.pointRef(t, n);
  },
  pointRefs(e) {
    return e.pointRefs();
  },
  positions(e, t) {
    return e.positions(t);
  },
  previous(e, t) {
    return e.previous(t);
  },
  range(e, t, n) {
    return e.range(t, n);
  },
  rangeRef(e, t, n) {
    return e.rangeRef(t, n);
  },
  rangeRefs(e) {
    return e.rangeRefs();
  },
  removeMark(e, t) {
    e.removeMark(t);
  },
  setNormalizing(e, t) {
    e.setNormalizing(t);
  },
  start(e, t) {
    return e.start(t);
  },
  string(e, t, n) {
    return e.string(t, n);
  },
  unhangRange(e, t, n) {
    return e.unhangRange(t, n);
  },
  void(e, t) {
    return e.void(t);
  },
  withoutNormalizing(e, t) {
    e.withoutNormalizing(t);
  },
  shouldMergeNodesRemovePrevNode: (e, t, n) => e.shouldMergeNodesRemovePrevNode(t, n)
};
function fA(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function hA(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? fA(Object(n), !0).forEach(function(r) {
      Pc(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : fA(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var yr = {
  compare(e, t) {
    var n = $e.compare(e.path, t.path);
    return n === 0 ? e.offset < t.offset ? -1 : e.offset > t.offset ? 1 : 0 : n;
  },
  isAfter(e, t) {
    return yr.compare(e, t) === 1;
  },
  isBefore(e, t) {
    return yr.compare(e, t) === -1;
  },
  equals(e, t) {
    return e.offset === t.offset && $e.equals(e.path, t.path);
  },
  isPoint(e) {
    return Wo(e) && typeof e.offset == "number" && $e.isPath(e.path);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return gP(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "forward"
      } = n, {
        path: i,
        offset: a
      } = r;
      switch (t.type) {
        case "insert_node":
        case "move_node": {
          r.path = $e.transform(i, t, n);
          break;
        }
        case "insert_text": {
          $e.equals(t.path, i) && (t.offset < a || t.offset === a && o === "forward") && (r.offset += t.text.length);
          break;
        }
        case "merge_node": {
          $e.equals(t.path, i) && (r.offset += t.position), r.path = $e.transform(i, t, n);
          break;
        }
        case "remove_text": {
          $e.equals(t.path, i) && t.offset <= a && (r.offset -= Math.min(a - t.offset, t.text.length));
          break;
        }
        case "remove_node": {
          if ($e.equals(t.path, i) || $e.isAncestor(t.path, i))
            return null;
          r.path = $e.transform(i, t, n);
          break;
        }
        case "split_node": {
          if ($e.equals(t.path, i)) {
            if (t.position === a && o == null)
              return null;
            (t.position < a || t.position === a && o === "forward") && (r.offset -= t.position, r.path = $e.transform(i, t, hA(hA({}, n), {}, {
              affinity: "forward"
            })));
          } else
            r.path = $e.transform(i, t, n);
          break;
        }
      }
    });
  }
}, gA = void 0, Ti = {
  setScrubber(e) {
    gA = e;
  },
  stringify(e) {
    return JSON.stringify(e, gA);
  }
}, Vpe = ["text"], Zpe = ["anchor", "focus"];
function mA(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Zs(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? mA(Object(n), !0).forEach(function(r) {
      Pc(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : mA(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var ao = {
  equals(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      loose: r = !1
    } = n;
    function o(i) {
      var a = Yd(i, Vpe);
      return a;
    }
    return a7(r ? o(e) : e, r ? o(t) : t);
  },
  isText(e) {
    return Wo(e) && typeof e.text == "string";
  },
  isTextList(e) {
    return Array.isArray(e) && e.every((t) => ao.isText(t));
  },
  isTextProps(e) {
    return e.text !== void 0;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "text" && (!e.hasOwnProperty(n) || e[n] !== t[n]))
        return !1;
    return !0;
  },
  decorations(e, t) {
    var n = [Zs({}, e)];
    for (var r of t) {
      var o = Yd(r, Zpe), [i, a] = Wt.edges(r), s = [], l = 0, u = i.offset, c = a.offset;
      for (var p of n) {
        var {
          length: d
        } = p.text, g = l;
        if (l += d, u <= g && l <= c) {
          Object.assign(p, o), s.push(p);
          continue;
        }
        if (u !== c && (u === l || c === g) || u > l || c < g || c === g && g !== 0) {
          s.push(p);
          continue;
        }
        var f = p, m = void 0, v = void 0;
        if (c < l) {
          var E = c - g;
          v = Zs(Zs({}, f), {}, {
            text: f.text.slice(E)
          }), f = Zs(Zs({}, f), {}, {
            text: f.text.slice(0, E)
          });
        }
        if (u > g) {
          var w = u - g;
          m = Zs(Zs({}, f), {}, {
            text: f.text.slice(0, w)
          }), f = Zs(Zs({}, f), {}, {
            text: f.text.slice(w)
          });
        }
        Object.assign(f, o), m && s.push(m), s.push(f), v && s.push(v);
      }
      n = s;
    }
    return n;
  }
}, qpe = (e) => e.selection ? e.selection : e.children.length > 0 ? Yn.end(e, []) : [0], dr;
(function(e) {
  e[e.None = 0] = "None", e[e.Extend = 1] = "Extend", e[e.ZWJ = 2] = "ZWJ", e[e.RI = 4] = "RI", e[e.Prepend = 8] = "Prepend", e[e.SpacingMark = 16] = "SpacingMark", e[e.L = 32] = "L", e[e.V = 64] = "V", e[e.T = 128] = "T", e[e.LV = 256] = "LV", e[e.LVT = 512] = "LVT", e[e.ExtPict = 1024] = "ExtPict", e[e.Any = 2048] = "Any";
})(dr || (dr = {}));
dr.L, dr.L | dr.V | dr.LV | dr.LVT, dr.LV | dr.V, dr.V | dr.T, dr.LVT | dr.T, dr.T, dr.Any, dr.Extend | dr.ZWJ, dr.Any, dr.SpacingMark, dr.Prepend, dr.Any, dr.ZWJ, dr.ExtPict, dr.RI, dr.RI;
var Gpe = {
  delete(e, t) {
    e.delete(t);
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertText(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Yn.withoutNormalizing(e, () => {
      var {
        voids: r = !1
      } = n, {
        at: o = qpe(e)
      } = n;
      if ($e.isPath(o) && (o = Yn.range(e, o)), Wt.isRange(o))
        if (Wt.isCollapsed(o))
          o = o.anchor;
        else {
          var i = Wt.end(o);
          if (!r && Yn.void(e, {
            at: i
          }))
            return;
          var a = Wt.start(o), s = Yn.pointRef(e, a), l = Yn.pointRef(e, i);
          wv.delete(e, {
            at: o,
            voids: r
          });
          var u = s.unref(), c = l.unref();
          o = u || c, wv.setSelection(e, {
            anchor: o,
            focus: o
          });
        }
      if (!(!r && Yn.void(e, {
        at: o
      }) || Yn.elementReadOnly(e, {
        at: o
      }))) {
        var {
          path: p,
          offset: d
        } = o;
        t.length > 0 && e.apply({
          type: "insert_text",
          path: p,
          offset: d,
          text: t
        });
      }
    });
  }
};
function vA(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Yh(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? vA(Object(n), !0).forEach(function(r) {
      Pc(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : vA(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var wv = Yh(Yh(Yh(Yh({}, Rpe), Bpe), Npe), Gpe), l7 = {}, mP = {}, vP = {}, Xu = {}, yP = {}, bP = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Doctype = e.CDATA = e.Tag = e.Style = e.Script = e.Comment = e.Directive = e.Text = e.Root = e.isTag = e.ElementType = void 0;
  var t;
  (function(r) {
    r.Root = "root", r.Text = "text", r.Directive = "directive", r.Comment = "comment", r.Script = "script", r.Style = "style", r.Tag = "tag", r.CDATA = "cdata", r.Doctype = "doctype";
  })(t = e.ElementType || (e.ElementType = {}));
  function n(r) {
    return r.type === t.Tag || r.type === t.Script || r.type === t.Style;
  }
  e.isTag = n, e.Root = t.Root, e.Text = t.Text, e.Directive = t.Directive, e.Comment = t.Comment, e.Script = t.Script, e.Style = t.Style, e.Tag = t.Tag, e.CDATA = t.CDATA, e.Doctype = t.Doctype;
})(bP);
var Jt = {}, El = rr && rr.__extends || /* @__PURE__ */ function() {
  var e = function(t, n) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, o) {
      r.__proto__ = o;
    } || function(r, o) {
      for (var i in o) Object.prototype.hasOwnProperty.call(o, i) && (r[i] = o[i]);
    }, e(t, n);
  };
  return function(t, n) {
    if (typeof n != "function" && n !== null)
      throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
    e(t, n);
    function r() {
      this.constructor = t;
    }
    t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
  };
}(), Jp = rr && rr.__assign || function() {
  return Jp = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) {
      t = arguments[n];
      for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
    }
    return e;
  }, Jp.apply(this, arguments);
};
Object.defineProperty(Jt, "__esModule", { value: !0 });
Jt.cloneNode = Jt.hasChildren = Jt.isDocument = Jt.isDirective = Jt.isComment = Jt.isText = Jt.isCDATA = Jt.isTag = Jt.Element = Jt.Document = Jt.CDATA = Jt.NodeWithChildren = Jt.ProcessingInstruction = Jt.Comment = Jt.Text = Jt.DataNode = Jt.Node = void 0;
var vi = bP, wP = (
  /** @class */
  function() {
    function e() {
      this.parent = null, this.prev = null, this.next = null, this.startIndex = null, this.endIndex = null;
    }
    return Object.defineProperty(e.prototype, "parentNode", {
      // Read-write aliases for properties
      /**
       * Same as {@link parent}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.parent;
      },
      set: function(t) {
        this.parent = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "previousSibling", {
      /**
       * Same as {@link prev}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.prev;
      },
      set: function(t) {
        this.prev = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "nextSibling", {
      /**
       * Same as {@link next}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.next;
      },
      set: function(t) {
        this.next = t;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.cloneNode = function(t) {
      return t === void 0 && (t = !1), CP(this, t);
    }, e;
  }()
);
Jt.Node = wP;
var cw = (
  /** @class */
  function(e) {
    El(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.data = n, r;
    }
    return Object.defineProperty(t.prototype, "nodeValue", {
      /**
       * Same as {@link data}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.data;
      },
      set: function(n) {
        this.data = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(wP)
);
Jt.DataNode = cw;
var u7 = (
  /** @class */
  function(e) {
    El(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = vi.ElementType.Text, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 3;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(cw)
);
Jt.Text = u7;
var c7 = (
  /** @class */
  function(e) {
    El(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = vi.ElementType.Comment, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 8;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(cw)
);
Jt.Comment = c7;
var p7 = (
  /** @class */
  function(e) {
    El(t, e);
    function t(n, r) {
      var o = e.call(this, r) || this;
      return o.name = n, o.type = vi.ElementType.Directive, o;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(cw)
);
Jt.ProcessingInstruction = p7;
var pw = (
  /** @class */
  function(e) {
    El(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.children = n, r;
    }
    return Object.defineProperty(t.prototype, "firstChild", {
      // Aliases
      /** First child of the node. */
      get: function() {
        var n;
        return (n = this.children[0]) !== null && n !== void 0 ? n : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "lastChild", {
      /** Last child of the node. */
      get: function() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "childNodes", {
      /**
       * Same as {@link children}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.children;
      },
      set: function(n) {
        this.children = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(wP)
);
Jt.NodeWithChildren = pw;
var d7 = (
  /** @class */
  function(e) {
    El(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = vi.ElementType.CDATA, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 4;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(pw)
);
Jt.CDATA = d7;
var f7 = (
  /** @class */
  function(e) {
    El(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = vi.ElementType.Root, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 9;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(pw)
);
Jt.Document = f7;
var h7 = (
  /** @class */
  function(e) {
    El(t, e);
    function t(n, r, o, i) {
      o === void 0 && (o = []), i === void 0 && (i = n === "script" ? vi.ElementType.Script : n === "style" ? vi.ElementType.Style : vi.ElementType.Tag);
      var a = e.call(this, o) || this;
      return a.name = n, a.attribs = r, a.type = i, a;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "tagName", {
      // DOM Level 1 aliases
      /**
       * Same as {@link name}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.name;
      },
      set: function(n) {
        this.name = n;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "attributes", {
      get: function() {
        var n = this;
        return Object.keys(this.attribs).map(function(r) {
          var o, i;
          return {
            name: r,
            value: n.attribs[r],
            namespace: (o = n["x-attribsNamespace"]) === null || o === void 0 ? void 0 : o[r],
            prefix: (i = n["x-attribsPrefix"]) === null || i === void 0 ? void 0 : i[r]
          };
        });
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(pw)
);
Jt.Element = h7;
function g7(e) {
  return (0, vi.isTag)(e);
}
Jt.isTag = g7;
function m7(e) {
  return e.type === vi.ElementType.CDATA;
}
Jt.isCDATA = m7;
function v7(e) {
  return e.type === vi.ElementType.Text;
}
Jt.isText = v7;
function y7(e) {
  return e.type === vi.ElementType.Comment;
}
Jt.isComment = y7;
function b7(e) {
  return e.type === vi.ElementType.Directive;
}
Jt.isDirective = b7;
function w7(e) {
  return e.type === vi.ElementType.Root;
}
Jt.isDocument = w7;
function Kpe(e) {
  return Object.prototype.hasOwnProperty.call(e, "children");
}
Jt.hasChildren = Kpe;
function CP(e, t) {
  t === void 0 && (t = !1);
  var n;
  if (v7(e))
    n = new u7(e.data);
  else if (y7(e))
    n = new c7(e.data);
  else if (g7(e)) {
    var r = t ? tC(e.children) : [], o = new h7(e.name, Jp({}, e.attribs), r);
    r.forEach(function(l) {
      return l.parent = o;
    }), e.namespace != null && (o.namespace = e.namespace), e["x-attribsNamespace"] && (o["x-attribsNamespace"] = Jp({}, e["x-attribsNamespace"])), e["x-attribsPrefix"] && (o["x-attribsPrefix"] = Jp({}, e["x-attribsPrefix"])), n = o;
  } else if (m7(e)) {
    var r = t ? tC(e.children) : [], i = new d7(r);
    r.forEach(function(u) {
      return u.parent = i;
    }), n = i;
  } else if (w7(e)) {
    var r = t ? tC(e.children) : [], a = new f7(r);
    r.forEach(function(u) {
      return u.parent = a;
    }), e["x-mode"] && (a["x-mode"] = e["x-mode"]), n = a;
  } else if (b7(e)) {
    var s = new p7(e.name, e.data);
    e["x-name"] != null && (s["x-name"] = e["x-name"], s["x-publicId"] = e["x-publicId"], s["x-systemId"] = e["x-systemId"]), n = s;
  } else
    throw new Error("Not implemented yet: ".concat(e.type));
  return n.startIndex = e.startIndex, n.endIndex = e.endIndex, e.sourceCodeLocation != null && (n.sourceCodeLocation = e.sourceCodeLocation), n;
}
Jt.cloneNode = CP;
function tC(e) {
  for (var t = e.map(function(r) {
    return CP(r, !0);
  }), n = 1; n < t.length; n++)
    t[n].prev = t[n - 1], t[n - 1].next = t[n];
  return t;
}
(function(e) {
  var t = rr && rr.__createBinding || (Object.create ? function(s, l, u, c) {
    c === void 0 && (c = u);
    var p = Object.getOwnPropertyDescriptor(l, u);
    (!p || ("get" in p ? !l.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
      return l[u];
    } }), Object.defineProperty(s, c, p);
  } : function(s, l, u, c) {
    c === void 0 && (c = u), s[c] = l[u];
  }), n = rr && rr.__exportStar || function(s, l) {
    for (var u in s) u !== "default" && !Object.prototype.hasOwnProperty.call(l, u) && t(l, s, u);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.DomHandler = void 0;
  var r = bP, o = Jt;
  n(Jt, e);
  var i = {
    withStartIndices: !1,
    withEndIndices: !1,
    xmlMode: !1
  }, a = (
    /** @class */
    function() {
      function s(l, u, c) {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null, typeof u == "function" && (c = u, u = i), typeof l == "object" && (u = l, l = void 0), this.callback = l ?? null, this.options = u ?? i, this.elementCB = c ?? null;
      }
      return s.prototype.onparserinit = function(l) {
        this.parser = l;
      }, s.prototype.onreset = function() {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null;
      }, s.prototype.onend = function() {
        this.done || (this.done = !0, this.parser = null, this.handleCallback(null));
      }, s.prototype.onerror = function(l) {
        this.handleCallback(l);
      }, s.prototype.onclosetag = function() {
        this.lastNode = null;
        var l = this.tagStack.pop();
        this.options.withEndIndices && (l.endIndex = this.parser.endIndex), this.elementCB && this.elementCB(l);
      }, s.prototype.onopentag = function(l, u) {
        var c = this.options.xmlMode ? r.ElementType.Tag : void 0, p = new o.Element(l, u, void 0, c);
        this.addNode(p), this.tagStack.push(p);
      }, s.prototype.ontext = function(l) {
        var u = this.lastNode;
        if (u && u.type === r.ElementType.Text)
          u.data += l, this.options.withEndIndices && (u.endIndex = this.parser.endIndex);
        else {
          var c = new o.Text(l);
          this.addNode(c), this.lastNode = c;
        }
      }, s.prototype.oncomment = function(l) {
        if (this.lastNode && this.lastNode.type === r.ElementType.Comment) {
          this.lastNode.data += l;
          return;
        }
        var u = new o.Comment(l);
        this.addNode(u), this.lastNode = u;
      }, s.prototype.oncommentend = function() {
        this.lastNode = null;
      }, s.prototype.oncdatastart = function() {
        var l = new o.Text(""), u = new o.CDATA([l]);
        this.addNode(u), l.parent = u, this.lastNode = l;
      }, s.prototype.oncdataend = function() {
        this.lastNode = null;
      }, s.prototype.onprocessinginstruction = function(l, u) {
        var c = new o.ProcessingInstruction(l, u);
        this.addNode(c);
      }, s.prototype.handleCallback = function(l) {
        if (typeof this.callback == "function")
          this.callback(l, this.dom);
        else if (l)
          throw l;
      }, s.prototype.addNode = function(l) {
        var u = this.tagStack[this.tagStack.length - 1], c = u.children[u.children.length - 1];
        this.options.withStartIndices && (l.startIndex = this.parser.startIndex), this.options.withEndIndices && (l.endIndex = this.parser.endIndex), u.children.push(l), c && (l.prev = c, c.next = l), l.parent = u, this.lastNode = null;
      }, s;
    }()
  );
  e.DomHandler = a, e.default = a;
})(yP);
var C7 = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CARRIAGE_RETURN_PLACEHOLDER_REGEX = e.CARRIAGE_RETURN_PLACEHOLDER = e.CARRIAGE_RETURN_REGEX = e.CARRIAGE_RETURN = e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES = void 0, e.CASE_SENSITIVE_TAG_NAMES = [
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "linearGradient",
    "radialGradient",
    "textPath"
  ], e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES.reduce(function(t, n) {
    return t[n.toLowerCase()] = n, t;
  }, {}), e.CARRIAGE_RETURN = "\r", e.CARRIAGE_RETURN_REGEX = new RegExp(e.CARRIAGE_RETURN, "g"), e.CARRIAGE_RETURN_PLACEHOLDER = "__HTML_DOM_PARSER_CARRIAGE_RETURN_PLACEHOLDER_".concat(Date.now(), "__"), e.CARRIAGE_RETURN_PLACEHOLDER_REGEX = new RegExp(e.CARRIAGE_RETURN_PLACEHOLDER, "g");
})(C7);
Object.defineProperty(Xu, "__esModule", { value: !0 });
Xu.formatAttributes = x7;
Xu.escapeSpecialCharacters = Jpe;
Xu.revertEscapedCharacters = O7;
Xu.formatDOM = E7;
var Xh = yP, Xd = C7;
function Ype(e) {
  return Xd.CASE_SENSITIVE_TAG_NAMES_MAP[e];
}
function x7(e) {
  for (var t = {}, n = 0, r = e.length; n < r; n++) {
    var o = e[n];
    t[o.name] = o.value;
  }
  return t;
}
function Xpe(e) {
  e = e.toLowerCase();
  var t = Ype(e);
  return t || e;
}
function Jpe(e) {
  return e.replace(Xd.CARRIAGE_RETURN_REGEX, Xd.CARRIAGE_RETURN_PLACEHOLDER);
}
function O7(e) {
  return e.replace(Xd.CARRIAGE_RETURN_PLACEHOLDER_REGEX, Xd.CARRIAGE_RETURN);
}
function E7(e, t, n) {
  t === void 0 && (t = null);
  for (var r = [], o, i = 0, a = e.length; i < a; i++) {
    var s = e[i];
    switch (s.nodeType) {
      case 1: {
        var l = Xpe(s.nodeName);
        o = new Xh.Element(l, x7(s.attributes)), o.children = E7(
          // template children are on content
          l === "template" ? s.content.childNodes : s.childNodes,
          o
        );
        break;
      }
      case 3:
        o = new Xh.Text(O7(s.nodeValue));
        break;
      case 8:
        o = new Xh.Comment(s.nodeValue);
        break;
      default:
        continue;
    }
    var u = r[i - 1] || null;
    u && (u.next = o), o.parent = t, o.prev = u, o.next = null, r.push(o);
  }
  return n && (o = new Xh.ProcessingInstruction(n.substring(0, n.indexOf(" ")).toLowerCase(), n), o.next = r[0] || null, o.parent = t, r.unshift(o), r[1] && (r[1].prev = r[0])), r;
}
Object.defineProperty(vP, "__esModule", { value: !0 });
vP.default = rde;
var Qpe = Xu, yA = "html", bA = "head", Jh = "body", ede = /<([a-zA-Z]+[0-9]?)/, wA = /<head[^]*>/i, CA = /<body[^]*>/i, Cv = function(e, t) {
  throw new Error("This browser does not support `document.implementation.createHTMLDocument`");
}, ak = function(e, t) {
  throw new Error("This browser does not support `DOMParser.prototype.parseFromString`");
}, xA = typeof window == "object" && window.DOMParser;
if (typeof xA == "function") {
  var tde = new xA(), nde = "text/html";
  ak = function(e, t) {
    return t && (e = "<".concat(t, ">").concat(e, "</").concat(t, ">")), tde.parseFromString(e, nde);
  }, Cv = ak;
}
if (typeof document == "object" && document.implementation) {
  var Qh = document.implementation.createHTMLDocument();
  Cv = function(e, t) {
    if (t) {
      var n = Qh.documentElement.querySelector(t);
      return n && (n.innerHTML = e), Qh;
    }
    return Qh.documentElement.innerHTML = e, Qh;
  };
}
var eg = typeof document == "object" && document.createElement("template"), lk;
eg && eg.content && (lk = function(e) {
  return eg.innerHTML = e, eg.content.childNodes;
});
function rde(e) {
  var t, n;
  e = (0, Qpe.escapeSpecialCharacters)(e);
  var r = e.match(ede), o = r && r[1] ? r[1].toLowerCase() : "";
  switch (o) {
    case yA: {
      var i = ak(e);
      if (!wA.test(e)) {
        var a = i.querySelector(bA);
        (t = a == null ? void 0 : a.parentNode) === null || t === void 0 || t.removeChild(a);
      }
      if (!CA.test(e)) {
        var a = i.querySelector(Jh);
        (n = a == null ? void 0 : a.parentNode) === null || n === void 0 || n.removeChild(a);
      }
      return i.querySelectorAll(yA);
    }
    case bA:
    case Jh: {
      var s = Cv(e).querySelectorAll(o);
      return CA.test(e) && wA.test(e) ? s[0].parentNode.childNodes : s;
    }
    default: {
      if (lk)
        return lk(e);
      var a = Cv(e, Jh).querySelector(Jh);
      return a.childNodes;
    }
  }
}
var ode = rr && rr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(mP, "__esModule", { value: !0 });
mP.default = lde;
var ide = ode(vP), sde = Xu, ade = /<(![a-zA-Z\s]+)>/;
function lde(e) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e)
    return [];
  var t = e.match(ade), n = t ? t[1] : void 0;
  return (0, sde.formatDOM)((0, ide.default)(e), null, n);
}
var dw = {}, ms = {}, fw = {}, ude = 0;
fw.SAME = ude;
var cde = 1;
fw.CAMELCASE = cde;
fw.possibleStandardNames = {
  accept: 0,
  acceptCharset: 1,
  "accept-charset": "acceptCharset",
  accessKey: 1,
  action: 0,
  allowFullScreen: 1,
  alt: 0,
  as: 0,
  async: 0,
  autoCapitalize: 1,
  autoComplete: 1,
  autoCorrect: 1,
  autoFocus: 1,
  autoPlay: 1,
  autoSave: 1,
  capture: 0,
  cellPadding: 1,
  cellSpacing: 1,
  challenge: 0,
  charSet: 1,
  checked: 0,
  children: 0,
  cite: 0,
  class: "className",
  classID: 1,
  className: 1,
  cols: 0,
  colSpan: 1,
  content: 0,
  contentEditable: 1,
  contextMenu: 1,
  controls: 0,
  controlsList: 1,
  coords: 0,
  crossOrigin: 1,
  dangerouslySetInnerHTML: 1,
  data: 0,
  dateTime: 1,
  default: 0,
  defaultChecked: 1,
  defaultValue: 1,
  defer: 0,
  dir: 0,
  disabled: 0,
  disablePictureInPicture: 1,
  disableRemotePlayback: 1,
  download: 0,
  draggable: 0,
  encType: 1,
  enterKeyHint: 1,
  for: "htmlFor",
  form: 0,
  formMethod: 1,
  formAction: 1,
  formEncType: 1,
  formNoValidate: 1,
  formTarget: 1,
  frameBorder: 1,
  headers: 0,
  height: 0,
  hidden: 0,
  high: 0,
  href: 0,
  hrefLang: 1,
  htmlFor: 1,
  httpEquiv: 1,
  "http-equiv": "httpEquiv",
  icon: 0,
  id: 0,
  innerHTML: 1,
  inputMode: 1,
  integrity: 0,
  is: 0,
  itemID: 1,
  itemProp: 1,
  itemRef: 1,
  itemScope: 1,
  itemType: 1,
  keyParams: 1,
  keyType: 1,
  kind: 0,
  label: 0,
  lang: 0,
  list: 0,
  loop: 0,
  low: 0,
  manifest: 0,
  marginWidth: 1,
  marginHeight: 1,
  max: 0,
  maxLength: 1,
  media: 0,
  mediaGroup: 1,
  method: 0,
  min: 0,
  minLength: 1,
  multiple: 0,
  muted: 0,
  name: 0,
  noModule: 1,
  nonce: 0,
  noValidate: 1,
  open: 0,
  optimum: 0,
  pattern: 0,
  placeholder: 0,
  playsInline: 1,
  poster: 0,
  preload: 0,
  profile: 0,
  radioGroup: 1,
  readOnly: 1,
  referrerPolicy: 1,
  rel: 0,
  required: 0,
  reversed: 0,
  role: 0,
  rows: 0,
  rowSpan: 1,
  sandbox: 0,
  scope: 0,
  scoped: 0,
  scrolling: 0,
  seamless: 0,
  selected: 0,
  shape: 0,
  size: 0,
  sizes: 0,
  span: 0,
  spellCheck: 1,
  src: 0,
  srcDoc: 1,
  srcLang: 1,
  srcSet: 1,
  start: 0,
  step: 0,
  style: 0,
  summary: 0,
  tabIndex: 1,
  target: 0,
  title: 0,
  type: 0,
  useMap: 1,
  value: 0,
  width: 0,
  wmode: 0,
  wrap: 0,
  about: 0,
  accentHeight: 1,
  "accent-height": "accentHeight",
  accumulate: 0,
  additive: 0,
  alignmentBaseline: 1,
  "alignment-baseline": "alignmentBaseline",
  allowReorder: 1,
  alphabetic: 0,
  amplitude: 0,
  arabicForm: 1,
  "arabic-form": "arabicForm",
  ascent: 0,
  attributeName: 1,
  attributeType: 1,
  autoReverse: 1,
  azimuth: 0,
  baseFrequency: 1,
  baselineShift: 1,
  "baseline-shift": "baselineShift",
  baseProfile: 1,
  bbox: 0,
  begin: 0,
  bias: 0,
  by: 0,
  calcMode: 1,
  capHeight: 1,
  "cap-height": "capHeight",
  clip: 0,
  clipPath: 1,
  "clip-path": "clipPath",
  clipPathUnits: 1,
  clipRule: 1,
  "clip-rule": "clipRule",
  color: 0,
  colorInterpolation: 1,
  "color-interpolation": "colorInterpolation",
  colorInterpolationFilters: 1,
  "color-interpolation-filters": "colorInterpolationFilters",
  colorProfile: 1,
  "color-profile": "colorProfile",
  colorRendering: 1,
  "color-rendering": "colorRendering",
  contentScriptType: 1,
  contentStyleType: 1,
  cursor: 0,
  cx: 0,
  cy: 0,
  d: 0,
  datatype: 0,
  decelerate: 0,
  descent: 0,
  diffuseConstant: 1,
  direction: 0,
  display: 0,
  divisor: 0,
  dominantBaseline: 1,
  "dominant-baseline": "dominantBaseline",
  dur: 0,
  dx: 0,
  dy: 0,
  edgeMode: 1,
  elevation: 0,
  enableBackground: 1,
  "enable-background": "enableBackground",
  end: 0,
  exponent: 0,
  externalResourcesRequired: 1,
  fill: 0,
  fillOpacity: 1,
  "fill-opacity": "fillOpacity",
  fillRule: 1,
  "fill-rule": "fillRule",
  filter: 0,
  filterRes: 1,
  filterUnits: 1,
  floodOpacity: 1,
  "flood-opacity": "floodOpacity",
  floodColor: 1,
  "flood-color": "floodColor",
  focusable: 0,
  fontFamily: 1,
  "font-family": "fontFamily",
  fontSize: 1,
  "font-size": "fontSize",
  fontSizeAdjust: 1,
  "font-size-adjust": "fontSizeAdjust",
  fontStretch: 1,
  "font-stretch": "fontStretch",
  fontStyle: 1,
  "font-style": "fontStyle",
  fontVariant: 1,
  "font-variant": "fontVariant",
  fontWeight: 1,
  "font-weight": "fontWeight",
  format: 0,
  from: 0,
  fx: 0,
  fy: 0,
  g1: 0,
  g2: 0,
  glyphName: 1,
  "glyph-name": "glyphName",
  glyphOrientationHorizontal: 1,
  "glyph-orientation-horizontal": "glyphOrientationHorizontal",
  glyphOrientationVertical: 1,
  "glyph-orientation-vertical": "glyphOrientationVertical",
  glyphRef: 1,
  gradientTransform: 1,
  gradientUnits: 1,
  hanging: 0,
  horizAdvX: 1,
  "horiz-adv-x": "horizAdvX",
  horizOriginX: 1,
  "horiz-origin-x": "horizOriginX",
  ideographic: 0,
  imageRendering: 1,
  "image-rendering": "imageRendering",
  in2: 0,
  in: 0,
  inlist: 0,
  intercept: 0,
  k1: 0,
  k2: 0,
  k3: 0,
  k4: 0,
  k: 0,
  kernelMatrix: 1,
  kernelUnitLength: 1,
  kerning: 0,
  keyPoints: 1,
  keySplines: 1,
  keyTimes: 1,
  lengthAdjust: 1,
  letterSpacing: 1,
  "letter-spacing": "letterSpacing",
  lightingColor: 1,
  "lighting-color": "lightingColor",
  limitingConeAngle: 1,
  local: 0,
  markerEnd: 1,
  "marker-end": "markerEnd",
  markerHeight: 1,
  markerMid: 1,
  "marker-mid": "markerMid",
  markerStart: 1,
  "marker-start": "markerStart",
  markerUnits: 1,
  markerWidth: 1,
  mask: 0,
  maskContentUnits: 1,
  maskUnits: 1,
  mathematical: 0,
  mode: 0,
  numOctaves: 1,
  offset: 0,
  opacity: 0,
  operator: 0,
  order: 0,
  orient: 0,
  orientation: 0,
  origin: 0,
  overflow: 0,
  overlinePosition: 1,
  "overline-position": "overlinePosition",
  overlineThickness: 1,
  "overline-thickness": "overlineThickness",
  paintOrder: 1,
  "paint-order": "paintOrder",
  panose1: 0,
  "panose-1": "panose1",
  pathLength: 1,
  patternContentUnits: 1,
  patternTransform: 1,
  patternUnits: 1,
  pointerEvents: 1,
  "pointer-events": "pointerEvents",
  points: 0,
  pointsAtX: 1,
  pointsAtY: 1,
  pointsAtZ: 1,
  prefix: 0,
  preserveAlpha: 1,
  preserveAspectRatio: 1,
  primitiveUnits: 1,
  property: 0,
  r: 0,
  radius: 0,
  refX: 1,
  refY: 1,
  renderingIntent: 1,
  "rendering-intent": "renderingIntent",
  repeatCount: 1,
  repeatDur: 1,
  requiredExtensions: 1,
  requiredFeatures: 1,
  resource: 0,
  restart: 0,
  result: 0,
  results: 0,
  rotate: 0,
  rx: 0,
  ry: 0,
  scale: 0,
  security: 0,
  seed: 0,
  shapeRendering: 1,
  "shape-rendering": "shapeRendering",
  slope: 0,
  spacing: 0,
  specularConstant: 1,
  specularExponent: 1,
  speed: 0,
  spreadMethod: 1,
  startOffset: 1,
  stdDeviation: 1,
  stemh: 0,
  stemv: 0,
  stitchTiles: 1,
  stopColor: 1,
  "stop-color": "stopColor",
  stopOpacity: 1,
  "stop-opacity": "stopOpacity",
  strikethroughPosition: 1,
  "strikethrough-position": "strikethroughPosition",
  strikethroughThickness: 1,
  "strikethrough-thickness": "strikethroughThickness",
  string: 0,
  stroke: 0,
  strokeDasharray: 1,
  "stroke-dasharray": "strokeDasharray",
  strokeDashoffset: 1,
  "stroke-dashoffset": "strokeDashoffset",
  strokeLinecap: 1,
  "stroke-linecap": "strokeLinecap",
  strokeLinejoin: 1,
  "stroke-linejoin": "strokeLinejoin",
  strokeMiterlimit: 1,
  "stroke-miterlimit": "strokeMiterlimit",
  strokeWidth: 1,
  "stroke-width": "strokeWidth",
  strokeOpacity: 1,
  "stroke-opacity": "strokeOpacity",
  suppressContentEditableWarning: 1,
  suppressHydrationWarning: 1,
  surfaceScale: 1,
  systemLanguage: 1,
  tableValues: 1,
  targetX: 1,
  targetY: 1,
  textAnchor: 1,
  "text-anchor": "textAnchor",
  textDecoration: 1,
  "text-decoration": "textDecoration",
  textLength: 1,
  textRendering: 1,
  "text-rendering": "textRendering",
  to: 0,
  transform: 0,
  typeof: 0,
  u1: 0,
  u2: 0,
  underlinePosition: 1,
  "underline-position": "underlinePosition",
  underlineThickness: 1,
  "underline-thickness": "underlineThickness",
  unicode: 0,
  unicodeBidi: 1,
  "unicode-bidi": "unicodeBidi",
  unicodeRange: 1,
  "unicode-range": "unicodeRange",
  unitsPerEm: 1,
  "units-per-em": "unitsPerEm",
  unselectable: 0,
  vAlphabetic: 1,
  "v-alphabetic": "vAlphabetic",
  values: 0,
  vectorEffect: 1,
  "vector-effect": "vectorEffect",
  version: 0,
  vertAdvY: 1,
  "vert-adv-y": "vertAdvY",
  vertOriginX: 1,
  "vert-origin-x": "vertOriginX",
  vertOriginY: 1,
  "vert-origin-y": "vertOriginY",
  vHanging: 1,
  "v-hanging": "vHanging",
  vIdeographic: 1,
  "v-ideographic": "vIdeographic",
  viewBox: 1,
  viewTarget: 1,
  visibility: 0,
  vMathematical: 1,
  "v-mathematical": "vMathematical",
  vocab: 0,
  widths: 0,
  wordSpacing: 1,
  "word-spacing": "wordSpacing",
  writingMode: 1,
  "writing-mode": "writingMode",
  x1: 0,
  x2: 0,
  x: 0,
  xChannelSelector: 1,
  xHeight: 1,
  "x-height": "xHeight",
  xlinkActuate: 1,
  "xlink:actuate": "xlinkActuate",
  xlinkArcrole: 1,
  "xlink:arcrole": "xlinkArcrole",
  xlinkHref: 1,
  "xlink:href": "xlinkHref",
  xlinkRole: 1,
  "xlink:role": "xlinkRole",
  xlinkShow: 1,
  "xlink:show": "xlinkShow",
  xlinkTitle: 1,
  "xlink:title": "xlinkTitle",
  xlinkType: 1,
  "xlink:type": "xlinkType",
  xmlBase: 1,
  "xml:base": "xmlBase",
  xmlLang: 1,
  "xml:lang": "xmlLang",
  xmlns: 0,
  "xml:space": "xmlSpace",
  xmlnsXlink: 1,
  "xmlns:xlink": "xmlnsXlink",
  xmlSpace: 1,
  y1: 0,
  y2: 0,
  y: 0,
  yChannelSelector: 1,
  z: 0,
  zoomAndPan: 1
};
const k7 = 0, kl = 1, hw = 2, gw = 3, xP = 4, L7 = 5, P7 = 6;
function pde(e) {
  return No.hasOwnProperty(e) ? No[e] : null;
}
function ti(e, t, n, r, o, i, a) {
  this.acceptsBooleans = t === hw || t === gw || t === xP, this.attributeName = r, this.attributeNamespace = o, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = i, this.removeEmptyString = a;
}
const No = {}, dde = [
  "children",
  "dangerouslySetInnerHTML",
  // TODO: This prevents the assignment of defaultValue to regular
  // elements (not just inputs). Now that ReactDOMInput assigns to the
  // defaultValue property -- do we need this?
  "defaultValue",
  "defaultChecked",
  "innerHTML",
  "suppressContentEditableWarning",
  "suppressHydrationWarning",
  "style"
];
dde.forEach((e) => {
  No[e] = new ti(
    e,
    k7,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"]
].forEach(([e, t]) => {
  No[e] = new ti(
    e,
    kl,
    !1,
    // mustUseProperty
    t,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["contentEditable", "draggable", "spellCheck", "value"].forEach((e) => {
  No[e] = new ti(
    e,
    hw,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha"
].forEach((e) => {
  No[e] = new ti(
    e,
    hw,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "allowFullScreen",
  "async",
  // Note: there is a special case that prevents it from being written to the DOM
  // on the client side because the browsers are inconsistent. Instead we call focus().
  "autoFocus",
  "autoPlay",
  "controls",
  "default",
  "defer",
  "disabled",
  "disablePictureInPicture",
  "disableRemotePlayback",
  "formNoValidate",
  "hidden",
  "loop",
  "noModule",
  "noValidate",
  "open",
  "playsInline",
  "readOnly",
  "required",
  "reversed",
  "scoped",
  "seamless",
  // Microdata
  "itemScope"
].forEach((e) => {
  No[e] = new ti(
    e,
    gw,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "checked",
  // Note: `option.selected` is not updated if `select.multiple` is
  // disabled with `removeAttribute`. We have special logic for handling this.
  "multiple",
  "muted",
  "selected"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  No[e] = new ti(
    e,
    gw,
    !0,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "capture",
  "download"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  No[e] = new ti(
    e,
    xP,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "cols",
  "rows",
  "size",
  "span"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  No[e] = new ti(
    e,
    P7,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["rowSpan", "start"].forEach((e) => {
  No[e] = new ti(
    e,
    L7,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const OP = /[\-\:]([a-z])/g, EP = (e) => e[1].toUpperCase();
[
  "accent-height",
  "alignment-baseline",
  "arabic-form",
  "baseline-shift",
  "cap-height",
  "clip-path",
  "clip-rule",
  "color-interpolation",
  "color-interpolation-filters",
  "color-profile",
  "color-rendering",
  "dominant-baseline",
  "enable-background",
  "fill-opacity",
  "fill-rule",
  "flood-color",
  "flood-opacity",
  "font-family",
  "font-size",
  "font-size-adjust",
  "font-stretch",
  "font-style",
  "font-variant",
  "font-weight",
  "glyph-name",
  "glyph-orientation-horizontal",
  "glyph-orientation-vertical",
  "horiz-adv-x",
  "horiz-origin-x",
  "image-rendering",
  "letter-spacing",
  "lighting-color",
  "marker-end",
  "marker-mid",
  "marker-start",
  "overline-position",
  "overline-thickness",
  "paint-order",
  "panose-1",
  "pointer-events",
  "rendering-intent",
  "shape-rendering",
  "stop-color",
  "stop-opacity",
  "strikethrough-position",
  "strikethrough-thickness",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "text-anchor",
  "text-decoration",
  "text-rendering",
  "underline-position",
  "underline-thickness",
  "unicode-bidi",
  "unicode-range",
  "units-per-em",
  "v-alphabetic",
  "v-hanging",
  "v-ideographic",
  "v-mathematical",
  "vector-effect",
  "vert-adv-y",
  "vert-origin-x",
  "vert-origin-y",
  "word-spacing",
  "writing-mode",
  "xmlns:xlink",
  "x-height"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(OP, EP);
  No[t] = new ti(
    t,
    kl,
    !1,
    // mustUseProperty
    e,
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xlink:actuate",
  "xlink:arcrole",
  "xlink:role",
  "xlink:show",
  "xlink:title",
  "xlink:type"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(OP, EP);
  No[t] = new ti(
    t,
    kl,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/1999/xlink",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xml:base",
  "xml:lang",
  "xml:space"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(OP, EP);
  No[t] = new ti(
    t,
    kl,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/XML/1998/namespace",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["tabIndex", "crossOrigin"].forEach((e) => {
  No[e] = new ti(
    e,
    kl,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const fde = "xlinkHref";
No[fde] = new ti(
  "xlinkHref",
  kl,
  !1,
  // mustUseProperty
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  // sanitizeURL
  !1
  // removeEmptyString
);
["src", "href", "action", "formAction"].forEach((e) => {
  No[e] = new ti(
    e,
    kl,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !0,
    // sanitizeURL
    !0
    // removeEmptyString
  );
});
const {
  CAMELCASE: hde,
  SAME: gde,
  possibleStandardNames: OA
} = fw, mde = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", vde = mde + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", yde = RegExp.prototype.test.bind(
  // eslint-disable-next-line no-misleading-character-class
  new RegExp("^(data|aria)-[" + vde + "]*$")
), bde = Object.keys(
  OA
).reduce((e, t) => {
  const n = OA[t];
  return n === gde ? e[t] = t : n === hde ? e[t.toLowerCase()] = t : e[t] = n, e;
}, {});
ms.BOOLEAN = gw;
ms.BOOLEANISH_STRING = hw;
ms.NUMERIC = L7;
ms.OVERLOADED_BOOLEAN = xP;
ms.POSITIVE_NUMERIC = P7;
ms.RESERVED = k7;
ms.STRING = kl;
ms.getPropertyInfo = pde;
ms.isCustomAttribute = yde;
ms.possibleStandardNames = bde;
var kP = {}, LP = {}, EA = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, wde = /\n/g, Cde = /^\s*/, xde = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, Ode = /^:\s*/, Ede = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, kde = /^[;\s]*/, Lde = /^\s+|\s+$/g, Pde = `
`, kA = "/", LA = "*", uu = "", _de = "comment", Sde = "declaration", Mde = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e) return [];
  t = t || {};
  var n = 1, r = 1;
  function o(f) {
    var m = f.match(wde);
    m && (n += m.length);
    var v = f.lastIndexOf(Pde);
    r = ~v ? f.length - v : r + f.length;
  }
  function i() {
    var f = { line: n, column: r };
    return function(m) {
      return m.position = new a(f), u(), m;
    };
  }
  function a(f) {
    this.start = f, this.end = { line: n, column: r }, this.source = t.source;
  }
  a.prototype.content = e;
  function s(f) {
    var m = new Error(
      t.source + ":" + n + ":" + r + ": " + f
    );
    if (m.reason = f, m.filename = t.source, m.line = n, m.column = r, m.source = e, !t.silent) throw m;
  }
  function l(f) {
    var m = f.exec(e);
    if (m) {
      var v = m[0];
      return o(v), e = e.slice(v.length), m;
    }
  }
  function u() {
    l(Cde);
  }
  function c(f) {
    var m;
    for (f = f || []; m = p(); )
      m !== !1 && f.push(m);
    return f;
  }
  function p() {
    var f = i();
    if (!(kA != e.charAt(0) || LA != e.charAt(1))) {
      for (var m = 2; uu != e.charAt(m) && (LA != e.charAt(m) || kA != e.charAt(m + 1)); )
        ++m;
      if (m += 2, uu === e.charAt(m - 1))
        return s("End of comment missing");
      var v = e.slice(2, m - 2);
      return r += 2, o(v), e = e.slice(m), r += 2, f({
        type: _de,
        comment: v
      });
    }
  }
  function d() {
    var f = i(), m = l(xde);
    if (m) {
      if (p(), !l(Ode)) return s("property missing ':'");
      var v = l(Ede), E = f({
        type: Sde,
        property: PA(m[0].replace(EA, uu)),
        value: v ? PA(v[0].replace(EA, uu)) : uu
      });
      return l(kde), E;
    }
  }
  function g() {
    var f = [];
    c(f);
    for (var m; m = d(); )
      m !== !1 && (f.push(m), c(f));
    return f;
  }
  return u(), g();
};
function PA(e) {
  return e ? e.replace(Lde, uu) : uu;
}
var Dde = rr && rr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(LP, "__esModule", { value: !0 });
LP.default = jde;
var Tde = Dde(Mde);
function jde(e, t) {
  var n = null;
  if (!e || typeof e != "string")
    return n;
  var r = (0, Tde.default)(e), o = typeof t == "function";
  return r.forEach(function(i) {
    if (i.type === "declaration") {
      var a = i.property, s = i.value;
      o ? t(a, s, i) : s && (n = n || {}, n[a] = s);
    }
  }), n;
}
var mw = {};
Object.defineProperty(mw, "__esModule", { value: !0 });
mw.camelCase = void 0;
var Ade = /^--[a-zA-Z0-9_-]+$/, Ide = /-([a-z])/g, Rde = /^[^-]+$/, Bde = /^-(webkit|moz|ms|o|khtml)-/, Nde = /^-(ms)-/, Fde = function(e) {
  return !e || Rde.test(e) || Ade.test(e);
}, zde = function(e, t) {
  return t.toUpperCase();
}, _A = function(e, t) {
  return "".concat(t, "-");
}, Ude = function(e, t) {
  return t === void 0 && (t = {}), Fde(e) ? e : (e = e.toLowerCase(), t.reactCompat ? e = e.replace(Nde, _A) : e = e.replace(Bde, _A), e.replace(Ide, zde));
};
mw.camelCase = Ude;
var Hde = rr && rr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
}, $de = Hde(LP), Wde = mw;
function uk(e, t) {
  var n = {};
  return !e || typeof e != "string" || (0, $de.default)(e, function(r, o) {
    r && o && (n[(0, Wde.camelCase)(r, t)] = o);
  }), n;
}
uk.default = uk;
var Vde = uk;
(function(e) {
  var t = rr && rr.__importDefault || function(c) {
    return c && c.__esModule ? c : { default: c };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.returnFirstArg = e.canTextBeChildOfNode = e.ELEMENTS_WITH_NO_TEXT_CHILDREN = e.PRESERVE_CUSTOM_ATTRIBUTES = void 0, e.isCustomComponent = i, e.setStyleProp = s;
  var n = we, r = t(Vde), o = /* @__PURE__ */ new Set([
    "annotation-xml",
    "color-profile",
    "font-face",
    "font-face-src",
    "font-face-uri",
    "font-face-format",
    "font-face-name",
    "missing-glyph"
  ]);
  function i(c, p) {
    return c.includes("-") ? !o.has(c) : !!(p && typeof p.is == "string");
  }
  var a = {
    reactCompat: !0
  };
  function s(c, p) {
    if (typeof c == "string") {
      if (!c.trim()) {
        p.style = {};
        return;
      }
      try {
        p.style = (0, r.default)(c, a);
      } catch {
        p.style = {};
      }
    }
  }
  e.PRESERVE_CUSTOM_ATTRIBUTES = Number(n.version.split(".")[0]) >= 16, e.ELEMENTS_WITH_NO_TEXT_CHILDREN = /* @__PURE__ */ new Set([
    "tr",
    "tbody",
    "thead",
    "tfoot",
    "colgroup",
    "table",
    "head",
    "html",
    "frameset"
  ]);
  var l = function(c) {
    return !e.ELEMENTS_WITH_NO_TEXT_CHILDREN.has(c.name);
  };
  e.canTextBeChildOfNode = l;
  var u = function(c) {
    return c;
  };
  e.returnFirstArg = u;
})(kP);
Object.defineProperty(dw, "__esModule", { value: !0 });
dw.default = Kde;
var Np = ms, SA = kP, Zde = ["checked", "value"], qde = ["input", "select", "textarea"], Gde = {
  reset: !0,
  submit: !0
};
function Kde(e, t) {
  e === void 0 && (e = {});
  var n = {}, r = !!(e.type && Gde[e.type]);
  for (var o in e) {
    var i = e[o];
    if ((0, Np.isCustomAttribute)(o)) {
      n[o] = i;
      continue;
    }
    var a = o.toLowerCase(), s = MA(a);
    if (s) {
      var l = (0, Np.getPropertyInfo)(s);
      switch (Zde.includes(s) && qde.includes(t) && !r && (s = MA("default" + a)), n[s] = i, l && l.type) {
        case Np.BOOLEAN:
          n[s] = !0;
          break;
        case Np.OVERLOADED_BOOLEAN:
          i === "" && (n[s] = !0);
          break;
      }
      continue;
    }
    SA.PRESERVE_CUSTOM_ATTRIBUTES && (n[o] = i);
  }
  return (0, SA.setStyleProp)(e.style, n), n;
}
function MA(e) {
  return Np.possibleStandardNames[e];
}
var PP = {}, Yde = rr && rr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(PP, "__esModule", { value: !0 });
PP.default = _7;
var nC = we, Xde = Yde(dw), Qp = kP, Jde = {
  cloneElement: nC.cloneElement,
  createElement: nC.createElement,
  isValidElement: nC.isValidElement
};
function _7(e, t) {
  t === void 0 && (t = {});
  for (var n = [], r = typeof t.replace == "function", o = t.transform || Qp.returnFirstArg, i = t.library || Jde, a = i.cloneElement, s = i.createElement, l = i.isValidElement, u = e.length, c = 0; c < u; c++) {
    var p = e[c];
    if (r) {
      var d = t.replace(p, c);
      if (l(d)) {
        u > 1 && (d = a(d, {
          key: d.key || c
        })), n.push(o(d, p, c));
        continue;
      }
    }
    if (p.type === "text") {
      var g = !p.data.trim().length;
      if (g && p.parent && !(0, Qp.canTextBeChildOfNode)(p.parent) || t.trim && g)
        continue;
      n.push(o(p.data, p, c));
      continue;
    }
    var f = p, m = {};
    Qde(f) ? ((0, Qp.setStyleProp)(f.attribs.style, f.attribs), m = f.attribs) : f.attribs && (m = (0, Xde.default)(f.attribs, f.name));
    var v = void 0;
    switch (p.type) {
      case "script":
      case "style":
        p.children[0] && (m.dangerouslySetInnerHTML = {
          __html: p.children[0].data
        });
        break;
      case "tag":
        p.name === "textarea" && p.children[0] ? m.defaultValue = p.children[0].data : p.children && p.children.length && (v = _7(p.children, t));
        break;
      default:
        continue;
    }
    u > 1 && (m.key = c), n.push(o(s(p.name, m, v), p, c));
  }
  return n.length === 1 ? n[0] : n;
}
function Qde(e) {
  return Qp.PRESERVE_CUSTOM_ATTRIBUTES && e.type === "tag" && (0, Qp.isCustomComponent)(e.name, e.attribs);
}
(function(e) {
  var t = rr && rr.__importDefault || function(l) {
    return l && l.__esModule ? l : { default: l };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.htmlToDOM = e.domToReact = e.attributesToProps = e.Text = e.ProcessingInstruction = e.Element = e.Comment = void 0, e.default = s;
  var n = t(mP);
  e.htmlToDOM = n.default;
  var r = t(dw);
  e.attributesToProps = r.default;
  var o = t(PP);
  e.domToReact = o.default;
  var i = yP;
  Object.defineProperty(e, "Comment", { enumerable: !0, get: function() {
    return i.Comment;
  } }), Object.defineProperty(e, "Element", { enumerable: !0, get: function() {
    return i.Element;
  } }), Object.defineProperty(e, "ProcessingInstruction", { enumerable: !0, get: function() {
    return i.ProcessingInstruction;
  } }), Object.defineProperty(e, "Text", { enumerable: !0, get: function() {
    return i.Text;
  } });
  var a = { lowerCaseAttributeNames: !1 };
  function s(l, u) {
    if (typeof l != "string")
      throw new TypeError("First argument must be a string");
    return l ? (0, o.default)((0, n.default)(l, (u == null ? void 0 : u.htmlparser2) || a), u) : [];
  }
})(l7);
const efe = /* @__PURE__ */ bpe(l7);
efe.default;
Ke({});
function tfe(e) {
  return e && e.replace(/[^0-9]/g, "");
}
const nfe = {
  CNPJ: "99.999.999/9999-99"
};
tfe(nfe.CNPJ).length;
to((e, t) => /* @__PURE__ */ Do.jsx("input", { ref: t, ...e }));
function S7(e) {
  return e && e.replace(/[^0-9]/g, "");
}
const M7 = {
  EIGTH: "(99) 9999-9999",
  NINE: "(99) 99999-9999"
};
function rfe(e, t) {
  let n = "", r = 0;
  for (let o = 0; o < t.length; o++)
    if (t[o] === "9")
      if (r < e.length)
        n += e[r], r++;
      else
        break;
    else if (r < e.length)
      n += t[o];
    else
      break;
  return n;
}
function ofe(e) {
  return e.length > 10 ? "NINE" : "EIGTH";
}
const ife = S7(M7.NINE).length, sfe = to((e, t) => /* @__PURE__ */ Do.jsx("input", { ref: t, ...e }));
to(
  (e, t) => {
    const { onFocus: n, onBlur: r, size: o, onChange: i, value: a, currentCountry: s, disabled: l } = e, [u, c] = k(!1);
    h(() => {
      u ? i(s.mask) : c(!0);
    }, [s]);
    const p = `phoneInputMask ${o}`;
    function d(g) {
      let f = S7(g.target.value);
      const m = ofe(f);
      f.length > ife || (f = rfe(f, M7[m]), g.target.value = f, i(f));
    }
    return s.code === "+55" ? /* @__PURE__ */ Do.jsx(
      "input",
      {
        value: a,
        onChange: d,
        className: p,
        onFocus: n,
        onBlur: r,
        disabled: l,
        ref: t
      }
    ) : /* @__PURE__ */ Do.jsx(
      cl,
      {
        value: a,
        onChange: (g) => i(g.target.value),
        className: p,
        component: sfe,
        onFocus: n,
        onBlur: r,
        disabled: l,
        mask: s.mask,
        showMask: !0,
        replacement: { _: /\d/ },
        ref: t
      }
    );
  }
);
Ke({});
var ga = {};
Object.defineProperty(ga, "__esModule", {
  value: !0
});
var afe = typeof window < "u" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform), rC = {
  alt: "altKey",
  control: "ctrlKey",
  meta: "metaKey",
  shift: "shiftKey"
}, D7 = {
  add: "+",
  break: "pause",
  cmd: "meta",
  command: "meta",
  ctl: "control",
  ctrl: "control",
  del: "delete",
  down: "arrowdown",
  esc: "escape",
  ins: "insert",
  left: "arrowleft",
  mod: afe ? "meta" : "control",
  opt: "alt",
  option: "alt",
  return: "enter",
  right: "arrowright",
  space: " ",
  spacebar: " ",
  up: "arrowup",
  win: "meta",
  windows: "meta"
}, _P = {
  backspace: 8,
  tab: 9,
  enter: 13,
  shift: 16,
  control: 17,
  alt: 18,
  pause: 19,
  capslock: 20,
  escape: 27,
  " ": 32,
  pageup: 33,
  pagedown: 34,
  end: 35,
  home: 36,
  arrowleft: 37,
  arrowup: 38,
  arrowright: 39,
  arrowdown: 40,
  insert: 45,
  delete: 46,
  meta: 91,
  numlock: 144,
  scrolllock: 145,
  ";": 186,
  "=": 187,
  ",": 188,
  "-": 189,
  ".": 190,
  "/": 191,
  "`": 192,
  "[": 219,
  "\\": 220,
  "]": 221,
  "'": 222
};
for (var tg = 1; tg < 20; tg++)
  _P["f" + tg] = 111 + tg;
function vw(e, t, n) {
  t && !("byKey" in t) && (n = t, t = null), Array.isArray(e) || (e = [e]);
  var r = e.map(function(a) {
    return T7(a, t);
  }), o = function(a) {
    return r.some(function(s) {
      return j7(s, a);
    });
  }, i = n == null ? o : o(n);
  return i;
}
function lfe(e, t) {
  return vw(e, t);
}
function ufe(e, t) {
  return vw(e, { byKey: !0 }, t);
}
function T7(e, t) {
  var n = t && t.byKey, r = {};
  e = e.replace("++", "+add");
  var o = e.split("+"), i = o.length;
  for (var a in rC)
    r[rC[a]] = !1;
  var s = !0, l = !1, u = void 0;
  try {
    for (var c = o[Symbol.iterator](), p; !(s = (p = c.next()).done); s = !0) {
      var d = p.value, g = d.endsWith("?") && d.length > 1;
      g && (d = d.slice(0, -1));
      var f = SP(d), m = rC[f];
      if (d.length > 1 && !m && !D7[d] && !_P[f])
        throw new TypeError('Unknown modifier: "' + d + '"');
      (i === 1 || !m) && (n ? r.key = f : r.which = A7(d)), m && (r[m] = g ? null : !0);
    }
  } catch (v) {
    l = !0, u = v;
  } finally {
    try {
      !s && c.return && c.return();
    } finally {
      if (l)
        throw u;
    }
  }
  return r;
}
function j7(e, t) {
  for (var n in e) {
    var r = e[n], o = void 0;
    if (r != null && (n === "key" && t.key != null ? o = t.key.toLowerCase() : n === "which" ? o = r === 91 && t.which === 93 ? 91 : t.which : o = t[n], !(o == null && r === !1) && o !== r))
      return !1;
  }
  return !0;
}
function A7(e) {
  e = SP(e);
  var t = _P[e] || e.toUpperCase().charCodeAt(0);
  return t;
}
function SP(e) {
  return e = e.toLowerCase(), e = D7[e] || e, e;
}
ga.default = vw;
var oC = ga.isHotkey = vw;
ga.isCodeHotkey = lfe;
ga.isKeyHotkey = ufe;
ga.parseHotkey = T7;
ga.compareHotkey = j7;
ga.toKeyCode = A7;
ga.toKeyName = SP;
var cfe = typeof rr == "object" && rr && rr.Object === Object && rr, pfe = cfe, dfe = pfe, ffe = typeof self == "object" && self && self.Object === Object && self, hfe = dfe || ffe || Function("return this")(), gfe = hfe, mfe = gfe, vfe = mfe.Symbol, I7 = vfe, DA = I7;
DA && DA.toStringTag;
var TA = I7;
TA && TA.toStringTag;
var jA;
(function(e) {
  e.BORDER_BOX = "border-box", e.CONTENT_BOX = "content-box", e.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(jA || (jA = {}));
var MP = function(e) {
  return Object.freeze(e);
}, yfe = /* @__PURE__ */ function() {
  function e(t, n) {
    this.inlineSize = t, this.blockSize = n, MP(this);
  }
  return e;
}(), bfe = function() {
  function e(t, n, r, o) {
    return this.x = t, this.y = n, this.width = r, this.height = o, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, MP(this);
  }
  return e.prototype.toJSON = function() {
    var t = this, n = t.x, r = t.y, o = t.top, i = t.right, a = t.bottom, s = t.left, l = t.width, u = t.height;
    return { x: n, y: r, top: o, right: i, bottom: a, left: s, width: l, height: u };
  }, e.fromRect = function(t) {
    return new e(t.x, t.y, t.width, t.height);
  }, e;
}(), AA = typeof window < "u" ? window : {};
/msie|trident/i.test(AA.navigator && AA.navigator.userAgent);
var iC = function(e, t, n) {
  return e === void 0 && (e = 0), t === void 0 && (t = 0), n === void 0 && (n = !1), new yfe((n ? t : e) || 0, (n ? e : t) || 0);
};
MP({
  devicePixelContentBoxSize: iC(),
  borderBoxSize: iC(),
  contentBoxSize: iC(),
  contentRect: new bfe(0, 0, 0, 0)
});
function Jd(e) {
  "@babel/helpers - typeof";
  return Jd = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Jd(e);
}
function wfe(e, t) {
  if (Jd(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (Jd(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function Cfe(e) {
  var t = wfe(e, "string");
  return Jd(t) === "symbol" ? t : String(t);
}
function ed(e, t, n) {
  return t = Cfe(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
var xfe = /* @__PURE__ */ Ke(null), sC, aC;
parseInt(we.version.split(".")[0], 10);
var IA = typeof navigator < "u" && /Mac OS X/.test(navigator.userAgent), lC = typeof navigator < "u" && /Android/.test(navigator.userAgent), ng = typeof navigator < "u" && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent), Ofe = typeof navigator < "u" && /Chrome/i.test(navigator.userAgent);
typeof navigator < "u" && /Safari/.test(navigator.userAgent) && /Version\/(\d+)/.test(navigator.userAgent) && (sC = navigator.userAgent.match(/Version\/(\d+)/)) !== null && sC !== void 0 && sC[1] && parseInt((aC = navigator.userAgent.match(/Version\/(\d+)/)) === null || aC === void 0 ? void 0 : aC[1], 10) < 17;
var Efe = /* @__PURE__ */ new WeakMap(), kfe = /* @__PURE__ */ new WeakMap(), Lfe = /* @__PURE__ */ new WeakMap(), Pfe = /* @__PURE__ */ new WeakMap(), _fe = /* @__PURE__ */ new WeakMap(), RA = /* @__PURE__ */ new WeakMap(), Sfe = /* @__PURE__ */ new WeakMap(), BA = /* @__PURE__ */ new WeakMap(), rg = /* @__PURE__ */ new WeakMap(), Mfe = /* @__PURE__ */ new WeakMap(), Dfe = /* @__PURE__ */ new WeakMap(), Tfe = /* @__PURE__ */ new WeakMap(), R7 = globalThis.Node, jfe = globalThis.Text, B7 = (e) => e && e.ownerDocument && e.ownerDocument.defaultView || null, Afe = (e) => xv(e) && e.nodeType === 8, Ls = (e) => xv(e) && e.nodeType === 1, xv = (e) => {
  var t = B7(e);
  return !!t && e instanceof t.Node;
}, NA = (e) => {
  var t = e && e.anchorNode && B7(e.anchorNode);
  return !!t && e instanceof t.Selection;
}, Ife = (e) => {
  var [t, n] = e;
  if (Ls(t) && t.childNodes.length) {
    var r = n === t.childNodes.length, o = r ? n - 1 : n;
    for ([t, o] = N7(t, o, r ? "backward" : "forward"), r = o < n; Ls(t) && t.childNodes.length; ) {
      var i = r ? t.childNodes.length - 1 : 0;
      t = Bfe(t, i, r ? "backward" : "forward");
    }
    n = r && t.textContent != null ? t.textContent.length : 0;
  }
  return [t, n];
}, Rfe = (e) => {
  for (var t = e && e.parentNode; t; ) {
    if (t.toString() === "[object ShadowRoot]")
      return !0;
    t = t.parentNode;
  }
  return !1;
}, N7 = (e, t, n) => {
  for (var {
    childNodes: r
  } = e, o = r[t], i = t, a = !1, s = !1; (Afe(o) || Ls(o) && o.childNodes.length === 0 || Ls(o) && o.getAttribute("contenteditable") === "false") && !(a && s); ) {
    if (i >= r.length) {
      a = !0, i = t - 1, n = "backward";
      continue;
    }
    if (i < 0) {
      s = !0, i = t + 1, n = "forward";
      continue;
    }
    o = r[i], t = i, i += n === "forward" ? 1 : -1;
  }
  return [o, t];
}, Bfe = (e, t, n) => {
  var [r] = N7(e, t, n);
  return r;
}, FA = (e) => e.getSelection != null ? e.getSelection() : document.getSelection(), F7 = (e, t, n) => {
  var {
    target: r
  } = t;
  if (Ls(r) && r.matches('[contentEditable="false"]'))
    return !1;
  var {
    document: o
  } = en.getWindow(e);
  if (o.contains(r))
    return en.hasDOMNode(e, r, {
      editable: !0
    });
  var i = n.find((a) => {
    var {
      addedNodes: s,
      removedNodes: l
    } = a;
    for (var u of s)
      if (u === r || u.contains(r))
        return !0;
    for (var c of l)
      if (c === r || c.contains(r))
        return !0;
  });
  return !i || i === t ? !1 : F7(e, i, n);
}, zA = (e, t) => !!(e.compareDocumentPosition(t) & R7.DOCUMENT_POSITION_PRECEDING), Nfe = (e, t) => !!(e.compareDocumentPosition(t) & R7.DOCUMENT_POSITION_FOLLOWING), Ffe = 0;
class zfe {
  constructor() {
    ed(this, "id", void 0), this.id = "".concat(Ffe++);
  }
}
var en = {
  androidPendingDiffs: (e) => Tfe.get(e),
  androidScheduleFlush: (e) => {
    var t;
    (t = Dfe.get(e)) === null || t === void 0 || t();
  },
  blur: (e) => {
    var t = en.toDOMNode(e, e), n = en.findDocumentOrShadowRoot(e);
    rg.set(e, !1), n.activeElement === t && t.blur();
  },
  deselect: (e) => {
    var {
      selection: t
    } = e, n = en.findDocumentOrShadowRoot(e), r = FA(n);
    r && r.rangeCount > 0 && r.removeAllRanges(), t && wv.deselect(e);
  },
  findDocumentOrShadowRoot: (e) => {
    var t = en.toDOMNode(e, e), n = t.getRootNode();
    return n instanceof Document || n instanceof ShadowRoot ? n : t.ownerDocument;
  },
  findEventRange: (e, t) => {
    "nativeEvent" in t && (t = t.nativeEvent);
    var {
      clientX: n,
      clientY: r,
      target: o
    } = t;
    if (n == null || r == null)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var i = en.toSlateNode(e, t.target), a = en.findPath(e, i);
    if (ia.isElement(i) && Yn.isVoid(e, i)) {
      var s = o.getBoundingClientRect(), l = e.isInline(i) ? n - s.left < s.left + s.width - n : r - s.top < s.top + s.height - r, u = Yn.point(e, a, {
        edge: l ? "start" : "end"
      }), c = l ? Yn.before(e, u) : Yn.after(e, u);
      if (c) {
        var p = Yn.range(e, c);
        return p;
      }
    }
    var d, {
      document: g
    } = en.getWindow(e);
    if (g.caretRangeFromPoint)
      d = g.caretRangeFromPoint(n, r);
    else {
      var f = g.caretPositionFromPoint(n, r);
      f && (d = g.createRange(), d.setStart(f.offsetNode, f.offset), d.setEnd(f.offsetNode, f.offset));
    }
    if (!d)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var m = en.toSlateRange(e, d, {
      exactMatch: !1,
      suppressThrow: !1
    });
    return m;
  },
  findKey: (e, t) => {
    var n = RA.get(t);
    return n || (n = new zfe(), RA.set(t, n)), n;
  },
  findPath: (e, t) => {
    for (var n = [], r = t; ; ) {
      var o = kfe.get(r);
      if (o == null) {
        if (Yn.isEditor(r))
          return n;
        break;
      }
      var i = Efe.get(r);
      if (i == null)
        break;
      n.unshift(i), r = o;
    }
    throw new Error("Unable to find the path for Slate node: ".concat(Ti.stringify(t)));
  },
  focus: function(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      retries: 5
    };
    if (!rg.get(e)) {
      if (t.retries <= 0)
        throw new Error("Could not set focus, editor seems stuck with pending operations");
      if (e.operations.length > 0) {
        setTimeout(() => {
          en.focus(e, {
            retries: t.retries - 1
          });
        }, 10);
        return;
      }
      var n = en.toDOMNode(e, e), r = en.findDocumentOrShadowRoot(e);
      if (r.activeElement !== n) {
        if (e.selection && r instanceof Document) {
          var o = FA(r), i = en.toDOMRange(e, e.selection);
          o == null || o.removeAllRanges(), o == null || o.addRange(i);
        }
        e.selection || wv.select(e, Yn.start(e, [])), rg.set(e, !0), n.focus({
          preventScroll: !0
        });
      }
    }
  },
  getWindow: (e) => {
    var t = Lfe.get(e);
    if (!t)
      throw new Error("Unable to find a host window element for this editor");
    return t;
  },
  hasDOMNode: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      editable: r = !1
    } = n, o = en.toDOMNode(e, e), i;
    try {
      i = Ls(t) ? t : t.parentElement;
    } catch (a) {
      if (a instanceof Error && !a.message.includes('Permission denied to access property "nodeType"'))
        throw a;
    }
    return i ? i.closest("[data-slate-editor]") === o && (!r || i.isContentEditable ? !0 : typeof i.isContentEditable == "boolean" && // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined
    // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable="false"(readOnly)
    i.closest('[contenteditable="false"]') === o || !!i.getAttribute("data-slate-zero-width")) : !1;
  },
  hasEditableTarget: (e, t) => xv(t) && en.hasDOMNode(e, t, {
    editable: !0
  }),
  hasRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t;
    return Yn.hasPath(e, n.path) && Yn.hasPath(e, r.path);
  },
  hasSelectableTarget: (e, t) => en.hasEditableTarget(e, t) || en.isTargetInsideNonReadonlyVoid(e, t),
  hasTarget: (e, t) => xv(t) && en.hasDOMNode(e, t),
  insertData: (e, t) => {
    e.insertData(t);
  },
  insertFragmentData: (e, t) => e.insertFragmentData(t),
  insertTextData: (e, t) => e.insertTextData(t),
  isComposing: (e) => !!Mfe.get(e),
  isFocused: (e) => !!rg.get(e),
  isReadOnly: (e) => !!BA.get(e),
  isTargetInsideNonReadonlyVoid: (e, t) => {
    if (BA.get(e)) return !1;
    var n = en.hasTarget(e, t) && en.toSlateNode(e, t);
    return ia.isElement(n) && Yn.isVoid(e, n);
  },
  setFragmentData: (e, t, n) => e.setFragmentData(t, n),
  toDOMNode: (e, t) => {
    var n = Sfe.get(e), r = Yn.isEditor(t) ? Pfe.get(e) : n == null ? void 0 : n.get(en.findKey(e, t));
    if (!r)
      throw new Error("Cannot resolve a DOM node from Slate node: ".concat(Ti.stringify(t)));
    return r;
  },
  toDOMPoint: (e, t) => {
    var [n] = Yn.node(e, t.path), r = en.toDOMNode(e, n), o;
    Yn.void(e, {
      at: t
    }) && (t = {
      path: t.path,
      offset: 0
    });
    for (var i = "[data-slate-string], [data-slate-zero-width]", a = Array.from(r.querySelectorAll(i)), s = 0, l = 0; l < a.length; l++) {
      var u = a[l], c = u.childNodes[0];
      if (!(c == null || c.textContent == null)) {
        var {
          length: p
        } = c.textContent, d = u.getAttribute("data-slate-length"), g = d == null ? p : parseInt(d, 10), f = s + g, m = a[l + 1];
        if (t.offset === f && m !== null && m !== void 0 && m.hasAttribute("data-slate-mark-placeholder")) {
          var v, E = m.childNodes[0];
          o = [
            // COMPAT: If we don't explicity set the dom point to be on the actual
            // dom text element, chrome will put the selection behind the actual dom
            // text element, causing domRange.getBoundingClientRect() calls on a collapsed
            // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)
            // which will cause issues when scrolling to it.
            E instanceof jfe ? E : m,
            (v = m.textContent) !== null && v !== void 0 && v.startsWith("\uFEFF") ? 1 : 0
          ];
          break;
        }
        if (t.offset <= f) {
          var w = Math.min(p, Math.max(0, t.offset - s));
          o = [c, w];
          break;
        }
        s = f;
      }
    }
    if (!o)
      throw new Error("Cannot resolve a DOM point from Slate point: ".concat(Ti.stringify(t)));
    return o;
  },
  toDOMRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t, o = Wt.isBackward(t), i = en.toDOMPoint(e, n), a = Wt.isCollapsed(t) ? i : en.toDOMPoint(e, r), s = en.getWindow(e), l = s.document.createRange(), [u, c] = o ? a : i, [p, d] = o ? i : a, g = Ls(u) ? u : u.parentElement, f = !!g.getAttribute("data-slate-zero-width"), m = Ls(p) ? p : p.parentElement, v = !!m.getAttribute("data-slate-zero-width");
    return l.setStart(u, f ? 1 : c), l.setEnd(p, v ? 1 : d), l;
  },
  toSlateNode: (e, t) => {
    var n = Ls(t) ? t : t.parentElement;
    n && !n.hasAttribute("data-slate-node") && (n = n.closest("[data-slate-node]"));
    var r = n ? _fe.get(n) : null;
    if (!r)
      throw new Error("Cannot resolve a Slate node from DOM node: ".concat(n));
    return r;
  },
  toSlatePoint: (e, t, n) => {
    var {
      exactMatch: r,
      suppressThrow: o,
      searchDirection: i = "backward"
    } = n, [a, s] = r ? t : Ife(t), l = a.parentNode, u = null, c = 0;
    if (l) {
      var p, d, g = en.toDOMNode(e, e), f = l.closest('[data-slate-void="true"]'), m = f && g.contains(f) ? f : null, v = l.closest('[contenteditable="false"]'), E = v && g.contains(v) ? v : null, w = l.closest("[data-slate-leaf]"), M = null;
      if (w) {
        if (u = w.closest('[data-slate-node="text"]'), u) {
          var O = en.getWindow(e), y = O.document.createRange();
          y.setStart(u, 0), y.setEnd(a, s);
          var C = y.cloneContents(), _ = [...Array.prototype.slice.call(C.querySelectorAll("[data-slate-zero-width]")), ...Array.prototype.slice.call(C.querySelectorAll("[contenteditable=false]"))];
          _.forEach((S) => {
            if (lC && !r && S.hasAttribute("data-slate-zero-width") && S.textContent.length > 0 && S.textContext !== "\uFEFF") {
              S.textContent.startsWith("\uFEFF") && (S.textContent = S.textContent.slice(1));
              return;
            }
            S.parentNode.removeChild(S);
          }), c = C.textContent.length, M = u;
        }
      } else if (m) {
        for (var F = m.querySelectorAll("[data-slate-leaf]"), L = 0; L < F.length; L++) {
          var N = F[L];
          if (en.hasDOMNode(e, N)) {
            w = N;
            break;
          }
        }
        w ? (u = w.closest('[data-slate-node="text"]'), M = w, c = M.textContent.length, M.querySelectorAll("[data-slate-zero-width]").forEach((S) => {
          c -= S.textContent.length;
        })) : c = 1;
      } else if (E) {
        var R = (S) => S ? S.querySelectorAll(
          // Exclude leaf nodes in nested editors
          "[data-slate-leaf]:not(:scope [data-slate-editor] [data-slate-leaf])"
        ) : [], W = E.closest('[data-slate-node="element"]');
        if (i === "forward") {
          var V, z = [...R(W), ...R(W == null ? void 0 : W.nextElementSibling)];
          w = (V = z.find((S) => Nfe(E, S))) !== null && V !== void 0 ? V : null;
        } else {
          var Z, K = [...R(W == null ? void 0 : W.previousElementSibling), ...R(W)];
          w = (Z = K.findLast((S) => zA(E, S))) !== null && Z !== void 0 ? Z : null;
        }
        w && (u = w.closest('[data-slate-node="text"]'), M = w, i === "forward" ? c = 0 : (c = M.textContent.length, M.querySelectorAll("[data-slate-zero-width]").forEach((S) => {
          c -= S.textContent.length;
        })));
      }
      M && c === M.textContent.length && // COMPAT: Android IMEs might remove the zero width space while composing,
      // and we don't add it for line-breaks.
      lC && M.getAttribute("data-slate-zero-width") === "z" && (p = M.textContent) !== null && p !== void 0 && p.startsWith("\uFEFF") && // COMPAT: If the parent node is a Slate zero-width space, editor is
      // because the text node should have no characters. However, during IME
      // composition the ASCII characters will be prepended to the zero-width
      // space, so subtract 1 from the offset to account for the zero-width
      // space character.
      (l.hasAttribute("data-slate-zero-width") || // COMPAT: In Firefox, `range.cloneContents()` returns an extra trailing '\n'
      // when the document ends with a new-line character. This results in the offset
      // length being off by one, so we need to subtract one to account for this.
      ng && (d = M.textContent) !== null && d !== void 0 && d.endsWith(`

`)) && c--;
    }
    if (lC && !u && !r) {
      var X = l.hasAttribute("data-slate-node") ? l : l.closest("[data-slate-node]");
      if (X && en.hasDOMNode(e, X, {
        editable: !0
      })) {
        var te = en.toSlateNode(e, X), {
          path: J,
          offset: P
        } = Yn.start(e, en.findPath(e, te));
        return X.querySelector("[data-slate-leaf]") || (P = s), {
          path: J,
          offset: P
        };
      }
    }
    if (!u) {
      if (o)
        return null;
      throw new Error("Cannot resolve a Slate point from DOM point: ".concat(t));
    }
    var D = en.toSlateNode(e, u), H = en.findPath(e, D);
    return {
      path: H,
      offset: c
    };
  },
  toSlateRange: (e, t, n) => {
    var r, {
      exactMatch: o,
      suppressThrow: i
    } = n, a = NA(t) ? t.anchorNode : t.startContainer, s, l, u, c, p;
    if (a)
      if (NA(t)) {
        if (ng && t.rangeCount > 1) {
          u = t.focusNode;
          var d = t.getRangeAt(0), g = t.getRangeAt(t.rangeCount - 1);
          if (u instanceof HTMLTableRowElement && d.startContainer instanceof HTMLTableRowElement && g.startContainer instanceof HTMLTableRowElement) {
            let C = function(_) {
              return _.childElementCount > 0 ? C(_.children[0]) : _;
            };
            var f = d.startContainer, m = g.startContainer, v = C(f.children[d.startOffset]), E = C(m.children[g.startOffset]);
            c = 0, E.childNodes.length > 0 ? s = E.childNodes[0] : s = E, v.childNodes.length > 0 ? u = v.childNodes[0] : u = v, E instanceof HTMLElement ? l = E.innerHTML.length : l = 0;
          } else
            d.startContainer === u ? (s = g.endContainer, l = g.endOffset, c = d.startOffset) : (s = d.startContainer, l = d.endOffset, c = g.startOffset);
        } else
          s = t.anchorNode, l = t.anchorOffset, u = t.focusNode, c = t.focusOffset;
        Ofe && Rfe(s) || ng ? p = t.anchorNode === t.focusNode && t.anchorOffset === t.focusOffset : p = t.isCollapsed;
      } else
        s = t.startContainer, l = t.startOffset, u = t.endContainer, c = t.endOffset, p = t.collapsed;
    if (s == null || u == null || l == null || c == null)
      throw new Error("Cannot resolve a Slate range from DOM range: ".concat(t));
    ng && (r = u.textContent) !== null && r !== void 0 && r.endsWith(`

`) && c === u.textContent.length && c--;
    var w = en.toSlatePoint(e, [s, l], {
      exactMatch: o,
      suppressThrow: i
    });
    if (!w)
      return null;
    var M = zA(s, u) || s === u && c < l, O = p ? w : en.toSlatePoint(e, [u, c], {
      exactMatch: o,
      suppressThrow: i,
      searchDirection: M ? "forward" : "backward"
    });
    if (!O)
      return null;
    var y = {
      anchor: w,
      focus: O
    };
    return Wt.isExpanded(y) && Wt.isForward(y) && Ls(u) && Yn.void(e, {
      at: y.focus,
      mode: "highest"
    }) && (y = Yn.unhangRange(e, y, {
      voids: !0
    })), y;
  }
}, Ufe = {
  bold: "mod+b",
  compose: ["down", "left", "right", "up", "backspace", "enter"],
  moveBackward: "left",
  moveForward: "right",
  moveWordBackward: "ctrl+left",
  moveWordForward: "ctrl+right",
  deleteBackward: "shift?+backspace",
  deleteForward: "shift?+delete",
  extendBackward: "shift+left",
  extendForward: "shift+right",
  italic: "mod+i",
  insertSoftBreak: "shift+enter",
  splitBlock: "enter",
  undo: "mod+z"
}, Hfe = {
  moveLineBackward: "opt+up",
  moveLineForward: "opt+down",
  moveWordBackward: "opt+left",
  moveWordForward: "opt+right",
  deleteBackward: ["ctrl+backspace", "ctrl+h"],
  deleteForward: ["ctrl+delete", "ctrl+d"],
  deleteLineBackward: "cmd+shift?+backspace",
  deleteLineForward: ["cmd+shift?+delete", "ctrl+k"],
  deleteWordBackward: "opt+shift?+backspace",
  deleteWordForward: "opt+shift?+delete",
  extendLineBackward: "opt+shift+up",
  extendLineForward: "opt+shift+down",
  redo: "cmd+shift+z",
  transposeCharacter: "ctrl+t"
}, $fe = {
  deleteWordBackward: "ctrl+shift?+backspace",
  deleteWordForward: "ctrl+shift?+delete",
  redo: ["ctrl+y", "ctrl+shift+z"]
}, Lr = (e) => {
  var t = Ufe[e], n = Hfe[e], r = $fe[e], o = t && oC(t), i = n && oC(n), a = r && oC(r);
  return (s) => !!(o && o(s) || IA && i && i(s) || !IA && a && a(s));
};
Lr("bold"), Lr("compose"), Lr("moveBackward"), Lr("moveForward"), Lr("deleteBackward"), Lr("deleteForward"), Lr("deleteLineBackward"), Lr("deleteLineForward"), Lr("deleteWordBackward"), Lr("deleteWordForward"), Lr("extendBackward"), Lr("extendForward"), Lr("extendLineBackward"), Lr("extendLineForward"), Lr("italic"), Lr("moveLineBackward"), Lr("moveLineForward"), Lr("moveWordBackward"), Lr("moveWordForward"), Lr("redo"), Lr("insertSoftBreak"), Lr("splitBlock"), Lr("transposeCharacter"), Lr("undo");
var Wfe = (e, t) => {
  var n = [], r = () => {
    n = [];
  }, o = (a) => {
    if (t.current) {
      var s = a.filter((l) => F7(e, l, a));
      n.push(...s);
    }
  };
  function i() {
    n.length > 0 && (n.reverse().forEach((a) => {
      a.type !== "characterData" && (a.removedNodes.forEach((s) => {
        a.target.insertBefore(s, a.nextSibling);
      }), a.addedNodes.forEach((s) => {
        a.target.removeChild(s);
      }));
    }), r());
  }
  return {
    registerMutations: o,
    restoreDOM: i,
    clear: r
  };
}, Vfe = {
  subtree: !0,
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0
};
class Zfe extends Wu {
  constructor() {
    super(...arguments), ed(this, "context", null), ed(this, "manager", null), ed(this, "mutationObserver", null);
  }
  observe() {
    var t, {
      node: n
    } = this.props;
    if (!n.current)
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    (t = this.mutationObserver) === null || t === void 0 || t.observe(n.current, Vfe);
  }
  componentDidMount() {
    var {
      receivedUserInput: t
    } = this.props, n = this.context;
    this.manager = Wfe(n, t), this.mutationObserver = new MutationObserver(this.manager.registerMutations), this.observe();
  }
  getSnapshotBeforeUpdate() {
    var t, n, r, o = (t = this.mutationObserver) === null || t === void 0 ? void 0 : t.takeRecords();
    if (o != null && o.length) {
      var i;
      (i = this.manager) === null || i === void 0 || i.registerMutations(o);
    }
    return (n = this.mutationObserver) === null || n === void 0 || n.disconnect(), (r = this.manager) === null || r === void 0 || r.restoreDOM(), null;
  }
  componentDidUpdate() {
    var t;
    (t = this.manager) === null || t === void 0 || t.clear(), this.observe();
  }
  componentWillUnmount() {
    var t;
    (t = this.mutationObserver) === null || t === void 0 || t.disconnect();
  }
  render() {
    return this.props.children;
  }
}
ed(Zfe, "contextType", xfe);
Ke({});
Ke({});
Ke({});
var lo = {}, DP = {}, vf = {}, yf = {}, z7 = "Expected a function", UA = NaN, qfe = "[object Symbol]", Gfe = /^\s+|\s+$/g, Kfe = /^[-+]0x[0-9a-f]+$/i, Yfe = /^0b[01]+$/i, Xfe = /^0o[0-7]+$/i, Jfe = parseInt, Qfe = typeof rr == "object" && rr && rr.Object === Object && rr, ehe = typeof self == "object" && self && self.Object === Object && self, the = Qfe || ehe || Function("return this")(), nhe = Object.prototype, rhe = nhe.toString, ohe = Math.max, ihe = Math.min, uC = function() {
  return the.Date.now();
};
function she(e, t, n) {
  var r, o, i, a, s, l, u = 0, c = !1, p = !1, d = !0;
  if (typeof e != "function")
    throw new TypeError(z7);
  t = HA(t) || 0, Ov(n) && (c = !!n.leading, p = "maxWait" in n, i = p ? ohe(HA(n.maxWait) || 0, t) : i, d = "trailing" in n ? !!n.trailing : d);
  function g(C) {
    var _ = r, F = o;
    return r = o = void 0, u = C, a = e.apply(F, _), a;
  }
  function f(C) {
    return u = C, s = setTimeout(E, t), c ? g(C) : a;
  }
  function m(C) {
    var _ = C - l, F = C - u, L = t - _;
    return p ? ihe(L, i - F) : L;
  }
  function v(C) {
    var _ = C - l, F = C - u;
    return l === void 0 || _ >= t || _ < 0 || p && F >= i;
  }
  function E() {
    var C = uC();
    if (v(C))
      return w(C);
    s = setTimeout(E, m(C));
  }
  function w(C) {
    return s = void 0, d && r ? g(C) : (r = o = void 0, a);
  }
  function M() {
    s !== void 0 && clearTimeout(s), u = 0, r = l = o = s = void 0;
  }
  function O() {
    return s === void 0 ? a : w(uC());
  }
  function y() {
    var C = uC(), _ = v(C);
    if (r = arguments, o = this, l = C, _) {
      if (s === void 0)
        return f(l);
      if (p)
        return s = setTimeout(E, t), g(l);
    }
    return s === void 0 && (s = setTimeout(E, t)), a;
  }
  return y.cancel = M, y.flush = O, y;
}
function ahe(e, t, n) {
  var r = !0, o = !0;
  if (typeof e != "function")
    throw new TypeError(z7);
  return Ov(n) && (r = "leading" in n ? !!n.leading : r, o = "trailing" in n ? !!n.trailing : o), she(e, t, {
    leading: r,
    maxWait: t,
    trailing: o
  });
}
function Ov(e) {
  var t = typeof e;
  return !!e && (t == "object" || t == "function");
}
function lhe(e) {
  return !!e && typeof e == "object";
}
function uhe(e) {
  return typeof e == "symbol" || lhe(e) && rhe.call(e) == qfe;
}
function HA(e) {
  if (typeof e == "number")
    return e;
  if (uhe(e))
    return UA;
  if (Ov(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = Ov(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = e.replace(Gfe, "");
  var n = Yfe.test(e);
  return n || Xfe.test(e) ? Jfe(e.slice(2), n ? 2 : 8) : Kfe.test(e) ? UA : +e;
}
var che = ahe, bf = {};
Object.defineProperty(bf, "__esModule", {
  value: !0
});
bf.addPassiveEventListener = function(e, t, n) {
  var r = n.name;
  r || (r = t, console.warn("Listener must be a named function.")), Pm.has(t) || Pm.set(t, /* @__PURE__ */ new Set());
  var o = Pm.get(t);
  if (!o.has(r)) {
    var i = function() {
      var a = !1;
      try {
        var s = Object.defineProperty({}, "passive", {
          get: function() {
            a = !0;
          }
        });
        window.addEventListener("test", null, s);
      } catch {
      }
      return a;
    }();
    e.addEventListener(t, n, i ? { passive: !0 } : !1), o.add(r);
  }
};
bf.removePassiveEventListener = function(e, t, n) {
  e.removeEventListener(t, n), Pm.get(t).delete(n.name || t);
};
var Pm = /* @__PURE__ */ new Map();
Object.defineProperty(yf, "__esModule", {
  value: !0
});
var phe = che, dhe = fhe(phe), $A = bf;
function fhe(e) {
  return e && e.__esModule ? e : { default: e };
}
var hhe = function(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 66;
  return (0, dhe.default)(e, t);
}, Ur = {
  spyCallbacks: [],
  spySetState: [],
  scrollSpyContainers: [],
  mount: function(e, t) {
    if (e) {
      var n = hhe(function(r) {
        Ur.scrollHandler(e);
      }, t);
      return Ur.scrollSpyContainers.push(e), (0, $A.addPassiveEventListener)(e, "scroll", n), function() {
        (0, $A.removePassiveEventListener)(e, "scroll", n), Ur.scrollSpyContainers.splice(Ur.scrollSpyContainers.indexOf(e), 1);
      };
    }
    return function() {
    };
  },
  isMounted: function(e) {
    return Ur.scrollSpyContainers.indexOf(e) !== -1;
  },
  currentPositionX: function(e) {
    if (e === document) {
      var t = window.scrollY !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.scrollX : n ? document.documentElement.scrollLeft : document.body.scrollLeft;
    } else
      return e.scrollLeft;
  },
  currentPositionY: function(e) {
    if (e === document) {
      var t = window.scrollX !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.scrollY : n ? document.documentElement.scrollTop : document.body.scrollTop;
    } else
      return e.scrollTop;
  },
  scrollHandler: function(e) {
    var t = Ur.scrollSpyContainers[Ur.scrollSpyContainers.indexOf(e)].spyCallbacks || [];
    t.forEach(function(n) {
      return n(Ur.currentPositionX(e), Ur.currentPositionY(e));
    });
  },
  addStateHandler: function(e) {
    Ur.spySetState.push(e);
  },
  addSpyHandler: function(e, t) {
    var n = Ur.scrollSpyContainers[Ur.scrollSpyContainers.indexOf(t)];
    n.spyCallbacks || (n.spyCallbacks = []), n.spyCallbacks.push(e);
  },
  updateStates: function() {
    Ur.spySetState.forEach(function(e) {
      return e();
    });
  },
  unmount: function(e, t) {
    Ur.scrollSpyContainers.forEach(function(n) {
      return n.spyCallbacks && n.spyCallbacks.length && n.spyCallbacks.indexOf(t) > -1 && n.spyCallbacks.splice(n.spyCallbacks.indexOf(t), 1);
    }), Ur.spySetState && Ur.spySetState.length && Ur.spySetState.indexOf(e) > -1 && Ur.spySetState.splice(Ur.spySetState.indexOf(e), 1), document.removeEventListener("scroll", Ur.scrollHandler);
  },
  update: function() {
    return Ur.scrollSpyContainers.forEach(function(e) {
      return Ur.scrollHandler(e);
    });
  }
};
yf.default = Ur;
var _c = {}, wf = {};
Object.defineProperty(wf, "__esModule", {
  value: !0
});
var ghe = function(e, t) {
  var n = e.indexOf("#") === 0 ? e.substring(1) : e, r = n ? "#" + n : "", o = window && window.location, i = r ? o.pathname + o.search + r : o.pathname + o.search;
  t ? history.pushState(history.state, "", i) : history.replaceState(history.state, "", i);
}, mhe = function() {
  return window.location.hash.replace(/^#/, "");
}, vhe = function(e) {
  return function(t) {
    return e.contains ? e != t && e.contains(t) : !!(e.compareDocumentPosition(t) & 16);
  };
}, yhe = function(e) {
  return getComputedStyle(e).position !== "static";
}, cC = function(e, t) {
  for (var n = e.offsetTop, r = e.offsetParent; r && !t(r); )
    n += r.offsetTop, r = r.offsetParent;
  return { offsetTop: n, offsetParent: r };
}, bhe = function(e, t, n) {
  if (n)
    return e === document ? t.getBoundingClientRect().left + (window.scrollX || window.pageXOffset) : getComputedStyle(e).position !== "static" ? t.offsetLeft : t.offsetLeft - e.offsetLeft;
  if (e === document)
    return t.getBoundingClientRect().top + (window.scrollY || window.pageYOffset);
  if (yhe(e)) {
    if (t.offsetParent !== e) {
      var r = function(l) {
        return l === e || l === document;
      }, o = cC(t, r), i = o.offsetTop, a = o.offsetParent;
      if (a !== e)
        throw new Error("Seems containerElement is not an ancestor of the Element");
      return i;
    }
    return t.offsetTop;
  }
  if (t.offsetParent === e.offsetParent)
    return t.offsetTop - e.offsetTop;
  var s = function(l) {
    return l === document;
  };
  return cC(t, s).offsetTop - cC(e, s).offsetTop;
};
wf.default = {
  updateHash: ghe,
  getHash: mhe,
  filterElementInContainer: vhe,
  scrollOffset: bhe
};
var yw = {}, TP = {};
Object.defineProperty(TP, "__esModule", {
  value: !0
});
TP.default = {
  /*
   * https://github.com/oblador/angular-scroll (duScrollDefaultEasing)
   */
  defaultEasing: function(e) {
    return e < 0.5 ? Math.pow(e * 2, 2) / 2 : 1 - Math.pow((1 - e) * 2, 2) / 2;
  },
  /*
   * https://gist.github.com/gre/1650294
   */
  // no easing, no acceleration
  linear: function(e) {
    return e;
  },
  // accelerating from zero velocity
  easeInQuad: function(e) {
    return e * e;
  },
  // decelerating to zero velocity
  easeOutQuad: function(e) {
    return e * (2 - e);
  },
  // acceleration until halfway, then deceleration
  easeInOutQuad: function(e) {
    return e < 0.5 ? 2 * e * e : -1 + (4 - 2 * e) * e;
  },
  // accelerating from zero velocity 
  easeInCubic: function(e) {
    return e * e * e;
  },
  // decelerating to zero velocity 
  easeOutCubic: function(e) {
    return --e * e * e + 1;
  },
  // acceleration until halfway, then deceleration 
  easeInOutCubic: function(e) {
    return e < 0.5 ? 4 * e * e * e : (e - 1) * (2 * e - 2) * (2 * e - 2) + 1;
  },
  // accelerating from zero velocity 
  easeInQuart: function(e) {
    return e * e * e * e;
  },
  // decelerating to zero velocity 
  easeOutQuart: function(e) {
    return 1 - --e * e * e * e;
  },
  // acceleration until halfway, then deceleration
  easeInOutQuart: function(e) {
    return e < 0.5 ? 8 * e * e * e * e : 1 - 8 * --e * e * e * e;
  },
  // accelerating from zero velocity
  easeInQuint: function(e) {
    return e * e * e * e * e;
  },
  // decelerating to zero velocity
  easeOutQuint: function(e) {
    return 1 + --e * e * e * e * e;
  },
  // acceleration until halfway, then deceleration 
  easeInOutQuint: function(e) {
    return e < 0.5 ? 16 * e * e * e * e * e : 1 + 16 * --e * e * e * e * e;
  }
};
var jP = {};
Object.defineProperty(jP, "__esModule", {
  value: !0
});
var whe = bf, Che = ["mousedown", "wheel", "touchmove", "keydown"];
jP.default = {
  subscribe: function(e) {
    return typeof document < "u" && Che.forEach(function(t) {
      return (0, whe.addPassiveEventListener)(document, t, e);
    });
  }
};
var Cf = {};
Object.defineProperty(Cf, "__esModule", {
  value: !0
});
var ck = {
  registered: {},
  scrollEvent: {
    register: function(e, t) {
      ck.registered[e] = t;
    },
    remove: function(e) {
      ck.registered[e] = null;
    }
  }
};
Cf.default = ck;
Object.defineProperty(yw, "__esModule", {
  value: !0
});
var xhe = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, Ohe = wf;
bw(Ohe);
var Ehe = TP, WA = bw(Ehe), khe = jP, Lhe = bw(khe), Phe = Cf, bs = bw(Phe);
function bw(e) {
  return e && e.__esModule ? e : { default: e };
}
var U7 = function(e) {
  return WA.default[e.smooth] || WA.default.defaultEasing;
}, _he = function(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}, She = function() {
  if (typeof window < "u")
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame;
}, pk = function() {
  return She() || function(e, t, n) {
    window.setTimeout(e, n || 1e3 / 60, (/* @__PURE__ */ new Date()).getTime());
  };
}(), H7 = function() {
  return {
    currentPosition: 0,
    startPosition: 0,
    targetPosition: 0,
    progress: 0,
    duration: 0,
    cancel: !1,
    target: null,
    containerElement: null,
    to: null,
    start: null,
    delta: null,
    percent: null,
    delayTimeout: null
  };
}, $7 = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollLeft;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageXOffset : r ? document.documentElement.scrollLeft : document.body.scrollLeft;
}, W7 = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollTop;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageYOffset : r ? document.documentElement.scrollTop : document.body.scrollTop;
}, Mhe = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollWidth - t.offsetWidth;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollWidth, n.offsetWidth, r.clientWidth, r.scrollWidth, r.offsetWidth);
}, Dhe = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollHeight - t.offsetHeight;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollHeight, n.offsetHeight, r.clientHeight, r.scrollHeight, r.offsetHeight);
}, The = function e(t, n, r) {
  var o = n.data;
  if (!n.ignoreCancelEvents && o.cancel) {
    bs.default.registered.end && bs.default.registered.end(o.to, o.target, o.currentPositionY);
    return;
  }
  if (o.delta = Math.round(o.targetPosition - o.startPosition), o.start === null && (o.start = r), o.progress = r - o.start, o.percent = o.progress >= o.duration ? 1 : t(o.progress / o.duration), o.currentPosition = o.startPosition + Math.ceil(o.delta * o.percent), o.containerElement && o.containerElement !== document && o.containerElement !== document.body ? n.horizontal ? o.containerElement.scrollLeft = o.currentPosition : o.containerElement.scrollTop = o.currentPosition : n.horizontal ? window.scrollTo(o.currentPosition, 0) : window.scrollTo(0, o.currentPosition), o.percent < 1) {
    var i = e.bind(null, t, n);
    pk.call(window, i);
    return;
  }
  bs.default.registered.end && bs.default.registered.end(o.to, o.target, o.currentPosition);
}, AP = function(e) {
  e.data.containerElement = e ? e.containerId ? document.getElementById(e.containerId) : e.container && e.container.nodeType ? e.container : document : null;
}, xf = function(e, t, n, r) {
  t.data = t.data || H7(), window.clearTimeout(t.data.delayTimeout);
  var o = function() {
    t.data.cancel = !0;
  };
  if (Lhe.default.subscribe(o), AP(t), t.data.start = null, t.data.cancel = !1, t.data.startPosition = t.horizontal ? $7(t) : W7(t), t.data.targetPosition = t.absolute ? e : e + t.data.startPosition, t.data.startPosition === t.data.targetPosition) {
    bs.default.registered.end && bs.default.registered.end(t.data.to, t.data.target, t.data.currentPosition);
    return;
  }
  t.data.delta = Math.round(t.data.targetPosition - t.data.startPosition), t.data.duration = _he(t.duration)(t.data.delta), t.data.duration = isNaN(parseFloat(t.data.duration)) ? 1e3 : parseFloat(t.data.duration), t.data.to = n, t.data.target = r;
  var i = U7(t), a = The.bind(null, i, t);
  if (t && t.delay > 0) {
    t.data.delayTimeout = window.setTimeout(function() {
      bs.default.registered.begin && bs.default.registered.begin(t.data.to, t.data.target), pk.call(window, a);
    }, t.delay);
    return;
  }
  bs.default.registered.begin && bs.default.registered.begin(t.data.to, t.data.target), pk.call(window, a);
}, ww = function(e) {
  return e = xhe({}, e), e.data = e.data || H7(), e.absolute = !0, e;
}, jhe = function(e) {
  xf(0, ww(e));
}, Ahe = function(e, t) {
  xf(e, ww(t));
}, Ihe = function(e) {
  e = ww(e), AP(e), xf(e.horizontal ? Mhe(e) : Dhe(e), e);
}, Rhe = function(e, t) {
  t = ww(t), AP(t);
  var n = t.horizontal ? $7(t) : W7(t);
  xf(e + n, t);
};
yw.default = {
  animateTopScroll: xf,
  getAnimationType: U7,
  scrollToTop: jhe,
  scrollToBottom: Ihe,
  scrollTo: Ahe,
  scrollMore: Rhe
};
Object.defineProperty(_c, "__esModule", {
  value: !0
});
var Bhe = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, Nhe = wf, Fhe = IP(Nhe), zhe = yw, Uhe = IP(zhe), Hhe = Cf, og = IP(Hhe);
function IP(e) {
  return e && e.__esModule ? e : { default: e };
}
var ig = {}, VA = void 0;
_c.default = {
  unmount: function() {
    ig = {};
  },
  register: function(e, t) {
    ig[e] = t;
  },
  unregister: function(e) {
    delete ig[e];
  },
  get: function(e) {
    return ig[e] || document.getElementById(e) || document.getElementsByName(e)[0] || document.getElementsByClassName(e)[0];
  },
  setActiveLink: function(e) {
    return VA = e;
  },
  getActiveLink: function() {
    return VA;
  },
  scrollTo: function(e, t) {
    var n = this.get(e);
    if (!n) {
      console.warn("target Element not found");
      return;
    }
    t = Bhe({}, t, { absolute: !1 });
    var r = t.containerId, o = t.container, i = void 0;
    r ? i = document.getElementById(r) : o && o.nodeType ? i = o : i = document, t.absolute = !0;
    var a = t.horizontal, s = Fhe.default.scrollOffset(i, n, a) + (t.offset || 0);
    if (!t.smooth) {
      og.default.registered.begin && og.default.registered.begin(e, n), i === document ? t.horizontal ? window.scrollTo(s, 0) : window.scrollTo(0, s) : i.scrollTop = s, og.default.registered.end && og.default.registered.end(e, n);
      return;
    }
    Uhe.default.animateTopScroll(s, t, e, n);
  }
};
var dk = { exports: {} }, pC = { exports: {} }, Mn = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var ZA;
function $he() {
  if (ZA) return Mn;
  ZA = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, g = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, m = e ? Symbol.for("react.block") : 60121, v = e ? Symbol.for("react.fundamental") : 60117, E = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
  function M(y) {
    if (typeof y == "object" && y !== null) {
      var C = y.$$typeof;
      switch (C) {
        case t:
          switch (y = y.type, y) {
            case l:
            case u:
            case r:
            case i:
            case o:
            case p:
              return y;
            default:
              switch (y = y && y.$$typeof, y) {
                case s:
                case c:
                case f:
                case g:
                case a:
                  return y;
                default:
                  return C;
              }
          }
        case n:
          return C;
      }
    }
  }
  function O(y) {
    return M(y) === u;
  }
  return Mn.AsyncMode = l, Mn.ConcurrentMode = u, Mn.ContextConsumer = s, Mn.ContextProvider = a, Mn.Element = t, Mn.ForwardRef = c, Mn.Fragment = r, Mn.Lazy = f, Mn.Memo = g, Mn.Portal = n, Mn.Profiler = i, Mn.StrictMode = o, Mn.Suspense = p, Mn.isAsyncMode = function(y) {
    return O(y) || M(y) === l;
  }, Mn.isConcurrentMode = O, Mn.isContextConsumer = function(y) {
    return M(y) === s;
  }, Mn.isContextProvider = function(y) {
    return M(y) === a;
  }, Mn.isElement = function(y) {
    return typeof y == "object" && y !== null && y.$$typeof === t;
  }, Mn.isForwardRef = function(y) {
    return M(y) === c;
  }, Mn.isFragment = function(y) {
    return M(y) === r;
  }, Mn.isLazy = function(y) {
    return M(y) === f;
  }, Mn.isMemo = function(y) {
    return M(y) === g;
  }, Mn.isPortal = function(y) {
    return M(y) === n;
  }, Mn.isProfiler = function(y) {
    return M(y) === i;
  }, Mn.isStrictMode = function(y) {
    return M(y) === o;
  }, Mn.isSuspense = function(y) {
    return M(y) === p;
  }, Mn.isValidElementType = function(y) {
    return typeof y == "string" || typeof y == "function" || y === r || y === u || y === i || y === o || y === p || y === d || typeof y == "object" && y !== null && (y.$$typeof === f || y.$$typeof === g || y.$$typeof === a || y.$$typeof === s || y.$$typeof === c || y.$$typeof === v || y.$$typeof === E || y.$$typeof === w || y.$$typeof === m);
  }, Mn.typeOf = M, Mn;
}
var Fn = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var qA;
function Whe() {
  return qA || (qA = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, g = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, m = e ? Symbol.for("react.block") : 60121, v = e ? Symbol.for("react.fundamental") : 60117, E = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
    function M(B) {
      return typeof B == "string" || typeof B == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      B === r || B === u || B === i || B === o || B === p || B === d || typeof B == "object" && B !== null && (B.$$typeof === f || B.$$typeof === g || B.$$typeof === a || B.$$typeof === s || B.$$typeof === c || B.$$typeof === v || B.$$typeof === E || B.$$typeof === w || B.$$typeof === m);
    }
    function O(B) {
      if (typeof B == "object" && B !== null) {
        var ue = B.$$typeof;
        switch (ue) {
          case t:
            var fe = B.type;
            switch (fe) {
              case l:
              case u:
              case r:
              case i:
              case o:
              case p:
                return fe;
              default:
                var oe = fe && fe.$$typeof;
                switch (oe) {
                  case s:
                  case c:
                  case f:
                  case g:
                  case a:
                    return oe;
                  default:
                    return ue;
                }
            }
          case n:
            return ue;
        }
      }
    }
    var y = l, C = u, _ = s, F = a, L = t, N = c, R = r, W = f, V = g, z = n, Z = i, K = o, X = p, te = !1;
    function J(B) {
      return te || (te = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), P(B) || O(B) === l;
    }
    function P(B) {
      return O(B) === u;
    }
    function D(B) {
      return O(B) === s;
    }
    function H(B) {
      return O(B) === a;
    }
    function S(B) {
      return typeof B == "object" && B !== null && B.$$typeof === t;
    }
    function $(B) {
      return O(B) === c;
    }
    function x(B) {
      return O(B) === r;
    }
    function j(B) {
      return O(B) === f;
    }
    function U(B) {
      return O(B) === g;
    }
    function T(B) {
      return O(B) === n;
    }
    function q(B) {
      return O(B) === i;
    }
    function A(B) {
      return O(B) === o;
    }
    function Y(B) {
      return O(B) === p;
    }
    Fn.AsyncMode = y, Fn.ConcurrentMode = C, Fn.ContextConsumer = _, Fn.ContextProvider = F, Fn.Element = L, Fn.ForwardRef = N, Fn.Fragment = R, Fn.Lazy = W, Fn.Memo = V, Fn.Portal = z, Fn.Profiler = Z, Fn.StrictMode = K, Fn.Suspense = X, Fn.isAsyncMode = J, Fn.isConcurrentMode = P, Fn.isContextConsumer = D, Fn.isContextProvider = H, Fn.isElement = S, Fn.isForwardRef = $, Fn.isFragment = x, Fn.isLazy = j, Fn.isMemo = U, Fn.isPortal = T, Fn.isProfiler = q, Fn.isStrictMode = A, Fn.isSuspense = Y, Fn.isValidElementType = M, Fn.typeOf = O;
  }()), Fn;
}
var GA;
function V7() {
  return GA || (GA = 1, process.env.NODE_ENV === "production" ? pC.exports = $he() : pC.exports = Whe()), pC.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var dC, KA;
function Vhe() {
  if (KA) return dC;
  KA = 1;
  var e = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, n = Object.prototype.propertyIsEnumerable;
  function r(i) {
    if (i == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(i);
  }
  function o() {
    try {
      if (!Object.assign)
        return !1;
      var i = new String("abc");
      if (i[5] = "de", Object.getOwnPropertyNames(i)[0] === "5")
        return !1;
      for (var a = {}, s = 0; s < 10; s++)
        a["_" + String.fromCharCode(s)] = s;
      var l = Object.getOwnPropertyNames(a).map(function(c) {
        return a[c];
      });
      if (l.join("") !== "0123456789")
        return !1;
      var u = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(c) {
        u[c] = c;
      }), Object.keys(Object.assign({}, u)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return dC = o() ? Object.assign : function(i, a) {
    for (var s, l = r(i), u, c = 1; c < arguments.length; c++) {
      s = Object(arguments[c]);
      for (var p in s)
        t.call(s, p) && (l[p] = s[p]);
      if (e) {
        u = e(s);
        for (var d = 0; d < u.length; d++)
          n.call(s, u[d]) && (l[u[d]] = s[u[d]]);
      }
    }
    return l;
  }, dC;
}
var fC, YA;
function RP() {
  if (YA) return fC;
  YA = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return fC = e, fC;
}
var XA, JA;
function Z7() {
  return JA || (JA = 1, XA = Function.call.bind(Object.prototype.hasOwnProperty)), XA;
}
var hC, QA;
function Zhe() {
  if (QA) return hC;
  QA = 1;
  var e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = RP(), n = {}, r = Z7();
    e = function(i) {
      var a = "Warning: " + i;
      typeof console < "u" && console.error(a);
      try {
        throw new Error(a);
      } catch {
      }
    };
  }
  function o(i, a, s, l, u) {
    if (process.env.NODE_ENV !== "production") {
      for (var c in i)
        if (r(i, c)) {
          var p;
          try {
            if (typeof i[c] != "function") {
              var d = Error(
                (l || "React class") + ": " + s + " type `" + c + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof i[c] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw d.name = "Invariant Violation", d;
            }
            p = i[c](a, c, l, s, null, t);
          } catch (f) {
            p = f;
          }
          if (p && !(p instanceof Error) && e(
            (l || "React class") + ": type specification of " + s + " `" + c + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof p + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), p instanceof Error && !(p.message in n)) {
            n[p.message] = !0;
            var g = u ? u() : "";
            e(
              "Failed " + s + " type: " + p.message + (g ?? "")
            );
          }
        }
    }
  }
  return o.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (n = {});
  }, hC = o, hC;
}
var gC, eI;
function qhe() {
  if (eI) return gC;
  eI = 1;
  var e = V7(), t = Vhe(), n = RP(), r = Z7(), o = Zhe(), i = function() {
  };
  process.env.NODE_ENV !== "production" && (i = function(s) {
    var l = "Warning: " + s;
    typeof console < "u" && console.error(l);
    try {
      throw new Error(l);
    } catch {
    }
  });
  function a() {
    return null;
  }
  return gC = function(s, l) {
    var u = typeof Symbol == "function" && Symbol.iterator, c = "@@iterator";
    function p(P) {
      var D = P && (u && P[u] || P[c]);
      if (typeof D == "function")
        return D;
    }
    var d = "<<anonymous>>", g = {
      array: E("array"),
      bigint: E("bigint"),
      bool: E("boolean"),
      func: E("function"),
      number: E("number"),
      object: E("object"),
      string: E("string"),
      symbol: E("symbol"),
      any: w(),
      arrayOf: M,
      element: O(),
      elementType: y(),
      instanceOf: C,
      node: N(),
      objectOf: F,
      oneOf: _,
      oneOfType: L,
      shape: W,
      exact: V
    };
    function f(P, D) {
      return P === D ? P !== 0 || 1 / P === 1 / D : P !== P && D !== D;
    }
    function m(P, D) {
      this.message = P, this.data = D && typeof D == "object" ? D : {}, this.stack = "";
    }
    m.prototype = Error.prototype;
    function v(P) {
      if (process.env.NODE_ENV !== "production")
        var D = {}, H = 0;
      function S(x, j, U, T, q, A, Y) {
        if (T = T || d, A = A || U, Y !== n) {
          if (l) {
            var B = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw B.name = "Invariant Violation", B;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var ue = T + ":" + U;
            !D[ue] && // Avoid spamming the console because they are often not actionable except for lib authors
            H < 3 && (i(
              "You are manually calling a React.PropTypes validation function for the `" + A + "` prop on `" + T + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), D[ue] = !0, H++);
          }
        }
        return j[U] == null ? x ? j[U] === null ? new m("The " + q + " `" + A + "` is marked as required " + ("in `" + T + "`, but its value is `null`.")) : new m("The " + q + " `" + A + "` is marked as required in " + ("`" + T + "`, but its value is `undefined`.")) : null : P(j, U, T, q, A);
      }
      var $ = S.bind(null, !1);
      return $.isRequired = S.bind(null, !0), $;
    }
    function E(P) {
      function D(H, S, $, x, j, U) {
        var T = H[S], q = K(T);
        if (q !== P) {
          var A = X(T);
          return new m(
            "Invalid " + x + " `" + j + "` of type " + ("`" + A + "` supplied to `" + $ + "`, expected ") + ("`" + P + "`."),
            { expectedType: P }
          );
        }
        return null;
      }
      return v(D);
    }
    function w() {
      return v(a);
    }
    function M(P) {
      function D(H, S, $, x, j) {
        if (typeof P != "function")
          return new m("Property `" + j + "` of component `" + $ + "` has invalid PropType notation inside arrayOf.");
        var U = H[S];
        if (!Array.isArray(U)) {
          var T = K(U);
          return new m("Invalid " + x + " `" + j + "` of type " + ("`" + T + "` supplied to `" + $ + "`, expected an array."));
        }
        for (var q = 0; q < U.length; q++) {
          var A = P(U, q, $, x, j + "[" + q + "]", n);
          if (A instanceof Error)
            return A;
        }
        return null;
      }
      return v(D);
    }
    function O() {
      function P(D, H, S, $, x) {
        var j = D[H];
        if (!s(j)) {
          var U = K(j);
          return new m("Invalid " + $ + " `" + x + "` of type " + ("`" + U + "` supplied to `" + S + "`, expected a single ReactElement."));
        }
        return null;
      }
      return v(P);
    }
    function y() {
      function P(D, H, S, $, x) {
        var j = D[H];
        if (!e.isValidElementType(j)) {
          var U = K(j);
          return new m("Invalid " + $ + " `" + x + "` of type " + ("`" + U + "` supplied to `" + S + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return v(P);
    }
    function C(P) {
      function D(H, S, $, x, j) {
        if (!(H[S] instanceof P)) {
          var U = P.name || d, T = J(H[S]);
          return new m("Invalid " + x + " `" + j + "` of type " + ("`" + T + "` supplied to `" + $ + "`, expected ") + ("instance of `" + U + "`."));
        }
        return null;
      }
      return v(D);
    }
    function _(P) {
      if (!Array.isArray(P))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? i(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : i("Invalid argument supplied to oneOf, expected an array.")), a;
      function D(H, S, $, x, j) {
        for (var U = H[S], T = 0; T < P.length; T++)
          if (f(U, P[T]))
            return null;
        var q = JSON.stringify(P, function(A, Y) {
          var B = X(Y);
          return B === "symbol" ? String(Y) : Y;
        });
        return new m("Invalid " + x + " `" + j + "` of value `" + String(U) + "` " + ("supplied to `" + $ + "`, expected one of " + q + "."));
      }
      return v(D);
    }
    function F(P) {
      function D(H, S, $, x, j) {
        if (typeof P != "function")
          return new m("Property `" + j + "` of component `" + $ + "` has invalid PropType notation inside objectOf.");
        var U = H[S], T = K(U);
        if (T !== "object")
          return new m("Invalid " + x + " `" + j + "` of type " + ("`" + T + "` supplied to `" + $ + "`, expected an object."));
        for (var q in U)
          if (r(U, q)) {
            var A = P(U, q, $, x, j + "." + q, n);
            if (A instanceof Error)
              return A;
          }
        return null;
      }
      return v(D);
    }
    function L(P) {
      if (!Array.isArray(P))
        return process.env.NODE_ENV !== "production" && i("Invalid argument supplied to oneOfType, expected an instance of array."), a;
      for (var D = 0; D < P.length; D++) {
        var H = P[D];
        if (typeof H != "function")
          return i(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + te(H) + " at index " + D + "."
          ), a;
      }
      function S($, x, j, U, T) {
        for (var q = [], A = 0; A < P.length; A++) {
          var Y = P[A], B = Y($, x, j, U, T, n);
          if (B == null)
            return null;
          B.data && r(B.data, "expectedType") && q.push(B.data.expectedType);
        }
        var ue = q.length > 0 ? ", expected one of type [" + q.join(", ") + "]" : "";
        return new m("Invalid " + U + " `" + T + "` supplied to " + ("`" + j + "`" + ue + "."));
      }
      return v(S);
    }
    function N() {
      function P(D, H, S, $, x) {
        return z(D[H]) ? null : new m("Invalid " + $ + " `" + x + "` supplied to " + ("`" + S + "`, expected a ReactNode."));
      }
      return v(P);
    }
    function R(P, D, H, S, $) {
      return new m(
        (P || "React class") + ": " + D + " type `" + H + "." + S + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + $ + "`."
      );
    }
    function W(P) {
      function D(H, S, $, x, j) {
        var U = H[S], T = K(U);
        if (T !== "object")
          return new m("Invalid " + x + " `" + j + "` of type `" + T + "` " + ("supplied to `" + $ + "`, expected `object`."));
        for (var q in P) {
          var A = P[q];
          if (typeof A != "function")
            return R($, x, j, q, X(A));
          var Y = A(U, q, $, x, j + "." + q, n);
          if (Y)
            return Y;
        }
        return null;
      }
      return v(D);
    }
    function V(P) {
      function D(H, S, $, x, j) {
        var U = H[S], T = K(U);
        if (T !== "object")
          return new m("Invalid " + x + " `" + j + "` of type `" + T + "` " + ("supplied to `" + $ + "`, expected `object`."));
        var q = t({}, H[S], P);
        for (var A in q) {
          var Y = P[A];
          if (r(P, A) && typeof Y != "function")
            return R($, x, j, A, X(Y));
          if (!Y)
            return new m(
              "Invalid " + x + " `" + j + "` key `" + A + "` supplied to `" + $ + "`.\nBad object: " + JSON.stringify(H[S], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(P), null, "  ")
            );
          var B = Y(U, A, $, x, j + "." + A, n);
          if (B)
            return B;
        }
        return null;
      }
      return v(D);
    }
    function z(P) {
      switch (typeof P) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !P;
        case "object":
          if (Array.isArray(P))
            return P.every(z);
          if (P === null || s(P))
            return !0;
          var D = p(P);
          if (D) {
            var H = D.call(P), S;
            if (D !== P.entries) {
              for (; !(S = H.next()).done; )
                if (!z(S.value))
                  return !1;
            } else
              for (; !(S = H.next()).done; ) {
                var $ = S.value;
                if ($ && !z($[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function Z(P, D) {
      return P === "symbol" ? !0 : D ? D["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && D instanceof Symbol : !1;
    }
    function K(P) {
      var D = typeof P;
      return Array.isArray(P) ? "array" : P instanceof RegExp ? "object" : Z(D, P) ? "symbol" : D;
    }
    function X(P) {
      if (typeof P > "u" || P === null)
        return "" + P;
      var D = K(P);
      if (D === "object") {
        if (P instanceof Date)
          return "date";
        if (P instanceof RegExp)
          return "regexp";
      }
      return D;
    }
    function te(P) {
      var D = X(P);
      switch (D) {
        case "array":
        case "object":
          return "an " + D;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + D;
        default:
          return D;
      }
    }
    function J(P) {
      return !P.constructor || !P.constructor.name ? d : P.constructor.name;
    }
    return g.checkPropTypes = o, g.resetWarningCache = o.resetWarningCache, g.PropTypes = g, g;
  }, gC;
}
var mC, tI;
function Ghe() {
  if (tI) return mC;
  tI = 1;
  var e = RP();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, mC = function() {
    function r(a, s, l, u, c, p) {
      if (p !== e) {
        var d = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw d.name = "Invariant Violation", d;
      }
    }
    r.isRequired = r;
    function o() {
      return r;
    }
    var i = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: o,
      element: r,
      elementType: r,
      instanceOf: o,
      node: r,
      objectOf: o,
      oneOf: o,
      oneOfType: o,
      shape: o,
      exact: o,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return i.PropTypes = i, i;
  }, mC;
}
if (process.env.NODE_ENV !== "production") {
  var Khe = V7(), Yhe = !0;
  dk.exports = qhe()(Khe.isElement, Yhe);
} else
  dk.exports = Ghe()();
var Cw = dk.exports, xw = {};
Object.defineProperty(xw, "__esModule", {
  value: !0
});
var Xhe = wf, vC = Jhe(Xhe);
function Jhe(e) {
  return e && e.__esModule ? e : { default: e };
}
var Qhe = {
  mountFlag: !1,
  initialized: !1,
  scroller: null,
  containers: {},
  mount: function(e) {
    this.scroller = e, this.handleHashChange = this.handleHashChange.bind(this), window.addEventListener("hashchange", this.handleHashChange), this.initStateFromHash(), this.mountFlag = !0;
  },
  mapContainer: function(e, t) {
    this.containers[e] = t;
  },
  isMounted: function() {
    return this.mountFlag;
  },
  isInitialized: function() {
    return this.initialized;
  },
  initStateFromHash: function() {
    var e = this, t = this.getHash();
    t ? window.setTimeout(function() {
      e.scrollTo(t, !0), e.initialized = !0;
    }, 10) : this.initialized = !0;
  },
  scrollTo: function(e, t) {
    var n = this.scroller, r = n.get(e);
    if (r && (t || e !== n.getActiveLink())) {
      var o = this.containers[e] || document;
      n.scrollTo(e, { container: o });
    }
  },
  getHash: function() {
    return vC.default.getHash();
  },
  changeHash: function(e, t) {
    this.isInitialized() && vC.default.getHash() !== e && vC.default.updateHash(e, t);
  },
  handleHashChange: function() {
    this.scrollTo(this.getHash());
  },
  unmount: function() {
    this.scroller = null, this.containers = null, window.removeEventListener("hashchange", this.handleHashChange);
  }
};
xw.default = Qhe;
Object.defineProperty(vf, "__esModule", {
  value: !0
});
var sg = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, ege = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), tge = we, nI = Of(tge), nge = yf, ag = Of(nge), rge = _c, oge = Of(rge), ige = Cw, Pr = Of(ige), sge = xw, xa = Of(sge);
function Of(e) {
  return e && e.__esModule ? e : { default: e };
}
function age(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function lge(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function uge(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var rI = {
  to: Pr.default.string.isRequired,
  containerId: Pr.default.string,
  container: Pr.default.object,
  activeClass: Pr.default.string,
  activeStyle: Pr.default.object,
  spy: Pr.default.bool,
  horizontal: Pr.default.bool,
  smooth: Pr.default.oneOfType([Pr.default.bool, Pr.default.string]),
  offset: Pr.default.number,
  delay: Pr.default.number,
  isDynamic: Pr.default.bool,
  onClick: Pr.default.func,
  duration: Pr.default.oneOfType([Pr.default.number, Pr.default.func]),
  absolute: Pr.default.bool,
  onSetActive: Pr.default.func,
  onSetInactive: Pr.default.func,
  ignoreCancelEvents: Pr.default.bool,
  hashSpy: Pr.default.bool,
  saveHashHistory: Pr.default.bool,
  spyThrottle: Pr.default.number
};
vf.default = function(e, t) {
  var n = t || oge.default, r = function(i) {
    uge(a, i);
    function a(s) {
      age(this, a);
      var l = lge(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
      return o.call(l), l.state = {
        active: !1
      }, l.beforeUnmountCallbacks = [], l;
    }
    return ege(a, [{
      key: "getScrollSpyContainer",
      value: function() {
        var s = this.props.containerId, l = this.props.container;
        return s && !l ? document.getElementById(s) : l && l.nodeType ? l : document;
      }
    }, {
      key: "componentDidMount",
      value: function() {
        if (this.props.spy || this.props.hashSpy) {
          var s = this.getScrollSpyContainer();
          if (!ag.default.isMounted(s)) {
            var l = ag.default.mount(s, this.props.spyThrottle);
            this.beforeUnmountCallbacks.push(l);
          }
          this.props.hashSpy && (xa.default.isMounted() || xa.default.mount(n), xa.default.mapContainer(this.props.to, s)), ag.default.addSpyHandler(this.spyHandler, s), this.setState({
            container: s
          });
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        ag.default.unmount(this.stateHandler, this.spyHandler), this.beforeUnmountCallbacks.forEach(function(s) {
          return s();
        });
      }
    }, {
      key: "render",
      value: function() {
        var s = "";
        this.state && this.state.active ? s = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : s = this.props.className;
        var l = {};
        this.state && this.state.active ? l = sg({}, this.props.style, this.props.activeStyle) : l = sg({}, this.props.style);
        var u = sg({}, this.props);
        for (var c in rI)
          u.hasOwnProperty(c) && delete u[c];
        return u.className = s, u.style = l, u.onClick = this.handleClick, nI.default.createElement(e, u);
      }
    }]), a;
  }(nI.default.PureComponent), o = function() {
    var i = this;
    this.scrollTo = function(a, s) {
      n.scrollTo(a, sg({}, i.state, s));
    }, this.handleClick = function(a) {
      i.props.onClick && i.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), i.scrollTo(i.props.to, i.props);
    }, this.spyHandler = function(a, s) {
      var l = i.getScrollSpyContainer();
      if (!(xa.default.isMounted() && !xa.default.isInitialized())) {
        var u = i.props.horizontal, c = i.props.to, p = null, d = void 0, g = void 0;
        if (u) {
          var f = 0, m = 0, v = 0;
          if (l.getBoundingClientRect) {
            var E = l.getBoundingClientRect();
            v = E.left;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var w = p.getBoundingClientRect();
            f = w.left - v + a, m = f + w.width;
          }
          var M = a - i.props.offset;
          d = M >= Math.floor(f) && M < Math.floor(m), g = M < Math.floor(f) || M >= Math.floor(m);
        } else {
          var O = 0, y = 0, C = 0;
          if (l.getBoundingClientRect) {
            var _ = l.getBoundingClientRect();
            C = _.top;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var F = p.getBoundingClientRect();
            O = F.top - C + s, y = O + F.height;
          }
          var L = s - i.props.offset;
          d = L >= Math.floor(O) && L < Math.floor(y), g = L < Math.floor(O) || L >= Math.floor(y);
        }
        var N = n.getActiveLink();
        if (g) {
          if (c === N && n.setActiveLink(void 0), i.props.hashSpy && xa.default.getHash() === c) {
            var R = i.props.saveHashHistory, W = R === void 0 ? !1 : R;
            xa.default.changeHash("", W);
          }
          i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive(c, p));
        }
        if (d && (N !== c || i.state.active === !1)) {
          n.setActiveLink(c);
          var V = i.props.saveHashHistory, z = V === void 0 ? !1 : V;
          i.props.hashSpy && xa.default.changeHash(c, z), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(c, p));
        }
      }
    };
  };
  return r.propTypes = rI, r.defaultProps = { offset: 0 }, r;
};
Object.defineProperty(DP, "__esModule", {
  value: !0
});
var cge = we, oI = q7(cge), pge = vf, dge = q7(pge);
function q7(e) {
  return e && e.__esModule ? e : { default: e };
}
function fge(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function iI(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function hge(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var gge = function(e) {
  hge(t, e);
  function t() {
    var n, r, o, i;
    fge(this, t);
    for (var a = arguments.length, s = Array(a), l = 0; l < a; l++)
      s[l] = arguments[l];
    return i = (r = (o = iI(this, (n = t.__proto__ || Object.getPrototypeOf(t)).call.apply(n, [this].concat(s))), o), o.render = function() {
      return oI.default.createElement(
        "a",
        o.props,
        o.props.children
      );
    }, r), iI(o, i);
  }
  return t;
}(oI.default.Component);
DP.default = (0, dge.default)(gge);
var BP = {};
Object.defineProperty(BP, "__esModule", {
  value: !0
});
var mge = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), vge = we, sI = G7(vge), yge = vf, bge = G7(yge);
function G7(e) {
  return e && e.__esModule ? e : { default: e };
}
function wge(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Cge(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function xge(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var Oge = function(e) {
  xge(t, e);
  function t() {
    return wge(this, t), Cge(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return mge(t, [{
    key: "render",
    value: function() {
      return sI.default.createElement(
        "button",
        this.props,
        this.props.children
      );
    }
  }]), t;
}(sI.default.Component);
BP.default = (0, bge.default)(Oge);
var NP = {}, Ow = {};
Object.defineProperty(Ow, "__esModule", {
  value: !0
});
var Ege = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, kge = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), Lge = we, aI = Ew(Lge), Pge = pl;
Ew(Pge);
var _ge = _c, lI = Ew(_ge), Sge = Cw, uI = Ew(Sge);
function Ew(e) {
  return e && e.__esModule ? e : { default: e };
}
function Mge(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Dge(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function Tge(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
Ow.default = function(e) {
  var t = function(n) {
    Tge(r, n);
    function r(o) {
      Mge(this, r);
      var i = Dge(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
      return i.childBindings = {
        domNode: null
      }, i;
    }
    return kge(r, [{
      key: "componentDidMount",
      value: function() {
        if (typeof window > "u")
          return !1;
        this.registerElems(this.props.name);
      }
    }, {
      key: "componentDidUpdate",
      value: function(o) {
        this.props.name !== o.name && this.registerElems(this.props.name);
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        if (typeof window > "u")
          return !1;
        lI.default.unregister(this.props.name);
      }
    }, {
      key: "registerElems",
      value: function(o) {
        lI.default.register(o, this.childBindings.domNode);
      }
    }, {
      key: "render",
      value: function() {
        return aI.default.createElement(e, Ege({}, this.props, { parentBindings: this.childBindings }));
      }
    }]), r;
  }(aI.default.Component);
  return t.propTypes = {
    name: uI.default.string,
    id: uI.default.string
  }, t;
};
Object.defineProperty(NP, "__esModule", {
  value: !0
});
var cI = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, jge = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), Age = we, pI = FP(Age), Ige = Ow, Rge = FP(Ige), Bge = Cw, dI = FP(Bge);
function FP(e) {
  return e && e.__esModule ? e : { default: e };
}
function Nge(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Fge(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function zge(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var K7 = function(e) {
  zge(t, e);
  function t() {
    return Nge(this, t), Fge(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return jge(t, [{
    key: "render",
    value: function() {
      var n = this, r = cI({}, this.props);
      return delete r.name, r.parentBindings && delete r.parentBindings, pI.default.createElement(
        "div",
        cI({}, r, { ref: function(o) {
          n.props.parentBindings.domNode = o;
        } }),
        this.props.children
      );
    }
  }]), t;
}(pI.default.Component);
K7.propTypes = {
  name: dI.default.string,
  id: dI.default.string
};
NP.default = (0, Rge.default)(K7);
var yC = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, fI = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}();
function hI(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function gI(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function mI(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var lg = we, Al = yf, bC = _c, Gr = Cw, Oa = xw, vI = {
  to: Gr.string.isRequired,
  containerId: Gr.string,
  container: Gr.object,
  activeClass: Gr.string,
  spy: Gr.bool,
  smooth: Gr.oneOfType([Gr.bool, Gr.string]),
  offset: Gr.number,
  delay: Gr.number,
  isDynamic: Gr.bool,
  onClick: Gr.func,
  duration: Gr.oneOfType([Gr.number, Gr.func]),
  absolute: Gr.bool,
  onSetActive: Gr.func,
  onSetInactive: Gr.func,
  ignoreCancelEvents: Gr.bool,
  hashSpy: Gr.bool,
  spyThrottle: Gr.number
}, Uge = {
  Scroll: function(e, t) {
    console.warn("Helpers.Scroll is deprecated since v1.7.0");
    var n = t || bC, r = function(i) {
      mI(a, i);
      function a(s) {
        hI(this, a);
        var l = gI(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
        return o.call(l), l.state = {
          active: !1
        }, l;
      }
      return fI(a, [{
        key: "getScrollSpyContainer",
        value: function() {
          var s = this.props.containerId, l = this.props.container;
          return s ? document.getElementById(s) : l && l.nodeType ? l : document;
        }
      }, {
        key: "componentDidMount",
        value: function() {
          if (this.props.spy || this.props.hashSpy) {
            var s = this.getScrollSpyContainer();
            Al.isMounted(s) || Al.mount(s, this.props.spyThrottle), this.props.hashSpy && (Oa.isMounted() || Oa.mount(n), Oa.mapContainer(this.props.to, s)), this.props.spy && Al.addStateHandler(this.stateHandler), Al.addSpyHandler(this.spyHandler, s), this.setState({
              container: s
            });
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          Al.unmount(this.stateHandler, this.spyHandler);
        }
      }, {
        key: "render",
        value: function() {
          var s = "";
          this.state && this.state.active ? s = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : s = this.props.className;
          var l = yC({}, this.props);
          for (var u in vI)
            l.hasOwnProperty(u) && delete l[u];
          return l.className = s, l.onClick = this.handleClick, lg.createElement(e, l);
        }
      }]), a;
    }(lg.Component), o = function() {
      var i = this;
      this.scrollTo = function(a, s) {
        n.scrollTo(a, yC({}, i.state, s));
      }, this.handleClick = function(a) {
        i.props.onClick && i.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), i.scrollTo(i.props.to, i.props);
      }, this.stateHandler = function() {
        n.getActiveLink() !== i.props.to && (i.state !== null && i.state.active && i.props.onSetInactive && i.props.onSetInactive(), i.setState({ active: !1 }));
      }, this.spyHandler = function(a) {
        var s = i.getScrollSpyContainer();
        if (!(Oa.isMounted() && !Oa.isInitialized())) {
          var l = i.props.to, u = null, c = 0, p = 0, d = 0;
          if (s.getBoundingClientRect) {
            var g = s.getBoundingClientRect();
            d = g.top;
          }
          if (!u || i.props.isDynamic) {
            if (u = n.get(l), !u)
              return;
            var f = u.getBoundingClientRect();
            c = f.top - d + a, p = c + f.height;
          }
          var m = a - i.props.offset, v = m >= Math.floor(c) && m < Math.floor(p), E = m < Math.floor(c) || m >= Math.floor(p), w = n.getActiveLink();
          if (E)
            return l === w && n.setActiveLink(void 0), i.props.hashSpy && Oa.getHash() === l && Oa.changeHash(), i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive()), Al.updateStates();
          if (v && w !== l)
            return n.setActiveLink(l), i.props.hashSpy && Oa.changeHash(l), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(l)), Al.updateStates();
        }
      };
    };
    return r.propTypes = vI, r.defaultProps = { offset: 0 }, r;
  },
  Element: function(e) {
    console.warn("Helpers.Element is deprecated since v1.7.0");
    var t = function(n) {
      mI(r, n);
      function r(o) {
        hI(this, r);
        var i = gI(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
        return i.childBindings = {
          domNode: null
        }, i;
      }
      return fI(r, [{
        key: "componentDidMount",
        value: function() {
          if (typeof window > "u")
            return !1;
          this.registerElems(this.props.name);
        }
      }, {
        key: "componentDidUpdate",
        value: function(o) {
          this.props.name !== o.name && this.registerElems(this.props.name);
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          if (typeof window > "u")
            return !1;
          bC.unregister(this.props.name);
        }
      }, {
        key: "registerElems",
        value: function(o) {
          bC.register(o, this.childBindings.domNode);
        }
      }, {
        key: "render",
        value: function() {
          return lg.createElement(e, yC({}, this.props, { parentBindings: this.childBindings }));
        }
      }]), r;
    }(lg.Component);
    return t.propTypes = {
      name: Gr.string,
      id: Gr.string
    }, t;
  }
}, Hge = Uge;
Object.defineProperty(lo, "__esModule", {
  value: !0
});
lo.Helpers = lo.ScrollElement = lo.ScrollLink = lo.animateScroll = lo.scrollSpy = lo.Events = lo.scroller = lo.Element = lo.Button = lo.Link = void 0;
var $ge = DP, Y7 = js($ge), Wge = BP, X7 = js(Wge), Vge = NP, J7 = js(Vge), Zge = _c, Q7 = js(Zge), qge = Cf, eZ = js(qge), Gge = yf, tZ = js(Gge), Kge = yw, nZ = js(Kge), Yge = vf, rZ = js(Yge), Xge = Ow, oZ = js(Xge), Jge = Hge, iZ = js(Jge);
function js(e) {
  return e && e.__esModule ? e : { default: e };
}
lo.Link = Y7.default;
lo.Button = X7.default;
lo.Element = J7.default;
lo.scroller = Q7.default;
lo.Events = eZ.default;
lo.scrollSpy = tZ.default;
lo.animateScroll = nZ.default;
lo.ScrollLink = rZ.default;
lo.ScrollElement = oZ.default;
lo.Helpers = iZ.default;
lo.default = { Link: Y7.default, Button: X7.default, Element: J7.default, scroller: Q7.default, Events: eZ.default, scrollSpy: tZ.default, animateScroll: nZ.default, ScrollLink: rZ.default, ScrollElement: oZ.default, Helpers: iZ.default };
Ke({});
Ke({});
Ke({});
function Qd(e) {
  "@babel/helpers - typeof";
  return Qd = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Qd(e);
}
function Qge(e, t) {
  if (Qd(e) != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (Qd(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function eme(e) {
  var t = Qge(e, "string");
  return Qd(t) == "symbol" ? t : t + "";
}
function Ce(e, t, n) {
  return (t = eme(t)) in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function sZ(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var wC, yI;
function tme() {
  if (yI) return wC;
  yI = 1;
  var e = process.env.NODE_ENV, t = function(n, r, o, i, a, s, l, u) {
    if (e !== "production" && r === void 0)
      throw new Error("invariant requires an error message argument");
    if (!n) {
      var c;
      if (r === void 0)
        c = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
      else {
        var p = [o, i, a, s, l, u], d = 0;
        c = new Error(r.replace(/%s/g, function() {
          return p[d++];
        })), c.name = "Invariant Violation";
      }
      throw c.framesToPop = 1, c;
    }
  };
  return wC = t, wC;
}
var nme = tme(), yo = /* @__PURE__ */ sZ(nme), Tt = Ke(null);
function rme() {
  yo(!!ge, "useGoogleMap is React hook and requires React version 16.8+");
  var e = ge(Tt);
  return yo(!!e, "useGoogleMap needs a GoogleMap available up in the tree"), e;
}
function ome(e, t, n) {
  return Object.keys(e).reduce(function(r, o) {
    return t(r, e[o], o);
  }, n);
}
function ime(e, t) {
  Object.keys(e).forEach((n) => t(e[n], n));
}
function sme(e, t, n, r) {
  var o = {}, i = (a, s) => {
    var l = n[s];
    l !== t[s] && (o[s] = l, a(r, l));
  };
  return ime(e, i), o;
}
function ame(e, t, n) {
  var r = ome(n, function(o, i, a) {
    return typeof e[a] == "function" && o.push(google.maps.event.addListener(t, i, e[a])), o;
  }, []);
  return r;
}
function lme(e) {
  google.maps.event.removeListener(e);
}
function fn() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  e.forEach(lme);
}
function an(e) {
  var {
    updaterMap: t,
    eventMap: n,
    prevProps: r,
    nextProps: o,
    instance: i
  } = e, a = ame(o, i, n);
  return sme(t, r, o, i), a;
}
function ume(e) {
  var {
    children: t,
    options: n,
    id: r,
    mapContainerStyle: o,
    mapContainerClassName: i,
    center: a,
    // clickableIcons,
    // extraMapTypes,
    // heading,
    // mapTypeId,
    onClick: s,
    onDblClick: l,
    onDrag: u,
    onDragEnd: c,
    onDragStart: p,
    onMouseMove: d,
    onMouseOut: g,
    onMouseOver: f,
    onMouseDown: m,
    onMouseUp: v,
    onRightClick: E,
    // onMapTypeIdChanged,
    // onTilesLoaded,
    // onBoundsChanged,
    onCenterChanged: w,
    // onHeadingChanged,
    // onIdle,
    // onProjectionChanged,
    // onResize,
    // onTiltChanged,
    // onZoomChanged,
    onLoad: M,
    onUnmount: O
  } = e, [y, C] = k(null), _ = ut(null), [F, L] = k(null), [N, R] = k(null), [W, V] = k(null), [z, Z] = k(null), [K, X] = k(null), [te, J] = k(null), [P, D] = k(null), [H, S] = k(null), [$, x] = k(null), [j, U] = k(null), [T, q] = k(null), [A, Y] = k(null);
  return h(() => {
    n && y !== null && y.setOptions(n);
  }, [y, n]), h(() => {
    y !== null && typeof a < "u" && y.setCenter(a);
  }, [y, a]), h(() => {
    y && l && (N !== null && google.maps.event.removeListener(N), R(google.maps.event.addListener(y, "dblclick", l)));
  }, [l]), h(() => {
    y && c && (W !== null && google.maps.event.removeListener(W), V(google.maps.event.addListener(y, "dragend", c)));
  }, [c]), h(() => {
    y && p && (z !== null && google.maps.event.removeListener(z), Z(google.maps.event.addListener(y, "dragstart", p)));
  }, [p]), h(() => {
    y && m && (K !== null && google.maps.event.removeListener(K), X(google.maps.event.addListener(y, "mousedown", m)));
  }, [m]), h(() => {
    y && d && (te !== null && google.maps.event.removeListener(te), J(google.maps.event.addListener(y, "mousemove", d)));
  }, [d]), h(() => {
    y && g && (P !== null && google.maps.event.removeListener(P), D(google.maps.event.addListener(y, "mouseout", g)));
  }, [g]), h(() => {
    y && f && (H !== null && google.maps.event.removeListener(H), S(google.maps.event.addListener(y, "mouseover", f)));
  }, [f]), h(() => {
    y && v && ($ !== null && google.maps.event.removeListener($), x(google.maps.event.addListener(y, "mouseup", v)));
  }, [v]), h(() => {
    y && E && (j !== null && google.maps.event.removeListener(j), U(google.maps.event.addListener(y, "rightclick", E)));
  }, [E]), h(() => {
    y && s && (T !== null && google.maps.event.removeListener(T), q(google.maps.event.addListener(y, "click", s)));
  }, [s]), h(() => {
    y && u && (A !== null && google.maps.event.removeListener(A), Y(google.maps.event.addListener(y, "drag", u)));
  }, [u]), h(() => {
    y && w && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(y, "center_changed", w)));
  }, [s]), h(() => {
    var B = _.current === null ? null : new google.maps.Map(_.current, n);
    return C(B), B !== null && M && M(B), () => {
      B !== null && O && O(B);
    };
  }, []), Do.jsx("div", {
    id: r,
    ref: _,
    style: o,
    className: i,
    children: Do.jsx(Tt.Provider, {
      value: y,
      children: y !== null ? t : null
    })
  });
}
ve(ume);
function bI(e, t, n, r, o, i, a) {
  try {
    var s = e[i](a), l = s.value;
  } catch (u) {
    return void n(u);
  }
  s.done ? t(l) : Promise.resolve(l).then(r, o);
}
function aZ(e) {
  return function() {
    var t = this, n = arguments;
    return new Promise(function(r, o) {
      var i = e.apply(t, n);
      function a(l) {
        bI(i, r, o, a, s, "next", l);
      }
      function s(l) {
        bI(i, r, o, a, s, "throw", l);
      }
      a(void 0);
    });
  };
}
function lZ(e) {
  var {
    googleMapsApiKey: t,
    googleMapsClientId: n,
    version: r = "weekly",
    language: o,
    region: i,
    libraries: a,
    channel: s,
    mapIds: l,
    authReferrerPolicy: u
  } = e, c = [];
  return yo(t && n || !(t && n), "You need to specify either googleMapsApiKey or googleMapsClientId for @react-google-maps/api load script to work. You cannot use both at the same time."), t ? c.push("key=".concat(t)) : n && c.push("client=".concat(n)), r && c.push("v=".concat(r)), o && c.push("language=".concat(o)), i && c.push("region=".concat(i)), a && a.length && c.push("libraries=".concat(a.sort().join(","))), s && c.push("channel=".concat(s)), l && l.length && c.push("map_ids=".concat(l.join(","))), u && c.push("auth_referrer_policy=".concat(u)), c.push("loading=async"), c.push("callback=initMap"), "https://maps.googleapis.com/maps/api/js?".concat(c.join("&"));
}
var cu = typeof document < "u";
function uZ(e) {
  var {
    url: t,
    id: n,
    nonce: r
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } = e;
  return cu ? new Promise(function(o, i) {
    var a = document.getElementById(n), s = window;
    if (a) {
      var l = a.getAttribute("data-state");
      if (a.src === t && l !== "error") {
        if (l === "ready")
          return o(n);
        var u = s.initMap, c = a.onerror;
        s.initMap = function() {
          u && u(), o(n);
        }, a.onerror = function(d) {
          c && c(d), i(d);
        };
        return;
      } else
        a.remove();
    }
    var p = document.createElement("script");
    p.type = "text/javascript", p.src = t, p.id = n, p.async = !0, p.nonce = r || "", p.onerror = function(d) {
      p.setAttribute("data-state", "error"), i(d);
    }, s.initMap = function() {
      p.setAttribute("data-state", "ready"), o(n);
    }, document.head.appendChild(p);
  }).catch((o) => {
    throw console.error("injectScript error: ", o), o;
  }) : Promise.reject(new Error("document is undefined"));
}
function wI(e) {
  var t = e.href;
  return t && (t.indexOf("https://fonts.googleapis.com/css?family=Roboto") === 0 || t.indexOf("https://fonts.googleapis.com/css?family=Google+Sans+Text") === 0) ? !0 : (
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.styleSheet.cssText = "", !0) : (
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.innerHTML = "", !0) : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.innerHTML
      )
    )
  );
}
function cZ() {
  var e = document.getElementsByTagName("head")[0];
  if (e) {
    var t = e.insertBefore.bind(e);
    e.insertBefore = function(r, o) {
      return wI(r) || Reflect.apply(t, e, [r, o]), r;
    };
    var n = e.appendChild.bind(e);
    e.appendChild = function(r) {
      return wI(r) || Reflect.apply(n, e, [r]), r;
    };
  }
}
var rp = !1;
function pZ() {
  return Do.jsx("div", {
    children: "Loading..."
  });
}
var fk = {
  id: "script-loader",
  version: "weekly"
};
class cme extends pe {
  constructor() {
    super(...arguments), Ce(this, "check", null), Ce(this, "state", {
      loaded: !1
    }), Ce(this, "cleanupCallback", () => {
      delete window.google.maps, this.injectScript();
    }), Ce(this, "isCleaningUp", /* @__PURE__ */ aZ(function* () {
      function t(n) {
        if (!rp)
          n();
        else if (cu)
          var r = window.setInterval(function() {
            rp || (window.clearInterval(r), n());
          }, 1);
      }
      return new Promise(t);
    })), Ce(this, "cleanup", () => {
      rp = !0;
      var t = document.getElementById(this.props.id);
      t && t.parentNode && t.parentNode.removeChild(t), Array.prototype.slice.call(document.getElementsByTagName("script")).filter(function(n) {
        return typeof n.src == "string" && n.src.includes("maps.googleapis");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("link")).filter(function(n) {
        return n.href === "https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Google+Sans";
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("style")).filter(function(n) {
        return n.innerText !== void 0 && n.innerText.length > 0 && n.innerText.includes(".gm-");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      });
    }), Ce(this, "injectScript", () => {
      this.props.preventGoogleFontsLoading && cZ(), yo(!!this.props.id, 'LoadScript requires "id" prop to be a string: %s', this.props.id);
      var t = {
        id: this.props.id,
        nonce: this.props.nonce,
        url: lZ(this.props)
      };
      uZ(t).then(() => {
        this.props.onLoad && this.props.onLoad(), this.setState(function() {
          return {
            loaded: !0
          };
        });
      }).catch((n) => {
        this.props.onError && this.props.onError(n), console.error(`
          There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(this.props.googleMapsApiKey || "-", ") or Client ID (").concat(this.props.googleMapsClientId || "-", `) to <LoadScript />
          Otherwise it is a Network issue.
        `));
      });
    }), Ce(this, "getRef", (t) => {
      this.check = t;
    });
  }
  componentDidMount() {
    if (cu) {
      if (window.google && window.google.maps && !rp) {
        console.error("google api is already presented");
        return;
      }
      this.isCleaningUp().then(this.injectScript).catch(function(t) {
        console.error("Error at injecting script after cleaning up: ", t);
      });
    }
  }
  componentDidUpdate(t) {
    this.props.libraries !== t.libraries && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), cu && t.language !== this.props.language && (this.cleanup(), this.setState(function() {
      return {
        loaded: !1
      };
    }, this.cleanupCallback));
  }
  componentWillUnmount() {
    if (cu) {
      this.cleanup();
      var t = () => {
        this.check || (delete window.google, rp = !1);
      };
      window.setTimeout(t, 1), this.props.onUnmount && this.props.onUnmount();
    }
  }
  render() {
    return Do.jsxs(Do.Fragment, {
      children: [Do.jsx("div", {
        ref: this.getRef
      }), this.state.loaded ? this.props.children : this.props.loadingElement || Do.jsx(pZ, {})]
    });
  }
}
Ce(cme, "defaultProps", fk);
function pme(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.includes(r)) continue;
    n[r] = e[r];
  }
  return n;
}
function zP(e, t) {
  if (e == null) return {};
  var n, r, o = pme(e, t);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (r = 0; r < i.length; r++) n = i[r], t.includes(n) || {}.propertyIsEnumerable.call(e, n) && (o[n] = e[n]);
  }
  return o;
}
var CI;
function dme(e) {
  var {
    id: t = fk.id,
    version: n = fk.version,
    nonce: r,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    preventGoogleFontsLoading: u,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  } = e, g = ut(!1), [f, m] = k(!1), [v, E] = k(void 0);
  h(function() {
    return g.current = !0, () => {
      g.current = !1;
    };
  }, []), h(function() {
    cu && u && cZ();
  }, [u]), h(function() {
    f && yo(!!window.google, "useLoadScript was marked as loaded, but window.google is not present. Something went wrong.");
  }, [f]);
  var w = lZ({
    version: n,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  });
  h(function() {
    if (!cu)
      return;
    function O() {
      g.current && (m(!0), CI = w);
    }
    if (window.google && window.google.maps && CI === w) {
      O();
      return;
    }
    uZ({
      id: t,
      url: w,
      nonce: r
    }).then(O).catch(function(y) {
      g.current && E(y), console.warn(`
        There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(o || "-", ") or Client ID (").concat(i || "-", `)
        Otherwise it is a Network issue.
      `)), console.error(y);
    });
  }, [t, w, r]);
  var M = ut(void 0);
  return h(function() {
    M.current && l !== M.current && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), M.current = l;
  }, [l]), {
    isLoaded: f,
    loadError: v,
    url: w
  };
}
var fme = ["loadingElement", "onLoad", "onError", "onUnmount", "children"], hme = Do.jsx(pZ, {});
function gme(e) {
  var {
    loadingElement: t,
    onLoad: n,
    onError: r,
    onUnmount: o,
    children: i
  } = e, a = zP(e, fme), {
    isLoaded: s,
    loadError: l
  } = dme(a);
  return h(function() {
    s && typeof n == "function" && n();
  }, [s, n]), h(function() {
    l && typeof r == "function" && r(l);
  }, [l, r]), h(function() {
    return () => {
      o && o();
    };
  }, [o]), s ? i : t || hme;
}
ve(gme);
var xI;
(function(e) {
  e[e.INITIALIZED = 0] = "INITIALIZED", e[e.LOADING = 1] = "LOADING", e[e.SUCCESS = 2] = "SUCCESS", e[e.FAILURE = 3] = "FAILURE";
})(xI || (xI = {}));
function OI(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Ev(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? OI(Object(n), !0).forEach(function(r) {
      Ce(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : OI(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var EI = {}, kI = {
  options(e, t) {
    e.setOptions(t);
  }
};
function mme(e) {
  var {
    options: t,
    onLoad: n,
    onUnmount: r
  } = e, o = ge(Tt), [i, a] = k(null);
  return h(() => {
    i !== null && i.setMap(o);
  }, [o]), h(() => {
    t && i !== null && i.setOptions(t);
  }, [i, t]), h(() => {
    var s = new google.maps.TrafficLayer(Ev(Ev({}, t), {}, {
      map: o
    }));
    return a(s), n && n(s), () => {
      i !== null && (r && r(i), i.setMap(null));
    };
  }, []), null;
}
ve(mme);
class vme extends pe {
  constructor() {
    super(...arguments), Ce(this, "state", {
      trafficLayer: null
    }), Ce(this, "setTrafficLayerCallback", () => {
      this.state.trafficLayer !== null && this.props.onLoad && this.props.onLoad(this.state.trafficLayer);
    }), Ce(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = new google.maps.TrafficLayer(Ev(Ev({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = an({
      updaterMap: kI,
      eventMap: EI,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        trafficLayer: t
      };
    }, this.setTrafficLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.trafficLayer !== null && (fn(this.registeredEvents), this.registeredEvents = an({
      updaterMap: kI,
      eventMap: EI,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.trafficLayer
    }));
  }
  componentWillUnmount() {
    this.state.trafficLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.trafficLayer), fn(this.registeredEvents), this.state.trafficLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Ce(vme, "contextType", Tt);
function yme(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = ge(Tt), [o, i] = k(null);
  return h(() => {
    o !== null && o.setMap(r);
  }, [r]), h(() => {
    var a = new google.maps.BicyclingLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      a !== null && (n && n(a), a.setMap(null));
    };
  }, []), null;
}
ve(yme);
class bme extends pe {
  constructor() {
    super(...arguments), Ce(this, "state", {
      bicyclingLayer: null
    }), Ce(this, "setBicyclingLayerCallback", () => {
      this.state.bicyclingLayer !== null && (this.state.bicyclingLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.bicyclingLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.BicyclingLayer();
    this.setState(() => ({
      bicyclingLayer: t
    }), this.setBicyclingLayerCallback);
  }
  componentWillUnmount() {
    this.state.bicyclingLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.bicyclingLayer), this.state.bicyclingLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Ce(bme, "contextType", Tt);
function wme(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = ge(Tt), [o, i] = k(null);
  return h(() => {
    o !== null && o.setMap(r);
  }, [r]), h(() => {
    var a = new google.maps.TransitLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      o !== null && (n && n(o), o.setMap(null));
    };
  }, []), null;
}
ve(wme);
class Cme extends pe {
  constructor() {
    super(...arguments), Ce(this, "state", {
      transitLayer: null
    }), Ce(this, "setTransitLayerCallback", () => {
      this.state.transitLayer !== null && (this.state.transitLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.transitLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.TransitLayer();
    this.setState(function() {
      return {
        transitLayer: t
      };
    }, this.setTransitLayerCallback);
  }
  componentWillUnmount() {
    this.state.transitLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.transitLayer), this.state.transitLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Ce(Cme, "contextType", Tt);
function LI(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function kv(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? LI(Object(n), !0).forEach(function(r) {
      Ce(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : LI(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var PI = {
  onCircleComplete: "circlecomplete",
  onMarkerComplete: "markercomplete",
  onOverlayComplete: "overlaycomplete",
  onPolygonComplete: "polygoncomplete",
  onPolylineComplete: "polylinecomplete",
  onRectangleComplete: "rectanglecomplete"
}, _I = {
  drawingMode(e, t) {
    e.setDrawingMode(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function xme(e) {
  var {
    options: t,
    drawingMode: n,
    onCircleComplete: r,
    onMarkerComplete: o,
    onOverlayComplete: i,
    onPolygonComplete: a,
    onPolylineComplete: s,
    onRectangleComplete: l,
    onLoad: u,
    onUnmount: c
  } = e, p = ge(Tt), [d, g] = k(null), [f, m] = k(null), [v, E] = k(null), [w, M] = k(null), [O, y] = k(null), [C, _] = k(null), [F, L] = k(null);
  return h(() => {
    d !== null && d.setMap(p);
  }, [p]), h(() => {
    t && d !== null && d.setOptions(t);
  }, [d, t]), h(() => {
    d !== null && d.setDrawingMode(n ?? null);
  }, [d, n]), h(() => {
    d && r && (f !== null && google.maps.event.removeListener(f), m(google.maps.event.addListener(d, "circlecomplete", r)));
  }, [d, r]), h(() => {
    d && o && (v !== null && google.maps.event.removeListener(v), E(google.maps.event.addListener(d, "markercomplete", o)));
  }, [d, o]), h(() => {
    d && i && (w !== null && google.maps.event.removeListener(w), M(google.maps.event.addListener(d, "overlaycomplete", i)));
  }, [d, i]), h(() => {
    d && a && (O !== null && google.maps.event.removeListener(O), y(google.maps.event.addListener(d, "polygoncomplete", a)));
  }, [d, a]), h(() => {
    d && s && (C !== null && google.maps.event.removeListener(C), _(google.maps.event.addListener(d, "polylinecomplete", s)));
  }, [d, s]), h(() => {
    d && l && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(d, "rectanglecomplete", l)));
  }, [d, l]), h(() => {
    yo(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
    var N = new google.maps.drawing.DrawingManager(kv(kv({}, t), {}, {
      map: p
    }));
    return n && N.setDrawingMode(n), r && m(google.maps.event.addListener(N, "circlecomplete", r)), o && E(google.maps.event.addListener(N, "markercomplete", o)), i && M(google.maps.event.addListener(N, "overlaycomplete", i)), a && y(google.maps.event.addListener(N, "polygoncomplete", a)), s && _(google.maps.event.addListener(N, "polylinecomplete", s)), l && L(google.maps.event.addListener(N, "rectanglecomplete", l)), g(N), u && u(N), () => {
      d !== null && (f && google.maps.event.removeListener(f), v && google.maps.event.removeListener(v), w && google.maps.event.removeListener(w), O && google.maps.event.removeListener(O), C && google.maps.event.removeListener(C), F && google.maps.event.removeListener(F), c && c(d), d.setMap(null));
    };
  }, []), null;
}
ve(xme);
class Ome extends pe {
  constructor(t) {
    super(t), Ce(this, "registeredEvents", []), Ce(this, "state", {
      drawingManager: null
    }), Ce(this, "setDrawingManagerCallback", () => {
      this.state.drawingManager !== null && this.props.onLoad && this.props.onLoad(this.state.drawingManager);
    }), yo(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
  }
  componentDidMount() {
    var t = new google.maps.drawing.DrawingManager(kv(kv({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = an({
      updaterMap: _I,
      eventMap: PI,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        drawingManager: t
      };
    }, this.setDrawingManagerCallback);
  }
  componentDidUpdate(t) {
    this.state.drawingManager !== null && (fn(this.registeredEvents), this.registeredEvents = an({
      updaterMap: _I,
      eventMap: PI,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.drawingManager
    }));
  }
  componentWillUnmount() {
    this.state.drawingManager !== null && (this.props.onUnmount && this.props.onUnmount(this.state.drawingManager), fn(this.registeredEvents), this.state.drawingManager.setMap(null));
  }
  render() {
    return null;
  }
}
Ce(Ome, "contextType", Tt);
function SI(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function rc(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? SI(Object(n), !0).forEach(function(r) {
      Ce(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : SI(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var MI = {
  onAnimationChanged: "animation_changed",
  onClick: "click",
  onClickableChanged: "clickable_changed",
  onCursorChanged: "cursor_changed",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDraggableChanged: "draggable_changed",
  onDragStart: "dragstart",
  onFlatChanged: "flat_changed",
  onIconChanged: "icon_changed",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onPositionChanged: "position_changed",
  onRightClick: "rightclick",
  onShapeChanged: "shape_changed",
  onTitleChanged: "title_changed",
  onVisibleChanged: "visible_changed",
  onZindexChanged: "zindex_changed"
}, DI = {
  animation(e, t) {
    e.setAnimation(t);
  },
  clickable(e, t) {
    e.setClickable(t);
  },
  cursor(e, t) {
    e.setCursor(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  icon(e, t) {
    e.setIcon(t);
  },
  label(e, t) {
    e.setLabel(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  opacity(e, t) {
    e.setOpacity(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  shape(e, t) {
    e.setShape(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, Lv = {};
function Eme(e) {
  var {
    position: t,
    options: n,
    clusterer: r,
    noClustererRedraw: o,
    children: i,
    draggable: a,
    visible: s,
    animation: l,
    clickable: u,
    cursor: c,
    icon: p,
    label: d,
    opacity: g,
    shape: f,
    title: m,
    zIndex: v,
    onClick: E,
    onDblClick: w,
    onDrag: M,
    onDragEnd: O,
    onDragStart: y,
    onMouseOut: C,
    onMouseOver: _,
    onMouseUp: F,
    onMouseDown: L,
    onRightClick: N,
    onClickableChanged: R,
    onCursorChanged: W,
    onAnimationChanged: V,
    onDraggableChanged: z,
    onFlatChanged: Z,
    onIconChanged: K,
    onPositionChanged: X,
    onShapeChanged: te,
    onTitleChanged: J,
    onVisibleChanged: P,
    onZindexChanged: D,
    onLoad: H,
    onUnmount: S
  } = e, $ = ge(Tt), [x, j] = k(null), [U, T] = k(null), [q, A] = k(null), [Y, B] = k(null), [ue, fe] = k(null), [oe, Ae] = k(null), [Ze, Ge] = k(null), [Ie, et] = k(null), [Ye, _e] = k(null), [Qe, at] = k(null), [Pe, Me] = k(null), [Je, We] = k(null), [Re, nt] = k(null), [De, yt] = k(null), [ot, st] = k(null), [ct, bt] = k(null), [pt, dt] = k(null), [tt, Xe] = k(null), [wt, Ct] = k(null), [ft, bn] = k(null), [ht, wn] = k(null), [gt, Mt] = k(null);
  h(() => {
    x !== null && x.setMap($);
  }, [$]), h(() => {
    typeof n < "u" && x !== null && x.setOptions(n);
  }, [x, n]), h(() => {
    typeof a < "u" && x !== null && x.setDraggable(a);
  }, [x, a]), h(() => {
    t && x !== null && x.setPosition(t);
  }, [x, t]), h(() => {
    typeof s < "u" && x !== null && x.setVisible(s);
  }, [x, s]), h(() => {
    x == null || x.setAnimation(l);
  }, [x, l]), h(() => {
    x && u !== void 0 && x.setClickable(u);
  }, [x, u]), h(() => {
    x && c !== void 0 && x.setCursor(c);
  }, [x, c]), h(() => {
    x && p !== void 0 && x.setIcon(p);
  }, [x, p]), h(() => {
    x && d !== void 0 && x.setLabel(d);
  }, [x, d]), h(() => {
    x && g !== void 0 && x.setOpacity(g);
  }, [x, g]), h(() => {
    x && f !== void 0 && x.setShape(f);
  }, [x, f]), h(() => {
    x && m !== void 0 && x.setTitle(m);
  }, [x, m]), h(() => {
    x && v !== void 0 && x.setZIndex(v);
  }, [x, v]), h(() => {
    x && w && (U !== null && google.maps.event.removeListener(U), T(google.maps.event.addListener(x, "dblclick", w)));
  }, [w]), h(() => {
    x && O && (q !== null && google.maps.event.removeListener(q), A(google.maps.event.addListener(x, "dragend", O)));
  }, [O]), h(() => {
    x && y && (Y !== null && google.maps.event.removeListener(Y), B(google.maps.event.addListener(x, "dragstart", y)));
  }, [y]), h(() => {
    x && L && (ue !== null && google.maps.event.removeListener(ue), fe(google.maps.event.addListener(x, "mousedown", L)));
  }, [L]), h(() => {
    x && C && (oe !== null && google.maps.event.removeListener(oe), Ae(google.maps.event.addListener(x, "mouseout", C)));
  }, [C]), h(() => {
    x && _ && (Ze !== null && google.maps.event.removeListener(Ze), Ge(google.maps.event.addListener(x, "mouseover", _)));
  }, [_]), h(() => {
    x && F && (Ie !== null && google.maps.event.removeListener(Ie), et(google.maps.event.addListener(x, "mouseup", F)));
  }, [F]), h(() => {
    x && N && (Ye !== null && google.maps.event.removeListener(Ye), _e(google.maps.event.addListener(x, "rightclick", N)));
  }, [N]), h(() => {
    x && E && (Qe !== null && google.maps.event.removeListener(Qe), at(google.maps.event.addListener(x, "click", E)));
  }, [E]), h(() => {
    x && M && (Pe !== null && google.maps.event.removeListener(Pe), Me(google.maps.event.addListener(x, "drag", M)));
  }, [M]), h(() => {
    x && R && (Je !== null && google.maps.event.removeListener(Je), We(google.maps.event.addListener(x, "clickable_changed", R)));
  }, [R]), h(() => {
    x && W && (Re !== null && google.maps.event.removeListener(Re), nt(google.maps.event.addListener(x, "cursor_changed", W)));
  }, [W]), h(() => {
    x && V && (De !== null && google.maps.event.removeListener(De), yt(google.maps.event.addListener(x, "animation_changed", V)));
  }, [V]), h(() => {
    x && z && (ot !== null && google.maps.event.removeListener(ot), st(google.maps.event.addListener(x, "draggable_changed", z)));
  }, [z]), h(() => {
    x && Z && (ct !== null && google.maps.event.removeListener(ct), bt(google.maps.event.addListener(x, "flat_changed", Z)));
  }, [Z]), h(() => {
    x && K && (pt !== null && google.maps.event.removeListener(pt), dt(google.maps.event.addListener(x, "icon_changed", K)));
  }, [K]), h(() => {
    x && X && (tt !== null && google.maps.event.removeListener(tt), Xe(google.maps.event.addListener(x, "position_changed", X)));
  }, [X]), h(() => {
    x && te && (wt !== null && google.maps.event.removeListener(wt), Ct(google.maps.event.addListener(x, "shape_changed", te)));
  }, [te]), h(() => {
    x && J && (ft !== null && google.maps.event.removeListener(ft), bn(google.maps.event.addListener(x, "title_changed", J)));
  }, [J]), h(() => {
    x && P && (ht !== null && google.maps.event.removeListener(ht), wn(google.maps.event.addListener(x, "visible_changed", P)));
  }, [P]), h(() => {
    x && D && (gt !== null && google.maps.event.removeListener(gt), Mt(google.maps.event.addListener(x, "zindex_changed", D)));
  }, [D]), h(() => {
    var mt = rc(rc(rc({}, n || Lv), r ? Lv : {
      map: $
    }), {}, {
      position: t
    }), re = new google.maps.Marker(mt);
    return r ? r.addMarker(re, !!o) : re.setMap($), t && re.setPosition(t), typeof s < "u" && re.setVisible(s), typeof a < "u" && re.setDraggable(a), typeof u < "u" && re.setClickable(u), typeof c == "string" && re.setCursor(c), p && re.setIcon(p), typeof d < "u" && re.setLabel(d), typeof g < "u" && re.setOpacity(g), f && re.setShape(f), typeof m == "string" && re.setTitle(m), typeof v == "number" && re.setZIndex(v), w && T(google.maps.event.addListener(re, "dblclick", w)), O && A(google.maps.event.addListener(re, "dragend", O)), y && B(google.maps.event.addListener(re, "dragstart", y)), L && fe(google.maps.event.addListener(re, "mousedown", L)), C && Ae(google.maps.event.addListener(re, "mouseout", C)), _ && Ge(google.maps.event.addListener(re, "mouseover", _)), F && et(google.maps.event.addListener(re, "mouseup", F)), N && _e(google.maps.event.addListener(re, "rightclick", N)), E && at(google.maps.event.addListener(re, "click", E)), M && Me(google.maps.event.addListener(re, "drag", M)), R && We(google.maps.event.addListener(re, "clickable_changed", R)), W && nt(google.maps.event.addListener(re, "cursor_changed", W)), V && yt(google.maps.event.addListener(re, "animation_changed", V)), z && st(google.maps.event.addListener(re, "draggable_changed", z)), Z && bt(google.maps.event.addListener(re, "flat_changed", Z)), K && dt(google.maps.event.addListener(re, "icon_changed", K)), X && Xe(google.maps.event.addListener(re, "position_changed", X)), te && Ct(google.maps.event.addListener(re, "shape_changed", te)), J && bn(google.maps.event.addListener(re, "title_changed", J)), P && wn(google.maps.event.addListener(re, "visible_changed", P)), D && Mt(google.maps.event.addListener(re, "zindex_changed", D)), j(re), H && H(re), () => {
      U !== null && google.maps.event.removeListener(U), q !== null && google.maps.event.removeListener(q), Y !== null && google.maps.event.removeListener(Y), ue !== null && google.maps.event.removeListener(ue), oe !== null && google.maps.event.removeListener(oe), Ze !== null && google.maps.event.removeListener(Ze), Ie !== null && google.maps.event.removeListener(Ie), Ye !== null && google.maps.event.removeListener(Ye), Qe !== null && google.maps.event.removeListener(Qe), Je !== null && google.maps.event.removeListener(Je), Re !== null && google.maps.event.removeListener(Re), De !== null && google.maps.event.removeListener(De), ot !== null && google.maps.event.removeListener(ot), ct !== null && google.maps.event.removeListener(ct), pt !== null && google.maps.event.removeListener(pt), tt !== null && google.maps.event.removeListener(tt), ft !== null && google.maps.event.removeListener(ft), ht !== null && google.maps.event.removeListener(ht), gt !== null && google.maps.event.removeListener(gt), S && S(re), r ? r.removeMarker(re, !!o) : re && re.setMap(null);
    };
  }, []);
  var ir = Cn(() => i ? lt.map(i, (mt) => {
    if (!yi(mt))
      return mt;
    var re = mt;
    return bi(re, {
      anchor: x
    });
  }) : null, [i, x]);
  return Do.jsx(Do.Fragment, {
    children: ir
  }) || null;
}
ve(Eme);
class kme extends pe {
  constructor() {
    super(...arguments), Ce(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this;
    return aZ(function* () {
      var n = rc(rc(rc({}, t.props.options || Lv), t.props.clusterer ? Lv : {
        map: t.context
      }), {}, {
        position: t.props.position
      });
      t.marker = new google.maps.Marker(n), t.props.clusterer ? t.props.clusterer.addMarker(t.marker, !!t.props.noClustererRedraw) : t.marker.setMap(t.context), t.registeredEvents = an({
        updaterMap: DI,
        eventMap: MI,
        prevProps: {},
        nextProps: t.props,
        instance: t.marker
      }), t.props.onLoad && t.props.onLoad(t.marker);
    })();
  }
  componentDidUpdate(t) {
    this.marker && (fn(this.registeredEvents), this.registeredEvents = an({
      updaterMap: DI,
      eventMap: MI,
      prevProps: t,
      nextProps: this.props,
      instance: this.marker
    }));
  }
  componentWillUnmount() {
    this.marker && (this.props.onUnmount && this.props.onUnmount(this.marker), fn(this.registeredEvents), this.props.clusterer ? this.props.clusterer.removeMarker(this.marker, !!this.props.noClustererRedraw) : this.marker && this.marker.setMap(null));
  }
  render() {
    var t = this.props.children ? lt.map(this.props.children, (n) => {
      if (!yi(n))
        return n;
      var r = n;
      return bi(r, {
        anchor: this.marker
      });
    }) : null;
    return t || null;
  }
}
Ce(kme, "contextType", Tt);
var Lme = (
  /** @class */
  function() {
    function e(t, n) {
      t.getClusterer().extend(e, google.maps.OverlayView), this.cluster = t, this.clusterClassName = this.cluster.getClusterer().getClusterClass(), this.className = this.clusterClassName, this.styles = n, this.center = void 0, this.div = null, this.sums = null, this.visible = !1, this.boundsChangedListener = null, this.url = "", this.height = 0, this.width = 0, this.anchorText = [0, 0], this.anchorIcon = [0, 0], this.textColor = "black", this.textSize = 11, this.textDecoration = "none", this.fontWeight = "bold", this.fontStyle = "normal", this.fontFamily = "Arial,sans-serif", this.backgroundPosition = "0 0", this.cMouseDownInCluster = null, this.cDraggingMapByCluster = null, this.timeOut = null, this.setMap(t.getMap()), this.onBoundsChanged = this.onBoundsChanged.bind(this), this.onMouseDown = this.onMouseDown.bind(this), this.onClick = this.onClick.bind(this), this.onMouseOver = this.onMouseOver.bind(this), this.onMouseOut = this.onMouseOut.bind(this), this.onAdd = this.onAdd.bind(this), this.onRemove = this.onRemove.bind(this), this.draw = this.draw.bind(this), this.hide = this.hide.bind(this), this.show = this.show.bind(this), this.useStyle = this.useStyle.bind(this), this.setCenter = this.setCenter.bind(this), this.getPosFromLatLng = this.getPosFromLatLng.bind(this);
    }
    return e.prototype.onBoundsChanged = function() {
      this.cDraggingMapByCluster = this.cMouseDownInCluster;
    }, e.prototype.onMouseDown = function() {
      this.cMouseDownInCluster = !0, this.cDraggingMapByCluster = !1;
    }, e.prototype.onClick = function(t) {
      if (this.cMouseDownInCluster = !1, !this.cDraggingMapByCluster) {
        var n = this.cluster.getClusterer();
        if (google.maps.event.trigger(n, "click", this.cluster), google.maps.event.trigger(n, "clusterclick", this.cluster), n.getZoomOnClick()) {
          var r = n.getMaxZoom(), o = this.cluster.getBounds(), i = n.getMap();
          i !== null && "fitBounds" in i && i.fitBounds(o), this.timeOut = window.setTimeout(function() {
            var a = n.getMap();
            if (a !== null) {
              "fitBounds" in a && a.fitBounds(o);
              var s = a.getZoom() || 0;
              r !== null && s > r && a.setZoom(r + 1);
            }
          }, 100);
        }
        t.cancelBubble = !0, t.stopPropagation && t.stopPropagation();
      }
    }, e.prototype.onMouseOver = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseover", this.cluster);
    }, e.prototype.onMouseOut = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseout", this.cluster);
    }, e.prototype.onAdd = function() {
      var t;
      this.div = document.createElement("div"), this.div.className = this.className, this.visible && this.show(), (t = this.getPanes()) === null || t === void 0 || t.overlayMouseTarget.appendChild(this.div);
      var n = this.getMap();
      n !== null && (this.boundsChangedListener = google.maps.event.addListener(n, "bounds_changed", this.onBoundsChanged), this.div.addEventListener("mousedown", this.onMouseDown), this.div.addEventListener("click", this.onClick), this.div.addEventListener("mouseover", this.onMouseOver), this.div.addEventListener("mouseout", this.onMouseOut));
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.hide(), this.boundsChangedListener !== null && google.maps.event.removeListener(this.boundsChangedListener), this.div.removeEventListener("mousedown", this.onMouseDown), this.div.removeEventListener("click", this.onClick), this.div.removeEventListener("mouseover", this.onMouseOver), this.div.removeEventListener("mouseout", this.onMouseOut), this.div.parentNode.removeChild(this.div), this.timeOut !== null && (window.clearTimeout(this.timeOut), this.timeOut = null), this.div = null);
    }, e.prototype.draw = function() {
      if (this.visible && this.div !== null && this.center) {
        var t = this.getPosFromLatLng(this.center);
        this.div.style.top = t !== null ? "".concat(t.y, "px") : "0", this.div.style.left = t !== null ? "".concat(t.x, "px") : "0";
      }
    }, e.prototype.hide = function() {
      this.div && (this.div.style.display = "none"), this.visible = !1;
    }, e.prototype.show = function() {
      var t, n, r, o, i, a;
      if (this.div && this.center) {
        var s = this.sums === null || typeof this.sums.title > "u" || this.sums.title === "" ? this.cluster.getClusterer().getTitle() : this.sums.title, l = this.backgroundPosition.split(" "), u = parseInt(((t = l[0]) === null || t === void 0 ? void 0 : t.replace(/^\s+|\s+$/g, "")) || "0", 10), c = parseInt(((n = l[1]) === null || n === void 0 ? void 0 : n.replace(/^\s+|\s+$/g, "")) || "0", 10), p = this.getPosFromLatLng(this.center);
        this.div.className = this.className, this.div.setAttribute("style", "cursor: pointer; position: absolute; top: ".concat(p !== null ? "".concat(p.y, "px") : "0", "; left: ").concat(p !== null ? "".concat(p.x, "px") : "0", "; width: ").concat(this.width, "px; height: ").concat(this.height, "px; "));
        var d = document.createElement("img");
        d.alt = s, d.src = this.url, d.width = this.width, d.height = this.height, d.setAttribute("style", "position: absolute; top: ".concat(c, "px; left: ").concat(u, "px")), this.cluster.getClusterer().enableRetinaIcons || (d.style.clip = "rect(-".concat(c, "px, -").concat(u + this.width, "px, -").concat(c + this.height, ", -").concat(u, ")"));
        var g = document.createElement("div");
        g.setAttribute("style", "position: absolute; top: ".concat(this.anchorText[0], "px; left: ").concat(this.anchorText[1], "px; color: ").concat(this.textColor, "; font-size: ").concat(this.textSize, "px; font-family: ").concat(this.fontFamily, "; font-weight: ").concat(this.fontWeight, "; fontStyle: ").concat(this.fontStyle, "; text-decoration: ").concat(this.textDecoration, "; text-align: center; width: ").concat(this.width, "px; line-height: ").concat(this.height, "px")), !((r = this.sums) === null || r === void 0) && r.text && (g.innerText = "".concat((o = this.sums) === null || o === void 0 ? void 0 : o.text)), !((i = this.sums) === null || i === void 0) && i.html && (g.innerHTML = "".concat((a = this.sums) === null || a === void 0 ? void 0 : a.html)), this.div.innerHTML = "", this.div.appendChild(d), this.div.appendChild(g), this.div.title = s, this.div.style.display = "";
      }
      this.visible = !0;
    }, e.prototype.useStyle = function(t) {
      this.sums = t;
      var n = this.cluster.getClusterer().getStyles(), r = n[Math.min(n.length - 1, Math.max(0, t.index - 1))];
      r && (this.url = r.url, this.height = r.height, this.width = r.width, r.className && (this.className = "".concat(this.clusterClassName, " ").concat(r.className)), this.anchorText = r.anchorText || [0, 0], this.anchorIcon = r.anchorIcon || [this.height / 2, this.width / 2], this.textColor = r.textColor || "black", this.textSize = r.textSize || 11, this.textDecoration = r.textDecoration || "none", this.fontWeight = r.fontWeight || "bold", this.fontStyle = r.fontStyle || "normal", this.fontFamily = r.fontFamily || "Arial,sans-serif", this.backgroundPosition = r.backgroundPosition || "0 0");
    }, e.prototype.setCenter = function(t) {
      this.center = t;
    }, e.prototype.getPosFromLatLng = function(t) {
      var n = this.getProjection().fromLatLngToDivPixel(t);
      return n !== null && (n.x -= this.anchorIcon[1], n.y -= this.anchorIcon[0]), n;
    }, e;
  }()
), Pme = (
  /** @class */
  function() {
    function e(t) {
      this.markerClusterer = t, this.map = this.markerClusterer.getMap(), this.gridSize = this.markerClusterer.getGridSize(), this.minClusterSize = this.markerClusterer.getMinimumClusterSize(), this.averageCenter = this.markerClusterer.getAverageCenter(), this.markers = [], this.center = void 0, this.bounds = null, this.clusterIcon = new Lme(this, this.markerClusterer.getStyles()), this.getSize = this.getSize.bind(this), this.getMarkers = this.getMarkers.bind(this), this.getCenter = this.getCenter.bind(this), this.getMap = this.getMap.bind(this), this.getClusterer = this.getClusterer.bind(this), this.getBounds = this.getBounds.bind(this), this.remove = this.remove.bind(this), this.addMarker = this.addMarker.bind(this), this.isMarkerInClusterBounds = this.isMarkerInClusterBounds.bind(this), this.calculateBounds = this.calculateBounds.bind(this), this.updateIcon = this.updateIcon.bind(this), this.isMarkerAlreadyAdded = this.isMarkerAlreadyAdded.bind(this);
    }
    return e.prototype.getSize = function() {
      return this.markers.length;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getCenter = function() {
      return this.center;
    }, e.prototype.getMap = function() {
      return this.map;
    }, e.prototype.getClusterer = function() {
      return this.markerClusterer;
    }, e.prototype.getBounds = function() {
      for (var t = new google.maps.LatLngBounds(this.center, this.center), n = this.getMarkers(), r = 0, o = n; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && t.extend(a);
      }
      return t;
    }, e.prototype.remove = function() {
      this.clusterIcon.setMap(null), this.markers = [], delete this.markers;
    }, e.prototype.addMarker = function(t) {
      var n;
      if (this.isMarkerAlreadyAdded(t))
        return !1;
      if (this.center) {
        if (this.averageCenter) {
          var r = t.getPosition();
          if (r) {
            var o = this.markers.length + 1;
            this.center = new google.maps.LatLng((this.center.lat() * (o - 1) + r.lat()) / o, (this.center.lng() * (o - 1) + r.lng()) / o), this.calculateBounds();
          }
        }
      } else {
        var r = t.getPosition();
        r && (this.center = r, this.calculateBounds());
      }
      t.isAdded = !0, this.markers.push(t);
      var i = this.markers.length, a = this.markerClusterer.getMaxZoom(), s = (n = this.map) === null || n === void 0 ? void 0 : n.getZoom();
      if (a !== null && typeof s < "u" && s > a)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i < this.minClusterSize)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i === this.minClusterSize)
        for (var l = 0, u = this.markers; l < u.length; l++) {
          var c = u[l];
          c.setMap(null);
        }
      else
        t.setMap(null);
      return !0;
    }, e.prototype.isMarkerInClusterBounds = function(t) {
      if (this.bounds !== null) {
        var n = t.getPosition();
        if (n)
          return this.bounds.contains(n);
      }
      return !1;
    }, e.prototype.calculateBounds = function() {
      this.bounds = this.markerClusterer.getExtendedBounds(new google.maps.LatLngBounds(this.center, this.center));
    }, e.prototype.updateIcon = function() {
      var t, n = this.markers.length, r = this.markerClusterer.getMaxZoom(), o = (t = this.map) === null || t === void 0 ? void 0 : t.getZoom();
      if (r !== null && typeof o < "u" && o > r) {
        this.clusterIcon.hide();
        return;
      }
      if (n < this.minClusterSize) {
        this.clusterIcon.hide();
        return;
      }
      this.center && this.clusterIcon.setCenter(this.center), this.clusterIcon.useStyle(this.markerClusterer.getCalculator()(this.markers, this.markerClusterer.getStyles().length)), this.clusterIcon.show();
    }, e.prototype.isMarkerAlreadyAdded = function(t) {
      if (this.markers.includes)
        return this.markers.includes(t);
      for (var n = 0; n < this.markers.length; n++)
        if (t === this.markers[n])
          return !0;
      return !1;
    }, e;
  }()
);
function _me(e, t) {
  var n = e.length, r = n.toString().length, o = Math.min(r, t);
  return {
    text: n.toString(),
    index: o,
    title: ""
  };
}
var Sme = 2e3, Mme = 500, Dme = "https://developers.google.com/maps/documentation/javascript/examples/markerclusterer/m", Tme = "png", jme = [53, 56, 66, 78, 90], Ame = "cluster", dZ = (
  /** @class */
  function() {
    function e(t, n, r) {
      n === void 0 && (n = []), r === void 0 && (r = {}), this.getMinimumClusterSize = this.getMinimumClusterSize.bind(this), this.setMinimumClusterSize = this.setMinimumClusterSize.bind(this), this.getEnableRetinaIcons = this.getEnableRetinaIcons.bind(this), this.setEnableRetinaIcons = this.setEnableRetinaIcons.bind(this), this.addToClosestCluster = this.addToClosestCluster.bind(this), this.getImageExtension = this.getImageExtension.bind(this), this.setImageExtension = this.setImageExtension.bind(this), this.getExtendedBounds = this.getExtendedBounds.bind(this), this.getAverageCenter = this.getAverageCenter.bind(this), this.setAverageCenter = this.setAverageCenter.bind(this), this.getTotalClusters = this.getTotalClusters.bind(this), this.fitMapToMarkers = this.fitMapToMarkers.bind(this), this.getIgnoreHidden = this.getIgnoreHidden.bind(this), this.setIgnoreHidden = this.setIgnoreHidden.bind(this), this.getClusterClass = this.getClusterClass.bind(this), this.setClusterClass = this.setClusterClass.bind(this), this.getTotalMarkers = this.getTotalMarkers.bind(this), this.getZoomOnClick = this.getZoomOnClick.bind(this), this.setZoomOnClick = this.setZoomOnClick.bind(this), this.getBatchSizeIE = this.getBatchSizeIE.bind(this), this.setBatchSizeIE = this.setBatchSizeIE.bind(this), this.createClusters = this.createClusters.bind(this), this.onZoomChanged = this.onZoomChanged.bind(this), this.getImageSizes = this.getImageSizes.bind(this), this.setImageSizes = this.setImageSizes.bind(this), this.getCalculator = this.getCalculator.bind(this), this.setCalculator = this.setCalculator.bind(this), this.removeMarkers = this.removeMarkers.bind(this), this.resetViewport = this.resetViewport.bind(this), this.getImagePath = this.getImagePath.bind(this), this.setImagePath = this.setImagePath.bind(this), this.pushMarkerTo = this.pushMarkerTo.bind(this), this.removeMarker = this.removeMarker.bind(this), this.clearMarkers = this.clearMarkers.bind(this), this.setupStyles = this.setupStyles.bind(this), this.getGridSize = this.getGridSize.bind(this), this.setGridSize = this.setGridSize.bind(this), this.getClusters = this.getClusters.bind(this), this.getMaxZoom = this.getMaxZoom.bind(this), this.setMaxZoom = this.setMaxZoom.bind(this), this.getMarkers = this.getMarkers.bind(this), this.addMarkers = this.addMarkers.bind(this), this.getStyles = this.getStyles.bind(this), this.setStyles = this.setStyles.bind(this), this.addMarker = this.addMarker.bind(this), this.onRemove = this.onRemove.bind(this), this.getTitle = this.getTitle.bind(this), this.setTitle = this.setTitle.bind(this), this.repaint = this.repaint.bind(this), this.onIdle = this.onIdle.bind(this), this.redraw = this.redraw.bind(this), this.onAdd = this.onAdd.bind(this), this.draw = this.draw.bind(this), this.extend = this.extend.bind(this), this.extend(e, google.maps.OverlayView), this.markers = [], this.clusters = [], this.listeners = [], this.activeMap = null, this.ready = !1, this.gridSize = r.gridSize || 60, this.minClusterSize = r.minimumClusterSize || 2, this.maxZoom = r.maxZoom || null, this.styles = r.styles || [], this.title = r.title || "", this.zoomOnClick = !0, r.zoomOnClick !== void 0 && (this.zoomOnClick = r.zoomOnClick), this.averageCenter = !1, r.averageCenter !== void 0 && (this.averageCenter = r.averageCenter), this.ignoreHidden = !1, r.ignoreHidden !== void 0 && (this.ignoreHidden = r.ignoreHidden), this.enableRetinaIcons = !1, r.enableRetinaIcons !== void 0 && (this.enableRetinaIcons = r.enableRetinaIcons), this.imagePath = r.imagePath || Dme, this.imageExtension = r.imageExtension || Tme, this.imageSizes = r.imageSizes || jme, this.calculator = r.calculator || _me, this.batchSize = r.batchSize || Sme, this.batchSizeIE = r.batchSizeIE || Mme, this.clusterClass = r.clusterClass || Ame, navigator.userAgent.toLowerCase().indexOf("msie") !== -1 && (this.batchSize = this.batchSizeIE), this.timerRefStatic = null, this.setupStyles(), this.addMarkers(n, !0), this.setMap(t);
    }
    return e.prototype.onZoomChanged = function() {
      var t, n;
      this.resetViewport(!1), (((t = this.getMap()) === null || t === void 0 ? void 0 : t.getZoom()) === (this.get("minZoom") || 0) || ((n = this.getMap()) === null || n === void 0 ? void 0 : n.getZoom()) === this.get("maxZoom")) && google.maps.event.trigger(this, "idle");
    }, e.prototype.onIdle = function() {
      this.redraw();
    }, e.prototype.onAdd = function() {
      var t = this.getMap();
      this.activeMap = t, this.ready = !0, this.repaint(), t !== null && (this.listeners = [google.maps.event.addListener(t, "zoom_changed", this.onZoomChanged), google.maps.event.addListener(t, "idle", this.onIdle)]);
    }, e.prototype.onRemove = function() {
      for (var t = 0, n = this.markers; t < n.length; t++) {
        var r = n[t];
        r.getMap() !== this.activeMap && r.setMap(this.activeMap);
      }
      for (var o = 0, i = this.clusters; o < i.length; o++) {
        var a = i[o];
        a.remove();
      }
      this.clusters = [];
      for (var s = 0, l = this.listeners; s < l.length; s++) {
        var u = l[s];
        google.maps.event.removeListener(u);
      }
      this.listeners = [], this.activeMap = null, this.ready = !1;
    }, e.prototype.draw = function() {
    }, e.prototype.getMap = function() {
      return null;
    }, e.prototype.getPanes = function() {
      return null;
    }, e.prototype.getProjection = function() {
      return {
        fromContainerPixelToLatLng: function() {
          return null;
        },
        fromDivPixelToLatLng: function() {
          return null;
        },
        fromLatLngToContainerPixel: function() {
          return null;
        },
        fromLatLngToDivPixel: function() {
          return null;
        },
        getVisibleRegion: function() {
          return null;
        },
        getWorldWidth: function() {
          return 0;
        }
      };
    }, e.prototype.setMap = function() {
    }, e.prototype.addListener = function() {
      return {
        remove: function() {
        }
      };
    }, e.prototype.bindTo = function() {
    }, e.prototype.get = function() {
    }, e.prototype.notify = function() {
    }, e.prototype.set = function() {
    }, e.prototype.setValues = function() {
    }, e.prototype.unbind = function() {
    }, e.prototype.unbindAll = function() {
    }, e.prototype.setupStyles = function() {
      if (!(this.styles.length > 0))
        for (var t = 0; t < this.imageSizes.length; t++)
          this.styles.push({
            url: "".concat(this.imagePath + (t + 1), ".").concat(this.imageExtension),
            height: this.imageSizes[t] || 0,
            width: this.imageSizes[t] || 0
          });
    }, e.prototype.fitMapToMarkers = function() {
      for (var t = this.getMarkers(), n = new google.maps.LatLngBounds(), r = 0, o = t; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && n.extend(a);
      }
      var s = this.getMap();
      s !== null && "fitBounds" in s && s.fitBounds(n);
    }, e.prototype.getGridSize = function() {
      return this.gridSize;
    }, e.prototype.setGridSize = function(t) {
      this.gridSize = t;
    }, e.prototype.getMinimumClusterSize = function() {
      return this.minClusterSize;
    }, e.prototype.setMinimumClusterSize = function(t) {
      this.minClusterSize = t;
    }, e.prototype.getMaxZoom = function() {
      return this.maxZoom;
    }, e.prototype.setMaxZoom = function(t) {
      this.maxZoom = t;
    }, e.prototype.getStyles = function() {
      return this.styles;
    }, e.prototype.setStyles = function(t) {
      this.styles = t;
    }, e.prototype.getTitle = function() {
      return this.title;
    }, e.prototype.setTitle = function(t) {
      this.title = t;
    }, e.prototype.getZoomOnClick = function() {
      return this.zoomOnClick;
    }, e.prototype.setZoomOnClick = function(t) {
      this.zoomOnClick = t;
    }, e.prototype.getAverageCenter = function() {
      return this.averageCenter;
    }, e.prototype.setAverageCenter = function(t) {
      this.averageCenter = t;
    }, e.prototype.getIgnoreHidden = function() {
      return this.ignoreHidden;
    }, e.prototype.setIgnoreHidden = function(t) {
      this.ignoreHidden = t;
    }, e.prototype.getEnableRetinaIcons = function() {
      return this.enableRetinaIcons;
    }, e.prototype.setEnableRetinaIcons = function(t) {
      this.enableRetinaIcons = t;
    }, e.prototype.getImageExtension = function() {
      return this.imageExtension;
    }, e.prototype.setImageExtension = function(t) {
      this.imageExtension = t;
    }, e.prototype.getImagePath = function() {
      return this.imagePath;
    }, e.prototype.setImagePath = function(t) {
      this.imagePath = t;
    }, e.prototype.getImageSizes = function() {
      return this.imageSizes;
    }, e.prototype.setImageSizes = function(t) {
      this.imageSizes = t;
    }, e.prototype.getCalculator = function() {
      return this.calculator;
    }, e.prototype.setCalculator = function(t) {
      this.calculator = t;
    }, e.prototype.getBatchSizeIE = function() {
      return this.batchSizeIE;
    }, e.prototype.setBatchSizeIE = function(t) {
      this.batchSizeIE = t;
    }, e.prototype.getClusterClass = function() {
      return this.clusterClass;
    }, e.prototype.setClusterClass = function(t) {
      this.clusterClass = t;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getTotalMarkers = function() {
      return this.markers.length;
    }, e.prototype.getClusters = function() {
      return this.clusters;
    }, e.prototype.getTotalClusters = function() {
      return this.clusters.length;
    }, e.prototype.addMarker = function(t, n) {
      this.pushMarkerTo(t), n || this.redraw();
    }, e.prototype.addMarkers = function(t, n) {
      for (var r in t)
        if (Object.prototype.hasOwnProperty.call(t, r)) {
          var o = t[r];
          o && this.pushMarkerTo(o);
        }
      n || this.redraw();
    }, e.prototype.pushMarkerTo = function(t) {
      var n = this;
      t.getDraggable() && google.maps.event.addListener(t, "dragend", function() {
        n.ready && (t.isAdded = !1, n.repaint());
      }), t.isAdded = !1, this.markers.push(t);
    }, e.prototype.removeMarker_ = function(t) {
      var n = -1;
      if (this.markers.indexOf)
        n = this.markers.indexOf(t);
      else
        for (var r = 0; r < this.markers.length; r++)
          if (t === this.markers[r]) {
            n = r;
            break;
          }
      return n === -1 ? !1 : (t.setMap(null), this.markers.splice(n, 1), !0);
    }, e.prototype.removeMarker = function(t, n) {
      var r = this.removeMarker_(t);
      return !n && r && this.repaint(), r;
    }, e.prototype.removeMarkers = function(t, n) {
      for (var r = !1, o = 0, i = t; o < i.length; o++) {
        var a = i[o];
        r = r || this.removeMarker_(a);
      }
      return !n && r && this.repaint(), r;
    }, e.prototype.clearMarkers = function() {
      this.resetViewport(!0), this.markers = [];
    }, e.prototype.repaint = function() {
      var t = this.clusters.slice();
      this.clusters = [], this.resetViewport(!1), this.redraw(), setTimeout(function() {
        for (var n = 0, r = t; n < r.length; n++) {
          var o = r[n];
          o.remove();
        }
      }, 0);
    }, e.prototype.getExtendedBounds = function(t) {
      var n = this.getProjection(), r = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getNorthEast().lat(), t.getNorthEast().lng())
      );
      r !== null && (r.x += this.gridSize, r.y -= this.gridSize);
      var o = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getSouthWest().lat(), t.getSouthWest().lng())
      );
      if (o !== null && (o.x -= this.gridSize, o.y += this.gridSize), r !== null) {
        var i = n.fromDivPixelToLatLng(r);
        i !== null && t.extend(i);
      }
      if (o !== null) {
        var a = n.fromDivPixelToLatLng(o);
        a !== null && t.extend(a);
      }
      return t;
    }, e.prototype.redraw = function() {
      this.createClusters(0);
    }, e.prototype.resetViewport = function(t) {
      for (var n = 0, r = this.clusters; n < r.length; n++) {
        var o = r[n];
        o.remove();
      }
      this.clusters = [];
      for (var i = 0, a = this.markers; i < a.length; i++) {
        var s = a[i];
        s.isAdded = !1, t && s.setMap(null);
      }
    }, e.prototype.distanceBetweenPoints = function(t, n) {
      var r = 6371, o = (n.lat() - t.lat()) * Math.PI / 180, i = (n.lng() - t.lng()) * Math.PI / 180, a = Math.sin(o / 2) * Math.sin(o / 2) + Math.cos(t.lat() * Math.PI / 180) * Math.cos(n.lat() * Math.PI / 180) * Math.sin(i / 2) * Math.sin(i / 2);
      return r * (2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)));
    }, e.prototype.isMarkerInBounds = function(t, n) {
      var r = t.getPosition();
      return r ? n.contains(r) : !1;
    }, e.prototype.addToClosestCluster = function(t) {
      for (var n, r = 4e4, o = null, i = 0, a = this.clusters; i < a.length; i++) {
        var s = a[i];
        n = s;
        var l = n.getCenter(), u = t.getPosition();
        if (l && u) {
          var c = this.distanceBetweenPoints(l, u);
          c < r && (r = c, o = n);
        }
      }
      o && o.isMarkerInClusterBounds(t) ? o.addMarker(t) : (n = new Pme(this), n.addMarker(t), this.clusters.push(n));
    }, e.prototype.createClusters = function(t) {
      var n = this;
      if (this.ready) {
        t === 0 && (google.maps.event.trigger(this, "clusteringbegin", this), this.timerRefStatic !== null && (window.clearTimeout(this.timerRefStatic), delete this.timerRefStatic));
        for (var r = this.getMap(), o = r !== null && ("getBounds" in r) ? r.getBounds() : null, i = (r == null ? void 0 : r.getZoom()) || 0, a = i > 3 ? new google.maps.LatLngBounds(o == null ? void 0 : o.getSouthWest(), o == null ? void 0 : o.getNorthEast()) : new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625)), s = this.getExtendedBounds(a), l = Math.min(t + this.batchSize, this.markers.length), u = t; u < l; u++) {
          var c = this.markers[u];
          c && !c.isAdded && this.isMarkerInBounds(c, s) && (!this.ignoreHidden || this.ignoreHidden && c.getVisible()) && this.addToClosestCluster(c);
        }
        if (l < this.markers.length)
          this.timerRefStatic = window.setTimeout(function() {
            n.createClusters(l);
          }, 0);
        else {
          this.timerRefStatic = null, google.maps.event.trigger(this, "clusteringend", this);
          for (var p = 0, d = this.clusters; p < d.length; p++) {
            var g = d[p];
            g.updateIcon();
          }
        }
      }
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype) {
          var i = o;
          this.prototype[i] = r.prototype[i];
        }
        return this;
      }).apply(t, [n]);
    }, e;
  }()
);
function TI(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Ime(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? TI(Object(n), !0).forEach(function(r) {
      Ce(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : TI(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var es = {
  onClick: "click",
  onClusteringBegin: "clusteringbegin",
  onClusteringEnd: "clusteringend",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover"
}, xn = {
  averageCenter(e, t) {
    e.setAverageCenter(t);
  },
  batchSizeIE(e, t) {
    e.setBatchSizeIE(t);
  },
  calculator(e, t) {
    e.setCalculator(t);
  },
  clusterClass(e, t) {
    e.setClusterClass(t);
  },
  enableRetinaIcons(e, t) {
    e.setEnableRetinaIcons(t);
  },
  gridSize(e, t) {
    e.setGridSize(t);
  },
  ignoreHidden(e, t) {
    e.setIgnoreHidden(t);
  },
  imageExtension(e, t) {
    e.setImageExtension(t);
  },
  imagePath(e, t) {
    e.setImagePath(t);
  },
  imageSizes(e, t) {
    e.setImageSizes(t);
  },
  maxZoom(e, t) {
    e.setMaxZoom(t);
  },
  minimumClusterSize(e, t) {
    e.setMinimumClusterSize(t);
  },
  styles(e, t) {
    e.setStyles(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  zoomOnClick(e, t) {
    e.setZoomOnClick(t);
  }
}, Rme = {};
function Bme(e) {
  var {
    children: t,
    options: n,
    averageCenter: r,
    batchSizeIE: o,
    calculator: i,
    clusterClass: a,
    enableRetinaIcons: s,
    gridSize: l,
    ignoreHidden: u,
    imageExtension: c,
    imagePath: p,
    imageSizes: d,
    maxZoom: g,
    minimumClusterSize: f,
    styles: m,
    title: v,
    zoomOnClick: E,
    onClick: w,
    onClusteringBegin: M,
    onClusteringEnd: O,
    onMouseOver: y,
    onMouseOut: C,
    onLoad: _,
    onUnmount: F
  } = e, [L, N] = k(null), R = ge(Tt), [W, V] = k(null), [z, Z] = k(null), [K, X] = k(null), [te, J] = k(null), [P, D] = k(null);
  return h(() => {
    L && C && (te !== null && google.maps.event.removeListener(te), J(google.maps.event.addListener(L, es.onMouseOut, C)));
  }, [C]), h(() => {
    L && y && (P !== null && google.maps.event.removeListener(P), D(google.maps.event.addListener(L, es.onMouseOver, y)));
  }, [y]), h(() => {
    L && w && (W !== null && google.maps.event.removeListener(W), V(google.maps.event.addListener(L, es.onClick, w)));
  }, [w]), h(() => {
    L && M && (z !== null && google.maps.event.removeListener(z), Z(google.maps.event.addListener(L, es.onClusteringBegin, M)));
  }, [M]), h(() => {
    L && O && (K !== null && google.maps.event.removeListener(K), Z(google.maps.event.addListener(L, es.onClusteringEnd, O)));
  }, [O]), h(() => {
    typeof r < "u" && L !== null && xn.averageCenter(L, r);
  }, [L, r]), h(() => {
    typeof o < "u" && L !== null && xn.batchSizeIE(L, o);
  }, [L, o]), h(() => {
    typeof i < "u" && L !== null && xn.calculator(L, i);
  }, [L, i]), h(() => {
    typeof a < "u" && L !== null && xn.clusterClass(L, a);
  }, [L, a]), h(() => {
    typeof s < "u" && L !== null && xn.enableRetinaIcons(L, s);
  }, [L, s]), h(() => {
    typeof l < "u" && L !== null && xn.gridSize(L, l);
  }, [L, l]), h(() => {
    typeof u < "u" && L !== null && xn.ignoreHidden(L, u);
  }, [L, u]), h(() => {
    typeof c < "u" && L !== null && xn.imageExtension(L, c);
  }, [L, c]), h(() => {
    typeof p < "u" && L !== null && xn.imagePath(L, p);
  }, [L, p]), h(() => {
    typeof d < "u" && L !== null && xn.imageSizes(L, d);
  }, [L, d]), h(() => {
    typeof g < "u" && L !== null && xn.maxZoom(L, g);
  }, [L, g]), h(() => {
    typeof f < "u" && L !== null && xn.minimumClusterSize(L, f);
  }, [L, f]), h(() => {
    typeof m < "u" && L !== null && xn.styles(L, m);
  }, [L, m]), h(() => {
    typeof v < "u" && L !== null && xn.title(L, v);
  }, [L, v]), h(() => {
    typeof E < "u" && L !== null && xn.zoomOnClick(L, E);
  }, [L, E]), h(() => {
    if (R) {
      var H = Ime({}, n || Rme), S = new dZ(R, [], H);
      return r && xn.averageCenter(S, r), o && xn.batchSizeIE(S, o), i && xn.calculator(S, i), a && xn.clusterClass(S, a), s && xn.enableRetinaIcons(S, s), l && xn.gridSize(S, l), u && xn.ignoreHidden(S, u), c && xn.imageExtension(S, c), p && xn.imagePath(S, p), d && xn.imageSizes(S, d), g && xn.maxZoom(S, g), f && xn.minimumClusterSize(S, f), m && xn.styles(S, m), v && xn.title(S, v), E && xn.zoomOnClick(S, E), C && J(google.maps.event.addListener(S, es.onMouseOut, C)), y && D(google.maps.event.addListener(S, es.onMouseOver, y)), w && V(google.maps.event.addListener(S, es.onClick, w)), M && Z(google.maps.event.addListener(S, es.onClusteringBegin, M)), O && X(google.maps.event.addListener(S, es.onClusteringEnd, O)), N(S), _ && _(S), () => {
        te !== null && google.maps.event.removeListener(te), P !== null && google.maps.event.removeListener(P), W !== null && google.maps.event.removeListener(W), z !== null && google.maps.event.removeListener(z), K !== null && google.maps.event.removeListener(K), F && F(S);
      };
    }
  }, []), L !== null && t(L) || null;
}
ve(Bme);
class Nme extends pe {
  constructor() {
    super(...arguments), Ce(this, "registeredEvents", []), Ce(this, "state", {
      markerClusterer: null
    }), Ce(this, "setClustererCallback", () => {
      this.state.markerClusterer !== null && this.props.onLoad && this.props.onLoad(this.state.markerClusterer);
    });
  }
  componentDidMount() {
    if (this.context) {
      var t = new dZ(this.context, [], this.props.options);
      this.registeredEvents = an({
        updaterMap: xn,
        eventMap: es,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        markerClusterer: t
      }), this.setClustererCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.markerClusterer && (fn(this.registeredEvents), this.registeredEvents = an({
      updaterMap: xn,
      eventMap: es,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.markerClusterer
    }));
  }
  componentWillUnmount() {
    this.state.markerClusterer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.markerClusterer), fn(this.registeredEvents), this.state.markerClusterer.setMap(null));
  }
  render() {
    return this.state.markerClusterer !== null ? this.props.children(this.state.markerClusterer) : null;
  }
}
Ce(Nme, "contextType", Tt);
function jI(e) {
  e.cancelBubble = !0, e.stopPropagation && e.stopPropagation();
}
var fZ = (
  /** @class */
  function() {
    function e(t) {
      t === void 0 && (t = {}), this.getCloseClickHandler = this.getCloseClickHandler.bind(this), this.closeClickHandler = this.closeClickHandler.bind(this), this.createInfoBoxDiv = this.createInfoBoxDiv.bind(this), this.addClickHandler = this.addClickHandler.bind(this), this.getCloseBoxImg = this.getCloseBoxImg.bind(this), this.getBoxWidths = this.getBoxWidths.bind(this), this.setBoxStyle = this.setBoxStyle.bind(this), this.setPosition = this.setPosition.bind(this), this.getPosition = this.getPosition.bind(this), this.setOptions = this.setOptions.bind(this), this.setContent = this.setContent.bind(this), this.setVisible = this.setVisible.bind(this), this.getContent = this.getContent.bind(this), this.getVisible = this.getVisible.bind(this), this.setZIndex = this.setZIndex.bind(this), this.getZIndex = this.getZIndex.bind(this), this.onRemove = this.onRemove.bind(this), this.panBox = this.panBox.bind(this), this.extend = this.extend.bind(this), this.close = this.close.bind(this), this.draw = this.draw.bind(this), this.show = this.show.bind(this), this.hide = this.hide.bind(this), this.open = this.open.bind(this), this.extend(e, google.maps.OverlayView), this.content = t.content || "", this.disableAutoPan = t.disableAutoPan || !1, this.maxWidth = t.maxWidth || 0, this.pixelOffset = t.pixelOffset || new google.maps.Size(0, 0), this.position = t.position || new google.maps.LatLng(0, 0), this.zIndex = t.zIndex || null, this.boxClass = t.boxClass || "infoBox", this.boxStyle = t.boxStyle || {}, this.closeBoxMargin = t.closeBoxMargin || "2px", this.closeBoxURL = t.closeBoxURL || "http://www.google.com/intl/en_us/mapfiles/close.gif", t.closeBoxURL === "" && (this.closeBoxURL = ""), this.infoBoxClearance = t.infoBoxClearance || new google.maps.Size(1, 1), typeof t.visible > "u" && (typeof t.isHidden > "u" ? t.visible = !0 : t.visible = !t.isHidden), this.isHidden = !t.visible, this.alignBottom = t.alignBottom || !1, this.pane = t.pane || "floatPane", this.enableEventPropagation = t.enableEventPropagation || !1, this.div = null, this.closeListener = null, this.moveListener = null, this.mapListener = null, this.contextListener = null, this.eventListeners = null, this.fixedWidthSet = null;
    }
    return e.prototype.createInfoBoxDiv = function() {
      var t = this, n = function(u) {
        u.returnValue = !1, u.preventDefault && u.preventDefault(), t.enableEventPropagation || jI(u);
      };
      if (!this.div) {
        this.div = document.createElement("div"), this.setBoxStyle(), typeof this.content == "string" ? this.div.innerHTML = this.getCloseBoxImg() + this.content : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(this.content));
        var r = this.getPanes();
        if (r !== null && r[this.pane].appendChild(this.div), this.addClickHandler(), this.div.style.width)
          this.fixedWidthSet = !0;
        else if (this.maxWidth !== 0 && this.div.offsetWidth > this.maxWidth)
          this.div.style.width = this.maxWidth + "px", this.fixedWidthSet = !0;
        else {
          var o = this.getBoxWidths();
          this.div.style.width = this.div.offsetWidth - o.left - o.right + "px", this.fixedWidthSet = !1;
        }
        if (this.panBox(this.disableAutoPan), !this.enableEventPropagation) {
          this.eventListeners = [];
          for (var i = ["mousedown", "mouseover", "mouseout", "mouseup", "click", "dblclick", "touchstart", "touchend", "touchmove"], a = 0, s = i; a < s.length; a++) {
            var l = s[a];
            this.eventListeners.push(google.maps.event.addListener(this.div, l, jI));
          }
          this.eventListeners.push(google.maps.event.addListener(this.div, "mouseover", function() {
            t.div && (t.div.style.cursor = "default");
          }));
        }
        this.contextListener = google.maps.event.addListener(this.div, "contextmenu", n), google.maps.event.trigger(this, "domready");
      }
    }, e.prototype.getCloseBoxImg = function() {
      var t = "";
      return this.closeBoxURL !== "" && (t = '<img alt=""', t += ' aria-hidden="true"', t += " src='" + this.closeBoxURL + "'", t += " align=right", t += " style='", t += " position: relative;", t += " cursor: pointer;", t += " margin: " + this.closeBoxMargin + ";", t += "'>"), t;
    }, e.prototype.addClickHandler = function() {
      this.closeListener = this.div && this.div.firstChild && this.closeBoxURL !== "" ? google.maps.event.addListener(this.div.firstChild, "click", this.getCloseClickHandler()) : null;
    }, e.prototype.closeClickHandler = function(t) {
      t.cancelBubble = !0, t.stopPropagation && t.stopPropagation(), google.maps.event.trigger(this, "closeclick"), this.close();
    }, e.prototype.getCloseClickHandler = function() {
      return this.closeClickHandler;
    }, e.prototype.panBox = function(t) {
      if (this.div && !t) {
        var n = this.getMap();
        if (n instanceof google.maps.Map) {
          var r = 0, o = 0, i = n.getBounds();
          i && !i.contains(this.position) && n.setCenter(this.position);
          var a = n.getDiv(), s = a.offsetWidth, l = a.offsetHeight, u = this.pixelOffset.width, c = this.pixelOffset.height, p = this.div.offsetWidth, d = this.div.offsetHeight, g = this.infoBoxClearance.width, f = this.infoBoxClearance.height, m = this.getProjection(), v = m.fromLatLngToContainerPixel(this.position);
          v !== null && (v.x < -u + g ? r = v.x + u - g : v.x + p + u + g > s && (r = v.x + p + u + g - s), this.alignBottom ? v.y < -c + f + d ? o = v.y + c - f - d : v.y + c + f > l && (o = v.y + c + f - l) : v.y < -c + f ? o = v.y + c - f : v.y + d + c + f > l && (o = v.y + d + c + f - l)), r === 0 && o === 0 || n.panBy(r, o);
        }
      }
    }, e.prototype.setBoxStyle = function() {
      if (this.div) {
        this.div.className = this.boxClass, this.div.style.cssText = "";
        var t = this.boxStyle;
        for (var n in t)
          Object.prototype.hasOwnProperty.call(t, n) && (this.div.style[n] = t[n]);
        if (this.div.style.webkitTransform = "translateZ(0)", typeof this.div.style.opacity < "u" && this.div.style.opacity !== "") {
          var r = parseFloat(this.div.style.opacity || "");
          this.div.style.msFilter = '"progid:DXImageTransform.Microsoft.Alpha(Opacity=' + r * 100 + ')"', this.div.style.filter = "alpha(opacity=" + r * 100 + ")";
        }
        this.div.style.position = "absolute", this.div.style.visibility = "hidden", this.zIndex !== null && (this.div.style.zIndex = this.zIndex + ""), this.div.style.overflow || (this.div.style.overflow = "auto");
      }
    }, e.prototype.getBoxWidths = function() {
      var t = {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0
      };
      if (!this.div)
        return t;
      if (document.defaultView) {
        var n = this.div.ownerDocument, r = n && n.defaultView ? n.defaultView.getComputedStyle(this.div, "") : null;
        r && (t.top = parseInt(r.borderTopWidth || "", 10) || 0, t.bottom = parseInt(r.borderBottomWidth || "", 10) || 0, t.left = parseInt(r.borderLeftWidth || "", 10) || 0, t.right = parseInt(r.borderRightWidth || "", 10) || 0);
      } else if (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        document.documentElement.currentStyle
      ) {
        var o = this.div.currentStyle;
        o && (t.top = parseInt(o.borderTopWidth || "", 10) || 0, t.bottom = parseInt(o.borderBottomWidth || "", 10) || 0, t.left = parseInt(o.borderLeftWidth || "", 10) || 0, t.right = parseInt(o.borderRightWidth || "", 10) || 0);
      }
      return t;
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.div.parentNode.removeChild(this.div), this.div = null);
    }, e.prototype.draw = function() {
      if (this.createInfoBoxDiv(), this.div) {
        var t = this.getProjection(), n = t.fromLatLngToDivPixel(this.position);
        n !== null && (this.div.style.left = n.x + this.pixelOffset.width + "px", this.alignBottom ? this.div.style.bottom = -(n.y + this.pixelOffset.height) + "px" : this.div.style.top = n.y + this.pixelOffset.height + "px"), this.isHidden ? this.div.style.visibility = "hidden" : this.div.style.visibility = "visible";
      }
    }, e.prototype.setOptions = function(t) {
      t === void 0 && (t = {}), typeof t.boxClass < "u" && (this.boxClass = t.boxClass, this.setBoxStyle()), typeof t.boxStyle < "u" && (this.boxStyle = t.boxStyle, this.setBoxStyle()), typeof t.content < "u" && this.setContent(t.content), typeof t.disableAutoPan < "u" && (this.disableAutoPan = t.disableAutoPan), typeof t.maxWidth < "u" && (this.maxWidth = t.maxWidth), typeof t.pixelOffset < "u" && (this.pixelOffset = t.pixelOffset), typeof t.alignBottom < "u" && (this.alignBottom = t.alignBottom), typeof t.position < "u" && this.setPosition(t.position), typeof t.zIndex < "u" && this.setZIndex(t.zIndex), typeof t.closeBoxMargin < "u" && (this.closeBoxMargin = t.closeBoxMargin), typeof t.closeBoxURL < "u" && (this.closeBoxURL = t.closeBoxURL), typeof t.infoBoxClearance < "u" && (this.infoBoxClearance = t.infoBoxClearance), typeof t.isHidden < "u" && (this.isHidden = t.isHidden), typeof t.visible < "u" && (this.isHidden = !t.visible), typeof t.enableEventPropagation < "u" && (this.enableEventPropagation = t.enableEventPropagation), this.div && this.draw();
    }, e.prototype.setContent = function(t) {
      this.content = t, this.div && (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.fixedWidthSet || (this.div.style.width = ""), typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t)), this.fixedWidthSet || (this.div.style.width = this.div.offsetWidth + "px", typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t))), this.addClickHandler()), google.maps.event.trigger(this, "content_changed");
    }, e.prototype.setPosition = function(t) {
      this.position = t, this.div && this.draw(), google.maps.event.trigger(this, "position_changed");
    }, e.prototype.setVisible = function(t) {
      this.isHidden = !t, this.div && (this.div.style.visibility = this.isHidden ? "hidden" : "visible");
    }, e.prototype.setZIndex = function(t) {
      this.zIndex = t, this.div && (this.div.style.zIndex = t + ""), google.maps.event.trigger(this, "zindex_changed");
    }, e.prototype.getContent = function() {
      return this.content;
    }, e.prototype.getPosition = function() {
      return this.position;
    }, e.prototype.getZIndex = function() {
      return this.zIndex;
    }, e.prototype.getVisible = function() {
      var t = this.getMap();
      return typeof t > "u" || t === null ? !1 : !this.isHidden;
    }, e.prototype.show = function() {
      this.isHidden = !1, this.div && (this.div.style.visibility = "visible");
    }, e.prototype.hide = function() {
      this.isHidden = !0, this.div && (this.div.style.visibility = "hidden");
    }, e.prototype.open = function(t, n) {
      var r = this;
      n && (this.position = n.getPosition(), this.moveListener = google.maps.event.addListener(n, "position_changed", function() {
        var o = n.getPosition();
        r.setPosition(o);
      }), this.mapListener = google.maps.event.addListener(n, "map_changed", function() {
        r.setMap(n.map);
      })), this.setMap(t), this.div && this.panBox();
    }, e.prototype.close = function() {
      if (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.eventListeners) {
        for (var t = 0, n = this.eventListeners; t < n.length; t++) {
          var r = n[t];
          google.maps.event.removeListener(r);
        }
        this.eventListeners = null;
      }
      this.moveListener && (google.maps.event.removeListener(this.moveListener), this.moveListener = null), this.mapListener && (google.maps.event.removeListener(this.mapListener), this.mapListener = null), this.contextListener && (google.maps.event.removeListener(this.contextListener), this.contextListener = null), this.setMap(null);
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype)
          Object.prototype.hasOwnProperty.call(this, o) || (this.prototype[o] = r.prototype[o]);
        return this;
      }).apply(t, [n]);
    }, e;
  }()
), Fme = ["position"], zme = ["position"];
function AI(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Pv(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? AI(Object(n), !0).forEach(function(r) {
      Ce(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : AI(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var II = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, RI = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    t instanceof google.maps.LatLng ? e.setPosition(t) : e.setPosition(new google.maps.LatLng(t.lat, t.lng));
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, Ume = {};
function Hme(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, g = ge(Tt), [f, m] = k(null), [v, E] = k(null), [w, M] = k(null), [O, y] = k(null), [C, _] = k(null), [F, L] = k(null), N = ut(null);
  return h(() => {
    g && f !== null && (f.close(), n ? f.open(g, n) : f.getPosition() && f.open(g));
  }, [g, f, n]), h(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), h(() => {
    if (o && f !== null) {
      var R = o instanceof google.maps.LatLng ? o : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        new google.maps.LatLng(o.lat, o.lng)
      );
      f.setPosition(R);
    }
  }, [o]), h(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), h(() => {
    f && a && (v !== null && google.maps.event.removeListener(v), E(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), h(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), M(google.maps.event.addListener(f, "domready", s)));
  }, [s]), h(() => {
    f && l && (O !== null && google.maps.event.removeListener(O), y(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), h(() => {
    f && u && (C !== null && google.maps.event.removeListener(C), _(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), h(() => {
    f && c && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), h(() => {
    if (g) {
      var R = r || Ume, {
        position: W
      } = R, V = zP(R, Fme), z;
      W && !(W instanceof google.maps.LatLng) && (z = new google.maps.LatLng(W.lat, W.lng));
      var Z = new fZ(Pv(Pv({}, V), z ? {
        position: z
      } : {}));
      N.current = document.createElement("div"), m(Z), a && E(google.maps.event.addListener(Z, "closeclick", a)), s && M(google.maps.event.addListener(Z, "domready", s)), l && y(google.maps.event.addListener(Z, "content_changed", l)), u && _(google.maps.event.addListener(Z, "position_changed", u)), c && L(google.maps.event.addListener(Z, "zindex_changed", c)), Z.setContent(N.current), n ? Z.open(g, n) : Z.getPosition() ? Z.open(g) : yo(!1, "You must provide either an anchor or a position prop for <InfoBox>."), p && p(Z);
    }
    return () => {
      f !== null && (v && google.maps.event.removeListener(v), O && google.maps.event.removeListener(O), w && google.maps.event.removeListener(w), C && google.maps.event.removeListener(C), F && google.maps.event.removeListener(F), d && d(f), f.close());
    };
  }, []), N.current ? or(lt.only(t), N.current) : null;
}
ve(Hme);
class $me extends pe {
  constructor() {
    super(...arguments), Ce(this, "registeredEvents", []), Ce(this, "containerElement", null), Ce(this, "state", {
      infoBox: null
    }), Ce(this, "open", (t, n) => {
      n ? this.context !== null && t.open(this.context, n) : t.getPosition() ? this.context !== null && t.open(this.context) : yo(!1, "You must provide either an anchor or a position prop for <InfoBox>.");
    }), Ce(this, "setInfoBoxCallback", () => {
      this.state.infoBox !== null && this.containerElement !== null && (this.state.infoBox.setContent(this.containerElement), this.open(this.state.infoBox, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoBox));
    });
  }
  componentDidMount() {
    var t = this.props.options || {}, {
      position: n
    } = t, r = zP(t, zme), o;
    n && !(n instanceof google.maps.LatLng) && (o = new google.maps.LatLng(n.lat, n.lng));
    var i = new fZ(Pv(Pv({}, r), o ? {
      position: o
    } : {}));
    this.containerElement = document.createElement("div"), this.registeredEvents = an({
      updaterMap: RI,
      eventMap: II,
      prevProps: {},
      nextProps: this.props,
      instance: i
    }), this.setState({
      infoBox: i
    }, this.setInfoBoxCallback);
  }
  componentDidUpdate(t) {
    var {
      infoBox: n
    } = this.state;
    n !== null && (fn(this.registeredEvents), this.registeredEvents = an({
      updaterMap: RI,
      eventMap: II,
      prevProps: t,
      nextProps: this.props,
      instance: n
    }));
  }
  componentWillUnmount() {
    var {
      onUnmount: t
    } = this.props, {
      infoBox: n
    } = this.state;
    n !== null && (t && t(n), fn(this.registeredEvents), n.close());
  }
  render() {
    return this.containerElement ? or(lt.only(this.props.children), this.containerElement) : null;
  }
}
Ce($me, "contextType", Tt);
var BI, NI;
function Wme() {
  return NI || (NI = 1, BI = function e(t, n) {
    if (t === n) return !0;
    if (t && n && typeof t == "object" && typeof n == "object") {
      if (t.constructor !== n.constructor) return !1;
      var r, o, i;
      if (Array.isArray(t)) {
        if (r = t.length, r != n.length) return !1;
        for (o = r; o-- !== 0; ) if (!e(t[o], n[o])) return !1;
        return !0;
      }
      if (t.constructor === RegExp) return t.source === n.source && t.flags === n.flags;
      if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === n.valueOf();
      if (t.toString !== Object.prototype.toString) return t.toString() === n.toString();
      if (i = Object.keys(t), r = i.length, r !== Object.keys(n).length) return !1;
      for (o = r; o-- !== 0; ) if (!Object.prototype.hasOwnProperty.call(n, i[o])) return !1;
      for (o = r; o-- !== 0; ) {
        var a = i[o];
        if (!e(t[a], n[a])) return !1;
      }
      return !0;
    }
    return t !== t && n !== n;
  }), BI;
}
var Vme = Wme(), FI = /* @__PURE__ */ sZ(Vme), zI = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array], CC = 1, op = 8;
class UP {
  /**
   * Creates an index from raw `ArrayBuffer` data.
   * @param {ArrayBuffer} data
   */
  static from(t) {
    if (!(t instanceof ArrayBuffer))
      throw new Error("Data must be an instance of ArrayBuffer.");
    var [n, r] = new Uint8Array(t, 0, 2);
    if (n !== 219)
      throw new Error("Data does not appear to be in a KDBush format.");
    var o = r >> 4;
    if (o !== CC)
      throw new Error("Got v".concat(o, " data when expected v").concat(CC, "."));
    var i = zI[r & 15];
    if (!i)
      throw new Error("Unrecognized array type.");
    var [a] = new Uint16Array(t, 2, 1), [s] = new Uint32Array(t, 4, 1);
    return new UP(s, a, i, t);
  }
  /**
   * Creates an index that will hold a given number of items.
   * @param {number} numItems
   * @param {number} [nodeSize=64] Size of the KD-tree node (64 by default).
   * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).
   * @param {ArrayBuffer} [data] (For internal use only)
   */
  constructor(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 64, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Float64Array, o = arguments.length > 3 ? arguments[3] : void 0;
    if (isNaN(t) || t < 0) throw new Error("Unpexpected numItems value: ".concat(t, "."));
    this.numItems = +t, this.nodeSize = Math.min(Math.max(+n, 2), 65535), this.ArrayType = r, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
    var i = zI.indexOf(this.ArrayType), a = t * 2 * this.ArrayType.BYTES_PER_ELEMENT, s = t * this.IndexArrayType.BYTES_PER_ELEMENT, l = (8 - s % 8) % 8;
    if (i < 0)
      throw new Error("Unexpected typed array class: ".concat(r, "."));
    o && o instanceof ArrayBuffer ? (this.data = o, this.ids = new this.IndexArrayType(this.data, op, t), this.coords = new this.ArrayType(this.data, op + s + l, t * 2), this._pos = t * 2, this._finished = !0) : (this.data = new ArrayBuffer(op + a + s + l), this.ids = new this.IndexArrayType(this.data, op, t), this.coords = new this.ArrayType(this.data, op + s + l, t * 2), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, (CC << 4) + i]), new Uint16Array(this.data, 2, 1)[0] = n, new Uint32Array(this.data, 4, 1)[0] = t);
  }
  /**
   * Add a point to the index.
   * @param {number} x
   * @param {number} y
   * @returns {number} An incremental index associated with the added item (starting from `0`).
   */
  add(t, n) {
    var r = this._pos >> 1;
    return this.ids[r] = r, this.coords[this._pos++] = t, this.coords[this._pos++] = n, r;
  }
  /**
   * Perform indexing of the added points.
   */
  finish() {
    var t = this._pos >> 1;
    if (t !== this.numItems)
      throw new Error("Added ".concat(t, " items when expected ").concat(this.numItems, "."));
    return hk(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
  }
  /**
   * Search the index for items within a given bounding box.
   * @param {number} minX
   * @param {number} minY
   * @param {number} maxX
   * @param {number} maxY
   * @returns {number[]} An array of indices correponding to the found items.
   */
  range(t, n, r, o) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: i,
      coords: a,
      nodeSize: s
    } = this, l = [0, i.length - 1, 0], u = []; l.length; ) {
      var c = l.pop() || 0, p = l.pop() || 0, d = l.pop() || 0;
      if (p - d <= s) {
        for (var g = d; g <= p; g++) {
          var f = a[2 * g], m = a[2 * g + 1];
          f >= t && f <= r && m >= n && m <= o && u.push(i[g]);
        }
        continue;
      }
      var v = d + p >> 1, E = a[2 * v], w = a[2 * v + 1];
      E >= t && E <= r && w >= n && w <= o && u.push(i[v]), (c === 0 ? t <= E : n <= w) && (l.push(d), l.push(v - 1), l.push(1 - c)), (c === 0 ? r >= E : o >= w) && (l.push(v + 1), l.push(p), l.push(1 - c));
    }
    return u;
  }
  /**
   * Search the index for items within a given radius.
   * @param {number} qx
   * @param {number} qy
   * @param {number} r Query radius.
   * @returns {number[]} An array of indices correponding to the found items.
   */
  within(t, n, r) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: o,
      coords: i,
      nodeSize: a
    } = this, s = [0, o.length - 1, 0], l = [], u = r * r; s.length; ) {
      var c = s.pop() || 0, p = s.pop() || 0, d = s.pop() || 0;
      if (p - d <= a) {
        for (var g = d; g <= p; g++)
          UI(i[2 * g], i[2 * g + 1], t, n) <= u && l.push(o[g]);
        continue;
      }
      var f = d + p >> 1, m = i[2 * f], v = i[2 * f + 1];
      UI(m, v, t, n) <= u && l.push(o[f]), (c === 0 ? t - r <= m : n - r <= v) && (s.push(d), s.push(f - 1), s.push(1 - c)), (c === 0 ? t + r >= m : n + r >= v) && (s.push(f + 1), s.push(p), s.push(1 - c));
    }
    return l;
  }
}
function hk(e, t, n, r, o, i) {
  if (!(o - r <= n)) {
    var a = r + o >> 1;
    hZ(e, t, a, r, o, i), hk(e, t, n, r, a - 1, 1 - i), hk(e, t, n, a + 1, o, 1 - i);
  }
}
function hZ(e, t, n, r, o, i) {
  for (; o > r; ) {
    if (o - r > 600) {
      var a = o - r + 1, s = n - r + 1, l = Math.log(a), u = 0.5 * Math.exp(2 * l / 3), c = 0.5 * Math.sqrt(l * u * (a - u) / a) * (s - a / 2 < 0 ? -1 : 1), p = Math.max(r, Math.floor(n - s * u / a + c)), d = Math.min(o, Math.floor(n + (a - s) * u / a + c));
      hZ(e, t, n, p, d, i);
    }
    var g = t[2 * n + i], f = r, m = o;
    for (ip(e, t, r, n), t[2 * o + i] > g && ip(e, t, r, o); f < m; ) {
      for (ip(e, t, f, m), f++, m--; t[2 * f + i] < g; ) f++;
      for (; t[2 * m + i] > g; ) m--;
    }
    t[2 * r + i] === g ? ip(e, t, r, m) : (m++, ip(e, t, m, o)), m <= n && (r = m + 1), n <= m && (o = m - 1);
  }
}
function ip(e, t, n, r) {
  xC(e, n, r), xC(t, 2 * n, 2 * r), xC(t, 2 * n + 1, 2 * r + 1);
}
function xC(e, t, n) {
  var r = e[t];
  e[t] = e[n], e[n] = r;
}
function UI(e, t, n, r) {
  var o = e - n, i = t - r;
  return o * o + i * i;
}
var Zme = {
  minZoom: 0,
  // min zoom to generate clusters on
  maxZoom: 16,
  // max zoom level to cluster the points on
  minPoints: 2,
  // minimum points to form a cluster
  radius: 40,
  // cluster radius in pixels
  extent: 512,
  // tile extent (radius is calculated relative to it)
  nodeSize: 64,
  // size of the KD-tree leaf node, affects performance
  log: !1,
  // whether to log timing info
  // whether to generate numeric ids for input features (in vector tiles)
  generateId: !1,
  // a reduce function for calculating custom cluster properties
  reduce: null,
  // (accumulated, props) => { accumulated.sum += props.sum; }
  // properties to use for individual points when running the reducer
  map: (e) => e
  // props => ({sum: props.my_value})
}, HI = Math.fround || /* @__PURE__ */ ((e) => (t) => (e[0] = +t, e[0]))(new Float32Array(1)), Il = 2, Wa = 3, OC = 4, Ba = 5, gZ = 6;
class qme {
  constructor(t) {
    this.options = Object.assign(Object.create(Zme), t), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
  }
  load(t) {
    var {
      log: n,
      minZoom: r,
      maxZoom: o
    } = this.options;
    n && console.time("total time");
    var i = "prepare ".concat(t.length, " points");
    n && console.time(i), this.points = t;
    for (var a = [], s = 0; s < t.length; s++) {
      var l = t[s];
      if (l.geometry) {
        var [u, c] = l.geometry.coordinates, p = HI(ug(u)), d = HI(cg(c));
        a.push(
          p,
          d,
          // projected point coordinates
          1 / 0,
          // the last zoom the point was processed at
          s,
          // index of the source feature in the original input array
          -1,
          // parent cluster id
          1
          // number of points in a cluster
        ), this.options.reduce && a.push(0);
      }
    }
    var g = this.trees[o + 1] = this._createTree(a);
    n && console.timeEnd(i);
    for (var f = o; f >= r; f--) {
      var m = +Date.now();
      g = this.trees[f] = this._createTree(this._cluster(g, f)), n && console.log("z%d: %d clusters in %dms", f, g.numItems, +Date.now() - m);
    }
    return n && console.timeEnd("total time"), this;
  }
  getClusters(t, n) {
    var r = ((t[0] + 180) % 360 + 360) % 360 - 180, o = Math.max(-90, Math.min(90, t[1])), i = t[2] === 180 ? 180 : ((t[2] + 180) % 360 + 360) % 360 - 180, a = Math.max(-90, Math.min(90, t[3]));
    if (t[2] - t[0] >= 360)
      r = -180, i = 180;
    else if (r > i) {
      var s = this.getClusters([r, o, 180, a], n), l = this.getClusters([-180, o, i, a], n);
      return s.concat(l);
    }
    var u = this.trees[this._limitZoom(n)], c = u.range(ug(r), cg(a), ug(i), cg(o)), p = u.data, d = [];
    for (var g of c) {
      var f = this.stride * g;
      d.push(p[f + Ba] > 1 ? $I(p, f, this.clusterProps) : this.points[p[f + Wa]]);
    }
    return d;
  }
  getChildren(t) {
    var n = this._getOriginId(t), r = this._getOriginZoom(t), o = "No cluster with the specified id.", i = this.trees[r];
    if (!i) throw new Error(o);
    var a = i.data;
    if (n * this.stride >= a.length) throw new Error(o);
    var s = this.options.radius / (this.options.extent * Math.pow(2, r - 1)), l = a[n * this.stride], u = a[n * this.stride + 1], c = i.within(l, u, s), p = [];
    for (var d of c) {
      var g = d * this.stride;
      a[g + OC] === t && p.push(a[g + Ba] > 1 ? $I(a, g, this.clusterProps) : this.points[a[g + Wa]]);
    }
    if (p.length === 0) throw new Error(o);
    return p;
  }
  getLeaves(t, n, r) {
    n = n || 10, r = r || 0;
    var o = [];
    return this._appendLeaves(o, t, n, r, 0), o;
  }
  getTile(t, n, r) {
    var o = this.trees[this._limitZoom(t)], i = Math.pow(2, t), {
      extent: a,
      radius: s
    } = this.options, l = s / a, u = (r - l) / i, c = (r + 1 + l) / i, p = {
      features: []
    };
    return this._addTileFeatures(o.range((n - l) / i, u, (n + 1 + l) / i, c), o.data, n, r, i, p), n === 0 && this._addTileFeatures(o.range(1 - l / i, u, 1, c), o.data, i, r, i, p), n === i - 1 && this._addTileFeatures(o.range(0, u, l / i, c), o.data, -1, r, i, p), p.features.length ? p : null;
  }
  getClusterExpansionZoom(t) {
    for (var n = this._getOriginZoom(t) - 1; n <= this.options.maxZoom; ) {
      var r = this.getChildren(t);
      if (n++, r.length !== 1) break;
      t = r[0].properties.cluster_id;
    }
    return n;
  }
  _appendLeaves(t, n, r, o, i) {
    var a = this.getChildren(n);
    for (var s of a) {
      var l = s.properties;
      if (l && l.cluster ? i + l.point_count <= o ? i += l.point_count : i = this._appendLeaves(t, l.cluster_id, r, o, i) : i < o ? i++ : t.push(s), t.length === r) break;
    }
    return i;
  }
  _createTree(t) {
    for (var n = new UP(t.length / this.stride | 0, this.options.nodeSize, Float32Array), r = 0; r < t.length; r += this.stride) n.add(t[r], t[r + 1]);
    return n.finish(), n.data = t, n;
  }
  _addTileFeatures(t, n, r, o, i, a) {
    for (var s of t) {
      var l = s * this.stride, u = n[l + Ba] > 1, c = void 0, p = void 0, d = void 0;
      if (u)
        c = mZ(n, l, this.clusterProps), p = n[l], d = n[l + 1];
      else {
        var g = this.points[n[l + Wa]];
        c = g.properties;
        var [f, m] = g.geometry.coordinates;
        p = ug(f), d = cg(m);
      }
      var v = {
        type: 1,
        geometry: [[Math.round(this.options.extent * (p * i - r)), Math.round(this.options.extent * (d * i - o))]],
        tags: c
      }, E = void 0;
      u || this.options.generateId ? E = n[l + Wa] : E = this.points[n[l + Wa]].id, E !== void 0 && (v.id = E), a.features.push(v);
    }
  }
  _limitZoom(t) {
    return Math.max(this.options.minZoom, Math.min(Math.floor(+t), this.options.maxZoom + 1));
  }
  _cluster(t, n) {
    for (var {
      radius: r,
      extent: o,
      reduce: i,
      minPoints: a
    } = this.options, s = r / (o * Math.pow(2, n)), l = t.data, u = [], c = this.stride, p = 0; p < l.length; p += c)
      if (!(l[p + Il] <= n)) {
        l[p + Il] = n;
        var d = l[p], g = l[p + 1], f = t.within(l[p], l[p + 1], s), m = l[p + Ba], v = m;
        for (var E of f) {
          var w = E * c;
          l[w + Il] > n && (v += l[w + Ba]);
        }
        if (v > m && v >= a) {
          var M = d * m, O = g * m, y = void 0, C = -1, _ = ((p / c | 0) << 5) + (n + 1) + this.points.length;
          for (var F of f) {
            var L = F * c;
            if (!(l[L + Il] <= n)) {
              l[L + Il] = n;
              var N = l[L + Ba];
              M += l[L] * N, O += l[L + 1] * N, l[L + OC] = _, i && (y || (y = this._map(l, p, !0), C = this.clusterProps.length, this.clusterProps.push(y)), i(y, this._map(l, L)));
            }
          }
          l[p + OC] = _, u.push(M / v, O / v, 1 / 0, _, -1, v), i && u.push(C);
        } else {
          for (var R = 0; R < c; R++) u.push(l[p + R]);
          if (v > 1)
            for (var W of f) {
              var V = W * c;
              if (!(l[V + Il] <= n)) {
                l[V + Il] = n;
                for (var z = 0; z < c; z++) u.push(l[V + z]);
              }
            }
        }
      }
    return u;
  }
  // get index of the point from which the cluster originated
  _getOriginId(t) {
    return t - this.points.length >> 5;
  }
  // get zoom of the point from which the cluster originated
  _getOriginZoom(t) {
    return (t - this.points.length) % 32;
  }
  _map(t, n, r) {
    if (t[n + Ba] > 1) {
      var o = this.clusterProps[t[n + gZ]];
      return r ? Object.assign({}, o) : o;
    }
    var i = this.points[t[n + Wa]].properties, a = this.options.map(i);
    return r && a === i ? Object.assign({}, a) : a;
  }
}
function $I(e, t, n) {
  return {
    type: "Feature",
    id: e[t + Wa],
    properties: mZ(e, t, n),
    geometry: {
      type: "Point",
      coordinates: [Gme(e[t]), Kme(e[t + 1])]
    }
  };
}
function mZ(e, t, n) {
  var r = e[t + Ba], o = r >= 1e4 ? "".concat(Math.round(r / 1e3), "k") : r >= 1e3 ? "".concat(Math.round(r / 100) / 10, "k") : r, i = e[t + gZ], a = i === -1 ? {} : Object.assign({}, n[i]);
  return Object.assign(a, {
    cluster: !0,
    cluster_id: e[t + Wa],
    point_count: r,
    point_count_abbreviated: o
  });
}
function ug(e) {
  return e / 360 + 0.5;
}
function cg(e) {
  var t = Math.sin(e * Math.PI / 180), n = 0.5 - 0.25 * Math.log((1 + t) / (1 - t)) / Math.PI;
  return n < 0 ? 0 : n > 1 ? 1 : n;
}
function Gme(e) {
  return (e - 0.5) * 360;
}
function Kme(e) {
  var t = (180 - e * 360) * Math.PI / 180;
  return 360 * Math.atan(Math.exp(t)) / Math.PI - 90;
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function Yme(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
    t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
  return n;
}
class ji {
  static isAdvancedMarkerAvailable(t) {
    return google.maps.marker && t.getMapCapabilities().isAdvancedMarkersAvailable === !0;
  }
  static isAdvancedMarker(t) {
    return google.maps.marker && t instanceof google.maps.marker.AdvancedMarkerElement;
  }
  static setMap(t, n) {
    this.isAdvancedMarker(t) ? t.map = n : t.setMap(n);
  }
  static getPosition(t) {
    if (this.isAdvancedMarker(t)) {
      if (t.position) {
        if (t.position instanceof google.maps.LatLng)
          return t.position;
        if (t.position.lat && t.position.lng)
          return new google.maps.LatLng(t.position.lat, t.position.lng);
      }
      return new google.maps.LatLng(null);
    }
    return t.getPosition();
  }
  static getVisible(t) {
    return this.isAdvancedMarker(t) ? !0 : t.getVisible();
  }
}
class gk {
  constructor(t) {
    var {
      markers: n,
      position: r
    } = t;
    this.markers = n, r && (r instanceof google.maps.LatLng ? this._position = r : this._position = new google.maps.LatLng(r));
  }
  get bounds() {
    if (!(this.markers.length === 0 && !this._position)) {
      var t = new google.maps.LatLngBounds(this._position, this._position);
      for (var n of this.markers)
        t.extend(ji.getPosition(n));
      return t;
    }
  }
  get position() {
    return this._position || this.bounds.getCenter();
  }
  /**
   * Get the count of **visible** markers.
   */
  get count() {
    return this.markers.filter((t) => ji.getVisible(t)).length;
  }
  /**
   * Add a marker to the cluster.
   */
  push(t) {
    this.markers.push(t);
  }
  /**
   * Cleanup references and remove marker from map.
   */
  delete() {
    this.marker && (ji.setMap(this.marker, null), this.marker = void 0), this.markers.length = 0;
  }
}
let Xme = class {
  constructor(e) {
    var {
      maxZoom: t = 16
    } = e;
    this.maxZoom = t;
  }
  /**
   * Helper function to bypass clustering based upon some map state such as
   * zoom, number of markers, etc.
   *
   * ```typescript
   *  cluster({markers, map}: AlgorithmInput): Cluster[] {
   *    if (shouldBypassClustering(map)) {
   *      return this.noop({markers})
   *    }
   * }
   * ```
   */
  noop(e) {
    var {
      markers: t
    } = e;
    return Jme(t);
  }
};
var Jme = (e) => {
  var t = e.map((n) => new gk({
    position: ji.getPosition(n),
    markers: [n]
  }));
  return t;
};
class Qme extends Xme {
  constructor(t) {
    var {
      maxZoom: n,
      radius: r = 60
    } = t, o = Yme(t, ["maxZoom", "radius"]);
    super({
      maxZoom: n
    }), this.state = {
      zoom: -1
    }, this.superCluster = new qme(Object.assign({
      maxZoom: this.maxZoom,
      radius: r
    }, o));
  }
  calculate(t) {
    var n = !1, r = {
      zoom: t.map.getZoom()
    };
    if (!FI(t.markers, this.markers)) {
      n = !0, this.markers = [...t.markers];
      var o = this.markers.map((i) => {
        var a = ji.getPosition(i), s = [a.lng(), a.lat()];
        return {
          type: "Feature",
          geometry: {
            type: "Point",
            coordinates: s
          },
          properties: {
            marker: i
          }
        };
      });
      this.superCluster.load(o);
    }
    return n || (this.state.zoom <= this.maxZoom || r.zoom <= this.maxZoom) && (n = !FI(this.state, r)), this.state = r, n && (this.clusters = this.cluster(t)), {
      clusters: this.clusters,
      changed: n
    };
  }
  cluster(t) {
    var {
      map: n
    } = t;
    return this.superCluster.getClusters([-180, -90, 180, 90], Math.round(n.getZoom())).map((r) => this.transformCluster(r));
  }
  transformCluster(t) {
    var {
      geometry: {
        coordinates: [n, r]
      },
      properties: o
    } = t;
    if (o.cluster)
      return new gk({
        markers: this.superCluster.getLeaves(o.cluster_id, 1 / 0).map((a) => a.properties.marker),
        position: {
          lat: r,
          lng: n
        }
      });
    var i = o.marker;
    return new gk({
      markers: [i],
      position: ji.getPosition(i)
    });
  }
}
class eve {
  constructor(t, n) {
    this.markers = {
      sum: t.length
    };
    var r = n.map((i) => i.count), o = r.reduce((i, a) => i + a, 0);
    this.clusters = {
      count: n.length,
      markers: {
        mean: o / n.length,
        sum: o,
        min: Math.min(...r),
        max: Math.max(...r)
      }
    };
  }
}
class tve {
  /**
   * The default render function for the library used by {@link MarkerClusterer}.
   *
   * Currently set to use the following:
   *
   * ```typescript
   * // change color if this cluster has more markers than the mean cluster
   * const color =
   *   count > Math.max(10, stats.clusters.markers.mean)
   *     ? "#ff0000"
   *     : "#0000ff";
   *
   * // create svg url with fill color
   * const svg = window.btoa(`
   * <svg fill="${color}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240">
   *   <circle cx="120" cy="120" opacity=".6" r="70" />
   *   <circle cx="120" cy="120" opacity=".3" r="90" />
   *   <circle cx="120" cy="120" opacity=".2" r="110" />
   *   <circle cx="120" cy="120" opacity=".1" r="130" />
   * </svg>`);
   *
   * // create marker using svg icon
   * return new google.maps.Marker({
   *   position,
   *   icon: {
   *     url: `data:image/svg+xml;base64,${svg}`,
   *     scaledSize: new google.maps.Size(45, 45),
   *   },
   *   label: {
   *     text: String(count),
   *     color: "rgba(255,255,255,0.9)",
   *     fontSize: "12px",
   *   },
   *   // adjust zIndex to be above other markers
   *   zIndex: 1000 + count,
   * });
   * ```
   */
  render(t, n, r) {
    var {
      count: o,
      position: i
    } = t, a = o > Math.max(10, n.clusters.markers.mean) ? "#ff0000" : "#0000ff", s = '<svg fill="'.concat(a, `" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" width="50" height="50">
<circle cx="120" cy="120" opacity=".6" r="70" />
<circle cx="120" cy="120" opacity=".3" r="90" />
<circle cx="120" cy="120" opacity=".2" r="110" />
<text x="50%" y="50%" style="fill:#fff" text-anchor="middle" font-size="50" dominant-baseline="middle" font-family="roboto,arial,sans-serif">`).concat(o, `</text>
</svg>`), l = "Cluster of ".concat(o, " markers"), u = Number(google.maps.Marker.MAX_ZINDEX) + o;
    if (ji.isAdvancedMarkerAvailable(r)) {
      var c = new DOMParser(), p = c.parseFromString(s, "image/svg+xml").documentElement;
      p.setAttribute("transform", "translate(0 25)");
      var d = {
        map: r,
        position: i,
        zIndex: u,
        title: l,
        content: p
      };
      return new google.maps.marker.AdvancedMarkerElement(d);
    }
    var g = {
      position: i,
      zIndex: u,
      title: l,
      icon: {
        url: "data:image/svg+xml;base64,".concat(btoa(s)),
        anchor: new google.maps.Point(25, 25)
      }
    };
    return new google.maps.Marker(g);
  }
}
function nve(e, t) {
  for (var n in t.prototype)
    e.prototype[n] = t.prototype[n];
}
class HP {
  constructor() {
    nve(HP, google.maps.OverlayView);
  }
}
var td;
(function(e) {
  e.CLUSTERING_BEGIN = "clusteringbegin", e.CLUSTERING_END = "clusteringend", e.CLUSTER_CLICK = "click";
})(td || (td = {}));
var rve = (e, t, n) => {
  n.fitBounds(t.bounds);
};
class ove extends HP {
  constructor(t) {
    var {
      map: n,
      markers: r = [],
      algorithmOptions: o = {},
      algorithm: i = new Qme(o),
      renderer: a = new tve(),
      onClusterClick: s = rve
    } = t;
    super(), this.markers = [...r], this.clusters = [], this.algorithm = i, this.renderer = a, this.onClusterClick = s, n && this.setMap(n);
  }
  addMarker(t, n) {
    this.markers.includes(t) || (this.markers.push(t), n || this.render());
  }
  addMarkers(t, n) {
    t.forEach((r) => {
      this.addMarker(r, !0);
    }), n || this.render();
  }
  removeMarker(t, n) {
    var r = this.markers.indexOf(t);
    return r === -1 ? !1 : (ji.setMap(t, null), this.markers.splice(r, 1), n || this.render(), !0);
  }
  removeMarkers(t, n) {
    var r = !1;
    return t.forEach((o) => {
      r = this.removeMarker(o, !0) || r;
    }), r && !n && this.render(), r;
  }
  clearMarkers(t) {
    this.markers.length = 0, t || this.render();
  }
  /**
   * Recalculates and draws all the marker clusters.
   */
  render() {
    var t = this.getMap();
    if (t instanceof google.maps.Map && t.getProjection()) {
      google.maps.event.trigger(this, td.CLUSTERING_BEGIN, this);
      var {
        clusters: n,
        changed: r
      } = this.algorithm.calculate({
        markers: this.markers,
        map: t,
        mapCanvasProjection: this.getProjection()
      });
      if (r || r == null) {
        var o = /* @__PURE__ */ new Set();
        for (var i of n)
          i.markers.length == 1 && o.add(i.markers[0]);
        var a = [];
        for (var s of this.clusters)
          s.marker != null && (s.markers.length == 1 ? o.has(s.marker) || ji.setMap(s.marker, null) : a.push(s.marker));
        this.clusters = n, this.renderClusters(), requestAnimationFrame(() => a.forEach((l) => ji.setMap(l, null)));
      }
      google.maps.event.trigger(this, td.CLUSTERING_END, this);
    }
  }
  onAdd() {
    this.idleListener = this.getMap().addListener("idle", this.render.bind(this)), this.render();
  }
  onRemove() {
    google.maps.event.removeListener(this.idleListener), this.reset();
  }
  reset() {
    this.markers.forEach((t) => ji.setMap(t, null)), this.clusters.forEach((t) => t.delete()), this.clusters = [];
  }
  renderClusters() {
    var t = new eve(this.markers, this.clusters), n = this.getMap();
    this.clusters.forEach((r) => {
      r.markers.length === 1 ? r.marker = r.markers[0] : (r.marker = this.renderer.render(r, t, n), r.markers.forEach((o) => ji.setMap(o, null)), this.onClusterClick && r.marker.addListener(
        "click",
        /* istanbul ignore next */
        (o) => {
          google.maps.event.trigger(this, td.CLUSTER_CLICK, r), this.onClusterClick(o, r, n);
        }
      )), ji.setMap(r.marker, n);
    });
  }
}
function WI(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function VI(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? WI(Object(n), !0).forEach(function(r) {
      Ce(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : WI(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function ive(e) {
  var t = rme(), [n, r] = k(null);
  return h(() => {
    if (t && n === null) {
      var o = new ove(VI(VI({}, e), {}, {
        map: t
      }));
      r(o);
    }
  }, [t]), n;
}
function sve(e) {
  var {
    children: t,
    options: n
  } = e, r = ive(n);
  return r !== null ? t(r) : null;
}
ve(sve);
var ZI = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, qI = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
function ave(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, g = ge(Tt), [f, m] = k(null), [v, E] = k(null), [w, M] = k(null), [O, y] = k(null), [C, _] = k(null), [F, L] = k(null), N = ut(null);
  return h(() => {
    f !== null && (f.close(), n ? f.open(g, n) : f.getPosition() && f.open(g));
  }, [g, f, n]), h(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), h(() => {
    o && f !== null && f.setPosition(o);
  }, [o]), h(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), h(() => {
    f && a && (v !== null && google.maps.event.removeListener(v), E(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), h(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), M(google.maps.event.addListener(f, "domready", s)));
  }, [s]), h(() => {
    f && l && (O !== null && google.maps.event.removeListener(O), y(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), h(() => {
    f && u && (C !== null && google.maps.event.removeListener(C), _(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), h(() => {
    f && c && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), h(() => {
    var R = new google.maps.InfoWindow(r);
    return m(R), N.current = document.createElement("div"), a && E(google.maps.event.addListener(R, "closeclick", a)), s && M(google.maps.event.addListener(R, "domready", s)), l && y(google.maps.event.addListener(R, "content_changed", l)), u && _(google.maps.event.addListener(R, "position_changed", u)), c && L(google.maps.event.addListener(R, "zindex_changed", c)), R.setContent(N.current), o && R.setPosition(o), i && R.setZIndex(i), n ? R.open(g, n) : R.getPosition() ? R.open(g) : yo(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>."), p && p(R), () => {
      v && google.maps.event.removeListener(v), O && google.maps.event.removeListener(O), w && google.maps.event.removeListener(w), C && google.maps.event.removeListener(C), F && google.maps.event.removeListener(F), d && d(R), R.close();
    };
  }, []), N.current ? or(lt.only(t), N.current) : null;
}
ve(ave);
class lve extends pe {
  constructor() {
    super(...arguments), Ce(this, "registeredEvents", []), Ce(this, "containerElement", null), Ce(this, "state", {
      infoWindow: null
    }), Ce(this, "open", (t, n) => {
      n ? t.open(this.context, n) : t.getPosition() ? t.open(this.context) : yo(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>.");
    }), Ce(this, "setInfoWindowCallback", () => {
      this.state.infoWindow !== null && this.containerElement !== null && (this.state.infoWindow.setContent(this.containerElement), this.open(this.state.infoWindow, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoWindow));
    });
  }
  componentDidMount() {
    var t = new google.maps.InfoWindow(this.props.options);
    this.containerElement = document.createElement("div"), this.registeredEvents = an({
      updaterMap: qI,
      eventMap: ZI,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(() => ({
      infoWindow: t
    }), this.setInfoWindowCallback);
  }
  componentDidUpdate(t) {
    this.state.infoWindow !== null && (fn(this.registeredEvents), this.registeredEvents = an({
      updaterMap: qI,
      eventMap: ZI,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.infoWindow
    }));
  }
  componentWillUnmount() {
    this.state.infoWindow !== null && (fn(this.registeredEvents), this.props.onUnmount && this.props.onUnmount(this.state.infoWindow), this.state.infoWindow.close());
  }
  render() {
    return this.containerElement ? or(lt.only(this.props.children), this.containerElement) : null;
  }
}
Ce(lve, "contextType", Tt);
function GI(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function _v(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? GI(Object(n), !0).forEach(function(r) {
      Ce(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : GI(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var KI = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, YI = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, uve = {};
function cve(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: g,
    onRightClick: f,
    onClick: m,
    onDrag: v,
    onLoad: E,
    onUnmount: w
  } = e, M = ge(Tt), [O, y] = k(null), [C, _] = k(null), [F, L] = k(null), [N, R] = k(null), [W, V] = k(null), [z, Z] = k(null), [K, X] = k(null), [te, J] = k(null), [P, D] = k(null), [H, S] = k(null), [$, x] = k(null), [j, U] = k(null);
  return h(() => {
    O !== null && O.setMap(M);
  }, [M]), h(() => {
    typeof t < "u" && O !== null && O.setOptions(t);
  }, [O, t]), h(() => {
    typeof n < "u" && O !== null && O.setDraggable(n);
  }, [O, n]), h(() => {
    typeof r < "u" && O !== null && O.setEditable(r);
  }, [O, r]), h(() => {
    typeof o < "u" && O !== null && O.setVisible(o);
  }, [O, o]), h(() => {
    typeof i < "u" && O !== null && O.setPath(i);
  }, [O, i]), h(() => {
    O && a && (C !== null && google.maps.event.removeListener(C), _(google.maps.event.addListener(O, "dblclick", a)));
  }, [a]), h(() => {
    O && s && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(O, "dragend", s)));
  }, [s]), h(() => {
    O && l && (N !== null && google.maps.event.removeListener(N), R(google.maps.event.addListener(O, "dragstart", l)));
  }, [l]), h(() => {
    O && u && (W !== null && google.maps.event.removeListener(W), V(google.maps.event.addListener(O, "mousedown", u)));
  }, [u]), h(() => {
    O && c && (z !== null && google.maps.event.removeListener(z), Z(google.maps.event.addListener(O, "mousemove", c)));
  }, [c]), h(() => {
    O && p && (K !== null && google.maps.event.removeListener(K), X(google.maps.event.addListener(O, "mouseout", p)));
  }, [p]), h(() => {
    O && d && (te !== null && google.maps.event.removeListener(te), J(google.maps.event.addListener(O, "mouseover", d)));
  }, [d]), h(() => {
    O && g && (P !== null && google.maps.event.removeListener(P), D(google.maps.event.addListener(O, "mouseup", g)));
  }, [g]), h(() => {
    O && f && (H !== null && google.maps.event.removeListener(H), S(google.maps.event.addListener(O, "rightclick", f)));
  }, [f]), h(() => {
    O && m && ($ !== null && google.maps.event.removeListener($), x(google.maps.event.addListener(O, "click", m)));
  }, [m]), h(() => {
    O && v && (j !== null && google.maps.event.removeListener(j), U(google.maps.event.addListener(O, "drag", v)));
  }, [v]), h(() => {
    var T = new google.maps.Polyline(_v(_v({}, t || uve), {}, {
      map: M
    }));
    return i && T.setPath(i), typeof o < "u" && T.setVisible(o), typeof r < "u" && T.setEditable(r), typeof n < "u" && T.setDraggable(n), a && _(google.maps.event.addListener(T, "dblclick", a)), s && L(google.maps.event.addListener(T, "dragend", s)), l && R(google.maps.event.addListener(T, "dragstart", l)), u && V(google.maps.event.addListener(T, "mousedown", u)), c && Z(google.maps.event.addListener(T, "mousemove", c)), p && X(google.maps.event.addListener(T, "mouseout", p)), d && J(google.maps.event.addListener(T, "mouseover", d)), g && D(google.maps.event.addListener(T, "mouseup", g)), f && S(google.maps.event.addListener(T, "rightclick", f)), m && x(google.maps.event.addListener(T, "click", m)), v && U(google.maps.event.addListener(T, "drag", v)), y(T), E && E(T), () => {
      C !== null && google.maps.event.removeListener(C), F !== null && google.maps.event.removeListener(F), N !== null && google.maps.event.removeListener(N), W !== null && google.maps.event.removeListener(W), z !== null && google.maps.event.removeListener(z), K !== null && google.maps.event.removeListener(K), te !== null && google.maps.event.removeListener(te), P !== null && google.maps.event.removeListener(P), H !== null && google.maps.event.removeListener(H), $ !== null && google.maps.event.removeListener($), w && w(T), T.setMap(null);
    };
  }, []), null;
}
ve(cve);
class pve extends pe {
  constructor() {
    super(...arguments), Ce(this, "registeredEvents", []), Ce(this, "state", {
      polyline: null
    }), Ce(this, "setPolylineCallback", () => {
      this.state.polyline !== null && this.props.onLoad && this.props.onLoad(this.state.polyline);
    });
  }
  componentDidMount() {
    var t = new google.maps.Polyline(_v(_v({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = an({
      updaterMap: YI,
      eventMap: KI,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        polyline: t
      };
    }, this.setPolylineCallback);
  }
  componentDidUpdate(t) {
    this.state.polyline !== null && (fn(this.registeredEvents), this.registeredEvents = an({
      updaterMap: YI,
      eventMap: KI,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.polyline
    }));
  }
  componentWillUnmount() {
    this.state.polyline !== null && (this.props.onUnmount && this.props.onUnmount(this.state.polyline), fn(this.registeredEvents), this.state.polyline.setMap(null));
  }
  render() {
    return null;
  }
}
Ce(pve, "contextType", Tt);
function XI(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function JI(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? XI(Object(n), !0).forEach(function(r) {
      Ce(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : XI(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var QI = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, eR = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  paths(e, t) {
    e.setPaths(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function dve(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    paths: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: g,
    onMouseUp: f,
    onRightClick: m,
    onClick: v,
    onDrag: E,
    onLoad: w,
    onUnmount: M,
    onEdit: O
  } = e, y = ge(Tt), [C, _] = k(null), [F, L] = k(null), [N, R] = k(null), [W, V] = k(null), [z, Z] = k(null), [K, X] = k(null), [te, J] = k(null), [P, D] = k(null), [H, S] = k(null), [$, x] = k(null), [j, U] = k(null), [T, q] = k(null);
  return h(() => {
    C !== null && C.setMap(y);
  }, [y]), h(() => {
    typeof t < "u" && C !== null && C.setOptions(t);
  }, [C, t]), h(() => {
    typeof n < "u" && C !== null && C.setDraggable(n);
  }, [C, n]), h(() => {
    typeof r < "u" && C !== null && C.setEditable(r);
  }, [C, r]), h(() => {
    typeof o < "u" && C !== null && C.setVisible(o);
  }, [C, o]), h(() => {
    typeof i < "u" && C !== null && C.setPath(i);
  }, [C, i]), h(() => {
    typeof a < "u" && C !== null && C.setPaths(a);
  }, [C, a]), h(() => {
    C && typeof s == "function" && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(C, "dblclick", s)));
  }, [s]), h(() => {
    C && (google.maps.event.addListener(C.getPath(), "insert_at", () => {
      O == null || O(C);
    }), google.maps.event.addListener(C.getPath(), "set_at", () => {
      O == null || O(C);
    }), google.maps.event.addListener(C.getPath(), "remove_at", () => {
      O == null || O(C);
    }));
  }, [C, O]), h(() => {
    C && typeof l == "function" && (N !== null && google.maps.event.removeListener(N), R(google.maps.event.addListener(C, "dragend", l)));
  }, [l]), h(() => {
    C && typeof u == "function" && (W !== null && google.maps.event.removeListener(W), V(google.maps.event.addListener(C, "dragstart", u)));
  }, [u]), h(() => {
    C && typeof c == "function" && (z !== null && google.maps.event.removeListener(z), Z(google.maps.event.addListener(C, "mousedown", c)));
  }, [c]), h(() => {
    C && typeof p == "function" && (K !== null && google.maps.event.removeListener(K), X(google.maps.event.addListener(C, "mousemove", p)));
  }, [p]), h(() => {
    C && typeof d == "function" && (te !== null && google.maps.event.removeListener(te), J(google.maps.event.addListener(C, "mouseout", d)));
  }, [d]), h(() => {
    C && typeof g == "function" && (P !== null && google.maps.event.removeListener(P), D(google.maps.event.addListener(C, "mouseover", g)));
  }, [g]), h(() => {
    C && typeof f == "function" && (H !== null && google.maps.event.removeListener(H), S(google.maps.event.addListener(C, "mouseup", f)));
  }, [f]), h(() => {
    C && typeof m == "function" && ($ !== null && google.maps.event.removeListener($), x(google.maps.event.addListener(C, "rightclick", m)));
  }, [m]), h(() => {
    C && typeof v == "function" && (j !== null && google.maps.event.removeListener(j), U(google.maps.event.addListener(C, "click", v)));
  }, [v]), h(() => {
    C && typeof E == "function" && (T !== null && google.maps.event.removeListener(T), q(google.maps.event.addListener(C, "drag", E)));
  }, [E]), h(() => {
    var A = new google.maps.Polygon(JI(JI({}, t), {}, {
      map: y
    }));
    return i && A.setPath(i), a && A.setPaths(a), typeof o < "u" && A.setVisible(o), typeof r < "u" && A.setEditable(r), typeof n < "u" && A.setDraggable(n), s && L(google.maps.event.addListener(A, "dblclick", s)), l && R(google.maps.event.addListener(A, "dragend", l)), u && V(google.maps.event.addListener(A, "dragstart", u)), c && Z(google.maps.event.addListener(A, "mousedown", c)), p && X(google.maps.event.addListener(A, "mousemove", p)), d && J(google.maps.event.addListener(A, "mouseout", d)), g && D(google.maps.event.addListener(A, "mouseover", g)), f && S(google.maps.event.addListener(A, "mouseup", f)), m && x(google.maps.event.addListener(A, "rightclick", m)), v && U(google.maps.event.addListener(A, "click", v)), E && q(google.maps.event.addListener(A, "drag", E)), _(A), w && w(A), () => {
      F !== null && google.maps.event.removeListener(F), N !== null && google.maps.event.removeListener(N), W !== null && google.maps.event.removeListener(W), z !== null && google.maps.event.removeListener(z), K !== null && google.maps.event.removeListener(K), te !== null && google.maps.event.removeListener(te), P !== null && google.maps.event.removeListener(P), H !== null && google.maps.event.removeListener(H), $ !== null && google.maps.event.removeListener($), j !== null && google.maps.event.removeListener(j), M && M(A), A.setMap(null);
    };
  }, []), null;
}
ve(dve);
class fve extends pe {
  constructor() {
    super(...arguments), Ce(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this.props.options || {};
    this.polygon = new google.maps.Polygon(t), this.polygon.setMap(this.context), this.registeredEvents = an({
      updaterMap: eR,
      eventMap: QI,
      prevProps: {},
      nextProps: this.props,
      instance: this.polygon
    }), this.props.onLoad && this.props.onLoad(this.polygon);
  }
  componentDidUpdate(t) {
    this.polygon && (fn(this.registeredEvents), this.registeredEvents = an({
      updaterMap: eR,
      eventMap: QI,
      prevProps: t,
      nextProps: this.props,
      instance: this.polygon
    }));
  }
  componentWillUnmount() {
    this.polygon && (this.props.onUnmount && this.props.onUnmount(this.polygon), fn(this.registeredEvents), this.polygon && this.polygon.setMap(null));
  }
  render() {
    return null;
  }
}
Ce(fve, "contextType", Tt);
function tR(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Sv(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? tR(Object(n), !0).forEach(function(r) {
      Ce(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : tR(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var nR = {
  onBoundsChanged: "bounds_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, rR = {
  bounds(e, t) {
    e.setBounds(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function hve(e) {
  var {
    options: t,
    bounds: n,
    draggable: r,
    editable: o,
    visible: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: g,
    onRightClick: f,
    onClick: m,
    onDrag: v,
    onBoundsChanged: E,
    onLoad: w,
    onUnmount: M
  } = e, O = ge(Tt), [y, C] = k(null), [_, F] = k(null), [L, N] = k(null), [R, W] = k(null), [V, z] = k(null), [Z, K] = k(null), [X, te] = k(null), [J, P] = k(null), [D, H] = k(null), [S, $] = k(null), [x, j] = k(null), [U, T] = k(null), [q, A] = k(null);
  return h(() => {
    y !== null && y.setMap(O);
  }, [O]), h(() => {
    typeof t < "u" && y !== null && y.setOptions(t);
  }, [y, t]), h(() => {
    typeof r < "u" && y !== null && y.setDraggable(r);
  }, [y, r]), h(() => {
    typeof o < "u" && y !== null && y.setEditable(o);
  }, [y, o]), h(() => {
    typeof i < "u" && y !== null && y.setVisible(i);
  }, [y, i]), h(() => {
    typeof n < "u" && y !== null && y.setBounds(n);
  }, [y, n]), h(() => {
    y && a && (_ !== null && google.maps.event.removeListener(_), F(google.maps.event.addListener(y, "dblclick", a)));
  }, [a]), h(() => {
    y && s && (L !== null && google.maps.event.removeListener(L), N(google.maps.event.addListener(y, "dragend", s)));
  }, [s]), h(() => {
    y && l && (R !== null && google.maps.event.removeListener(R), W(google.maps.event.addListener(y, "dragstart", l)));
  }, [l]), h(() => {
    y && u && (V !== null && google.maps.event.removeListener(V), z(google.maps.event.addListener(y, "mousedown", u)));
  }, [u]), h(() => {
    y && c && (Z !== null && google.maps.event.removeListener(Z), K(google.maps.event.addListener(y, "mousemove", c)));
  }, [c]), h(() => {
    y && p && (X !== null && google.maps.event.removeListener(X), te(google.maps.event.addListener(y, "mouseout", p)));
  }, [p]), h(() => {
    y && d && (J !== null && google.maps.event.removeListener(J), P(google.maps.event.addListener(y, "mouseover", d)));
  }, [d]), h(() => {
    y && g && (D !== null && google.maps.event.removeListener(D), H(google.maps.event.addListener(y, "mouseup", g)));
  }, [g]), h(() => {
    y && f && (S !== null && google.maps.event.removeListener(S), $(google.maps.event.addListener(y, "rightclick", f)));
  }, [f]), h(() => {
    y && m && (x !== null && google.maps.event.removeListener(x), j(google.maps.event.addListener(y, "click", m)));
  }, [m]), h(() => {
    y && v && (U !== null && google.maps.event.removeListener(U), T(google.maps.event.addListener(y, "drag", v)));
  }, [v]), h(() => {
    y && E && (q !== null && google.maps.event.removeListener(q), A(google.maps.event.addListener(y, "bounds_changed", E)));
  }, [E]), h(() => {
    var Y = new google.maps.Rectangle(Sv(Sv({}, t), {}, {
      map: O
    }));
    return typeof i < "u" && Y.setVisible(i), typeof o < "u" && Y.setEditable(o), typeof r < "u" && Y.setDraggable(r), typeof n < "u" && Y.setBounds(n), a && F(google.maps.event.addListener(Y, "dblclick", a)), s && N(google.maps.event.addListener(Y, "dragend", s)), l && W(google.maps.event.addListener(Y, "dragstart", l)), u && z(google.maps.event.addListener(Y, "mousedown", u)), c && K(google.maps.event.addListener(Y, "mousemove", c)), p && te(google.maps.event.addListener(Y, "mouseout", p)), d && P(google.maps.event.addListener(Y, "mouseover", d)), g && H(google.maps.event.addListener(Y, "mouseup", g)), f && $(google.maps.event.addListener(Y, "rightclick", f)), m && j(google.maps.event.addListener(Y, "click", m)), v && T(google.maps.event.addListener(Y, "drag", v)), E && A(google.maps.event.addListener(Y, "bounds_changed", E)), C(Y), w && w(Y), () => {
      _ !== null && google.maps.event.removeListener(_), L !== null && google.maps.event.removeListener(L), R !== null && google.maps.event.removeListener(R), V !== null && google.maps.event.removeListener(V), Z !== null && google.maps.event.removeListener(Z), X !== null && google.maps.event.removeListener(X), J !== null && google.maps.event.removeListener(J), D !== null && google.maps.event.removeListener(D), S !== null && google.maps.event.removeListener(S), x !== null && google.maps.event.removeListener(x), U !== null && google.maps.event.removeListener(U), q !== null && google.maps.event.removeListener(q), M && M(Y), Y.setMap(null);
    };
  }, []), null;
}
ve(hve);
class gve extends pe {
  constructor() {
    super(...arguments), Ce(this, "registeredEvents", []), Ce(this, "state", {
      rectangle: null
    }), Ce(this, "setRectangleCallback", () => {
      this.state.rectangle !== null && this.props.onLoad && this.props.onLoad(this.state.rectangle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Rectangle(Sv(Sv({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = an({
      updaterMap: rR,
      eventMap: nR,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        rectangle: t
      };
    }, this.setRectangleCallback);
  }
  componentDidUpdate(t) {
    this.state.rectangle !== null && (fn(this.registeredEvents), this.registeredEvents = an({
      updaterMap: rR,
      eventMap: nR,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.rectangle
    }));
  }
  componentWillUnmount() {
    this.state.rectangle !== null && (this.props.onUnmount && this.props.onUnmount(this.state.rectangle), fn(this.registeredEvents), this.state.rectangle.setMap(null));
  }
  render() {
    return null;
  }
}
Ce(gve, "contextType", Tt);
function oR(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Mv(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? oR(Object(n), !0).forEach(function(r) {
      Ce(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : oR(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var iR = {
  onCenterChanged: "center_changed",
  onRadiusChanged: "radius_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, sR = {
  center(e, t) {
    e.setCenter(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  radius(e, t) {
    e.setRadius(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, mve = {};
function vve(e) {
  var {
    options: t,
    center: n,
    radius: r,
    draggable: o,
    editable: i,
    visible: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: g,
    onMouseUp: f,
    onRightClick: m,
    onClick: v,
    onDrag: E,
    onCenterChanged: w,
    onRadiusChanged: M,
    onLoad: O,
    onUnmount: y
  } = e, C = ge(Tt), [_, F] = k(null), [L, N] = k(null), [R, W] = k(null), [V, z] = k(null), [Z, K] = k(null), [X, te] = k(null), [J, P] = k(null), [D, H] = k(null), [S, $] = k(null), [x, j] = k(null), [U, T] = k(null), [q, A] = k(null), [Y, B] = k(null), [ue, fe] = k(null);
  return h(() => {
    _ !== null && _.setMap(C);
  }, [C]), h(() => {
    typeof t < "u" && _ !== null && _.setOptions(t);
  }, [_, t]), h(() => {
    typeof o < "u" && _ !== null && _.setDraggable(o);
  }, [_, o]), h(() => {
    typeof i < "u" && _ !== null && _.setEditable(i);
  }, [_, i]), h(() => {
    typeof a < "u" && _ !== null && _.setVisible(a);
  }, [_, a]), h(() => {
    typeof r == "number" && _ !== null && _.setRadius(r);
  }, [_, r]), h(() => {
    typeof n < "u" && _ !== null && _.setCenter(n);
  }, [_, n]), h(() => {
    _ && s && (L !== null && google.maps.event.removeListener(L), N(google.maps.event.addListener(_, "dblclick", s)));
  }, [s]), h(() => {
    _ && l && (R !== null && google.maps.event.removeListener(R), W(google.maps.event.addListener(_, "dragend", l)));
  }, [l]), h(() => {
    _ && u && (V !== null && google.maps.event.removeListener(V), z(google.maps.event.addListener(_, "dragstart", u)));
  }, [u]), h(() => {
    _ && c && (Z !== null && google.maps.event.removeListener(Z), K(google.maps.event.addListener(_, "mousedown", c)));
  }, [c]), h(() => {
    _ && p && (X !== null && google.maps.event.removeListener(X), te(google.maps.event.addListener(_, "mousemove", p)));
  }, [p]), h(() => {
    _ && d && (J !== null && google.maps.event.removeListener(J), P(google.maps.event.addListener(_, "mouseout", d)));
  }, [d]), h(() => {
    _ && g && (D !== null && google.maps.event.removeListener(D), H(google.maps.event.addListener(_, "mouseover", g)));
  }, [g]), h(() => {
    _ && f && (S !== null && google.maps.event.removeListener(S), $(google.maps.event.addListener(_, "mouseup", f)));
  }, [f]), h(() => {
    _ && m && (x !== null && google.maps.event.removeListener(x), j(google.maps.event.addListener(_, "rightclick", m)));
  }, [m]), h(() => {
    _ && v && (U !== null && google.maps.event.removeListener(U), T(google.maps.event.addListener(_, "click", v)));
  }, [v]), h(() => {
    _ && E && (q !== null && google.maps.event.removeListener(q), A(google.maps.event.addListener(_, "drag", E)));
  }, [E]), h(() => {
    _ && w && (Y !== null && google.maps.event.removeListener(Y), B(google.maps.event.addListener(_, "center_changed", w)));
  }, [v]), h(() => {
    _ && M && (ue !== null && google.maps.event.removeListener(ue), fe(google.maps.event.addListener(_, "radius_changed", M)));
  }, [M]), h(() => {
    var oe = new google.maps.Circle(Mv(Mv({}, t || mve), {}, {
      map: C
    }));
    return typeof r == "number" && oe.setRadius(r), typeof n < "u" && oe.setCenter(n), typeof r == "number" && oe.setRadius(r), typeof a < "u" && oe.setVisible(a), typeof i < "u" && oe.setEditable(i), typeof o < "u" && oe.setDraggable(o), s && N(google.maps.event.addListener(oe, "dblclick", s)), l && W(google.maps.event.addListener(oe, "dragend", l)), u && z(google.maps.event.addListener(oe, "dragstart", u)), c && K(google.maps.event.addListener(oe, "mousedown", c)), p && te(google.maps.event.addListener(oe, "mousemove", p)), d && P(google.maps.event.addListener(oe, "mouseout", d)), g && H(google.maps.event.addListener(oe, "mouseover", g)), f && $(google.maps.event.addListener(oe, "mouseup", f)), m && j(google.maps.event.addListener(oe, "rightclick", m)), v && T(google.maps.event.addListener(oe, "click", v)), E && A(google.maps.event.addListener(oe, "drag", E)), w && B(google.maps.event.addListener(oe, "center_changed", w)), M && fe(google.maps.event.addListener(oe, "radius_changed", M)), F(oe), O && O(oe), () => {
      L !== null && google.maps.event.removeListener(L), R !== null && google.maps.event.removeListener(R), V !== null && google.maps.event.removeListener(V), Z !== null && google.maps.event.removeListener(Z), X !== null && google.maps.event.removeListener(X), J !== null && google.maps.event.removeListener(J), D !== null && google.maps.event.removeListener(D), S !== null && google.maps.event.removeListener(S), x !== null && google.maps.event.removeListener(x), U !== null && google.maps.event.removeListener(U), Y !== null && google.maps.event.removeListener(Y), ue !== null && google.maps.event.removeListener(ue), y && y(oe), oe.setMap(null);
    };
  }, []), null;
}
ve(vve);
class yve extends pe {
  constructor() {
    super(...arguments), Ce(this, "registeredEvents", []), Ce(this, "state", {
      circle: null
    }), Ce(this, "setCircleCallback", () => {
      this.state.circle !== null && this.props.onLoad && this.props.onLoad(this.state.circle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Circle(Mv(Mv({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = an({
      updaterMap: sR,
      eventMap: iR,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        circle: t
      };
    }, this.setCircleCallback);
  }
  componentDidUpdate(t) {
    this.state.circle !== null && (fn(this.registeredEvents), this.registeredEvents = an({
      updaterMap: sR,
      eventMap: iR,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.circle
    }));
  }
  componentWillUnmount() {
    if (this.state.circle !== null) {
      var t;
      this.props.onUnmount && this.props.onUnmount(this.state.circle), fn(this.registeredEvents), (t = this.state.circle) === null || t === void 0 || t.setMap(null);
    }
  }
  render() {
    return null;
  }
}
Ce(yve, "contextType", Tt);
function aR(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Dv(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? aR(Object(n), !0).forEach(function(r) {
      Ce(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : aR(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var lR = {
  onClick: "click",
  onDblClick: "dblclick",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onAddFeature: "addfeature",
  onRemoveFeature: "removefeature",
  onRemoveProperty: "removeproperty",
  onSetGeometry: "setgeometry",
  onSetProperty: "setproperty"
}, uR = {
  add(e, t) {
    e.add(t);
  },
  addgeojson(e, t, n) {
    e.addGeoJson(t, n);
  },
  contains(e, t) {
    e.contains(t);
  },
  foreach(e, t) {
    e.forEach(t);
  },
  loadgeojson(e, t, n, r) {
    e.loadGeoJson(t, n, r);
  },
  overridestyle(e, t, n) {
    e.overrideStyle(t, n);
  },
  remove(e, t) {
    e.remove(t);
  },
  revertstyle(e, t) {
    e.revertStyle(t);
  },
  controlposition(e, t) {
    e.setControlPosition(t);
  },
  controls(e, t) {
    e.setControls(t);
  },
  drawingmode(e, t) {
    e.setDrawingMode(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  style(e, t) {
    e.setStyle(t);
  },
  togeojson(e, t) {
    e.toGeoJson(t);
  }
};
function bve(e) {
  var {
    options: t,
    onClick: n,
    onDblClick: r,
    onMouseDown: o,
    onMouseMove: i,
    onMouseOut: a,
    onMouseOver: s,
    onMouseUp: l,
    onRightClick: u,
    onAddFeature: c,
    onRemoveFeature: p,
    onRemoveProperty: d,
    onSetGeometry: g,
    onSetProperty: f,
    onLoad: m,
    onUnmount: v
  } = e, E = ge(Tt), [w, M] = k(null), [O, y] = k(null), [C, _] = k(null), [F, L] = k(null), [N, R] = k(null), [W, V] = k(null), [z, Z] = k(null), [K, X] = k(null), [te, J] = k(null), [P, D] = k(null), [H, S] = k(null), [$, x] = k(null), [j, U] = k(null), [T, q] = k(null);
  return h(() => {
    w !== null && w.setMap(E);
  }, [E]), h(() => {
    w && r && (O !== null && google.maps.event.removeListener(O), y(google.maps.event.addListener(w, "dblclick", r)));
  }, [r]), h(() => {
    w && o && (C !== null && google.maps.event.removeListener(C), _(google.maps.event.addListener(w, "mousedown", o)));
  }, [o]), h(() => {
    w && i && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(w, "mousemove", i)));
  }, [i]), h(() => {
    w && a && (N !== null && google.maps.event.removeListener(N), R(google.maps.event.addListener(w, "mouseout", a)));
  }, [a]), h(() => {
    w && s && (W !== null && google.maps.event.removeListener(W), V(google.maps.event.addListener(w, "mouseover", s)));
  }, [s]), h(() => {
    w && l && (z !== null && google.maps.event.removeListener(z), Z(google.maps.event.addListener(w, "mouseup", l)));
  }, [l]), h(() => {
    w && u && (K !== null && google.maps.event.removeListener(K), X(google.maps.event.addListener(w, "rightclick", u)));
  }, [u]), h(() => {
    w && n && (te !== null && google.maps.event.removeListener(te), J(google.maps.event.addListener(w, "click", n)));
  }, [n]), h(() => {
    w && c && (P !== null && google.maps.event.removeListener(P), D(google.maps.event.addListener(w, "addfeature", c)));
  }, [c]), h(() => {
    w && p && (H !== null && google.maps.event.removeListener(H), S(google.maps.event.addListener(w, "removefeature", p)));
  }, [p]), h(() => {
    w && d && ($ !== null && google.maps.event.removeListener($), x(google.maps.event.addListener(w, "removeproperty", d)));
  }, [d]), h(() => {
    w && g && (j !== null && google.maps.event.removeListener(j), U(google.maps.event.addListener(w, "setgeometry", g)));
  }, [g]), h(() => {
    w && f && (T !== null && google.maps.event.removeListener(T), q(google.maps.event.addListener(w, "setproperty", f)));
  }, [f]), h(() => {
    if (E !== null) {
      var A = new google.maps.Data(Dv(Dv({}, t), {}, {
        map: E
      }));
      r && y(google.maps.event.addListener(A, "dblclick", r)), o && _(google.maps.event.addListener(A, "mousedown", o)), i && L(google.maps.event.addListener(A, "mousemove", i)), a && R(google.maps.event.addListener(A, "mouseout", a)), s && V(google.maps.event.addListener(A, "mouseover", s)), l && Z(google.maps.event.addListener(A, "mouseup", l)), u && X(google.maps.event.addListener(A, "rightclick", u)), n && J(google.maps.event.addListener(A, "click", n)), c && D(google.maps.event.addListener(A, "addfeature", c)), p && S(google.maps.event.addListener(A, "removefeature", p)), d && x(google.maps.event.addListener(A, "removeproperty", d)), g && U(google.maps.event.addListener(A, "setgeometry", g)), f && q(google.maps.event.addListener(A, "setproperty", f)), M(A), m && m(A);
    }
    return () => {
      w && (O !== null && google.maps.event.removeListener(O), C !== null && google.maps.event.removeListener(C), F !== null && google.maps.event.removeListener(F), N !== null && google.maps.event.removeListener(N), W !== null && google.maps.event.removeListener(W), z !== null && google.maps.event.removeListener(z), K !== null && google.maps.event.removeListener(K), te !== null && google.maps.event.removeListener(te), P !== null && google.maps.event.removeListener(P), H !== null && google.maps.event.removeListener(H), $ !== null && google.maps.event.removeListener($), j !== null && google.maps.event.removeListener(j), T !== null && google.maps.event.removeListener(T), v && v(w), w.setMap(null));
    };
  }, []), null;
}
ve(bve);
class wve extends pe {
  constructor() {
    super(...arguments), Ce(this, "registeredEvents", []), Ce(this, "state", {
      data: null
    }), Ce(this, "setDataCallback", () => {
      this.state.data !== null && this.props.onLoad && this.props.onLoad(this.state.data);
    });
  }
  componentDidMount() {
    if (this.context !== null) {
      var t = new google.maps.Data(Dv(Dv({}, this.props.options), {}, {
        map: this.context
      }));
      this.registeredEvents = an({
        updaterMap: uR,
        eventMap: lR,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        data: t
      }), this.setDataCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.data !== null && (fn(this.registeredEvents), this.registeredEvents = an({
      updaterMap: uR,
      eventMap: lR,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.data
    }));
  }
  componentWillUnmount() {
    this.state.data !== null && (this.props.onUnmount && this.props.onUnmount(this.state.data), fn(this.registeredEvents), this.state.data && this.state.data.setMap(null));
  }
  render() {
    return null;
  }
}
Ce(wve, "contextType", Tt);
function cR(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function pR(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? cR(Object(n), !0).forEach(function(r) {
      Ce(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : cR(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var dR = {
  onClick: "click",
  onDefaultViewportChanged: "defaultviewport_changed",
  onStatusChanged: "status_changed"
}, fR = {
  options(e, t) {
    e.setOptions(t);
  },
  url(e, t) {
    e.setUrl(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
class Cve extends pe {
  constructor() {
    super(...arguments), Ce(this, "registeredEvents", []), Ce(this, "state", {
      kmlLayer: null
    }), Ce(this, "setKmlLayerCallback", () => {
      this.state.kmlLayer !== null && this.props.onLoad && this.props.onLoad(this.state.kmlLayer);
    });
  }
  componentDidMount() {
    var t = new google.maps.KmlLayer(pR(pR({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = an({
      updaterMap: fR,
      eventMap: dR,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        kmlLayer: t
      };
    }, this.setKmlLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.kmlLayer !== null && (fn(this.registeredEvents), this.registeredEvents = an({
      updaterMap: fR,
      eventMap: dR,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.kmlLayer
    }));
  }
  componentWillUnmount() {
    this.state.kmlLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.kmlLayer), fn(this.registeredEvents), this.state.kmlLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Ce(Cve, "contextType", Tt);
function vZ(e, t) {
  return typeof t == "function" ? t(e.offsetWidth, e.offsetHeight) : {
    x: 0,
    y: 0
  };
}
function xve(e, t) {
  return new t(e.lat, e.lng);
}
function Ove(e, t) {
  return new t(new google.maps.LatLng(e.ne.lat, e.ne.lng), new google.maps.LatLng(e.sw.lat, e.sw.lng));
}
function Eve(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function kve(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function Lve(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n.getNorthEast()), o = e && e.fromLatLngToDivPixel(n.getSouthWest());
  return r && o ? {
    left: "".concat(o.x + t.x, "px"),
    top: "".concat(r.y + t.y, "px"),
    width: "".concat(r.x - o.x - t.x, "px"),
    height: "".concat(o.y - r.y - t.y, "px")
  } : {
    left: "-9999px",
    top: "-9999px"
  };
}
function Pve(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n);
  if (r) {
    var {
      x: o,
      y: i
    } = r;
    return {
      left: "".concat(o + t.x, "px"),
      top: "".concat(i + t.y, "px")
    };
  }
  return {
    left: "-9999px",
    top: "-9999px"
  };
}
function yZ(e, t, n, r) {
  return n !== void 0 ? Lve(e, t, kve(n, google.maps.LatLngBounds, Ove)) : Pve(e, t, Eve(r, google.maps.LatLng, xve));
}
function _ve(e, t) {
  return e.left === t.left && e.top === t.top && e.width === t.height && e.height === t.height;
}
function hR(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Sve(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? hR(Object(n), !0).forEach(function(r) {
      Ce(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : hR(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function Mve(e, t, n, r, o) {
  class i extends google.maps.OverlayView {
    constructor(s, l, u, c) {
      super(), this.container = s, this.pane = l, this.position = u, this.bounds = c;
    }
    onAdd() {
      var s, l = (s = this.getPanes()) === null || s === void 0 ? void 0 : s[this.pane];
      l == null || l.appendChild(this.container);
    }
    draw() {
      var s = this.getProjection(), l = Sve({}, this.container ? vZ(this.container, o) : {
        x: 0,
        y: 0
      }), u = yZ(s, l, this.bounds, this.position);
      for (var [c, p] of Object.entries(u))
        this.container.style[c] = p;
    }
    onRemove() {
      this.container.parentNode !== null && this.container.parentNode.removeChild(this.container);
    }
  }
  return new i(e, t, n, r);
}
function gR(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Dve(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? gR(Object(n), !0).forEach(function(r) {
      Ce(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : gR(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function mR(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLng ? e : new google.maps.LatLng(e.lat, e.lng);
  return t + "";
}
function vR(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLngBounds ? e : new google.maps.LatLngBounds(new google.maps.LatLng(e.south, e.east), new google.maps.LatLng(e.north, e.west));
  return t + "";
}
function Tve(e) {
  var {
    position: t,
    bounds: n,
    mapPaneName: r,
    zIndex: o,
    onLoad: i,
    onUnmount: a,
    getPixelPositionOffset: s,
    children: l
  } = e, u = ge(Tt), c = Cn(() => {
    var d = document.createElement("div");
    return d.style.position = "absolute", d;
  }, []), p = Cn(() => Mve(c, r, t, n, s), [c, r, t, n]);
  return h(() => (i == null || i(p), p == null || p.setMap(u), () => {
    a == null || a(p), p == null || p.setMap(null);
  }), [u, p]), h(() => {
    c.style.zIndex = "".concat(o);
  }, [o, c]), wi.createPortal(l, c);
}
ve(Tve);
class Sc extends pe {
  constructor(t) {
    super(t), Ce(this, "state", {
      paneEl: null,
      containerStyle: {
        // set initial position
        position: "absolute"
      }
    }), Ce(this, "updatePane", () => {
      var r = this.props.mapPaneName, o = this.overlayView.getPanes();
      yo(!!r, "OverlayView requires props.mapPaneName but got %s", r), o ? this.setState({
        paneEl: o[r]
      }) : this.setState({
        paneEl: null
      });
    }), Ce(this, "onAdd", () => {
      var r, o;
      this.updatePane(), (r = (o = this.props).onLoad) === null || r === void 0 || r.call(o, this.overlayView);
    }), Ce(this, "onPositionElement", () => {
      var r = this.overlayView.getProjection(), o = Dve({
        x: 0,
        y: 0
      }, this.containerRef.current ? vZ(this.containerRef.current, this.props.getPixelPositionOffset) : {}), i = yZ(r, o, this.props.bounds, this.props.position);
      if (!_ve(i, {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        left: this.state.containerStyle.left,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        top: this.state.containerStyle.top,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        width: this.state.containerStyle.width,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        height: this.state.containerStyle.height
      })) {
        var a, s, l, u;
        this.setState({
          containerStyle: {
            top: (a = i.top) !== null && a !== void 0 ? a : 0,
            left: (s = i.left) !== null && s !== void 0 ? s : 0,
            width: (l = i.width) !== null && l !== void 0 ? l : 0,
            height: (u = i.height) !== null && u !== void 0 ? u : 0,
            position: "absolute"
          }
        });
      }
    }), Ce(this, "draw", () => {
      this.onPositionElement();
    }), Ce(this, "onRemove", () => {
      var r, o;
      this.setState(() => ({
        paneEl: null
      })), (r = (o = this.props).onUnmount) === null || r === void 0 || r.call(o, this.overlayView);
    }), this.containerRef = mo();
    var n = new google.maps.OverlayView();
    n.onAdd = this.onAdd, n.draw = this.draw, n.onRemove = this.onRemove, this.overlayView = n;
  }
  componentDidMount() {
    this.overlayView.setMap(this.context);
  }
  componentDidUpdate(t) {
    var n = mR(t.position), r = mR(this.props.position), o = vR(t.bounds), i = vR(this.props.bounds);
    (n !== r || o !== i) && this.overlayView.draw(), t.mapPaneName !== this.props.mapPaneName && this.updatePane();
  }
  componentWillUnmount() {
    this.overlayView.setMap(null);
  }
  render() {
    var t = this.state.paneEl;
    return t ? wi.createPortal(Do.jsx("div", {
      ref: this.containerRef,
      style: this.state.containerStyle,
      children: lt.only(this.props.children)
    }), t) : null;
  }
}
Ce(Sc, "FLOAT_PANE", "floatPane");
Ce(Sc, "MAP_PANE", "mapPane");
Ce(Sc, "MARKER_LAYER", "markerLayer");
Ce(Sc, "OVERLAY_LAYER", "overlayLayer");
Ce(Sc, "OVERLAY_MOUSE_TARGET", "overlayMouseTarget");
Ce(Sc, "contextType", Tt);
function jve() {
}
function yR(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function bR(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? yR(Object(n), !0).forEach(function(r) {
      Ce(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : yR(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var wR = {
  onDblClick: "dblclick",
  onClick: "click"
}, CR = {
  opacity(e, t) {
    e.setOpacity(t);
  }
};
function Ave(e) {
  var {
    url: t,
    bounds: n,
    options: r,
    visible: o
  } = e, i = ge(Tt), a = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east)), s = Cn(() => new google.maps.GroundOverlay(t, a, r), []);
  return h(() => {
    s !== null && s.setMap(i);
  }, [i]), h(() => {
    typeof t < "u" && s !== null && (s.set("url", t), s.setMap(i));
  }, [s, t]), h(() => {
    typeof o < "u" && s !== null && s.setOpacity(o ? 1 : 0);
  }, [s, o]), h(() => {
    var l = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east));
    typeof n < "u" && s !== null && (s.set("bounds", l), s.setMap(i));
  }, [s, n]), null;
}
ve(Ave);
class bZ extends pe {
  constructor() {
    super(...arguments), Ce(this, "registeredEvents", []), Ce(this, "state", {
      groundOverlay: null
    }), Ce(this, "setGroundOverlayCallback", () => {
      this.state.groundOverlay !== null && this.props.onLoad && this.props.onLoad(this.state.groundOverlay);
    });
  }
  componentDidMount() {
    yo(!!this.props.url || !!this.props.bounds, "For GroundOverlay, url and bounds are passed in to constructor and are immutable after instantiated. This is the behavior of Google Maps JavaScript API v3 ( See https://developers.google.com/maps/documentation/javascript/reference#GroundOverlay) Hence, use the corresponding two props provided by `react-google-maps-api`, url and bounds. In some cases, you'll need the GroundOverlay component to reflect the changes of url and bounds. You can leverage the React's key property to remount the component. Typically, just `key={url}` would serve your need. See https://github.com/tomchentw/react-google-maps/issues/655");
    var t = new google.maps.GroundOverlay(this.props.url, this.props.bounds, bR(bR({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = an({
      updaterMap: CR,
      eventMap: wR,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        groundOverlay: t
      };
    }, this.setGroundOverlayCallback);
  }
  componentDidUpdate(t) {
    this.state.groundOverlay !== null && (fn(this.registeredEvents), this.registeredEvents = an({
      updaterMap: CR,
      eventMap: wR,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.groundOverlay
    }));
  }
  componentWillUnmount() {
    this.state.groundOverlay && (this.props.onUnmount && this.props.onUnmount(this.state.groundOverlay), this.state.groundOverlay.setMap(null));
  }
  render() {
    return null;
  }
}
Ce(bZ, "defaultProps", {
  onLoad: jve
});
Ce(bZ, "contextType", Tt);
function xR(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Tv(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? xR(Object(n), !0).forEach(function(r) {
      Ce(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : xR(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var OR = {}, ER = {
  data(e, t) {
    e.setData(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function Ive(e) {
  var {
    data: t,
    onLoad: n,
    onUnmount: r,
    options: o
  } = e, i = ge(Tt), [a, s] = k(null);
  return h(() => {
    google.maps.visualization || yo(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} in useJsApiScript? %s', google.maps.visualization);
  }, []), h(() => {
    yo(!!t, "data property is required in HeatmapLayer %s", t);
  }, [t]), h(() => {
    a !== null && a.setMap(i);
  }, [i]), h(() => {
    o && a !== null && a.setOptions(o);
  }, [a, o]), h(() => {
    var l = new google.maps.visualization.HeatmapLayer(Tv(Tv({}, o), {}, {
      data: t,
      map: i
    }));
    return s(l), n && n(l), () => {
      a !== null && (r && r(a), a.setMap(null));
    };
  }, []), null;
}
ve(Ive);
class Rve extends pe {
  constructor() {
    super(...arguments), Ce(this, "registeredEvents", []), Ce(this, "state", {
      heatmapLayer: null
    }), Ce(this, "setHeatmapLayerCallback", () => {
      this.state.heatmapLayer !== null && this.props.onLoad && this.props.onLoad(this.state.heatmapLayer);
    });
  }
  componentDidMount() {
    yo(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} to <LoadScript />? %s', google.maps.visualization), yo(!!this.props.data, "data property is required in HeatmapLayer %s", this.props.data);
    var t = new google.maps.visualization.HeatmapLayer(Tv(Tv({}, this.props.options), {}, {
      data: this.props.data,
      map: this.context
    }));
    this.registeredEvents = an({
      updaterMap: ER,
      eventMap: OR,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        heatmapLayer: t
      };
    }, this.setHeatmapLayerCallback);
  }
  componentDidUpdate(t) {
    fn(this.registeredEvents), this.registeredEvents = an({
      updaterMap: ER,
      eventMap: OR,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.heatmapLayer
    });
  }
  componentWillUnmount() {
    this.state.heatmapLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.heatmapLayer), fn(this.registeredEvents), this.state.heatmapLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Ce(Rve, "contextType", Tt);
var kR = {
  onCloseClick: "closeclick",
  onPanoChanged: "pano_changed",
  onPositionChanged: "position_changed",
  onPovChanged: "pov_changed",
  onResize: "resize",
  onStatusChanged: "status_changed",
  onVisibleChanged: "visible_changed",
  onZoomChanged: "zoom_changed"
}, LR = {
  register(e, t, n) {
    e.registerPanoProvider(t, n);
  },
  links(e, t) {
    e.setLinks(t);
  },
  motionTracking(e, t) {
    e.setMotionTracking(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  pano(e, t) {
    e.setPano(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  pov(e, t) {
    e.setPov(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zoom(e, t) {
    e.setZoom(t);
  }
};
class Bve extends pe {
  constructor() {
    super(...arguments), Ce(this, "registeredEvents", []), Ce(this, "state", {
      streetViewPanorama: null
    }), Ce(this, "setStreetViewPanoramaCallback", () => {
      this.state.streetViewPanorama !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewPanorama);
    });
  }
  componentDidMount() {
    var t, n, r = (t = (n = this.context) === null || n === void 0 ? void 0 : n.getStreetView()) !== null && t !== void 0 ? t : null;
    this.registeredEvents = an({
      updaterMap: LR,
      eventMap: kR,
      prevProps: {},
      nextProps: this.props,
      instance: r
    }), this.setState(() => ({
      streetViewPanorama: r
    }), this.setStreetViewPanoramaCallback);
  }
  componentDidUpdate(t) {
    this.state.streetViewPanorama !== null && (fn(this.registeredEvents), this.registeredEvents = an({
      updaterMap: LR,
      eventMap: kR,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.streetViewPanorama
    }));
  }
  componentWillUnmount() {
    this.state.streetViewPanorama !== null && (this.props.onUnmount && this.props.onUnmount(this.state.streetViewPanorama), fn(this.registeredEvents), this.state.streetViewPanorama.setVisible(!1));
  }
  render() {
    return null;
  }
}
Ce(Bve, "contextType", Tt);
class Nve extends pe {
  constructor() {
    super(...arguments), Ce(this, "state", {
      streetViewService: null
    }), Ce(this, "setStreetViewServiceCallback", () => {
      this.state.streetViewService !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewService);
    });
  }
  componentDidMount() {
    var t = new google.maps.StreetViewService();
    this.setState(function() {
      return {
        streetViewService: t
      };
    }, this.setStreetViewServiceCallback);
  }
  componentWillUnmount() {
    this.state.streetViewService !== null && this.props.onUnmount && this.props.onUnmount(this.state.streetViewService);
  }
  render() {
    return null;
  }
}
Ce(Nve, "contextType", Tt);
var PR = {
  onDirectionsChanged: "directions_changed"
}, _R = {
  directions(e, t) {
    e.setDirections(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  panel(e, t) {
    e.setPanel(t);
  },
  routeIndex(e, t) {
    e.setRouteIndex(t);
  }
};
class Fve extends pe {
  constructor() {
    super(...arguments), Ce(this, "registeredEvents", []), Ce(this, "state", {
      directionsRenderer: null
    }), Ce(this, "setDirectionsRendererCallback", () => {
      this.state.directionsRenderer !== null && (this.state.directionsRenderer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.directionsRenderer));
    });
  }
  componentDidMount() {
    var t = new google.maps.DirectionsRenderer(this.props.options);
    this.registeredEvents = an({
      updaterMap: _R,
      eventMap: PR,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        directionsRenderer: t
      };
    }, this.setDirectionsRendererCallback);
  }
  componentDidUpdate(t) {
    this.state.directionsRenderer !== null && (fn(this.registeredEvents), this.registeredEvents = an({
      updaterMap: _R,
      eventMap: PR,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.directionsRenderer
    }));
  }
  componentWillUnmount() {
    this.state.directionsRenderer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.directionsRenderer), fn(this.registeredEvents), this.state.directionsRenderer && this.state.directionsRenderer.setMap(null));
  }
  render() {
    return null;
  }
}
Ce(Fve, "contextType", Tt);
var SR = {
  onPlacesChanged: "places_changed"
}, MR = {
  bounds(e, t) {
    e.setBounds(t);
  }
};
class zve extends pe {
  constructor() {
    super(...arguments), Ce(this, "registeredEvents", []), Ce(this, "containerElement", mo()), Ce(this, "state", {
      searchBox: null
    }), Ce(this, "setSearchBoxCallback", () => {
      this.state.searchBox !== null && this.props.onLoad && this.props.onLoad(this.state.searchBox);
    });
  }
  componentDidMount() {
    if (yo(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places), this.containerElement !== null && this.containerElement.current !== null) {
      var t = this.containerElement.current.querySelector("input");
      if (t !== null) {
        var n = new google.maps.places.SearchBox(t, this.props.options);
        this.registeredEvents = an({
          updaterMap: MR,
          eventMap: SR,
          prevProps: {},
          nextProps: this.props,
          instance: n
        }), this.setState(function() {
          return {
            searchBox: n
          };
        }, this.setSearchBoxCallback);
      }
    }
  }
  componentDidUpdate(t) {
    this.state.searchBox !== null && (fn(this.registeredEvents), this.registeredEvents = an({
      updaterMap: MR,
      eventMap: SR,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.searchBox
    }));
  }
  componentWillUnmount() {
    this.state.searchBox !== null && (this.props.onUnmount && this.props.onUnmount(this.state.searchBox), fn(this.registeredEvents));
  }
  render() {
    return Do.jsx("div", {
      ref: this.containerElement,
      children: lt.only(this.props.children)
    });
  }
}
Ce(zve, "contextType", Tt);
var DR = {
  onPlaceChanged: "place_changed"
}, TR = {
  bounds(e, t) {
    e.setBounds(t);
  },
  restrictions(e, t) {
    e.setComponentRestrictions(t);
  },
  fields(e, t) {
    e.setFields(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  types(e, t) {
    e.setTypes(t);
  }
};
class wZ extends pe {
  constructor() {
    super(...arguments), Ce(this, "registeredEvents", []), Ce(this, "containerElement", mo()), Ce(this, "state", {
      autocomplete: null
    }), Ce(this, "setAutocompleteCallback", () => {
      this.state.autocomplete !== null && this.props.onLoad && this.props.onLoad(this.state.autocomplete);
    });
  }
  componentDidMount() {
    var t;
    yo(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places);
    var n = (t = this.containerElement.current) === null || t === void 0 ? void 0 : t.querySelector("input");
    if (n) {
      var r = new google.maps.places.Autocomplete(n, this.props.options);
      this.registeredEvents = an({
        updaterMap: TR,
        eventMap: DR,
        prevProps: {},
        nextProps: this.props,
        instance: r
      }), this.setState(() => ({
        autocomplete: r
      }), this.setAutocompleteCallback);
    }
  }
  componentDidUpdate(t) {
    fn(this.registeredEvents), this.registeredEvents = an({
      updaterMap: TR,
      eventMap: DR,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.autocomplete
    });
  }
  componentWillUnmount() {
    this.state.autocomplete !== null && fn(this.registeredEvents);
  }
  render() {
    return Do.jsx("div", {
      ref: this.containerElement,
      className: this.props.className,
      children: lt.only(this.props.children)
    });
  }
}
Ce(wZ, "defaultProps", {
  className: ""
});
Ce(wZ, "contextType", Tt);
let Uve = { data: "" }, Hve = (e) => typeof window == "object" ? ((e ? e.querySelector("#_goober") : window._goober) || Object.assign((e || document.head).appendChild(document.createElement("style")), { innerHTML: " ", id: "_goober" })).firstChild : e || Uve, $ve = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g, Wve = /\/\*[^]*?\*\/|  +/g, jR = /\n+/g, Qa = (e, t) => {
  let n = "", r = "", o = "";
  for (let i in e) {
    let a = e[i];
    i[0] == "@" ? i[1] == "i" ? n = i + " " + a + ";" : r += i[1] == "f" ? Qa(a, i) : i + "{" + Qa(a, i[1] == "k" ? "" : t) + "}" : typeof a == "object" ? r += Qa(a, t ? t.replace(/([^,])+/g, (s) => i.replace(/([^,]*:\S+\([^)]*\))|([^,])+/g, (l) => /&/.test(l) ? l.replace(/&/g, s) : s ? s + " " + l : l)) : i) : a != null && (i = /^--/.test(i) ? i : i.replace(/[A-Z]/g, "-$&").toLowerCase(), o += Qa.p ? Qa.p(i, a) : i + ":" + a + ";");
  }
  return n + (t && o ? t + "{" + o + "}" : o) + r;
}, qs = {}, CZ = (e) => {
  if (typeof e == "object") {
    let t = "";
    for (let n in e) t += n + CZ(e[n]);
    return t;
  }
  return e;
}, Vve = (e, t, n, r, o) => {
  let i = CZ(e), a = qs[i] || (qs[i] = ((l) => {
    let u = 0, c = 11;
    for (; u < l.length; ) c = 101 * c + l.charCodeAt(u++) >>> 0;
    return "go" + c;
  })(i));
  if (!qs[a]) {
    let l = i !== e ? e : ((u) => {
      let c, p, d = [{}];
      for (; c = $ve.exec(u.replace(Wve, "")); ) c[4] ? d.shift() : c[3] ? (p = c[3].replace(jR, " ").trim(), d.unshift(d[0][p] = d[0][p] || {})) : d[0][c[1]] = c[2].replace(jR, " ").trim();
      return d[0];
    })(e);
    qs[a] = Qa(o ? { ["@keyframes " + a]: l } : l, n ? "" : "." + a);
  }
  let s = n && qs.g ? qs.g : null;
  return n && (qs.g = qs[a]), ((l, u, c, p) => {
    p ? u.data = u.data.replace(p, l) : u.data.indexOf(l) === -1 && (u.data = c ? l + u.data : u.data + l);
  })(qs[a], t, r, s), a;
}, Zve = (e, t, n) => e.reduce((r, o, i) => {
  let a = t[i];
  if (a && a.call) {
    let s = a(n), l = s && s.props && s.props.className || /^go/.test(s) && s;
    a = l ? "." + l : s && typeof s == "object" ? s.props ? "" : Qa(s, "") : s === !1 ? "" : s;
  }
  return r + o + (a ?? "");
}, "");
function kw(e) {
  let t = this || {}, n = e.call ? e(t.p) : e;
  return Vve(n.unshift ? n.raw ? Zve(n, [].slice.call(arguments, 1), t.p) : n.reduce((r, o) => Object.assign(r, o && o.call ? o(t.p) : o), {}) : n, Hve(t.target), t.g, t.o, t.k);
}
let xZ, mk, vk;
kw.bind({ g: 1 });
let la = kw.bind({ k: 1 });
function qve(e, t, n, r) {
  Qa.p = t, xZ = e, mk = n, vk = r;
}
function Ll(e, t) {
  let n = this || {};
  return function() {
    let r = arguments;
    function o(i, a) {
      let s = Object.assign({}, i), l = s.className || o.className;
      n.p = Object.assign({ theme: mk && mk() }, s), n.o = / *go\d+/.test(l), s.className = kw.apply(n, r) + (l ? " " + l : "");
      let u = e;
      return e[0] && (u = s.as || e, delete s.as), vk && u[0] && vk(s), xZ(u, s);
    }
    return o;
  };
}
var Gve = (e) => typeof e == "function", Kve = (e, t) => Gve(e) ? e(t) : e, Yve = /* @__PURE__ */ (() => {
  let e;
  return () => {
    if (e === void 0 && typeof window < "u") {
      let t = matchMedia("(prefers-reduced-motion: reduce)");
      e = !t || t.matches;
    }
    return e;
  };
})(), Xve = la`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`, Jve = la`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`, Qve = la`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`, eye = Ll("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${Xve} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${Jve} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${(e) => e.secondary || "#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${Qve} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`, tye = la`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, nye = Ll("div")`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${(e) => e.secondary || "#e0e0e0"};
  border-right-color: ${(e) => e.primary || "#616161"};
  animation: ${tye} 1s linear infinite;
`, rye = la`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`, oye = la`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`, iye = Ll("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${rye} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${oye} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${(e) => e.secondary || "#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`, sye = Ll("div")`
  position: absolute;
`, aye = Ll("div")`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`, lye = la`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`, uye = Ll("div")`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${lye} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`, cye = ({ toast: e }) => {
  let { icon: t, type: n, iconTheme: r } = e;
  return t !== void 0 ? typeof t == "string" ? Be.createElement(uye, null, t) : t : n === "blank" ? null : Be.createElement(aye, null, Be.createElement(nye, { ...r }), n !== "loading" && Be.createElement(sye, null, n === "error" ? Be.createElement(eye, { ...r }) : Be.createElement(iye, { ...r })));
}, pye = (e) => `
0% {transform: translate3d(0,${e * -200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`, dye = (e) => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${e * -150}%,-1px) scale(.6); opacity:0;}
`, fye = "0%{opacity:0;} 100%{opacity:1;}", hye = "0%{opacity:1;} 100%{opacity:0;}", gye = Ll("div")`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`, mye = Ll("div")`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`, vye = (e, t) => {
  let n = e.includes("top") ? 1 : -1, [r, o] = Yve() ? [fye, hye] : [pye(n), dye(n)];
  return { animation: t ? `${la(r)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards` : `${la(o)} 0.4s forwards cubic-bezier(.06,.71,.55,1)` };
};
Be.memo(({ toast: e, position: t, style: n, children: r }) => {
  let o = e.height ? vye(e.position || t || "top-center", e.visible) : { opacity: 0 }, i = Be.createElement(cye, { toast: e }), a = Be.createElement(mye, { ...e.ariaProps }, Kve(e.message, e));
  return Be.createElement(gye, { className: e.className, style: { ...o, ...n, ...e.style } }, typeof r == "function" ? r({ icon: i, message: a }) : Be.createElement(Be.Fragment, null, i, a));
});
qve(Be.createElement);
kw`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`;
Ke({});
function yye(e) {
  return e && e.replace(/[^0-9]/g, "");
}
const bye = {
  CNPJ: "99.999.999/9999-99"
};
yye(bye.CNPJ).length;
to((e, t) => /* @__PURE__ */ Mo.jsx("input", { ref: t, ...e }));
function OZ(e) {
  return e && e.replace(/[^0-9]/g, "");
}
const EZ = {
  EIGTH: "(99) 9999-9999",
  NINE: "(99) 99999-9999"
};
function wye(e, t) {
  let n = "", r = 0;
  for (let o = 0; o < t.length; o++)
    if (t[o] === "9")
      if (r < e.length)
        n += e[r], r++;
      else
        break;
    else if (r < e.length)
      n += t[o];
    else
      break;
  return n;
}
function Cye(e) {
  return e.length > 10 ? "NINE" : "EIGTH";
}
const xye = OZ(EZ.NINE).length, Oye = to((e, t) => /* @__PURE__ */ Mo.jsx("input", { ref: t, ...e }));
to(
  (e, t) => {
    const { onFocus: n, onBlur: r, size: o, onChange: i, value: a, currentCountry: s, disabled: l } = e, [u, c] = k(!1);
    h(() => {
      u ? i(s.mask) : c(!0);
    }, [s]);
    const p = `phoneInputMask ${o}`;
    function d(g) {
      let f = OZ(g.target.value);
      const m = Cye(f);
      f.length > xye || (f = wye(f, EZ[m]), g.target.value = f, i(f));
    }
    return s.code === "+55" ? /* @__PURE__ */ Mo.jsx(
      "input",
      {
        value: a,
        onChange: d,
        className: p,
        onFocus: n,
        onBlur: r,
        disabled: l,
        ref: t
      }
    ) : /* @__PURE__ */ Mo.jsx(
      cl,
      {
        value: a,
        onChange: (g) => i(g.target.value),
        className: p,
        component: Oye,
        onFocus: n,
        onBlur: r,
        disabled: l,
        mask: s.mask,
        showMask: !0,
        replacement: { _: /\d/ },
        ref: t
      }
    );
  }
);
Ke({});
var ma = {};
Object.defineProperty(ma, "__esModule", {
  value: !0
});
var Eye = typeof window < "u" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform), EC = {
  alt: "altKey",
  control: "ctrlKey",
  meta: "metaKey",
  shift: "shiftKey"
}, kZ = {
  add: "+",
  break: "pause",
  cmd: "meta",
  command: "meta",
  ctl: "control",
  ctrl: "control",
  del: "delete",
  down: "arrowdown",
  esc: "escape",
  ins: "insert",
  left: "arrowleft",
  mod: Eye ? "meta" : "control",
  opt: "alt",
  option: "alt",
  return: "enter",
  right: "arrowright",
  space: " ",
  spacebar: " ",
  up: "arrowup",
  win: "meta",
  windows: "meta"
}, $P = {
  backspace: 8,
  tab: 9,
  enter: 13,
  shift: 16,
  control: 17,
  alt: 18,
  pause: 19,
  capslock: 20,
  escape: 27,
  " ": 32,
  pageup: 33,
  pagedown: 34,
  end: 35,
  home: 36,
  arrowleft: 37,
  arrowup: 38,
  arrowright: 39,
  arrowdown: 40,
  insert: 45,
  delete: 46,
  meta: 91,
  numlock: 144,
  scrolllock: 145,
  ";": 186,
  "=": 187,
  ",": 188,
  "-": 189,
  ".": 190,
  "/": 191,
  "`": 192,
  "[": 219,
  "\\": 220,
  "]": 221,
  "'": 222
};
for (var pg = 1; pg < 20; pg++)
  $P["f" + pg] = 111 + pg;
function Lw(e, t, n) {
  t && !("byKey" in t) && (n = t, t = null), Array.isArray(e) || (e = [e]);
  var r = e.map(function(a) {
    return LZ(a, t);
  }), o = function(a) {
    return r.some(function(s) {
      return PZ(s, a);
    });
  }, i = n == null ? o : o(n);
  return i;
}
function kye(e, t) {
  return Lw(e, t);
}
function Lye(e, t) {
  return Lw(e, { byKey: !0 }, t);
}
function LZ(e, t) {
  var n = t && t.byKey, r = {};
  e = e.replace("++", "+add");
  var o = e.split("+"), i = o.length;
  for (var a in EC)
    r[EC[a]] = !1;
  var s = !0, l = !1, u = void 0;
  try {
    for (var c = o[Symbol.iterator](), p; !(s = (p = c.next()).done); s = !0) {
      var d = p.value, g = d.endsWith("?") && d.length > 1;
      g && (d = d.slice(0, -1));
      var f = WP(d), m = EC[f];
      if (d.length > 1 && !m && !kZ[d] && !$P[f])
        throw new TypeError('Unknown modifier: "' + d + '"');
      (i === 1 || !m) && (n ? r.key = f : r.which = _Z(d)), m && (r[m] = g ? null : !0);
    }
  } catch (v) {
    l = !0, u = v;
  } finally {
    try {
      !s && c.return && c.return();
    } finally {
      if (l)
        throw u;
    }
  }
  return r;
}
function PZ(e, t) {
  for (var n in e) {
    var r = e[n], o = void 0;
    if (r != null && (n === "key" && t.key != null ? o = t.key.toLowerCase() : n === "which" ? o = r === 91 && t.which === 93 ? 91 : t.which : o = t[n], !(o == null && r === !1) && o !== r))
      return !1;
  }
  return !0;
}
function _Z(e) {
  e = WP(e);
  var t = $P[e] || e.toUpperCase().charCodeAt(0);
  return t;
}
function WP(e) {
  return e = e.toLowerCase(), e = kZ[e] || e, e;
}
ma.default = Lw;
var kC = ma.isHotkey = Lw;
ma.isCodeHotkey = kye;
ma.isKeyHotkey = Lye;
ma.parseHotkey = LZ;
ma.compareHotkey = PZ;
ma.toKeyCode = _Z;
ma.toKeyName = WP;
var Pye = typeof nr == "object" && nr && nr.Object === Object && nr, _ye = Pye, Sye = _ye, Mye = typeof self == "object" && self && self.Object === Object && self, Dye = Sye || Mye || Function("return this")(), Tye = Dye, jye = Tye, Aye = jye.Symbol, SZ = Aye, AR = SZ;
AR && AR.toStringTag;
var IR = SZ;
IR && IR.toStringTag;
var RR;
(function(e) {
  e.BORDER_BOX = "border-box", e.CONTENT_BOX = "content-box", e.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(RR || (RR = {}));
var VP = function(e) {
  return Object.freeze(e);
}, Iye = /* @__PURE__ */ function() {
  function e(t, n) {
    this.inlineSize = t, this.blockSize = n, VP(this);
  }
  return e;
}(), Rye = function() {
  function e(t, n, r, o) {
    return this.x = t, this.y = n, this.width = r, this.height = o, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, VP(this);
  }
  return e.prototype.toJSON = function() {
    var t = this, n = t.x, r = t.y, o = t.top, i = t.right, a = t.bottom, s = t.left, l = t.width, u = t.height;
    return { x: n, y: r, top: o, right: i, bottom: a, left: s, width: l, height: u };
  }, e.fromRect = function(t) {
    return new e(t.x, t.y, t.width, t.height);
  }, e;
}(), BR = typeof window < "u" ? window : {};
/msie|trident/i.test(BR.navigator && BR.navigator.userAgent);
var LC = function(e, t, n) {
  return e === void 0 && (e = 0), t === void 0 && (t = 0), n === void 0 && (n = !1), new Iye((n ? t : e) || 0, (n ? e : t) || 0);
};
VP({
  devicePixelContentBoxSize: LC(),
  borderBoxSize: LC(),
  contentBoxSize: LC(),
  contentRect: new Rye(0, 0, 0, 0)
});
function ef(e) {
  "@babel/helpers - typeof";
  return ef = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, ef(e);
}
function Bye(e, t) {
  if (ef(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (ef(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function Nye(e) {
  var t = Bye(e, "string");
  return ef(t) === "symbol" ? t : String(t);
}
function nd(e, t, n) {
  return t = Nye(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
var Fye = /* @__PURE__ */ Ke(null), PC, _C;
parseInt(we.version.split(".")[0], 10);
var NR = typeof navigator < "u" && /Mac OS X/.test(navigator.userAgent), SC = typeof navigator < "u" && /Android/.test(navigator.userAgent), dg = typeof navigator < "u" && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent), zye = typeof navigator < "u" && /Chrome/i.test(navigator.userAgent);
typeof navigator < "u" && /Safari/.test(navigator.userAgent) && /Version\/(\d+)/.test(navigator.userAgent) && (PC = navigator.userAgent.match(/Version\/(\d+)/)) !== null && PC !== void 0 && PC[1] && parseInt((_C = navigator.userAgent.match(/Version\/(\d+)/)) === null || _C === void 0 ? void 0 : _C[1], 10) < 17;
var Uye = /* @__PURE__ */ new WeakMap(), Hye = /* @__PURE__ */ new WeakMap(), $ye = /* @__PURE__ */ new WeakMap(), Wye = /* @__PURE__ */ new WeakMap(), Vye = /* @__PURE__ */ new WeakMap(), FR = /* @__PURE__ */ new WeakMap(), Zye = /* @__PURE__ */ new WeakMap(), zR = /* @__PURE__ */ new WeakMap(), fg = /* @__PURE__ */ new WeakMap(), qye = /* @__PURE__ */ new WeakMap(), Gye = /* @__PURE__ */ new WeakMap(), Kye = /* @__PURE__ */ new WeakMap(), MZ = globalThis.Node, Yye = globalThis.Text, DZ = (e) => e && e.ownerDocument && e.ownerDocument.defaultView || null, Xye = (e) => jv(e) && e.nodeType === 8, Ps = (e) => jv(e) && e.nodeType === 1, jv = (e) => {
  var t = DZ(e);
  return !!t && e instanceof t.Node;
}, UR = (e) => {
  var t = e && e.anchorNode && DZ(e.anchorNode);
  return !!t && e instanceof t.Selection;
}, Jye = (e) => {
  var [t, n] = e;
  if (Ps(t) && t.childNodes.length) {
    var r = n === t.childNodes.length, o = r ? n - 1 : n;
    for ([t, o] = TZ(t, o, r ? "backward" : "forward"), r = o < n; Ps(t) && t.childNodes.length; ) {
      var i = r ? t.childNodes.length - 1 : 0;
      t = ebe(t, i, r ? "backward" : "forward");
    }
    n = r && t.textContent != null ? t.textContent.length : 0;
  }
  return [t, n];
}, Qye = (e) => {
  for (var t = e && e.parentNode; t; ) {
    if (t.toString() === "[object ShadowRoot]")
      return !0;
    t = t.parentNode;
  }
  return !1;
}, TZ = (e, t, n) => {
  for (var {
    childNodes: r
  } = e, o = r[t], i = t, a = !1, s = !1; (Xye(o) || Ps(o) && o.childNodes.length === 0 || Ps(o) && o.getAttribute("contenteditable") === "false") && !(a && s); ) {
    if (i >= r.length) {
      a = !0, i = t - 1, n = "backward";
      continue;
    }
    if (i < 0) {
      s = !0, i = t + 1, n = "forward";
      continue;
    }
    o = r[i], t = i, i += n === "forward" ? 1 : -1;
  }
  return [o, t];
}, ebe = (e, t, n) => {
  var [r] = TZ(e, t, n);
  return r;
}, HR = (e) => e.getSelection != null ? e.getSelection() : document.getSelection(), jZ = (e, t, n) => {
  var {
    target: r
  } = t;
  if (Ps(r) && r.matches('[contentEditable="false"]'))
    return !1;
  var {
    document: o
  } = tn.getWindow(e);
  if (o.contains(r))
    return tn.hasDOMNode(e, r, {
      editable: !0
    });
  var i = n.find((a) => {
    var {
      addedNodes: s,
      removedNodes: l
    } = a;
    for (var u of s)
      if (u === r || u.contains(r))
        return !0;
    for (var c of l)
      if (c === r || c.contains(r))
        return !0;
  });
  return !i || i === t ? !1 : jZ(e, i, n);
}, $R = (e, t) => !!(e.compareDocumentPosition(t) & MZ.DOCUMENT_POSITION_PRECEDING), tbe = (e, t) => !!(e.compareDocumentPosition(t) & MZ.DOCUMENT_POSITION_FOLLOWING), nbe = 0;
class rbe {
  constructor() {
    nd(this, "id", void 0), this.id = "".concat(nbe++);
  }
}
var tn = {
  androidPendingDiffs: (e) => Kye.get(e),
  androidScheduleFlush: (e) => {
    var t;
    (t = Gye.get(e)) === null || t === void 0 || t();
  },
  blur: (e) => {
    var t = tn.toDOMNode(e, e), n = tn.findDocumentOrShadowRoot(e);
    fg.set(e, !1), n.activeElement === t && t.blur();
  },
  deselect: (e) => {
    var {
      selection: t
    } = e, n = tn.findDocumentOrShadowRoot(e), r = HR(n);
    r && r.rangeCount > 0 && r.removeAllRanges(), t && gv.deselect(e);
  },
  findDocumentOrShadowRoot: (e) => {
    var t = tn.toDOMNode(e, e), n = t.getRootNode();
    return n instanceof Document || n instanceof ShadowRoot ? n : t.ownerDocument;
  },
  findEventRange: (e, t) => {
    "nativeEvent" in t && (t = t.nativeEvent);
    var {
      clientX: n,
      clientY: r,
      target: o
    } = t;
    if (n == null || r == null)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var i = tn.toSlateNode(e, t.target), a = tn.findPath(e, i);
    if (oa.isElement(i) && Kn.isVoid(e, i)) {
      var s = o.getBoundingClientRect(), l = e.isInline(i) ? n - s.left < s.left + s.width - n : r - s.top < s.top + s.height - r, u = Kn.point(e, a, {
        edge: l ? "start" : "end"
      }), c = l ? Kn.before(e, u) : Kn.after(e, u);
      if (c) {
        var p = Kn.range(e, c);
        return p;
      }
    }
    var d, {
      document: g
    } = tn.getWindow(e);
    if (g.caretRangeFromPoint)
      d = g.caretRangeFromPoint(n, r);
    else {
      var f = g.caretPositionFromPoint(n, r);
      f && (d = g.createRange(), d.setStart(f.offsetNode, f.offset), d.setEnd(f.offsetNode, f.offset));
    }
    if (!d)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var m = tn.toSlateRange(e, d, {
      exactMatch: !1,
      suppressThrow: !1
    });
    return m;
  },
  findKey: (e, t) => {
    var n = FR.get(t);
    return n || (n = new rbe(), FR.set(t, n)), n;
  },
  findPath: (e, t) => {
    for (var n = [], r = t; ; ) {
      var o = Hye.get(r);
      if (o == null) {
        if (Kn.isEditor(r))
          return n;
        break;
      }
      var i = Uye.get(r);
      if (i == null)
        break;
      n.unshift(i), r = o;
    }
    throw new Error("Unable to find the path for Slate node: ".concat(Di.stringify(t)));
  },
  focus: function(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      retries: 5
    };
    if (!fg.get(e)) {
      if (t.retries <= 0)
        throw new Error("Could not set focus, editor seems stuck with pending operations");
      if (e.operations.length > 0) {
        setTimeout(() => {
          tn.focus(e, {
            retries: t.retries - 1
          });
        }, 10);
        return;
      }
      var n = tn.toDOMNode(e, e), r = tn.findDocumentOrShadowRoot(e);
      if (r.activeElement !== n) {
        if (e.selection && r instanceof Document) {
          var o = HR(r), i = tn.toDOMRange(e, e.selection);
          o == null || o.removeAllRanges(), o == null || o.addRange(i);
        }
        e.selection || gv.select(e, Kn.start(e, [])), fg.set(e, !0), n.focus({
          preventScroll: !0
        });
      }
    }
  },
  getWindow: (e) => {
    var t = $ye.get(e);
    if (!t)
      throw new Error("Unable to find a host window element for this editor");
    return t;
  },
  hasDOMNode: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      editable: r = !1
    } = n, o = tn.toDOMNode(e, e), i;
    try {
      i = Ps(t) ? t : t.parentElement;
    } catch (a) {
      if (a instanceof Error && !a.message.includes('Permission denied to access property "nodeType"'))
        throw a;
    }
    return i ? i.closest("[data-slate-editor]") === o && (!r || i.isContentEditable ? !0 : typeof i.isContentEditable == "boolean" && // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined
    // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable="false"(readOnly)
    i.closest('[contenteditable="false"]') === o || !!i.getAttribute("data-slate-zero-width")) : !1;
  },
  hasEditableTarget: (e, t) => jv(t) && tn.hasDOMNode(e, t, {
    editable: !0
  }),
  hasRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t;
    return Kn.hasPath(e, n.path) && Kn.hasPath(e, r.path);
  },
  hasSelectableTarget: (e, t) => tn.hasEditableTarget(e, t) || tn.isTargetInsideNonReadonlyVoid(e, t),
  hasTarget: (e, t) => jv(t) && tn.hasDOMNode(e, t),
  insertData: (e, t) => {
    e.insertData(t);
  },
  insertFragmentData: (e, t) => e.insertFragmentData(t),
  insertTextData: (e, t) => e.insertTextData(t),
  isComposing: (e) => !!qye.get(e),
  isFocused: (e) => !!fg.get(e),
  isReadOnly: (e) => !!zR.get(e),
  isTargetInsideNonReadonlyVoid: (e, t) => {
    if (zR.get(e)) return !1;
    var n = tn.hasTarget(e, t) && tn.toSlateNode(e, t);
    return oa.isElement(n) && Kn.isVoid(e, n);
  },
  setFragmentData: (e, t, n) => e.setFragmentData(t, n),
  toDOMNode: (e, t) => {
    var n = Zye.get(e), r = Kn.isEditor(t) ? Wye.get(e) : n == null ? void 0 : n.get(tn.findKey(e, t));
    if (!r)
      throw new Error("Cannot resolve a DOM node from Slate node: ".concat(Di.stringify(t)));
    return r;
  },
  toDOMPoint: (e, t) => {
    var [n] = Kn.node(e, t.path), r = tn.toDOMNode(e, n), o;
    Kn.void(e, {
      at: t
    }) && (t = {
      path: t.path,
      offset: 0
    });
    for (var i = "[data-slate-string], [data-slate-zero-width]", a = Array.from(r.querySelectorAll(i)), s = 0, l = 0; l < a.length; l++) {
      var u = a[l], c = u.childNodes[0];
      if (!(c == null || c.textContent == null)) {
        var {
          length: p
        } = c.textContent, d = u.getAttribute("data-slate-length"), g = d == null ? p : parseInt(d, 10), f = s + g, m = a[l + 1];
        if (t.offset === f && m !== null && m !== void 0 && m.hasAttribute("data-slate-mark-placeholder")) {
          var v, E = m.childNodes[0];
          o = [
            // COMPAT: If we don't explicity set the dom point to be on the actual
            // dom text element, chrome will put the selection behind the actual dom
            // text element, causing domRange.getBoundingClientRect() calls on a collapsed
            // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)
            // which will cause issues when scrolling to it.
            E instanceof Yye ? E : m,
            (v = m.textContent) !== null && v !== void 0 && v.startsWith("\uFEFF") ? 1 : 0
          ];
          break;
        }
        if (t.offset <= f) {
          var w = Math.min(p, Math.max(0, t.offset - s));
          o = [c, w];
          break;
        }
        s = f;
      }
    }
    if (!o)
      throw new Error("Cannot resolve a DOM point from Slate point: ".concat(Di.stringify(t)));
    return o;
  },
  toDOMRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t, o = $t.isBackward(t), i = tn.toDOMPoint(e, n), a = $t.isCollapsed(t) ? i : tn.toDOMPoint(e, r), s = tn.getWindow(e), l = s.document.createRange(), [u, c] = o ? a : i, [p, d] = o ? i : a, g = Ps(u) ? u : u.parentElement, f = !!g.getAttribute("data-slate-zero-width"), m = Ps(p) ? p : p.parentElement, v = !!m.getAttribute("data-slate-zero-width");
    return l.setStart(u, f ? 1 : c), l.setEnd(p, v ? 1 : d), l;
  },
  toSlateNode: (e, t) => {
    var n = Ps(t) ? t : t.parentElement;
    n && !n.hasAttribute("data-slate-node") && (n = n.closest("[data-slate-node]"));
    var r = n ? Vye.get(n) : null;
    if (!r)
      throw new Error("Cannot resolve a Slate node from DOM node: ".concat(n));
    return r;
  },
  toSlatePoint: (e, t, n) => {
    var {
      exactMatch: r,
      suppressThrow: o,
      searchDirection: i = "backward"
    } = n, [a, s] = r ? t : Jye(t), l = a.parentNode, u = null, c = 0;
    if (l) {
      var p, d, g = tn.toDOMNode(e, e), f = l.closest('[data-slate-void="true"]'), m = f && g.contains(f) ? f : null, v = l.closest('[contenteditable="false"]'), E = v && g.contains(v) ? v : null, w = l.closest("[data-slate-leaf]"), M = null;
      if (w) {
        if (u = w.closest('[data-slate-node="text"]'), u) {
          var O = tn.getWindow(e), y = O.document.createRange();
          y.setStart(u, 0), y.setEnd(a, s);
          var C = y.cloneContents(), _ = [...Array.prototype.slice.call(C.querySelectorAll("[data-slate-zero-width]")), ...Array.prototype.slice.call(C.querySelectorAll("[contenteditable=false]"))];
          _.forEach((S) => {
            if (SC && !r && S.hasAttribute("data-slate-zero-width") && S.textContent.length > 0 && S.textContext !== "\uFEFF") {
              S.textContent.startsWith("\uFEFF") && (S.textContent = S.textContent.slice(1));
              return;
            }
            S.parentNode.removeChild(S);
          }), c = C.textContent.length, M = u;
        }
      } else if (m) {
        for (var F = m.querySelectorAll("[data-slate-leaf]"), L = 0; L < F.length; L++) {
          var N = F[L];
          if (tn.hasDOMNode(e, N)) {
            w = N;
            break;
          }
        }
        w ? (u = w.closest('[data-slate-node="text"]'), M = w, c = M.textContent.length, M.querySelectorAll("[data-slate-zero-width]").forEach((S) => {
          c -= S.textContent.length;
        })) : c = 1;
      } else if (E) {
        var R = (S) => S ? S.querySelectorAll(
          // Exclude leaf nodes in nested editors
          "[data-slate-leaf]:not(:scope [data-slate-editor] [data-slate-leaf])"
        ) : [], W = E.closest('[data-slate-node="element"]');
        if (i === "forward") {
          var V, z = [...R(W), ...R(W == null ? void 0 : W.nextElementSibling)];
          w = (V = z.find((S) => tbe(E, S))) !== null && V !== void 0 ? V : null;
        } else {
          var Z, K = [...R(W == null ? void 0 : W.previousElementSibling), ...R(W)];
          w = (Z = K.findLast((S) => $R(E, S))) !== null && Z !== void 0 ? Z : null;
        }
        w && (u = w.closest('[data-slate-node="text"]'), M = w, i === "forward" ? c = 0 : (c = M.textContent.length, M.querySelectorAll("[data-slate-zero-width]").forEach((S) => {
          c -= S.textContent.length;
        })));
      }
      M && c === M.textContent.length && // COMPAT: Android IMEs might remove the zero width space while composing,
      // and we don't add it for line-breaks.
      SC && M.getAttribute("data-slate-zero-width") === "z" && (p = M.textContent) !== null && p !== void 0 && p.startsWith("\uFEFF") && // COMPAT: If the parent node is a Slate zero-width space, editor is
      // because the text node should have no characters. However, during IME
      // composition the ASCII characters will be prepended to the zero-width
      // space, so subtract 1 from the offset to account for the zero-width
      // space character.
      (l.hasAttribute("data-slate-zero-width") || // COMPAT: In Firefox, `range.cloneContents()` returns an extra trailing '\n'
      // when the document ends with a new-line character. This results in the offset
      // length being off by one, so we need to subtract one to account for this.
      dg && (d = M.textContent) !== null && d !== void 0 && d.endsWith(`

`)) && c--;
    }
    if (SC && !u && !r) {
      var X = l.hasAttribute("data-slate-node") ? l : l.closest("[data-slate-node]");
      if (X && tn.hasDOMNode(e, X, {
        editable: !0
      })) {
        var te = tn.toSlateNode(e, X), {
          path: J,
          offset: P
        } = Kn.start(e, tn.findPath(e, te));
        return X.querySelector("[data-slate-leaf]") || (P = s), {
          path: J,
          offset: P
        };
      }
    }
    if (!u) {
      if (o)
        return null;
      throw new Error("Cannot resolve a Slate point from DOM point: ".concat(t));
    }
    var D = tn.toSlateNode(e, u), H = tn.findPath(e, D);
    return {
      path: H,
      offset: c
    };
  },
  toSlateRange: (e, t, n) => {
    var r, {
      exactMatch: o,
      suppressThrow: i
    } = n, a = UR(t) ? t.anchorNode : t.startContainer, s, l, u, c, p;
    if (a)
      if (UR(t)) {
        if (dg && t.rangeCount > 1) {
          u = t.focusNode;
          var d = t.getRangeAt(0), g = t.getRangeAt(t.rangeCount - 1);
          if (u instanceof HTMLTableRowElement && d.startContainer instanceof HTMLTableRowElement && g.startContainer instanceof HTMLTableRowElement) {
            let C = function(_) {
              return _.childElementCount > 0 ? C(_.children[0]) : _;
            };
            var f = d.startContainer, m = g.startContainer, v = C(f.children[d.startOffset]), E = C(m.children[g.startOffset]);
            c = 0, E.childNodes.length > 0 ? s = E.childNodes[0] : s = E, v.childNodes.length > 0 ? u = v.childNodes[0] : u = v, E instanceof HTMLElement ? l = E.innerHTML.length : l = 0;
          } else
            d.startContainer === u ? (s = g.endContainer, l = g.endOffset, c = d.startOffset) : (s = d.startContainer, l = d.endOffset, c = g.startOffset);
        } else
          s = t.anchorNode, l = t.anchorOffset, u = t.focusNode, c = t.focusOffset;
        zye && Qye(s) || dg ? p = t.anchorNode === t.focusNode && t.anchorOffset === t.focusOffset : p = t.isCollapsed;
      } else
        s = t.startContainer, l = t.startOffset, u = t.endContainer, c = t.endOffset, p = t.collapsed;
    if (s == null || u == null || l == null || c == null)
      throw new Error("Cannot resolve a Slate range from DOM range: ".concat(t));
    dg && (r = u.textContent) !== null && r !== void 0 && r.endsWith(`

`) && c === u.textContent.length && c--;
    var w = tn.toSlatePoint(e, [s, l], {
      exactMatch: o,
      suppressThrow: i
    });
    if (!w)
      return null;
    var M = $R(s, u) || s === u && c < l, O = p ? w : tn.toSlatePoint(e, [u, c], {
      exactMatch: o,
      suppressThrow: i,
      searchDirection: M ? "forward" : "backward"
    });
    if (!O)
      return null;
    var y = {
      anchor: w,
      focus: O
    };
    return $t.isExpanded(y) && $t.isForward(y) && Ps(u) && Kn.void(e, {
      at: y.focus,
      mode: "highest"
    }) && (y = Kn.unhangRange(e, y, {
      voids: !0
    })), y;
  }
}, obe = {
  bold: "mod+b",
  compose: ["down", "left", "right", "up", "backspace", "enter"],
  moveBackward: "left",
  moveForward: "right",
  moveWordBackward: "ctrl+left",
  moveWordForward: "ctrl+right",
  deleteBackward: "shift?+backspace",
  deleteForward: "shift?+delete",
  extendBackward: "shift+left",
  extendForward: "shift+right",
  italic: "mod+i",
  insertSoftBreak: "shift+enter",
  splitBlock: "enter",
  undo: "mod+z"
}, ibe = {
  moveLineBackward: "opt+up",
  moveLineForward: "opt+down",
  moveWordBackward: "opt+left",
  moveWordForward: "opt+right",
  deleteBackward: ["ctrl+backspace", "ctrl+h"],
  deleteForward: ["ctrl+delete", "ctrl+d"],
  deleteLineBackward: "cmd+shift?+backspace",
  deleteLineForward: ["cmd+shift?+delete", "ctrl+k"],
  deleteWordBackward: "opt+shift?+backspace",
  deleteWordForward: "opt+shift?+delete",
  extendLineBackward: "opt+shift+up",
  extendLineForward: "opt+shift+down",
  redo: "cmd+shift+z",
  transposeCharacter: "ctrl+t"
}, sbe = {
  deleteWordBackward: "ctrl+shift?+backspace",
  deleteWordForward: "ctrl+shift?+delete",
  redo: ["ctrl+y", "ctrl+shift+z"]
}, _r = (e) => {
  var t = obe[e], n = ibe[e], r = sbe[e], o = t && kC(t), i = n && kC(n), a = r && kC(r);
  return (s) => !!(o && o(s) || NR && i && i(s) || !NR && a && a(s));
};
_r("bold"), _r("compose"), _r("moveBackward"), _r("moveForward"), _r("deleteBackward"), _r("deleteForward"), _r("deleteLineBackward"), _r("deleteLineForward"), _r("deleteWordBackward"), _r("deleteWordForward"), _r("extendBackward"), _r("extendForward"), _r("extendLineBackward"), _r("extendLineForward"), _r("italic"), _r("moveLineBackward"), _r("moveLineForward"), _r("moveWordBackward"), _r("moveWordForward"), _r("redo"), _r("insertSoftBreak"), _r("splitBlock"), _r("transposeCharacter"), _r("undo");
var abe = (e, t) => {
  var n = [], r = () => {
    n = [];
  }, o = (a) => {
    if (t.current) {
      var s = a.filter((l) => jZ(e, l, a));
      n.push(...s);
    }
  };
  function i() {
    n.length > 0 && (n.reverse().forEach((a) => {
      a.type !== "characterData" && (a.removedNodes.forEach((s) => {
        a.target.insertBefore(s, a.nextSibling);
      }), a.addedNodes.forEach((s) => {
        a.target.removeChild(s);
      }));
    }), r());
  }
  return {
    registerMutations: o,
    restoreDOM: i,
    clear: r
  };
}, lbe = {
  subtree: !0,
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0
};
class ube extends Wu {
  constructor() {
    super(...arguments), nd(this, "context", null), nd(this, "manager", null), nd(this, "mutationObserver", null);
  }
  observe() {
    var t, {
      node: n
    } = this.props;
    if (!n.current)
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    (t = this.mutationObserver) === null || t === void 0 || t.observe(n.current, lbe);
  }
  componentDidMount() {
    var {
      receivedUserInput: t
    } = this.props, n = this.context;
    this.manager = abe(n, t), this.mutationObserver = new MutationObserver(this.manager.registerMutations), this.observe();
  }
  getSnapshotBeforeUpdate() {
    var t, n, r, o = (t = this.mutationObserver) === null || t === void 0 ? void 0 : t.takeRecords();
    if (o != null && o.length) {
      var i;
      (i = this.manager) === null || i === void 0 || i.registerMutations(o);
    }
    return (n = this.mutationObserver) === null || n === void 0 || n.disconnect(), (r = this.manager) === null || r === void 0 || r.restoreDOM(), null;
  }
  componentDidUpdate() {
    var t;
    (t = this.manager) === null || t === void 0 || t.clear(), this.observe();
  }
  componentWillUnmount() {
    var t;
    (t = this.mutationObserver) === null || t === void 0 || t.disconnect();
  }
  render() {
    return this.props.children;
  }
}
nd(ube, "contextType", Fye);
Ke({});
Ke({});
Ke({});
var uo = {}, ZP = {}, Ef = {}, kf = {}, AZ = "Expected a function", WR = NaN, cbe = "[object Symbol]", pbe = /^\s+|\s+$/g, dbe = /^[-+]0x[0-9a-f]+$/i, fbe = /^0b[01]+$/i, hbe = /^0o[0-7]+$/i, gbe = parseInt, mbe = typeof nr == "object" && nr && nr.Object === Object && nr, vbe = typeof self == "object" && self && self.Object === Object && self, ybe = mbe || vbe || Function("return this")(), bbe = Object.prototype, wbe = bbe.toString, Cbe = Math.max, xbe = Math.min, MC = function() {
  return ybe.Date.now();
};
function Obe(e, t, n) {
  var r, o, i, a, s, l, u = 0, c = !1, p = !1, d = !0;
  if (typeof e != "function")
    throw new TypeError(AZ);
  t = VR(t) || 0, Av(n) && (c = !!n.leading, p = "maxWait" in n, i = p ? Cbe(VR(n.maxWait) || 0, t) : i, d = "trailing" in n ? !!n.trailing : d);
  function g(C) {
    var _ = r, F = o;
    return r = o = void 0, u = C, a = e.apply(F, _), a;
  }
  function f(C) {
    return u = C, s = setTimeout(E, t), c ? g(C) : a;
  }
  function m(C) {
    var _ = C - l, F = C - u, L = t - _;
    return p ? xbe(L, i - F) : L;
  }
  function v(C) {
    var _ = C - l, F = C - u;
    return l === void 0 || _ >= t || _ < 0 || p && F >= i;
  }
  function E() {
    var C = MC();
    if (v(C))
      return w(C);
    s = setTimeout(E, m(C));
  }
  function w(C) {
    return s = void 0, d && r ? g(C) : (r = o = void 0, a);
  }
  function M() {
    s !== void 0 && clearTimeout(s), u = 0, r = l = o = s = void 0;
  }
  function O() {
    return s === void 0 ? a : w(MC());
  }
  function y() {
    var C = MC(), _ = v(C);
    if (r = arguments, o = this, l = C, _) {
      if (s === void 0)
        return f(l);
      if (p)
        return s = setTimeout(E, t), g(l);
    }
    return s === void 0 && (s = setTimeout(E, t)), a;
  }
  return y.cancel = M, y.flush = O, y;
}
function Ebe(e, t, n) {
  var r = !0, o = !0;
  if (typeof e != "function")
    throw new TypeError(AZ);
  return Av(n) && (r = "leading" in n ? !!n.leading : r, o = "trailing" in n ? !!n.trailing : o), Obe(e, t, {
    leading: r,
    maxWait: t,
    trailing: o
  });
}
function Av(e) {
  var t = typeof e;
  return !!e && (t == "object" || t == "function");
}
function kbe(e) {
  return !!e && typeof e == "object";
}
function Lbe(e) {
  return typeof e == "symbol" || kbe(e) && wbe.call(e) == cbe;
}
function VR(e) {
  if (typeof e == "number")
    return e;
  if (Lbe(e))
    return WR;
  if (Av(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = Av(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = e.replace(pbe, "");
  var n = fbe.test(e);
  return n || hbe.test(e) ? gbe(e.slice(2), n ? 2 : 8) : dbe.test(e) ? WR : +e;
}
var Pbe = Ebe, Lf = {};
Object.defineProperty(Lf, "__esModule", {
  value: !0
});
Lf.addPassiveEventListener = function(e, t, n) {
  var r = n.name;
  r || (r = t, console.warn("Listener must be a named function.")), _m.has(t) || _m.set(t, /* @__PURE__ */ new Set());
  var o = _m.get(t);
  if (!o.has(r)) {
    var i = function() {
      var a = !1;
      try {
        var s = Object.defineProperty({}, "passive", {
          get: function() {
            a = !0;
          }
        });
        window.addEventListener("test", null, s);
      } catch {
      }
      return a;
    }();
    e.addEventListener(t, n, i ? { passive: !0 } : !1), o.add(r);
  }
};
Lf.removePassiveEventListener = function(e, t, n) {
  e.removeEventListener(t, n), _m.get(t).delete(n.name || t);
};
var _m = /* @__PURE__ */ new Map();
Object.defineProperty(kf, "__esModule", {
  value: !0
});
var _be = Pbe, Sbe = Mbe(_be), ZR = Lf;
function Mbe(e) {
  return e && e.__esModule ? e : { default: e };
}
var Dbe = function(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 66;
  return (0, Sbe.default)(e, t);
}, Hr = {
  spyCallbacks: [],
  spySetState: [],
  scrollSpyContainers: [],
  mount: function(e, t) {
    if (e) {
      var n = Dbe(function(r) {
        Hr.scrollHandler(e);
      }, t);
      return Hr.scrollSpyContainers.push(e), (0, ZR.addPassiveEventListener)(e, "scroll", n), function() {
        (0, ZR.removePassiveEventListener)(e, "scroll", n), Hr.scrollSpyContainers.splice(Hr.scrollSpyContainers.indexOf(e), 1);
      };
    }
    return function() {
    };
  },
  isMounted: function(e) {
    return Hr.scrollSpyContainers.indexOf(e) !== -1;
  },
  currentPositionX: function(e) {
    if (e === document) {
      var t = window.scrollY !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.scrollX : n ? document.documentElement.scrollLeft : document.body.scrollLeft;
    } else
      return e.scrollLeft;
  },
  currentPositionY: function(e) {
    if (e === document) {
      var t = window.scrollX !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.scrollY : n ? document.documentElement.scrollTop : document.body.scrollTop;
    } else
      return e.scrollTop;
  },
  scrollHandler: function(e) {
    var t = Hr.scrollSpyContainers[Hr.scrollSpyContainers.indexOf(e)].spyCallbacks || [];
    t.forEach(function(n) {
      return n(Hr.currentPositionX(e), Hr.currentPositionY(e));
    });
  },
  addStateHandler: function(e) {
    Hr.spySetState.push(e);
  },
  addSpyHandler: function(e, t) {
    var n = Hr.scrollSpyContainers[Hr.scrollSpyContainers.indexOf(t)];
    n.spyCallbacks || (n.spyCallbacks = []), n.spyCallbacks.push(e);
  },
  updateStates: function() {
    Hr.spySetState.forEach(function(e) {
      return e();
    });
  },
  unmount: function(e, t) {
    Hr.scrollSpyContainers.forEach(function(n) {
      return n.spyCallbacks && n.spyCallbacks.length && n.spyCallbacks.indexOf(t) > -1 && n.spyCallbacks.splice(n.spyCallbacks.indexOf(t), 1);
    }), Hr.spySetState && Hr.spySetState.length && Hr.spySetState.indexOf(e) > -1 && Hr.spySetState.splice(Hr.spySetState.indexOf(e), 1), document.removeEventListener("scroll", Hr.scrollHandler);
  },
  update: function() {
    return Hr.scrollSpyContainers.forEach(function(e) {
      return Hr.scrollHandler(e);
    });
  }
};
kf.default = Hr;
var Mc = {}, Pf = {};
Object.defineProperty(Pf, "__esModule", {
  value: !0
});
var Tbe = function(e, t) {
  var n = e.indexOf("#") === 0 ? e.substring(1) : e, r = n ? "#" + n : "", o = window && window.location, i = r ? o.pathname + o.search + r : o.pathname + o.search;
  t ? history.pushState(history.state, "", i) : history.replaceState(history.state, "", i);
}, jbe = function() {
  return window.location.hash.replace(/^#/, "");
}, Abe = function(e) {
  return function(t) {
    return e.contains ? e != t && e.contains(t) : !!(e.compareDocumentPosition(t) & 16);
  };
}, Ibe = function(e) {
  return getComputedStyle(e).position !== "static";
}, DC = function(e, t) {
  for (var n = e.offsetTop, r = e.offsetParent; r && !t(r); )
    n += r.offsetTop, r = r.offsetParent;
  return { offsetTop: n, offsetParent: r };
}, Rbe = function(e, t, n) {
  if (n)
    return e === document ? t.getBoundingClientRect().left + (window.scrollX || window.pageXOffset) : getComputedStyle(e).position !== "static" ? t.offsetLeft : t.offsetLeft - e.offsetLeft;
  if (e === document)
    return t.getBoundingClientRect().top + (window.scrollY || window.pageYOffset);
  if (Ibe(e)) {
    if (t.offsetParent !== e) {
      var r = function(l) {
        return l === e || l === document;
      }, o = DC(t, r), i = o.offsetTop, a = o.offsetParent;
      if (a !== e)
        throw new Error("Seems containerElement is not an ancestor of the Element");
      return i;
    }
    return t.offsetTop;
  }
  if (t.offsetParent === e.offsetParent)
    return t.offsetTop - e.offsetTop;
  var s = function(l) {
    return l === document;
  };
  return DC(t, s).offsetTop - DC(e, s).offsetTop;
};
Pf.default = {
  updateHash: Tbe,
  getHash: jbe,
  filterElementInContainer: Abe,
  scrollOffset: Rbe
};
var Pw = {}, qP = {};
Object.defineProperty(qP, "__esModule", {
  value: !0
});
qP.default = {
  /*
   * https://github.com/oblador/angular-scroll (duScrollDefaultEasing)
   */
  defaultEasing: function(e) {
    return e < 0.5 ? Math.pow(e * 2, 2) / 2 : 1 - Math.pow((1 - e) * 2, 2) / 2;
  },
  /*
   * https://gist.github.com/gre/1650294
   */
  // no easing, no acceleration
  linear: function(e) {
    return e;
  },
  // accelerating from zero velocity
  easeInQuad: function(e) {
    return e * e;
  },
  // decelerating to zero velocity
  easeOutQuad: function(e) {
    return e * (2 - e);
  },
  // acceleration until halfway, then deceleration
  easeInOutQuad: function(e) {
    return e < 0.5 ? 2 * e * e : -1 + (4 - 2 * e) * e;
  },
  // accelerating from zero velocity 
  easeInCubic: function(e) {
    return e * e * e;
  },
  // decelerating to zero velocity 
  easeOutCubic: function(e) {
    return --e * e * e + 1;
  },
  // acceleration until halfway, then deceleration 
  easeInOutCubic: function(e) {
    return e < 0.5 ? 4 * e * e * e : (e - 1) * (2 * e - 2) * (2 * e - 2) + 1;
  },
  // accelerating from zero velocity 
  easeInQuart: function(e) {
    return e * e * e * e;
  },
  // decelerating to zero velocity 
  easeOutQuart: function(e) {
    return 1 - --e * e * e * e;
  },
  // acceleration until halfway, then deceleration
  easeInOutQuart: function(e) {
    return e < 0.5 ? 8 * e * e * e * e : 1 - 8 * --e * e * e * e;
  },
  // accelerating from zero velocity
  easeInQuint: function(e) {
    return e * e * e * e * e;
  },
  // decelerating to zero velocity
  easeOutQuint: function(e) {
    return 1 + --e * e * e * e * e;
  },
  // acceleration until halfway, then deceleration 
  easeInOutQuint: function(e) {
    return e < 0.5 ? 16 * e * e * e * e * e : 1 + 16 * --e * e * e * e * e;
  }
};
var GP = {};
Object.defineProperty(GP, "__esModule", {
  value: !0
});
var Bbe = Lf, Nbe = ["mousedown", "wheel", "touchmove", "keydown"];
GP.default = {
  subscribe: function(e) {
    return typeof document < "u" && Nbe.forEach(function(t) {
      return (0, Bbe.addPassiveEventListener)(document, t, e);
    });
  }
};
var _f = {};
Object.defineProperty(_f, "__esModule", {
  value: !0
});
var yk = {
  registered: {},
  scrollEvent: {
    register: function(e, t) {
      yk.registered[e] = t;
    },
    remove: function(e) {
      yk.registered[e] = null;
    }
  }
};
_f.default = yk;
Object.defineProperty(Pw, "__esModule", {
  value: !0
});
var Fbe = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, zbe = Pf;
_w(zbe);
var Ube = qP, qR = _w(Ube), Hbe = GP, $be = _w(Hbe), Wbe = _f, ws = _w(Wbe);
function _w(e) {
  return e && e.__esModule ? e : { default: e };
}
var IZ = function(e) {
  return qR.default[e.smooth] || qR.default.defaultEasing;
}, Vbe = function(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}, Zbe = function() {
  if (typeof window < "u")
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame;
}, bk = function() {
  return Zbe() || function(e, t, n) {
    window.setTimeout(e, n || 1e3 / 60, (/* @__PURE__ */ new Date()).getTime());
  };
}(), RZ = function() {
  return {
    currentPosition: 0,
    startPosition: 0,
    targetPosition: 0,
    progress: 0,
    duration: 0,
    cancel: !1,
    target: null,
    containerElement: null,
    to: null,
    start: null,
    delta: null,
    percent: null,
    delayTimeout: null
  };
}, BZ = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollLeft;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageXOffset : r ? document.documentElement.scrollLeft : document.body.scrollLeft;
}, NZ = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollTop;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageYOffset : r ? document.documentElement.scrollTop : document.body.scrollTop;
}, qbe = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollWidth - t.offsetWidth;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollWidth, n.offsetWidth, r.clientWidth, r.scrollWidth, r.offsetWidth);
}, Gbe = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollHeight - t.offsetHeight;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollHeight, n.offsetHeight, r.clientHeight, r.scrollHeight, r.offsetHeight);
}, Kbe = function e(t, n, r) {
  var o = n.data;
  if (!n.ignoreCancelEvents && o.cancel) {
    ws.default.registered.end && ws.default.registered.end(o.to, o.target, o.currentPositionY);
    return;
  }
  if (o.delta = Math.round(o.targetPosition - o.startPosition), o.start === null && (o.start = r), o.progress = r - o.start, o.percent = o.progress >= o.duration ? 1 : t(o.progress / o.duration), o.currentPosition = o.startPosition + Math.ceil(o.delta * o.percent), o.containerElement && o.containerElement !== document && o.containerElement !== document.body ? n.horizontal ? o.containerElement.scrollLeft = o.currentPosition : o.containerElement.scrollTop = o.currentPosition : n.horizontal ? window.scrollTo(o.currentPosition, 0) : window.scrollTo(0, o.currentPosition), o.percent < 1) {
    var i = e.bind(null, t, n);
    bk.call(window, i);
    return;
  }
  ws.default.registered.end && ws.default.registered.end(o.to, o.target, o.currentPosition);
}, KP = function(e) {
  e.data.containerElement = e ? e.containerId ? document.getElementById(e.containerId) : e.container && e.container.nodeType ? e.container : document : null;
}, Sf = function(e, t, n, r) {
  t.data = t.data || RZ(), window.clearTimeout(t.data.delayTimeout);
  var o = function() {
    t.data.cancel = !0;
  };
  if ($be.default.subscribe(o), KP(t), t.data.start = null, t.data.cancel = !1, t.data.startPosition = t.horizontal ? BZ(t) : NZ(t), t.data.targetPosition = t.absolute ? e : e + t.data.startPosition, t.data.startPosition === t.data.targetPosition) {
    ws.default.registered.end && ws.default.registered.end(t.data.to, t.data.target, t.data.currentPosition);
    return;
  }
  t.data.delta = Math.round(t.data.targetPosition - t.data.startPosition), t.data.duration = Vbe(t.duration)(t.data.delta), t.data.duration = isNaN(parseFloat(t.data.duration)) ? 1e3 : parseFloat(t.data.duration), t.data.to = n, t.data.target = r;
  var i = IZ(t), a = Kbe.bind(null, i, t);
  if (t && t.delay > 0) {
    t.data.delayTimeout = window.setTimeout(function() {
      ws.default.registered.begin && ws.default.registered.begin(t.data.to, t.data.target), bk.call(window, a);
    }, t.delay);
    return;
  }
  ws.default.registered.begin && ws.default.registered.begin(t.data.to, t.data.target), bk.call(window, a);
}, Sw = function(e) {
  return e = Fbe({}, e), e.data = e.data || RZ(), e.absolute = !0, e;
}, Ybe = function(e) {
  Sf(0, Sw(e));
}, Xbe = function(e, t) {
  Sf(e, Sw(t));
}, Jbe = function(e) {
  e = Sw(e), KP(e), Sf(e.horizontal ? qbe(e) : Gbe(e), e);
}, Qbe = function(e, t) {
  t = Sw(t), KP(t);
  var n = t.horizontal ? BZ(t) : NZ(t);
  Sf(e + n, t);
};
Pw.default = {
  animateTopScroll: Sf,
  getAnimationType: IZ,
  scrollToTop: Ybe,
  scrollToBottom: Jbe,
  scrollTo: Xbe,
  scrollMore: Qbe
};
Object.defineProperty(Mc, "__esModule", {
  value: !0
});
var ewe = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, twe = Pf, nwe = YP(twe), rwe = Pw, owe = YP(rwe), iwe = _f, hg = YP(iwe);
function YP(e) {
  return e && e.__esModule ? e : { default: e };
}
var gg = {}, GR = void 0;
Mc.default = {
  unmount: function() {
    gg = {};
  },
  register: function(e, t) {
    gg[e] = t;
  },
  unregister: function(e) {
    delete gg[e];
  },
  get: function(e) {
    return gg[e] || document.getElementById(e) || document.getElementsByName(e)[0] || document.getElementsByClassName(e)[0];
  },
  setActiveLink: function(e) {
    return GR = e;
  },
  getActiveLink: function() {
    return GR;
  },
  scrollTo: function(e, t) {
    var n = this.get(e);
    if (!n) {
      console.warn("target Element not found");
      return;
    }
    t = ewe({}, t, { absolute: !1 });
    var r = t.containerId, o = t.container, i = void 0;
    r ? i = document.getElementById(r) : o && o.nodeType ? i = o : i = document, t.absolute = !0;
    var a = t.horizontal, s = nwe.default.scrollOffset(i, n, a) + (t.offset || 0);
    if (!t.smooth) {
      hg.default.registered.begin && hg.default.registered.begin(e, n), i === document ? t.horizontal ? window.scrollTo(s, 0) : window.scrollTo(0, s) : i.scrollTop = s, hg.default.registered.end && hg.default.registered.end(e, n);
      return;
    }
    owe.default.animateTopScroll(s, t, e, n);
  }
};
var wk = { exports: {} }, TC = { exports: {} }, Dn = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var KR;
function swe() {
  if (KR) return Dn;
  KR = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, g = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, m = e ? Symbol.for("react.block") : 60121, v = e ? Symbol.for("react.fundamental") : 60117, E = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
  function M(y) {
    if (typeof y == "object" && y !== null) {
      var C = y.$$typeof;
      switch (C) {
        case t:
          switch (y = y.type, y) {
            case l:
            case u:
            case r:
            case i:
            case o:
            case p:
              return y;
            default:
              switch (y = y && y.$$typeof, y) {
                case s:
                case c:
                case f:
                case g:
                case a:
                  return y;
                default:
                  return C;
              }
          }
        case n:
          return C;
      }
    }
  }
  function O(y) {
    return M(y) === u;
  }
  return Dn.AsyncMode = l, Dn.ConcurrentMode = u, Dn.ContextConsumer = s, Dn.ContextProvider = a, Dn.Element = t, Dn.ForwardRef = c, Dn.Fragment = r, Dn.Lazy = f, Dn.Memo = g, Dn.Portal = n, Dn.Profiler = i, Dn.StrictMode = o, Dn.Suspense = p, Dn.isAsyncMode = function(y) {
    return O(y) || M(y) === l;
  }, Dn.isConcurrentMode = O, Dn.isContextConsumer = function(y) {
    return M(y) === s;
  }, Dn.isContextProvider = function(y) {
    return M(y) === a;
  }, Dn.isElement = function(y) {
    return typeof y == "object" && y !== null && y.$$typeof === t;
  }, Dn.isForwardRef = function(y) {
    return M(y) === c;
  }, Dn.isFragment = function(y) {
    return M(y) === r;
  }, Dn.isLazy = function(y) {
    return M(y) === f;
  }, Dn.isMemo = function(y) {
    return M(y) === g;
  }, Dn.isPortal = function(y) {
    return M(y) === n;
  }, Dn.isProfiler = function(y) {
    return M(y) === i;
  }, Dn.isStrictMode = function(y) {
    return M(y) === o;
  }, Dn.isSuspense = function(y) {
    return M(y) === p;
  }, Dn.isValidElementType = function(y) {
    return typeof y == "string" || typeof y == "function" || y === r || y === u || y === i || y === o || y === p || y === d || typeof y == "object" && y !== null && (y.$$typeof === f || y.$$typeof === g || y.$$typeof === a || y.$$typeof === s || y.$$typeof === c || y.$$typeof === v || y.$$typeof === E || y.$$typeof === w || y.$$typeof === m);
  }, Dn.typeOf = M, Dn;
}
var zn = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var YR;
function awe() {
  return YR || (YR = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, g = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, m = e ? Symbol.for("react.block") : 60121, v = e ? Symbol.for("react.fundamental") : 60117, E = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
    function M(B) {
      return typeof B == "string" || typeof B == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      B === r || B === u || B === i || B === o || B === p || B === d || typeof B == "object" && B !== null && (B.$$typeof === f || B.$$typeof === g || B.$$typeof === a || B.$$typeof === s || B.$$typeof === c || B.$$typeof === v || B.$$typeof === E || B.$$typeof === w || B.$$typeof === m);
    }
    function O(B) {
      if (typeof B == "object" && B !== null) {
        var ue = B.$$typeof;
        switch (ue) {
          case t:
            var fe = B.type;
            switch (fe) {
              case l:
              case u:
              case r:
              case i:
              case o:
              case p:
                return fe;
              default:
                var oe = fe && fe.$$typeof;
                switch (oe) {
                  case s:
                  case c:
                  case f:
                  case g:
                  case a:
                    return oe;
                  default:
                    return ue;
                }
            }
          case n:
            return ue;
        }
      }
    }
    var y = l, C = u, _ = s, F = a, L = t, N = c, R = r, W = f, V = g, z = n, Z = i, K = o, X = p, te = !1;
    function J(B) {
      return te || (te = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), P(B) || O(B) === l;
    }
    function P(B) {
      return O(B) === u;
    }
    function D(B) {
      return O(B) === s;
    }
    function H(B) {
      return O(B) === a;
    }
    function S(B) {
      return typeof B == "object" && B !== null && B.$$typeof === t;
    }
    function $(B) {
      return O(B) === c;
    }
    function x(B) {
      return O(B) === r;
    }
    function j(B) {
      return O(B) === f;
    }
    function U(B) {
      return O(B) === g;
    }
    function T(B) {
      return O(B) === n;
    }
    function q(B) {
      return O(B) === i;
    }
    function A(B) {
      return O(B) === o;
    }
    function Y(B) {
      return O(B) === p;
    }
    zn.AsyncMode = y, zn.ConcurrentMode = C, zn.ContextConsumer = _, zn.ContextProvider = F, zn.Element = L, zn.ForwardRef = N, zn.Fragment = R, zn.Lazy = W, zn.Memo = V, zn.Portal = z, zn.Profiler = Z, zn.StrictMode = K, zn.Suspense = X, zn.isAsyncMode = J, zn.isConcurrentMode = P, zn.isContextConsumer = D, zn.isContextProvider = H, zn.isElement = S, zn.isForwardRef = $, zn.isFragment = x, zn.isLazy = j, zn.isMemo = U, zn.isPortal = T, zn.isProfiler = q, zn.isStrictMode = A, zn.isSuspense = Y, zn.isValidElementType = M, zn.typeOf = O;
  }()), zn;
}
var XR;
function FZ() {
  return XR || (XR = 1, process.env.NODE_ENV === "production" ? TC.exports = swe() : TC.exports = awe()), TC.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var jC, JR;
function lwe() {
  if (JR) return jC;
  JR = 1;
  var e = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, n = Object.prototype.propertyIsEnumerable;
  function r(i) {
    if (i == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(i);
  }
  function o() {
    try {
      if (!Object.assign)
        return !1;
      var i = new String("abc");
      if (i[5] = "de", Object.getOwnPropertyNames(i)[0] === "5")
        return !1;
      for (var a = {}, s = 0; s < 10; s++)
        a["_" + String.fromCharCode(s)] = s;
      var l = Object.getOwnPropertyNames(a).map(function(c) {
        return a[c];
      });
      if (l.join("") !== "0123456789")
        return !1;
      var u = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(c) {
        u[c] = c;
      }), Object.keys(Object.assign({}, u)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return jC = o() ? Object.assign : function(i, a) {
    for (var s, l = r(i), u, c = 1; c < arguments.length; c++) {
      s = Object(arguments[c]);
      for (var p in s)
        t.call(s, p) && (l[p] = s[p]);
      if (e) {
        u = e(s);
        for (var d = 0; d < u.length; d++)
          n.call(s, u[d]) && (l[u[d]] = s[u[d]]);
      }
    }
    return l;
  }, jC;
}
var AC, QR;
function XP() {
  if (QR) return AC;
  QR = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return AC = e, AC;
}
var eB, tB;
function zZ() {
  return tB || (tB = 1, eB = Function.call.bind(Object.prototype.hasOwnProperty)), eB;
}
var IC, nB;
function uwe() {
  if (nB) return IC;
  nB = 1;
  var e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = XP(), n = {}, r = zZ();
    e = function(i) {
      var a = "Warning: " + i;
      typeof console < "u" && console.error(a);
      try {
        throw new Error(a);
      } catch {
      }
    };
  }
  function o(i, a, s, l, u) {
    if (process.env.NODE_ENV !== "production") {
      for (var c in i)
        if (r(i, c)) {
          var p;
          try {
            if (typeof i[c] != "function") {
              var d = Error(
                (l || "React class") + ": " + s + " type `" + c + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof i[c] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw d.name = "Invariant Violation", d;
            }
            p = i[c](a, c, l, s, null, t);
          } catch (f) {
            p = f;
          }
          if (p && !(p instanceof Error) && e(
            (l || "React class") + ": type specification of " + s + " `" + c + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof p + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), p instanceof Error && !(p.message in n)) {
            n[p.message] = !0;
            var g = u ? u() : "";
            e(
              "Failed " + s + " type: " + p.message + (g ?? "")
            );
          }
        }
    }
  }
  return o.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (n = {});
  }, IC = o, IC;
}
var RC, rB;
function cwe() {
  if (rB) return RC;
  rB = 1;
  var e = FZ(), t = lwe(), n = XP(), r = zZ(), o = uwe(), i = function() {
  };
  process.env.NODE_ENV !== "production" && (i = function(s) {
    var l = "Warning: " + s;
    typeof console < "u" && console.error(l);
    try {
      throw new Error(l);
    } catch {
    }
  });
  function a() {
    return null;
  }
  return RC = function(s, l) {
    var u = typeof Symbol == "function" && Symbol.iterator, c = "@@iterator";
    function p(P) {
      var D = P && (u && P[u] || P[c]);
      if (typeof D == "function")
        return D;
    }
    var d = "<<anonymous>>", g = {
      array: E("array"),
      bigint: E("bigint"),
      bool: E("boolean"),
      func: E("function"),
      number: E("number"),
      object: E("object"),
      string: E("string"),
      symbol: E("symbol"),
      any: w(),
      arrayOf: M,
      element: O(),
      elementType: y(),
      instanceOf: C,
      node: N(),
      objectOf: F,
      oneOf: _,
      oneOfType: L,
      shape: W,
      exact: V
    };
    function f(P, D) {
      return P === D ? P !== 0 || 1 / P === 1 / D : P !== P && D !== D;
    }
    function m(P, D) {
      this.message = P, this.data = D && typeof D == "object" ? D : {}, this.stack = "";
    }
    m.prototype = Error.prototype;
    function v(P) {
      if (process.env.NODE_ENV !== "production")
        var D = {}, H = 0;
      function S(x, j, U, T, q, A, Y) {
        if (T = T || d, A = A || U, Y !== n) {
          if (l) {
            var B = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw B.name = "Invariant Violation", B;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var ue = T + ":" + U;
            !D[ue] && // Avoid spamming the console because they are often not actionable except for lib authors
            H < 3 && (i(
              "You are manually calling a React.PropTypes validation function for the `" + A + "` prop on `" + T + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), D[ue] = !0, H++);
          }
        }
        return j[U] == null ? x ? j[U] === null ? new m("The " + q + " `" + A + "` is marked as required " + ("in `" + T + "`, but its value is `null`.")) : new m("The " + q + " `" + A + "` is marked as required in " + ("`" + T + "`, but its value is `undefined`.")) : null : P(j, U, T, q, A);
      }
      var $ = S.bind(null, !1);
      return $.isRequired = S.bind(null, !0), $;
    }
    function E(P) {
      function D(H, S, $, x, j, U) {
        var T = H[S], q = K(T);
        if (q !== P) {
          var A = X(T);
          return new m(
            "Invalid " + x + " `" + j + "` of type " + ("`" + A + "` supplied to `" + $ + "`, expected ") + ("`" + P + "`."),
            { expectedType: P }
          );
        }
        return null;
      }
      return v(D);
    }
    function w() {
      return v(a);
    }
    function M(P) {
      function D(H, S, $, x, j) {
        if (typeof P != "function")
          return new m("Property `" + j + "` of component `" + $ + "` has invalid PropType notation inside arrayOf.");
        var U = H[S];
        if (!Array.isArray(U)) {
          var T = K(U);
          return new m("Invalid " + x + " `" + j + "` of type " + ("`" + T + "` supplied to `" + $ + "`, expected an array."));
        }
        for (var q = 0; q < U.length; q++) {
          var A = P(U, q, $, x, j + "[" + q + "]", n);
          if (A instanceof Error)
            return A;
        }
        return null;
      }
      return v(D);
    }
    function O() {
      function P(D, H, S, $, x) {
        var j = D[H];
        if (!s(j)) {
          var U = K(j);
          return new m("Invalid " + $ + " `" + x + "` of type " + ("`" + U + "` supplied to `" + S + "`, expected a single ReactElement."));
        }
        return null;
      }
      return v(P);
    }
    function y() {
      function P(D, H, S, $, x) {
        var j = D[H];
        if (!e.isValidElementType(j)) {
          var U = K(j);
          return new m("Invalid " + $ + " `" + x + "` of type " + ("`" + U + "` supplied to `" + S + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return v(P);
    }
    function C(P) {
      function D(H, S, $, x, j) {
        if (!(H[S] instanceof P)) {
          var U = P.name || d, T = J(H[S]);
          return new m("Invalid " + x + " `" + j + "` of type " + ("`" + T + "` supplied to `" + $ + "`, expected ") + ("instance of `" + U + "`."));
        }
        return null;
      }
      return v(D);
    }
    function _(P) {
      if (!Array.isArray(P))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? i(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : i("Invalid argument supplied to oneOf, expected an array.")), a;
      function D(H, S, $, x, j) {
        for (var U = H[S], T = 0; T < P.length; T++)
          if (f(U, P[T]))
            return null;
        var q = JSON.stringify(P, function(A, Y) {
          var B = X(Y);
          return B === "symbol" ? String(Y) : Y;
        });
        return new m("Invalid " + x + " `" + j + "` of value `" + String(U) + "` " + ("supplied to `" + $ + "`, expected one of " + q + "."));
      }
      return v(D);
    }
    function F(P) {
      function D(H, S, $, x, j) {
        if (typeof P != "function")
          return new m("Property `" + j + "` of component `" + $ + "` has invalid PropType notation inside objectOf.");
        var U = H[S], T = K(U);
        if (T !== "object")
          return new m("Invalid " + x + " `" + j + "` of type " + ("`" + T + "` supplied to `" + $ + "`, expected an object."));
        for (var q in U)
          if (r(U, q)) {
            var A = P(U, q, $, x, j + "." + q, n);
            if (A instanceof Error)
              return A;
          }
        return null;
      }
      return v(D);
    }
    function L(P) {
      if (!Array.isArray(P))
        return process.env.NODE_ENV !== "production" && i("Invalid argument supplied to oneOfType, expected an instance of array."), a;
      for (var D = 0; D < P.length; D++) {
        var H = P[D];
        if (typeof H != "function")
          return i(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + te(H) + " at index " + D + "."
          ), a;
      }
      function S($, x, j, U, T) {
        for (var q = [], A = 0; A < P.length; A++) {
          var Y = P[A], B = Y($, x, j, U, T, n);
          if (B == null)
            return null;
          B.data && r(B.data, "expectedType") && q.push(B.data.expectedType);
        }
        var ue = q.length > 0 ? ", expected one of type [" + q.join(", ") + "]" : "";
        return new m("Invalid " + U + " `" + T + "` supplied to " + ("`" + j + "`" + ue + "."));
      }
      return v(S);
    }
    function N() {
      function P(D, H, S, $, x) {
        return z(D[H]) ? null : new m("Invalid " + $ + " `" + x + "` supplied to " + ("`" + S + "`, expected a ReactNode."));
      }
      return v(P);
    }
    function R(P, D, H, S, $) {
      return new m(
        (P || "React class") + ": " + D + " type `" + H + "." + S + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + $ + "`."
      );
    }
    function W(P) {
      function D(H, S, $, x, j) {
        var U = H[S], T = K(U);
        if (T !== "object")
          return new m("Invalid " + x + " `" + j + "` of type `" + T + "` " + ("supplied to `" + $ + "`, expected `object`."));
        for (var q in P) {
          var A = P[q];
          if (typeof A != "function")
            return R($, x, j, q, X(A));
          var Y = A(U, q, $, x, j + "." + q, n);
          if (Y)
            return Y;
        }
        return null;
      }
      return v(D);
    }
    function V(P) {
      function D(H, S, $, x, j) {
        var U = H[S], T = K(U);
        if (T !== "object")
          return new m("Invalid " + x + " `" + j + "` of type `" + T + "` " + ("supplied to `" + $ + "`, expected `object`."));
        var q = t({}, H[S], P);
        for (var A in q) {
          var Y = P[A];
          if (r(P, A) && typeof Y != "function")
            return R($, x, j, A, X(Y));
          if (!Y)
            return new m(
              "Invalid " + x + " `" + j + "` key `" + A + "` supplied to `" + $ + "`.\nBad object: " + JSON.stringify(H[S], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(P), null, "  ")
            );
          var B = Y(U, A, $, x, j + "." + A, n);
          if (B)
            return B;
        }
        return null;
      }
      return v(D);
    }
    function z(P) {
      switch (typeof P) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !P;
        case "object":
          if (Array.isArray(P))
            return P.every(z);
          if (P === null || s(P))
            return !0;
          var D = p(P);
          if (D) {
            var H = D.call(P), S;
            if (D !== P.entries) {
              for (; !(S = H.next()).done; )
                if (!z(S.value))
                  return !1;
            } else
              for (; !(S = H.next()).done; ) {
                var $ = S.value;
                if ($ && !z($[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function Z(P, D) {
      return P === "symbol" ? !0 : D ? D["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && D instanceof Symbol : !1;
    }
    function K(P) {
      var D = typeof P;
      return Array.isArray(P) ? "array" : P instanceof RegExp ? "object" : Z(D, P) ? "symbol" : D;
    }
    function X(P) {
      if (typeof P > "u" || P === null)
        return "" + P;
      var D = K(P);
      if (D === "object") {
        if (P instanceof Date)
          return "date";
        if (P instanceof RegExp)
          return "regexp";
      }
      return D;
    }
    function te(P) {
      var D = X(P);
      switch (D) {
        case "array":
        case "object":
          return "an " + D;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + D;
        default:
          return D;
      }
    }
    function J(P) {
      return !P.constructor || !P.constructor.name ? d : P.constructor.name;
    }
    return g.checkPropTypes = o, g.resetWarningCache = o.resetWarningCache, g.PropTypes = g, g;
  }, RC;
}
var BC, oB;
function pwe() {
  if (oB) return BC;
  oB = 1;
  var e = XP();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, BC = function() {
    function r(a, s, l, u, c, p) {
      if (p !== e) {
        var d = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw d.name = "Invariant Violation", d;
      }
    }
    r.isRequired = r;
    function o() {
      return r;
    }
    var i = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: o,
      element: r,
      elementType: r,
      instanceOf: o,
      node: r,
      objectOf: o,
      oneOf: o,
      oneOfType: o,
      shape: o,
      exact: o,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return i.PropTypes = i, i;
  }, BC;
}
if (process.env.NODE_ENV !== "production") {
  var dwe = FZ(), fwe = !0;
  wk.exports = cwe()(dwe.isElement, fwe);
} else
  wk.exports = pwe()();
var Mw = wk.exports, Dw = {};
Object.defineProperty(Dw, "__esModule", {
  value: !0
});
var hwe = Pf, NC = gwe(hwe);
function gwe(e) {
  return e && e.__esModule ? e : { default: e };
}
var mwe = {
  mountFlag: !1,
  initialized: !1,
  scroller: null,
  containers: {},
  mount: function(e) {
    this.scroller = e, this.handleHashChange = this.handleHashChange.bind(this), window.addEventListener("hashchange", this.handleHashChange), this.initStateFromHash(), this.mountFlag = !0;
  },
  mapContainer: function(e, t) {
    this.containers[e] = t;
  },
  isMounted: function() {
    return this.mountFlag;
  },
  isInitialized: function() {
    return this.initialized;
  },
  initStateFromHash: function() {
    var e = this, t = this.getHash();
    t ? window.setTimeout(function() {
      e.scrollTo(t, !0), e.initialized = !0;
    }, 10) : this.initialized = !0;
  },
  scrollTo: function(e, t) {
    var n = this.scroller, r = n.get(e);
    if (r && (t || e !== n.getActiveLink())) {
      var o = this.containers[e] || document;
      n.scrollTo(e, { container: o });
    }
  },
  getHash: function() {
    return NC.default.getHash();
  },
  changeHash: function(e, t) {
    this.isInitialized() && NC.default.getHash() !== e && NC.default.updateHash(e, t);
  },
  handleHashChange: function() {
    this.scrollTo(this.getHash());
  },
  unmount: function() {
    this.scroller = null, this.containers = null, window.removeEventListener("hashchange", this.handleHashChange);
  }
};
Dw.default = mwe;
Object.defineProperty(Ef, "__esModule", {
  value: !0
});
var mg = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, vwe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), ywe = we, iB = Mf(ywe), bwe = kf, vg = Mf(bwe), wwe = Mc, Cwe = Mf(wwe), xwe = Mw, Sr = Mf(xwe), Owe = Dw, Ea = Mf(Owe);
function Mf(e) {
  return e && e.__esModule ? e : { default: e };
}
function Ewe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function kwe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function Lwe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var sB = {
  to: Sr.default.string.isRequired,
  containerId: Sr.default.string,
  container: Sr.default.object,
  activeClass: Sr.default.string,
  activeStyle: Sr.default.object,
  spy: Sr.default.bool,
  horizontal: Sr.default.bool,
  smooth: Sr.default.oneOfType([Sr.default.bool, Sr.default.string]),
  offset: Sr.default.number,
  delay: Sr.default.number,
  isDynamic: Sr.default.bool,
  onClick: Sr.default.func,
  duration: Sr.default.oneOfType([Sr.default.number, Sr.default.func]),
  absolute: Sr.default.bool,
  onSetActive: Sr.default.func,
  onSetInactive: Sr.default.func,
  ignoreCancelEvents: Sr.default.bool,
  hashSpy: Sr.default.bool,
  saveHashHistory: Sr.default.bool,
  spyThrottle: Sr.default.number
};
Ef.default = function(e, t) {
  var n = t || Cwe.default, r = function(i) {
    Lwe(a, i);
    function a(s) {
      Ewe(this, a);
      var l = kwe(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
      return o.call(l), l.state = {
        active: !1
      }, l.beforeUnmountCallbacks = [], l;
    }
    return vwe(a, [{
      key: "getScrollSpyContainer",
      value: function() {
        var s = this.props.containerId, l = this.props.container;
        return s && !l ? document.getElementById(s) : l && l.nodeType ? l : document;
      }
    }, {
      key: "componentDidMount",
      value: function() {
        if (this.props.spy || this.props.hashSpy) {
          var s = this.getScrollSpyContainer();
          if (!vg.default.isMounted(s)) {
            var l = vg.default.mount(s, this.props.spyThrottle);
            this.beforeUnmountCallbacks.push(l);
          }
          this.props.hashSpy && (Ea.default.isMounted() || Ea.default.mount(n), Ea.default.mapContainer(this.props.to, s)), vg.default.addSpyHandler(this.spyHandler, s), this.setState({
            container: s
          });
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        vg.default.unmount(this.stateHandler, this.spyHandler), this.beforeUnmountCallbacks.forEach(function(s) {
          return s();
        });
      }
    }, {
      key: "render",
      value: function() {
        var s = "";
        this.state && this.state.active ? s = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : s = this.props.className;
        var l = {};
        this.state && this.state.active ? l = mg({}, this.props.style, this.props.activeStyle) : l = mg({}, this.props.style);
        var u = mg({}, this.props);
        for (var c in sB)
          u.hasOwnProperty(c) && delete u[c];
        return u.className = s, u.style = l, u.onClick = this.handleClick, iB.default.createElement(e, u);
      }
    }]), a;
  }(iB.default.PureComponent), o = function() {
    var i = this;
    this.scrollTo = function(a, s) {
      n.scrollTo(a, mg({}, i.state, s));
    }, this.handleClick = function(a) {
      i.props.onClick && i.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), i.scrollTo(i.props.to, i.props);
    }, this.spyHandler = function(a, s) {
      var l = i.getScrollSpyContainer();
      if (!(Ea.default.isMounted() && !Ea.default.isInitialized())) {
        var u = i.props.horizontal, c = i.props.to, p = null, d = void 0, g = void 0;
        if (u) {
          var f = 0, m = 0, v = 0;
          if (l.getBoundingClientRect) {
            var E = l.getBoundingClientRect();
            v = E.left;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var w = p.getBoundingClientRect();
            f = w.left - v + a, m = f + w.width;
          }
          var M = a - i.props.offset;
          d = M >= Math.floor(f) && M < Math.floor(m), g = M < Math.floor(f) || M >= Math.floor(m);
        } else {
          var O = 0, y = 0, C = 0;
          if (l.getBoundingClientRect) {
            var _ = l.getBoundingClientRect();
            C = _.top;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var F = p.getBoundingClientRect();
            O = F.top - C + s, y = O + F.height;
          }
          var L = s - i.props.offset;
          d = L >= Math.floor(O) && L < Math.floor(y), g = L < Math.floor(O) || L >= Math.floor(y);
        }
        var N = n.getActiveLink();
        if (g) {
          if (c === N && n.setActiveLink(void 0), i.props.hashSpy && Ea.default.getHash() === c) {
            var R = i.props.saveHashHistory, W = R === void 0 ? !1 : R;
            Ea.default.changeHash("", W);
          }
          i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive(c, p));
        }
        if (d && (N !== c || i.state.active === !1)) {
          n.setActiveLink(c);
          var V = i.props.saveHashHistory, z = V === void 0 ? !1 : V;
          i.props.hashSpy && Ea.default.changeHash(c, z), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(c, p));
        }
      }
    };
  };
  return r.propTypes = sB, r.defaultProps = { offset: 0 }, r;
};
Object.defineProperty(ZP, "__esModule", {
  value: !0
});
var Pwe = we, aB = UZ(Pwe), _we = Ef, Swe = UZ(_we);
function UZ(e) {
  return e && e.__esModule ? e : { default: e };
}
function Mwe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function lB(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function Dwe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var Twe = function(e) {
  Dwe(t, e);
  function t() {
    var n, r, o, i;
    Mwe(this, t);
    for (var a = arguments.length, s = Array(a), l = 0; l < a; l++)
      s[l] = arguments[l];
    return i = (r = (o = lB(this, (n = t.__proto__ || Object.getPrototypeOf(t)).call.apply(n, [this].concat(s))), o), o.render = function() {
      return aB.default.createElement(
        "a",
        o.props,
        o.props.children
      );
    }, r), lB(o, i);
  }
  return t;
}(aB.default.Component);
ZP.default = (0, Swe.default)(Twe);
var JP = {};
Object.defineProperty(JP, "__esModule", {
  value: !0
});
var jwe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), Awe = we, uB = HZ(Awe), Iwe = Ef, Rwe = HZ(Iwe);
function HZ(e) {
  return e && e.__esModule ? e : { default: e };
}
function Bwe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Nwe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function Fwe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var zwe = function(e) {
  Fwe(t, e);
  function t() {
    return Bwe(this, t), Nwe(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return jwe(t, [{
    key: "render",
    value: function() {
      return uB.default.createElement(
        "button",
        this.props,
        this.props.children
      );
    }
  }]), t;
}(uB.default.Component);
JP.default = (0, Rwe.default)(zwe);
var QP = {}, Tw = {};
Object.defineProperty(Tw, "__esModule", {
  value: !0
});
var Uwe = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, Hwe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), $we = we, cB = jw($we), Wwe = pl;
jw(Wwe);
var Vwe = Mc, pB = jw(Vwe), Zwe = Mw, dB = jw(Zwe);
function jw(e) {
  return e && e.__esModule ? e : { default: e };
}
function qwe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Gwe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function Kwe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
Tw.default = function(e) {
  var t = function(n) {
    Kwe(r, n);
    function r(o) {
      qwe(this, r);
      var i = Gwe(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
      return i.childBindings = {
        domNode: null
      }, i;
    }
    return Hwe(r, [{
      key: "componentDidMount",
      value: function() {
        if (typeof window > "u")
          return !1;
        this.registerElems(this.props.name);
      }
    }, {
      key: "componentDidUpdate",
      value: function(o) {
        this.props.name !== o.name && this.registerElems(this.props.name);
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        if (typeof window > "u")
          return !1;
        pB.default.unregister(this.props.name);
      }
    }, {
      key: "registerElems",
      value: function(o) {
        pB.default.register(o, this.childBindings.domNode);
      }
    }, {
      key: "render",
      value: function() {
        return cB.default.createElement(e, Uwe({}, this.props, { parentBindings: this.childBindings }));
      }
    }]), r;
  }(cB.default.Component);
  return t.propTypes = {
    name: dB.default.string,
    id: dB.default.string
  }, t;
};
Object.defineProperty(QP, "__esModule", {
  value: !0
});
var fB = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, Ywe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), Xwe = we, hB = e_(Xwe), Jwe = Tw, Qwe = e_(Jwe), e0e = Mw, gB = e_(e0e);
function e_(e) {
  return e && e.__esModule ? e : { default: e };
}
function t0e(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function n0e(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function r0e(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var $Z = function(e) {
  r0e(t, e);
  function t() {
    return t0e(this, t), n0e(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return Ywe(t, [{
    key: "render",
    value: function() {
      var n = this, r = fB({}, this.props);
      return delete r.name, r.parentBindings && delete r.parentBindings, hB.default.createElement(
        "div",
        fB({}, r, { ref: function(o) {
          n.props.parentBindings.domNode = o;
        } }),
        this.props.children
      );
    }
  }]), t;
}(hB.default.Component);
$Z.propTypes = {
  name: gB.default.string,
  id: gB.default.string
};
QP.default = (0, Qwe.default)($Z);
var FC = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, mB = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}();
function vB(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function yB(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function bB(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var yg = we, Rl = kf, zC = Mc, Kr = Mw, ka = Dw, wB = {
  to: Kr.string.isRequired,
  containerId: Kr.string,
  container: Kr.object,
  activeClass: Kr.string,
  spy: Kr.bool,
  smooth: Kr.oneOfType([Kr.bool, Kr.string]),
  offset: Kr.number,
  delay: Kr.number,
  isDynamic: Kr.bool,
  onClick: Kr.func,
  duration: Kr.oneOfType([Kr.number, Kr.func]),
  absolute: Kr.bool,
  onSetActive: Kr.func,
  onSetInactive: Kr.func,
  ignoreCancelEvents: Kr.bool,
  hashSpy: Kr.bool,
  spyThrottle: Kr.number
}, o0e = {
  Scroll: function(e, t) {
    console.warn("Helpers.Scroll is deprecated since v1.7.0");
    var n = t || zC, r = function(i) {
      bB(a, i);
      function a(s) {
        vB(this, a);
        var l = yB(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
        return o.call(l), l.state = {
          active: !1
        }, l;
      }
      return mB(a, [{
        key: "getScrollSpyContainer",
        value: function() {
          var s = this.props.containerId, l = this.props.container;
          return s ? document.getElementById(s) : l && l.nodeType ? l : document;
        }
      }, {
        key: "componentDidMount",
        value: function() {
          if (this.props.spy || this.props.hashSpy) {
            var s = this.getScrollSpyContainer();
            Rl.isMounted(s) || Rl.mount(s, this.props.spyThrottle), this.props.hashSpy && (ka.isMounted() || ka.mount(n), ka.mapContainer(this.props.to, s)), this.props.spy && Rl.addStateHandler(this.stateHandler), Rl.addSpyHandler(this.spyHandler, s), this.setState({
              container: s
            });
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          Rl.unmount(this.stateHandler, this.spyHandler);
        }
      }, {
        key: "render",
        value: function() {
          var s = "";
          this.state && this.state.active ? s = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : s = this.props.className;
          var l = FC({}, this.props);
          for (var u in wB)
            l.hasOwnProperty(u) && delete l[u];
          return l.className = s, l.onClick = this.handleClick, yg.createElement(e, l);
        }
      }]), a;
    }(yg.Component), o = function() {
      var i = this;
      this.scrollTo = function(a, s) {
        n.scrollTo(a, FC({}, i.state, s));
      }, this.handleClick = function(a) {
        i.props.onClick && i.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), i.scrollTo(i.props.to, i.props);
      }, this.stateHandler = function() {
        n.getActiveLink() !== i.props.to && (i.state !== null && i.state.active && i.props.onSetInactive && i.props.onSetInactive(), i.setState({ active: !1 }));
      }, this.spyHandler = function(a) {
        var s = i.getScrollSpyContainer();
        if (!(ka.isMounted() && !ka.isInitialized())) {
          var l = i.props.to, u = null, c = 0, p = 0, d = 0;
          if (s.getBoundingClientRect) {
            var g = s.getBoundingClientRect();
            d = g.top;
          }
          if (!u || i.props.isDynamic) {
            if (u = n.get(l), !u)
              return;
            var f = u.getBoundingClientRect();
            c = f.top - d + a, p = c + f.height;
          }
          var m = a - i.props.offset, v = m >= Math.floor(c) && m < Math.floor(p), E = m < Math.floor(c) || m >= Math.floor(p), w = n.getActiveLink();
          if (E)
            return l === w && n.setActiveLink(void 0), i.props.hashSpy && ka.getHash() === l && ka.changeHash(), i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive()), Rl.updateStates();
          if (v && w !== l)
            return n.setActiveLink(l), i.props.hashSpy && ka.changeHash(l), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(l)), Rl.updateStates();
        }
      };
    };
    return r.propTypes = wB, r.defaultProps = { offset: 0 }, r;
  },
  Element: function(e) {
    console.warn("Helpers.Element is deprecated since v1.7.0");
    var t = function(n) {
      bB(r, n);
      function r(o) {
        vB(this, r);
        var i = yB(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
        return i.childBindings = {
          domNode: null
        }, i;
      }
      return mB(r, [{
        key: "componentDidMount",
        value: function() {
          if (typeof window > "u")
            return !1;
          this.registerElems(this.props.name);
        }
      }, {
        key: "componentDidUpdate",
        value: function(o) {
          this.props.name !== o.name && this.registerElems(this.props.name);
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          if (typeof window > "u")
            return !1;
          zC.unregister(this.props.name);
        }
      }, {
        key: "registerElems",
        value: function(o) {
          zC.register(o, this.childBindings.domNode);
        }
      }, {
        key: "render",
        value: function() {
          return yg.createElement(e, FC({}, this.props, { parentBindings: this.childBindings }));
        }
      }]), r;
    }(yg.Component);
    return t.propTypes = {
      name: Kr.string,
      id: Kr.string
    }, t;
  }
}, i0e = o0e;
Object.defineProperty(uo, "__esModule", {
  value: !0
});
uo.Helpers = uo.ScrollElement = uo.ScrollLink = uo.animateScroll = uo.scrollSpy = uo.Events = uo.scroller = uo.Element = uo.Button = uo.Link = void 0;
var s0e = ZP, WZ = As(s0e), a0e = JP, VZ = As(a0e), l0e = QP, ZZ = As(l0e), u0e = Mc, qZ = As(u0e), c0e = _f, GZ = As(c0e), p0e = kf, KZ = As(p0e), d0e = Pw, YZ = As(d0e), f0e = Ef, XZ = As(f0e), h0e = Tw, JZ = As(h0e), g0e = i0e, QZ = As(g0e);
function As(e) {
  return e && e.__esModule ? e : { default: e };
}
uo.Link = WZ.default;
uo.Button = VZ.default;
uo.Element = ZZ.default;
uo.scroller = qZ.default;
uo.Events = GZ.default;
uo.scrollSpy = KZ.default;
uo.animateScroll = YZ.default;
uo.ScrollLink = XZ.default;
uo.ScrollElement = JZ.default;
uo.Helpers = QZ.default;
uo.default = { Link: WZ.default, Button: VZ.default, Element: ZZ.default, scroller: qZ.default, Events: GZ.default, scrollSpy: KZ.default, animateScroll: YZ.default, ScrollLink: XZ.default, ScrollElement: JZ.default, Helpers: QZ.default };
Ke({});
Ke({});
Ke({});
function tf(e) {
  "@babel/helpers - typeof";
  return tf = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, tf(e);
}
function m0e(e, t) {
  if (tf(e) != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (tf(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function v0e(e) {
  var t = m0e(e, "string");
  return tf(t) == "symbol" ? t : t + "";
}
function xe(e, t, n) {
  return (t = v0e(t)) in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function eq(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var UC, CB;
function y0e() {
  if (CB) return UC;
  CB = 1;
  var e = process.env.NODE_ENV, t = function(n, r, o, i, a, s, l, u) {
    if (e !== "production" && r === void 0)
      throw new Error("invariant requires an error message argument");
    if (!n) {
      var c;
      if (r === void 0)
        c = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
      else {
        var p = [o, i, a, s, l, u], d = 0;
        c = new Error(r.replace(/%s/g, function() {
          return p[d++];
        })), c.name = "Invariant Violation";
      }
      throw c.framesToPop = 1, c;
    }
  };
  return UC = t, UC;
}
var b0e = y0e(), bo = /* @__PURE__ */ eq(b0e), jt = Ke(null);
function w0e() {
  bo(!!ge, "useGoogleMap is React hook and requires React version 16.8+");
  var e = ge(jt);
  return bo(!!e, "useGoogleMap needs a GoogleMap available up in the tree"), e;
}
function C0e(e, t, n) {
  return Object.keys(e).reduce(function(r, o) {
    return t(r, e[o], o);
  }, n);
}
function x0e(e, t) {
  Object.keys(e).forEach((n) => t(e[n], n));
}
function O0e(e, t, n, r) {
  var o = {}, i = (a, s) => {
    var l = n[s];
    l !== t[s] && (o[s] = l, a(r, l));
  };
  return x0e(e, i), o;
}
function E0e(e, t, n) {
  var r = C0e(n, function(o, i, a) {
    return typeof e[a] == "function" && o.push(google.maps.event.addListener(t, i, e[a])), o;
  }, []);
  return r;
}
function k0e(e) {
  google.maps.event.removeListener(e);
}
function hn() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  e.forEach(k0e);
}
function ln(e) {
  var {
    updaterMap: t,
    eventMap: n,
    prevProps: r,
    nextProps: o,
    instance: i
  } = e, a = E0e(o, i, n);
  return O0e(t, r, o, i), a;
}
function L0e(e) {
  var {
    children: t,
    options: n,
    id: r,
    mapContainerStyle: o,
    mapContainerClassName: i,
    center: a,
    // clickableIcons,
    // extraMapTypes,
    // heading,
    // mapTypeId,
    onClick: s,
    onDblClick: l,
    onDrag: u,
    onDragEnd: c,
    onDragStart: p,
    onMouseMove: d,
    onMouseOut: g,
    onMouseOver: f,
    onMouseDown: m,
    onMouseUp: v,
    onRightClick: E,
    // onMapTypeIdChanged,
    // onTilesLoaded,
    // onBoundsChanged,
    onCenterChanged: w,
    // onHeadingChanged,
    // onIdle,
    // onProjectionChanged,
    // onResize,
    // onTiltChanged,
    // onZoomChanged,
    onLoad: M,
    onUnmount: O
  } = e, [y, C] = k(null), _ = ut(null), [F, L] = k(null), [N, R] = k(null), [W, V] = k(null), [z, Z] = k(null), [K, X] = k(null), [te, J] = k(null), [P, D] = k(null), [H, S] = k(null), [$, x] = k(null), [j, U] = k(null), [T, q] = k(null), [A, Y] = k(null);
  return h(() => {
    n && y !== null && y.setOptions(n);
  }, [y, n]), h(() => {
    y !== null && typeof a < "u" && y.setCenter(a);
  }, [y, a]), h(() => {
    y && l && (N !== null && google.maps.event.removeListener(N), R(google.maps.event.addListener(y, "dblclick", l)));
  }, [l]), h(() => {
    y && c && (W !== null && google.maps.event.removeListener(W), V(google.maps.event.addListener(y, "dragend", c)));
  }, [c]), h(() => {
    y && p && (z !== null && google.maps.event.removeListener(z), Z(google.maps.event.addListener(y, "dragstart", p)));
  }, [p]), h(() => {
    y && m && (K !== null && google.maps.event.removeListener(K), X(google.maps.event.addListener(y, "mousedown", m)));
  }, [m]), h(() => {
    y && d && (te !== null && google.maps.event.removeListener(te), J(google.maps.event.addListener(y, "mousemove", d)));
  }, [d]), h(() => {
    y && g && (P !== null && google.maps.event.removeListener(P), D(google.maps.event.addListener(y, "mouseout", g)));
  }, [g]), h(() => {
    y && f && (H !== null && google.maps.event.removeListener(H), S(google.maps.event.addListener(y, "mouseover", f)));
  }, [f]), h(() => {
    y && v && ($ !== null && google.maps.event.removeListener($), x(google.maps.event.addListener(y, "mouseup", v)));
  }, [v]), h(() => {
    y && E && (j !== null && google.maps.event.removeListener(j), U(google.maps.event.addListener(y, "rightclick", E)));
  }, [E]), h(() => {
    y && s && (T !== null && google.maps.event.removeListener(T), q(google.maps.event.addListener(y, "click", s)));
  }, [s]), h(() => {
    y && u && (A !== null && google.maps.event.removeListener(A), Y(google.maps.event.addListener(y, "drag", u)));
  }, [u]), h(() => {
    y && w && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(y, "center_changed", w)));
  }, [s]), h(() => {
    var B = _.current === null ? null : new google.maps.Map(_.current, n);
    return C(B), B !== null && M && M(B), () => {
      B !== null && O && O(B);
    };
  }, []), Mo.jsx("div", {
    id: r,
    ref: _,
    style: o,
    className: i,
    children: Mo.jsx(jt.Provider, {
      value: y,
      children: y !== null ? t : null
    })
  });
}
ve(L0e);
function xB(e, t, n, r, o, i, a) {
  try {
    var s = e[i](a), l = s.value;
  } catch (u) {
    return void n(u);
  }
  s.done ? t(l) : Promise.resolve(l).then(r, o);
}
function tq(e) {
  return function() {
    var t = this, n = arguments;
    return new Promise(function(r, o) {
      var i = e.apply(t, n);
      function a(l) {
        xB(i, r, o, a, s, "next", l);
      }
      function s(l) {
        xB(i, r, o, a, s, "throw", l);
      }
      a(void 0);
    });
  };
}
function nq(e) {
  var {
    googleMapsApiKey: t,
    googleMapsClientId: n,
    version: r = "weekly",
    language: o,
    region: i,
    libraries: a,
    channel: s,
    mapIds: l,
    authReferrerPolicy: u
  } = e, c = [];
  return bo(t && n || !(t && n), "You need to specify either googleMapsApiKey or googleMapsClientId for @react-google-maps/api load script to work. You cannot use both at the same time."), t ? c.push("key=".concat(t)) : n && c.push("client=".concat(n)), r && c.push("v=".concat(r)), o && c.push("language=".concat(o)), i && c.push("region=".concat(i)), a && a.length && c.push("libraries=".concat(a.sort().join(","))), s && c.push("channel=".concat(s)), l && l.length && c.push("map_ids=".concat(l.join(","))), u && c.push("auth_referrer_policy=".concat(u)), c.push("loading=async"), c.push("callback=initMap"), "https://maps.googleapis.com/maps/api/js?".concat(c.join("&"));
}
var pu = typeof document < "u";
function rq(e) {
  var {
    url: t,
    id: n,
    nonce: r
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } = e;
  return pu ? new Promise(function(o, i) {
    var a = document.getElementById(n), s = window;
    if (a) {
      var l = a.getAttribute("data-state");
      if (a.src === t && l !== "error") {
        if (l === "ready")
          return o(n);
        var u = s.initMap, c = a.onerror;
        s.initMap = function() {
          u && u(), o(n);
        }, a.onerror = function(d) {
          c && c(d), i(d);
        };
        return;
      } else
        a.remove();
    }
    var p = document.createElement("script");
    p.type = "text/javascript", p.src = t, p.id = n, p.async = !0, p.nonce = r || "", p.onerror = function(d) {
      p.setAttribute("data-state", "error"), i(d);
    }, s.initMap = function() {
      p.setAttribute("data-state", "ready"), o(n);
    }, document.head.appendChild(p);
  }).catch((o) => {
    throw console.error("injectScript error: ", o), o;
  }) : Promise.reject(new Error("document is undefined"));
}
function OB(e) {
  var t = e.href;
  return t && (t.indexOf("https://fonts.googleapis.com/css?family=Roboto") === 0 || t.indexOf("https://fonts.googleapis.com/css?family=Google+Sans+Text") === 0) ? !0 : (
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.styleSheet.cssText = "", !0) : (
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.innerHTML = "", !0) : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.innerHTML
      )
    )
  );
}
function oq() {
  var e = document.getElementsByTagName("head")[0];
  if (e) {
    var t = e.insertBefore.bind(e);
    e.insertBefore = function(r, o) {
      return OB(r) || Reflect.apply(t, e, [r, o]), r;
    };
    var n = e.appendChild.bind(e);
    e.appendChild = function(r) {
      return OB(r) || Reflect.apply(n, e, [r]), r;
    };
  }
}
var sp = !1;
function iq() {
  return Mo.jsx("div", {
    children: "Loading..."
  });
}
var Ck = {
  id: "script-loader",
  version: "weekly"
};
class P0e extends pe {
  constructor() {
    super(...arguments), xe(this, "check", null), xe(this, "state", {
      loaded: !1
    }), xe(this, "cleanupCallback", () => {
      delete window.google.maps, this.injectScript();
    }), xe(this, "isCleaningUp", /* @__PURE__ */ tq(function* () {
      function t(n) {
        if (!sp)
          n();
        else if (pu)
          var r = window.setInterval(function() {
            sp || (window.clearInterval(r), n());
          }, 1);
      }
      return new Promise(t);
    })), xe(this, "cleanup", () => {
      sp = !0;
      var t = document.getElementById(this.props.id);
      t && t.parentNode && t.parentNode.removeChild(t), Array.prototype.slice.call(document.getElementsByTagName("script")).filter(function(n) {
        return typeof n.src == "string" && n.src.includes("maps.googleapis");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("link")).filter(function(n) {
        return n.href === "https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Google+Sans";
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("style")).filter(function(n) {
        return n.innerText !== void 0 && n.innerText.length > 0 && n.innerText.includes(".gm-");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      });
    }), xe(this, "injectScript", () => {
      this.props.preventGoogleFontsLoading && oq(), bo(!!this.props.id, 'LoadScript requires "id" prop to be a string: %s', this.props.id);
      var t = {
        id: this.props.id,
        nonce: this.props.nonce,
        url: nq(this.props)
      };
      rq(t).then(() => {
        this.props.onLoad && this.props.onLoad(), this.setState(function() {
          return {
            loaded: !0
          };
        });
      }).catch((n) => {
        this.props.onError && this.props.onError(n), console.error(`
          There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(this.props.googleMapsApiKey || "-", ") or Client ID (").concat(this.props.googleMapsClientId || "-", `) to <LoadScript />
          Otherwise it is a Network issue.
        `));
      });
    }), xe(this, "getRef", (t) => {
      this.check = t;
    });
  }
  componentDidMount() {
    if (pu) {
      if (window.google && window.google.maps && !sp) {
        console.error("google api is already presented");
        return;
      }
      this.isCleaningUp().then(this.injectScript).catch(function(t) {
        console.error("Error at injecting script after cleaning up: ", t);
      });
    }
  }
  componentDidUpdate(t) {
    this.props.libraries !== t.libraries && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), pu && t.language !== this.props.language && (this.cleanup(), this.setState(function() {
      return {
        loaded: !1
      };
    }, this.cleanupCallback));
  }
  componentWillUnmount() {
    if (pu) {
      this.cleanup();
      var t = () => {
        this.check || (delete window.google, sp = !1);
      };
      window.setTimeout(t, 1), this.props.onUnmount && this.props.onUnmount();
    }
  }
  render() {
    return Mo.jsxs(Mo.Fragment, {
      children: [Mo.jsx("div", {
        ref: this.getRef
      }), this.state.loaded ? this.props.children : this.props.loadingElement || Mo.jsx(iq, {})]
    });
  }
}
xe(P0e, "defaultProps", Ck);
function _0e(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.includes(r)) continue;
    n[r] = e[r];
  }
  return n;
}
function t_(e, t) {
  if (e == null) return {};
  var n, r, o = _0e(e, t);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (r = 0; r < i.length; r++) n = i[r], t.includes(n) || {}.propertyIsEnumerable.call(e, n) && (o[n] = e[n]);
  }
  return o;
}
var EB;
function S0e(e) {
  var {
    id: t = Ck.id,
    version: n = Ck.version,
    nonce: r,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    preventGoogleFontsLoading: u,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  } = e, g = ut(!1), [f, m] = k(!1), [v, E] = k(void 0);
  h(function() {
    return g.current = !0, () => {
      g.current = !1;
    };
  }, []), h(function() {
    pu && u && oq();
  }, [u]), h(function() {
    f && bo(!!window.google, "useLoadScript was marked as loaded, but window.google is not present. Something went wrong.");
  }, [f]);
  var w = nq({
    version: n,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  });
  h(function() {
    if (!pu)
      return;
    function O() {
      g.current && (m(!0), EB = w);
    }
    if (window.google && window.google.maps && EB === w) {
      O();
      return;
    }
    rq({
      id: t,
      url: w,
      nonce: r
    }).then(O).catch(function(y) {
      g.current && E(y), console.warn(`
        There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(o || "-", ") or Client ID (").concat(i || "-", `)
        Otherwise it is a Network issue.
      `)), console.error(y);
    });
  }, [t, w, r]);
  var M = ut(void 0);
  return h(function() {
    M.current && l !== M.current && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), M.current = l;
  }, [l]), {
    isLoaded: f,
    loadError: v,
    url: w
  };
}
var M0e = ["loadingElement", "onLoad", "onError", "onUnmount", "children"], D0e = Mo.jsx(iq, {});
function T0e(e) {
  var {
    loadingElement: t,
    onLoad: n,
    onError: r,
    onUnmount: o,
    children: i
  } = e, a = t_(e, M0e), {
    isLoaded: s,
    loadError: l
  } = S0e(a);
  return h(function() {
    s && typeof n == "function" && n();
  }, [s, n]), h(function() {
    l && typeof r == "function" && r(l);
  }, [l, r]), h(function() {
    return () => {
      o && o();
    };
  }, [o]), s ? i : t || D0e;
}
ve(T0e);
var kB;
(function(e) {
  e[e.INITIALIZED = 0] = "INITIALIZED", e[e.LOADING = 1] = "LOADING", e[e.SUCCESS = 2] = "SUCCESS", e[e.FAILURE = 3] = "FAILURE";
})(kB || (kB = {}));
function LB(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Iv(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? LB(Object(n), !0).forEach(function(r) {
      xe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : LB(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var PB = {}, _B = {
  options(e, t) {
    e.setOptions(t);
  }
};
function j0e(e) {
  var {
    options: t,
    onLoad: n,
    onUnmount: r
  } = e, o = ge(jt), [i, a] = k(null);
  return h(() => {
    i !== null && i.setMap(o);
  }, [o]), h(() => {
    t && i !== null && i.setOptions(t);
  }, [i, t]), h(() => {
    var s = new google.maps.TrafficLayer(Iv(Iv({}, t), {}, {
      map: o
    }));
    return a(s), n && n(s), () => {
      i !== null && (r && r(i), i.setMap(null));
    };
  }, []), null;
}
ve(j0e);
class A0e extends pe {
  constructor() {
    super(...arguments), xe(this, "state", {
      trafficLayer: null
    }), xe(this, "setTrafficLayerCallback", () => {
      this.state.trafficLayer !== null && this.props.onLoad && this.props.onLoad(this.state.trafficLayer);
    }), xe(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = new google.maps.TrafficLayer(Iv(Iv({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = ln({
      updaterMap: _B,
      eventMap: PB,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        trafficLayer: t
      };
    }, this.setTrafficLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.trafficLayer !== null && (hn(this.registeredEvents), this.registeredEvents = ln({
      updaterMap: _B,
      eventMap: PB,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.trafficLayer
    }));
  }
  componentWillUnmount() {
    this.state.trafficLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.trafficLayer), hn(this.registeredEvents), this.state.trafficLayer.setMap(null));
  }
  render() {
    return null;
  }
}
xe(A0e, "contextType", jt);
function I0e(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = ge(jt), [o, i] = k(null);
  return h(() => {
    o !== null && o.setMap(r);
  }, [r]), h(() => {
    var a = new google.maps.BicyclingLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      a !== null && (n && n(a), a.setMap(null));
    };
  }, []), null;
}
ve(I0e);
class R0e extends pe {
  constructor() {
    super(...arguments), xe(this, "state", {
      bicyclingLayer: null
    }), xe(this, "setBicyclingLayerCallback", () => {
      this.state.bicyclingLayer !== null && (this.state.bicyclingLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.bicyclingLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.BicyclingLayer();
    this.setState(() => ({
      bicyclingLayer: t
    }), this.setBicyclingLayerCallback);
  }
  componentWillUnmount() {
    this.state.bicyclingLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.bicyclingLayer), this.state.bicyclingLayer.setMap(null));
  }
  render() {
    return null;
  }
}
xe(R0e, "contextType", jt);
function B0e(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = ge(jt), [o, i] = k(null);
  return h(() => {
    o !== null && o.setMap(r);
  }, [r]), h(() => {
    var a = new google.maps.TransitLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      o !== null && (n && n(o), o.setMap(null));
    };
  }, []), null;
}
ve(B0e);
class N0e extends pe {
  constructor() {
    super(...arguments), xe(this, "state", {
      transitLayer: null
    }), xe(this, "setTransitLayerCallback", () => {
      this.state.transitLayer !== null && (this.state.transitLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.transitLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.TransitLayer();
    this.setState(function() {
      return {
        transitLayer: t
      };
    }, this.setTransitLayerCallback);
  }
  componentWillUnmount() {
    this.state.transitLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.transitLayer), this.state.transitLayer.setMap(null));
  }
  render() {
    return null;
  }
}
xe(N0e, "contextType", jt);
function SB(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Rv(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? SB(Object(n), !0).forEach(function(r) {
      xe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : SB(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var MB = {
  onCircleComplete: "circlecomplete",
  onMarkerComplete: "markercomplete",
  onOverlayComplete: "overlaycomplete",
  onPolygonComplete: "polygoncomplete",
  onPolylineComplete: "polylinecomplete",
  onRectangleComplete: "rectanglecomplete"
}, DB = {
  drawingMode(e, t) {
    e.setDrawingMode(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function F0e(e) {
  var {
    options: t,
    drawingMode: n,
    onCircleComplete: r,
    onMarkerComplete: o,
    onOverlayComplete: i,
    onPolygonComplete: a,
    onPolylineComplete: s,
    onRectangleComplete: l,
    onLoad: u,
    onUnmount: c
  } = e, p = ge(jt), [d, g] = k(null), [f, m] = k(null), [v, E] = k(null), [w, M] = k(null), [O, y] = k(null), [C, _] = k(null), [F, L] = k(null);
  return h(() => {
    d !== null && d.setMap(p);
  }, [p]), h(() => {
    t && d !== null && d.setOptions(t);
  }, [d, t]), h(() => {
    d !== null && d.setDrawingMode(n ?? null);
  }, [d, n]), h(() => {
    d && r && (f !== null && google.maps.event.removeListener(f), m(google.maps.event.addListener(d, "circlecomplete", r)));
  }, [d, r]), h(() => {
    d && o && (v !== null && google.maps.event.removeListener(v), E(google.maps.event.addListener(d, "markercomplete", o)));
  }, [d, o]), h(() => {
    d && i && (w !== null && google.maps.event.removeListener(w), M(google.maps.event.addListener(d, "overlaycomplete", i)));
  }, [d, i]), h(() => {
    d && a && (O !== null && google.maps.event.removeListener(O), y(google.maps.event.addListener(d, "polygoncomplete", a)));
  }, [d, a]), h(() => {
    d && s && (C !== null && google.maps.event.removeListener(C), _(google.maps.event.addListener(d, "polylinecomplete", s)));
  }, [d, s]), h(() => {
    d && l && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(d, "rectanglecomplete", l)));
  }, [d, l]), h(() => {
    bo(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
    var N = new google.maps.drawing.DrawingManager(Rv(Rv({}, t), {}, {
      map: p
    }));
    return n && N.setDrawingMode(n), r && m(google.maps.event.addListener(N, "circlecomplete", r)), o && E(google.maps.event.addListener(N, "markercomplete", o)), i && M(google.maps.event.addListener(N, "overlaycomplete", i)), a && y(google.maps.event.addListener(N, "polygoncomplete", a)), s && _(google.maps.event.addListener(N, "polylinecomplete", s)), l && L(google.maps.event.addListener(N, "rectanglecomplete", l)), g(N), u && u(N), () => {
      d !== null && (f && google.maps.event.removeListener(f), v && google.maps.event.removeListener(v), w && google.maps.event.removeListener(w), O && google.maps.event.removeListener(O), C && google.maps.event.removeListener(C), F && google.maps.event.removeListener(F), c && c(d), d.setMap(null));
    };
  }, []), null;
}
ve(F0e);
class z0e extends pe {
  constructor(t) {
    super(t), xe(this, "registeredEvents", []), xe(this, "state", {
      drawingManager: null
    }), xe(this, "setDrawingManagerCallback", () => {
      this.state.drawingManager !== null && this.props.onLoad && this.props.onLoad(this.state.drawingManager);
    }), bo(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
  }
  componentDidMount() {
    var t = new google.maps.drawing.DrawingManager(Rv(Rv({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = ln({
      updaterMap: DB,
      eventMap: MB,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        drawingManager: t
      };
    }, this.setDrawingManagerCallback);
  }
  componentDidUpdate(t) {
    this.state.drawingManager !== null && (hn(this.registeredEvents), this.registeredEvents = ln({
      updaterMap: DB,
      eventMap: MB,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.drawingManager
    }));
  }
  componentWillUnmount() {
    this.state.drawingManager !== null && (this.props.onUnmount && this.props.onUnmount(this.state.drawingManager), hn(this.registeredEvents), this.state.drawingManager.setMap(null));
  }
  render() {
    return null;
  }
}
xe(z0e, "contextType", jt);
function TB(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function oc(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? TB(Object(n), !0).forEach(function(r) {
      xe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : TB(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var jB = {
  onAnimationChanged: "animation_changed",
  onClick: "click",
  onClickableChanged: "clickable_changed",
  onCursorChanged: "cursor_changed",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDraggableChanged: "draggable_changed",
  onDragStart: "dragstart",
  onFlatChanged: "flat_changed",
  onIconChanged: "icon_changed",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onPositionChanged: "position_changed",
  onRightClick: "rightclick",
  onShapeChanged: "shape_changed",
  onTitleChanged: "title_changed",
  onVisibleChanged: "visible_changed",
  onZindexChanged: "zindex_changed"
}, AB = {
  animation(e, t) {
    e.setAnimation(t);
  },
  clickable(e, t) {
    e.setClickable(t);
  },
  cursor(e, t) {
    e.setCursor(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  icon(e, t) {
    e.setIcon(t);
  },
  label(e, t) {
    e.setLabel(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  opacity(e, t) {
    e.setOpacity(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  shape(e, t) {
    e.setShape(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, Bv = {};
function U0e(e) {
  var {
    position: t,
    options: n,
    clusterer: r,
    noClustererRedraw: o,
    children: i,
    draggable: a,
    visible: s,
    animation: l,
    clickable: u,
    cursor: c,
    icon: p,
    label: d,
    opacity: g,
    shape: f,
    title: m,
    zIndex: v,
    onClick: E,
    onDblClick: w,
    onDrag: M,
    onDragEnd: O,
    onDragStart: y,
    onMouseOut: C,
    onMouseOver: _,
    onMouseUp: F,
    onMouseDown: L,
    onRightClick: N,
    onClickableChanged: R,
    onCursorChanged: W,
    onAnimationChanged: V,
    onDraggableChanged: z,
    onFlatChanged: Z,
    onIconChanged: K,
    onPositionChanged: X,
    onShapeChanged: te,
    onTitleChanged: J,
    onVisibleChanged: P,
    onZindexChanged: D,
    onLoad: H,
    onUnmount: S
  } = e, $ = ge(jt), [x, j] = k(null), [U, T] = k(null), [q, A] = k(null), [Y, B] = k(null), [ue, fe] = k(null), [oe, Ae] = k(null), [Ze, Ge] = k(null), [Ie, et] = k(null), [Ye, _e] = k(null), [Qe, at] = k(null), [Pe, Me] = k(null), [Je, We] = k(null), [Re, nt] = k(null), [De, yt] = k(null), [ot, st] = k(null), [ct, bt] = k(null), [pt, dt] = k(null), [tt, Xe] = k(null), [wt, Ct] = k(null), [ft, bn] = k(null), [ht, wn] = k(null), [gt, Mt] = k(null);
  h(() => {
    x !== null && x.setMap($);
  }, [$]), h(() => {
    typeof n < "u" && x !== null && x.setOptions(n);
  }, [x, n]), h(() => {
    typeof a < "u" && x !== null && x.setDraggable(a);
  }, [x, a]), h(() => {
    t && x !== null && x.setPosition(t);
  }, [x, t]), h(() => {
    typeof s < "u" && x !== null && x.setVisible(s);
  }, [x, s]), h(() => {
    x == null || x.setAnimation(l);
  }, [x, l]), h(() => {
    x && u !== void 0 && x.setClickable(u);
  }, [x, u]), h(() => {
    x && c !== void 0 && x.setCursor(c);
  }, [x, c]), h(() => {
    x && p !== void 0 && x.setIcon(p);
  }, [x, p]), h(() => {
    x && d !== void 0 && x.setLabel(d);
  }, [x, d]), h(() => {
    x && g !== void 0 && x.setOpacity(g);
  }, [x, g]), h(() => {
    x && f !== void 0 && x.setShape(f);
  }, [x, f]), h(() => {
    x && m !== void 0 && x.setTitle(m);
  }, [x, m]), h(() => {
    x && v !== void 0 && x.setZIndex(v);
  }, [x, v]), h(() => {
    x && w && (U !== null && google.maps.event.removeListener(U), T(google.maps.event.addListener(x, "dblclick", w)));
  }, [w]), h(() => {
    x && O && (q !== null && google.maps.event.removeListener(q), A(google.maps.event.addListener(x, "dragend", O)));
  }, [O]), h(() => {
    x && y && (Y !== null && google.maps.event.removeListener(Y), B(google.maps.event.addListener(x, "dragstart", y)));
  }, [y]), h(() => {
    x && L && (ue !== null && google.maps.event.removeListener(ue), fe(google.maps.event.addListener(x, "mousedown", L)));
  }, [L]), h(() => {
    x && C && (oe !== null && google.maps.event.removeListener(oe), Ae(google.maps.event.addListener(x, "mouseout", C)));
  }, [C]), h(() => {
    x && _ && (Ze !== null && google.maps.event.removeListener(Ze), Ge(google.maps.event.addListener(x, "mouseover", _)));
  }, [_]), h(() => {
    x && F && (Ie !== null && google.maps.event.removeListener(Ie), et(google.maps.event.addListener(x, "mouseup", F)));
  }, [F]), h(() => {
    x && N && (Ye !== null && google.maps.event.removeListener(Ye), _e(google.maps.event.addListener(x, "rightclick", N)));
  }, [N]), h(() => {
    x && E && (Qe !== null && google.maps.event.removeListener(Qe), at(google.maps.event.addListener(x, "click", E)));
  }, [E]), h(() => {
    x && M && (Pe !== null && google.maps.event.removeListener(Pe), Me(google.maps.event.addListener(x, "drag", M)));
  }, [M]), h(() => {
    x && R && (Je !== null && google.maps.event.removeListener(Je), We(google.maps.event.addListener(x, "clickable_changed", R)));
  }, [R]), h(() => {
    x && W && (Re !== null && google.maps.event.removeListener(Re), nt(google.maps.event.addListener(x, "cursor_changed", W)));
  }, [W]), h(() => {
    x && V && (De !== null && google.maps.event.removeListener(De), yt(google.maps.event.addListener(x, "animation_changed", V)));
  }, [V]), h(() => {
    x && z && (ot !== null && google.maps.event.removeListener(ot), st(google.maps.event.addListener(x, "draggable_changed", z)));
  }, [z]), h(() => {
    x && Z && (ct !== null && google.maps.event.removeListener(ct), bt(google.maps.event.addListener(x, "flat_changed", Z)));
  }, [Z]), h(() => {
    x && K && (pt !== null && google.maps.event.removeListener(pt), dt(google.maps.event.addListener(x, "icon_changed", K)));
  }, [K]), h(() => {
    x && X && (tt !== null && google.maps.event.removeListener(tt), Xe(google.maps.event.addListener(x, "position_changed", X)));
  }, [X]), h(() => {
    x && te && (wt !== null && google.maps.event.removeListener(wt), Ct(google.maps.event.addListener(x, "shape_changed", te)));
  }, [te]), h(() => {
    x && J && (ft !== null && google.maps.event.removeListener(ft), bn(google.maps.event.addListener(x, "title_changed", J)));
  }, [J]), h(() => {
    x && P && (ht !== null && google.maps.event.removeListener(ht), wn(google.maps.event.addListener(x, "visible_changed", P)));
  }, [P]), h(() => {
    x && D && (gt !== null && google.maps.event.removeListener(gt), Mt(google.maps.event.addListener(x, "zindex_changed", D)));
  }, [D]), h(() => {
    var mt = oc(oc(oc({}, n || Bv), r ? Bv : {
      map: $
    }), {}, {
      position: t
    }), re = new google.maps.Marker(mt);
    return r ? r.addMarker(re, !!o) : re.setMap($), t && re.setPosition(t), typeof s < "u" && re.setVisible(s), typeof a < "u" && re.setDraggable(a), typeof u < "u" && re.setClickable(u), typeof c == "string" && re.setCursor(c), p && re.setIcon(p), typeof d < "u" && re.setLabel(d), typeof g < "u" && re.setOpacity(g), f && re.setShape(f), typeof m == "string" && re.setTitle(m), typeof v == "number" && re.setZIndex(v), w && T(google.maps.event.addListener(re, "dblclick", w)), O && A(google.maps.event.addListener(re, "dragend", O)), y && B(google.maps.event.addListener(re, "dragstart", y)), L && fe(google.maps.event.addListener(re, "mousedown", L)), C && Ae(google.maps.event.addListener(re, "mouseout", C)), _ && Ge(google.maps.event.addListener(re, "mouseover", _)), F && et(google.maps.event.addListener(re, "mouseup", F)), N && _e(google.maps.event.addListener(re, "rightclick", N)), E && at(google.maps.event.addListener(re, "click", E)), M && Me(google.maps.event.addListener(re, "drag", M)), R && We(google.maps.event.addListener(re, "clickable_changed", R)), W && nt(google.maps.event.addListener(re, "cursor_changed", W)), V && yt(google.maps.event.addListener(re, "animation_changed", V)), z && st(google.maps.event.addListener(re, "draggable_changed", z)), Z && bt(google.maps.event.addListener(re, "flat_changed", Z)), K && dt(google.maps.event.addListener(re, "icon_changed", K)), X && Xe(google.maps.event.addListener(re, "position_changed", X)), te && Ct(google.maps.event.addListener(re, "shape_changed", te)), J && bn(google.maps.event.addListener(re, "title_changed", J)), P && wn(google.maps.event.addListener(re, "visible_changed", P)), D && Mt(google.maps.event.addListener(re, "zindex_changed", D)), j(re), H && H(re), () => {
      U !== null && google.maps.event.removeListener(U), q !== null && google.maps.event.removeListener(q), Y !== null && google.maps.event.removeListener(Y), ue !== null && google.maps.event.removeListener(ue), oe !== null && google.maps.event.removeListener(oe), Ze !== null && google.maps.event.removeListener(Ze), Ie !== null && google.maps.event.removeListener(Ie), Ye !== null && google.maps.event.removeListener(Ye), Qe !== null && google.maps.event.removeListener(Qe), Je !== null && google.maps.event.removeListener(Je), Re !== null && google.maps.event.removeListener(Re), De !== null && google.maps.event.removeListener(De), ot !== null && google.maps.event.removeListener(ot), ct !== null && google.maps.event.removeListener(ct), pt !== null && google.maps.event.removeListener(pt), tt !== null && google.maps.event.removeListener(tt), ft !== null && google.maps.event.removeListener(ft), ht !== null && google.maps.event.removeListener(ht), gt !== null && google.maps.event.removeListener(gt), S && S(re), r ? r.removeMarker(re, !!o) : re && re.setMap(null);
    };
  }, []);
  var ir = Cn(() => i ? lt.map(i, (mt) => {
    if (!yi(mt))
      return mt;
    var re = mt;
    return bi(re, {
      anchor: x
    });
  }) : null, [i, x]);
  return Mo.jsx(Mo.Fragment, {
    children: ir
  }) || null;
}
ve(U0e);
class H0e extends pe {
  constructor() {
    super(...arguments), xe(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this;
    return tq(function* () {
      var n = oc(oc(oc({}, t.props.options || Bv), t.props.clusterer ? Bv : {
        map: t.context
      }), {}, {
        position: t.props.position
      });
      t.marker = new google.maps.Marker(n), t.props.clusterer ? t.props.clusterer.addMarker(t.marker, !!t.props.noClustererRedraw) : t.marker.setMap(t.context), t.registeredEvents = ln({
        updaterMap: AB,
        eventMap: jB,
        prevProps: {},
        nextProps: t.props,
        instance: t.marker
      }), t.props.onLoad && t.props.onLoad(t.marker);
    })();
  }
  componentDidUpdate(t) {
    this.marker && (hn(this.registeredEvents), this.registeredEvents = ln({
      updaterMap: AB,
      eventMap: jB,
      prevProps: t,
      nextProps: this.props,
      instance: this.marker
    }));
  }
  componentWillUnmount() {
    this.marker && (this.props.onUnmount && this.props.onUnmount(this.marker), hn(this.registeredEvents), this.props.clusterer ? this.props.clusterer.removeMarker(this.marker, !!this.props.noClustererRedraw) : this.marker && this.marker.setMap(null));
  }
  render() {
    var t = this.props.children ? lt.map(this.props.children, (n) => {
      if (!yi(n))
        return n;
      var r = n;
      return bi(r, {
        anchor: this.marker
      });
    }) : null;
    return t || null;
  }
}
xe(H0e, "contextType", jt);
var $0e = (
  /** @class */
  function() {
    function e(t, n) {
      t.getClusterer().extend(e, google.maps.OverlayView), this.cluster = t, this.clusterClassName = this.cluster.getClusterer().getClusterClass(), this.className = this.clusterClassName, this.styles = n, this.center = void 0, this.div = null, this.sums = null, this.visible = !1, this.boundsChangedListener = null, this.url = "", this.height = 0, this.width = 0, this.anchorText = [0, 0], this.anchorIcon = [0, 0], this.textColor = "black", this.textSize = 11, this.textDecoration = "none", this.fontWeight = "bold", this.fontStyle = "normal", this.fontFamily = "Arial,sans-serif", this.backgroundPosition = "0 0", this.cMouseDownInCluster = null, this.cDraggingMapByCluster = null, this.timeOut = null, this.setMap(t.getMap()), this.onBoundsChanged = this.onBoundsChanged.bind(this), this.onMouseDown = this.onMouseDown.bind(this), this.onClick = this.onClick.bind(this), this.onMouseOver = this.onMouseOver.bind(this), this.onMouseOut = this.onMouseOut.bind(this), this.onAdd = this.onAdd.bind(this), this.onRemove = this.onRemove.bind(this), this.draw = this.draw.bind(this), this.hide = this.hide.bind(this), this.show = this.show.bind(this), this.useStyle = this.useStyle.bind(this), this.setCenter = this.setCenter.bind(this), this.getPosFromLatLng = this.getPosFromLatLng.bind(this);
    }
    return e.prototype.onBoundsChanged = function() {
      this.cDraggingMapByCluster = this.cMouseDownInCluster;
    }, e.prototype.onMouseDown = function() {
      this.cMouseDownInCluster = !0, this.cDraggingMapByCluster = !1;
    }, e.prototype.onClick = function(t) {
      if (this.cMouseDownInCluster = !1, !this.cDraggingMapByCluster) {
        var n = this.cluster.getClusterer();
        if (google.maps.event.trigger(n, "click", this.cluster), google.maps.event.trigger(n, "clusterclick", this.cluster), n.getZoomOnClick()) {
          var r = n.getMaxZoom(), o = this.cluster.getBounds(), i = n.getMap();
          i !== null && "fitBounds" in i && i.fitBounds(o), this.timeOut = window.setTimeout(function() {
            var a = n.getMap();
            if (a !== null) {
              "fitBounds" in a && a.fitBounds(o);
              var s = a.getZoom() || 0;
              r !== null && s > r && a.setZoom(r + 1);
            }
          }, 100);
        }
        t.cancelBubble = !0, t.stopPropagation && t.stopPropagation();
      }
    }, e.prototype.onMouseOver = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseover", this.cluster);
    }, e.prototype.onMouseOut = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseout", this.cluster);
    }, e.prototype.onAdd = function() {
      var t;
      this.div = document.createElement("div"), this.div.className = this.className, this.visible && this.show(), (t = this.getPanes()) === null || t === void 0 || t.overlayMouseTarget.appendChild(this.div);
      var n = this.getMap();
      n !== null && (this.boundsChangedListener = google.maps.event.addListener(n, "bounds_changed", this.onBoundsChanged), this.div.addEventListener("mousedown", this.onMouseDown), this.div.addEventListener("click", this.onClick), this.div.addEventListener("mouseover", this.onMouseOver), this.div.addEventListener("mouseout", this.onMouseOut));
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.hide(), this.boundsChangedListener !== null && google.maps.event.removeListener(this.boundsChangedListener), this.div.removeEventListener("mousedown", this.onMouseDown), this.div.removeEventListener("click", this.onClick), this.div.removeEventListener("mouseover", this.onMouseOver), this.div.removeEventListener("mouseout", this.onMouseOut), this.div.parentNode.removeChild(this.div), this.timeOut !== null && (window.clearTimeout(this.timeOut), this.timeOut = null), this.div = null);
    }, e.prototype.draw = function() {
      if (this.visible && this.div !== null && this.center) {
        var t = this.getPosFromLatLng(this.center);
        this.div.style.top = t !== null ? "".concat(t.y, "px") : "0", this.div.style.left = t !== null ? "".concat(t.x, "px") : "0";
      }
    }, e.prototype.hide = function() {
      this.div && (this.div.style.display = "none"), this.visible = !1;
    }, e.prototype.show = function() {
      var t, n, r, o, i, a;
      if (this.div && this.center) {
        var s = this.sums === null || typeof this.sums.title > "u" || this.sums.title === "" ? this.cluster.getClusterer().getTitle() : this.sums.title, l = this.backgroundPosition.split(" "), u = parseInt(((t = l[0]) === null || t === void 0 ? void 0 : t.replace(/^\s+|\s+$/g, "")) || "0", 10), c = parseInt(((n = l[1]) === null || n === void 0 ? void 0 : n.replace(/^\s+|\s+$/g, "")) || "0", 10), p = this.getPosFromLatLng(this.center);
        this.div.className = this.className, this.div.setAttribute("style", "cursor: pointer; position: absolute; top: ".concat(p !== null ? "".concat(p.y, "px") : "0", "; left: ").concat(p !== null ? "".concat(p.x, "px") : "0", "; width: ").concat(this.width, "px; height: ").concat(this.height, "px; "));
        var d = document.createElement("img");
        d.alt = s, d.src = this.url, d.width = this.width, d.height = this.height, d.setAttribute("style", "position: absolute; top: ".concat(c, "px; left: ").concat(u, "px")), this.cluster.getClusterer().enableRetinaIcons || (d.style.clip = "rect(-".concat(c, "px, -").concat(u + this.width, "px, -").concat(c + this.height, ", -").concat(u, ")"));
        var g = document.createElement("div");
        g.setAttribute("style", "position: absolute; top: ".concat(this.anchorText[0], "px; left: ").concat(this.anchorText[1], "px; color: ").concat(this.textColor, "; font-size: ").concat(this.textSize, "px; font-family: ").concat(this.fontFamily, "; font-weight: ").concat(this.fontWeight, "; fontStyle: ").concat(this.fontStyle, "; text-decoration: ").concat(this.textDecoration, "; text-align: center; width: ").concat(this.width, "px; line-height: ").concat(this.height, "px")), !((r = this.sums) === null || r === void 0) && r.text && (g.innerText = "".concat((o = this.sums) === null || o === void 0 ? void 0 : o.text)), !((i = this.sums) === null || i === void 0) && i.html && (g.innerHTML = "".concat((a = this.sums) === null || a === void 0 ? void 0 : a.html)), this.div.innerHTML = "", this.div.appendChild(d), this.div.appendChild(g), this.div.title = s, this.div.style.display = "";
      }
      this.visible = !0;
    }, e.prototype.useStyle = function(t) {
      this.sums = t;
      var n = this.cluster.getClusterer().getStyles(), r = n[Math.min(n.length - 1, Math.max(0, t.index - 1))];
      r && (this.url = r.url, this.height = r.height, this.width = r.width, r.className && (this.className = "".concat(this.clusterClassName, " ").concat(r.className)), this.anchorText = r.anchorText || [0, 0], this.anchorIcon = r.anchorIcon || [this.height / 2, this.width / 2], this.textColor = r.textColor || "black", this.textSize = r.textSize || 11, this.textDecoration = r.textDecoration || "none", this.fontWeight = r.fontWeight || "bold", this.fontStyle = r.fontStyle || "normal", this.fontFamily = r.fontFamily || "Arial,sans-serif", this.backgroundPosition = r.backgroundPosition || "0 0");
    }, e.prototype.setCenter = function(t) {
      this.center = t;
    }, e.prototype.getPosFromLatLng = function(t) {
      var n = this.getProjection().fromLatLngToDivPixel(t);
      return n !== null && (n.x -= this.anchorIcon[1], n.y -= this.anchorIcon[0]), n;
    }, e;
  }()
), W0e = (
  /** @class */
  function() {
    function e(t) {
      this.markerClusterer = t, this.map = this.markerClusterer.getMap(), this.gridSize = this.markerClusterer.getGridSize(), this.minClusterSize = this.markerClusterer.getMinimumClusterSize(), this.averageCenter = this.markerClusterer.getAverageCenter(), this.markers = [], this.center = void 0, this.bounds = null, this.clusterIcon = new $0e(this, this.markerClusterer.getStyles()), this.getSize = this.getSize.bind(this), this.getMarkers = this.getMarkers.bind(this), this.getCenter = this.getCenter.bind(this), this.getMap = this.getMap.bind(this), this.getClusterer = this.getClusterer.bind(this), this.getBounds = this.getBounds.bind(this), this.remove = this.remove.bind(this), this.addMarker = this.addMarker.bind(this), this.isMarkerInClusterBounds = this.isMarkerInClusterBounds.bind(this), this.calculateBounds = this.calculateBounds.bind(this), this.updateIcon = this.updateIcon.bind(this), this.isMarkerAlreadyAdded = this.isMarkerAlreadyAdded.bind(this);
    }
    return e.prototype.getSize = function() {
      return this.markers.length;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getCenter = function() {
      return this.center;
    }, e.prototype.getMap = function() {
      return this.map;
    }, e.prototype.getClusterer = function() {
      return this.markerClusterer;
    }, e.prototype.getBounds = function() {
      for (var t = new google.maps.LatLngBounds(this.center, this.center), n = this.getMarkers(), r = 0, o = n; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && t.extend(a);
      }
      return t;
    }, e.prototype.remove = function() {
      this.clusterIcon.setMap(null), this.markers = [], delete this.markers;
    }, e.prototype.addMarker = function(t) {
      var n;
      if (this.isMarkerAlreadyAdded(t))
        return !1;
      if (this.center) {
        if (this.averageCenter) {
          var r = t.getPosition();
          if (r) {
            var o = this.markers.length + 1;
            this.center = new google.maps.LatLng((this.center.lat() * (o - 1) + r.lat()) / o, (this.center.lng() * (o - 1) + r.lng()) / o), this.calculateBounds();
          }
        }
      } else {
        var r = t.getPosition();
        r && (this.center = r, this.calculateBounds());
      }
      t.isAdded = !0, this.markers.push(t);
      var i = this.markers.length, a = this.markerClusterer.getMaxZoom(), s = (n = this.map) === null || n === void 0 ? void 0 : n.getZoom();
      if (a !== null && typeof s < "u" && s > a)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i < this.minClusterSize)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i === this.minClusterSize)
        for (var l = 0, u = this.markers; l < u.length; l++) {
          var c = u[l];
          c.setMap(null);
        }
      else
        t.setMap(null);
      return !0;
    }, e.prototype.isMarkerInClusterBounds = function(t) {
      if (this.bounds !== null) {
        var n = t.getPosition();
        if (n)
          return this.bounds.contains(n);
      }
      return !1;
    }, e.prototype.calculateBounds = function() {
      this.bounds = this.markerClusterer.getExtendedBounds(new google.maps.LatLngBounds(this.center, this.center));
    }, e.prototype.updateIcon = function() {
      var t, n = this.markers.length, r = this.markerClusterer.getMaxZoom(), o = (t = this.map) === null || t === void 0 ? void 0 : t.getZoom();
      if (r !== null && typeof o < "u" && o > r) {
        this.clusterIcon.hide();
        return;
      }
      if (n < this.minClusterSize) {
        this.clusterIcon.hide();
        return;
      }
      this.center && this.clusterIcon.setCenter(this.center), this.clusterIcon.useStyle(this.markerClusterer.getCalculator()(this.markers, this.markerClusterer.getStyles().length)), this.clusterIcon.show();
    }, e.prototype.isMarkerAlreadyAdded = function(t) {
      if (this.markers.includes)
        return this.markers.includes(t);
      for (var n = 0; n < this.markers.length; n++)
        if (t === this.markers[n])
          return !0;
      return !1;
    }, e;
  }()
);
function V0e(e, t) {
  var n = e.length, r = n.toString().length, o = Math.min(r, t);
  return {
    text: n.toString(),
    index: o,
    title: ""
  };
}
var Z0e = 2e3, q0e = 500, G0e = "https://developers.google.com/maps/documentation/javascript/examples/markerclusterer/m", K0e = "png", Y0e = [53, 56, 66, 78, 90], X0e = "cluster", sq = (
  /** @class */
  function() {
    function e(t, n, r) {
      n === void 0 && (n = []), r === void 0 && (r = {}), this.getMinimumClusterSize = this.getMinimumClusterSize.bind(this), this.setMinimumClusterSize = this.setMinimumClusterSize.bind(this), this.getEnableRetinaIcons = this.getEnableRetinaIcons.bind(this), this.setEnableRetinaIcons = this.setEnableRetinaIcons.bind(this), this.addToClosestCluster = this.addToClosestCluster.bind(this), this.getImageExtension = this.getImageExtension.bind(this), this.setImageExtension = this.setImageExtension.bind(this), this.getExtendedBounds = this.getExtendedBounds.bind(this), this.getAverageCenter = this.getAverageCenter.bind(this), this.setAverageCenter = this.setAverageCenter.bind(this), this.getTotalClusters = this.getTotalClusters.bind(this), this.fitMapToMarkers = this.fitMapToMarkers.bind(this), this.getIgnoreHidden = this.getIgnoreHidden.bind(this), this.setIgnoreHidden = this.setIgnoreHidden.bind(this), this.getClusterClass = this.getClusterClass.bind(this), this.setClusterClass = this.setClusterClass.bind(this), this.getTotalMarkers = this.getTotalMarkers.bind(this), this.getZoomOnClick = this.getZoomOnClick.bind(this), this.setZoomOnClick = this.setZoomOnClick.bind(this), this.getBatchSizeIE = this.getBatchSizeIE.bind(this), this.setBatchSizeIE = this.setBatchSizeIE.bind(this), this.createClusters = this.createClusters.bind(this), this.onZoomChanged = this.onZoomChanged.bind(this), this.getImageSizes = this.getImageSizes.bind(this), this.setImageSizes = this.setImageSizes.bind(this), this.getCalculator = this.getCalculator.bind(this), this.setCalculator = this.setCalculator.bind(this), this.removeMarkers = this.removeMarkers.bind(this), this.resetViewport = this.resetViewport.bind(this), this.getImagePath = this.getImagePath.bind(this), this.setImagePath = this.setImagePath.bind(this), this.pushMarkerTo = this.pushMarkerTo.bind(this), this.removeMarker = this.removeMarker.bind(this), this.clearMarkers = this.clearMarkers.bind(this), this.setupStyles = this.setupStyles.bind(this), this.getGridSize = this.getGridSize.bind(this), this.setGridSize = this.setGridSize.bind(this), this.getClusters = this.getClusters.bind(this), this.getMaxZoom = this.getMaxZoom.bind(this), this.setMaxZoom = this.setMaxZoom.bind(this), this.getMarkers = this.getMarkers.bind(this), this.addMarkers = this.addMarkers.bind(this), this.getStyles = this.getStyles.bind(this), this.setStyles = this.setStyles.bind(this), this.addMarker = this.addMarker.bind(this), this.onRemove = this.onRemove.bind(this), this.getTitle = this.getTitle.bind(this), this.setTitle = this.setTitle.bind(this), this.repaint = this.repaint.bind(this), this.onIdle = this.onIdle.bind(this), this.redraw = this.redraw.bind(this), this.onAdd = this.onAdd.bind(this), this.draw = this.draw.bind(this), this.extend = this.extend.bind(this), this.extend(e, google.maps.OverlayView), this.markers = [], this.clusters = [], this.listeners = [], this.activeMap = null, this.ready = !1, this.gridSize = r.gridSize || 60, this.minClusterSize = r.minimumClusterSize || 2, this.maxZoom = r.maxZoom || null, this.styles = r.styles || [], this.title = r.title || "", this.zoomOnClick = !0, r.zoomOnClick !== void 0 && (this.zoomOnClick = r.zoomOnClick), this.averageCenter = !1, r.averageCenter !== void 0 && (this.averageCenter = r.averageCenter), this.ignoreHidden = !1, r.ignoreHidden !== void 0 && (this.ignoreHidden = r.ignoreHidden), this.enableRetinaIcons = !1, r.enableRetinaIcons !== void 0 && (this.enableRetinaIcons = r.enableRetinaIcons), this.imagePath = r.imagePath || G0e, this.imageExtension = r.imageExtension || K0e, this.imageSizes = r.imageSizes || Y0e, this.calculator = r.calculator || V0e, this.batchSize = r.batchSize || Z0e, this.batchSizeIE = r.batchSizeIE || q0e, this.clusterClass = r.clusterClass || X0e, navigator.userAgent.toLowerCase().indexOf("msie") !== -1 && (this.batchSize = this.batchSizeIE), this.timerRefStatic = null, this.setupStyles(), this.addMarkers(n, !0), this.setMap(t);
    }
    return e.prototype.onZoomChanged = function() {
      var t, n;
      this.resetViewport(!1), (((t = this.getMap()) === null || t === void 0 ? void 0 : t.getZoom()) === (this.get("minZoom") || 0) || ((n = this.getMap()) === null || n === void 0 ? void 0 : n.getZoom()) === this.get("maxZoom")) && google.maps.event.trigger(this, "idle");
    }, e.prototype.onIdle = function() {
      this.redraw();
    }, e.prototype.onAdd = function() {
      var t = this.getMap();
      this.activeMap = t, this.ready = !0, this.repaint(), t !== null && (this.listeners = [google.maps.event.addListener(t, "zoom_changed", this.onZoomChanged), google.maps.event.addListener(t, "idle", this.onIdle)]);
    }, e.prototype.onRemove = function() {
      for (var t = 0, n = this.markers; t < n.length; t++) {
        var r = n[t];
        r.getMap() !== this.activeMap && r.setMap(this.activeMap);
      }
      for (var o = 0, i = this.clusters; o < i.length; o++) {
        var a = i[o];
        a.remove();
      }
      this.clusters = [];
      for (var s = 0, l = this.listeners; s < l.length; s++) {
        var u = l[s];
        google.maps.event.removeListener(u);
      }
      this.listeners = [], this.activeMap = null, this.ready = !1;
    }, e.prototype.draw = function() {
    }, e.prototype.getMap = function() {
      return null;
    }, e.prototype.getPanes = function() {
      return null;
    }, e.prototype.getProjection = function() {
      return {
        fromContainerPixelToLatLng: function() {
          return null;
        },
        fromDivPixelToLatLng: function() {
          return null;
        },
        fromLatLngToContainerPixel: function() {
          return null;
        },
        fromLatLngToDivPixel: function() {
          return null;
        },
        getVisibleRegion: function() {
          return null;
        },
        getWorldWidth: function() {
          return 0;
        }
      };
    }, e.prototype.setMap = function() {
    }, e.prototype.addListener = function() {
      return {
        remove: function() {
        }
      };
    }, e.prototype.bindTo = function() {
    }, e.prototype.get = function() {
    }, e.prototype.notify = function() {
    }, e.prototype.set = function() {
    }, e.prototype.setValues = function() {
    }, e.prototype.unbind = function() {
    }, e.prototype.unbindAll = function() {
    }, e.prototype.setupStyles = function() {
      if (!(this.styles.length > 0))
        for (var t = 0; t < this.imageSizes.length; t++)
          this.styles.push({
            url: "".concat(this.imagePath + (t + 1), ".").concat(this.imageExtension),
            height: this.imageSizes[t] || 0,
            width: this.imageSizes[t] || 0
          });
    }, e.prototype.fitMapToMarkers = function() {
      for (var t = this.getMarkers(), n = new google.maps.LatLngBounds(), r = 0, o = t; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && n.extend(a);
      }
      var s = this.getMap();
      s !== null && "fitBounds" in s && s.fitBounds(n);
    }, e.prototype.getGridSize = function() {
      return this.gridSize;
    }, e.prototype.setGridSize = function(t) {
      this.gridSize = t;
    }, e.prototype.getMinimumClusterSize = function() {
      return this.minClusterSize;
    }, e.prototype.setMinimumClusterSize = function(t) {
      this.minClusterSize = t;
    }, e.prototype.getMaxZoom = function() {
      return this.maxZoom;
    }, e.prototype.setMaxZoom = function(t) {
      this.maxZoom = t;
    }, e.prototype.getStyles = function() {
      return this.styles;
    }, e.prototype.setStyles = function(t) {
      this.styles = t;
    }, e.prototype.getTitle = function() {
      return this.title;
    }, e.prototype.setTitle = function(t) {
      this.title = t;
    }, e.prototype.getZoomOnClick = function() {
      return this.zoomOnClick;
    }, e.prototype.setZoomOnClick = function(t) {
      this.zoomOnClick = t;
    }, e.prototype.getAverageCenter = function() {
      return this.averageCenter;
    }, e.prototype.setAverageCenter = function(t) {
      this.averageCenter = t;
    }, e.prototype.getIgnoreHidden = function() {
      return this.ignoreHidden;
    }, e.prototype.setIgnoreHidden = function(t) {
      this.ignoreHidden = t;
    }, e.prototype.getEnableRetinaIcons = function() {
      return this.enableRetinaIcons;
    }, e.prototype.setEnableRetinaIcons = function(t) {
      this.enableRetinaIcons = t;
    }, e.prototype.getImageExtension = function() {
      return this.imageExtension;
    }, e.prototype.setImageExtension = function(t) {
      this.imageExtension = t;
    }, e.prototype.getImagePath = function() {
      return this.imagePath;
    }, e.prototype.setImagePath = function(t) {
      this.imagePath = t;
    }, e.prototype.getImageSizes = function() {
      return this.imageSizes;
    }, e.prototype.setImageSizes = function(t) {
      this.imageSizes = t;
    }, e.prototype.getCalculator = function() {
      return this.calculator;
    }, e.prototype.setCalculator = function(t) {
      this.calculator = t;
    }, e.prototype.getBatchSizeIE = function() {
      return this.batchSizeIE;
    }, e.prototype.setBatchSizeIE = function(t) {
      this.batchSizeIE = t;
    }, e.prototype.getClusterClass = function() {
      return this.clusterClass;
    }, e.prototype.setClusterClass = function(t) {
      this.clusterClass = t;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getTotalMarkers = function() {
      return this.markers.length;
    }, e.prototype.getClusters = function() {
      return this.clusters;
    }, e.prototype.getTotalClusters = function() {
      return this.clusters.length;
    }, e.prototype.addMarker = function(t, n) {
      this.pushMarkerTo(t), n || this.redraw();
    }, e.prototype.addMarkers = function(t, n) {
      for (var r in t)
        if (Object.prototype.hasOwnProperty.call(t, r)) {
          var o = t[r];
          o && this.pushMarkerTo(o);
        }
      n || this.redraw();
    }, e.prototype.pushMarkerTo = function(t) {
      var n = this;
      t.getDraggable() && google.maps.event.addListener(t, "dragend", function() {
        n.ready && (t.isAdded = !1, n.repaint());
      }), t.isAdded = !1, this.markers.push(t);
    }, e.prototype.removeMarker_ = function(t) {
      var n = -1;
      if (this.markers.indexOf)
        n = this.markers.indexOf(t);
      else
        for (var r = 0; r < this.markers.length; r++)
          if (t === this.markers[r]) {
            n = r;
            break;
          }
      return n === -1 ? !1 : (t.setMap(null), this.markers.splice(n, 1), !0);
    }, e.prototype.removeMarker = function(t, n) {
      var r = this.removeMarker_(t);
      return !n && r && this.repaint(), r;
    }, e.prototype.removeMarkers = function(t, n) {
      for (var r = !1, o = 0, i = t; o < i.length; o++) {
        var a = i[o];
        r = r || this.removeMarker_(a);
      }
      return !n && r && this.repaint(), r;
    }, e.prototype.clearMarkers = function() {
      this.resetViewport(!0), this.markers = [];
    }, e.prototype.repaint = function() {
      var t = this.clusters.slice();
      this.clusters = [], this.resetViewport(!1), this.redraw(), setTimeout(function() {
        for (var n = 0, r = t; n < r.length; n++) {
          var o = r[n];
          o.remove();
        }
      }, 0);
    }, e.prototype.getExtendedBounds = function(t) {
      var n = this.getProjection(), r = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getNorthEast().lat(), t.getNorthEast().lng())
      );
      r !== null && (r.x += this.gridSize, r.y -= this.gridSize);
      var o = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getSouthWest().lat(), t.getSouthWest().lng())
      );
      if (o !== null && (o.x -= this.gridSize, o.y += this.gridSize), r !== null) {
        var i = n.fromDivPixelToLatLng(r);
        i !== null && t.extend(i);
      }
      if (o !== null) {
        var a = n.fromDivPixelToLatLng(o);
        a !== null && t.extend(a);
      }
      return t;
    }, e.prototype.redraw = function() {
      this.createClusters(0);
    }, e.prototype.resetViewport = function(t) {
      for (var n = 0, r = this.clusters; n < r.length; n++) {
        var o = r[n];
        o.remove();
      }
      this.clusters = [];
      for (var i = 0, a = this.markers; i < a.length; i++) {
        var s = a[i];
        s.isAdded = !1, t && s.setMap(null);
      }
    }, e.prototype.distanceBetweenPoints = function(t, n) {
      var r = 6371, o = (n.lat() - t.lat()) * Math.PI / 180, i = (n.lng() - t.lng()) * Math.PI / 180, a = Math.sin(o / 2) * Math.sin(o / 2) + Math.cos(t.lat() * Math.PI / 180) * Math.cos(n.lat() * Math.PI / 180) * Math.sin(i / 2) * Math.sin(i / 2);
      return r * (2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)));
    }, e.prototype.isMarkerInBounds = function(t, n) {
      var r = t.getPosition();
      return r ? n.contains(r) : !1;
    }, e.prototype.addToClosestCluster = function(t) {
      for (var n, r = 4e4, o = null, i = 0, a = this.clusters; i < a.length; i++) {
        var s = a[i];
        n = s;
        var l = n.getCenter(), u = t.getPosition();
        if (l && u) {
          var c = this.distanceBetweenPoints(l, u);
          c < r && (r = c, o = n);
        }
      }
      o && o.isMarkerInClusterBounds(t) ? o.addMarker(t) : (n = new W0e(this), n.addMarker(t), this.clusters.push(n));
    }, e.prototype.createClusters = function(t) {
      var n = this;
      if (this.ready) {
        t === 0 && (google.maps.event.trigger(this, "clusteringbegin", this), this.timerRefStatic !== null && (window.clearTimeout(this.timerRefStatic), delete this.timerRefStatic));
        for (var r = this.getMap(), o = r !== null && ("getBounds" in r) ? r.getBounds() : null, i = (r == null ? void 0 : r.getZoom()) || 0, a = i > 3 ? new google.maps.LatLngBounds(o == null ? void 0 : o.getSouthWest(), o == null ? void 0 : o.getNorthEast()) : new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625)), s = this.getExtendedBounds(a), l = Math.min(t + this.batchSize, this.markers.length), u = t; u < l; u++) {
          var c = this.markers[u];
          c && !c.isAdded && this.isMarkerInBounds(c, s) && (!this.ignoreHidden || this.ignoreHidden && c.getVisible()) && this.addToClosestCluster(c);
        }
        if (l < this.markers.length)
          this.timerRefStatic = window.setTimeout(function() {
            n.createClusters(l);
          }, 0);
        else {
          this.timerRefStatic = null, google.maps.event.trigger(this, "clusteringend", this);
          for (var p = 0, d = this.clusters; p < d.length; p++) {
            var g = d[p];
            g.updateIcon();
          }
        }
      }
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype) {
          var i = o;
          this.prototype[i] = r.prototype[i];
        }
        return this;
      }).apply(t, [n]);
    }, e;
  }()
);
function IB(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function J0e(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? IB(Object(n), !0).forEach(function(r) {
      xe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : IB(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var ts = {
  onClick: "click",
  onClusteringBegin: "clusteringbegin",
  onClusteringEnd: "clusteringend",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover"
}, On = {
  averageCenter(e, t) {
    e.setAverageCenter(t);
  },
  batchSizeIE(e, t) {
    e.setBatchSizeIE(t);
  },
  calculator(e, t) {
    e.setCalculator(t);
  },
  clusterClass(e, t) {
    e.setClusterClass(t);
  },
  enableRetinaIcons(e, t) {
    e.setEnableRetinaIcons(t);
  },
  gridSize(e, t) {
    e.setGridSize(t);
  },
  ignoreHidden(e, t) {
    e.setIgnoreHidden(t);
  },
  imageExtension(e, t) {
    e.setImageExtension(t);
  },
  imagePath(e, t) {
    e.setImagePath(t);
  },
  imageSizes(e, t) {
    e.setImageSizes(t);
  },
  maxZoom(e, t) {
    e.setMaxZoom(t);
  },
  minimumClusterSize(e, t) {
    e.setMinimumClusterSize(t);
  },
  styles(e, t) {
    e.setStyles(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  zoomOnClick(e, t) {
    e.setZoomOnClick(t);
  }
}, Q0e = {};
function eCe(e) {
  var {
    children: t,
    options: n,
    averageCenter: r,
    batchSizeIE: o,
    calculator: i,
    clusterClass: a,
    enableRetinaIcons: s,
    gridSize: l,
    ignoreHidden: u,
    imageExtension: c,
    imagePath: p,
    imageSizes: d,
    maxZoom: g,
    minimumClusterSize: f,
    styles: m,
    title: v,
    zoomOnClick: E,
    onClick: w,
    onClusteringBegin: M,
    onClusteringEnd: O,
    onMouseOver: y,
    onMouseOut: C,
    onLoad: _,
    onUnmount: F
  } = e, [L, N] = k(null), R = ge(jt), [W, V] = k(null), [z, Z] = k(null), [K, X] = k(null), [te, J] = k(null), [P, D] = k(null);
  return h(() => {
    L && C && (te !== null && google.maps.event.removeListener(te), J(google.maps.event.addListener(L, ts.onMouseOut, C)));
  }, [C]), h(() => {
    L && y && (P !== null && google.maps.event.removeListener(P), D(google.maps.event.addListener(L, ts.onMouseOver, y)));
  }, [y]), h(() => {
    L && w && (W !== null && google.maps.event.removeListener(W), V(google.maps.event.addListener(L, ts.onClick, w)));
  }, [w]), h(() => {
    L && M && (z !== null && google.maps.event.removeListener(z), Z(google.maps.event.addListener(L, ts.onClusteringBegin, M)));
  }, [M]), h(() => {
    L && O && (K !== null && google.maps.event.removeListener(K), Z(google.maps.event.addListener(L, ts.onClusteringEnd, O)));
  }, [O]), h(() => {
    typeof r < "u" && L !== null && On.averageCenter(L, r);
  }, [L, r]), h(() => {
    typeof o < "u" && L !== null && On.batchSizeIE(L, o);
  }, [L, o]), h(() => {
    typeof i < "u" && L !== null && On.calculator(L, i);
  }, [L, i]), h(() => {
    typeof a < "u" && L !== null && On.clusterClass(L, a);
  }, [L, a]), h(() => {
    typeof s < "u" && L !== null && On.enableRetinaIcons(L, s);
  }, [L, s]), h(() => {
    typeof l < "u" && L !== null && On.gridSize(L, l);
  }, [L, l]), h(() => {
    typeof u < "u" && L !== null && On.ignoreHidden(L, u);
  }, [L, u]), h(() => {
    typeof c < "u" && L !== null && On.imageExtension(L, c);
  }, [L, c]), h(() => {
    typeof p < "u" && L !== null && On.imagePath(L, p);
  }, [L, p]), h(() => {
    typeof d < "u" && L !== null && On.imageSizes(L, d);
  }, [L, d]), h(() => {
    typeof g < "u" && L !== null && On.maxZoom(L, g);
  }, [L, g]), h(() => {
    typeof f < "u" && L !== null && On.minimumClusterSize(L, f);
  }, [L, f]), h(() => {
    typeof m < "u" && L !== null && On.styles(L, m);
  }, [L, m]), h(() => {
    typeof v < "u" && L !== null && On.title(L, v);
  }, [L, v]), h(() => {
    typeof E < "u" && L !== null && On.zoomOnClick(L, E);
  }, [L, E]), h(() => {
    if (R) {
      var H = J0e({}, n || Q0e), S = new sq(R, [], H);
      return r && On.averageCenter(S, r), o && On.batchSizeIE(S, o), i && On.calculator(S, i), a && On.clusterClass(S, a), s && On.enableRetinaIcons(S, s), l && On.gridSize(S, l), u && On.ignoreHidden(S, u), c && On.imageExtension(S, c), p && On.imagePath(S, p), d && On.imageSizes(S, d), g && On.maxZoom(S, g), f && On.minimumClusterSize(S, f), m && On.styles(S, m), v && On.title(S, v), E && On.zoomOnClick(S, E), C && J(google.maps.event.addListener(S, ts.onMouseOut, C)), y && D(google.maps.event.addListener(S, ts.onMouseOver, y)), w && V(google.maps.event.addListener(S, ts.onClick, w)), M && Z(google.maps.event.addListener(S, ts.onClusteringBegin, M)), O && X(google.maps.event.addListener(S, ts.onClusteringEnd, O)), N(S), _ && _(S), () => {
        te !== null && google.maps.event.removeListener(te), P !== null && google.maps.event.removeListener(P), W !== null && google.maps.event.removeListener(W), z !== null && google.maps.event.removeListener(z), K !== null && google.maps.event.removeListener(K), F && F(S);
      };
    }
  }, []), L !== null && t(L) || null;
}
ve(eCe);
class tCe extends pe {
  constructor() {
    super(...arguments), xe(this, "registeredEvents", []), xe(this, "state", {
      markerClusterer: null
    }), xe(this, "setClustererCallback", () => {
      this.state.markerClusterer !== null && this.props.onLoad && this.props.onLoad(this.state.markerClusterer);
    });
  }
  componentDidMount() {
    if (this.context) {
      var t = new sq(this.context, [], this.props.options);
      this.registeredEvents = ln({
        updaterMap: On,
        eventMap: ts,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        markerClusterer: t
      }), this.setClustererCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.markerClusterer && (hn(this.registeredEvents), this.registeredEvents = ln({
      updaterMap: On,
      eventMap: ts,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.markerClusterer
    }));
  }
  componentWillUnmount() {
    this.state.markerClusterer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.markerClusterer), hn(this.registeredEvents), this.state.markerClusterer.setMap(null));
  }
  render() {
    return this.state.markerClusterer !== null ? this.props.children(this.state.markerClusterer) : null;
  }
}
xe(tCe, "contextType", jt);
function RB(e) {
  e.cancelBubble = !0, e.stopPropagation && e.stopPropagation();
}
var aq = (
  /** @class */
  function() {
    function e(t) {
      t === void 0 && (t = {}), this.getCloseClickHandler = this.getCloseClickHandler.bind(this), this.closeClickHandler = this.closeClickHandler.bind(this), this.createInfoBoxDiv = this.createInfoBoxDiv.bind(this), this.addClickHandler = this.addClickHandler.bind(this), this.getCloseBoxImg = this.getCloseBoxImg.bind(this), this.getBoxWidths = this.getBoxWidths.bind(this), this.setBoxStyle = this.setBoxStyle.bind(this), this.setPosition = this.setPosition.bind(this), this.getPosition = this.getPosition.bind(this), this.setOptions = this.setOptions.bind(this), this.setContent = this.setContent.bind(this), this.setVisible = this.setVisible.bind(this), this.getContent = this.getContent.bind(this), this.getVisible = this.getVisible.bind(this), this.setZIndex = this.setZIndex.bind(this), this.getZIndex = this.getZIndex.bind(this), this.onRemove = this.onRemove.bind(this), this.panBox = this.panBox.bind(this), this.extend = this.extend.bind(this), this.close = this.close.bind(this), this.draw = this.draw.bind(this), this.show = this.show.bind(this), this.hide = this.hide.bind(this), this.open = this.open.bind(this), this.extend(e, google.maps.OverlayView), this.content = t.content || "", this.disableAutoPan = t.disableAutoPan || !1, this.maxWidth = t.maxWidth || 0, this.pixelOffset = t.pixelOffset || new google.maps.Size(0, 0), this.position = t.position || new google.maps.LatLng(0, 0), this.zIndex = t.zIndex || null, this.boxClass = t.boxClass || "infoBox", this.boxStyle = t.boxStyle || {}, this.closeBoxMargin = t.closeBoxMargin || "2px", this.closeBoxURL = t.closeBoxURL || "http://www.google.com/intl/en_us/mapfiles/close.gif", t.closeBoxURL === "" && (this.closeBoxURL = ""), this.infoBoxClearance = t.infoBoxClearance || new google.maps.Size(1, 1), typeof t.visible > "u" && (typeof t.isHidden > "u" ? t.visible = !0 : t.visible = !t.isHidden), this.isHidden = !t.visible, this.alignBottom = t.alignBottom || !1, this.pane = t.pane || "floatPane", this.enableEventPropagation = t.enableEventPropagation || !1, this.div = null, this.closeListener = null, this.moveListener = null, this.mapListener = null, this.contextListener = null, this.eventListeners = null, this.fixedWidthSet = null;
    }
    return e.prototype.createInfoBoxDiv = function() {
      var t = this, n = function(u) {
        u.returnValue = !1, u.preventDefault && u.preventDefault(), t.enableEventPropagation || RB(u);
      };
      if (!this.div) {
        this.div = document.createElement("div"), this.setBoxStyle(), typeof this.content == "string" ? this.div.innerHTML = this.getCloseBoxImg() + this.content : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(this.content));
        var r = this.getPanes();
        if (r !== null && r[this.pane].appendChild(this.div), this.addClickHandler(), this.div.style.width)
          this.fixedWidthSet = !0;
        else if (this.maxWidth !== 0 && this.div.offsetWidth > this.maxWidth)
          this.div.style.width = this.maxWidth + "px", this.fixedWidthSet = !0;
        else {
          var o = this.getBoxWidths();
          this.div.style.width = this.div.offsetWidth - o.left - o.right + "px", this.fixedWidthSet = !1;
        }
        if (this.panBox(this.disableAutoPan), !this.enableEventPropagation) {
          this.eventListeners = [];
          for (var i = ["mousedown", "mouseover", "mouseout", "mouseup", "click", "dblclick", "touchstart", "touchend", "touchmove"], a = 0, s = i; a < s.length; a++) {
            var l = s[a];
            this.eventListeners.push(google.maps.event.addListener(this.div, l, RB));
          }
          this.eventListeners.push(google.maps.event.addListener(this.div, "mouseover", function() {
            t.div && (t.div.style.cursor = "default");
          }));
        }
        this.contextListener = google.maps.event.addListener(this.div, "contextmenu", n), google.maps.event.trigger(this, "domready");
      }
    }, e.prototype.getCloseBoxImg = function() {
      var t = "";
      return this.closeBoxURL !== "" && (t = '<img alt=""', t += ' aria-hidden="true"', t += " src='" + this.closeBoxURL + "'", t += " align=right", t += " style='", t += " position: relative;", t += " cursor: pointer;", t += " margin: " + this.closeBoxMargin + ";", t += "'>"), t;
    }, e.prototype.addClickHandler = function() {
      this.closeListener = this.div && this.div.firstChild && this.closeBoxURL !== "" ? google.maps.event.addListener(this.div.firstChild, "click", this.getCloseClickHandler()) : null;
    }, e.prototype.closeClickHandler = function(t) {
      t.cancelBubble = !0, t.stopPropagation && t.stopPropagation(), google.maps.event.trigger(this, "closeclick"), this.close();
    }, e.prototype.getCloseClickHandler = function() {
      return this.closeClickHandler;
    }, e.prototype.panBox = function(t) {
      if (this.div && !t) {
        var n = this.getMap();
        if (n instanceof google.maps.Map) {
          var r = 0, o = 0, i = n.getBounds();
          i && !i.contains(this.position) && n.setCenter(this.position);
          var a = n.getDiv(), s = a.offsetWidth, l = a.offsetHeight, u = this.pixelOffset.width, c = this.pixelOffset.height, p = this.div.offsetWidth, d = this.div.offsetHeight, g = this.infoBoxClearance.width, f = this.infoBoxClearance.height, m = this.getProjection(), v = m.fromLatLngToContainerPixel(this.position);
          v !== null && (v.x < -u + g ? r = v.x + u - g : v.x + p + u + g > s && (r = v.x + p + u + g - s), this.alignBottom ? v.y < -c + f + d ? o = v.y + c - f - d : v.y + c + f > l && (o = v.y + c + f - l) : v.y < -c + f ? o = v.y + c - f : v.y + d + c + f > l && (o = v.y + d + c + f - l)), r === 0 && o === 0 || n.panBy(r, o);
        }
      }
    }, e.prototype.setBoxStyle = function() {
      if (this.div) {
        this.div.className = this.boxClass, this.div.style.cssText = "";
        var t = this.boxStyle;
        for (var n in t)
          Object.prototype.hasOwnProperty.call(t, n) && (this.div.style[n] = t[n]);
        if (this.div.style.webkitTransform = "translateZ(0)", typeof this.div.style.opacity < "u" && this.div.style.opacity !== "") {
          var r = parseFloat(this.div.style.opacity || "");
          this.div.style.msFilter = '"progid:DXImageTransform.Microsoft.Alpha(Opacity=' + r * 100 + ')"', this.div.style.filter = "alpha(opacity=" + r * 100 + ")";
        }
        this.div.style.position = "absolute", this.div.style.visibility = "hidden", this.zIndex !== null && (this.div.style.zIndex = this.zIndex + ""), this.div.style.overflow || (this.div.style.overflow = "auto");
      }
    }, e.prototype.getBoxWidths = function() {
      var t = {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0
      };
      if (!this.div)
        return t;
      if (document.defaultView) {
        var n = this.div.ownerDocument, r = n && n.defaultView ? n.defaultView.getComputedStyle(this.div, "") : null;
        r && (t.top = parseInt(r.borderTopWidth || "", 10) || 0, t.bottom = parseInt(r.borderBottomWidth || "", 10) || 0, t.left = parseInt(r.borderLeftWidth || "", 10) || 0, t.right = parseInt(r.borderRightWidth || "", 10) || 0);
      } else if (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        document.documentElement.currentStyle
      ) {
        var o = this.div.currentStyle;
        o && (t.top = parseInt(o.borderTopWidth || "", 10) || 0, t.bottom = parseInt(o.borderBottomWidth || "", 10) || 0, t.left = parseInt(o.borderLeftWidth || "", 10) || 0, t.right = parseInt(o.borderRightWidth || "", 10) || 0);
      }
      return t;
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.div.parentNode.removeChild(this.div), this.div = null);
    }, e.prototype.draw = function() {
      if (this.createInfoBoxDiv(), this.div) {
        var t = this.getProjection(), n = t.fromLatLngToDivPixel(this.position);
        n !== null && (this.div.style.left = n.x + this.pixelOffset.width + "px", this.alignBottom ? this.div.style.bottom = -(n.y + this.pixelOffset.height) + "px" : this.div.style.top = n.y + this.pixelOffset.height + "px"), this.isHidden ? this.div.style.visibility = "hidden" : this.div.style.visibility = "visible";
      }
    }, e.prototype.setOptions = function(t) {
      t === void 0 && (t = {}), typeof t.boxClass < "u" && (this.boxClass = t.boxClass, this.setBoxStyle()), typeof t.boxStyle < "u" && (this.boxStyle = t.boxStyle, this.setBoxStyle()), typeof t.content < "u" && this.setContent(t.content), typeof t.disableAutoPan < "u" && (this.disableAutoPan = t.disableAutoPan), typeof t.maxWidth < "u" && (this.maxWidth = t.maxWidth), typeof t.pixelOffset < "u" && (this.pixelOffset = t.pixelOffset), typeof t.alignBottom < "u" && (this.alignBottom = t.alignBottom), typeof t.position < "u" && this.setPosition(t.position), typeof t.zIndex < "u" && this.setZIndex(t.zIndex), typeof t.closeBoxMargin < "u" && (this.closeBoxMargin = t.closeBoxMargin), typeof t.closeBoxURL < "u" && (this.closeBoxURL = t.closeBoxURL), typeof t.infoBoxClearance < "u" && (this.infoBoxClearance = t.infoBoxClearance), typeof t.isHidden < "u" && (this.isHidden = t.isHidden), typeof t.visible < "u" && (this.isHidden = !t.visible), typeof t.enableEventPropagation < "u" && (this.enableEventPropagation = t.enableEventPropagation), this.div && this.draw();
    }, e.prototype.setContent = function(t) {
      this.content = t, this.div && (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.fixedWidthSet || (this.div.style.width = ""), typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t)), this.fixedWidthSet || (this.div.style.width = this.div.offsetWidth + "px", typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t))), this.addClickHandler()), google.maps.event.trigger(this, "content_changed");
    }, e.prototype.setPosition = function(t) {
      this.position = t, this.div && this.draw(), google.maps.event.trigger(this, "position_changed");
    }, e.prototype.setVisible = function(t) {
      this.isHidden = !t, this.div && (this.div.style.visibility = this.isHidden ? "hidden" : "visible");
    }, e.prototype.setZIndex = function(t) {
      this.zIndex = t, this.div && (this.div.style.zIndex = t + ""), google.maps.event.trigger(this, "zindex_changed");
    }, e.prototype.getContent = function() {
      return this.content;
    }, e.prototype.getPosition = function() {
      return this.position;
    }, e.prototype.getZIndex = function() {
      return this.zIndex;
    }, e.prototype.getVisible = function() {
      var t = this.getMap();
      return typeof t > "u" || t === null ? !1 : !this.isHidden;
    }, e.prototype.show = function() {
      this.isHidden = !1, this.div && (this.div.style.visibility = "visible");
    }, e.prototype.hide = function() {
      this.isHidden = !0, this.div && (this.div.style.visibility = "hidden");
    }, e.prototype.open = function(t, n) {
      var r = this;
      n && (this.position = n.getPosition(), this.moveListener = google.maps.event.addListener(n, "position_changed", function() {
        var o = n.getPosition();
        r.setPosition(o);
      }), this.mapListener = google.maps.event.addListener(n, "map_changed", function() {
        r.setMap(n.map);
      })), this.setMap(t), this.div && this.panBox();
    }, e.prototype.close = function() {
      if (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.eventListeners) {
        for (var t = 0, n = this.eventListeners; t < n.length; t++) {
          var r = n[t];
          google.maps.event.removeListener(r);
        }
        this.eventListeners = null;
      }
      this.moveListener && (google.maps.event.removeListener(this.moveListener), this.moveListener = null), this.mapListener && (google.maps.event.removeListener(this.mapListener), this.mapListener = null), this.contextListener && (google.maps.event.removeListener(this.contextListener), this.contextListener = null), this.setMap(null);
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype)
          Object.prototype.hasOwnProperty.call(this, o) || (this.prototype[o] = r.prototype[o]);
        return this;
      }).apply(t, [n]);
    }, e;
  }()
), nCe = ["position"], rCe = ["position"];
function BB(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Nv(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? BB(Object(n), !0).forEach(function(r) {
      xe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : BB(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var NB = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, FB = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    t instanceof google.maps.LatLng ? e.setPosition(t) : e.setPosition(new google.maps.LatLng(t.lat, t.lng));
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, oCe = {};
function iCe(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, g = ge(jt), [f, m] = k(null), [v, E] = k(null), [w, M] = k(null), [O, y] = k(null), [C, _] = k(null), [F, L] = k(null), N = ut(null);
  return h(() => {
    g && f !== null && (f.close(), n ? f.open(g, n) : f.getPosition() && f.open(g));
  }, [g, f, n]), h(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), h(() => {
    if (o && f !== null) {
      var R = o instanceof google.maps.LatLng ? o : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        new google.maps.LatLng(o.lat, o.lng)
      );
      f.setPosition(R);
    }
  }, [o]), h(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), h(() => {
    f && a && (v !== null && google.maps.event.removeListener(v), E(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), h(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), M(google.maps.event.addListener(f, "domready", s)));
  }, [s]), h(() => {
    f && l && (O !== null && google.maps.event.removeListener(O), y(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), h(() => {
    f && u && (C !== null && google.maps.event.removeListener(C), _(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), h(() => {
    f && c && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), h(() => {
    if (g) {
      var R = r || oCe, {
        position: W
      } = R, V = t_(R, nCe), z;
      W && !(W instanceof google.maps.LatLng) && (z = new google.maps.LatLng(W.lat, W.lng));
      var Z = new aq(Nv(Nv({}, V), z ? {
        position: z
      } : {}));
      N.current = document.createElement("div"), m(Z), a && E(google.maps.event.addListener(Z, "closeclick", a)), s && M(google.maps.event.addListener(Z, "domready", s)), l && y(google.maps.event.addListener(Z, "content_changed", l)), u && _(google.maps.event.addListener(Z, "position_changed", u)), c && L(google.maps.event.addListener(Z, "zindex_changed", c)), Z.setContent(N.current), n ? Z.open(g, n) : Z.getPosition() ? Z.open(g) : bo(!1, "You must provide either an anchor or a position prop for <InfoBox>."), p && p(Z);
    }
    return () => {
      f !== null && (v && google.maps.event.removeListener(v), O && google.maps.event.removeListener(O), w && google.maps.event.removeListener(w), C && google.maps.event.removeListener(C), F && google.maps.event.removeListener(F), d && d(f), f.close());
    };
  }, []), N.current ? or(lt.only(t), N.current) : null;
}
ve(iCe);
class sCe extends pe {
  constructor() {
    super(...arguments), xe(this, "registeredEvents", []), xe(this, "containerElement", null), xe(this, "state", {
      infoBox: null
    }), xe(this, "open", (t, n) => {
      n ? this.context !== null && t.open(this.context, n) : t.getPosition() ? this.context !== null && t.open(this.context) : bo(!1, "You must provide either an anchor or a position prop for <InfoBox>.");
    }), xe(this, "setInfoBoxCallback", () => {
      this.state.infoBox !== null && this.containerElement !== null && (this.state.infoBox.setContent(this.containerElement), this.open(this.state.infoBox, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoBox));
    });
  }
  componentDidMount() {
    var t = this.props.options || {}, {
      position: n
    } = t, r = t_(t, rCe), o;
    n && !(n instanceof google.maps.LatLng) && (o = new google.maps.LatLng(n.lat, n.lng));
    var i = new aq(Nv(Nv({}, r), o ? {
      position: o
    } : {}));
    this.containerElement = document.createElement("div"), this.registeredEvents = ln({
      updaterMap: FB,
      eventMap: NB,
      prevProps: {},
      nextProps: this.props,
      instance: i
    }), this.setState({
      infoBox: i
    }, this.setInfoBoxCallback);
  }
  componentDidUpdate(t) {
    var {
      infoBox: n
    } = this.state;
    n !== null && (hn(this.registeredEvents), this.registeredEvents = ln({
      updaterMap: FB,
      eventMap: NB,
      prevProps: t,
      nextProps: this.props,
      instance: n
    }));
  }
  componentWillUnmount() {
    var {
      onUnmount: t
    } = this.props, {
      infoBox: n
    } = this.state;
    n !== null && (t && t(n), hn(this.registeredEvents), n.close());
  }
  render() {
    return this.containerElement ? or(lt.only(this.props.children), this.containerElement) : null;
  }
}
xe(sCe, "contextType", jt);
var zB, UB;
function aCe() {
  return UB || (UB = 1, zB = function e(t, n) {
    if (t === n) return !0;
    if (t && n && typeof t == "object" && typeof n == "object") {
      if (t.constructor !== n.constructor) return !1;
      var r, o, i;
      if (Array.isArray(t)) {
        if (r = t.length, r != n.length) return !1;
        for (o = r; o-- !== 0; ) if (!e(t[o], n[o])) return !1;
        return !0;
      }
      if (t.constructor === RegExp) return t.source === n.source && t.flags === n.flags;
      if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === n.valueOf();
      if (t.toString !== Object.prototype.toString) return t.toString() === n.toString();
      if (i = Object.keys(t), r = i.length, r !== Object.keys(n).length) return !1;
      for (o = r; o-- !== 0; ) if (!Object.prototype.hasOwnProperty.call(n, i[o])) return !1;
      for (o = r; o-- !== 0; ) {
        var a = i[o];
        if (!e(t[a], n[a])) return !1;
      }
      return !0;
    }
    return t !== t && n !== n;
  }), zB;
}
var lCe = aCe(), HB = /* @__PURE__ */ eq(lCe), $B = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array], HC = 1, ap = 8;
class n_ {
  /**
   * Creates an index from raw `ArrayBuffer` data.
   * @param {ArrayBuffer} data
   */
  static from(t) {
    if (!(t instanceof ArrayBuffer))
      throw new Error("Data must be an instance of ArrayBuffer.");
    var [n, r] = new Uint8Array(t, 0, 2);
    if (n !== 219)
      throw new Error("Data does not appear to be in a KDBush format.");
    var o = r >> 4;
    if (o !== HC)
      throw new Error("Got v".concat(o, " data when expected v").concat(HC, "."));
    var i = $B[r & 15];
    if (!i)
      throw new Error("Unrecognized array type.");
    var [a] = new Uint16Array(t, 2, 1), [s] = new Uint32Array(t, 4, 1);
    return new n_(s, a, i, t);
  }
  /**
   * Creates an index that will hold a given number of items.
   * @param {number} numItems
   * @param {number} [nodeSize=64] Size of the KD-tree node (64 by default).
   * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).
   * @param {ArrayBuffer} [data] (For internal use only)
   */
  constructor(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 64, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Float64Array, o = arguments.length > 3 ? arguments[3] : void 0;
    if (isNaN(t) || t < 0) throw new Error("Unpexpected numItems value: ".concat(t, "."));
    this.numItems = +t, this.nodeSize = Math.min(Math.max(+n, 2), 65535), this.ArrayType = r, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
    var i = $B.indexOf(this.ArrayType), a = t * 2 * this.ArrayType.BYTES_PER_ELEMENT, s = t * this.IndexArrayType.BYTES_PER_ELEMENT, l = (8 - s % 8) % 8;
    if (i < 0)
      throw new Error("Unexpected typed array class: ".concat(r, "."));
    o && o instanceof ArrayBuffer ? (this.data = o, this.ids = new this.IndexArrayType(this.data, ap, t), this.coords = new this.ArrayType(this.data, ap + s + l, t * 2), this._pos = t * 2, this._finished = !0) : (this.data = new ArrayBuffer(ap + a + s + l), this.ids = new this.IndexArrayType(this.data, ap, t), this.coords = new this.ArrayType(this.data, ap + s + l, t * 2), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, (HC << 4) + i]), new Uint16Array(this.data, 2, 1)[0] = n, new Uint32Array(this.data, 4, 1)[0] = t);
  }
  /**
   * Add a point to the index.
   * @param {number} x
   * @param {number} y
   * @returns {number} An incremental index associated with the added item (starting from `0`).
   */
  add(t, n) {
    var r = this._pos >> 1;
    return this.ids[r] = r, this.coords[this._pos++] = t, this.coords[this._pos++] = n, r;
  }
  /**
   * Perform indexing of the added points.
   */
  finish() {
    var t = this._pos >> 1;
    if (t !== this.numItems)
      throw new Error("Added ".concat(t, " items when expected ").concat(this.numItems, "."));
    return xk(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
  }
  /**
   * Search the index for items within a given bounding box.
   * @param {number} minX
   * @param {number} minY
   * @param {number} maxX
   * @param {number} maxY
   * @returns {number[]} An array of indices correponding to the found items.
   */
  range(t, n, r, o) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: i,
      coords: a,
      nodeSize: s
    } = this, l = [0, i.length - 1, 0], u = []; l.length; ) {
      var c = l.pop() || 0, p = l.pop() || 0, d = l.pop() || 0;
      if (p - d <= s) {
        for (var g = d; g <= p; g++) {
          var f = a[2 * g], m = a[2 * g + 1];
          f >= t && f <= r && m >= n && m <= o && u.push(i[g]);
        }
        continue;
      }
      var v = d + p >> 1, E = a[2 * v], w = a[2 * v + 1];
      E >= t && E <= r && w >= n && w <= o && u.push(i[v]), (c === 0 ? t <= E : n <= w) && (l.push(d), l.push(v - 1), l.push(1 - c)), (c === 0 ? r >= E : o >= w) && (l.push(v + 1), l.push(p), l.push(1 - c));
    }
    return u;
  }
  /**
   * Search the index for items within a given radius.
   * @param {number} qx
   * @param {number} qy
   * @param {number} r Query radius.
   * @returns {number[]} An array of indices correponding to the found items.
   */
  within(t, n, r) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: o,
      coords: i,
      nodeSize: a
    } = this, s = [0, o.length - 1, 0], l = [], u = r * r; s.length; ) {
      var c = s.pop() || 0, p = s.pop() || 0, d = s.pop() || 0;
      if (p - d <= a) {
        for (var g = d; g <= p; g++)
          WB(i[2 * g], i[2 * g + 1], t, n) <= u && l.push(o[g]);
        continue;
      }
      var f = d + p >> 1, m = i[2 * f], v = i[2 * f + 1];
      WB(m, v, t, n) <= u && l.push(o[f]), (c === 0 ? t - r <= m : n - r <= v) && (s.push(d), s.push(f - 1), s.push(1 - c)), (c === 0 ? t + r >= m : n + r >= v) && (s.push(f + 1), s.push(p), s.push(1 - c));
    }
    return l;
  }
}
function xk(e, t, n, r, o, i) {
  if (!(o - r <= n)) {
    var a = r + o >> 1;
    lq(e, t, a, r, o, i), xk(e, t, n, r, a - 1, 1 - i), xk(e, t, n, a + 1, o, 1 - i);
  }
}
function lq(e, t, n, r, o, i) {
  for (; o > r; ) {
    if (o - r > 600) {
      var a = o - r + 1, s = n - r + 1, l = Math.log(a), u = 0.5 * Math.exp(2 * l / 3), c = 0.5 * Math.sqrt(l * u * (a - u) / a) * (s - a / 2 < 0 ? -1 : 1), p = Math.max(r, Math.floor(n - s * u / a + c)), d = Math.min(o, Math.floor(n + (a - s) * u / a + c));
      lq(e, t, n, p, d, i);
    }
    var g = t[2 * n + i], f = r, m = o;
    for (lp(e, t, r, n), t[2 * o + i] > g && lp(e, t, r, o); f < m; ) {
      for (lp(e, t, f, m), f++, m--; t[2 * f + i] < g; ) f++;
      for (; t[2 * m + i] > g; ) m--;
    }
    t[2 * r + i] === g ? lp(e, t, r, m) : (m++, lp(e, t, m, o)), m <= n && (r = m + 1), n <= m && (o = m - 1);
  }
}
function lp(e, t, n, r) {
  $C(e, n, r), $C(t, 2 * n, 2 * r), $C(t, 2 * n + 1, 2 * r + 1);
}
function $C(e, t, n) {
  var r = e[t];
  e[t] = e[n], e[n] = r;
}
function WB(e, t, n, r) {
  var o = e - n, i = t - r;
  return o * o + i * i;
}
var uCe = {
  minZoom: 0,
  // min zoom to generate clusters on
  maxZoom: 16,
  // max zoom level to cluster the points on
  minPoints: 2,
  // minimum points to form a cluster
  radius: 40,
  // cluster radius in pixels
  extent: 512,
  // tile extent (radius is calculated relative to it)
  nodeSize: 64,
  // size of the KD-tree leaf node, affects performance
  log: !1,
  // whether to log timing info
  // whether to generate numeric ids for input features (in vector tiles)
  generateId: !1,
  // a reduce function for calculating custom cluster properties
  reduce: null,
  // (accumulated, props) => { accumulated.sum += props.sum; }
  // properties to use for individual points when running the reducer
  map: (e) => e
  // props => ({sum: props.my_value})
}, VB = Math.fround || /* @__PURE__ */ ((e) => (t) => (e[0] = +t, e[0]))(new Float32Array(1)), Bl = 2, Va = 3, WC = 4, Na = 5, uq = 6;
class cCe {
  constructor(t) {
    this.options = Object.assign(Object.create(uCe), t), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
  }
  load(t) {
    var {
      log: n,
      minZoom: r,
      maxZoom: o
    } = this.options;
    n && console.time("total time");
    var i = "prepare ".concat(t.length, " points");
    n && console.time(i), this.points = t;
    for (var a = [], s = 0; s < t.length; s++) {
      var l = t[s];
      if (l.geometry) {
        var [u, c] = l.geometry.coordinates, p = VB(bg(u)), d = VB(wg(c));
        a.push(
          p,
          d,
          // projected point coordinates
          1 / 0,
          // the last zoom the point was processed at
          s,
          // index of the source feature in the original input array
          -1,
          // parent cluster id
          1
          // number of points in a cluster
        ), this.options.reduce && a.push(0);
      }
    }
    var g = this.trees[o + 1] = this._createTree(a);
    n && console.timeEnd(i);
    for (var f = o; f >= r; f--) {
      var m = +Date.now();
      g = this.trees[f] = this._createTree(this._cluster(g, f)), n && console.log("z%d: %d clusters in %dms", f, g.numItems, +Date.now() - m);
    }
    return n && console.timeEnd("total time"), this;
  }
  getClusters(t, n) {
    var r = ((t[0] + 180) % 360 + 360) % 360 - 180, o = Math.max(-90, Math.min(90, t[1])), i = t[2] === 180 ? 180 : ((t[2] + 180) % 360 + 360) % 360 - 180, a = Math.max(-90, Math.min(90, t[3]));
    if (t[2] - t[0] >= 360)
      r = -180, i = 180;
    else if (r > i) {
      var s = this.getClusters([r, o, 180, a], n), l = this.getClusters([-180, o, i, a], n);
      return s.concat(l);
    }
    var u = this.trees[this._limitZoom(n)], c = u.range(bg(r), wg(a), bg(i), wg(o)), p = u.data, d = [];
    for (var g of c) {
      var f = this.stride * g;
      d.push(p[f + Na] > 1 ? ZB(p, f, this.clusterProps) : this.points[p[f + Va]]);
    }
    return d;
  }
  getChildren(t) {
    var n = this._getOriginId(t), r = this._getOriginZoom(t), o = "No cluster with the specified id.", i = this.trees[r];
    if (!i) throw new Error(o);
    var a = i.data;
    if (n * this.stride >= a.length) throw new Error(o);
    var s = this.options.radius / (this.options.extent * Math.pow(2, r - 1)), l = a[n * this.stride], u = a[n * this.stride + 1], c = i.within(l, u, s), p = [];
    for (var d of c) {
      var g = d * this.stride;
      a[g + WC] === t && p.push(a[g + Na] > 1 ? ZB(a, g, this.clusterProps) : this.points[a[g + Va]]);
    }
    if (p.length === 0) throw new Error(o);
    return p;
  }
  getLeaves(t, n, r) {
    n = n || 10, r = r || 0;
    var o = [];
    return this._appendLeaves(o, t, n, r, 0), o;
  }
  getTile(t, n, r) {
    var o = this.trees[this._limitZoom(t)], i = Math.pow(2, t), {
      extent: a,
      radius: s
    } = this.options, l = s / a, u = (r - l) / i, c = (r + 1 + l) / i, p = {
      features: []
    };
    return this._addTileFeatures(o.range((n - l) / i, u, (n + 1 + l) / i, c), o.data, n, r, i, p), n === 0 && this._addTileFeatures(o.range(1 - l / i, u, 1, c), o.data, i, r, i, p), n === i - 1 && this._addTileFeatures(o.range(0, u, l / i, c), o.data, -1, r, i, p), p.features.length ? p : null;
  }
  getClusterExpansionZoom(t) {
    for (var n = this._getOriginZoom(t) - 1; n <= this.options.maxZoom; ) {
      var r = this.getChildren(t);
      if (n++, r.length !== 1) break;
      t = r[0].properties.cluster_id;
    }
    return n;
  }
  _appendLeaves(t, n, r, o, i) {
    var a = this.getChildren(n);
    for (var s of a) {
      var l = s.properties;
      if (l && l.cluster ? i + l.point_count <= o ? i += l.point_count : i = this._appendLeaves(t, l.cluster_id, r, o, i) : i < o ? i++ : t.push(s), t.length === r) break;
    }
    return i;
  }
  _createTree(t) {
    for (var n = new n_(t.length / this.stride | 0, this.options.nodeSize, Float32Array), r = 0; r < t.length; r += this.stride) n.add(t[r], t[r + 1]);
    return n.finish(), n.data = t, n;
  }
  _addTileFeatures(t, n, r, o, i, a) {
    for (var s of t) {
      var l = s * this.stride, u = n[l + Na] > 1, c = void 0, p = void 0, d = void 0;
      if (u)
        c = cq(n, l, this.clusterProps), p = n[l], d = n[l + 1];
      else {
        var g = this.points[n[l + Va]];
        c = g.properties;
        var [f, m] = g.geometry.coordinates;
        p = bg(f), d = wg(m);
      }
      var v = {
        type: 1,
        geometry: [[Math.round(this.options.extent * (p * i - r)), Math.round(this.options.extent * (d * i - o))]],
        tags: c
      }, E = void 0;
      u || this.options.generateId ? E = n[l + Va] : E = this.points[n[l + Va]].id, E !== void 0 && (v.id = E), a.features.push(v);
    }
  }
  _limitZoom(t) {
    return Math.max(this.options.minZoom, Math.min(Math.floor(+t), this.options.maxZoom + 1));
  }
  _cluster(t, n) {
    for (var {
      radius: r,
      extent: o,
      reduce: i,
      minPoints: a
    } = this.options, s = r / (o * Math.pow(2, n)), l = t.data, u = [], c = this.stride, p = 0; p < l.length; p += c)
      if (!(l[p + Bl] <= n)) {
        l[p + Bl] = n;
        var d = l[p], g = l[p + 1], f = t.within(l[p], l[p + 1], s), m = l[p + Na], v = m;
        for (var E of f) {
          var w = E * c;
          l[w + Bl] > n && (v += l[w + Na]);
        }
        if (v > m && v >= a) {
          var M = d * m, O = g * m, y = void 0, C = -1, _ = ((p / c | 0) << 5) + (n + 1) + this.points.length;
          for (var F of f) {
            var L = F * c;
            if (!(l[L + Bl] <= n)) {
              l[L + Bl] = n;
              var N = l[L + Na];
              M += l[L] * N, O += l[L + 1] * N, l[L + WC] = _, i && (y || (y = this._map(l, p, !0), C = this.clusterProps.length, this.clusterProps.push(y)), i(y, this._map(l, L)));
            }
          }
          l[p + WC] = _, u.push(M / v, O / v, 1 / 0, _, -1, v), i && u.push(C);
        } else {
          for (var R = 0; R < c; R++) u.push(l[p + R]);
          if (v > 1)
            for (var W of f) {
              var V = W * c;
              if (!(l[V + Bl] <= n)) {
                l[V + Bl] = n;
                for (var z = 0; z < c; z++) u.push(l[V + z]);
              }
            }
        }
      }
    return u;
  }
  // get index of the point from which the cluster originated
  _getOriginId(t) {
    return t - this.points.length >> 5;
  }
  // get zoom of the point from which the cluster originated
  _getOriginZoom(t) {
    return (t - this.points.length) % 32;
  }
  _map(t, n, r) {
    if (t[n + Na] > 1) {
      var o = this.clusterProps[t[n + uq]];
      return r ? Object.assign({}, o) : o;
    }
    var i = this.points[t[n + Va]].properties, a = this.options.map(i);
    return r && a === i ? Object.assign({}, a) : a;
  }
}
function ZB(e, t, n) {
  return {
    type: "Feature",
    id: e[t + Va],
    properties: cq(e, t, n),
    geometry: {
      type: "Point",
      coordinates: [pCe(e[t]), dCe(e[t + 1])]
    }
  };
}
function cq(e, t, n) {
  var r = e[t + Na], o = r >= 1e4 ? "".concat(Math.round(r / 1e3), "k") : r >= 1e3 ? "".concat(Math.round(r / 100) / 10, "k") : r, i = e[t + uq], a = i === -1 ? {} : Object.assign({}, n[i]);
  return Object.assign(a, {
    cluster: !0,
    cluster_id: e[t + Va],
    point_count: r,
    point_count_abbreviated: o
  });
}
function bg(e) {
  return e / 360 + 0.5;
}
function wg(e) {
  var t = Math.sin(e * Math.PI / 180), n = 0.5 - 0.25 * Math.log((1 + t) / (1 - t)) / Math.PI;
  return n < 0 ? 0 : n > 1 ? 1 : n;
}
function pCe(e) {
  return (e - 0.5) * 360;
}
function dCe(e) {
  var t = (180 - e * 360) * Math.PI / 180;
  return 360 * Math.atan(Math.exp(t)) / Math.PI - 90;
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function fCe(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
    t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
  return n;
}
class Ai {
  static isAdvancedMarkerAvailable(t) {
    return google.maps.marker && t.getMapCapabilities().isAdvancedMarkersAvailable === !0;
  }
  static isAdvancedMarker(t) {
    return google.maps.marker && t instanceof google.maps.marker.AdvancedMarkerElement;
  }
  static setMap(t, n) {
    this.isAdvancedMarker(t) ? t.map = n : t.setMap(n);
  }
  static getPosition(t) {
    if (this.isAdvancedMarker(t)) {
      if (t.position) {
        if (t.position instanceof google.maps.LatLng)
          return t.position;
        if (t.position.lat && t.position.lng)
          return new google.maps.LatLng(t.position.lat, t.position.lng);
      }
      return new google.maps.LatLng(null);
    }
    return t.getPosition();
  }
  static getVisible(t) {
    return this.isAdvancedMarker(t) ? !0 : t.getVisible();
  }
}
class Ok {
  constructor(t) {
    var {
      markers: n,
      position: r
    } = t;
    this.markers = n, r && (r instanceof google.maps.LatLng ? this._position = r : this._position = new google.maps.LatLng(r));
  }
  get bounds() {
    if (!(this.markers.length === 0 && !this._position)) {
      var t = new google.maps.LatLngBounds(this._position, this._position);
      for (var n of this.markers)
        t.extend(Ai.getPosition(n));
      return t;
    }
  }
  get position() {
    return this._position || this.bounds.getCenter();
  }
  /**
   * Get the count of **visible** markers.
   */
  get count() {
    return this.markers.filter((t) => Ai.getVisible(t)).length;
  }
  /**
   * Add a marker to the cluster.
   */
  push(t) {
    this.markers.push(t);
  }
  /**
   * Cleanup references and remove marker from map.
   */
  delete() {
    this.marker && (Ai.setMap(this.marker, null), this.marker = void 0), this.markers.length = 0;
  }
}
class hCe {
  constructor(t) {
    var {
      maxZoom: n = 16
    } = t;
    this.maxZoom = n;
  }
  /**
   * Helper function to bypass clustering based upon some map state such as
   * zoom, number of markers, etc.
   *
   * ```typescript
   *  cluster({markers, map}: AlgorithmInput): Cluster[] {
   *    if (shouldBypassClustering(map)) {
   *      return this.noop({markers})
   *    }
   * }
   * ```
   */
  noop(t) {
    var {
      markers: n
    } = t;
    return gCe(n);
  }
}
var gCe = (e) => {
  var t = e.map((n) => new Ok({
    position: Ai.getPosition(n),
    markers: [n]
  }));
  return t;
};
class mCe extends hCe {
  constructor(t) {
    var {
      maxZoom: n,
      radius: r = 60
    } = t, o = fCe(t, ["maxZoom", "radius"]);
    super({
      maxZoom: n
    }), this.state = {
      zoom: -1
    }, this.superCluster = new cCe(Object.assign({
      maxZoom: this.maxZoom,
      radius: r
    }, o));
  }
  calculate(t) {
    var n = !1, r = {
      zoom: t.map.getZoom()
    };
    if (!HB(t.markers, this.markers)) {
      n = !0, this.markers = [...t.markers];
      var o = this.markers.map((i) => {
        var a = Ai.getPosition(i), s = [a.lng(), a.lat()];
        return {
          type: "Feature",
          geometry: {
            type: "Point",
            coordinates: s
          },
          properties: {
            marker: i
          }
        };
      });
      this.superCluster.load(o);
    }
    return n || (this.state.zoom <= this.maxZoom || r.zoom <= this.maxZoom) && (n = !HB(this.state, r)), this.state = r, n && (this.clusters = this.cluster(t)), {
      clusters: this.clusters,
      changed: n
    };
  }
  cluster(t) {
    var {
      map: n
    } = t;
    return this.superCluster.getClusters([-180, -90, 180, 90], Math.round(n.getZoom())).map((r) => this.transformCluster(r));
  }
  transformCluster(t) {
    var {
      geometry: {
        coordinates: [n, r]
      },
      properties: o
    } = t;
    if (o.cluster)
      return new Ok({
        markers: this.superCluster.getLeaves(o.cluster_id, 1 / 0).map((a) => a.properties.marker),
        position: {
          lat: r,
          lng: n
        }
      });
    var i = o.marker;
    return new Ok({
      markers: [i],
      position: Ai.getPosition(i)
    });
  }
}
class vCe {
  constructor(t, n) {
    this.markers = {
      sum: t.length
    };
    var r = n.map((i) => i.count), o = r.reduce((i, a) => i + a, 0);
    this.clusters = {
      count: n.length,
      markers: {
        mean: o / n.length,
        sum: o,
        min: Math.min(...r),
        max: Math.max(...r)
      }
    };
  }
}
class yCe {
  /**
   * The default render function for the library used by {@link MarkerClusterer}.
   *
   * Currently set to use the following:
   *
   * ```typescript
   * // change color if this cluster has more markers than the mean cluster
   * const color =
   *   count > Math.max(10, stats.clusters.markers.mean)
   *     ? "#ff0000"
   *     : "#0000ff";
   *
   * // create svg url with fill color
   * const svg = window.btoa(`
   * <svg fill="${color}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240">
   *   <circle cx="120" cy="120" opacity=".6" r="70" />
   *   <circle cx="120" cy="120" opacity=".3" r="90" />
   *   <circle cx="120" cy="120" opacity=".2" r="110" />
   *   <circle cx="120" cy="120" opacity=".1" r="130" />
   * </svg>`);
   *
   * // create marker using svg icon
   * return new google.maps.Marker({
   *   position,
   *   icon: {
   *     url: `data:image/svg+xml;base64,${svg}`,
   *     scaledSize: new google.maps.Size(45, 45),
   *   },
   *   label: {
   *     text: String(count),
   *     color: "rgba(255,255,255,0.9)",
   *     fontSize: "12px",
   *   },
   *   // adjust zIndex to be above other markers
   *   zIndex: 1000 + count,
   * });
   * ```
   */
  render(t, n, r) {
    var {
      count: o,
      position: i
    } = t, a = o > Math.max(10, n.clusters.markers.mean) ? "#ff0000" : "#0000ff", s = '<svg fill="'.concat(a, `" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" width="50" height="50">
<circle cx="120" cy="120" opacity=".6" r="70" />
<circle cx="120" cy="120" opacity=".3" r="90" />
<circle cx="120" cy="120" opacity=".2" r="110" />
<text x="50%" y="50%" style="fill:#fff" text-anchor="middle" font-size="50" dominant-baseline="middle" font-family="roboto,arial,sans-serif">`).concat(o, `</text>
</svg>`), l = "Cluster of ".concat(o, " markers"), u = Number(google.maps.Marker.MAX_ZINDEX) + o;
    if (Ai.isAdvancedMarkerAvailable(r)) {
      var c = new DOMParser(), p = c.parseFromString(s, "image/svg+xml").documentElement;
      p.setAttribute("transform", "translate(0 25)");
      var d = {
        map: r,
        position: i,
        zIndex: u,
        title: l,
        content: p
      };
      return new google.maps.marker.AdvancedMarkerElement(d);
    }
    var g = {
      position: i,
      zIndex: u,
      title: l,
      icon: {
        url: "data:image/svg+xml;base64,".concat(btoa(s)),
        anchor: new google.maps.Point(25, 25)
      }
    };
    return new google.maps.Marker(g);
  }
}
function bCe(e, t) {
  for (var n in t.prototype)
    e.prototype[n] = t.prototype[n];
}
class r_ {
  constructor() {
    bCe(r_, google.maps.OverlayView);
  }
}
var rd;
(function(e) {
  e.CLUSTERING_BEGIN = "clusteringbegin", e.CLUSTERING_END = "clusteringend", e.CLUSTER_CLICK = "click";
})(rd || (rd = {}));
var wCe = (e, t, n) => {
  n.fitBounds(t.bounds);
};
class CCe extends r_ {
  constructor(t) {
    var {
      map: n,
      markers: r = [],
      algorithmOptions: o = {},
      algorithm: i = new mCe(o),
      renderer: a = new yCe(),
      onClusterClick: s = wCe
    } = t;
    super(), this.markers = [...r], this.clusters = [], this.algorithm = i, this.renderer = a, this.onClusterClick = s, n && this.setMap(n);
  }
  addMarker(t, n) {
    this.markers.includes(t) || (this.markers.push(t), n || this.render());
  }
  addMarkers(t, n) {
    t.forEach((r) => {
      this.addMarker(r, !0);
    }), n || this.render();
  }
  removeMarker(t, n) {
    var r = this.markers.indexOf(t);
    return r === -1 ? !1 : (Ai.setMap(t, null), this.markers.splice(r, 1), n || this.render(), !0);
  }
  removeMarkers(t, n) {
    var r = !1;
    return t.forEach((o) => {
      r = this.removeMarker(o, !0) || r;
    }), r && !n && this.render(), r;
  }
  clearMarkers(t) {
    this.markers.length = 0, t || this.render();
  }
  /**
   * Recalculates and draws all the marker clusters.
   */
  render() {
    var t = this.getMap();
    if (t instanceof google.maps.Map && t.getProjection()) {
      google.maps.event.trigger(this, rd.CLUSTERING_BEGIN, this);
      var {
        clusters: n,
        changed: r
      } = this.algorithm.calculate({
        markers: this.markers,
        map: t,
        mapCanvasProjection: this.getProjection()
      });
      if (r || r == null) {
        var o = /* @__PURE__ */ new Set();
        for (var i of n)
          i.markers.length == 1 && o.add(i.markers[0]);
        var a = [];
        for (var s of this.clusters)
          s.marker != null && (s.markers.length == 1 ? o.has(s.marker) || Ai.setMap(s.marker, null) : a.push(s.marker));
        this.clusters = n, this.renderClusters(), requestAnimationFrame(() => a.forEach((l) => Ai.setMap(l, null)));
      }
      google.maps.event.trigger(this, rd.CLUSTERING_END, this);
    }
  }
  onAdd() {
    this.idleListener = this.getMap().addListener("idle", this.render.bind(this)), this.render();
  }
  onRemove() {
    google.maps.event.removeListener(this.idleListener), this.reset();
  }
  reset() {
    this.markers.forEach((t) => Ai.setMap(t, null)), this.clusters.forEach((t) => t.delete()), this.clusters = [];
  }
  renderClusters() {
    var t = new vCe(this.markers, this.clusters), n = this.getMap();
    this.clusters.forEach((r) => {
      r.markers.length === 1 ? r.marker = r.markers[0] : (r.marker = this.renderer.render(r, t, n), r.markers.forEach((o) => Ai.setMap(o, null)), this.onClusterClick && r.marker.addListener(
        "click",
        /* istanbul ignore next */
        (o) => {
          google.maps.event.trigger(this, rd.CLUSTER_CLICK, r), this.onClusterClick(o, r, n);
        }
      )), Ai.setMap(r.marker, n);
    });
  }
}
function qB(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function GB(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? qB(Object(n), !0).forEach(function(r) {
      xe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : qB(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function xCe(e) {
  var t = w0e(), [n, r] = k(null);
  return h(() => {
    if (t && n === null) {
      var o = new CCe(GB(GB({}, e), {}, {
        map: t
      }));
      r(o);
    }
  }, [t]), n;
}
function OCe(e) {
  var {
    children: t,
    options: n
  } = e, r = xCe(n);
  return r !== null ? t(r) : null;
}
ve(OCe);
var KB = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, YB = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
function ECe(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, g = ge(jt), [f, m] = k(null), [v, E] = k(null), [w, M] = k(null), [O, y] = k(null), [C, _] = k(null), [F, L] = k(null), N = ut(null);
  return h(() => {
    f !== null && (f.close(), n ? f.open(g, n) : f.getPosition() && f.open(g));
  }, [g, f, n]), h(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), h(() => {
    o && f !== null && f.setPosition(o);
  }, [o]), h(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), h(() => {
    f && a && (v !== null && google.maps.event.removeListener(v), E(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), h(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), M(google.maps.event.addListener(f, "domready", s)));
  }, [s]), h(() => {
    f && l && (O !== null && google.maps.event.removeListener(O), y(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), h(() => {
    f && u && (C !== null && google.maps.event.removeListener(C), _(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), h(() => {
    f && c && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), h(() => {
    var R = new google.maps.InfoWindow(r);
    return m(R), N.current = document.createElement("div"), a && E(google.maps.event.addListener(R, "closeclick", a)), s && M(google.maps.event.addListener(R, "domready", s)), l && y(google.maps.event.addListener(R, "content_changed", l)), u && _(google.maps.event.addListener(R, "position_changed", u)), c && L(google.maps.event.addListener(R, "zindex_changed", c)), R.setContent(N.current), o && R.setPosition(o), i && R.setZIndex(i), n ? R.open(g, n) : R.getPosition() ? R.open(g) : bo(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>."), p && p(R), () => {
      v && google.maps.event.removeListener(v), O && google.maps.event.removeListener(O), w && google.maps.event.removeListener(w), C && google.maps.event.removeListener(C), F && google.maps.event.removeListener(F), d && d(R), R.close();
    };
  }, []), N.current ? or(lt.only(t), N.current) : null;
}
ve(ECe);
class kCe extends pe {
  constructor() {
    super(...arguments), xe(this, "registeredEvents", []), xe(this, "containerElement", null), xe(this, "state", {
      infoWindow: null
    }), xe(this, "open", (t, n) => {
      n ? t.open(this.context, n) : t.getPosition() ? t.open(this.context) : bo(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>.");
    }), xe(this, "setInfoWindowCallback", () => {
      this.state.infoWindow !== null && this.containerElement !== null && (this.state.infoWindow.setContent(this.containerElement), this.open(this.state.infoWindow, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoWindow));
    });
  }
  componentDidMount() {
    var t = new google.maps.InfoWindow(this.props.options);
    this.containerElement = document.createElement("div"), this.registeredEvents = ln({
      updaterMap: YB,
      eventMap: KB,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(() => ({
      infoWindow: t
    }), this.setInfoWindowCallback);
  }
  componentDidUpdate(t) {
    this.state.infoWindow !== null && (hn(this.registeredEvents), this.registeredEvents = ln({
      updaterMap: YB,
      eventMap: KB,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.infoWindow
    }));
  }
  componentWillUnmount() {
    this.state.infoWindow !== null && (hn(this.registeredEvents), this.props.onUnmount && this.props.onUnmount(this.state.infoWindow), this.state.infoWindow.close());
  }
  render() {
    return this.containerElement ? or(lt.only(this.props.children), this.containerElement) : null;
  }
}
xe(kCe, "contextType", jt);
function XB(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Fv(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? XB(Object(n), !0).forEach(function(r) {
      xe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : XB(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var JB = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, QB = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, LCe = {};
function PCe(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: g,
    onRightClick: f,
    onClick: m,
    onDrag: v,
    onLoad: E,
    onUnmount: w
  } = e, M = ge(jt), [O, y] = k(null), [C, _] = k(null), [F, L] = k(null), [N, R] = k(null), [W, V] = k(null), [z, Z] = k(null), [K, X] = k(null), [te, J] = k(null), [P, D] = k(null), [H, S] = k(null), [$, x] = k(null), [j, U] = k(null);
  return h(() => {
    O !== null && O.setMap(M);
  }, [M]), h(() => {
    typeof t < "u" && O !== null && O.setOptions(t);
  }, [O, t]), h(() => {
    typeof n < "u" && O !== null && O.setDraggable(n);
  }, [O, n]), h(() => {
    typeof r < "u" && O !== null && O.setEditable(r);
  }, [O, r]), h(() => {
    typeof o < "u" && O !== null && O.setVisible(o);
  }, [O, o]), h(() => {
    typeof i < "u" && O !== null && O.setPath(i);
  }, [O, i]), h(() => {
    O && a && (C !== null && google.maps.event.removeListener(C), _(google.maps.event.addListener(O, "dblclick", a)));
  }, [a]), h(() => {
    O && s && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(O, "dragend", s)));
  }, [s]), h(() => {
    O && l && (N !== null && google.maps.event.removeListener(N), R(google.maps.event.addListener(O, "dragstart", l)));
  }, [l]), h(() => {
    O && u && (W !== null && google.maps.event.removeListener(W), V(google.maps.event.addListener(O, "mousedown", u)));
  }, [u]), h(() => {
    O && c && (z !== null && google.maps.event.removeListener(z), Z(google.maps.event.addListener(O, "mousemove", c)));
  }, [c]), h(() => {
    O && p && (K !== null && google.maps.event.removeListener(K), X(google.maps.event.addListener(O, "mouseout", p)));
  }, [p]), h(() => {
    O && d && (te !== null && google.maps.event.removeListener(te), J(google.maps.event.addListener(O, "mouseover", d)));
  }, [d]), h(() => {
    O && g && (P !== null && google.maps.event.removeListener(P), D(google.maps.event.addListener(O, "mouseup", g)));
  }, [g]), h(() => {
    O && f && (H !== null && google.maps.event.removeListener(H), S(google.maps.event.addListener(O, "rightclick", f)));
  }, [f]), h(() => {
    O && m && ($ !== null && google.maps.event.removeListener($), x(google.maps.event.addListener(O, "click", m)));
  }, [m]), h(() => {
    O && v && (j !== null && google.maps.event.removeListener(j), U(google.maps.event.addListener(O, "drag", v)));
  }, [v]), h(() => {
    var T = new google.maps.Polyline(Fv(Fv({}, t || LCe), {}, {
      map: M
    }));
    return i && T.setPath(i), typeof o < "u" && T.setVisible(o), typeof r < "u" && T.setEditable(r), typeof n < "u" && T.setDraggable(n), a && _(google.maps.event.addListener(T, "dblclick", a)), s && L(google.maps.event.addListener(T, "dragend", s)), l && R(google.maps.event.addListener(T, "dragstart", l)), u && V(google.maps.event.addListener(T, "mousedown", u)), c && Z(google.maps.event.addListener(T, "mousemove", c)), p && X(google.maps.event.addListener(T, "mouseout", p)), d && J(google.maps.event.addListener(T, "mouseover", d)), g && D(google.maps.event.addListener(T, "mouseup", g)), f && S(google.maps.event.addListener(T, "rightclick", f)), m && x(google.maps.event.addListener(T, "click", m)), v && U(google.maps.event.addListener(T, "drag", v)), y(T), E && E(T), () => {
      C !== null && google.maps.event.removeListener(C), F !== null && google.maps.event.removeListener(F), N !== null && google.maps.event.removeListener(N), W !== null && google.maps.event.removeListener(W), z !== null && google.maps.event.removeListener(z), K !== null && google.maps.event.removeListener(K), te !== null && google.maps.event.removeListener(te), P !== null && google.maps.event.removeListener(P), H !== null && google.maps.event.removeListener(H), $ !== null && google.maps.event.removeListener($), w && w(T), T.setMap(null);
    };
  }, []), null;
}
ve(PCe);
class _Ce extends pe {
  constructor() {
    super(...arguments), xe(this, "registeredEvents", []), xe(this, "state", {
      polyline: null
    }), xe(this, "setPolylineCallback", () => {
      this.state.polyline !== null && this.props.onLoad && this.props.onLoad(this.state.polyline);
    });
  }
  componentDidMount() {
    var t = new google.maps.Polyline(Fv(Fv({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = ln({
      updaterMap: QB,
      eventMap: JB,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        polyline: t
      };
    }, this.setPolylineCallback);
  }
  componentDidUpdate(t) {
    this.state.polyline !== null && (hn(this.registeredEvents), this.registeredEvents = ln({
      updaterMap: QB,
      eventMap: JB,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.polyline
    }));
  }
  componentWillUnmount() {
    this.state.polyline !== null && (this.props.onUnmount && this.props.onUnmount(this.state.polyline), hn(this.registeredEvents), this.state.polyline.setMap(null));
  }
  render() {
    return null;
  }
}
xe(_Ce, "contextType", jt);
function eN(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function tN(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? eN(Object(n), !0).forEach(function(r) {
      xe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : eN(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var nN = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, rN = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  paths(e, t) {
    e.setPaths(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function SCe(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    paths: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: g,
    onMouseUp: f,
    onRightClick: m,
    onClick: v,
    onDrag: E,
    onLoad: w,
    onUnmount: M,
    onEdit: O
  } = e, y = ge(jt), [C, _] = k(null), [F, L] = k(null), [N, R] = k(null), [W, V] = k(null), [z, Z] = k(null), [K, X] = k(null), [te, J] = k(null), [P, D] = k(null), [H, S] = k(null), [$, x] = k(null), [j, U] = k(null), [T, q] = k(null);
  return h(() => {
    C !== null && C.setMap(y);
  }, [y]), h(() => {
    typeof t < "u" && C !== null && C.setOptions(t);
  }, [C, t]), h(() => {
    typeof n < "u" && C !== null && C.setDraggable(n);
  }, [C, n]), h(() => {
    typeof r < "u" && C !== null && C.setEditable(r);
  }, [C, r]), h(() => {
    typeof o < "u" && C !== null && C.setVisible(o);
  }, [C, o]), h(() => {
    typeof i < "u" && C !== null && C.setPath(i);
  }, [C, i]), h(() => {
    typeof a < "u" && C !== null && C.setPaths(a);
  }, [C, a]), h(() => {
    C && typeof s == "function" && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(C, "dblclick", s)));
  }, [s]), h(() => {
    C && (google.maps.event.addListener(C.getPath(), "insert_at", () => {
      O == null || O(C);
    }), google.maps.event.addListener(C.getPath(), "set_at", () => {
      O == null || O(C);
    }), google.maps.event.addListener(C.getPath(), "remove_at", () => {
      O == null || O(C);
    }));
  }, [C, O]), h(() => {
    C && typeof l == "function" && (N !== null && google.maps.event.removeListener(N), R(google.maps.event.addListener(C, "dragend", l)));
  }, [l]), h(() => {
    C && typeof u == "function" && (W !== null && google.maps.event.removeListener(W), V(google.maps.event.addListener(C, "dragstart", u)));
  }, [u]), h(() => {
    C && typeof c == "function" && (z !== null && google.maps.event.removeListener(z), Z(google.maps.event.addListener(C, "mousedown", c)));
  }, [c]), h(() => {
    C && typeof p == "function" && (K !== null && google.maps.event.removeListener(K), X(google.maps.event.addListener(C, "mousemove", p)));
  }, [p]), h(() => {
    C && typeof d == "function" && (te !== null && google.maps.event.removeListener(te), J(google.maps.event.addListener(C, "mouseout", d)));
  }, [d]), h(() => {
    C && typeof g == "function" && (P !== null && google.maps.event.removeListener(P), D(google.maps.event.addListener(C, "mouseover", g)));
  }, [g]), h(() => {
    C && typeof f == "function" && (H !== null && google.maps.event.removeListener(H), S(google.maps.event.addListener(C, "mouseup", f)));
  }, [f]), h(() => {
    C && typeof m == "function" && ($ !== null && google.maps.event.removeListener($), x(google.maps.event.addListener(C, "rightclick", m)));
  }, [m]), h(() => {
    C && typeof v == "function" && (j !== null && google.maps.event.removeListener(j), U(google.maps.event.addListener(C, "click", v)));
  }, [v]), h(() => {
    C && typeof E == "function" && (T !== null && google.maps.event.removeListener(T), q(google.maps.event.addListener(C, "drag", E)));
  }, [E]), h(() => {
    var A = new google.maps.Polygon(tN(tN({}, t), {}, {
      map: y
    }));
    return i && A.setPath(i), a && A.setPaths(a), typeof o < "u" && A.setVisible(o), typeof r < "u" && A.setEditable(r), typeof n < "u" && A.setDraggable(n), s && L(google.maps.event.addListener(A, "dblclick", s)), l && R(google.maps.event.addListener(A, "dragend", l)), u && V(google.maps.event.addListener(A, "dragstart", u)), c && Z(google.maps.event.addListener(A, "mousedown", c)), p && X(google.maps.event.addListener(A, "mousemove", p)), d && J(google.maps.event.addListener(A, "mouseout", d)), g && D(google.maps.event.addListener(A, "mouseover", g)), f && S(google.maps.event.addListener(A, "mouseup", f)), m && x(google.maps.event.addListener(A, "rightclick", m)), v && U(google.maps.event.addListener(A, "click", v)), E && q(google.maps.event.addListener(A, "drag", E)), _(A), w && w(A), () => {
      F !== null && google.maps.event.removeListener(F), N !== null && google.maps.event.removeListener(N), W !== null && google.maps.event.removeListener(W), z !== null && google.maps.event.removeListener(z), K !== null && google.maps.event.removeListener(K), te !== null && google.maps.event.removeListener(te), P !== null && google.maps.event.removeListener(P), H !== null && google.maps.event.removeListener(H), $ !== null && google.maps.event.removeListener($), j !== null && google.maps.event.removeListener(j), M && M(A), A.setMap(null);
    };
  }, []), null;
}
ve(SCe);
class MCe extends pe {
  constructor() {
    super(...arguments), xe(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this.props.options || {};
    this.polygon = new google.maps.Polygon(t), this.polygon.setMap(this.context), this.registeredEvents = ln({
      updaterMap: rN,
      eventMap: nN,
      prevProps: {},
      nextProps: this.props,
      instance: this.polygon
    }), this.props.onLoad && this.props.onLoad(this.polygon);
  }
  componentDidUpdate(t) {
    this.polygon && (hn(this.registeredEvents), this.registeredEvents = ln({
      updaterMap: rN,
      eventMap: nN,
      prevProps: t,
      nextProps: this.props,
      instance: this.polygon
    }));
  }
  componentWillUnmount() {
    this.polygon && (this.props.onUnmount && this.props.onUnmount(this.polygon), hn(this.registeredEvents), this.polygon && this.polygon.setMap(null));
  }
  render() {
    return null;
  }
}
xe(MCe, "contextType", jt);
function oN(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function zv(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? oN(Object(n), !0).forEach(function(r) {
      xe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : oN(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var iN = {
  onBoundsChanged: "bounds_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, sN = {
  bounds(e, t) {
    e.setBounds(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function DCe(e) {
  var {
    options: t,
    bounds: n,
    draggable: r,
    editable: o,
    visible: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: g,
    onRightClick: f,
    onClick: m,
    onDrag: v,
    onBoundsChanged: E,
    onLoad: w,
    onUnmount: M
  } = e, O = ge(jt), [y, C] = k(null), [_, F] = k(null), [L, N] = k(null), [R, W] = k(null), [V, z] = k(null), [Z, K] = k(null), [X, te] = k(null), [J, P] = k(null), [D, H] = k(null), [S, $] = k(null), [x, j] = k(null), [U, T] = k(null), [q, A] = k(null);
  return h(() => {
    y !== null && y.setMap(O);
  }, [O]), h(() => {
    typeof t < "u" && y !== null && y.setOptions(t);
  }, [y, t]), h(() => {
    typeof r < "u" && y !== null && y.setDraggable(r);
  }, [y, r]), h(() => {
    typeof o < "u" && y !== null && y.setEditable(o);
  }, [y, o]), h(() => {
    typeof i < "u" && y !== null && y.setVisible(i);
  }, [y, i]), h(() => {
    typeof n < "u" && y !== null && y.setBounds(n);
  }, [y, n]), h(() => {
    y && a && (_ !== null && google.maps.event.removeListener(_), F(google.maps.event.addListener(y, "dblclick", a)));
  }, [a]), h(() => {
    y && s && (L !== null && google.maps.event.removeListener(L), N(google.maps.event.addListener(y, "dragend", s)));
  }, [s]), h(() => {
    y && l && (R !== null && google.maps.event.removeListener(R), W(google.maps.event.addListener(y, "dragstart", l)));
  }, [l]), h(() => {
    y && u && (V !== null && google.maps.event.removeListener(V), z(google.maps.event.addListener(y, "mousedown", u)));
  }, [u]), h(() => {
    y && c && (Z !== null && google.maps.event.removeListener(Z), K(google.maps.event.addListener(y, "mousemove", c)));
  }, [c]), h(() => {
    y && p && (X !== null && google.maps.event.removeListener(X), te(google.maps.event.addListener(y, "mouseout", p)));
  }, [p]), h(() => {
    y && d && (J !== null && google.maps.event.removeListener(J), P(google.maps.event.addListener(y, "mouseover", d)));
  }, [d]), h(() => {
    y && g && (D !== null && google.maps.event.removeListener(D), H(google.maps.event.addListener(y, "mouseup", g)));
  }, [g]), h(() => {
    y && f && (S !== null && google.maps.event.removeListener(S), $(google.maps.event.addListener(y, "rightclick", f)));
  }, [f]), h(() => {
    y && m && (x !== null && google.maps.event.removeListener(x), j(google.maps.event.addListener(y, "click", m)));
  }, [m]), h(() => {
    y && v && (U !== null && google.maps.event.removeListener(U), T(google.maps.event.addListener(y, "drag", v)));
  }, [v]), h(() => {
    y && E && (q !== null && google.maps.event.removeListener(q), A(google.maps.event.addListener(y, "bounds_changed", E)));
  }, [E]), h(() => {
    var Y = new google.maps.Rectangle(zv(zv({}, t), {}, {
      map: O
    }));
    return typeof i < "u" && Y.setVisible(i), typeof o < "u" && Y.setEditable(o), typeof r < "u" && Y.setDraggable(r), typeof n < "u" && Y.setBounds(n), a && F(google.maps.event.addListener(Y, "dblclick", a)), s && N(google.maps.event.addListener(Y, "dragend", s)), l && W(google.maps.event.addListener(Y, "dragstart", l)), u && z(google.maps.event.addListener(Y, "mousedown", u)), c && K(google.maps.event.addListener(Y, "mousemove", c)), p && te(google.maps.event.addListener(Y, "mouseout", p)), d && P(google.maps.event.addListener(Y, "mouseover", d)), g && H(google.maps.event.addListener(Y, "mouseup", g)), f && $(google.maps.event.addListener(Y, "rightclick", f)), m && j(google.maps.event.addListener(Y, "click", m)), v && T(google.maps.event.addListener(Y, "drag", v)), E && A(google.maps.event.addListener(Y, "bounds_changed", E)), C(Y), w && w(Y), () => {
      _ !== null && google.maps.event.removeListener(_), L !== null && google.maps.event.removeListener(L), R !== null && google.maps.event.removeListener(R), V !== null && google.maps.event.removeListener(V), Z !== null && google.maps.event.removeListener(Z), X !== null && google.maps.event.removeListener(X), J !== null && google.maps.event.removeListener(J), D !== null && google.maps.event.removeListener(D), S !== null && google.maps.event.removeListener(S), x !== null && google.maps.event.removeListener(x), U !== null && google.maps.event.removeListener(U), q !== null && google.maps.event.removeListener(q), M && M(Y), Y.setMap(null);
    };
  }, []), null;
}
ve(DCe);
class TCe extends pe {
  constructor() {
    super(...arguments), xe(this, "registeredEvents", []), xe(this, "state", {
      rectangle: null
    }), xe(this, "setRectangleCallback", () => {
      this.state.rectangle !== null && this.props.onLoad && this.props.onLoad(this.state.rectangle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Rectangle(zv(zv({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = ln({
      updaterMap: sN,
      eventMap: iN,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        rectangle: t
      };
    }, this.setRectangleCallback);
  }
  componentDidUpdate(t) {
    this.state.rectangle !== null && (hn(this.registeredEvents), this.registeredEvents = ln({
      updaterMap: sN,
      eventMap: iN,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.rectangle
    }));
  }
  componentWillUnmount() {
    this.state.rectangle !== null && (this.props.onUnmount && this.props.onUnmount(this.state.rectangle), hn(this.registeredEvents), this.state.rectangle.setMap(null));
  }
  render() {
    return null;
  }
}
xe(TCe, "contextType", jt);
function aN(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Uv(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? aN(Object(n), !0).forEach(function(r) {
      xe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : aN(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var lN = {
  onCenterChanged: "center_changed",
  onRadiusChanged: "radius_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, uN = {
  center(e, t) {
    e.setCenter(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  radius(e, t) {
    e.setRadius(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, jCe = {};
function ACe(e) {
  var {
    options: t,
    center: n,
    radius: r,
    draggable: o,
    editable: i,
    visible: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: g,
    onMouseUp: f,
    onRightClick: m,
    onClick: v,
    onDrag: E,
    onCenterChanged: w,
    onRadiusChanged: M,
    onLoad: O,
    onUnmount: y
  } = e, C = ge(jt), [_, F] = k(null), [L, N] = k(null), [R, W] = k(null), [V, z] = k(null), [Z, K] = k(null), [X, te] = k(null), [J, P] = k(null), [D, H] = k(null), [S, $] = k(null), [x, j] = k(null), [U, T] = k(null), [q, A] = k(null), [Y, B] = k(null), [ue, fe] = k(null);
  return h(() => {
    _ !== null && _.setMap(C);
  }, [C]), h(() => {
    typeof t < "u" && _ !== null && _.setOptions(t);
  }, [_, t]), h(() => {
    typeof o < "u" && _ !== null && _.setDraggable(o);
  }, [_, o]), h(() => {
    typeof i < "u" && _ !== null && _.setEditable(i);
  }, [_, i]), h(() => {
    typeof a < "u" && _ !== null && _.setVisible(a);
  }, [_, a]), h(() => {
    typeof r == "number" && _ !== null && _.setRadius(r);
  }, [_, r]), h(() => {
    typeof n < "u" && _ !== null && _.setCenter(n);
  }, [_, n]), h(() => {
    _ && s && (L !== null && google.maps.event.removeListener(L), N(google.maps.event.addListener(_, "dblclick", s)));
  }, [s]), h(() => {
    _ && l && (R !== null && google.maps.event.removeListener(R), W(google.maps.event.addListener(_, "dragend", l)));
  }, [l]), h(() => {
    _ && u && (V !== null && google.maps.event.removeListener(V), z(google.maps.event.addListener(_, "dragstart", u)));
  }, [u]), h(() => {
    _ && c && (Z !== null && google.maps.event.removeListener(Z), K(google.maps.event.addListener(_, "mousedown", c)));
  }, [c]), h(() => {
    _ && p && (X !== null && google.maps.event.removeListener(X), te(google.maps.event.addListener(_, "mousemove", p)));
  }, [p]), h(() => {
    _ && d && (J !== null && google.maps.event.removeListener(J), P(google.maps.event.addListener(_, "mouseout", d)));
  }, [d]), h(() => {
    _ && g && (D !== null && google.maps.event.removeListener(D), H(google.maps.event.addListener(_, "mouseover", g)));
  }, [g]), h(() => {
    _ && f && (S !== null && google.maps.event.removeListener(S), $(google.maps.event.addListener(_, "mouseup", f)));
  }, [f]), h(() => {
    _ && m && (x !== null && google.maps.event.removeListener(x), j(google.maps.event.addListener(_, "rightclick", m)));
  }, [m]), h(() => {
    _ && v && (U !== null && google.maps.event.removeListener(U), T(google.maps.event.addListener(_, "click", v)));
  }, [v]), h(() => {
    _ && E && (q !== null && google.maps.event.removeListener(q), A(google.maps.event.addListener(_, "drag", E)));
  }, [E]), h(() => {
    _ && w && (Y !== null && google.maps.event.removeListener(Y), B(google.maps.event.addListener(_, "center_changed", w)));
  }, [v]), h(() => {
    _ && M && (ue !== null && google.maps.event.removeListener(ue), fe(google.maps.event.addListener(_, "radius_changed", M)));
  }, [M]), h(() => {
    var oe = new google.maps.Circle(Uv(Uv({}, t || jCe), {}, {
      map: C
    }));
    return typeof r == "number" && oe.setRadius(r), typeof n < "u" && oe.setCenter(n), typeof r == "number" && oe.setRadius(r), typeof a < "u" && oe.setVisible(a), typeof i < "u" && oe.setEditable(i), typeof o < "u" && oe.setDraggable(o), s && N(google.maps.event.addListener(oe, "dblclick", s)), l && W(google.maps.event.addListener(oe, "dragend", l)), u && z(google.maps.event.addListener(oe, "dragstart", u)), c && K(google.maps.event.addListener(oe, "mousedown", c)), p && te(google.maps.event.addListener(oe, "mousemove", p)), d && P(google.maps.event.addListener(oe, "mouseout", d)), g && H(google.maps.event.addListener(oe, "mouseover", g)), f && $(google.maps.event.addListener(oe, "mouseup", f)), m && j(google.maps.event.addListener(oe, "rightclick", m)), v && T(google.maps.event.addListener(oe, "click", v)), E && A(google.maps.event.addListener(oe, "drag", E)), w && B(google.maps.event.addListener(oe, "center_changed", w)), M && fe(google.maps.event.addListener(oe, "radius_changed", M)), F(oe), O && O(oe), () => {
      L !== null && google.maps.event.removeListener(L), R !== null && google.maps.event.removeListener(R), V !== null && google.maps.event.removeListener(V), Z !== null && google.maps.event.removeListener(Z), X !== null && google.maps.event.removeListener(X), J !== null && google.maps.event.removeListener(J), D !== null && google.maps.event.removeListener(D), S !== null && google.maps.event.removeListener(S), x !== null && google.maps.event.removeListener(x), U !== null && google.maps.event.removeListener(U), Y !== null && google.maps.event.removeListener(Y), ue !== null && google.maps.event.removeListener(ue), y && y(oe), oe.setMap(null);
    };
  }, []), null;
}
ve(ACe);
class ICe extends pe {
  constructor() {
    super(...arguments), xe(this, "registeredEvents", []), xe(this, "state", {
      circle: null
    }), xe(this, "setCircleCallback", () => {
      this.state.circle !== null && this.props.onLoad && this.props.onLoad(this.state.circle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Circle(Uv(Uv({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = ln({
      updaterMap: uN,
      eventMap: lN,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        circle: t
      };
    }, this.setCircleCallback);
  }
  componentDidUpdate(t) {
    this.state.circle !== null && (hn(this.registeredEvents), this.registeredEvents = ln({
      updaterMap: uN,
      eventMap: lN,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.circle
    }));
  }
  componentWillUnmount() {
    if (this.state.circle !== null) {
      var t;
      this.props.onUnmount && this.props.onUnmount(this.state.circle), hn(this.registeredEvents), (t = this.state.circle) === null || t === void 0 || t.setMap(null);
    }
  }
  render() {
    return null;
  }
}
xe(ICe, "contextType", jt);
function cN(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Hv(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? cN(Object(n), !0).forEach(function(r) {
      xe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : cN(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var pN = {
  onClick: "click",
  onDblClick: "dblclick",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onAddFeature: "addfeature",
  onRemoveFeature: "removefeature",
  onRemoveProperty: "removeproperty",
  onSetGeometry: "setgeometry",
  onSetProperty: "setproperty"
}, dN = {
  add(e, t) {
    e.add(t);
  },
  addgeojson(e, t, n) {
    e.addGeoJson(t, n);
  },
  contains(e, t) {
    e.contains(t);
  },
  foreach(e, t) {
    e.forEach(t);
  },
  loadgeojson(e, t, n, r) {
    e.loadGeoJson(t, n, r);
  },
  overridestyle(e, t, n) {
    e.overrideStyle(t, n);
  },
  remove(e, t) {
    e.remove(t);
  },
  revertstyle(e, t) {
    e.revertStyle(t);
  },
  controlposition(e, t) {
    e.setControlPosition(t);
  },
  controls(e, t) {
    e.setControls(t);
  },
  drawingmode(e, t) {
    e.setDrawingMode(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  style(e, t) {
    e.setStyle(t);
  },
  togeojson(e, t) {
    e.toGeoJson(t);
  }
};
function RCe(e) {
  var {
    options: t,
    onClick: n,
    onDblClick: r,
    onMouseDown: o,
    onMouseMove: i,
    onMouseOut: a,
    onMouseOver: s,
    onMouseUp: l,
    onRightClick: u,
    onAddFeature: c,
    onRemoveFeature: p,
    onRemoveProperty: d,
    onSetGeometry: g,
    onSetProperty: f,
    onLoad: m,
    onUnmount: v
  } = e, E = ge(jt), [w, M] = k(null), [O, y] = k(null), [C, _] = k(null), [F, L] = k(null), [N, R] = k(null), [W, V] = k(null), [z, Z] = k(null), [K, X] = k(null), [te, J] = k(null), [P, D] = k(null), [H, S] = k(null), [$, x] = k(null), [j, U] = k(null), [T, q] = k(null);
  return h(() => {
    w !== null && w.setMap(E);
  }, [E]), h(() => {
    w && r && (O !== null && google.maps.event.removeListener(O), y(google.maps.event.addListener(w, "dblclick", r)));
  }, [r]), h(() => {
    w && o && (C !== null && google.maps.event.removeListener(C), _(google.maps.event.addListener(w, "mousedown", o)));
  }, [o]), h(() => {
    w && i && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(w, "mousemove", i)));
  }, [i]), h(() => {
    w && a && (N !== null && google.maps.event.removeListener(N), R(google.maps.event.addListener(w, "mouseout", a)));
  }, [a]), h(() => {
    w && s && (W !== null && google.maps.event.removeListener(W), V(google.maps.event.addListener(w, "mouseover", s)));
  }, [s]), h(() => {
    w && l && (z !== null && google.maps.event.removeListener(z), Z(google.maps.event.addListener(w, "mouseup", l)));
  }, [l]), h(() => {
    w && u && (K !== null && google.maps.event.removeListener(K), X(google.maps.event.addListener(w, "rightclick", u)));
  }, [u]), h(() => {
    w && n && (te !== null && google.maps.event.removeListener(te), J(google.maps.event.addListener(w, "click", n)));
  }, [n]), h(() => {
    w && c && (P !== null && google.maps.event.removeListener(P), D(google.maps.event.addListener(w, "addfeature", c)));
  }, [c]), h(() => {
    w && p && (H !== null && google.maps.event.removeListener(H), S(google.maps.event.addListener(w, "removefeature", p)));
  }, [p]), h(() => {
    w && d && ($ !== null && google.maps.event.removeListener($), x(google.maps.event.addListener(w, "removeproperty", d)));
  }, [d]), h(() => {
    w && g && (j !== null && google.maps.event.removeListener(j), U(google.maps.event.addListener(w, "setgeometry", g)));
  }, [g]), h(() => {
    w && f && (T !== null && google.maps.event.removeListener(T), q(google.maps.event.addListener(w, "setproperty", f)));
  }, [f]), h(() => {
    if (E !== null) {
      var A = new google.maps.Data(Hv(Hv({}, t), {}, {
        map: E
      }));
      r && y(google.maps.event.addListener(A, "dblclick", r)), o && _(google.maps.event.addListener(A, "mousedown", o)), i && L(google.maps.event.addListener(A, "mousemove", i)), a && R(google.maps.event.addListener(A, "mouseout", a)), s && V(google.maps.event.addListener(A, "mouseover", s)), l && Z(google.maps.event.addListener(A, "mouseup", l)), u && X(google.maps.event.addListener(A, "rightclick", u)), n && J(google.maps.event.addListener(A, "click", n)), c && D(google.maps.event.addListener(A, "addfeature", c)), p && S(google.maps.event.addListener(A, "removefeature", p)), d && x(google.maps.event.addListener(A, "removeproperty", d)), g && U(google.maps.event.addListener(A, "setgeometry", g)), f && q(google.maps.event.addListener(A, "setproperty", f)), M(A), m && m(A);
    }
    return () => {
      w && (O !== null && google.maps.event.removeListener(O), C !== null && google.maps.event.removeListener(C), F !== null && google.maps.event.removeListener(F), N !== null && google.maps.event.removeListener(N), W !== null && google.maps.event.removeListener(W), z !== null && google.maps.event.removeListener(z), K !== null && google.maps.event.removeListener(K), te !== null && google.maps.event.removeListener(te), P !== null && google.maps.event.removeListener(P), H !== null && google.maps.event.removeListener(H), $ !== null && google.maps.event.removeListener($), j !== null && google.maps.event.removeListener(j), T !== null && google.maps.event.removeListener(T), v && v(w), w.setMap(null));
    };
  }, []), null;
}
ve(RCe);
class BCe extends pe {
  constructor() {
    super(...arguments), xe(this, "registeredEvents", []), xe(this, "state", {
      data: null
    }), xe(this, "setDataCallback", () => {
      this.state.data !== null && this.props.onLoad && this.props.onLoad(this.state.data);
    });
  }
  componentDidMount() {
    if (this.context !== null) {
      var t = new google.maps.Data(Hv(Hv({}, this.props.options), {}, {
        map: this.context
      }));
      this.registeredEvents = ln({
        updaterMap: dN,
        eventMap: pN,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        data: t
      }), this.setDataCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.data !== null && (hn(this.registeredEvents), this.registeredEvents = ln({
      updaterMap: dN,
      eventMap: pN,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.data
    }));
  }
  componentWillUnmount() {
    this.state.data !== null && (this.props.onUnmount && this.props.onUnmount(this.state.data), hn(this.registeredEvents), this.state.data && this.state.data.setMap(null));
  }
  render() {
    return null;
  }
}
xe(BCe, "contextType", jt);
function fN(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function hN(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? fN(Object(n), !0).forEach(function(r) {
      xe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : fN(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var gN = {
  onClick: "click",
  onDefaultViewportChanged: "defaultviewport_changed",
  onStatusChanged: "status_changed"
}, mN = {
  options(e, t) {
    e.setOptions(t);
  },
  url(e, t) {
    e.setUrl(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
class NCe extends pe {
  constructor() {
    super(...arguments), xe(this, "registeredEvents", []), xe(this, "state", {
      kmlLayer: null
    }), xe(this, "setKmlLayerCallback", () => {
      this.state.kmlLayer !== null && this.props.onLoad && this.props.onLoad(this.state.kmlLayer);
    });
  }
  componentDidMount() {
    var t = new google.maps.KmlLayer(hN(hN({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = ln({
      updaterMap: mN,
      eventMap: gN,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        kmlLayer: t
      };
    }, this.setKmlLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.kmlLayer !== null && (hn(this.registeredEvents), this.registeredEvents = ln({
      updaterMap: mN,
      eventMap: gN,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.kmlLayer
    }));
  }
  componentWillUnmount() {
    this.state.kmlLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.kmlLayer), hn(this.registeredEvents), this.state.kmlLayer.setMap(null));
  }
  render() {
    return null;
  }
}
xe(NCe, "contextType", jt);
function pq(e, t) {
  return typeof t == "function" ? t(e.offsetWidth, e.offsetHeight) : {
    x: 0,
    y: 0
  };
}
function FCe(e, t) {
  return new t(e.lat, e.lng);
}
function zCe(e, t) {
  return new t(new google.maps.LatLng(e.ne.lat, e.ne.lng), new google.maps.LatLng(e.sw.lat, e.sw.lng));
}
function UCe(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function HCe(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function $Ce(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n.getNorthEast()), o = e && e.fromLatLngToDivPixel(n.getSouthWest());
  return r && o ? {
    left: "".concat(o.x + t.x, "px"),
    top: "".concat(r.y + t.y, "px"),
    width: "".concat(r.x - o.x - t.x, "px"),
    height: "".concat(o.y - r.y - t.y, "px")
  } : {
    left: "-9999px",
    top: "-9999px"
  };
}
function WCe(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n);
  if (r) {
    var {
      x: o,
      y: i
    } = r;
    return {
      left: "".concat(o + t.x, "px"),
      top: "".concat(i + t.y, "px")
    };
  }
  return {
    left: "-9999px",
    top: "-9999px"
  };
}
function dq(e, t, n, r) {
  return n !== void 0 ? $Ce(e, t, HCe(n, google.maps.LatLngBounds, zCe)) : WCe(e, t, UCe(r, google.maps.LatLng, FCe));
}
function VCe(e, t) {
  return e.left === t.left && e.top === t.top && e.width === t.height && e.height === t.height;
}
function vN(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ZCe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? vN(Object(n), !0).forEach(function(r) {
      xe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : vN(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function qCe(e, t, n, r, o) {
  class i extends google.maps.OverlayView {
    constructor(s, l, u, c) {
      super(), this.container = s, this.pane = l, this.position = u, this.bounds = c;
    }
    onAdd() {
      var s, l = (s = this.getPanes()) === null || s === void 0 ? void 0 : s[this.pane];
      l == null || l.appendChild(this.container);
    }
    draw() {
      var s = this.getProjection(), l = ZCe({}, this.container ? pq(this.container, o) : {
        x: 0,
        y: 0
      }), u = dq(s, l, this.bounds, this.position);
      for (var [c, p] of Object.entries(u))
        this.container.style[c] = p;
    }
    onRemove() {
      this.container.parentNode !== null && this.container.parentNode.removeChild(this.container);
    }
  }
  return new i(e, t, n, r);
}
function yN(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function GCe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? yN(Object(n), !0).forEach(function(r) {
      xe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : yN(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function bN(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLng ? e : new google.maps.LatLng(e.lat, e.lng);
  return t + "";
}
function wN(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLngBounds ? e : new google.maps.LatLngBounds(new google.maps.LatLng(e.south, e.east), new google.maps.LatLng(e.north, e.west));
  return t + "";
}
function KCe(e) {
  var {
    position: t,
    bounds: n,
    mapPaneName: r,
    zIndex: o,
    onLoad: i,
    onUnmount: a,
    getPixelPositionOffset: s,
    children: l
  } = e, u = ge(jt), c = Cn(() => {
    var d = document.createElement("div");
    return d.style.position = "absolute", d;
  }, []), p = Cn(() => qCe(c, r, t, n, s), [c, r, t, n]);
  return h(() => (i == null || i(p), p == null || p.setMap(u), () => {
    a == null || a(p), p == null || p.setMap(null);
  }), [u, p]), h(() => {
    c.style.zIndex = "".concat(o);
  }, [o, c]), wi.createPortal(l, c);
}
ve(KCe);
class Dc extends pe {
  constructor(t) {
    super(t), xe(this, "state", {
      paneEl: null,
      containerStyle: {
        // set initial position
        position: "absolute"
      }
    }), xe(this, "updatePane", () => {
      var r = this.props.mapPaneName, o = this.overlayView.getPanes();
      bo(!!r, "OverlayView requires props.mapPaneName but got %s", r), o ? this.setState({
        paneEl: o[r]
      }) : this.setState({
        paneEl: null
      });
    }), xe(this, "onAdd", () => {
      var r, o;
      this.updatePane(), (r = (o = this.props).onLoad) === null || r === void 0 || r.call(o, this.overlayView);
    }), xe(this, "onPositionElement", () => {
      var r = this.overlayView.getProjection(), o = GCe({
        x: 0,
        y: 0
      }, this.containerRef.current ? pq(this.containerRef.current, this.props.getPixelPositionOffset) : {}), i = dq(r, o, this.props.bounds, this.props.position);
      if (!VCe(i, {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        left: this.state.containerStyle.left,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        top: this.state.containerStyle.top,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        width: this.state.containerStyle.width,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        height: this.state.containerStyle.height
      })) {
        var a, s, l, u;
        this.setState({
          containerStyle: {
            top: (a = i.top) !== null && a !== void 0 ? a : 0,
            left: (s = i.left) !== null && s !== void 0 ? s : 0,
            width: (l = i.width) !== null && l !== void 0 ? l : 0,
            height: (u = i.height) !== null && u !== void 0 ? u : 0,
            position: "absolute"
          }
        });
      }
    }), xe(this, "draw", () => {
      this.onPositionElement();
    }), xe(this, "onRemove", () => {
      var r, o;
      this.setState(() => ({
        paneEl: null
      })), (r = (o = this.props).onUnmount) === null || r === void 0 || r.call(o, this.overlayView);
    }), this.containerRef = mo();
    var n = new google.maps.OverlayView();
    n.onAdd = this.onAdd, n.draw = this.draw, n.onRemove = this.onRemove, this.overlayView = n;
  }
  componentDidMount() {
    this.overlayView.setMap(this.context);
  }
  componentDidUpdate(t) {
    var n = bN(t.position), r = bN(this.props.position), o = wN(t.bounds), i = wN(this.props.bounds);
    (n !== r || o !== i) && this.overlayView.draw(), t.mapPaneName !== this.props.mapPaneName && this.updatePane();
  }
  componentWillUnmount() {
    this.overlayView.setMap(null);
  }
  render() {
    var t = this.state.paneEl;
    return t ? wi.createPortal(Mo.jsx("div", {
      ref: this.containerRef,
      style: this.state.containerStyle,
      children: lt.only(this.props.children)
    }), t) : null;
  }
}
xe(Dc, "FLOAT_PANE", "floatPane");
xe(Dc, "MAP_PANE", "mapPane");
xe(Dc, "MARKER_LAYER", "markerLayer");
xe(Dc, "OVERLAY_LAYER", "overlayLayer");
xe(Dc, "OVERLAY_MOUSE_TARGET", "overlayMouseTarget");
xe(Dc, "contextType", jt);
function YCe() {
}
function CN(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function xN(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? CN(Object(n), !0).forEach(function(r) {
      xe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : CN(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var ON = {
  onDblClick: "dblclick",
  onClick: "click"
}, EN = {
  opacity(e, t) {
    e.setOpacity(t);
  }
};
function XCe(e) {
  var {
    url: t,
    bounds: n,
    options: r,
    visible: o
  } = e, i = ge(jt), a = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east)), s = Cn(() => new google.maps.GroundOverlay(t, a, r), []);
  return h(() => {
    s !== null && s.setMap(i);
  }, [i]), h(() => {
    typeof t < "u" && s !== null && (s.set("url", t), s.setMap(i));
  }, [s, t]), h(() => {
    typeof o < "u" && s !== null && s.setOpacity(o ? 1 : 0);
  }, [s, o]), h(() => {
    var l = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east));
    typeof n < "u" && s !== null && (s.set("bounds", l), s.setMap(i));
  }, [s, n]), null;
}
ve(XCe);
class fq extends pe {
  constructor() {
    super(...arguments), xe(this, "registeredEvents", []), xe(this, "state", {
      groundOverlay: null
    }), xe(this, "setGroundOverlayCallback", () => {
      this.state.groundOverlay !== null && this.props.onLoad && this.props.onLoad(this.state.groundOverlay);
    });
  }
  componentDidMount() {
    bo(!!this.props.url || !!this.props.bounds, "For GroundOverlay, url and bounds are passed in to constructor and are immutable after instantiated. This is the behavior of Google Maps JavaScript API v3 ( See https://developers.google.com/maps/documentation/javascript/reference#GroundOverlay) Hence, use the corresponding two props provided by `react-google-maps-api`, url and bounds. In some cases, you'll need the GroundOverlay component to reflect the changes of url and bounds. You can leverage the React's key property to remount the component. Typically, just `key={url}` would serve your need. See https://github.com/tomchentw/react-google-maps/issues/655");
    var t = new google.maps.GroundOverlay(this.props.url, this.props.bounds, xN(xN({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = ln({
      updaterMap: EN,
      eventMap: ON,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        groundOverlay: t
      };
    }, this.setGroundOverlayCallback);
  }
  componentDidUpdate(t) {
    this.state.groundOverlay !== null && (hn(this.registeredEvents), this.registeredEvents = ln({
      updaterMap: EN,
      eventMap: ON,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.groundOverlay
    }));
  }
  componentWillUnmount() {
    this.state.groundOverlay && (this.props.onUnmount && this.props.onUnmount(this.state.groundOverlay), this.state.groundOverlay.setMap(null));
  }
  render() {
    return null;
  }
}
xe(fq, "defaultProps", {
  onLoad: YCe
});
xe(fq, "contextType", jt);
function kN(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function $v(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? kN(Object(n), !0).forEach(function(r) {
      xe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : kN(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var LN = {}, PN = {
  data(e, t) {
    e.setData(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function JCe(e) {
  var {
    data: t,
    onLoad: n,
    onUnmount: r,
    options: o
  } = e, i = ge(jt), [a, s] = k(null);
  return h(() => {
    google.maps.visualization || bo(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} in useJsApiScript? %s', google.maps.visualization);
  }, []), h(() => {
    bo(!!t, "data property is required in HeatmapLayer %s", t);
  }, [t]), h(() => {
    a !== null && a.setMap(i);
  }, [i]), h(() => {
    o && a !== null && a.setOptions(o);
  }, [a, o]), h(() => {
    var l = new google.maps.visualization.HeatmapLayer($v($v({}, o), {}, {
      data: t,
      map: i
    }));
    return s(l), n && n(l), () => {
      a !== null && (r && r(a), a.setMap(null));
    };
  }, []), null;
}
ve(JCe);
class QCe extends pe {
  constructor() {
    super(...arguments), xe(this, "registeredEvents", []), xe(this, "state", {
      heatmapLayer: null
    }), xe(this, "setHeatmapLayerCallback", () => {
      this.state.heatmapLayer !== null && this.props.onLoad && this.props.onLoad(this.state.heatmapLayer);
    });
  }
  componentDidMount() {
    bo(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} to <LoadScript />? %s', google.maps.visualization), bo(!!this.props.data, "data property is required in HeatmapLayer %s", this.props.data);
    var t = new google.maps.visualization.HeatmapLayer($v($v({}, this.props.options), {}, {
      data: this.props.data,
      map: this.context
    }));
    this.registeredEvents = ln({
      updaterMap: PN,
      eventMap: LN,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        heatmapLayer: t
      };
    }, this.setHeatmapLayerCallback);
  }
  componentDidUpdate(t) {
    hn(this.registeredEvents), this.registeredEvents = ln({
      updaterMap: PN,
      eventMap: LN,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.heatmapLayer
    });
  }
  componentWillUnmount() {
    this.state.heatmapLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.heatmapLayer), hn(this.registeredEvents), this.state.heatmapLayer.setMap(null));
  }
  render() {
    return null;
  }
}
xe(QCe, "contextType", jt);
var _N = {
  onCloseClick: "closeclick",
  onPanoChanged: "pano_changed",
  onPositionChanged: "position_changed",
  onPovChanged: "pov_changed",
  onResize: "resize",
  onStatusChanged: "status_changed",
  onVisibleChanged: "visible_changed",
  onZoomChanged: "zoom_changed"
}, SN = {
  register(e, t, n) {
    e.registerPanoProvider(t, n);
  },
  links(e, t) {
    e.setLinks(t);
  },
  motionTracking(e, t) {
    e.setMotionTracking(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  pano(e, t) {
    e.setPano(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  pov(e, t) {
    e.setPov(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zoom(e, t) {
    e.setZoom(t);
  }
};
class exe extends pe {
  constructor() {
    super(...arguments), xe(this, "registeredEvents", []), xe(this, "state", {
      streetViewPanorama: null
    }), xe(this, "setStreetViewPanoramaCallback", () => {
      this.state.streetViewPanorama !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewPanorama);
    });
  }
  componentDidMount() {
    var t, n, r = (t = (n = this.context) === null || n === void 0 ? void 0 : n.getStreetView()) !== null && t !== void 0 ? t : null;
    this.registeredEvents = ln({
      updaterMap: SN,
      eventMap: _N,
      prevProps: {},
      nextProps: this.props,
      instance: r
    }), this.setState(() => ({
      streetViewPanorama: r
    }), this.setStreetViewPanoramaCallback);
  }
  componentDidUpdate(t) {
    this.state.streetViewPanorama !== null && (hn(this.registeredEvents), this.registeredEvents = ln({
      updaterMap: SN,
      eventMap: _N,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.streetViewPanorama
    }));
  }
  componentWillUnmount() {
    this.state.streetViewPanorama !== null && (this.props.onUnmount && this.props.onUnmount(this.state.streetViewPanorama), hn(this.registeredEvents), this.state.streetViewPanorama.setVisible(!1));
  }
  render() {
    return null;
  }
}
xe(exe, "contextType", jt);
class txe extends pe {
  constructor() {
    super(...arguments), xe(this, "state", {
      streetViewService: null
    }), xe(this, "setStreetViewServiceCallback", () => {
      this.state.streetViewService !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewService);
    });
  }
  componentDidMount() {
    var t = new google.maps.StreetViewService();
    this.setState(function() {
      return {
        streetViewService: t
      };
    }, this.setStreetViewServiceCallback);
  }
  componentWillUnmount() {
    this.state.streetViewService !== null && this.props.onUnmount && this.props.onUnmount(this.state.streetViewService);
  }
  render() {
    return null;
  }
}
xe(txe, "contextType", jt);
var MN = {
  onDirectionsChanged: "directions_changed"
}, DN = {
  directions(e, t) {
    e.setDirections(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  panel(e, t) {
    e.setPanel(t);
  },
  routeIndex(e, t) {
    e.setRouteIndex(t);
  }
};
class nxe extends pe {
  constructor() {
    super(...arguments), xe(this, "registeredEvents", []), xe(this, "state", {
      directionsRenderer: null
    }), xe(this, "setDirectionsRendererCallback", () => {
      this.state.directionsRenderer !== null && (this.state.directionsRenderer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.directionsRenderer));
    });
  }
  componentDidMount() {
    var t = new google.maps.DirectionsRenderer(this.props.options);
    this.registeredEvents = ln({
      updaterMap: DN,
      eventMap: MN,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        directionsRenderer: t
      };
    }, this.setDirectionsRendererCallback);
  }
  componentDidUpdate(t) {
    this.state.directionsRenderer !== null && (hn(this.registeredEvents), this.registeredEvents = ln({
      updaterMap: DN,
      eventMap: MN,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.directionsRenderer
    }));
  }
  componentWillUnmount() {
    this.state.directionsRenderer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.directionsRenderer), hn(this.registeredEvents), this.state.directionsRenderer && this.state.directionsRenderer.setMap(null));
  }
  render() {
    return null;
  }
}
xe(nxe, "contextType", jt);
var TN = {
  onPlacesChanged: "places_changed"
}, jN = {
  bounds(e, t) {
    e.setBounds(t);
  }
};
class rxe extends pe {
  constructor() {
    super(...arguments), xe(this, "registeredEvents", []), xe(this, "containerElement", mo()), xe(this, "state", {
      searchBox: null
    }), xe(this, "setSearchBoxCallback", () => {
      this.state.searchBox !== null && this.props.onLoad && this.props.onLoad(this.state.searchBox);
    });
  }
  componentDidMount() {
    if (bo(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places), this.containerElement !== null && this.containerElement.current !== null) {
      var t = this.containerElement.current.querySelector("input");
      if (t !== null) {
        var n = new google.maps.places.SearchBox(t, this.props.options);
        this.registeredEvents = ln({
          updaterMap: jN,
          eventMap: TN,
          prevProps: {},
          nextProps: this.props,
          instance: n
        }), this.setState(function() {
          return {
            searchBox: n
          };
        }, this.setSearchBoxCallback);
      }
    }
  }
  componentDidUpdate(t) {
    this.state.searchBox !== null && (hn(this.registeredEvents), this.registeredEvents = ln({
      updaterMap: jN,
      eventMap: TN,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.searchBox
    }));
  }
  componentWillUnmount() {
    this.state.searchBox !== null && (this.props.onUnmount && this.props.onUnmount(this.state.searchBox), hn(this.registeredEvents));
  }
  render() {
    return Mo.jsx("div", {
      ref: this.containerElement,
      children: lt.only(this.props.children)
    });
  }
}
xe(rxe, "contextType", jt);
var AN = {
  onPlaceChanged: "place_changed"
}, IN = {
  bounds(e, t) {
    e.setBounds(t);
  },
  restrictions(e, t) {
    e.setComponentRestrictions(t);
  },
  fields(e, t) {
    e.setFields(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  types(e, t) {
    e.setTypes(t);
  }
};
class hq extends pe {
  constructor() {
    super(...arguments), xe(this, "registeredEvents", []), xe(this, "containerElement", mo()), xe(this, "state", {
      autocomplete: null
    }), xe(this, "setAutocompleteCallback", () => {
      this.state.autocomplete !== null && this.props.onLoad && this.props.onLoad(this.state.autocomplete);
    });
  }
  componentDidMount() {
    var t;
    bo(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places);
    var n = (t = this.containerElement.current) === null || t === void 0 ? void 0 : t.querySelector("input");
    if (n) {
      var r = new google.maps.places.Autocomplete(n, this.props.options);
      this.registeredEvents = ln({
        updaterMap: IN,
        eventMap: AN,
        prevProps: {},
        nextProps: this.props,
        instance: r
      }), this.setState(() => ({
        autocomplete: r
      }), this.setAutocompleteCallback);
    }
  }
  componentDidUpdate(t) {
    hn(this.registeredEvents), this.registeredEvents = ln({
      updaterMap: IN,
      eventMap: AN,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.autocomplete
    });
  }
  componentWillUnmount() {
    this.state.autocomplete !== null && hn(this.registeredEvents);
  }
  render() {
    return Mo.jsx("div", {
      ref: this.containerElement,
      className: this.props.className,
      children: lt.only(this.props.children)
    });
  }
}
xe(hq, "defaultProps", {
  className: ""
});
xe(hq, "contextType", jt);
let oxe = { data: "" }, ixe = (e) => typeof window == "object" ? ((e ? e.querySelector("#_goober") : window._goober) || Object.assign((e || document.head).appendChild(document.createElement("style")), { innerHTML: " ", id: "_goober" })).firstChild : e || oxe, sxe = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g, axe = /\/\*[^]*?\*\/|  +/g, RN = /\n+/g, el = (e, t) => {
  let n = "", r = "", o = "";
  for (let i in e) {
    let a = e[i];
    i[0] == "@" ? i[1] == "i" ? n = i + " " + a + ";" : r += i[1] == "f" ? el(a, i) : i + "{" + el(a, i[1] == "k" ? "" : t) + "}" : typeof a == "object" ? r += el(a, t ? t.replace(/([^,])+/g, (s) => i.replace(/([^,]*:\S+\([^)]*\))|([^,])+/g, (l) => /&/.test(l) ? l.replace(/&/g, s) : s ? s + " " + l : l)) : i) : a != null && (i = /^--/.test(i) ? i : i.replace(/[A-Z]/g, "-$&").toLowerCase(), o += el.p ? el.p(i, a) : i + ":" + a + ";");
  }
  return n + (t && o ? t + "{" + o + "}" : o) + r;
}, Gs = {}, gq = (e) => {
  if (typeof e == "object") {
    let t = "";
    for (let n in e) t += n + gq(e[n]);
    return t;
  }
  return e;
}, lxe = (e, t, n, r, o) => {
  let i = gq(e), a = Gs[i] || (Gs[i] = ((l) => {
    let u = 0, c = 11;
    for (; u < l.length; ) c = 101 * c + l.charCodeAt(u++) >>> 0;
    return "go" + c;
  })(i));
  if (!Gs[a]) {
    let l = i !== e ? e : ((u) => {
      let c, p, d = [{}];
      for (; c = sxe.exec(u.replace(axe, "")); ) c[4] ? d.shift() : c[3] ? (p = c[3].replace(RN, " ").trim(), d.unshift(d[0][p] = d[0][p] || {})) : d[0][c[1]] = c[2].replace(RN, " ").trim();
      return d[0];
    })(e);
    Gs[a] = el(o ? { ["@keyframes " + a]: l } : l, n ? "" : "." + a);
  }
  let s = n && Gs.g ? Gs.g : null;
  return n && (Gs.g = Gs[a]), ((l, u, c, p) => {
    p ? u.data = u.data.replace(p, l) : u.data.indexOf(l) === -1 && (u.data = c ? l + u.data : u.data + l);
  })(Gs[a], t, r, s), a;
}, uxe = (e, t, n) => e.reduce((r, o, i) => {
  let a = t[i];
  if (a && a.call) {
    let s = a(n), l = s && s.props && s.props.className || /^go/.test(s) && s;
    a = l ? "." + l : s && typeof s == "object" ? s.props ? "" : el(s, "") : s === !1 ? "" : s;
  }
  return r + o + (a ?? "");
}, "");
function Aw(e) {
  let t = this || {}, n = e.call ? e(t.p) : e;
  return lxe(n.unshift ? n.raw ? uxe(n, [].slice.call(arguments, 1), t.p) : n.reduce((r, o) => Object.assign(r, o && o.call ? o(t.p) : o), {}) : n, ixe(t.target), t.g, t.o, t.k);
}
let mq, Ek, kk;
Aw.bind({ g: 1 });
let ua = Aw.bind({ k: 1 });
function cxe(e, t, n, r) {
  el.p = t, mq = e, Ek = n, kk = r;
}
function Pl(e, t) {
  let n = this || {};
  return function() {
    let r = arguments;
    function o(i, a) {
      let s = Object.assign({}, i), l = s.className || o.className;
      n.p = Object.assign({ theme: Ek && Ek() }, s), n.o = / *go\d+/.test(l), s.className = Aw.apply(n, r) + (l ? " " + l : "");
      let u = e;
      return e[0] && (u = s.as || e, delete s.as), kk && u[0] && kk(s), mq(u, s);
    }
    return o;
  };
}
var pxe = (e) => typeof e == "function", dxe = (e, t) => pxe(e) ? e(t) : e, fxe = /* @__PURE__ */ (() => {
  let e;
  return () => {
    if (e === void 0 && typeof window < "u") {
      let t = matchMedia("(prefers-reduced-motion: reduce)");
      e = !t || t.matches;
    }
    return e;
  };
})(), hxe = ua`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`, gxe = ua`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`, mxe = ua`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`, vxe = Pl("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${hxe} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${gxe} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${(e) => e.secondary || "#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${mxe} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`, yxe = ua`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, bxe = Pl("div")`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${(e) => e.secondary || "#e0e0e0"};
  border-right-color: ${(e) => e.primary || "#616161"};
  animation: ${yxe} 1s linear infinite;
`, wxe = ua`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`, Cxe = ua`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`, xxe = Pl("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${wxe} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${Cxe} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${(e) => e.secondary || "#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`, Oxe = Pl("div")`
  position: absolute;
`, Exe = Pl("div")`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`, kxe = ua`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`, Lxe = Pl("div")`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${kxe} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`, Pxe = ({ toast: e }) => {
  let { icon: t, type: n, iconTheme: r } = e;
  return t !== void 0 ? typeof t == "string" ? Be.createElement(Lxe, null, t) : t : n === "blank" ? null : Be.createElement(Exe, null, Be.createElement(bxe, { ...r }), n !== "loading" && Be.createElement(Oxe, null, n === "error" ? Be.createElement(vxe, { ...r }) : Be.createElement(xxe, { ...r })));
}, _xe = (e) => `
0% {transform: translate3d(0,${e * -200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`, Sxe = (e) => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${e * -150}%,-1px) scale(.6); opacity:0;}
`, Mxe = "0%{opacity:0;} 100%{opacity:1;}", Dxe = "0%{opacity:1;} 100%{opacity:0;}", Txe = Pl("div")`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`, jxe = Pl("div")`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`, Axe = (e, t) => {
  let n = e.includes("top") ? 1 : -1, [r, o] = fxe() ? [Mxe, Dxe] : [_xe(n), Sxe(n)];
  return { animation: t ? `${ua(r)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards` : `${ua(o)} 0.4s forwards cubic-bezier(.06,.71,.55,1)` };
};
Be.memo(({ toast: e, position: t, style: n, children: r }) => {
  let o = e.height ? Axe(e.position || t || "top-center", e.visible) : { opacity: 0 }, i = Be.createElement(Pxe, { toast: e }), a = Be.createElement(jxe, { ...e.ariaProps }, dxe(e.message, e));
  return Be.createElement(Txe, { className: e.className, style: { ...o, ...n, ...e.style } }, typeof r == "function" ? r({ icon: i, message: a }) : Be.createElement(Be.Fragment, null, i, a));
});
cxe(Be.createElement);
Aw`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`;
Ke({});
function Ixe(e) {
  return e && e.replace(/[^0-9]/g, "");
}
const Rxe = {
  CNPJ: "99.999.999/9999-99"
};
Ixe(Rxe.CNPJ).length;
to((e, t) => /* @__PURE__ */ So.jsx("input", { ref: t, ...e }));
function vq(e) {
  return e && e.replace(/[^0-9]/g, "");
}
const yq = {
  EIGTH: "(99) 9999-9999",
  NINE: "(99) 99999-9999"
};
function Bxe(e, t) {
  let n = "", r = 0;
  for (let o = 0; o < t.length; o++)
    if (t[o] === "9")
      if (r < e.length)
        n += e[r], r++;
      else
        break;
    else if (r < e.length)
      n += t[o];
    else
      break;
  return n;
}
function Nxe(e) {
  return e.length > 10 ? "NINE" : "EIGTH";
}
const Fxe = vq(yq.NINE).length, zxe = to((e, t) => /* @__PURE__ */ So.jsx("input", { ref: t, ...e }));
to(
  (e, t) => {
    const { onFocus: n, onBlur: r, size: o, onChange: i, value: a, currentCountry: s, disabled: l } = e, [u, c] = k(!1);
    h(() => {
      u ? i(s.mask) : c(!0);
    }, [s]);
    const p = `phoneInputMask ${o}`;
    function d(g) {
      let f = vq(g.target.value);
      const m = Nxe(f);
      f.length > Fxe || (f = Bxe(f, yq[m]), g.target.value = f, i(f));
    }
    return s.code === "+55" ? /* @__PURE__ */ So.jsx(
      "input",
      {
        value: a,
        onChange: d,
        className: p,
        onFocus: n,
        onBlur: r,
        disabled: l,
        ref: t
      }
    ) : /* @__PURE__ */ So.jsx(
      cl,
      {
        value: a,
        onChange: (g) => i(g.target.value),
        className: p,
        component: zxe,
        onFocus: n,
        onBlur: r,
        disabled: l,
        mask: s.mask,
        showMask: !0,
        replacement: { _: /\d/ },
        ref: t
      }
    );
  }
);
Ke({});
var va = {};
Object.defineProperty(va, "__esModule", {
  value: !0
});
var Uxe = typeof window < "u" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform), VC = {
  alt: "altKey",
  control: "ctrlKey",
  meta: "metaKey",
  shift: "shiftKey"
}, bq = {
  add: "+",
  break: "pause",
  cmd: "meta",
  command: "meta",
  ctl: "control",
  ctrl: "control",
  del: "delete",
  down: "arrowdown",
  esc: "escape",
  ins: "insert",
  left: "arrowleft",
  mod: Uxe ? "meta" : "control",
  opt: "alt",
  option: "alt",
  return: "enter",
  right: "arrowright",
  space: " ",
  spacebar: " ",
  up: "arrowup",
  win: "meta",
  windows: "meta"
}, o_ = {
  backspace: 8,
  tab: 9,
  enter: 13,
  shift: 16,
  control: 17,
  alt: 18,
  pause: 19,
  capslock: 20,
  escape: 27,
  " ": 32,
  pageup: 33,
  pagedown: 34,
  end: 35,
  home: 36,
  arrowleft: 37,
  arrowup: 38,
  arrowright: 39,
  arrowdown: 40,
  insert: 45,
  delete: 46,
  meta: 91,
  numlock: 144,
  scrolllock: 145,
  ";": 186,
  "=": 187,
  ",": 188,
  "-": 189,
  ".": 190,
  "/": 191,
  "`": 192,
  "[": 219,
  "\\": 220,
  "]": 221,
  "'": 222
};
for (var Cg = 1; Cg < 20; Cg++)
  o_["f" + Cg] = 111 + Cg;
function Iw(e, t, n) {
  t && !("byKey" in t) && (n = t, t = null), Array.isArray(e) || (e = [e]);
  var r = e.map(function(a) {
    return wq(a, t);
  }), o = function(a) {
    return r.some(function(s) {
      return Cq(s, a);
    });
  }, i = n == null ? o : o(n);
  return i;
}
function Hxe(e, t) {
  return Iw(e, t);
}
function $xe(e, t) {
  return Iw(e, { byKey: !0 }, t);
}
function wq(e, t) {
  var n = t && t.byKey, r = {};
  e = e.replace("++", "+add");
  var o = e.split("+"), i = o.length;
  for (var a in VC)
    r[VC[a]] = !1;
  var s = !0, l = !1, u = void 0;
  try {
    for (var c = o[Symbol.iterator](), p; !(s = (p = c.next()).done); s = !0) {
      var d = p.value, g = d.endsWith("?") && d.length > 1;
      g && (d = d.slice(0, -1));
      var f = i_(d), m = VC[f];
      if (d.length > 1 && !m && !bq[d] && !o_[f])
        throw new TypeError('Unknown modifier: "' + d + '"');
      (i === 1 || !m) && (n ? r.key = f : r.which = xq(d)), m && (r[m] = g ? null : !0);
    }
  } catch (v) {
    l = !0, u = v;
  } finally {
    try {
      !s && c.return && c.return();
    } finally {
      if (l)
        throw u;
    }
  }
  return r;
}
function Cq(e, t) {
  for (var n in e) {
    var r = e[n], o = void 0;
    if (r != null && (n === "key" && t.key != null ? o = t.key.toLowerCase() : n === "which" ? o = r === 91 && t.which === 93 ? 91 : t.which : o = t[n], !(o == null && r === !1) && o !== r))
      return !1;
  }
  return !0;
}
function xq(e) {
  e = i_(e);
  var t = o_[e] || e.toUpperCase().charCodeAt(0);
  return t;
}
function i_(e) {
  return e = e.toLowerCase(), e = bq[e] || e, e;
}
va.default = Iw;
var ZC = va.isHotkey = Iw;
va.isCodeHotkey = Hxe;
va.isKeyHotkey = $xe;
va.parseHotkey = wq;
va.compareHotkey = Cq;
va.toKeyCode = xq;
va.toKeyName = i_;
var Wxe = typeof tr == "object" && tr && tr.Object === Object && tr, Vxe = Wxe, Zxe = Vxe, qxe = typeof self == "object" && self && self.Object === Object && self, Gxe = Zxe || qxe || Function("return this")(), Kxe = Gxe, Yxe = Kxe, Xxe = Yxe.Symbol, Oq = Xxe, BN = Oq;
BN && BN.toStringTag;
var NN = Oq;
NN && NN.toStringTag;
var FN;
(function(e) {
  e.BORDER_BOX = "border-box", e.CONTENT_BOX = "content-box", e.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(FN || (FN = {}));
var s_ = function(e) {
  return Object.freeze(e);
}, Jxe = /* @__PURE__ */ function() {
  function e(t, n) {
    this.inlineSize = t, this.blockSize = n, s_(this);
  }
  return e;
}(), Qxe = function() {
  function e(t, n, r, o) {
    return this.x = t, this.y = n, this.width = r, this.height = o, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, s_(this);
  }
  return e.prototype.toJSON = function() {
    var t = this, n = t.x, r = t.y, o = t.top, i = t.right, a = t.bottom, s = t.left, l = t.width, u = t.height;
    return { x: n, y: r, top: o, right: i, bottom: a, left: s, width: l, height: u };
  }, e.fromRect = function(t) {
    return new e(t.x, t.y, t.width, t.height);
  }, e;
}(), zN = typeof window < "u" ? window : {};
/msie|trident/i.test(zN.navigator && zN.navigator.userAgent);
var qC = function(e, t, n) {
  return e === void 0 && (e = 0), t === void 0 && (t = 0), n === void 0 && (n = !1), new Jxe((n ? t : e) || 0, (n ? e : t) || 0);
};
s_({
  devicePixelContentBoxSize: qC(),
  borderBoxSize: qC(),
  contentBoxSize: qC(),
  contentRect: new Qxe(0, 0, 0, 0)
});
function nf(e) {
  "@babel/helpers - typeof";
  return nf = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, nf(e);
}
function eOe(e, t) {
  if (nf(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (nf(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function tOe(e) {
  var t = eOe(e, "string");
  return nf(t) === "symbol" ? t : String(t);
}
function od(e, t, n) {
  return t = tOe(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
var nOe = /* @__PURE__ */ Ke(null), GC, KC;
parseInt(we.version.split(".")[0], 10);
var UN = typeof navigator < "u" && /Mac OS X/.test(navigator.userAgent), YC = typeof navigator < "u" && /Android/.test(navigator.userAgent), xg = typeof navigator < "u" && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent), rOe = typeof navigator < "u" && /Chrome/i.test(navigator.userAgent);
typeof navigator < "u" && /Safari/.test(navigator.userAgent) && /Version\/(\d+)/.test(navigator.userAgent) && (GC = navigator.userAgent.match(/Version\/(\d+)/)) !== null && GC !== void 0 && GC[1] && parseInt((KC = navigator.userAgent.match(/Version\/(\d+)/)) === null || KC === void 0 ? void 0 : KC[1], 10) < 17;
var oOe = /* @__PURE__ */ new WeakMap(), iOe = /* @__PURE__ */ new WeakMap(), sOe = /* @__PURE__ */ new WeakMap(), aOe = /* @__PURE__ */ new WeakMap(), lOe = /* @__PURE__ */ new WeakMap(), HN = /* @__PURE__ */ new WeakMap(), uOe = /* @__PURE__ */ new WeakMap(), $N = /* @__PURE__ */ new WeakMap(), Og = /* @__PURE__ */ new WeakMap(), cOe = /* @__PURE__ */ new WeakMap(), pOe = /* @__PURE__ */ new WeakMap(), dOe = /* @__PURE__ */ new WeakMap(), Eq = globalThis.Node, fOe = globalThis.Text, kq = (e) => e && e.ownerDocument && e.ownerDocument.defaultView || null, hOe = (e) => Wv(e) && e.nodeType === 8, _s = (e) => Wv(e) && e.nodeType === 1, Wv = (e) => {
  var t = kq(e);
  return !!t && e instanceof t.Node;
}, WN = (e) => {
  var t = e && e.anchorNode && kq(e.anchorNode);
  return !!t && e instanceof t.Selection;
}, gOe = (e) => {
  var [t, n] = e;
  if (_s(t) && t.childNodes.length) {
    var r = n === t.childNodes.length, o = r ? n - 1 : n;
    for ([t, o] = Lq(t, o, r ? "backward" : "forward"), r = o < n; _s(t) && t.childNodes.length; ) {
      var i = r ? t.childNodes.length - 1 : 0;
      t = vOe(t, i, r ? "backward" : "forward");
    }
    n = r && t.textContent != null ? t.textContent.length : 0;
  }
  return [t, n];
}, mOe = (e) => {
  for (var t = e && e.parentNode; t; ) {
    if (t.toString() === "[object ShadowRoot]")
      return !0;
    t = t.parentNode;
  }
  return !1;
}, Lq = (e, t, n) => {
  for (var {
    childNodes: r
  } = e, o = r[t], i = t, a = !1, s = !1; (hOe(o) || _s(o) && o.childNodes.length === 0 || _s(o) && o.getAttribute("contenteditable") === "false") && !(a && s); ) {
    if (i >= r.length) {
      a = !0, i = t - 1, n = "backward";
      continue;
    }
    if (i < 0) {
      s = !0, i = t + 1, n = "forward";
      continue;
    }
    o = r[i], t = i, i += n === "forward" ? 1 : -1;
  }
  return [o, t];
}, vOe = (e, t, n) => {
  var [r] = Lq(e, t, n);
  return r;
}, VN = (e) => e.getSelection != null ? e.getSelection() : document.getSelection(), Pq = (e, t, n) => {
  var {
    target: r
  } = t;
  if (_s(r) && r.matches('[contentEditable="false"]'))
    return !1;
  var {
    document: o
  } = nn.getWindow(e);
  if (o.contains(r))
    return nn.hasDOMNode(e, r, {
      editable: !0
    });
  var i = n.find((a) => {
    var {
      addedNodes: s,
      removedNodes: l
    } = a;
    for (var u of s)
      if (u === r || u.contains(r))
        return !0;
    for (var c of l)
      if (c === r || c.contains(r))
        return !0;
  });
  return !i || i === t ? !1 : Pq(e, i, n);
}, ZN = (e, t) => !!(e.compareDocumentPosition(t) & Eq.DOCUMENT_POSITION_PRECEDING), yOe = (e, t) => !!(e.compareDocumentPosition(t) & Eq.DOCUMENT_POSITION_FOLLOWING), bOe = 0;
class wOe {
  constructor() {
    od(this, "id", void 0), this.id = "".concat(bOe++);
  }
}
var nn = {
  androidPendingDiffs: (e) => dOe.get(e),
  androidScheduleFlush: (e) => {
    var t;
    (t = pOe.get(e)) === null || t === void 0 || t();
  },
  blur: (e) => {
    var t = nn.toDOMNode(e, e), n = nn.findDocumentOrShadowRoot(e);
    Og.set(e, !1), n.activeElement === t && t.blur();
  },
  deselect: (e) => {
    var {
      selection: t
    } = e, n = nn.findDocumentOrShadowRoot(e), r = VN(n);
    r && r.rangeCount > 0 && r.removeAllRanges(), t && cv.deselect(e);
  },
  findDocumentOrShadowRoot: (e) => {
    var t = nn.toDOMNode(e, e), n = t.getRootNode();
    return n instanceof Document || n instanceof ShadowRoot ? n : t.ownerDocument;
  },
  findEventRange: (e, t) => {
    "nativeEvent" in t && (t = t.nativeEvent);
    var {
      clientX: n,
      clientY: r,
      target: o
    } = t;
    if (n == null || r == null)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var i = nn.toSlateNode(e, t.target), a = nn.findPath(e, i);
    if (ra.isElement(i) && Gn.isVoid(e, i)) {
      var s = o.getBoundingClientRect(), l = e.isInline(i) ? n - s.left < s.left + s.width - n : r - s.top < s.top + s.height - r, u = Gn.point(e, a, {
        edge: l ? "start" : "end"
      }), c = l ? Gn.before(e, u) : Gn.after(e, u);
      if (c) {
        var p = Gn.range(e, c);
        return p;
      }
    }
    var d, {
      document: g
    } = nn.getWindow(e);
    if (g.caretRangeFromPoint)
      d = g.caretRangeFromPoint(n, r);
    else {
      var f = g.caretPositionFromPoint(n, r);
      f && (d = g.createRange(), d.setStart(f.offsetNode, f.offset), d.setEnd(f.offsetNode, f.offset));
    }
    if (!d)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var m = nn.toSlateRange(e, d, {
      exactMatch: !1,
      suppressThrow: !1
    });
    return m;
  },
  findKey: (e, t) => {
    var n = HN.get(t);
    return n || (n = new wOe(), HN.set(t, n)), n;
  },
  findPath: (e, t) => {
    for (var n = [], r = t; ; ) {
      var o = iOe.get(r);
      if (o == null) {
        if (Gn.isEditor(r))
          return n;
        break;
      }
      var i = oOe.get(r);
      if (i == null)
        break;
      n.unshift(i), r = o;
    }
    throw new Error("Unable to find the path for Slate node: ".concat(Mi.stringify(t)));
  },
  focus: function(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      retries: 5
    };
    if (!Og.get(e)) {
      if (t.retries <= 0)
        throw new Error("Could not set focus, editor seems stuck with pending operations");
      if (e.operations.length > 0) {
        setTimeout(() => {
          nn.focus(e, {
            retries: t.retries - 1
          });
        }, 10);
        return;
      }
      var n = nn.toDOMNode(e, e), r = nn.findDocumentOrShadowRoot(e);
      if (r.activeElement !== n) {
        if (e.selection && r instanceof Document) {
          var o = VN(r), i = nn.toDOMRange(e, e.selection);
          o == null || o.removeAllRanges(), o == null || o.addRange(i);
        }
        e.selection || cv.select(e, Gn.start(e, [])), Og.set(e, !0), n.focus({
          preventScroll: !0
        });
      }
    }
  },
  getWindow: (e) => {
    var t = sOe.get(e);
    if (!t)
      throw new Error("Unable to find a host window element for this editor");
    return t;
  },
  hasDOMNode: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      editable: r = !1
    } = n, o = nn.toDOMNode(e, e), i;
    try {
      i = _s(t) ? t : t.parentElement;
    } catch (a) {
      if (a instanceof Error && !a.message.includes('Permission denied to access property "nodeType"'))
        throw a;
    }
    return i ? i.closest("[data-slate-editor]") === o && (!r || i.isContentEditable ? !0 : typeof i.isContentEditable == "boolean" && // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined
    // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable="false"(readOnly)
    i.closest('[contenteditable="false"]') === o || !!i.getAttribute("data-slate-zero-width")) : !1;
  },
  hasEditableTarget: (e, t) => Wv(t) && nn.hasDOMNode(e, t, {
    editable: !0
  }),
  hasRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t;
    return Gn.hasPath(e, n.path) && Gn.hasPath(e, r.path);
  },
  hasSelectableTarget: (e, t) => nn.hasEditableTarget(e, t) || nn.isTargetInsideNonReadonlyVoid(e, t),
  hasTarget: (e, t) => Wv(t) && nn.hasDOMNode(e, t),
  insertData: (e, t) => {
    e.insertData(t);
  },
  insertFragmentData: (e, t) => e.insertFragmentData(t),
  insertTextData: (e, t) => e.insertTextData(t),
  isComposing: (e) => !!cOe.get(e),
  isFocused: (e) => !!Og.get(e),
  isReadOnly: (e) => !!$N.get(e),
  isTargetInsideNonReadonlyVoid: (e, t) => {
    if ($N.get(e)) return !1;
    var n = nn.hasTarget(e, t) && nn.toSlateNode(e, t);
    return ra.isElement(n) && Gn.isVoid(e, n);
  },
  setFragmentData: (e, t, n) => e.setFragmentData(t, n),
  toDOMNode: (e, t) => {
    var n = uOe.get(e), r = Gn.isEditor(t) ? aOe.get(e) : n == null ? void 0 : n.get(nn.findKey(e, t));
    if (!r)
      throw new Error("Cannot resolve a DOM node from Slate node: ".concat(Mi.stringify(t)));
    return r;
  },
  toDOMPoint: (e, t) => {
    var [n] = Gn.node(e, t.path), r = nn.toDOMNode(e, n), o;
    Gn.void(e, {
      at: t
    }) && (t = {
      path: t.path,
      offset: 0
    });
    for (var i = "[data-slate-string], [data-slate-zero-width]", a = Array.from(r.querySelectorAll(i)), s = 0, l = 0; l < a.length; l++) {
      var u = a[l], c = u.childNodes[0];
      if (!(c == null || c.textContent == null)) {
        var {
          length: p
        } = c.textContent, d = u.getAttribute("data-slate-length"), g = d == null ? p : parseInt(d, 10), f = s + g, m = a[l + 1];
        if (t.offset === f && m !== null && m !== void 0 && m.hasAttribute("data-slate-mark-placeholder")) {
          var v, E = m.childNodes[0];
          o = [
            // COMPAT: If we don't explicity set the dom point to be on the actual
            // dom text element, chrome will put the selection behind the actual dom
            // text element, causing domRange.getBoundingClientRect() calls on a collapsed
            // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)
            // which will cause issues when scrolling to it.
            E instanceof fOe ? E : m,
            (v = m.textContent) !== null && v !== void 0 && v.startsWith("\uFEFF") ? 1 : 0
          ];
          break;
        }
        if (t.offset <= f) {
          var w = Math.min(p, Math.max(0, t.offset - s));
          o = [c, w];
          break;
        }
        s = f;
      }
    }
    if (!o)
      throw new Error("Cannot resolve a DOM point from Slate point: ".concat(Mi.stringify(t)));
    return o;
  },
  toDOMRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t, o = Ht.isBackward(t), i = nn.toDOMPoint(e, n), a = Ht.isCollapsed(t) ? i : nn.toDOMPoint(e, r), s = nn.getWindow(e), l = s.document.createRange(), [u, c] = o ? a : i, [p, d] = o ? i : a, g = _s(u) ? u : u.parentElement, f = !!g.getAttribute("data-slate-zero-width"), m = _s(p) ? p : p.parentElement, v = !!m.getAttribute("data-slate-zero-width");
    return l.setStart(u, f ? 1 : c), l.setEnd(p, v ? 1 : d), l;
  },
  toSlateNode: (e, t) => {
    var n = _s(t) ? t : t.parentElement;
    n && !n.hasAttribute("data-slate-node") && (n = n.closest("[data-slate-node]"));
    var r = n ? lOe.get(n) : null;
    if (!r)
      throw new Error("Cannot resolve a Slate node from DOM node: ".concat(n));
    return r;
  },
  toSlatePoint: (e, t, n) => {
    var {
      exactMatch: r,
      suppressThrow: o,
      searchDirection: i = "backward"
    } = n, [a, s] = r ? t : gOe(t), l = a.parentNode, u = null, c = 0;
    if (l) {
      var p, d, g = nn.toDOMNode(e, e), f = l.closest('[data-slate-void="true"]'), m = f && g.contains(f) ? f : null, v = l.closest('[contenteditable="false"]'), E = v && g.contains(v) ? v : null, w = l.closest("[data-slate-leaf]"), M = null;
      if (w) {
        if (u = w.closest('[data-slate-node="text"]'), u) {
          var O = nn.getWindow(e), y = O.document.createRange();
          y.setStart(u, 0), y.setEnd(a, s);
          var C = y.cloneContents(), _ = [...Array.prototype.slice.call(C.querySelectorAll("[data-slate-zero-width]")), ...Array.prototype.slice.call(C.querySelectorAll("[contenteditable=false]"))];
          _.forEach((S) => {
            if (YC && !r && S.hasAttribute("data-slate-zero-width") && S.textContent.length > 0 && S.textContext !== "\uFEFF") {
              S.textContent.startsWith("\uFEFF") && (S.textContent = S.textContent.slice(1));
              return;
            }
            S.parentNode.removeChild(S);
          }), c = C.textContent.length, M = u;
        }
      } else if (m) {
        for (var F = m.querySelectorAll("[data-slate-leaf]"), L = 0; L < F.length; L++) {
          var N = F[L];
          if (nn.hasDOMNode(e, N)) {
            w = N;
            break;
          }
        }
        w ? (u = w.closest('[data-slate-node="text"]'), M = w, c = M.textContent.length, M.querySelectorAll("[data-slate-zero-width]").forEach((S) => {
          c -= S.textContent.length;
        })) : c = 1;
      } else if (E) {
        var R = (S) => S ? S.querySelectorAll(
          // Exclude leaf nodes in nested editors
          "[data-slate-leaf]:not(:scope [data-slate-editor] [data-slate-leaf])"
        ) : [], W = E.closest('[data-slate-node="element"]');
        if (i === "forward") {
          var V, z = [...R(W), ...R(W == null ? void 0 : W.nextElementSibling)];
          w = (V = z.find((S) => yOe(E, S))) !== null && V !== void 0 ? V : null;
        } else {
          var Z, K = [...R(W == null ? void 0 : W.previousElementSibling), ...R(W)];
          w = (Z = K.findLast((S) => ZN(E, S))) !== null && Z !== void 0 ? Z : null;
        }
        w && (u = w.closest('[data-slate-node="text"]'), M = w, i === "forward" ? c = 0 : (c = M.textContent.length, M.querySelectorAll("[data-slate-zero-width]").forEach((S) => {
          c -= S.textContent.length;
        })));
      }
      M && c === M.textContent.length && // COMPAT: Android IMEs might remove the zero width space while composing,
      // and we don't add it for line-breaks.
      YC && M.getAttribute("data-slate-zero-width") === "z" && (p = M.textContent) !== null && p !== void 0 && p.startsWith("\uFEFF") && // COMPAT: If the parent node is a Slate zero-width space, editor is
      // because the text node should have no characters. However, during IME
      // composition the ASCII characters will be prepended to the zero-width
      // space, so subtract 1 from the offset to account for the zero-width
      // space character.
      (l.hasAttribute("data-slate-zero-width") || // COMPAT: In Firefox, `range.cloneContents()` returns an extra trailing '\n'
      // when the document ends with a new-line character. This results in the offset
      // length being off by one, so we need to subtract one to account for this.
      xg && (d = M.textContent) !== null && d !== void 0 && d.endsWith(`

`)) && c--;
    }
    if (YC && !u && !r) {
      var X = l.hasAttribute("data-slate-node") ? l : l.closest("[data-slate-node]");
      if (X && nn.hasDOMNode(e, X, {
        editable: !0
      })) {
        var te = nn.toSlateNode(e, X), {
          path: J,
          offset: P
        } = Gn.start(e, nn.findPath(e, te));
        return X.querySelector("[data-slate-leaf]") || (P = s), {
          path: J,
          offset: P
        };
      }
    }
    if (!u) {
      if (o)
        return null;
      throw new Error("Cannot resolve a Slate point from DOM point: ".concat(t));
    }
    var D = nn.toSlateNode(e, u), H = nn.findPath(e, D);
    return {
      path: H,
      offset: c
    };
  },
  toSlateRange: (e, t, n) => {
    var r, {
      exactMatch: o,
      suppressThrow: i
    } = n, a = WN(t) ? t.anchorNode : t.startContainer, s, l, u, c, p;
    if (a)
      if (WN(t)) {
        if (xg && t.rangeCount > 1) {
          u = t.focusNode;
          var d = t.getRangeAt(0), g = t.getRangeAt(t.rangeCount - 1);
          if (u instanceof HTMLTableRowElement && d.startContainer instanceof HTMLTableRowElement && g.startContainer instanceof HTMLTableRowElement) {
            let C = function(_) {
              return _.childElementCount > 0 ? C(_.children[0]) : _;
            };
            var f = d.startContainer, m = g.startContainer, v = C(f.children[d.startOffset]), E = C(m.children[g.startOffset]);
            c = 0, E.childNodes.length > 0 ? s = E.childNodes[0] : s = E, v.childNodes.length > 0 ? u = v.childNodes[0] : u = v, E instanceof HTMLElement ? l = E.innerHTML.length : l = 0;
          } else
            d.startContainer === u ? (s = g.endContainer, l = g.endOffset, c = d.startOffset) : (s = d.startContainer, l = d.endOffset, c = g.startOffset);
        } else
          s = t.anchorNode, l = t.anchorOffset, u = t.focusNode, c = t.focusOffset;
        rOe && mOe(s) || xg ? p = t.anchorNode === t.focusNode && t.anchorOffset === t.focusOffset : p = t.isCollapsed;
      } else
        s = t.startContainer, l = t.startOffset, u = t.endContainer, c = t.endOffset, p = t.collapsed;
    if (s == null || u == null || l == null || c == null)
      throw new Error("Cannot resolve a Slate range from DOM range: ".concat(t));
    xg && (r = u.textContent) !== null && r !== void 0 && r.endsWith(`

`) && c === u.textContent.length && c--;
    var w = nn.toSlatePoint(e, [s, l], {
      exactMatch: o,
      suppressThrow: i
    });
    if (!w)
      return null;
    var M = ZN(s, u) || s === u && c < l, O = p ? w : nn.toSlatePoint(e, [u, c], {
      exactMatch: o,
      suppressThrow: i,
      searchDirection: M ? "forward" : "backward"
    });
    if (!O)
      return null;
    var y = {
      anchor: w,
      focus: O
    };
    return Ht.isExpanded(y) && Ht.isForward(y) && _s(u) && Gn.void(e, {
      at: y.focus,
      mode: "highest"
    }) && (y = Gn.unhangRange(e, y, {
      voids: !0
    })), y;
  }
}, COe = {
  bold: "mod+b",
  compose: ["down", "left", "right", "up", "backspace", "enter"],
  moveBackward: "left",
  moveForward: "right",
  moveWordBackward: "ctrl+left",
  moveWordForward: "ctrl+right",
  deleteBackward: "shift?+backspace",
  deleteForward: "shift?+delete",
  extendBackward: "shift+left",
  extendForward: "shift+right",
  italic: "mod+i",
  insertSoftBreak: "shift+enter",
  splitBlock: "enter",
  undo: "mod+z"
}, xOe = {
  moveLineBackward: "opt+up",
  moveLineForward: "opt+down",
  moveWordBackward: "opt+left",
  moveWordForward: "opt+right",
  deleteBackward: ["ctrl+backspace", "ctrl+h"],
  deleteForward: ["ctrl+delete", "ctrl+d"],
  deleteLineBackward: "cmd+shift?+backspace",
  deleteLineForward: ["cmd+shift?+delete", "ctrl+k"],
  deleteWordBackward: "opt+shift?+backspace",
  deleteWordForward: "opt+shift?+delete",
  extendLineBackward: "opt+shift+up",
  extendLineForward: "opt+shift+down",
  redo: "cmd+shift+z",
  transposeCharacter: "ctrl+t"
}, OOe = {
  deleteWordBackward: "ctrl+shift?+backspace",
  deleteWordForward: "ctrl+shift?+delete",
  redo: ["ctrl+y", "ctrl+shift+z"]
}, Mr = (e) => {
  var t = COe[e], n = xOe[e], r = OOe[e], o = t && ZC(t), i = n && ZC(n), a = r && ZC(r);
  return (s) => !!(o && o(s) || UN && i && i(s) || !UN && a && a(s));
};
Mr("bold"), Mr("compose"), Mr("moveBackward"), Mr("moveForward"), Mr("deleteBackward"), Mr("deleteForward"), Mr("deleteLineBackward"), Mr("deleteLineForward"), Mr("deleteWordBackward"), Mr("deleteWordForward"), Mr("extendBackward"), Mr("extendForward"), Mr("extendLineBackward"), Mr("extendLineForward"), Mr("italic"), Mr("moveLineBackward"), Mr("moveLineForward"), Mr("moveWordBackward"), Mr("moveWordForward"), Mr("redo"), Mr("insertSoftBreak"), Mr("splitBlock"), Mr("transposeCharacter"), Mr("undo");
var EOe = (e, t) => {
  var n = [], r = () => {
    n = [];
  }, o = (a) => {
    if (t.current) {
      var s = a.filter((l) => Pq(e, l, a));
      n.push(...s);
    }
  };
  function i() {
    n.length > 0 && (n.reverse().forEach((a) => {
      a.type !== "characterData" && (a.removedNodes.forEach((s) => {
        a.target.insertBefore(s, a.nextSibling);
      }), a.addedNodes.forEach((s) => {
        a.target.removeChild(s);
      }));
    }), r());
  }
  return {
    registerMutations: o,
    restoreDOM: i,
    clear: r
  };
}, kOe = {
  subtree: !0,
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0
};
class LOe extends Wu {
  constructor() {
    super(...arguments), od(this, "context", null), od(this, "manager", null), od(this, "mutationObserver", null);
  }
  observe() {
    var t, {
      node: n
    } = this.props;
    if (!n.current)
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    (t = this.mutationObserver) === null || t === void 0 || t.observe(n.current, kOe);
  }
  componentDidMount() {
    var {
      receivedUserInput: t
    } = this.props, n = this.context;
    this.manager = EOe(n, t), this.mutationObserver = new MutationObserver(this.manager.registerMutations), this.observe();
  }
  getSnapshotBeforeUpdate() {
    var t, n, r, o = (t = this.mutationObserver) === null || t === void 0 ? void 0 : t.takeRecords();
    if (o != null && o.length) {
      var i;
      (i = this.manager) === null || i === void 0 || i.registerMutations(o);
    }
    return (n = this.mutationObserver) === null || n === void 0 || n.disconnect(), (r = this.manager) === null || r === void 0 || r.restoreDOM(), null;
  }
  componentDidUpdate() {
    var t;
    (t = this.manager) === null || t === void 0 || t.clear(), this.observe();
  }
  componentWillUnmount() {
    var t;
    (t = this.mutationObserver) === null || t === void 0 || t.disconnect();
  }
  render() {
    return this.props.children;
  }
}
od(LOe, "contextType", nOe);
Ke({});
Ke({});
Ke({});
var co = {}, a_ = {}, Df = {}, Tf = {}, _q = "Expected a function", qN = NaN, POe = "[object Symbol]", _Oe = /^\s+|\s+$/g, SOe = /^[-+]0x[0-9a-f]+$/i, MOe = /^0b[01]+$/i, DOe = /^0o[0-7]+$/i, TOe = parseInt, jOe = typeof tr == "object" && tr && tr.Object === Object && tr, AOe = typeof self == "object" && self && self.Object === Object && self, IOe = jOe || AOe || Function("return this")(), ROe = Object.prototype, BOe = ROe.toString, NOe = Math.max, FOe = Math.min, XC = function() {
  return IOe.Date.now();
};
function zOe(e, t, n) {
  var r, o, i, a, s, l, u = 0, c = !1, p = !1, d = !0;
  if (typeof e != "function")
    throw new TypeError(_q);
  t = GN(t) || 0, Vv(n) && (c = !!n.leading, p = "maxWait" in n, i = p ? NOe(GN(n.maxWait) || 0, t) : i, d = "trailing" in n ? !!n.trailing : d);
  function g(C) {
    var _ = r, F = o;
    return r = o = void 0, u = C, a = e.apply(F, _), a;
  }
  function f(C) {
    return u = C, s = setTimeout(E, t), c ? g(C) : a;
  }
  function m(C) {
    var _ = C - l, F = C - u, L = t - _;
    return p ? FOe(L, i - F) : L;
  }
  function v(C) {
    var _ = C - l, F = C - u;
    return l === void 0 || _ >= t || _ < 0 || p && F >= i;
  }
  function E() {
    var C = XC();
    if (v(C))
      return w(C);
    s = setTimeout(E, m(C));
  }
  function w(C) {
    return s = void 0, d && r ? g(C) : (r = o = void 0, a);
  }
  function M() {
    s !== void 0 && clearTimeout(s), u = 0, r = l = o = s = void 0;
  }
  function O() {
    return s === void 0 ? a : w(XC());
  }
  function y() {
    var C = XC(), _ = v(C);
    if (r = arguments, o = this, l = C, _) {
      if (s === void 0)
        return f(l);
      if (p)
        return s = setTimeout(E, t), g(l);
    }
    return s === void 0 && (s = setTimeout(E, t)), a;
  }
  return y.cancel = M, y.flush = O, y;
}
function UOe(e, t, n) {
  var r = !0, o = !0;
  if (typeof e != "function")
    throw new TypeError(_q);
  return Vv(n) && (r = "leading" in n ? !!n.leading : r, o = "trailing" in n ? !!n.trailing : o), zOe(e, t, {
    leading: r,
    maxWait: t,
    trailing: o
  });
}
function Vv(e) {
  var t = typeof e;
  return !!e && (t == "object" || t == "function");
}
function HOe(e) {
  return !!e && typeof e == "object";
}
function $Oe(e) {
  return typeof e == "symbol" || HOe(e) && BOe.call(e) == POe;
}
function GN(e) {
  if (typeof e == "number")
    return e;
  if ($Oe(e))
    return qN;
  if (Vv(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = Vv(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = e.replace(_Oe, "");
  var n = MOe.test(e);
  return n || DOe.test(e) ? TOe(e.slice(2), n ? 2 : 8) : SOe.test(e) ? qN : +e;
}
var WOe = UOe, jf = {};
Object.defineProperty(jf, "__esModule", {
  value: !0
});
jf.addPassiveEventListener = function(e, t, n) {
  var r = n.name;
  r || (r = t, console.warn("Listener must be a named function.")), Sm.has(t) || Sm.set(t, /* @__PURE__ */ new Set());
  var o = Sm.get(t);
  if (!o.has(r)) {
    var i = function() {
      var a = !1;
      try {
        var s = Object.defineProperty({}, "passive", {
          get: function() {
            a = !0;
          }
        });
        window.addEventListener("test", null, s);
      } catch {
      }
      return a;
    }();
    e.addEventListener(t, n, i ? { passive: !0 } : !1), o.add(r);
  }
};
jf.removePassiveEventListener = function(e, t, n) {
  e.removeEventListener(t, n), Sm.get(t).delete(n.name || t);
};
var Sm = /* @__PURE__ */ new Map();
Object.defineProperty(Tf, "__esModule", {
  value: !0
});
var VOe = WOe, ZOe = qOe(VOe), KN = jf;
function qOe(e) {
  return e && e.__esModule ? e : { default: e };
}
var GOe = function(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 66;
  return (0, ZOe.default)(e, t);
}, $r = {
  spyCallbacks: [],
  spySetState: [],
  scrollSpyContainers: [],
  mount: function(e, t) {
    if (e) {
      var n = GOe(function(r) {
        $r.scrollHandler(e);
      }, t);
      return $r.scrollSpyContainers.push(e), (0, KN.addPassiveEventListener)(e, "scroll", n), function() {
        (0, KN.removePassiveEventListener)(e, "scroll", n), $r.scrollSpyContainers.splice($r.scrollSpyContainers.indexOf(e), 1);
      };
    }
    return function() {
    };
  },
  isMounted: function(e) {
    return $r.scrollSpyContainers.indexOf(e) !== -1;
  },
  currentPositionX: function(e) {
    if (e === document) {
      var t = window.scrollY !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.scrollX : n ? document.documentElement.scrollLeft : document.body.scrollLeft;
    } else
      return e.scrollLeft;
  },
  currentPositionY: function(e) {
    if (e === document) {
      var t = window.scrollX !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.scrollY : n ? document.documentElement.scrollTop : document.body.scrollTop;
    } else
      return e.scrollTop;
  },
  scrollHandler: function(e) {
    var t = $r.scrollSpyContainers[$r.scrollSpyContainers.indexOf(e)].spyCallbacks || [];
    t.forEach(function(n) {
      return n($r.currentPositionX(e), $r.currentPositionY(e));
    });
  },
  addStateHandler: function(e) {
    $r.spySetState.push(e);
  },
  addSpyHandler: function(e, t) {
    var n = $r.scrollSpyContainers[$r.scrollSpyContainers.indexOf(t)];
    n.spyCallbacks || (n.spyCallbacks = []), n.spyCallbacks.push(e);
  },
  updateStates: function() {
    $r.spySetState.forEach(function(e) {
      return e();
    });
  },
  unmount: function(e, t) {
    $r.scrollSpyContainers.forEach(function(n) {
      return n.spyCallbacks && n.spyCallbacks.length && n.spyCallbacks.indexOf(t) > -1 && n.spyCallbacks.splice(n.spyCallbacks.indexOf(t), 1);
    }), $r.spySetState && $r.spySetState.length && $r.spySetState.indexOf(e) > -1 && $r.spySetState.splice($r.spySetState.indexOf(e), 1), document.removeEventListener("scroll", $r.scrollHandler);
  },
  update: function() {
    return $r.scrollSpyContainers.forEach(function(e) {
      return $r.scrollHandler(e);
    });
  }
};
Tf.default = $r;
var Tc = {}, Af = {};
Object.defineProperty(Af, "__esModule", {
  value: !0
});
var KOe = function(e, t) {
  var n = e.indexOf("#") === 0 ? e.substring(1) : e, r = n ? "#" + n : "", o = window && window.location, i = r ? o.pathname + o.search + r : o.pathname + o.search;
  t ? history.pushState(history.state, "", i) : history.replaceState(history.state, "", i);
}, YOe = function() {
  return window.location.hash.replace(/^#/, "");
}, XOe = function(e) {
  return function(t) {
    return e.contains ? e != t && e.contains(t) : !!(e.compareDocumentPosition(t) & 16);
  };
}, JOe = function(e) {
  return getComputedStyle(e).position !== "static";
}, JC = function(e, t) {
  for (var n = e.offsetTop, r = e.offsetParent; r && !t(r); )
    n += r.offsetTop, r = r.offsetParent;
  return { offsetTop: n, offsetParent: r };
}, QOe = function(e, t, n) {
  if (n)
    return e === document ? t.getBoundingClientRect().left + (window.scrollX || window.pageXOffset) : getComputedStyle(e).position !== "static" ? t.offsetLeft : t.offsetLeft - e.offsetLeft;
  if (e === document)
    return t.getBoundingClientRect().top + (window.scrollY || window.pageYOffset);
  if (JOe(e)) {
    if (t.offsetParent !== e) {
      var r = function(l) {
        return l === e || l === document;
      }, o = JC(t, r), i = o.offsetTop, a = o.offsetParent;
      if (a !== e)
        throw new Error("Seems containerElement is not an ancestor of the Element");
      return i;
    }
    return t.offsetTop;
  }
  if (t.offsetParent === e.offsetParent)
    return t.offsetTop - e.offsetTop;
  var s = function(l) {
    return l === document;
  };
  return JC(t, s).offsetTop - JC(e, s).offsetTop;
};
Af.default = {
  updateHash: KOe,
  getHash: YOe,
  filterElementInContainer: XOe,
  scrollOffset: QOe
};
var Rw = {}, l_ = {};
Object.defineProperty(l_, "__esModule", {
  value: !0
});
l_.default = {
  /*
   * https://github.com/oblador/angular-scroll (duScrollDefaultEasing)
   */
  defaultEasing: function(e) {
    return e < 0.5 ? Math.pow(e * 2, 2) / 2 : 1 - Math.pow((1 - e) * 2, 2) / 2;
  },
  /*
   * https://gist.github.com/gre/1650294
   */
  // no easing, no acceleration
  linear: function(e) {
    return e;
  },
  // accelerating from zero velocity
  easeInQuad: function(e) {
    return e * e;
  },
  // decelerating to zero velocity
  easeOutQuad: function(e) {
    return e * (2 - e);
  },
  // acceleration until halfway, then deceleration
  easeInOutQuad: function(e) {
    return e < 0.5 ? 2 * e * e : -1 + (4 - 2 * e) * e;
  },
  // accelerating from zero velocity 
  easeInCubic: function(e) {
    return e * e * e;
  },
  // decelerating to zero velocity 
  easeOutCubic: function(e) {
    return --e * e * e + 1;
  },
  // acceleration until halfway, then deceleration 
  easeInOutCubic: function(e) {
    return e < 0.5 ? 4 * e * e * e : (e - 1) * (2 * e - 2) * (2 * e - 2) + 1;
  },
  // accelerating from zero velocity 
  easeInQuart: function(e) {
    return e * e * e * e;
  },
  // decelerating to zero velocity 
  easeOutQuart: function(e) {
    return 1 - --e * e * e * e;
  },
  // acceleration until halfway, then deceleration
  easeInOutQuart: function(e) {
    return e < 0.5 ? 8 * e * e * e * e : 1 - 8 * --e * e * e * e;
  },
  // accelerating from zero velocity
  easeInQuint: function(e) {
    return e * e * e * e * e;
  },
  // decelerating to zero velocity
  easeOutQuint: function(e) {
    return 1 + --e * e * e * e * e;
  },
  // acceleration until halfway, then deceleration 
  easeInOutQuint: function(e) {
    return e < 0.5 ? 16 * e * e * e * e * e : 1 + 16 * --e * e * e * e * e;
  }
};
var u_ = {};
Object.defineProperty(u_, "__esModule", {
  value: !0
});
var eEe = jf, tEe = ["mousedown", "wheel", "touchmove", "keydown"];
u_.default = {
  subscribe: function(e) {
    return typeof document < "u" && tEe.forEach(function(t) {
      return (0, eEe.addPassiveEventListener)(document, t, e);
    });
  }
};
var If = {};
Object.defineProperty(If, "__esModule", {
  value: !0
});
var Lk = {
  registered: {},
  scrollEvent: {
    register: function(e, t) {
      Lk.registered[e] = t;
    },
    remove: function(e) {
      Lk.registered[e] = null;
    }
  }
};
If.default = Lk;
Object.defineProperty(Rw, "__esModule", {
  value: !0
});
var nEe = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, rEe = Af;
Bw(rEe);
var oEe = l_, YN = Bw(oEe), iEe = u_, sEe = Bw(iEe), aEe = If, Cs = Bw(aEe);
function Bw(e) {
  return e && e.__esModule ? e : { default: e };
}
var Sq = function(e) {
  return YN.default[e.smooth] || YN.default.defaultEasing;
}, lEe = function(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}, uEe = function() {
  if (typeof window < "u")
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame;
}, Pk = function() {
  return uEe() || function(e, t, n) {
    window.setTimeout(e, n || 1e3 / 60, (/* @__PURE__ */ new Date()).getTime());
  };
}(), Mq = function() {
  return {
    currentPosition: 0,
    startPosition: 0,
    targetPosition: 0,
    progress: 0,
    duration: 0,
    cancel: !1,
    target: null,
    containerElement: null,
    to: null,
    start: null,
    delta: null,
    percent: null,
    delayTimeout: null
  };
}, Dq = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollLeft;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageXOffset : r ? document.documentElement.scrollLeft : document.body.scrollLeft;
}, Tq = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollTop;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageYOffset : r ? document.documentElement.scrollTop : document.body.scrollTop;
}, cEe = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollWidth - t.offsetWidth;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollWidth, n.offsetWidth, r.clientWidth, r.scrollWidth, r.offsetWidth);
}, pEe = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollHeight - t.offsetHeight;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollHeight, n.offsetHeight, r.clientHeight, r.scrollHeight, r.offsetHeight);
}, dEe = function e(t, n, r) {
  var o = n.data;
  if (!n.ignoreCancelEvents && o.cancel) {
    Cs.default.registered.end && Cs.default.registered.end(o.to, o.target, o.currentPositionY);
    return;
  }
  if (o.delta = Math.round(o.targetPosition - o.startPosition), o.start === null && (o.start = r), o.progress = r - o.start, o.percent = o.progress >= o.duration ? 1 : t(o.progress / o.duration), o.currentPosition = o.startPosition + Math.ceil(o.delta * o.percent), o.containerElement && o.containerElement !== document && o.containerElement !== document.body ? n.horizontal ? o.containerElement.scrollLeft = o.currentPosition : o.containerElement.scrollTop = o.currentPosition : n.horizontal ? window.scrollTo(o.currentPosition, 0) : window.scrollTo(0, o.currentPosition), o.percent < 1) {
    var i = e.bind(null, t, n);
    Pk.call(window, i);
    return;
  }
  Cs.default.registered.end && Cs.default.registered.end(o.to, o.target, o.currentPosition);
}, c_ = function(e) {
  e.data.containerElement = e ? e.containerId ? document.getElementById(e.containerId) : e.container && e.container.nodeType ? e.container : document : null;
}, Rf = function(e, t, n, r) {
  t.data = t.data || Mq(), window.clearTimeout(t.data.delayTimeout);
  var o = function() {
    t.data.cancel = !0;
  };
  if (sEe.default.subscribe(o), c_(t), t.data.start = null, t.data.cancel = !1, t.data.startPosition = t.horizontal ? Dq(t) : Tq(t), t.data.targetPosition = t.absolute ? e : e + t.data.startPosition, t.data.startPosition === t.data.targetPosition) {
    Cs.default.registered.end && Cs.default.registered.end(t.data.to, t.data.target, t.data.currentPosition);
    return;
  }
  t.data.delta = Math.round(t.data.targetPosition - t.data.startPosition), t.data.duration = lEe(t.duration)(t.data.delta), t.data.duration = isNaN(parseFloat(t.data.duration)) ? 1e3 : parseFloat(t.data.duration), t.data.to = n, t.data.target = r;
  var i = Sq(t), a = dEe.bind(null, i, t);
  if (t && t.delay > 0) {
    t.data.delayTimeout = window.setTimeout(function() {
      Cs.default.registered.begin && Cs.default.registered.begin(t.data.to, t.data.target), Pk.call(window, a);
    }, t.delay);
    return;
  }
  Cs.default.registered.begin && Cs.default.registered.begin(t.data.to, t.data.target), Pk.call(window, a);
}, Nw = function(e) {
  return e = nEe({}, e), e.data = e.data || Mq(), e.absolute = !0, e;
}, fEe = function(e) {
  Rf(0, Nw(e));
}, hEe = function(e, t) {
  Rf(e, Nw(t));
}, gEe = function(e) {
  e = Nw(e), c_(e), Rf(e.horizontal ? cEe(e) : pEe(e), e);
}, mEe = function(e, t) {
  t = Nw(t), c_(t);
  var n = t.horizontal ? Dq(t) : Tq(t);
  Rf(e + n, t);
};
Rw.default = {
  animateTopScroll: Rf,
  getAnimationType: Sq,
  scrollToTop: fEe,
  scrollToBottom: gEe,
  scrollTo: hEe,
  scrollMore: mEe
};
Object.defineProperty(Tc, "__esModule", {
  value: !0
});
var vEe = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, yEe = Af, bEe = p_(yEe), wEe = Rw, CEe = p_(wEe), xEe = If, Eg = p_(xEe);
function p_(e) {
  return e && e.__esModule ? e : { default: e };
}
var kg = {}, XN = void 0;
Tc.default = {
  unmount: function() {
    kg = {};
  },
  register: function(e, t) {
    kg[e] = t;
  },
  unregister: function(e) {
    delete kg[e];
  },
  get: function(e) {
    return kg[e] || document.getElementById(e) || document.getElementsByName(e)[0] || document.getElementsByClassName(e)[0];
  },
  setActiveLink: function(e) {
    return XN = e;
  },
  getActiveLink: function() {
    return XN;
  },
  scrollTo: function(e, t) {
    var n = this.get(e);
    if (!n) {
      console.warn("target Element not found");
      return;
    }
    t = vEe({}, t, { absolute: !1 });
    var r = t.containerId, o = t.container, i = void 0;
    r ? i = document.getElementById(r) : o && o.nodeType ? i = o : i = document, t.absolute = !0;
    var a = t.horizontal, s = bEe.default.scrollOffset(i, n, a) + (t.offset || 0);
    if (!t.smooth) {
      Eg.default.registered.begin && Eg.default.registered.begin(e, n), i === document ? t.horizontal ? window.scrollTo(s, 0) : window.scrollTo(0, s) : i.scrollTop = s, Eg.default.registered.end && Eg.default.registered.end(e, n);
      return;
    }
    CEe.default.animateTopScroll(s, t, e, n);
  }
};
var _k = { exports: {} }, QC = { exports: {} }, Tn = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var JN;
function OEe() {
  if (JN) return Tn;
  JN = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, g = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, m = e ? Symbol.for("react.block") : 60121, v = e ? Symbol.for("react.fundamental") : 60117, E = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
  function M(y) {
    if (typeof y == "object" && y !== null) {
      var C = y.$$typeof;
      switch (C) {
        case t:
          switch (y = y.type, y) {
            case l:
            case u:
            case r:
            case i:
            case o:
            case p:
              return y;
            default:
              switch (y = y && y.$$typeof, y) {
                case s:
                case c:
                case f:
                case g:
                case a:
                  return y;
                default:
                  return C;
              }
          }
        case n:
          return C;
      }
    }
  }
  function O(y) {
    return M(y) === u;
  }
  return Tn.AsyncMode = l, Tn.ConcurrentMode = u, Tn.ContextConsumer = s, Tn.ContextProvider = a, Tn.Element = t, Tn.ForwardRef = c, Tn.Fragment = r, Tn.Lazy = f, Tn.Memo = g, Tn.Portal = n, Tn.Profiler = i, Tn.StrictMode = o, Tn.Suspense = p, Tn.isAsyncMode = function(y) {
    return O(y) || M(y) === l;
  }, Tn.isConcurrentMode = O, Tn.isContextConsumer = function(y) {
    return M(y) === s;
  }, Tn.isContextProvider = function(y) {
    return M(y) === a;
  }, Tn.isElement = function(y) {
    return typeof y == "object" && y !== null && y.$$typeof === t;
  }, Tn.isForwardRef = function(y) {
    return M(y) === c;
  }, Tn.isFragment = function(y) {
    return M(y) === r;
  }, Tn.isLazy = function(y) {
    return M(y) === f;
  }, Tn.isMemo = function(y) {
    return M(y) === g;
  }, Tn.isPortal = function(y) {
    return M(y) === n;
  }, Tn.isProfiler = function(y) {
    return M(y) === i;
  }, Tn.isStrictMode = function(y) {
    return M(y) === o;
  }, Tn.isSuspense = function(y) {
    return M(y) === p;
  }, Tn.isValidElementType = function(y) {
    return typeof y == "string" || typeof y == "function" || y === r || y === u || y === i || y === o || y === p || y === d || typeof y == "object" && y !== null && (y.$$typeof === f || y.$$typeof === g || y.$$typeof === a || y.$$typeof === s || y.$$typeof === c || y.$$typeof === v || y.$$typeof === E || y.$$typeof === w || y.$$typeof === m);
  }, Tn.typeOf = M, Tn;
}
var Un = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var QN;
function EEe() {
  return QN || (QN = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, g = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, m = e ? Symbol.for("react.block") : 60121, v = e ? Symbol.for("react.fundamental") : 60117, E = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
    function M(B) {
      return typeof B == "string" || typeof B == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      B === r || B === u || B === i || B === o || B === p || B === d || typeof B == "object" && B !== null && (B.$$typeof === f || B.$$typeof === g || B.$$typeof === a || B.$$typeof === s || B.$$typeof === c || B.$$typeof === v || B.$$typeof === E || B.$$typeof === w || B.$$typeof === m);
    }
    function O(B) {
      if (typeof B == "object" && B !== null) {
        var ue = B.$$typeof;
        switch (ue) {
          case t:
            var fe = B.type;
            switch (fe) {
              case l:
              case u:
              case r:
              case i:
              case o:
              case p:
                return fe;
              default:
                var oe = fe && fe.$$typeof;
                switch (oe) {
                  case s:
                  case c:
                  case f:
                  case g:
                  case a:
                    return oe;
                  default:
                    return ue;
                }
            }
          case n:
            return ue;
        }
      }
    }
    var y = l, C = u, _ = s, F = a, L = t, N = c, R = r, W = f, V = g, z = n, Z = i, K = o, X = p, te = !1;
    function J(B) {
      return te || (te = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), P(B) || O(B) === l;
    }
    function P(B) {
      return O(B) === u;
    }
    function D(B) {
      return O(B) === s;
    }
    function H(B) {
      return O(B) === a;
    }
    function S(B) {
      return typeof B == "object" && B !== null && B.$$typeof === t;
    }
    function $(B) {
      return O(B) === c;
    }
    function x(B) {
      return O(B) === r;
    }
    function j(B) {
      return O(B) === f;
    }
    function U(B) {
      return O(B) === g;
    }
    function T(B) {
      return O(B) === n;
    }
    function q(B) {
      return O(B) === i;
    }
    function A(B) {
      return O(B) === o;
    }
    function Y(B) {
      return O(B) === p;
    }
    Un.AsyncMode = y, Un.ConcurrentMode = C, Un.ContextConsumer = _, Un.ContextProvider = F, Un.Element = L, Un.ForwardRef = N, Un.Fragment = R, Un.Lazy = W, Un.Memo = V, Un.Portal = z, Un.Profiler = Z, Un.StrictMode = K, Un.Suspense = X, Un.isAsyncMode = J, Un.isConcurrentMode = P, Un.isContextConsumer = D, Un.isContextProvider = H, Un.isElement = S, Un.isForwardRef = $, Un.isFragment = x, Un.isLazy = j, Un.isMemo = U, Un.isPortal = T, Un.isProfiler = q, Un.isStrictMode = A, Un.isSuspense = Y, Un.isValidElementType = M, Un.typeOf = O;
  }()), Un;
}
var eF;
function jq() {
  return eF || (eF = 1, process.env.NODE_ENV === "production" ? QC.exports = OEe() : QC.exports = EEe()), QC.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var ex, tF;
function kEe() {
  if (tF) return ex;
  tF = 1;
  var e = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, n = Object.prototype.propertyIsEnumerable;
  function r(i) {
    if (i == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(i);
  }
  function o() {
    try {
      if (!Object.assign)
        return !1;
      var i = new String("abc");
      if (i[5] = "de", Object.getOwnPropertyNames(i)[0] === "5")
        return !1;
      for (var a = {}, s = 0; s < 10; s++)
        a["_" + String.fromCharCode(s)] = s;
      var l = Object.getOwnPropertyNames(a).map(function(c) {
        return a[c];
      });
      if (l.join("") !== "0123456789")
        return !1;
      var u = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(c) {
        u[c] = c;
      }), Object.keys(Object.assign({}, u)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return ex = o() ? Object.assign : function(i, a) {
    for (var s, l = r(i), u, c = 1; c < arguments.length; c++) {
      s = Object(arguments[c]);
      for (var p in s)
        t.call(s, p) && (l[p] = s[p]);
      if (e) {
        u = e(s);
        for (var d = 0; d < u.length; d++)
          n.call(s, u[d]) && (l[u[d]] = s[u[d]]);
      }
    }
    return l;
  }, ex;
}
var tx, nF;
function d_() {
  if (nF) return tx;
  nF = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return tx = e, tx;
}
var rF, oF;
function Aq() {
  return oF || (oF = 1, rF = Function.call.bind(Object.prototype.hasOwnProperty)), rF;
}
var nx, iF;
function LEe() {
  if (iF) return nx;
  iF = 1;
  var e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = d_(), n = {}, r = Aq();
    e = function(i) {
      var a = "Warning: " + i;
      typeof console < "u" && console.error(a);
      try {
        throw new Error(a);
      } catch {
      }
    };
  }
  function o(i, a, s, l, u) {
    if (process.env.NODE_ENV !== "production") {
      for (var c in i)
        if (r(i, c)) {
          var p;
          try {
            if (typeof i[c] != "function") {
              var d = Error(
                (l || "React class") + ": " + s + " type `" + c + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof i[c] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw d.name = "Invariant Violation", d;
            }
            p = i[c](a, c, l, s, null, t);
          } catch (f) {
            p = f;
          }
          if (p && !(p instanceof Error) && e(
            (l || "React class") + ": type specification of " + s + " `" + c + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof p + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), p instanceof Error && !(p.message in n)) {
            n[p.message] = !0;
            var g = u ? u() : "";
            e(
              "Failed " + s + " type: " + p.message + (g ?? "")
            );
          }
        }
    }
  }
  return o.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (n = {});
  }, nx = o, nx;
}
var rx, sF;
function PEe() {
  if (sF) return rx;
  sF = 1;
  var e = jq(), t = kEe(), n = d_(), r = Aq(), o = LEe(), i = function() {
  };
  process.env.NODE_ENV !== "production" && (i = function(s) {
    var l = "Warning: " + s;
    typeof console < "u" && console.error(l);
    try {
      throw new Error(l);
    } catch {
    }
  });
  function a() {
    return null;
  }
  return rx = function(s, l) {
    var u = typeof Symbol == "function" && Symbol.iterator, c = "@@iterator";
    function p(P) {
      var D = P && (u && P[u] || P[c]);
      if (typeof D == "function")
        return D;
    }
    var d = "<<anonymous>>", g = {
      array: E("array"),
      bigint: E("bigint"),
      bool: E("boolean"),
      func: E("function"),
      number: E("number"),
      object: E("object"),
      string: E("string"),
      symbol: E("symbol"),
      any: w(),
      arrayOf: M,
      element: O(),
      elementType: y(),
      instanceOf: C,
      node: N(),
      objectOf: F,
      oneOf: _,
      oneOfType: L,
      shape: W,
      exact: V
    };
    function f(P, D) {
      return P === D ? P !== 0 || 1 / P === 1 / D : P !== P && D !== D;
    }
    function m(P, D) {
      this.message = P, this.data = D && typeof D == "object" ? D : {}, this.stack = "";
    }
    m.prototype = Error.prototype;
    function v(P) {
      if (process.env.NODE_ENV !== "production")
        var D = {}, H = 0;
      function S(x, j, U, T, q, A, Y) {
        if (T = T || d, A = A || U, Y !== n) {
          if (l) {
            var B = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw B.name = "Invariant Violation", B;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var ue = T + ":" + U;
            !D[ue] && // Avoid spamming the console because they are often not actionable except for lib authors
            H < 3 && (i(
              "You are manually calling a React.PropTypes validation function for the `" + A + "` prop on `" + T + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), D[ue] = !0, H++);
          }
        }
        return j[U] == null ? x ? j[U] === null ? new m("The " + q + " `" + A + "` is marked as required " + ("in `" + T + "`, but its value is `null`.")) : new m("The " + q + " `" + A + "` is marked as required in " + ("`" + T + "`, but its value is `undefined`.")) : null : P(j, U, T, q, A);
      }
      var $ = S.bind(null, !1);
      return $.isRequired = S.bind(null, !0), $;
    }
    function E(P) {
      function D(H, S, $, x, j, U) {
        var T = H[S], q = K(T);
        if (q !== P) {
          var A = X(T);
          return new m(
            "Invalid " + x + " `" + j + "` of type " + ("`" + A + "` supplied to `" + $ + "`, expected ") + ("`" + P + "`."),
            { expectedType: P }
          );
        }
        return null;
      }
      return v(D);
    }
    function w() {
      return v(a);
    }
    function M(P) {
      function D(H, S, $, x, j) {
        if (typeof P != "function")
          return new m("Property `" + j + "` of component `" + $ + "` has invalid PropType notation inside arrayOf.");
        var U = H[S];
        if (!Array.isArray(U)) {
          var T = K(U);
          return new m("Invalid " + x + " `" + j + "` of type " + ("`" + T + "` supplied to `" + $ + "`, expected an array."));
        }
        for (var q = 0; q < U.length; q++) {
          var A = P(U, q, $, x, j + "[" + q + "]", n);
          if (A instanceof Error)
            return A;
        }
        return null;
      }
      return v(D);
    }
    function O() {
      function P(D, H, S, $, x) {
        var j = D[H];
        if (!s(j)) {
          var U = K(j);
          return new m("Invalid " + $ + " `" + x + "` of type " + ("`" + U + "` supplied to `" + S + "`, expected a single ReactElement."));
        }
        return null;
      }
      return v(P);
    }
    function y() {
      function P(D, H, S, $, x) {
        var j = D[H];
        if (!e.isValidElementType(j)) {
          var U = K(j);
          return new m("Invalid " + $ + " `" + x + "` of type " + ("`" + U + "` supplied to `" + S + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return v(P);
    }
    function C(P) {
      function D(H, S, $, x, j) {
        if (!(H[S] instanceof P)) {
          var U = P.name || d, T = J(H[S]);
          return new m("Invalid " + x + " `" + j + "` of type " + ("`" + T + "` supplied to `" + $ + "`, expected ") + ("instance of `" + U + "`."));
        }
        return null;
      }
      return v(D);
    }
    function _(P) {
      if (!Array.isArray(P))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? i(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : i("Invalid argument supplied to oneOf, expected an array.")), a;
      function D(H, S, $, x, j) {
        for (var U = H[S], T = 0; T < P.length; T++)
          if (f(U, P[T]))
            return null;
        var q = JSON.stringify(P, function(A, Y) {
          var B = X(Y);
          return B === "symbol" ? String(Y) : Y;
        });
        return new m("Invalid " + x + " `" + j + "` of value `" + String(U) + "` " + ("supplied to `" + $ + "`, expected one of " + q + "."));
      }
      return v(D);
    }
    function F(P) {
      function D(H, S, $, x, j) {
        if (typeof P != "function")
          return new m("Property `" + j + "` of component `" + $ + "` has invalid PropType notation inside objectOf.");
        var U = H[S], T = K(U);
        if (T !== "object")
          return new m("Invalid " + x + " `" + j + "` of type " + ("`" + T + "` supplied to `" + $ + "`, expected an object."));
        for (var q in U)
          if (r(U, q)) {
            var A = P(U, q, $, x, j + "." + q, n);
            if (A instanceof Error)
              return A;
          }
        return null;
      }
      return v(D);
    }
    function L(P) {
      if (!Array.isArray(P))
        return process.env.NODE_ENV !== "production" && i("Invalid argument supplied to oneOfType, expected an instance of array."), a;
      for (var D = 0; D < P.length; D++) {
        var H = P[D];
        if (typeof H != "function")
          return i(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + te(H) + " at index " + D + "."
          ), a;
      }
      function S($, x, j, U, T) {
        for (var q = [], A = 0; A < P.length; A++) {
          var Y = P[A], B = Y($, x, j, U, T, n);
          if (B == null)
            return null;
          B.data && r(B.data, "expectedType") && q.push(B.data.expectedType);
        }
        var ue = q.length > 0 ? ", expected one of type [" + q.join(", ") + "]" : "";
        return new m("Invalid " + U + " `" + T + "` supplied to " + ("`" + j + "`" + ue + "."));
      }
      return v(S);
    }
    function N() {
      function P(D, H, S, $, x) {
        return z(D[H]) ? null : new m("Invalid " + $ + " `" + x + "` supplied to " + ("`" + S + "`, expected a ReactNode."));
      }
      return v(P);
    }
    function R(P, D, H, S, $) {
      return new m(
        (P || "React class") + ": " + D + " type `" + H + "." + S + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + $ + "`."
      );
    }
    function W(P) {
      function D(H, S, $, x, j) {
        var U = H[S], T = K(U);
        if (T !== "object")
          return new m("Invalid " + x + " `" + j + "` of type `" + T + "` " + ("supplied to `" + $ + "`, expected `object`."));
        for (var q in P) {
          var A = P[q];
          if (typeof A != "function")
            return R($, x, j, q, X(A));
          var Y = A(U, q, $, x, j + "." + q, n);
          if (Y)
            return Y;
        }
        return null;
      }
      return v(D);
    }
    function V(P) {
      function D(H, S, $, x, j) {
        var U = H[S], T = K(U);
        if (T !== "object")
          return new m("Invalid " + x + " `" + j + "` of type `" + T + "` " + ("supplied to `" + $ + "`, expected `object`."));
        var q = t({}, H[S], P);
        for (var A in q) {
          var Y = P[A];
          if (r(P, A) && typeof Y != "function")
            return R($, x, j, A, X(Y));
          if (!Y)
            return new m(
              "Invalid " + x + " `" + j + "` key `" + A + "` supplied to `" + $ + "`.\nBad object: " + JSON.stringify(H[S], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(P), null, "  ")
            );
          var B = Y(U, A, $, x, j + "." + A, n);
          if (B)
            return B;
        }
        return null;
      }
      return v(D);
    }
    function z(P) {
      switch (typeof P) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !P;
        case "object":
          if (Array.isArray(P))
            return P.every(z);
          if (P === null || s(P))
            return !0;
          var D = p(P);
          if (D) {
            var H = D.call(P), S;
            if (D !== P.entries) {
              for (; !(S = H.next()).done; )
                if (!z(S.value))
                  return !1;
            } else
              for (; !(S = H.next()).done; ) {
                var $ = S.value;
                if ($ && !z($[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function Z(P, D) {
      return P === "symbol" ? !0 : D ? D["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && D instanceof Symbol : !1;
    }
    function K(P) {
      var D = typeof P;
      return Array.isArray(P) ? "array" : P instanceof RegExp ? "object" : Z(D, P) ? "symbol" : D;
    }
    function X(P) {
      if (typeof P > "u" || P === null)
        return "" + P;
      var D = K(P);
      if (D === "object") {
        if (P instanceof Date)
          return "date";
        if (P instanceof RegExp)
          return "regexp";
      }
      return D;
    }
    function te(P) {
      var D = X(P);
      switch (D) {
        case "array":
        case "object":
          return "an " + D;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + D;
        default:
          return D;
      }
    }
    function J(P) {
      return !P.constructor || !P.constructor.name ? d : P.constructor.name;
    }
    return g.checkPropTypes = o, g.resetWarningCache = o.resetWarningCache, g.PropTypes = g, g;
  }, rx;
}
var ox, aF;
function _Ee() {
  if (aF) return ox;
  aF = 1;
  var e = d_();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, ox = function() {
    function r(a, s, l, u, c, p) {
      if (p !== e) {
        var d = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw d.name = "Invariant Violation", d;
      }
    }
    r.isRequired = r;
    function o() {
      return r;
    }
    var i = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: o,
      element: r,
      elementType: r,
      instanceOf: o,
      node: r,
      objectOf: o,
      oneOf: o,
      oneOfType: o,
      shape: o,
      exact: o,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return i.PropTypes = i, i;
  }, ox;
}
if (process.env.NODE_ENV !== "production") {
  var SEe = jq(), MEe = !0;
  _k.exports = PEe()(SEe.isElement, MEe);
} else
  _k.exports = _Ee()();
var Fw = _k.exports, zw = {};
Object.defineProperty(zw, "__esModule", {
  value: !0
});
var DEe = Af, ix = TEe(DEe);
function TEe(e) {
  return e && e.__esModule ? e : { default: e };
}
var jEe = {
  mountFlag: !1,
  initialized: !1,
  scroller: null,
  containers: {},
  mount: function(e) {
    this.scroller = e, this.handleHashChange = this.handleHashChange.bind(this), window.addEventListener("hashchange", this.handleHashChange), this.initStateFromHash(), this.mountFlag = !0;
  },
  mapContainer: function(e, t) {
    this.containers[e] = t;
  },
  isMounted: function() {
    return this.mountFlag;
  },
  isInitialized: function() {
    return this.initialized;
  },
  initStateFromHash: function() {
    var e = this, t = this.getHash();
    t ? window.setTimeout(function() {
      e.scrollTo(t, !0), e.initialized = !0;
    }, 10) : this.initialized = !0;
  },
  scrollTo: function(e, t) {
    var n = this.scroller, r = n.get(e);
    if (r && (t || e !== n.getActiveLink())) {
      var o = this.containers[e] || document;
      n.scrollTo(e, { container: o });
    }
  },
  getHash: function() {
    return ix.default.getHash();
  },
  changeHash: function(e, t) {
    this.isInitialized() && ix.default.getHash() !== e && ix.default.updateHash(e, t);
  },
  handleHashChange: function() {
    this.scrollTo(this.getHash());
  },
  unmount: function() {
    this.scroller = null, this.containers = null, window.removeEventListener("hashchange", this.handleHashChange);
  }
};
zw.default = jEe;
Object.defineProperty(Df, "__esModule", {
  value: !0
});
var Lg = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, AEe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), IEe = we, lF = Bf(IEe), REe = Tf, Pg = Bf(REe), BEe = Tc, NEe = Bf(BEe), FEe = Fw, Dr = Bf(FEe), zEe = zw, La = Bf(zEe);
function Bf(e) {
  return e && e.__esModule ? e : { default: e };
}
function UEe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function HEe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function $Ee(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var uF = {
  to: Dr.default.string.isRequired,
  containerId: Dr.default.string,
  container: Dr.default.object,
  activeClass: Dr.default.string,
  activeStyle: Dr.default.object,
  spy: Dr.default.bool,
  horizontal: Dr.default.bool,
  smooth: Dr.default.oneOfType([Dr.default.bool, Dr.default.string]),
  offset: Dr.default.number,
  delay: Dr.default.number,
  isDynamic: Dr.default.bool,
  onClick: Dr.default.func,
  duration: Dr.default.oneOfType([Dr.default.number, Dr.default.func]),
  absolute: Dr.default.bool,
  onSetActive: Dr.default.func,
  onSetInactive: Dr.default.func,
  ignoreCancelEvents: Dr.default.bool,
  hashSpy: Dr.default.bool,
  saveHashHistory: Dr.default.bool,
  spyThrottle: Dr.default.number
};
Df.default = function(e, t) {
  var n = t || NEe.default, r = function(i) {
    $Ee(a, i);
    function a(s) {
      UEe(this, a);
      var l = HEe(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
      return o.call(l), l.state = {
        active: !1
      }, l.beforeUnmountCallbacks = [], l;
    }
    return AEe(a, [{
      key: "getScrollSpyContainer",
      value: function() {
        var s = this.props.containerId, l = this.props.container;
        return s && !l ? document.getElementById(s) : l && l.nodeType ? l : document;
      }
    }, {
      key: "componentDidMount",
      value: function() {
        if (this.props.spy || this.props.hashSpy) {
          var s = this.getScrollSpyContainer();
          if (!Pg.default.isMounted(s)) {
            var l = Pg.default.mount(s, this.props.spyThrottle);
            this.beforeUnmountCallbacks.push(l);
          }
          this.props.hashSpy && (La.default.isMounted() || La.default.mount(n), La.default.mapContainer(this.props.to, s)), Pg.default.addSpyHandler(this.spyHandler, s), this.setState({
            container: s
          });
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        Pg.default.unmount(this.stateHandler, this.spyHandler), this.beforeUnmountCallbacks.forEach(function(s) {
          return s();
        });
      }
    }, {
      key: "render",
      value: function() {
        var s = "";
        this.state && this.state.active ? s = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : s = this.props.className;
        var l = {};
        this.state && this.state.active ? l = Lg({}, this.props.style, this.props.activeStyle) : l = Lg({}, this.props.style);
        var u = Lg({}, this.props);
        for (var c in uF)
          u.hasOwnProperty(c) && delete u[c];
        return u.className = s, u.style = l, u.onClick = this.handleClick, lF.default.createElement(e, u);
      }
    }]), a;
  }(lF.default.PureComponent), o = function() {
    var i = this;
    this.scrollTo = function(a, s) {
      n.scrollTo(a, Lg({}, i.state, s));
    }, this.handleClick = function(a) {
      i.props.onClick && i.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), i.scrollTo(i.props.to, i.props);
    }, this.spyHandler = function(a, s) {
      var l = i.getScrollSpyContainer();
      if (!(La.default.isMounted() && !La.default.isInitialized())) {
        var u = i.props.horizontal, c = i.props.to, p = null, d = void 0, g = void 0;
        if (u) {
          var f = 0, m = 0, v = 0;
          if (l.getBoundingClientRect) {
            var E = l.getBoundingClientRect();
            v = E.left;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var w = p.getBoundingClientRect();
            f = w.left - v + a, m = f + w.width;
          }
          var M = a - i.props.offset;
          d = M >= Math.floor(f) && M < Math.floor(m), g = M < Math.floor(f) || M >= Math.floor(m);
        } else {
          var O = 0, y = 0, C = 0;
          if (l.getBoundingClientRect) {
            var _ = l.getBoundingClientRect();
            C = _.top;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var F = p.getBoundingClientRect();
            O = F.top - C + s, y = O + F.height;
          }
          var L = s - i.props.offset;
          d = L >= Math.floor(O) && L < Math.floor(y), g = L < Math.floor(O) || L >= Math.floor(y);
        }
        var N = n.getActiveLink();
        if (g) {
          if (c === N && n.setActiveLink(void 0), i.props.hashSpy && La.default.getHash() === c) {
            var R = i.props.saveHashHistory, W = R === void 0 ? !1 : R;
            La.default.changeHash("", W);
          }
          i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive(c, p));
        }
        if (d && (N !== c || i.state.active === !1)) {
          n.setActiveLink(c);
          var V = i.props.saveHashHistory, z = V === void 0 ? !1 : V;
          i.props.hashSpy && La.default.changeHash(c, z), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(c, p));
        }
      }
    };
  };
  return r.propTypes = uF, r.defaultProps = { offset: 0 }, r;
};
Object.defineProperty(a_, "__esModule", {
  value: !0
});
var WEe = we, cF = Iq(WEe), VEe = Df, ZEe = Iq(VEe);
function Iq(e) {
  return e && e.__esModule ? e : { default: e };
}
function qEe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function pF(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function GEe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var KEe = function(e) {
  GEe(t, e);
  function t() {
    var n, r, o, i;
    qEe(this, t);
    for (var a = arguments.length, s = Array(a), l = 0; l < a; l++)
      s[l] = arguments[l];
    return i = (r = (o = pF(this, (n = t.__proto__ || Object.getPrototypeOf(t)).call.apply(n, [this].concat(s))), o), o.render = function() {
      return cF.default.createElement(
        "a",
        o.props,
        o.props.children
      );
    }, r), pF(o, i);
  }
  return t;
}(cF.default.Component);
a_.default = (0, ZEe.default)(KEe);
var f_ = {};
Object.defineProperty(f_, "__esModule", {
  value: !0
});
var YEe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), XEe = we, dF = Rq(XEe), JEe = Df, QEe = Rq(JEe);
function Rq(e) {
  return e && e.__esModule ? e : { default: e };
}
function eke(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function tke(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function nke(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var rke = function(e) {
  nke(t, e);
  function t() {
    return eke(this, t), tke(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return YEe(t, [{
    key: "render",
    value: function() {
      return dF.default.createElement(
        "button",
        this.props,
        this.props.children
      );
    }
  }]), t;
}(dF.default.Component);
f_.default = (0, QEe.default)(rke);
var h_ = {}, Uw = {};
Object.defineProperty(Uw, "__esModule", {
  value: !0
});
var oke = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, ike = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), ske = we, fF = Hw(ske), ake = pl;
Hw(ake);
var lke = Tc, hF = Hw(lke), uke = Fw, gF = Hw(uke);
function Hw(e) {
  return e && e.__esModule ? e : { default: e };
}
function cke(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function pke(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function dke(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
Uw.default = function(e) {
  var t = function(n) {
    dke(r, n);
    function r(o) {
      cke(this, r);
      var i = pke(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
      return i.childBindings = {
        domNode: null
      }, i;
    }
    return ike(r, [{
      key: "componentDidMount",
      value: function() {
        if (typeof window > "u")
          return !1;
        this.registerElems(this.props.name);
      }
    }, {
      key: "componentDidUpdate",
      value: function(o) {
        this.props.name !== o.name && this.registerElems(this.props.name);
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        if (typeof window > "u")
          return !1;
        hF.default.unregister(this.props.name);
      }
    }, {
      key: "registerElems",
      value: function(o) {
        hF.default.register(o, this.childBindings.domNode);
      }
    }, {
      key: "render",
      value: function() {
        return fF.default.createElement(e, oke({}, this.props, { parentBindings: this.childBindings }));
      }
    }]), r;
  }(fF.default.Component);
  return t.propTypes = {
    name: gF.default.string,
    id: gF.default.string
  }, t;
};
Object.defineProperty(h_, "__esModule", {
  value: !0
});
var mF = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, fke = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), hke = we, vF = g_(hke), gke = Uw, mke = g_(gke), vke = Fw, yF = g_(vke);
function g_(e) {
  return e && e.__esModule ? e : { default: e };
}
function yke(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function bke(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function wke(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var Bq = function(e) {
  wke(t, e);
  function t() {
    return yke(this, t), bke(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return fke(t, [{
    key: "render",
    value: function() {
      var n = this, r = mF({}, this.props);
      return delete r.name, r.parentBindings && delete r.parentBindings, vF.default.createElement(
        "div",
        mF({}, r, { ref: function(o) {
          n.props.parentBindings.domNode = o;
        } }),
        this.props.children
      );
    }
  }]), t;
}(vF.default.Component);
Bq.propTypes = {
  name: yF.default.string,
  id: yF.default.string
};
h_.default = (0, mke.default)(Bq);
var sx = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, bF = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}();
function wF(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function CF(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function xF(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var _g = we, Nl = Tf, ax = Tc, Yr = Fw, Pa = zw, OF = {
  to: Yr.string.isRequired,
  containerId: Yr.string,
  container: Yr.object,
  activeClass: Yr.string,
  spy: Yr.bool,
  smooth: Yr.oneOfType([Yr.bool, Yr.string]),
  offset: Yr.number,
  delay: Yr.number,
  isDynamic: Yr.bool,
  onClick: Yr.func,
  duration: Yr.oneOfType([Yr.number, Yr.func]),
  absolute: Yr.bool,
  onSetActive: Yr.func,
  onSetInactive: Yr.func,
  ignoreCancelEvents: Yr.bool,
  hashSpy: Yr.bool,
  spyThrottle: Yr.number
}, Cke = {
  Scroll: function(e, t) {
    console.warn("Helpers.Scroll is deprecated since v1.7.0");
    var n = t || ax, r = function(i) {
      xF(a, i);
      function a(s) {
        wF(this, a);
        var l = CF(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
        return o.call(l), l.state = {
          active: !1
        }, l;
      }
      return bF(a, [{
        key: "getScrollSpyContainer",
        value: function() {
          var s = this.props.containerId, l = this.props.container;
          return s ? document.getElementById(s) : l && l.nodeType ? l : document;
        }
      }, {
        key: "componentDidMount",
        value: function() {
          if (this.props.spy || this.props.hashSpy) {
            var s = this.getScrollSpyContainer();
            Nl.isMounted(s) || Nl.mount(s, this.props.spyThrottle), this.props.hashSpy && (Pa.isMounted() || Pa.mount(n), Pa.mapContainer(this.props.to, s)), this.props.spy && Nl.addStateHandler(this.stateHandler), Nl.addSpyHandler(this.spyHandler, s), this.setState({
              container: s
            });
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          Nl.unmount(this.stateHandler, this.spyHandler);
        }
      }, {
        key: "render",
        value: function() {
          var s = "";
          this.state && this.state.active ? s = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : s = this.props.className;
          var l = sx({}, this.props);
          for (var u in OF)
            l.hasOwnProperty(u) && delete l[u];
          return l.className = s, l.onClick = this.handleClick, _g.createElement(e, l);
        }
      }]), a;
    }(_g.Component), o = function() {
      var i = this;
      this.scrollTo = function(a, s) {
        n.scrollTo(a, sx({}, i.state, s));
      }, this.handleClick = function(a) {
        i.props.onClick && i.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), i.scrollTo(i.props.to, i.props);
      }, this.stateHandler = function() {
        n.getActiveLink() !== i.props.to && (i.state !== null && i.state.active && i.props.onSetInactive && i.props.onSetInactive(), i.setState({ active: !1 }));
      }, this.spyHandler = function(a) {
        var s = i.getScrollSpyContainer();
        if (!(Pa.isMounted() && !Pa.isInitialized())) {
          var l = i.props.to, u = null, c = 0, p = 0, d = 0;
          if (s.getBoundingClientRect) {
            var g = s.getBoundingClientRect();
            d = g.top;
          }
          if (!u || i.props.isDynamic) {
            if (u = n.get(l), !u)
              return;
            var f = u.getBoundingClientRect();
            c = f.top - d + a, p = c + f.height;
          }
          var m = a - i.props.offset, v = m >= Math.floor(c) && m < Math.floor(p), E = m < Math.floor(c) || m >= Math.floor(p), w = n.getActiveLink();
          if (E)
            return l === w && n.setActiveLink(void 0), i.props.hashSpy && Pa.getHash() === l && Pa.changeHash(), i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive()), Nl.updateStates();
          if (v && w !== l)
            return n.setActiveLink(l), i.props.hashSpy && Pa.changeHash(l), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(l)), Nl.updateStates();
        }
      };
    };
    return r.propTypes = OF, r.defaultProps = { offset: 0 }, r;
  },
  Element: function(e) {
    console.warn("Helpers.Element is deprecated since v1.7.0");
    var t = function(n) {
      xF(r, n);
      function r(o) {
        wF(this, r);
        var i = CF(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
        return i.childBindings = {
          domNode: null
        }, i;
      }
      return bF(r, [{
        key: "componentDidMount",
        value: function() {
          if (typeof window > "u")
            return !1;
          this.registerElems(this.props.name);
        }
      }, {
        key: "componentDidUpdate",
        value: function(o) {
          this.props.name !== o.name && this.registerElems(this.props.name);
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          if (typeof window > "u")
            return !1;
          ax.unregister(this.props.name);
        }
      }, {
        key: "registerElems",
        value: function(o) {
          ax.register(o, this.childBindings.domNode);
        }
      }, {
        key: "render",
        value: function() {
          return _g.createElement(e, sx({}, this.props, { parentBindings: this.childBindings }));
        }
      }]), r;
    }(_g.Component);
    return t.propTypes = {
      name: Yr.string,
      id: Yr.string
    }, t;
  }
}, xke = Cke;
Object.defineProperty(co, "__esModule", {
  value: !0
});
co.Helpers = co.ScrollElement = co.ScrollLink = co.animateScroll = co.scrollSpy = co.Events = co.scroller = co.Element = co.Button = co.Link = void 0;
var Oke = a_, Nq = Is(Oke), Eke = f_, Fq = Is(Eke), kke = h_, zq = Is(kke), Lke = Tc, Uq = Is(Lke), Pke = If, Hq = Is(Pke), _ke = Tf, $q = Is(_ke), Ske = Rw, Wq = Is(Ske), Mke = Df, Vq = Is(Mke), Dke = Uw, Zq = Is(Dke), Tke = xke, qq = Is(Tke);
function Is(e) {
  return e && e.__esModule ? e : { default: e };
}
co.Link = Nq.default;
co.Button = Fq.default;
co.Element = zq.default;
co.scroller = Uq.default;
co.Events = Hq.default;
co.scrollSpy = $q.default;
co.animateScroll = Wq.default;
co.ScrollLink = Vq.default;
co.ScrollElement = Zq.default;
co.Helpers = qq.default;
co.default = { Link: Nq.default, Button: Fq.default, Element: zq.default, scroller: Uq.default, Events: Hq.default, scrollSpy: $q.default, animateScroll: Wq.default, ScrollLink: Vq.default, ScrollElement: Zq.default, Helpers: qq.default };
Ke({});
Ke({});
Ke({});
function rf(e) {
  "@babel/helpers - typeof";
  return rf = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, rf(e);
}
function jke(e, t) {
  if (rf(e) != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (rf(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function Ake(e) {
  var t = jke(e, "string");
  return rf(t) == "symbol" ? t : t + "";
}
function Oe(e, t, n) {
  return (t = Ake(t)) in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function Gq(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var lx, EF;
function Ike() {
  if (EF) return lx;
  EF = 1;
  var e = process.env.NODE_ENV, t = function(n, r, o, i, a, s, l, u) {
    if (e !== "production" && r === void 0)
      throw new Error("invariant requires an error message argument");
    if (!n) {
      var c;
      if (r === void 0)
        c = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
      else {
        var p = [o, i, a, s, l, u], d = 0;
        c = new Error(r.replace(/%s/g, function() {
          return p[d++];
        })), c.name = "Invariant Violation";
      }
      throw c.framesToPop = 1, c;
    }
  };
  return lx = t, lx;
}
var Rke = Ike(), wo = /* @__PURE__ */ Gq(Rke), At = Ke(null);
function Bke() {
  wo(!!ge, "useGoogleMap is React hook and requires React version 16.8+");
  var e = ge(At);
  return wo(!!e, "useGoogleMap needs a GoogleMap available up in the tree"), e;
}
function Nke(e, t, n) {
  return Object.keys(e).reduce(function(r, o) {
    return t(r, e[o], o);
  }, n);
}
function Fke(e, t) {
  Object.keys(e).forEach((n) => t(e[n], n));
}
function zke(e, t, n, r) {
  var o = {}, i = (a, s) => {
    var l = n[s];
    l !== t[s] && (o[s] = l, a(r, l));
  };
  return Fke(e, i), o;
}
function Uke(e, t, n) {
  var r = Nke(n, function(o, i, a) {
    return typeof e[a] == "function" && o.push(google.maps.event.addListener(t, i, e[a])), o;
  }, []);
  return r;
}
function Hke(e) {
  google.maps.event.removeListener(e);
}
function gn() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  e.forEach(Hke);
}
function un(e) {
  var {
    updaterMap: t,
    eventMap: n,
    prevProps: r,
    nextProps: o,
    instance: i
  } = e, a = Uke(o, i, n);
  return zke(t, r, o, i), a;
}
function $ke(e) {
  var {
    children: t,
    options: n,
    id: r,
    mapContainerStyle: o,
    mapContainerClassName: i,
    center: a,
    // clickableIcons,
    // extraMapTypes,
    // heading,
    // mapTypeId,
    onClick: s,
    onDblClick: l,
    onDrag: u,
    onDragEnd: c,
    onDragStart: p,
    onMouseMove: d,
    onMouseOut: g,
    onMouseOver: f,
    onMouseDown: m,
    onMouseUp: v,
    onRightClick: E,
    // onMapTypeIdChanged,
    // onTilesLoaded,
    // onBoundsChanged,
    onCenterChanged: w,
    // onHeadingChanged,
    // onIdle,
    // onProjectionChanged,
    // onResize,
    // onTiltChanged,
    // onZoomChanged,
    onLoad: M,
    onUnmount: O
  } = e, [y, C] = k(null), _ = ut(null), [F, L] = k(null), [N, R] = k(null), [W, V] = k(null), [z, Z] = k(null), [K, X] = k(null), [te, J] = k(null), [P, D] = k(null), [H, S] = k(null), [$, x] = k(null), [j, U] = k(null), [T, q] = k(null), [A, Y] = k(null);
  return h(() => {
    n && y !== null && y.setOptions(n);
  }, [y, n]), h(() => {
    y !== null && typeof a < "u" && y.setCenter(a);
  }, [y, a]), h(() => {
    y && l && (N !== null && google.maps.event.removeListener(N), R(google.maps.event.addListener(y, "dblclick", l)));
  }, [l]), h(() => {
    y && c && (W !== null && google.maps.event.removeListener(W), V(google.maps.event.addListener(y, "dragend", c)));
  }, [c]), h(() => {
    y && p && (z !== null && google.maps.event.removeListener(z), Z(google.maps.event.addListener(y, "dragstart", p)));
  }, [p]), h(() => {
    y && m && (K !== null && google.maps.event.removeListener(K), X(google.maps.event.addListener(y, "mousedown", m)));
  }, [m]), h(() => {
    y && d && (te !== null && google.maps.event.removeListener(te), J(google.maps.event.addListener(y, "mousemove", d)));
  }, [d]), h(() => {
    y && g && (P !== null && google.maps.event.removeListener(P), D(google.maps.event.addListener(y, "mouseout", g)));
  }, [g]), h(() => {
    y && f && (H !== null && google.maps.event.removeListener(H), S(google.maps.event.addListener(y, "mouseover", f)));
  }, [f]), h(() => {
    y && v && ($ !== null && google.maps.event.removeListener($), x(google.maps.event.addListener(y, "mouseup", v)));
  }, [v]), h(() => {
    y && E && (j !== null && google.maps.event.removeListener(j), U(google.maps.event.addListener(y, "rightclick", E)));
  }, [E]), h(() => {
    y && s && (T !== null && google.maps.event.removeListener(T), q(google.maps.event.addListener(y, "click", s)));
  }, [s]), h(() => {
    y && u && (A !== null && google.maps.event.removeListener(A), Y(google.maps.event.addListener(y, "drag", u)));
  }, [u]), h(() => {
    y && w && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(y, "center_changed", w)));
  }, [s]), h(() => {
    var B = _.current === null ? null : new google.maps.Map(_.current, n);
    return C(B), B !== null && M && M(B), () => {
      B !== null && O && O(B);
    };
  }, []), So.jsx("div", {
    id: r,
    ref: _,
    style: o,
    className: i,
    children: So.jsx(At.Provider, {
      value: y,
      children: y !== null ? t : null
    })
  });
}
ve($ke);
function kF(e, t, n, r, o, i, a) {
  try {
    var s = e[i](a), l = s.value;
  } catch (u) {
    return void n(u);
  }
  s.done ? t(l) : Promise.resolve(l).then(r, o);
}
function Kq(e) {
  return function() {
    var t = this, n = arguments;
    return new Promise(function(r, o) {
      var i = e.apply(t, n);
      function a(l) {
        kF(i, r, o, a, s, "next", l);
      }
      function s(l) {
        kF(i, r, o, a, s, "throw", l);
      }
      a(void 0);
    });
  };
}
function Yq(e) {
  var {
    googleMapsApiKey: t,
    googleMapsClientId: n,
    version: r = "weekly",
    language: o,
    region: i,
    libraries: a,
    channel: s,
    mapIds: l,
    authReferrerPolicy: u
  } = e, c = [];
  return wo(t && n || !(t && n), "You need to specify either googleMapsApiKey or googleMapsClientId for @react-google-maps/api load script to work. You cannot use both at the same time."), t ? c.push("key=".concat(t)) : n && c.push("client=".concat(n)), r && c.push("v=".concat(r)), o && c.push("language=".concat(o)), i && c.push("region=".concat(i)), a && a.length && c.push("libraries=".concat(a.sort().join(","))), s && c.push("channel=".concat(s)), l && l.length && c.push("map_ids=".concat(l.join(","))), u && c.push("auth_referrer_policy=".concat(u)), c.push("loading=async"), c.push("callback=initMap"), "https://maps.googleapis.com/maps/api/js?".concat(c.join("&"));
}
var du = typeof document < "u";
function Xq(e) {
  var {
    url: t,
    id: n,
    nonce: r
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } = e;
  return du ? new Promise(function(o, i) {
    var a = document.getElementById(n), s = window;
    if (a) {
      var l = a.getAttribute("data-state");
      if (a.src === t && l !== "error") {
        if (l === "ready")
          return o(n);
        var u = s.initMap, c = a.onerror;
        s.initMap = function() {
          u && u(), o(n);
        }, a.onerror = function(d) {
          c && c(d), i(d);
        };
        return;
      } else
        a.remove();
    }
    var p = document.createElement("script");
    p.type = "text/javascript", p.src = t, p.id = n, p.async = !0, p.nonce = r || "", p.onerror = function(d) {
      p.setAttribute("data-state", "error"), i(d);
    }, s.initMap = function() {
      p.setAttribute("data-state", "ready"), o(n);
    }, document.head.appendChild(p);
  }).catch((o) => {
    throw console.error("injectScript error: ", o), o;
  }) : Promise.reject(new Error("document is undefined"));
}
function LF(e) {
  var t = e.href;
  return t && (t.indexOf("https://fonts.googleapis.com/css?family=Roboto") === 0 || t.indexOf("https://fonts.googleapis.com/css?family=Google+Sans+Text") === 0) ? !0 : (
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.styleSheet.cssText = "", !0) : (
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.innerHTML = "", !0) : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.innerHTML
      )
    )
  );
}
function Jq() {
  var e = document.getElementsByTagName("head")[0];
  if (e) {
    var t = e.insertBefore.bind(e);
    e.insertBefore = function(r, o) {
      return LF(r) || Reflect.apply(t, e, [r, o]), r;
    };
    var n = e.appendChild.bind(e);
    e.appendChild = function(r) {
      return LF(r) || Reflect.apply(n, e, [r]), r;
    };
  }
}
var up = !1;
function Qq() {
  return So.jsx("div", {
    children: "Loading..."
  });
}
var Sk = {
  id: "script-loader",
  version: "weekly"
};
class Wke extends pe {
  constructor() {
    super(...arguments), Oe(this, "check", null), Oe(this, "state", {
      loaded: !1
    }), Oe(this, "cleanupCallback", () => {
      delete window.google.maps, this.injectScript();
    }), Oe(this, "isCleaningUp", /* @__PURE__ */ Kq(function* () {
      function t(n) {
        if (!up)
          n();
        else if (du)
          var r = window.setInterval(function() {
            up || (window.clearInterval(r), n());
          }, 1);
      }
      return new Promise(t);
    })), Oe(this, "cleanup", () => {
      up = !0;
      var t = document.getElementById(this.props.id);
      t && t.parentNode && t.parentNode.removeChild(t), Array.prototype.slice.call(document.getElementsByTagName("script")).filter(function(n) {
        return typeof n.src == "string" && n.src.includes("maps.googleapis");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("link")).filter(function(n) {
        return n.href === "https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Google+Sans";
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("style")).filter(function(n) {
        return n.innerText !== void 0 && n.innerText.length > 0 && n.innerText.includes(".gm-");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      });
    }), Oe(this, "injectScript", () => {
      this.props.preventGoogleFontsLoading && Jq(), wo(!!this.props.id, 'LoadScript requires "id" prop to be a string: %s', this.props.id);
      var t = {
        id: this.props.id,
        nonce: this.props.nonce,
        url: Yq(this.props)
      };
      Xq(t).then(() => {
        this.props.onLoad && this.props.onLoad(), this.setState(function() {
          return {
            loaded: !0
          };
        });
      }).catch((n) => {
        this.props.onError && this.props.onError(n), console.error(`
          There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(this.props.googleMapsApiKey || "-", ") or Client ID (").concat(this.props.googleMapsClientId || "-", `) to <LoadScript />
          Otherwise it is a Network issue.
        `));
      });
    }), Oe(this, "getRef", (t) => {
      this.check = t;
    });
  }
  componentDidMount() {
    if (du) {
      if (window.google && window.google.maps && !up) {
        console.error("google api is already presented");
        return;
      }
      this.isCleaningUp().then(this.injectScript).catch(function(t) {
        console.error("Error at injecting script after cleaning up: ", t);
      });
    }
  }
  componentDidUpdate(t) {
    this.props.libraries !== t.libraries && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), du && t.language !== this.props.language && (this.cleanup(), this.setState(function() {
      return {
        loaded: !1
      };
    }, this.cleanupCallback));
  }
  componentWillUnmount() {
    if (du) {
      this.cleanup();
      var t = () => {
        this.check || (delete window.google, up = !1);
      };
      window.setTimeout(t, 1), this.props.onUnmount && this.props.onUnmount();
    }
  }
  render() {
    return So.jsxs(So.Fragment, {
      children: [So.jsx("div", {
        ref: this.getRef
      }), this.state.loaded ? this.props.children : this.props.loadingElement || So.jsx(Qq, {})]
    });
  }
}
Oe(Wke, "defaultProps", Sk);
function Vke(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.includes(r)) continue;
    n[r] = e[r];
  }
  return n;
}
function m_(e, t) {
  if (e == null) return {};
  var n, r, o = Vke(e, t);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (r = 0; r < i.length; r++) n = i[r], t.includes(n) || {}.propertyIsEnumerable.call(e, n) && (o[n] = e[n]);
  }
  return o;
}
var PF;
function Zke(e) {
  var {
    id: t = Sk.id,
    version: n = Sk.version,
    nonce: r,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    preventGoogleFontsLoading: u,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  } = e, g = ut(!1), [f, m] = k(!1), [v, E] = k(void 0);
  h(function() {
    return g.current = !0, () => {
      g.current = !1;
    };
  }, []), h(function() {
    du && u && Jq();
  }, [u]), h(function() {
    f && wo(!!window.google, "useLoadScript was marked as loaded, but window.google is not present. Something went wrong.");
  }, [f]);
  var w = Yq({
    version: n,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  });
  h(function() {
    if (!du)
      return;
    function O() {
      g.current && (m(!0), PF = w);
    }
    if (window.google && window.google.maps && PF === w) {
      O();
      return;
    }
    Xq({
      id: t,
      url: w,
      nonce: r
    }).then(O).catch(function(y) {
      g.current && E(y), console.warn(`
        There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(o || "-", ") or Client ID (").concat(i || "-", `)
        Otherwise it is a Network issue.
      `)), console.error(y);
    });
  }, [t, w, r]);
  var M = ut(void 0);
  return h(function() {
    M.current && l !== M.current && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), M.current = l;
  }, [l]), {
    isLoaded: f,
    loadError: v,
    url: w
  };
}
var qke = ["loadingElement", "onLoad", "onError", "onUnmount", "children"], Gke = So.jsx(Qq, {});
function Kke(e) {
  var {
    loadingElement: t,
    onLoad: n,
    onError: r,
    onUnmount: o,
    children: i
  } = e, a = m_(e, qke), {
    isLoaded: s,
    loadError: l
  } = Zke(a);
  return h(function() {
    s && typeof n == "function" && n();
  }, [s, n]), h(function() {
    l && typeof r == "function" && r(l);
  }, [l, r]), h(function() {
    return () => {
      o && o();
    };
  }, [o]), s ? i : t || Gke;
}
ve(Kke);
var _F;
(function(e) {
  e[e.INITIALIZED = 0] = "INITIALIZED", e[e.LOADING = 1] = "LOADING", e[e.SUCCESS = 2] = "SUCCESS", e[e.FAILURE = 3] = "FAILURE";
})(_F || (_F = {}));
function SF(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Zv(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? SF(Object(n), !0).forEach(function(r) {
      Oe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : SF(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var MF = {}, DF = {
  options(e, t) {
    e.setOptions(t);
  }
};
function Yke(e) {
  var {
    options: t,
    onLoad: n,
    onUnmount: r
  } = e, o = ge(At), [i, a] = k(null);
  return h(() => {
    i !== null && i.setMap(o);
  }, [o]), h(() => {
    t && i !== null && i.setOptions(t);
  }, [i, t]), h(() => {
    var s = new google.maps.TrafficLayer(Zv(Zv({}, t), {}, {
      map: o
    }));
    return a(s), n && n(s), () => {
      i !== null && (r && r(i), i.setMap(null));
    };
  }, []), null;
}
ve(Yke);
class Xke extends pe {
  constructor() {
    super(...arguments), Oe(this, "state", {
      trafficLayer: null
    }), Oe(this, "setTrafficLayerCallback", () => {
      this.state.trafficLayer !== null && this.props.onLoad && this.props.onLoad(this.state.trafficLayer);
    }), Oe(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = new google.maps.TrafficLayer(Zv(Zv({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = un({
      updaterMap: DF,
      eventMap: MF,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        trafficLayer: t
      };
    }, this.setTrafficLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.trafficLayer !== null && (gn(this.registeredEvents), this.registeredEvents = un({
      updaterMap: DF,
      eventMap: MF,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.trafficLayer
    }));
  }
  componentWillUnmount() {
    this.state.trafficLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.trafficLayer), gn(this.registeredEvents), this.state.trafficLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Oe(Xke, "contextType", At);
function Jke(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = ge(At), [o, i] = k(null);
  return h(() => {
    o !== null && o.setMap(r);
  }, [r]), h(() => {
    var a = new google.maps.BicyclingLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      a !== null && (n && n(a), a.setMap(null));
    };
  }, []), null;
}
ve(Jke);
class Qke extends pe {
  constructor() {
    super(...arguments), Oe(this, "state", {
      bicyclingLayer: null
    }), Oe(this, "setBicyclingLayerCallback", () => {
      this.state.bicyclingLayer !== null && (this.state.bicyclingLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.bicyclingLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.BicyclingLayer();
    this.setState(() => ({
      bicyclingLayer: t
    }), this.setBicyclingLayerCallback);
  }
  componentWillUnmount() {
    this.state.bicyclingLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.bicyclingLayer), this.state.bicyclingLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Oe(Qke, "contextType", At);
function e1e(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = ge(At), [o, i] = k(null);
  return h(() => {
    o !== null && o.setMap(r);
  }, [r]), h(() => {
    var a = new google.maps.TransitLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      o !== null && (n && n(o), o.setMap(null));
    };
  }, []), null;
}
ve(e1e);
class t1e extends pe {
  constructor() {
    super(...arguments), Oe(this, "state", {
      transitLayer: null
    }), Oe(this, "setTransitLayerCallback", () => {
      this.state.transitLayer !== null && (this.state.transitLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.transitLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.TransitLayer();
    this.setState(function() {
      return {
        transitLayer: t
      };
    }, this.setTransitLayerCallback);
  }
  componentWillUnmount() {
    this.state.transitLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.transitLayer), this.state.transitLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Oe(t1e, "contextType", At);
function TF(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function qv(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? TF(Object(n), !0).forEach(function(r) {
      Oe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : TF(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var jF = {
  onCircleComplete: "circlecomplete",
  onMarkerComplete: "markercomplete",
  onOverlayComplete: "overlaycomplete",
  onPolygonComplete: "polygoncomplete",
  onPolylineComplete: "polylinecomplete",
  onRectangleComplete: "rectanglecomplete"
}, AF = {
  drawingMode(e, t) {
    e.setDrawingMode(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function n1e(e) {
  var {
    options: t,
    drawingMode: n,
    onCircleComplete: r,
    onMarkerComplete: o,
    onOverlayComplete: i,
    onPolygonComplete: a,
    onPolylineComplete: s,
    onRectangleComplete: l,
    onLoad: u,
    onUnmount: c
  } = e, p = ge(At), [d, g] = k(null), [f, m] = k(null), [v, E] = k(null), [w, M] = k(null), [O, y] = k(null), [C, _] = k(null), [F, L] = k(null);
  return h(() => {
    d !== null && d.setMap(p);
  }, [p]), h(() => {
    t && d !== null && d.setOptions(t);
  }, [d, t]), h(() => {
    d !== null && d.setDrawingMode(n ?? null);
  }, [d, n]), h(() => {
    d && r && (f !== null && google.maps.event.removeListener(f), m(google.maps.event.addListener(d, "circlecomplete", r)));
  }, [d, r]), h(() => {
    d && o && (v !== null && google.maps.event.removeListener(v), E(google.maps.event.addListener(d, "markercomplete", o)));
  }, [d, o]), h(() => {
    d && i && (w !== null && google.maps.event.removeListener(w), M(google.maps.event.addListener(d, "overlaycomplete", i)));
  }, [d, i]), h(() => {
    d && a && (O !== null && google.maps.event.removeListener(O), y(google.maps.event.addListener(d, "polygoncomplete", a)));
  }, [d, a]), h(() => {
    d && s && (C !== null && google.maps.event.removeListener(C), _(google.maps.event.addListener(d, "polylinecomplete", s)));
  }, [d, s]), h(() => {
    d && l && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(d, "rectanglecomplete", l)));
  }, [d, l]), h(() => {
    wo(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
    var N = new google.maps.drawing.DrawingManager(qv(qv({}, t), {}, {
      map: p
    }));
    return n && N.setDrawingMode(n), r && m(google.maps.event.addListener(N, "circlecomplete", r)), o && E(google.maps.event.addListener(N, "markercomplete", o)), i && M(google.maps.event.addListener(N, "overlaycomplete", i)), a && y(google.maps.event.addListener(N, "polygoncomplete", a)), s && _(google.maps.event.addListener(N, "polylinecomplete", s)), l && L(google.maps.event.addListener(N, "rectanglecomplete", l)), g(N), u && u(N), () => {
      d !== null && (f && google.maps.event.removeListener(f), v && google.maps.event.removeListener(v), w && google.maps.event.removeListener(w), O && google.maps.event.removeListener(O), C && google.maps.event.removeListener(C), F && google.maps.event.removeListener(F), c && c(d), d.setMap(null));
    };
  }, []), null;
}
ve(n1e);
class r1e extends pe {
  constructor(t) {
    super(t), Oe(this, "registeredEvents", []), Oe(this, "state", {
      drawingManager: null
    }), Oe(this, "setDrawingManagerCallback", () => {
      this.state.drawingManager !== null && this.props.onLoad && this.props.onLoad(this.state.drawingManager);
    }), wo(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
  }
  componentDidMount() {
    var t = new google.maps.drawing.DrawingManager(qv(qv({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = un({
      updaterMap: AF,
      eventMap: jF,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        drawingManager: t
      };
    }, this.setDrawingManagerCallback);
  }
  componentDidUpdate(t) {
    this.state.drawingManager !== null && (gn(this.registeredEvents), this.registeredEvents = un({
      updaterMap: AF,
      eventMap: jF,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.drawingManager
    }));
  }
  componentWillUnmount() {
    this.state.drawingManager !== null && (this.props.onUnmount && this.props.onUnmount(this.state.drawingManager), gn(this.registeredEvents), this.state.drawingManager.setMap(null));
  }
  render() {
    return null;
  }
}
Oe(r1e, "contextType", At);
function IF(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ic(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? IF(Object(n), !0).forEach(function(r) {
      Oe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : IF(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var RF = {
  onAnimationChanged: "animation_changed",
  onClick: "click",
  onClickableChanged: "clickable_changed",
  onCursorChanged: "cursor_changed",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDraggableChanged: "draggable_changed",
  onDragStart: "dragstart",
  onFlatChanged: "flat_changed",
  onIconChanged: "icon_changed",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onPositionChanged: "position_changed",
  onRightClick: "rightclick",
  onShapeChanged: "shape_changed",
  onTitleChanged: "title_changed",
  onVisibleChanged: "visible_changed",
  onZindexChanged: "zindex_changed"
}, BF = {
  animation(e, t) {
    e.setAnimation(t);
  },
  clickable(e, t) {
    e.setClickable(t);
  },
  cursor(e, t) {
    e.setCursor(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  icon(e, t) {
    e.setIcon(t);
  },
  label(e, t) {
    e.setLabel(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  opacity(e, t) {
    e.setOpacity(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  shape(e, t) {
    e.setShape(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, Gv = {};
function o1e(e) {
  var {
    position: t,
    options: n,
    clusterer: r,
    noClustererRedraw: o,
    children: i,
    draggable: a,
    visible: s,
    animation: l,
    clickable: u,
    cursor: c,
    icon: p,
    label: d,
    opacity: g,
    shape: f,
    title: m,
    zIndex: v,
    onClick: E,
    onDblClick: w,
    onDrag: M,
    onDragEnd: O,
    onDragStart: y,
    onMouseOut: C,
    onMouseOver: _,
    onMouseUp: F,
    onMouseDown: L,
    onRightClick: N,
    onClickableChanged: R,
    onCursorChanged: W,
    onAnimationChanged: V,
    onDraggableChanged: z,
    onFlatChanged: Z,
    onIconChanged: K,
    onPositionChanged: X,
    onShapeChanged: te,
    onTitleChanged: J,
    onVisibleChanged: P,
    onZindexChanged: D,
    onLoad: H,
    onUnmount: S
  } = e, $ = ge(At), [x, j] = k(null), [U, T] = k(null), [q, A] = k(null), [Y, B] = k(null), [ue, fe] = k(null), [oe, Ae] = k(null), [Ze, Ge] = k(null), [Ie, et] = k(null), [Ye, _e] = k(null), [Qe, at] = k(null), [Pe, Me] = k(null), [Je, We] = k(null), [Re, nt] = k(null), [De, yt] = k(null), [ot, st] = k(null), [ct, bt] = k(null), [pt, dt] = k(null), [tt, Xe] = k(null), [wt, Ct] = k(null), [ft, bn] = k(null), [ht, wn] = k(null), [gt, Mt] = k(null);
  h(() => {
    x !== null && x.setMap($);
  }, [$]), h(() => {
    typeof n < "u" && x !== null && x.setOptions(n);
  }, [x, n]), h(() => {
    typeof a < "u" && x !== null && x.setDraggable(a);
  }, [x, a]), h(() => {
    t && x !== null && x.setPosition(t);
  }, [x, t]), h(() => {
    typeof s < "u" && x !== null && x.setVisible(s);
  }, [x, s]), h(() => {
    x == null || x.setAnimation(l);
  }, [x, l]), h(() => {
    x && u !== void 0 && x.setClickable(u);
  }, [x, u]), h(() => {
    x && c !== void 0 && x.setCursor(c);
  }, [x, c]), h(() => {
    x && p !== void 0 && x.setIcon(p);
  }, [x, p]), h(() => {
    x && d !== void 0 && x.setLabel(d);
  }, [x, d]), h(() => {
    x && g !== void 0 && x.setOpacity(g);
  }, [x, g]), h(() => {
    x && f !== void 0 && x.setShape(f);
  }, [x, f]), h(() => {
    x && m !== void 0 && x.setTitle(m);
  }, [x, m]), h(() => {
    x && v !== void 0 && x.setZIndex(v);
  }, [x, v]), h(() => {
    x && w && (U !== null && google.maps.event.removeListener(U), T(google.maps.event.addListener(x, "dblclick", w)));
  }, [w]), h(() => {
    x && O && (q !== null && google.maps.event.removeListener(q), A(google.maps.event.addListener(x, "dragend", O)));
  }, [O]), h(() => {
    x && y && (Y !== null && google.maps.event.removeListener(Y), B(google.maps.event.addListener(x, "dragstart", y)));
  }, [y]), h(() => {
    x && L && (ue !== null && google.maps.event.removeListener(ue), fe(google.maps.event.addListener(x, "mousedown", L)));
  }, [L]), h(() => {
    x && C && (oe !== null && google.maps.event.removeListener(oe), Ae(google.maps.event.addListener(x, "mouseout", C)));
  }, [C]), h(() => {
    x && _ && (Ze !== null && google.maps.event.removeListener(Ze), Ge(google.maps.event.addListener(x, "mouseover", _)));
  }, [_]), h(() => {
    x && F && (Ie !== null && google.maps.event.removeListener(Ie), et(google.maps.event.addListener(x, "mouseup", F)));
  }, [F]), h(() => {
    x && N && (Ye !== null && google.maps.event.removeListener(Ye), _e(google.maps.event.addListener(x, "rightclick", N)));
  }, [N]), h(() => {
    x && E && (Qe !== null && google.maps.event.removeListener(Qe), at(google.maps.event.addListener(x, "click", E)));
  }, [E]), h(() => {
    x && M && (Pe !== null && google.maps.event.removeListener(Pe), Me(google.maps.event.addListener(x, "drag", M)));
  }, [M]), h(() => {
    x && R && (Je !== null && google.maps.event.removeListener(Je), We(google.maps.event.addListener(x, "clickable_changed", R)));
  }, [R]), h(() => {
    x && W && (Re !== null && google.maps.event.removeListener(Re), nt(google.maps.event.addListener(x, "cursor_changed", W)));
  }, [W]), h(() => {
    x && V && (De !== null && google.maps.event.removeListener(De), yt(google.maps.event.addListener(x, "animation_changed", V)));
  }, [V]), h(() => {
    x && z && (ot !== null && google.maps.event.removeListener(ot), st(google.maps.event.addListener(x, "draggable_changed", z)));
  }, [z]), h(() => {
    x && Z && (ct !== null && google.maps.event.removeListener(ct), bt(google.maps.event.addListener(x, "flat_changed", Z)));
  }, [Z]), h(() => {
    x && K && (pt !== null && google.maps.event.removeListener(pt), dt(google.maps.event.addListener(x, "icon_changed", K)));
  }, [K]), h(() => {
    x && X && (tt !== null && google.maps.event.removeListener(tt), Xe(google.maps.event.addListener(x, "position_changed", X)));
  }, [X]), h(() => {
    x && te && (wt !== null && google.maps.event.removeListener(wt), Ct(google.maps.event.addListener(x, "shape_changed", te)));
  }, [te]), h(() => {
    x && J && (ft !== null && google.maps.event.removeListener(ft), bn(google.maps.event.addListener(x, "title_changed", J)));
  }, [J]), h(() => {
    x && P && (ht !== null && google.maps.event.removeListener(ht), wn(google.maps.event.addListener(x, "visible_changed", P)));
  }, [P]), h(() => {
    x && D && (gt !== null && google.maps.event.removeListener(gt), Mt(google.maps.event.addListener(x, "zindex_changed", D)));
  }, [D]), h(() => {
    var mt = ic(ic(ic({}, n || Gv), r ? Gv : {
      map: $
    }), {}, {
      position: t
    }), re = new google.maps.Marker(mt);
    return r ? r.addMarker(re, !!o) : re.setMap($), t && re.setPosition(t), typeof s < "u" && re.setVisible(s), typeof a < "u" && re.setDraggable(a), typeof u < "u" && re.setClickable(u), typeof c == "string" && re.setCursor(c), p && re.setIcon(p), typeof d < "u" && re.setLabel(d), typeof g < "u" && re.setOpacity(g), f && re.setShape(f), typeof m == "string" && re.setTitle(m), typeof v == "number" && re.setZIndex(v), w && T(google.maps.event.addListener(re, "dblclick", w)), O && A(google.maps.event.addListener(re, "dragend", O)), y && B(google.maps.event.addListener(re, "dragstart", y)), L && fe(google.maps.event.addListener(re, "mousedown", L)), C && Ae(google.maps.event.addListener(re, "mouseout", C)), _ && Ge(google.maps.event.addListener(re, "mouseover", _)), F && et(google.maps.event.addListener(re, "mouseup", F)), N && _e(google.maps.event.addListener(re, "rightclick", N)), E && at(google.maps.event.addListener(re, "click", E)), M && Me(google.maps.event.addListener(re, "drag", M)), R && We(google.maps.event.addListener(re, "clickable_changed", R)), W && nt(google.maps.event.addListener(re, "cursor_changed", W)), V && yt(google.maps.event.addListener(re, "animation_changed", V)), z && st(google.maps.event.addListener(re, "draggable_changed", z)), Z && bt(google.maps.event.addListener(re, "flat_changed", Z)), K && dt(google.maps.event.addListener(re, "icon_changed", K)), X && Xe(google.maps.event.addListener(re, "position_changed", X)), te && Ct(google.maps.event.addListener(re, "shape_changed", te)), J && bn(google.maps.event.addListener(re, "title_changed", J)), P && wn(google.maps.event.addListener(re, "visible_changed", P)), D && Mt(google.maps.event.addListener(re, "zindex_changed", D)), j(re), H && H(re), () => {
      U !== null && google.maps.event.removeListener(U), q !== null && google.maps.event.removeListener(q), Y !== null && google.maps.event.removeListener(Y), ue !== null && google.maps.event.removeListener(ue), oe !== null && google.maps.event.removeListener(oe), Ze !== null && google.maps.event.removeListener(Ze), Ie !== null && google.maps.event.removeListener(Ie), Ye !== null && google.maps.event.removeListener(Ye), Qe !== null && google.maps.event.removeListener(Qe), Je !== null && google.maps.event.removeListener(Je), Re !== null && google.maps.event.removeListener(Re), De !== null && google.maps.event.removeListener(De), ot !== null && google.maps.event.removeListener(ot), ct !== null && google.maps.event.removeListener(ct), pt !== null && google.maps.event.removeListener(pt), tt !== null && google.maps.event.removeListener(tt), ft !== null && google.maps.event.removeListener(ft), ht !== null && google.maps.event.removeListener(ht), gt !== null && google.maps.event.removeListener(gt), S && S(re), r ? r.removeMarker(re, !!o) : re && re.setMap(null);
    };
  }, []);
  var ir = Cn(() => i ? lt.map(i, (mt) => {
    if (!yi(mt))
      return mt;
    var re = mt;
    return bi(re, {
      anchor: x
    });
  }) : null, [i, x]);
  return So.jsx(So.Fragment, {
    children: ir
  }) || null;
}
ve(o1e);
class i1e extends pe {
  constructor() {
    super(...arguments), Oe(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this;
    return Kq(function* () {
      var n = ic(ic(ic({}, t.props.options || Gv), t.props.clusterer ? Gv : {
        map: t.context
      }), {}, {
        position: t.props.position
      });
      t.marker = new google.maps.Marker(n), t.props.clusterer ? t.props.clusterer.addMarker(t.marker, !!t.props.noClustererRedraw) : t.marker.setMap(t.context), t.registeredEvents = un({
        updaterMap: BF,
        eventMap: RF,
        prevProps: {},
        nextProps: t.props,
        instance: t.marker
      }), t.props.onLoad && t.props.onLoad(t.marker);
    })();
  }
  componentDidUpdate(t) {
    this.marker && (gn(this.registeredEvents), this.registeredEvents = un({
      updaterMap: BF,
      eventMap: RF,
      prevProps: t,
      nextProps: this.props,
      instance: this.marker
    }));
  }
  componentWillUnmount() {
    this.marker && (this.props.onUnmount && this.props.onUnmount(this.marker), gn(this.registeredEvents), this.props.clusterer ? this.props.clusterer.removeMarker(this.marker, !!this.props.noClustererRedraw) : this.marker && this.marker.setMap(null));
  }
  render() {
    var t = this.props.children ? lt.map(this.props.children, (n) => {
      if (!yi(n))
        return n;
      var r = n;
      return bi(r, {
        anchor: this.marker
      });
    }) : null;
    return t || null;
  }
}
Oe(i1e, "contextType", At);
var s1e = (
  /** @class */
  function() {
    function e(t, n) {
      t.getClusterer().extend(e, google.maps.OverlayView), this.cluster = t, this.clusterClassName = this.cluster.getClusterer().getClusterClass(), this.className = this.clusterClassName, this.styles = n, this.center = void 0, this.div = null, this.sums = null, this.visible = !1, this.boundsChangedListener = null, this.url = "", this.height = 0, this.width = 0, this.anchorText = [0, 0], this.anchorIcon = [0, 0], this.textColor = "black", this.textSize = 11, this.textDecoration = "none", this.fontWeight = "bold", this.fontStyle = "normal", this.fontFamily = "Arial,sans-serif", this.backgroundPosition = "0 0", this.cMouseDownInCluster = null, this.cDraggingMapByCluster = null, this.timeOut = null, this.setMap(t.getMap()), this.onBoundsChanged = this.onBoundsChanged.bind(this), this.onMouseDown = this.onMouseDown.bind(this), this.onClick = this.onClick.bind(this), this.onMouseOver = this.onMouseOver.bind(this), this.onMouseOut = this.onMouseOut.bind(this), this.onAdd = this.onAdd.bind(this), this.onRemove = this.onRemove.bind(this), this.draw = this.draw.bind(this), this.hide = this.hide.bind(this), this.show = this.show.bind(this), this.useStyle = this.useStyle.bind(this), this.setCenter = this.setCenter.bind(this), this.getPosFromLatLng = this.getPosFromLatLng.bind(this);
    }
    return e.prototype.onBoundsChanged = function() {
      this.cDraggingMapByCluster = this.cMouseDownInCluster;
    }, e.prototype.onMouseDown = function() {
      this.cMouseDownInCluster = !0, this.cDraggingMapByCluster = !1;
    }, e.prototype.onClick = function(t) {
      if (this.cMouseDownInCluster = !1, !this.cDraggingMapByCluster) {
        var n = this.cluster.getClusterer();
        if (google.maps.event.trigger(n, "click", this.cluster), google.maps.event.trigger(n, "clusterclick", this.cluster), n.getZoomOnClick()) {
          var r = n.getMaxZoom(), o = this.cluster.getBounds(), i = n.getMap();
          i !== null && "fitBounds" in i && i.fitBounds(o), this.timeOut = window.setTimeout(function() {
            var a = n.getMap();
            if (a !== null) {
              "fitBounds" in a && a.fitBounds(o);
              var s = a.getZoom() || 0;
              r !== null && s > r && a.setZoom(r + 1);
            }
          }, 100);
        }
        t.cancelBubble = !0, t.stopPropagation && t.stopPropagation();
      }
    }, e.prototype.onMouseOver = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseover", this.cluster);
    }, e.prototype.onMouseOut = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseout", this.cluster);
    }, e.prototype.onAdd = function() {
      var t;
      this.div = document.createElement("div"), this.div.className = this.className, this.visible && this.show(), (t = this.getPanes()) === null || t === void 0 || t.overlayMouseTarget.appendChild(this.div);
      var n = this.getMap();
      n !== null && (this.boundsChangedListener = google.maps.event.addListener(n, "bounds_changed", this.onBoundsChanged), this.div.addEventListener("mousedown", this.onMouseDown), this.div.addEventListener("click", this.onClick), this.div.addEventListener("mouseover", this.onMouseOver), this.div.addEventListener("mouseout", this.onMouseOut));
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.hide(), this.boundsChangedListener !== null && google.maps.event.removeListener(this.boundsChangedListener), this.div.removeEventListener("mousedown", this.onMouseDown), this.div.removeEventListener("click", this.onClick), this.div.removeEventListener("mouseover", this.onMouseOver), this.div.removeEventListener("mouseout", this.onMouseOut), this.div.parentNode.removeChild(this.div), this.timeOut !== null && (window.clearTimeout(this.timeOut), this.timeOut = null), this.div = null);
    }, e.prototype.draw = function() {
      if (this.visible && this.div !== null && this.center) {
        var t = this.getPosFromLatLng(this.center);
        this.div.style.top = t !== null ? "".concat(t.y, "px") : "0", this.div.style.left = t !== null ? "".concat(t.x, "px") : "0";
      }
    }, e.prototype.hide = function() {
      this.div && (this.div.style.display = "none"), this.visible = !1;
    }, e.prototype.show = function() {
      var t, n, r, o, i, a;
      if (this.div && this.center) {
        var s = this.sums === null || typeof this.sums.title > "u" || this.sums.title === "" ? this.cluster.getClusterer().getTitle() : this.sums.title, l = this.backgroundPosition.split(" "), u = parseInt(((t = l[0]) === null || t === void 0 ? void 0 : t.replace(/^\s+|\s+$/g, "")) || "0", 10), c = parseInt(((n = l[1]) === null || n === void 0 ? void 0 : n.replace(/^\s+|\s+$/g, "")) || "0", 10), p = this.getPosFromLatLng(this.center);
        this.div.className = this.className, this.div.setAttribute("style", "cursor: pointer; position: absolute; top: ".concat(p !== null ? "".concat(p.y, "px") : "0", "; left: ").concat(p !== null ? "".concat(p.x, "px") : "0", "; width: ").concat(this.width, "px; height: ").concat(this.height, "px; "));
        var d = document.createElement("img");
        d.alt = s, d.src = this.url, d.width = this.width, d.height = this.height, d.setAttribute("style", "position: absolute; top: ".concat(c, "px; left: ").concat(u, "px")), this.cluster.getClusterer().enableRetinaIcons || (d.style.clip = "rect(-".concat(c, "px, -").concat(u + this.width, "px, -").concat(c + this.height, ", -").concat(u, ")"));
        var g = document.createElement("div");
        g.setAttribute("style", "position: absolute; top: ".concat(this.anchorText[0], "px; left: ").concat(this.anchorText[1], "px; color: ").concat(this.textColor, "; font-size: ").concat(this.textSize, "px; font-family: ").concat(this.fontFamily, "; font-weight: ").concat(this.fontWeight, "; fontStyle: ").concat(this.fontStyle, "; text-decoration: ").concat(this.textDecoration, "; text-align: center; width: ").concat(this.width, "px; line-height: ").concat(this.height, "px")), !((r = this.sums) === null || r === void 0) && r.text && (g.innerText = "".concat((o = this.sums) === null || o === void 0 ? void 0 : o.text)), !((i = this.sums) === null || i === void 0) && i.html && (g.innerHTML = "".concat((a = this.sums) === null || a === void 0 ? void 0 : a.html)), this.div.innerHTML = "", this.div.appendChild(d), this.div.appendChild(g), this.div.title = s, this.div.style.display = "";
      }
      this.visible = !0;
    }, e.prototype.useStyle = function(t) {
      this.sums = t;
      var n = this.cluster.getClusterer().getStyles(), r = n[Math.min(n.length - 1, Math.max(0, t.index - 1))];
      r && (this.url = r.url, this.height = r.height, this.width = r.width, r.className && (this.className = "".concat(this.clusterClassName, " ").concat(r.className)), this.anchorText = r.anchorText || [0, 0], this.anchorIcon = r.anchorIcon || [this.height / 2, this.width / 2], this.textColor = r.textColor || "black", this.textSize = r.textSize || 11, this.textDecoration = r.textDecoration || "none", this.fontWeight = r.fontWeight || "bold", this.fontStyle = r.fontStyle || "normal", this.fontFamily = r.fontFamily || "Arial,sans-serif", this.backgroundPosition = r.backgroundPosition || "0 0");
    }, e.prototype.setCenter = function(t) {
      this.center = t;
    }, e.prototype.getPosFromLatLng = function(t) {
      var n = this.getProjection().fromLatLngToDivPixel(t);
      return n !== null && (n.x -= this.anchorIcon[1], n.y -= this.anchorIcon[0]), n;
    }, e;
  }()
), a1e = (
  /** @class */
  function() {
    function e(t) {
      this.markerClusterer = t, this.map = this.markerClusterer.getMap(), this.gridSize = this.markerClusterer.getGridSize(), this.minClusterSize = this.markerClusterer.getMinimumClusterSize(), this.averageCenter = this.markerClusterer.getAverageCenter(), this.markers = [], this.center = void 0, this.bounds = null, this.clusterIcon = new s1e(this, this.markerClusterer.getStyles()), this.getSize = this.getSize.bind(this), this.getMarkers = this.getMarkers.bind(this), this.getCenter = this.getCenter.bind(this), this.getMap = this.getMap.bind(this), this.getClusterer = this.getClusterer.bind(this), this.getBounds = this.getBounds.bind(this), this.remove = this.remove.bind(this), this.addMarker = this.addMarker.bind(this), this.isMarkerInClusterBounds = this.isMarkerInClusterBounds.bind(this), this.calculateBounds = this.calculateBounds.bind(this), this.updateIcon = this.updateIcon.bind(this), this.isMarkerAlreadyAdded = this.isMarkerAlreadyAdded.bind(this);
    }
    return e.prototype.getSize = function() {
      return this.markers.length;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getCenter = function() {
      return this.center;
    }, e.prototype.getMap = function() {
      return this.map;
    }, e.prototype.getClusterer = function() {
      return this.markerClusterer;
    }, e.prototype.getBounds = function() {
      for (var t = new google.maps.LatLngBounds(this.center, this.center), n = this.getMarkers(), r = 0, o = n; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && t.extend(a);
      }
      return t;
    }, e.prototype.remove = function() {
      this.clusterIcon.setMap(null), this.markers = [], delete this.markers;
    }, e.prototype.addMarker = function(t) {
      var n;
      if (this.isMarkerAlreadyAdded(t))
        return !1;
      if (this.center) {
        if (this.averageCenter) {
          var r = t.getPosition();
          if (r) {
            var o = this.markers.length + 1;
            this.center = new google.maps.LatLng((this.center.lat() * (o - 1) + r.lat()) / o, (this.center.lng() * (o - 1) + r.lng()) / o), this.calculateBounds();
          }
        }
      } else {
        var r = t.getPosition();
        r && (this.center = r, this.calculateBounds());
      }
      t.isAdded = !0, this.markers.push(t);
      var i = this.markers.length, a = this.markerClusterer.getMaxZoom(), s = (n = this.map) === null || n === void 0 ? void 0 : n.getZoom();
      if (a !== null && typeof s < "u" && s > a)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i < this.minClusterSize)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i === this.minClusterSize)
        for (var l = 0, u = this.markers; l < u.length; l++) {
          var c = u[l];
          c.setMap(null);
        }
      else
        t.setMap(null);
      return !0;
    }, e.prototype.isMarkerInClusterBounds = function(t) {
      if (this.bounds !== null) {
        var n = t.getPosition();
        if (n)
          return this.bounds.contains(n);
      }
      return !1;
    }, e.prototype.calculateBounds = function() {
      this.bounds = this.markerClusterer.getExtendedBounds(new google.maps.LatLngBounds(this.center, this.center));
    }, e.prototype.updateIcon = function() {
      var t, n = this.markers.length, r = this.markerClusterer.getMaxZoom(), o = (t = this.map) === null || t === void 0 ? void 0 : t.getZoom();
      if (r !== null && typeof o < "u" && o > r) {
        this.clusterIcon.hide();
        return;
      }
      if (n < this.minClusterSize) {
        this.clusterIcon.hide();
        return;
      }
      this.center && this.clusterIcon.setCenter(this.center), this.clusterIcon.useStyle(this.markerClusterer.getCalculator()(this.markers, this.markerClusterer.getStyles().length)), this.clusterIcon.show();
    }, e.prototype.isMarkerAlreadyAdded = function(t) {
      if (this.markers.includes)
        return this.markers.includes(t);
      for (var n = 0; n < this.markers.length; n++)
        if (t === this.markers[n])
          return !0;
      return !1;
    }, e;
  }()
);
function l1e(e, t) {
  var n = e.length, r = n.toString().length, o = Math.min(r, t);
  return {
    text: n.toString(),
    index: o,
    title: ""
  };
}
var u1e = 2e3, c1e = 500, p1e = "https://developers.google.com/maps/documentation/javascript/examples/markerclusterer/m", d1e = "png", f1e = [53, 56, 66, 78, 90], h1e = "cluster", eG = (
  /** @class */
  function() {
    function e(t, n, r) {
      n === void 0 && (n = []), r === void 0 && (r = {}), this.getMinimumClusterSize = this.getMinimumClusterSize.bind(this), this.setMinimumClusterSize = this.setMinimumClusterSize.bind(this), this.getEnableRetinaIcons = this.getEnableRetinaIcons.bind(this), this.setEnableRetinaIcons = this.setEnableRetinaIcons.bind(this), this.addToClosestCluster = this.addToClosestCluster.bind(this), this.getImageExtension = this.getImageExtension.bind(this), this.setImageExtension = this.setImageExtension.bind(this), this.getExtendedBounds = this.getExtendedBounds.bind(this), this.getAverageCenter = this.getAverageCenter.bind(this), this.setAverageCenter = this.setAverageCenter.bind(this), this.getTotalClusters = this.getTotalClusters.bind(this), this.fitMapToMarkers = this.fitMapToMarkers.bind(this), this.getIgnoreHidden = this.getIgnoreHidden.bind(this), this.setIgnoreHidden = this.setIgnoreHidden.bind(this), this.getClusterClass = this.getClusterClass.bind(this), this.setClusterClass = this.setClusterClass.bind(this), this.getTotalMarkers = this.getTotalMarkers.bind(this), this.getZoomOnClick = this.getZoomOnClick.bind(this), this.setZoomOnClick = this.setZoomOnClick.bind(this), this.getBatchSizeIE = this.getBatchSizeIE.bind(this), this.setBatchSizeIE = this.setBatchSizeIE.bind(this), this.createClusters = this.createClusters.bind(this), this.onZoomChanged = this.onZoomChanged.bind(this), this.getImageSizes = this.getImageSizes.bind(this), this.setImageSizes = this.setImageSizes.bind(this), this.getCalculator = this.getCalculator.bind(this), this.setCalculator = this.setCalculator.bind(this), this.removeMarkers = this.removeMarkers.bind(this), this.resetViewport = this.resetViewport.bind(this), this.getImagePath = this.getImagePath.bind(this), this.setImagePath = this.setImagePath.bind(this), this.pushMarkerTo = this.pushMarkerTo.bind(this), this.removeMarker = this.removeMarker.bind(this), this.clearMarkers = this.clearMarkers.bind(this), this.setupStyles = this.setupStyles.bind(this), this.getGridSize = this.getGridSize.bind(this), this.setGridSize = this.setGridSize.bind(this), this.getClusters = this.getClusters.bind(this), this.getMaxZoom = this.getMaxZoom.bind(this), this.setMaxZoom = this.setMaxZoom.bind(this), this.getMarkers = this.getMarkers.bind(this), this.addMarkers = this.addMarkers.bind(this), this.getStyles = this.getStyles.bind(this), this.setStyles = this.setStyles.bind(this), this.addMarker = this.addMarker.bind(this), this.onRemove = this.onRemove.bind(this), this.getTitle = this.getTitle.bind(this), this.setTitle = this.setTitle.bind(this), this.repaint = this.repaint.bind(this), this.onIdle = this.onIdle.bind(this), this.redraw = this.redraw.bind(this), this.onAdd = this.onAdd.bind(this), this.draw = this.draw.bind(this), this.extend = this.extend.bind(this), this.extend(e, google.maps.OverlayView), this.markers = [], this.clusters = [], this.listeners = [], this.activeMap = null, this.ready = !1, this.gridSize = r.gridSize || 60, this.minClusterSize = r.minimumClusterSize || 2, this.maxZoom = r.maxZoom || null, this.styles = r.styles || [], this.title = r.title || "", this.zoomOnClick = !0, r.zoomOnClick !== void 0 && (this.zoomOnClick = r.zoomOnClick), this.averageCenter = !1, r.averageCenter !== void 0 && (this.averageCenter = r.averageCenter), this.ignoreHidden = !1, r.ignoreHidden !== void 0 && (this.ignoreHidden = r.ignoreHidden), this.enableRetinaIcons = !1, r.enableRetinaIcons !== void 0 && (this.enableRetinaIcons = r.enableRetinaIcons), this.imagePath = r.imagePath || p1e, this.imageExtension = r.imageExtension || d1e, this.imageSizes = r.imageSizes || f1e, this.calculator = r.calculator || l1e, this.batchSize = r.batchSize || u1e, this.batchSizeIE = r.batchSizeIE || c1e, this.clusterClass = r.clusterClass || h1e, navigator.userAgent.toLowerCase().indexOf("msie") !== -1 && (this.batchSize = this.batchSizeIE), this.timerRefStatic = null, this.setupStyles(), this.addMarkers(n, !0), this.setMap(t);
    }
    return e.prototype.onZoomChanged = function() {
      var t, n;
      this.resetViewport(!1), (((t = this.getMap()) === null || t === void 0 ? void 0 : t.getZoom()) === (this.get("minZoom") || 0) || ((n = this.getMap()) === null || n === void 0 ? void 0 : n.getZoom()) === this.get("maxZoom")) && google.maps.event.trigger(this, "idle");
    }, e.prototype.onIdle = function() {
      this.redraw();
    }, e.prototype.onAdd = function() {
      var t = this.getMap();
      this.activeMap = t, this.ready = !0, this.repaint(), t !== null && (this.listeners = [google.maps.event.addListener(t, "zoom_changed", this.onZoomChanged), google.maps.event.addListener(t, "idle", this.onIdle)]);
    }, e.prototype.onRemove = function() {
      for (var t = 0, n = this.markers; t < n.length; t++) {
        var r = n[t];
        r.getMap() !== this.activeMap && r.setMap(this.activeMap);
      }
      for (var o = 0, i = this.clusters; o < i.length; o++) {
        var a = i[o];
        a.remove();
      }
      this.clusters = [];
      for (var s = 0, l = this.listeners; s < l.length; s++) {
        var u = l[s];
        google.maps.event.removeListener(u);
      }
      this.listeners = [], this.activeMap = null, this.ready = !1;
    }, e.prototype.draw = function() {
    }, e.prototype.getMap = function() {
      return null;
    }, e.prototype.getPanes = function() {
      return null;
    }, e.prototype.getProjection = function() {
      return {
        fromContainerPixelToLatLng: function() {
          return null;
        },
        fromDivPixelToLatLng: function() {
          return null;
        },
        fromLatLngToContainerPixel: function() {
          return null;
        },
        fromLatLngToDivPixel: function() {
          return null;
        },
        getVisibleRegion: function() {
          return null;
        },
        getWorldWidth: function() {
          return 0;
        }
      };
    }, e.prototype.setMap = function() {
    }, e.prototype.addListener = function() {
      return {
        remove: function() {
        }
      };
    }, e.prototype.bindTo = function() {
    }, e.prototype.get = function() {
    }, e.prototype.notify = function() {
    }, e.prototype.set = function() {
    }, e.prototype.setValues = function() {
    }, e.prototype.unbind = function() {
    }, e.prototype.unbindAll = function() {
    }, e.prototype.setupStyles = function() {
      if (!(this.styles.length > 0))
        for (var t = 0; t < this.imageSizes.length; t++)
          this.styles.push({
            url: "".concat(this.imagePath + (t + 1), ".").concat(this.imageExtension),
            height: this.imageSizes[t] || 0,
            width: this.imageSizes[t] || 0
          });
    }, e.prototype.fitMapToMarkers = function() {
      for (var t = this.getMarkers(), n = new google.maps.LatLngBounds(), r = 0, o = t; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && n.extend(a);
      }
      var s = this.getMap();
      s !== null && "fitBounds" in s && s.fitBounds(n);
    }, e.prototype.getGridSize = function() {
      return this.gridSize;
    }, e.prototype.setGridSize = function(t) {
      this.gridSize = t;
    }, e.prototype.getMinimumClusterSize = function() {
      return this.minClusterSize;
    }, e.prototype.setMinimumClusterSize = function(t) {
      this.minClusterSize = t;
    }, e.prototype.getMaxZoom = function() {
      return this.maxZoom;
    }, e.prototype.setMaxZoom = function(t) {
      this.maxZoom = t;
    }, e.prototype.getStyles = function() {
      return this.styles;
    }, e.prototype.setStyles = function(t) {
      this.styles = t;
    }, e.prototype.getTitle = function() {
      return this.title;
    }, e.prototype.setTitle = function(t) {
      this.title = t;
    }, e.prototype.getZoomOnClick = function() {
      return this.zoomOnClick;
    }, e.prototype.setZoomOnClick = function(t) {
      this.zoomOnClick = t;
    }, e.prototype.getAverageCenter = function() {
      return this.averageCenter;
    }, e.prototype.setAverageCenter = function(t) {
      this.averageCenter = t;
    }, e.prototype.getIgnoreHidden = function() {
      return this.ignoreHidden;
    }, e.prototype.setIgnoreHidden = function(t) {
      this.ignoreHidden = t;
    }, e.prototype.getEnableRetinaIcons = function() {
      return this.enableRetinaIcons;
    }, e.prototype.setEnableRetinaIcons = function(t) {
      this.enableRetinaIcons = t;
    }, e.prototype.getImageExtension = function() {
      return this.imageExtension;
    }, e.prototype.setImageExtension = function(t) {
      this.imageExtension = t;
    }, e.prototype.getImagePath = function() {
      return this.imagePath;
    }, e.prototype.setImagePath = function(t) {
      this.imagePath = t;
    }, e.prototype.getImageSizes = function() {
      return this.imageSizes;
    }, e.prototype.setImageSizes = function(t) {
      this.imageSizes = t;
    }, e.prototype.getCalculator = function() {
      return this.calculator;
    }, e.prototype.setCalculator = function(t) {
      this.calculator = t;
    }, e.prototype.getBatchSizeIE = function() {
      return this.batchSizeIE;
    }, e.prototype.setBatchSizeIE = function(t) {
      this.batchSizeIE = t;
    }, e.prototype.getClusterClass = function() {
      return this.clusterClass;
    }, e.prototype.setClusterClass = function(t) {
      this.clusterClass = t;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getTotalMarkers = function() {
      return this.markers.length;
    }, e.prototype.getClusters = function() {
      return this.clusters;
    }, e.prototype.getTotalClusters = function() {
      return this.clusters.length;
    }, e.prototype.addMarker = function(t, n) {
      this.pushMarkerTo(t), n || this.redraw();
    }, e.prototype.addMarkers = function(t, n) {
      for (var r in t)
        if (Object.prototype.hasOwnProperty.call(t, r)) {
          var o = t[r];
          o && this.pushMarkerTo(o);
        }
      n || this.redraw();
    }, e.prototype.pushMarkerTo = function(t) {
      var n = this;
      t.getDraggable() && google.maps.event.addListener(t, "dragend", function() {
        n.ready && (t.isAdded = !1, n.repaint());
      }), t.isAdded = !1, this.markers.push(t);
    }, e.prototype.removeMarker_ = function(t) {
      var n = -1;
      if (this.markers.indexOf)
        n = this.markers.indexOf(t);
      else
        for (var r = 0; r < this.markers.length; r++)
          if (t === this.markers[r]) {
            n = r;
            break;
          }
      return n === -1 ? !1 : (t.setMap(null), this.markers.splice(n, 1), !0);
    }, e.prototype.removeMarker = function(t, n) {
      var r = this.removeMarker_(t);
      return !n && r && this.repaint(), r;
    }, e.prototype.removeMarkers = function(t, n) {
      for (var r = !1, o = 0, i = t; o < i.length; o++) {
        var a = i[o];
        r = r || this.removeMarker_(a);
      }
      return !n && r && this.repaint(), r;
    }, e.prototype.clearMarkers = function() {
      this.resetViewport(!0), this.markers = [];
    }, e.prototype.repaint = function() {
      var t = this.clusters.slice();
      this.clusters = [], this.resetViewport(!1), this.redraw(), setTimeout(function() {
        for (var n = 0, r = t; n < r.length; n++) {
          var o = r[n];
          o.remove();
        }
      }, 0);
    }, e.prototype.getExtendedBounds = function(t) {
      var n = this.getProjection(), r = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getNorthEast().lat(), t.getNorthEast().lng())
      );
      r !== null && (r.x += this.gridSize, r.y -= this.gridSize);
      var o = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getSouthWest().lat(), t.getSouthWest().lng())
      );
      if (o !== null && (o.x -= this.gridSize, o.y += this.gridSize), r !== null) {
        var i = n.fromDivPixelToLatLng(r);
        i !== null && t.extend(i);
      }
      if (o !== null) {
        var a = n.fromDivPixelToLatLng(o);
        a !== null && t.extend(a);
      }
      return t;
    }, e.prototype.redraw = function() {
      this.createClusters(0);
    }, e.prototype.resetViewport = function(t) {
      for (var n = 0, r = this.clusters; n < r.length; n++) {
        var o = r[n];
        o.remove();
      }
      this.clusters = [];
      for (var i = 0, a = this.markers; i < a.length; i++) {
        var s = a[i];
        s.isAdded = !1, t && s.setMap(null);
      }
    }, e.prototype.distanceBetweenPoints = function(t, n) {
      var r = 6371, o = (n.lat() - t.lat()) * Math.PI / 180, i = (n.lng() - t.lng()) * Math.PI / 180, a = Math.sin(o / 2) * Math.sin(o / 2) + Math.cos(t.lat() * Math.PI / 180) * Math.cos(n.lat() * Math.PI / 180) * Math.sin(i / 2) * Math.sin(i / 2);
      return r * (2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)));
    }, e.prototype.isMarkerInBounds = function(t, n) {
      var r = t.getPosition();
      return r ? n.contains(r) : !1;
    }, e.prototype.addToClosestCluster = function(t) {
      for (var n, r = 4e4, o = null, i = 0, a = this.clusters; i < a.length; i++) {
        var s = a[i];
        n = s;
        var l = n.getCenter(), u = t.getPosition();
        if (l && u) {
          var c = this.distanceBetweenPoints(l, u);
          c < r && (r = c, o = n);
        }
      }
      o && o.isMarkerInClusterBounds(t) ? o.addMarker(t) : (n = new a1e(this), n.addMarker(t), this.clusters.push(n));
    }, e.prototype.createClusters = function(t) {
      var n = this;
      if (this.ready) {
        t === 0 && (google.maps.event.trigger(this, "clusteringbegin", this), this.timerRefStatic !== null && (window.clearTimeout(this.timerRefStatic), delete this.timerRefStatic));
        for (var r = this.getMap(), o = r !== null && ("getBounds" in r) ? r.getBounds() : null, i = (r == null ? void 0 : r.getZoom()) || 0, a = i > 3 ? new google.maps.LatLngBounds(o == null ? void 0 : o.getSouthWest(), o == null ? void 0 : o.getNorthEast()) : new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625)), s = this.getExtendedBounds(a), l = Math.min(t + this.batchSize, this.markers.length), u = t; u < l; u++) {
          var c = this.markers[u];
          c && !c.isAdded && this.isMarkerInBounds(c, s) && (!this.ignoreHidden || this.ignoreHidden && c.getVisible()) && this.addToClosestCluster(c);
        }
        if (l < this.markers.length)
          this.timerRefStatic = window.setTimeout(function() {
            n.createClusters(l);
          }, 0);
        else {
          this.timerRefStatic = null, google.maps.event.trigger(this, "clusteringend", this);
          for (var p = 0, d = this.clusters; p < d.length; p++) {
            var g = d[p];
            g.updateIcon();
          }
        }
      }
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype) {
          var i = o;
          this.prototype[i] = r.prototype[i];
        }
        return this;
      }).apply(t, [n]);
    }, e;
  }()
);
function NF(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function g1e(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? NF(Object(n), !0).forEach(function(r) {
      Oe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : NF(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var ns = {
  onClick: "click",
  onClusteringBegin: "clusteringbegin",
  onClusteringEnd: "clusteringend",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover"
}, En = {
  averageCenter(e, t) {
    e.setAverageCenter(t);
  },
  batchSizeIE(e, t) {
    e.setBatchSizeIE(t);
  },
  calculator(e, t) {
    e.setCalculator(t);
  },
  clusterClass(e, t) {
    e.setClusterClass(t);
  },
  enableRetinaIcons(e, t) {
    e.setEnableRetinaIcons(t);
  },
  gridSize(e, t) {
    e.setGridSize(t);
  },
  ignoreHidden(e, t) {
    e.setIgnoreHidden(t);
  },
  imageExtension(e, t) {
    e.setImageExtension(t);
  },
  imagePath(e, t) {
    e.setImagePath(t);
  },
  imageSizes(e, t) {
    e.setImageSizes(t);
  },
  maxZoom(e, t) {
    e.setMaxZoom(t);
  },
  minimumClusterSize(e, t) {
    e.setMinimumClusterSize(t);
  },
  styles(e, t) {
    e.setStyles(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  zoomOnClick(e, t) {
    e.setZoomOnClick(t);
  }
}, m1e = {};
function v1e(e) {
  var {
    children: t,
    options: n,
    averageCenter: r,
    batchSizeIE: o,
    calculator: i,
    clusterClass: a,
    enableRetinaIcons: s,
    gridSize: l,
    ignoreHidden: u,
    imageExtension: c,
    imagePath: p,
    imageSizes: d,
    maxZoom: g,
    minimumClusterSize: f,
    styles: m,
    title: v,
    zoomOnClick: E,
    onClick: w,
    onClusteringBegin: M,
    onClusteringEnd: O,
    onMouseOver: y,
    onMouseOut: C,
    onLoad: _,
    onUnmount: F
  } = e, [L, N] = k(null), R = ge(At), [W, V] = k(null), [z, Z] = k(null), [K, X] = k(null), [te, J] = k(null), [P, D] = k(null);
  return h(() => {
    L && C && (te !== null && google.maps.event.removeListener(te), J(google.maps.event.addListener(L, ns.onMouseOut, C)));
  }, [C]), h(() => {
    L && y && (P !== null && google.maps.event.removeListener(P), D(google.maps.event.addListener(L, ns.onMouseOver, y)));
  }, [y]), h(() => {
    L && w && (W !== null && google.maps.event.removeListener(W), V(google.maps.event.addListener(L, ns.onClick, w)));
  }, [w]), h(() => {
    L && M && (z !== null && google.maps.event.removeListener(z), Z(google.maps.event.addListener(L, ns.onClusteringBegin, M)));
  }, [M]), h(() => {
    L && O && (K !== null && google.maps.event.removeListener(K), Z(google.maps.event.addListener(L, ns.onClusteringEnd, O)));
  }, [O]), h(() => {
    typeof r < "u" && L !== null && En.averageCenter(L, r);
  }, [L, r]), h(() => {
    typeof o < "u" && L !== null && En.batchSizeIE(L, o);
  }, [L, o]), h(() => {
    typeof i < "u" && L !== null && En.calculator(L, i);
  }, [L, i]), h(() => {
    typeof a < "u" && L !== null && En.clusterClass(L, a);
  }, [L, a]), h(() => {
    typeof s < "u" && L !== null && En.enableRetinaIcons(L, s);
  }, [L, s]), h(() => {
    typeof l < "u" && L !== null && En.gridSize(L, l);
  }, [L, l]), h(() => {
    typeof u < "u" && L !== null && En.ignoreHidden(L, u);
  }, [L, u]), h(() => {
    typeof c < "u" && L !== null && En.imageExtension(L, c);
  }, [L, c]), h(() => {
    typeof p < "u" && L !== null && En.imagePath(L, p);
  }, [L, p]), h(() => {
    typeof d < "u" && L !== null && En.imageSizes(L, d);
  }, [L, d]), h(() => {
    typeof g < "u" && L !== null && En.maxZoom(L, g);
  }, [L, g]), h(() => {
    typeof f < "u" && L !== null && En.minimumClusterSize(L, f);
  }, [L, f]), h(() => {
    typeof m < "u" && L !== null && En.styles(L, m);
  }, [L, m]), h(() => {
    typeof v < "u" && L !== null && En.title(L, v);
  }, [L, v]), h(() => {
    typeof E < "u" && L !== null && En.zoomOnClick(L, E);
  }, [L, E]), h(() => {
    if (R) {
      var H = g1e({}, n || m1e), S = new eG(R, [], H);
      return r && En.averageCenter(S, r), o && En.batchSizeIE(S, o), i && En.calculator(S, i), a && En.clusterClass(S, a), s && En.enableRetinaIcons(S, s), l && En.gridSize(S, l), u && En.ignoreHidden(S, u), c && En.imageExtension(S, c), p && En.imagePath(S, p), d && En.imageSizes(S, d), g && En.maxZoom(S, g), f && En.minimumClusterSize(S, f), m && En.styles(S, m), v && En.title(S, v), E && En.zoomOnClick(S, E), C && J(google.maps.event.addListener(S, ns.onMouseOut, C)), y && D(google.maps.event.addListener(S, ns.onMouseOver, y)), w && V(google.maps.event.addListener(S, ns.onClick, w)), M && Z(google.maps.event.addListener(S, ns.onClusteringBegin, M)), O && X(google.maps.event.addListener(S, ns.onClusteringEnd, O)), N(S), _ && _(S), () => {
        te !== null && google.maps.event.removeListener(te), P !== null && google.maps.event.removeListener(P), W !== null && google.maps.event.removeListener(W), z !== null && google.maps.event.removeListener(z), K !== null && google.maps.event.removeListener(K), F && F(S);
      };
    }
  }, []), L !== null && t(L) || null;
}
ve(v1e);
class y1e extends pe {
  constructor() {
    super(...arguments), Oe(this, "registeredEvents", []), Oe(this, "state", {
      markerClusterer: null
    }), Oe(this, "setClustererCallback", () => {
      this.state.markerClusterer !== null && this.props.onLoad && this.props.onLoad(this.state.markerClusterer);
    });
  }
  componentDidMount() {
    if (this.context) {
      var t = new eG(this.context, [], this.props.options);
      this.registeredEvents = un({
        updaterMap: En,
        eventMap: ns,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        markerClusterer: t
      }), this.setClustererCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.markerClusterer && (gn(this.registeredEvents), this.registeredEvents = un({
      updaterMap: En,
      eventMap: ns,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.markerClusterer
    }));
  }
  componentWillUnmount() {
    this.state.markerClusterer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.markerClusterer), gn(this.registeredEvents), this.state.markerClusterer.setMap(null));
  }
  render() {
    return this.state.markerClusterer !== null ? this.props.children(this.state.markerClusterer) : null;
  }
}
Oe(y1e, "contextType", At);
function FF(e) {
  e.cancelBubble = !0, e.stopPropagation && e.stopPropagation();
}
var tG = (
  /** @class */
  function() {
    function e(t) {
      t === void 0 && (t = {}), this.getCloseClickHandler = this.getCloseClickHandler.bind(this), this.closeClickHandler = this.closeClickHandler.bind(this), this.createInfoBoxDiv = this.createInfoBoxDiv.bind(this), this.addClickHandler = this.addClickHandler.bind(this), this.getCloseBoxImg = this.getCloseBoxImg.bind(this), this.getBoxWidths = this.getBoxWidths.bind(this), this.setBoxStyle = this.setBoxStyle.bind(this), this.setPosition = this.setPosition.bind(this), this.getPosition = this.getPosition.bind(this), this.setOptions = this.setOptions.bind(this), this.setContent = this.setContent.bind(this), this.setVisible = this.setVisible.bind(this), this.getContent = this.getContent.bind(this), this.getVisible = this.getVisible.bind(this), this.setZIndex = this.setZIndex.bind(this), this.getZIndex = this.getZIndex.bind(this), this.onRemove = this.onRemove.bind(this), this.panBox = this.panBox.bind(this), this.extend = this.extend.bind(this), this.close = this.close.bind(this), this.draw = this.draw.bind(this), this.show = this.show.bind(this), this.hide = this.hide.bind(this), this.open = this.open.bind(this), this.extend(e, google.maps.OverlayView), this.content = t.content || "", this.disableAutoPan = t.disableAutoPan || !1, this.maxWidth = t.maxWidth || 0, this.pixelOffset = t.pixelOffset || new google.maps.Size(0, 0), this.position = t.position || new google.maps.LatLng(0, 0), this.zIndex = t.zIndex || null, this.boxClass = t.boxClass || "infoBox", this.boxStyle = t.boxStyle || {}, this.closeBoxMargin = t.closeBoxMargin || "2px", this.closeBoxURL = t.closeBoxURL || "http://www.google.com/intl/en_us/mapfiles/close.gif", t.closeBoxURL === "" && (this.closeBoxURL = ""), this.infoBoxClearance = t.infoBoxClearance || new google.maps.Size(1, 1), typeof t.visible > "u" && (typeof t.isHidden > "u" ? t.visible = !0 : t.visible = !t.isHidden), this.isHidden = !t.visible, this.alignBottom = t.alignBottom || !1, this.pane = t.pane || "floatPane", this.enableEventPropagation = t.enableEventPropagation || !1, this.div = null, this.closeListener = null, this.moveListener = null, this.mapListener = null, this.contextListener = null, this.eventListeners = null, this.fixedWidthSet = null;
    }
    return e.prototype.createInfoBoxDiv = function() {
      var t = this, n = function(u) {
        u.returnValue = !1, u.preventDefault && u.preventDefault(), t.enableEventPropagation || FF(u);
      };
      if (!this.div) {
        this.div = document.createElement("div"), this.setBoxStyle(), typeof this.content == "string" ? this.div.innerHTML = this.getCloseBoxImg() + this.content : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(this.content));
        var r = this.getPanes();
        if (r !== null && r[this.pane].appendChild(this.div), this.addClickHandler(), this.div.style.width)
          this.fixedWidthSet = !0;
        else if (this.maxWidth !== 0 && this.div.offsetWidth > this.maxWidth)
          this.div.style.width = this.maxWidth + "px", this.fixedWidthSet = !0;
        else {
          var o = this.getBoxWidths();
          this.div.style.width = this.div.offsetWidth - o.left - o.right + "px", this.fixedWidthSet = !1;
        }
        if (this.panBox(this.disableAutoPan), !this.enableEventPropagation) {
          this.eventListeners = [];
          for (var i = ["mousedown", "mouseover", "mouseout", "mouseup", "click", "dblclick", "touchstart", "touchend", "touchmove"], a = 0, s = i; a < s.length; a++) {
            var l = s[a];
            this.eventListeners.push(google.maps.event.addListener(this.div, l, FF));
          }
          this.eventListeners.push(google.maps.event.addListener(this.div, "mouseover", function() {
            t.div && (t.div.style.cursor = "default");
          }));
        }
        this.contextListener = google.maps.event.addListener(this.div, "contextmenu", n), google.maps.event.trigger(this, "domready");
      }
    }, e.prototype.getCloseBoxImg = function() {
      var t = "";
      return this.closeBoxURL !== "" && (t = '<img alt=""', t += ' aria-hidden="true"', t += " src='" + this.closeBoxURL + "'", t += " align=right", t += " style='", t += " position: relative;", t += " cursor: pointer;", t += " margin: " + this.closeBoxMargin + ";", t += "'>"), t;
    }, e.prototype.addClickHandler = function() {
      this.closeListener = this.div && this.div.firstChild && this.closeBoxURL !== "" ? google.maps.event.addListener(this.div.firstChild, "click", this.getCloseClickHandler()) : null;
    }, e.prototype.closeClickHandler = function(t) {
      t.cancelBubble = !0, t.stopPropagation && t.stopPropagation(), google.maps.event.trigger(this, "closeclick"), this.close();
    }, e.prototype.getCloseClickHandler = function() {
      return this.closeClickHandler;
    }, e.prototype.panBox = function(t) {
      if (this.div && !t) {
        var n = this.getMap();
        if (n instanceof google.maps.Map) {
          var r = 0, o = 0, i = n.getBounds();
          i && !i.contains(this.position) && n.setCenter(this.position);
          var a = n.getDiv(), s = a.offsetWidth, l = a.offsetHeight, u = this.pixelOffset.width, c = this.pixelOffset.height, p = this.div.offsetWidth, d = this.div.offsetHeight, g = this.infoBoxClearance.width, f = this.infoBoxClearance.height, m = this.getProjection(), v = m.fromLatLngToContainerPixel(this.position);
          v !== null && (v.x < -u + g ? r = v.x + u - g : v.x + p + u + g > s && (r = v.x + p + u + g - s), this.alignBottom ? v.y < -c + f + d ? o = v.y + c - f - d : v.y + c + f > l && (o = v.y + c + f - l) : v.y < -c + f ? o = v.y + c - f : v.y + d + c + f > l && (o = v.y + d + c + f - l)), r === 0 && o === 0 || n.panBy(r, o);
        }
      }
    }, e.prototype.setBoxStyle = function() {
      if (this.div) {
        this.div.className = this.boxClass, this.div.style.cssText = "";
        var t = this.boxStyle;
        for (var n in t)
          Object.prototype.hasOwnProperty.call(t, n) && (this.div.style[n] = t[n]);
        if (this.div.style.webkitTransform = "translateZ(0)", typeof this.div.style.opacity < "u" && this.div.style.opacity !== "") {
          var r = parseFloat(this.div.style.opacity || "");
          this.div.style.msFilter = '"progid:DXImageTransform.Microsoft.Alpha(Opacity=' + r * 100 + ')"', this.div.style.filter = "alpha(opacity=" + r * 100 + ")";
        }
        this.div.style.position = "absolute", this.div.style.visibility = "hidden", this.zIndex !== null && (this.div.style.zIndex = this.zIndex + ""), this.div.style.overflow || (this.div.style.overflow = "auto");
      }
    }, e.prototype.getBoxWidths = function() {
      var t = {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0
      };
      if (!this.div)
        return t;
      if (document.defaultView) {
        var n = this.div.ownerDocument, r = n && n.defaultView ? n.defaultView.getComputedStyle(this.div, "") : null;
        r && (t.top = parseInt(r.borderTopWidth || "", 10) || 0, t.bottom = parseInt(r.borderBottomWidth || "", 10) || 0, t.left = parseInt(r.borderLeftWidth || "", 10) || 0, t.right = parseInt(r.borderRightWidth || "", 10) || 0);
      } else if (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        document.documentElement.currentStyle
      ) {
        var o = this.div.currentStyle;
        o && (t.top = parseInt(o.borderTopWidth || "", 10) || 0, t.bottom = parseInt(o.borderBottomWidth || "", 10) || 0, t.left = parseInt(o.borderLeftWidth || "", 10) || 0, t.right = parseInt(o.borderRightWidth || "", 10) || 0);
      }
      return t;
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.div.parentNode.removeChild(this.div), this.div = null);
    }, e.prototype.draw = function() {
      if (this.createInfoBoxDiv(), this.div) {
        var t = this.getProjection(), n = t.fromLatLngToDivPixel(this.position);
        n !== null && (this.div.style.left = n.x + this.pixelOffset.width + "px", this.alignBottom ? this.div.style.bottom = -(n.y + this.pixelOffset.height) + "px" : this.div.style.top = n.y + this.pixelOffset.height + "px"), this.isHidden ? this.div.style.visibility = "hidden" : this.div.style.visibility = "visible";
      }
    }, e.prototype.setOptions = function(t) {
      t === void 0 && (t = {}), typeof t.boxClass < "u" && (this.boxClass = t.boxClass, this.setBoxStyle()), typeof t.boxStyle < "u" && (this.boxStyle = t.boxStyle, this.setBoxStyle()), typeof t.content < "u" && this.setContent(t.content), typeof t.disableAutoPan < "u" && (this.disableAutoPan = t.disableAutoPan), typeof t.maxWidth < "u" && (this.maxWidth = t.maxWidth), typeof t.pixelOffset < "u" && (this.pixelOffset = t.pixelOffset), typeof t.alignBottom < "u" && (this.alignBottom = t.alignBottom), typeof t.position < "u" && this.setPosition(t.position), typeof t.zIndex < "u" && this.setZIndex(t.zIndex), typeof t.closeBoxMargin < "u" && (this.closeBoxMargin = t.closeBoxMargin), typeof t.closeBoxURL < "u" && (this.closeBoxURL = t.closeBoxURL), typeof t.infoBoxClearance < "u" && (this.infoBoxClearance = t.infoBoxClearance), typeof t.isHidden < "u" && (this.isHidden = t.isHidden), typeof t.visible < "u" && (this.isHidden = !t.visible), typeof t.enableEventPropagation < "u" && (this.enableEventPropagation = t.enableEventPropagation), this.div && this.draw();
    }, e.prototype.setContent = function(t) {
      this.content = t, this.div && (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.fixedWidthSet || (this.div.style.width = ""), typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t)), this.fixedWidthSet || (this.div.style.width = this.div.offsetWidth + "px", typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t))), this.addClickHandler()), google.maps.event.trigger(this, "content_changed");
    }, e.prototype.setPosition = function(t) {
      this.position = t, this.div && this.draw(), google.maps.event.trigger(this, "position_changed");
    }, e.prototype.setVisible = function(t) {
      this.isHidden = !t, this.div && (this.div.style.visibility = this.isHidden ? "hidden" : "visible");
    }, e.prototype.setZIndex = function(t) {
      this.zIndex = t, this.div && (this.div.style.zIndex = t + ""), google.maps.event.trigger(this, "zindex_changed");
    }, e.prototype.getContent = function() {
      return this.content;
    }, e.prototype.getPosition = function() {
      return this.position;
    }, e.prototype.getZIndex = function() {
      return this.zIndex;
    }, e.prototype.getVisible = function() {
      var t = this.getMap();
      return typeof t > "u" || t === null ? !1 : !this.isHidden;
    }, e.prototype.show = function() {
      this.isHidden = !1, this.div && (this.div.style.visibility = "visible");
    }, e.prototype.hide = function() {
      this.isHidden = !0, this.div && (this.div.style.visibility = "hidden");
    }, e.prototype.open = function(t, n) {
      var r = this;
      n && (this.position = n.getPosition(), this.moveListener = google.maps.event.addListener(n, "position_changed", function() {
        var o = n.getPosition();
        r.setPosition(o);
      }), this.mapListener = google.maps.event.addListener(n, "map_changed", function() {
        r.setMap(n.map);
      })), this.setMap(t), this.div && this.panBox();
    }, e.prototype.close = function() {
      if (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.eventListeners) {
        for (var t = 0, n = this.eventListeners; t < n.length; t++) {
          var r = n[t];
          google.maps.event.removeListener(r);
        }
        this.eventListeners = null;
      }
      this.moveListener && (google.maps.event.removeListener(this.moveListener), this.moveListener = null), this.mapListener && (google.maps.event.removeListener(this.mapListener), this.mapListener = null), this.contextListener && (google.maps.event.removeListener(this.contextListener), this.contextListener = null), this.setMap(null);
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype)
          Object.prototype.hasOwnProperty.call(this, o) || (this.prototype[o] = r.prototype[o]);
        return this;
      }).apply(t, [n]);
    }, e;
  }()
), b1e = ["position"], w1e = ["position"];
function zF(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Kv(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? zF(Object(n), !0).forEach(function(r) {
      Oe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : zF(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var UF = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, HF = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    t instanceof google.maps.LatLng ? e.setPosition(t) : e.setPosition(new google.maps.LatLng(t.lat, t.lng));
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, C1e = {};
function x1e(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, g = ge(At), [f, m] = k(null), [v, E] = k(null), [w, M] = k(null), [O, y] = k(null), [C, _] = k(null), [F, L] = k(null), N = ut(null);
  return h(() => {
    g && f !== null && (f.close(), n ? f.open(g, n) : f.getPosition() && f.open(g));
  }, [g, f, n]), h(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), h(() => {
    if (o && f !== null) {
      var R = o instanceof google.maps.LatLng ? o : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        new google.maps.LatLng(o.lat, o.lng)
      );
      f.setPosition(R);
    }
  }, [o]), h(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), h(() => {
    f && a && (v !== null && google.maps.event.removeListener(v), E(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), h(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), M(google.maps.event.addListener(f, "domready", s)));
  }, [s]), h(() => {
    f && l && (O !== null && google.maps.event.removeListener(O), y(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), h(() => {
    f && u && (C !== null && google.maps.event.removeListener(C), _(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), h(() => {
    f && c && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), h(() => {
    if (g) {
      var R = r || C1e, {
        position: W
      } = R, V = m_(R, b1e), z;
      W && !(W instanceof google.maps.LatLng) && (z = new google.maps.LatLng(W.lat, W.lng));
      var Z = new tG(Kv(Kv({}, V), z ? {
        position: z
      } : {}));
      N.current = document.createElement("div"), m(Z), a && E(google.maps.event.addListener(Z, "closeclick", a)), s && M(google.maps.event.addListener(Z, "domready", s)), l && y(google.maps.event.addListener(Z, "content_changed", l)), u && _(google.maps.event.addListener(Z, "position_changed", u)), c && L(google.maps.event.addListener(Z, "zindex_changed", c)), Z.setContent(N.current), n ? Z.open(g, n) : Z.getPosition() ? Z.open(g) : wo(!1, "You must provide either an anchor or a position prop for <InfoBox>."), p && p(Z);
    }
    return () => {
      f !== null && (v && google.maps.event.removeListener(v), O && google.maps.event.removeListener(O), w && google.maps.event.removeListener(w), C && google.maps.event.removeListener(C), F && google.maps.event.removeListener(F), d && d(f), f.close());
    };
  }, []), N.current ? or(lt.only(t), N.current) : null;
}
ve(x1e);
class O1e extends pe {
  constructor() {
    super(...arguments), Oe(this, "registeredEvents", []), Oe(this, "containerElement", null), Oe(this, "state", {
      infoBox: null
    }), Oe(this, "open", (t, n) => {
      n ? this.context !== null && t.open(this.context, n) : t.getPosition() ? this.context !== null && t.open(this.context) : wo(!1, "You must provide either an anchor or a position prop for <InfoBox>.");
    }), Oe(this, "setInfoBoxCallback", () => {
      this.state.infoBox !== null && this.containerElement !== null && (this.state.infoBox.setContent(this.containerElement), this.open(this.state.infoBox, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoBox));
    });
  }
  componentDidMount() {
    var t = this.props.options || {}, {
      position: n
    } = t, r = m_(t, w1e), o;
    n && !(n instanceof google.maps.LatLng) && (o = new google.maps.LatLng(n.lat, n.lng));
    var i = new tG(Kv(Kv({}, r), o ? {
      position: o
    } : {}));
    this.containerElement = document.createElement("div"), this.registeredEvents = un({
      updaterMap: HF,
      eventMap: UF,
      prevProps: {},
      nextProps: this.props,
      instance: i
    }), this.setState({
      infoBox: i
    }, this.setInfoBoxCallback);
  }
  componentDidUpdate(t) {
    var {
      infoBox: n
    } = this.state;
    n !== null && (gn(this.registeredEvents), this.registeredEvents = un({
      updaterMap: HF,
      eventMap: UF,
      prevProps: t,
      nextProps: this.props,
      instance: n
    }));
  }
  componentWillUnmount() {
    var {
      onUnmount: t
    } = this.props, {
      infoBox: n
    } = this.state;
    n !== null && (t && t(n), gn(this.registeredEvents), n.close());
  }
  render() {
    return this.containerElement ? or(lt.only(this.props.children), this.containerElement) : null;
  }
}
Oe(O1e, "contextType", At);
var $F, WF;
function E1e() {
  return WF || (WF = 1, $F = function e(t, n) {
    if (t === n) return !0;
    if (t && n && typeof t == "object" && typeof n == "object") {
      if (t.constructor !== n.constructor) return !1;
      var r, o, i;
      if (Array.isArray(t)) {
        if (r = t.length, r != n.length) return !1;
        for (o = r; o-- !== 0; ) if (!e(t[o], n[o])) return !1;
        return !0;
      }
      if (t.constructor === RegExp) return t.source === n.source && t.flags === n.flags;
      if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === n.valueOf();
      if (t.toString !== Object.prototype.toString) return t.toString() === n.toString();
      if (i = Object.keys(t), r = i.length, r !== Object.keys(n).length) return !1;
      for (o = r; o-- !== 0; ) if (!Object.prototype.hasOwnProperty.call(n, i[o])) return !1;
      for (o = r; o-- !== 0; ) {
        var a = i[o];
        if (!e(t[a], n[a])) return !1;
      }
      return !0;
    }
    return t !== t && n !== n;
  }), $F;
}
var k1e = E1e(), VF = /* @__PURE__ */ Gq(k1e), ZF = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array], ux = 1, cp = 8;
class v_ {
  /**
   * Creates an index from raw `ArrayBuffer` data.
   * @param {ArrayBuffer} data
   */
  static from(t) {
    if (!(t instanceof ArrayBuffer))
      throw new Error("Data must be an instance of ArrayBuffer.");
    var [n, r] = new Uint8Array(t, 0, 2);
    if (n !== 219)
      throw new Error("Data does not appear to be in a KDBush format.");
    var o = r >> 4;
    if (o !== ux)
      throw new Error("Got v".concat(o, " data when expected v").concat(ux, "."));
    var i = ZF[r & 15];
    if (!i)
      throw new Error("Unrecognized array type.");
    var [a] = new Uint16Array(t, 2, 1), [s] = new Uint32Array(t, 4, 1);
    return new v_(s, a, i, t);
  }
  /**
   * Creates an index that will hold a given number of items.
   * @param {number} numItems
   * @param {number} [nodeSize=64] Size of the KD-tree node (64 by default).
   * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).
   * @param {ArrayBuffer} [data] (For internal use only)
   */
  constructor(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 64, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Float64Array, o = arguments.length > 3 ? arguments[3] : void 0;
    if (isNaN(t) || t < 0) throw new Error("Unpexpected numItems value: ".concat(t, "."));
    this.numItems = +t, this.nodeSize = Math.min(Math.max(+n, 2), 65535), this.ArrayType = r, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
    var i = ZF.indexOf(this.ArrayType), a = t * 2 * this.ArrayType.BYTES_PER_ELEMENT, s = t * this.IndexArrayType.BYTES_PER_ELEMENT, l = (8 - s % 8) % 8;
    if (i < 0)
      throw new Error("Unexpected typed array class: ".concat(r, "."));
    o && o instanceof ArrayBuffer ? (this.data = o, this.ids = new this.IndexArrayType(this.data, cp, t), this.coords = new this.ArrayType(this.data, cp + s + l, t * 2), this._pos = t * 2, this._finished = !0) : (this.data = new ArrayBuffer(cp + a + s + l), this.ids = new this.IndexArrayType(this.data, cp, t), this.coords = new this.ArrayType(this.data, cp + s + l, t * 2), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, (ux << 4) + i]), new Uint16Array(this.data, 2, 1)[0] = n, new Uint32Array(this.data, 4, 1)[0] = t);
  }
  /**
   * Add a point to the index.
   * @param {number} x
   * @param {number} y
   * @returns {number} An incremental index associated with the added item (starting from `0`).
   */
  add(t, n) {
    var r = this._pos >> 1;
    return this.ids[r] = r, this.coords[this._pos++] = t, this.coords[this._pos++] = n, r;
  }
  /**
   * Perform indexing of the added points.
   */
  finish() {
    var t = this._pos >> 1;
    if (t !== this.numItems)
      throw new Error("Added ".concat(t, " items when expected ").concat(this.numItems, "."));
    return Mk(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
  }
  /**
   * Search the index for items within a given bounding box.
   * @param {number} minX
   * @param {number} minY
   * @param {number} maxX
   * @param {number} maxY
   * @returns {number[]} An array of indices correponding to the found items.
   */
  range(t, n, r, o) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: i,
      coords: a,
      nodeSize: s
    } = this, l = [0, i.length - 1, 0], u = []; l.length; ) {
      var c = l.pop() || 0, p = l.pop() || 0, d = l.pop() || 0;
      if (p - d <= s) {
        for (var g = d; g <= p; g++) {
          var f = a[2 * g], m = a[2 * g + 1];
          f >= t && f <= r && m >= n && m <= o && u.push(i[g]);
        }
        continue;
      }
      var v = d + p >> 1, E = a[2 * v], w = a[2 * v + 1];
      E >= t && E <= r && w >= n && w <= o && u.push(i[v]), (c === 0 ? t <= E : n <= w) && (l.push(d), l.push(v - 1), l.push(1 - c)), (c === 0 ? r >= E : o >= w) && (l.push(v + 1), l.push(p), l.push(1 - c));
    }
    return u;
  }
  /**
   * Search the index for items within a given radius.
   * @param {number} qx
   * @param {number} qy
   * @param {number} r Query radius.
   * @returns {number[]} An array of indices correponding to the found items.
   */
  within(t, n, r) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: o,
      coords: i,
      nodeSize: a
    } = this, s = [0, o.length - 1, 0], l = [], u = r * r; s.length; ) {
      var c = s.pop() || 0, p = s.pop() || 0, d = s.pop() || 0;
      if (p - d <= a) {
        for (var g = d; g <= p; g++)
          qF(i[2 * g], i[2 * g + 1], t, n) <= u && l.push(o[g]);
        continue;
      }
      var f = d + p >> 1, m = i[2 * f], v = i[2 * f + 1];
      qF(m, v, t, n) <= u && l.push(o[f]), (c === 0 ? t - r <= m : n - r <= v) && (s.push(d), s.push(f - 1), s.push(1 - c)), (c === 0 ? t + r >= m : n + r >= v) && (s.push(f + 1), s.push(p), s.push(1 - c));
    }
    return l;
  }
}
function Mk(e, t, n, r, o, i) {
  if (!(o - r <= n)) {
    var a = r + o >> 1;
    nG(e, t, a, r, o, i), Mk(e, t, n, r, a - 1, 1 - i), Mk(e, t, n, a + 1, o, 1 - i);
  }
}
function nG(e, t, n, r, o, i) {
  for (; o > r; ) {
    if (o - r > 600) {
      var a = o - r + 1, s = n - r + 1, l = Math.log(a), u = 0.5 * Math.exp(2 * l / 3), c = 0.5 * Math.sqrt(l * u * (a - u) / a) * (s - a / 2 < 0 ? -1 : 1), p = Math.max(r, Math.floor(n - s * u / a + c)), d = Math.min(o, Math.floor(n + (a - s) * u / a + c));
      nG(e, t, n, p, d, i);
    }
    var g = t[2 * n + i], f = r, m = o;
    for (pp(e, t, r, n), t[2 * o + i] > g && pp(e, t, r, o); f < m; ) {
      for (pp(e, t, f, m), f++, m--; t[2 * f + i] < g; ) f++;
      for (; t[2 * m + i] > g; ) m--;
    }
    t[2 * r + i] === g ? pp(e, t, r, m) : (m++, pp(e, t, m, o)), m <= n && (r = m + 1), n <= m && (o = m - 1);
  }
}
function pp(e, t, n, r) {
  cx(e, n, r), cx(t, 2 * n, 2 * r), cx(t, 2 * n + 1, 2 * r + 1);
}
function cx(e, t, n) {
  var r = e[t];
  e[t] = e[n], e[n] = r;
}
function qF(e, t, n, r) {
  var o = e - n, i = t - r;
  return o * o + i * i;
}
var L1e = {
  minZoom: 0,
  // min zoom to generate clusters on
  maxZoom: 16,
  // max zoom level to cluster the points on
  minPoints: 2,
  // minimum points to form a cluster
  radius: 40,
  // cluster radius in pixels
  extent: 512,
  // tile extent (radius is calculated relative to it)
  nodeSize: 64,
  // size of the KD-tree leaf node, affects performance
  log: !1,
  // whether to log timing info
  // whether to generate numeric ids for input features (in vector tiles)
  generateId: !1,
  // a reduce function for calculating custom cluster properties
  reduce: null,
  // (accumulated, props) => { accumulated.sum += props.sum; }
  // properties to use for individual points when running the reducer
  map: (e) => e
  // props => ({sum: props.my_value})
}, GF = Math.fround || /* @__PURE__ */ ((e) => (t) => (e[0] = +t, e[0]))(new Float32Array(1)), Fl = 2, Za = 3, px = 4, Fa = 5, rG = 6;
class P1e {
  constructor(t) {
    this.options = Object.assign(Object.create(L1e), t), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
  }
  load(t) {
    var {
      log: n,
      minZoom: r,
      maxZoom: o
    } = this.options;
    n && console.time("total time");
    var i = "prepare ".concat(t.length, " points");
    n && console.time(i), this.points = t;
    for (var a = [], s = 0; s < t.length; s++) {
      var l = t[s];
      if (l.geometry) {
        var [u, c] = l.geometry.coordinates, p = GF(Sg(u)), d = GF(Mg(c));
        a.push(
          p,
          d,
          // projected point coordinates
          1 / 0,
          // the last zoom the point was processed at
          s,
          // index of the source feature in the original input array
          -1,
          // parent cluster id
          1
          // number of points in a cluster
        ), this.options.reduce && a.push(0);
      }
    }
    var g = this.trees[o + 1] = this._createTree(a);
    n && console.timeEnd(i);
    for (var f = o; f >= r; f--) {
      var m = +Date.now();
      g = this.trees[f] = this._createTree(this._cluster(g, f)), n && console.log("z%d: %d clusters in %dms", f, g.numItems, +Date.now() - m);
    }
    return n && console.timeEnd("total time"), this;
  }
  getClusters(t, n) {
    var r = ((t[0] + 180) % 360 + 360) % 360 - 180, o = Math.max(-90, Math.min(90, t[1])), i = t[2] === 180 ? 180 : ((t[2] + 180) % 360 + 360) % 360 - 180, a = Math.max(-90, Math.min(90, t[3]));
    if (t[2] - t[0] >= 360)
      r = -180, i = 180;
    else if (r > i) {
      var s = this.getClusters([r, o, 180, a], n), l = this.getClusters([-180, o, i, a], n);
      return s.concat(l);
    }
    var u = this.trees[this._limitZoom(n)], c = u.range(Sg(r), Mg(a), Sg(i), Mg(o)), p = u.data, d = [];
    for (var g of c) {
      var f = this.stride * g;
      d.push(p[f + Fa] > 1 ? KF(p, f, this.clusterProps) : this.points[p[f + Za]]);
    }
    return d;
  }
  getChildren(t) {
    var n = this._getOriginId(t), r = this._getOriginZoom(t), o = "No cluster with the specified id.", i = this.trees[r];
    if (!i) throw new Error(o);
    var a = i.data;
    if (n * this.stride >= a.length) throw new Error(o);
    var s = this.options.radius / (this.options.extent * Math.pow(2, r - 1)), l = a[n * this.stride], u = a[n * this.stride + 1], c = i.within(l, u, s), p = [];
    for (var d of c) {
      var g = d * this.stride;
      a[g + px] === t && p.push(a[g + Fa] > 1 ? KF(a, g, this.clusterProps) : this.points[a[g + Za]]);
    }
    if (p.length === 0) throw new Error(o);
    return p;
  }
  getLeaves(t, n, r) {
    n = n || 10, r = r || 0;
    var o = [];
    return this._appendLeaves(o, t, n, r, 0), o;
  }
  getTile(t, n, r) {
    var o = this.trees[this._limitZoom(t)], i = Math.pow(2, t), {
      extent: a,
      radius: s
    } = this.options, l = s / a, u = (r - l) / i, c = (r + 1 + l) / i, p = {
      features: []
    };
    return this._addTileFeatures(o.range((n - l) / i, u, (n + 1 + l) / i, c), o.data, n, r, i, p), n === 0 && this._addTileFeatures(o.range(1 - l / i, u, 1, c), o.data, i, r, i, p), n === i - 1 && this._addTileFeatures(o.range(0, u, l / i, c), o.data, -1, r, i, p), p.features.length ? p : null;
  }
  getClusterExpansionZoom(t) {
    for (var n = this._getOriginZoom(t) - 1; n <= this.options.maxZoom; ) {
      var r = this.getChildren(t);
      if (n++, r.length !== 1) break;
      t = r[0].properties.cluster_id;
    }
    return n;
  }
  _appendLeaves(t, n, r, o, i) {
    var a = this.getChildren(n);
    for (var s of a) {
      var l = s.properties;
      if (l && l.cluster ? i + l.point_count <= o ? i += l.point_count : i = this._appendLeaves(t, l.cluster_id, r, o, i) : i < o ? i++ : t.push(s), t.length === r) break;
    }
    return i;
  }
  _createTree(t) {
    for (var n = new v_(t.length / this.stride | 0, this.options.nodeSize, Float32Array), r = 0; r < t.length; r += this.stride) n.add(t[r], t[r + 1]);
    return n.finish(), n.data = t, n;
  }
  _addTileFeatures(t, n, r, o, i, a) {
    for (var s of t) {
      var l = s * this.stride, u = n[l + Fa] > 1, c = void 0, p = void 0, d = void 0;
      if (u)
        c = oG(n, l, this.clusterProps), p = n[l], d = n[l + 1];
      else {
        var g = this.points[n[l + Za]];
        c = g.properties;
        var [f, m] = g.geometry.coordinates;
        p = Sg(f), d = Mg(m);
      }
      var v = {
        type: 1,
        geometry: [[Math.round(this.options.extent * (p * i - r)), Math.round(this.options.extent * (d * i - o))]],
        tags: c
      }, E = void 0;
      u || this.options.generateId ? E = n[l + Za] : E = this.points[n[l + Za]].id, E !== void 0 && (v.id = E), a.features.push(v);
    }
  }
  _limitZoom(t) {
    return Math.max(this.options.minZoom, Math.min(Math.floor(+t), this.options.maxZoom + 1));
  }
  _cluster(t, n) {
    for (var {
      radius: r,
      extent: o,
      reduce: i,
      minPoints: a
    } = this.options, s = r / (o * Math.pow(2, n)), l = t.data, u = [], c = this.stride, p = 0; p < l.length; p += c)
      if (!(l[p + Fl] <= n)) {
        l[p + Fl] = n;
        var d = l[p], g = l[p + 1], f = t.within(l[p], l[p + 1], s), m = l[p + Fa], v = m;
        for (var E of f) {
          var w = E * c;
          l[w + Fl] > n && (v += l[w + Fa]);
        }
        if (v > m && v >= a) {
          var M = d * m, O = g * m, y = void 0, C = -1, _ = ((p / c | 0) << 5) + (n + 1) + this.points.length;
          for (var F of f) {
            var L = F * c;
            if (!(l[L + Fl] <= n)) {
              l[L + Fl] = n;
              var N = l[L + Fa];
              M += l[L] * N, O += l[L + 1] * N, l[L + px] = _, i && (y || (y = this._map(l, p, !0), C = this.clusterProps.length, this.clusterProps.push(y)), i(y, this._map(l, L)));
            }
          }
          l[p + px] = _, u.push(M / v, O / v, 1 / 0, _, -1, v), i && u.push(C);
        } else {
          for (var R = 0; R < c; R++) u.push(l[p + R]);
          if (v > 1)
            for (var W of f) {
              var V = W * c;
              if (!(l[V + Fl] <= n)) {
                l[V + Fl] = n;
                for (var z = 0; z < c; z++) u.push(l[V + z]);
              }
            }
        }
      }
    return u;
  }
  // get index of the point from which the cluster originated
  _getOriginId(t) {
    return t - this.points.length >> 5;
  }
  // get zoom of the point from which the cluster originated
  _getOriginZoom(t) {
    return (t - this.points.length) % 32;
  }
  _map(t, n, r) {
    if (t[n + Fa] > 1) {
      var o = this.clusterProps[t[n + rG]];
      return r ? Object.assign({}, o) : o;
    }
    var i = this.points[t[n + Za]].properties, a = this.options.map(i);
    return r && a === i ? Object.assign({}, a) : a;
  }
}
function KF(e, t, n) {
  return {
    type: "Feature",
    id: e[t + Za],
    properties: oG(e, t, n),
    geometry: {
      type: "Point",
      coordinates: [_1e(e[t]), S1e(e[t + 1])]
    }
  };
}
function oG(e, t, n) {
  var r = e[t + Fa], o = r >= 1e4 ? "".concat(Math.round(r / 1e3), "k") : r >= 1e3 ? "".concat(Math.round(r / 100) / 10, "k") : r, i = e[t + rG], a = i === -1 ? {} : Object.assign({}, n[i]);
  return Object.assign(a, {
    cluster: !0,
    cluster_id: e[t + Za],
    point_count: r,
    point_count_abbreviated: o
  });
}
function Sg(e) {
  return e / 360 + 0.5;
}
function Mg(e) {
  var t = Math.sin(e * Math.PI / 180), n = 0.5 - 0.25 * Math.log((1 + t) / (1 - t)) / Math.PI;
  return n < 0 ? 0 : n > 1 ? 1 : n;
}
function _1e(e) {
  return (e - 0.5) * 360;
}
function S1e(e) {
  var t = (180 - e * 360) * Math.PI / 180;
  return 360 * Math.atan(Math.exp(t)) / Math.PI - 90;
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function M1e(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
    t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
  return n;
}
class Ii {
  static isAdvancedMarkerAvailable(t) {
    return google.maps.marker && t.getMapCapabilities().isAdvancedMarkersAvailable === !0;
  }
  static isAdvancedMarker(t) {
    return google.maps.marker && t instanceof google.maps.marker.AdvancedMarkerElement;
  }
  static setMap(t, n) {
    this.isAdvancedMarker(t) ? t.map = n : t.setMap(n);
  }
  static getPosition(t) {
    if (this.isAdvancedMarker(t)) {
      if (t.position) {
        if (t.position instanceof google.maps.LatLng)
          return t.position;
        if (t.position.lat && t.position.lng)
          return new google.maps.LatLng(t.position.lat, t.position.lng);
      }
      return new google.maps.LatLng(null);
    }
    return t.getPosition();
  }
  static getVisible(t) {
    return this.isAdvancedMarker(t) ? !0 : t.getVisible();
  }
}
class Dk {
  constructor(t) {
    var {
      markers: n,
      position: r
    } = t;
    this.markers = n, r && (r instanceof google.maps.LatLng ? this._position = r : this._position = new google.maps.LatLng(r));
  }
  get bounds() {
    if (!(this.markers.length === 0 && !this._position)) {
      var t = new google.maps.LatLngBounds(this._position, this._position);
      for (var n of this.markers)
        t.extend(Ii.getPosition(n));
      return t;
    }
  }
  get position() {
    return this._position || this.bounds.getCenter();
  }
  /**
   * Get the count of **visible** markers.
   */
  get count() {
    return this.markers.filter((t) => Ii.getVisible(t)).length;
  }
  /**
   * Add a marker to the cluster.
   */
  push(t) {
    this.markers.push(t);
  }
  /**
   * Cleanup references and remove marker from map.
   */
  delete() {
    this.marker && (Ii.setMap(this.marker, null), this.marker = void 0), this.markers.length = 0;
  }
}
class D1e {
  constructor(t) {
    var {
      maxZoom: n = 16
    } = t;
    this.maxZoom = n;
  }
  /**
   * Helper function to bypass clustering based upon some map state such as
   * zoom, number of markers, etc.
   *
   * ```typescript
   *  cluster({markers, map}: AlgorithmInput): Cluster[] {
   *    if (shouldBypassClustering(map)) {
   *      return this.noop({markers})
   *    }
   * }
   * ```
   */
  noop(t) {
    var {
      markers: n
    } = t;
    return T1e(n);
  }
}
var T1e = (e) => {
  var t = e.map((n) => new Dk({
    position: Ii.getPosition(n),
    markers: [n]
  }));
  return t;
};
class j1e extends D1e {
  constructor(t) {
    var {
      maxZoom: n,
      radius: r = 60
    } = t, o = M1e(t, ["maxZoom", "radius"]);
    super({
      maxZoom: n
    }), this.state = {
      zoom: -1
    }, this.superCluster = new P1e(Object.assign({
      maxZoom: this.maxZoom,
      radius: r
    }, o));
  }
  calculate(t) {
    var n = !1, r = {
      zoom: t.map.getZoom()
    };
    if (!VF(t.markers, this.markers)) {
      n = !0, this.markers = [...t.markers];
      var o = this.markers.map((i) => {
        var a = Ii.getPosition(i), s = [a.lng(), a.lat()];
        return {
          type: "Feature",
          geometry: {
            type: "Point",
            coordinates: s
          },
          properties: {
            marker: i
          }
        };
      });
      this.superCluster.load(o);
    }
    return n || (this.state.zoom <= this.maxZoom || r.zoom <= this.maxZoom) && (n = !VF(this.state, r)), this.state = r, n && (this.clusters = this.cluster(t)), {
      clusters: this.clusters,
      changed: n
    };
  }
  cluster(t) {
    var {
      map: n
    } = t;
    return this.superCluster.getClusters([-180, -90, 180, 90], Math.round(n.getZoom())).map((r) => this.transformCluster(r));
  }
  transformCluster(t) {
    var {
      geometry: {
        coordinates: [n, r]
      },
      properties: o
    } = t;
    if (o.cluster)
      return new Dk({
        markers: this.superCluster.getLeaves(o.cluster_id, 1 / 0).map((a) => a.properties.marker),
        position: {
          lat: r,
          lng: n
        }
      });
    var i = o.marker;
    return new Dk({
      markers: [i],
      position: Ii.getPosition(i)
    });
  }
}
class A1e {
  constructor(t, n) {
    this.markers = {
      sum: t.length
    };
    var r = n.map((i) => i.count), o = r.reduce((i, a) => i + a, 0);
    this.clusters = {
      count: n.length,
      markers: {
        mean: o / n.length,
        sum: o,
        min: Math.min(...r),
        max: Math.max(...r)
      }
    };
  }
}
class I1e {
  /**
   * The default render function for the library used by {@link MarkerClusterer}.
   *
   * Currently set to use the following:
   *
   * ```typescript
   * // change color if this cluster has more markers than the mean cluster
   * const color =
   *   count > Math.max(10, stats.clusters.markers.mean)
   *     ? "#ff0000"
   *     : "#0000ff";
   *
   * // create svg url with fill color
   * const svg = window.btoa(`
   * <svg fill="${color}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240">
   *   <circle cx="120" cy="120" opacity=".6" r="70" />
   *   <circle cx="120" cy="120" opacity=".3" r="90" />
   *   <circle cx="120" cy="120" opacity=".2" r="110" />
   *   <circle cx="120" cy="120" opacity=".1" r="130" />
   * </svg>`);
   *
   * // create marker using svg icon
   * return new google.maps.Marker({
   *   position,
   *   icon: {
   *     url: `data:image/svg+xml;base64,${svg}`,
   *     scaledSize: new google.maps.Size(45, 45),
   *   },
   *   label: {
   *     text: String(count),
   *     color: "rgba(255,255,255,0.9)",
   *     fontSize: "12px",
   *   },
   *   // adjust zIndex to be above other markers
   *   zIndex: 1000 + count,
   * });
   * ```
   */
  render(t, n, r) {
    var {
      count: o,
      position: i
    } = t, a = o > Math.max(10, n.clusters.markers.mean) ? "#ff0000" : "#0000ff", s = '<svg fill="'.concat(a, `" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" width="50" height="50">
<circle cx="120" cy="120" opacity=".6" r="70" />
<circle cx="120" cy="120" opacity=".3" r="90" />
<circle cx="120" cy="120" opacity=".2" r="110" />
<text x="50%" y="50%" style="fill:#fff" text-anchor="middle" font-size="50" dominant-baseline="middle" font-family="roboto,arial,sans-serif">`).concat(o, `</text>
</svg>`), l = "Cluster of ".concat(o, " markers"), u = Number(google.maps.Marker.MAX_ZINDEX) + o;
    if (Ii.isAdvancedMarkerAvailable(r)) {
      var c = new DOMParser(), p = c.parseFromString(s, "image/svg+xml").documentElement;
      p.setAttribute("transform", "translate(0 25)");
      var d = {
        map: r,
        position: i,
        zIndex: u,
        title: l,
        content: p
      };
      return new google.maps.marker.AdvancedMarkerElement(d);
    }
    var g = {
      position: i,
      zIndex: u,
      title: l,
      icon: {
        url: "data:image/svg+xml;base64,".concat(btoa(s)),
        anchor: new google.maps.Point(25, 25)
      }
    };
    return new google.maps.Marker(g);
  }
}
function R1e(e, t) {
  for (var n in t.prototype)
    e.prototype[n] = t.prototype[n];
}
class y_ {
  constructor() {
    R1e(y_, google.maps.OverlayView);
  }
}
var id;
(function(e) {
  e.CLUSTERING_BEGIN = "clusteringbegin", e.CLUSTERING_END = "clusteringend", e.CLUSTER_CLICK = "click";
})(id || (id = {}));
var B1e = (e, t, n) => {
  n.fitBounds(t.bounds);
};
class N1e extends y_ {
  constructor(t) {
    var {
      map: n,
      markers: r = [],
      algorithmOptions: o = {},
      algorithm: i = new j1e(o),
      renderer: a = new I1e(),
      onClusterClick: s = B1e
    } = t;
    super(), this.markers = [...r], this.clusters = [], this.algorithm = i, this.renderer = a, this.onClusterClick = s, n && this.setMap(n);
  }
  addMarker(t, n) {
    this.markers.includes(t) || (this.markers.push(t), n || this.render());
  }
  addMarkers(t, n) {
    t.forEach((r) => {
      this.addMarker(r, !0);
    }), n || this.render();
  }
  removeMarker(t, n) {
    var r = this.markers.indexOf(t);
    return r === -1 ? !1 : (Ii.setMap(t, null), this.markers.splice(r, 1), n || this.render(), !0);
  }
  removeMarkers(t, n) {
    var r = !1;
    return t.forEach((o) => {
      r = this.removeMarker(o, !0) || r;
    }), r && !n && this.render(), r;
  }
  clearMarkers(t) {
    this.markers.length = 0, t || this.render();
  }
  /**
   * Recalculates and draws all the marker clusters.
   */
  render() {
    var t = this.getMap();
    if (t instanceof google.maps.Map && t.getProjection()) {
      google.maps.event.trigger(this, id.CLUSTERING_BEGIN, this);
      var {
        clusters: n,
        changed: r
      } = this.algorithm.calculate({
        markers: this.markers,
        map: t,
        mapCanvasProjection: this.getProjection()
      });
      if (r || r == null) {
        var o = /* @__PURE__ */ new Set();
        for (var i of n)
          i.markers.length == 1 && o.add(i.markers[0]);
        var a = [];
        for (var s of this.clusters)
          s.marker != null && (s.markers.length == 1 ? o.has(s.marker) || Ii.setMap(s.marker, null) : a.push(s.marker));
        this.clusters = n, this.renderClusters(), requestAnimationFrame(() => a.forEach((l) => Ii.setMap(l, null)));
      }
      google.maps.event.trigger(this, id.CLUSTERING_END, this);
    }
  }
  onAdd() {
    this.idleListener = this.getMap().addListener("idle", this.render.bind(this)), this.render();
  }
  onRemove() {
    google.maps.event.removeListener(this.idleListener), this.reset();
  }
  reset() {
    this.markers.forEach((t) => Ii.setMap(t, null)), this.clusters.forEach((t) => t.delete()), this.clusters = [];
  }
  renderClusters() {
    var t = new A1e(this.markers, this.clusters), n = this.getMap();
    this.clusters.forEach((r) => {
      r.markers.length === 1 ? r.marker = r.markers[0] : (r.marker = this.renderer.render(r, t, n), r.markers.forEach((o) => Ii.setMap(o, null)), this.onClusterClick && r.marker.addListener(
        "click",
        /* istanbul ignore next */
        (o) => {
          google.maps.event.trigger(this, id.CLUSTER_CLICK, r), this.onClusterClick(o, r, n);
        }
      )), Ii.setMap(r.marker, n);
    });
  }
}
function YF(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function XF(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? YF(Object(n), !0).forEach(function(r) {
      Oe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : YF(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function F1e(e) {
  var t = Bke(), [n, r] = k(null);
  return h(() => {
    if (t && n === null) {
      var o = new N1e(XF(XF({}, e), {}, {
        map: t
      }));
      r(o);
    }
  }, [t]), n;
}
function z1e(e) {
  var {
    children: t,
    options: n
  } = e, r = F1e(n);
  return r !== null ? t(r) : null;
}
ve(z1e);
var JF = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, QF = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
function U1e(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, g = ge(At), [f, m] = k(null), [v, E] = k(null), [w, M] = k(null), [O, y] = k(null), [C, _] = k(null), [F, L] = k(null), N = ut(null);
  return h(() => {
    f !== null && (f.close(), n ? f.open(g, n) : f.getPosition() && f.open(g));
  }, [g, f, n]), h(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), h(() => {
    o && f !== null && f.setPosition(o);
  }, [o]), h(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), h(() => {
    f && a && (v !== null && google.maps.event.removeListener(v), E(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), h(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), M(google.maps.event.addListener(f, "domready", s)));
  }, [s]), h(() => {
    f && l && (O !== null && google.maps.event.removeListener(O), y(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), h(() => {
    f && u && (C !== null && google.maps.event.removeListener(C), _(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), h(() => {
    f && c && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), h(() => {
    var R = new google.maps.InfoWindow(r);
    return m(R), N.current = document.createElement("div"), a && E(google.maps.event.addListener(R, "closeclick", a)), s && M(google.maps.event.addListener(R, "domready", s)), l && y(google.maps.event.addListener(R, "content_changed", l)), u && _(google.maps.event.addListener(R, "position_changed", u)), c && L(google.maps.event.addListener(R, "zindex_changed", c)), R.setContent(N.current), o && R.setPosition(o), i && R.setZIndex(i), n ? R.open(g, n) : R.getPosition() ? R.open(g) : wo(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>."), p && p(R), () => {
      v && google.maps.event.removeListener(v), O && google.maps.event.removeListener(O), w && google.maps.event.removeListener(w), C && google.maps.event.removeListener(C), F && google.maps.event.removeListener(F), d && d(R), R.close();
    };
  }, []), N.current ? or(lt.only(t), N.current) : null;
}
ve(U1e);
class H1e extends pe {
  constructor() {
    super(...arguments), Oe(this, "registeredEvents", []), Oe(this, "containerElement", null), Oe(this, "state", {
      infoWindow: null
    }), Oe(this, "open", (t, n) => {
      n ? t.open(this.context, n) : t.getPosition() ? t.open(this.context) : wo(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>.");
    }), Oe(this, "setInfoWindowCallback", () => {
      this.state.infoWindow !== null && this.containerElement !== null && (this.state.infoWindow.setContent(this.containerElement), this.open(this.state.infoWindow, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoWindow));
    });
  }
  componentDidMount() {
    var t = new google.maps.InfoWindow(this.props.options);
    this.containerElement = document.createElement("div"), this.registeredEvents = un({
      updaterMap: QF,
      eventMap: JF,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(() => ({
      infoWindow: t
    }), this.setInfoWindowCallback);
  }
  componentDidUpdate(t) {
    this.state.infoWindow !== null && (gn(this.registeredEvents), this.registeredEvents = un({
      updaterMap: QF,
      eventMap: JF,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.infoWindow
    }));
  }
  componentWillUnmount() {
    this.state.infoWindow !== null && (gn(this.registeredEvents), this.props.onUnmount && this.props.onUnmount(this.state.infoWindow), this.state.infoWindow.close());
  }
  render() {
    return this.containerElement ? or(lt.only(this.props.children), this.containerElement) : null;
  }
}
Oe(H1e, "contextType", At);
function e2(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Yv(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? e2(Object(n), !0).forEach(function(r) {
      Oe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : e2(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var t2 = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, n2 = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, $1e = {};
function W1e(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: g,
    onRightClick: f,
    onClick: m,
    onDrag: v,
    onLoad: E,
    onUnmount: w
  } = e, M = ge(At), [O, y] = k(null), [C, _] = k(null), [F, L] = k(null), [N, R] = k(null), [W, V] = k(null), [z, Z] = k(null), [K, X] = k(null), [te, J] = k(null), [P, D] = k(null), [H, S] = k(null), [$, x] = k(null), [j, U] = k(null);
  return h(() => {
    O !== null && O.setMap(M);
  }, [M]), h(() => {
    typeof t < "u" && O !== null && O.setOptions(t);
  }, [O, t]), h(() => {
    typeof n < "u" && O !== null && O.setDraggable(n);
  }, [O, n]), h(() => {
    typeof r < "u" && O !== null && O.setEditable(r);
  }, [O, r]), h(() => {
    typeof o < "u" && O !== null && O.setVisible(o);
  }, [O, o]), h(() => {
    typeof i < "u" && O !== null && O.setPath(i);
  }, [O, i]), h(() => {
    O && a && (C !== null && google.maps.event.removeListener(C), _(google.maps.event.addListener(O, "dblclick", a)));
  }, [a]), h(() => {
    O && s && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(O, "dragend", s)));
  }, [s]), h(() => {
    O && l && (N !== null && google.maps.event.removeListener(N), R(google.maps.event.addListener(O, "dragstart", l)));
  }, [l]), h(() => {
    O && u && (W !== null && google.maps.event.removeListener(W), V(google.maps.event.addListener(O, "mousedown", u)));
  }, [u]), h(() => {
    O && c && (z !== null && google.maps.event.removeListener(z), Z(google.maps.event.addListener(O, "mousemove", c)));
  }, [c]), h(() => {
    O && p && (K !== null && google.maps.event.removeListener(K), X(google.maps.event.addListener(O, "mouseout", p)));
  }, [p]), h(() => {
    O && d && (te !== null && google.maps.event.removeListener(te), J(google.maps.event.addListener(O, "mouseover", d)));
  }, [d]), h(() => {
    O && g && (P !== null && google.maps.event.removeListener(P), D(google.maps.event.addListener(O, "mouseup", g)));
  }, [g]), h(() => {
    O && f && (H !== null && google.maps.event.removeListener(H), S(google.maps.event.addListener(O, "rightclick", f)));
  }, [f]), h(() => {
    O && m && ($ !== null && google.maps.event.removeListener($), x(google.maps.event.addListener(O, "click", m)));
  }, [m]), h(() => {
    O && v && (j !== null && google.maps.event.removeListener(j), U(google.maps.event.addListener(O, "drag", v)));
  }, [v]), h(() => {
    var T = new google.maps.Polyline(Yv(Yv({}, t || $1e), {}, {
      map: M
    }));
    return i && T.setPath(i), typeof o < "u" && T.setVisible(o), typeof r < "u" && T.setEditable(r), typeof n < "u" && T.setDraggable(n), a && _(google.maps.event.addListener(T, "dblclick", a)), s && L(google.maps.event.addListener(T, "dragend", s)), l && R(google.maps.event.addListener(T, "dragstart", l)), u && V(google.maps.event.addListener(T, "mousedown", u)), c && Z(google.maps.event.addListener(T, "mousemove", c)), p && X(google.maps.event.addListener(T, "mouseout", p)), d && J(google.maps.event.addListener(T, "mouseover", d)), g && D(google.maps.event.addListener(T, "mouseup", g)), f && S(google.maps.event.addListener(T, "rightclick", f)), m && x(google.maps.event.addListener(T, "click", m)), v && U(google.maps.event.addListener(T, "drag", v)), y(T), E && E(T), () => {
      C !== null && google.maps.event.removeListener(C), F !== null && google.maps.event.removeListener(F), N !== null && google.maps.event.removeListener(N), W !== null && google.maps.event.removeListener(W), z !== null && google.maps.event.removeListener(z), K !== null && google.maps.event.removeListener(K), te !== null && google.maps.event.removeListener(te), P !== null && google.maps.event.removeListener(P), H !== null && google.maps.event.removeListener(H), $ !== null && google.maps.event.removeListener($), w && w(T), T.setMap(null);
    };
  }, []), null;
}
ve(W1e);
class V1e extends pe {
  constructor() {
    super(...arguments), Oe(this, "registeredEvents", []), Oe(this, "state", {
      polyline: null
    }), Oe(this, "setPolylineCallback", () => {
      this.state.polyline !== null && this.props.onLoad && this.props.onLoad(this.state.polyline);
    });
  }
  componentDidMount() {
    var t = new google.maps.Polyline(Yv(Yv({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = un({
      updaterMap: n2,
      eventMap: t2,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        polyline: t
      };
    }, this.setPolylineCallback);
  }
  componentDidUpdate(t) {
    this.state.polyline !== null && (gn(this.registeredEvents), this.registeredEvents = un({
      updaterMap: n2,
      eventMap: t2,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.polyline
    }));
  }
  componentWillUnmount() {
    this.state.polyline !== null && (this.props.onUnmount && this.props.onUnmount(this.state.polyline), gn(this.registeredEvents), this.state.polyline.setMap(null));
  }
  render() {
    return null;
  }
}
Oe(V1e, "contextType", At);
function r2(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function o2(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? r2(Object(n), !0).forEach(function(r) {
      Oe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : r2(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var i2 = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, s2 = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  paths(e, t) {
    e.setPaths(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function Z1e(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    paths: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: g,
    onMouseUp: f,
    onRightClick: m,
    onClick: v,
    onDrag: E,
    onLoad: w,
    onUnmount: M,
    onEdit: O
  } = e, y = ge(At), [C, _] = k(null), [F, L] = k(null), [N, R] = k(null), [W, V] = k(null), [z, Z] = k(null), [K, X] = k(null), [te, J] = k(null), [P, D] = k(null), [H, S] = k(null), [$, x] = k(null), [j, U] = k(null), [T, q] = k(null);
  return h(() => {
    C !== null && C.setMap(y);
  }, [y]), h(() => {
    typeof t < "u" && C !== null && C.setOptions(t);
  }, [C, t]), h(() => {
    typeof n < "u" && C !== null && C.setDraggable(n);
  }, [C, n]), h(() => {
    typeof r < "u" && C !== null && C.setEditable(r);
  }, [C, r]), h(() => {
    typeof o < "u" && C !== null && C.setVisible(o);
  }, [C, o]), h(() => {
    typeof i < "u" && C !== null && C.setPath(i);
  }, [C, i]), h(() => {
    typeof a < "u" && C !== null && C.setPaths(a);
  }, [C, a]), h(() => {
    C && typeof s == "function" && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(C, "dblclick", s)));
  }, [s]), h(() => {
    C && (google.maps.event.addListener(C.getPath(), "insert_at", () => {
      O == null || O(C);
    }), google.maps.event.addListener(C.getPath(), "set_at", () => {
      O == null || O(C);
    }), google.maps.event.addListener(C.getPath(), "remove_at", () => {
      O == null || O(C);
    }));
  }, [C, O]), h(() => {
    C && typeof l == "function" && (N !== null && google.maps.event.removeListener(N), R(google.maps.event.addListener(C, "dragend", l)));
  }, [l]), h(() => {
    C && typeof u == "function" && (W !== null && google.maps.event.removeListener(W), V(google.maps.event.addListener(C, "dragstart", u)));
  }, [u]), h(() => {
    C && typeof c == "function" && (z !== null && google.maps.event.removeListener(z), Z(google.maps.event.addListener(C, "mousedown", c)));
  }, [c]), h(() => {
    C && typeof p == "function" && (K !== null && google.maps.event.removeListener(K), X(google.maps.event.addListener(C, "mousemove", p)));
  }, [p]), h(() => {
    C && typeof d == "function" && (te !== null && google.maps.event.removeListener(te), J(google.maps.event.addListener(C, "mouseout", d)));
  }, [d]), h(() => {
    C && typeof g == "function" && (P !== null && google.maps.event.removeListener(P), D(google.maps.event.addListener(C, "mouseover", g)));
  }, [g]), h(() => {
    C && typeof f == "function" && (H !== null && google.maps.event.removeListener(H), S(google.maps.event.addListener(C, "mouseup", f)));
  }, [f]), h(() => {
    C && typeof m == "function" && ($ !== null && google.maps.event.removeListener($), x(google.maps.event.addListener(C, "rightclick", m)));
  }, [m]), h(() => {
    C && typeof v == "function" && (j !== null && google.maps.event.removeListener(j), U(google.maps.event.addListener(C, "click", v)));
  }, [v]), h(() => {
    C && typeof E == "function" && (T !== null && google.maps.event.removeListener(T), q(google.maps.event.addListener(C, "drag", E)));
  }, [E]), h(() => {
    var A = new google.maps.Polygon(o2(o2({}, t), {}, {
      map: y
    }));
    return i && A.setPath(i), a && A.setPaths(a), typeof o < "u" && A.setVisible(o), typeof r < "u" && A.setEditable(r), typeof n < "u" && A.setDraggable(n), s && L(google.maps.event.addListener(A, "dblclick", s)), l && R(google.maps.event.addListener(A, "dragend", l)), u && V(google.maps.event.addListener(A, "dragstart", u)), c && Z(google.maps.event.addListener(A, "mousedown", c)), p && X(google.maps.event.addListener(A, "mousemove", p)), d && J(google.maps.event.addListener(A, "mouseout", d)), g && D(google.maps.event.addListener(A, "mouseover", g)), f && S(google.maps.event.addListener(A, "mouseup", f)), m && x(google.maps.event.addListener(A, "rightclick", m)), v && U(google.maps.event.addListener(A, "click", v)), E && q(google.maps.event.addListener(A, "drag", E)), _(A), w && w(A), () => {
      F !== null && google.maps.event.removeListener(F), N !== null && google.maps.event.removeListener(N), W !== null && google.maps.event.removeListener(W), z !== null && google.maps.event.removeListener(z), K !== null && google.maps.event.removeListener(K), te !== null && google.maps.event.removeListener(te), P !== null && google.maps.event.removeListener(P), H !== null && google.maps.event.removeListener(H), $ !== null && google.maps.event.removeListener($), j !== null && google.maps.event.removeListener(j), M && M(A), A.setMap(null);
    };
  }, []), null;
}
ve(Z1e);
class q1e extends pe {
  constructor() {
    super(...arguments), Oe(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this.props.options || {};
    this.polygon = new google.maps.Polygon(t), this.polygon.setMap(this.context), this.registeredEvents = un({
      updaterMap: s2,
      eventMap: i2,
      prevProps: {},
      nextProps: this.props,
      instance: this.polygon
    }), this.props.onLoad && this.props.onLoad(this.polygon);
  }
  componentDidUpdate(t) {
    this.polygon && (gn(this.registeredEvents), this.registeredEvents = un({
      updaterMap: s2,
      eventMap: i2,
      prevProps: t,
      nextProps: this.props,
      instance: this.polygon
    }));
  }
  componentWillUnmount() {
    this.polygon && (this.props.onUnmount && this.props.onUnmount(this.polygon), gn(this.registeredEvents), this.polygon && this.polygon.setMap(null));
  }
  render() {
    return null;
  }
}
Oe(q1e, "contextType", At);
function a2(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Xv(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? a2(Object(n), !0).forEach(function(r) {
      Oe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : a2(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var l2 = {
  onBoundsChanged: "bounds_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, u2 = {
  bounds(e, t) {
    e.setBounds(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function G1e(e) {
  var {
    options: t,
    bounds: n,
    draggable: r,
    editable: o,
    visible: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: g,
    onRightClick: f,
    onClick: m,
    onDrag: v,
    onBoundsChanged: E,
    onLoad: w,
    onUnmount: M
  } = e, O = ge(At), [y, C] = k(null), [_, F] = k(null), [L, N] = k(null), [R, W] = k(null), [V, z] = k(null), [Z, K] = k(null), [X, te] = k(null), [J, P] = k(null), [D, H] = k(null), [S, $] = k(null), [x, j] = k(null), [U, T] = k(null), [q, A] = k(null);
  return h(() => {
    y !== null && y.setMap(O);
  }, [O]), h(() => {
    typeof t < "u" && y !== null && y.setOptions(t);
  }, [y, t]), h(() => {
    typeof r < "u" && y !== null && y.setDraggable(r);
  }, [y, r]), h(() => {
    typeof o < "u" && y !== null && y.setEditable(o);
  }, [y, o]), h(() => {
    typeof i < "u" && y !== null && y.setVisible(i);
  }, [y, i]), h(() => {
    typeof n < "u" && y !== null && y.setBounds(n);
  }, [y, n]), h(() => {
    y && a && (_ !== null && google.maps.event.removeListener(_), F(google.maps.event.addListener(y, "dblclick", a)));
  }, [a]), h(() => {
    y && s && (L !== null && google.maps.event.removeListener(L), N(google.maps.event.addListener(y, "dragend", s)));
  }, [s]), h(() => {
    y && l && (R !== null && google.maps.event.removeListener(R), W(google.maps.event.addListener(y, "dragstart", l)));
  }, [l]), h(() => {
    y && u && (V !== null && google.maps.event.removeListener(V), z(google.maps.event.addListener(y, "mousedown", u)));
  }, [u]), h(() => {
    y && c && (Z !== null && google.maps.event.removeListener(Z), K(google.maps.event.addListener(y, "mousemove", c)));
  }, [c]), h(() => {
    y && p && (X !== null && google.maps.event.removeListener(X), te(google.maps.event.addListener(y, "mouseout", p)));
  }, [p]), h(() => {
    y && d && (J !== null && google.maps.event.removeListener(J), P(google.maps.event.addListener(y, "mouseover", d)));
  }, [d]), h(() => {
    y && g && (D !== null && google.maps.event.removeListener(D), H(google.maps.event.addListener(y, "mouseup", g)));
  }, [g]), h(() => {
    y && f && (S !== null && google.maps.event.removeListener(S), $(google.maps.event.addListener(y, "rightclick", f)));
  }, [f]), h(() => {
    y && m && (x !== null && google.maps.event.removeListener(x), j(google.maps.event.addListener(y, "click", m)));
  }, [m]), h(() => {
    y && v && (U !== null && google.maps.event.removeListener(U), T(google.maps.event.addListener(y, "drag", v)));
  }, [v]), h(() => {
    y && E && (q !== null && google.maps.event.removeListener(q), A(google.maps.event.addListener(y, "bounds_changed", E)));
  }, [E]), h(() => {
    var Y = new google.maps.Rectangle(Xv(Xv({}, t), {}, {
      map: O
    }));
    return typeof i < "u" && Y.setVisible(i), typeof o < "u" && Y.setEditable(o), typeof r < "u" && Y.setDraggable(r), typeof n < "u" && Y.setBounds(n), a && F(google.maps.event.addListener(Y, "dblclick", a)), s && N(google.maps.event.addListener(Y, "dragend", s)), l && W(google.maps.event.addListener(Y, "dragstart", l)), u && z(google.maps.event.addListener(Y, "mousedown", u)), c && K(google.maps.event.addListener(Y, "mousemove", c)), p && te(google.maps.event.addListener(Y, "mouseout", p)), d && P(google.maps.event.addListener(Y, "mouseover", d)), g && H(google.maps.event.addListener(Y, "mouseup", g)), f && $(google.maps.event.addListener(Y, "rightclick", f)), m && j(google.maps.event.addListener(Y, "click", m)), v && T(google.maps.event.addListener(Y, "drag", v)), E && A(google.maps.event.addListener(Y, "bounds_changed", E)), C(Y), w && w(Y), () => {
      _ !== null && google.maps.event.removeListener(_), L !== null && google.maps.event.removeListener(L), R !== null && google.maps.event.removeListener(R), V !== null && google.maps.event.removeListener(V), Z !== null && google.maps.event.removeListener(Z), X !== null && google.maps.event.removeListener(X), J !== null && google.maps.event.removeListener(J), D !== null && google.maps.event.removeListener(D), S !== null && google.maps.event.removeListener(S), x !== null && google.maps.event.removeListener(x), U !== null && google.maps.event.removeListener(U), q !== null && google.maps.event.removeListener(q), M && M(Y), Y.setMap(null);
    };
  }, []), null;
}
ve(G1e);
class K1e extends pe {
  constructor() {
    super(...arguments), Oe(this, "registeredEvents", []), Oe(this, "state", {
      rectangle: null
    }), Oe(this, "setRectangleCallback", () => {
      this.state.rectangle !== null && this.props.onLoad && this.props.onLoad(this.state.rectangle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Rectangle(Xv(Xv({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = un({
      updaterMap: u2,
      eventMap: l2,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        rectangle: t
      };
    }, this.setRectangleCallback);
  }
  componentDidUpdate(t) {
    this.state.rectangle !== null && (gn(this.registeredEvents), this.registeredEvents = un({
      updaterMap: u2,
      eventMap: l2,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.rectangle
    }));
  }
  componentWillUnmount() {
    this.state.rectangle !== null && (this.props.onUnmount && this.props.onUnmount(this.state.rectangle), gn(this.registeredEvents), this.state.rectangle.setMap(null));
  }
  render() {
    return null;
  }
}
Oe(K1e, "contextType", At);
function c2(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Jv(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? c2(Object(n), !0).forEach(function(r) {
      Oe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : c2(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var p2 = {
  onCenterChanged: "center_changed",
  onRadiusChanged: "radius_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, d2 = {
  center(e, t) {
    e.setCenter(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  radius(e, t) {
    e.setRadius(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, Y1e = {};
function X1e(e) {
  var {
    options: t,
    center: n,
    radius: r,
    draggable: o,
    editable: i,
    visible: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: g,
    onMouseUp: f,
    onRightClick: m,
    onClick: v,
    onDrag: E,
    onCenterChanged: w,
    onRadiusChanged: M,
    onLoad: O,
    onUnmount: y
  } = e, C = ge(At), [_, F] = k(null), [L, N] = k(null), [R, W] = k(null), [V, z] = k(null), [Z, K] = k(null), [X, te] = k(null), [J, P] = k(null), [D, H] = k(null), [S, $] = k(null), [x, j] = k(null), [U, T] = k(null), [q, A] = k(null), [Y, B] = k(null), [ue, fe] = k(null);
  return h(() => {
    _ !== null && _.setMap(C);
  }, [C]), h(() => {
    typeof t < "u" && _ !== null && _.setOptions(t);
  }, [_, t]), h(() => {
    typeof o < "u" && _ !== null && _.setDraggable(o);
  }, [_, o]), h(() => {
    typeof i < "u" && _ !== null && _.setEditable(i);
  }, [_, i]), h(() => {
    typeof a < "u" && _ !== null && _.setVisible(a);
  }, [_, a]), h(() => {
    typeof r == "number" && _ !== null && _.setRadius(r);
  }, [_, r]), h(() => {
    typeof n < "u" && _ !== null && _.setCenter(n);
  }, [_, n]), h(() => {
    _ && s && (L !== null && google.maps.event.removeListener(L), N(google.maps.event.addListener(_, "dblclick", s)));
  }, [s]), h(() => {
    _ && l && (R !== null && google.maps.event.removeListener(R), W(google.maps.event.addListener(_, "dragend", l)));
  }, [l]), h(() => {
    _ && u && (V !== null && google.maps.event.removeListener(V), z(google.maps.event.addListener(_, "dragstart", u)));
  }, [u]), h(() => {
    _ && c && (Z !== null && google.maps.event.removeListener(Z), K(google.maps.event.addListener(_, "mousedown", c)));
  }, [c]), h(() => {
    _ && p && (X !== null && google.maps.event.removeListener(X), te(google.maps.event.addListener(_, "mousemove", p)));
  }, [p]), h(() => {
    _ && d && (J !== null && google.maps.event.removeListener(J), P(google.maps.event.addListener(_, "mouseout", d)));
  }, [d]), h(() => {
    _ && g && (D !== null && google.maps.event.removeListener(D), H(google.maps.event.addListener(_, "mouseover", g)));
  }, [g]), h(() => {
    _ && f && (S !== null && google.maps.event.removeListener(S), $(google.maps.event.addListener(_, "mouseup", f)));
  }, [f]), h(() => {
    _ && m && (x !== null && google.maps.event.removeListener(x), j(google.maps.event.addListener(_, "rightclick", m)));
  }, [m]), h(() => {
    _ && v && (U !== null && google.maps.event.removeListener(U), T(google.maps.event.addListener(_, "click", v)));
  }, [v]), h(() => {
    _ && E && (q !== null && google.maps.event.removeListener(q), A(google.maps.event.addListener(_, "drag", E)));
  }, [E]), h(() => {
    _ && w && (Y !== null && google.maps.event.removeListener(Y), B(google.maps.event.addListener(_, "center_changed", w)));
  }, [v]), h(() => {
    _ && M && (ue !== null && google.maps.event.removeListener(ue), fe(google.maps.event.addListener(_, "radius_changed", M)));
  }, [M]), h(() => {
    var oe = new google.maps.Circle(Jv(Jv({}, t || Y1e), {}, {
      map: C
    }));
    return typeof r == "number" && oe.setRadius(r), typeof n < "u" && oe.setCenter(n), typeof r == "number" && oe.setRadius(r), typeof a < "u" && oe.setVisible(a), typeof i < "u" && oe.setEditable(i), typeof o < "u" && oe.setDraggable(o), s && N(google.maps.event.addListener(oe, "dblclick", s)), l && W(google.maps.event.addListener(oe, "dragend", l)), u && z(google.maps.event.addListener(oe, "dragstart", u)), c && K(google.maps.event.addListener(oe, "mousedown", c)), p && te(google.maps.event.addListener(oe, "mousemove", p)), d && P(google.maps.event.addListener(oe, "mouseout", d)), g && H(google.maps.event.addListener(oe, "mouseover", g)), f && $(google.maps.event.addListener(oe, "mouseup", f)), m && j(google.maps.event.addListener(oe, "rightclick", m)), v && T(google.maps.event.addListener(oe, "click", v)), E && A(google.maps.event.addListener(oe, "drag", E)), w && B(google.maps.event.addListener(oe, "center_changed", w)), M && fe(google.maps.event.addListener(oe, "radius_changed", M)), F(oe), O && O(oe), () => {
      L !== null && google.maps.event.removeListener(L), R !== null && google.maps.event.removeListener(R), V !== null && google.maps.event.removeListener(V), Z !== null && google.maps.event.removeListener(Z), X !== null && google.maps.event.removeListener(X), J !== null && google.maps.event.removeListener(J), D !== null && google.maps.event.removeListener(D), S !== null && google.maps.event.removeListener(S), x !== null && google.maps.event.removeListener(x), U !== null && google.maps.event.removeListener(U), Y !== null && google.maps.event.removeListener(Y), ue !== null && google.maps.event.removeListener(ue), y && y(oe), oe.setMap(null);
    };
  }, []), null;
}
ve(X1e);
class J1e extends pe {
  constructor() {
    super(...arguments), Oe(this, "registeredEvents", []), Oe(this, "state", {
      circle: null
    }), Oe(this, "setCircleCallback", () => {
      this.state.circle !== null && this.props.onLoad && this.props.onLoad(this.state.circle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Circle(Jv(Jv({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = un({
      updaterMap: d2,
      eventMap: p2,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        circle: t
      };
    }, this.setCircleCallback);
  }
  componentDidUpdate(t) {
    this.state.circle !== null && (gn(this.registeredEvents), this.registeredEvents = un({
      updaterMap: d2,
      eventMap: p2,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.circle
    }));
  }
  componentWillUnmount() {
    if (this.state.circle !== null) {
      var t;
      this.props.onUnmount && this.props.onUnmount(this.state.circle), gn(this.registeredEvents), (t = this.state.circle) === null || t === void 0 || t.setMap(null);
    }
  }
  render() {
    return null;
  }
}
Oe(J1e, "contextType", At);
function f2(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Qv(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? f2(Object(n), !0).forEach(function(r) {
      Oe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : f2(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var h2 = {
  onClick: "click",
  onDblClick: "dblclick",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onAddFeature: "addfeature",
  onRemoveFeature: "removefeature",
  onRemoveProperty: "removeproperty",
  onSetGeometry: "setgeometry",
  onSetProperty: "setproperty"
}, g2 = {
  add(e, t) {
    e.add(t);
  },
  addgeojson(e, t, n) {
    e.addGeoJson(t, n);
  },
  contains(e, t) {
    e.contains(t);
  },
  foreach(e, t) {
    e.forEach(t);
  },
  loadgeojson(e, t, n, r) {
    e.loadGeoJson(t, n, r);
  },
  overridestyle(e, t, n) {
    e.overrideStyle(t, n);
  },
  remove(e, t) {
    e.remove(t);
  },
  revertstyle(e, t) {
    e.revertStyle(t);
  },
  controlposition(e, t) {
    e.setControlPosition(t);
  },
  controls(e, t) {
    e.setControls(t);
  },
  drawingmode(e, t) {
    e.setDrawingMode(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  style(e, t) {
    e.setStyle(t);
  },
  togeojson(e, t) {
    e.toGeoJson(t);
  }
};
function Q1e(e) {
  var {
    options: t,
    onClick: n,
    onDblClick: r,
    onMouseDown: o,
    onMouseMove: i,
    onMouseOut: a,
    onMouseOver: s,
    onMouseUp: l,
    onRightClick: u,
    onAddFeature: c,
    onRemoveFeature: p,
    onRemoveProperty: d,
    onSetGeometry: g,
    onSetProperty: f,
    onLoad: m,
    onUnmount: v
  } = e, E = ge(At), [w, M] = k(null), [O, y] = k(null), [C, _] = k(null), [F, L] = k(null), [N, R] = k(null), [W, V] = k(null), [z, Z] = k(null), [K, X] = k(null), [te, J] = k(null), [P, D] = k(null), [H, S] = k(null), [$, x] = k(null), [j, U] = k(null), [T, q] = k(null);
  return h(() => {
    w !== null && w.setMap(E);
  }, [E]), h(() => {
    w && r && (O !== null && google.maps.event.removeListener(O), y(google.maps.event.addListener(w, "dblclick", r)));
  }, [r]), h(() => {
    w && o && (C !== null && google.maps.event.removeListener(C), _(google.maps.event.addListener(w, "mousedown", o)));
  }, [o]), h(() => {
    w && i && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(w, "mousemove", i)));
  }, [i]), h(() => {
    w && a && (N !== null && google.maps.event.removeListener(N), R(google.maps.event.addListener(w, "mouseout", a)));
  }, [a]), h(() => {
    w && s && (W !== null && google.maps.event.removeListener(W), V(google.maps.event.addListener(w, "mouseover", s)));
  }, [s]), h(() => {
    w && l && (z !== null && google.maps.event.removeListener(z), Z(google.maps.event.addListener(w, "mouseup", l)));
  }, [l]), h(() => {
    w && u && (K !== null && google.maps.event.removeListener(K), X(google.maps.event.addListener(w, "rightclick", u)));
  }, [u]), h(() => {
    w && n && (te !== null && google.maps.event.removeListener(te), J(google.maps.event.addListener(w, "click", n)));
  }, [n]), h(() => {
    w && c && (P !== null && google.maps.event.removeListener(P), D(google.maps.event.addListener(w, "addfeature", c)));
  }, [c]), h(() => {
    w && p && (H !== null && google.maps.event.removeListener(H), S(google.maps.event.addListener(w, "removefeature", p)));
  }, [p]), h(() => {
    w && d && ($ !== null && google.maps.event.removeListener($), x(google.maps.event.addListener(w, "removeproperty", d)));
  }, [d]), h(() => {
    w && g && (j !== null && google.maps.event.removeListener(j), U(google.maps.event.addListener(w, "setgeometry", g)));
  }, [g]), h(() => {
    w && f && (T !== null && google.maps.event.removeListener(T), q(google.maps.event.addListener(w, "setproperty", f)));
  }, [f]), h(() => {
    if (E !== null) {
      var A = new google.maps.Data(Qv(Qv({}, t), {}, {
        map: E
      }));
      r && y(google.maps.event.addListener(A, "dblclick", r)), o && _(google.maps.event.addListener(A, "mousedown", o)), i && L(google.maps.event.addListener(A, "mousemove", i)), a && R(google.maps.event.addListener(A, "mouseout", a)), s && V(google.maps.event.addListener(A, "mouseover", s)), l && Z(google.maps.event.addListener(A, "mouseup", l)), u && X(google.maps.event.addListener(A, "rightclick", u)), n && J(google.maps.event.addListener(A, "click", n)), c && D(google.maps.event.addListener(A, "addfeature", c)), p && S(google.maps.event.addListener(A, "removefeature", p)), d && x(google.maps.event.addListener(A, "removeproperty", d)), g && U(google.maps.event.addListener(A, "setgeometry", g)), f && q(google.maps.event.addListener(A, "setproperty", f)), M(A), m && m(A);
    }
    return () => {
      w && (O !== null && google.maps.event.removeListener(O), C !== null && google.maps.event.removeListener(C), F !== null && google.maps.event.removeListener(F), N !== null && google.maps.event.removeListener(N), W !== null && google.maps.event.removeListener(W), z !== null && google.maps.event.removeListener(z), K !== null && google.maps.event.removeListener(K), te !== null && google.maps.event.removeListener(te), P !== null && google.maps.event.removeListener(P), H !== null && google.maps.event.removeListener(H), $ !== null && google.maps.event.removeListener($), j !== null && google.maps.event.removeListener(j), T !== null && google.maps.event.removeListener(T), v && v(w), w.setMap(null));
    };
  }, []), null;
}
ve(Q1e);
class eLe extends pe {
  constructor() {
    super(...arguments), Oe(this, "registeredEvents", []), Oe(this, "state", {
      data: null
    }), Oe(this, "setDataCallback", () => {
      this.state.data !== null && this.props.onLoad && this.props.onLoad(this.state.data);
    });
  }
  componentDidMount() {
    if (this.context !== null) {
      var t = new google.maps.Data(Qv(Qv({}, this.props.options), {}, {
        map: this.context
      }));
      this.registeredEvents = un({
        updaterMap: g2,
        eventMap: h2,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        data: t
      }), this.setDataCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.data !== null && (gn(this.registeredEvents), this.registeredEvents = un({
      updaterMap: g2,
      eventMap: h2,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.data
    }));
  }
  componentWillUnmount() {
    this.state.data !== null && (this.props.onUnmount && this.props.onUnmount(this.state.data), gn(this.registeredEvents), this.state.data && this.state.data.setMap(null));
  }
  render() {
    return null;
  }
}
Oe(eLe, "contextType", At);
function m2(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function v2(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? m2(Object(n), !0).forEach(function(r) {
      Oe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : m2(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var y2 = {
  onClick: "click",
  onDefaultViewportChanged: "defaultviewport_changed",
  onStatusChanged: "status_changed"
}, b2 = {
  options(e, t) {
    e.setOptions(t);
  },
  url(e, t) {
    e.setUrl(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
class tLe extends pe {
  constructor() {
    super(...arguments), Oe(this, "registeredEvents", []), Oe(this, "state", {
      kmlLayer: null
    }), Oe(this, "setKmlLayerCallback", () => {
      this.state.kmlLayer !== null && this.props.onLoad && this.props.onLoad(this.state.kmlLayer);
    });
  }
  componentDidMount() {
    var t = new google.maps.KmlLayer(v2(v2({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = un({
      updaterMap: b2,
      eventMap: y2,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        kmlLayer: t
      };
    }, this.setKmlLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.kmlLayer !== null && (gn(this.registeredEvents), this.registeredEvents = un({
      updaterMap: b2,
      eventMap: y2,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.kmlLayer
    }));
  }
  componentWillUnmount() {
    this.state.kmlLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.kmlLayer), gn(this.registeredEvents), this.state.kmlLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Oe(tLe, "contextType", At);
function iG(e, t) {
  return typeof t == "function" ? t(e.offsetWidth, e.offsetHeight) : {
    x: 0,
    y: 0
  };
}
function nLe(e, t) {
  return new t(e.lat, e.lng);
}
function rLe(e, t) {
  return new t(new google.maps.LatLng(e.ne.lat, e.ne.lng), new google.maps.LatLng(e.sw.lat, e.sw.lng));
}
function oLe(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function iLe(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function sLe(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n.getNorthEast()), o = e && e.fromLatLngToDivPixel(n.getSouthWest());
  return r && o ? {
    left: "".concat(o.x + t.x, "px"),
    top: "".concat(r.y + t.y, "px"),
    width: "".concat(r.x - o.x - t.x, "px"),
    height: "".concat(o.y - r.y - t.y, "px")
  } : {
    left: "-9999px",
    top: "-9999px"
  };
}
function aLe(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n);
  if (r) {
    var {
      x: o,
      y: i
    } = r;
    return {
      left: "".concat(o + t.x, "px"),
      top: "".concat(i + t.y, "px")
    };
  }
  return {
    left: "-9999px",
    top: "-9999px"
  };
}
function sG(e, t, n, r) {
  return n !== void 0 ? sLe(e, t, iLe(n, google.maps.LatLngBounds, rLe)) : aLe(e, t, oLe(r, google.maps.LatLng, nLe));
}
function lLe(e, t) {
  return e.left === t.left && e.top === t.top && e.width === t.height && e.height === t.height;
}
function w2(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function uLe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? w2(Object(n), !0).forEach(function(r) {
      Oe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : w2(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function cLe(e, t, n, r, o) {
  class i extends google.maps.OverlayView {
    constructor(s, l, u, c) {
      super(), this.container = s, this.pane = l, this.position = u, this.bounds = c;
    }
    onAdd() {
      var s, l = (s = this.getPanes()) === null || s === void 0 ? void 0 : s[this.pane];
      l == null || l.appendChild(this.container);
    }
    draw() {
      var s = this.getProjection(), l = uLe({}, this.container ? iG(this.container, o) : {
        x: 0,
        y: 0
      }), u = sG(s, l, this.bounds, this.position);
      for (var [c, p] of Object.entries(u))
        this.container.style[c] = p;
    }
    onRemove() {
      this.container.parentNode !== null && this.container.parentNode.removeChild(this.container);
    }
  }
  return new i(e, t, n, r);
}
function C2(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function pLe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? C2(Object(n), !0).forEach(function(r) {
      Oe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : C2(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function x2(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLng ? e : new google.maps.LatLng(e.lat, e.lng);
  return t + "";
}
function O2(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLngBounds ? e : new google.maps.LatLngBounds(new google.maps.LatLng(e.south, e.east), new google.maps.LatLng(e.north, e.west));
  return t + "";
}
function dLe(e) {
  var {
    position: t,
    bounds: n,
    mapPaneName: r,
    zIndex: o,
    onLoad: i,
    onUnmount: a,
    getPixelPositionOffset: s,
    children: l
  } = e, u = ge(At), c = Cn(() => {
    var d = document.createElement("div");
    return d.style.position = "absolute", d;
  }, []), p = Cn(() => cLe(c, r, t, n, s), [c, r, t, n]);
  return h(() => (i == null || i(p), p == null || p.setMap(u), () => {
    a == null || a(p), p == null || p.setMap(null);
  }), [u, p]), h(() => {
    c.style.zIndex = "".concat(o);
  }, [o, c]), wi.createPortal(l, c);
}
ve(dLe);
class jc extends pe {
  constructor(t) {
    super(t), Oe(this, "state", {
      paneEl: null,
      containerStyle: {
        // set initial position
        position: "absolute"
      }
    }), Oe(this, "updatePane", () => {
      var r = this.props.mapPaneName, o = this.overlayView.getPanes();
      wo(!!r, "OverlayView requires props.mapPaneName but got %s", r), o ? this.setState({
        paneEl: o[r]
      }) : this.setState({
        paneEl: null
      });
    }), Oe(this, "onAdd", () => {
      var r, o;
      this.updatePane(), (r = (o = this.props).onLoad) === null || r === void 0 || r.call(o, this.overlayView);
    }), Oe(this, "onPositionElement", () => {
      var r = this.overlayView.getProjection(), o = pLe({
        x: 0,
        y: 0
      }, this.containerRef.current ? iG(this.containerRef.current, this.props.getPixelPositionOffset) : {}), i = sG(r, o, this.props.bounds, this.props.position);
      if (!lLe(i, {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        left: this.state.containerStyle.left,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        top: this.state.containerStyle.top,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        width: this.state.containerStyle.width,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        height: this.state.containerStyle.height
      })) {
        var a, s, l, u;
        this.setState({
          containerStyle: {
            top: (a = i.top) !== null && a !== void 0 ? a : 0,
            left: (s = i.left) !== null && s !== void 0 ? s : 0,
            width: (l = i.width) !== null && l !== void 0 ? l : 0,
            height: (u = i.height) !== null && u !== void 0 ? u : 0,
            position: "absolute"
          }
        });
      }
    }), Oe(this, "draw", () => {
      this.onPositionElement();
    }), Oe(this, "onRemove", () => {
      var r, o;
      this.setState(() => ({
        paneEl: null
      })), (r = (o = this.props).onUnmount) === null || r === void 0 || r.call(o, this.overlayView);
    }), this.containerRef = mo();
    var n = new google.maps.OverlayView();
    n.onAdd = this.onAdd, n.draw = this.draw, n.onRemove = this.onRemove, this.overlayView = n;
  }
  componentDidMount() {
    this.overlayView.setMap(this.context);
  }
  componentDidUpdate(t) {
    var n = x2(t.position), r = x2(this.props.position), o = O2(t.bounds), i = O2(this.props.bounds);
    (n !== r || o !== i) && this.overlayView.draw(), t.mapPaneName !== this.props.mapPaneName && this.updatePane();
  }
  componentWillUnmount() {
    this.overlayView.setMap(null);
  }
  render() {
    var t = this.state.paneEl;
    return t ? wi.createPortal(So.jsx("div", {
      ref: this.containerRef,
      style: this.state.containerStyle,
      children: lt.only(this.props.children)
    }), t) : null;
  }
}
Oe(jc, "FLOAT_PANE", "floatPane");
Oe(jc, "MAP_PANE", "mapPane");
Oe(jc, "MARKER_LAYER", "markerLayer");
Oe(jc, "OVERLAY_LAYER", "overlayLayer");
Oe(jc, "OVERLAY_MOUSE_TARGET", "overlayMouseTarget");
Oe(jc, "contextType", At);
function fLe() {
}
function E2(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function k2(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? E2(Object(n), !0).forEach(function(r) {
      Oe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : E2(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var L2 = {
  onDblClick: "dblclick",
  onClick: "click"
}, P2 = {
  opacity(e, t) {
    e.setOpacity(t);
  }
};
function hLe(e) {
  var {
    url: t,
    bounds: n,
    options: r,
    visible: o
  } = e, i = ge(At), a = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east)), s = Cn(() => new google.maps.GroundOverlay(t, a, r), []);
  return h(() => {
    s !== null && s.setMap(i);
  }, [i]), h(() => {
    typeof t < "u" && s !== null && (s.set("url", t), s.setMap(i));
  }, [s, t]), h(() => {
    typeof o < "u" && s !== null && s.setOpacity(o ? 1 : 0);
  }, [s, o]), h(() => {
    var l = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east));
    typeof n < "u" && s !== null && (s.set("bounds", l), s.setMap(i));
  }, [s, n]), null;
}
ve(hLe);
class aG extends pe {
  constructor() {
    super(...arguments), Oe(this, "registeredEvents", []), Oe(this, "state", {
      groundOverlay: null
    }), Oe(this, "setGroundOverlayCallback", () => {
      this.state.groundOverlay !== null && this.props.onLoad && this.props.onLoad(this.state.groundOverlay);
    });
  }
  componentDidMount() {
    wo(!!this.props.url || !!this.props.bounds, "For GroundOverlay, url and bounds are passed in to constructor and are immutable after instantiated. This is the behavior of Google Maps JavaScript API v3 ( See https://developers.google.com/maps/documentation/javascript/reference#GroundOverlay) Hence, use the corresponding two props provided by `react-google-maps-api`, url and bounds. In some cases, you'll need the GroundOverlay component to reflect the changes of url and bounds. You can leverage the React's key property to remount the component. Typically, just `key={url}` would serve your need. See https://github.com/tomchentw/react-google-maps/issues/655");
    var t = new google.maps.GroundOverlay(this.props.url, this.props.bounds, k2(k2({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = un({
      updaterMap: P2,
      eventMap: L2,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        groundOverlay: t
      };
    }, this.setGroundOverlayCallback);
  }
  componentDidUpdate(t) {
    this.state.groundOverlay !== null && (gn(this.registeredEvents), this.registeredEvents = un({
      updaterMap: P2,
      eventMap: L2,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.groundOverlay
    }));
  }
  componentWillUnmount() {
    this.state.groundOverlay && (this.props.onUnmount && this.props.onUnmount(this.state.groundOverlay), this.state.groundOverlay.setMap(null));
  }
  render() {
    return null;
  }
}
Oe(aG, "defaultProps", {
  onLoad: fLe
});
Oe(aG, "contextType", At);
function _2(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ey(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? _2(Object(n), !0).forEach(function(r) {
      Oe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : _2(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var S2 = {}, M2 = {
  data(e, t) {
    e.setData(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function gLe(e) {
  var {
    data: t,
    onLoad: n,
    onUnmount: r,
    options: o
  } = e, i = ge(At), [a, s] = k(null);
  return h(() => {
    google.maps.visualization || wo(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} in useJsApiScript? %s', google.maps.visualization);
  }, []), h(() => {
    wo(!!t, "data property is required in HeatmapLayer %s", t);
  }, [t]), h(() => {
    a !== null && a.setMap(i);
  }, [i]), h(() => {
    o && a !== null && a.setOptions(o);
  }, [a, o]), h(() => {
    var l = new google.maps.visualization.HeatmapLayer(ey(ey({}, o), {}, {
      data: t,
      map: i
    }));
    return s(l), n && n(l), () => {
      a !== null && (r && r(a), a.setMap(null));
    };
  }, []), null;
}
ve(gLe);
class mLe extends pe {
  constructor() {
    super(...arguments), Oe(this, "registeredEvents", []), Oe(this, "state", {
      heatmapLayer: null
    }), Oe(this, "setHeatmapLayerCallback", () => {
      this.state.heatmapLayer !== null && this.props.onLoad && this.props.onLoad(this.state.heatmapLayer);
    });
  }
  componentDidMount() {
    wo(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} to <LoadScript />? %s', google.maps.visualization), wo(!!this.props.data, "data property is required in HeatmapLayer %s", this.props.data);
    var t = new google.maps.visualization.HeatmapLayer(ey(ey({}, this.props.options), {}, {
      data: this.props.data,
      map: this.context
    }));
    this.registeredEvents = un({
      updaterMap: M2,
      eventMap: S2,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        heatmapLayer: t
      };
    }, this.setHeatmapLayerCallback);
  }
  componentDidUpdate(t) {
    gn(this.registeredEvents), this.registeredEvents = un({
      updaterMap: M2,
      eventMap: S2,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.heatmapLayer
    });
  }
  componentWillUnmount() {
    this.state.heatmapLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.heatmapLayer), gn(this.registeredEvents), this.state.heatmapLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Oe(mLe, "contextType", At);
var D2 = {
  onCloseClick: "closeclick",
  onPanoChanged: "pano_changed",
  onPositionChanged: "position_changed",
  onPovChanged: "pov_changed",
  onResize: "resize",
  onStatusChanged: "status_changed",
  onVisibleChanged: "visible_changed",
  onZoomChanged: "zoom_changed"
}, T2 = {
  register(e, t, n) {
    e.registerPanoProvider(t, n);
  },
  links(e, t) {
    e.setLinks(t);
  },
  motionTracking(e, t) {
    e.setMotionTracking(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  pano(e, t) {
    e.setPano(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  pov(e, t) {
    e.setPov(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zoom(e, t) {
    e.setZoom(t);
  }
};
class vLe extends pe {
  constructor() {
    super(...arguments), Oe(this, "registeredEvents", []), Oe(this, "state", {
      streetViewPanorama: null
    }), Oe(this, "setStreetViewPanoramaCallback", () => {
      this.state.streetViewPanorama !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewPanorama);
    });
  }
  componentDidMount() {
    var t, n, r = (t = (n = this.context) === null || n === void 0 ? void 0 : n.getStreetView()) !== null && t !== void 0 ? t : null;
    this.registeredEvents = un({
      updaterMap: T2,
      eventMap: D2,
      prevProps: {},
      nextProps: this.props,
      instance: r
    }), this.setState(() => ({
      streetViewPanorama: r
    }), this.setStreetViewPanoramaCallback);
  }
  componentDidUpdate(t) {
    this.state.streetViewPanorama !== null && (gn(this.registeredEvents), this.registeredEvents = un({
      updaterMap: T2,
      eventMap: D2,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.streetViewPanorama
    }));
  }
  componentWillUnmount() {
    this.state.streetViewPanorama !== null && (this.props.onUnmount && this.props.onUnmount(this.state.streetViewPanorama), gn(this.registeredEvents), this.state.streetViewPanorama.setVisible(!1));
  }
  render() {
    return null;
  }
}
Oe(vLe, "contextType", At);
class yLe extends pe {
  constructor() {
    super(...arguments), Oe(this, "state", {
      streetViewService: null
    }), Oe(this, "setStreetViewServiceCallback", () => {
      this.state.streetViewService !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewService);
    });
  }
  componentDidMount() {
    var t = new google.maps.StreetViewService();
    this.setState(function() {
      return {
        streetViewService: t
      };
    }, this.setStreetViewServiceCallback);
  }
  componentWillUnmount() {
    this.state.streetViewService !== null && this.props.onUnmount && this.props.onUnmount(this.state.streetViewService);
  }
  render() {
    return null;
  }
}
Oe(yLe, "contextType", At);
var j2 = {
  onDirectionsChanged: "directions_changed"
}, A2 = {
  directions(e, t) {
    e.setDirections(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  panel(e, t) {
    e.setPanel(t);
  },
  routeIndex(e, t) {
    e.setRouteIndex(t);
  }
};
class bLe extends pe {
  constructor() {
    super(...arguments), Oe(this, "registeredEvents", []), Oe(this, "state", {
      directionsRenderer: null
    }), Oe(this, "setDirectionsRendererCallback", () => {
      this.state.directionsRenderer !== null && (this.state.directionsRenderer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.directionsRenderer));
    });
  }
  componentDidMount() {
    var t = new google.maps.DirectionsRenderer(this.props.options);
    this.registeredEvents = un({
      updaterMap: A2,
      eventMap: j2,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        directionsRenderer: t
      };
    }, this.setDirectionsRendererCallback);
  }
  componentDidUpdate(t) {
    this.state.directionsRenderer !== null && (gn(this.registeredEvents), this.registeredEvents = un({
      updaterMap: A2,
      eventMap: j2,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.directionsRenderer
    }));
  }
  componentWillUnmount() {
    this.state.directionsRenderer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.directionsRenderer), gn(this.registeredEvents), this.state.directionsRenderer && this.state.directionsRenderer.setMap(null));
  }
  render() {
    return null;
  }
}
Oe(bLe, "contextType", At);
var I2 = {
  onPlacesChanged: "places_changed"
}, R2 = {
  bounds(e, t) {
    e.setBounds(t);
  }
};
class wLe extends pe {
  constructor() {
    super(...arguments), Oe(this, "registeredEvents", []), Oe(this, "containerElement", mo()), Oe(this, "state", {
      searchBox: null
    }), Oe(this, "setSearchBoxCallback", () => {
      this.state.searchBox !== null && this.props.onLoad && this.props.onLoad(this.state.searchBox);
    });
  }
  componentDidMount() {
    if (wo(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places), this.containerElement !== null && this.containerElement.current !== null) {
      var t = this.containerElement.current.querySelector("input");
      if (t !== null) {
        var n = new google.maps.places.SearchBox(t, this.props.options);
        this.registeredEvents = un({
          updaterMap: R2,
          eventMap: I2,
          prevProps: {},
          nextProps: this.props,
          instance: n
        }), this.setState(function() {
          return {
            searchBox: n
          };
        }, this.setSearchBoxCallback);
      }
    }
  }
  componentDidUpdate(t) {
    this.state.searchBox !== null && (gn(this.registeredEvents), this.registeredEvents = un({
      updaterMap: R2,
      eventMap: I2,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.searchBox
    }));
  }
  componentWillUnmount() {
    this.state.searchBox !== null && (this.props.onUnmount && this.props.onUnmount(this.state.searchBox), gn(this.registeredEvents));
  }
  render() {
    return So.jsx("div", {
      ref: this.containerElement,
      children: lt.only(this.props.children)
    });
  }
}
Oe(wLe, "contextType", At);
var B2 = {
  onPlaceChanged: "place_changed"
}, N2 = {
  bounds(e, t) {
    e.setBounds(t);
  },
  restrictions(e, t) {
    e.setComponentRestrictions(t);
  },
  fields(e, t) {
    e.setFields(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  types(e, t) {
    e.setTypes(t);
  }
};
class lG extends pe {
  constructor() {
    super(...arguments), Oe(this, "registeredEvents", []), Oe(this, "containerElement", mo()), Oe(this, "state", {
      autocomplete: null
    }), Oe(this, "setAutocompleteCallback", () => {
      this.state.autocomplete !== null && this.props.onLoad && this.props.onLoad(this.state.autocomplete);
    });
  }
  componentDidMount() {
    var t;
    wo(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places);
    var n = (t = this.containerElement.current) === null || t === void 0 ? void 0 : t.querySelector("input");
    if (n) {
      var r = new google.maps.places.Autocomplete(n, this.props.options);
      this.registeredEvents = un({
        updaterMap: N2,
        eventMap: B2,
        prevProps: {},
        nextProps: this.props,
        instance: r
      }), this.setState(() => ({
        autocomplete: r
      }), this.setAutocompleteCallback);
    }
  }
  componentDidUpdate(t) {
    gn(this.registeredEvents), this.registeredEvents = un({
      updaterMap: N2,
      eventMap: B2,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.autocomplete
    });
  }
  componentWillUnmount() {
    this.state.autocomplete !== null && gn(this.registeredEvents);
  }
  render() {
    return So.jsx("div", {
      ref: this.containerElement,
      className: this.props.className,
      children: lt.only(this.props.children)
    });
  }
}
Oe(lG, "defaultProps", {
  className: ""
});
Oe(lG, "contextType", At);
let CLe = { data: "" }, xLe = (e) => typeof window == "object" ? ((e ? e.querySelector("#_goober") : window._goober) || Object.assign((e || document.head).appendChild(document.createElement("style")), { innerHTML: " ", id: "_goober" })).firstChild : e || CLe, OLe = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g, ELe = /\/\*[^]*?\*\/|  +/g, F2 = /\n+/g, tl = (e, t) => {
  let n = "", r = "", o = "";
  for (let i in e) {
    let a = e[i];
    i[0] == "@" ? i[1] == "i" ? n = i + " " + a + ";" : r += i[1] == "f" ? tl(a, i) : i + "{" + tl(a, i[1] == "k" ? "" : t) + "}" : typeof a == "object" ? r += tl(a, t ? t.replace(/([^,])+/g, (s) => i.replace(/([^,]*:\S+\([^)]*\))|([^,])+/g, (l) => /&/.test(l) ? l.replace(/&/g, s) : s ? s + " " + l : l)) : i) : a != null && (i = /^--/.test(i) ? i : i.replace(/[A-Z]/g, "-$&").toLowerCase(), o += tl.p ? tl.p(i, a) : i + ":" + a + ";");
  }
  return n + (t && o ? t + "{" + o + "}" : o) + r;
}, Ks = {}, uG = (e) => {
  if (typeof e == "object") {
    let t = "";
    for (let n in e) t += n + uG(e[n]);
    return t;
  }
  return e;
}, kLe = (e, t, n, r, o) => {
  let i = uG(e), a = Ks[i] || (Ks[i] = ((l) => {
    let u = 0, c = 11;
    for (; u < l.length; ) c = 101 * c + l.charCodeAt(u++) >>> 0;
    return "go" + c;
  })(i));
  if (!Ks[a]) {
    let l = i !== e ? e : ((u) => {
      let c, p, d = [{}];
      for (; c = OLe.exec(u.replace(ELe, "")); ) c[4] ? d.shift() : c[3] ? (p = c[3].replace(F2, " ").trim(), d.unshift(d[0][p] = d[0][p] || {})) : d[0][c[1]] = c[2].replace(F2, " ").trim();
      return d[0];
    })(e);
    Ks[a] = tl(o ? { ["@keyframes " + a]: l } : l, n ? "" : "." + a);
  }
  let s = n && Ks.g ? Ks.g : null;
  return n && (Ks.g = Ks[a]), ((l, u, c, p) => {
    p ? u.data = u.data.replace(p, l) : u.data.indexOf(l) === -1 && (u.data = c ? l + u.data : u.data + l);
  })(Ks[a], t, r, s), a;
}, LLe = (e, t, n) => e.reduce((r, o, i) => {
  let a = t[i];
  if (a && a.call) {
    let s = a(n), l = s && s.props && s.props.className || /^go/.test(s) && s;
    a = l ? "." + l : s && typeof s == "object" ? s.props ? "" : tl(s, "") : s === !1 ? "" : s;
  }
  return r + o + (a ?? "");
}, "");
function $w(e) {
  let t = this || {}, n = e.call ? e(t.p) : e;
  return kLe(n.unshift ? n.raw ? LLe(n, [].slice.call(arguments, 1), t.p) : n.reduce((r, o) => Object.assign(r, o && o.call ? o(t.p) : o), {}) : n, xLe(t.target), t.g, t.o, t.k);
}
let cG, Tk, jk;
$w.bind({ g: 1 });
let ca = $w.bind({ k: 1 });
function PLe(e, t, n, r) {
  tl.p = t, cG = e, Tk = n, jk = r;
}
function _l(e, t) {
  let n = this || {};
  return function() {
    let r = arguments;
    function o(i, a) {
      let s = Object.assign({}, i), l = s.className || o.className;
      n.p = Object.assign({ theme: Tk && Tk() }, s), n.o = / *go\d+/.test(l), s.className = $w.apply(n, r) + (l ? " " + l : "");
      let u = e;
      return e[0] && (u = s.as || e, delete s.as), jk && u[0] && jk(s), cG(u, s);
    }
    return o;
  };
}
var _Le = (e) => typeof e == "function", SLe = (e, t) => _Le(e) ? e(t) : e, MLe = /* @__PURE__ */ (() => {
  let e;
  return () => {
    if (e === void 0 && typeof window < "u") {
      let t = matchMedia("(prefers-reduced-motion: reduce)");
      e = !t || t.matches;
    }
    return e;
  };
})(), DLe = ca`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`, TLe = ca`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`, jLe = ca`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`, ALe = _l("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${DLe} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${TLe} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${(e) => e.secondary || "#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${jLe} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`, ILe = ca`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, RLe = _l("div")`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${(e) => e.secondary || "#e0e0e0"};
  border-right-color: ${(e) => e.primary || "#616161"};
  animation: ${ILe} 1s linear infinite;
`, BLe = ca`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`, NLe = ca`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`, FLe = _l("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${BLe} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${NLe} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${(e) => e.secondary || "#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`, zLe = _l("div")`
  position: absolute;
`, ULe = _l("div")`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`, HLe = ca`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`, $Le = _l("div")`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${HLe} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`, WLe = ({ toast: e }) => {
  let { icon: t, type: n, iconTheme: r } = e;
  return t !== void 0 ? typeof t == "string" ? Be.createElement($Le, null, t) : t : n === "blank" ? null : Be.createElement(ULe, null, Be.createElement(RLe, { ...r }), n !== "loading" && Be.createElement(zLe, null, n === "error" ? Be.createElement(ALe, { ...r }) : Be.createElement(FLe, { ...r })));
}, VLe = (e) => `
0% {transform: translate3d(0,${e * -200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`, ZLe = (e) => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${e * -150}%,-1px) scale(.6); opacity:0;}
`, qLe = "0%{opacity:0;} 100%{opacity:1;}", GLe = "0%{opacity:1;} 100%{opacity:0;}", KLe = _l("div")`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`, YLe = _l("div")`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`, XLe = (e, t) => {
  let n = e.includes("top") ? 1 : -1, [r, o] = MLe() ? [qLe, GLe] : [VLe(n), ZLe(n)];
  return { animation: t ? `${ca(r)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards` : `${ca(o)} 0.4s forwards cubic-bezier(.06,.71,.55,1)` };
};
Be.memo(({ toast: e, position: t, style: n, children: r }) => {
  let o = e.height ? XLe(e.position || t || "top-center", e.visible) : { opacity: 0 }, i = Be.createElement(WLe, { toast: e }), a = Be.createElement(YLe, { ...e.ariaProps }, SLe(e.message, e));
  return Be.createElement(KLe, { className: e.className, style: { ...o, ...n, ...e.style } }, typeof r == "function" ? r({ icon: i, message: a }) : Be.createElement(Be.Fragment, null, i, a));
});
PLe(Be.createElement);
$w`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`;
Ke({});
function JLe(e) {
  return e && e.replace(/[^0-9]/g, "");
}
const QLe = {
  CNPJ: "99.999.999/9999-99"
};
JLe(QLe.CNPJ).length;
to((e, t) => /* @__PURE__ */ _o.jsx("input", { ref: t, ...e }));
function pG(e) {
  return e && e.replace(/[^0-9]/g, "");
}
const dG = {
  EIGTH: "(99) 9999-9999",
  NINE: "(99) 99999-9999"
};
function ePe(e, t) {
  let n = "", r = 0;
  for (let o = 0; o < t.length; o++)
    if (t[o] === "9")
      if (r < e.length)
        n += e[r], r++;
      else
        break;
    else if (r < e.length)
      n += t[o];
    else
      break;
  return n;
}
function tPe(e) {
  return e.length > 10 ? "NINE" : "EIGTH";
}
const nPe = pG(dG.NINE).length, rPe = to((e, t) => /* @__PURE__ */ _o.jsx("input", { ref: t, ...e }));
to(
  (e, t) => {
    const { onFocus: n, onBlur: r, size: o, onChange: i, value: a, currentCountry: s, disabled: l } = e, [u, c] = k(!1);
    h(() => {
      u ? i(s.mask) : c(!0);
    }, [s]);
    const p = `phoneInputMask ${o}`;
    function d(g) {
      let f = pG(g.target.value);
      const m = tPe(f);
      f.length > nPe || (f = ePe(f, dG[m]), g.target.value = f, i(f));
    }
    return s.code === "+55" ? /* @__PURE__ */ _o.jsx(
      "input",
      {
        value: a,
        onChange: d,
        className: p,
        onFocus: n,
        onBlur: r,
        disabled: l,
        ref: t
      }
    ) : /* @__PURE__ */ _o.jsx(
      cl,
      {
        value: a,
        onChange: (g) => i(g.target.value),
        className: p,
        component: rPe,
        onFocus: n,
        onBlur: r,
        disabled: l,
        mask: s.mask,
        showMask: !0,
        replacement: { _: /\d/ },
        ref: t
      }
    );
  }
);
Ke({});
var ya = {};
Object.defineProperty(ya, "__esModule", {
  value: !0
});
var oPe = typeof window < "u" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform), dx = {
  alt: "altKey",
  control: "ctrlKey",
  meta: "metaKey",
  shift: "shiftKey"
}, fG = {
  add: "+",
  break: "pause",
  cmd: "meta",
  command: "meta",
  ctl: "control",
  ctrl: "control",
  del: "delete",
  down: "arrowdown",
  esc: "escape",
  ins: "insert",
  left: "arrowleft",
  mod: oPe ? "meta" : "control",
  opt: "alt",
  option: "alt",
  return: "enter",
  right: "arrowright",
  space: " ",
  spacebar: " ",
  up: "arrowup",
  win: "meta",
  windows: "meta"
}, b_ = {
  backspace: 8,
  tab: 9,
  enter: 13,
  shift: 16,
  control: 17,
  alt: 18,
  pause: 19,
  capslock: 20,
  escape: 27,
  " ": 32,
  pageup: 33,
  pagedown: 34,
  end: 35,
  home: 36,
  arrowleft: 37,
  arrowup: 38,
  arrowright: 39,
  arrowdown: 40,
  insert: 45,
  delete: 46,
  meta: 91,
  numlock: 144,
  scrolllock: 145,
  ";": 186,
  "=": 187,
  ",": 188,
  "-": 189,
  ".": 190,
  "/": 191,
  "`": 192,
  "[": 219,
  "\\": 220,
  "]": 221,
  "'": 222
};
for (var Dg = 1; Dg < 20; Dg++)
  b_["f" + Dg] = 111 + Dg;
function Ww(e, t, n) {
  t && !("byKey" in t) && (n = t, t = null), Array.isArray(e) || (e = [e]);
  var r = e.map(function(a) {
    return hG(a, t);
  }), o = function(a) {
    return r.some(function(s) {
      return gG(s, a);
    });
  }, i = n == null ? o : o(n);
  return i;
}
function iPe(e, t) {
  return Ww(e, t);
}
function sPe(e, t) {
  return Ww(e, { byKey: !0 }, t);
}
function hG(e, t) {
  var n = t && t.byKey, r = {};
  e = e.replace("++", "+add");
  var o = e.split("+"), i = o.length;
  for (var a in dx)
    r[dx[a]] = !1;
  var s = !0, l = !1, u = void 0;
  try {
    for (var c = o[Symbol.iterator](), p; !(s = (p = c.next()).done); s = !0) {
      var d = p.value, g = d.endsWith("?") && d.length > 1;
      g && (d = d.slice(0, -1));
      var f = w_(d), m = dx[f];
      if (d.length > 1 && !m && !fG[d] && !b_[f])
        throw new TypeError('Unknown modifier: "' + d + '"');
      (i === 1 || !m) && (n ? r.key = f : r.which = mG(d)), m && (r[m] = g ? null : !0);
    }
  } catch (v) {
    l = !0, u = v;
  } finally {
    try {
      !s && c.return && c.return();
    } finally {
      if (l)
        throw u;
    }
  }
  return r;
}
function gG(e, t) {
  for (var n in e) {
    var r = e[n], o = void 0;
    if (r != null && (n === "key" && t.key != null ? o = t.key.toLowerCase() : n === "which" ? o = r === 91 && t.which === 93 ? 91 : t.which : o = t[n], !(o == null && r === !1) && o !== r))
      return !1;
  }
  return !0;
}
function mG(e) {
  e = w_(e);
  var t = b_[e] || e.toUpperCase().charCodeAt(0);
  return t;
}
function w_(e) {
  return e = e.toLowerCase(), e = fG[e] || e, e;
}
ya.default = Ww;
var fx = ya.isHotkey = Ww;
ya.isCodeHotkey = iPe;
ya.isKeyHotkey = sPe;
ya.parseHotkey = hG;
ya.compareHotkey = gG;
ya.toKeyCode = mG;
ya.toKeyName = w_;
var aPe = typeof er == "object" && er && er.Object === Object && er, lPe = aPe, uPe = lPe, cPe = typeof self == "object" && self && self.Object === Object && self, pPe = uPe || cPe || Function("return this")(), dPe = pPe, fPe = dPe, hPe = fPe.Symbol, vG = hPe, z2 = vG;
z2 && z2.toStringTag;
var U2 = vG;
U2 && U2.toStringTag;
var H2;
(function(e) {
  e.BORDER_BOX = "border-box", e.CONTENT_BOX = "content-box", e.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(H2 || (H2 = {}));
var C_ = function(e) {
  return Object.freeze(e);
}, gPe = /* @__PURE__ */ function() {
  function e(t, n) {
    this.inlineSize = t, this.blockSize = n, C_(this);
  }
  return e;
}(), mPe = function() {
  function e(t, n, r, o) {
    return this.x = t, this.y = n, this.width = r, this.height = o, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, C_(this);
  }
  return e.prototype.toJSON = function() {
    var t = this, n = t.x, r = t.y, o = t.top, i = t.right, a = t.bottom, s = t.left, l = t.width, u = t.height;
    return { x: n, y: r, top: o, right: i, bottom: a, left: s, width: l, height: u };
  }, e.fromRect = function(t) {
    return new e(t.x, t.y, t.width, t.height);
  }, e;
}(), $2 = typeof window < "u" ? window : {};
/msie|trident/i.test($2.navigator && $2.navigator.userAgent);
var hx = function(e, t, n) {
  return e === void 0 && (e = 0), t === void 0 && (t = 0), n === void 0 && (n = !1), new gPe((n ? t : e) || 0, (n ? e : t) || 0);
};
C_({
  devicePixelContentBoxSize: hx(),
  borderBoxSize: hx(),
  contentBoxSize: hx(),
  contentRect: new mPe(0, 0, 0, 0)
});
function of(e) {
  "@babel/helpers - typeof";
  return of = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, of(e);
}
function vPe(e, t) {
  if (of(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (of(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function yPe(e) {
  var t = vPe(e, "string");
  return of(t) === "symbol" ? t : String(t);
}
function sd(e, t, n) {
  return t = yPe(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
var bPe = /* @__PURE__ */ Ke(null), gx, mx;
parseInt(we.version.split(".")[0], 10);
var W2 = typeof navigator < "u" && /Mac OS X/.test(navigator.userAgent), vx = typeof navigator < "u" && /Android/.test(navigator.userAgent), Tg = typeof navigator < "u" && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent), wPe = typeof navigator < "u" && /Chrome/i.test(navigator.userAgent);
typeof navigator < "u" && /Safari/.test(navigator.userAgent) && /Version\/(\d+)/.test(navigator.userAgent) && (gx = navigator.userAgent.match(/Version\/(\d+)/)) !== null && gx !== void 0 && gx[1] && parseInt((mx = navigator.userAgent.match(/Version\/(\d+)/)) === null || mx === void 0 ? void 0 : mx[1], 10) < 17;
var CPe = /* @__PURE__ */ new WeakMap(), xPe = /* @__PURE__ */ new WeakMap(), OPe = /* @__PURE__ */ new WeakMap(), EPe = /* @__PURE__ */ new WeakMap(), kPe = /* @__PURE__ */ new WeakMap(), V2 = /* @__PURE__ */ new WeakMap(), LPe = /* @__PURE__ */ new WeakMap(), Z2 = /* @__PURE__ */ new WeakMap(), jg = /* @__PURE__ */ new WeakMap(), PPe = /* @__PURE__ */ new WeakMap(), _Pe = /* @__PURE__ */ new WeakMap(), SPe = /* @__PURE__ */ new WeakMap(), yG = globalThis.Node, MPe = globalThis.Text, bG = (e) => e && e.ownerDocument && e.ownerDocument.defaultView || null, DPe = (e) => ty(e) && e.nodeType === 8, Ss = (e) => ty(e) && e.nodeType === 1, ty = (e) => {
  var t = bG(e);
  return !!t && e instanceof t.Node;
}, q2 = (e) => {
  var t = e && e.anchorNode && bG(e.anchorNode);
  return !!t && e instanceof t.Selection;
}, TPe = (e) => {
  var [t, n] = e;
  if (Ss(t) && t.childNodes.length) {
    var r = n === t.childNodes.length, o = r ? n - 1 : n;
    for ([t, o] = wG(t, o, r ? "backward" : "forward"), r = o < n; Ss(t) && t.childNodes.length; ) {
      var i = r ? t.childNodes.length - 1 : 0;
      t = APe(t, i, r ? "backward" : "forward");
    }
    n = r && t.textContent != null ? t.textContent.length : 0;
  }
  return [t, n];
}, jPe = (e) => {
  for (var t = e && e.parentNode; t; ) {
    if (t.toString() === "[object ShadowRoot]")
      return !0;
    t = t.parentNode;
  }
  return !1;
}, wG = (e, t, n) => {
  for (var {
    childNodes: r
  } = e, o = r[t], i = t, a = !1, s = !1; (DPe(o) || Ss(o) && o.childNodes.length === 0 || Ss(o) && o.getAttribute("contenteditable") === "false") && !(a && s); ) {
    if (i >= r.length) {
      a = !0, i = t - 1, n = "backward";
      continue;
    }
    if (i < 0) {
      s = !0, i = t + 1, n = "forward";
      continue;
    }
    o = r[i], t = i, i += n === "forward" ? 1 : -1;
  }
  return [o, t];
}, APe = (e, t, n) => {
  var [r] = wG(e, t, n);
  return r;
}, G2 = (e) => e.getSelection != null ? e.getSelection() : document.getSelection(), CG = (e, t, n) => {
  var {
    target: r
  } = t;
  if (Ss(r) && r.matches('[contentEditable="false"]'))
    return !1;
  var {
    document: o
  } = rn.getWindow(e);
  if (o.contains(r))
    return rn.hasDOMNode(e, r, {
      editable: !0
    });
  var i = n.find((a) => {
    var {
      addedNodes: s,
      removedNodes: l
    } = a;
    for (var u of s)
      if (u === r || u.contains(r))
        return !0;
    for (var c of l)
      if (c === r || c.contains(r))
        return !0;
  });
  return !i || i === t ? !1 : CG(e, i, n);
}, K2 = (e, t) => !!(e.compareDocumentPosition(t) & yG.DOCUMENT_POSITION_PRECEDING), IPe = (e, t) => !!(e.compareDocumentPosition(t) & yG.DOCUMENT_POSITION_FOLLOWING), RPe = 0;
class BPe {
  constructor() {
    sd(this, "id", void 0), this.id = "".concat(RPe++);
  }
}
var rn = {
  androidPendingDiffs: (e) => SPe.get(e),
  androidScheduleFlush: (e) => {
    var t;
    (t = _Pe.get(e)) === null || t === void 0 || t();
  },
  blur: (e) => {
    var t = rn.toDOMNode(e, e), n = rn.findDocumentOrShadowRoot(e);
    jg.set(e, !1), n.activeElement === t && t.blur();
  },
  deselect: (e) => {
    var {
      selection: t
    } = e, n = rn.findDocumentOrShadowRoot(e), r = G2(n);
    r && r.rangeCount > 0 && r.removeAllRanges(), t && iv.deselect(e);
  },
  findDocumentOrShadowRoot: (e) => {
    var t = rn.toDOMNode(e, e), n = t.getRootNode();
    return n instanceof Document || n instanceof ShadowRoot ? n : t.ownerDocument;
  },
  findEventRange: (e, t) => {
    "nativeEvent" in t && (t = t.nativeEvent);
    var {
      clientX: n,
      clientY: r,
      target: o
    } = t;
    if (n == null || r == null)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var i = rn.toSlateNode(e, t.target), a = rn.findPath(e, i);
    if (na.isElement(i) && qn.isVoid(e, i)) {
      var s = o.getBoundingClientRect(), l = e.isInline(i) ? n - s.left < s.left + s.width - n : r - s.top < s.top + s.height - r, u = qn.point(e, a, {
        edge: l ? "start" : "end"
      }), c = l ? qn.before(e, u) : qn.after(e, u);
      if (c) {
        var p = qn.range(e, c);
        return p;
      }
    }
    var d, {
      document: g
    } = rn.getWindow(e);
    if (g.caretRangeFromPoint)
      d = g.caretRangeFromPoint(n, r);
    else {
      var f = g.caretPositionFromPoint(n, r);
      f && (d = g.createRange(), d.setStart(f.offsetNode, f.offset), d.setEnd(f.offsetNode, f.offset));
    }
    if (!d)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var m = rn.toSlateRange(e, d, {
      exactMatch: !1,
      suppressThrow: !1
    });
    return m;
  },
  findKey: (e, t) => {
    var n = V2.get(t);
    return n || (n = new BPe(), V2.set(t, n)), n;
  },
  findPath: (e, t) => {
    for (var n = [], r = t; ; ) {
      var o = xPe.get(r);
      if (o == null) {
        if (qn.isEditor(r))
          return n;
        break;
      }
      var i = CPe.get(r);
      if (i == null)
        break;
      n.unshift(i), r = o;
    }
    throw new Error("Unable to find the path for Slate node: ".concat(Si.stringify(t)));
  },
  focus: function(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      retries: 5
    };
    if (!jg.get(e)) {
      if (t.retries <= 0)
        throw new Error("Could not set focus, editor seems stuck with pending operations");
      if (e.operations.length > 0) {
        setTimeout(() => {
          rn.focus(e, {
            retries: t.retries - 1
          });
        }, 10);
        return;
      }
      var n = rn.toDOMNode(e, e), r = rn.findDocumentOrShadowRoot(e);
      if (r.activeElement !== n) {
        if (e.selection && r instanceof Document) {
          var o = G2(r), i = rn.toDOMRange(e, e.selection);
          o == null || o.removeAllRanges(), o == null || o.addRange(i);
        }
        e.selection || iv.select(e, qn.start(e, [])), jg.set(e, !0), n.focus({
          preventScroll: !0
        });
      }
    }
  },
  getWindow: (e) => {
    var t = OPe.get(e);
    if (!t)
      throw new Error("Unable to find a host window element for this editor");
    return t;
  },
  hasDOMNode: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      editable: r = !1
    } = n, o = rn.toDOMNode(e, e), i;
    try {
      i = Ss(t) ? t : t.parentElement;
    } catch (a) {
      if (a instanceof Error && !a.message.includes('Permission denied to access property "nodeType"'))
        throw a;
    }
    return i ? i.closest("[data-slate-editor]") === o && (!r || i.isContentEditable ? !0 : typeof i.isContentEditable == "boolean" && // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined
    // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable="false"(readOnly)
    i.closest('[contenteditable="false"]') === o || !!i.getAttribute("data-slate-zero-width")) : !1;
  },
  hasEditableTarget: (e, t) => ty(t) && rn.hasDOMNode(e, t, {
    editable: !0
  }),
  hasRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t;
    return qn.hasPath(e, n.path) && qn.hasPath(e, r.path);
  },
  hasSelectableTarget: (e, t) => rn.hasEditableTarget(e, t) || rn.isTargetInsideNonReadonlyVoid(e, t),
  hasTarget: (e, t) => ty(t) && rn.hasDOMNode(e, t),
  insertData: (e, t) => {
    e.insertData(t);
  },
  insertFragmentData: (e, t) => e.insertFragmentData(t),
  insertTextData: (e, t) => e.insertTextData(t),
  isComposing: (e) => !!PPe.get(e),
  isFocused: (e) => !!jg.get(e),
  isReadOnly: (e) => !!Z2.get(e),
  isTargetInsideNonReadonlyVoid: (e, t) => {
    if (Z2.get(e)) return !1;
    var n = rn.hasTarget(e, t) && rn.toSlateNode(e, t);
    return na.isElement(n) && qn.isVoid(e, n);
  },
  setFragmentData: (e, t, n) => e.setFragmentData(t, n),
  toDOMNode: (e, t) => {
    var n = LPe.get(e), r = qn.isEditor(t) ? EPe.get(e) : n == null ? void 0 : n.get(rn.findKey(e, t));
    if (!r)
      throw new Error("Cannot resolve a DOM node from Slate node: ".concat(Si.stringify(t)));
    return r;
  },
  toDOMPoint: (e, t) => {
    var [n] = qn.node(e, t.path), r = rn.toDOMNode(e, n), o;
    qn.void(e, {
      at: t
    }) && (t = {
      path: t.path,
      offset: 0
    });
    for (var i = "[data-slate-string], [data-slate-zero-width]", a = Array.from(r.querySelectorAll(i)), s = 0, l = 0; l < a.length; l++) {
      var u = a[l], c = u.childNodes[0];
      if (!(c == null || c.textContent == null)) {
        var {
          length: p
        } = c.textContent, d = u.getAttribute("data-slate-length"), g = d == null ? p : parseInt(d, 10), f = s + g, m = a[l + 1];
        if (t.offset === f && m !== null && m !== void 0 && m.hasAttribute("data-slate-mark-placeholder")) {
          var v, E = m.childNodes[0];
          o = [
            // COMPAT: If we don't explicity set the dom point to be on the actual
            // dom text element, chrome will put the selection behind the actual dom
            // text element, causing domRange.getBoundingClientRect() calls on a collapsed
            // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)
            // which will cause issues when scrolling to it.
            E instanceof MPe ? E : m,
            (v = m.textContent) !== null && v !== void 0 && v.startsWith("\uFEFF") ? 1 : 0
          ];
          break;
        }
        if (t.offset <= f) {
          var w = Math.min(p, Math.max(0, t.offset - s));
          o = [c, w];
          break;
        }
        s = f;
      }
    }
    if (!o)
      throw new Error("Cannot resolve a DOM point from Slate point: ".concat(Si.stringify(t)));
    return o;
  },
  toDOMRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t, o = Ut.isBackward(t), i = rn.toDOMPoint(e, n), a = Ut.isCollapsed(t) ? i : rn.toDOMPoint(e, r), s = rn.getWindow(e), l = s.document.createRange(), [u, c] = o ? a : i, [p, d] = o ? i : a, g = Ss(u) ? u : u.parentElement, f = !!g.getAttribute("data-slate-zero-width"), m = Ss(p) ? p : p.parentElement, v = !!m.getAttribute("data-slate-zero-width");
    return l.setStart(u, f ? 1 : c), l.setEnd(p, v ? 1 : d), l;
  },
  toSlateNode: (e, t) => {
    var n = Ss(t) ? t : t.parentElement;
    n && !n.hasAttribute("data-slate-node") && (n = n.closest("[data-slate-node]"));
    var r = n ? kPe.get(n) : null;
    if (!r)
      throw new Error("Cannot resolve a Slate node from DOM node: ".concat(n));
    return r;
  },
  toSlatePoint: (e, t, n) => {
    var {
      exactMatch: r,
      suppressThrow: o,
      searchDirection: i = "backward"
    } = n, [a, s] = r ? t : TPe(t), l = a.parentNode, u = null, c = 0;
    if (l) {
      var p, d, g = rn.toDOMNode(e, e), f = l.closest('[data-slate-void="true"]'), m = f && g.contains(f) ? f : null, v = l.closest('[contenteditable="false"]'), E = v && g.contains(v) ? v : null, w = l.closest("[data-slate-leaf]"), M = null;
      if (w) {
        if (u = w.closest('[data-slate-node="text"]'), u) {
          var O = rn.getWindow(e), y = O.document.createRange();
          y.setStart(u, 0), y.setEnd(a, s);
          var C = y.cloneContents(), _ = [...Array.prototype.slice.call(C.querySelectorAll("[data-slate-zero-width]")), ...Array.prototype.slice.call(C.querySelectorAll("[contenteditable=false]"))];
          _.forEach((S) => {
            if (vx && !r && S.hasAttribute("data-slate-zero-width") && S.textContent.length > 0 && S.textContext !== "\uFEFF") {
              S.textContent.startsWith("\uFEFF") && (S.textContent = S.textContent.slice(1));
              return;
            }
            S.parentNode.removeChild(S);
          }), c = C.textContent.length, M = u;
        }
      } else if (m) {
        for (var F = m.querySelectorAll("[data-slate-leaf]"), L = 0; L < F.length; L++) {
          var N = F[L];
          if (rn.hasDOMNode(e, N)) {
            w = N;
            break;
          }
        }
        w ? (u = w.closest('[data-slate-node="text"]'), M = w, c = M.textContent.length, M.querySelectorAll("[data-slate-zero-width]").forEach((S) => {
          c -= S.textContent.length;
        })) : c = 1;
      } else if (E) {
        var R = (S) => S ? S.querySelectorAll(
          // Exclude leaf nodes in nested editors
          "[data-slate-leaf]:not(:scope [data-slate-editor] [data-slate-leaf])"
        ) : [], W = E.closest('[data-slate-node="element"]');
        if (i === "forward") {
          var V, z = [...R(W), ...R(W == null ? void 0 : W.nextElementSibling)];
          w = (V = z.find((S) => IPe(E, S))) !== null && V !== void 0 ? V : null;
        } else {
          var Z, K = [...R(W == null ? void 0 : W.previousElementSibling), ...R(W)];
          w = (Z = K.findLast((S) => K2(E, S))) !== null && Z !== void 0 ? Z : null;
        }
        w && (u = w.closest('[data-slate-node="text"]'), M = w, i === "forward" ? c = 0 : (c = M.textContent.length, M.querySelectorAll("[data-slate-zero-width]").forEach((S) => {
          c -= S.textContent.length;
        })));
      }
      M && c === M.textContent.length && // COMPAT: Android IMEs might remove the zero width space while composing,
      // and we don't add it for line-breaks.
      vx && M.getAttribute("data-slate-zero-width") === "z" && (p = M.textContent) !== null && p !== void 0 && p.startsWith("\uFEFF") && // COMPAT: If the parent node is a Slate zero-width space, editor is
      // because the text node should have no characters. However, during IME
      // composition the ASCII characters will be prepended to the zero-width
      // space, so subtract 1 from the offset to account for the zero-width
      // space character.
      (l.hasAttribute("data-slate-zero-width") || // COMPAT: In Firefox, `range.cloneContents()` returns an extra trailing '\n'
      // when the document ends with a new-line character. This results in the offset
      // length being off by one, so we need to subtract one to account for this.
      Tg && (d = M.textContent) !== null && d !== void 0 && d.endsWith(`

`)) && c--;
    }
    if (vx && !u && !r) {
      var X = l.hasAttribute("data-slate-node") ? l : l.closest("[data-slate-node]");
      if (X && rn.hasDOMNode(e, X, {
        editable: !0
      })) {
        var te = rn.toSlateNode(e, X), {
          path: J,
          offset: P
        } = qn.start(e, rn.findPath(e, te));
        return X.querySelector("[data-slate-leaf]") || (P = s), {
          path: J,
          offset: P
        };
      }
    }
    if (!u) {
      if (o)
        return null;
      throw new Error("Cannot resolve a Slate point from DOM point: ".concat(t));
    }
    var D = rn.toSlateNode(e, u), H = rn.findPath(e, D);
    return {
      path: H,
      offset: c
    };
  },
  toSlateRange: (e, t, n) => {
    var r, {
      exactMatch: o,
      suppressThrow: i
    } = n, a = q2(t) ? t.anchorNode : t.startContainer, s, l, u, c, p;
    if (a)
      if (q2(t)) {
        if (Tg && t.rangeCount > 1) {
          u = t.focusNode;
          var d = t.getRangeAt(0), g = t.getRangeAt(t.rangeCount - 1);
          if (u instanceof HTMLTableRowElement && d.startContainer instanceof HTMLTableRowElement && g.startContainer instanceof HTMLTableRowElement) {
            let C = function(_) {
              return _.childElementCount > 0 ? C(_.children[0]) : _;
            };
            var f = d.startContainer, m = g.startContainer, v = C(f.children[d.startOffset]), E = C(m.children[g.startOffset]);
            c = 0, E.childNodes.length > 0 ? s = E.childNodes[0] : s = E, v.childNodes.length > 0 ? u = v.childNodes[0] : u = v, E instanceof HTMLElement ? l = E.innerHTML.length : l = 0;
          } else
            d.startContainer === u ? (s = g.endContainer, l = g.endOffset, c = d.startOffset) : (s = d.startContainer, l = d.endOffset, c = g.startOffset);
        } else
          s = t.anchorNode, l = t.anchorOffset, u = t.focusNode, c = t.focusOffset;
        wPe && jPe(s) || Tg ? p = t.anchorNode === t.focusNode && t.anchorOffset === t.focusOffset : p = t.isCollapsed;
      } else
        s = t.startContainer, l = t.startOffset, u = t.endContainer, c = t.endOffset, p = t.collapsed;
    if (s == null || u == null || l == null || c == null)
      throw new Error("Cannot resolve a Slate range from DOM range: ".concat(t));
    Tg && (r = u.textContent) !== null && r !== void 0 && r.endsWith(`

`) && c === u.textContent.length && c--;
    var w = rn.toSlatePoint(e, [s, l], {
      exactMatch: o,
      suppressThrow: i
    });
    if (!w)
      return null;
    var M = K2(s, u) || s === u && c < l, O = p ? w : rn.toSlatePoint(e, [u, c], {
      exactMatch: o,
      suppressThrow: i,
      searchDirection: M ? "forward" : "backward"
    });
    if (!O)
      return null;
    var y = {
      anchor: w,
      focus: O
    };
    return Ut.isExpanded(y) && Ut.isForward(y) && Ss(u) && qn.void(e, {
      at: y.focus,
      mode: "highest"
    }) && (y = qn.unhangRange(e, y, {
      voids: !0
    })), y;
  }
}, NPe = {
  bold: "mod+b",
  compose: ["down", "left", "right", "up", "backspace", "enter"],
  moveBackward: "left",
  moveForward: "right",
  moveWordBackward: "ctrl+left",
  moveWordForward: "ctrl+right",
  deleteBackward: "shift?+backspace",
  deleteForward: "shift?+delete",
  extendBackward: "shift+left",
  extendForward: "shift+right",
  italic: "mod+i",
  insertSoftBreak: "shift+enter",
  splitBlock: "enter",
  undo: "mod+z"
}, FPe = {
  moveLineBackward: "opt+up",
  moveLineForward: "opt+down",
  moveWordBackward: "opt+left",
  moveWordForward: "opt+right",
  deleteBackward: ["ctrl+backspace", "ctrl+h"],
  deleteForward: ["ctrl+delete", "ctrl+d"],
  deleteLineBackward: "cmd+shift?+backspace",
  deleteLineForward: ["cmd+shift?+delete", "ctrl+k"],
  deleteWordBackward: "opt+shift?+backspace",
  deleteWordForward: "opt+shift?+delete",
  extendLineBackward: "opt+shift+up",
  extendLineForward: "opt+shift+down",
  redo: "cmd+shift+z",
  transposeCharacter: "ctrl+t"
}, zPe = {
  deleteWordBackward: "ctrl+shift?+backspace",
  deleteWordForward: "ctrl+shift?+delete",
  redo: ["ctrl+y", "ctrl+shift+z"]
}, Tr = (e) => {
  var t = NPe[e], n = FPe[e], r = zPe[e], o = t && fx(t), i = n && fx(n), a = r && fx(r);
  return (s) => !!(o && o(s) || W2 && i && i(s) || !W2 && a && a(s));
};
Tr("bold"), Tr("compose"), Tr("moveBackward"), Tr("moveForward"), Tr("deleteBackward"), Tr("deleteForward"), Tr("deleteLineBackward"), Tr("deleteLineForward"), Tr("deleteWordBackward"), Tr("deleteWordForward"), Tr("extendBackward"), Tr("extendForward"), Tr("extendLineBackward"), Tr("extendLineForward"), Tr("italic"), Tr("moveLineBackward"), Tr("moveLineForward"), Tr("moveWordBackward"), Tr("moveWordForward"), Tr("redo"), Tr("insertSoftBreak"), Tr("splitBlock"), Tr("transposeCharacter"), Tr("undo");
var UPe = (e, t) => {
  var n = [], r = () => {
    n = [];
  }, o = (a) => {
    if (t.current) {
      var s = a.filter((l) => CG(e, l, a));
      n.push(...s);
    }
  };
  function i() {
    n.length > 0 && (n.reverse().forEach((a) => {
      a.type !== "characterData" && (a.removedNodes.forEach((s) => {
        a.target.insertBefore(s, a.nextSibling);
      }), a.addedNodes.forEach((s) => {
        a.target.removeChild(s);
      }));
    }), r());
  }
  return {
    registerMutations: o,
    restoreDOM: i,
    clear: r
  };
}, HPe = {
  subtree: !0,
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0
};
class $Pe extends Wu {
  constructor() {
    super(...arguments), sd(this, "context", null), sd(this, "manager", null), sd(this, "mutationObserver", null);
  }
  observe() {
    var t, {
      node: n
    } = this.props;
    if (!n.current)
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    (t = this.mutationObserver) === null || t === void 0 || t.observe(n.current, HPe);
  }
  componentDidMount() {
    var {
      receivedUserInput: t
    } = this.props, n = this.context;
    this.manager = UPe(n, t), this.mutationObserver = new MutationObserver(this.manager.registerMutations), this.observe();
  }
  getSnapshotBeforeUpdate() {
    var t, n, r, o = (t = this.mutationObserver) === null || t === void 0 ? void 0 : t.takeRecords();
    if (o != null && o.length) {
      var i;
      (i = this.manager) === null || i === void 0 || i.registerMutations(o);
    }
    return (n = this.mutationObserver) === null || n === void 0 || n.disconnect(), (r = this.manager) === null || r === void 0 || r.restoreDOM(), null;
  }
  componentDidUpdate() {
    var t;
    (t = this.manager) === null || t === void 0 || t.clear(), this.observe();
  }
  componentWillUnmount() {
    var t;
    (t = this.mutationObserver) === null || t === void 0 || t.disconnect();
  }
  render() {
    return this.props.children;
  }
}
sd($Pe, "contextType", bPe);
Ke({});
Ke({});
Ke({});
var po = {}, x_ = {}, Nf = {}, Ff = {}, xG = "Expected a function", Y2 = NaN, WPe = "[object Symbol]", VPe = /^\s+|\s+$/g, ZPe = /^[-+]0x[0-9a-f]+$/i, qPe = /^0b[01]+$/i, GPe = /^0o[0-7]+$/i, KPe = parseInt, YPe = typeof er == "object" && er && er.Object === Object && er, XPe = typeof self == "object" && self && self.Object === Object && self, JPe = YPe || XPe || Function("return this")(), QPe = Object.prototype, e_e = QPe.toString, t_e = Math.max, n_e = Math.min, yx = function() {
  return JPe.Date.now();
};
function r_e(e, t, n) {
  var r, o, i, a, s, l, u = 0, c = !1, p = !1, d = !0;
  if (typeof e != "function")
    throw new TypeError(xG);
  t = X2(t) || 0, ny(n) && (c = !!n.leading, p = "maxWait" in n, i = p ? t_e(X2(n.maxWait) || 0, t) : i, d = "trailing" in n ? !!n.trailing : d);
  function g(C) {
    var _ = r, F = o;
    return r = o = void 0, u = C, a = e.apply(F, _), a;
  }
  function f(C) {
    return u = C, s = setTimeout(E, t), c ? g(C) : a;
  }
  function m(C) {
    var _ = C - l, F = C - u, L = t - _;
    return p ? n_e(L, i - F) : L;
  }
  function v(C) {
    var _ = C - l, F = C - u;
    return l === void 0 || _ >= t || _ < 0 || p && F >= i;
  }
  function E() {
    var C = yx();
    if (v(C))
      return w(C);
    s = setTimeout(E, m(C));
  }
  function w(C) {
    return s = void 0, d && r ? g(C) : (r = o = void 0, a);
  }
  function M() {
    s !== void 0 && clearTimeout(s), u = 0, r = l = o = s = void 0;
  }
  function O() {
    return s === void 0 ? a : w(yx());
  }
  function y() {
    var C = yx(), _ = v(C);
    if (r = arguments, o = this, l = C, _) {
      if (s === void 0)
        return f(l);
      if (p)
        return s = setTimeout(E, t), g(l);
    }
    return s === void 0 && (s = setTimeout(E, t)), a;
  }
  return y.cancel = M, y.flush = O, y;
}
function o_e(e, t, n) {
  var r = !0, o = !0;
  if (typeof e != "function")
    throw new TypeError(xG);
  return ny(n) && (r = "leading" in n ? !!n.leading : r, o = "trailing" in n ? !!n.trailing : o), r_e(e, t, {
    leading: r,
    maxWait: t,
    trailing: o
  });
}
function ny(e) {
  var t = typeof e;
  return !!e && (t == "object" || t == "function");
}
function i_e(e) {
  return !!e && typeof e == "object";
}
function s_e(e) {
  return typeof e == "symbol" || i_e(e) && e_e.call(e) == WPe;
}
function X2(e) {
  if (typeof e == "number")
    return e;
  if (s_e(e))
    return Y2;
  if (ny(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = ny(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = e.replace(VPe, "");
  var n = qPe.test(e);
  return n || GPe.test(e) ? KPe(e.slice(2), n ? 2 : 8) : ZPe.test(e) ? Y2 : +e;
}
var a_e = o_e, zf = {};
Object.defineProperty(zf, "__esModule", {
  value: !0
});
zf.addPassiveEventListener = function(e, t, n) {
  var r = n.name;
  r || (r = t, console.warn("Listener must be a named function.")), Mm.has(t) || Mm.set(t, /* @__PURE__ */ new Set());
  var o = Mm.get(t);
  if (!o.has(r)) {
    var i = function() {
      var a = !1;
      try {
        var s = Object.defineProperty({}, "passive", {
          get: function() {
            a = !0;
          }
        });
        window.addEventListener("test", null, s);
      } catch {
      }
      return a;
    }();
    e.addEventListener(t, n, i ? { passive: !0 } : !1), o.add(r);
  }
};
zf.removePassiveEventListener = function(e, t, n) {
  e.removeEventListener(t, n), Mm.get(t).delete(n.name || t);
};
var Mm = /* @__PURE__ */ new Map();
Object.defineProperty(Ff, "__esModule", {
  value: !0
});
var l_e = a_e, u_e = c_e(l_e), J2 = zf;
function c_e(e) {
  return e && e.__esModule ? e : { default: e };
}
var p_e = function(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 66;
  return (0, u_e.default)(e, t);
}, Wr = {
  spyCallbacks: [],
  spySetState: [],
  scrollSpyContainers: [],
  mount: function(e, t) {
    if (e) {
      var n = p_e(function(r) {
        Wr.scrollHandler(e);
      }, t);
      return Wr.scrollSpyContainers.push(e), (0, J2.addPassiveEventListener)(e, "scroll", n), function() {
        (0, J2.removePassiveEventListener)(e, "scroll", n), Wr.scrollSpyContainers.splice(Wr.scrollSpyContainers.indexOf(e), 1);
      };
    }
    return function() {
    };
  },
  isMounted: function(e) {
    return Wr.scrollSpyContainers.indexOf(e) !== -1;
  },
  currentPositionX: function(e) {
    if (e === document) {
      var t = window.scrollY !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.scrollX : n ? document.documentElement.scrollLeft : document.body.scrollLeft;
    } else
      return e.scrollLeft;
  },
  currentPositionY: function(e) {
    if (e === document) {
      var t = window.scrollX !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.scrollY : n ? document.documentElement.scrollTop : document.body.scrollTop;
    } else
      return e.scrollTop;
  },
  scrollHandler: function(e) {
    var t = Wr.scrollSpyContainers[Wr.scrollSpyContainers.indexOf(e)].spyCallbacks || [];
    t.forEach(function(n) {
      return n(Wr.currentPositionX(e), Wr.currentPositionY(e));
    });
  },
  addStateHandler: function(e) {
    Wr.spySetState.push(e);
  },
  addSpyHandler: function(e, t) {
    var n = Wr.scrollSpyContainers[Wr.scrollSpyContainers.indexOf(t)];
    n.spyCallbacks || (n.spyCallbacks = []), n.spyCallbacks.push(e);
  },
  updateStates: function() {
    Wr.spySetState.forEach(function(e) {
      return e();
    });
  },
  unmount: function(e, t) {
    Wr.scrollSpyContainers.forEach(function(n) {
      return n.spyCallbacks && n.spyCallbacks.length && n.spyCallbacks.indexOf(t) > -1 && n.spyCallbacks.splice(n.spyCallbacks.indexOf(t), 1);
    }), Wr.spySetState && Wr.spySetState.length && Wr.spySetState.indexOf(e) > -1 && Wr.spySetState.splice(Wr.spySetState.indexOf(e), 1), document.removeEventListener("scroll", Wr.scrollHandler);
  },
  update: function() {
    return Wr.scrollSpyContainers.forEach(function(e) {
      return Wr.scrollHandler(e);
    });
  }
};
Ff.default = Wr;
var Ac = {}, Uf = {};
Object.defineProperty(Uf, "__esModule", {
  value: !0
});
var d_e = function(e, t) {
  var n = e.indexOf("#") === 0 ? e.substring(1) : e, r = n ? "#" + n : "", o = window && window.location, i = r ? o.pathname + o.search + r : o.pathname + o.search;
  t ? history.pushState(history.state, "", i) : history.replaceState(history.state, "", i);
}, f_e = function() {
  return window.location.hash.replace(/^#/, "");
}, h_e = function(e) {
  return function(t) {
    return e.contains ? e != t && e.contains(t) : !!(e.compareDocumentPosition(t) & 16);
  };
}, g_e = function(e) {
  return getComputedStyle(e).position !== "static";
}, bx = function(e, t) {
  for (var n = e.offsetTop, r = e.offsetParent; r && !t(r); )
    n += r.offsetTop, r = r.offsetParent;
  return { offsetTop: n, offsetParent: r };
}, m_e = function(e, t, n) {
  if (n)
    return e === document ? t.getBoundingClientRect().left + (window.scrollX || window.pageXOffset) : getComputedStyle(e).position !== "static" ? t.offsetLeft : t.offsetLeft - e.offsetLeft;
  if (e === document)
    return t.getBoundingClientRect().top + (window.scrollY || window.pageYOffset);
  if (g_e(e)) {
    if (t.offsetParent !== e) {
      var r = function(l) {
        return l === e || l === document;
      }, o = bx(t, r), i = o.offsetTop, a = o.offsetParent;
      if (a !== e)
        throw new Error("Seems containerElement is not an ancestor of the Element");
      return i;
    }
    return t.offsetTop;
  }
  if (t.offsetParent === e.offsetParent)
    return t.offsetTop - e.offsetTop;
  var s = function(l) {
    return l === document;
  };
  return bx(t, s).offsetTop - bx(e, s).offsetTop;
};
Uf.default = {
  updateHash: d_e,
  getHash: f_e,
  filterElementInContainer: h_e,
  scrollOffset: m_e
};
var Vw = {}, O_ = {};
Object.defineProperty(O_, "__esModule", {
  value: !0
});
O_.default = {
  /*
   * https://github.com/oblador/angular-scroll (duScrollDefaultEasing)
   */
  defaultEasing: function(e) {
    return e < 0.5 ? Math.pow(e * 2, 2) / 2 : 1 - Math.pow((1 - e) * 2, 2) / 2;
  },
  /*
   * https://gist.github.com/gre/1650294
   */
  // no easing, no acceleration
  linear: function(e) {
    return e;
  },
  // accelerating from zero velocity
  easeInQuad: function(e) {
    return e * e;
  },
  // decelerating to zero velocity
  easeOutQuad: function(e) {
    return e * (2 - e);
  },
  // acceleration until halfway, then deceleration
  easeInOutQuad: function(e) {
    return e < 0.5 ? 2 * e * e : -1 + (4 - 2 * e) * e;
  },
  // accelerating from zero velocity 
  easeInCubic: function(e) {
    return e * e * e;
  },
  // decelerating to zero velocity 
  easeOutCubic: function(e) {
    return --e * e * e + 1;
  },
  // acceleration until halfway, then deceleration 
  easeInOutCubic: function(e) {
    return e < 0.5 ? 4 * e * e * e : (e - 1) * (2 * e - 2) * (2 * e - 2) + 1;
  },
  // accelerating from zero velocity 
  easeInQuart: function(e) {
    return e * e * e * e;
  },
  // decelerating to zero velocity 
  easeOutQuart: function(e) {
    return 1 - --e * e * e * e;
  },
  // acceleration until halfway, then deceleration
  easeInOutQuart: function(e) {
    return e < 0.5 ? 8 * e * e * e * e : 1 - 8 * --e * e * e * e;
  },
  // accelerating from zero velocity
  easeInQuint: function(e) {
    return e * e * e * e * e;
  },
  // decelerating to zero velocity
  easeOutQuint: function(e) {
    return 1 + --e * e * e * e * e;
  },
  // acceleration until halfway, then deceleration 
  easeInOutQuint: function(e) {
    return e < 0.5 ? 16 * e * e * e * e * e : 1 + 16 * --e * e * e * e * e;
  }
};
var E_ = {};
Object.defineProperty(E_, "__esModule", {
  value: !0
});
var v_e = zf, y_e = ["mousedown", "wheel", "touchmove", "keydown"];
E_.default = {
  subscribe: function(e) {
    return typeof document < "u" && y_e.forEach(function(t) {
      return (0, v_e.addPassiveEventListener)(document, t, e);
    });
  }
};
var Hf = {};
Object.defineProperty(Hf, "__esModule", {
  value: !0
});
var Ak = {
  registered: {},
  scrollEvent: {
    register: function(e, t) {
      Ak.registered[e] = t;
    },
    remove: function(e) {
      Ak.registered[e] = null;
    }
  }
};
Hf.default = Ak;
Object.defineProperty(Vw, "__esModule", {
  value: !0
});
var b_e = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, w_e = Uf;
Zw(w_e);
var C_e = O_, Q2 = Zw(C_e), x_e = E_, O_e = Zw(x_e), E_e = Hf, xs = Zw(E_e);
function Zw(e) {
  return e && e.__esModule ? e : { default: e };
}
var OG = function(e) {
  return Q2.default[e.smooth] || Q2.default.defaultEasing;
}, k_e = function(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}, L_e = function() {
  if (typeof window < "u")
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame;
}, Ik = function() {
  return L_e() || function(e, t, n) {
    window.setTimeout(e, n || 1e3 / 60, (/* @__PURE__ */ new Date()).getTime());
  };
}(), EG = function() {
  return {
    currentPosition: 0,
    startPosition: 0,
    targetPosition: 0,
    progress: 0,
    duration: 0,
    cancel: !1,
    target: null,
    containerElement: null,
    to: null,
    start: null,
    delta: null,
    percent: null,
    delayTimeout: null
  };
}, kG = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollLeft;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageXOffset : r ? document.documentElement.scrollLeft : document.body.scrollLeft;
}, LG = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollTop;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageYOffset : r ? document.documentElement.scrollTop : document.body.scrollTop;
}, P_e = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollWidth - t.offsetWidth;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollWidth, n.offsetWidth, r.clientWidth, r.scrollWidth, r.offsetWidth);
}, __e = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollHeight - t.offsetHeight;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollHeight, n.offsetHeight, r.clientHeight, r.scrollHeight, r.offsetHeight);
}, S_e = function e(t, n, r) {
  var o = n.data;
  if (!n.ignoreCancelEvents && o.cancel) {
    xs.default.registered.end && xs.default.registered.end(o.to, o.target, o.currentPositionY);
    return;
  }
  if (o.delta = Math.round(o.targetPosition - o.startPosition), o.start === null && (o.start = r), o.progress = r - o.start, o.percent = o.progress >= o.duration ? 1 : t(o.progress / o.duration), o.currentPosition = o.startPosition + Math.ceil(o.delta * o.percent), o.containerElement && o.containerElement !== document && o.containerElement !== document.body ? n.horizontal ? o.containerElement.scrollLeft = o.currentPosition : o.containerElement.scrollTop = o.currentPosition : n.horizontal ? window.scrollTo(o.currentPosition, 0) : window.scrollTo(0, o.currentPosition), o.percent < 1) {
    var i = e.bind(null, t, n);
    Ik.call(window, i);
    return;
  }
  xs.default.registered.end && xs.default.registered.end(o.to, o.target, o.currentPosition);
}, k_ = function(e) {
  e.data.containerElement = e ? e.containerId ? document.getElementById(e.containerId) : e.container && e.container.nodeType ? e.container : document : null;
}, $f = function(e, t, n, r) {
  t.data = t.data || EG(), window.clearTimeout(t.data.delayTimeout);
  var o = function() {
    t.data.cancel = !0;
  };
  if (O_e.default.subscribe(o), k_(t), t.data.start = null, t.data.cancel = !1, t.data.startPosition = t.horizontal ? kG(t) : LG(t), t.data.targetPosition = t.absolute ? e : e + t.data.startPosition, t.data.startPosition === t.data.targetPosition) {
    xs.default.registered.end && xs.default.registered.end(t.data.to, t.data.target, t.data.currentPosition);
    return;
  }
  t.data.delta = Math.round(t.data.targetPosition - t.data.startPosition), t.data.duration = k_e(t.duration)(t.data.delta), t.data.duration = isNaN(parseFloat(t.data.duration)) ? 1e3 : parseFloat(t.data.duration), t.data.to = n, t.data.target = r;
  var i = OG(t), a = S_e.bind(null, i, t);
  if (t && t.delay > 0) {
    t.data.delayTimeout = window.setTimeout(function() {
      xs.default.registered.begin && xs.default.registered.begin(t.data.to, t.data.target), Ik.call(window, a);
    }, t.delay);
    return;
  }
  xs.default.registered.begin && xs.default.registered.begin(t.data.to, t.data.target), Ik.call(window, a);
}, qw = function(e) {
  return e = b_e({}, e), e.data = e.data || EG(), e.absolute = !0, e;
}, M_e = function(e) {
  $f(0, qw(e));
}, D_e = function(e, t) {
  $f(e, qw(t));
}, T_e = function(e) {
  e = qw(e), k_(e), $f(e.horizontal ? P_e(e) : __e(e), e);
}, j_e = function(e, t) {
  t = qw(t), k_(t);
  var n = t.horizontal ? kG(t) : LG(t);
  $f(e + n, t);
};
Vw.default = {
  animateTopScroll: $f,
  getAnimationType: OG,
  scrollToTop: M_e,
  scrollToBottom: T_e,
  scrollTo: D_e,
  scrollMore: j_e
};
Object.defineProperty(Ac, "__esModule", {
  value: !0
});
var A_e = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, I_e = Uf, R_e = L_(I_e), B_e = Vw, N_e = L_(B_e), F_e = Hf, Ag = L_(F_e);
function L_(e) {
  return e && e.__esModule ? e : { default: e };
}
var Ig = {}, ez = void 0;
Ac.default = {
  unmount: function() {
    Ig = {};
  },
  register: function(e, t) {
    Ig[e] = t;
  },
  unregister: function(e) {
    delete Ig[e];
  },
  get: function(e) {
    return Ig[e] || document.getElementById(e) || document.getElementsByName(e)[0] || document.getElementsByClassName(e)[0];
  },
  setActiveLink: function(e) {
    return ez = e;
  },
  getActiveLink: function() {
    return ez;
  },
  scrollTo: function(e, t) {
    var n = this.get(e);
    if (!n) {
      console.warn("target Element not found");
      return;
    }
    t = A_e({}, t, { absolute: !1 });
    var r = t.containerId, o = t.container, i = void 0;
    r ? i = document.getElementById(r) : o && o.nodeType ? i = o : i = document, t.absolute = !0;
    var a = t.horizontal, s = R_e.default.scrollOffset(i, n, a) + (t.offset || 0);
    if (!t.smooth) {
      Ag.default.registered.begin && Ag.default.registered.begin(e, n), i === document ? t.horizontal ? window.scrollTo(s, 0) : window.scrollTo(0, s) : i.scrollTop = s, Ag.default.registered.end && Ag.default.registered.end(e, n);
      return;
    }
    N_e.default.animateTopScroll(s, t, e, n);
  }
};
var Rk = { exports: {} }, wx = { exports: {} }, jn = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var tz;
function z_e() {
  if (tz) return jn;
  tz = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, g = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, m = e ? Symbol.for("react.block") : 60121, v = e ? Symbol.for("react.fundamental") : 60117, E = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
  function M(y) {
    if (typeof y == "object" && y !== null) {
      var C = y.$$typeof;
      switch (C) {
        case t:
          switch (y = y.type, y) {
            case l:
            case u:
            case r:
            case i:
            case o:
            case p:
              return y;
            default:
              switch (y = y && y.$$typeof, y) {
                case s:
                case c:
                case f:
                case g:
                case a:
                  return y;
                default:
                  return C;
              }
          }
        case n:
          return C;
      }
    }
  }
  function O(y) {
    return M(y) === u;
  }
  return jn.AsyncMode = l, jn.ConcurrentMode = u, jn.ContextConsumer = s, jn.ContextProvider = a, jn.Element = t, jn.ForwardRef = c, jn.Fragment = r, jn.Lazy = f, jn.Memo = g, jn.Portal = n, jn.Profiler = i, jn.StrictMode = o, jn.Suspense = p, jn.isAsyncMode = function(y) {
    return O(y) || M(y) === l;
  }, jn.isConcurrentMode = O, jn.isContextConsumer = function(y) {
    return M(y) === s;
  }, jn.isContextProvider = function(y) {
    return M(y) === a;
  }, jn.isElement = function(y) {
    return typeof y == "object" && y !== null && y.$$typeof === t;
  }, jn.isForwardRef = function(y) {
    return M(y) === c;
  }, jn.isFragment = function(y) {
    return M(y) === r;
  }, jn.isLazy = function(y) {
    return M(y) === f;
  }, jn.isMemo = function(y) {
    return M(y) === g;
  }, jn.isPortal = function(y) {
    return M(y) === n;
  }, jn.isProfiler = function(y) {
    return M(y) === i;
  }, jn.isStrictMode = function(y) {
    return M(y) === o;
  }, jn.isSuspense = function(y) {
    return M(y) === p;
  }, jn.isValidElementType = function(y) {
    return typeof y == "string" || typeof y == "function" || y === r || y === u || y === i || y === o || y === p || y === d || typeof y == "object" && y !== null && (y.$$typeof === f || y.$$typeof === g || y.$$typeof === a || y.$$typeof === s || y.$$typeof === c || y.$$typeof === v || y.$$typeof === E || y.$$typeof === w || y.$$typeof === m);
  }, jn.typeOf = M, jn;
}
var Hn = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var nz;
function U_e() {
  return nz || (nz = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, g = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, m = e ? Symbol.for("react.block") : 60121, v = e ? Symbol.for("react.fundamental") : 60117, E = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
    function M(B) {
      return typeof B == "string" || typeof B == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      B === r || B === u || B === i || B === o || B === p || B === d || typeof B == "object" && B !== null && (B.$$typeof === f || B.$$typeof === g || B.$$typeof === a || B.$$typeof === s || B.$$typeof === c || B.$$typeof === v || B.$$typeof === E || B.$$typeof === w || B.$$typeof === m);
    }
    function O(B) {
      if (typeof B == "object" && B !== null) {
        var ue = B.$$typeof;
        switch (ue) {
          case t:
            var fe = B.type;
            switch (fe) {
              case l:
              case u:
              case r:
              case i:
              case o:
              case p:
                return fe;
              default:
                var oe = fe && fe.$$typeof;
                switch (oe) {
                  case s:
                  case c:
                  case f:
                  case g:
                  case a:
                    return oe;
                  default:
                    return ue;
                }
            }
          case n:
            return ue;
        }
      }
    }
    var y = l, C = u, _ = s, F = a, L = t, N = c, R = r, W = f, V = g, z = n, Z = i, K = o, X = p, te = !1;
    function J(B) {
      return te || (te = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), P(B) || O(B) === l;
    }
    function P(B) {
      return O(B) === u;
    }
    function D(B) {
      return O(B) === s;
    }
    function H(B) {
      return O(B) === a;
    }
    function S(B) {
      return typeof B == "object" && B !== null && B.$$typeof === t;
    }
    function $(B) {
      return O(B) === c;
    }
    function x(B) {
      return O(B) === r;
    }
    function j(B) {
      return O(B) === f;
    }
    function U(B) {
      return O(B) === g;
    }
    function T(B) {
      return O(B) === n;
    }
    function q(B) {
      return O(B) === i;
    }
    function A(B) {
      return O(B) === o;
    }
    function Y(B) {
      return O(B) === p;
    }
    Hn.AsyncMode = y, Hn.ConcurrentMode = C, Hn.ContextConsumer = _, Hn.ContextProvider = F, Hn.Element = L, Hn.ForwardRef = N, Hn.Fragment = R, Hn.Lazy = W, Hn.Memo = V, Hn.Portal = z, Hn.Profiler = Z, Hn.StrictMode = K, Hn.Suspense = X, Hn.isAsyncMode = J, Hn.isConcurrentMode = P, Hn.isContextConsumer = D, Hn.isContextProvider = H, Hn.isElement = S, Hn.isForwardRef = $, Hn.isFragment = x, Hn.isLazy = j, Hn.isMemo = U, Hn.isPortal = T, Hn.isProfiler = q, Hn.isStrictMode = A, Hn.isSuspense = Y, Hn.isValidElementType = M, Hn.typeOf = O;
  }()), Hn;
}
var rz;
function PG() {
  return rz || (rz = 1, process.env.NODE_ENV === "production" ? wx.exports = z_e() : wx.exports = U_e()), wx.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var Cx, oz;
function H_e() {
  if (oz) return Cx;
  oz = 1;
  var e = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, n = Object.prototype.propertyIsEnumerable;
  function r(i) {
    if (i == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(i);
  }
  function o() {
    try {
      if (!Object.assign)
        return !1;
      var i = new String("abc");
      if (i[5] = "de", Object.getOwnPropertyNames(i)[0] === "5")
        return !1;
      for (var a = {}, s = 0; s < 10; s++)
        a["_" + String.fromCharCode(s)] = s;
      var l = Object.getOwnPropertyNames(a).map(function(c) {
        return a[c];
      });
      if (l.join("") !== "0123456789")
        return !1;
      var u = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(c) {
        u[c] = c;
      }), Object.keys(Object.assign({}, u)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return Cx = o() ? Object.assign : function(i, a) {
    for (var s, l = r(i), u, c = 1; c < arguments.length; c++) {
      s = Object(arguments[c]);
      for (var p in s)
        t.call(s, p) && (l[p] = s[p]);
      if (e) {
        u = e(s);
        for (var d = 0; d < u.length; d++)
          n.call(s, u[d]) && (l[u[d]] = s[u[d]]);
      }
    }
    return l;
  }, Cx;
}
var xx, iz;
function P_() {
  if (iz) return xx;
  iz = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return xx = e, xx;
}
var sz, az;
function _G() {
  return az || (az = 1, sz = Function.call.bind(Object.prototype.hasOwnProperty)), sz;
}
var Ox, lz;
function $_e() {
  if (lz) return Ox;
  lz = 1;
  var e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = P_(), n = {}, r = _G();
    e = function(i) {
      var a = "Warning: " + i;
      typeof console < "u" && console.error(a);
      try {
        throw new Error(a);
      } catch {
      }
    };
  }
  function o(i, a, s, l, u) {
    if (process.env.NODE_ENV !== "production") {
      for (var c in i)
        if (r(i, c)) {
          var p;
          try {
            if (typeof i[c] != "function") {
              var d = Error(
                (l || "React class") + ": " + s + " type `" + c + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof i[c] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw d.name = "Invariant Violation", d;
            }
            p = i[c](a, c, l, s, null, t);
          } catch (f) {
            p = f;
          }
          if (p && !(p instanceof Error) && e(
            (l || "React class") + ": type specification of " + s + " `" + c + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof p + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), p instanceof Error && !(p.message in n)) {
            n[p.message] = !0;
            var g = u ? u() : "";
            e(
              "Failed " + s + " type: " + p.message + (g ?? "")
            );
          }
        }
    }
  }
  return o.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (n = {});
  }, Ox = o, Ox;
}
var Ex, uz;
function W_e() {
  if (uz) return Ex;
  uz = 1;
  var e = PG(), t = H_e(), n = P_(), r = _G(), o = $_e(), i = function() {
  };
  process.env.NODE_ENV !== "production" && (i = function(s) {
    var l = "Warning: " + s;
    typeof console < "u" && console.error(l);
    try {
      throw new Error(l);
    } catch {
    }
  });
  function a() {
    return null;
  }
  return Ex = function(s, l) {
    var u = typeof Symbol == "function" && Symbol.iterator, c = "@@iterator";
    function p(P) {
      var D = P && (u && P[u] || P[c]);
      if (typeof D == "function")
        return D;
    }
    var d = "<<anonymous>>", g = {
      array: E("array"),
      bigint: E("bigint"),
      bool: E("boolean"),
      func: E("function"),
      number: E("number"),
      object: E("object"),
      string: E("string"),
      symbol: E("symbol"),
      any: w(),
      arrayOf: M,
      element: O(),
      elementType: y(),
      instanceOf: C,
      node: N(),
      objectOf: F,
      oneOf: _,
      oneOfType: L,
      shape: W,
      exact: V
    };
    function f(P, D) {
      return P === D ? P !== 0 || 1 / P === 1 / D : P !== P && D !== D;
    }
    function m(P, D) {
      this.message = P, this.data = D && typeof D == "object" ? D : {}, this.stack = "";
    }
    m.prototype = Error.prototype;
    function v(P) {
      if (process.env.NODE_ENV !== "production")
        var D = {}, H = 0;
      function S(x, j, U, T, q, A, Y) {
        if (T = T || d, A = A || U, Y !== n) {
          if (l) {
            var B = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw B.name = "Invariant Violation", B;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var ue = T + ":" + U;
            !D[ue] && // Avoid spamming the console because they are often not actionable except for lib authors
            H < 3 && (i(
              "You are manually calling a React.PropTypes validation function for the `" + A + "` prop on `" + T + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), D[ue] = !0, H++);
          }
        }
        return j[U] == null ? x ? j[U] === null ? new m("The " + q + " `" + A + "` is marked as required " + ("in `" + T + "`, but its value is `null`.")) : new m("The " + q + " `" + A + "` is marked as required in " + ("`" + T + "`, but its value is `undefined`.")) : null : P(j, U, T, q, A);
      }
      var $ = S.bind(null, !1);
      return $.isRequired = S.bind(null, !0), $;
    }
    function E(P) {
      function D(H, S, $, x, j, U) {
        var T = H[S], q = K(T);
        if (q !== P) {
          var A = X(T);
          return new m(
            "Invalid " + x + " `" + j + "` of type " + ("`" + A + "` supplied to `" + $ + "`, expected ") + ("`" + P + "`."),
            { expectedType: P }
          );
        }
        return null;
      }
      return v(D);
    }
    function w() {
      return v(a);
    }
    function M(P) {
      function D(H, S, $, x, j) {
        if (typeof P != "function")
          return new m("Property `" + j + "` of component `" + $ + "` has invalid PropType notation inside arrayOf.");
        var U = H[S];
        if (!Array.isArray(U)) {
          var T = K(U);
          return new m("Invalid " + x + " `" + j + "` of type " + ("`" + T + "` supplied to `" + $ + "`, expected an array."));
        }
        for (var q = 0; q < U.length; q++) {
          var A = P(U, q, $, x, j + "[" + q + "]", n);
          if (A instanceof Error)
            return A;
        }
        return null;
      }
      return v(D);
    }
    function O() {
      function P(D, H, S, $, x) {
        var j = D[H];
        if (!s(j)) {
          var U = K(j);
          return new m("Invalid " + $ + " `" + x + "` of type " + ("`" + U + "` supplied to `" + S + "`, expected a single ReactElement."));
        }
        return null;
      }
      return v(P);
    }
    function y() {
      function P(D, H, S, $, x) {
        var j = D[H];
        if (!e.isValidElementType(j)) {
          var U = K(j);
          return new m("Invalid " + $ + " `" + x + "` of type " + ("`" + U + "` supplied to `" + S + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return v(P);
    }
    function C(P) {
      function D(H, S, $, x, j) {
        if (!(H[S] instanceof P)) {
          var U = P.name || d, T = J(H[S]);
          return new m("Invalid " + x + " `" + j + "` of type " + ("`" + T + "` supplied to `" + $ + "`, expected ") + ("instance of `" + U + "`."));
        }
        return null;
      }
      return v(D);
    }
    function _(P) {
      if (!Array.isArray(P))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? i(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : i("Invalid argument supplied to oneOf, expected an array.")), a;
      function D(H, S, $, x, j) {
        for (var U = H[S], T = 0; T < P.length; T++)
          if (f(U, P[T]))
            return null;
        var q = JSON.stringify(P, function(A, Y) {
          var B = X(Y);
          return B === "symbol" ? String(Y) : Y;
        });
        return new m("Invalid " + x + " `" + j + "` of value `" + String(U) + "` " + ("supplied to `" + $ + "`, expected one of " + q + "."));
      }
      return v(D);
    }
    function F(P) {
      function D(H, S, $, x, j) {
        if (typeof P != "function")
          return new m("Property `" + j + "` of component `" + $ + "` has invalid PropType notation inside objectOf.");
        var U = H[S], T = K(U);
        if (T !== "object")
          return new m("Invalid " + x + " `" + j + "` of type " + ("`" + T + "` supplied to `" + $ + "`, expected an object."));
        for (var q in U)
          if (r(U, q)) {
            var A = P(U, q, $, x, j + "." + q, n);
            if (A instanceof Error)
              return A;
          }
        return null;
      }
      return v(D);
    }
    function L(P) {
      if (!Array.isArray(P))
        return process.env.NODE_ENV !== "production" && i("Invalid argument supplied to oneOfType, expected an instance of array."), a;
      for (var D = 0; D < P.length; D++) {
        var H = P[D];
        if (typeof H != "function")
          return i(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + te(H) + " at index " + D + "."
          ), a;
      }
      function S($, x, j, U, T) {
        for (var q = [], A = 0; A < P.length; A++) {
          var Y = P[A], B = Y($, x, j, U, T, n);
          if (B == null)
            return null;
          B.data && r(B.data, "expectedType") && q.push(B.data.expectedType);
        }
        var ue = q.length > 0 ? ", expected one of type [" + q.join(", ") + "]" : "";
        return new m("Invalid " + U + " `" + T + "` supplied to " + ("`" + j + "`" + ue + "."));
      }
      return v(S);
    }
    function N() {
      function P(D, H, S, $, x) {
        return z(D[H]) ? null : new m("Invalid " + $ + " `" + x + "` supplied to " + ("`" + S + "`, expected a ReactNode."));
      }
      return v(P);
    }
    function R(P, D, H, S, $) {
      return new m(
        (P || "React class") + ": " + D + " type `" + H + "." + S + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + $ + "`."
      );
    }
    function W(P) {
      function D(H, S, $, x, j) {
        var U = H[S], T = K(U);
        if (T !== "object")
          return new m("Invalid " + x + " `" + j + "` of type `" + T + "` " + ("supplied to `" + $ + "`, expected `object`."));
        for (var q in P) {
          var A = P[q];
          if (typeof A != "function")
            return R($, x, j, q, X(A));
          var Y = A(U, q, $, x, j + "." + q, n);
          if (Y)
            return Y;
        }
        return null;
      }
      return v(D);
    }
    function V(P) {
      function D(H, S, $, x, j) {
        var U = H[S], T = K(U);
        if (T !== "object")
          return new m("Invalid " + x + " `" + j + "` of type `" + T + "` " + ("supplied to `" + $ + "`, expected `object`."));
        var q = t({}, H[S], P);
        for (var A in q) {
          var Y = P[A];
          if (r(P, A) && typeof Y != "function")
            return R($, x, j, A, X(Y));
          if (!Y)
            return new m(
              "Invalid " + x + " `" + j + "` key `" + A + "` supplied to `" + $ + "`.\nBad object: " + JSON.stringify(H[S], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(P), null, "  ")
            );
          var B = Y(U, A, $, x, j + "." + A, n);
          if (B)
            return B;
        }
        return null;
      }
      return v(D);
    }
    function z(P) {
      switch (typeof P) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !P;
        case "object":
          if (Array.isArray(P))
            return P.every(z);
          if (P === null || s(P))
            return !0;
          var D = p(P);
          if (D) {
            var H = D.call(P), S;
            if (D !== P.entries) {
              for (; !(S = H.next()).done; )
                if (!z(S.value))
                  return !1;
            } else
              for (; !(S = H.next()).done; ) {
                var $ = S.value;
                if ($ && !z($[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function Z(P, D) {
      return P === "symbol" ? !0 : D ? D["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && D instanceof Symbol : !1;
    }
    function K(P) {
      var D = typeof P;
      return Array.isArray(P) ? "array" : P instanceof RegExp ? "object" : Z(D, P) ? "symbol" : D;
    }
    function X(P) {
      if (typeof P > "u" || P === null)
        return "" + P;
      var D = K(P);
      if (D === "object") {
        if (P instanceof Date)
          return "date";
        if (P instanceof RegExp)
          return "regexp";
      }
      return D;
    }
    function te(P) {
      var D = X(P);
      switch (D) {
        case "array":
        case "object":
          return "an " + D;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + D;
        default:
          return D;
      }
    }
    function J(P) {
      return !P.constructor || !P.constructor.name ? d : P.constructor.name;
    }
    return g.checkPropTypes = o, g.resetWarningCache = o.resetWarningCache, g.PropTypes = g, g;
  }, Ex;
}
var kx, cz;
function V_e() {
  if (cz) return kx;
  cz = 1;
  var e = P_();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, kx = function() {
    function r(a, s, l, u, c, p) {
      if (p !== e) {
        var d = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw d.name = "Invariant Violation", d;
      }
    }
    r.isRequired = r;
    function o() {
      return r;
    }
    var i = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: o,
      element: r,
      elementType: r,
      instanceOf: o,
      node: r,
      objectOf: o,
      oneOf: o,
      oneOfType: o,
      shape: o,
      exact: o,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return i.PropTypes = i, i;
  }, kx;
}
if (process.env.NODE_ENV !== "production") {
  var Z_e = PG(), q_e = !0;
  Rk.exports = W_e()(Z_e.isElement, q_e);
} else
  Rk.exports = V_e()();
var Gw = Rk.exports, Kw = {};
Object.defineProperty(Kw, "__esModule", {
  value: !0
});
var G_e = Uf, Lx = K_e(G_e);
function K_e(e) {
  return e && e.__esModule ? e : { default: e };
}
var Y_e = {
  mountFlag: !1,
  initialized: !1,
  scroller: null,
  containers: {},
  mount: function(e) {
    this.scroller = e, this.handleHashChange = this.handleHashChange.bind(this), window.addEventListener("hashchange", this.handleHashChange), this.initStateFromHash(), this.mountFlag = !0;
  },
  mapContainer: function(e, t) {
    this.containers[e] = t;
  },
  isMounted: function() {
    return this.mountFlag;
  },
  isInitialized: function() {
    return this.initialized;
  },
  initStateFromHash: function() {
    var e = this, t = this.getHash();
    t ? window.setTimeout(function() {
      e.scrollTo(t, !0), e.initialized = !0;
    }, 10) : this.initialized = !0;
  },
  scrollTo: function(e, t) {
    var n = this.scroller, r = n.get(e);
    if (r && (t || e !== n.getActiveLink())) {
      var o = this.containers[e] || document;
      n.scrollTo(e, { container: o });
    }
  },
  getHash: function() {
    return Lx.default.getHash();
  },
  changeHash: function(e, t) {
    this.isInitialized() && Lx.default.getHash() !== e && Lx.default.updateHash(e, t);
  },
  handleHashChange: function() {
    this.scrollTo(this.getHash());
  },
  unmount: function() {
    this.scroller = null, this.containers = null, window.removeEventListener("hashchange", this.handleHashChange);
  }
};
Kw.default = Y_e;
Object.defineProperty(Nf, "__esModule", {
  value: !0
});
var Rg = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, X_e = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), J_e = we, pz = Wf(J_e), Q_e = Ff, Bg = Wf(Q_e), eSe = Ac, tSe = Wf(eSe), nSe = Gw, jr = Wf(nSe), rSe = Kw, _a = Wf(rSe);
function Wf(e) {
  return e && e.__esModule ? e : { default: e };
}
function oSe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function iSe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function sSe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var dz = {
  to: jr.default.string.isRequired,
  containerId: jr.default.string,
  container: jr.default.object,
  activeClass: jr.default.string,
  activeStyle: jr.default.object,
  spy: jr.default.bool,
  horizontal: jr.default.bool,
  smooth: jr.default.oneOfType([jr.default.bool, jr.default.string]),
  offset: jr.default.number,
  delay: jr.default.number,
  isDynamic: jr.default.bool,
  onClick: jr.default.func,
  duration: jr.default.oneOfType([jr.default.number, jr.default.func]),
  absolute: jr.default.bool,
  onSetActive: jr.default.func,
  onSetInactive: jr.default.func,
  ignoreCancelEvents: jr.default.bool,
  hashSpy: jr.default.bool,
  saveHashHistory: jr.default.bool,
  spyThrottle: jr.default.number
};
Nf.default = function(e, t) {
  var n = t || tSe.default, r = function(i) {
    sSe(a, i);
    function a(s) {
      oSe(this, a);
      var l = iSe(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
      return o.call(l), l.state = {
        active: !1
      }, l.beforeUnmountCallbacks = [], l;
    }
    return X_e(a, [{
      key: "getScrollSpyContainer",
      value: function() {
        var s = this.props.containerId, l = this.props.container;
        return s && !l ? document.getElementById(s) : l && l.nodeType ? l : document;
      }
    }, {
      key: "componentDidMount",
      value: function() {
        if (this.props.spy || this.props.hashSpy) {
          var s = this.getScrollSpyContainer();
          if (!Bg.default.isMounted(s)) {
            var l = Bg.default.mount(s, this.props.spyThrottle);
            this.beforeUnmountCallbacks.push(l);
          }
          this.props.hashSpy && (_a.default.isMounted() || _a.default.mount(n), _a.default.mapContainer(this.props.to, s)), Bg.default.addSpyHandler(this.spyHandler, s), this.setState({
            container: s
          });
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        Bg.default.unmount(this.stateHandler, this.spyHandler), this.beforeUnmountCallbacks.forEach(function(s) {
          return s();
        });
      }
    }, {
      key: "render",
      value: function() {
        var s = "";
        this.state && this.state.active ? s = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : s = this.props.className;
        var l = {};
        this.state && this.state.active ? l = Rg({}, this.props.style, this.props.activeStyle) : l = Rg({}, this.props.style);
        var u = Rg({}, this.props);
        for (var c in dz)
          u.hasOwnProperty(c) && delete u[c];
        return u.className = s, u.style = l, u.onClick = this.handleClick, pz.default.createElement(e, u);
      }
    }]), a;
  }(pz.default.PureComponent), o = function() {
    var i = this;
    this.scrollTo = function(a, s) {
      n.scrollTo(a, Rg({}, i.state, s));
    }, this.handleClick = function(a) {
      i.props.onClick && i.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), i.scrollTo(i.props.to, i.props);
    }, this.spyHandler = function(a, s) {
      var l = i.getScrollSpyContainer();
      if (!(_a.default.isMounted() && !_a.default.isInitialized())) {
        var u = i.props.horizontal, c = i.props.to, p = null, d = void 0, g = void 0;
        if (u) {
          var f = 0, m = 0, v = 0;
          if (l.getBoundingClientRect) {
            var E = l.getBoundingClientRect();
            v = E.left;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var w = p.getBoundingClientRect();
            f = w.left - v + a, m = f + w.width;
          }
          var M = a - i.props.offset;
          d = M >= Math.floor(f) && M < Math.floor(m), g = M < Math.floor(f) || M >= Math.floor(m);
        } else {
          var O = 0, y = 0, C = 0;
          if (l.getBoundingClientRect) {
            var _ = l.getBoundingClientRect();
            C = _.top;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var F = p.getBoundingClientRect();
            O = F.top - C + s, y = O + F.height;
          }
          var L = s - i.props.offset;
          d = L >= Math.floor(O) && L < Math.floor(y), g = L < Math.floor(O) || L >= Math.floor(y);
        }
        var N = n.getActiveLink();
        if (g) {
          if (c === N && n.setActiveLink(void 0), i.props.hashSpy && _a.default.getHash() === c) {
            var R = i.props.saveHashHistory, W = R === void 0 ? !1 : R;
            _a.default.changeHash("", W);
          }
          i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive(c, p));
        }
        if (d && (N !== c || i.state.active === !1)) {
          n.setActiveLink(c);
          var V = i.props.saveHashHistory, z = V === void 0 ? !1 : V;
          i.props.hashSpy && _a.default.changeHash(c, z), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(c, p));
        }
      }
    };
  };
  return r.propTypes = dz, r.defaultProps = { offset: 0 }, r;
};
Object.defineProperty(x_, "__esModule", {
  value: !0
});
var aSe = we, fz = SG(aSe), lSe = Nf, uSe = SG(lSe);
function SG(e) {
  return e && e.__esModule ? e : { default: e };
}
function cSe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function hz(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function pSe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var dSe = function(e) {
  pSe(t, e);
  function t() {
    var n, r, o, i;
    cSe(this, t);
    for (var a = arguments.length, s = Array(a), l = 0; l < a; l++)
      s[l] = arguments[l];
    return i = (r = (o = hz(this, (n = t.__proto__ || Object.getPrototypeOf(t)).call.apply(n, [this].concat(s))), o), o.render = function() {
      return fz.default.createElement(
        "a",
        o.props,
        o.props.children
      );
    }, r), hz(o, i);
  }
  return t;
}(fz.default.Component);
x_.default = (0, uSe.default)(dSe);
var __ = {};
Object.defineProperty(__, "__esModule", {
  value: !0
});
var fSe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), hSe = we, gz = MG(hSe), gSe = Nf, mSe = MG(gSe);
function MG(e) {
  return e && e.__esModule ? e : { default: e };
}
function vSe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function ySe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function bSe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var wSe = function(e) {
  bSe(t, e);
  function t() {
    return vSe(this, t), ySe(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return fSe(t, [{
    key: "render",
    value: function() {
      return gz.default.createElement(
        "button",
        this.props,
        this.props.children
      );
    }
  }]), t;
}(gz.default.Component);
__.default = (0, mSe.default)(wSe);
var S_ = {}, Yw = {};
Object.defineProperty(Yw, "__esModule", {
  value: !0
});
var CSe = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, xSe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), OSe = we, mz = Xw(OSe), ESe = pl;
Xw(ESe);
var kSe = Ac, vz = Xw(kSe), LSe = Gw, yz = Xw(LSe);
function Xw(e) {
  return e && e.__esModule ? e : { default: e };
}
function PSe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function _Se(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function SSe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
Yw.default = function(e) {
  var t = function(n) {
    SSe(r, n);
    function r(o) {
      PSe(this, r);
      var i = _Se(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
      return i.childBindings = {
        domNode: null
      }, i;
    }
    return xSe(r, [{
      key: "componentDidMount",
      value: function() {
        if (typeof window > "u")
          return !1;
        this.registerElems(this.props.name);
      }
    }, {
      key: "componentDidUpdate",
      value: function(o) {
        this.props.name !== o.name && this.registerElems(this.props.name);
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        if (typeof window > "u")
          return !1;
        vz.default.unregister(this.props.name);
      }
    }, {
      key: "registerElems",
      value: function(o) {
        vz.default.register(o, this.childBindings.domNode);
      }
    }, {
      key: "render",
      value: function() {
        return mz.default.createElement(e, CSe({}, this.props, { parentBindings: this.childBindings }));
      }
    }]), r;
  }(mz.default.Component);
  return t.propTypes = {
    name: yz.default.string,
    id: yz.default.string
  }, t;
};
Object.defineProperty(S_, "__esModule", {
  value: !0
});
var bz = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, MSe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), DSe = we, wz = M_(DSe), TSe = Yw, jSe = M_(TSe), ASe = Gw, Cz = M_(ASe);
function M_(e) {
  return e && e.__esModule ? e : { default: e };
}
function ISe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function RSe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function BSe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var DG = function(e) {
  BSe(t, e);
  function t() {
    return ISe(this, t), RSe(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return MSe(t, [{
    key: "render",
    value: function() {
      var n = this, r = bz({}, this.props);
      return delete r.name, r.parentBindings && delete r.parentBindings, wz.default.createElement(
        "div",
        bz({}, r, { ref: function(o) {
          n.props.parentBindings.domNode = o;
        } }),
        this.props.children
      );
    }
  }]), t;
}(wz.default.Component);
DG.propTypes = {
  name: Cz.default.string,
  id: Cz.default.string
};
S_.default = (0, jSe.default)(DG);
var Px = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, xz = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}();
function Oz(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Ez(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function kz(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var Ng = we, zl = Ff, _x = Ac, Xr = Gw, Sa = Kw, Lz = {
  to: Xr.string.isRequired,
  containerId: Xr.string,
  container: Xr.object,
  activeClass: Xr.string,
  spy: Xr.bool,
  smooth: Xr.oneOfType([Xr.bool, Xr.string]),
  offset: Xr.number,
  delay: Xr.number,
  isDynamic: Xr.bool,
  onClick: Xr.func,
  duration: Xr.oneOfType([Xr.number, Xr.func]),
  absolute: Xr.bool,
  onSetActive: Xr.func,
  onSetInactive: Xr.func,
  ignoreCancelEvents: Xr.bool,
  hashSpy: Xr.bool,
  spyThrottle: Xr.number
}, NSe = {
  Scroll: function(e, t) {
    console.warn("Helpers.Scroll is deprecated since v1.7.0");
    var n = t || _x, r = function(i) {
      kz(a, i);
      function a(s) {
        Oz(this, a);
        var l = Ez(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
        return o.call(l), l.state = {
          active: !1
        }, l;
      }
      return xz(a, [{
        key: "getScrollSpyContainer",
        value: function() {
          var s = this.props.containerId, l = this.props.container;
          return s ? document.getElementById(s) : l && l.nodeType ? l : document;
        }
      }, {
        key: "componentDidMount",
        value: function() {
          if (this.props.spy || this.props.hashSpy) {
            var s = this.getScrollSpyContainer();
            zl.isMounted(s) || zl.mount(s, this.props.spyThrottle), this.props.hashSpy && (Sa.isMounted() || Sa.mount(n), Sa.mapContainer(this.props.to, s)), this.props.spy && zl.addStateHandler(this.stateHandler), zl.addSpyHandler(this.spyHandler, s), this.setState({
              container: s
            });
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          zl.unmount(this.stateHandler, this.spyHandler);
        }
      }, {
        key: "render",
        value: function() {
          var s = "";
          this.state && this.state.active ? s = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : s = this.props.className;
          var l = Px({}, this.props);
          for (var u in Lz)
            l.hasOwnProperty(u) && delete l[u];
          return l.className = s, l.onClick = this.handleClick, Ng.createElement(e, l);
        }
      }]), a;
    }(Ng.Component), o = function() {
      var i = this;
      this.scrollTo = function(a, s) {
        n.scrollTo(a, Px({}, i.state, s));
      }, this.handleClick = function(a) {
        i.props.onClick && i.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), i.scrollTo(i.props.to, i.props);
      }, this.stateHandler = function() {
        n.getActiveLink() !== i.props.to && (i.state !== null && i.state.active && i.props.onSetInactive && i.props.onSetInactive(), i.setState({ active: !1 }));
      }, this.spyHandler = function(a) {
        var s = i.getScrollSpyContainer();
        if (!(Sa.isMounted() && !Sa.isInitialized())) {
          var l = i.props.to, u = null, c = 0, p = 0, d = 0;
          if (s.getBoundingClientRect) {
            var g = s.getBoundingClientRect();
            d = g.top;
          }
          if (!u || i.props.isDynamic) {
            if (u = n.get(l), !u)
              return;
            var f = u.getBoundingClientRect();
            c = f.top - d + a, p = c + f.height;
          }
          var m = a - i.props.offset, v = m >= Math.floor(c) && m < Math.floor(p), E = m < Math.floor(c) || m >= Math.floor(p), w = n.getActiveLink();
          if (E)
            return l === w && n.setActiveLink(void 0), i.props.hashSpy && Sa.getHash() === l && Sa.changeHash(), i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive()), zl.updateStates();
          if (v && w !== l)
            return n.setActiveLink(l), i.props.hashSpy && Sa.changeHash(l), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(l)), zl.updateStates();
        }
      };
    };
    return r.propTypes = Lz, r.defaultProps = { offset: 0 }, r;
  },
  Element: function(e) {
    console.warn("Helpers.Element is deprecated since v1.7.0");
    var t = function(n) {
      kz(r, n);
      function r(o) {
        Oz(this, r);
        var i = Ez(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
        return i.childBindings = {
          domNode: null
        }, i;
      }
      return xz(r, [{
        key: "componentDidMount",
        value: function() {
          if (typeof window > "u")
            return !1;
          this.registerElems(this.props.name);
        }
      }, {
        key: "componentDidUpdate",
        value: function(o) {
          this.props.name !== o.name && this.registerElems(this.props.name);
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          if (typeof window > "u")
            return !1;
          _x.unregister(this.props.name);
        }
      }, {
        key: "registerElems",
        value: function(o) {
          _x.register(o, this.childBindings.domNode);
        }
      }, {
        key: "render",
        value: function() {
          return Ng.createElement(e, Px({}, this.props, { parentBindings: this.childBindings }));
        }
      }]), r;
    }(Ng.Component);
    return t.propTypes = {
      name: Xr.string,
      id: Xr.string
    }, t;
  }
}, FSe = NSe;
Object.defineProperty(po, "__esModule", {
  value: !0
});
po.Helpers = po.ScrollElement = po.ScrollLink = po.animateScroll = po.scrollSpy = po.Events = po.scroller = po.Element = po.Button = po.Link = void 0;
var zSe = x_, TG = Rs(zSe), USe = __, jG = Rs(USe), HSe = S_, AG = Rs(HSe), $Se = Ac, IG = Rs($Se), WSe = Hf, RG = Rs(WSe), VSe = Ff, BG = Rs(VSe), ZSe = Vw, NG = Rs(ZSe), qSe = Nf, FG = Rs(qSe), GSe = Yw, zG = Rs(GSe), KSe = FSe, UG = Rs(KSe);
function Rs(e) {
  return e && e.__esModule ? e : { default: e };
}
po.Link = TG.default;
po.Button = jG.default;
po.Element = AG.default;
po.scroller = IG.default;
po.Events = RG.default;
po.scrollSpy = BG.default;
po.animateScroll = NG.default;
po.ScrollLink = FG.default;
po.ScrollElement = zG.default;
po.Helpers = UG.default;
po.default = { Link: TG.default, Button: jG.default, Element: AG.default, scroller: IG.default, Events: RG.default, scrollSpy: BG.default, animateScroll: NG.default, ScrollLink: FG.default, ScrollElement: zG.default, Helpers: UG.default };
Ke({});
Ke({});
Ke({});
function sf(e) {
  "@babel/helpers - typeof";
  return sf = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, sf(e);
}
function YSe(e, t) {
  if (sf(e) != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (sf(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function XSe(e) {
  var t = YSe(e, "string");
  return sf(t) == "symbol" ? t : t + "";
}
function Ee(e, t, n) {
  return (t = XSe(t)) in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function HG(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var Sx, Pz;
function JSe() {
  if (Pz) return Sx;
  Pz = 1;
  var e = process.env.NODE_ENV, t = function(n, r, o, i, a, s, l, u) {
    if (e !== "production" && r === void 0)
      throw new Error("invariant requires an error message argument");
    if (!n) {
      var c;
      if (r === void 0)
        c = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
      else {
        var p = [o, i, a, s, l, u], d = 0;
        c = new Error(r.replace(/%s/g, function() {
          return p[d++];
        })), c.name = "Invariant Violation";
      }
      throw c.framesToPop = 1, c;
    }
  };
  return Sx = t, Sx;
}
var QSe = JSe(), Co = /* @__PURE__ */ HG(QSe), It = Ke(null);
function eMe() {
  Co(!!ge, "useGoogleMap is React hook and requires React version 16.8+");
  var e = ge(It);
  return Co(!!e, "useGoogleMap needs a GoogleMap available up in the tree"), e;
}
function tMe(e, t, n) {
  return Object.keys(e).reduce(function(r, o) {
    return t(r, e[o], o);
  }, n);
}
function nMe(e, t) {
  Object.keys(e).forEach((n) => t(e[n], n));
}
function rMe(e, t, n, r) {
  var o = {}, i = (a, s) => {
    var l = n[s];
    l !== t[s] && (o[s] = l, a(r, l));
  };
  return nMe(e, i), o;
}
function oMe(e, t, n) {
  var r = tMe(n, function(o, i, a) {
    return typeof e[a] == "function" && o.push(google.maps.event.addListener(t, i, e[a])), o;
  }, []);
  return r;
}
function iMe(e) {
  google.maps.event.removeListener(e);
}
function mn() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  e.forEach(iMe);
}
function cn(e) {
  var {
    updaterMap: t,
    eventMap: n,
    prevProps: r,
    nextProps: o,
    instance: i
  } = e, a = oMe(o, i, n);
  return rMe(t, r, o, i), a;
}
function sMe(e) {
  var {
    children: t,
    options: n,
    id: r,
    mapContainerStyle: o,
    mapContainerClassName: i,
    center: a,
    // clickableIcons,
    // extraMapTypes,
    // heading,
    // mapTypeId,
    onClick: s,
    onDblClick: l,
    onDrag: u,
    onDragEnd: c,
    onDragStart: p,
    onMouseMove: d,
    onMouseOut: g,
    onMouseOver: f,
    onMouseDown: m,
    onMouseUp: v,
    onRightClick: E,
    // onMapTypeIdChanged,
    // onTilesLoaded,
    // onBoundsChanged,
    onCenterChanged: w,
    // onHeadingChanged,
    // onIdle,
    // onProjectionChanged,
    // onResize,
    // onTiltChanged,
    // onZoomChanged,
    onLoad: M,
    onUnmount: O
  } = e, [y, C] = k(null), _ = ut(null), [F, L] = k(null), [N, R] = k(null), [W, V] = k(null), [z, Z] = k(null), [K, X] = k(null), [te, J] = k(null), [P, D] = k(null), [H, S] = k(null), [$, x] = k(null), [j, U] = k(null), [T, q] = k(null), [A, Y] = k(null);
  return h(() => {
    n && y !== null && y.setOptions(n);
  }, [y, n]), h(() => {
    y !== null && typeof a < "u" && y.setCenter(a);
  }, [y, a]), h(() => {
    y && l && (N !== null && google.maps.event.removeListener(N), R(google.maps.event.addListener(y, "dblclick", l)));
  }, [l]), h(() => {
    y && c && (W !== null && google.maps.event.removeListener(W), V(google.maps.event.addListener(y, "dragend", c)));
  }, [c]), h(() => {
    y && p && (z !== null && google.maps.event.removeListener(z), Z(google.maps.event.addListener(y, "dragstart", p)));
  }, [p]), h(() => {
    y && m && (K !== null && google.maps.event.removeListener(K), X(google.maps.event.addListener(y, "mousedown", m)));
  }, [m]), h(() => {
    y && d && (te !== null && google.maps.event.removeListener(te), J(google.maps.event.addListener(y, "mousemove", d)));
  }, [d]), h(() => {
    y && g && (P !== null && google.maps.event.removeListener(P), D(google.maps.event.addListener(y, "mouseout", g)));
  }, [g]), h(() => {
    y && f && (H !== null && google.maps.event.removeListener(H), S(google.maps.event.addListener(y, "mouseover", f)));
  }, [f]), h(() => {
    y && v && ($ !== null && google.maps.event.removeListener($), x(google.maps.event.addListener(y, "mouseup", v)));
  }, [v]), h(() => {
    y && E && (j !== null && google.maps.event.removeListener(j), U(google.maps.event.addListener(y, "rightclick", E)));
  }, [E]), h(() => {
    y && s && (T !== null && google.maps.event.removeListener(T), q(google.maps.event.addListener(y, "click", s)));
  }, [s]), h(() => {
    y && u && (A !== null && google.maps.event.removeListener(A), Y(google.maps.event.addListener(y, "drag", u)));
  }, [u]), h(() => {
    y && w && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(y, "center_changed", w)));
  }, [s]), h(() => {
    var B = _.current === null ? null : new google.maps.Map(_.current, n);
    return C(B), B !== null && M && M(B), () => {
      B !== null && O && O(B);
    };
  }, []), _o.jsx("div", {
    id: r,
    ref: _,
    style: o,
    className: i,
    children: _o.jsx(It.Provider, {
      value: y,
      children: y !== null ? t : null
    })
  });
}
ve(sMe);
function _z(e, t, n, r, o, i, a) {
  try {
    var s = e[i](a), l = s.value;
  } catch (u) {
    return void n(u);
  }
  s.done ? t(l) : Promise.resolve(l).then(r, o);
}
function $G(e) {
  return function() {
    var t = this, n = arguments;
    return new Promise(function(r, o) {
      var i = e.apply(t, n);
      function a(l) {
        _z(i, r, o, a, s, "next", l);
      }
      function s(l) {
        _z(i, r, o, a, s, "throw", l);
      }
      a(void 0);
    });
  };
}
function WG(e) {
  var {
    googleMapsApiKey: t,
    googleMapsClientId: n,
    version: r = "weekly",
    language: o,
    region: i,
    libraries: a,
    channel: s,
    mapIds: l,
    authReferrerPolicy: u
  } = e, c = [];
  return Co(t && n || !(t && n), "You need to specify either googleMapsApiKey or googleMapsClientId for @react-google-maps/api load script to work. You cannot use both at the same time."), t ? c.push("key=".concat(t)) : n && c.push("client=".concat(n)), r && c.push("v=".concat(r)), o && c.push("language=".concat(o)), i && c.push("region=".concat(i)), a && a.length && c.push("libraries=".concat(a.sort().join(","))), s && c.push("channel=".concat(s)), l && l.length && c.push("map_ids=".concat(l.join(","))), u && c.push("auth_referrer_policy=".concat(u)), c.push("loading=async"), c.push("callback=initMap"), "https://maps.googleapis.com/maps/api/js?".concat(c.join("&"));
}
var fu = typeof document < "u";
function VG(e) {
  var {
    url: t,
    id: n,
    nonce: r
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } = e;
  return fu ? new Promise(function(o, i) {
    var a = document.getElementById(n), s = window;
    if (a) {
      var l = a.getAttribute("data-state");
      if (a.src === t && l !== "error") {
        if (l === "ready")
          return o(n);
        var u = s.initMap, c = a.onerror;
        s.initMap = function() {
          u && u(), o(n);
        }, a.onerror = function(d) {
          c && c(d), i(d);
        };
        return;
      } else
        a.remove();
    }
    var p = document.createElement("script");
    p.type = "text/javascript", p.src = t, p.id = n, p.async = !0, p.nonce = r || "", p.onerror = function(d) {
      p.setAttribute("data-state", "error"), i(d);
    }, s.initMap = function() {
      p.setAttribute("data-state", "ready"), o(n);
    }, document.head.appendChild(p);
  }).catch((o) => {
    throw console.error("injectScript error: ", o), o;
  }) : Promise.reject(new Error("document is undefined"));
}
function Sz(e) {
  var t = e.href;
  return t && (t.indexOf("https://fonts.googleapis.com/css?family=Roboto") === 0 || t.indexOf("https://fonts.googleapis.com/css?family=Google+Sans+Text") === 0) ? !0 : (
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.styleSheet.cssText = "", !0) : (
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.innerHTML = "", !0) : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.innerHTML
      )
    )
  );
}
function ZG() {
  var e = document.getElementsByTagName("head")[0];
  if (e) {
    var t = e.insertBefore.bind(e);
    e.insertBefore = function(r, o) {
      return Sz(r) || Reflect.apply(t, e, [r, o]), r;
    };
    var n = e.appendChild.bind(e);
    e.appendChild = function(r) {
      return Sz(r) || Reflect.apply(n, e, [r]), r;
    };
  }
}
var dp = !1;
function qG() {
  return _o.jsx("div", {
    children: "Loading..."
  });
}
var Bk = {
  id: "script-loader",
  version: "weekly"
};
class aMe extends pe {
  constructor() {
    super(...arguments), Ee(this, "check", null), Ee(this, "state", {
      loaded: !1
    }), Ee(this, "cleanupCallback", () => {
      delete window.google.maps, this.injectScript();
    }), Ee(this, "isCleaningUp", /* @__PURE__ */ $G(function* () {
      function t(n) {
        if (!dp)
          n();
        else if (fu)
          var r = window.setInterval(function() {
            dp || (window.clearInterval(r), n());
          }, 1);
      }
      return new Promise(t);
    })), Ee(this, "cleanup", () => {
      dp = !0;
      var t = document.getElementById(this.props.id);
      t && t.parentNode && t.parentNode.removeChild(t), Array.prototype.slice.call(document.getElementsByTagName("script")).filter(function(n) {
        return typeof n.src == "string" && n.src.includes("maps.googleapis");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("link")).filter(function(n) {
        return n.href === "https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Google+Sans";
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("style")).filter(function(n) {
        return n.innerText !== void 0 && n.innerText.length > 0 && n.innerText.includes(".gm-");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      });
    }), Ee(this, "injectScript", () => {
      this.props.preventGoogleFontsLoading && ZG(), Co(!!this.props.id, 'LoadScript requires "id" prop to be a string: %s', this.props.id);
      var t = {
        id: this.props.id,
        nonce: this.props.nonce,
        url: WG(this.props)
      };
      VG(t).then(() => {
        this.props.onLoad && this.props.onLoad(), this.setState(function() {
          return {
            loaded: !0
          };
        });
      }).catch((n) => {
        this.props.onError && this.props.onError(n), console.error(`
          There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(this.props.googleMapsApiKey || "-", ") or Client ID (").concat(this.props.googleMapsClientId || "-", `) to <LoadScript />
          Otherwise it is a Network issue.
        `));
      });
    }), Ee(this, "getRef", (t) => {
      this.check = t;
    });
  }
  componentDidMount() {
    if (fu) {
      if (window.google && window.google.maps && !dp) {
        console.error("google api is already presented");
        return;
      }
      this.isCleaningUp().then(this.injectScript).catch(function(t) {
        console.error("Error at injecting script after cleaning up: ", t);
      });
    }
  }
  componentDidUpdate(t) {
    this.props.libraries !== t.libraries && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), fu && t.language !== this.props.language && (this.cleanup(), this.setState(function() {
      return {
        loaded: !1
      };
    }, this.cleanupCallback));
  }
  componentWillUnmount() {
    if (fu) {
      this.cleanup();
      var t = () => {
        this.check || (delete window.google, dp = !1);
      };
      window.setTimeout(t, 1), this.props.onUnmount && this.props.onUnmount();
    }
  }
  render() {
    return _o.jsxs(_o.Fragment, {
      children: [_o.jsx("div", {
        ref: this.getRef
      }), this.state.loaded ? this.props.children : this.props.loadingElement || _o.jsx(qG, {})]
    });
  }
}
Ee(aMe, "defaultProps", Bk);
function lMe(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.includes(r)) continue;
    n[r] = e[r];
  }
  return n;
}
function D_(e, t) {
  if (e == null) return {};
  var n, r, o = lMe(e, t);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (r = 0; r < i.length; r++) n = i[r], t.includes(n) || {}.propertyIsEnumerable.call(e, n) && (o[n] = e[n]);
  }
  return o;
}
var Mz;
function uMe(e) {
  var {
    id: t = Bk.id,
    version: n = Bk.version,
    nonce: r,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    preventGoogleFontsLoading: u,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  } = e, g = ut(!1), [f, m] = k(!1), [v, E] = k(void 0);
  h(function() {
    return g.current = !0, () => {
      g.current = !1;
    };
  }, []), h(function() {
    fu && u && ZG();
  }, [u]), h(function() {
    f && Co(!!window.google, "useLoadScript was marked as loaded, but window.google is not present. Something went wrong.");
  }, [f]);
  var w = WG({
    version: n,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  });
  h(function() {
    if (!fu)
      return;
    function O() {
      g.current && (m(!0), Mz = w);
    }
    if (window.google && window.google.maps && Mz === w) {
      O();
      return;
    }
    VG({
      id: t,
      url: w,
      nonce: r
    }).then(O).catch(function(y) {
      g.current && E(y), console.warn(`
        There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(o || "-", ") or Client ID (").concat(i || "-", `)
        Otherwise it is a Network issue.
      `)), console.error(y);
    });
  }, [t, w, r]);
  var M = ut(void 0);
  return h(function() {
    M.current && l !== M.current && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), M.current = l;
  }, [l]), {
    isLoaded: f,
    loadError: v,
    url: w
  };
}
var cMe = ["loadingElement", "onLoad", "onError", "onUnmount", "children"], pMe = _o.jsx(qG, {});
function dMe(e) {
  var {
    loadingElement: t,
    onLoad: n,
    onError: r,
    onUnmount: o,
    children: i
  } = e, a = D_(e, cMe), {
    isLoaded: s,
    loadError: l
  } = uMe(a);
  return h(function() {
    s && typeof n == "function" && n();
  }, [s, n]), h(function() {
    l && typeof r == "function" && r(l);
  }, [l, r]), h(function() {
    return () => {
      o && o();
    };
  }, [o]), s ? i : t || pMe;
}
ve(dMe);
var Dz;
(function(e) {
  e[e.INITIALIZED = 0] = "INITIALIZED", e[e.LOADING = 1] = "LOADING", e[e.SUCCESS = 2] = "SUCCESS", e[e.FAILURE = 3] = "FAILURE";
})(Dz || (Dz = {}));
function Tz(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ry(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Tz(Object(n), !0).forEach(function(r) {
      Ee(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Tz(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var jz = {}, Az = {
  options(e, t) {
    e.setOptions(t);
  }
};
function fMe(e) {
  var {
    options: t,
    onLoad: n,
    onUnmount: r
  } = e, o = ge(It), [i, a] = k(null);
  return h(() => {
    i !== null && i.setMap(o);
  }, [o]), h(() => {
    t && i !== null && i.setOptions(t);
  }, [i, t]), h(() => {
    var s = new google.maps.TrafficLayer(ry(ry({}, t), {}, {
      map: o
    }));
    return a(s), n && n(s), () => {
      i !== null && (r && r(i), i.setMap(null));
    };
  }, []), null;
}
ve(fMe);
class hMe extends pe {
  constructor() {
    super(...arguments), Ee(this, "state", {
      trafficLayer: null
    }), Ee(this, "setTrafficLayerCallback", () => {
      this.state.trafficLayer !== null && this.props.onLoad && this.props.onLoad(this.state.trafficLayer);
    }), Ee(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = new google.maps.TrafficLayer(ry(ry({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = cn({
      updaterMap: Az,
      eventMap: jz,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        trafficLayer: t
      };
    }, this.setTrafficLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.trafficLayer !== null && (mn(this.registeredEvents), this.registeredEvents = cn({
      updaterMap: Az,
      eventMap: jz,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.trafficLayer
    }));
  }
  componentWillUnmount() {
    this.state.trafficLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.trafficLayer), mn(this.registeredEvents), this.state.trafficLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Ee(hMe, "contextType", It);
function gMe(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = ge(It), [o, i] = k(null);
  return h(() => {
    o !== null && o.setMap(r);
  }, [r]), h(() => {
    var a = new google.maps.BicyclingLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      a !== null && (n && n(a), a.setMap(null));
    };
  }, []), null;
}
ve(gMe);
class mMe extends pe {
  constructor() {
    super(...arguments), Ee(this, "state", {
      bicyclingLayer: null
    }), Ee(this, "setBicyclingLayerCallback", () => {
      this.state.bicyclingLayer !== null && (this.state.bicyclingLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.bicyclingLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.BicyclingLayer();
    this.setState(() => ({
      bicyclingLayer: t
    }), this.setBicyclingLayerCallback);
  }
  componentWillUnmount() {
    this.state.bicyclingLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.bicyclingLayer), this.state.bicyclingLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Ee(mMe, "contextType", It);
function vMe(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = ge(It), [o, i] = k(null);
  return h(() => {
    o !== null && o.setMap(r);
  }, [r]), h(() => {
    var a = new google.maps.TransitLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      o !== null && (n && n(o), o.setMap(null));
    };
  }, []), null;
}
ve(vMe);
class yMe extends pe {
  constructor() {
    super(...arguments), Ee(this, "state", {
      transitLayer: null
    }), Ee(this, "setTransitLayerCallback", () => {
      this.state.transitLayer !== null && (this.state.transitLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.transitLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.TransitLayer();
    this.setState(function() {
      return {
        transitLayer: t
      };
    }, this.setTransitLayerCallback);
  }
  componentWillUnmount() {
    this.state.transitLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.transitLayer), this.state.transitLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Ee(yMe, "contextType", It);
function Iz(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function oy(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Iz(Object(n), !0).forEach(function(r) {
      Ee(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Iz(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Rz = {
  onCircleComplete: "circlecomplete",
  onMarkerComplete: "markercomplete",
  onOverlayComplete: "overlaycomplete",
  onPolygonComplete: "polygoncomplete",
  onPolylineComplete: "polylinecomplete",
  onRectangleComplete: "rectanglecomplete"
}, Bz = {
  drawingMode(e, t) {
    e.setDrawingMode(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function bMe(e) {
  var {
    options: t,
    drawingMode: n,
    onCircleComplete: r,
    onMarkerComplete: o,
    onOverlayComplete: i,
    onPolygonComplete: a,
    onPolylineComplete: s,
    onRectangleComplete: l,
    onLoad: u,
    onUnmount: c
  } = e, p = ge(It), [d, g] = k(null), [f, m] = k(null), [v, E] = k(null), [w, M] = k(null), [O, y] = k(null), [C, _] = k(null), [F, L] = k(null);
  return h(() => {
    d !== null && d.setMap(p);
  }, [p]), h(() => {
    t && d !== null && d.setOptions(t);
  }, [d, t]), h(() => {
    d !== null && d.setDrawingMode(n ?? null);
  }, [d, n]), h(() => {
    d && r && (f !== null && google.maps.event.removeListener(f), m(google.maps.event.addListener(d, "circlecomplete", r)));
  }, [d, r]), h(() => {
    d && o && (v !== null && google.maps.event.removeListener(v), E(google.maps.event.addListener(d, "markercomplete", o)));
  }, [d, o]), h(() => {
    d && i && (w !== null && google.maps.event.removeListener(w), M(google.maps.event.addListener(d, "overlaycomplete", i)));
  }, [d, i]), h(() => {
    d && a && (O !== null && google.maps.event.removeListener(O), y(google.maps.event.addListener(d, "polygoncomplete", a)));
  }, [d, a]), h(() => {
    d && s && (C !== null && google.maps.event.removeListener(C), _(google.maps.event.addListener(d, "polylinecomplete", s)));
  }, [d, s]), h(() => {
    d && l && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(d, "rectanglecomplete", l)));
  }, [d, l]), h(() => {
    Co(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
    var N = new google.maps.drawing.DrawingManager(oy(oy({}, t), {}, {
      map: p
    }));
    return n && N.setDrawingMode(n), r && m(google.maps.event.addListener(N, "circlecomplete", r)), o && E(google.maps.event.addListener(N, "markercomplete", o)), i && M(google.maps.event.addListener(N, "overlaycomplete", i)), a && y(google.maps.event.addListener(N, "polygoncomplete", a)), s && _(google.maps.event.addListener(N, "polylinecomplete", s)), l && L(google.maps.event.addListener(N, "rectanglecomplete", l)), g(N), u && u(N), () => {
      d !== null && (f && google.maps.event.removeListener(f), v && google.maps.event.removeListener(v), w && google.maps.event.removeListener(w), O && google.maps.event.removeListener(O), C && google.maps.event.removeListener(C), F && google.maps.event.removeListener(F), c && c(d), d.setMap(null));
    };
  }, []), null;
}
ve(bMe);
class wMe extends pe {
  constructor(t) {
    super(t), Ee(this, "registeredEvents", []), Ee(this, "state", {
      drawingManager: null
    }), Ee(this, "setDrawingManagerCallback", () => {
      this.state.drawingManager !== null && this.props.onLoad && this.props.onLoad(this.state.drawingManager);
    }), Co(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
  }
  componentDidMount() {
    var t = new google.maps.drawing.DrawingManager(oy(oy({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = cn({
      updaterMap: Bz,
      eventMap: Rz,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        drawingManager: t
      };
    }, this.setDrawingManagerCallback);
  }
  componentDidUpdate(t) {
    this.state.drawingManager !== null && (mn(this.registeredEvents), this.registeredEvents = cn({
      updaterMap: Bz,
      eventMap: Rz,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.drawingManager
    }));
  }
  componentWillUnmount() {
    this.state.drawingManager !== null && (this.props.onUnmount && this.props.onUnmount(this.state.drawingManager), mn(this.registeredEvents), this.state.drawingManager.setMap(null));
  }
  render() {
    return null;
  }
}
Ee(wMe, "contextType", It);
function Nz(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function sc(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Nz(Object(n), !0).forEach(function(r) {
      Ee(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Nz(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Fz = {
  onAnimationChanged: "animation_changed",
  onClick: "click",
  onClickableChanged: "clickable_changed",
  onCursorChanged: "cursor_changed",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDraggableChanged: "draggable_changed",
  onDragStart: "dragstart",
  onFlatChanged: "flat_changed",
  onIconChanged: "icon_changed",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onPositionChanged: "position_changed",
  onRightClick: "rightclick",
  onShapeChanged: "shape_changed",
  onTitleChanged: "title_changed",
  onVisibleChanged: "visible_changed",
  onZindexChanged: "zindex_changed"
}, zz = {
  animation(e, t) {
    e.setAnimation(t);
  },
  clickable(e, t) {
    e.setClickable(t);
  },
  cursor(e, t) {
    e.setCursor(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  icon(e, t) {
    e.setIcon(t);
  },
  label(e, t) {
    e.setLabel(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  opacity(e, t) {
    e.setOpacity(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  shape(e, t) {
    e.setShape(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, iy = {};
function CMe(e) {
  var {
    position: t,
    options: n,
    clusterer: r,
    noClustererRedraw: o,
    children: i,
    draggable: a,
    visible: s,
    animation: l,
    clickable: u,
    cursor: c,
    icon: p,
    label: d,
    opacity: g,
    shape: f,
    title: m,
    zIndex: v,
    onClick: E,
    onDblClick: w,
    onDrag: M,
    onDragEnd: O,
    onDragStart: y,
    onMouseOut: C,
    onMouseOver: _,
    onMouseUp: F,
    onMouseDown: L,
    onRightClick: N,
    onClickableChanged: R,
    onCursorChanged: W,
    onAnimationChanged: V,
    onDraggableChanged: z,
    onFlatChanged: Z,
    onIconChanged: K,
    onPositionChanged: X,
    onShapeChanged: te,
    onTitleChanged: J,
    onVisibleChanged: P,
    onZindexChanged: D,
    onLoad: H,
    onUnmount: S
  } = e, $ = ge(It), [x, j] = k(null), [U, T] = k(null), [q, A] = k(null), [Y, B] = k(null), [ue, fe] = k(null), [oe, Ae] = k(null), [Ze, Ge] = k(null), [Ie, et] = k(null), [Ye, _e] = k(null), [Qe, at] = k(null), [Pe, Me] = k(null), [Je, We] = k(null), [Re, nt] = k(null), [De, yt] = k(null), [ot, st] = k(null), [ct, bt] = k(null), [pt, dt] = k(null), [tt, Xe] = k(null), [wt, Ct] = k(null), [ft, bn] = k(null), [ht, wn] = k(null), [gt, Mt] = k(null);
  h(() => {
    x !== null && x.setMap($);
  }, [$]), h(() => {
    typeof n < "u" && x !== null && x.setOptions(n);
  }, [x, n]), h(() => {
    typeof a < "u" && x !== null && x.setDraggable(a);
  }, [x, a]), h(() => {
    t && x !== null && x.setPosition(t);
  }, [x, t]), h(() => {
    typeof s < "u" && x !== null && x.setVisible(s);
  }, [x, s]), h(() => {
    x == null || x.setAnimation(l);
  }, [x, l]), h(() => {
    x && u !== void 0 && x.setClickable(u);
  }, [x, u]), h(() => {
    x && c !== void 0 && x.setCursor(c);
  }, [x, c]), h(() => {
    x && p !== void 0 && x.setIcon(p);
  }, [x, p]), h(() => {
    x && d !== void 0 && x.setLabel(d);
  }, [x, d]), h(() => {
    x && g !== void 0 && x.setOpacity(g);
  }, [x, g]), h(() => {
    x && f !== void 0 && x.setShape(f);
  }, [x, f]), h(() => {
    x && m !== void 0 && x.setTitle(m);
  }, [x, m]), h(() => {
    x && v !== void 0 && x.setZIndex(v);
  }, [x, v]), h(() => {
    x && w && (U !== null && google.maps.event.removeListener(U), T(google.maps.event.addListener(x, "dblclick", w)));
  }, [w]), h(() => {
    x && O && (q !== null && google.maps.event.removeListener(q), A(google.maps.event.addListener(x, "dragend", O)));
  }, [O]), h(() => {
    x && y && (Y !== null && google.maps.event.removeListener(Y), B(google.maps.event.addListener(x, "dragstart", y)));
  }, [y]), h(() => {
    x && L && (ue !== null && google.maps.event.removeListener(ue), fe(google.maps.event.addListener(x, "mousedown", L)));
  }, [L]), h(() => {
    x && C && (oe !== null && google.maps.event.removeListener(oe), Ae(google.maps.event.addListener(x, "mouseout", C)));
  }, [C]), h(() => {
    x && _ && (Ze !== null && google.maps.event.removeListener(Ze), Ge(google.maps.event.addListener(x, "mouseover", _)));
  }, [_]), h(() => {
    x && F && (Ie !== null && google.maps.event.removeListener(Ie), et(google.maps.event.addListener(x, "mouseup", F)));
  }, [F]), h(() => {
    x && N && (Ye !== null && google.maps.event.removeListener(Ye), _e(google.maps.event.addListener(x, "rightclick", N)));
  }, [N]), h(() => {
    x && E && (Qe !== null && google.maps.event.removeListener(Qe), at(google.maps.event.addListener(x, "click", E)));
  }, [E]), h(() => {
    x && M && (Pe !== null && google.maps.event.removeListener(Pe), Me(google.maps.event.addListener(x, "drag", M)));
  }, [M]), h(() => {
    x && R && (Je !== null && google.maps.event.removeListener(Je), We(google.maps.event.addListener(x, "clickable_changed", R)));
  }, [R]), h(() => {
    x && W && (Re !== null && google.maps.event.removeListener(Re), nt(google.maps.event.addListener(x, "cursor_changed", W)));
  }, [W]), h(() => {
    x && V && (De !== null && google.maps.event.removeListener(De), yt(google.maps.event.addListener(x, "animation_changed", V)));
  }, [V]), h(() => {
    x && z && (ot !== null && google.maps.event.removeListener(ot), st(google.maps.event.addListener(x, "draggable_changed", z)));
  }, [z]), h(() => {
    x && Z && (ct !== null && google.maps.event.removeListener(ct), bt(google.maps.event.addListener(x, "flat_changed", Z)));
  }, [Z]), h(() => {
    x && K && (pt !== null && google.maps.event.removeListener(pt), dt(google.maps.event.addListener(x, "icon_changed", K)));
  }, [K]), h(() => {
    x && X && (tt !== null && google.maps.event.removeListener(tt), Xe(google.maps.event.addListener(x, "position_changed", X)));
  }, [X]), h(() => {
    x && te && (wt !== null && google.maps.event.removeListener(wt), Ct(google.maps.event.addListener(x, "shape_changed", te)));
  }, [te]), h(() => {
    x && J && (ft !== null && google.maps.event.removeListener(ft), bn(google.maps.event.addListener(x, "title_changed", J)));
  }, [J]), h(() => {
    x && P && (ht !== null && google.maps.event.removeListener(ht), wn(google.maps.event.addListener(x, "visible_changed", P)));
  }, [P]), h(() => {
    x && D && (gt !== null && google.maps.event.removeListener(gt), Mt(google.maps.event.addListener(x, "zindex_changed", D)));
  }, [D]), h(() => {
    var mt = sc(sc(sc({}, n || iy), r ? iy : {
      map: $
    }), {}, {
      position: t
    }), re = new google.maps.Marker(mt);
    return r ? r.addMarker(re, !!o) : re.setMap($), t && re.setPosition(t), typeof s < "u" && re.setVisible(s), typeof a < "u" && re.setDraggable(a), typeof u < "u" && re.setClickable(u), typeof c == "string" && re.setCursor(c), p && re.setIcon(p), typeof d < "u" && re.setLabel(d), typeof g < "u" && re.setOpacity(g), f && re.setShape(f), typeof m == "string" && re.setTitle(m), typeof v == "number" && re.setZIndex(v), w && T(google.maps.event.addListener(re, "dblclick", w)), O && A(google.maps.event.addListener(re, "dragend", O)), y && B(google.maps.event.addListener(re, "dragstart", y)), L && fe(google.maps.event.addListener(re, "mousedown", L)), C && Ae(google.maps.event.addListener(re, "mouseout", C)), _ && Ge(google.maps.event.addListener(re, "mouseover", _)), F && et(google.maps.event.addListener(re, "mouseup", F)), N && _e(google.maps.event.addListener(re, "rightclick", N)), E && at(google.maps.event.addListener(re, "click", E)), M && Me(google.maps.event.addListener(re, "drag", M)), R && We(google.maps.event.addListener(re, "clickable_changed", R)), W && nt(google.maps.event.addListener(re, "cursor_changed", W)), V && yt(google.maps.event.addListener(re, "animation_changed", V)), z && st(google.maps.event.addListener(re, "draggable_changed", z)), Z && bt(google.maps.event.addListener(re, "flat_changed", Z)), K && dt(google.maps.event.addListener(re, "icon_changed", K)), X && Xe(google.maps.event.addListener(re, "position_changed", X)), te && Ct(google.maps.event.addListener(re, "shape_changed", te)), J && bn(google.maps.event.addListener(re, "title_changed", J)), P && wn(google.maps.event.addListener(re, "visible_changed", P)), D && Mt(google.maps.event.addListener(re, "zindex_changed", D)), j(re), H && H(re), () => {
      U !== null && google.maps.event.removeListener(U), q !== null && google.maps.event.removeListener(q), Y !== null && google.maps.event.removeListener(Y), ue !== null && google.maps.event.removeListener(ue), oe !== null && google.maps.event.removeListener(oe), Ze !== null && google.maps.event.removeListener(Ze), Ie !== null && google.maps.event.removeListener(Ie), Ye !== null && google.maps.event.removeListener(Ye), Qe !== null && google.maps.event.removeListener(Qe), Je !== null && google.maps.event.removeListener(Je), Re !== null && google.maps.event.removeListener(Re), De !== null && google.maps.event.removeListener(De), ot !== null && google.maps.event.removeListener(ot), ct !== null && google.maps.event.removeListener(ct), pt !== null && google.maps.event.removeListener(pt), tt !== null && google.maps.event.removeListener(tt), ft !== null && google.maps.event.removeListener(ft), ht !== null && google.maps.event.removeListener(ht), gt !== null && google.maps.event.removeListener(gt), S && S(re), r ? r.removeMarker(re, !!o) : re && re.setMap(null);
    };
  }, []);
  var ir = Cn(() => i ? lt.map(i, (mt) => {
    if (!yi(mt))
      return mt;
    var re = mt;
    return bi(re, {
      anchor: x
    });
  }) : null, [i, x]);
  return _o.jsx(_o.Fragment, {
    children: ir
  }) || null;
}
ve(CMe);
class xMe extends pe {
  constructor() {
    super(...arguments), Ee(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this;
    return $G(function* () {
      var n = sc(sc(sc({}, t.props.options || iy), t.props.clusterer ? iy : {
        map: t.context
      }), {}, {
        position: t.props.position
      });
      t.marker = new google.maps.Marker(n), t.props.clusterer ? t.props.clusterer.addMarker(t.marker, !!t.props.noClustererRedraw) : t.marker.setMap(t.context), t.registeredEvents = cn({
        updaterMap: zz,
        eventMap: Fz,
        prevProps: {},
        nextProps: t.props,
        instance: t.marker
      }), t.props.onLoad && t.props.onLoad(t.marker);
    })();
  }
  componentDidUpdate(t) {
    this.marker && (mn(this.registeredEvents), this.registeredEvents = cn({
      updaterMap: zz,
      eventMap: Fz,
      prevProps: t,
      nextProps: this.props,
      instance: this.marker
    }));
  }
  componentWillUnmount() {
    this.marker && (this.props.onUnmount && this.props.onUnmount(this.marker), mn(this.registeredEvents), this.props.clusterer ? this.props.clusterer.removeMarker(this.marker, !!this.props.noClustererRedraw) : this.marker && this.marker.setMap(null));
  }
  render() {
    var t = this.props.children ? lt.map(this.props.children, (n) => {
      if (!yi(n))
        return n;
      var r = n;
      return bi(r, {
        anchor: this.marker
      });
    }) : null;
    return t || null;
  }
}
Ee(xMe, "contextType", It);
var OMe = (
  /** @class */
  function() {
    function e(t, n) {
      t.getClusterer().extend(e, google.maps.OverlayView), this.cluster = t, this.clusterClassName = this.cluster.getClusterer().getClusterClass(), this.className = this.clusterClassName, this.styles = n, this.center = void 0, this.div = null, this.sums = null, this.visible = !1, this.boundsChangedListener = null, this.url = "", this.height = 0, this.width = 0, this.anchorText = [0, 0], this.anchorIcon = [0, 0], this.textColor = "black", this.textSize = 11, this.textDecoration = "none", this.fontWeight = "bold", this.fontStyle = "normal", this.fontFamily = "Arial,sans-serif", this.backgroundPosition = "0 0", this.cMouseDownInCluster = null, this.cDraggingMapByCluster = null, this.timeOut = null, this.setMap(t.getMap()), this.onBoundsChanged = this.onBoundsChanged.bind(this), this.onMouseDown = this.onMouseDown.bind(this), this.onClick = this.onClick.bind(this), this.onMouseOver = this.onMouseOver.bind(this), this.onMouseOut = this.onMouseOut.bind(this), this.onAdd = this.onAdd.bind(this), this.onRemove = this.onRemove.bind(this), this.draw = this.draw.bind(this), this.hide = this.hide.bind(this), this.show = this.show.bind(this), this.useStyle = this.useStyle.bind(this), this.setCenter = this.setCenter.bind(this), this.getPosFromLatLng = this.getPosFromLatLng.bind(this);
    }
    return e.prototype.onBoundsChanged = function() {
      this.cDraggingMapByCluster = this.cMouseDownInCluster;
    }, e.prototype.onMouseDown = function() {
      this.cMouseDownInCluster = !0, this.cDraggingMapByCluster = !1;
    }, e.prototype.onClick = function(t) {
      if (this.cMouseDownInCluster = !1, !this.cDraggingMapByCluster) {
        var n = this.cluster.getClusterer();
        if (google.maps.event.trigger(n, "click", this.cluster), google.maps.event.trigger(n, "clusterclick", this.cluster), n.getZoomOnClick()) {
          var r = n.getMaxZoom(), o = this.cluster.getBounds(), i = n.getMap();
          i !== null && "fitBounds" in i && i.fitBounds(o), this.timeOut = window.setTimeout(function() {
            var a = n.getMap();
            if (a !== null) {
              "fitBounds" in a && a.fitBounds(o);
              var s = a.getZoom() || 0;
              r !== null && s > r && a.setZoom(r + 1);
            }
          }, 100);
        }
        t.cancelBubble = !0, t.stopPropagation && t.stopPropagation();
      }
    }, e.prototype.onMouseOver = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseover", this.cluster);
    }, e.prototype.onMouseOut = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseout", this.cluster);
    }, e.prototype.onAdd = function() {
      var t;
      this.div = document.createElement("div"), this.div.className = this.className, this.visible && this.show(), (t = this.getPanes()) === null || t === void 0 || t.overlayMouseTarget.appendChild(this.div);
      var n = this.getMap();
      n !== null && (this.boundsChangedListener = google.maps.event.addListener(n, "bounds_changed", this.onBoundsChanged), this.div.addEventListener("mousedown", this.onMouseDown), this.div.addEventListener("click", this.onClick), this.div.addEventListener("mouseover", this.onMouseOver), this.div.addEventListener("mouseout", this.onMouseOut));
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.hide(), this.boundsChangedListener !== null && google.maps.event.removeListener(this.boundsChangedListener), this.div.removeEventListener("mousedown", this.onMouseDown), this.div.removeEventListener("click", this.onClick), this.div.removeEventListener("mouseover", this.onMouseOver), this.div.removeEventListener("mouseout", this.onMouseOut), this.div.parentNode.removeChild(this.div), this.timeOut !== null && (window.clearTimeout(this.timeOut), this.timeOut = null), this.div = null);
    }, e.prototype.draw = function() {
      if (this.visible && this.div !== null && this.center) {
        var t = this.getPosFromLatLng(this.center);
        this.div.style.top = t !== null ? "".concat(t.y, "px") : "0", this.div.style.left = t !== null ? "".concat(t.x, "px") : "0";
      }
    }, e.prototype.hide = function() {
      this.div && (this.div.style.display = "none"), this.visible = !1;
    }, e.prototype.show = function() {
      var t, n, r, o, i, a;
      if (this.div && this.center) {
        var s = this.sums === null || typeof this.sums.title > "u" || this.sums.title === "" ? this.cluster.getClusterer().getTitle() : this.sums.title, l = this.backgroundPosition.split(" "), u = parseInt(((t = l[0]) === null || t === void 0 ? void 0 : t.replace(/^\s+|\s+$/g, "")) || "0", 10), c = parseInt(((n = l[1]) === null || n === void 0 ? void 0 : n.replace(/^\s+|\s+$/g, "")) || "0", 10), p = this.getPosFromLatLng(this.center);
        this.div.className = this.className, this.div.setAttribute("style", "cursor: pointer; position: absolute; top: ".concat(p !== null ? "".concat(p.y, "px") : "0", "; left: ").concat(p !== null ? "".concat(p.x, "px") : "0", "; width: ").concat(this.width, "px; height: ").concat(this.height, "px; "));
        var d = document.createElement("img");
        d.alt = s, d.src = this.url, d.width = this.width, d.height = this.height, d.setAttribute("style", "position: absolute; top: ".concat(c, "px; left: ").concat(u, "px")), this.cluster.getClusterer().enableRetinaIcons || (d.style.clip = "rect(-".concat(c, "px, -").concat(u + this.width, "px, -").concat(c + this.height, ", -").concat(u, ")"));
        var g = document.createElement("div");
        g.setAttribute("style", "position: absolute; top: ".concat(this.anchorText[0], "px; left: ").concat(this.anchorText[1], "px; color: ").concat(this.textColor, "; font-size: ").concat(this.textSize, "px; font-family: ").concat(this.fontFamily, "; font-weight: ").concat(this.fontWeight, "; fontStyle: ").concat(this.fontStyle, "; text-decoration: ").concat(this.textDecoration, "; text-align: center; width: ").concat(this.width, "px; line-height: ").concat(this.height, "px")), !((r = this.sums) === null || r === void 0) && r.text && (g.innerText = "".concat((o = this.sums) === null || o === void 0 ? void 0 : o.text)), !((i = this.sums) === null || i === void 0) && i.html && (g.innerHTML = "".concat((a = this.sums) === null || a === void 0 ? void 0 : a.html)), this.div.innerHTML = "", this.div.appendChild(d), this.div.appendChild(g), this.div.title = s, this.div.style.display = "";
      }
      this.visible = !0;
    }, e.prototype.useStyle = function(t) {
      this.sums = t;
      var n = this.cluster.getClusterer().getStyles(), r = n[Math.min(n.length - 1, Math.max(0, t.index - 1))];
      r && (this.url = r.url, this.height = r.height, this.width = r.width, r.className && (this.className = "".concat(this.clusterClassName, " ").concat(r.className)), this.anchorText = r.anchorText || [0, 0], this.anchorIcon = r.anchorIcon || [this.height / 2, this.width / 2], this.textColor = r.textColor || "black", this.textSize = r.textSize || 11, this.textDecoration = r.textDecoration || "none", this.fontWeight = r.fontWeight || "bold", this.fontStyle = r.fontStyle || "normal", this.fontFamily = r.fontFamily || "Arial,sans-serif", this.backgroundPosition = r.backgroundPosition || "0 0");
    }, e.prototype.setCenter = function(t) {
      this.center = t;
    }, e.prototype.getPosFromLatLng = function(t) {
      var n = this.getProjection().fromLatLngToDivPixel(t);
      return n !== null && (n.x -= this.anchorIcon[1], n.y -= this.anchorIcon[0]), n;
    }, e;
  }()
), EMe = (
  /** @class */
  function() {
    function e(t) {
      this.markerClusterer = t, this.map = this.markerClusterer.getMap(), this.gridSize = this.markerClusterer.getGridSize(), this.minClusterSize = this.markerClusterer.getMinimumClusterSize(), this.averageCenter = this.markerClusterer.getAverageCenter(), this.markers = [], this.center = void 0, this.bounds = null, this.clusterIcon = new OMe(this, this.markerClusterer.getStyles()), this.getSize = this.getSize.bind(this), this.getMarkers = this.getMarkers.bind(this), this.getCenter = this.getCenter.bind(this), this.getMap = this.getMap.bind(this), this.getClusterer = this.getClusterer.bind(this), this.getBounds = this.getBounds.bind(this), this.remove = this.remove.bind(this), this.addMarker = this.addMarker.bind(this), this.isMarkerInClusterBounds = this.isMarkerInClusterBounds.bind(this), this.calculateBounds = this.calculateBounds.bind(this), this.updateIcon = this.updateIcon.bind(this), this.isMarkerAlreadyAdded = this.isMarkerAlreadyAdded.bind(this);
    }
    return e.prototype.getSize = function() {
      return this.markers.length;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getCenter = function() {
      return this.center;
    }, e.prototype.getMap = function() {
      return this.map;
    }, e.prototype.getClusterer = function() {
      return this.markerClusterer;
    }, e.prototype.getBounds = function() {
      for (var t = new google.maps.LatLngBounds(this.center, this.center), n = this.getMarkers(), r = 0, o = n; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && t.extend(a);
      }
      return t;
    }, e.prototype.remove = function() {
      this.clusterIcon.setMap(null), this.markers = [], delete this.markers;
    }, e.prototype.addMarker = function(t) {
      var n;
      if (this.isMarkerAlreadyAdded(t))
        return !1;
      if (this.center) {
        if (this.averageCenter) {
          var r = t.getPosition();
          if (r) {
            var o = this.markers.length + 1;
            this.center = new google.maps.LatLng((this.center.lat() * (o - 1) + r.lat()) / o, (this.center.lng() * (o - 1) + r.lng()) / o), this.calculateBounds();
          }
        }
      } else {
        var r = t.getPosition();
        r && (this.center = r, this.calculateBounds());
      }
      t.isAdded = !0, this.markers.push(t);
      var i = this.markers.length, a = this.markerClusterer.getMaxZoom(), s = (n = this.map) === null || n === void 0 ? void 0 : n.getZoom();
      if (a !== null && typeof s < "u" && s > a)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i < this.minClusterSize)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i === this.minClusterSize)
        for (var l = 0, u = this.markers; l < u.length; l++) {
          var c = u[l];
          c.setMap(null);
        }
      else
        t.setMap(null);
      return !0;
    }, e.prototype.isMarkerInClusterBounds = function(t) {
      if (this.bounds !== null) {
        var n = t.getPosition();
        if (n)
          return this.bounds.contains(n);
      }
      return !1;
    }, e.prototype.calculateBounds = function() {
      this.bounds = this.markerClusterer.getExtendedBounds(new google.maps.LatLngBounds(this.center, this.center));
    }, e.prototype.updateIcon = function() {
      var t, n = this.markers.length, r = this.markerClusterer.getMaxZoom(), o = (t = this.map) === null || t === void 0 ? void 0 : t.getZoom();
      if (r !== null && typeof o < "u" && o > r) {
        this.clusterIcon.hide();
        return;
      }
      if (n < this.minClusterSize) {
        this.clusterIcon.hide();
        return;
      }
      this.center && this.clusterIcon.setCenter(this.center), this.clusterIcon.useStyle(this.markerClusterer.getCalculator()(this.markers, this.markerClusterer.getStyles().length)), this.clusterIcon.show();
    }, e.prototype.isMarkerAlreadyAdded = function(t) {
      if (this.markers.includes)
        return this.markers.includes(t);
      for (var n = 0; n < this.markers.length; n++)
        if (t === this.markers[n])
          return !0;
      return !1;
    }, e;
  }()
);
function kMe(e, t) {
  var n = e.length, r = n.toString().length, o = Math.min(r, t);
  return {
    text: n.toString(),
    index: o,
    title: ""
  };
}
var LMe = 2e3, PMe = 500, _Me = "https://developers.google.com/maps/documentation/javascript/examples/markerclusterer/m", SMe = "png", MMe = [53, 56, 66, 78, 90], DMe = "cluster", GG = (
  /** @class */
  function() {
    function e(t, n, r) {
      n === void 0 && (n = []), r === void 0 && (r = {}), this.getMinimumClusterSize = this.getMinimumClusterSize.bind(this), this.setMinimumClusterSize = this.setMinimumClusterSize.bind(this), this.getEnableRetinaIcons = this.getEnableRetinaIcons.bind(this), this.setEnableRetinaIcons = this.setEnableRetinaIcons.bind(this), this.addToClosestCluster = this.addToClosestCluster.bind(this), this.getImageExtension = this.getImageExtension.bind(this), this.setImageExtension = this.setImageExtension.bind(this), this.getExtendedBounds = this.getExtendedBounds.bind(this), this.getAverageCenter = this.getAverageCenter.bind(this), this.setAverageCenter = this.setAverageCenter.bind(this), this.getTotalClusters = this.getTotalClusters.bind(this), this.fitMapToMarkers = this.fitMapToMarkers.bind(this), this.getIgnoreHidden = this.getIgnoreHidden.bind(this), this.setIgnoreHidden = this.setIgnoreHidden.bind(this), this.getClusterClass = this.getClusterClass.bind(this), this.setClusterClass = this.setClusterClass.bind(this), this.getTotalMarkers = this.getTotalMarkers.bind(this), this.getZoomOnClick = this.getZoomOnClick.bind(this), this.setZoomOnClick = this.setZoomOnClick.bind(this), this.getBatchSizeIE = this.getBatchSizeIE.bind(this), this.setBatchSizeIE = this.setBatchSizeIE.bind(this), this.createClusters = this.createClusters.bind(this), this.onZoomChanged = this.onZoomChanged.bind(this), this.getImageSizes = this.getImageSizes.bind(this), this.setImageSizes = this.setImageSizes.bind(this), this.getCalculator = this.getCalculator.bind(this), this.setCalculator = this.setCalculator.bind(this), this.removeMarkers = this.removeMarkers.bind(this), this.resetViewport = this.resetViewport.bind(this), this.getImagePath = this.getImagePath.bind(this), this.setImagePath = this.setImagePath.bind(this), this.pushMarkerTo = this.pushMarkerTo.bind(this), this.removeMarker = this.removeMarker.bind(this), this.clearMarkers = this.clearMarkers.bind(this), this.setupStyles = this.setupStyles.bind(this), this.getGridSize = this.getGridSize.bind(this), this.setGridSize = this.setGridSize.bind(this), this.getClusters = this.getClusters.bind(this), this.getMaxZoom = this.getMaxZoom.bind(this), this.setMaxZoom = this.setMaxZoom.bind(this), this.getMarkers = this.getMarkers.bind(this), this.addMarkers = this.addMarkers.bind(this), this.getStyles = this.getStyles.bind(this), this.setStyles = this.setStyles.bind(this), this.addMarker = this.addMarker.bind(this), this.onRemove = this.onRemove.bind(this), this.getTitle = this.getTitle.bind(this), this.setTitle = this.setTitle.bind(this), this.repaint = this.repaint.bind(this), this.onIdle = this.onIdle.bind(this), this.redraw = this.redraw.bind(this), this.onAdd = this.onAdd.bind(this), this.draw = this.draw.bind(this), this.extend = this.extend.bind(this), this.extend(e, google.maps.OverlayView), this.markers = [], this.clusters = [], this.listeners = [], this.activeMap = null, this.ready = !1, this.gridSize = r.gridSize || 60, this.minClusterSize = r.minimumClusterSize || 2, this.maxZoom = r.maxZoom || null, this.styles = r.styles || [], this.title = r.title || "", this.zoomOnClick = !0, r.zoomOnClick !== void 0 && (this.zoomOnClick = r.zoomOnClick), this.averageCenter = !1, r.averageCenter !== void 0 && (this.averageCenter = r.averageCenter), this.ignoreHidden = !1, r.ignoreHidden !== void 0 && (this.ignoreHidden = r.ignoreHidden), this.enableRetinaIcons = !1, r.enableRetinaIcons !== void 0 && (this.enableRetinaIcons = r.enableRetinaIcons), this.imagePath = r.imagePath || _Me, this.imageExtension = r.imageExtension || SMe, this.imageSizes = r.imageSizes || MMe, this.calculator = r.calculator || kMe, this.batchSize = r.batchSize || LMe, this.batchSizeIE = r.batchSizeIE || PMe, this.clusterClass = r.clusterClass || DMe, navigator.userAgent.toLowerCase().indexOf("msie") !== -1 && (this.batchSize = this.batchSizeIE), this.timerRefStatic = null, this.setupStyles(), this.addMarkers(n, !0), this.setMap(t);
    }
    return e.prototype.onZoomChanged = function() {
      var t, n;
      this.resetViewport(!1), (((t = this.getMap()) === null || t === void 0 ? void 0 : t.getZoom()) === (this.get("minZoom") || 0) || ((n = this.getMap()) === null || n === void 0 ? void 0 : n.getZoom()) === this.get("maxZoom")) && google.maps.event.trigger(this, "idle");
    }, e.prototype.onIdle = function() {
      this.redraw();
    }, e.prototype.onAdd = function() {
      var t = this.getMap();
      this.activeMap = t, this.ready = !0, this.repaint(), t !== null && (this.listeners = [google.maps.event.addListener(t, "zoom_changed", this.onZoomChanged), google.maps.event.addListener(t, "idle", this.onIdle)]);
    }, e.prototype.onRemove = function() {
      for (var t = 0, n = this.markers; t < n.length; t++) {
        var r = n[t];
        r.getMap() !== this.activeMap && r.setMap(this.activeMap);
      }
      for (var o = 0, i = this.clusters; o < i.length; o++) {
        var a = i[o];
        a.remove();
      }
      this.clusters = [];
      for (var s = 0, l = this.listeners; s < l.length; s++) {
        var u = l[s];
        google.maps.event.removeListener(u);
      }
      this.listeners = [], this.activeMap = null, this.ready = !1;
    }, e.prototype.draw = function() {
    }, e.prototype.getMap = function() {
      return null;
    }, e.prototype.getPanes = function() {
      return null;
    }, e.prototype.getProjection = function() {
      return {
        fromContainerPixelToLatLng: function() {
          return null;
        },
        fromDivPixelToLatLng: function() {
          return null;
        },
        fromLatLngToContainerPixel: function() {
          return null;
        },
        fromLatLngToDivPixel: function() {
          return null;
        },
        getVisibleRegion: function() {
          return null;
        },
        getWorldWidth: function() {
          return 0;
        }
      };
    }, e.prototype.setMap = function() {
    }, e.prototype.addListener = function() {
      return {
        remove: function() {
        }
      };
    }, e.prototype.bindTo = function() {
    }, e.prototype.get = function() {
    }, e.prototype.notify = function() {
    }, e.prototype.set = function() {
    }, e.prototype.setValues = function() {
    }, e.prototype.unbind = function() {
    }, e.prototype.unbindAll = function() {
    }, e.prototype.setupStyles = function() {
      if (!(this.styles.length > 0))
        for (var t = 0; t < this.imageSizes.length; t++)
          this.styles.push({
            url: "".concat(this.imagePath + (t + 1), ".").concat(this.imageExtension),
            height: this.imageSizes[t] || 0,
            width: this.imageSizes[t] || 0
          });
    }, e.prototype.fitMapToMarkers = function() {
      for (var t = this.getMarkers(), n = new google.maps.LatLngBounds(), r = 0, o = t; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && n.extend(a);
      }
      var s = this.getMap();
      s !== null && "fitBounds" in s && s.fitBounds(n);
    }, e.prototype.getGridSize = function() {
      return this.gridSize;
    }, e.prototype.setGridSize = function(t) {
      this.gridSize = t;
    }, e.prototype.getMinimumClusterSize = function() {
      return this.minClusterSize;
    }, e.prototype.setMinimumClusterSize = function(t) {
      this.minClusterSize = t;
    }, e.prototype.getMaxZoom = function() {
      return this.maxZoom;
    }, e.prototype.setMaxZoom = function(t) {
      this.maxZoom = t;
    }, e.prototype.getStyles = function() {
      return this.styles;
    }, e.prototype.setStyles = function(t) {
      this.styles = t;
    }, e.prototype.getTitle = function() {
      return this.title;
    }, e.prototype.setTitle = function(t) {
      this.title = t;
    }, e.prototype.getZoomOnClick = function() {
      return this.zoomOnClick;
    }, e.prototype.setZoomOnClick = function(t) {
      this.zoomOnClick = t;
    }, e.prototype.getAverageCenter = function() {
      return this.averageCenter;
    }, e.prototype.setAverageCenter = function(t) {
      this.averageCenter = t;
    }, e.prototype.getIgnoreHidden = function() {
      return this.ignoreHidden;
    }, e.prototype.setIgnoreHidden = function(t) {
      this.ignoreHidden = t;
    }, e.prototype.getEnableRetinaIcons = function() {
      return this.enableRetinaIcons;
    }, e.prototype.setEnableRetinaIcons = function(t) {
      this.enableRetinaIcons = t;
    }, e.prototype.getImageExtension = function() {
      return this.imageExtension;
    }, e.prototype.setImageExtension = function(t) {
      this.imageExtension = t;
    }, e.prototype.getImagePath = function() {
      return this.imagePath;
    }, e.prototype.setImagePath = function(t) {
      this.imagePath = t;
    }, e.prototype.getImageSizes = function() {
      return this.imageSizes;
    }, e.prototype.setImageSizes = function(t) {
      this.imageSizes = t;
    }, e.prototype.getCalculator = function() {
      return this.calculator;
    }, e.prototype.setCalculator = function(t) {
      this.calculator = t;
    }, e.prototype.getBatchSizeIE = function() {
      return this.batchSizeIE;
    }, e.prototype.setBatchSizeIE = function(t) {
      this.batchSizeIE = t;
    }, e.prototype.getClusterClass = function() {
      return this.clusterClass;
    }, e.prototype.setClusterClass = function(t) {
      this.clusterClass = t;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getTotalMarkers = function() {
      return this.markers.length;
    }, e.prototype.getClusters = function() {
      return this.clusters;
    }, e.prototype.getTotalClusters = function() {
      return this.clusters.length;
    }, e.prototype.addMarker = function(t, n) {
      this.pushMarkerTo(t), n || this.redraw();
    }, e.prototype.addMarkers = function(t, n) {
      for (var r in t)
        if (Object.prototype.hasOwnProperty.call(t, r)) {
          var o = t[r];
          o && this.pushMarkerTo(o);
        }
      n || this.redraw();
    }, e.prototype.pushMarkerTo = function(t) {
      var n = this;
      t.getDraggable() && google.maps.event.addListener(t, "dragend", function() {
        n.ready && (t.isAdded = !1, n.repaint());
      }), t.isAdded = !1, this.markers.push(t);
    }, e.prototype.removeMarker_ = function(t) {
      var n = -1;
      if (this.markers.indexOf)
        n = this.markers.indexOf(t);
      else
        for (var r = 0; r < this.markers.length; r++)
          if (t === this.markers[r]) {
            n = r;
            break;
          }
      return n === -1 ? !1 : (t.setMap(null), this.markers.splice(n, 1), !0);
    }, e.prototype.removeMarker = function(t, n) {
      var r = this.removeMarker_(t);
      return !n && r && this.repaint(), r;
    }, e.prototype.removeMarkers = function(t, n) {
      for (var r = !1, o = 0, i = t; o < i.length; o++) {
        var a = i[o];
        r = r || this.removeMarker_(a);
      }
      return !n && r && this.repaint(), r;
    }, e.prototype.clearMarkers = function() {
      this.resetViewport(!0), this.markers = [];
    }, e.prototype.repaint = function() {
      var t = this.clusters.slice();
      this.clusters = [], this.resetViewport(!1), this.redraw(), setTimeout(function() {
        for (var n = 0, r = t; n < r.length; n++) {
          var o = r[n];
          o.remove();
        }
      }, 0);
    }, e.prototype.getExtendedBounds = function(t) {
      var n = this.getProjection(), r = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getNorthEast().lat(), t.getNorthEast().lng())
      );
      r !== null && (r.x += this.gridSize, r.y -= this.gridSize);
      var o = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getSouthWest().lat(), t.getSouthWest().lng())
      );
      if (o !== null && (o.x -= this.gridSize, o.y += this.gridSize), r !== null) {
        var i = n.fromDivPixelToLatLng(r);
        i !== null && t.extend(i);
      }
      if (o !== null) {
        var a = n.fromDivPixelToLatLng(o);
        a !== null && t.extend(a);
      }
      return t;
    }, e.prototype.redraw = function() {
      this.createClusters(0);
    }, e.prototype.resetViewport = function(t) {
      for (var n = 0, r = this.clusters; n < r.length; n++) {
        var o = r[n];
        o.remove();
      }
      this.clusters = [];
      for (var i = 0, a = this.markers; i < a.length; i++) {
        var s = a[i];
        s.isAdded = !1, t && s.setMap(null);
      }
    }, e.prototype.distanceBetweenPoints = function(t, n) {
      var r = 6371, o = (n.lat() - t.lat()) * Math.PI / 180, i = (n.lng() - t.lng()) * Math.PI / 180, a = Math.sin(o / 2) * Math.sin(o / 2) + Math.cos(t.lat() * Math.PI / 180) * Math.cos(n.lat() * Math.PI / 180) * Math.sin(i / 2) * Math.sin(i / 2);
      return r * (2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)));
    }, e.prototype.isMarkerInBounds = function(t, n) {
      var r = t.getPosition();
      return r ? n.contains(r) : !1;
    }, e.prototype.addToClosestCluster = function(t) {
      for (var n, r = 4e4, o = null, i = 0, a = this.clusters; i < a.length; i++) {
        var s = a[i];
        n = s;
        var l = n.getCenter(), u = t.getPosition();
        if (l && u) {
          var c = this.distanceBetweenPoints(l, u);
          c < r && (r = c, o = n);
        }
      }
      o && o.isMarkerInClusterBounds(t) ? o.addMarker(t) : (n = new EMe(this), n.addMarker(t), this.clusters.push(n));
    }, e.prototype.createClusters = function(t) {
      var n = this;
      if (this.ready) {
        t === 0 && (google.maps.event.trigger(this, "clusteringbegin", this), this.timerRefStatic !== null && (window.clearTimeout(this.timerRefStatic), delete this.timerRefStatic));
        for (var r = this.getMap(), o = r !== null && ("getBounds" in r) ? r.getBounds() : null, i = (r == null ? void 0 : r.getZoom()) || 0, a = i > 3 ? new google.maps.LatLngBounds(o == null ? void 0 : o.getSouthWest(), o == null ? void 0 : o.getNorthEast()) : new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625)), s = this.getExtendedBounds(a), l = Math.min(t + this.batchSize, this.markers.length), u = t; u < l; u++) {
          var c = this.markers[u];
          c && !c.isAdded && this.isMarkerInBounds(c, s) && (!this.ignoreHidden || this.ignoreHidden && c.getVisible()) && this.addToClosestCluster(c);
        }
        if (l < this.markers.length)
          this.timerRefStatic = window.setTimeout(function() {
            n.createClusters(l);
          }, 0);
        else {
          this.timerRefStatic = null, google.maps.event.trigger(this, "clusteringend", this);
          for (var p = 0, d = this.clusters; p < d.length; p++) {
            var g = d[p];
            g.updateIcon();
          }
        }
      }
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype) {
          var i = o;
          this.prototype[i] = r.prototype[i];
        }
        return this;
      }).apply(t, [n]);
    }, e;
  }()
);
function Uz(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function TMe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Uz(Object(n), !0).forEach(function(r) {
      Ee(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Uz(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var rs = {
  onClick: "click",
  onClusteringBegin: "clusteringbegin",
  onClusteringEnd: "clusteringend",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover"
}, kn = {
  averageCenter(e, t) {
    e.setAverageCenter(t);
  },
  batchSizeIE(e, t) {
    e.setBatchSizeIE(t);
  },
  calculator(e, t) {
    e.setCalculator(t);
  },
  clusterClass(e, t) {
    e.setClusterClass(t);
  },
  enableRetinaIcons(e, t) {
    e.setEnableRetinaIcons(t);
  },
  gridSize(e, t) {
    e.setGridSize(t);
  },
  ignoreHidden(e, t) {
    e.setIgnoreHidden(t);
  },
  imageExtension(e, t) {
    e.setImageExtension(t);
  },
  imagePath(e, t) {
    e.setImagePath(t);
  },
  imageSizes(e, t) {
    e.setImageSizes(t);
  },
  maxZoom(e, t) {
    e.setMaxZoom(t);
  },
  minimumClusterSize(e, t) {
    e.setMinimumClusterSize(t);
  },
  styles(e, t) {
    e.setStyles(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  zoomOnClick(e, t) {
    e.setZoomOnClick(t);
  }
}, jMe = {};
function AMe(e) {
  var {
    children: t,
    options: n,
    averageCenter: r,
    batchSizeIE: o,
    calculator: i,
    clusterClass: a,
    enableRetinaIcons: s,
    gridSize: l,
    ignoreHidden: u,
    imageExtension: c,
    imagePath: p,
    imageSizes: d,
    maxZoom: g,
    minimumClusterSize: f,
    styles: m,
    title: v,
    zoomOnClick: E,
    onClick: w,
    onClusteringBegin: M,
    onClusteringEnd: O,
    onMouseOver: y,
    onMouseOut: C,
    onLoad: _,
    onUnmount: F
  } = e, [L, N] = k(null), R = ge(It), [W, V] = k(null), [z, Z] = k(null), [K, X] = k(null), [te, J] = k(null), [P, D] = k(null);
  return h(() => {
    L && C && (te !== null && google.maps.event.removeListener(te), J(google.maps.event.addListener(L, rs.onMouseOut, C)));
  }, [C]), h(() => {
    L && y && (P !== null && google.maps.event.removeListener(P), D(google.maps.event.addListener(L, rs.onMouseOver, y)));
  }, [y]), h(() => {
    L && w && (W !== null && google.maps.event.removeListener(W), V(google.maps.event.addListener(L, rs.onClick, w)));
  }, [w]), h(() => {
    L && M && (z !== null && google.maps.event.removeListener(z), Z(google.maps.event.addListener(L, rs.onClusteringBegin, M)));
  }, [M]), h(() => {
    L && O && (K !== null && google.maps.event.removeListener(K), Z(google.maps.event.addListener(L, rs.onClusteringEnd, O)));
  }, [O]), h(() => {
    typeof r < "u" && L !== null && kn.averageCenter(L, r);
  }, [L, r]), h(() => {
    typeof o < "u" && L !== null && kn.batchSizeIE(L, o);
  }, [L, o]), h(() => {
    typeof i < "u" && L !== null && kn.calculator(L, i);
  }, [L, i]), h(() => {
    typeof a < "u" && L !== null && kn.clusterClass(L, a);
  }, [L, a]), h(() => {
    typeof s < "u" && L !== null && kn.enableRetinaIcons(L, s);
  }, [L, s]), h(() => {
    typeof l < "u" && L !== null && kn.gridSize(L, l);
  }, [L, l]), h(() => {
    typeof u < "u" && L !== null && kn.ignoreHidden(L, u);
  }, [L, u]), h(() => {
    typeof c < "u" && L !== null && kn.imageExtension(L, c);
  }, [L, c]), h(() => {
    typeof p < "u" && L !== null && kn.imagePath(L, p);
  }, [L, p]), h(() => {
    typeof d < "u" && L !== null && kn.imageSizes(L, d);
  }, [L, d]), h(() => {
    typeof g < "u" && L !== null && kn.maxZoom(L, g);
  }, [L, g]), h(() => {
    typeof f < "u" && L !== null && kn.minimumClusterSize(L, f);
  }, [L, f]), h(() => {
    typeof m < "u" && L !== null && kn.styles(L, m);
  }, [L, m]), h(() => {
    typeof v < "u" && L !== null && kn.title(L, v);
  }, [L, v]), h(() => {
    typeof E < "u" && L !== null && kn.zoomOnClick(L, E);
  }, [L, E]), h(() => {
    if (R) {
      var H = TMe({}, n || jMe), S = new GG(R, [], H);
      return r && kn.averageCenter(S, r), o && kn.batchSizeIE(S, o), i && kn.calculator(S, i), a && kn.clusterClass(S, a), s && kn.enableRetinaIcons(S, s), l && kn.gridSize(S, l), u && kn.ignoreHidden(S, u), c && kn.imageExtension(S, c), p && kn.imagePath(S, p), d && kn.imageSizes(S, d), g && kn.maxZoom(S, g), f && kn.minimumClusterSize(S, f), m && kn.styles(S, m), v && kn.title(S, v), E && kn.zoomOnClick(S, E), C && J(google.maps.event.addListener(S, rs.onMouseOut, C)), y && D(google.maps.event.addListener(S, rs.onMouseOver, y)), w && V(google.maps.event.addListener(S, rs.onClick, w)), M && Z(google.maps.event.addListener(S, rs.onClusteringBegin, M)), O && X(google.maps.event.addListener(S, rs.onClusteringEnd, O)), N(S), _ && _(S), () => {
        te !== null && google.maps.event.removeListener(te), P !== null && google.maps.event.removeListener(P), W !== null && google.maps.event.removeListener(W), z !== null && google.maps.event.removeListener(z), K !== null && google.maps.event.removeListener(K), F && F(S);
      };
    }
  }, []), L !== null && t(L) || null;
}
ve(AMe);
class IMe extends pe {
  constructor() {
    super(...arguments), Ee(this, "registeredEvents", []), Ee(this, "state", {
      markerClusterer: null
    }), Ee(this, "setClustererCallback", () => {
      this.state.markerClusterer !== null && this.props.onLoad && this.props.onLoad(this.state.markerClusterer);
    });
  }
  componentDidMount() {
    if (this.context) {
      var t = new GG(this.context, [], this.props.options);
      this.registeredEvents = cn({
        updaterMap: kn,
        eventMap: rs,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        markerClusterer: t
      }), this.setClustererCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.markerClusterer && (mn(this.registeredEvents), this.registeredEvents = cn({
      updaterMap: kn,
      eventMap: rs,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.markerClusterer
    }));
  }
  componentWillUnmount() {
    this.state.markerClusterer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.markerClusterer), mn(this.registeredEvents), this.state.markerClusterer.setMap(null));
  }
  render() {
    return this.state.markerClusterer !== null ? this.props.children(this.state.markerClusterer) : null;
  }
}
Ee(IMe, "contextType", It);
function Hz(e) {
  e.cancelBubble = !0, e.stopPropagation && e.stopPropagation();
}
var KG = (
  /** @class */
  function() {
    function e(t) {
      t === void 0 && (t = {}), this.getCloseClickHandler = this.getCloseClickHandler.bind(this), this.closeClickHandler = this.closeClickHandler.bind(this), this.createInfoBoxDiv = this.createInfoBoxDiv.bind(this), this.addClickHandler = this.addClickHandler.bind(this), this.getCloseBoxImg = this.getCloseBoxImg.bind(this), this.getBoxWidths = this.getBoxWidths.bind(this), this.setBoxStyle = this.setBoxStyle.bind(this), this.setPosition = this.setPosition.bind(this), this.getPosition = this.getPosition.bind(this), this.setOptions = this.setOptions.bind(this), this.setContent = this.setContent.bind(this), this.setVisible = this.setVisible.bind(this), this.getContent = this.getContent.bind(this), this.getVisible = this.getVisible.bind(this), this.setZIndex = this.setZIndex.bind(this), this.getZIndex = this.getZIndex.bind(this), this.onRemove = this.onRemove.bind(this), this.panBox = this.panBox.bind(this), this.extend = this.extend.bind(this), this.close = this.close.bind(this), this.draw = this.draw.bind(this), this.show = this.show.bind(this), this.hide = this.hide.bind(this), this.open = this.open.bind(this), this.extend(e, google.maps.OverlayView), this.content = t.content || "", this.disableAutoPan = t.disableAutoPan || !1, this.maxWidth = t.maxWidth || 0, this.pixelOffset = t.pixelOffset || new google.maps.Size(0, 0), this.position = t.position || new google.maps.LatLng(0, 0), this.zIndex = t.zIndex || null, this.boxClass = t.boxClass || "infoBox", this.boxStyle = t.boxStyle || {}, this.closeBoxMargin = t.closeBoxMargin || "2px", this.closeBoxURL = t.closeBoxURL || "http://www.google.com/intl/en_us/mapfiles/close.gif", t.closeBoxURL === "" && (this.closeBoxURL = ""), this.infoBoxClearance = t.infoBoxClearance || new google.maps.Size(1, 1), typeof t.visible > "u" && (typeof t.isHidden > "u" ? t.visible = !0 : t.visible = !t.isHidden), this.isHidden = !t.visible, this.alignBottom = t.alignBottom || !1, this.pane = t.pane || "floatPane", this.enableEventPropagation = t.enableEventPropagation || !1, this.div = null, this.closeListener = null, this.moveListener = null, this.mapListener = null, this.contextListener = null, this.eventListeners = null, this.fixedWidthSet = null;
    }
    return e.prototype.createInfoBoxDiv = function() {
      var t = this, n = function(u) {
        u.returnValue = !1, u.preventDefault && u.preventDefault(), t.enableEventPropagation || Hz(u);
      };
      if (!this.div) {
        this.div = document.createElement("div"), this.setBoxStyle(), typeof this.content == "string" ? this.div.innerHTML = this.getCloseBoxImg() + this.content : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(this.content));
        var r = this.getPanes();
        if (r !== null && r[this.pane].appendChild(this.div), this.addClickHandler(), this.div.style.width)
          this.fixedWidthSet = !0;
        else if (this.maxWidth !== 0 && this.div.offsetWidth > this.maxWidth)
          this.div.style.width = this.maxWidth + "px", this.fixedWidthSet = !0;
        else {
          var o = this.getBoxWidths();
          this.div.style.width = this.div.offsetWidth - o.left - o.right + "px", this.fixedWidthSet = !1;
        }
        if (this.panBox(this.disableAutoPan), !this.enableEventPropagation) {
          this.eventListeners = [];
          for (var i = ["mousedown", "mouseover", "mouseout", "mouseup", "click", "dblclick", "touchstart", "touchend", "touchmove"], a = 0, s = i; a < s.length; a++) {
            var l = s[a];
            this.eventListeners.push(google.maps.event.addListener(this.div, l, Hz));
          }
          this.eventListeners.push(google.maps.event.addListener(this.div, "mouseover", function() {
            t.div && (t.div.style.cursor = "default");
          }));
        }
        this.contextListener = google.maps.event.addListener(this.div, "contextmenu", n), google.maps.event.trigger(this, "domready");
      }
    }, e.prototype.getCloseBoxImg = function() {
      var t = "";
      return this.closeBoxURL !== "" && (t = '<img alt=""', t += ' aria-hidden="true"', t += " src='" + this.closeBoxURL + "'", t += " align=right", t += " style='", t += " position: relative;", t += " cursor: pointer;", t += " margin: " + this.closeBoxMargin + ";", t += "'>"), t;
    }, e.prototype.addClickHandler = function() {
      this.closeListener = this.div && this.div.firstChild && this.closeBoxURL !== "" ? google.maps.event.addListener(this.div.firstChild, "click", this.getCloseClickHandler()) : null;
    }, e.prototype.closeClickHandler = function(t) {
      t.cancelBubble = !0, t.stopPropagation && t.stopPropagation(), google.maps.event.trigger(this, "closeclick"), this.close();
    }, e.prototype.getCloseClickHandler = function() {
      return this.closeClickHandler;
    }, e.prototype.panBox = function(t) {
      if (this.div && !t) {
        var n = this.getMap();
        if (n instanceof google.maps.Map) {
          var r = 0, o = 0, i = n.getBounds();
          i && !i.contains(this.position) && n.setCenter(this.position);
          var a = n.getDiv(), s = a.offsetWidth, l = a.offsetHeight, u = this.pixelOffset.width, c = this.pixelOffset.height, p = this.div.offsetWidth, d = this.div.offsetHeight, g = this.infoBoxClearance.width, f = this.infoBoxClearance.height, m = this.getProjection(), v = m.fromLatLngToContainerPixel(this.position);
          v !== null && (v.x < -u + g ? r = v.x + u - g : v.x + p + u + g > s && (r = v.x + p + u + g - s), this.alignBottom ? v.y < -c + f + d ? o = v.y + c - f - d : v.y + c + f > l && (o = v.y + c + f - l) : v.y < -c + f ? o = v.y + c - f : v.y + d + c + f > l && (o = v.y + d + c + f - l)), r === 0 && o === 0 || n.panBy(r, o);
        }
      }
    }, e.prototype.setBoxStyle = function() {
      if (this.div) {
        this.div.className = this.boxClass, this.div.style.cssText = "";
        var t = this.boxStyle;
        for (var n in t)
          Object.prototype.hasOwnProperty.call(t, n) && (this.div.style[n] = t[n]);
        if (this.div.style.webkitTransform = "translateZ(0)", typeof this.div.style.opacity < "u" && this.div.style.opacity !== "") {
          var r = parseFloat(this.div.style.opacity || "");
          this.div.style.msFilter = '"progid:DXImageTransform.Microsoft.Alpha(Opacity=' + r * 100 + ')"', this.div.style.filter = "alpha(opacity=" + r * 100 + ")";
        }
        this.div.style.position = "absolute", this.div.style.visibility = "hidden", this.zIndex !== null && (this.div.style.zIndex = this.zIndex + ""), this.div.style.overflow || (this.div.style.overflow = "auto");
      }
    }, e.prototype.getBoxWidths = function() {
      var t = {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0
      };
      if (!this.div)
        return t;
      if (document.defaultView) {
        var n = this.div.ownerDocument, r = n && n.defaultView ? n.defaultView.getComputedStyle(this.div, "") : null;
        r && (t.top = parseInt(r.borderTopWidth || "", 10) || 0, t.bottom = parseInt(r.borderBottomWidth || "", 10) || 0, t.left = parseInt(r.borderLeftWidth || "", 10) || 0, t.right = parseInt(r.borderRightWidth || "", 10) || 0);
      } else if (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        document.documentElement.currentStyle
      ) {
        var o = this.div.currentStyle;
        o && (t.top = parseInt(o.borderTopWidth || "", 10) || 0, t.bottom = parseInt(o.borderBottomWidth || "", 10) || 0, t.left = parseInt(o.borderLeftWidth || "", 10) || 0, t.right = parseInt(o.borderRightWidth || "", 10) || 0);
      }
      return t;
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.div.parentNode.removeChild(this.div), this.div = null);
    }, e.prototype.draw = function() {
      if (this.createInfoBoxDiv(), this.div) {
        var t = this.getProjection(), n = t.fromLatLngToDivPixel(this.position);
        n !== null && (this.div.style.left = n.x + this.pixelOffset.width + "px", this.alignBottom ? this.div.style.bottom = -(n.y + this.pixelOffset.height) + "px" : this.div.style.top = n.y + this.pixelOffset.height + "px"), this.isHidden ? this.div.style.visibility = "hidden" : this.div.style.visibility = "visible";
      }
    }, e.prototype.setOptions = function(t) {
      t === void 0 && (t = {}), typeof t.boxClass < "u" && (this.boxClass = t.boxClass, this.setBoxStyle()), typeof t.boxStyle < "u" && (this.boxStyle = t.boxStyle, this.setBoxStyle()), typeof t.content < "u" && this.setContent(t.content), typeof t.disableAutoPan < "u" && (this.disableAutoPan = t.disableAutoPan), typeof t.maxWidth < "u" && (this.maxWidth = t.maxWidth), typeof t.pixelOffset < "u" && (this.pixelOffset = t.pixelOffset), typeof t.alignBottom < "u" && (this.alignBottom = t.alignBottom), typeof t.position < "u" && this.setPosition(t.position), typeof t.zIndex < "u" && this.setZIndex(t.zIndex), typeof t.closeBoxMargin < "u" && (this.closeBoxMargin = t.closeBoxMargin), typeof t.closeBoxURL < "u" && (this.closeBoxURL = t.closeBoxURL), typeof t.infoBoxClearance < "u" && (this.infoBoxClearance = t.infoBoxClearance), typeof t.isHidden < "u" && (this.isHidden = t.isHidden), typeof t.visible < "u" && (this.isHidden = !t.visible), typeof t.enableEventPropagation < "u" && (this.enableEventPropagation = t.enableEventPropagation), this.div && this.draw();
    }, e.prototype.setContent = function(t) {
      this.content = t, this.div && (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.fixedWidthSet || (this.div.style.width = ""), typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t)), this.fixedWidthSet || (this.div.style.width = this.div.offsetWidth + "px", typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t))), this.addClickHandler()), google.maps.event.trigger(this, "content_changed");
    }, e.prototype.setPosition = function(t) {
      this.position = t, this.div && this.draw(), google.maps.event.trigger(this, "position_changed");
    }, e.prototype.setVisible = function(t) {
      this.isHidden = !t, this.div && (this.div.style.visibility = this.isHidden ? "hidden" : "visible");
    }, e.prototype.setZIndex = function(t) {
      this.zIndex = t, this.div && (this.div.style.zIndex = t + ""), google.maps.event.trigger(this, "zindex_changed");
    }, e.prototype.getContent = function() {
      return this.content;
    }, e.prototype.getPosition = function() {
      return this.position;
    }, e.prototype.getZIndex = function() {
      return this.zIndex;
    }, e.prototype.getVisible = function() {
      var t = this.getMap();
      return typeof t > "u" || t === null ? !1 : !this.isHidden;
    }, e.prototype.show = function() {
      this.isHidden = !1, this.div && (this.div.style.visibility = "visible");
    }, e.prototype.hide = function() {
      this.isHidden = !0, this.div && (this.div.style.visibility = "hidden");
    }, e.prototype.open = function(t, n) {
      var r = this;
      n && (this.position = n.getPosition(), this.moveListener = google.maps.event.addListener(n, "position_changed", function() {
        var o = n.getPosition();
        r.setPosition(o);
      }), this.mapListener = google.maps.event.addListener(n, "map_changed", function() {
        r.setMap(n.map);
      })), this.setMap(t), this.div && this.panBox();
    }, e.prototype.close = function() {
      if (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.eventListeners) {
        for (var t = 0, n = this.eventListeners; t < n.length; t++) {
          var r = n[t];
          google.maps.event.removeListener(r);
        }
        this.eventListeners = null;
      }
      this.moveListener && (google.maps.event.removeListener(this.moveListener), this.moveListener = null), this.mapListener && (google.maps.event.removeListener(this.mapListener), this.mapListener = null), this.contextListener && (google.maps.event.removeListener(this.contextListener), this.contextListener = null), this.setMap(null);
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype)
          Object.prototype.hasOwnProperty.call(this, o) || (this.prototype[o] = r.prototype[o]);
        return this;
      }).apply(t, [n]);
    }, e;
  }()
), RMe = ["position"], BMe = ["position"];
function $z(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function sy(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? $z(Object(n), !0).forEach(function(r) {
      Ee(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : $z(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Wz = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, Vz = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    t instanceof google.maps.LatLng ? e.setPosition(t) : e.setPosition(new google.maps.LatLng(t.lat, t.lng));
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, NMe = {};
function FMe(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, g = ge(It), [f, m] = k(null), [v, E] = k(null), [w, M] = k(null), [O, y] = k(null), [C, _] = k(null), [F, L] = k(null), N = ut(null);
  return h(() => {
    g && f !== null && (f.close(), n ? f.open(g, n) : f.getPosition() && f.open(g));
  }, [g, f, n]), h(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), h(() => {
    if (o && f !== null) {
      var R = o instanceof google.maps.LatLng ? o : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        new google.maps.LatLng(o.lat, o.lng)
      );
      f.setPosition(R);
    }
  }, [o]), h(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), h(() => {
    f && a && (v !== null && google.maps.event.removeListener(v), E(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), h(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), M(google.maps.event.addListener(f, "domready", s)));
  }, [s]), h(() => {
    f && l && (O !== null && google.maps.event.removeListener(O), y(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), h(() => {
    f && u && (C !== null && google.maps.event.removeListener(C), _(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), h(() => {
    f && c && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), h(() => {
    if (g) {
      var R = r || NMe, {
        position: W
      } = R, V = D_(R, RMe), z;
      W && !(W instanceof google.maps.LatLng) && (z = new google.maps.LatLng(W.lat, W.lng));
      var Z = new KG(sy(sy({}, V), z ? {
        position: z
      } : {}));
      N.current = document.createElement("div"), m(Z), a && E(google.maps.event.addListener(Z, "closeclick", a)), s && M(google.maps.event.addListener(Z, "domready", s)), l && y(google.maps.event.addListener(Z, "content_changed", l)), u && _(google.maps.event.addListener(Z, "position_changed", u)), c && L(google.maps.event.addListener(Z, "zindex_changed", c)), Z.setContent(N.current), n ? Z.open(g, n) : Z.getPosition() ? Z.open(g) : Co(!1, "You must provide either an anchor or a position prop for <InfoBox>."), p && p(Z);
    }
    return () => {
      f !== null && (v && google.maps.event.removeListener(v), O && google.maps.event.removeListener(O), w && google.maps.event.removeListener(w), C && google.maps.event.removeListener(C), F && google.maps.event.removeListener(F), d && d(f), f.close());
    };
  }, []), N.current ? or(lt.only(t), N.current) : null;
}
ve(FMe);
class zMe extends pe {
  constructor() {
    super(...arguments), Ee(this, "registeredEvents", []), Ee(this, "containerElement", null), Ee(this, "state", {
      infoBox: null
    }), Ee(this, "open", (t, n) => {
      n ? this.context !== null && t.open(this.context, n) : t.getPosition() ? this.context !== null && t.open(this.context) : Co(!1, "You must provide either an anchor or a position prop for <InfoBox>.");
    }), Ee(this, "setInfoBoxCallback", () => {
      this.state.infoBox !== null && this.containerElement !== null && (this.state.infoBox.setContent(this.containerElement), this.open(this.state.infoBox, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoBox));
    });
  }
  componentDidMount() {
    var t = this.props.options || {}, {
      position: n
    } = t, r = D_(t, BMe), o;
    n && !(n instanceof google.maps.LatLng) && (o = new google.maps.LatLng(n.lat, n.lng));
    var i = new KG(sy(sy({}, r), o ? {
      position: o
    } : {}));
    this.containerElement = document.createElement("div"), this.registeredEvents = cn({
      updaterMap: Vz,
      eventMap: Wz,
      prevProps: {},
      nextProps: this.props,
      instance: i
    }), this.setState({
      infoBox: i
    }, this.setInfoBoxCallback);
  }
  componentDidUpdate(t) {
    var {
      infoBox: n
    } = this.state;
    n !== null && (mn(this.registeredEvents), this.registeredEvents = cn({
      updaterMap: Vz,
      eventMap: Wz,
      prevProps: t,
      nextProps: this.props,
      instance: n
    }));
  }
  componentWillUnmount() {
    var {
      onUnmount: t
    } = this.props, {
      infoBox: n
    } = this.state;
    n !== null && (t && t(n), mn(this.registeredEvents), n.close());
  }
  render() {
    return this.containerElement ? or(lt.only(this.props.children), this.containerElement) : null;
  }
}
Ee(zMe, "contextType", It);
var Zz, qz;
function UMe() {
  return qz || (qz = 1, Zz = function e(t, n) {
    if (t === n) return !0;
    if (t && n && typeof t == "object" && typeof n == "object") {
      if (t.constructor !== n.constructor) return !1;
      var r, o, i;
      if (Array.isArray(t)) {
        if (r = t.length, r != n.length) return !1;
        for (o = r; o-- !== 0; ) if (!e(t[o], n[o])) return !1;
        return !0;
      }
      if (t.constructor === RegExp) return t.source === n.source && t.flags === n.flags;
      if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === n.valueOf();
      if (t.toString !== Object.prototype.toString) return t.toString() === n.toString();
      if (i = Object.keys(t), r = i.length, r !== Object.keys(n).length) return !1;
      for (o = r; o-- !== 0; ) if (!Object.prototype.hasOwnProperty.call(n, i[o])) return !1;
      for (o = r; o-- !== 0; ) {
        var a = i[o];
        if (!e(t[a], n[a])) return !1;
      }
      return !0;
    }
    return t !== t && n !== n;
  }), Zz;
}
var HMe = UMe(), Gz = /* @__PURE__ */ HG(HMe), Kz = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array], Mx = 1, fp = 8;
class T_ {
  /**
   * Creates an index from raw `ArrayBuffer` data.
   * @param {ArrayBuffer} data
   */
  static from(t) {
    if (!(t instanceof ArrayBuffer))
      throw new Error("Data must be an instance of ArrayBuffer.");
    var [n, r] = new Uint8Array(t, 0, 2);
    if (n !== 219)
      throw new Error("Data does not appear to be in a KDBush format.");
    var o = r >> 4;
    if (o !== Mx)
      throw new Error("Got v".concat(o, " data when expected v").concat(Mx, "."));
    var i = Kz[r & 15];
    if (!i)
      throw new Error("Unrecognized array type.");
    var [a] = new Uint16Array(t, 2, 1), [s] = new Uint32Array(t, 4, 1);
    return new T_(s, a, i, t);
  }
  /**
   * Creates an index that will hold a given number of items.
   * @param {number} numItems
   * @param {number} [nodeSize=64] Size of the KD-tree node (64 by default).
   * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).
   * @param {ArrayBuffer} [data] (For internal use only)
   */
  constructor(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 64, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Float64Array, o = arguments.length > 3 ? arguments[3] : void 0;
    if (isNaN(t) || t < 0) throw new Error("Unpexpected numItems value: ".concat(t, "."));
    this.numItems = +t, this.nodeSize = Math.min(Math.max(+n, 2), 65535), this.ArrayType = r, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
    var i = Kz.indexOf(this.ArrayType), a = t * 2 * this.ArrayType.BYTES_PER_ELEMENT, s = t * this.IndexArrayType.BYTES_PER_ELEMENT, l = (8 - s % 8) % 8;
    if (i < 0)
      throw new Error("Unexpected typed array class: ".concat(r, "."));
    o && o instanceof ArrayBuffer ? (this.data = o, this.ids = new this.IndexArrayType(this.data, fp, t), this.coords = new this.ArrayType(this.data, fp + s + l, t * 2), this._pos = t * 2, this._finished = !0) : (this.data = new ArrayBuffer(fp + a + s + l), this.ids = new this.IndexArrayType(this.data, fp, t), this.coords = new this.ArrayType(this.data, fp + s + l, t * 2), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, (Mx << 4) + i]), new Uint16Array(this.data, 2, 1)[0] = n, new Uint32Array(this.data, 4, 1)[0] = t);
  }
  /**
   * Add a point to the index.
   * @param {number} x
   * @param {number} y
   * @returns {number} An incremental index associated with the added item (starting from `0`).
   */
  add(t, n) {
    var r = this._pos >> 1;
    return this.ids[r] = r, this.coords[this._pos++] = t, this.coords[this._pos++] = n, r;
  }
  /**
   * Perform indexing of the added points.
   */
  finish() {
    var t = this._pos >> 1;
    if (t !== this.numItems)
      throw new Error("Added ".concat(t, " items when expected ").concat(this.numItems, "."));
    return Nk(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
  }
  /**
   * Search the index for items within a given bounding box.
   * @param {number} minX
   * @param {number} minY
   * @param {number} maxX
   * @param {number} maxY
   * @returns {number[]} An array of indices correponding to the found items.
   */
  range(t, n, r, o) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: i,
      coords: a,
      nodeSize: s
    } = this, l = [0, i.length - 1, 0], u = []; l.length; ) {
      var c = l.pop() || 0, p = l.pop() || 0, d = l.pop() || 0;
      if (p - d <= s) {
        for (var g = d; g <= p; g++) {
          var f = a[2 * g], m = a[2 * g + 1];
          f >= t && f <= r && m >= n && m <= o && u.push(i[g]);
        }
        continue;
      }
      var v = d + p >> 1, E = a[2 * v], w = a[2 * v + 1];
      E >= t && E <= r && w >= n && w <= o && u.push(i[v]), (c === 0 ? t <= E : n <= w) && (l.push(d), l.push(v - 1), l.push(1 - c)), (c === 0 ? r >= E : o >= w) && (l.push(v + 1), l.push(p), l.push(1 - c));
    }
    return u;
  }
  /**
   * Search the index for items within a given radius.
   * @param {number} qx
   * @param {number} qy
   * @param {number} r Query radius.
   * @returns {number[]} An array of indices correponding to the found items.
   */
  within(t, n, r) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: o,
      coords: i,
      nodeSize: a
    } = this, s = [0, o.length - 1, 0], l = [], u = r * r; s.length; ) {
      var c = s.pop() || 0, p = s.pop() || 0, d = s.pop() || 0;
      if (p - d <= a) {
        for (var g = d; g <= p; g++)
          Yz(i[2 * g], i[2 * g + 1], t, n) <= u && l.push(o[g]);
        continue;
      }
      var f = d + p >> 1, m = i[2 * f], v = i[2 * f + 1];
      Yz(m, v, t, n) <= u && l.push(o[f]), (c === 0 ? t - r <= m : n - r <= v) && (s.push(d), s.push(f - 1), s.push(1 - c)), (c === 0 ? t + r >= m : n + r >= v) && (s.push(f + 1), s.push(p), s.push(1 - c));
    }
    return l;
  }
}
function Nk(e, t, n, r, o, i) {
  if (!(o - r <= n)) {
    var a = r + o >> 1;
    YG(e, t, a, r, o, i), Nk(e, t, n, r, a - 1, 1 - i), Nk(e, t, n, a + 1, o, 1 - i);
  }
}
function YG(e, t, n, r, o, i) {
  for (; o > r; ) {
    if (o - r > 600) {
      var a = o - r + 1, s = n - r + 1, l = Math.log(a), u = 0.5 * Math.exp(2 * l / 3), c = 0.5 * Math.sqrt(l * u * (a - u) / a) * (s - a / 2 < 0 ? -1 : 1), p = Math.max(r, Math.floor(n - s * u / a + c)), d = Math.min(o, Math.floor(n + (a - s) * u / a + c));
      YG(e, t, n, p, d, i);
    }
    var g = t[2 * n + i], f = r, m = o;
    for (hp(e, t, r, n), t[2 * o + i] > g && hp(e, t, r, o); f < m; ) {
      for (hp(e, t, f, m), f++, m--; t[2 * f + i] < g; ) f++;
      for (; t[2 * m + i] > g; ) m--;
    }
    t[2 * r + i] === g ? hp(e, t, r, m) : (m++, hp(e, t, m, o)), m <= n && (r = m + 1), n <= m && (o = m - 1);
  }
}
function hp(e, t, n, r) {
  Dx(e, n, r), Dx(t, 2 * n, 2 * r), Dx(t, 2 * n + 1, 2 * r + 1);
}
function Dx(e, t, n) {
  var r = e[t];
  e[t] = e[n], e[n] = r;
}
function Yz(e, t, n, r) {
  var o = e - n, i = t - r;
  return o * o + i * i;
}
var $Me = {
  minZoom: 0,
  // min zoom to generate clusters on
  maxZoom: 16,
  // max zoom level to cluster the points on
  minPoints: 2,
  // minimum points to form a cluster
  radius: 40,
  // cluster radius in pixels
  extent: 512,
  // tile extent (radius is calculated relative to it)
  nodeSize: 64,
  // size of the KD-tree leaf node, affects performance
  log: !1,
  // whether to log timing info
  // whether to generate numeric ids for input features (in vector tiles)
  generateId: !1,
  // a reduce function for calculating custom cluster properties
  reduce: null,
  // (accumulated, props) => { accumulated.sum += props.sum; }
  // properties to use for individual points when running the reducer
  map: (e) => e
  // props => ({sum: props.my_value})
}, Xz = Math.fround || /* @__PURE__ */ ((e) => (t) => (e[0] = +t, e[0]))(new Float32Array(1)), Ul = 2, qa = 3, Tx = 4, za = 5, XG = 6;
class WMe {
  constructor(t) {
    this.options = Object.assign(Object.create($Me), t), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
  }
  load(t) {
    var {
      log: n,
      minZoom: r,
      maxZoom: o
    } = this.options;
    n && console.time("total time");
    var i = "prepare ".concat(t.length, " points");
    n && console.time(i), this.points = t;
    for (var a = [], s = 0; s < t.length; s++) {
      var l = t[s];
      if (l.geometry) {
        var [u, c] = l.geometry.coordinates, p = Xz(Fg(u)), d = Xz(zg(c));
        a.push(
          p,
          d,
          // projected point coordinates
          1 / 0,
          // the last zoom the point was processed at
          s,
          // index of the source feature in the original input array
          -1,
          // parent cluster id
          1
          // number of points in a cluster
        ), this.options.reduce && a.push(0);
      }
    }
    var g = this.trees[o + 1] = this._createTree(a);
    n && console.timeEnd(i);
    for (var f = o; f >= r; f--) {
      var m = +Date.now();
      g = this.trees[f] = this._createTree(this._cluster(g, f)), n && console.log("z%d: %d clusters in %dms", f, g.numItems, +Date.now() - m);
    }
    return n && console.timeEnd("total time"), this;
  }
  getClusters(t, n) {
    var r = ((t[0] + 180) % 360 + 360) % 360 - 180, o = Math.max(-90, Math.min(90, t[1])), i = t[2] === 180 ? 180 : ((t[2] + 180) % 360 + 360) % 360 - 180, a = Math.max(-90, Math.min(90, t[3]));
    if (t[2] - t[0] >= 360)
      r = -180, i = 180;
    else if (r > i) {
      var s = this.getClusters([r, o, 180, a], n), l = this.getClusters([-180, o, i, a], n);
      return s.concat(l);
    }
    var u = this.trees[this._limitZoom(n)], c = u.range(Fg(r), zg(a), Fg(i), zg(o)), p = u.data, d = [];
    for (var g of c) {
      var f = this.stride * g;
      d.push(p[f + za] > 1 ? Jz(p, f, this.clusterProps) : this.points[p[f + qa]]);
    }
    return d;
  }
  getChildren(t) {
    var n = this._getOriginId(t), r = this._getOriginZoom(t), o = "No cluster with the specified id.", i = this.trees[r];
    if (!i) throw new Error(o);
    var a = i.data;
    if (n * this.stride >= a.length) throw new Error(o);
    var s = this.options.radius / (this.options.extent * Math.pow(2, r - 1)), l = a[n * this.stride], u = a[n * this.stride + 1], c = i.within(l, u, s), p = [];
    for (var d of c) {
      var g = d * this.stride;
      a[g + Tx] === t && p.push(a[g + za] > 1 ? Jz(a, g, this.clusterProps) : this.points[a[g + qa]]);
    }
    if (p.length === 0) throw new Error(o);
    return p;
  }
  getLeaves(t, n, r) {
    n = n || 10, r = r || 0;
    var o = [];
    return this._appendLeaves(o, t, n, r, 0), o;
  }
  getTile(t, n, r) {
    var o = this.trees[this._limitZoom(t)], i = Math.pow(2, t), {
      extent: a,
      radius: s
    } = this.options, l = s / a, u = (r - l) / i, c = (r + 1 + l) / i, p = {
      features: []
    };
    return this._addTileFeatures(o.range((n - l) / i, u, (n + 1 + l) / i, c), o.data, n, r, i, p), n === 0 && this._addTileFeatures(o.range(1 - l / i, u, 1, c), o.data, i, r, i, p), n === i - 1 && this._addTileFeatures(o.range(0, u, l / i, c), o.data, -1, r, i, p), p.features.length ? p : null;
  }
  getClusterExpansionZoom(t) {
    for (var n = this._getOriginZoom(t) - 1; n <= this.options.maxZoom; ) {
      var r = this.getChildren(t);
      if (n++, r.length !== 1) break;
      t = r[0].properties.cluster_id;
    }
    return n;
  }
  _appendLeaves(t, n, r, o, i) {
    var a = this.getChildren(n);
    for (var s of a) {
      var l = s.properties;
      if (l && l.cluster ? i + l.point_count <= o ? i += l.point_count : i = this._appendLeaves(t, l.cluster_id, r, o, i) : i < o ? i++ : t.push(s), t.length === r) break;
    }
    return i;
  }
  _createTree(t) {
    for (var n = new T_(t.length / this.stride | 0, this.options.nodeSize, Float32Array), r = 0; r < t.length; r += this.stride) n.add(t[r], t[r + 1]);
    return n.finish(), n.data = t, n;
  }
  _addTileFeatures(t, n, r, o, i, a) {
    for (var s of t) {
      var l = s * this.stride, u = n[l + za] > 1, c = void 0, p = void 0, d = void 0;
      if (u)
        c = JG(n, l, this.clusterProps), p = n[l], d = n[l + 1];
      else {
        var g = this.points[n[l + qa]];
        c = g.properties;
        var [f, m] = g.geometry.coordinates;
        p = Fg(f), d = zg(m);
      }
      var v = {
        type: 1,
        geometry: [[Math.round(this.options.extent * (p * i - r)), Math.round(this.options.extent * (d * i - o))]],
        tags: c
      }, E = void 0;
      u || this.options.generateId ? E = n[l + qa] : E = this.points[n[l + qa]].id, E !== void 0 && (v.id = E), a.features.push(v);
    }
  }
  _limitZoom(t) {
    return Math.max(this.options.minZoom, Math.min(Math.floor(+t), this.options.maxZoom + 1));
  }
  _cluster(t, n) {
    for (var {
      radius: r,
      extent: o,
      reduce: i,
      minPoints: a
    } = this.options, s = r / (o * Math.pow(2, n)), l = t.data, u = [], c = this.stride, p = 0; p < l.length; p += c)
      if (!(l[p + Ul] <= n)) {
        l[p + Ul] = n;
        var d = l[p], g = l[p + 1], f = t.within(l[p], l[p + 1], s), m = l[p + za], v = m;
        for (var E of f) {
          var w = E * c;
          l[w + Ul] > n && (v += l[w + za]);
        }
        if (v > m && v >= a) {
          var M = d * m, O = g * m, y = void 0, C = -1, _ = ((p / c | 0) << 5) + (n + 1) + this.points.length;
          for (var F of f) {
            var L = F * c;
            if (!(l[L + Ul] <= n)) {
              l[L + Ul] = n;
              var N = l[L + za];
              M += l[L] * N, O += l[L + 1] * N, l[L + Tx] = _, i && (y || (y = this._map(l, p, !0), C = this.clusterProps.length, this.clusterProps.push(y)), i(y, this._map(l, L)));
            }
          }
          l[p + Tx] = _, u.push(M / v, O / v, 1 / 0, _, -1, v), i && u.push(C);
        } else {
          for (var R = 0; R < c; R++) u.push(l[p + R]);
          if (v > 1)
            for (var W of f) {
              var V = W * c;
              if (!(l[V + Ul] <= n)) {
                l[V + Ul] = n;
                for (var z = 0; z < c; z++) u.push(l[V + z]);
              }
            }
        }
      }
    return u;
  }
  // get index of the point from which the cluster originated
  _getOriginId(t) {
    return t - this.points.length >> 5;
  }
  // get zoom of the point from which the cluster originated
  _getOriginZoom(t) {
    return (t - this.points.length) % 32;
  }
  _map(t, n, r) {
    if (t[n + za] > 1) {
      var o = this.clusterProps[t[n + XG]];
      return r ? Object.assign({}, o) : o;
    }
    var i = this.points[t[n + qa]].properties, a = this.options.map(i);
    return r && a === i ? Object.assign({}, a) : a;
  }
}
function Jz(e, t, n) {
  return {
    type: "Feature",
    id: e[t + qa],
    properties: JG(e, t, n),
    geometry: {
      type: "Point",
      coordinates: [VMe(e[t]), ZMe(e[t + 1])]
    }
  };
}
function JG(e, t, n) {
  var r = e[t + za], o = r >= 1e4 ? "".concat(Math.round(r / 1e3), "k") : r >= 1e3 ? "".concat(Math.round(r / 100) / 10, "k") : r, i = e[t + XG], a = i === -1 ? {} : Object.assign({}, n[i]);
  return Object.assign(a, {
    cluster: !0,
    cluster_id: e[t + qa],
    point_count: r,
    point_count_abbreviated: o
  });
}
function Fg(e) {
  return e / 360 + 0.5;
}
function zg(e) {
  var t = Math.sin(e * Math.PI / 180), n = 0.5 - 0.25 * Math.log((1 + t) / (1 - t)) / Math.PI;
  return n < 0 ? 0 : n > 1 ? 1 : n;
}
function VMe(e) {
  return (e - 0.5) * 360;
}
function ZMe(e) {
  var t = (180 - e * 360) * Math.PI / 180;
  return 360 * Math.atan(Math.exp(t)) / Math.PI - 90;
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function qMe(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
    t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
  return n;
}
class Ri {
  static isAdvancedMarkerAvailable(t) {
    return google.maps.marker && t.getMapCapabilities().isAdvancedMarkersAvailable === !0;
  }
  static isAdvancedMarker(t) {
    return google.maps.marker && t instanceof google.maps.marker.AdvancedMarkerElement;
  }
  static setMap(t, n) {
    this.isAdvancedMarker(t) ? t.map = n : t.setMap(n);
  }
  static getPosition(t) {
    if (this.isAdvancedMarker(t)) {
      if (t.position) {
        if (t.position instanceof google.maps.LatLng)
          return t.position;
        if (t.position.lat && t.position.lng)
          return new google.maps.LatLng(t.position.lat, t.position.lng);
      }
      return new google.maps.LatLng(null);
    }
    return t.getPosition();
  }
  static getVisible(t) {
    return this.isAdvancedMarker(t) ? !0 : t.getVisible();
  }
}
class Fk {
  constructor(t) {
    var {
      markers: n,
      position: r
    } = t;
    this.markers = n, r && (r instanceof google.maps.LatLng ? this._position = r : this._position = new google.maps.LatLng(r));
  }
  get bounds() {
    if (!(this.markers.length === 0 && !this._position)) {
      var t = new google.maps.LatLngBounds(this._position, this._position);
      for (var n of this.markers)
        t.extend(Ri.getPosition(n));
      return t;
    }
  }
  get position() {
    return this._position || this.bounds.getCenter();
  }
  /**
   * Get the count of **visible** markers.
   */
  get count() {
    return this.markers.filter((t) => Ri.getVisible(t)).length;
  }
  /**
   * Add a marker to the cluster.
   */
  push(t) {
    this.markers.push(t);
  }
  /**
   * Cleanup references and remove marker from map.
   */
  delete() {
    this.marker && (Ri.setMap(this.marker, null), this.marker = void 0), this.markers.length = 0;
  }
}
class GMe {
  constructor(t) {
    var {
      maxZoom: n = 16
    } = t;
    this.maxZoom = n;
  }
  /**
   * Helper function to bypass clustering based upon some map state such as
   * zoom, number of markers, etc.
   *
   * ```typescript
   *  cluster({markers, map}: AlgorithmInput): Cluster[] {
   *    if (shouldBypassClustering(map)) {
   *      return this.noop({markers})
   *    }
   * }
   * ```
   */
  noop(t) {
    var {
      markers: n
    } = t;
    return KMe(n);
  }
}
var KMe = (e) => {
  var t = e.map((n) => new Fk({
    position: Ri.getPosition(n),
    markers: [n]
  }));
  return t;
};
class YMe extends GMe {
  constructor(t) {
    var {
      maxZoom: n,
      radius: r = 60
    } = t, o = qMe(t, ["maxZoom", "radius"]);
    super({
      maxZoom: n
    }), this.state = {
      zoom: -1
    }, this.superCluster = new WMe(Object.assign({
      maxZoom: this.maxZoom,
      radius: r
    }, o));
  }
  calculate(t) {
    var n = !1, r = {
      zoom: t.map.getZoom()
    };
    if (!Gz(t.markers, this.markers)) {
      n = !0, this.markers = [...t.markers];
      var o = this.markers.map((i) => {
        var a = Ri.getPosition(i), s = [a.lng(), a.lat()];
        return {
          type: "Feature",
          geometry: {
            type: "Point",
            coordinates: s
          },
          properties: {
            marker: i
          }
        };
      });
      this.superCluster.load(o);
    }
    return n || (this.state.zoom <= this.maxZoom || r.zoom <= this.maxZoom) && (n = !Gz(this.state, r)), this.state = r, n && (this.clusters = this.cluster(t)), {
      clusters: this.clusters,
      changed: n
    };
  }
  cluster(t) {
    var {
      map: n
    } = t;
    return this.superCluster.getClusters([-180, -90, 180, 90], Math.round(n.getZoom())).map((r) => this.transformCluster(r));
  }
  transformCluster(t) {
    var {
      geometry: {
        coordinates: [n, r]
      },
      properties: o
    } = t;
    if (o.cluster)
      return new Fk({
        markers: this.superCluster.getLeaves(o.cluster_id, 1 / 0).map((a) => a.properties.marker),
        position: {
          lat: r,
          lng: n
        }
      });
    var i = o.marker;
    return new Fk({
      markers: [i],
      position: Ri.getPosition(i)
    });
  }
}
class XMe {
  constructor(t, n) {
    this.markers = {
      sum: t.length
    };
    var r = n.map((i) => i.count), o = r.reduce((i, a) => i + a, 0);
    this.clusters = {
      count: n.length,
      markers: {
        mean: o / n.length,
        sum: o,
        min: Math.min(...r),
        max: Math.max(...r)
      }
    };
  }
}
class JMe {
  /**
   * The default render function for the library used by {@link MarkerClusterer}.
   *
   * Currently set to use the following:
   *
   * ```typescript
   * // change color if this cluster has more markers than the mean cluster
   * const color =
   *   count > Math.max(10, stats.clusters.markers.mean)
   *     ? "#ff0000"
   *     : "#0000ff";
   *
   * // create svg url with fill color
   * const svg = window.btoa(`
   * <svg fill="${color}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240">
   *   <circle cx="120" cy="120" opacity=".6" r="70" />
   *   <circle cx="120" cy="120" opacity=".3" r="90" />
   *   <circle cx="120" cy="120" opacity=".2" r="110" />
   *   <circle cx="120" cy="120" opacity=".1" r="130" />
   * </svg>`);
   *
   * // create marker using svg icon
   * return new google.maps.Marker({
   *   position,
   *   icon: {
   *     url: `data:image/svg+xml;base64,${svg}`,
   *     scaledSize: new google.maps.Size(45, 45),
   *   },
   *   label: {
   *     text: String(count),
   *     color: "rgba(255,255,255,0.9)",
   *     fontSize: "12px",
   *   },
   *   // adjust zIndex to be above other markers
   *   zIndex: 1000 + count,
   * });
   * ```
   */
  render(t, n, r) {
    var {
      count: o,
      position: i
    } = t, a = o > Math.max(10, n.clusters.markers.mean) ? "#ff0000" : "#0000ff", s = '<svg fill="'.concat(a, `" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" width="50" height="50">
<circle cx="120" cy="120" opacity=".6" r="70" />
<circle cx="120" cy="120" opacity=".3" r="90" />
<circle cx="120" cy="120" opacity=".2" r="110" />
<text x="50%" y="50%" style="fill:#fff" text-anchor="middle" font-size="50" dominant-baseline="middle" font-family="roboto,arial,sans-serif">`).concat(o, `</text>
</svg>`), l = "Cluster of ".concat(o, " markers"), u = Number(google.maps.Marker.MAX_ZINDEX) + o;
    if (Ri.isAdvancedMarkerAvailable(r)) {
      var c = new DOMParser(), p = c.parseFromString(s, "image/svg+xml").documentElement;
      p.setAttribute("transform", "translate(0 25)");
      var d = {
        map: r,
        position: i,
        zIndex: u,
        title: l,
        content: p
      };
      return new google.maps.marker.AdvancedMarkerElement(d);
    }
    var g = {
      position: i,
      zIndex: u,
      title: l,
      icon: {
        url: "data:image/svg+xml;base64,".concat(btoa(s)),
        anchor: new google.maps.Point(25, 25)
      }
    };
    return new google.maps.Marker(g);
  }
}
function QMe(e, t) {
  for (var n in t.prototype)
    e.prototype[n] = t.prototype[n];
}
class j_ {
  constructor() {
    QMe(j_, google.maps.OverlayView);
  }
}
var ad;
(function(e) {
  e.CLUSTERING_BEGIN = "clusteringbegin", e.CLUSTERING_END = "clusteringend", e.CLUSTER_CLICK = "click";
})(ad || (ad = {}));
var eDe = (e, t, n) => {
  n.fitBounds(t.bounds);
};
class tDe extends j_ {
  constructor(t) {
    var {
      map: n,
      markers: r = [],
      algorithmOptions: o = {},
      algorithm: i = new YMe(o),
      renderer: a = new JMe(),
      onClusterClick: s = eDe
    } = t;
    super(), this.markers = [...r], this.clusters = [], this.algorithm = i, this.renderer = a, this.onClusterClick = s, n && this.setMap(n);
  }
  addMarker(t, n) {
    this.markers.includes(t) || (this.markers.push(t), n || this.render());
  }
  addMarkers(t, n) {
    t.forEach((r) => {
      this.addMarker(r, !0);
    }), n || this.render();
  }
  removeMarker(t, n) {
    var r = this.markers.indexOf(t);
    return r === -1 ? !1 : (Ri.setMap(t, null), this.markers.splice(r, 1), n || this.render(), !0);
  }
  removeMarkers(t, n) {
    var r = !1;
    return t.forEach((o) => {
      r = this.removeMarker(o, !0) || r;
    }), r && !n && this.render(), r;
  }
  clearMarkers(t) {
    this.markers.length = 0, t || this.render();
  }
  /**
   * Recalculates and draws all the marker clusters.
   */
  render() {
    var t = this.getMap();
    if (t instanceof google.maps.Map && t.getProjection()) {
      google.maps.event.trigger(this, ad.CLUSTERING_BEGIN, this);
      var {
        clusters: n,
        changed: r
      } = this.algorithm.calculate({
        markers: this.markers,
        map: t,
        mapCanvasProjection: this.getProjection()
      });
      if (r || r == null) {
        var o = /* @__PURE__ */ new Set();
        for (var i of n)
          i.markers.length == 1 && o.add(i.markers[0]);
        var a = [];
        for (var s of this.clusters)
          s.marker != null && (s.markers.length == 1 ? o.has(s.marker) || Ri.setMap(s.marker, null) : a.push(s.marker));
        this.clusters = n, this.renderClusters(), requestAnimationFrame(() => a.forEach((l) => Ri.setMap(l, null)));
      }
      google.maps.event.trigger(this, ad.CLUSTERING_END, this);
    }
  }
  onAdd() {
    this.idleListener = this.getMap().addListener("idle", this.render.bind(this)), this.render();
  }
  onRemove() {
    google.maps.event.removeListener(this.idleListener), this.reset();
  }
  reset() {
    this.markers.forEach((t) => Ri.setMap(t, null)), this.clusters.forEach((t) => t.delete()), this.clusters = [];
  }
  renderClusters() {
    var t = new XMe(this.markers, this.clusters), n = this.getMap();
    this.clusters.forEach((r) => {
      r.markers.length === 1 ? r.marker = r.markers[0] : (r.marker = this.renderer.render(r, t, n), r.markers.forEach((o) => Ri.setMap(o, null)), this.onClusterClick && r.marker.addListener(
        "click",
        /* istanbul ignore next */
        (o) => {
          google.maps.event.trigger(this, ad.CLUSTER_CLICK, r), this.onClusterClick(o, r, n);
        }
      )), Ri.setMap(r.marker, n);
    });
  }
}
function Qz(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function eU(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Qz(Object(n), !0).forEach(function(r) {
      Ee(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Qz(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function nDe(e) {
  var t = eMe(), [n, r] = k(null);
  return h(() => {
    if (t && n === null) {
      var o = new tDe(eU(eU({}, e), {}, {
        map: t
      }));
      r(o);
    }
  }, [t]), n;
}
function rDe(e) {
  var {
    children: t,
    options: n
  } = e, r = nDe(n);
  return r !== null ? t(r) : null;
}
ve(rDe);
var tU = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, nU = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
function oDe(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, g = ge(It), [f, m] = k(null), [v, E] = k(null), [w, M] = k(null), [O, y] = k(null), [C, _] = k(null), [F, L] = k(null), N = ut(null);
  return h(() => {
    f !== null && (f.close(), n ? f.open(g, n) : f.getPosition() && f.open(g));
  }, [g, f, n]), h(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), h(() => {
    o && f !== null && f.setPosition(o);
  }, [o]), h(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), h(() => {
    f && a && (v !== null && google.maps.event.removeListener(v), E(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), h(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), M(google.maps.event.addListener(f, "domready", s)));
  }, [s]), h(() => {
    f && l && (O !== null && google.maps.event.removeListener(O), y(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), h(() => {
    f && u && (C !== null && google.maps.event.removeListener(C), _(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), h(() => {
    f && c && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), h(() => {
    var R = new google.maps.InfoWindow(r);
    return m(R), N.current = document.createElement("div"), a && E(google.maps.event.addListener(R, "closeclick", a)), s && M(google.maps.event.addListener(R, "domready", s)), l && y(google.maps.event.addListener(R, "content_changed", l)), u && _(google.maps.event.addListener(R, "position_changed", u)), c && L(google.maps.event.addListener(R, "zindex_changed", c)), R.setContent(N.current), o && R.setPosition(o), i && R.setZIndex(i), n ? R.open(g, n) : R.getPosition() ? R.open(g) : Co(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>."), p && p(R), () => {
      v && google.maps.event.removeListener(v), O && google.maps.event.removeListener(O), w && google.maps.event.removeListener(w), C && google.maps.event.removeListener(C), F && google.maps.event.removeListener(F), d && d(R), R.close();
    };
  }, []), N.current ? or(lt.only(t), N.current) : null;
}
ve(oDe);
class iDe extends pe {
  constructor() {
    super(...arguments), Ee(this, "registeredEvents", []), Ee(this, "containerElement", null), Ee(this, "state", {
      infoWindow: null
    }), Ee(this, "open", (t, n) => {
      n ? t.open(this.context, n) : t.getPosition() ? t.open(this.context) : Co(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>.");
    }), Ee(this, "setInfoWindowCallback", () => {
      this.state.infoWindow !== null && this.containerElement !== null && (this.state.infoWindow.setContent(this.containerElement), this.open(this.state.infoWindow, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoWindow));
    });
  }
  componentDidMount() {
    var t = new google.maps.InfoWindow(this.props.options);
    this.containerElement = document.createElement("div"), this.registeredEvents = cn({
      updaterMap: nU,
      eventMap: tU,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(() => ({
      infoWindow: t
    }), this.setInfoWindowCallback);
  }
  componentDidUpdate(t) {
    this.state.infoWindow !== null && (mn(this.registeredEvents), this.registeredEvents = cn({
      updaterMap: nU,
      eventMap: tU,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.infoWindow
    }));
  }
  componentWillUnmount() {
    this.state.infoWindow !== null && (mn(this.registeredEvents), this.props.onUnmount && this.props.onUnmount(this.state.infoWindow), this.state.infoWindow.close());
  }
  render() {
    return this.containerElement ? or(lt.only(this.props.children), this.containerElement) : null;
  }
}
Ee(iDe, "contextType", It);
function rU(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ay(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? rU(Object(n), !0).forEach(function(r) {
      Ee(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : rU(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var oU = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, iU = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, sDe = {};
function aDe(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: g,
    onRightClick: f,
    onClick: m,
    onDrag: v,
    onLoad: E,
    onUnmount: w
  } = e, M = ge(It), [O, y] = k(null), [C, _] = k(null), [F, L] = k(null), [N, R] = k(null), [W, V] = k(null), [z, Z] = k(null), [K, X] = k(null), [te, J] = k(null), [P, D] = k(null), [H, S] = k(null), [$, x] = k(null), [j, U] = k(null);
  return h(() => {
    O !== null && O.setMap(M);
  }, [M]), h(() => {
    typeof t < "u" && O !== null && O.setOptions(t);
  }, [O, t]), h(() => {
    typeof n < "u" && O !== null && O.setDraggable(n);
  }, [O, n]), h(() => {
    typeof r < "u" && O !== null && O.setEditable(r);
  }, [O, r]), h(() => {
    typeof o < "u" && O !== null && O.setVisible(o);
  }, [O, o]), h(() => {
    typeof i < "u" && O !== null && O.setPath(i);
  }, [O, i]), h(() => {
    O && a && (C !== null && google.maps.event.removeListener(C), _(google.maps.event.addListener(O, "dblclick", a)));
  }, [a]), h(() => {
    O && s && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(O, "dragend", s)));
  }, [s]), h(() => {
    O && l && (N !== null && google.maps.event.removeListener(N), R(google.maps.event.addListener(O, "dragstart", l)));
  }, [l]), h(() => {
    O && u && (W !== null && google.maps.event.removeListener(W), V(google.maps.event.addListener(O, "mousedown", u)));
  }, [u]), h(() => {
    O && c && (z !== null && google.maps.event.removeListener(z), Z(google.maps.event.addListener(O, "mousemove", c)));
  }, [c]), h(() => {
    O && p && (K !== null && google.maps.event.removeListener(K), X(google.maps.event.addListener(O, "mouseout", p)));
  }, [p]), h(() => {
    O && d && (te !== null && google.maps.event.removeListener(te), J(google.maps.event.addListener(O, "mouseover", d)));
  }, [d]), h(() => {
    O && g && (P !== null && google.maps.event.removeListener(P), D(google.maps.event.addListener(O, "mouseup", g)));
  }, [g]), h(() => {
    O && f && (H !== null && google.maps.event.removeListener(H), S(google.maps.event.addListener(O, "rightclick", f)));
  }, [f]), h(() => {
    O && m && ($ !== null && google.maps.event.removeListener($), x(google.maps.event.addListener(O, "click", m)));
  }, [m]), h(() => {
    O && v && (j !== null && google.maps.event.removeListener(j), U(google.maps.event.addListener(O, "drag", v)));
  }, [v]), h(() => {
    var T = new google.maps.Polyline(ay(ay({}, t || sDe), {}, {
      map: M
    }));
    return i && T.setPath(i), typeof o < "u" && T.setVisible(o), typeof r < "u" && T.setEditable(r), typeof n < "u" && T.setDraggable(n), a && _(google.maps.event.addListener(T, "dblclick", a)), s && L(google.maps.event.addListener(T, "dragend", s)), l && R(google.maps.event.addListener(T, "dragstart", l)), u && V(google.maps.event.addListener(T, "mousedown", u)), c && Z(google.maps.event.addListener(T, "mousemove", c)), p && X(google.maps.event.addListener(T, "mouseout", p)), d && J(google.maps.event.addListener(T, "mouseover", d)), g && D(google.maps.event.addListener(T, "mouseup", g)), f && S(google.maps.event.addListener(T, "rightclick", f)), m && x(google.maps.event.addListener(T, "click", m)), v && U(google.maps.event.addListener(T, "drag", v)), y(T), E && E(T), () => {
      C !== null && google.maps.event.removeListener(C), F !== null && google.maps.event.removeListener(F), N !== null && google.maps.event.removeListener(N), W !== null && google.maps.event.removeListener(W), z !== null && google.maps.event.removeListener(z), K !== null && google.maps.event.removeListener(K), te !== null && google.maps.event.removeListener(te), P !== null && google.maps.event.removeListener(P), H !== null && google.maps.event.removeListener(H), $ !== null && google.maps.event.removeListener($), w && w(T), T.setMap(null);
    };
  }, []), null;
}
ve(aDe);
class lDe extends pe {
  constructor() {
    super(...arguments), Ee(this, "registeredEvents", []), Ee(this, "state", {
      polyline: null
    }), Ee(this, "setPolylineCallback", () => {
      this.state.polyline !== null && this.props.onLoad && this.props.onLoad(this.state.polyline);
    });
  }
  componentDidMount() {
    var t = new google.maps.Polyline(ay(ay({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = cn({
      updaterMap: iU,
      eventMap: oU,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        polyline: t
      };
    }, this.setPolylineCallback);
  }
  componentDidUpdate(t) {
    this.state.polyline !== null && (mn(this.registeredEvents), this.registeredEvents = cn({
      updaterMap: iU,
      eventMap: oU,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.polyline
    }));
  }
  componentWillUnmount() {
    this.state.polyline !== null && (this.props.onUnmount && this.props.onUnmount(this.state.polyline), mn(this.registeredEvents), this.state.polyline.setMap(null));
  }
  render() {
    return null;
  }
}
Ee(lDe, "contextType", It);
function sU(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function aU(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? sU(Object(n), !0).forEach(function(r) {
      Ee(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : sU(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var lU = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, uU = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  paths(e, t) {
    e.setPaths(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function uDe(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    paths: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: g,
    onMouseUp: f,
    onRightClick: m,
    onClick: v,
    onDrag: E,
    onLoad: w,
    onUnmount: M,
    onEdit: O
  } = e, y = ge(It), [C, _] = k(null), [F, L] = k(null), [N, R] = k(null), [W, V] = k(null), [z, Z] = k(null), [K, X] = k(null), [te, J] = k(null), [P, D] = k(null), [H, S] = k(null), [$, x] = k(null), [j, U] = k(null), [T, q] = k(null);
  return h(() => {
    C !== null && C.setMap(y);
  }, [y]), h(() => {
    typeof t < "u" && C !== null && C.setOptions(t);
  }, [C, t]), h(() => {
    typeof n < "u" && C !== null && C.setDraggable(n);
  }, [C, n]), h(() => {
    typeof r < "u" && C !== null && C.setEditable(r);
  }, [C, r]), h(() => {
    typeof o < "u" && C !== null && C.setVisible(o);
  }, [C, o]), h(() => {
    typeof i < "u" && C !== null && C.setPath(i);
  }, [C, i]), h(() => {
    typeof a < "u" && C !== null && C.setPaths(a);
  }, [C, a]), h(() => {
    C && typeof s == "function" && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(C, "dblclick", s)));
  }, [s]), h(() => {
    C && (google.maps.event.addListener(C.getPath(), "insert_at", () => {
      O == null || O(C);
    }), google.maps.event.addListener(C.getPath(), "set_at", () => {
      O == null || O(C);
    }), google.maps.event.addListener(C.getPath(), "remove_at", () => {
      O == null || O(C);
    }));
  }, [C, O]), h(() => {
    C && typeof l == "function" && (N !== null && google.maps.event.removeListener(N), R(google.maps.event.addListener(C, "dragend", l)));
  }, [l]), h(() => {
    C && typeof u == "function" && (W !== null && google.maps.event.removeListener(W), V(google.maps.event.addListener(C, "dragstart", u)));
  }, [u]), h(() => {
    C && typeof c == "function" && (z !== null && google.maps.event.removeListener(z), Z(google.maps.event.addListener(C, "mousedown", c)));
  }, [c]), h(() => {
    C && typeof p == "function" && (K !== null && google.maps.event.removeListener(K), X(google.maps.event.addListener(C, "mousemove", p)));
  }, [p]), h(() => {
    C && typeof d == "function" && (te !== null && google.maps.event.removeListener(te), J(google.maps.event.addListener(C, "mouseout", d)));
  }, [d]), h(() => {
    C && typeof g == "function" && (P !== null && google.maps.event.removeListener(P), D(google.maps.event.addListener(C, "mouseover", g)));
  }, [g]), h(() => {
    C && typeof f == "function" && (H !== null && google.maps.event.removeListener(H), S(google.maps.event.addListener(C, "mouseup", f)));
  }, [f]), h(() => {
    C && typeof m == "function" && ($ !== null && google.maps.event.removeListener($), x(google.maps.event.addListener(C, "rightclick", m)));
  }, [m]), h(() => {
    C && typeof v == "function" && (j !== null && google.maps.event.removeListener(j), U(google.maps.event.addListener(C, "click", v)));
  }, [v]), h(() => {
    C && typeof E == "function" && (T !== null && google.maps.event.removeListener(T), q(google.maps.event.addListener(C, "drag", E)));
  }, [E]), h(() => {
    var A = new google.maps.Polygon(aU(aU({}, t), {}, {
      map: y
    }));
    return i && A.setPath(i), a && A.setPaths(a), typeof o < "u" && A.setVisible(o), typeof r < "u" && A.setEditable(r), typeof n < "u" && A.setDraggable(n), s && L(google.maps.event.addListener(A, "dblclick", s)), l && R(google.maps.event.addListener(A, "dragend", l)), u && V(google.maps.event.addListener(A, "dragstart", u)), c && Z(google.maps.event.addListener(A, "mousedown", c)), p && X(google.maps.event.addListener(A, "mousemove", p)), d && J(google.maps.event.addListener(A, "mouseout", d)), g && D(google.maps.event.addListener(A, "mouseover", g)), f && S(google.maps.event.addListener(A, "mouseup", f)), m && x(google.maps.event.addListener(A, "rightclick", m)), v && U(google.maps.event.addListener(A, "click", v)), E && q(google.maps.event.addListener(A, "drag", E)), _(A), w && w(A), () => {
      F !== null && google.maps.event.removeListener(F), N !== null && google.maps.event.removeListener(N), W !== null && google.maps.event.removeListener(W), z !== null && google.maps.event.removeListener(z), K !== null && google.maps.event.removeListener(K), te !== null && google.maps.event.removeListener(te), P !== null && google.maps.event.removeListener(P), H !== null && google.maps.event.removeListener(H), $ !== null && google.maps.event.removeListener($), j !== null && google.maps.event.removeListener(j), M && M(A), A.setMap(null);
    };
  }, []), null;
}
ve(uDe);
class cDe extends pe {
  constructor() {
    super(...arguments), Ee(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this.props.options || {};
    this.polygon = new google.maps.Polygon(t), this.polygon.setMap(this.context), this.registeredEvents = cn({
      updaterMap: uU,
      eventMap: lU,
      prevProps: {},
      nextProps: this.props,
      instance: this.polygon
    }), this.props.onLoad && this.props.onLoad(this.polygon);
  }
  componentDidUpdate(t) {
    this.polygon && (mn(this.registeredEvents), this.registeredEvents = cn({
      updaterMap: uU,
      eventMap: lU,
      prevProps: t,
      nextProps: this.props,
      instance: this.polygon
    }));
  }
  componentWillUnmount() {
    this.polygon && (this.props.onUnmount && this.props.onUnmount(this.polygon), mn(this.registeredEvents), this.polygon && this.polygon.setMap(null));
  }
  render() {
    return null;
  }
}
Ee(cDe, "contextType", It);
function cU(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ly(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? cU(Object(n), !0).forEach(function(r) {
      Ee(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : cU(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var pU = {
  onBoundsChanged: "bounds_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, dU = {
  bounds(e, t) {
    e.setBounds(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function pDe(e) {
  var {
    options: t,
    bounds: n,
    draggable: r,
    editable: o,
    visible: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: g,
    onRightClick: f,
    onClick: m,
    onDrag: v,
    onBoundsChanged: E,
    onLoad: w,
    onUnmount: M
  } = e, O = ge(It), [y, C] = k(null), [_, F] = k(null), [L, N] = k(null), [R, W] = k(null), [V, z] = k(null), [Z, K] = k(null), [X, te] = k(null), [J, P] = k(null), [D, H] = k(null), [S, $] = k(null), [x, j] = k(null), [U, T] = k(null), [q, A] = k(null);
  return h(() => {
    y !== null && y.setMap(O);
  }, [O]), h(() => {
    typeof t < "u" && y !== null && y.setOptions(t);
  }, [y, t]), h(() => {
    typeof r < "u" && y !== null && y.setDraggable(r);
  }, [y, r]), h(() => {
    typeof o < "u" && y !== null && y.setEditable(o);
  }, [y, o]), h(() => {
    typeof i < "u" && y !== null && y.setVisible(i);
  }, [y, i]), h(() => {
    typeof n < "u" && y !== null && y.setBounds(n);
  }, [y, n]), h(() => {
    y && a && (_ !== null && google.maps.event.removeListener(_), F(google.maps.event.addListener(y, "dblclick", a)));
  }, [a]), h(() => {
    y && s && (L !== null && google.maps.event.removeListener(L), N(google.maps.event.addListener(y, "dragend", s)));
  }, [s]), h(() => {
    y && l && (R !== null && google.maps.event.removeListener(R), W(google.maps.event.addListener(y, "dragstart", l)));
  }, [l]), h(() => {
    y && u && (V !== null && google.maps.event.removeListener(V), z(google.maps.event.addListener(y, "mousedown", u)));
  }, [u]), h(() => {
    y && c && (Z !== null && google.maps.event.removeListener(Z), K(google.maps.event.addListener(y, "mousemove", c)));
  }, [c]), h(() => {
    y && p && (X !== null && google.maps.event.removeListener(X), te(google.maps.event.addListener(y, "mouseout", p)));
  }, [p]), h(() => {
    y && d && (J !== null && google.maps.event.removeListener(J), P(google.maps.event.addListener(y, "mouseover", d)));
  }, [d]), h(() => {
    y && g && (D !== null && google.maps.event.removeListener(D), H(google.maps.event.addListener(y, "mouseup", g)));
  }, [g]), h(() => {
    y && f && (S !== null && google.maps.event.removeListener(S), $(google.maps.event.addListener(y, "rightclick", f)));
  }, [f]), h(() => {
    y && m && (x !== null && google.maps.event.removeListener(x), j(google.maps.event.addListener(y, "click", m)));
  }, [m]), h(() => {
    y && v && (U !== null && google.maps.event.removeListener(U), T(google.maps.event.addListener(y, "drag", v)));
  }, [v]), h(() => {
    y && E && (q !== null && google.maps.event.removeListener(q), A(google.maps.event.addListener(y, "bounds_changed", E)));
  }, [E]), h(() => {
    var Y = new google.maps.Rectangle(ly(ly({}, t), {}, {
      map: O
    }));
    return typeof i < "u" && Y.setVisible(i), typeof o < "u" && Y.setEditable(o), typeof r < "u" && Y.setDraggable(r), typeof n < "u" && Y.setBounds(n), a && F(google.maps.event.addListener(Y, "dblclick", a)), s && N(google.maps.event.addListener(Y, "dragend", s)), l && W(google.maps.event.addListener(Y, "dragstart", l)), u && z(google.maps.event.addListener(Y, "mousedown", u)), c && K(google.maps.event.addListener(Y, "mousemove", c)), p && te(google.maps.event.addListener(Y, "mouseout", p)), d && P(google.maps.event.addListener(Y, "mouseover", d)), g && H(google.maps.event.addListener(Y, "mouseup", g)), f && $(google.maps.event.addListener(Y, "rightclick", f)), m && j(google.maps.event.addListener(Y, "click", m)), v && T(google.maps.event.addListener(Y, "drag", v)), E && A(google.maps.event.addListener(Y, "bounds_changed", E)), C(Y), w && w(Y), () => {
      _ !== null && google.maps.event.removeListener(_), L !== null && google.maps.event.removeListener(L), R !== null && google.maps.event.removeListener(R), V !== null && google.maps.event.removeListener(V), Z !== null && google.maps.event.removeListener(Z), X !== null && google.maps.event.removeListener(X), J !== null && google.maps.event.removeListener(J), D !== null && google.maps.event.removeListener(D), S !== null && google.maps.event.removeListener(S), x !== null && google.maps.event.removeListener(x), U !== null && google.maps.event.removeListener(U), q !== null && google.maps.event.removeListener(q), M && M(Y), Y.setMap(null);
    };
  }, []), null;
}
ve(pDe);
class dDe extends pe {
  constructor() {
    super(...arguments), Ee(this, "registeredEvents", []), Ee(this, "state", {
      rectangle: null
    }), Ee(this, "setRectangleCallback", () => {
      this.state.rectangle !== null && this.props.onLoad && this.props.onLoad(this.state.rectangle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Rectangle(ly(ly({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = cn({
      updaterMap: dU,
      eventMap: pU,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        rectangle: t
      };
    }, this.setRectangleCallback);
  }
  componentDidUpdate(t) {
    this.state.rectangle !== null && (mn(this.registeredEvents), this.registeredEvents = cn({
      updaterMap: dU,
      eventMap: pU,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.rectangle
    }));
  }
  componentWillUnmount() {
    this.state.rectangle !== null && (this.props.onUnmount && this.props.onUnmount(this.state.rectangle), mn(this.registeredEvents), this.state.rectangle.setMap(null));
  }
  render() {
    return null;
  }
}
Ee(dDe, "contextType", It);
function fU(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function uy(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? fU(Object(n), !0).forEach(function(r) {
      Ee(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : fU(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var hU = {
  onCenterChanged: "center_changed",
  onRadiusChanged: "radius_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, gU = {
  center(e, t) {
    e.setCenter(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  radius(e, t) {
    e.setRadius(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, fDe = {};
function hDe(e) {
  var {
    options: t,
    center: n,
    radius: r,
    draggable: o,
    editable: i,
    visible: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: g,
    onMouseUp: f,
    onRightClick: m,
    onClick: v,
    onDrag: E,
    onCenterChanged: w,
    onRadiusChanged: M,
    onLoad: O,
    onUnmount: y
  } = e, C = ge(It), [_, F] = k(null), [L, N] = k(null), [R, W] = k(null), [V, z] = k(null), [Z, K] = k(null), [X, te] = k(null), [J, P] = k(null), [D, H] = k(null), [S, $] = k(null), [x, j] = k(null), [U, T] = k(null), [q, A] = k(null), [Y, B] = k(null), [ue, fe] = k(null);
  return h(() => {
    _ !== null && _.setMap(C);
  }, [C]), h(() => {
    typeof t < "u" && _ !== null && _.setOptions(t);
  }, [_, t]), h(() => {
    typeof o < "u" && _ !== null && _.setDraggable(o);
  }, [_, o]), h(() => {
    typeof i < "u" && _ !== null && _.setEditable(i);
  }, [_, i]), h(() => {
    typeof a < "u" && _ !== null && _.setVisible(a);
  }, [_, a]), h(() => {
    typeof r == "number" && _ !== null && _.setRadius(r);
  }, [_, r]), h(() => {
    typeof n < "u" && _ !== null && _.setCenter(n);
  }, [_, n]), h(() => {
    _ && s && (L !== null && google.maps.event.removeListener(L), N(google.maps.event.addListener(_, "dblclick", s)));
  }, [s]), h(() => {
    _ && l && (R !== null && google.maps.event.removeListener(R), W(google.maps.event.addListener(_, "dragend", l)));
  }, [l]), h(() => {
    _ && u && (V !== null && google.maps.event.removeListener(V), z(google.maps.event.addListener(_, "dragstart", u)));
  }, [u]), h(() => {
    _ && c && (Z !== null && google.maps.event.removeListener(Z), K(google.maps.event.addListener(_, "mousedown", c)));
  }, [c]), h(() => {
    _ && p && (X !== null && google.maps.event.removeListener(X), te(google.maps.event.addListener(_, "mousemove", p)));
  }, [p]), h(() => {
    _ && d && (J !== null && google.maps.event.removeListener(J), P(google.maps.event.addListener(_, "mouseout", d)));
  }, [d]), h(() => {
    _ && g && (D !== null && google.maps.event.removeListener(D), H(google.maps.event.addListener(_, "mouseover", g)));
  }, [g]), h(() => {
    _ && f && (S !== null && google.maps.event.removeListener(S), $(google.maps.event.addListener(_, "mouseup", f)));
  }, [f]), h(() => {
    _ && m && (x !== null && google.maps.event.removeListener(x), j(google.maps.event.addListener(_, "rightclick", m)));
  }, [m]), h(() => {
    _ && v && (U !== null && google.maps.event.removeListener(U), T(google.maps.event.addListener(_, "click", v)));
  }, [v]), h(() => {
    _ && E && (q !== null && google.maps.event.removeListener(q), A(google.maps.event.addListener(_, "drag", E)));
  }, [E]), h(() => {
    _ && w && (Y !== null && google.maps.event.removeListener(Y), B(google.maps.event.addListener(_, "center_changed", w)));
  }, [v]), h(() => {
    _ && M && (ue !== null && google.maps.event.removeListener(ue), fe(google.maps.event.addListener(_, "radius_changed", M)));
  }, [M]), h(() => {
    var oe = new google.maps.Circle(uy(uy({}, t || fDe), {}, {
      map: C
    }));
    return typeof r == "number" && oe.setRadius(r), typeof n < "u" && oe.setCenter(n), typeof r == "number" && oe.setRadius(r), typeof a < "u" && oe.setVisible(a), typeof i < "u" && oe.setEditable(i), typeof o < "u" && oe.setDraggable(o), s && N(google.maps.event.addListener(oe, "dblclick", s)), l && W(google.maps.event.addListener(oe, "dragend", l)), u && z(google.maps.event.addListener(oe, "dragstart", u)), c && K(google.maps.event.addListener(oe, "mousedown", c)), p && te(google.maps.event.addListener(oe, "mousemove", p)), d && P(google.maps.event.addListener(oe, "mouseout", d)), g && H(google.maps.event.addListener(oe, "mouseover", g)), f && $(google.maps.event.addListener(oe, "mouseup", f)), m && j(google.maps.event.addListener(oe, "rightclick", m)), v && T(google.maps.event.addListener(oe, "click", v)), E && A(google.maps.event.addListener(oe, "drag", E)), w && B(google.maps.event.addListener(oe, "center_changed", w)), M && fe(google.maps.event.addListener(oe, "radius_changed", M)), F(oe), O && O(oe), () => {
      L !== null && google.maps.event.removeListener(L), R !== null && google.maps.event.removeListener(R), V !== null && google.maps.event.removeListener(V), Z !== null && google.maps.event.removeListener(Z), X !== null && google.maps.event.removeListener(X), J !== null && google.maps.event.removeListener(J), D !== null && google.maps.event.removeListener(D), S !== null && google.maps.event.removeListener(S), x !== null && google.maps.event.removeListener(x), U !== null && google.maps.event.removeListener(U), Y !== null && google.maps.event.removeListener(Y), ue !== null && google.maps.event.removeListener(ue), y && y(oe), oe.setMap(null);
    };
  }, []), null;
}
ve(hDe);
class gDe extends pe {
  constructor() {
    super(...arguments), Ee(this, "registeredEvents", []), Ee(this, "state", {
      circle: null
    }), Ee(this, "setCircleCallback", () => {
      this.state.circle !== null && this.props.onLoad && this.props.onLoad(this.state.circle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Circle(uy(uy({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = cn({
      updaterMap: gU,
      eventMap: hU,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        circle: t
      };
    }, this.setCircleCallback);
  }
  componentDidUpdate(t) {
    this.state.circle !== null && (mn(this.registeredEvents), this.registeredEvents = cn({
      updaterMap: gU,
      eventMap: hU,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.circle
    }));
  }
  componentWillUnmount() {
    if (this.state.circle !== null) {
      var t;
      this.props.onUnmount && this.props.onUnmount(this.state.circle), mn(this.registeredEvents), (t = this.state.circle) === null || t === void 0 || t.setMap(null);
    }
  }
  render() {
    return null;
  }
}
Ee(gDe, "contextType", It);
function mU(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function cy(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? mU(Object(n), !0).forEach(function(r) {
      Ee(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : mU(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var vU = {
  onClick: "click",
  onDblClick: "dblclick",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onAddFeature: "addfeature",
  onRemoveFeature: "removefeature",
  onRemoveProperty: "removeproperty",
  onSetGeometry: "setgeometry",
  onSetProperty: "setproperty"
}, yU = {
  add(e, t) {
    e.add(t);
  },
  addgeojson(e, t, n) {
    e.addGeoJson(t, n);
  },
  contains(e, t) {
    e.contains(t);
  },
  foreach(e, t) {
    e.forEach(t);
  },
  loadgeojson(e, t, n, r) {
    e.loadGeoJson(t, n, r);
  },
  overridestyle(e, t, n) {
    e.overrideStyle(t, n);
  },
  remove(e, t) {
    e.remove(t);
  },
  revertstyle(e, t) {
    e.revertStyle(t);
  },
  controlposition(e, t) {
    e.setControlPosition(t);
  },
  controls(e, t) {
    e.setControls(t);
  },
  drawingmode(e, t) {
    e.setDrawingMode(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  style(e, t) {
    e.setStyle(t);
  },
  togeojson(e, t) {
    e.toGeoJson(t);
  }
};
function mDe(e) {
  var {
    options: t,
    onClick: n,
    onDblClick: r,
    onMouseDown: o,
    onMouseMove: i,
    onMouseOut: a,
    onMouseOver: s,
    onMouseUp: l,
    onRightClick: u,
    onAddFeature: c,
    onRemoveFeature: p,
    onRemoveProperty: d,
    onSetGeometry: g,
    onSetProperty: f,
    onLoad: m,
    onUnmount: v
  } = e, E = ge(It), [w, M] = k(null), [O, y] = k(null), [C, _] = k(null), [F, L] = k(null), [N, R] = k(null), [W, V] = k(null), [z, Z] = k(null), [K, X] = k(null), [te, J] = k(null), [P, D] = k(null), [H, S] = k(null), [$, x] = k(null), [j, U] = k(null), [T, q] = k(null);
  return h(() => {
    w !== null && w.setMap(E);
  }, [E]), h(() => {
    w && r && (O !== null && google.maps.event.removeListener(O), y(google.maps.event.addListener(w, "dblclick", r)));
  }, [r]), h(() => {
    w && o && (C !== null && google.maps.event.removeListener(C), _(google.maps.event.addListener(w, "mousedown", o)));
  }, [o]), h(() => {
    w && i && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(w, "mousemove", i)));
  }, [i]), h(() => {
    w && a && (N !== null && google.maps.event.removeListener(N), R(google.maps.event.addListener(w, "mouseout", a)));
  }, [a]), h(() => {
    w && s && (W !== null && google.maps.event.removeListener(W), V(google.maps.event.addListener(w, "mouseover", s)));
  }, [s]), h(() => {
    w && l && (z !== null && google.maps.event.removeListener(z), Z(google.maps.event.addListener(w, "mouseup", l)));
  }, [l]), h(() => {
    w && u && (K !== null && google.maps.event.removeListener(K), X(google.maps.event.addListener(w, "rightclick", u)));
  }, [u]), h(() => {
    w && n && (te !== null && google.maps.event.removeListener(te), J(google.maps.event.addListener(w, "click", n)));
  }, [n]), h(() => {
    w && c && (P !== null && google.maps.event.removeListener(P), D(google.maps.event.addListener(w, "addfeature", c)));
  }, [c]), h(() => {
    w && p && (H !== null && google.maps.event.removeListener(H), S(google.maps.event.addListener(w, "removefeature", p)));
  }, [p]), h(() => {
    w && d && ($ !== null && google.maps.event.removeListener($), x(google.maps.event.addListener(w, "removeproperty", d)));
  }, [d]), h(() => {
    w && g && (j !== null && google.maps.event.removeListener(j), U(google.maps.event.addListener(w, "setgeometry", g)));
  }, [g]), h(() => {
    w && f && (T !== null && google.maps.event.removeListener(T), q(google.maps.event.addListener(w, "setproperty", f)));
  }, [f]), h(() => {
    if (E !== null) {
      var A = new google.maps.Data(cy(cy({}, t), {}, {
        map: E
      }));
      r && y(google.maps.event.addListener(A, "dblclick", r)), o && _(google.maps.event.addListener(A, "mousedown", o)), i && L(google.maps.event.addListener(A, "mousemove", i)), a && R(google.maps.event.addListener(A, "mouseout", a)), s && V(google.maps.event.addListener(A, "mouseover", s)), l && Z(google.maps.event.addListener(A, "mouseup", l)), u && X(google.maps.event.addListener(A, "rightclick", u)), n && J(google.maps.event.addListener(A, "click", n)), c && D(google.maps.event.addListener(A, "addfeature", c)), p && S(google.maps.event.addListener(A, "removefeature", p)), d && x(google.maps.event.addListener(A, "removeproperty", d)), g && U(google.maps.event.addListener(A, "setgeometry", g)), f && q(google.maps.event.addListener(A, "setproperty", f)), M(A), m && m(A);
    }
    return () => {
      w && (O !== null && google.maps.event.removeListener(O), C !== null && google.maps.event.removeListener(C), F !== null && google.maps.event.removeListener(F), N !== null && google.maps.event.removeListener(N), W !== null && google.maps.event.removeListener(W), z !== null && google.maps.event.removeListener(z), K !== null && google.maps.event.removeListener(K), te !== null && google.maps.event.removeListener(te), P !== null && google.maps.event.removeListener(P), H !== null && google.maps.event.removeListener(H), $ !== null && google.maps.event.removeListener($), j !== null && google.maps.event.removeListener(j), T !== null && google.maps.event.removeListener(T), v && v(w), w.setMap(null));
    };
  }, []), null;
}
ve(mDe);
class vDe extends pe {
  constructor() {
    super(...arguments), Ee(this, "registeredEvents", []), Ee(this, "state", {
      data: null
    }), Ee(this, "setDataCallback", () => {
      this.state.data !== null && this.props.onLoad && this.props.onLoad(this.state.data);
    });
  }
  componentDidMount() {
    if (this.context !== null) {
      var t = new google.maps.Data(cy(cy({}, this.props.options), {}, {
        map: this.context
      }));
      this.registeredEvents = cn({
        updaterMap: yU,
        eventMap: vU,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        data: t
      }), this.setDataCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.data !== null && (mn(this.registeredEvents), this.registeredEvents = cn({
      updaterMap: yU,
      eventMap: vU,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.data
    }));
  }
  componentWillUnmount() {
    this.state.data !== null && (this.props.onUnmount && this.props.onUnmount(this.state.data), mn(this.registeredEvents), this.state.data && this.state.data.setMap(null));
  }
  render() {
    return null;
  }
}
Ee(vDe, "contextType", It);
function bU(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function wU(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? bU(Object(n), !0).forEach(function(r) {
      Ee(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : bU(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var CU = {
  onClick: "click",
  onDefaultViewportChanged: "defaultviewport_changed",
  onStatusChanged: "status_changed"
}, xU = {
  options(e, t) {
    e.setOptions(t);
  },
  url(e, t) {
    e.setUrl(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
class yDe extends pe {
  constructor() {
    super(...arguments), Ee(this, "registeredEvents", []), Ee(this, "state", {
      kmlLayer: null
    }), Ee(this, "setKmlLayerCallback", () => {
      this.state.kmlLayer !== null && this.props.onLoad && this.props.onLoad(this.state.kmlLayer);
    });
  }
  componentDidMount() {
    var t = new google.maps.KmlLayer(wU(wU({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = cn({
      updaterMap: xU,
      eventMap: CU,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        kmlLayer: t
      };
    }, this.setKmlLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.kmlLayer !== null && (mn(this.registeredEvents), this.registeredEvents = cn({
      updaterMap: xU,
      eventMap: CU,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.kmlLayer
    }));
  }
  componentWillUnmount() {
    this.state.kmlLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.kmlLayer), mn(this.registeredEvents), this.state.kmlLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Ee(yDe, "contextType", It);
function QG(e, t) {
  return typeof t == "function" ? t(e.offsetWidth, e.offsetHeight) : {
    x: 0,
    y: 0
  };
}
function bDe(e, t) {
  return new t(e.lat, e.lng);
}
function wDe(e, t) {
  return new t(new google.maps.LatLng(e.ne.lat, e.ne.lng), new google.maps.LatLng(e.sw.lat, e.sw.lng));
}
function CDe(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function xDe(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function ODe(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n.getNorthEast()), o = e && e.fromLatLngToDivPixel(n.getSouthWest());
  return r && o ? {
    left: "".concat(o.x + t.x, "px"),
    top: "".concat(r.y + t.y, "px"),
    width: "".concat(r.x - o.x - t.x, "px"),
    height: "".concat(o.y - r.y - t.y, "px")
  } : {
    left: "-9999px",
    top: "-9999px"
  };
}
function EDe(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n);
  if (r) {
    var {
      x: o,
      y: i
    } = r;
    return {
      left: "".concat(o + t.x, "px"),
      top: "".concat(i + t.y, "px")
    };
  }
  return {
    left: "-9999px",
    top: "-9999px"
  };
}
function eK(e, t, n, r) {
  return n !== void 0 ? ODe(e, t, xDe(n, google.maps.LatLngBounds, wDe)) : EDe(e, t, CDe(r, google.maps.LatLng, bDe));
}
function kDe(e, t) {
  return e.left === t.left && e.top === t.top && e.width === t.height && e.height === t.height;
}
function OU(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function LDe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? OU(Object(n), !0).forEach(function(r) {
      Ee(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : OU(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function PDe(e, t, n, r, o) {
  class i extends google.maps.OverlayView {
    constructor(s, l, u, c) {
      super(), this.container = s, this.pane = l, this.position = u, this.bounds = c;
    }
    onAdd() {
      var s, l = (s = this.getPanes()) === null || s === void 0 ? void 0 : s[this.pane];
      l == null || l.appendChild(this.container);
    }
    draw() {
      var s = this.getProjection(), l = LDe({}, this.container ? QG(this.container, o) : {
        x: 0,
        y: 0
      }), u = eK(s, l, this.bounds, this.position);
      for (var [c, p] of Object.entries(u))
        this.container.style[c] = p;
    }
    onRemove() {
      this.container.parentNode !== null && this.container.parentNode.removeChild(this.container);
    }
  }
  return new i(e, t, n, r);
}
function EU(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function _De(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? EU(Object(n), !0).forEach(function(r) {
      Ee(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : EU(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function kU(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLng ? e : new google.maps.LatLng(e.lat, e.lng);
  return t + "";
}
function LU(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLngBounds ? e : new google.maps.LatLngBounds(new google.maps.LatLng(e.south, e.east), new google.maps.LatLng(e.north, e.west));
  return t + "";
}
function SDe(e) {
  var {
    position: t,
    bounds: n,
    mapPaneName: r,
    zIndex: o,
    onLoad: i,
    onUnmount: a,
    getPixelPositionOffset: s,
    children: l
  } = e, u = ge(It), c = Cn(() => {
    var d = document.createElement("div");
    return d.style.position = "absolute", d;
  }, []), p = Cn(() => PDe(c, r, t, n, s), [c, r, t, n]);
  return h(() => (i == null || i(p), p == null || p.setMap(u), () => {
    a == null || a(p), p == null || p.setMap(null);
  }), [u, p]), h(() => {
    c.style.zIndex = "".concat(o);
  }, [o, c]), wi.createPortal(l, c);
}
ve(SDe);
class Ic extends pe {
  constructor(t) {
    super(t), Ee(this, "state", {
      paneEl: null,
      containerStyle: {
        // set initial position
        position: "absolute"
      }
    }), Ee(this, "updatePane", () => {
      var r = this.props.mapPaneName, o = this.overlayView.getPanes();
      Co(!!r, "OverlayView requires props.mapPaneName but got %s", r), o ? this.setState({
        paneEl: o[r]
      }) : this.setState({
        paneEl: null
      });
    }), Ee(this, "onAdd", () => {
      var r, o;
      this.updatePane(), (r = (o = this.props).onLoad) === null || r === void 0 || r.call(o, this.overlayView);
    }), Ee(this, "onPositionElement", () => {
      var r = this.overlayView.getProjection(), o = _De({
        x: 0,
        y: 0
      }, this.containerRef.current ? QG(this.containerRef.current, this.props.getPixelPositionOffset) : {}), i = eK(r, o, this.props.bounds, this.props.position);
      if (!kDe(i, {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        left: this.state.containerStyle.left,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        top: this.state.containerStyle.top,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        width: this.state.containerStyle.width,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        height: this.state.containerStyle.height
      })) {
        var a, s, l, u;
        this.setState({
          containerStyle: {
            top: (a = i.top) !== null && a !== void 0 ? a : 0,
            left: (s = i.left) !== null && s !== void 0 ? s : 0,
            width: (l = i.width) !== null && l !== void 0 ? l : 0,
            height: (u = i.height) !== null && u !== void 0 ? u : 0,
            position: "absolute"
          }
        });
      }
    }), Ee(this, "draw", () => {
      this.onPositionElement();
    }), Ee(this, "onRemove", () => {
      var r, o;
      this.setState(() => ({
        paneEl: null
      })), (r = (o = this.props).onUnmount) === null || r === void 0 || r.call(o, this.overlayView);
    }), this.containerRef = mo();
    var n = new google.maps.OverlayView();
    n.onAdd = this.onAdd, n.draw = this.draw, n.onRemove = this.onRemove, this.overlayView = n;
  }
  componentDidMount() {
    this.overlayView.setMap(this.context);
  }
  componentDidUpdate(t) {
    var n = kU(t.position), r = kU(this.props.position), o = LU(t.bounds), i = LU(this.props.bounds);
    (n !== r || o !== i) && this.overlayView.draw(), t.mapPaneName !== this.props.mapPaneName && this.updatePane();
  }
  componentWillUnmount() {
    this.overlayView.setMap(null);
  }
  render() {
    var t = this.state.paneEl;
    return t ? wi.createPortal(_o.jsx("div", {
      ref: this.containerRef,
      style: this.state.containerStyle,
      children: lt.only(this.props.children)
    }), t) : null;
  }
}
Ee(Ic, "FLOAT_PANE", "floatPane");
Ee(Ic, "MAP_PANE", "mapPane");
Ee(Ic, "MARKER_LAYER", "markerLayer");
Ee(Ic, "OVERLAY_LAYER", "overlayLayer");
Ee(Ic, "OVERLAY_MOUSE_TARGET", "overlayMouseTarget");
Ee(Ic, "contextType", It);
function MDe() {
}
function PU(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function _U(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? PU(Object(n), !0).forEach(function(r) {
      Ee(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : PU(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var SU = {
  onDblClick: "dblclick",
  onClick: "click"
}, MU = {
  opacity(e, t) {
    e.setOpacity(t);
  }
};
function DDe(e) {
  var {
    url: t,
    bounds: n,
    options: r,
    visible: o
  } = e, i = ge(It), a = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east)), s = Cn(() => new google.maps.GroundOverlay(t, a, r), []);
  return h(() => {
    s !== null && s.setMap(i);
  }, [i]), h(() => {
    typeof t < "u" && s !== null && (s.set("url", t), s.setMap(i));
  }, [s, t]), h(() => {
    typeof o < "u" && s !== null && s.setOpacity(o ? 1 : 0);
  }, [s, o]), h(() => {
    var l = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east));
    typeof n < "u" && s !== null && (s.set("bounds", l), s.setMap(i));
  }, [s, n]), null;
}
ve(DDe);
class tK extends pe {
  constructor() {
    super(...arguments), Ee(this, "registeredEvents", []), Ee(this, "state", {
      groundOverlay: null
    }), Ee(this, "setGroundOverlayCallback", () => {
      this.state.groundOverlay !== null && this.props.onLoad && this.props.onLoad(this.state.groundOverlay);
    });
  }
  componentDidMount() {
    Co(!!this.props.url || !!this.props.bounds, "For GroundOverlay, url and bounds are passed in to constructor and are immutable after instantiated. This is the behavior of Google Maps JavaScript API v3 ( See https://developers.google.com/maps/documentation/javascript/reference#GroundOverlay) Hence, use the corresponding two props provided by `react-google-maps-api`, url and bounds. In some cases, you'll need the GroundOverlay component to reflect the changes of url and bounds. You can leverage the React's key property to remount the component. Typically, just `key={url}` would serve your need. See https://github.com/tomchentw/react-google-maps/issues/655");
    var t = new google.maps.GroundOverlay(this.props.url, this.props.bounds, _U(_U({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = cn({
      updaterMap: MU,
      eventMap: SU,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        groundOverlay: t
      };
    }, this.setGroundOverlayCallback);
  }
  componentDidUpdate(t) {
    this.state.groundOverlay !== null && (mn(this.registeredEvents), this.registeredEvents = cn({
      updaterMap: MU,
      eventMap: SU,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.groundOverlay
    }));
  }
  componentWillUnmount() {
    this.state.groundOverlay && (this.props.onUnmount && this.props.onUnmount(this.state.groundOverlay), this.state.groundOverlay.setMap(null));
  }
  render() {
    return null;
  }
}
Ee(tK, "defaultProps", {
  onLoad: MDe
});
Ee(tK, "contextType", It);
function DU(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function py(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? DU(Object(n), !0).forEach(function(r) {
      Ee(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : DU(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var TU = {}, jU = {
  data(e, t) {
    e.setData(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function TDe(e) {
  var {
    data: t,
    onLoad: n,
    onUnmount: r,
    options: o
  } = e, i = ge(It), [a, s] = k(null);
  return h(() => {
    google.maps.visualization || Co(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} in useJsApiScript? %s', google.maps.visualization);
  }, []), h(() => {
    Co(!!t, "data property is required in HeatmapLayer %s", t);
  }, [t]), h(() => {
    a !== null && a.setMap(i);
  }, [i]), h(() => {
    o && a !== null && a.setOptions(o);
  }, [a, o]), h(() => {
    var l = new google.maps.visualization.HeatmapLayer(py(py({}, o), {}, {
      data: t,
      map: i
    }));
    return s(l), n && n(l), () => {
      a !== null && (r && r(a), a.setMap(null));
    };
  }, []), null;
}
ve(TDe);
class jDe extends pe {
  constructor() {
    super(...arguments), Ee(this, "registeredEvents", []), Ee(this, "state", {
      heatmapLayer: null
    }), Ee(this, "setHeatmapLayerCallback", () => {
      this.state.heatmapLayer !== null && this.props.onLoad && this.props.onLoad(this.state.heatmapLayer);
    });
  }
  componentDidMount() {
    Co(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} to <LoadScript />? %s', google.maps.visualization), Co(!!this.props.data, "data property is required in HeatmapLayer %s", this.props.data);
    var t = new google.maps.visualization.HeatmapLayer(py(py({}, this.props.options), {}, {
      data: this.props.data,
      map: this.context
    }));
    this.registeredEvents = cn({
      updaterMap: jU,
      eventMap: TU,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        heatmapLayer: t
      };
    }, this.setHeatmapLayerCallback);
  }
  componentDidUpdate(t) {
    mn(this.registeredEvents), this.registeredEvents = cn({
      updaterMap: jU,
      eventMap: TU,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.heatmapLayer
    });
  }
  componentWillUnmount() {
    this.state.heatmapLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.heatmapLayer), mn(this.registeredEvents), this.state.heatmapLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Ee(jDe, "contextType", It);
var AU = {
  onCloseClick: "closeclick",
  onPanoChanged: "pano_changed",
  onPositionChanged: "position_changed",
  onPovChanged: "pov_changed",
  onResize: "resize",
  onStatusChanged: "status_changed",
  onVisibleChanged: "visible_changed",
  onZoomChanged: "zoom_changed"
}, IU = {
  register(e, t, n) {
    e.registerPanoProvider(t, n);
  },
  links(e, t) {
    e.setLinks(t);
  },
  motionTracking(e, t) {
    e.setMotionTracking(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  pano(e, t) {
    e.setPano(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  pov(e, t) {
    e.setPov(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zoom(e, t) {
    e.setZoom(t);
  }
};
class ADe extends pe {
  constructor() {
    super(...arguments), Ee(this, "registeredEvents", []), Ee(this, "state", {
      streetViewPanorama: null
    }), Ee(this, "setStreetViewPanoramaCallback", () => {
      this.state.streetViewPanorama !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewPanorama);
    });
  }
  componentDidMount() {
    var t, n, r = (t = (n = this.context) === null || n === void 0 ? void 0 : n.getStreetView()) !== null && t !== void 0 ? t : null;
    this.registeredEvents = cn({
      updaterMap: IU,
      eventMap: AU,
      prevProps: {},
      nextProps: this.props,
      instance: r
    }), this.setState(() => ({
      streetViewPanorama: r
    }), this.setStreetViewPanoramaCallback);
  }
  componentDidUpdate(t) {
    this.state.streetViewPanorama !== null && (mn(this.registeredEvents), this.registeredEvents = cn({
      updaterMap: IU,
      eventMap: AU,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.streetViewPanorama
    }));
  }
  componentWillUnmount() {
    this.state.streetViewPanorama !== null && (this.props.onUnmount && this.props.onUnmount(this.state.streetViewPanorama), mn(this.registeredEvents), this.state.streetViewPanorama.setVisible(!1));
  }
  render() {
    return null;
  }
}
Ee(ADe, "contextType", It);
class IDe extends pe {
  constructor() {
    super(...arguments), Ee(this, "state", {
      streetViewService: null
    }), Ee(this, "setStreetViewServiceCallback", () => {
      this.state.streetViewService !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewService);
    });
  }
  componentDidMount() {
    var t = new google.maps.StreetViewService();
    this.setState(function() {
      return {
        streetViewService: t
      };
    }, this.setStreetViewServiceCallback);
  }
  componentWillUnmount() {
    this.state.streetViewService !== null && this.props.onUnmount && this.props.onUnmount(this.state.streetViewService);
  }
  render() {
    return null;
  }
}
Ee(IDe, "contextType", It);
var RU = {
  onDirectionsChanged: "directions_changed"
}, BU = {
  directions(e, t) {
    e.setDirections(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  panel(e, t) {
    e.setPanel(t);
  },
  routeIndex(e, t) {
    e.setRouteIndex(t);
  }
};
class RDe extends pe {
  constructor() {
    super(...arguments), Ee(this, "registeredEvents", []), Ee(this, "state", {
      directionsRenderer: null
    }), Ee(this, "setDirectionsRendererCallback", () => {
      this.state.directionsRenderer !== null && (this.state.directionsRenderer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.directionsRenderer));
    });
  }
  componentDidMount() {
    var t = new google.maps.DirectionsRenderer(this.props.options);
    this.registeredEvents = cn({
      updaterMap: BU,
      eventMap: RU,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        directionsRenderer: t
      };
    }, this.setDirectionsRendererCallback);
  }
  componentDidUpdate(t) {
    this.state.directionsRenderer !== null && (mn(this.registeredEvents), this.registeredEvents = cn({
      updaterMap: BU,
      eventMap: RU,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.directionsRenderer
    }));
  }
  componentWillUnmount() {
    this.state.directionsRenderer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.directionsRenderer), mn(this.registeredEvents), this.state.directionsRenderer && this.state.directionsRenderer.setMap(null));
  }
  render() {
    return null;
  }
}
Ee(RDe, "contextType", It);
var NU = {
  onPlacesChanged: "places_changed"
}, FU = {
  bounds(e, t) {
    e.setBounds(t);
  }
};
class BDe extends pe {
  constructor() {
    super(...arguments), Ee(this, "registeredEvents", []), Ee(this, "containerElement", mo()), Ee(this, "state", {
      searchBox: null
    }), Ee(this, "setSearchBoxCallback", () => {
      this.state.searchBox !== null && this.props.onLoad && this.props.onLoad(this.state.searchBox);
    });
  }
  componentDidMount() {
    if (Co(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places), this.containerElement !== null && this.containerElement.current !== null) {
      var t = this.containerElement.current.querySelector("input");
      if (t !== null) {
        var n = new google.maps.places.SearchBox(t, this.props.options);
        this.registeredEvents = cn({
          updaterMap: FU,
          eventMap: NU,
          prevProps: {},
          nextProps: this.props,
          instance: n
        }), this.setState(function() {
          return {
            searchBox: n
          };
        }, this.setSearchBoxCallback);
      }
    }
  }
  componentDidUpdate(t) {
    this.state.searchBox !== null && (mn(this.registeredEvents), this.registeredEvents = cn({
      updaterMap: FU,
      eventMap: NU,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.searchBox
    }));
  }
  componentWillUnmount() {
    this.state.searchBox !== null && (this.props.onUnmount && this.props.onUnmount(this.state.searchBox), mn(this.registeredEvents));
  }
  render() {
    return _o.jsx("div", {
      ref: this.containerElement,
      children: lt.only(this.props.children)
    });
  }
}
Ee(BDe, "contextType", It);
var zU = {
  onPlaceChanged: "place_changed"
}, UU = {
  bounds(e, t) {
    e.setBounds(t);
  },
  restrictions(e, t) {
    e.setComponentRestrictions(t);
  },
  fields(e, t) {
    e.setFields(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  types(e, t) {
    e.setTypes(t);
  }
};
class nK extends pe {
  constructor() {
    super(...arguments), Ee(this, "registeredEvents", []), Ee(this, "containerElement", mo()), Ee(this, "state", {
      autocomplete: null
    }), Ee(this, "setAutocompleteCallback", () => {
      this.state.autocomplete !== null && this.props.onLoad && this.props.onLoad(this.state.autocomplete);
    });
  }
  componentDidMount() {
    var t;
    Co(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places);
    var n = (t = this.containerElement.current) === null || t === void 0 ? void 0 : t.querySelector("input");
    if (n) {
      var r = new google.maps.places.Autocomplete(n, this.props.options);
      this.registeredEvents = cn({
        updaterMap: UU,
        eventMap: zU,
        prevProps: {},
        nextProps: this.props,
        instance: r
      }), this.setState(() => ({
        autocomplete: r
      }), this.setAutocompleteCallback);
    }
  }
  componentDidUpdate(t) {
    mn(this.registeredEvents), this.registeredEvents = cn({
      updaterMap: UU,
      eventMap: zU,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.autocomplete
    });
  }
  componentWillUnmount() {
    this.state.autocomplete !== null && mn(this.registeredEvents);
  }
  render() {
    return _o.jsx("div", {
      ref: this.containerElement,
      className: this.props.className,
      children: lt.only(this.props.children)
    });
  }
}
Ee(nK, "defaultProps", {
  className: ""
});
Ee(nK, "contextType", It);
let NDe = { data: "" }, FDe = (e) => typeof window == "object" ? ((e ? e.querySelector("#_goober") : window._goober) || Object.assign((e || document.head).appendChild(document.createElement("style")), { innerHTML: " ", id: "_goober" })).firstChild : e || NDe, zDe = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g, UDe = /\/\*[^]*?\*\/|  +/g, HU = /\n+/g, nl = (e, t) => {
  let n = "", r = "", o = "";
  for (let i in e) {
    let a = e[i];
    i[0] == "@" ? i[1] == "i" ? n = i + " " + a + ";" : r += i[1] == "f" ? nl(a, i) : i + "{" + nl(a, i[1] == "k" ? "" : t) + "}" : typeof a == "object" ? r += nl(a, t ? t.replace(/([^,])+/g, (s) => i.replace(/([^,]*:\S+\([^)]*\))|([^,])+/g, (l) => /&/.test(l) ? l.replace(/&/g, s) : s ? s + " " + l : l)) : i) : a != null && (i = /^--/.test(i) ? i : i.replace(/[A-Z]/g, "-$&").toLowerCase(), o += nl.p ? nl.p(i, a) : i + ":" + a + ";");
  }
  return n + (t && o ? t + "{" + o + "}" : o) + r;
}, Ys = {}, rK = (e) => {
  if (typeof e == "object") {
    let t = "";
    for (let n in e) t += n + rK(e[n]);
    return t;
  }
  return e;
}, HDe = (e, t, n, r, o) => {
  let i = rK(e), a = Ys[i] || (Ys[i] = ((l) => {
    let u = 0, c = 11;
    for (; u < l.length; ) c = 101 * c + l.charCodeAt(u++) >>> 0;
    return "go" + c;
  })(i));
  if (!Ys[a]) {
    let l = i !== e ? e : ((u) => {
      let c, p, d = [{}];
      for (; c = zDe.exec(u.replace(UDe, "")); ) c[4] ? d.shift() : c[3] ? (p = c[3].replace(HU, " ").trim(), d.unshift(d[0][p] = d[0][p] || {})) : d[0][c[1]] = c[2].replace(HU, " ").trim();
      return d[0];
    })(e);
    Ys[a] = nl(o ? { ["@keyframes " + a]: l } : l, n ? "" : "." + a);
  }
  let s = n && Ys.g ? Ys.g : null;
  return n && (Ys.g = Ys[a]), ((l, u, c, p) => {
    p ? u.data = u.data.replace(p, l) : u.data.indexOf(l) === -1 && (u.data = c ? l + u.data : u.data + l);
  })(Ys[a], t, r, s), a;
}, $De = (e, t, n) => e.reduce((r, o, i) => {
  let a = t[i];
  if (a && a.call) {
    let s = a(n), l = s && s.props && s.props.className || /^go/.test(s) && s;
    a = l ? "." + l : s && typeof s == "object" ? s.props ? "" : nl(s, "") : s === !1 ? "" : s;
  }
  return r + o + (a ?? "");
}, "");
function Jw(e) {
  let t = this || {}, n = e.call ? e(t.p) : e;
  return HDe(n.unshift ? n.raw ? $De(n, [].slice.call(arguments, 1), t.p) : n.reduce((r, o) => Object.assign(r, o && o.call ? o(t.p) : o), {}) : n, FDe(t.target), t.g, t.o, t.k);
}
let oK, zk, Uk;
Jw.bind({ g: 1 });
let pa = Jw.bind({ k: 1 });
function WDe(e, t, n, r) {
  nl.p = t, oK = e, zk = n, Uk = r;
}
function Sl(e, t) {
  let n = this || {};
  return function() {
    let r = arguments;
    function o(i, a) {
      let s = Object.assign({}, i), l = s.className || o.className;
      n.p = Object.assign({ theme: zk && zk() }, s), n.o = / *go\d+/.test(l), s.className = Jw.apply(n, r) + (l ? " " + l : "");
      let u = e;
      return e[0] && (u = s.as || e, delete s.as), Uk && u[0] && Uk(s), oK(u, s);
    }
    return o;
  };
}
var VDe = (e) => typeof e == "function", ZDe = (e, t) => VDe(e) ? e(t) : e, qDe = /* @__PURE__ */ (() => {
  let e;
  return () => {
    if (e === void 0 && typeof window < "u") {
      let t = matchMedia("(prefers-reduced-motion: reduce)");
      e = !t || t.matches;
    }
    return e;
  };
})(), GDe = pa`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`, KDe = pa`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`, YDe = pa`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`, XDe = Sl("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${GDe} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${KDe} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${(e) => e.secondary || "#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${YDe} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`, JDe = pa`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, QDe = Sl("div")`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${(e) => e.secondary || "#e0e0e0"};
  border-right-color: ${(e) => e.primary || "#616161"};
  animation: ${JDe} 1s linear infinite;
`, eTe = pa`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`, tTe = pa`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`, nTe = Sl("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${eTe} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${tTe} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${(e) => e.secondary || "#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`, rTe = Sl("div")`
  position: absolute;
`, oTe = Sl("div")`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`, iTe = pa`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`, sTe = Sl("div")`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${iTe} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`, aTe = ({ toast: e }) => {
  let { icon: t, type: n, iconTheme: r } = e;
  return t !== void 0 ? typeof t == "string" ? Be.createElement(sTe, null, t) : t : n === "blank" ? null : Be.createElement(oTe, null, Be.createElement(QDe, { ...r }), n !== "loading" && Be.createElement(rTe, null, n === "error" ? Be.createElement(XDe, { ...r }) : Be.createElement(nTe, { ...r })));
}, lTe = (e) => `
0% {transform: translate3d(0,${e * -200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`, uTe = (e) => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${e * -150}%,-1px) scale(.6); opacity:0;}
`, cTe = "0%{opacity:0;} 100%{opacity:1;}", pTe = "0%{opacity:1;} 100%{opacity:0;}", dTe = Sl("div")`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`, fTe = Sl("div")`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`, hTe = (e, t) => {
  let n = e.includes("top") ? 1 : -1, [r, o] = qDe() ? [cTe, pTe] : [lTe(n), uTe(n)];
  return { animation: t ? `${pa(r)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards` : `${pa(o)} 0.4s forwards cubic-bezier(.06,.71,.55,1)` };
};
Be.memo(({ toast: e, position: t, style: n, children: r }) => {
  let o = e.height ? hTe(e.position || t || "top-center", e.visible) : { opacity: 0 }, i = Be.createElement(aTe, { toast: e }), a = Be.createElement(fTe, { ...e.ariaProps }, ZDe(e.message, e));
  return Be.createElement(dTe, { className: e.className, style: { ...o, ...n, ...e.style } }, typeof r == "function" ? r({ icon: i, message: a }) : Be.createElement(Be.Fragment, null, i, a));
});
WDe(Be.createElement);
Jw`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`;
Ke({});
function gTe(e) {
  return e && e.replace(/[^0-9]/g, "");
}
const mTe = {
  CNPJ: "99.999.999/9999-99"
};
gTe(mTe.CNPJ).length;
to((e, t) => /* @__PURE__ */ Po.jsx("input", { ref: t, ...e }));
function iK(e) {
  return e && e.replace(/[^0-9]/g, "");
}
const sK = {
  EIGTH: "(99) 9999-9999",
  NINE: "(99) 99999-9999"
};
function vTe(e, t) {
  let n = "", r = 0;
  for (let o = 0; o < t.length; o++)
    if (t[o] === "9")
      if (r < e.length)
        n += e[r], r++;
      else
        break;
    else if (r < e.length)
      n += t[o];
    else
      break;
  return n;
}
function yTe(e) {
  return e.length > 10 ? "NINE" : "EIGTH";
}
const bTe = iK(sK.NINE).length, wTe = to((e, t) => /* @__PURE__ */ Po.jsx("input", { ref: t, ...e }));
to(
  (e, t) => {
    const { onFocus: n, onBlur: r, size: o, onChange: i, value: a, currentCountry: s, disabled: l } = e, [u, c] = k(!1);
    h(() => {
      u ? i(s.mask) : c(!0);
    }, [s]);
    const p = `phoneInputMask ${o}`;
    function d(g) {
      let f = iK(g.target.value);
      const m = yTe(f);
      f.length > bTe || (f = vTe(f, sK[m]), g.target.value = f, i(f));
    }
    return s.code === "+55" ? /* @__PURE__ */ Po.jsx(
      "input",
      {
        value: a,
        onChange: d,
        className: p,
        onFocus: n,
        onBlur: r,
        disabled: l,
        ref: t
      }
    ) : /* @__PURE__ */ Po.jsx(
      cl,
      {
        value: a,
        onChange: (g) => i(g.target.value),
        className: p,
        component: wTe,
        onFocus: n,
        onBlur: r,
        disabled: l,
        mask: s.mask,
        showMask: !0,
        replacement: { _: /\d/ },
        ref: t
      }
    );
  }
);
Ke({});
var ba = {};
Object.defineProperty(ba, "__esModule", {
  value: !0
});
var CTe = typeof window < "u" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform), jx = {
  alt: "altKey",
  control: "ctrlKey",
  meta: "metaKey",
  shift: "shiftKey"
}, aK = {
  add: "+",
  break: "pause",
  cmd: "meta",
  command: "meta",
  ctl: "control",
  ctrl: "control",
  del: "delete",
  down: "arrowdown",
  esc: "escape",
  ins: "insert",
  left: "arrowleft",
  mod: CTe ? "meta" : "control",
  opt: "alt",
  option: "alt",
  return: "enter",
  right: "arrowright",
  space: " ",
  spacebar: " ",
  up: "arrowup",
  win: "meta",
  windows: "meta"
}, A_ = {
  backspace: 8,
  tab: 9,
  enter: 13,
  shift: 16,
  control: 17,
  alt: 18,
  pause: 19,
  capslock: 20,
  escape: 27,
  " ": 32,
  pageup: 33,
  pagedown: 34,
  end: 35,
  home: 36,
  arrowleft: 37,
  arrowup: 38,
  arrowright: 39,
  arrowdown: 40,
  insert: 45,
  delete: 46,
  meta: 91,
  numlock: 144,
  scrolllock: 145,
  ";": 186,
  "=": 187,
  ",": 188,
  "-": 189,
  ".": 190,
  "/": 191,
  "`": 192,
  "[": 219,
  "\\": 220,
  "]": 221,
  "'": 222
};
for (var Ug = 1; Ug < 20; Ug++)
  A_["f" + Ug] = 111 + Ug;
function Qw(e, t, n) {
  t && !("byKey" in t) && (n = t, t = null), Array.isArray(e) || (e = [e]);
  var r = e.map(function(a) {
    return lK(a, t);
  }), o = function(a) {
    return r.some(function(s) {
      return uK(s, a);
    });
  }, i = n == null ? o : o(n);
  return i;
}
function xTe(e, t) {
  return Qw(e, t);
}
function OTe(e, t) {
  return Qw(e, { byKey: !0 }, t);
}
function lK(e, t) {
  var n = t && t.byKey, r = {};
  e = e.replace("++", "+add");
  var o = e.split("+"), i = o.length;
  for (var a in jx)
    r[jx[a]] = !1;
  var s = !0, l = !1, u = void 0;
  try {
    for (var c = o[Symbol.iterator](), p; !(s = (p = c.next()).done); s = !0) {
      var d = p.value, g = d.endsWith("?") && d.length > 1;
      g && (d = d.slice(0, -1));
      var f = I_(d), m = jx[f];
      if (d.length > 1 && !m && !aK[d] && !A_[f])
        throw new TypeError('Unknown modifier: "' + d + '"');
      (i === 1 || !m) && (n ? r.key = f : r.which = cK(d)), m && (r[m] = g ? null : !0);
    }
  } catch (v) {
    l = !0, u = v;
  } finally {
    try {
      !s && c.return && c.return();
    } finally {
      if (l)
        throw u;
    }
  }
  return r;
}
function uK(e, t) {
  for (var n in e) {
    var r = e[n], o = void 0;
    if (r != null && (n === "key" && t.key != null ? o = t.key.toLowerCase() : n === "which" ? o = r === 91 && t.which === 93 ? 91 : t.which : o = t[n], !(o == null && r === !1) && o !== r))
      return !1;
  }
  return !0;
}
function cK(e) {
  e = I_(e);
  var t = A_[e] || e.toUpperCase().charCodeAt(0);
  return t;
}
function I_(e) {
  return e = e.toLowerCase(), e = aK[e] || e, e;
}
ba.default = Qw;
var Ax = ba.isHotkey = Qw;
ba.isCodeHotkey = xTe;
ba.isKeyHotkey = OTe;
ba.parseHotkey = lK;
ba.compareHotkey = uK;
ba.toKeyCode = cK;
ba.toKeyName = I_;
var ETe = typeof Qn == "object" && Qn && Qn.Object === Object && Qn, kTe = ETe, LTe = kTe, PTe = typeof self == "object" && self && self.Object === Object && self, _Te = LTe || PTe || Function("return this")(), STe = _Te, MTe = STe, DTe = MTe.Symbol, pK = DTe, $U = pK;
$U && $U.toStringTag;
var WU = pK;
WU && WU.toStringTag;
var VU;
(function(e) {
  e.BORDER_BOX = "border-box", e.CONTENT_BOX = "content-box", e.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(VU || (VU = {}));
var R_ = function(e) {
  return Object.freeze(e);
}, TTe = /* @__PURE__ */ function() {
  function e(t, n) {
    this.inlineSize = t, this.blockSize = n, R_(this);
  }
  return e;
}(), jTe = function() {
  function e(t, n, r, o) {
    return this.x = t, this.y = n, this.width = r, this.height = o, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, R_(this);
  }
  return e.prototype.toJSON = function() {
    var t = this, n = t.x, r = t.y, o = t.top, i = t.right, a = t.bottom, s = t.left, l = t.width, u = t.height;
    return { x: n, y: r, top: o, right: i, bottom: a, left: s, width: l, height: u };
  }, e.fromRect = function(t) {
    return new e(t.x, t.y, t.width, t.height);
  }, e;
}(), ZU = typeof window < "u" ? window : {};
/msie|trident/i.test(ZU.navigator && ZU.navigator.userAgent);
var Ix = function(e, t, n) {
  return e === void 0 && (e = 0), t === void 0 && (t = 0), n === void 0 && (n = !1), new TTe((n ? t : e) || 0, (n ? e : t) || 0);
};
R_({
  devicePixelContentBoxSize: Ix(),
  borderBoxSize: Ix(),
  contentBoxSize: Ix(),
  contentRect: new jTe(0, 0, 0, 0)
});
function af(e) {
  "@babel/helpers - typeof";
  return af = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, af(e);
}
function ATe(e, t) {
  if (af(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (af(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function ITe(e) {
  var t = ATe(e, "string");
  return af(t) === "symbol" ? t : String(t);
}
function ld(e, t, n) {
  return t = ITe(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
var RTe = /* @__PURE__ */ Ke(null), Rx, Bx;
parseInt(we.version.split(".")[0], 10);
var qU = typeof navigator < "u" && /Mac OS X/.test(navigator.userAgent), Nx = typeof navigator < "u" && /Android/.test(navigator.userAgent), Hg = typeof navigator < "u" && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent), BTe = typeof navigator < "u" && /Chrome/i.test(navigator.userAgent);
typeof navigator < "u" && /Safari/.test(navigator.userAgent) && /Version\/(\d+)/.test(navigator.userAgent) && (Rx = navigator.userAgent.match(/Version\/(\d+)/)) !== null && Rx !== void 0 && Rx[1] && parseInt((Bx = navigator.userAgent.match(/Version\/(\d+)/)) === null || Bx === void 0 ? void 0 : Bx[1], 10) < 17;
var NTe = /* @__PURE__ */ new WeakMap(), FTe = /* @__PURE__ */ new WeakMap(), zTe = /* @__PURE__ */ new WeakMap(), UTe = /* @__PURE__ */ new WeakMap(), HTe = /* @__PURE__ */ new WeakMap(), GU = /* @__PURE__ */ new WeakMap(), $Te = /* @__PURE__ */ new WeakMap(), KU = /* @__PURE__ */ new WeakMap(), $g = /* @__PURE__ */ new WeakMap(), WTe = /* @__PURE__ */ new WeakMap(), VTe = /* @__PURE__ */ new WeakMap(), ZTe = /* @__PURE__ */ new WeakMap(), dK = globalThis.Node, qTe = globalThis.Text, fK = (e) => e && e.ownerDocument && e.ownerDocument.defaultView || null, GTe = (e) => dy(e) && e.nodeType === 8, Ms = (e) => dy(e) && e.nodeType === 1, dy = (e) => {
  var t = fK(e);
  return !!t && e instanceof t.Node;
}, YU = (e) => {
  var t = e && e.anchorNode && fK(e.anchorNode);
  return !!t && e instanceof t.Selection;
}, KTe = (e) => {
  var [t, n] = e;
  if (Ms(t) && t.childNodes.length) {
    var r = n === t.childNodes.length, o = r ? n - 1 : n;
    for ([t, o] = hK(t, o, r ? "backward" : "forward"), r = o < n; Ms(t) && t.childNodes.length; ) {
      var i = r ? t.childNodes.length - 1 : 0;
      t = XTe(t, i, r ? "backward" : "forward");
    }
    n = r && t.textContent != null ? t.textContent.length : 0;
  }
  return [t, n];
}, YTe = (e) => {
  for (var t = e && e.parentNode; t; ) {
    if (t.toString() === "[object ShadowRoot]")
      return !0;
    t = t.parentNode;
  }
  return !1;
}, hK = (e, t, n) => {
  for (var {
    childNodes: r
  } = e, o = r[t], i = t, a = !1, s = !1; (GTe(o) || Ms(o) && o.childNodes.length === 0 || Ms(o) && o.getAttribute("contenteditable") === "false") && !(a && s); ) {
    if (i >= r.length) {
      a = !0, i = t - 1, n = "backward";
      continue;
    }
    if (i < 0) {
      s = !0, i = t + 1, n = "forward";
      continue;
    }
    o = r[i], t = i, i += n === "forward" ? 1 : -1;
  }
  return [o, t];
}, XTe = (e, t, n) => {
  var [r] = hK(e, t, n);
  return r;
}, XU = (e) => e.getSelection != null ? e.getSelection() : document.getSelection(), gK = (e, t, n) => {
  var {
    target: r
  } = t;
  if (Ms(r) && r.matches('[contentEditable="false"]'))
    return !1;
  var {
    document: o
  } = on.getWindow(e);
  if (o.contains(r))
    return on.hasDOMNode(e, r, {
      editable: !0
    });
  var i = n.find((a) => {
    var {
      addedNodes: s,
      removedNodes: l
    } = a;
    for (var u of s)
      if (u === r || u.contains(r))
        return !0;
    for (var c of l)
      if (c === r || c.contains(r))
        return !0;
  });
  return !i || i === t ? !1 : gK(e, i, n);
}, JU = (e, t) => !!(e.compareDocumentPosition(t) & dK.DOCUMENT_POSITION_PRECEDING), JTe = (e, t) => !!(e.compareDocumentPosition(t) & dK.DOCUMENT_POSITION_FOLLOWING), QTe = 0;
class eje {
  constructor() {
    ld(this, "id", void 0), this.id = "".concat(QTe++);
  }
}
var on = {
  androidPendingDiffs: (e) => ZTe.get(e),
  androidScheduleFlush: (e) => {
    var t;
    (t = VTe.get(e)) === null || t === void 0 || t();
  },
  blur: (e) => {
    var t = on.toDOMNode(e, e), n = on.findDocumentOrShadowRoot(e);
    $g.set(e, !1), n.activeElement === t && t.blur();
  },
  deselect: (e) => {
    var {
      selection: t
    } = e, n = on.findDocumentOrShadowRoot(e), r = XU(n);
    r && r.rangeCount > 0 && r.removeAllRanges(), t && ev.deselect(e);
  },
  findDocumentOrShadowRoot: (e) => {
    var t = on.toDOMNode(e, e), n = t.getRootNode();
    return n instanceof Document || n instanceof ShadowRoot ? n : t.ownerDocument;
  },
  findEventRange: (e, t) => {
    "nativeEvent" in t && (t = t.nativeEvent);
    var {
      clientX: n,
      clientY: r,
      target: o
    } = t;
    if (n == null || r == null)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var i = on.toSlateNode(e, t.target), a = on.findPath(e, i);
    if (ta.isElement(i) && Zn.isVoid(e, i)) {
      var s = o.getBoundingClientRect(), l = e.isInline(i) ? n - s.left < s.left + s.width - n : r - s.top < s.top + s.height - r, u = Zn.point(e, a, {
        edge: l ? "start" : "end"
      }), c = l ? Zn.before(e, u) : Zn.after(e, u);
      if (c) {
        var p = Zn.range(e, c);
        return p;
      }
    }
    var d, {
      document: g
    } = on.getWindow(e);
    if (g.caretRangeFromPoint)
      d = g.caretRangeFromPoint(n, r);
    else {
      var f = g.caretPositionFromPoint(n, r);
      f && (d = g.createRange(), d.setStart(f.offsetNode, f.offset), d.setEnd(f.offsetNode, f.offset));
    }
    if (!d)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var m = on.toSlateRange(e, d, {
      exactMatch: !1,
      suppressThrow: !1
    });
    return m;
  },
  findKey: (e, t) => {
    var n = GU.get(t);
    return n || (n = new eje(), GU.set(t, n)), n;
  },
  findPath: (e, t) => {
    for (var n = [], r = t; ; ) {
      var o = FTe.get(r);
      if (o == null) {
        if (Zn.isEditor(r))
          return n;
        break;
      }
      var i = NTe.get(r);
      if (i == null)
        break;
      n.unshift(i), r = o;
    }
    throw new Error("Unable to find the path for Slate node: ".concat(_i.stringify(t)));
  },
  focus: function(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      retries: 5
    };
    if (!$g.get(e)) {
      if (t.retries <= 0)
        throw new Error("Could not set focus, editor seems stuck with pending operations");
      if (e.operations.length > 0) {
        setTimeout(() => {
          on.focus(e, {
            retries: t.retries - 1
          });
        }, 10);
        return;
      }
      var n = on.toDOMNode(e, e), r = on.findDocumentOrShadowRoot(e);
      if (r.activeElement !== n) {
        if (e.selection && r instanceof Document) {
          var o = XU(r), i = on.toDOMRange(e, e.selection);
          o == null || o.removeAllRanges(), o == null || o.addRange(i);
        }
        e.selection || ev.select(e, Zn.start(e, [])), $g.set(e, !0), n.focus({
          preventScroll: !0
        });
      }
    }
  },
  getWindow: (e) => {
    var t = zTe.get(e);
    if (!t)
      throw new Error("Unable to find a host window element for this editor");
    return t;
  },
  hasDOMNode: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      editable: r = !1
    } = n, o = on.toDOMNode(e, e), i;
    try {
      i = Ms(t) ? t : t.parentElement;
    } catch (a) {
      if (a instanceof Error && !a.message.includes('Permission denied to access property "nodeType"'))
        throw a;
    }
    return i ? i.closest("[data-slate-editor]") === o && (!r || i.isContentEditable ? !0 : typeof i.isContentEditable == "boolean" && // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined
    // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable="false"(readOnly)
    i.closest('[contenteditable="false"]') === o || !!i.getAttribute("data-slate-zero-width")) : !1;
  },
  hasEditableTarget: (e, t) => dy(t) && on.hasDOMNode(e, t, {
    editable: !0
  }),
  hasRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t;
    return Zn.hasPath(e, n.path) && Zn.hasPath(e, r.path);
  },
  hasSelectableTarget: (e, t) => on.hasEditableTarget(e, t) || on.isTargetInsideNonReadonlyVoid(e, t),
  hasTarget: (e, t) => dy(t) && on.hasDOMNode(e, t),
  insertData: (e, t) => {
    e.insertData(t);
  },
  insertFragmentData: (e, t) => e.insertFragmentData(t),
  insertTextData: (e, t) => e.insertTextData(t),
  isComposing: (e) => !!WTe.get(e),
  isFocused: (e) => !!$g.get(e),
  isReadOnly: (e) => !!KU.get(e),
  isTargetInsideNonReadonlyVoid: (e, t) => {
    if (KU.get(e)) return !1;
    var n = on.hasTarget(e, t) && on.toSlateNode(e, t);
    return ta.isElement(n) && Zn.isVoid(e, n);
  },
  setFragmentData: (e, t, n) => e.setFragmentData(t, n),
  toDOMNode: (e, t) => {
    var n = $Te.get(e), r = Zn.isEditor(t) ? UTe.get(e) : n == null ? void 0 : n.get(on.findKey(e, t));
    if (!r)
      throw new Error("Cannot resolve a DOM node from Slate node: ".concat(_i.stringify(t)));
    return r;
  },
  toDOMPoint: (e, t) => {
    var [n] = Zn.node(e, t.path), r = on.toDOMNode(e, n), o;
    Zn.void(e, {
      at: t
    }) && (t = {
      path: t.path,
      offset: 0
    });
    for (var i = "[data-slate-string], [data-slate-zero-width]", a = Array.from(r.querySelectorAll(i)), s = 0, l = 0; l < a.length; l++) {
      var u = a[l], c = u.childNodes[0];
      if (!(c == null || c.textContent == null)) {
        var {
          length: p
        } = c.textContent, d = u.getAttribute("data-slate-length"), g = d == null ? p : parseInt(d, 10), f = s + g, m = a[l + 1];
        if (t.offset === f && m !== null && m !== void 0 && m.hasAttribute("data-slate-mark-placeholder")) {
          var v, E = m.childNodes[0];
          o = [
            // COMPAT: If we don't explicity set the dom point to be on the actual
            // dom text element, chrome will put the selection behind the actual dom
            // text element, causing domRange.getBoundingClientRect() calls on a collapsed
            // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)
            // which will cause issues when scrolling to it.
            E instanceof qTe ? E : m,
            (v = m.textContent) !== null && v !== void 0 && v.startsWith("\uFEFF") ? 1 : 0
          ];
          break;
        }
        if (t.offset <= f) {
          var w = Math.min(p, Math.max(0, t.offset - s));
          o = [c, w];
          break;
        }
        s = f;
      }
    }
    if (!o)
      throw new Error("Cannot resolve a DOM point from Slate point: ".concat(_i.stringify(t)));
    return o;
  },
  toDOMRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t, o = zt.isBackward(t), i = on.toDOMPoint(e, n), a = zt.isCollapsed(t) ? i : on.toDOMPoint(e, r), s = on.getWindow(e), l = s.document.createRange(), [u, c] = o ? a : i, [p, d] = o ? i : a, g = Ms(u) ? u : u.parentElement, f = !!g.getAttribute("data-slate-zero-width"), m = Ms(p) ? p : p.parentElement, v = !!m.getAttribute("data-slate-zero-width");
    return l.setStart(u, f ? 1 : c), l.setEnd(p, v ? 1 : d), l;
  },
  toSlateNode: (e, t) => {
    var n = Ms(t) ? t : t.parentElement;
    n && !n.hasAttribute("data-slate-node") && (n = n.closest("[data-slate-node]"));
    var r = n ? HTe.get(n) : null;
    if (!r)
      throw new Error("Cannot resolve a Slate node from DOM node: ".concat(n));
    return r;
  },
  toSlatePoint: (e, t, n) => {
    var {
      exactMatch: r,
      suppressThrow: o,
      searchDirection: i = "backward"
    } = n, [a, s] = r ? t : KTe(t), l = a.parentNode, u = null, c = 0;
    if (l) {
      var p, d, g = on.toDOMNode(e, e), f = l.closest('[data-slate-void="true"]'), m = f && g.contains(f) ? f : null, v = l.closest('[contenteditable="false"]'), E = v && g.contains(v) ? v : null, w = l.closest("[data-slate-leaf]"), M = null;
      if (w) {
        if (u = w.closest('[data-slate-node="text"]'), u) {
          var O = on.getWindow(e), y = O.document.createRange();
          y.setStart(u, 0), y.setEnd(a, s);
          var C = y.cloneContents(), _ = [...Array.prototype.slice.call(C.querySelectorAll("[data-slate-zero-width]")), ...Array.prototype.slice.call(C.querySelectorAll("[contenteditable=false]"))];
          _.forEach((S) => {
            if (Nx && !r && S.hasAttribute("data-slate-zero-width") && S.textContent.length > 0 && S.textContext !== "\uFEFF") {
              S.textContent.startsWith("\uFEFF") && (S.textContent = S.textContent.slice(1));
              return;
            }
            S.parentNode.removeChild(S);
          }), c = C.textContent.length, M = u;
        }
      } else if (m) {
        for (var F = m.querySelectorAll("[data-slate-leaf]"), L = 0; L < F.length; L++) {
          var N = F[L];
          if (on.hasDOMNode(e, N)) {
            w = N;
            break;
          }
        }
        w ? (u = w.closest('[data-slate-node="text"]'), M = w, c = M.textContent.length, M.querySelectorAll("[data-slate-zero-width]").forEach((S) => {
          c -= S.textContent.length;
        })) : c = 1;
      } else if (E) {
        var R = (S) => S ? S.querySelectorAll(
          // Exclude leaf nodes in nested editors
          "[data-slate-leaf]:not(:scope [data-slate-editor] [data-slate-leaf])"
        ) : [], W = E.closest('[data-slate-node="element"]');
        if (i === "forward") {
          var V, z = [...R(W), ...R(W == null ? void 0 : W.nextElementSibling)];
          w = (V = z.find((S) => JTe(E, S))) !== null && V !== void 0 ? V : null;
        } else {
          var Z, K = [...R(W == null ? void 0 : W.previousElementSibling), ...R(W)];
          w = (Z = K.findLast((S) => JU(E, S))) !== null && Z !== void 0 ? Z : null;
        }
        w && (u = w.closest('[data-slate-node="text"]'), M = w, i === "forward" ? c = 0 : (c = M.textContent.length, M.querySelectorAll("[data-slate-zero-width]").forEach((S) => {
          c -= S.textContent.length;
        })));
      }
      M && c === M.textContent.length && // COMPAT: Android IMEs might remove the zero width space while composing,
      // and we don't add it for line-breaks.
      Nx && M.getAttribute("data-slate-zero-width") === "z" && (p = M.textContent) !== null && p !== void 0 && p.startsWith("\uFEFF") && // COMPAT: If the parent node is a Slate zero-width space, editor is
      // because the text node should have no characters. However, during IME
      // composition the ASCII characters will be prepended to the zero-width
      // space, so subtract 1 from the offset to account for the zero-width
      // space character.
      (l.hasAttribute("data-slate-zero-width") || // COMPAT: In Firefox, `range.cloneContents()` returns an extra trailing '\n'
      // when the document ends with a new-line character. This results in the offset
      // length being off by one, so we need to subtract one to account for this.
      Hg && (d = M.textContent) !== null && d !== void 0 && d.endsWith(`

`)) && c--;
    }
    if (Nx && !u && !r) {
      var X = l.hasAttribute("data-slate-node") ? l : l.closest("[data-slate-node]");
      if (X && on.hasDOMNode(e, X, {
        editable: !0
      })) {
        var te = on.toSlateNode(e, X), {
          path: J,
          offset: P
        } = Zn.start(e, on.findPath(e, te));
        return X.querySelector("[data-slate-leaf]") || (P = s), {
          path: J,
          offset: P
        };
      }
    }
    if (!u) {
      if (o)
        return null;
      throw new Error("Cannot resolve a Slate point from DOM point: ".concat(t));
    }
    var D = on.toSlateNode(e, u), H = on.findPath(e, D);
    return {
      path: H,
      offset: c
    };
  },
  toSlateRange: (e, t, n) => {
    var r, {
      exactMatch: o,
      suppressThrow: i
    } = n, a = YU(t) ? t.anchorNode : t.startContainer, s, l, u, c, p;
    if (a)
      if (YU(t)) {
        if (Hg && t.rangeCount > 1) {
          u = t.focusNode;
          var d = t.getRangeAt(0), g = t.getRangeAt(t.rangeCount - 1);
          if (u instanceof HTMLTableRowElement && d.startContainer instanceof HTMLTableRowElement && g.startContainer instanceof HTMLTableRowElement) {
            let C = function(_) {
              return _.childElementCount > 0 ? C(_.children[0]) : _;
            };
            var f = d.startContainer, m = g.startContainer, v = C(f.children[d.startOffset]), E = C(m.children[g.startOffset]);
            c = 0, E.childNodes.length > 0 ? s = E.childNodes[0] : s = E, v.childNodes.length > 0 ? u = v.childNodes[0] : u = v, E instanceof HTMLElement ? l = E.innerHTML.length : l = 0;
          } else
            d.startContainer === u ? (s = g.endContainer, l = g.endOffset, c = d.startOffset) : (s = d.startContainer, l = d.endOffset, c = g.startOffset);
        } else
          s = t.anchorNode, l = t.anchorOffset, u = t.focusNode, c = t.focusOffset;
        BTe && YTe(s) || Hg ? p = t.anchorNode === t.focusNode && t.anchorOffset === t.focusOffset : p = t.isCollapsed;
      } else
        s = t.startContainer, l = t.startOffset, u = t.endContainer, c = t.endOffset, p = t.collapsed;
    if (s == null || u == null || l == null || c == null)
      throw new Error("Cannot resolve a Slate range from DOM range: ".concat(t));
    Hg && (r = u.textContent) !== null && r !== void 0 && r.endsWith(`

`) && c === u.textContent.length && c--;
    var w = on.toSlatePoint(e, [s, l], {
      exactMatch: o,
      suppressThrow: i
    });
    if (!w)
      return null;
    var M = JU(s, u) || s === u && c < l, O = p ? w : on.toSlatePoint(e, [u, c], {
      exactMatch: o,
      suppressThrow: i,
      searchDirection: M ? "forward" : "backward"
    });
    if (!O)
      return null;
    var y = {
      anchor: w,
      focus: O
    };
    return zt.isExpanded(y) && zt.isForward(y) && Ms(u) && Zn.void(e, {
      at: y.focus,
      mode: "highest"
    }) && (y = Zn.unhangRange(e, y, {
      voids: !0
    })), y;
  }
}, tje = {
  bold: "mod+b",
  compose: ["down", "left", "right", "up", "backspace", "enter"],
  moveBackward: "left",
  moveForward: "right",
  moveWordBackward: "ctrl+left",
  moveWordForward: "ctrl+right",
  deleteBackward: "shift?+backspace",
  deleteForward: "shift?+delete",
  extendBackward: "shift+left",
  extendForward: "shift+right",
  italic: "mod+i",
  insertSoftBreak: "shift+enter",
  splitBlock: "enter",
  undo: "mod+z"
}, nje = {
  moveLineBackward: "opt+up",
  moveLineForward: "opt+down",
  moveWordBackward: "opt+left",
  moveWordForward: "opt+right",
  deleteBackward: ["ctrl+backspace", "ctrl+h"],
  deleteForward: ["ctrl+delete", "ctrl+d"],
  deleteLineBackward: "cmd+shift?+backspace",
  deleteLineForward: ["cmd+shift?+delete", "ctrl+k"],
  deleteWordBackward: "opt+shift?+backspace",
  deleteWordForward: "opt+shift?+delete",
  extendLineBackward: "opt+shift+up",
  extendLineForward: "opt+shift+down",
  redo: "cmd+shift+z",
  transposeCharacter: "ctrl+t"
}, rje = {
  deleteWordBackward: "ctrl+shift?+backspace",
  deleteWordForward: "ctrl+shift?+delete",
  redo: ["ctrl+y", "ctrl+shift+z"]
}, Ar = (e) => {
  var t = tje[e], n = nje[e], r = rje[e], o = t && Ax(t), i = n && Ax(n), a = r && Ax(r);
  return (s) => !!(o && o(s) || qU && i && i(s) || !qU && a && a(s));
};
Ar("bold"), Ar("compose"), Ar("moveBackward"), Ar("moveForward"), Ar("deleteBackward"), Ar("deleteForward"), Ar("deleteLineBackward"), Ar("deleteLineForward"), Ar("deleteWordBackward"), Ar("deleteWordForward"), Ar("extendBackward"), Ar("extendForward"), Ar("extendLineBackward"), Ar("extendLineForward"), Ar("italic"), Ar("moveLineBackward"), Ar("moveLineForward"), Ar("moveWordBackward"), Ar("moveWordForward"), Ar("redo"), Ar("insertSoftBreak"), Ar("splitBlock"), Ar("transposeCharacter"), Ar("undo");
var oje = (e, t) => {
  var n = [], r = () => {
    n = [];
  }, o = (a) => {
    if (t.current) {
      var s = a.filter((l) => gK(e, l, a));
      n.push(...s);
    }
  };
  function i() {
    n.length > 0 && (n.reverse().forEach((a) => {
      a.type !== "characterData" && (a.removedNodes.forEach((s) => {
        a.target.insertBefore(s, a.nextSibling);
      }), a.addedNodes.forEach((s) => {
        a.target.removeChild(s);
      }));
    }), r());
  }
  return {
    registerMutations: o,
    restoreDOM: i,
    clear: r
  };
}, ije = {
  subtree: !0,
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0
};
class sje extends Wu {
  constructor() {
    super(...arguments), ld(this, "context", null), ld(this, "manager", null), ld(this, "mutationObserver", null);
  }
  observe() {
    var t, {
      node: n
    } = this.props;
    if (!n.current)
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    (t = this.mutationObserver) === null || t === void 0 || t.observe(n.current, ije);
  }
  componentDidMount() {
    var {
      receivedUserInput: t
    } = this.props, n = this.context;
    this.manager = oje(n, t), this.mutationObserver = new MutationObserver(this.manager.registerMutations), this.observe();
  }
  getSnapshotBeforeUpdate() {
    var t, n, r, o = (t = this.mutationObserver) === null || t === void 0 ? void 0 : t.takeRecords();
    if (o != null && o.length) {
      var i;
      (i = this.manager) === null || i === void 0 || i.registerMutations(o);
    }
    return (n = this.mutationObserver) === null || n === void 0 || n.disconnect(), (r = this.manager) === null || r === void 0 || r.restoreDOM(), null;
  }
  componentDidUpdate() {
    var t;
    (t = this.manager) === null || t === void 0 || t.clear(), this.observe();
  }
  componentWillUnmount() {
    var t;
    (t = this.mutationObserver) === null || t === void 0 || t.disconnect();
  }
  render() {
    return this.props.children;
  }
}
ld(sje, "contextType", RTe);
Ke({});
Ke({});
Ke({});
var fo = {}, B_ = {}, Vf = {}, Zf = {}, mK = "Expected a function", QU = NaN, aje = "[object Symbol]", lje = /^\s+|\s+$/g, uje = /^[-+]0x[0-9a-f]+$/i, cje = /^0b[01]+$/i, pje = /^0o[0-7]+$/i, dje = parseInt, fje = typeof Qn == "object" && Qn && Qn.Object === Object && Qn, hje = typeof self == "object" && self && self.Object === Object && self, gje = fje || hje || Function("return this")(), mje = Object.prototype, vje = mje.toString, yje = Math.max, bje = Math.min, Fx = function() {
  return gje.Date.now();
};
function wje(e, t, n) {
  var r, o, i, a, s, l, u = 0, c = !1, p = !1, d = !0;
  if (typeof e != "function")
    throw new TypeError(mK);
  t = eH(t) || 0, fy(n) && (c = !!n.leading, p = "maxWait" in n, i = p ? yje(eH(n.maxWait) || 0, t) : i, d = "trailing" in n ? !!n.trailing : d);
  function g(C) {
    var _ = r, F = o;
    return r = o = void 0, u = C, a = e.apply(F, _), a;
  }
  function f(C) {
    return u = C, s = setTimeout(E, t), c ? g(C) : a;
  }
  function m(C) {
    var _ = C - l, F = C - u, L = t - _;
    return p ? bje(L, i - F) : L;
  }
  function v(C) {
    var _ = C - l, F = C - u;
    return l === void 0 || _ >= t || _ < 0 || p && F >= i;
  }
  function E() {
    var C = Fx();
    if (v(C))
      return w(C);
    s = setTimeout(E, m(C));
  }
  function w(C) {
    return s = void 0, d && r ? g(C) : (r = o = void 0, a);
  }
  function M() {
    s !== void 0 && clearTimeout(s), u = 0, r = l = o = s = void 0;
  }
  function O() {
    return s === void 0 ? a : w(Fx());
  }
  function y() {
    var C = Fx(), _ = v(C);
    if (r = arguments, o = this, l = C, _) {
      if (s === void 0)
        return f(l);
      if (p)
        return s = setTimeout(E, t), g(l);
    }
    return s === void 0 && (s = setTimeout(E, t)), a;
  }
  return y.cancel = M, y.flush = O, y;
}
function Cje(e, t, n) {
  var r = !0, o = !0;
  if (typeof e != "function")
    throw new TypeError(mK);
  return fy(n) && (r = "leading" in n ? !!n.leading : r, o = "trailing" in n ? !!n.trailing : o), wje(e, t, {
    leading: r,
    maxWait: t,
    trailing: o
  });
}
function fy(e) {
  var t = typeof e;
  return !!e && (t == "object" || t == "function");
}
function xje(e) {
  return !!e && typeof e == "object";
}
function Oje(e) {
  return typeof e == "symbol" || xje(e) && vje.call(e) == aje;
}
function eH(e) {
  if (typeof e == "number")
    return e;
  if (Oje(e))
    return QU;
  if (fy(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = fy(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = e.replace(lje, "");
  var n = cje.test(e);
  return n || pje.test(e) ? dje(e.slice(2), n ? 2 : 8) : uje.test(e) ? QU : +e;
}
var Eje = Cje, qf = {};
Object.defineProperty(qf, "__esModule", {
  value: !0
});
qf.addPassiveEventListener = function(e, t, n) {
  var r = n.name;
  r || (r = t, console.warn("Listener must be a named function.")), Dm.has(t) || Dm.set(t, /* @__PURE__ */ new Set());
  var o = Dm.get(t);
  if (!o.has(r)) {
    var i = function() {
      var a = !1;
      try {
        var s = Object.defineProperty({}, "passive", {
          get: function() {
            a = !0;
          }
        });
        window.addEventListener("test", null, s);
      } catch {
      }
      return a;
    }();
    e.addEventListener(t, n, i ? { passive: !0 } : !1), o.add(r);
  }
};
qf.removePassiveEventListener = function(e, t, n) {
  e.removeEventListener(t, n), Dm.get(t).delete(n.name || t);
};
var Dm = /* @__PURE__ */ new Map();
Object.defineProperty(Zf, "__esModule", {
  value: !0
});
var kje = Eje, Lje = Pje(kje), tH = qf;
function Pje(e) {
  return e && e.__esModule ? e : { default: e };
}
var _je = function(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 66;
  return (0, Lje.default)(e, t);
}, Vr = {
  spyCallbacks: [],
  spySetState: [],
  scrollSpyContainers: [],
  mount: function(e, t) {
    if (e) {
      var n = _je(function(r) {
        Vr.scrollHandler(e);
      }, t);
      return Vr.scrollSpyContainers.push(e), (0, tH.addPassiveEventListener)(e, "scroll", n), function() {
        (0, tH.removePassiveEventListener)(e, "scroll", n), Vr.scrollSpyContainers.splice(Vr.scrollSpyContainers.indexOf(e), 1);
      };
    }
    return function() {
    };
  },
  isMounted: function(e) {
    return Vr.scrollSpyContainers.indexOf(e) !== -1;
  },
  currentPositionX: function(e) {
    if (e === document) {
      var t = window.scrollY !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.scrollX : n ? document.documentElement.scrollLeft : document.body.scrollLeft;
    } else
      return e.scrollLeft;
  },
  currentPositionY: function(e) {
    if (e === document) {
      var t = window.scrollX !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.scrollY : n ? document.documentElement.scrollTop : document.body.scrollTop;
    } else
      return e.scrollTop;
  },
  scrollHandler: function(e) {
    var t = Vr.scrollSpyContainers[Vr.scrollSpyContainers.indexOf(e)].spyCallbacks || [];
    t.forEach(function(n) {
      return n(Vr.currentPositionX(e), Vr.currentPositionY(e));
    });
  },
  addStateHandler: function(e) {
    Vr.spySetState.push(e);
  },
  addSpyHandler: function(e, t) {
    var n = Vr.scrollSpyContainers[Vr.scrollSpyContainers.indexOf(t)];
    n.spyCallbacks || (n.spyCallbacks = []), n.spyCallbacks.push(e);
  },
  updateStates: function() {
    Vr.spySetState.forEach(function(e) {
      return e();
    });
  },
  unmount: function(e, t) {
    Vr.scrollSpyContainers.forEach(function(n) {
      return n.spyCallbacks && n.spyCallbacks.length && n.spyCallbacks.indexOf(t) > -1 && n.spyCallbacks.splice(n.spyCallbacks.indexOf(t), 1);
    }), Vr.spySetState && Vr.spySetState.length && Vr.spySetState.indexOf(e) > -1 && Vr.spySetState.splice(Vr.spySetState.indexOf(e), 1), document.removeEventListener("scroll", Vr.scrollHandler);
  },
  update: function() {
    return Vr.scrollSpyContainers.forEach(function(e) {
      return Vr.scrollHandler(e);
    });
  }
};
Zf.default = Vr;
var Rc = {}, Gf = {};
Object.defineProperty(Gf, "__esModule", {
  value: !0
});
var Sje = function(e, t) {
  var n = e.indexOf("#") === 0 ? e.substring(1) : e, r = n ? "#" + n : "", o = window && window.location, i = r ? o.pathname + o.search + r : o.pathname + o.search;
  t ? history.pushState(history.state, "", i) : history.replaceState(history.state, "", i);
}, Mje = function() {
  return window.location.hash.replace(/^#/, "");
}, Dje = function(e) {
  return function(t) {
    return e.contains ? e != t && e.contains(t) : !!(e.compareDocumentPosition(t) & 16);
  };
}, Tje = function(e) {
  return getComputedStyle(e).position !== "static";
}, zx = function(e, t) {
  for (var n = e.offsetTop, r = e.offsetParent; r && !t(r); )
    n += r.offsetTop, r = r.offsetParent;
  return { offsetTop: n, offsetParent: r };
}, jje = function(e, t, n) {
  if (n)
    return e === document ? t.getBoundingClientRect().left + (window.scrollX || window.pageXOffset) : getComputedStyle(e).position !== "static" ? t.offsetLeft : t.offsetLeft - e.offsetLeft;
  if (e === document)
    return t.getBoundingClientRect().top + (window.scrollY || window.pageYOffset);
  if (Tje(e)) {
    if (t.offsetParent !== e) {
      var r = function(l) {
        return l === e || l === document;
      }, o = zx(t, r), i = o.offsetTop, a = o.offsetParent;
      if (a !== e)
        throw new Error("Seems containerElement is not an ancestor of the Element");
      return i;
    }
    return t.offsetTop;
  }
  if (t.offsetParent === e.offsetParent)
    return t.offsetTop - e.offsetTop;
  var s = function(l) {
    return l === document;
  };
  return zx(t, s).offsetTop - zx(e, s).offsetTop;
};
Gf.default = {
  updateHash: Sje,
  getHash: Mje,
  filterElementInContainer: Dje,
  scrollOffset: jje
};
var e0 = {}, N_ = {};
Object.defineProperty(N_, "__esModule", {
  value: !0
});
N_.default = {
  /*
   * https://github.com/oblador/angular-scroll (duScrollDefaultEasing)
   */
  defaultEasing: function(e) {
    return e < 0.5 ? Math.pow(e * 2, 2) / 2 : 1 - Math.pow((1 - e) * 2, 2) / 2;
  },
  /*
   * https://gist.github.com/gre/1650294
   */
  // no easing, no acceleration
  linear: function(e) {
    return e;
  },
  // accelerating from zero velocity
  easeInQuad: function(e) {
    return e * e;
  },
  // decelerating to zero velocity
  easeOutQuad: function(e) {
    return e * (2 - e);
  },
  // acceleration until halfway, then deceleration
  easeInOutQuad: function(e) {
    return e < 0.5 ? 2 * e * e : -1 + (4 - 2 * e) * e;
  },
  // accelerating from zero velocity 
  easeInCubic: function(e) {
    return e * e * e;
  },
  // decelerating to zero velocity 
  easeOutCubic: function(e) {
    return --e * e * e + 1;
  },
  // acceleration until halfway, then deceleration 
  easeInOutCubic: function(e) {
    return e < 0.5 ? 4 * e * e * e : (e - 1) * (2 * e - 2) * (2 * e - 2) + 1;
  },
  // accelerating from zero velocity 
  easeInQuart: function(e) {
    return e * e * e * e;
  },
  // decelerating to zero velocity 
  easeOutQuart: function(e) {
    return 1 - --e * e * e * e;
  },
  // acceleration until halfway, then deceleration
  easeInOutQuart: function(e) {
    return e < 0.5 ? 8 * e * e * e * e : 1 - 8 * --e * e * e * e;
  },
  // accelerating from zero velocity
  easeInQuint: function(e) {
    return e * e * e * e * e;
  },
  // decelerating to zero velocity
  easeOutQuint: function(e) {
    return 1 + --e * e * e * e * e;
  },
  // acceleration until halfway, then deceleration 
  easeInOutQuint: function(e) {
    return e < 0.5 ? 16 * e * e * e * e * e : 1 + 16 * --e * e * e * e * e;
  }
};
var F_ = {};
Object.defineProperty(F_, "__esModule", {
  value: !0
});
var Aje = qf, Ije = ["mousedown", "wheel", "touchmove", "keydown"];
F_.default = {
  subscribe: function(e) {
    return typeof document < "u" && Ije.forEach(function(t) {
      return (0, Aje.addPassiveEventListener)(document, t, e);
    });
  }
};
var Kf = {};
Object.defineProperty(Kf, "__esModule", {
  value: !0
});
var Hk = {
  registered: {},
  scrollEvent: {
    register: function(e, t) {
      Hk.registered[e] = t;
    },
    remove: function(e) {
      Hk.registered[e] = null;
    }
  }
};
Kf.default = Hk;
Object.defineProperty(e0, "__esModule", {
  value: !0
});
var Rje = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, Bje = Gf;
t0(Bje);
var Nje = N_, nH = t0(Nje), Fje = F_, zje = t0(Fje), Uje = Kf, Os = t0(Uje);
function t0(e) {
  return e && e.__esModule ? e : { default: e };
}
var vK = function(e) {
  return nH.default[e.smooth] || nH.default.defaultEasing;
}, Hje = function(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}, $je = function() {
  if (typeof window < "u")
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame;
}, $k = function() {
  return $je() || function(e, t, n) {
    window.setTimeout(e, n || 1e3 / 60, (/* @__PURE__ */ new Date()).getTime());
  };
}(), yK = function() {
  return {
    currentPosition: 0,
    startPosition: 0,
    targetPosition: 0,
    progress: 0,
    duration: 0,
    cancel: !1,
    target: null,
    containerElement: null,
    to: null,
    start: null,
    delta: null,
    percent: null,
    delayTimeout: null
  };
}, bK = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollLeft;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageXOffset : r ? document.documentElement.scrollLeft : document.body.scrollLeft;
}, wK = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollTop;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageYOffset : r ? document.documentElement.scrollTop : document.body.scrollTop;
}, Wje = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollWidth - t.offsetWidth;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollWidth, n.offsetWidth, r.clientWidth, r.scrollWidth, r.offsetWidth);
}, Vje = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollHeight - t.offsetHeight;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollHeight, n.offsetHeight, r.clientHeight, r.scrollHeight, r.offsetHeight);
}, Zje = function e(t, n, r) {
  var o = n.data;
  if (!n.ignoreCancelEvents && o.cancel) {
    Os.default.registered.end && Os.default.registered.end(o.to, o.target, o.currentPositionY);
    return;
  }
  if (o.delta = Math.round(o.targetPosition - o.startPosition), o.start === null && (o.start = r), o.progress = r - o.start, o.percent = o.progress >= o.duration ? 1 : t(o.progress / o.duration), o.currentPosition = o.startPosition + Math.ceil(o.delta * o.percent), o.containerElement && o.containerElement !== document && o.containerElement !== document.body ? n.horizontal ? o.containerElement.scrollLeft = o.currentPosition : o.containerElement.scrollTop = o.currentPosition : n.horizontal ? window.scrollTo(o.currentPosition, 0) : window.scrollTo(0, o.currentPosition), o.percent < 1) {
    var i = e.bind(null, t, n);
    $k.call(window, i);
    return;
  }
  Os.default.registered.end && Os.default.registered.end(o.to, o.target, o.currentPosition);
}, z_ = function(e) {
  e.data.containerElement = e ? e.containerId ? document.getElementById(e.containerId) : e.container && e.container.nodeType ? e.container : document : null;
}, Yf = function(e, t, n, r) {
  t.data = t.data || yK(), window.clearTimeout(t.data.delayTimeout);
  var o = function() {
    t.data.cancel = !0;
  };
  if (zje.default.subscribe(o), z_(t), t.data.start = null, t.data.cancel = !1, t.data.startPosition = t.horizontal ? bK(t) : wK(t), t.data.targetPosition = t.absolute ? e : e + t.data.startPosition, t.data.startPosition === t.data.targetPosition) {
    Os.default.registered.end && Os.default.registered.end(t.data.to, t.data.target, t.data.currentPosition);
    return;
  }
  t.data.delta = Math.round(t.data.targetPosition - t.data.startPosition), t.data.duration = Hje(t.duration)(t.data.delta), t.data.duration = isNaN(parseFloat(t.data.duration)) ? 1e3 : parseFloat(t.data.duration), t.data.to = n, t.data.target = r;
  var i = vK(t), a = Zje.bind(null, i, t);
  if (t && t.delay > 0) {
    t.data.delayTimeout = window.setTimeout(function() {
      Os.default.registered.begin && Os.default.registered.begin(t.data.to, t.data.target), $k.call(window, a);
    }, t.delay);
    return;
  }
  Os.default.registered.begin && Os.default.registered.begin(t.data.to, t.data.target), $k.call(window, a);
}, n0 = function(e) {
  return e = Rje({}, e), e.data = e.data || yK(), e.absolute = !0, e;
}, qje = function(e) {
  Yf(0, n0(e));
}, Gje = function(e, t) {
  Yf(e, n0(t));
}, Kje = function(e) {
  e = n0(e), z_(e), Yf(e.horizontal ? Wje(e) : Vje(e), e);
}, Yje = function(e, t) {
  t = n0(t), z_(t);
  var n = t.horizontal ? bK(t) : wK(t);
  Yf(e + n, t);
};
e0.default = {
  animateTopScroll: Yf,
  getAnimationType: vK,
  scrollToTop: qje,
  scrollToBottom: Kje,
  scrollTo: Gje,
  scrollMore: Yje
};
Object.defineProperty(Rc, "__esModule", {
  value: !0
});
var Xje = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, Jje = Gf, Qje = U_(Jje), eAe = e0, tAe = U_(eAe), nAe = Kf, Wg = U_(nAe);
function U_(e) {
  return e && e.__esModule ? e : { default: e };
}
var Vg = {}, rH = void 0;
Rc.default = {
  unmount: function() {
    Vg = {};
  },
  register: function(e, t) {
    Vg[e] = t;
  },
  unregister: function(e) {
    delete Vg[e];
  },
  get: function(e) {
    return Vg[e] || document.getElementById(e) || document.getElementsByName(e)[0] || document.getElementsByClassName(e)[0];
  },
  setActiveLink: function(e) {
    return rH = e;
  },
  getActiveLink: function() {
    return rH;
  },
  scrollTo: function(e, t) {
    var n = this.get(e);
    if (!n) {
      console.warn("target Element not found");
      return;
    }
    t = Xje({}, t, { absolute: !1 });
    var r = t.containerId, o = t.container, i = void 0;
    r ? i = document.getElementById(r) : o && o.nodeType ? i = o : i = document, t.absolute = !0;
    var a = t.horizontal, s = Qje.default.scrollOffset(i, n, a) + (t.offset || 0);
    if (!t.smooth) {
      Wg.default.registered.begin && Wg.default.registered.begin(e, n), i === document ? t.horizontal ? window.scrollTo(s, 0) : window.scrollTo(0, s) : i.scrollTop = s, Wg.default.registered.end && Wg.default.registered.end(e, n);
      return;
    }
    tAe.default.animateTopScroll(s, t, e, n);
  }
};
var Wk = { exports: {} }, Ux = { exports: {} }, An = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var oH;
function rAe() {
  if (oH) return An;
  oH = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, g = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, m = e ? Symbol.for("react.block") : 60121, v = e ? Symbol.for("react.fundamental") : 60117, E = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
  function M(y) {
    if (typeof y == "object" && y !== null) {
      var C = y.$$typeof;
      switch (C) {
        case t:
          switch (y = y.type, y) {
            case l:
            case u:
            case r:
            case i:
            case o:
            case p:
              return y;
            default:
              switch (y = y && y.$$typeof, y) {
                case s:
                case c:
                case f:
                case g:
                case a:
                  return y;
                default:
                  return C;
              }
          }
        case n:
          return C;
      }
    }
  }
  function O(y) {
    return M(y) === u;
  }
  return An.AsyncMode = l, An.ConcurrentMode = u, An.ContextConsumer = s, An.ContextProvider = a, An.Element = t, An.ForwardRef = c, An.Fragment = r, An.Lazy = f, An.Memo = g, An.Portal = n, An.Profiler = i, An.StrictMode = o, An.Suspense = p, An.isAsyncMode = function(y) {
    return O(y) || M(y) === l;
  }, An.isConcurrentMode = O, An.isContextConsumer = function(y) {
    return M(y) === s;
  }, An.isContextProvider = function(y) {
    return M(y) === a;
  }, An.isElement = function(y) {
    return typeof y == "object" && y !== null && y.$$typeof === t;
  }, An.isForwardRef = function(y) {
    return M(y) === c;
  }, An.isFragment = function(y) {
    return M(y) === r;
  }, An.isLazy = function(y) {
    return M(y) === f;
  }, An.isMemo = function(y) {
    return M(y) === g;
  }, An.isPortal = function(y) {
    return M(y) === n;
  }, An.isProfiler = function(y) {
    return M(y) === i;
  }, An.isStrictMode = function(y) {
    return M(y) === o;
  }, An.isSuspense = function(y) {
    return M(y) === p;
  }, An.isValidElementType = function(y) {
    return typeof y == "string" || typeof y == "function" || y === r || y === u || y === i || y === o || y === p || y === d || typeof y == "object" && y !== null && (y.$$typeof === f || y.$$typeof === g || y.$$typeof === a || y.$$typeof === s || y.$$typeof === c || y.$$typeof === v || y.$$typeof === E || y.$$typeof === w || y.$$typeof === m);
  }, An.typeOf = M, An;
}
var $n = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var iH;
function oAe() {
  return iH || (iH = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, g = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, m = e ? Symbol.for("react.block") : 60121, v = e ? Symbol.for("react.fundamental") : 60117, E = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
    function M(B) {
      return typeof B == "string" || typeof B == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      B === r || B === u || B === i || B === o || B === p || B === d || typeof B == "object" && B !== null && (B.$$typeof === f || B.$$typeof === g || B.$$typeof === a || B.$$typeof === s || B.$$typeof === c || B.$$typeof === v || B.$$typeof === E || B.$$typeof === w || B.$$typeof === m);
    }
    function O(B) {
      if (typeof B == "object" && B !== null) {
        var ue = B.$$typeof;
        switch (ue) {
          case t:
            var fe = B.type;
            switch (fe) {
              case l:
              case u:
              case r:
              case i:
              case o:
              case p:
                return fe;
              default:
                var oe = fe && fe.$$typeof;
                switch (oe) {
                  case s:
                  case c:
                  case f:
                  case g:
                  case a:
                    return oe;
                  default:
                    return ue;
                }
            }
          case n:
            return ue;
        }
      }
    }
    var y = l, C = u, _ = s, F = a, L = t, N = c, R = r, W = f, V = g, z = n, Z = i, K = o, X = p, te = !1;
    function J(B) {
      return te || (te = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), P(B) || O(B) === l;
    }
    function P(B) {
      return O(B) === u;
    }
    function D(B) {
      return O(B) === s;
    }
    function H(B) {
      return O(B) === a;
    }
    function S(B) {
      return typeof B == "object" && B !== null && B.$$typeof === t;
    }
    function $(B) {
      return O(B) === c;
    }
    function x(B) {
      return O(B) === r;
    }
    function j(B) {
      return O(B) === f;
    }
    function U(B) {
      return O(B) === g;
    }
    function T(B) {
      return O(B) === n;
    }
    function q(B) {
      return O(B) === i;
    }
    function A(B) {
      return O(B) === o;
    }
    function Y(B) {
      return O(B) === p;
    }
    $n.AsyncMode = y, $n.ConcurrentMode = C, $n.ContextConsumer = _, $n.ContextProvider = F, $n.Element = L, $n.ForwardRef = N, $n.Fragment = R, $n.Lazy = W, $n.Memo = V, $n.Portal = z, $n.Profiler = Z, $n.StrictMode = K, $n.Suspense = X, $n.isAsyncMode = J, $n.isConcurrentMode = P, $n.isContextConsumer = D, $n.isContextProvider = H, $n.isElement = S, $n.isForwardRef = $, $n.isFragment = x, $n.isLazy = j, $n.isMemo = U, $n.isPortal = T, $n.isProfiler = q, $n.isStrictMode = A, $n.isSuspense = Y, $n.isValidElementType = M, $n.typeOf = O;
  }()), $n;
}
var sH;
function CK() {
  return sH || (sH = 1, process.env.NODE_ENV === "production" ? Ux.exports = rAe() : Ux.exports = oAe()), Ux.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var Hx, aH;
function iAe() {
  if (aH) return Hx;
  aH = 1;
  var e = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, n = Object.prototype.propertyIsEnumerable;
  function r(i) {
    if (i == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(i);
  }
  function o() {
    try {
      if (!Object.assign)
        return !1;
      var i = new String("abc");
      if (i[5] = "de", Object.getOwnPropertyNames(i)[0] === "5")
        return !1;
      for (var a = {}, s = 0; s < 10; s++)
        a["_" + String.fromCharCode(s)] = s;
      var l = Object.getOwnPropertyNames(a).map(function(c) {
        return a[c];
      });
      if (l.join("") !== "0123456789")
        return !1;
      var u = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(c) {
        u[c] = c;
      }), Object.keys(Object.assign({}, u)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return Hx = o() ? Object.assign : function(i, a) {
    for (var s, l = r(i), u, c = 1; c < arguments.length; c++) {
      s = Object(arguments[c]);
      for (var p in s)
        t.call(s, p) && (l[p] = s[p]);
      if (e) {
        u = e(s);
        for (var d = 0; d < u.length; d++)
          n.call(s, u[d]) && (l[u[d]] = s[u[d]]);
      }
    }
    return l;
  }, Hx;
}
var $x, lH;
function H_() {
  if (lH) return $x;
  lH = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return $x = e, $x;
}
var uH, cH;
function xK() {
  return cH || (cH = 1, uH = Function.call.bind(Object.prototype.hasOwnProperty)), uH;
}
var Wx, pH;
function sAe() {
  if (pH) return Wx;
  pH = 1;
  var e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = H_(), n = {}, r = xK();
    e = function(i) {
      var a = "Warning: " + i;
      typeof console < "u" && console.error(a);
      try {
        throw new Error(a);
      } catch {
      }
    };
  }
  function o(i, a, s, l, u) {
    if (process.env.NODE_ENV !== "production") {
      for (var c in i)
        if (r(i, c)) {
          var p;
          try {
            if (typeof i[c] != "function") {
              var d = Error(
                (l || "React class") + ": " + s + " type `" + c + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof i[c] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw d.name = "Invariant Violation", d;
            }
            p = i[c](a, c, l, s, null, t);
          } catch (f) {
            p = f;
          }
          if (p && !(p instanceof Error) && e(
            (l || "React class") + ": type specification of " + s + " `" + c + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof p + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), p instanceof Error && !(p.message in n)) {
            n[p.message] = !0;
            var g = u ? u() : "";
            e(
              "Failed " + s + " type: " + p.message + (g ?? "")
            );
          }
        }
    }
  }
  return o.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (n = {});
  }, Wx = o, Wx;
}
var Vx, dH;
function aAe() {
  if (dH) return Vx;
  dH = 1;
  var e = CK(), t = iAe(), n = H_(), r = xK(), o = sAe(), i = function() {
  };
  process.env.NODE_ENV !== "production" && (i = function(s) {
    var l = "Warning: " + s;
    typeof console < "u" && console.error(l);
    try {
      throw new Error(l);
    } catch {
    }
  });
  function a() {
    return null;
  }
  return Vx = function(s, l) {
    var u = typeof Symbol == "function" && Symbol.iterator, c = "@@iterator";
    function p(P) {
      var D = P && (u && P[u] || P[c]);
      if (typeof D == "function")
        return D;
    }
    var d = "<<anonymous>>", g = {
      array: E("array"),
      bigint: E("bigint"),
      bool: E("boolean"),
      func: E("function"),
      number: E("number"),
      object: E("object"),
      string: E("string"),
      symbol: E("symbol"),
      any: w(),
      arrayOf: M,
      element: O(),
      elementType: y(),
      instanceOf: C,
      node: N(),
      objectOf: F,
      oneOf: _,
      oneOfType: L,
      shape: W,
      exact: V
    };
    function f(P, D) {
      return P === D ? P !== 0 || 1 / P === 1 / D : P !== P && D !== D;
    }
    function m(P, D) {
      this.message = P, this.data = D && typeof D == "object" ? D : {}, this.stack = "";
    }
    m.prototype = Error.prototype;
    function v(P) {
      if (process.env.NODE_ENV !== "production")
        var D = {}, H = 0;
      function S(x, j, U, T, q, A, Y) {
        if (T = T || d, A = A || U, Y !== n) {
          if (l) {
            var B = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw B.name = "Invariant Violation", B;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var ue = T + ":" + U;
            !D[ue] && // Avoid spamming the console because they are often not actionable except for lib authors
            H < 3 && (i(
              "You are manually calling a React.PropTypes validation function for the `" + A + "` prop on `" + T + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), D[ue] = !0, H++);
          }
        }
        return j[U] == null ? x ? j[U] === null ? new m("The " + q + " `" + A + "` is marked as required " + ("in `" + T + "`, but its value is `null`.")) : new m("The " + q + " `" + A + "` is marked as required in " + ("`" + T + "`, but its value is `undefined`.")) : null : P(j, U, T, q, A);
      }
      var $ = S.bind(null, !1);
      return $.isRequired = S.bind(null, !0), $;
    }
    function E(P) {
      function D(H, S, $, x, j, U) {
        var T = H[S], q = K(T);
        if (q !== P) {
          var A = X(T);
          return new m(
            "Invalid " + x + " `" + j + "` of type " + ("`" + A + "` supplied to `" + $ + "`, expected ") + ("`" + P + "`."),
            { expectedType: P }
          );
        }
        return null;
      }
      return v(D);
    }
    function w() {
      return v(a);
    }
    function M(P) {
      function D(H, S, $, x, j) {
        if (typeof P != "function")
          return new m("Property `" + j + "` of component `" + $ + "` has invalid PropType notation inside arrayOf.");
        var U = H[S];
        if (!Array.isArray(U)) {
          var T = K(U);
          return new m("Invalid " + x + " `" + j + "` of type " + ("`" + T + "` supplied to `" + $ + "`, expected an array."));
        }
        for (var q = 0; q < U.length; q++) {
          var A = P(U, q, $, x, j + "[" + q + "]", n);
          if (A instanceof Error)
            return A;
        }
        return null;
      }
      return v(D);
    }
    function O() {
      function P(D, H, S, $, x) {
        var j = D[H];
        if (!s(j)) {
          var U = K(j);
          return new m("Invalid " + $ + " `" + x + "` of type " + ("`" + U + "` supplied to `" + S + "`, expected a single ReactElement."));
        }
        return null;
      }
      return v(P);
    }
    function y() {
      function P(D, H, S, $, x) {
        var j = D[H];
        if (!e.isValidElementType(j)) {
          var U = K(j);
          return new m("Invalid " + $ + " `" + x + "` of type " + ("`" + U + "` supplied to `" + S + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return v(P);
    }
    function C(P) {
      function D(H, S, $, x, j) {
        if (!(H[S] instanceof P)) {
          var U = P.name || d, T = J(H[S]);
          return new m("Invalid " + x + " `" + j + "` of type " + ("`" + T + "` supplied to `" + $ + "`, expected ") + ("instance of `" + U + "`."));
        }
        return null;
      }
      return v(D);
    }
    function _(P) {
      if (!Array.isArray(P))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? i(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : i("Invalid argument supplied to oneOf, expected an array.")), a;
      function D(H, S, $, x, j) {
        for (var U = H[S], T = 0; T < P.length; T++)
          if (f(U, P[T]))
            return null;
        var q = JSON.stringify(P, function(A, Y) {
          var B = X(Y);
          return B === "symbol" ? String(Y) : Y;
        });
        return new m("Invalid " + x + " `" + j + "` of value `" + String(U) + "` " + ("supplied to `" + $ + "`, expected one of " + q + "."));
      }
      return v(D);
    }
    function F(P) {
      function D(H, S, $, x, j) {
        if (typeof P != "function")
          return new m("Property `" + j + "` of component `" + $ + "` has invalid PropType notation inside objectOf.");
        var U = H[S], T = K(U);
        if (T !== "object")
          return new m("Invalid " + x + " `" + j + "` of type " + ("`" + T + "` supplied to `" + $ + "`, expected an object."));
        for (var q in U)
          if (r(U, q)) {
            var A = P(U, q, $, x, j + "." + q, n);
            if (A instanceof Error)
              return A;
          }
        return null;
      }
      return v(D);
    }
    function L(P) {
      if (!Array.isArray(P))
        return process.env.NODE_ENV !== "production" && i("Invalid argument supplied to oneOfType, expected an instance of array."), a;
      for (var D = 0; D < P.length; D++) {
        var H = P[D];
        if (typeof H != "function")
          return i(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + te(H) + " at index " + D + "."
          ), a;
      }
      function S($, x, j, U, T) {
        for (var q = [], A = 0; A < P.length; A++) {
          var Y = P[A], B = Y($, x, j, U, T, n);
          if (B == null)
            return null;
          B.data && r(B.data, "expectedType") && q.push(B.data.expectedType);
        }
        var ue = q.length > 0 ? ", expected one of type [" + q.join(", ") + "]" : "";
        return new m("Invalid " + U + " `" + T + "` supplied to " + ("`" + j + "`" + ue + "."));
      }
      return v(S);
    }
    function N() {
      function P(D, H, S, $, x) {
        return z(D[H]) ? null : new m("Invalid " + $ + " `" + x + "` supplied to " + ("`" + S + "`, expected a ReactNode."));
      }
      return v(P);
    }
    function R(P, D, H, S, $) {
      return new m(
        (P || "React class") + ": " + D + " type `" + H + "." + S + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + $ + "`."
      );
    }
    function W(P) {
      function D(H, S, $, x, j) {
        var U = H[S], T = K(U);
        if (T !== "object")
          return new m("Invalid " + x + " `" + j + "` of type `" + T + "` " + ("supplied to `" + $ + "`, expected `object`."));
        for (var q in P) {
          var A = P[q];
          if (typeof A != "function")
            return R($, x, j, q, X(A));
          var Y = A(U, q, $, x, j + "." + q, n);
          if (Y)
            return Y;
        }
        return null;
      }
      return v(D);
    }
    function V(P) {
      function D(H, S, $, x, j) {
        var U = H[S], T = K(U);
        if (T !== "object")
          return new m("Invalid " + x + " `" + j + "` of type `" + T + "` " + ("supplied to `" + $ + "`, expected `object`."));
        var q = t({}, H[S], P);
        for (var A in q) {
          var Y = P[A];
          if (r(P, A) && typeof Y != "function")
            return R($, x, j, A, X(Y));
          if (!Y)
            return new m(
              "Invalid " + x + " `" + j + "` key `" + A + "` supplied to `" + $ + "`.\nBad object: " + JSON.stringify(H[S], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(P), null, "  ")
            );
          var B = Y(U, A, $, x, j + "." + A, n);
          if (B)
            return B;
        }
        return null;
      }
      return v(D);
    }
    function z(P) {
      switch (typeof P) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !P;
        case "object":
          if (Array.isArray(P))
            return P.every(z);
          if (P === null || s(P))
            return !0;
          var D = p(P);
          if (D) {
            var H = D.call(P), S;
            if (D !== P.entries) {
              for (; !(S = H.next()).done; )
                if (!z(S.value))
                  return !1;
            } else
              for (; !(S = H.next()).done; ) {
                var $ = S.value;
                if ($ && !z($[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function Z(P, D) {
      return P === "symbol" ? !0 : D ? D["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && D instanceof Symbol : !1;
    }
    function K(P) {
      var D = typeof P;
      return Array.isArray(P) ? "array" : P instanceof RegExp ? "object" : Z(D, P) ? "symbol" : D;
    }
    function X(P) {
      if (typeof P > "u" || P === null)
        return "" + P;
      var D = K(P);
      if (D === "object") {
        if (P instanceof Date)
          return "date";
        if (P instanceof RegExp)
          return "regexp";
      }
      return D;
    }
    function te(P) {
      var D = X(P);
      switch (D) {
        case "array":
        case "object":
          return "an " + D;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + D;
        default:
          return D;
      }
    }
    function J(P) {
      return !P.constructor || !P.constructor.name ? d : P.constructor.name;
    }
    return g.checkPropTypes = o, g.resetWarningCache = o.resetWarningCache, g.PropTypes = g, g;
  }, Vx;
}
var Zx, fH;
function lAe() {
  if (fH) return Zx;
  fH = 1;
  var e = H_();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, Zx = function() {
    function r(a, s, l, u, c, p) {
      if (p !== e) {
        var d = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw d.name = "Invariant Violation", d;
      }
    }
    r.isRequired = r;
    function o() {
      return r;
    }
    var i = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: o,
      element: r,
      elementType: r,
      instanceOf: o,
      node: r,
      objectOf: o,
      oneOf: o,
      oneOfType: o,
      shape: o,
      exact: o,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return i.PropTypes = i, i;
  }, Zx;
}
if (process.env.NODE_ENV !== "production") {
  var uAe = CK(), cAe = !0;
  Wk.exports = aAe()(uAe.isElement, cAe);
} else
  Wk.exports = lAe()();
var r0 = Wk.exports, o0 = {};
Object.defineProperty(o0, "__esModule", {
  value: !0
});
var pAe = Gf, qx = dAe(pAe);
function dAe(e) {
  return e && e.__esModule ? e : { default: e };
}
var fAe = {
  mountFlag: !1,
  initialized: !1,
  scroller: null,
  containers: {},
  mount: function(e) {
    this.scroller = e, this.handleHashChange = this.handleHashChange.bind(this), window.addEventListener("hashchange", this.handleHashChange), this.initStateFromHash(), this.mountFlag = !0;
  },
  mapContainer: function(e, t) {
    this.containers[e] = t;
  },
  isMounted: function() {
    return this.mountFlag;
  },
  isInitialized: function() {
    return this.initialized;
  },
  initStateFromHash: function() {
    var e = this, t = this.getHash();
    t ? window.setTimeout(function() {
      e.scrollTo(t, !0), e.initialized = !0;
    }, 10) : this.initialized = !0;
  },
  scrollTo: function(e, t) {
    var n = this.scroller, r = n.get(e);
    if (r && (t || e !== n.getActiveLink())) {
      var o = this.containers[e] || document;
      n.scrollTo(e, { container: o });
    }
  },
  getHash: function() {
    return qx.default.getHash();
  },
  changeHash: function(e, t) {
    this.isInitialized() && qx.default.getHash() !== e && qx.default.updateHash(e, t);
  },
  handleHashChange: function() {
    this.scrollTo(this.getHash());
  },
  unmount: function() {
    this.scroller = null, this.containers = null, window.removeEventListener("hashchange", this.handleHashChange);
  }
};
o0.default = fAe;
Object.defineProperty(Vf, "__esModule", {
  value: !0
});
var Zg = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, hAe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), gAe = we, hH = Xf(gAe), mAe = Zf, qg = Xf(mAe), vAe = Rc, yAe = Xf(vAe), bAe = r0, Ir = Xf(bAe), wAe = o0, Ma = Xf(wAe);
function Xf(e) {
  return e && e.__esModule ? e : { default: e };
}
function CAe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function xAe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function OAe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var gH = {
  to: Ir.default.string.isRequired,
  containerId: Ir.default.string,
  container: Ir.default.object,
  activeClass: Ir.default.string,
  activeStyle: Ir.default.object,
  spy: Ir.default.bool,
  horizontal: Ir.default.bool,
  smooth: Ir.default.oneOfType([Ir.default.bool, Ir.default.string]),
  offset: Ir.default.number,
  delay: Ir.default.number,
  isDynamic: Ir.default.bool,
  onClick: Ir.default.func,
  duration: Ir.default.oneOfType([Ir.default.number, Ir.default.func]),
  absolute: Ir.default.bool,
  onSetActive: Ir.default.func,
  onSetInactive: Ir.default.func,
  ignoreCancelEvents: Ir.default.bool,
  hashSpy: Ir.default.bool,
  saveHashHistory: Ir.default.bool,
  spyThrottle: Ir.default.number
};
Vf.default = function(e, t) {
  var n = t || yAe.default, r = function(i) {
    OAe(a, i);
    function a(s) {
      CAe(this, a);
      var l = xAe(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
      return o.call(l), l.state = {
        active: !1
      }, l.beforeUnmountCallbacks = [], l;
    }
    return hAe(a, [{
      key: "getScrollSpyContainer",
      value: function() {
        var s = this.props.containerId, l = this.props.container;
        return s && !l ? document.getElementById(s) : l && l.nodeType ? l : document;
      }
    }, {
      key: "componentDidMount",
      value: function() {
        if (this.props.spy || this.props.hashSpy) {
          var s = this.getScrollSpyContainer();
          if (!qg.default.isMounted(s)) {
            var l = qg.default.mount(s, this.props.spyThrottle);
            this.beforeUnmountCallbacks.push(l);
          }
          this.props.hashSpy && (Ma.default.isMounted() || Ma.default.mount(n), Ma.default.mapContainer(this.props.to, s)), qg.default.addSpyHandler(this.spyHandler, s), this.setState({
            container: s
          });
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        qg.default.unmount(this.stateHandler, this.spyHandler), this.beforeUnmountCallbacks.forEach(function(s) {
          return s();
        });
      }
    }, {
      key: "render",
      value: function() {
        var s = "";
        this.state && this.state.active ? s = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : s = this.props.className;
        var l = {};
        this.state && this.state.active ? l = Zg({}, this.props.style, this.props.activeStyle) : l = Zg({}, this.props.style);
        var u = Zg({}, this.props);
        for (var c in gH)
          u.hasOwnProperty(c) && delete u[c];
        return u.className = s, u.style = l, u.onClick = this.handleClick, hH.default.createElement(e, u);
      }
    }]), a;
  }(hH.default.PureComponent), o = function() {
    var i = this;
    this.scrollTo = function(a, s) {
      n.scrollTo(a, Zg({}, i.state, s));
    }, this.handleClick = function(a) {
      i.props.onClick && i.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), i.scrollTo(i.props.to, i.props);
    }, this.spyHandler = function(a, s) {
      var l = i.getScrollSpyContainer();
      if (!(Ma.default.isMounted() && !Ma.default.isInitialized())) {
        var u = i.props.horizontal, c = i.props.to, p = null, d = void 0, g = void 0;
        if (u) {
          var f = 0, m = 0, v = 0;
          if (l.getBoundingClientRect) {
            var E = l.getBoundingClientRect();
            v = E.left;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var w = p.getBoundingClientRect();
            f = w.left - v + a, m = f + w.width;
          }
          var M = a - i.props.offset;
          d = M >= Math.floor(f) && M < Math.floor(m), g = M < Math.floor(f) || M >= Math.floor(m);
        } else {
          var O = 0, y = 0, C = 0;
          if (l.getBoundingClientRect) {
            var _ = l.getBoundingClientRect();
            C = _.top;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var F = p.getBoundingClientRect();
            O = F.top - C + s, y = O + F.height;
          }
          var L = s - i.props.offset;
          d = L >= Math.floor(O) && L < Math.floor(y), g = L < Math.floor(O) || L >= Math.floor(y);
        }
        var N = n.getActiveLink();
        if (g) {
          if (c === N && n.setActiveLink(void 0), i.props.hashSpy && Ma.default.getHash() === c) {
            var R = i.props.saveHashHistory, W = R === void 0 ? !1 : R;
            Ma.default.changeHash("", W);
          }
          i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive(c, p));
        }
        if (d && (N !== c || i.state.active === !1)) {
          n.setActiveLink(c);
          var V = i.props.saveHashHistory, z = V === void 0 ? !1 : V;
          i.props.hashSpy && Ma.default.changeHash(c, z), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(c, p));
        }
      }
    };
  };
  return r.propTypes = gH, r.defaultProps = { offset: 0 }, r;
};
Object.defineProperty(B_, "__esModule", {
  value: !0
});
var EAe = we, mH = OK(EAe), kAe = Vf, LAe = OK(kAe);
function OK(e) {
  return e && e.__esModule ? e : { default: e };
}
function PAe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function vH(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function _Ae(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var SAe = function(e) {
  _Ae(t, e);
  function t() {
    var n, r, o, i;
    PAe(this, t);
    for (var a = arguments.length, s = Array(a), l = 0; l < a; l++)
      s[l] = arguments[l];
    return i = (r = (o = vH(this, (n = t.__proto__ || Object.getPrototypeOf(t)).call.apply(n, [this].concat(s))), o), o.render = function() {
      return mH.default.createElement(
        "a",
        o.props,
        o.props.children
      );
    }, r), vH(o, i);
  }
  return t;
}(mH.default.Component);
B_.default = (0, LAe.default)(SAe);
var $_ = {};
Object.defineProperty($_, "__esModule", {
  value: !0
});
var MAe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), DAe = we, yH = EK(DAe), TAe = Vf, jAe = EK(TAe);
function EK(e) {
  return e && e.__esModule ? e : { default: e };
}
function AAe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function IAe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function RAe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var BAe = function(e) {
  RAe(t, e);
  function t() {
    return AAe(this, t), IAe(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return MAe(t, [{
    key: "render",
    value: function() {
      return yH.default.createElement(
        "button",
        this.props,
        this.props.children
      );
    }
  }]), t;
}(yH.default.Component);
$_.default = (0, jAe.default)(BAe);
var W_ = {}, i0 = {};
Object.defineProperty(i0, "__esModule", {
  value: !0
});
var NAe = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, FAe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), zAe = we, bH = s0(zAe), UAe = pl;
s0(UAe);
var HAe = Rc, wH = s0(HAe), $Ae = r0, CH = s0($Ae);
function s0(e) {
  return e && e.__esModule ? e : { default: e };
}
function WAe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function VAe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function ZAe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
i0.default = function(e) {
  var t = function(n) {
    ZAe(r, n);
    function r(o) {
      WAe(this, r);
      var i = VAe(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
      return i.childBindings = {
        domNode: null
      }, i;
    }
    return FAe(r, [{
      key: "componentDidMount",
      value: function() {
        if (typeof window > "u")
          return !1;
        this.registerElems(this.props.name);
      }
    }, {
      key: "componentDidUpdate",
      value: function(o) {
        this.props.name !== o.name && this.registerElems(this.props.name);
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        if (typeof window > "u")
          return !1;
        wH.default.unregister(this.props.name);
      }
    }, {
      key: "registerElems",
      value: function(o) {
        wH.default.register(o, this.childBindings.domNode);
      }
    }, {
      key: "render",
      value: function() {
        return bH.default.createElement(e, NAe({}, this.props, { parentBindings: this.childBindings }));
      }
    }]), r;
  }(bH.default.Component);
  return t.propTypes = {
    name: CH.default.string,
    id: CH.default.string
  }, t;
};
Object.defineProperty(W_, "__esModule", {
  value: !0
});
var xH = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, qAe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), GAe = we, OH = V_(GAe), KAe = i0, YAe = V_(KAe), XAe = r0, EH = V_(XAe);
function V_(e) {
  return e && e.__esModule ? e : { default: e };
}
function JAe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function QAe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function eIe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var kK = function(e) {
  eIe(t, e);
  function t() {
    return JAe(this, t), QAe(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return qAe(t, [{
    key: "render",
    value: function() {
      var n = this, r = xH({}, this.props);
      return delete r.name, r.parentBindings && delete r.parentBindings, OH.default.createElement(
        "div",
        xH({}, r, { ref: function(o) {
          n.props.parentBindings.domNode = o;
        } }),
        this.props.children
      );
    }
  }]), t;
}(OH.default.Component);
kK.propTypes = {
  name: EH.default.string,
  id: EH.default.string
};
W_.default = (0, YAe.default)(kK);
var Gx = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, kH = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}();
function LH(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function PH(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function _H(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var Gg = we, Hl = Zf, Kx = Rc, Jr = r0, Da = o0, SH = {
  to: Jr.string.isRequired,
  containerId: Jr.string,
  container: Jr.object,
  activeClass: Jr.string,
  spy: Jr.bool,
  smooth: Jr.oneOfType([Jr.bool, Jr.string]),
  offset: Jr.number,
  delay: Jr.number,
  isDynamic: Jr.bool,
  onClick: Jr.func,
  duration: Jr.oneOfType([Jr.number, Jr.func]),
  absolute: Jr.bool,
  onSetActive: Jr.func,
  onSetInactive: Jr.func,
  ignoreCancelEvents: Jr.bool,
  hashSpy: Jr.bool,
  spyThrottle: Jr.number
}, tIe = {
  Scroll: function(e, t) {
    console.warn("Helpers.Scroll is deprecated since v1.7.0");
    var n = t || Kx, r = function(i) {
      _H(a, i);
      function a(s) {
        LH(this, a);
        var l = PH(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
        return o.call(l), l.state = {
          active: !1
        }, l;
      }
      return kH(a, [{
        key: "getScrollSpyContainer",
        value: function() {
          var s = this.props.containerId, l = this.props.container;
          return s ? document.getElementById(s) : l && l.nodeType ? l : document;
        }
      }, {
        key: "componentDidMount",
        value: function() {
          if (this.props.spy || this.props.hashSpy) {
            var s = this.getScrollSpyContainer();
            Hl.isMounted(s) || Hl.mount(s, this.props.spyThrottle), this.props.hashSpy && (Da.isMounted() || Da.mount(n), Da.mapContainer(this.props.to, s)), this.props.spy && Hl.addStateHandler(this.stateHandler), Hl.addSpyHandler(this.spyHandler, s), this.setState({
              container: s
            });
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          Hl.unmount(this.stateHandler, this.spyHandler);
        }
      }, {
        key: "render",
        value: function() {
          var s = "";
          this.state && this.state.active ? s = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : s = this.props.className;
          var l = Gx({}, this.props);
          for (var u in SH)
            l.hasOwnProperty(u) && delete l[u];
          return l.className = s, l.onClick = this.handleClick, Gg.createElement(e, l);
        }
      }]), a;
    }(Gg.Component), o = function() {
      var i = this;
      this.scrollTo = function(a, s) {
        n.scrollTo(a, Gx({}, i.state, s));
      }, this.handleClick = function(a) {
        i.props.onClick && i.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), i.scrollTo(i.props.to, i.props);
      }, this.stateHandler = function() {
        n.getActiveLink() !== i.props.to && (i.state !== null && i.state.active && i.props.onSetInactive && i.props.onSetInactive(), i.setState({ active: !1 }));
      }, this.spyHandler = function(a) {
        var s = i.getScrollSpyContainer();
        if (!(Da.isMounted() && !Da.isInitialized())) {
          var l = i.props.to, u = null, c = 0, p = 0, d = 0;
          if (s.getBoundingClientRect) {
            var g = s.getBoundingClientRect();
            d = g.top;
          }
          if (!u || i.props.isDynamic) {
            if (u = n.get(l), !u)
              return;
            var f = u.getBoundingClientRect();
            c = f.top - d + a, p = c + f.height;
          }
          var m = a - i.props.offset, v = m >= Math.floor(c) && m < Math.floor(p), E = m < Math.floor(c) || m >= Math.floor(p), w = n.getActiveLink();
          if (E)
            return l === w && n.setActiveLink(void 0), i.props.hashSpy && Da.getHash() === l && Da.changeHash(), i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive()), Hl.updateStates();
          if (v && w !== l)
            return n.setActiveLink(l), i.props.hashSpy && Da.changeHash(l), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(l)), Hl.updateStates();
        }
      };
    };
    return r.propTypes = SH, r.defaultProps = { offset: 0 }, r;
  },
  Element: function(e) {
    console.warn("Helpers.Element is deprecated since v1.7.0");
    var t = function(n) {
      _H(r, n);
      function r(o) {
        LH(this, r);
        var i = PH(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
        return i.childBindings = {
          domNode: null
        }, i;
      }
      return kH(r, [{
        key: "componentDidMount",
        value: function() {
          if (typeof window > "u")
            return !1;
          this.registerElems(this.props.name);
        }
      }, {
        key: "componentDidUpdate",
        value: function(o) {
          this.props.name !== o.name && this.registerElems(this.props.name);
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          if (typeof window > "u")
            return !1;
          Kx.unregister(this.props.name);
        }
      }, {
        key: "registerElems",
        value: function(o) {
          Kx.register(o, this.childBindings.domNode);
        }
      }, {
        key: "render",
        value: function() {
          return Gg.createElement(e, Gx({}, this.props, { parentBindings: this.childBindings }));
        }
      }]), r;
    }(Gg.Component);
    return t.propTypes = {
      name: Jr.string,
      id: Jr.string
    }, t;
  }
}, nIe = tIe;
Object.defineProperty(fo, "__esModule", {
  value: !0
});
fo.Helpers = fo.ScrollElement = fo.ScrollLink = fo.animateScroll = fo.scrollSpy = fo.Events = fo.scroller = fo.Element = fo.Button = fo.Link = void 0;
var rIe = B_, LK = Bs(rIe), oIe = $_, PK = Bs(oIe), iIe = W_, _K = Bs(iIe), sIe = Rc, SK = Bs(sIe), aIe = Kf, MK = Bs(aIe), lIe = Zf, DK = Bs(lIe), uIe = e0, TK = Bs(uIe), cIe = Vf, jK = Bs(cIe), pIe = i0, AK = Bs(pIe), dIe = nIe, IK = Bs(dIe);
function Bs(e) {
  return e && e.__esModule ? e : { default: e };
}
fo.Link = LK.default;
fo.Button = PK.default;
fo.Element = _K.default;
fo.scroller = SK.default;
fo.Events = MK.default;
fo.scrollSpy = DK.default;
fo.animateScroll = TK.default;
fo.ScrollLink = jK.default;
fo.ScrollElement = AK.default;
fo.Helpers = IK.default;
fo.default = { Link: LK.default, Button: PK.default, Element: _K.default, scroller: SK.default, Events: MK.default, scrollSpy: DK.default, animateScroll: TK.default, ScrollLink: jK.default, ScrollElement: AK.default, Helpers: IK.default };
Ke({});
Ke({});
Ke({});
function lf(e) {
  "@babel/helpers - typeof";
  return lf = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, lf(e);
}
function fIe(e, t) {
  if (lf(e) != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (lf(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function hIe(e) {
  var t = fIe(e, "string");
  return lf(t) == "symbol" ? t : t + "";
}
function ke(e, t, n) {
  return (t = hIe(t)) in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function RK(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var Yx, MH;
function gIe() {
  if (MH) return Yx;
  MH = 1;
  var e = process.env.NODE_ENV, t = function(n, r, o, i, a, s, l, u) {
    if (e !== "production" && r === void 0)
      throw new Error("invariant requires an error message argument");
    if (!n) {
      var c;
      if (r === void 0)
        c = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
      else {
        var p = [o, i, a, s, l, u], d = 0;
        c = new Error(r.replace(/%s/g, function() {
          return p[d++];
        })), c.name = "Invariant Violation";
      }
      throw c.framesToPop = 1, c;
    }
  };
  return Yx = t, Yx;
}
var mIe = gIe(), xo = /* @__PURE__ */ RK(mIe), Rt = Ke(null);
function vIe() {
  xo(!!ge, "useGoogleMap is React hook and requires React version 16.8+");
  var e = ge(Rt);
  return xo(!!e, "useGoogleMap needs a GoogleMap available up in the tree"), e;
}
function yIe(e, t, n) {
  return Object.keys(e).reduce(function(r, o) {
    return t(r, e[o], o);
  }, n);
}
function bIe(e, t) {
  Object.keys(e).forEach((n) => t(e[n], n));
}
function wIe(e, t, n, r) {
  var o = {}, i = (a, s) => {
    var l = n[s];
    l !== t[s] && (o[s] = l, a(r, l));
  };
  return bIe(e, i), o;
}
function CIe(e, t, n) {
  var r = yIe(n, function(o, i, a) {
    return typeof e[a] == "function" && o.push(google.maps.event.addListener(t, i, e[a])), o;
  }, []);
  return r;
}
function xIe(e) {
  google.maps.event.removeListener(e);
}
function vn() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  e.forEach(xIe);
}
function pn(e) {
  var {
    updaterMap: t,
    eventMap: n,
    prevProps: r,
    nextProps: o,
    instance: i
  } = e, a = CIe(o, i, n);
  return wIe(t, r, o, i), a;
}
function OIe(e) {
  var {
    children: t,
    options: n,
    id: r,
    mapContainerStyle: o,
    mapContainerClassName: i,
    center: a,
    // clickableIcons,
    // extraMapTypes,
    // heading,
    // mapTypeId,
    onClick: s,
    onDblClick: l,
    onDrag: u,
    onDragEnd: c,
    onDragStart: p,
    onMouseMove: d,
    onMouseOut: g,
    onMouseOver: f,
    onMouseDown: m,
    onMouseUp: v,
    onRightClick: E,
    // onMapTypeIdChanged,
    // onTilesLoaded,
    // onBoundsChanged,
    onCenterChanged: w,
    // onHeadingChanged,
    // onIdle,
    // onProjectionChanged,
    // onResize,
    // onTiltChanged,
    // onZoomChanged,
    onLoad: M,
    onUnmount: O
  } = e, [y, C] = k(null), _ = ut(null), [F, L] = k(null), [N, R] = k(null), [W, V] = k(null), [z, Z] = k(null), [K, X] = k(null), [te, J] = k(null), [P, D] = k(null), [H, S] = k(null), [$, x] = k(null), [j, U] = k(null), [T, q] = k(null), [A, Y] = k(null);
  return h(() => {
    n && y !== null && y.setOptions(n);
  }, [y, n]), h(() => {
    y !== null && typeof a < "u" && y.setCenter(a);
  }, [y, a]), h(() => {
    y && l && (N !== null && google.maps.event.removeListener(N), R(google.maps.event.addListener(y, "dblclick", l)));
  }, [l]), h(() => {
    y && c && (W !== null && google.maps.event.removeListener(W), V(google.maps.event.addListener(y, "dragend", c)));
  }, [c]), h(() => {
    y && p && (z !== null && google.maps.event.removeListener(z), Z(google.maps.event.addListener(y, "dragstart", p)));
  }, [p]), h(() => {
    y && m && (K !== null && google.maps.event.removeListener(K), X(google.maps.event.addListener(y, "mousedown", m)));
  }, [m]), h(() => {
    y && d && (te !== null && google.maps.event.removeListener(te), J(google.maps.event.addListener(y, "mousemove", d)));
  }, [d]), h(() => {
    y && g && (P !== null && google.maps.event.removeListener(P), D(google.maps.event.addListener(y, "mouseout", g)));
  }, [g]), h(() => {
    y && f && (H !== null && google.maps.event.removeListener(H), S(google.maps.event.addListener(y, "mouseover", f)));
  }, [f]), h(() => {
    y && v && ($ !== null && google.maps.event.removeListener($), x(google.maps.event.addListener(y, "mouseup", v)));
  }, [v]), h(() => {
    y && E && (j !== null && google.maps.event.removeListener(j), U(google.maps.event.addListener(y, "rightclick", E)));
  }, [E]), h(() => {
    y && s && (T !== null && google.maps.event.removeListener(T), q(google.maps.event.addListener(y, "click", s)));
  }, [s]), h(() => {
    y && u && (A !== null && google.maps.event.removeListener(A), Y(google.maps.event.addListener(y, "drag", u)));
  }, [u]), h(() => {
    y && w && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(y, "center_changed", w)));
  }, [s]), h(() => {
    var B = _.current === null ? null : new google.maps.Map(_.current, n);
    return C(B), B !== null && M && M(B), () => {
      B !== null && O && O(B);
    };
  }, []), Po.jsx("div", {
    id: r,
    ref: _,
    style: o,
    className: i,
    children: Po.jsx(Rt.Provider, {
      value: y,
      children: y !== null ? t : null
    })
  });
}
ve(OIe);
function DH(e, t, n, r, o, i, a) {
  try {
    var s = e[i](a), l = s.value;
  } catch (u) {
    return void n(u);
  }
  s.done ? t(l) : Promise.resolve(l).then(r, o);
}
function BK(e) {
  return function() {
    var t = this, n = arguments;
    return new Promise(function(r, o) {
      var i = e.apply(t, n);
      function a(l) {
        DH(i, r, o, a, s, "next", l);
      }
      function s(l) {
        DH(i, r, o, a, s, "throw", l);
      }
      a(void 0);
    });
  };
}
function NK(e) {
  var {
    googleMapsApiKey: t,
    googleMapsClientId: n,
    version: r = "weekly",
    language: o,
    region: i,
    libraries: a,
    channel: s,
    mapIds: l,
    authReferrerPolicy: u
  } = e, c = [];
  return xo(t && n || !(t && n), "You need to specify either googleMapsApiKey or googleMapsClientId for @react-google-maps/api load script to work. You cannot use both at the same time."), t ? c.push("key=".concat(t)) : n && c.push("client=".concat(n)), r && c.push("v=".concat(r)), o && c.push("language=".concat(o)), i && c.push("region=".concat(i)), a && a.length && c.push("libraries=".concat(a.sort().join(","))), s && c.push("channel=".concat(s)), l && l.length && c.push("map_ids=".concat(l.join(","))), u && c.push("auth_referrer_policy=".concat(u)), c.push("loading=async"), c.push("callback=initMap"), "https://maps.googleapis.com/maps/api/js?".concat(c.join("&"));
}
var hu = typeof document < "u";
function FK(e) {
  var {
    url: t,
    id: n,
    nonce: r
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } = e;
  return hu ? new Promise(function(o, i) {
    var a = document.getElementById(n), s = window;
    if (a) {
      var l = a.getAttribute("data-state");
      if (a.src === t && l !== "error") {
        if (l === "ready")
          return o(n);
        var u = s.initMap, c = a.onerror;
        s.initMap = function() {
          u && u(), o(n);
        }, a.onerror = function(d) {
          c && c(d), i(d);
        };
        return;
      } else
        a.remove();
    }
    var p = document.createElement("script");
    p.type = "text/javascript", p.src = t, p.id = n, p.async = !0, p.nonce = r || "", p.onerror = function(d) {
      p.setAttribute("data-state", "error"), i(d);
    }, s.initMap = function() {
      p.setAttribute("data-state", "ready"), o(n);
    }, document.head.appendChild(p);
  }).catch((o) => {
    throw console.error("injectScript error: ", o), o;
  }) : Promise.reject(new Error("document is undefined"));
}
function TH(e) {
  var t = e.href;
  return t && (t.indexOf("https://fonts.googleapis.com/css?family=Roboto") === 0 || t.indexOf("https://fonts.googleapis.com/css?family=Google+Sans+Text") === 0) ? !0 : (
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.styleSheet.cssText = "", !0) : (
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.innerHTML = "", !0) : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.innerHTML
      )
    )
  );
}
function zK() {
  var e = document.getElementsByTagName("head")[0];
  if (e) {
    var t = e.insertBefore.bind(e);
    e.insertBefore = function(r, o) {
      return TH(r) || Reflect.apply(t, e, [r, o]), r;
    };
    var n = e.appendChild.bind(e);
    e.appendChild = function(r) {
      return TH(r) || Reflect.apply(n, e, [r]), r;
    };
  }
}
var gp = !1;
function UK() {
  return Po.jsx("div", {
    children: "Loading..."
  });
}
var Vk = {
  id: "script-loader",
  version: "weekly"
};
class EIe extends pe {
  constructor() {
    super(...arguments), ke(this, "check", null), ke(this, "state", {
      loaded: !1
    }), ke(this, "cleanupCallback", () => {
      delete window.google.maps, this.injectScript();
    }), ke(this, "isCleaningUp", /* @__PURE__ */ BK(function* () {
      function t(n) {
        if (!gp)
          n();
        else if (hu)
          var r = window.setInterval(function() {
            gp || (window.clearInterval(r), n());
          }, 1);
      }
      return new Promise(t);
    })), ke(this, "cleanup", () => {
      gp = !0;
      var t = document.getElementById(this.props.id);
      t && t.parentNode && t.parentNode.removeChild(t), Array.prototype.slice.call(document.getElementsByTagName("script")).filter(function(n) {
        return typeof n.src == "string" && n.src.includes("maps.googleapis");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("link")).filter(function(n) {
        return n.href === "https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Google+Sans";
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("style")).filter(function(n) {
        return n.innerText !== void 0 && n.innerText.length > 0 && n.innerText.includes(".gm-");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      });
    }), ke(this, "injectScript", () => {
      this.props.preventGoogleFontsLoading && zK(), xo(!!this.props.id, 'LoadScript requires "id" prop to be a string: %s', this.props.id);
      var t = {
        id: this.props.id,
        nonce: this.props.nonce,
        url: NK(this.props)
      };
      FK(t).then(() => {
        this.props.onLoad && this.props.onLoad(), this.setState(function() {
          return {
            loaded: !0
          };
        });
      }).catch((n) => {
        this.props.onError && this.props.onError(n), console.error(`
          There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(this.props.googleMapsApiKey || "-", ") or Client ID (").concat(this.props.googleMapsClientId || "-", `) to <LoadScript />
          Otherwise it is a Network issue.
        `));
      });
    }), ke(this, "getRef", (t) => {
      this.check = t;
    });
  }
  componentDidMount() {
    if (hu) {
      if (window.google && window.google.maps && !gp) {
        console.error("google api is already presented");
        return;
      }
      this.isCleaningUp().then(this.injectScript).catch(function(t) {
        console.error("Error at injecting script after cleaning up: ", t);
      });
    }
  }
  componentDidUpdate(t) {
    this.props.libraries !== t.libraries && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), hu && t.language !== this.props.language && (this.cleanup(), this.setState(function() {
      return {
        loaded: !1
      };
    }, this.cleanupCallback));
  }
  componentWillUnmount() {
    if (hu) {
      this.cleanup();
      var t = () => {
        this.check || (delete window.google, gp = !1);
      };
      window.setTimeout(t, 1), this.props.onUnmount && this.props.onUnmount();
    }
  }
  render() {
    return Po.jsxs(Po.Fragment, {
      children: [Po.jsx("div", {
        ref: this.getRef
      }), this.state.loaded ? this.props.children : this.props.loadingElement || Po.jsx(UK, {})]
    });
  }
}
ke(EIe, "defaultProps", Vk);
function kIe(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.includes(r)) continue;
    n[r] = e[r];
  }
  return n;
}
function Z_(e, t) {
  if (e == null) return {};
  var n, r, o = kIe(e, t);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (r = 0; r < i.length; r++) n = i[r], t.includes(n) || {}.propertyIsEnumerable.call(e, n) && (o[n] = e[n]);
  }
  return o;
}
var jH;
function LIe(e) {
  var {
    id: t = Vk.id,
    version: n = Vk.version,
    nonce: r,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    preventGoogleFontsLoading: u,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  } = e, g = ut(!1), [f, m] = k(!1), [v, E] = k(void 0);
  h(function() {
    return g.current = !0, () => {
      g.current = !1;
    };
  }, []), h(function() {
    hu && u && zK();
  }, [u]), h(function() {
    f && xo(!!window.google, "useLoadScript was marked as loaded, but window.google is not present. Something went wrong.");
  }, [f]);
  var w = NK({
    version: n,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  });
  h(function() {
    if (!hu)
      return;
    function O() {
      g.current && (m(!0), jH = w);
    }
    if (window.google && window.google.maps && jH === w) {
      O();
      return;
    }
    FK({
      id: t,
      url: w,
      nonce: r
    }).then(O).catch(function(y) {
      g.current && E(y), console.warn(`
        There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(o || "-", ") or Client ID (").concat(i || "-", `)
        Otherwise it is a Network issue.
      `)), console.error(y);
    });
  }, [t, w, r]);
  var M = ut(void 0);
  return h(function() {
    M.current && l !== M.current && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), M.current = l;
  }, [l]), {
    isLoaded: f,
    loadError: v,
    url: w
  };
}
var PIe = ["loadingElement", "onLoad", "onError", "onUnmount", "children"], _Ie = Po.jsx(UK, {});
function SIe(e) {
  var {
    loadingElement: t,
    onLoad: n,
    onError: r,
    onUnmount: o,
    children: i
  } = e, a = Z_(e, PIe), {
    isLoaded: s,
    loadError: l
  } = LIe(a);
  return h(function() {
    s && typeof n == "function" && n();
  }, [s, n]), h(function() {
    l && typeof r == "function" && r(l);
  }, [l, r]), h(function() {
    return () => {
      o && o();
    };
  }, [o]), s ? i : t || _Ie;
}
ve(SIe);
var AH;
(function(e) {
  e[e.INITIALIZED = 0] = "INITIALIZED", e[e.LOADING = 1] = "LOADING", e[e.SUCCESS = 2] = "SUCCESS", e[e.FAILURE = 3] = "FAILURE";
})(AH || (AH = {}));
function IH(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function hy(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? IH(Object(n), !0).forEach(function(r) {
      ke(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : IH(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var RH = {}, BH = {
  options(e, t) {
    e.setOptions(t);
  }
};
function MIe(e) {
  var {
    options: t,
    onLoad: n,
    onUnmount: r
  } = e, o = ge(Rt), [i, a] = k(null);
  return h(() => {
    i !== null && i.setMap(o);
  }, [o]), h(() => {
    t && i !== null && i.setOptions(t);
  }, [i, t]), h(() => {
    var s = new google.maps.TrafficLayer(hy(hy({}, t), {}, {
      map: o
    }));
    return a(s), n && n(s), () => {
      i !== null && (r && r(i), i.setMap(null));
    };
  }, []), null;
}
ve(MIe);
class DIe extends pe {
  constructor() {
    super(...arguments), ke(this, "state", {
      trafficLayer: null
    }), ke(this, "setTrafficLayerCallback", () => {
      this.state.trafficLayer !== null && this.props.onLoad && this.props.onLoad(this.state.trafficLayer);
    }), ke(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = new google.maps.TrafficLayer(hy(hy({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = pn({
      updaterMap: BH,
      eventMap: RH,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        trafficLayer: t
      };
    }, this.setTrafficLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.trafficLayer !== null && (vn(this.registeredEvents), this.registeredEvents = pn({
      updaterMap: BH,
      eventMap: RH,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.trafficLayer
    }));
  }
  componentWillUnmount() {
    this.state.trafficLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.trafficLayer), vn(this.registeredEvents), this.state.trafficLayer.setMap(null));
  }
  render() {
    return null;
  }
}
ke(DIe, "contextType", Rt);
function TIe(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = ge(Rt), [o, i] = k(null);
  return h(() => {
    o !== null && o.setMap(r);
  }, [r]), h(() => {
    var a = new google.maps.BicyclingLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      a !== null && (n && n(a), a.setMap(null));
    };
  }, []), null;
}
ve(TIe);
class jIe extends pe {
  constructor() {
    super(...arguments), ke(this, "state", {
      bicyclingLayer: null
    }), ke(this, "setBicyclingLayerCallback", () => {
      this.state.bicyclingLayer !== null && (this.state.bicyclingLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.bicyclingLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.BicyclingLayer();
    this.setState(() => ({
      bicyclingLayer: t
    }), this.setBicyclingLayerCallback);
  }
  componentWillUnmount() {
    this.state.bicyclingLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.bicyclingLayer), this.state.bicyclingLayer.setMap(null));
  }
  render() {
    return null;
  }
}
ke(jIe, "contextType", Rt);
function AIe(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = ge(Rt), [o, i] = k(null);
  return h(() => {
    o !== null && o.setMap(r);
  }, [r]), h(() => {
    var a = new google.maps.TransitLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      o !== null && (n && n(o), o.setMap(null));
    };
  }, []), null;
}
ve(AIe);
class IIe extends pe {
  constructor() {
    super(...arguments), ke(this, "state", {
      transitLayer: null
    }), ke(this, "setTransitLayerCallback", () => {
      this.state.transitLayer !== null && (this.state.transitLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.transitLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.TransitLayer();
    this.setState(function() {
      return {
        transitLayer: t
      };
    }, this.setTransitLayerCallback);
  }
  componentWillUnmount() {
    this.state.transitLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.transitLayer), this.state.transitLayer.setMap(null));
  }
  render() {
    return null;
  }
}
ke(IIe, "contextType", Rt);
function NH(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function gy(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? NH(Object(n), !0).forEach(function(r) {
      ke(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : NH(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var FH = {
  onCircleComplete: "circlecomplete",
  onMarkerComplete: "markercomplete",
  onOverlayComplete: "overlaycomplete",
  onPolygonComplete: "polygoncomplete",
  onPolylineComplete: "polylinecomplete",
  onRectangleComplete: "rectanglecomplete"
}, zH = {
  drawingMode(e, t) {
    e.setDrawingMode(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function RIe(e) {
  var {
    options: t,
    drawingMode: n,
    onCircleComplete: r,
    onMarkerComplete: o,
    onOverlayComplete: i,
    onPolygonComplete: a,
    onPolylineComplete: s,
    onRectangleComplete: l,
    onLoad: u,
    onUnmount: c
  } = e, p = ge(Rt), [d, g] = k(null), [f, m] = k(null), [v, E] = k(null), [w, M] = k(null), [O, y] = k(null), [C, _] = k(null), [F, L] = k(null);
  return h(() => {
    d !== null && d.setMap(p);
  }, [p]), h(() => {
    t && d !== null && d.setOptions(t);
  }, [d, t]), h(() => {
    d !== null && d.setDrawingMode(n ?? null);
  }, [d, n]), h(() => {
    d && r && (f !== null && google.maps.event.removeListener(f), m(google.maps.event.addListener(d, "circlecomplete", r)));
  }, [d, r]), h(() => {
    d && o && (v !== null && google.maps.event.removeListener(v), E(google.maps.event.addListener(d, "markercomplete", o)));
  }, [d, o]), h(() => {
    d && i && (w !== null && google.maps.event.removeListener(w), M(google.maps.event.addListener(d, "overlaycomplete", i)));
  }, [d, i]), h(() => {
    d && a && (O !== null && google.maps.event.removeListener(O), y(google.maps.event.addListener(d, "polygoncomplete", a)));
  }, [d, a]), h(() => {
    d && s && (C !== null && google.maps.event.removeListener(C), _(google.maps.event.addListener(d, "polylinecomplete", s)));
  }, [d, s]), h(() => {
    d && l && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(d, "rectanglecomplete", l)));
  }, [d, l]), h(() => {
    xo(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
    var N = new google.maps.drawing.DrawingManager(gy(gy({}, t), {}, {
      map: p
    }));
    return n && N.setDrawingMode(n), r && m(google.maps.event.addListener(N, "circlecomplete", r)), o && E(google.maps.event.addListener(N, "markercomplete", o)), i && M(google.maps.event.addListener(N, "overlaycomplete", i)), a && y(google.maps.event.addListener(N, "polygoncomplete", a)), s && _(google.maps.event.addListener(N, "polylinecomplete", s)), l && L(google.maps.event.addListener(N, "rectanglecomplete", l)), g(N), u && u(N), () => {
      d !== null && (f && google.maps.event.removeListener(f), v && google.maps.event.removeListener(v), w && google.maps.event.removeListener(w), O && google.maps.event.removeListener(O), C && google.maps.event.removeListener(C), F && google.maps.event.removeListener(F), c && c(d), d.setMap(null));
    };
  }, []), null;
}
ve(RIe);
class BIe extends pe {
  constructor(t) {
    super(t), ke(this, "registeredEvents", []), ke(this, "state", {
      drawingManager: null
    }), ke(this, "setDrawingManagerCallback", () => {
      this.state.drawingManager !== null && this.props.onLoad && this.props.onLoad(this.state.drawingManager);
    }), xo(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
  }
  componentDidMount() {
    var t = new google.maps.drawing.DrawingManager(gy(gy({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = pn({
      updaterMap: zH,
      eventMap: FH,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        drawingManager: t
      };
    }, this.setDrawingManagerCallback);
  }
  componentDidUpdate(t) {
    this.state.drawingManager !== null && (vn(this.registeredEvents), this.registeredEvents = pn({
      updaterMap: zH,
      eventMap: FH,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.drawingManager
    }));
  }
  componentWillUnmount() {
    this.state.drawingManager !== null && (this.props.onUnmount && this.props.onUnmount(this.state.drawingManager), vn(this.registeredEvents), this.state.drawingManager.setMap(null));
  }
  render() {
    return null;
  }
}
ke(BIe, "contextType", Rt);
function UH(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ac(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? UH(Object(n), !0).forEach(function(r) {
      ke(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : UH(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var HH = {
  onAnimationChanged: "animation_changed",
  onClick: "click",
  onClickableChanged: "clickable_changed",
  onCursorChanged: "cursor_changed",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDraggableChanged: "draggable_changed",
  onDragStart: "dragstart",
  onFlatChanged: "flat_changed",
  onIconChanged: "icon_changed",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onPositionChanged: "position_changed",
  onRightClick: "rightclick",
  onShapeChanged: "shape_changed",
  onTitleChanged: "title_changed",
  onVisibleChanged: "visible_changed",
  onZindexChanged: "zindex_changed"
}, $H = {
  animation(e, t) {
    e.setAnimation(t);
  },
  clickable(e, t) {
    e.setClickable(t);
  },
  cursor(e, t) {
    e.setCursor(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  icon(e, t) {
    e.setIcon(t);
  },
  label(e, t) {
    e.setLabel(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  opacity(e, t) {
    e.setOpacity(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  shape(e, t) {
    e.setShape(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, my = {};
function NIe(e) {
  var {
    position: t,
    options: n,
    clusterer: r,
    noClustererRedraw: o,
    children: i,
    draggable: a,
    visible: s,
    animation: l,
    clickable: u,
    cursor: c,
    icon: p,
    label: d,
    opacity: g,
    shape: f,
    title: m,
    zIndex: v,
    onClick: E,
    onDblClick: w,
    onDrag: M,
    onDragEnd: O,
    onDragStart: y,
    onMouseOut: C,
    onMouseOver: _,
    onMouseUp: F,
    onMouseDown: L,
    onRightClick: N,
    onClickableChanged: R,
    onCursorChanged: W,
    onAnimationChanged: V,
    onDraggableChanged: z,
    onFlatChanged: Z,
    onIconChanged: K,
    onPositionChanged: X,
    onShapeChanged: te,
    onTitleChanged: J,
    onVisibleChanged: P,
    onZindexChanged: D,
    onLoad: H,
    onUnmount: S
  } = e, $ = ge(Rt), [x, j] = k(null), [U, T] = k(null), [q, A] = k(null), [Y, B] = k(null), [ue, fe] = k(null), [oe, Ae] = k(null), [Ze, Ge] = k(null), [Ie, et] = k(null), [Ye, _e] = k(null), [Qe, at] = k(null), [Pe, Me] = k(null), [Je, We] = k(null), [Re, nt] = k(null), [De, yt] = k(null), [ot, st] = k(null), [ct, bt] = k(null), [pt, dt] = k(null), [tt, Xe] = k(null), [wt, Ct] = k(null), [ft, bn] = k(null), [ht, wn] = k(null), [gt, Mt] = k(null);
  h(() => {
    x !== null && x.setMap($);
  }, [$]), h(() => {
    typeof n < "u" && x !== null && x.setOptions(n);
  }, [x, n]), h(() => {
    typeof a < "u" && x !== null && x.setDraggable(a);
  }, [x, a]), h(() => {
    t && x !== null && x.setPosition(t);
  }, [x, t]), h(() => {
    typeof s < "u" && x !== null && x.setVisible(s);
  }, [x, s]), h(() => {
    x == null || x.setAnimation(l);
  }, [x, l]), h(() => {
    x && u !== void 0 && x.setClickable(u);
  }, [x, u]), h(() => {
    x && c !== void 0 && x.setCursor(c);
  }, [x, c]), h(() => {
    x && p !== void 0 && x.setIcon(p);
  }, [x, p]), h(() => {
    x && d !== void 0 && x.setLabel(d);
  }, [x, d]), h(() => {
    x && g !== void 0 && x.setOpacity(g);
  }, [x, g]), h(() => {
    x && f !== void 0 && x.setShape(f);
  }, [x, f]), h(() => {
    x && m !== void 0 && x.setTitle(m);
  }, [x, m]), h(() => {
    x && v !== void 0 && x.setZIndex(v);
  }, [x, v]), h(() => {
    x && w && (U !== null && google.maps.event.removeListener(U), T(google.maps.event.addListener(x, "dblclick", w)));
  }, [w]), h(() => {
    x && O && (q !== null && google.maps.event.removeListener(q), A(google.maps.event.addListener(x, "dragend", O)));
  }, [O]), h(() => {
    x && y && (Y !== null && google.maps.event.removeListener(Y), B(google.maps.event.addListener(x, "dragstart", y)));
  }, [y]), h(() => {
    x && L && (ue !== null && google.maps.event.removeListener(ue), fe(google.maps.event.addListener(x, "mousedown", L)));
  }, [L]), h(() => {
    x && C && (oe !== null && google.maps.event.removeListener(oe), Ae(google.maps.event.addListener(x, "mouseout", C)));
  }, [C]), h(() => {
    x && _ && (Ze !== null && google.maps.event.removeListener(Ze), Ge(google.maps.event.addListener(x, "mouseover", _)));
  }, [_]), h(() => {
    x && F && (Ie !== null && google.maps.event.removeListener(Ie), et(google.maps.event.addListener(x, "mouseup", F)));
  }, [F]), h(() => {
    x && N && (Ye !== null && google.maps.event.removeListener(Ye), _e(google.maps.event.addListener(x, "rightclick", N)));
  }, [N]), h(() => {
    x && E && (Qe !== null && google.maps.event.removeListener(Qe), at(google.maps.event.addListener(x, "click", E)));
  }, [E]), h(() => {
    x && M && (Pe !== null && google.maps.event.removeListener(Pe), Me(google.maps.event.addListener(x, "drag", M)));
  }, [M]), h(() => {
    x && R && (Je !== null && google.maps.event.removeListener(Je), We(google.maps.event.addListener(x, "clickable_changed", R)));
  }, [R]), h(() => {
    x && W && (Re !== null && google.maps.event.removeListener(Re), nt(google.maps.event.addListener(x, "cursor_changed", W)));
  }, [W]), h(() => {
    x && V && (De !== null && google.maps.event.removeListener(De), yt(google.maps.event.addListener(x, "animation_changed", V)));
  }, [V]), h(() => {
    x && z && (ot !== null && google.maps.event.removeListener(ot), st(google.maps.event.addListener(x, "draggable_changed", z)));
  }, [z]), h(() => {
    x && Z && (ct !== null && google.maps.event.removeListener(ct), bt(google.maps.event.addListener(x, "flat_changed", Z)));
  }, [Z]), h(() => {
    x && K && (pt !== null && google.maps.event.removeListener(pt), dt(google.maps.event.addListener(x, "icon_changed", K)));
  }, [K]), h(() => {
    x && X && (tt !== null && google.maps.event.removeListener(tt), Xe(google.maps.event.addListener(x, "position_changed", X)));
  }, [X]), h(() => {
    x && te && (wt !== null && google.maps.event.removeListener(wt), Ct(google.maps.event.addListener(x, "shape_changed", te)));
  }, [te]), h(() => {
    x && J && (ft !== null && google.maps.event.removeListener(ft), bn(google.maps.event.addListener(x, "title_changed", J)));
  }, [J]), h(() => {
    x && P && (ht !== null && google.maps.event.removeListener(ht), wn(google.maps.event.addListener(x, "visible_changed", P)));
  }, [P]), h(() => {
    x && D && (gt !== null && google.maps.event.removeListener(gt), Mt(google.maps.event.addListener(x, "zindex_changed", D)));
  }, [D]), h(() => {
    var mt = ac(ac(ac({}, n || my), r ? my : {
      map: $
    }), {}, {
      position: t
    }), re = new google.maps.Marker(mt);
    return r ? r.addMarker(re, !!o) : re.setMap($), t && re.setPosition(t), typeof s < "u" && re.setVisible(s), typeof a < "u" && re.setDraggable(a), typeof u < "u" && re.setClickable(u), typeof c == "string" && re.setCursor(c), p && re.setIcon(p), typeof d < "u" && re.setLabel(d), typeof g < "u" && re.setOpacity(g), f && re.setShape(f), typeof m == "string" && re.setTitle(m), typeof v == "number" && re.setZIndex(v), w && T(google.maps.event.addListener(re, "dblclick", w)), O && A(google.maps.event.addListener(re, "dragend", O)), y && B(google.maps.event.addListener(re, "dragstart", y)), L && fe(google.maps.event.addListener(re, "mousedown", L)), C && Ae(google.maps.event.addListener(re, "mouseout", C)), _ && Ge(google.maps.event.addListener(re, "mouseover", _)), F && et(google.maps.event.addListener(re, "mouseup", F)), N && _e(google.maps.event.addListener(re, "rightclick", N)), E && at(google.maps.event.addListener(re, "click", E)), M && Me(google.maps.event.addListener(re, "drag", M)), R && We(google.maps.event.addListener(re, "clickable_changed", R)), W && nt(google.maps.event.addListener(re, "cursor_changed", W)), V && yt(google.maps.event.addListener(re, "animation_changed", V)), z && st(google.maps.event.addListener(re, "draggable_changed", z)), Z && bt(google.maps.event.addListener(re, "flat_changed", Z)), K && dt(google.maps.event.addListener(re, "icon_changed", K)), X && Xe(google.maps.event.addListener(re, "position_changed", X)), te && Ct(google.maps.event.addListener(re, "shape_changed", te)), J && bn(google.maps.event.addListener(re, "title_changed", J)), P && wn(google.maps.event.addListener(re, "visible_changed", P)), D && Mt(google.maps.event.addListener(re, "zindex_changed", D)), j(re), H && H(re), () => {
      U !== null && google.maps.event.removeListener(U), q !== null && google.maps.event.removeListener(q), Y !== null && google.maps.event.removeListener(Y), ue !== null && google.maps.event.removeListener(ue), oe !== null && google.maps.event.removeListener(oe), Ze !== null && google.maps.event.removeListener(Ze), Ie !== null && google.maps.event.removeListener(Ie), Ye !== null && google.maps.event.removeListener(Ye), Qe !== null && google.maps.event.removeListener(Qe), Je !== null && google.maps.event.removeListener(Je), Re !== null && google.maps.event.removeListener(Re), De !== null && google.maps.event.removeListener(De), ot !== null && google.maps.event.removeListener(ot), ct !== null && google.maps.event.removeListener(ct), pt !== null && google.maps.event.removeListener(pt), tt !== null && google.maps.event.removeListener(tt), ft !== null && google.maps.event.removeListener(ft), ht !== null && google.maps.event.removeListener(ht), gt !== null && google.maps.event.removeListener(gt), S && S(re), r ? r.removeMarker(re, !!o) : re && re.setMap(null);
    };
  }, []);
  var ir = Cn(() => i ? lt.map(i, (mt) => {
    if (!yi(mt))
      return mt;
    var re = mt;
    return bi(re, {
      anchor: x
    });
  }) : null, [i, x]);
  return Po.jsx(Po.Fragment, {
    children: ir
  }) || null;
}
ve(NIe);
class FIe extends pe {
  constructor() {
    super(...arguments), ke(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this;
    return BK(function* () {
      var n = ac(ac(ac({}, t.props.options || my), t.props.clusterer ? my : {
        map: t.context
      }), {}, {
        position: t.props.position
      });
      t.marker = new google.maps.Marker(n), t.props.clusterer ? t.props.clusterer.addMarker(t.marker, !!t.props.noClustererRedraw) : t.marker.setMap(t.context), t.registeredEvents = pn({
        updaterMap: $H,
        eventMap: HH,
        prevProps: {},
        nextProps: t.props,
        instance: t.marker
      }), t.props.onLoad && t.props.onLoad(t.marker);
    })();
  }
  componentDidUpdate(t) {
    this.marker && (vn(this.registeredEvents), this.registeredEvents = pn({
      updaterMap: $H,
      eventMap: HH,
      prevProps: t,
      nextProps: this.props,
      instance: this.marker
    }));
  }
  componentWillUnmount() {
    this.marker && (this.props.onUnmount && this.props.onUnmount(this.marker), vn(this.registeredEvents), this.props.clusterer ? this.props.clusterer.removeMarker(this.marker, !!this.props.noClustererRedraw) : this.marker && this.marker.setMap(null));
  }
  render() {
    var t = this.props.children ? lt.map(this.props.children, (n) => {
      if (!yi(n))
        return n;
      var r = n;
      return bi(r, {
        anchor: this.marker
      });
    }) : null;
    return t || null;
  }
}
ke(FIe, "contextType", Rt);
var zIe = (
  /** @class */
  function() {
    function e(t, n) {
      t.getClusterer().extend(e, google.maps.OverlayView), this.cluster = t, this.clusterClassName = this.cluster.getClusterer().getClusterClass(), this.className = this.clusterClassName, this.styles = n, this.center = void 0, this.div = null, this.sums = null, this.visible = !1, this.boundsChangedListener = null, this.url = "", this.height = 0, this.width = 0, this.anchorText = [0, 0], this.anchorIcon = [0, 0], this.textColor = "black", this.textSize = 11, this.textDecoration = "none", this.fontWeight = "bold", this.fontStyle = "normal", this.fontFamily = "Arial,sans-serif", this.backgroundPosition = "0 0", this.cMouseDownInCluster = null, this.cDraggingMapByCluster = null, this.timeOut = null, this.setMap(t.getMap()), this.onBoundsChanged = this.onBoundsChanged.bind(this), this.onMouseDown = this.onMouseDown.bind(this), this.onClick = this.onClick.bind(this), this.onMouseOver = this.onMouseOver.bind(this), this.onMouseOut = this.onMouseOut.bind(this), this.onAdd = this.onAdd.bind(this), this.onRemove = this.onRemove.bind(this), this.draw = this.draw.bind(this), this.hide = this.hide.bind(this), this.show = this.show.bind(this), this.useStyle = this.useStyle.bind(this), this.setCenter = this.setCenter.bind(this), this.getPosFromLatLng = this.getPosFromLatLng.bind(this);
    }
    return e.prototype.onBoundsChanged = function() {
      this.cDraggingMapByCluster = this.cMouseDownInCluster;
    }, e.prototype.onMouseDown = function() {
      this.cMouseDownInCluster = !0, this.cDraggingMapByCluster = !1;
    }, e.prototype.onClick = function(t) {
      if (this.cMouseDownInCluster = !1, !this.cDraggingMapByCluster) {
        var n = this.cluster.getClusterer();
        if (google.maps.event.trigger(n, "click", this.cluster), google.maps.event.trigger(n, "clusterclick", this.cluster), n.getZoomOnClick()) {
          var r = n.getMaxZoom(), o = this.cluster.getBounds(), i = n.getMap();
          i !== null && "fitBounds" in i && i.fitBounds(o), this.timeOut = window.setTimeout(function() {
            var a = n.getMap();
            if (a !== null) {
              "fitBounds" in a && a.fitBounds(o);
              var s = a.getZoom() || 0;
              r !== null && s > r && a.setZoom(r + 1);
            }
          }, 100);
        }
        t.cancelBubble = !0, t.stopPropagation && t.stopPropagation();
      }
    }, e.prototype.onMouseOver = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseover", this.cluster);
    }, e.prototype.onMouseOut = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseout", this.cluster);
    }, e.prototype.onAdd = function() {
      var t;
      this.div = document.createElement("div"), this.div.className = this.className, this.visible && this.show(), (t = this.getPanes()) === null || t === void 0 || t.overlayMouseTarget.appendChild(this.div);
      var n = this.getMap();
      n !== null && (this.boundsChangedListener = google.maps.event.addListener(n, "bounds_changed", this.onBoundsChanged), this.div.addEventListener("mousedown", this.onMouseDown), this.div.addEventListener("click", this.onClick), this.div.addEventListener("mouseover", this.onMouseOver), this.div.addEventListener("mouseout", this.onMouseOut));
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.hide(), this.boundsChangedListener !== null && google.maps.event.removeListener(this.boundsChangedListener), this.div.removeEventListener("mousedown", this.onMouseDown), this.div.removeEventListener("click", this.onClick), this.div.removeEventListener("mouseover", this.onMouseOver), this.div.removeEventListener("mouseout", this.onMouseOut), this.div.parentNode.removeChild(this.div), this.timeOut !== null && (window.clearTimeout(this.timeOut), this.timeOut = null), this.div = null);
    }, e.prototype.draw = function() {
      if (this.visible && this.div !== null && this.center) {
        var t = this.getPosFromLatLng(this.center);
        this.div.style.top = t !== null ? "".concat(t.y, "px") : "0", this.div.style.left = t !== null ? "".concat(t.x, "px") : "0";
      }
    }, e.prototype.hide = function() {
      this.div && (this.div.style.display = "none"), this.visible = !1;
    }, e.prototype.show = function() {
      var t, n, r, o, i, a;
      if (this.div && this.center) {
        var s = this.sums === null || typeof this.sums.title > "u" || this.sums.title === "" ? this.cluster.getClusterer().getTitle() : this.sums.title, l = this.backgroundPosition.split(" "), u = parseInt(((t = l[0]) === null || t === void 0 ? void 0 : t.replace(/^\s+|\s+$/g, "")) || "0", 10), c = parseInt(((n = l[1]) === null || n === void 0 ? void 0 : n.replace(/^\s+|\s+$/g, "")) || "0", 10), p = this.getPosFromLatLng(this.center);
        this.div.className = this.className, this.div.setAttribute("style", "cursor: pointer; position: absolute; top: ".concat(p !== null ? "".concat(p.y, "px") : "0", "; left: ").concat(p !== null ? "".concat(p.x, "px") : "0", "; width: ").concat(this.width, "px; height: ").concat(this.height, "px; "));
        var d = document.createElement("img");
        d.alt = s, d.src = this.url, d.width = this.width, d.height = this.height, d.setAttribute("style", "position: absolute; top: ".concat(c, "px; left: ").concat(u, "px")), this.cluster.getClusterer().enableRetinaIcons || (d.style.clip = "rect(-".concat(c, "px, -").concat(u + this.width, "px, -").concat(c + this.height, ", -").concat(u, ")"));
        var g = document.createElement("div");
        g.setAttribute("style", "position: absolute; top: ".concat(this.anchorText[0], "px; left: ").concat(this.anchorText[1], "px; color: ").concat(this.textColor, "; font-size: ").concat(this.textSize, "px; font-family: ").concat(this.fontFamily, "; font-weight: ").concat(this.fontWeight, "; fontStyle: ").concat(this.fontStyle, "; text-decoration: ").concat(this.textDecoration, "; text-align: center; width: ").concat(this.width, "px; line-height: ").concat(this.height, "px")), !((r = this.sums) === null || r === void 0) && r.text && (g.innerText = "".concat((o = this.sums) === null || o === void 0 ? void 0 : o.text)), !((i = this.sums) === null || i === void 0) && i.html && (g.innerHTML = "".concat((a = this.sums) === null || a === void 0 ? void 0 : a.html)), this.div.innerHTML = "", this.div.appendChild(d), this.div.appendChild(g), this.div.title = s, this.div.style.display = "";
      }
      this.visible = !0;
    }, e.prototype.useStyle = function(t) {
      this.sums = t;
      var n = this.cluster.getClusterer().getStyles(), r = n[Math.min(n.length - 1, Math.max(0, t.index - 1))];
      r && (this.url = r.url, this.height = r.height, this.width = r.width, r.className && (this.className = "".concat(this.clusterClassName, " ").concat(r.className)), this.anchorText = r.anchorText || [0, 0], this.anchorIcon = r.anchorIcon || [this.height / 2, this.width / 2], this.textColor = r.textColor || "black", this.textSize = r.textSize || 11, this.textDecoration = r.textDecoration || "none", this.fontWeight = r.fontWeight || "bold", this.fontStyle = r.fontStyle || "normal", this.fontFamily = r.fontFamily || "Arial,sans-serif", this.backgroundPosition = r.backgroundPosition || "0 0");
    }, e.prototype.setCenter = function(t) {
      this.center = t;
    }, e.prototype.getPosFromLatLng = function(t) {
      var n = this.getProjection().fromLatLngToDivPixel(t);
      return n !== null && (n.x -= this.anchorIcon[1], n.y -= this.anchorIcon[0]), n;
    }, e;
  }()
), UIe = (
  /** @class */
  function() {
    function e(t) {
      this.markerClusterer = t, this.map = this.markerClusterer.getMap(), this.gridSize = this.markerClusterer.getGridSize(), this.minClusterSize = this.markerClusterer.getMinimumClusterSize(), this.averageCenter = this.markerClusterer.getAverageCenter(), this.markers = [], this.center = void 0, this.bounds = null, this.clusterIcon = new zIe(this, this.markerClusterer.getStyles()), this.getSize = this.getSize.bind(this), this.getMarkers = this.getMarkers.bind(this), this.getCenter = this.getCenter.bind(this), this.getMap = this.getMap.bind(this), this.getClusterer = this.getClusterer.bind(this), this.getBounds = this.getBounds.bind(this), this.remove = this.remove.bind(this), this.addMarker = this.addMarker.bind(this), this.isMarkerInClusterBounds = this.isMarkerInClusterBounds.bind(this), this.calculateBounds = this.calculateBounds.bind(this), this.updateIcon = this.updateIcon.bind(this), this.isMarkerAlreadyAdded = this.isMarkerAlreadyAdded.bind(this);
    }
    return e.prototype.getSize = function() {
      return this.markers.length;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getCenter = function() {
      return this.center;
    }, e.prototype.getMap = function() {
      return this.map;
    }, e.prototype.getClusterer = function() {
      return this.markerClusterer;
    }, e.prototype.getBounds = function() {
      for (var t = new google.maps.LatLngBounds(this.center, this.center), n = this.getMarkers(), r = 0, o = n; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && t.extend(a);
      }
      return t;
    }, e.prototype.remove = function() {
      this.clusterIcon.setMap(null), this.markers = [], delete this.markers;
    }, e.prototype.addMarker = function(t) {
      var n;
      if (this.isMarkerAlreadyAdded(t))
        return !1;
      if (this.center) {
        if (this.averageCenter) {
          var r = t.getPosition();
          if (r) {
            var o = this.markers.length + 1;
            this.center = new google.maps.LatLng((this.center.lat() * (o - 1) + r.lat()) / o, (this.center.lng() * (o - 1) + r.lng()) / o), this.calculateBounds();
          }
        }
      } else {
        var r = t.getPosition();
        r && (this.center = r, this.calculateBounds());
      }
      t.isAdded = !0, this.markers.push(t);
      var i = this.markers.length, a = this.markerClusterer.getMaxZoom(), s = (n = this.map) === null || n === void 0 ? void 0 : n.getZoom();
      if (a !== null && typeof s < "u" && s > a)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i < this.minClusterSize)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i === this.minClusterSize)
        for (var l = 0, u = this.markers; l < u.length; l++) {
          var c = u[l];
          c.setMap(null);
        }
      else
        t.setMap(null);
      return !0;
    }, e.prototype.isMarkerInClusterBounds = function(t) {
      if (this.bounds !== null) {
        var n = t.getPosition();
        if (n)
          return this.bounds.contains(n);
      }
      return !1;
    }, e.prototype.calculateBounds = function() {
      this.bounds = this.markerClusterer.getExtendedBounds(new google.maps.LatLngBounds(this.center, this.center));
    }, e.prototype.updateIcon = function() {
      var t, n = this.markers.length, r = this.markerClusterer.getMaxZoom(), o = (t = this.map) === null || t === void 0 ? void 0 : t.getZoom();
      if (r !== null && typeof o < "u" && o > r) {
        this.clusterIcon.hide();
        return;
      }
      if (n < this.minClusterSize) {
        this.clusterIcon.hide();
        return;
      }
      this.center && this.clusterIcon.setCenter(this.center), this.clusterIcon.useStyle(this.markerClusterer.getCalculator()(this.markers, this.markerClusterer.getStyles().length)), this.clusterIcon.show();
    }, e.prototype.isMarkerAlreadyAdded = function(t) {
      if (this.markers.includes)
        return this.markers.includes(t);
      for (var n = 0; n < this.markers.length; n++)
        if (t === this.markers[n])
          return !0;
      return !1;
    }, e;
  }()
);
function HIe(e, t) {
  var n = e.length, r = n.toString().length, o = Math.min(r, t);
  return {
    text: n.toString(),
    index: o,
    title: ""
  };
}
var $Ie = 2e3, WIe = 500, VIe = "https://developers.google.com/maps/documentation/javascript/examples/markerclusterer/m", ZIe = "png", qIe = [53, 56, 66, 78, 90], GIe = "cluster", HK = (
  /** @class */
  function() {
    function e(t, n, r) {
      n === void 0 && (n = []), r === void 0 && (r = {}), this.getMinimumClusterSize = this.getMinimumClusterSize.bind(this), this.setMinimumClusterSize = this.setMinimumClusterSize.bind(this), this.getEnableRetinaIcons = this.getEnableRetinaIcons.bind(this), this.setEnableRetinaIcons = this.setEnableRetinaIcons.bind(this), this.addToClosestCluster = this.addToClosestCluster.bind(this), this.getImageExtension = this.getImageExtension.bind(this), this.setImageExtension = this.setImageExtension.bind(this), this.getExtendedBounds = this.getExtendedBounds.bind(this), this.getAverageCenter = this.getAverageCenter.bind(this), this.setAverageCenter = this.setAverageCenter.bind(this), this.getTotalClusters = this.getTotalClusters.bind(this), this.fitMapToMarkers = this.fitMapToMarkers.bind(this), this.getIgnoreHidden = this.getIgnoreHidden.bind(this), this.setIgnoreHidden = this.setIgnoreHidden.bind(this), this.getClusterClass = this.getClusterClass.bind(this), this.setClusterClass = this.setClusterClass.bind(this), this.getTotalMarkers = this.getTotalMarkers.bind(this), this.getZoomOnClick = this.getZoomOnClick.bind(this), this.setZoomOnClick = this.setZoomOnClick.bind(this), this.getBatchSizeIE = this.getBatchSizeIE.bind(this), this.setBatchSizeIE = this.setBatchSizeIE.bind(this), this.createClusters = this.createClusters.bind(this), this.onZoomChanged = this.onZoomChanged.bind(this), this.getImageSizes = this.getImageSizes.bind(this), this.setImageSizes = this.setImageSizes.bind(this), this.getCalculator = this.getCalculator.bind(this), this.setCalculator = this.setCalculator.bind(this), this.removeMarkers = this.removeMarkers.bind(this), this.resetViewport = this.resetViewport.bind(this), this.getImagePath = this.getImagePath.bind(this), this.setImagePath = this.setImagePath.bind(this), this.pushMarkerTo = this.pushMarkerTo.bind(this), this.removeMarker = this.removeMarker.bind(this), this.clearMarkers = this.clearMarkers.bind(this), this.setupStyles = this.setupStyles.bind(this), this.getGridSize = this.getGridSize.bind(this), this.setGridSize = this.setGridSize.bind(this), this.getClusters = this.getClusters.bind(this), this.getMaxZoom = this.getMaxZoom.bind(this), this.setMaxZoom = this.setMaxZoom.bind(this), this.getMarkers = this.getMarkers.bind(this), this.addMarkers = this.addMarkers.bind(this), this.getStyles = this.getStyles.bind(this), this.setStyles = this.setStyles.bind(this), this.addMarker = this.addMarker.bind(this), this.onRemove = this.onRemove.bind(this), this.getTitle = this.getTitle.bind(this), this.setTitle = this.setTitle.bind(this), this.repaint = this.repaint.bind(this), this.onIdle = this.onIdle.bind(this), this.redraw = this.redraw.bind(this), this.onAdd = this.onAdd.bind(this), this.draw = this.draw.bind(this), this.extend = this.extend.bind(this), this.extend(e, google.maps.OverlayView), this.markers = [], this.clusters = [], this.listeners = [], this.activeMap = null, this.ready = !1, this.gridSize = r.gridSize || 60, this.minClusterSize = r.minimumClusterSize || 2, this.maxZoom = r.maxZoom || null, this.styles = r.styles || [], this.title = r.title || "", this.zoomOnClick = !0, r.zoomOnClick !== void 0 && (this.zoomOnClick = r.zoomOnClick), this.averageCenter = !1, r.averageCenter !== void 0 && (this.averageCenter = r.averageCenter), this.ignoreHidden = !1, r.ignoreHidden !== void 0 && (this.ignoreHidden = r.ignoreHidden), this.enableRetinaIcons = !1, r.enableRetinaIcons !== void 0 && (this.enableRetinaIcons = r.enableRetinaIcons), this.imagePath = r.imagePath || VIe, this.imageExtension = r.imageExtension || ZIe, this.imageSizes = r.imageSizes || qIe, this.calculator = r.calculator || HIe, this.batchSize = r.batchSize || $Ie, this.batchSizeIE = r.batchSizeIE || WIe, this.clusterClass = r.clusterClass || GIe, navigator.userAgent.toLowerCase().indexOf("msie") !== -1 && (this.batchSize = this.batchSizeIE), this.timerRefStatic = null, this.setupStyles(), this.addMarkers(n, !0), this.setMap(t);
    }
    return e.prototype.onZoomChanged = function() {
      var t, n;
      this.resetViewport(!1), (((t = this.getMap()) === null || t === void 0 ? void 0 : t.getZoom()) === (this.get("minZoom") || 0) || ((n = this.getMap()) === null || n === void 0 ? void 0 : n.getZoom()) === this.get("maxZoom")) && google.maps.event.trigger(this, "idle");
    }, e.prototype.onIdle = function() {
      this.redraw();
    }, e.prototype.onAdd = function() {
      var t = this.getMap();
      this.activeMap = t, this.ready = !0, this.repaint(), t !== null && (this.listeners = [google.maps.event.addListener(t, "zoom_changed", this.onZoomChanged), google.maps.event.addListener(t, "idle", this.onIdle)]);
    }, e.prototype.onRemove = function() {
      for (var t = 0, n = this.markers; t < n.length; t++) {
        var r = n[t];
        r.getMap() !== this.activeMap && r.setMap(this.activeMap);
      }
      for (var o = 0, i = this.clusters; o < i.length; o++) {
        var a = i[o];
        a.remove();
      }
      this.clusters = [];
      for (var s = 0, l = this.listeners; s < l.length; s++) {
        var u = l[s];
        google.maps.event.removeListener(u);
      }
      this.listeners = [], this.activeMap = null, this.ready = !1;
    }, e.prototype.draw = function() {
    }, e.prototype.getMap = function() {
      return null;
    }, e.prototype.getPanes = function() {
      return null;
    }, e.prototype.getProjection = function() {
      return {
        fromContainerPixelToLatLng: function() {
          return null;
        },
        fromDivPixelToLatLng: function() {
          return null;
        },
        fromLatLngToContainerPixel: function() {
          return null;
        },
        fromLatLngToDivPixel: function() {
          return null;
        },
        getVisibleRegion: function() {
          return null;
        },
        getWorldWidth: function() {
          return 0;
        }
      };
    }, e.prototype.setMap = function() {
    }, e.prototype.addListener = function() {
      return {
        remove: function() {
        }
      };
    }, e.prototype.bindTo = function() {
    }, e.prototype.get = function() {
    }, e.prototype.notify = function() {
    }, e.prototype.set = function() {
    }, e.prototype.setValues = function() {
    }, e.prototype.unbind = function() {
    }, e.prototype.unbindAll = function() {
    }, e.prototype.setupStyles = function() {
      if (!(this.styles.length > 0))
        for (var t = 0; t < this.imageSizes.length; t++)
          this.styles.push({
            url: "".concat(this.imagePath + (t + 1), ".").concat(this.imageExtension),
            height: this.imageSizes[t] || 0,
            width: this.imageSizes[t] || 0
          });
    }, e.prototype.fitMapToMarkers = function() {
      for (var t = this.getMarkers(), n = new google.maps.LatLngBounds(), r = 0, o = t; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && n.extend(a);
      }
      var s = this.getMap();
      s !== null && "fitBounds" in s && s.fitBounds(n);
    }, e.prototype.getGridSize = function() {
      return this.gridSize;
    }, e.prototype.setGridSize = function(t) {
      this.gridSize = t;
    }, e.prototype.getMinimumClusterSize = function() {
      return this.minClusterSize;
    }, e.prototype.setMinimumClusterSize = function(t) {
      this.minClusterSize = t;
    }, e.prototype.getMaxZoom = function() {
      return this.maxZoom;
    }, e.prototype.setMaxZoom = function(t) {
      this.maxZoom = t;
    }, e.prototype.getStyles = function() {
      return this.styles;
    }, e.prototype.setStyles = function(t) {
      this.styles = t;
    }, e.prototype.getTitle = function() {
      return this.title;
    }, e.prototype.setTitle = function(t) {
      this.title = t;
    }, e.prototype.getZoomOnClick = function() {
      return this.zoomOnClick;
    }, e.prototype.setZoomOnClick = function(t) {
      this.zoomOnClick = t;
    }, e.prototype.getAverageCenter = function() {
      return this.averageCenter;
    }, e.prototype.setAverageCenter = function(t) {
      this.averageCenter = t;
    }, e.prototype.getIgnoreHidden = function() {
      return this.ignoreHidden;
    }, e.prototype.setIgnoreHidden = function(t) {
      this.ignoreHidden = t;
    }, e.prototype.getEnableRetinaIcons = function() {
      return this.enableRetinaIcons;
    }, e.prototype.setEnableRetinaIcons = function(t) {
      this.enableRetinaIcons = t;
    }, e.prototype.getImageExtension = function() {
      return this.imageExtension;
    }, e.prototype.setImageExtension = function(t) {
      this.imageExtension = t;
    }, e.prototype.getImagePath = function() {
      return this.imagePath;
    }, e.prototype.setImagePath = function(t) {
      this.imagePath = t;
    }, e.prototype.getImageSizes = function() {
      return this.imageSizes;
    }, e.prototype.setImageSizes = function(t) {
      this.imageSizes = t;
    }, e.prototype.getCalculator = function() {
      return this.calculator;
    }, e.prototype.setCalculator = function(t) {
      this.calculator = t;
    }, e.prototype.getBatchSizeIE = function() {
      return this.batchSizeIE;
    }, e.prototype.setBatchSizeIE = function(t) {
      this.batchSizeIE = t;
    }, e.prototype.getClusterClass = function() {
      return this.clusterClass;
    }, e.prototype.setClusterClass = function(t) {
      this.clusterClass = t;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getTotalMarkers = function() {
      return this.markers.length;
    }, e.prototype.getClusters = function() {
      return this.clusters;
    }, e.prototype.getTotalClusters = function() {
      return this.clusters.length;
    }, e.prototype.addMarker = function(t, n) {
      this.pushMarkerTo(t), n || this.redraw();
    }, e.prototype.addMarkers = function(t, n) {
      for (var r in t)
        if (Object.prototype.hasOwnProperty.call(t, r)) {
          var o = t[r];
          o && this.pushMarkerTo(o);
        }
      n || this.redraw();
    }, e.prototype.pushMarkerTo = function(t) {
      var n = this;
      t.getDraggable() && google.maps.event.addListener(t, "dragend", function() {
        n.ready && (t.isAdded = !1, n.repaint());
      }), t.isAdded = !1, this.markers.push(t);
    }, e.prototype.removeMarker_ = function(t) {
      var n = -1;
      if (this.markers.indexOf)
        n = this.markers.indexOf(t);
      else
        for (var r = 0; r < this.markers.length; r++)
          if (t === this.markers[r]) {
            n = r;
            break;
          }
      return n === -1 ? !1 : (t.setMap(null), this.markers.splice(n, 1), !0);
    }, e.prototype.removeMarker = function(t, n) {
      var r = this.removeMarker_(t);
      return !n && r && this.repaint(), r;
    }, e.prototype.removeMarkers = function(t, n) {
      for (var r = !1, o = 0, i = t; o < i.length; o++) {
        var a = i[o];
        r = r || this.removeMarker_(a);
      }
      return !n && r && this.repaint(), r;
    }, e.prototype.clearMarkers = function() {
      this.resetViewport(!0), this.markers = [];
    }, e.prototype.repaint = function() {
      var t = this.clusters.slice();
      this.clusters = [], this.resetViewport(!1), this.redraw(), setTimeout(function() {
        for (var n = 0, r = t; n < r.length; n++) {
          var o = r[n];
          o.remove();
        }
      }, 0);
    }, e.prototype.getExtendedBounds = function(t) {
      var n = this.getProjection(), r = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getNorthEast().lat(), t.getNorthEast().lng())
      );
      r !== null && (r.x += this.gridSize, r.y -= this.gridSize);
      var o = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getSouthWest().lat(), t.getSouthWest().lng())
      );
      if (o !== null && (o.x -= this.gridSize, o.y += this.gridSize), r !== null) {
        var i = n.fromDivPixelToLatLng(r);
        i !== null && t.extend(i);
      }
      if (o !== null) {
        var a = n.fromDivPixelToLatLng(o);
        a !== null && t.extend(a);
      }
      return t;
    }, e.prototype.redraw = function() {
      this.createClusters(0);
    }, e.prototype.resetViewport = function(t) {
      for (var n = 0, r = this.clusters; n < r.length; n++) {
        var o = r[n];
        o.remove();
      }
      this.clusters = [];
      for (var i = 0, a = this.markers; i < a.length; i++) {
        var s = a[i];
        s.isAdded = !1, t && s.setMap(null);
      }
    }, e.prototype.distanceBetweenPoints = function(t, n) {
      var r = 6371, o = (n.lat() - t.lat()) * Math.PI / 180, i = (n.lng() - t.lng()) * Math.PI / 180, a = Math.sin(o / 2) * Math.sin(o / 2) + Math.cos(t.lat() * Math.PI / 180) * Math.cos(n.lat() * Math.PI / 180) * Math.sin(i / 2) * Math.sin(i / 2);
      return r * (2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)));
    }, e.prototype.isMarkerInBounds = function(t, n) {
      var r = t.getPosition();
      return r ? n.contains(r) : !1;
    }, e.prototype.addToClosestCluster = function(t) {
      for (var n, r = 4e4, o = null, i = 0, a = this.clusters; i < a.length; i++) {
        var s = a[i];
        n = s;
        var l = n.getCenter(), u = t.getPosition();
        if (l && u) {
          var c = this.distanceBetweenPoints(l, u);
          c < r && (r = c, o = n);
        }
      }
      o && o.isMarkerInClusterBounds(t) ? o.addMarker(t) : (n = new UIe(this), n.addMarker(t), this.clusters.push(n));
    }, e.prototype.createClusters = function(t) {
      var n = this;
      if (this.ready) {
        t === 0 && (google.maps.event.trigger(this, "clusteringbegin", this), this.timerRefStatic !== null && (window.clearTimeout(this.timerRefStatic), delete this.timerRefStatic));
        for (var r = this.getMap(), o = r !== null && ("getBounds" in r) ? r.getBounds() : null, i = (r == null ? void 0 : r.getZoom()) || 0, a = i > 3 ? new google.maps.LatLngBounds(o == null ? void 0 : o.getSouthWest(), o == null ? void 0 : o.getNorthEast()) : new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625)), s = this.getExtendedBounds(a), l = Math.min(t + this.batchSize, this.markers.length), u = t; u < l; u++) {
          var c = this.markers[u];
          c && !c.isAdded && this.isMarkerInBounds(c, s) && (!this.ignoreHidden || this.ignoreHidden && c.getVisible()) && this.addToClosestCluster(c);
        }
        if (l < this.markers.length)
          this.timerRefStatic = window.setTimeout(function() {
            n.createClusters(l);
          }, 0);
        else {
          this.timerRefStatic = null, google.maps.event.trigger(this, "clusteringend", this);
          for (var p = 0, d = this.clusters; p < d.length; p++) {
            var g = d[p];
            g.updateIcon();
          }
        }
      }
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype) {
          var i = o;
          this.prototype[i] = r.prototype[i];
        }
        return this;
      }).apply(t, [n]);
    }, e;
  }()
);
function WH(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function KIe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? WH(Object(n), !0).forEach(function(r) {
      ke(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : WH(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var os = {
  onClick: "click",
  onClusteringBegin: "clusteringbegin",
  onClusteringEnd: "clusteringend",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover"
}, Ln = {
  averageCenter(e, t) {
    e.setAverageCenter(t);
  },
  batchSizeIE(e, t) {
    e.setBatchSizeIE(t);
  },
  calculator(e, t) {
    e.setCalculator(t);
  },
  clusterClass(e, t) {
    e.setClusterClass(t);
  },
  enableRetinaIcons(e, t) {
    e.setEnableRetinaIcons(t);
  },
  gridSize(e, t) {
    e.setGridSize(t);
  },
  ignoreHidden(e, t) {
    e.setIgnoreHidden(t);
  },
  imageExtension(e, t) {
    e.setImageExtension(t);
  },
  imagePath(e, t) {
    e.setImagePath(t);
  },
  imageSizes(e, t) {
    e.setImageSizes(t);
  },
  maxZoom(e, t) {
    e.setMaxZoom(t);
  },
  minimumClusterSize(e, t) {
    e.setMinimumClusterSize(t);
  },
  styles(e, t) {
    e.setStyles(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  zoomOnClick(e, t) {
    e.setZoomOnClick(t);
  }
}, YIe = {};
function XIe(e) {
  var {
    children: t,
    options: n,
    averageCenter: r,
    batchSizeIE: o,
    calculator: i,
    clusterClass: a,
    enableRetinaIcons: s,
    gridSize: l,
    ignoreHidden: u,
    imageExtension: c,
    imagePath: p,
    imageSizes: d,
    maxZoom: g,
    minimumClusterSize: f,
    styles: m,
    title: v,
    zoomOnClick: E,
    onClick: w,
    onClusteringBegin: M,
    onClusteringEnd: O,
    onMouseOver: y,
    onMouseOut: C,
    onLoad: _,
    onUnmount: F
  } = e, [L, N] = k(null), R = ge(Rt), [W, V] = k(null), [z, Z] = k(null), [K, X] = k(null), [te, J] = k(null), [P, D] = k(null);
  return h(() => {
    L && C && (te !== null && google.maps.event.removeListener(te), J(google.maps.event.addListener(L, os.onMouseOut, C)));
  }, [C]), h(() => {
    L && y && (P !== null && google.maps.event.removeListener(P), D(google.maps.event.addListener(L, os.onMouseOver, y)));
  }, [y]), h(() => {
    L && w && (W !== null && google.maps.event.removeListener(W), V(google.maps.event.addListener(L, os.onClick, w)));
  }, [w]), h(() => {
    L && M && (z !== null && google.maps.event.removeListener(z), Z(google.maps.event.addListener(L, os.onClusteringBegin, M)));
  }, [M]), h(() => {
    L && O && (K !== null && google.maps.event.removeListener(K), Z(google.maps.event.addListener(L, os.onClusteringEnd, O)));
  }, [O]), h(() => {
    typeof r < "u" && L !== null && Ln.averageCenter(L, r);
  }, [L, r]), h(() => {
    typeof o < "u" && L !== null && Ln.batchSizeIE(L, o);
  }, [L, o]), h(() => {
    typeof i < "u" && L !== null && Ln.calculator(L, i);
  }, [L, i]), h(() => {
    typeof a < "u" && L !== null && Ln.clusterClass(L, a);
  }, [L, a]), h(() => {
    typeof s < "u" && L !== null && Ln.enableRetinaIcons(L, s);
  }, [L, s]), h(() => {
    typeof l < "u" && L !== null && Ln.gridSize(L, l);
  }, [L, l]), h(() => {
    typeof u < "u" && L !== null && Ln.ignoreHidden(L, u);
  }, [L, u]), h(() => {
    typeof c < "u" && L !== null && Ln.imageExtension(L, c);
  }, [L, c]), h(() => {
    typeof p < "u" && L !== null && Ln.imagePath(L, p);
  }, [L, p]), h(() => {
    typeof d < "u" && L !== null && Ln.imageSizes(L, d);
  }, [L, d]), h(() => {
    typeof g < "u" && L !== null && Ln.maxZoom(L, g);
  }, [L, g]), h(() => {
    typeof f < "u" && L !== null && Ln.minimumClusterSize(L, f);
  }, [L, f]), h(() => {
    typeof m < "u" && L !== null && Ln.styles(L, m);
  }, [L, m]), h(() => {
    typeof v < "u" && L !== null && Ln.title(L, v);
  }, [L, v]), h(() => {
    typeof E < "u" && L !== null && Ln.zoomOnClick(L, E);
  }, [L, E]), h(() => {
    if (R) {
      var H = KIe({}, n || YIe), S = new HK(R, [], H);
      return r && Ln.averageCenter(S, r), o && Ln.batchSizeIE(S, o), i && Ln.calculator(S, i), a && Ln.clusterClass(S, a), s && Ln.enableRetinaIcons(S, s), l && Ln.gridSize(S, l), u && Ln.ignoreHidden(S, u), c && Ln.imageExtension(S, c), p && Ln.imagePath(S, p), d && Ln.imageSizes(S, d), g && Ln.maxZoom(S, g), f && Ln.minimumClusterSize(S, f), m && Ln.styles(S, m), v && Ln.title(S, v), E && Ln.zoomOnClick(S, E), C && J(google.maps.event.addListener(S, os.onMouseOut, C)), y && D(google.maps.event.addListener(S, os.onMouseOver, y)), w && V(google.maps.event.addListener(S, os.onClick, w)), M && Z(google.maps.event.addListener(S, os.onClusteringBegin, M)), O && X(google.maps.event.addListener(S, os.onClusteringEnd, O)), N(S), _ && _(S), () => {
        te !== null && google.maps.event.removeListener(te), P !== null && google.maps.event.removeListener(P), W !== null && google.maps.event.removeListener(W), z !== null && google.maps.event.removeListener(z), K !== null && google.maps.event.removeListener(K), F && F(S);
      };
    }
  }, []), L !== null && t(L) || null;
}
ve(XIe);
class JIe extends pe {
  constructor() {
    super(...arguments), ke(this, "registeredEvents", []), ke(this, "state", {
      markerClusterer: null
    }), ke(this, "setClustererCallback", () => {
      this.state.markerClusterer !== null && this.props.onLoad && this.props.onLoad(this.state.markerClusterer);
    });
  }
  componentDidMount() {
    if (this.context) {
      var t = new HK(this.context, [], this.props.options);
      this.registeredEvents = pn({
        updaterMap: Ln,
        eventMap: os,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        markerClusterer: t
      }), this.setClustererCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.markerClusterer && (vn(this.registeredEvents), this.registeredEvents = pn({
      updaterMap: Ln,
      eventMap: os,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.markerClusterer
    }));
  }
  componentWillUnmount() {
    this.state.markerClusterer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.markerClusterer), vn(this.registeredEvents), this.state.markerClusterer.setMap(null));
  }
  render() {
    return this.state.markerClusterer !== null ? this.props.children(this.state.markerClusterer) : null;
  }
}
ke(JIe, "contextType", Rt);
function VH(e) {
  e.cancelBubble = !0, e.stopPropagation && e.stopPropagation();
}
var $K = (
  /** @class */
  function() {
    function e(t) {
      t === void 0 && (t = {}), this.getCloseClickHandler = this.getCloseClickHandler.bind(this), this.closeClickHandler = this.closeClickHandler.bind(this), this.createInfoBoxDiv = this.createInfoBoxDiv.bind(this), this.addClickHandler = this.addClickHandler.bind(this), this.getCloseBoxImg = this.getCloseBoxImg.bind(this), this.getBoxWidths = this.getBoxWidths.bind(this), this.setBoxStyle = this.setBoxStyle.bind(this), this.setPosition = this.setPosition.bind(this), this.getPosition = this.getPosition.bind(this), this.setOptions = this.setOptions.bind(this), this.setContent = this.setContent.bind(this), this.setVisible = this.setVisible.bind(this), this.getContent = this.getContent.bind(this), this.getVisible = this.getVisible.bind(this), this.setZIndex = this.setZIndex.bind(this), this.getZIndex = this.getZIndex.bind(this), this.onRemove = this.onRemove.bind(this), this.panBox = this.panBox.bind(this), this.extend = this.extend.bind(this), this.close = this.close.bind(this), this.draw = this.draw.bind(this), this.show = this.show.bind(this), this.hide = this.hide.bind(this), this.open = this.open.bind(this), this.extend(e, google.maps.OverlayView), this.content = t.content || "", this.disableAutoPan = t.disableAutoPan || !1, this.maxWidth = t.maxWidth || 0, this.pixelOffset = t.pixelOffset || new google.maps.Size(0, 0), this.position = t.position || new google.maps.LatLng(0, 0), this.zIndex = t.zIndex || null, this.boxClass = t.boxClass || "infoBox", this.boxStyle = t.boxStyle || {}, this.closeBoxMargin = t.closeBoxMargin || "2px", this.closeBoxURL = t.closeBoxURL || "http://www.google.com/intl/en_us/mapfiles/close.gif", t.closeBoxURL === "" && (this.closeBoxURL = ""), this.infoBoxClearance = t.infoBoxClearance || new google.maps.Size(1, 1), typeof t.visible > "u" && (typeof t.isHidden > "u" ? t.visible = !0 : t.visible = !t.isHidden), this.isHidden = !t.visible, this.alignBottom = t.alignBottom || !1, this.pane = t.pane || "floatPane", this.enableEventPropagation = t.enableEventPropagation || !1, this.div = null, this.closeListener = null, this.moveListener = null, this.mapListener = null, this.contextListener = null, this.eventListeners = null, this.fixedWidthSet = null;
    }
    return e.prototype.createInfoBoxDiv = function() {
      var t = this, n = function(u) {
        u.returnValue = !1, u.preventDefault && u.preventDefault(), t.enableEventPropagation || VH(u);
      };
      if (!this.div) {
        this.div = document.createElement("div"), this.setBoxStyle(), typeof this.content == "string" ? this.div.innerHTML = this.getCloseBoxImg() + this.content : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(this.content));
        var r = this.getPanes();
        if (r !== null && r[this.pane].appendChild(this.div), this.addClickHandler(), this.div.style.width)
          this.fixedWidthSet = !0;
        else if (this.maxWidth !== 0 && this.div.offsetWidth > this.maxWidth)
          this.div.style.width = this.maxWidth + "px", this.fixedWidthSet = !0;
        else {
          var o = this.getBoxWidths();
          this.div.style.width = this.div.offsetWidth - o.left - o.right + "px", this.fixedWidthSet = !1;
        }
        if (this.panBox(this.disableAutoPan), !this.enableEventPropagation) {
          this.eventListeners = [];
          for (var i = ["mousedown", "mouseover", "mouseout", "mouseup", "click", "dblclick", "touchstart", "touchend", "touchmove"], a = 0, s = i; a < s.length; a++) {
            var l = s[a];
            this.eventListeners.push(google.maps.event.addListener(this.div, l, VH));
          }
          this.eventListeners.push(google.maps.event.addListener(this.div, "mouseover", function() {
            t.div && (t.div.style.cursor = "default");
          }));
        }
        this.contextListener = google.maps.event.addListener(this.div, "contextmenu", n), google.maps.event.trigger(this, "domready");
      }
    }, e.prototype.getCloseBoxImg = function() {
      var t = "";
      return this.closeBoxURL !== "" && (t = '<img alt=""', t += ' aria-hidden="true"', t += " src='" + this.closeBoxURL + "'", t += " align=right", t += " style='", t += " position: relative;", t += " cursor: pointer;", t += " margin: " + this.closeBoxMargin + ";", t += "'>"), t;
    }, e.prototype.addClickHandler = function() {
      this.closeListener = this.div && this.div.firstChild && this.closeBoxURL !== "" ? google.maps.event.addListener(this.div.firstChild, "click", this.getCloseClickHandler()) : null;
    }, e.prototype.closeClickHandler = function(t) {
      t.cancelBubble = !0, t.stopPropagation && t.stopPropagation(), google.maps.event.trigger(this, "closeclick"), this.close();
    }, e.prototype.getCloseClickHandler = function() {
      return this.closeClickHandler;
    }, e.prototype.panBox = function(t) {
      if (this.div && !t) {
        var n = this.getMap();
        if (n instanceof google.maps.Map) {
          var r = 0, o = 0, i = n.getBounds();
          i && !i.contains(this.position) && n.setCenter(this.position);
          var a = n.getDiv(), s = a.offsetWidth, l = a.offsetHeight, u = this.pixelOffset.width, c = this.pixelOffset.height, p = this.div.offsetWidth, d = this.div.offsetHeight, g = this.infoBoxClearance.width, f = this.infoBoxClearance.height, m = this.getProjection(), v = m.fromLatLngToContainerPixel(this.position);
          v !== null && (v.x < -u + g ? r = v.x + u - g : v.x + p + u + g > s && (r = v.x + p + u + g - s), this.alignBottom ? v.y < -c + f + d ? o = v.y + c - f - d : v.y + c + f > l && (o = v.y + c + f - l) : v.y < -c + f ? o = v.y + c - f : v.y + d + c + f > l && (o = v.y + d + c + f - l)), r === 0 && o === 0 || n.panBy(r, o);
        }
      }
    }, e.prototype.setBoxStyle = function() {
      if (this.div) {
        this.div.className = this.boxClass, this.div.style.cssText = "";
        var t = this.boxStyle;
        for (var n in t)
          Object.prototype.hasOwnProperty.call(t, n) && (this.div.style[n] = t[n]);
        if (this.div.style.webkitTransform = "translateZ(0)", typeof this.div.style.opacity < "u" && this.div.style.opacity !== "") {
          var r = parseFloat(this.div.style.opacity || "");
          this.div.style.msFilter = '"progid:DXImageTransform.Microsoft.Alpha(Opacity=' + r * 100 + ')"', this.div.style.filter = "alpha(opacity=" + r * 100 + ")";
        }
        this.div.style.position = "absolute", this.div.style.visibility = "hidden", this.zIndex !== null && (this.div.style.zIndex = this.zIndex + ""), this.div.style.overflow || (this.div.style.overflow = "auto");
      }
    }, e.prototype.getBoxWidths = function() {
      var t = {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0
      };
      if (!this.div)
        return t;
      if (document.defaultView) {
        var n = this.div.ownerDocument, r = n && n.defaultView ? n.defaultView.getComputedStyle(this.div, "") : null;
        r && (t.top = parseInt(r.borderTopWidth || "", 10) || 0, t.bottom = parseInt(r.borderBottomWidth || "", 10) || 0, t.left = parseInt(r.borderLeftWidth || "", 10) || 0, t.right = parseInt(r.borderRightWidth || "", 10) || 0);
      } else if (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        document.documentElement.currentStyle
      ) {
        var o = this.div.currentStyle;
        o && (t.top = parseInt(o.borderTopWidth || "", 10) || 0, t.bottom = parseInt(o.borderBottomWidth || "", 10) || 0, t.left = parseInt(o.borderLeftWidth || "", 10) || 0, t.right = parseInt(o.borderRightWidth || "", 10) || 0);
      }
      return t;
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.div.parentNode.removeChild(this.div), this.div = null);
    }, e.prototype.draw = function() {
      if (this.createInfoBoxDiv(), this.div) {
        var t = this.getProjection(), n = t.fromLatLngToDivPixel(this.position);
        n !== null && (this.div.style.left = n.x + this.pixelOffset.width + "px", this.alignBottom ? this.div.style.bottom = -(n.y + this.pixelOffset.height) + "px" : this.div.style.top = n.y + this.pixelOffset.height + "px"), this.isHidden ? this.div.style.visibility = "hidden" : this.div.style.visibility = "visible";
      }
    }, e.prototype.setOptions = function(t) {
      t === void 0 && (t = {}), typeof t.boxClass < "u" && (this.boxClass = t.boxClass, this.setBoxStyle()), typeof t.boxStyle < "u" && (this.boxStyle = t.boxStyle, this.setBoxStyle()), typeof t.content < "u" && this.setContent(t.content), typeof t.disableAutoPan < "u" && (this.disableAutoPan = t.disableAutoPan), typeof t.maxWidth < "u" && (this.maxWidth = t.maxWidth), typeof t.pixelOffset < "u" && (this.pixelOffset = t.pixelOffset), typeof t.alignBottom < "u" && (this.alignBottom = t.alignBottom), typeof t.position < "u" && this.setPosition(t.position), typeof t.zIndex < "u" && this.setZIndex(t.zIndex), typeof t.closeBoxMargin < "u" && (this.closeBoxMargin = t.closeBoxMargin), typeof t.closeBoxURL < "u" && (this.closeBoxURL = t.closeBoxURL), typeof t.infoBoxClearance < "u" && (this.infoBoxClearance = t.infoBoxClearance), typeof t.isHidden < "u" && (this.isHidden = t.isHidden), typeof t.visible < "u" && (this.isHidden = !t.visible), typeof t.enableEventPropagation < "u" && (this.enableEventPropagation = t.enableEventPropagation), this.div && this.draw();
    }, e.prototype.setContent = function(t) {
      this.content = t, this.div && (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.fixedWidthSet || (this.div.style.width = ""), typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t)), this.fixedWidthSet || (this.div.style.width = this.div.offsetWidth + "px", typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t))), this.addClickHandler()), google.maps.event.trigger(this, "content_changed");
    }, e.prototype.setPosition = function(t) {
      this.position = t, this.div && this.draw(), google.maps.event.trigger(this, "position_changed");
    }, e.prototype.setVisible = function(t) {
      this.isHidden = !t, this.div && (this.div.style.visibility = this.isHidden ? "hidden" : "visible");
    }, e.prototype.setZIndex = function(t) {
      this.zIndex = t, this.div && (this.div.style.zIndex = t + ""), google.maps.event.trigger(this, "zindex_changed");
    }, e.prototype.getContent = function() {
      return this.content;
    }, e.prototype.getPosition = function() {
      return this.position;
    }, e.prototype.getZIndex = function() {
      return this.zIndex;
    }, e.prototype.getVisible = function() {
      var t = this.getMap();
      return typeof t > "u" || t === null ? !1 : !this.isHidden;
    }, e.prototype.show = function() {
      this.isHidden = !1, this.div && (this.div.style.visibility = "visible");
    }, e.prototype.hide = function() {
      this.isHidden = !0, this.div && (this.div.style.visibility = "hidden");
    }, e.prototype.open = function(t, n) {
      var r = this;
      n && (this.position = n.getPosition(), this.moveListener = google.maps.event.addListener(n, "position_changed", function() {
        var o = n.getPosition();
        r.setPosition(o);
      }), this.mapListener = google.maps.event.addListener(n, "map_changed", function() {
        r.setMap(n.map);
      })), this.setMap(t), this.div && this.panBox();
    }, e.prototype.close = function() {
      if (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.eventListeners) {
        for (var t = 0, n = this.eventListeners; t < n.length; t++) {
          var r = n[t];
          google.maps.event.removeListener(r);
        }
        this.eventListeners = null;
      }
      this.moveListener && (google.maps.event.removeListener(this.moveListener), this.moveListener = null), this.mapListener && (google.maps.event.removeListener(this.mapListener), this.mapListener = null), this.contextListener && (google.maps.event.removeListener(this.contextListener), this.contextListener = null), this.setMap(null);
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype)
          Object.prototype.hasOwnProperty.call(this, o) || (this.prototype[o] = r.prototype[o]);
        return this;
      }).apply(t, [n]);
    }, e;
  }()
), QIe = ["position"], eRe = ["position"];
function ZH(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function vy(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? ZH(Object(n), !0).forEach(function(r) {
      ke(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : ZH(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var qH = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, GH = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    t instanceof google.maps.LatLng ? e.setPosition(t) : e.setPosition(new google.maps.LatLng(t.lat, t.lng));
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, tRe = {};
function nRe(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, g = ge(Rt), [f, m] = k(null), [v, E] = k(null), [w, M] = k(null), [O, y] = k(null), [C, _] = k(null), [F, L] = k(null), N = ut(null);
  return h(() => {
    g && f !== null && (f.close(), n ? f.open(g, n) : f.getPosition() && f.open(g));
  }, [g, f, n]), h(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), h(() => {
    if (o && f !== null) {
      var R = o instanceof google.maps.LatLng ? o : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        new google.maps.LatLng(o.lat, o.lng)
      );
      f.setPosition(R);
    }
  }, [o]), h(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), h(() => {
    f && a && (v !== null && google.maps.event.removeListener(v), E(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), h(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), M(google.maps.event.addListener(f, "domready", s)));
  }, [s]), h(() => {
    f && l && (O !== null && google.maps.event.removeListener(O), y(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), h(() => {
    f && u && (C !== null && google.maps.event.removeListener(C), _(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), h(() => {
    f && c && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), h(() => {
    if (g) {
      var R = r || tRe, {
        position: W
      } = R, V = Z_(R, QIe), z;
      W && !(W instanceof google.maps.LatLng) && (z = new google.maps.LatLng(W.lat, W.lng));
      var Z = new $K(vy(vy({}, V), z ? {
        position: z
      } : {}));
      N.current = document.createElement("div"), m(Z), a && E(google.maps.event.addListener(Z, "closeclick", a)), s && M(google.maps.event.addListener(Z, "domready", s)), l && y(google.maps.event.addListener(Z, "content_changed", l)), u && _(google.maps.event.addListener(Z, "position_changed", u)), c && L(google.maps.event.addListener(Z, "zindex_changed", c)), Z.setContent(N.current), n ? Z.open(g, n) : Z.getPosition() ? Z.open(g) : xo(!1, "You must provide either an anchor or a position prop for <InfoBox>."), p && p(Z);
    }
    return () => {
      f !== null && (v && google.maps.event.removeListener(v), O && google.maps.event.removeListener(O), w && google.maps.event.removeListener(w), C && google.maps.event.removeListener(C), F && google.maps.event.removeListener(F), d && d(f), f.close());
    };
  }, []), N.current ? or(lt.only(t), N.current) : null;
}
ve(nRe);
class rRe extends pe {
  constructor() {
    super(...arguments), ke(this, "registeredEvents", []), ke(this, "containerElement", null), ke(this, "state", {
      infoBox: null
    }), ke(this, "open", (t, n) => {
      n ? this.context !== null && t.open(this.context, n) : t.getPosition() ? this.context !== null && t.open(this.context) : xo(!1, "You must provide either an anchor or a position prop for <InfoBox>.");
    }), ke(this, "setInfoBoxCallback", () => {
      this.state.infoBox !== null && this.containerElement !== null && (this.state.infoBox.setContent(this.containerElement), this.open(this.state.infoBox, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoBox));
    });
  }
  componentDidMount() {
    var t = this.props.options || {}, {
      position: n
    } = t, r = Z_(t, eRe), o;
    n && !(n instanceof google.maps.LatLng) && (o = new google.maps.LatLng(n.lat, n.lng));
    var i = new $K(vy(vy({}, r), o ? {
      position: o
    } : {}));
    this.containerElement = document.createElement("div"), this.registeredEvents = pn({
      updaterMap: GH,
      eventMap: qH,
      prevProps: {},
      nextProps: this.props,
      instance: i
    }), this.setState({
      infoBox: i
    }, this.setInfoBoxCallback);
  }
  componentDidUpdate(t) {
    var {
      infoBox: n
    } = this.state;
    n !== null && (vn(this.registeredEvents), this.registeredEvents = pn({
      updaterMap: GH,
      eventMap: qH,
      prevProps: t,
      nextProps: this.props,
      instance: n
    }));
  }
  componentWillUnmount() {
    var {
      onUnmount: t
    } = this.props, {
      infoBox: n
    } = this.state;
    n !== null && (t && t(n), vn(this.registeredEvents), n.close());
  }
  render() {
    return this.containerElement ? or(lt.only(this.props.children), this.containerElement) : null;
  }
}
ke(rRe, "contextType", Rt);
var KH, YH;
function oRe() {
  return YH || (YH = 1, KH = function e(t, n) {
    if (t === n) return !0;
    if (t && n && typeof t == "object" && typeof n == "object") {
      if (t.constructor !== n.constructor) return !1;
      var r, o, i;
      if (Array.isArray(t)) {
        if (r = t.length, r != n.length) return !1;
        for (o = r; o-- !== 0; ) if (!e(t[o], n[o])) return !1;
        return !0;
      }
      if (t.constructor === RegExp) return t.source === n.source && t.flags === n.flags;
      if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === n.valueOf();
      if (t.toString !== Object.prototype.toString) return t.toString() === n.toString();
      if (i = Object.keys(t), r = i.length, r !== Object.keys(n).length) return !1;
      for (o = r; o-- !== 0; ) if (!Object.prototype.hasOwnProperty.call(n, i[o])) return !1;
      for (o = r; o-- !== 0; ) {
        var a = i[o];
        if (!e(t[a], n[a])) return !1;
      }
      return !0;
    }
    return t !== t && n !== n;
  }), KH;
}
var iRe = oRe(), XH = /* @__PURE__ */ RK(iRe), JH = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array], Xx = 1, mp = 8;
class q_ {
  /**
   * Creates an index from raw `ArrayBuffer` data.
   * @param {ArrayBuffer} data
   */
  static from(t) {
    if (!(t instanceof ArrayBuffer))
      throw new Error("Data must be an instance of ArrayBuffer.");
    var [n, r] = new Uint8Array(t, 0, 2);
    if (n !== 219)
      throw new Error("Data does not appear to be in a KDBush format.");
    var o = r >> 4;
    if (o !== Xx)
      throw new Error("Got v".concat(o, " data when expected v").concat(Xx, "."));
    var i = JH[r & 15];
    if (!i)
      throw new Error("Unrecognized array type.");
    var [a] = new Uint16Array(t, 2, 1), [s] = new Uint32Array(t, 4, 1);
    return new q_(s, a, i, t);
  }
  /**
   * Creates an index that will hold a given number of items.
   * @param {number} numItems
   * @param {number} [nodeSize=64] Size of the KD-tree node (64 by default).
   * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).
   * @param {ArrayBuffer} [data] (For internal use only)
   */
  constructor(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 64, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Float64Array, o = arguments.length > 3 ? arguments[3] : void 0;
    if (isNaN(t) || t < 0) throw new Error("Unpexpected numItems value: ".concat(t, "."));
    this.numItems = +t, this.nodeSize = Math.min(Math.max(+n, 2), 65535), this.ArrayType = r, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
    var i = JH.indexOf(this.ArrayType), a = t * 2 * this.ArrayType.BYTES_PER_ELEMENT, s = t * this.IndexArrayType.BYTES_PER_ELEMENT, l = (8 - s % 8) % 8;
    if (i < 0)
      throw new Error("Unexpected typed array class: ".concat(r, "."));
    o && o instanceof ArrayBuffer ? (this.data = o, this.ids = new this.IndexArrayType(this.data, mp, t), this.coords = new this.ArrayType(this.data, mp + s + l, t * 2), this._pos = t * 2, this._finished = !0) : (this.data = new ArrayBuffer(mp + a + s + l), this.ids = new this.IndexArrayType(this.data, mp, t), this.coords = new this.ArrayType(this.data, mp + s + l, t * 2), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, (Xx << 4) + i]), new Uint16Array(this.data, 2, 1)[0] = n, new Uint32Array(this.data, 4, 1)[0] = t);
  }
  /**
   * Add a point to the index.
   * @param {number} x
   * @param {number} y
   * @returns {number} An incremental index associated with the added item (starting from `0`).
   */
  add(t, n) {
    var r = this._pos >> 1;
    return this.ids[r] = r, this.coords[this._pos++] = t, this.coords[this._pos++] = n, r;
  }
  /**
   * Perform indexing of the added points.
   */
  finish() {
    var t = this._pos >> 1;
    if (t !== this.numItems)
      throw new Error("Added ".concat(t, " items when expected ").concat(this.numItems, "."));
    return Zk(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
  }
  /**
   * Search the index for items within a given bounding box.
   * @param {number} minX
   * @param {number} minY
   * @param {number} maxX
   * @param {number} maxY
   * @returns {number[]} An array of indices correponding to the found items.
   */
  range(t, n, r, o) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: i,
      coords: a,
      nodeSize: s
    } = this, l = [0, i.length - 1, 0], u = []; l.length; ) {
      var c = l.pop() || 0, p = l.pop() || 0, d = l.pop() || 0;
      if (p - d <= s) {
        for (var g = d; g <= p; g++) {
          var f = a[2 * g], m = a[2 * g + 1];
          f >= t && f <= r && m >= n && m <= o && u.push(i[g]);
        }
        continue;
      }
      var v = d + p >> 1, E = a[2 * v], w = a[2 * v + 1];
      E >= t && E <= r && w >= n && w <= o && u.push(i[v]), (c === 0 ? t <= E : n <= w) && (l.push(d), l.push(v - 1), l.push(1 - c)), (c === 0 ? r >= E : o >= w) && (l.push(v + 1), l.push(p), l.push(1 - c));
    }
    return u;
  }
  /**
   * Search the index for items within a given radius.
   * @param {number} qx
   * @param {number} qy
   * @param {number} r Query radius.
   * @returns {number[]} An array of indices correponding to the found items.
   */
  within(t, n, r) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: o,
      coords: i,
      nodeSize: a
    } = this, s = [0, o.length - 1, 0], l = [], u = r * r; s.length; ) {
      var c = s.pop() || 0, p = s.pop() || 0, d = s.pop() || 0;
      if (p - d <= a) {
        for (var g = d; g <= p; g++)
          QH(i[2 * g], i[2 * g + 1], t, n) <= u && l.push(o[g]);
        continue;
      }
      var f = d + p >> 1, m = i[2 * f], v = i[2 * f + 1];
      QH(m, v, t, n) <= u && l.push(o[f]), (c === 0 ? t - r <= m : n - r <= v) && (s.push(d), s.push(f - 1), s.push(1 - c)), (c === 0 ? t + r >= m : n + r >= v) && (s.push(f + 1), s.push(p), s.push(1 - c));
    }
    return l;
  }
}
function Zk(e, t, n, r, o, i) {
  if (!(o - r <= n)) {
    var a = r + o >> 1;
    WK(e, t, a, r, o, i), Zk(e, t, n, r, a - 1, 1 - i), Zk(e, t, n, a + 1, o, 1 - i);
  }
}
function WK(e, t, n, r, o, i) {
  for (; o > r; ) {
    if (o - r > 600) {
      var a = o - r + 1, s = n - r + 1, l = Math.log(a), u = 0.5 * Math.exp(2 * l / 3), c = 0.5 * Math.sqrt(l * u * (a - u) / a) * (s - a / 2 < 0 ? -1 : 1), p = Math.max(r, Math.floor(n - s * u / a + c)), d = Math.min(o, Math.floor(n + (a - s) * u / a + c));
      WK(e, t, n, p, d, i);
    }
    var g = t[2 * n + i], f = r, m = o;
    for (vp(e, t, r, n), t[2 * o + i] > g && vp(e, t, r, o); f < m; ) {
      for (vp(e, t, f, m), f++, m--; t[2 * f + i] < g; ) f++;
      for (; t[2 * m + i] > g; ) m--;
    }
    t[2 * r + i] === g ? vp(e, t, r, m) : (m++, vp(e, t, m, o)), m <= n && (r = m + 1), n <= m && (o = m - 1);
  }
}
function vp(e, t, n, r) {
  Jx(e, n, r), Jx(t, 2 * n, 2 * r), Jx(t, 2 * n + 1, 2 * r + 1);
}
function Jx(e, t, n) {
  var r = e[t];
  e[t] = e[n], e[n] = r;
}
function QH(e, t, n, r) {
  var o = e - n, i = t - r;
  return o * o + i * i;
}
var sRe = {
  minZoom: 0,
  // min zoom to generate clusters on
  maxZoom: 16,
  // max zoom level to cluster the points on
  minPoints: 2,
  // minimum points to form a cluster
  radius: 40,
  // cluster radius in pixels
  extent: 512,
  // tile extent (radius is calculated relative to it)
  nodeSize: 64,
  // size of the KD-tree leaf node, affects performance
  log: !1,
  // whether to log timing info
  // whether to generate numeric ids for input features (in vector tiles)
  generateId: !1,
  // a reduce function for calculating custom cluster properties
  reduce: null,
  // (accumulated, props) => { accumulated.sum += props.sum; }
  // properties to use for individual points when running the reducer
  map: (e) => e
  // props => ({sum: props.my_value})
}, e$ = Math.fround || /* @__PURE__ */ ((e) => (t) => (e[0] = +t, e[0]))(new Float32Array(1)), $l = 2, Ga = 3, Qx = 4, Ua = 5, VK = 6;
class aRe {
  constructor(t) {
    this.options = Object.assign(Object.create(sRe), t), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
  }
  load(t) {
    var {
      log: n,
      minZoom: r,
      maxZoom: o
    } = this.options;
    n && console.time("total time");
    var i = "prepare ".concat(t.length, " points");
    n && console.time(i), this.points = t;
    for (var a = [], s = 0; s < t.length; s++) {
      var l = t[s];
      if (l.geometry) {
        var [u, c] = l.geometry.coordinates, p = e$(Kg(u)), d = e$(Yg(c));
        a.push(
          p,
          d,
          // projected point coordinates
          1 / 0,
          // the last zoom the point was processed at
          s,
          // index of the source feature in the original input array
          -1,
          // parent cluster id
          1
          // number of points in a cluster
        ), this.options.reduce && a.push(0);
      }
    }
    var g = this.trees[o + 1] = this._createTree(a);
    n && console.timeEnd(i);
    for (var f = o; f >= r; f--) {
      var m = +Date.now();
      g = this.trees[f] = this._createTree(this._cluster(g, f)), n && console.log("z%d: %d clusters in %dms", f, g.numItems, +Date.now() - m);
    }
    return n && console.timeEnd("total time"), this;
  }
  getClusters(t, n) {
    var r = ((t[0] + 180) % 360 + 360) % 360 - 180, o = Math.max(-90, Math.min(90, t[1])), i = t[2] === 180 ? 180 : ((t[2] + 180) % 360 + 360) % 360 - 180, a = Math.max(-90, Math.min(90, t[3]));
    if (t[2] - t[0] >= 360)
      r = -180, i = 180;
    else if (r > i) {
      var s = this.getClusters([r, o, 180, a], n), l = this.getClusters([-180, o, i, a], n);
      return s.concat(l);
    }
    var u = this.trees[this._limitZoom(n)], c = u.range(Kg(r), Yg(a), Kg(i), Yg(o)), p = u.data, d = [];
    for (var g of c) {
      var f = this.stride * g;
      d.push(p[f + Ua] > 1 ? t$(p, f, this.clusterProps) : this.points[p[f + Ga]]);
    }
    return d;
  }
  getChildren(t) {
    var n = this._getOriginId(t), r = this._getOriginZoom(t), o = "No cluster with the specified id.", i = this.trees[r];
    if (!i) throw new Error(o);
    var a = i.data;
    if (n * this.stride >= a.length) throw new Error(o);
    var s = this.options.radius / (this.options.extent * Math.pow(2, r - 1)), l = a[n * this.stride], u = a[n * this.stride + 1], c = i.within(l, u, s), p = [];
    for (var d of c) {
      var g = d * this.stride;
      a[g + Qx] === t && p.push(a[g + Ua] > 1 ? t$(a, g, this.clusterProps) : this.points[a[g + Ga]]);
    }
    if (p.length === 0) throw new Error(o);
    return p;
  }
  getLeaves(t, n, r) {
    n = n || 10, r = r || 0;
    var o = [];
    return this._appendLeaves(o, t, n, r, 0), o;
  }
  getTile(t, n, r) {
    var o = this.trees[this._limitZoom(t)], i = Math.pow(2, t), {
      extent: a,
      radius: s
    } = this.options, l = s / a, u = (r - l) / i, c = (r + 1 + l) / i, p = {
      features: []
    };
    return this._addTileFeatures(o.range((n - l) / i, u, (n + 1 + l) / i, c), o.data, n, r, i, p), n === 0 && this._addTileFeatures(o.range(1 - l / i, u, 1, c), o.data, i, r, i, p), n === i - 1 && this._addTileFeatures(o.range(0, u, l / i, c), o.data, -1, r, i, p), p.features.length ? p : null;
  }
  getClusterExpansionZoom(t) {
    for (var n = this._getOriginZoom(t) - 1; n <= this.options.maxZoom; ) {
      var r = this.getChildren(t);
      if (n++, r.length !== 1) break;
      t = r[0].properties.cluster_id;
    }
    return n;
  }
  _appendLeaves(t, n, r, o, i) {
    var a = this.getChildren(n);
    for (var s of a) {
      var l = s.properties;
      if (l && l.cluster ? i + l.point_count <= o ? i += l.point_count : i = this._appendLeaves(t, l.cluster_id, r, o, i) : i < o ? i++ : t.push(s), t.length === r) break;
    }
    return i;
  }
  _createTree(t) {
    for (var n = new q_(t.length / this.stride | 0, this.options.nodeSize, Float32Array), r = 0; r < t.length; r += this.stride) n.add(t[r], t[r + 1]);
    return n.finish(), n.data = t, n;
  }
  _addTileFeatures(t, n, r, o, i, a) {
    for (var s of t) {
      var l = s * this.stride, u = n[l + Ua] > 1, c = void 0, p = void 0, d = void 0;
      if (u)
        c = ZK(n, l, this.clusterProps), p = n[l], d = n[l + 1];
      else {
        var g = this.points[n[l + Ga]];
        c = g.properties;
        var [f, m] = g.geometry.coordinates;
        p = Kg(f), d = Yg(m);
      }
      var v = {
        type: 1,
        geometry: [[Math.round(this.options.extent * (p * i - r)), Math.round(this.options.extent * (d * i - o))]],
        tags: c
      }, E = void 0;
      u || this.options.generateId ? E = n[l + Ga] : E = this.points[n[l + Ga]].id, E !== void 0 && (v.id = E), a.features.push(v);
    }
  }
  _limitZoom(t) {
    return Math.max(this.options.minZoom, Math.min(Math.floor(+t), this.options.maxZoom + 1));
  }
  _cluster(t, n) {
    for (var {
      radius: r,
      extent: o,
      reduce: i,
      minPoints: a
    } = this.options, s = r / (o * Math.pow(2, n)), l = t.data, u = [], c = this.stride, p = 0; p < l.length; p += c)
      if (!(l[p + $l] <= n)) {
        l[p + $l] = n;
        var d = l[p], g = l[p + 1], f = t.within(l[p], l[p + 1], s), m = l[p + Ua], v = m;
        for (var E of f) {
          var w = E * c;
          l[w + $l] > n && (v += l[w + Ua]);
        }
        if (v > m && v >= a) {
          var M = d * m, O = g * m, y = void 0, C = -1, _ = ((p / c | 0) << 5) + (n + 1) + this.points.length;
          for (var F of f) {
            var L = F * c;
            if (!(l[L + $l] <= n)) {
              l[L + $l] = n;
              var N = l[L + Ua];
              M += l[L] * N, O += l[L + 1] * N, l[L + Qx] = _, i && (y || (y = this._map(l, p, !0), C = this.clusterProps.length, this.clusterProps.push(y)), i(y, this._map(l, L)));
            }
          }
          l[p + Qx] = _, u.push(M / v, O / v, 1 / 0, _, -1, v), i && u.push(C);
        } else {
          for (var R = 0; R < c; R++) u.push(l[p + R]);
          if (v > 1)
            for (var W of f) {
              var V = W * c;
              if (!(l[V + $l] <= n)) {
                l[V + $l] = n;
                for (var z = 0; z < c; z++) u.push(l[V + z]);
              }
            }
        }
      }
    return u;
  }
  // get index of the point from which the cluster originated
  _getOriginId(t) {
    return t - this.points.length >> 5;
  }
  // get zoom of the point from which the cluster originated
  _getOriginZoom(t) {
    return (t - this.points.length) % 32;
  }
  _map(t, n, r) {
    if (t[n + Ua] > 1) {
      var o = this.clusterProps[t[n + VK]];
      return r ? Object.assign({}, o) : o;
    }
    var i = this.points[t[n + Ga]].properties, a = this.options.map(i);
    return r && a === i ? Object.assign({}, a) : a;
  }
}
function t$(e, t, n) {
  return {
    type: "Feature",
    id: e[t + Ga],
    properties: ZK(e, t, n),
    geometry: {
      type: "Point",
      coordinates: [lRe(e[t]), uRe(e[t + 1])]
    }
  };
}
function ZK(e, t, n) {
  var r = e[t + Ua], o = r >= 1e4 ? "".concat(Math.round(r / 1e3), "k") : r >= 1e3 ? "".concat(Math.round(r / 100) / 10, "k") : r, i = e[t + VK], a = i === -1 ? {} : Object.assign({}, n[i]);
  return Object.assign(a, {
    cluster: !0,
    cluster_id: e[t + Ga],
    point_count: r,
    point_count_abbreviated: o
  });
}
function Kg(e) {
  return e / 360 + 0.5;
}
function Yg(e) {
  var t = Math.sin(e * Math.PI / 180), n = 0.5 - 0.25 * Math.log((1 + t) / (1 - t)) / Math.PI;
  return n < 0 ? 0 : n > 1 ? 1 : n;
}
function lRe(e) {
  return (e - 0.5) * 360;
}
function uRe(e) {
  var t = (180 - e * 360) * Math.PI / 180;
  return 360 * Math.atan(Math.exp(t)) / Math.PI - 90;
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function cRe(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
    t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
  return n;
}
class Bi {
  static isAdvancedMarkerAvailable(t) {
    return google.maps.marker && t.getMapCapabilities().isAdvancedMarkersAvailable === !0;
  }
  static isAdvancedMarker(t) {
    return google.maps.marker && t instanceof google.maps.marker.AdvancedMarkerElement;
  }
  static setMap(t, n) {
    this.isAdvancedMarker(t) ? t.map = n : t.setMap(n);
  }
  static getPosition(t) {
    if (this.isAdvancedMarker(t)) {
      if (t.position) {
        if (t.position instanceof google.maps.LatLng)
          return t.position;
        if (t.position.lat && t.position.lng)
          return new google.maps.LatLng(t.position.lat, t.position.lng);
      }
      return new google.maps.LatLng(null);
    }
    return t.getPosition();
  }
  static getVisible(t) {
    return this.isAdvancedMarker(t) ? !0 : t.getVisible();
  }
}
class qk {
  constructor(t) {
    var {
      markers: n,
      position: r
    } = t;
    this.markers = n, r && (r instanceof google.maps.LatLng ? this._position = r : this._position = new google.maps.LatLng(r));
  }
  get bounds() {
    if (!(this.markers.length === 0 && !this._position)) {
      var t = new google.maps.LatLngBounds(this._position, this._position);
      for (var n of this.markers)
        t.extend(Bi.getPosition(n));
      return t;
    }
  }
  get position() {
    return this._position || this.bounds.getCenter();
  }
  /**
   * Get the count of **visible** markers.
   */
  get count() {
    return this.markers.filter((t) => Bi.getVisible(t)).length;
  }
  /**
   * Add a marker to the cluster.
   */
  push(t) {
    this.markers.push(t);
  }
  /**
   * Cleanup references and remove marker from map.
   */
  delete() {
    this.marker && (Bi.setMap(this.marker, null), this.marker = void 0), this.markers.length = 0;
  }
}
class pRe {
  constructor(t) {
    var {
      maxZoom: n = 16
    } = t;
    this.maxZoom = n;
  }
  /**
   * Helper function to bypass clustering based upon some map state such as
   * zoom, number of markers, etc.
   *
   * ```typescript
   *  cluster({markers, map}: AlgorithmInput): Cluster[] {
   *    if (shouldBypassClustering(map)) {
   *      return this.noop({markers})
   *    }
   * }
   * ```
   */
  noop(t) {
    var {
      markers: n
    } = t;
    return dRe(n);
  }
}
var dRe = (e) => {
  var t = e.map((n) => new qk({
    position: Bi.getPosition(n),
    markers: [n]
  }));
  return t;
};
class fRe extends pRe {
  constructor(t) {
    var {
      maxZoom: n,
      radius: r = 60
    } = t, o = cRe(t, ["maxZoom", "radius"]);
    super({
      maxZoom: n
    }), this.state = {
      zoom: -1
    }, this.superCluster = new aRe(Object.assign({
      maxZoom: this.maxZoom,
      radius: r
    }, o));
  }
  calculate(t) {
    var n = !1, r = {
      zoom: t.map.getZoom()
    };
    if (!XH(t.markers, this.markers)) {
      n = !0, this.markers = [...t.markers];
      var o = this.markers.map((i) => {
        var a = Bi.getPosition(i), s = [a.lng(), a.lat()];
        return {
          type: "Feature",
          geometry: {
            type: "Point",
            coordinates: s
          },
          properties: {
            marker: i
          }
        };
      });
      this.superCluster.load(o);
    }
    return n || (this.state.zoom <= this.maxZoom || r.zoom <= this.maxZoom) && (n = !XH(this.state, r)), this.state = r, n && (this.clusters = this.cluster(t)), {
      clusters: this.clusters,
      changed: n
    };
  }
  cluster(t) {
    var {
      map: n
    } = t;
    return this.superCluster.getClusters([-180, -90, 180, 90], Math.round(n.getZoom())).map((r) => this.transformCluster(r));
  }
  transformCluster(t) {
    var {
      geometry: {
        coordinates: [n, r]
      },
      properties: o
    } = t;
    if (o.cluster)
      return new qk({
        markers: this.superCluster.getLeaves(o.cluster_id, 1 / 0).map((a) => a.properties.marker),
        position: {
          lat: r,
          lng: n
        }
      });
    var i = o.marker;
    return new qk({
      markers: [i],
      position: Bi.getPosition(i)
    });
  }
}
class hRe {
  constructor(t, n) {
    this.markers = {
      sum: t.length
    };
    var r = n.map((i) => i.count), o = r.reduce((i, a) => i + a, 0);
    this.clusters = {
      count: n.length,
      markers: {
        mean: o / n.length,
        sum: o,
        min: Math.min(...r),
        max: Math.max(...r)
      }
    };
  }
}
class gRe {
  /**
   * The default render function for the library used by {@link MarkerClusterer}.
   *
   * Currently set to use the following:
   *
   * ```typescript
   * // change color if this cluster has more markers than the mean cluster
   * const color =
   *   count > Math.max(10, stats.clusters.markers.mean)
   *     ? "#ff0000"
   *     : "#0000ff";
   *
   * // create svg url with fill color
   * const svg = window.btoa(`
   * <svg fill="${color}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240">
   *   <circle cx="120" cy="120" opacity=".6" r="70" />
   *   <circle cx="120" cy="120" opacity=".3" r="90" />
   *   <circle cx="120" cy="120" opacity=".2" r="110" />
   *   <circle cx="120" cy="120" opacity=".1" r="130" />
   * </svg>`);
   *
   * // create marker using svg icon
   * return new google.maps.Marker({
   *   position,
   *   icon: {
   *     url: `data:image/svg+xml;base64,${svg}`,
   *     scaledSize: new google.maps.Size(45, 45),
   *   },
   *   label: {
   *     text: String(count),
   *     color: "rgba(255,255,255,0.9)",
   *     fontSize: "12px",
   *   },
   *   // adjust zIndex to be above other markers
   *   zIndex: 1000 + count,
   * });
   * ```
   */
  render(t, n, r) {
    var {
      count: o,
      position: i
    } = t, a = o > Math.max(10, n.clusters.markers.mean) ? "#ff0000" : "#0000ff", s = '<svg fill="'.concat(a, `" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" width="50" height="50">
<circle cx="120" cy="120" opacity=".6" r="70" />
<circle cx="120" cy="120" opacity=".3" r="90" />
<circle cx="120" cy="120" opacity=".2" r="110" />
<text x="50%" y="50%" style="fill:#fff" text-anchor="middle" font-size="50" dominant-baseline="middle" font-family="roboto,arial,sans-serif">`).concat(o, `</text>
</svg>`), l = "Cluster of ".concat(o, " markers"), u = Number(google.maps.Marker.MAX_ZINDEX) + o;
    if (Bi.isAdvancedMarkerAvailable(r)) {
      var c = new DOMParser(), p = c.parseFromString(s, "image/svg+xml").documentElement;
      p.setAttribute("transform", "translate(0 25)");
      var d = {
        map: r,
        position: i,
        zIndex: u,
        title: l,
        content: p
      };
      return new google.maps.marker.AdvancedMarkerElement(d);
    }
    var g = {
      position: i,
      zIndex: u,
      title: l,
      icon: {
        url: "data:image/svg+xml;base64,".concat(btoa(s)),
        anchor: new google.maps.Point(25, 25)
      }
    };
    return new google.maps.Marker(g);
  }
}
function mRe(e, t) {
  for (var n in t.prototype)
    e.prototype[n] = t.prototype[n];
}
class G_ {
  constructor() {
    mRe(G_, google.maps.OverlayView);
  }
}
var ud;
(function(e) {
  e.CLUSTERING_BEGIN = "clusteringbegin", e.CLUSTERING_END = "clusteringend", e.CLUSTER_CLICK = "click";
})(ud || (ud = {}));
var vRe = (e, t, n) => {
  n.fitBounds(t.bounds);
};
class yRe extends G_ {
  constructor(t) {
    var {
      map: n,
      markers: r = [],
      algorithmOptions: o = {},
      algorithm: i = new fRe(o),
      renderer: a = new gRe(),
      onClusterClick: s = vRe
    } = t;
    super(), this.markers = [...r], this.clusters = [], this.algorithm = i, this.renderer = a, this.onClusterClick = s, n && this.setMap(n);
  }
  addMarker(t, n) {
    this.markers.includes(t) || (this.markers.push(t), n || this.render());
  }
  addMarkers(t, n) {
    t.forEach((r) => {
      this.addMarker(r, !0);
    }), n || this.render();
  }
  removeMarker(t, n) {
    var r = this.markers.indexOf(t);
    return r === -1 ? !1 : (Bi.setMap(t, null), this.markers.splice(r, 1), n || this.render(), !0);
  }
  removeMarkers(t, n) {
    var r = !1;
    return t.forEach((o) => {
      r = this.removeMarker(o, !0) || r;
    }), r && !n && this.render(), r;
  }
  clearMarkers(t) {
    this.markers.length = 0, t || this.render();
  }
  /**
   * Recalculates and draws all the marker clusters.
   */
  render() {
    var t = this.getMap();
    if (t instanceof google.maps.Map && t.getProjection()) {
      google.maps.event.trigger(this, ud.CLUSTERING_BEGIN, this);
      var {
        clusters: n,
        changed: r
      } = this.algorithm.calculate({
        markers: this.markers,
        map: t,
        mapCanvasProjection: this.getProjection()
      });
      if (r || r == null) {
        var o = /* @__PURE__ */ new Set();
        for (var i of n)
          i.markers.length == 1 && o.add(i.markers[0]);
        var a = [];
        for (var s of this.clusters)
          s.marker != null && (s.markers.length == 1 ? o.has(s.marker) || Bi.setMap(s.marker, null) : a.push(s.marker));
        this.clusters = n, this.renderClusters(), requestAnimationFrame(() => a.forEach((l) => Bi.setMap(l, null)));
      }
      google.maps.event.trigger(this, ud.CLUSTERING_END, this);
    }
  }
  onAdd() {
    this.idleListener = this.getMap().addListener("idle", this.render.bind(this)), this.render();
  }
  onRemove() {
    google.maps.event.removeListener(this.idleListener), this.reset();
  }
  reset() {
    this.markers.forEach((t) => Bi.setMap(t, null)), this.clusters.forEach((t) => t.delete()), this.clusters = [];
  }
  renderClusters() {
    var t = new hRe(this.markers, this.clusters), n = this.getMap();
    this.clusters.forEach((r) => {
      r.markers.length === 1 ? r.marker = r.markers[0] : (r.marker = this.renderer.render(r, t, n), r.markers.forEach((o) => Bi.setMap(o, null)), this.onClusterClick && r.marker.addListener(
        "click",
        /* istanbul ignore next */
        (o) => {
          google.maps.event.trigger(this, ud.CLUSTER_CLICK, r), this.onClusterClick(o, r, n);
        }
      )), Bi.setMap(r.marker, n);
    });
  }
}
function n$(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function r$(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? n$(Object(n), !0).forEach(function(r) {
      ke(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : n$(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function bRe(e) {
  var t = vIe(), [n, r] = k(null);
  return h(() => {
    if (t && n === null) {
      var o = new yRe(r$(r$({}, e), {}, {
        map: t
      }));
      r(o);
    }
  }, [t]), n;
}
function wRe(e) {
  var {
    children: t,
    options: n
  } = e, r = bRe(n);
  return r !== null ? t(r) : null;
}
ve(wRe);
var o$ = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, i$ = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
function CRe(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, g = ge(Rt), [f, m] = k(null), [v, E] = k(null), [w, M] = k(null), [O, y] = k(null), [C, _] = k(null), [F, L] = k(null), N = ut(null);
  return h(() => {
    f !== null && (f.close(), n ? f.open(g, n) : f.getPosition() && f.open(g));
  }, [g, f, n]), h(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), h(() => {
    o && f !== null && f.setPosition(o);
  }, [o]), h(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), h(() => {
    f && a && (v !== null && google.maps.event.removeListener(v), E(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), h(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), M(google.maps.event.addListener(f, "domready", s)));
  }, [s]), h(() => {
    f && l && (O !== null && google.maps.event.removeListener(O), y(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), h(() => {
    f && u && (C !== null && google.maps.event.removeListener(C), _(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), h(() => {
    f && c && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), h(() => {
    var R = new google.maps.InfoWindow(r);
    return m(R), N.current = document.createElement("div"), a && E(google.maps.event.addListener(R, "closeclick", a)), s && M(google.maps.event.addListener(R, "domready", s)), l && y(google.maps.event.addListener(R, "content_changed", l)), u && _(google.maps.event.addListener(R, "position_changed", u)), c && L(google.maps.event.addListener(R, "zindex_changed", c)), R.setContent(N.current), o && R.setPosition(o), i && R.setZIndex(i), n ? R.open(g, n) : R.getPosition() ? R.open(g) : xo(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>."), p && p(R), () => {
      v && google.maps.event.removeListener(v), O && google.maps.event.removeListener(O), w && google.maps.event.removeListener(w), C && google.maps.event.removeListener(C), F && google.maps.event.removeListener(F), d && d(R), R.close();
    };
  }, []), N.current ? or(lt.only(t), N.current) : null;
}
ve(CRe);
class xRe extends pe {
  constructor() {
    super(...arguments), ke(this, "registeredEvents", []), ke(this, "containerElement", null), ke(this, "state", {
      infoWindow: null
    }), ke(this, "open", (t, n) => {
      n ? t.open(this.context, n) : t.getPosition() ? t.open(this.context) : xo(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>.");
    }), ke(this, "setInfoWindowCallback", () => {
      this.state.infoWindow !== null && this.containerElement !== null && (this.state.infoWindow.setContent(this.containerElement), this.open(this.state.infoWindow, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoWindow));
    });
  }
  componentDidMount() {
    var t = new google.maps.InfoWindow(this.props.options);
    this.containerElement = document.createElement("div"), this.registeredEvents = pn({
      updaterMap: i$,
      eventMap: o$,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(() => ({
      infoWindow: t
    }), this.setInfoWindowCallback);
  }
  componentDidUpdate(t) {
    this.state.infoWindow !== null && (vn(this.registeredEvents), this.registeredEvents = pn({
      updaterMap: i$,
      eventMap: o$,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.infoWindow
    }));
  }
  componentWillUnmount() {
    this.state.infoWindow !== null && (vn(this.registeredEvents), this.props.onUnmount && this.props.onUnmount(this.state.infoWindow), this.state.infoWindow.close());
  }
  render() {
    return this.containerElement ? or(lt.only(this.props.children), this.containerElement) : null;
  }
}
ke(xRe, "contextType", Rt);
function s$(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function yy(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? s$(Object(n), !0).forEach(function(r) {
      ke(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : s$(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var a$ = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, l$ = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, ORe = {};
function ERe(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: g,
    onRightClick: f,
    onClick: m,
    onDrag: v,
    onLoad: E,
    onUnmount: w
  } = e, M = ge(Rt), [O, y] = k(null), [C, _] = k(null), [F, L] = k(null), [N, R] = k(null), [W, V] = k(null), [z, Z] = k(null), [K, X] = k(null), [te, J] = k(null), [P, D] = k(null), [H, S] = k(null), [$, x] = k(null), [j, U] = k(null);
  return h(() => {
    O !== null && O.setMap(M);
  }, [M]), h(() => {
    typeof t < "u" && O !== null && O.setOptions(t);
  }, [O, t]), h(() => {
    typeof n < "u" && O !== null && O.setDraggable(n);
  }, [O, n]), h(() => {
    typeof r < "u" && O !== null && O.setEditable(r);
  }, [O, r]), h(() => {
    typeof o < "u" && O !== null && O.setVisible(o);
  }, [O, o]), h(() => {
    typeof i < "u" && O !== null && O.setPath(i);
  }, [O, i]), h(() => {
    O && a && (C !== null && google.maps.event.removeListener(C), _(google.maps.event.addListener(O, "dblclick", a)));
  }, [a]), h(() => {
    O && s && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(O, "dragend", s)));
  }, [s]), h(() => {
    O && l && (N !== null && google.maps.event.removeListener(N), R(google.maps.event.addListener(O, "dragstart", l)));
  }, [l]), h(() => {
    O && u && (W !== null && google.maps.event.removeListener(W), V(google.maps.event.addListener(O, "mousedown", u)));
  }, [u]), h(() => {
    O && c && (z !== null && google.maps.event.removeListener(z), Z(google.maps.event.addListener(O, "mousemove", c)));
  }, [c]), h(() => {
    O && p && (K !== null && google.maps.event.removeListener(K), X(google.maps.event.addListener(O, "mouseout", p)));
  }, [p]), h(() => {
    O && d && (te !== null && google.maps.event.removeListener(te), J(google.maps.event.addListener(O, "mouseover", d)));
  }, [d]), h(() => {
    O && g && (P !== null && google.maps.event.removeListener(P), D(google.maps.event.addListener(O, "mouseup", g)));
  }, [g]), h(() => {
    O && f && (H !== null && google.maps.event.removeListener(H), S(google.maps.event.addListener(O, "rightclick", f)));
  }, [f]), h(() => {
    O && m && ($ !== null && google.maps.event.removeListener($), x(google.maps.event.addListener(O, "click", m)));
  }, [m]), h(() => {
    O && v && (j !== null && google.maps.event.removeListener(j), U(google.maps.event.addListener(O, "drag", v)));
  }, [v]), h(() => {
    var T = new google.maps.Polyline(yy(yy({}, t || ORe), {}, {
      map: M
    }));
    return i && T.setPath(i), typeof o < "u" && T.setVisible(o), typeof r < "u" && T.setEditable(r), typeof n < "u" && T.setDraggable(n), a && _(google.maps.event.addListener(T, "dblclick", a)), s && L(google.maps.event.addListener(T, "dragend", s)), l && R(google.maps.event.addListener(T, "dragstart", l)), u && V(google.maps.event.addListener(T, "mousedown", u)), c && Z(google.maps.event.addListener(T, "mousemove", c)), p && X(google.maps.event.addListener(T, "mouseout", p)), d && J(google.maps.event.addListener(T, "mouseover", d)), g && D(google.maps.event.addListener(T, "mouseup", g)), f && S(google.maps.event.addListener(T, "rightclick", f)), m && x(google.maps.event.addListener(T, "click", m)), v && U(google.maps.event.addListener(T, "drag", v)), y(T), E && E(T), () => {
      C !== null && google.maps.event.removeListener(C), F !== null && google.maps.event.removeListener(F), N !== null && google.maps.event.removeListener(N), W !== null && google.maps.event.removeListener(W), z !== null && google.maps.event.removeListener(z), K !== null && google.maps.event.removeListener(K), te !== null && google.maps.event.removeListener(te), P !== null && google.maps.event.removeListener(P), H !== null && google.maps.event.removeListener(H), $ !== null && google.maps.event.removeListener($), w && w(T), T.setMap(null);
    };
  }, []), null;
}
ve(ERe);
class kRe extends pe {
  constructor() {
    super(...arguments), ke(this, "registeredEvents", []), ke(this, "state", {
      polyline: null
    }), ke(this, "setPolylineCallback", () => {
      this.state.polyline !== null && this.props.onLoad && this.props.onLoad(this.state.polyline);
    });
  }
  componentDidMount() {
    var t = new google.maps.Polyline(yy(yy({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = pn({
      updaterMap: l$,
      eventMap: a$,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        polyline: t
      };
    }, this.setPolylineCallback);
  }
  componentDidUpdate(t) {
    this.state.polyline !== null && (vn(this.registeredEvents), this.registeredEvents = pn({
      updaterMap: l$,
      eventMap: a$,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.polyline
    }));
  }
  componentWillUnmount() {
    this.state.polyline !== null && (this.props.onUnmount && this.props.onUnmount(this.state.polyline), vn(this.registeredEvents), this.state.polyline.setMap(null));
  }
  render() {
    return null;
  }
}
ke(kRe, "contextType", Rt);
function u$(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function c$(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? u$(Object(n), !0).forEach(function(r) {
      ke(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : u$(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var p$ = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, d$ = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  paths(e, t) {
    e.setPaths(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function LRe(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    paths: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: g,
    onMouseUp: f,
    onRightClick: m,
    onClick: v,
    onDrag: E,
    onLoad: w,
    onUnmount: M,
    onEdit: O
  } = e, y = ge(Rt), [C, _] = k(null), [F, L] = k(null), [N, R] = k(null), [W, V] = k(null), [z, Z] = k(null), [K, X] = k(null), [te, J] = k(null), [P, D] = k(null), [H, S] = k(null), [$, x] = k(null), [j, U] = k(null), [T, q] = k(null);
  return h(() => {
    C !== null && C.setMap(y);
  }, [y]), h(() => {
    typeof t < "u" && C !== null && C.setOptions(t);
  }, [C, t]), h(() => {
    typeof n < "u" && C !== null && C.setDraggable(n);
  }, [C, n]), h(() => {
    typeof r < "u" && C !== null && C.setEditable(r);
  }, [C, r]), h(() => {
    typeof o < "u" && C !== null && C.setVisible(o);
  }, [C, o]), h(() => {
    typeof i < "u" && C !== null && C.setPath(i);
  }, [C, i]), h(() => {
    typeof a < "u" && C !== null && C.setPaths(a);
  }, [C, a]), h(() => {
    C && typeof s == "function" && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(C, "dblclick", s)));
  }, [s]), h(() => {
    C && (google.maps.event.addListener(C.getPath(), "insert_at", () => {
      O == null || O(C);
    }), google.maps.event.addListener(C.getPath(), "set_at", () => {
      O == null || O(C);
    }), google.maps.event.addListener(C.getPath(), "remove_at", () => {
      O == null || O(C);
    }));
  }, [C, O]), h(() => {
    C && typeof l == "function" && (N !== null && google.maps.event.removeListener(N), R(google.maps.event.addListener(C, "dragend", l)));
  }, [l]), h(() => {
    C && typeof u == "function" && (W !== null && google.maps.event.removeListener(W), V(google.maps.event.addListener(C, "dragstart", u)));
  }, [u]), h(() => {
    C && typeof c == "function" && (z !== null && google.maps.event.removeListener(z), Z(google.maps.event.addListener(C, "mousedown", c)));
  }, [c]), h(() => {
    C && typeof p == "function" && (K !== null && google.maps.event.removeListener(K), X(google.maps.event.addListener(C, "mousemove", p)));
  }, [p]), h(() => {
    C && typeof d == "function" && (te !== null && google.maps.event.removeListener(te), J(google.maps.event.addListener(C, "mouseout", d)));
  }, [d]), h(() => {
    C && typeof g == "function" && (P !== null && google.maps.event.removeListener(P), D(google.maps.event.addListener(C, "mouseover", g)));
  }, [g]), h(() => {
    C && typeof f == "function" && (H !== null && google.maps.event.removeListener(H), S(google.maps.event.addListener(C, "mouseup", f)));
  }, [f]), h(() => {
    C && typeof m == "function" && ($ !== null && google.maps.event.removeListener($), x(google.maps.event.addListener(C, "rightclick", m)));
  }, [m]), h(() => {
    C && typeof v == "function" && (j !== null && google.maps.event.removeListener(j), U(google.maps.event.addListener(C, "click", v)));
  }, [v]), h(() => {
    C && typeof E == "function" && (T !== null && google.maps.event.removeListener(T), q(google.maps.event.addListener(C, "drag", E)));
  }, [E]), h(() => {
    var A = new google.maps.Polygon(c$(c$({}, t), {}, {
      map: y
    }));
    return i && A.setPath(i), a && A.setPaths(a), typeof o < "u" && A.setVisible(o), typeof r < "u" && A.setEditable(r), typeof n < "u" && A.setDraggable(n), s && L(google.maps.event.addListener(A, "dblclick", s)), l && R(google.maps.event.addListener(A, "dragend", l)), u && V(google.maps.event.addListener(A, "dragstart", u)), c && Z(google.maps.event.addListener(A, "mousedown", c)), p && X(google.maps.event.addListener(A, "mousemove", p)), d && J(google.maps.event.addListener(A, "mouseout", d)), g && D(google.maps.event.addListener(A, "mouseover", g)), f && S(google.maps.event.addListener(A, "mouseup", f)), m && x(google.maps.event.addListener(A, "rightclick", m)), v && U(google.maps.event.addListener(A, "click", v)), E && q(google.maps.event.addListener(A, "drag", E)), _(A), w && w(A), () => {
      F !== null && google.maps.event.removeListener(F), N !== null && google.maps.event.removeListener(N), W !== null && google.maps.event.removeListener(W), z !== null && google.maps.event.removeListener(z), K !== null && google.maps.event.removeListener(K), te !== null && google.maps.event.removeListener(te), P !== null && google.maps.event.removeListener(P), H !== null && google.maps.event.removeListener(H), $ !== null && google.maps.event.removeListener($), j !== null && google.maps.event.removeListener(j), M && M(A), A.setMap(null);
    };
  }, []), null;
}
ve(LRe);
class PRe extends pe {
  constructor() {
    super(...arguments), ke(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this.props.options || {};
    this.polygon = new google.maps.Polygon(t), this.polygon.setMap(this.context), this.registeredEvents = pn({
      updaterMap: d$,
      eventMap: p$,
      prevProps: {},
      nextProps: this.props,
      instance: this.polygon
    }), this.props.onLoad && this.props.onLoad(this.polygon);
  }
  componentDidUpdate(t) {
    this.polygon && (vn(this.registeredEvents), this.registeredEvents = pn({
      updaterMap: d$,
      eventMap: p$,
      prevProps: t,
      nextProps: this.props,
      instance: this.polygon
    }));
  }
  componentWillUnmount() {
    this.polygon && (this.props.onUnmount && this.props.onUnmount(this.polygon), vn(this.registeredEvents), this.polygon && this.polygon.setMap(null));
  }
  render() {
    return null;
  }
}
ke(PRe, "contextType", Rt);
function f$(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function by(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? f$(Object(n), !0).forEach(function(r) {
      ke(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : f$(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var h$ = {
  onBoundsChanged: "bounds_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, g$ = {
  bounds(e, t) {
    e.setBounds(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function _Re(e) {
  var {
    options: t,
    bounds: n,
    draggable: r,
    editable: o,
    visible: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: g,
    onRightClick: f,
    onClick: m,
    onDrag: v,
    onBoundsChanged: E,
    onLoad: w,
    onUnmount: M
  } = e, O = ge(Rt), [y, C] = k(null), [_, F] = k(null), [L, N] = k(null), [R, W] = k(null), [V, z] = k(null), [Z, K] = k(null), [X, te] = k(null), [J, P] = k(null), [D, H] = k(null), [S, $] = k(null), [x, j] = k(null), [U, T] = k(null), [q, A] = k(null);
  return h(() => {
    y !== null && y.setMap(O);
  }, [O]), h(() => {
    typeof t < "u" && y !== null && y.setOptions(t);
  }, [y, t]), h(() => {
    typeof r < "u" && y !== null && y.setDraggable(r);
  }, [y, r]), h(() => {
    typeof o < "u" && y !== null && y.setEditable(o);
  }, [y, o]), h(() => {
    typeof i < "u" && y !== null && y.setVisible(i);
  }, [y, i]), h(() => {
    typeof n < "u" && y !== null && y.setBounds(n);
  }, [y, n]), h(() => {
    y && a && (_ !== null && google.maps.event.removeListener(_), F(google.maps.event.addListener(y, "dblclick", a)));
  }, [a]), h(() => {
    y && s && (L !== null && google.maps.event.removeListener(L), N(google.maps.event.addListener(y, "dragend", s)));
  }, [s]), h(() => {
    y && l && (R !== null && google.maps.event.removeListener(R), W(google.maps.event.addListener(y, "dragstart", l)));
  }, [l]), h(() => {
    y && u && (V !== null && google.maps.event.removeListener(V), z(google.maps.event.addListener(y, "mousedown", u)));
  }, [u]), h(() => {
    y && c && (Z !== null && google.maps.event.removeListener(Z), K(google.maps.event.addListener(y, "mousemove", c)));
  }, [c]), h(() => {
    y && p && (X !== null && google.maps.event.removeListener(X), te(google.maps.event.addListener(y, "mouseout", p)));
  }, [p]), h(() => {
    y && d && (J !== null && google.maps.event.removeListener(J), P(google.maps.event.addListener(y, "mouseover", d)));
  }, [d]), h(() => {
    y && g && (D !== null && google.maps.event.removeListener(D), H(google.maps.event.addListener(y, "mouseup", g)));
  }, [g]), h(() => {
    y && f && (S !== null && google.maps.event.removeListener(S), $(google.maps.event.addListener(y, "rightclick", f)));
  }, [f]), h(() => {
    y && m && (x !== null && google.maps.event.removeListener(x), j(google.maps.event.addListener(y, "click", m)));
  }, [m]), h(() => {
    y && v && (U !== null && google.maps.event.removeListener(U), T(google.maps.event.addListener(y, "drag", v)));
  }, [v]), h(() => {
    y && E && (q !== null && google.maps.event.removeListener(q), A(google.maps.event.addListener(y, "bounds_changed", E)));
  }, [E]), h(() => {
    var Y = new google.maps.Rectangle(by(by({}, t), {}, {
      map: O
    }));
    return typeof i < "u" && Y.setVisible(i), typeof o < "u" && Y.setEditable(o), typeof r < "u" && Y.setDraggable(r), typeof n < "u" && Y.setBounds(n), a && F(google.maps.event.addListener(Y, "dblclick", a)), s && N(google.maps.event.addListener(Y, "dragend", s)), l && W(google.maps.event.addListener(Y, "dragstart", l)), u && z(google.maps.event.addListener(Y, "mousedown", u)), c && K(google.maps.event.addListener(Y, "mousemove", c)), p && te(google.maps.event.addListener(Y, "mouseout", p)), d && P(google.maps.event.addListener(Y, "mouseover", d)), g && H(google.maps.event.addListener(Y, "mouseup", g)), f && $(google.maps.event.addListener(Y, "rightclick", f)), m && j(google.maps.event.addListener(Y, "click", m)), v && T(google.maps.event.addListener(Y, "drag", v)), E && A(google.maps.event.addListener(Y, "bounds_changed", E)), C(Y), w && w(Y), () => {
      _ !== null && google.maps.event.removeListener(_), L !== null && google.maps.event.removeListener(L), R !== null && google.maps.event.removeListener(R), V !== null && google.maps.event.removeListener(V), Z !== null && google.maps.event.removeListener(Z), X !== null && google.maps.event.removeListener(X), J !== null && google.maps.event.removeListener(J), D !== null && google.maps.event.removeListener(D), S !== null && google.maps.event.removeListener(S), x !== null && google.maps.event.removeListener(x), U !== null && google.maps.event.removeListener(U), q !== null && google.maps.event.removeListener(q), M && M(Y), Y.setMap(null);
    };
  }, []), null;
}
ve(_Re);
class SRe extends pe {
  constructor() {
    super(...arguments), ke(this, "registeredEvents", []), ke(this, "state", {
      rectangle: null
    }), ke(this, "setRectangleCallback", () => {
      this.state.rectangle !== null && this.props.onLoad && this.props.onLoad(this.state.rectangle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Rectangle(by(by({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = pn({
      updaterMap: g$,
      eventMap: h$,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        rectangle: t
      };
    }, this.setRectangleCallback);
  }
  componentDidUpdate(t) {
    this.state.rectangle !== null && (vn(this.registeredEvents), this.registeredEvents = pn({
      updaterMap: g$,
      eventMap: h$,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.rectangle
    }));
  }
  componentWillUnmount() {
    this.state.rectangle !== null && (this.props.onUnmount && this.props.onUnmount(this.state.rectangle), vn(this.registeredEvents), this.state.rectangle.setMap(null));
  }
  render() {
    return null;
  }
}
ke(SRe, "contextType", Rt);
function m$(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function wy(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? m$(Object(n), !0).forEach(function(r) {
      ke(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : m$(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var v$ = {
  onCenterChanged: "center_changed",
  onRadiusChanged: "radius_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, y$ = {
  center(e, t) {
    e.setCenter(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  radius(e, t) {
    e.setRadius(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, MRe = {};
function DRe(e) {
  var {
    options: t,
    center: n,
    radius: r,
    draggable: o,
    editable: i,
    visible: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: g,
    onMouseUp: f,
    onRightClick: m,
    onClick: v,
    onDrag: E,
    onCenterChanged: w,
    onRadiusChanged: M,
    onLoad: O,
    onUnmount: y
  } = e, C = ge(Rt), [_, F] = k(null), [L, N] = k(null), [R, W] = k(null), [V, z] = k(null), [Z, K] = k(null), [X, te] = k(null), [J, P] = k(null), [D, H] = k(null), [S, $] = k(null), [x, j] = k(null), [U, T] = k(null), [q, A] = k(null), [Y, B] = k(null), [ue, fe] = k(null);
  return h(() => {
    _ !== null && _.setMap(C);
  }, [C]), h(() => {
    typeof t < "u" && _ !== null && _.setOptions(t);
  }, [_, t]), h(() => {
    typeof o < "u" && _ !== null && _.setDraggable(o);
  }, [_, o]), h(() => {
    typeof i < "u" && _ !== null && _.setEditable(i);
  }, [_, i]), h(() => {
    typeof a < "u" && _ !== null && _.setVisible(a);
  }, [_, a]), h(() => {
    typeof r == "number" && _ !== null && _.setRadius(r);
  }, [_, r]), h(() => {
    typeof n < "u" && _ !== null && _.setCenter(n);
  }, [_, n]), h(() => {
    _ && s && (L !== null && google.maps.event.removeListener(L), N(google.maps.event.addListener(_, "dblclick", s)));
  }, [s]), h(() => {
    _ && l && (R !== null && google.maps.event.removeListener(R), W(google.maps.event.addListener(_, "dragend", l)));
  }, [l]), h(() => {
    _ && u && (V !== null && google.maps.event.removeListener(V), z(google.maps.event.addListener(_, "dragstart", u)));
  }, [u]), h(() => {
    _ && c && (Z !== null && google.maps.event.removeListener(Z), K(google.maps.event.addListener(_, "mousedown", c)));
  }, [c]), h(() => {
    _ && p && (X !== null && google.maps.event.removeListener(X), te(google.maps.event.addListener(_, "mousemove", p)));
  }, [p]), h(() => {
    _ && d && (J !== null && google.maps.event.removeListener(J), P(google.maps.event.addListener(_, "mouseout", d)));
  }, [d]), h(() => {
    _ && g && (D !== null && google.maps.event.removeListener(D), H(google.maps.event.addListener(_, "mouseover", g)));
  }, [g]), h(() => {
    _ && f && (S !== null && google.maps.event.removeListener(S), $(google.maps.event.addListener(_, "mouseup", f)));
  }, [f]), h(() => {
    _ && m && (x !== null && google.maps.event.removeListener(x), j(google.maps.event.addListener(_, "rightclick", m)));
  }, [m]), h(() => {
    _ && v && (U !== null && google.maps.event.removeListener(U), T(google.maps.event.addListener(_, "click", v)));
  }, [v]), h(() => {
    _ && E && (q !== null && google.maps.event.removeListener(q), A(google.maps.event.addListener(_, "drag", E)));
  }, [E]), h(() => {
    _ && w && (Y !== null && google.maps.event.removeListener(Y), B(google.maps.event.addListener(_, "center_changed", w)));
  }, [v]), h(() => {
    _ && M && (ue !== null && google.maps.event.removeListener(ue), fe(google.maps.event.addListener(_, "radius_changed", M)));
  }, [M]), h(() => {
    var oe = new google.maps.Circle(wy(wy({}, t || MRe), {}, {
      map: C
    }));
    return typeof r == "number" && oe.setRadius(r), typeof n < "u" && oe.setCenter(n), typeof r == "number" && oe.setRadius(r), typeof a < "u" && oe.setVisible(a), typeof i < "u" && oe.setEditable(i), typeof o < "u" && oe.setDraggable(o), s && N(google.maps.event.addListener(oe, "dblclick", s)), l && W(google.maps.event.addListener(oe, "dragend", l)), u && z(google.maps.event.addListener(oe, "dragstart", u)), c && K(google.maps.event.addListener(oe, "mousedown", c)), p && te(google.maps.event.addListener(oe, "mousemove", p)), d && P(google.maps.event.addListener(oe, "mouseout", d)), g && H(google.maps.event.addListener(oe, "mouseover", g)), f && $(google.maps.event.addListener(oe, "mouseup", f)), m && j(google.maps.event.addListener(oe, "rightclick", m)), v && T(google.maps.event.addListener(oe, "click", v)), E && A(google.maps.event.addListener(oe, "drag", E)), w && B(google.maps.event.addListener(oe, "center_changed", w)), M && fe(google.maps.event.addListener(oe, "radius_changed", M)), F(oe), O && O(oe), () => {
      L !== null && google.maps.event.removeListener(L), R !== null && google.maps.event.removeListener(R), V !== null && google.maps.event.removeListener(V), Z !== null && google.maps.event.removeListener(Z), X !== null && google.maps.event.removeListener(X), J !== null && google.maps.event.removeListener(J), D !== null && google.maps.event.removeListener(D), S !== null && google.maps.event.removeListener(S), x !== null && google.maps.event.removeListener(x), U !== null && google.maps.event.removeListener(U), Y !== null && google.maps.event.removeListener(Y), ue !== null && google.maps.event.removeListener(ue), y && y(oe), oe.setMap(null);
    };
  }, []), null;
}
ve(DRe);
class TRe extends pe {
  constructor() {
    super(...arguments), ke(this, "registeredEvents", []), ke(this, "state", {
      circle: null
    }), ke(this, "setCircleCallback", () => {
      this.state.circle !== null && this.props.onLoad && this.props.onLoad(this.state.circle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Circle(wy(wy({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = pn({
      updaterMap: y$,
      eventMap: v$,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        circle: t
      };
    }, this.setCircleCallback);
  }
  componentDidUpdate(t) {
    this.state.circle !== null && (vn(this.registeredEvents), this.registeredEvents = pn({
      updaterMap: y$,
      eventMap: v$,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.circle
    }));
  }
  componentWillUnmount() {
    if (this.state.circle !== null) {
      var t;
      this.props.onUnmount && this.props.onUnmount(this.state.circle), vn(this.registeredEvents), (t = this.state.circle) === null || t === void 0 || t.setMap(null);
    }
  }
  render() {
    return null;
  }
}
ke(TRe, "contextType", Rt);
function b$(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Cy(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? b$(Object(n), !0).forEach(function(r) {
      ke(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : b$(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var w$ = {
  onClick: "click",
  onDblClick: "dblclick",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onAddFeature: "addfeature",
  onRemoveFeature: "removefeature",
  onRemoveProperty: "removeproperty",
  onSetGeometry: "setgeometry",
  onSetProperty: "setproperty"
}, C$ = {
  add(e, t) {
    e.add(t);
  },
  addgeojson(e, t, n) {
    e.addGeoJson(t, n);
  },
  contains(e, t) {
    e.contains(t);
  },
  foreach(e, t) {
    e.forEach(t);
  },
  loadgeojson(e, t, n, r) {
    e.loadGeoJson(t, n, r);
  },
  overridestyle(e, t, n) {
    e.overrideStyle(t, n);
  },
  remove(e, t) {
    e.remove(t);
  },
  revertstyle(e, t) {
    e.revertStyle(t);
  },
  controlposition(e, t) {
    e.setControlPosition(t);
  },
  controls(e, t) {
    e.setControls(t);
  },
  drawingmode(e, t) {
    e.setDrawingMode(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  style(e, t) {
    e.setStyle(t);
  },
  togeojson(e, t) {
    e.toGeoJson(t);
  }
};
function jRe(e) {
  var {
    options: t,
    onClick: n,
    onDblClick: r,
    onMouseDown: o,
    onMouseMove: i,
    onMouseOut: a,
    onMouseOver: s,
    onMouseUp: l,
    onRightClick: u,
    onAddFeature: c,
    onRemoveFeature: p,
    onRemoveProperty: d,
    onSetGeometry: g,
    onSetProperty: f,
    onLoad: m,
    onUnmount: v
  } = e, E = ge(Rt), [w, M] = k(null), [O, y] = k(null), [C, _] = k(null), [F, L] = k(null), [N, R] = k(null), [W, V] = k(null), [z, Z] = k(null), [K, X] = k(null), [te, J] = k(null), [P, D] = k(null), [H, S] = k(null), [$, x] = k(null), [j, U] = k(null), [T, q] = k(null);
  return h(() => {
    w !== null && w.setMap(E);
  }, [E]), h(() => {
    w && r && (O !== null && google.maps.event.removeListener(O), y(google.maps.event.addListener(w, "dblclick", r)));
  }, [r]), h(() => {
    w && o && (C !== null && google.maps.event.removeListener(C), _(google.maps.event.addListener(w, "mousedown", o)));
  }, [o]), h(() => {
    w && i && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(w, "mousemove", i)));
  }, [i]), h(() => {
    w && a && (N !== null && google.maps.event.removeListener(N), R(google.maps.event.addListener(w, "mouseout", a)));
  }, [a]), h(() => {
    w && s && (W !== null && google.maps.event.removeListener(W), V(google.maps.event.addListener(w, "mouseover", s)));
  }, [s]), h(() => {
    w && l && (z !== null && google.maps.event.removeListener(z), Z(google.maps.event.addListener(w, "mouseup", l)));
  }, [l]), h(() => {
    w && u && (K !== null && google.maps.event.removeListener(K), X(google.maps.event.addListener(w, "rightclick", u)));
  }, [u]), h(() => {
    w && n && (te !== null && google.maps.event.removeListener(te), J(google.maps.event.addListener(w, "click", n)));
  }, [n]), h(() => {
    w && c && (P !== null && google.maps.event.removeListener(P), D(google.maps.event.addListener(w, "addfeature", c)));
  }, [c]), h(() => {
    w && p && (H !== null && google.maps.event.removeListener(H), S(google.maps.event.addListener(w, "removefeature", p)));
  }, [p]), h(() => {
    w && d && ($ !== null && google.maps.event.removeListener($), x(google.maps.event.addListener(w, "removeproperty", d)));
  }, [d]), h(() => {
    w && g && (j !== null && google.maps.event.removeListener(j), U(google.maps.event.addListener(w, "setgeometry", g)));
  }, [g]), h(() => {
    w && f && (T !== null && google.maps.event.removeListener(T), q(google.maps.event.addListener(w, "setproperty", f)));
  }, [f]), h(() => {
    if (E !== null) {
      var A = new google.maps.Data(Cy(Cy({}, t), {}, {
        map: E
      }));
      r && y(google.maps.event.addListener(A, "dblclick", r)), o && _(google.maps.event.addListener(A, "mousedown", o)), i && L(google.maps.event.addListener(A, "mousemove", i)), a && R(google.maps.event.addListener(A, "mouseout", a)), s && V(google.maps.event.addListener(A, "mouseover", s)), l && Z(google.maps.event.addListener(A, "mouseup", l)), u && X(google.maps.event.addListener(A, "rightclick", u)), n && J(google.maps.event.addListener(A, "click", n)), c && D(google.maps.event.addListener(A, "addfeature", c)), p && S(google.maps.event.addListener(A, "removefeature", p)), d && x(google.maps.event.addListener(A, "removeproperty", d)), g && U(google.maps.event.addListener(A, "setgeometry", g)), f && q(google.maps.event.addListener(A, "setproperty", f)), M(A), m && m(A);
    }
    return () => {
      w && (O !== null && google.maps.event.removeListener(O), C !== null && google.maps.event.removeListener(C), F !== null && google.maps.event.removeListener(F), N !== null && google.maps.event.removeListener(N), W !== null && google.maps.event.removeListener(W), z !== null && google.maps.event.removeListener(z), K !== null && google.maps.event.removeListener(K), te !== null && google.maps.event.removeListener(te), P !== null && google.maps.event.removeListener(P), H !== null && google.maps.event.removeListener(H), $ !== null && google.maps.event.removeListener($), j !== null && google.maps.event.removeListener(j), T !== null && google.maps.event.removeListener(T), v && v(w), w.setMap(null));
    };
  }, []), null;
}
ve(jRe);
class ARe extends pe {
  constructor() {
    super(...arguments), ke(this, "registeredEvents", []), ke(this, "state", {
      data: null
    }), ke(this, "setDataCallback", () => {
      this.state.data !== null && this.props.onLoad && this.props.onLoad(this.state.data);
    });
  }
  componentDidMount() {
    if (this.context !== null) {
      var t = new google.maps.Data(Cy(Cy({}, this.props.options), {}, {
        map: this.context
      }));
      this.registeredEvents = pn({
        updaterMap: C$,
        eventMap: w$,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        data: t
      }), this.setDataCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.data !== null && (vn(this.registeredEvents), this.registeredEvents = pn({
      updaterMap: C$,
      eventMap: w$,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.data
    }));
  }
  componentWillUnmount() {
    this.state.data !== null && (this.props.onUnmount && this.props.onUnmount(this.state.data), vn(this.registeredEvents), this.state.data && this.state.data.setMap(null));
  }
  render() {
    return null;
  }
}
ke(ARe, "contextType", Rt);
function x$(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function O$(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? x$(Object(n), !0).forEach(function(r) {
      ke(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : x$(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var E$ = {
  onClick: "click",
  onDefaultViewportChanged: "defaultviewport_changed",
  onStatusChanged: "status_changed"
}, k$ = {
  options(e, t) {
    e.setOptions(t);
  },
  url(e, t) {
    e.setUrl(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
class IRe extends pe {
  constructor() {
    super(...arguments), ke(this, "registeredEvents", []), ke(this, "state", {
      kmlLayer: null
    }), ke(this, "setKmlLayerCallback", () => {
      this.state.kmlLayer !== null && this.props.onLoad && this.props.onLoad(this.state.kmlLayer);
    });
  }
  componentDidMount() {
    var t = new google.maps.KmlLayer(O$(O$({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = pn({
      updaterMap: k$,
      eventMap: E$,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        kmlLayer: t
      };
    }, this.setKmlLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.kmlLayer !== null && (vn(this.registeredEvents), this.registeredEvents = pn({
      updaterMap: k$,
      eventMap: E$,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.kmlLayer
    }));
  }
  componentWillUnmount() {
    this.state.kmlLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.kmlLayer), vn(this.registeredEvents), this.state.kmlLayer.setMap(null));
  }
  render() {
    return null;
  }
}
ke(IRe, "contextType", Rt);
function qK(e, t) {
  return typeof t == "function" ? t(e.offsetWidth, e.offsetHeight) : {
    x: 0,
    y: 0
  };
}
function RRe(e, t) {
  return new t(e.lat, e.lng);
}
function BRe(e, t) {
  return new t(new google.maps.LatLng(e.ne.lat, e.ne.lng), new google.maps.LatLng(e.sw.lat, e.sw.lng));
}
function NRe(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function FRe(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function zRe(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n.getNorthEast()), o = e && e.fromLatLngToDivPixel(n.getSouthWest());
  return r && o ? {
    left: "".concat(o.x + t.x, "px"),
    top: "".concat(r.y + t.y, "px"),
    width: "".concat(r.x - o.x - t.x, "px"),
    height: "".concat(o.y - r.y - t.y, "px")
  } : {
    left: "-9999px",
    top: "-9999px"
  };
}
function URe(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n);
  if (r) {
    var {
      x: o,
      y: i
    } = r;
    return {
      left: "".concat(o + t.x, "px"),
      top: "".concat(i + t.y, "px")
    };
  }
  return {
    left: "-9999px",
    top: "-9999px"
  };
}
function GK(e, t, n, r) {
  return n !== void 0 ? zRe(e, t, FRe(n, google.maps.LatLngBounds, BRe)) : URe(e, t, NRe(r, google.maps.LatLng, RRe));
}
function HRe(e, t) {
  return e.left === t.left && e.top === t.top && e.width === t.height && e.height === t.height;
}
function L$(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function $Re(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? L$(Object(n), !0).forEach(function(r) {
      ke(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : L$(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function WRe(e, t, n, r, o) {
  class i extends google.maps.OverlayView {
    constructor(s, l, u, c) {
      super(), this.container = s, this.pane = l, this.position = u, this.bounds = c;
    }
    onAdd() {
      var s, l = (s = this.getPanes()) === null || s === void 0 ? void 0 : s[this.pane];
      l == null || l.appendChild(this.container);
    }
    draw() {
      var s = this.getProjection(), l = $Re({}, this.container ? qK(this.container, o) : {
        x: 0,
        y: 0
      }), u = GK(s, l, this.bounds, this.position);
      for (var [c, p] of Object.entries(u))
        this.container.style[c] = p;
    }
    onRemove() {
      this.container.parentNode !== null && this.container.parentNode.removeChild(this.container);
    }
  }
  return new i(e, t, n, r);
}
function P$(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function VRe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? P$(Object(n), !0).forEach(function(r) {
      ke(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : P$(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function _$(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLng ? e : new google.maps.LatLng(e.lat, e.lng);
  return t + "";
}
function S$(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLngBounds ? e : new google.maps.LatLngBounds(new google.maps.LatLng(e.south, e.east), new google.maps.LatLng(e.north, e.west));
  return t + "";
}
function ZRe(e) {
  var {
    position: t,
    bounds: n,
    mapPaneName: r,
    zIndex: o,
    onLoad: i,
    onUnmount: a,
    getPixelPositionOffset: s,
    children: l
  } = e, u = ge(Rt), c = Cn(() => {
    var d = document.createElement("div");
    return d.style.position = "absolute", d;
  }, []), p = Cn(() => WRe(c, r, t, n, s), [c, r, t, n]);
  return h(() => (i == null || i(p), p == null || p.setMap(u), () => {
    a == null || a(p), p == null || p.setMap(null);
  }), [u, p]), h(() => {
    c.style.zIndex = "".concat(o);
  }, [o, c]), wi.createPortal(l, c);
}
ve(ZRe);
class Bc extends pe {
  constructor(t) {
    super(t), ke(this, "state", {
      paneEl: null,
      containerStyle: {
        // set initial position
        position: "absolute"
      }
    }), ke(this, "updatePane", () => {
      var r = this.props.mapPaneName, o = this.overlayView.getPanes();
      xo(!!r, "OverlayView requires props.mapPaneName but got %s", r), o ? this.setState({
        paneEl: o[r]
      }) : this.setState({
        paneEl: null
      });
    }), ke(this, "onAdd", () => {
      var r, o;
      this.updatePane(), (r = (o = this.props).onLoad) === null || r === void 0 || r.call(o, this.overlayView);
    }), ke(this, "onPositionElement", () => {
      var r = this.overlayView.getProjection(), o = VRe({
        x: 0,
        y: 0
      }, this.containerRef.current ? qK(this.containerRef.current, this.props.getPixelPositionOffset) : {}), i = GK(r, o, this.props.bounds, this.props.position);
      if (!HRe(i, {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        left: this.state.containerStyle.left,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        top: this.state.containerStyle.top,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        width: this.state.containerStyle.width,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        height: this.state.containerStyle.height
      })) {
        var a, s, l, u;
        this.setState({
          containerStyle: {
            top: (a = i.top) !== null && a !== void 0 ? a : 0,
            left: (s = i.left) !== null && s !== void 0 ? s : 0,
            width: (l = i.width) !== null && l !== void 0 ? l : 0,
            height: (u = i.height) !== null && u !== void 0 ? u : 0,
            position: "absolute"
          }
        });
      }
    }), ke(this, "draw", () => {
      this.onPositionElement();
    }), ke(this, "onRemove", () => {
      var r, o;
      this.setState(() => ({
        paneEl: null
      })), (r = (o = this.props).onUnmount) === null || r === void 0 || r.call(o, this.overlayView);
    }), this.containerRef = mo();
    var n = new google.maps.OverlayView();
    n.onAdd = this.onAdd, n.draw = this.draw, n.onRemove = this.onRemove, this.overlayView = n;
  }
  componentDidMount() {
    this.overlayView.setMap(this.context);
  }
  componentDidUpdate(t) {
    var n = _$(t.position), r = _$(this.props.position), o = S$(t.bounds), i = S$(this.props.bounds);
    (n !== r || o !== i) && this.overlayView.draw(), t.mapPaneName !== this.props.mapPaneName && this.updatePane();
  }
  componentWillUnmount() {
    this.overlayView.setMap(null);
  }
  render() {
    var t = this.state.paneEl;
    return t ? wi.createPortal(Po.jsx("div", {
      ref: this.containerRef,
      style: this.state.containerStyle,
      children: lt.only(this.props.children)
    }), t) : null;
  }
}
ke(Bc, "FLOAT_PANE", "floatPane");
ke(Bc, "MAP_PANE", "mapPane");
ke(Bc, "MARKER_LAYER", "markerLayer");
ke(Bc, "OVERLAY_LAYER", "overlayLayer");
ke(Bc, "OVERLAY_MOUSE_TARGET", "overlayMouseTarget");
ke(Bc, "contextType", Rt);
function qRe() {
}
function M$(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function D$(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? M$(Object(n), !0).forEach(function(r) {
      ke(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : M$(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var T$ = {
  onDblClick: "dblclick",
  onClick: "click"
}, j$ = {
  opacity(e, t) {
    e.setOpacity(t);
  }
};
function GRe(e) {
  var {
    url: t,
    bounds: n,
    options: r,
    visible: o
  } = e, i = ge(Rt), a = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east)), s = Cn(() => new google.maps.GroundOverlay(t, a, r), []);
  return h(() => {
    s !== null && s.setMap(i);
  }, [i]), h(() => {
    typeof t < "u" && s !== null && (s.set("url", t), s.setMap(i));
  }, [s, t]), h(() => {
    typeof o < "u" && s !== null && s.setOpacity(o ? 1 : 0);
  }, [s, o]), h(() => {
    var l = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east));
    typeof n < "u" && s !== null && (s.set("bounds", l), s.setMap(i));
  }, [s, n]), null;
}
ve(GRe);
class KK extends pe {
  constructor() {
    super(...arguments), ke(this, "registeredEvents", []), ke(this, "state", {
      groundOverlay: null
    }), ke(this, "setGroundOverlayCallback", () => {
      this.state.groundOverlay !== null && this.props.onLoad && this.props.onLoad(this.state.groundOverlay);
    });
  }
  componentDidMount() {
    xo(!!this.props.url || !!this.props.bounds, "For GroundOverlay, url and bounds are passed in to constructor and are immutable after instantiated. This is the behavior of Google Maps JavaScript API v3 ( See https://developers.google.com/maps/documentation/javascript/reference#GroundOverlay) Hence, use the corresponding two props provided by `react-google-maps-api`, url and bounds. In some cases, you'll need the GroundOverlay component to reflect the changes of url and bounds. You can leverage the React's key property to remount the component. Typically, just `key={url}` would serve your need. See https://github.com/tomchentw/react-google-maps/issues/655");
    var t = new google.maps.GroundOverlay(this.props.url, this.props.bounds, D$(D$({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = pn({
      updaterMap: j$,
      eventMap: T$,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        groundOverlay: t
      };
    }, this.setGroundOverlayCallback);
  }
  componentDidUpdate(t) {
    this.state.groundOverlay !== null && (vn(this.registeredEvents), this.registeredEvents = pn({
      updaterMap: j$,
      eventMap: T$,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.groundOverlay
    }));
  }
  componentWillUnmount() {
    this.state.groundOverlay && (this.props.onUnmount && this.props.onUnmount(this.state.groundOverlay), this.state.groundOverlay.setMap(null));
  }
  render() {
    return null;
  }
}
ke(KK, "defaultProps", {
  onLoad: qRe
});
ke(KK, "contextType", Rt);
function A$(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function xy(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? A$(Object(n), !0).forEach(function(r) {
      ke(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : A$(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var I$ = {}, R$ = {
  data(e, t) {
    e.setData(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function KRe(e) {
  var {
    data: t,
    onLoad: n,
    onUnmount: r,
    options: o
  } = e, i = ge(Rt), [a, s] = k(null);
  return h(() => {
    google.maps.visualization || xo(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} in useJsApiScript? %s', google.maps.visualization);
  }, []), h(() => {
    xo(!!t, "data property is required in HeatmapLayer %s", t);
  }, [t]), h(() => {
    a !== null && a.setMap(i);
  }, [i]), h(() => {
    o && a !== null && a.setOptions(o);
  }, [a, o]), h(() => {
    var l = new google.maps.visualization.HeatmapLayer(xy(xy({}, o), {}, {
      data: t,
      map: i
    }));
    return s(l), n && n(l), () => {
      a !== null && (r && r(a), a.setMap(null));
    };
  }, []), null;
}
ve(KRe);
class YRe extends pe {
  constructor() {
    super(...arguments), ke(this, "registeredEvents", []), ke(this, "state", {
      heatmapLayer: null
    }), ke(this, "setHeatmapLayerCallback", () => {
      this.state.heatmapLayer !== null && this.props.onLoad && this.props.onLoad(this.state.heatmapLayer);
    });
  }
  componentDidMount() {
    xo(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} to <LoadScript />? %s', google.maps.visualization), xo(!!this.props.data, "data property is required in HeatmapLayer %s", this.props.data);
    var t = new google.maps.visualization.HeatmapLayer(xy(xy({}, this.props.options), {}, {
      data: this.props.data,
      map: this.context
    }));
    this.registeredEvents = pn({
      updaterMap: R$,
      eventMap: I$,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        heatmapLayer: t
      };
    }, this.setHeatmapLayerCallback);
  }
  componentDidUpdate(t) {
    vn(this.registeredEvents), this.registeredEvents = pn({
      updaterMap: R$,
      eventMap: I$,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.heatmapLayer
    });
  }
  componentWillUnmount() {
    this.state.heatmapLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.heatmapLayer), vn(this.registeredEvents), this.state.heatmapLayer.setMap(null));
  }
  render() {
    return null;
  }
}
ke(YRe, "contextType", Rt);
var B$ = {
  onCloseClick: "closeclick",
  onPanoChanged: "pano_changed",
  onPositionChanged: "position_changed",
  onPovChanged: "pov_changed",
  onResize: "resize",
  onStatusChanged: "status_changed",
  onVisibleChanged: "visible_changed",
  onZoomChanged: "zoom_changed"
}, N$ = {
  register(e, t, n) {
    e.registerPanoProvider(t, n);
  },
  links(e, t) {
    e.setLinks(t);
  },
  motionTracking(e, t) {
    e.setMotionTracking(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  pano(e, t) {
    e.setPano(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  pov(e, t) {
    e.setPov(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zoom(e, t) {
    e.setZoom(t);
  }
};
class XRe extends pe {
  constructor() {
    super(...arguments), ke(this, "registeredEvents", []), ke(this, "state", {
      streetViewPanorama: null
    }), ke(this, "setStreetViewPanoramaCallback", () => {
      this.state.streetViewPanorama !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewPanorama);
    });
  }
  componentDidMount() {
    var t, n, r = (t = (n = this.context) === null || n === void 0 ? void 0 : n.getStreetView()) !== null && t !== void 0 ? t : null;
    this.registeredEvents = pn({
      updaterMap: N$,
      eventMap: B$,
      prevProps: {},
      nextProps: this.props,
      instance: r
    }), this.setState(() => ({
      streetViewPanorama: r
    }), this.setStreetViewPanoramaCallback);
  }
  componentDidUpdate(t) {
    this.state.streetViewPanorama !== null && (vn(this.registeredEvents), this.registeredEvents = pn({
      updaterMap: N$,
      eventMap: B$,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.streetViewPanorama
    }));
  }
  componentWillUnmount() {
    this.state.streetViewPanorama !== null && (this.props.onUnmount && this.props.onUnmount(this.state.streetViewPanorama), vn(this.registeredEvents), this.state.streetViewPanorama.setVisible(!1));
  }
  render() {
    return null;
  }
}
ke(XRe, "contextType", Rt);
class JRe extends pe {
  constructor() {
    super(...arguments), ke(this, "state", {
      streetViewService: null
    }), ke(this, "setStreetViewServiceCallback", () => {
      this.state.streetViewService !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewService);
    });
  }
  componentDidMount() {
    var t = new google.maps.StreetViewService();
    this.setState(function() {
      return {
        streetViewService: t
      };
    }, this.setStreetViewServiceCallback);
  }
  componentWillUnmount() {
    this.state.streetViewService !== null && this.props.onUnmount && this.props.onUnmount(this.state.streetViewService);
  }
  render() {
    return null;
  }
}
ke(JRe, "contextType", Rt);
var F$ = {
  onDirectionsChanged: "directions_changed"
}, z$ = {
  directions(e, t) {
    e.setDirections(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  panel(e, t) {
    e.setPanel(t);
  },
  routeIndex(e, t) {
    e.setRouteIndex(t);
  }
};
class QRe extends pe {
  constructor() {
    super(...arguments), ke(this, "registeredEvents", []), ke(this, "state", {
      directionsRenderer: null
    }), ke(this, "setDirectionsRendererCallback", () => {
      this.state.directionsRenderer !== null && (this.state.directionsRenderer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.directionsRenderer));
    });
  }
  componentDidMount() {
    var t = new google.maps.DirectionsRenderer(this.props.options);
    this.registeredEvents = pn({
      updaterMap: z$,
      eventMap: F$,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        directionsRenderer: t
      };
    }, this.setDirectionsRendererCallback);
  }
  componentDidUpdate(t) {
    this.state.directionsRenderer !== null && (vn(this.registeredEvents), this.registeredEvents = pn({
      updaterMap: z$,
      eventMap: F$,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.directionsRenderer
    }));
  }
  componentWillUnmount() {
    this.state.directionsRenderer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.directionsRenderer), vn(this.registeredEvents), this.state.directionsRenderer && this.state.directionsRenderer.setMap(null));
  }
  render() {
    return null;
  }
}
ke(QRe, "contextType", Rt);
var U$ = {
  onPlacesChanged: "places_changed"
}, H$ = {
  bounds(e, t) {
    e.setBounds(t);
  }
};
class eBe extends pe {
  constructor() {
    super(...arguments), ke(this, "registeredEvents", []), ke(this, "containerElement", mo()), ke(this, "state", {
      searchBox: null
    }), ke(this, "setSearchBoxCallback", () => {
      this.state.searchBox !== null && this.props.onLoad && this.props.onLoad(this.state.searchBox);
    });
  }
  componentDidMount() {
    if (xo(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places), this.containerElement !== null && this.containerElement.current !== null) {
      var t = this.containerElement.current.querySelector("input");
      if (t !== null) {
        var n = new google.maps.places.SearchBox(t, this.props.options);
        this.registeredEvents = pn({
          updaterMap: H$,
          eventMap: U$,
          prevProps: {},
          nextProps: this.props,
          instance: n
        }), this.setState(function() {
          return {
            searchBox: n
          };
        }, this.setSearchBoxCallback);
      }
    }
  }
  componentDidUpdate(t) {
    this.state.searchBox !== null && (vn(this.registeredEvents), this.registeredEvents = pn({
      updaterMap: H$,
      eventMap: U$,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.searchBox
    }));
  }
  componentWillUnmount() {
    this.state.searchBox !== null && (this.props.onUnmount && this.props.onUnmount(this.state.searchBox), vn(this.registeredEvents));
  }
  render() {
    return Po.jsx("div", {
      ref: this.containerElement,
      children: lt.only(this.props.children)
    });
  }
}
ke(eBe, "contextType", Rt);
var $$ = {
  onPlaceChanged: "place_changed"
}, W$ = {
  bounds(e, t) {
    e.setBounds(t);
  },
  restrictions(e, t) {
    e.setComponentRestrictions(t);
  },
  fields(e, t) {
    e.setFields(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  types(e, t) {
    e.setTypes(t);
  }
};
class YK extends pe {
  constructor() {
    super(...arguments), ke(this, "registeredEvents", []), ke(this, "containerElement", mo()), ke(this, "state", {
      autocomplete: null
    }), ke(this, "setAutocompleteCallback", () => {
      this.state.autocomplete !== null && this.props.onLoad && this.props.onLoad(this.state.autocomplete);
    });
  }
  componentDidMount() {
    var t;
    xo(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places);
    var n = (t = this.containerElement.current) === null || t === void 0 ? void 0 : t.querySelector("input");
    if (n) {
      var r = new google.maps.places.Autocomplete(n, this.props.options);
      this.registeredEvents = pn({
        updaterMap: W$,
        eventMap: $$,
        prevProps: {},
        nextProps: this.props,
        instance: r
      }), this.setState(() => ({
        autocomplete: r
      }), this.setAutocompleteCallback);
    }
  }
  componentDidUpdate(t) {
    vn(this.registeredEvents), this.registeredEvents = pn({
      updaterMap: W$,
      eventMap: $$,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.autocomplete
    });
  }
  componentWillUnmount() {
    this.state.autocomplete !== null && vn(this.registeredEvents);
  }
  render() {
    return Po.jsx("div", {
      ref: this.containerElement,
      className: this.props.className,
      children: lt.only(this.props.children)
    });
  }
}
ke(YK, "defaultProps", {
  className: ""
});
ke(YK, "contextType", Rt);
let tBe = { data: "" }, nBe = (e) => typeof window == "object" ? ((e ? e.querySelector("#_goober") : window._goober) || Object.assign((e || document.head).appendChild(document.createElement("style")), { innerHTML: " ", id: "_goober" })).firstChild : e || tBe, rBe = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g, oBe = /\/\*[^]*?\*\/|  +/g, V$ = /\n+/g, rl = (e, t) => {
  let n = "", r = "", o = "";
  for (let i in e) {
    let a = e[i];
    i[0] == "@" ? i[1] == "i" ? n = i + " " + a + ";" : r += i[1] == "f" ? rl(a, i) : i + "{" + rl(a, i[1] == "k" ? "" : t) + "}" : typeof a == "object" ? r += rl(a, t ? t.replace(/([^,])+/g, (s) => i.replace(/([^,]*:\S+\([^)]*\))|([^,])+/g, (l) => /&/.test(l) ? l.replace(/&/g, s) : s ? s + " " + l : l)) : i) : a != null && (i = /^--/.test(i) ? i : i.replace(/[A-Z]/g, "-$&").toLowerCase(), o += rl.p ? rl.p(i, a) : i + ":" + a + ";");
  }
  return n + (t && o ? t + "{" + o + "}" : o) + r;
}, Xs = {}, XK = (e) => {
  if (typeof e == "object") {
    let t = "";
    for (let n in e) t += n + XK(e[n]);
    return t;
  }
  return e;
}, iBe = (e, t, n, r, o) => {
  let i = XK(e), a = Xs[i] || (Xs[i] = ((l) => {
    let u = 0, c = 11;
    for (; u < l.length; ) c = 101 * c + l.charCodeAt(u++) >>> 0;
    return "go" + c;
  })(i));
  if (!Xs[a]) {
    let l = i !== e ? e : ((u) => {
      let c, p, d = [{}];
      for (; c = rBe.exec(u.replace(oBe, "")); ) c[4] ? d.shift() : c[3] ? (p = c[3].replace(V$, " ").trim(), d.unshift(d[0][p] = d[0][p] || {})) : d[0][c[1]] = c[2].replace(V$, " ").trim();
      return d[0];
    })(e);
    Xs[a] = rl(o ? { ["@keyframes " + a]: l } : l, n ? "" : "." + a);
  }
  let s = n && Xs.g ? Xs.g : null;
  return n && (Xs.g = Xs[a]), ((l, u, c, p) => {
    p ? u.data = u.data.replace(p, l) : u.data.indexOf(l) === -1 && (u.data = c ? l + u.data : u.data + l);
  })(Xs[a], t, r, s), a;
}, sBe = (e, t, n) => e.reduce((r, o, i) => {
  let a = t[i];
  if (a && a.call) {
    let s = a(n), l = s && s.props && s.props.className || /^go/.test(s) && s;
    a = l ? "." + l : s && typeof s == "object" ? s.props ? "" : rl(s, "") : s === !1 ? "" : s;
  }
  return r + o + (a ?? "");
}, "");
function a0(e) {
  let t = this || {}, n = e.call ? e(t.p) : e;
  return iBe(n.unshift ? n.raw ? sBe(n, [].slice.call(arguments, 1), t.p) : n.reduce((r, o) => Object.assign(r, o && o.call ? o(t.p) : o), {}) : n, nBe(t.target), t.g, t.o, t.k);
}
let JK, Gk, Kk;
a0.bind({ g: 1 });
let da = a0.bind({ k: 1 });
function aBe(e, t, n, r) {
  rl.p = t, JK = e, Gk = n, Kk = r;
}
function Ml(e, t) {
  let n = this || {};
  return function() {
    let r = arguments;
    function o(i, a) {
      let s = Object.assign({}, i), l = s.className || o.className;
      n.p = Object.assign({ theme: Gk && Gk() }, s), n.o = / *go\d+/.test(l), s.className = a0.apply(n, r) + (l ? " " + l : "");
      let u = e;
      return e[0] && (u = s.as || e, delete s.as), Kk && u[0] && Kk(s), JK(u, s);
    }
    return o;
  };
}
var lBe = (e) => typeof e == "function", uBe = (e, t) => lBe(e) ? e(t) : e, cBe = /* @__PURE__ */ (() => {
  let e;
  return () => {
    if (e === void 0 && typeof window < "u") {
      let t = matchMedia("(prefers-reduced-motion: reduce)");
      e = !t || t.matches;
    }
    return e;
  };
})(), pBe = da`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`, dBe = da`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`, fBe = da`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`, hBe = Ml("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${pBe} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${dBe} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${(e) => e.secondary || "#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${fBe} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`, gBe = da`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, mBe = Ml("div")`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${(e) => e.secondary || "#e0e0e0"};
  border-right-color: ${(e) => e.primary || "#616161"};
  animation: ${gBe} 1s linear infinite;
`, vBe = da`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`, yBe = da`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`, bBe = Ml("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${vBe} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${yBe} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${(e) => e.secondary || "#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`, wBe = Ml("div")`
  position: absolute;
`, CBe = Ml("div")`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`, xBe = da`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`, OBe = Ml("div")`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${xBe} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`, EBe = ({ toast: e }) => {
  let { icon: t, type: n, iconTheme: r } = e;
  return t !== void 0 ? typeof t == "string" ? Be.createElement(OBe, null, t) : t : n === "blank" ? null : Be.createElement(CBe, null, Be.createElement(mBe, { ...r }), n !== "loading" && Be.createElement(wBe, null, n === "error" ? Be.createElement(hBe, { ...r }) : Be.createElement(bBe, { ...r })));
}, kBe = (e) => `
0% {transform: translate3d(0,${e * -200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`, LBe = (e) => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${e * -150}%,-1px) scale(.6); opacity:0;}
`, PBe = "0%{opacity:0;} 100%{opacity:1;}", _Be = "0%{opacity:1;} 100%{opacity:0;}", SBe = Ml("div")`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`, MBe = Ml("div")`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`, DBe = (e, t) => {
  let n = e.includes("top") ? 1 : -1, [r, o] = cBe() ? [PBe, _Be] : [kBe(n), LBe(n)];
  return { animation: t ? `${da(r)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards` : `${da(o)} 0.4s forwards cubic-bezier(.06,.71,.55,1)` };
};
Be.memo(({ toast: e, position: t, style: n, children: r }) => {
  let o = e.height ? DBe(e.position || t || "top-center", e.visible) : { opacity: 0 }, i = Be.createElement(EBe, { toast: e }), a = Be.createElement(MBe, { ...e.ariaProps }, uBe(e.message, e));
  return Be.createElement(SBe, { className: e.className, style: { ...o, ...n, ...e.style } }, typeof r == "function" ? r({ icon: i, message: a }) : Be.createElement(Be.Fragment, null, i, a));
});
aBe(Be.createElement);
a0`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`;
function K_(e) {
  const {
    isLoading: t = !1,
    scheme: n = "primary",
    variant: r = "solid",
    loadingText: o,
    size: i = "md",
    leftIcon: a,
    rightIcon: s,
    disabled: l,
    className: u = "",
    children: c,
    ...p
  } = e, d = { xs: 12, sm: 16, md: 20, lg: 24 }[i], g = `arkynButton ${t ? "loadingTrue" : "loadingFalse"} ${r} ${n} ${i} ${o ? "loadingTextTrue" : "loadingTextFalse"} ${u}`;
  return /* @__PURE__ */ Sn.jsxs("button", { className: g, disabled: l || t, ...p, children: [
    /* @__PURE__ */ Sn.jsxs("div", { className: "arkynButtonSpinner", children: [
      /* @__PURE__ */ Sn.jsx(Ts, { size: d, strokeWidth: 2.5 }),
      o && o
    ] }),
    /* @__PURE__ */ Sn.jsxs("div", { className: "arkynButtonContent", children: [
      $M(d, a),
      c,
      $M(d, s)
    ] })
  ] });
}
function TBe() {
  const e = k1(), t = F6(), n = L1(), [r, o] = k(null);
  function i(u, c) {
    return JSON.stringify(u) === JSON.stringify(c);
  }
  function a() {
    r && o(null);
  }
  h(() => {
    var u, c;
    let p = ((c = (u = n[0]) == null ? void 0 : u.data) == null ? void 0 : c.fieldErrors) || {};
    i(r, p) || Object.entries(p).length !== 0 && o(p);
  }, [n, e]), h(() => {
    var u;
    ((u = n[0]) == null ? void 0 : u.state) === "submitting" && a();
  }, [n, t]);
  const s = (e == null ? void 0 : e.fieldErrors) || r;
  let l = {};
  return Object.entries(s || {}).forEach(([u, c]) => {
    typeof c == "string" && typeof u == "string" && (l[u] = c);
  }), l;
}
Ke({});
function jBe(e) {
  const {
    isLoading: t = !1,
    scheme: n = "primary",
    variant: r = "solid",
    size: o = "md",
    icon: i,
    disabled: a,
    className: s = "",
    ...l
  } = e, u = { xs: 12, sm: 16, md: 20, lg: 24 }, c = `arkynIconButton ${r} ${n} ${o} ${t ? "loadingTrue" : "loadingFalse"} ${s}`;
  return /* @__PURE__ */ Sn.jsxs(
    "button",
    {
      disabled: a || t,
      className: c.trim(),
      ...l,
      children: [
        /* @__PURE__ */ Sn.jsx("div", { className: "arkynIconButtonSpinner", children: /* @__PURE__ */ Sn.jsx(Ts, { size: u[o], strokeWidth: 2.5 }) }),
        /* @__PURE__ */ Sn.jsx("div", { className: "arkynIconButtonContent", children: /* @__PURE__ */ Sn.jsx(i, { size: u[o], strokeWidth: 2.5 }) })
      ]
    }
  );
}
function ABe(e) {
  const {
    text: t,
    size: n = "lg",
    children: r,
    orientation: o = "top",
    className: i = "",
    ...a
  } = e, s = `arkynTooltip ${n} ${o} ${i}`;
  return /* @__PURE__ */ Sn.jsxs("div", { className: s.trim(), ...a, children: [
    r,
    /* @__PURE__ */ Sn.jsx("div", { className: "arkynTooltipText", children: t })
  ] });
}
function IBe(e) {
  return e && e.replace(/[^0-9]/g, "");
}
const RBe = {
  CNPJ: "99.999.999/9999-99"
};
IBe(RBe.CNPJ).length;
to((e, t) => /* @__PURE__ */ Sn.jsx("input", { ref: t, ...e }));
function QK(e) {
  return e && e.replace(/[^0-9]/g, "");
}
const eY = {
  EIGTH: "(99) 9999-9999",
  NINE: "(99) 99999-9999"
};
function BBe(e, t) {
  let n = "", r = 0;
  for (let o = 0; o < t.length; o++)
    if (t[o] === "9")
      if (r < e.length)
        n += e[r], r++;
      else
        break;
    else if (r < e.length)
      n += t[o];
    else
      break;
  return n;
}
function NBe(e) {
  return e.length > 10 ? "NINE" : "EIGTH";
}
const FBe = QK(eY.NINE).length, zBe = to((e, t) => /* @__PURE__ */ Sn.jsx("input", { ref: t, ...e }));
to(
  (e, t) => {
    const { onFocus: n, onBlur: r, size: o, onChange: i, value: a, currentCountry: s, disabled: l } = e, [u, c] = k(!1);
    h(() => {
      u ? i(s.mask) : c(!0);
    }, [s]);
    const p = `phoneInputMask ${o}`;
    function d(g) {
      let f = QK(g.target.value);
      const m = NBe(f);
      f.length > FBe || (f = BBe(f, eY[m]), g.target.value = f, i(f));
    }
    return s.code === "+55" ? /* @__PURE__ */ Sn.jsx(
      "input",
      {
        value: a,
        onChange: d,
        className: p,
        onFocus: n,
        onBlur: r,
        disabled: l,
        ref: t
      }
    ) : /* @__PURE__ */ Sn.jsx(
      cl,
      {
        value: a,
        onChange: (g) => i(g.target.value),
        className: p,
        component: zBe,
        onFocus: n,
        onBlur: r,
        disabled: l,
        mask: s.mask,
        showMask: !0,
        replacement: { _: /\d/ },
        ref: t
      }
    );
  }
);
Ke({});
var wa = {};
Object.defineProperty(wa, "__esModule", {
  value: !0
});
var UBe = typeof window < "u" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform), eO = {
  alt: "altKey",
  control: "ctrlKey",
  meta: "metaKey",
  shift: "shiftKey"
}, tY = {
  add: "+",
  break: "pause",
  cmd: "meta",
  command: "meta",
  ctl: "control",
  ctrl: "control",
  del: "delete",
  down: "arrowdown",
  esc: "escape",
  ins: "insert",
  left: "arrowleft",
  mod: UBe ? "meta" : "control",
  opt: "alt",
  option: "alt",
  return: "enter",
  right: "arrowright",
  space: " ",
  spacebar: " ",
  up: "arrowup",
  win: "meta",
  windows: "meta"
}, Y_ = {
  backspace: 8,
  tab: 9,
  enter: 13,
  shift: 16,
  control: 17,
  alt: 18,
  pause: 19,
  capslock: 20,
  escape: 27,
  " ": 32,
  pageup: 33,
  pagedown: 34,
  end: 35,
  home: 36,
  arrowleft: 37,
  arrowup: 38,
  arrowright: 39,
  arrowdown: 40,
  insert: 45,
  delete: 46,
  meta: 91,
  numlock: 144,
  scrolllock: 145,
  ";": 186,
  "=": 187,
  ",": 188,
  "-": 189,
  ".": 190,
  "/": 191,
  "`": 192,
  "[": 219,
  "\\": 220,
  "]": 221,
  "'": 222
};
for (var Xg = 1; Xg < 20; Xg++)
  Y_["f" + Xg] = 111 + Xg;
function l0(e, t, n) {
  t && !("byKey" in t) && (n = t, t = null), Array.isArray(e) || (e = [e]);
  var r = e.map(function(a) {
    return nY(a, t);
  }), o = function(a) {
    return r.some(function(s) {
      return rY(s, a);
    });
  }, i = n == null ? o : o(n);
  return i;
}
function HBe(e, t) {
  return l0(e, t);
}
function $Be(e, t) {
  return l0(e, { byKey: !0 }, t);
}
function nY(e, t) {
  var n = t && t.byKey, r = {};
  e = e.replace("++", "+add");
  var o = e.split("+"), i = o.length;
  for (var a in eO)
    r[eO[a]] = !1;
  var s = !0, l = !1, u = void 0;
  try {
    for (var c = o[Symbol.iterator](), p; !(s = (p = c.next()).done); s = !0) {
      var d = p.value, g = d.endsWith("?") && d.length > 1;
      g && (d = d.slice(0, -1));
      var f = X_(d), m = eO[f];
      if (d.length > 1 && !m && !tY[d] && !Y_[f])
        throw new TypeError('Unknown modifier: "' + d + '"');
      (i === 1 || !m) && (n ? r.key = f : r.which = oY(d)), m && (r[m] = g ? null : !0);
    }
  } catch (v) {
    l = !0, u = v;
  } finally {
    try {
      !s && c.return && c.return();
    } finally {
      if (l)
        throw u;
    }
  }
  return r;
}
function rY(e, t) {
  for (var n in e) {
    var r = e[n], o = void 0;
    if (r != null && (n === "key" && t.key != null ? o = t.key.toLowerCase() : n === "which" ? o = r === 91 && t.which === 93 ? 91 : t.which : o = t[n], !(o == null && r === !1) && o !== r))
      return !1;
  }
  return !0;
}
function oY(e) {
  e = X_(e);
  var t = Y_[e] || e.toUpperCase().charCodeAt(0);
  return t;
}
function X_(e) {
  return e = e.toLowerCase(), e = tY[e] || e, e;
}
wa.default = l0;
var tO = wa.isHotkey = l0;
wa.isCodeHotkey = HBe;
wa.isKeyHotkey = $Be;
wa.parseHotkey = nY;
wa.compareHotkey = rY;
wa.toKeyCode = oY;
wa.toKeyName = X_;
var WBe = typeof Jn == "object" && Jn && Jn.Object === Object && Jn, VBe = WBe, ZBe = VBe, qBe = typeof self == "object" && self && self.Object === Object && self, GBe = ZBe || qBe || Function("return this")(), KBe = GBe, YBe = KBe, XBe = YBe.Symbol, iY = XBe, Z$ = iY;
Z$ && Z$.toStringTag;
var q$ = iY;
q$ && q$.toStringTag;
var G$;
(function(e) {
  e.BORDER_BOX = "border-box", e.CONTENT_BOX = "content-box", e.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(G$ || (G$ = {}));
var J_ = function(e) {
  return Object.freeze(e);
}, JBe = /* @__PURE__ */ function() {
  function e(t, n) {
    this.inlineSize = t, this.blockSize = n, J_(this);
  }
  return e;
}(), QBe = function() {
  function e(t, n, r, o) {
    return this.x = t, this.y = n, this.width = r, this.height = o, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, J_(this);
  }
  return e.prototype.toJSON = function() {
    var t = this, n = t.x, r = t.y, o = t.top, i = t.right, a = t.bottom, s = t.left, l = t.width, u = t.height;
    return { x: n, y: r, top: o, right: i, bottom: a, left: s, width: l, height: u };
  }, e.fromRect = function(t) {
    return new e(t.x, t.y, t.width, t.height);
  }, e;
}(), K$ = typeof window < "u" ? window : {};
/msie|trident/i.test(K$.navigator && K$.navigator.userAgent);
var nO = function(e, t, n) {
  return e === void 0 && (e = 0), t === void 0 && (t = 0), n === void 0 && (n = !1), new JBe((n ? t : e) || 0, (n ? e : t) || 0);
};
J_({
  devicePixelContentBoxSize: nO(),
  borderBoxSize: nO(),
  contentBoxSize: nO(),
  contentRect: new QBe(0, 0, 0, 0)
});
function uf(e) {
  "@babel/helpers - typeof";
  return uf = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, uf(e);
}
function eNe(e, t) {
  if (uf(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (uf(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function tNe(e) {
  var t = eNe(e, "string");
  return uf(t) === "symbol" ? t : String(t);
}
function cd(e, t, n) {
  return t = tNe(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
var nNe = /* @__PURE__ */ Ke(null), rO, oO;
parseInt(we.version.split(".")[0], 10);
var Y$ = typeof navigator < "u" && /Mac OS X/.test(navigator.userAgent), iO = typeof navigator < "u" && /Android/.test(navigator.userAgent), Jg = typeof navigator < "u" && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent), rNe = typeof navigator < "u" && /Chrome/i.test(navigator.userAgent);
typeof navigator < "u" && /Safari/.test(navigator.userAgent) && /Version\/(\d+)/.test(navigator.userAgent) && (rO = navigator.userAgent.match(/Version\/(\d+)/)) !== null && rO !== void 0 && rO[1] && parseInt((oO = navigator.userAgent.match(/Version\/(\d+)/)) === null || oO === void 0 ? void 0 : oO[1], 10) < 17;
var oNe = /* @__PURE__ */ new WeakMap(), iNe = /* @__PURE__ */ new WeakMap(), sNe = /* @__PURE__ */ new WeakMap(), aNe = /* @__PURE__ */ new WeakMap(), lNe = /* @__PURE__ */ new WeakMap(), X$ = /* @__PURE__ */ new WeakMap(), uNe = /* @__PURE__ */ new WeakMap(), J$ = /* @__PURE__ */ new WeakMap(), Qg = /* @__PURE__ */ new WeakMap(), cNe = /* @__PURE__ */ new WeakMap(), pNe = /* @__PURE__ */ new WeakMap(), dNe = /* @__PURE__ */ new WeakMap(), sY = globalThis.Node, fNe = globalThis.Text, aY = (e) => e && e.ownerDocument && e.ownerDocument.defaultView || null, hNe = (e) => Oy(e) && e.nodeType === 8, Ds = (e) => Oy(e) && e.nodeType === 1, Oy = (e) => {
  var t = aY(e);
  return !!t && e instanceof t.Node;
}, Q$ = (e) => {
  var t = e && e.anchorNode && aY(e.anchorNode);
  return !!t && e instanceof t.Selection;
}, gNe = (e) => {
  var [t, n] = e;
  if (Ds(t) && t.childNodes.length) {
    var r = n === t.childNodes.length, o = r ? n - 1 : n;
    for ([t, o] = lY(t, o, r ? "backward" : "forward"), r = o < n; Ds(t) && t.childNodes.length; ) {
      var i = r ? t.childNodes.length - 1 : 0;
      t = vNe(t, i, r ? "backward" : "forward");
    }
    n = r && t.textContent != null ? t.textContent.length : 0;
  }
  return [t, n];
}, mNe = (e) => {
  for (var t = e && e.parentNode; t; ) {
    if (t.toString() === "[object ShadowRoot]")
      return !0;
    t = t.parentNode;
  }
  return !1;
}, lY = (e, t, n) => {
  for (var {
    childNodes: r
  } = e, o = r[t], i = t, a = !1, s = !1; (hNe(o) || Ds(o) && o.childNodes.length === 0 || Ds(o) && o.getAttribute("contenteditable") === "false") && !(a && s); ) {
    if (i >= r.length) {
      a = !0, i = t - 1, n = "backward";
      continue;
    }
    if (i < 0) {
      s = !0, i = t + 1, n = "forward";
      continue;
    }
    o = r[i], t = i, i += n === "forward" ? 1 : -1;
  }
  return [o, t];
}, vNe = (e, t, n) => {
  var [r] = lY(e, t, n);
  return r;
}, e3 = (e) => e.getSelection != null ? e.getSelection() : document.getSelection(), uY = (e, t, n) => {
  var {
    target: r
  } = t;
  if (Ds(r) && r.matches('[contentEditable="false"]'))
    return !1;
  var {
    document: o
  } = sn.getWindow(e);
  if (o.contains(r))
    return sn.hasDOMNode(e, r, {
      editable: !0
    });
  var i = n.find((a) => {
    var {
      addedNodes: s,
      removedNodes: l
    } = a;
    for (var u of s)
      if (u === r || u.contains(r))
        return !0;
    for (var c of l)
      if (c === r || c.contains(r))
        return !0;
  });
  return !i || i === t ? !1 : uY(e, i, n);
}, t3 = (e, t) => !!(e.compareDocumentPosition(t) & sY.DOCUMENT_POSITION_PRECEDING), yNe = (e, t) => !!(e.compareDocumentPosition(t) & sY.DOCUMENT_POSITION_FOLLOWING), bNe = 0;
class wNe {
  constructor() {
    cd(this, "id", void 0), this.id = "".concat(bNe++);
  }
}
var sn = {
  androidPendingDiffs: (e) => dNe.get(e),
  androidScheduleFlush: (e) => {
    var t;
    (t = pNe.get(e)) === null || t === void 0 || t();
  },
  blur: (e) => {
    var t = sn.toDOMNode(e, e), n = sn.findDocumentOrShadowRoot(e);
    Qg.set(e, !1), n.activeElement === t && t.blur();
  },
  deselect: (e) => {
    var {
      selection: t
    } = e, n = sn.findDocumentOrShadowRoot(e), r = e3(n);
    r && r.rangeCount > 0 && r.removeAllRanges(), t && Km.deselect(e);
  },
  findDocumentOrShadowRoot: (e) => {
    var t = sn.toDOMNode(e, e), n = t.getRootNode();
    return n instanceof Document || n instanceof ShadowRoot ? n : t.ownerDocument;
  },
  findEventRange: (e, t) => {
    "nativeEvent" in t && (t = t.nativeEvent);
    var {
      clientX: n,
      clientY: r,
      target: o
    } = t;
    if (n == null || r == null)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var i = sn.toSlateNode(e, t.target), a = sn.findPath(e, i);
    if (ea.isElement(i) && Vn.isVoid(e, i)) {
      var s = o.getBoundingClientRect(), l = e.isInline(i) ? n - s.left < s.left + s.width - n : r - s.top < s.top + s.height - r, u = Vn.point(e, a, {
        edge: l ? "start" : "end"
      }), c = l ? Vn.before(e, u) : Vn.after(e, u);
      if (c) {
        var p = Vn.range(e, c);
        return p;
      }
    }
    var d, {
      document: g
    } = sn.getWindow(e);
    if (g.caretRangeFromPoint)
      d = g.caretRangeFromPoint(n, r);
    else {
      var f = g.caretPositionFromPoint(n, r);
      f && (d = g.createRange(), d.setStart(f.offsetNode, f.offset), d.setEnd(f.offsetNode, f.offset));
    }
    if (!d)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var m = sn.toSlateRange(e, d, {
      exactMatch: !1,
      suppressThrow: !1
    });
    return m;
  },
  findKey: (e, t) => {
    var n = X$.get(t);
    return n || (n = new wNe(), X$.set(t, n)), n;
  },
  findPath: (e, t) => {
    for (var n = [], r = t; ; ) {
      var o = iNe.get(r);
      if (o == null) {
        if (Vn.isEditor(r))
          return n;
        break;
      }
      var i = oNe.get(r);
      if (i == null)
        break;
      n.unshift(i), r = o;
    }
    throw new Error("Unable to find the path for Slate node: ".concat(Pi.stringify(t)));
  },
  focus: function(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      retries: 5
    };
    if (!Qg.get(e)) {
      if (t.retries <= 0)
        throw new Error("Could not set focus, editor seems stuck with pending operations");
      if (e.operations.length > 0) {
        setTimeout(() => {
          sn.focus(e, {
            retries: t.retries - 1
          });
        }, 10);
        return;
      }
      var n = sn.toDOMNode(e, e), r = sn.findDocumentOrShadowRoot(e);
      if (r.activeElement !== n) {
        if (e.selection && r instanceof Document) {
          var o = e3(r), i = sn.toDOMRange(e, e.selection);
          o == null || o.removeAllRanges(), o == null || o.addRange(i);
        }
        e.selection || Km.select(e, Vn.start(e, [])), Qg.set(e, !0), n.focus({
          preventScroll: !0
        });
      }
    }
  },
  getWindow: (e) => {
    var t = sNe.get(e);
    if (!t)
      throw new Error("Unable to find a host window element for this editor");
    return t;
  },
  hasDOMNode: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      editable: r = !1
    } = n, o = sn.toDOMNode(e, e), i;
    try {
      i = Ds(t) ? t : t.parentElement;
    } catch (a) {
      if (a instanceof Error && !a.message.includes('Permission denied to access property "nodeType"'))
        throw a;
    }
    return i ? i.closest("[data-slate-editor]") === o && (!r || i.isContentEditable ? !0 : typeof i.isContentEditable == "boolean" && // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined
    // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable="false"(readOnly)
    i.closest('[contenteditable="false"]') === o || !!i.getAttribute("data-slate-zero-width")) : !1;
  },
  hasEditableTarget: (e, t) => Oy(t) && sn.hasDOMNode(e, t, {
    editable: !0
  }),
  hasRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t;
    return Vn.hasPath(e, n.path) && Vn.hasPath(e, r.path);
  },
  hasSelectableTarget: (e, t) => sn.hasEditableTarget(e, t) || sn.isTargetInsideNonReadonlyVoid(e, t),
  hasTarget: (e, t) => Oy(t) && sn.hasDOMNode(e, t),
  insertData: (e, t) => {
    e.insertData(t);
  },
  insertFragmentData: (e, t) => e.insertFragmentData(t),
  insertTextData: (e, t) => e.insertTextData(t),
  isComposing: (e) => !!cNe.get(e),
  isFocused: (e) => !!Qg.get(e),
  isReadOnly: (e) => !!J$.get(e),
  isTargetInsideNonReadonlyVoid: (e, t) => {
    if (J$.get(e)) return !1;
    var n = sn.hasTarget(e, t) && sn.toSlateNode(e, t);
    return ea.isElement(n) && Vn.isVoid(e, n);
  },
  setFragmentData: (e, t, n) => e.setFragmentData(t, n),
  toDOMNode: (e, t) => {
    var n = uNe.get(e), r = Vn.isEditor(t) ? aNe.get(e) : n == null ? void 0 : n.get(sn.findKey(e, t));
    if (!r)
      throw new Error("Cannot resolve a DOM node from Slate node: ".concat(Pi.stringify(t)));
    return r;
  },
  toDOMPoint: (e, t) => {
    var [n] = Vn.node(e, t.path), r = sn.toDOMNode(e, n), o;
    Vn.void(e, {
      at: t
    }) && (t = {
      path: t.path,
      offset: 0
    });
    for (var i = "[data-slate-string], [data-slate-zero-width]", a = Array.from(r.querySelectorAll(i)), s = 0, l = 0; l < a.length; l++) {
      var u = a[l], c = u.childNodes[0];
      if (!(c == null || c.textContent == null)) {
        var {
          length: p
        } = c.textContent, d = u.getAttribute("data-slate-length"), g = d == null ? p : parseInt(d, 10), f = s + g, m = a[l + 1];
        if (t.offset === f && m !== null && m !== void 0 && m.hasAttribute("data-slate-mark-placeholder")) {
          var v, E = m.childNodes[0];
          o = [
            // COMPAT: If we don't explicity set the dom point to be on the actual
            // dom text element, chrome will put the selection behind the actual dom
            // text element, causing domRange.getBoundingClientRect() calls on a collapsed
            // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)
            // which will cause issues when scrolling to it.
            E instanceof fNe ? E : m,
            (v = m.textContent) !== null && v !== void 0 && v.startsWith("\uFEFF") ? 1 : 0
          ];
          break;
        }
        if (t.offset <= f) {
          var w = Math.min(p, Math.max(0, t.offset - s));
          o = [c, w];
          break;
        }
        s = f;
      }
    }
    if (!o)
      throw new Error("Cannot resolve a DOM point from Slate point: ".concat(Pi.stringify(t)));
    return o;
  },
  toDOMRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t, o = Ft.isBackward(t), i = sn.toDOMPoint(e, n), a = Ft.isCollapsed(t) ? i : sn.toDOMPoint(e, r), s = sn.getWindow(e), l = s.document.createRange(), [u, c] = o ? a : i, [p, d] = o ? i : a, g = Ds(u) ? u : u.parentElement, f = !!g.getAttribute("data-slate-zero-width"), m = Ds(p) ? p : p.parentElement, v = !!m.getAttribute("data-slate-zero-width");
    return l.setStart(u, f ? 1 : c), l.setEnd(p, v ? 1 : d), l;
  },
  toSlateNode: (e, t) => {
    var n = Ds(t) ? t : t.parentElement;
    n && !n.hasAttribute("data-slate-node") && (n = n.closest("[data-slate-node]"));
    var r = n ? lNe.get(n) : null;
    if (!r)
      throw new Error("Cannot resolve a Slate node from DOM node: ".concat(n));
    return r;
  },
  toSlatePoint: (e, t, n) => {
    var {
      exactMatch: r,
      suppressThrow: o,
      searchDirection: i = "backward"
    } = n, [a, s] = r ? t : gNe(t), l = a.parentNode, u = null, c = 0;
    if (l) {
      var p, d, g = sn.toDOMNode(e, e), f = l.closest('[data-slate-void="true"]'), m = f && g.contains(f) ? f : null, v = l.closest('[contenteditable="false"]'), E = v && g.contains(v) ? v : null, w = l.closest("[data-slate-leaf]"), M = null;
      if (w) {
        if (u = w.closest('[data-slate-node="text"]'), u) {
          var O = sn.getWindow(e), y = O.document.createRange();
          y.setStart(u, 0), y.setEnd(a, s);
          var C = y.cloneContents(), _ = [...Array.prototype.slice.call(C.querySelectorAll("[data-slate-zero-width]")), ...Array.prototype.slice.call(C.querySelectorAll("[contenteditable=false]"))];
          _.forEach((S) => {
            if (iO && !r && S.hasAttribute("data-slate-zero-width") && S.textContent.length > 0 && S.textContext !== "\uFEFF") {
              S.textContent.startsWith("\uFEFF") && (S.textContent = S.textContent.slice(1));
              return;
            }
            S.parentNode.removeChild(S);
          }), c = C.textContent.length, M = u;
        }
      } else if (m) {
        for (var F = m.querySelectorAll("[data-slate-leaf]"), L = 0; L < F.length; L++) {
          var N = F[L];
          if (sn.hasDOMNode(e, N)) {
            w = N;
            break;
          }
        }
        w ? (u = w.closest('[data-slate-node="text"]'), M = w, c = M.textContent.length, M.querySelectorAll("[data-slate-zero-width]").forEach((S) => {
          c -= S.textContent.length;
        })) : c = 1;
      } else if (E) {
        var R = (S) => S ? S.querySelectorAll(
          // Exclude leaf nodes in nested editors
          "[data-slate-leaf]:not(:scope [data-slate-editor] [data-slate-leaf])"
        ) : [], W = E.closest('[data-slate-node="element"]');
        if (i === "forward") {
          var V, z = [...R(W), ...R(W == null ? void 0 : W.nextElementSibling)];
          w = (V = z.find((S) => yNe(E, S))) !== null && V !== void 0 ? V : null;
        } else {
          var Z, K = [...R(W == null ? void 0 : W.previousElementSibling), ...R(W)];
          w = (Z = K.findLast((S) => t3(E, S))) !== null && Z !== void 0 ? Z : null;
        }
        w && (u = w.closest('[data-slate-node="text"]'), M = w, i === "forward" ? c = 0 : (c = M.textContent.length, M.querySelectorAll("[data-slate-zero-width]").forEach((S) => {
          c -= S.textContent.length;
        })));
      }
      M && c === M.textContent.length && // COMPAT: Android IMEs might remove the zero width space while composing,
      // and we don't add it for line-breaks.
      iO && M.getAttribute("data-slate-zero-width") === "z" && (p = M.textContent) !== null && p !== void 0 && p.startsWith("\uFEFF") && // COMPAT: If the parent node is a Slate zero-width space, editor is
      // because the text node should have no characters. However, during IME
      // composition the ASCII characters will be prepended to the zero-width
      // space, so subtract 1 from the offset to account for the zero-width
      // space character.
      (l.hasAttribute("data-slate-zero-width") || // COMPAT: In Firefox, `range.cloneContents()` returns an extra trailing '\n'
      // when the document ends with a new-line character. This results in the offset
      // length being off by one, so we need to subtract one to account for this.
      Jg && (d = M.textContent) !== null && d !== void 0 && d.endsWith(`

`)) && c--;
    }
    if (iO && !u && !r) {
      var X = l.hasAttribute("data-slate-node") ? l : l.closest("[data-slate-node]");
      if (X && sn.hasDOMNode(e, X, {
        editable: !0
      })) {
        var te = sn.toSlateNode(e, X), {
          path: J,
          offset: P
        } = Vn.start(e, sn.findPath(e, te));
        return X.querySelector("[data-slate-leaf]") || (P = s), {
          path: J,
          offset: P
        };
      }
    }
    if (!u) {
      if (o)
        return null;
      throw new Error("Cannot resolve a Slate point from DOM point: ".concat(t));
    }
    var D = sn.toSlateNode(e, u), H = sn.findPath(e, D);
    return {
      path: H,
      offset: c
    };
  },
  toSlateRange: (e, t, n) => {
    var r, {
      exactMatch: o,
      suppressThrow: i
    } = n, a = Q$(t) ? t.anchorNode : t.startContainer, s, l, u, c, p;
    if (a)
      if (Q$(t)) {
        if (Jg && t.rangeCount > 1) {
          u = t.focusNode;
          var d = t.getRangeAt(0), g = t.getRangeAt(t.rangeCount - 1);
          if (u instanceof HTMLTableRowElement && d.startContainer instanceof HTMLTableRowElement && g.startContainer instanceof HTMLTableRowElement) {
            let C = function(_) {
              return _.childElementCount > 0 ? C(_.children[0]) : _;
            };
            var f = d.startContainer, m = g.startContainer, v = C(f.children[d.startOffset]), E = C(m.children[g.startOffset]);
            c = 0, E.childNodes.length > 0 ? s = E.childNodes[0] : s = E, v.childNodes.length > 0 ? u = v.childNodes[0] : u = v, E instanceof HTMLElement ? l = E.innerHTML.length : l = 0;
          } else
            d.startContainer === u ? (s = g.endContainer, l = g.endOffset, c = d.startOffset) : (s = d.startContainer, l = d.endOffset, c = g.startOffset);
        } else
          s = t.anchorNode, l = t.anchorOffset, u = t.focusNode, c = t.focusOffset;
        rNe && mNe(s) || Jg ? p = t.anchorNode === t.focusNode && t.anchorOffset === t.focusOffset : p = t.isCollapsed;
      } else
        s = t.startContainer, l = t.startOffset, u = t.endContainer, c = t.endOffset, p = t.collapsed;
    if (s == null || u == null || l == null || c == null)
      throw new Error("Cannot resolve a Slate range from DOM range: ".concat(t));
    Jg && (r = u.textContent) !== null && r !== void 0 && r.endsWith(`

`) && c === u.textContent.length && c--;
    var w = sn.toSlatePoint(e, [s, l], {
      exactMatch: o,
      suppressThrow: i
    });
    if (!w)
      return null;
    var M = t3(s, u) || s === u && c < l, O = p ? w : sn.toSlatePoint(e, [u, c], {
      exactMatch: o,
      suppressThrow: i,
      searchDirection: M ? "forward" : "backward"
    });
    if (!O)
      return null;
    var y = {
      anchor: w,
      focus: O
    };
    return Ft.isExpanded(y) && Ft.isForward(y) && Ds(u) && Vn.void(e, {
      at: y.focus,
      mode: "highest"
    }) && (y = Vn.unhangRange(e, y, {
      voids: !0
    })), y;
  }
}, CNe = {
  bold: "mod+b",
  compose: ["down", "left", "right", "up", "backspace", "enter"],
  moveBackward: "left",
  moveForward: "right",
  moveWordBackward: "ctrl+left",
  moveWordForward: "ctrl+right",
  deleteBackward: "shift?+backspace",
  deleteForward: "shift?+delete",
  extendBackward: "shift+left",
  extendForward: "shift+right",
  italic: "mod+i",
  insertSoftBreak: "shift+enter",
  splitBlock: "enter",
  undo: "mod+z"
}, xNe = {
  moveLineBackward: "opt+up",
  moveLineForward: "opt+down",
  moveWordBackward: "opt+left",
  moveWordForward: "opt+right",
  deleteBackward: ["ctrl+backspace", "ctrl+h"],
  deleteForward: ["ctrl+delete", "ctrl+d"],
  deleteLineBackward: "cmd+shift?+backspace",
  deleteLineForward: ["cmd+shift?+delete", "ctrl+k"],
  deleteWordBackward: "opt+shift?+backspace",
  deleteWordForward: "opt+shift?+delete",
  extendLineBackward: "opt+shift+up",
  extendLineForward: "opt+shift+down",
  redo: "cmd+shift+z",
  transposeCharacter: "ctrl+t"
}, ONe = {
  deleteWordBackward: "ctrl+shift?+backspace",
  deleteWordForward: "ctrl+shift?+delete",
  redo: ["ctrl+y", "ctrl+shift+z"]
}, Rr = (e) => {
  var t = CNe[e], n = xNe[e], r = ONe[e], o = t && tO(t), i = n && tO(n), a = r && tO(r);
  return (s) => !!(o && o(s) || Y$ && i && i(s) || !Y$ && a && a(s));
};
Rr("bold"), Rr("compose"), Rr("moveBackward"), Rr("moveForward"), Rr("deleteBackward"), Rr("deleteForward"), Rr("deleteLineBackward"), Rr("deleteLineForward"), Rr("deleteWordBackward"), Rr("deleteWordForward"), Rr("extendBackward"), Rr("extendForward"), Rr("extendLineBackward"), Rr("extendLineForward"), Rr("italic"), Rr("moveLineBackward"), Rr("moveLineForward"), Rr("moveWordBackward"), Rr("moveWordForward"), Rr("redo"), Rr("insertSoftBreak"), Rr("splitBlock"), Rr("transposeCharacter"), Rr("undo");
var ENe = (e, t) => {
  var n = [], r = () => {
    n = [];
  }, o = (a) => {
    if (t.current) {
      var s = a.filter((l) => uY(e, l, a));
      n.push(...s);
    }
  };
  function i() {
    n.length > 0 && (n.reverse().forEach((a) => {
      a.type !== "characterData" && (a.removedNodes.forEach((s) => {
        a.target.insertBefore(s, a.nextSibling);
      }), a.addedNodes.forEach((s) => {
        a.target.removeChild(s);
      }));
    }), r());
  }
  return {
    registerMutations: o,
    restoreDOM: i,
    clear: r
  };
}, kNe = {
  subtree: !0,
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0
};
class LNe extends Wu {
  constructor() {
    super(...arguments), cd(this, "context", null), cd(this, "manager", null), cd(this, "mutationObserver", null);
  }
  observe() {
    var t, {
      node: n
    } = this.props;
    if (!n.current)
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    (t = this.mutationObserver) === null || t === void 0 || t.observe(n.current, kNe);
  }
  componentDidMount() {
    var {
      receivedUserInput: t
    } = this.props, n = this.context;
    this.manager = ENe(n, t), this.mutationObserver = new MutationObserver(this.manager.registerMutations), this.observe();
  }
  getSnapshotBeforeUpdate() {
    var t, n, r, o = (t = this.mutationObserver) === null || t === void 0 ? void 0 : t.takeRecords();
    if (o != null && o.length) {
      var i;
      (i = this.manager) === null || i === void 0 || i.registerMutations(o);
    }
    return (n = this.mutationObserver) === null || n === void 0 || n.disconnect(), (r = this.manager) === null || r === void 0 || r.restoreDOM(), null;
  }
  componentDidUpdate() {
    var t;
    (t = this.manager) === null || t === void 0 || t.clear(), this.observe();
  }
  componentWillUnmount() {
    var t;
    (t = this.mutationObserver) === null || t === void 0 || t.disconnect();
  }
  render() {
    return this.props.children;
  }
}
cd(LNe, "contextType", nNe);
Ke({});
Ke({});
Ke({});
var ho = {}, Q_ = {}, Jf = {}, Qf = {}, cY = "Expected a function", n3 = NaN, PNe = "[object Symbol]", _Ne = /^\s+|\s+$/g, SNe = /^[-+]0x[0-9a-f]+$/i, MNe = /^0b[01]+$/i, DNe = /^0o[0-7]+$/i, TNe = parseInt, jNe = typeof Jn == "object" && Jn && Jn.Object === Object && Jn, ANe = typeof self == "object" && self && self.Object === Object && self, INe = jNe || ANe || Function("return this")(), RNe = Object.prototype, BNe = RNe.toString, NNe = Math.max, FNe = Math.min, sO = function() {
  return INe.Date.now();
};
function zNe(e, t, n) {
  var r, o, i, a, s, l, u = 0, c = !1, p = !1, d = !0;
  if (typeof e != "function")
    throw new TypeError(cY);
  t = r3(t) || 0, Ey(n) && (c = !!n.leading, p = "maxWait" in n, i = p ? NNe(r3(n.maxWait) || 0, t) : i, d = "trailing" in n ? !!n.trailing : d);
  function g(C) {
    var _ = r, F = o;
    return r = o = void 0, u = C, a = e.apply(F, _), a;
  }
  function f(C) {
    return u = C, s = setTimeout(E, t), c ? g(C) : a;
  }
  function m(C) {
    var _ = C - l, F = C - u, L = t - _;
    return p ? FNe(L, i - F) : L;
  }
  function v(C) {
    var _ = C - l, F = C - u;
    return l === void 0 || _ >= t || _ < 0 || p && F >= i;
  }
  function E() {
    var C = sO();
    if (v(C))
      return w(C);
    s = setTimeout(E, m(C));
  }
  function w(C) {
    return s = void 0, d && r ? g(C) : (r = o = void 0, a);
  }
  function M() {
    s !== void 0 && clearTimeout(s), u = 0, r = l = o = s = void 0;
  }
  function O() {
    return s === void 0 ? a : w(sO());
  }
  function y() {
    var C = sO(), _ = v(C);
    if (r = arguments, o = this, l = C, _) {
      if (s === void 0)
        return f(l);
      if (p)
        return s = setTimeout(E, t), g(l);
    }
    return s === void 0 && (s = setTimeout(E, t)), a;
  }
  return y.cancel = M, y.flush = O, y;
}
function UNe(e, t, n) {
  var r = !0, o = !0;
  if (typeof e != "function")
    throw new TypeError(cY);
  return Ey(n) && (r = "leading" in n ? !!n.leading : r, o = "trailing" in n ? !!n.trailing : o), zNe(e, t, {
    leading: r,
    maxWait: t,
    trailing: o
  });
}
function Ey(e) {
  var t = typeof e;
  return !!e && (t == "object" || t == "function");
}
function HNe(e) {
  return !!e && typeof e == "object";
}
function $Ne(e) {
  return typeof e == "symbol" || HNe(e) && BNe.call(e) == PNe;
}
function r3(e) {
  if (typeof e == "number")
    return e;
  if ($Ne(e))
    return n3;
  if (Ey(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = Ey(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = e.replace(_Ne, "");
  var n = MNe.test(e);
  return n || DNe.test(e) ? TNe(e.slice(2), n ? 2 : 8) : SNe.test(e) ? n3 : +e;
}
var WNe = UNe, eh = {};
Object.defineProperty(eh, "__esModule", {
  value: !0
});
eh.addPassiveEventListener = function(e, t, n) {
  var r = n.name;
  r || (r = t, console.warn("Listener must be a named function.")), Tm.has(t) || Tm.set(t, /* @__PURE__ */ new Set());
  var o = Tm.get(t);
  if (!o.has(r)) {
    var i = function() {
      var a = !1;
      try {
        var s = Object.defineProperty({}, "passive", {
          get: function() {
            a = !0;
          }
        });
        window.addEventListener("test", null, s);
      } catch {
      }
      return a;
    }();
    e.addEventListener(t, n, i ? { passive: !0 } : !1), o.add(r);
  }
};
eh.removePassiveEventListener = function(e, t, n) {
  e.removeEventListener(t, n), Tm.get(t).delete(n.name || t);
};
var Tm = /* @__PURE__ */ new Map();
Object.defineProperty(Qf, "__esModule", {
  value: !0
});
var VNe = WNe, ZNe = qNe(VNe), o3 = eh;
function qNe(e) {
  return e && e.__esModule ? e : { default: e };
}
var GNe = function(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 66;
  return (0, ZNe.default)(e, t);
}, Zr = {
  spyCallbacks: [],
  spySetState: [],
  scrollSpyContainers: [],
  mount: function(e, t) {
    if (e) {
      var n = GNe(function(r) {
        Zr.scrollHandler(e);
      }, t);
      return Zr.scrollSpyContainers.push(e), (0, o3.addPassiveEventListener)(e, "scroll", n), function() {
        (0, o3.removePassiveEventListener)(e, "scroll", n), Zr.scrollSpyContainers.splice(Zr.scrollSpyContainers.indexOf(e), 1);
      };
    }
    return function() {
    };
  },
  isMounted: function(e) {
    return Zr.scrollSpyContainers.indexOf(e) !== -1;
  },
  currentPositionX: function(e) {
    if (e === document) {
      var t = window.scrollY !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.scrollX : n ? document.documentElement.scrollLeft : document.body.scrollLeft;
    } else
      return e.scrollLeft;
  },
  currentPositionY: function(e) {
    if (e === document) {
      var t = window.scrollX !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.scrollY : n ? document.documentElement.scrollTop : document.body.scrollTop;
    } else
      return e.scrollTop;
  },
  scrollHandler: function(e) {
    var t = Zr.scrollSpyContainers[Zr.scrollSpyContainers.indexOf(e)].spyCallbacks || [];
    t.forEach(function(n) {
      return n(Zr.currentPositionX(e), Zr.currentPositionY(e));
    });
  },
  addStateHandler: function(e) {
    Zr.spySetState.push(e);
  },
  addSpyHandler: function(e, t) {
    var n = Zr.scrollSpyContainers[Zr.scrollSpyContainers.indexOf(t)];
    n.spyCallbacks || (n.spyCallbacks = []), n.spyCallbacks.push(e);
  },
  updateStates: function() {
    Zr.spySetState.forEach(function(e) {
      return e();
    });
  },
  unmount: function(e, t) {
    Zr.scrollSpyContainers.forEach(function(n) {
      return n.spyCallbacks && n.spyCallbacks.length && n.spyCallbacks.indexOf(t) > -1 && n.spyCallbacks.splice(n.spyCallbacks.indexOf(t), 1);
    }), Zr.spySetState && Zr.spySetState.length && Zr.spySetState.indexOf(e) > -1 && Zr.spySetState.splice(Zr.spySetState.indexOf(e), 1), document.removeEventListener("scroll", Zr.scrollHandler);
  },
  update: function() {
    return Zr.scrollSpyContainers.forEach(function(e) {
      return Zr.scrollHandler(e);
    });
  }
};
Qf.default = Zr;
var Nc = {}, th = {};
Object.defineProperty(th, "__esModule", {
  value: !0
});
var KNe = function(e, t) {
  var n = e.indexOf("#") === 0 ? e.substring(1) : e, r = n ? "#" + n : "", o = window && window.location, i = r ? o.pathname + o.search + r : o.pathname + o.search;
  t ? history.pushState(history.state, "", i) : history.replaceState(history.state, "", i);
}, YNe = function() {
  return window.location.hash.replace(/^#/, "");
}, XNe = function(e) {
  return function(t) {
    return e.contains ? e != t && e.contains(t) : !!(e.compareDocumentPosition(t) & 16);
  };
}, JNe = function(e) {
  return getComputedStyle(e).position !== "static";
}, aO = function(e, t) {
  for (var n = e.offsetTop, r = e.offsetParent; r && !t(r); )
    n += r.offsetTop, r = r.offsetParent;
  return { offsetTop: n, offsetParent: r };
}, QNe = function(e, t, n) {
  if (n)
    return e === document ? t.getBoundingClientRect().left + (window.scrollX || window.pageXOffset) : getComputedStyle(e).position !== "static" ? t.offsetLeft : t.offsetLeft - e.offsetLeft;
  if (e === document)
    return t.getBoundingClientRect().top + (window.scrollY || window.pageYOffset);
  if (JNe(e)) {
    if (t.offsetParent !== e) {
      var r = function(l) {
        return l === e || l === document;
      }, o = aO(t, r), i = o.offsetTop, a = o.offsetParent;
      if (a !== e)
        throw new Error("Seems containerElement is not an ancestor of the Element");
      return i;
    }
    return t.offsetTop;
  }
  if (t.offsetParent === e.offsetParent)
    return t.offsetTop - e.offsetTop;
  var s = function(l) {
    return l === document;
  };
  return aO(t, s).offsetTop - aO(e, s).offsetTop;
};
th.default = {
  updateHash: KNe,
  getHash: YNe,
  filterElementInContainer: XNe,
  scrollOffset: QNe
};
var u0 = {}, eS = {};
Object.defineProperty(eS, "__esModule", {
  value: !0
});
eS.default = {
  /*
   * https://github.com/oblador/angular-scroll (duScrollDefaultEasing)
   */
  defaultEasing: function(e) {
    return e < 0.5 ? Math.pow(e * 2, 2) / 2 : 1 - Math.pow((1 - e) * 2, 2) / 2;
  },
  /*
   * https://gist.github.com/gre/1650294
   */
  // no easing, no acceleration
  linear: function(e) {
    return e;
  },
  // accelerating from zero velocity
  easeInQuad: function(e) {
    return e * e;
  },
  // decelerating to zero velocity
  easeOutQuad: function(e) {
    return e * (2 - e);
  },
  // acceleration until halfway, then deceleration
  easeInOutQuad: function(e) {
    return e < 0.5 ? 2 * e * e : -1 + (4 - 2 * e) * e;
  },
  // accelerating from zero velocity 
  easeInCubic: function(e) {
    return e * e * e;
  },
  // decelerating to zero velocity 
  easeOutCubic: function(e) {
    return --e * e * e + 1;
  },
  // acceleration until halfway, then deceleration 
  easeInOutCubic: function(e) {
    return e < 0.5 ? 4 * e * e * e : (e - 1) * (2 * e - 2) * (2 * e - 2) + 1;
  },
  // accelerating from zero velocity 
  easeInQuart: function(e) {
    return e * e * e * e;
  },
  // decelerating to zero velocity 
  easeOutQuart: function(e) {
    return 1 - --e * e * e * e;
  },
  // acceleration until halfway, then deceleration
  easeInOutQuart: function(e) {
    return e < 0.5 ? 8 * e * e * e * e : 1 - 8 * --e * e * e * e;
  },
  // accelerating from zero velocity
  easeInQuint: function(e) {
    return e * e * e * e * e;
  },
  // decelerating to zero velocity
  easeOutQuint: function(e) {
    return 1 + --e * e * e * e * e;
  },
  // acceleration until halfway, then deceleration 
  easeInOutQuint: function(e) {
    return e < 0.5 ? 16 * e * e * e * e * e : 1 + 16 * --e * e * e * e * e;
  }
};
var tS = {};
Object.defineProperty(tS, "__esModule", {
  value: !0
});
var eFe = eh, tFe = ["mousedown", "wheel", "touchmove", "keydown"];
tS.default = {
  subscribe: function(e) {
    return typeof document < "u" && tFe.forEach(function(t) {
      return (0, eFe.addPassiveEventListener)(document, t, e);
    });
  }
};
var nh = {};
Object.defineProperty(nh, "__esModule", {
  value: !0
});
var Yk = {
  registered: {},
  scrollEvent: {
    register: function(e, t) {
      Yk.registered[e] = t;
    },
    remove: function(e) {
      Yk.registered[e] = null;
    }
  }
};
nh.default = Yk;
Object.defineProperty(u0, "__esModule", {
  value: !0
});
var nFe = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, rFe = th;
c0(rFe);
var oFe = eS, i3 = c0(oFe), iFe = tS, sFe = c0(iFe), aFe = nh, Es = c0(aFe);
function c0(e) {
  return e && e.__esModule ? e : { default: e };
}
var pY = function(e) {
  return i3.default[e.smooth] || i3.default.defaultEasing;
}, lFe = function(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}, uFe = function() {
  if (typeof window < "u")
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame;
}, Xk = function() {
  return uFe() || function(e, t, n) {
    window.setTimeout(e, n || 1e3 / 60, (/* @__PURE__ */ new Date()).getTime());
  };
}(), dY = function() {
  return {
    currentPosition: 0,
    startPosition: 0,
    targetPosition: 0,
    progress: 0,
    duration: 0,
    cancel: !1,
    target: null,
    containerElement: null,
    to: null,
    start: null,
    delta: null,
    percent: null,
    delayTimeout: null
  };
}, fY = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollLeft;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageXOffset : r ? document.documentElement.scrollLeft : document.body.scrollLeft;
}, hY = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollTop;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageYOffset : r ? document.documentElement.scrollTop : document.body.scrollTop;
}, cFe = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollWidth - t.offsetWidth;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollWidth, n.offsetWidth, r.clientWidth, r.scrollWidth, r.offsetWidth);
}, pFe = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollHeight - t.offsetHeight;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollHeight, n.offsetHeight, r.clientHeight, r.scrollHeight, r.offsetHeight);
}, dFe = function e(t, n, r) {
  var o = n.data;
  if (!n.ignoreCancelEvents && o.cancel) {
    Es.default.registered.end && Es.default.registered.end(o.to, o.target, o.currentPositionY);
    return;
  }
  if (o.delta = Math.round(o.targetPosition - o.startPosition), o.start === null && (o.start = r), o.progress = r - o.start, o.percent = o.progress >= o.duration ? 1 : t(o.progress / o.duration), o.currentPosition = o.startPosition + Math.ceil(o.delta * o.percent), o.containerElement && o.containerElement !== document && o.containerElement !== document.body ? n.horizontal ? o.containerElement.scrollLeft = o.currentPosition : o.containerElement.scrollTop = o.currentPosition : n.horizontal ? window.scrollTo(o.currentPosition, 0) : window.scrollTo(0, o.currentPosition), o.percent < 1) {
    var i = e.bind(null, t, n);
    Xk.call(window, i);
    return;
  }
  Es.default.registered.end && Es.default.registered.end(o.to, o.target, o.currentPosition);
}, nS = function(e) {
  e.data.containerElement = e ? e.containerId ? document.getElementById(e.containerId) : e.container && e.container.nodeType ? e.container : document : null;
}, rh = function(e, t, n, r) {
  t.data = t.data || dY(), window.clearTimeout(t.data.delayTimeout);
  var o = function() {
    t.data.cancel = !0;
  };
  if (sFe.default.subscribe(o), nS(t), t.data.start = null, t.data.cancel = !1, t.data.startPosition = t.horizontal ? fY(t) : hY(t), t.data.targetPosition = t.absolute ? e : e + t.data.startPosition, t.data.startPosition === t.data.targetPosition) {
    Es.default.registered.end && Es.default.registered.end(t.data.to, t.data.target, t.data.currentPosition);
    return;
  }
  t.data.delta = Math.round(t.data.targetPosition - t.data.startPosition), t.data.duration = lFe(t.duration)(t.data.delta), t.data.duration = isNaN(parseFloat(t.data.duration)) ? 1e3 : parseFloat(t.data.duration), t.data.to = n, t.data.target = r;
  var i = pY(t), a = dFe.bind(null, i, t);
  if (t && t.delay > 0) {
    t.data.delayTimeout = window.setTimeout(function() {
      Es.default.registered.begin && Es.default.registered.begin(t.data.to, t.data.target), Xk.call(window, a);
    }, t.delay);
    return;
  }
  Es.default.registered.begin && Es.default.registered.begin(t.data.to, t.data.target), Xk.call(window, a);
}, p0 = function(e) {
  return e = nFe({}, e), e.data = e.data || dY(), e.absolute = !0, e;
}, fFe = function(e) {
  rh(0, p0(e));
}, hFe = function(e, t) {
  rh(e, p0(t));
}, gFe = function(e) {
  e = p0(e), nS(e), rh(e.horizontal ? cFe(e) : pFe(e), e);
}, mFe = function(e, t) {
  t = p0(t), nS(t);
  var n = t.horizontal ? fY(t) : hY(t);
  rh(e + n, t);
};
u0.default = {
  animateTopScroll: rh,
  getAnimationType: pY,
  scrollToTop: fFe,
  scrollToBottom: gFe,
  scrollTo: hFe,
  scrollMore: mFe
};
Object.defineProperty(Nc, "__esModule", {
  value: !0
});
var vFe = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, yFe = th, bFe = rS(yFe), wFe = u0, CFe = rS(wFe), xFe = nh, em = rS(xFe);
function rS(e) {
  return e && e.__esModule ? e : { default: e };
}
var tm = {}, s3 = void 0;
Nc.default = {
  unmount: function() {
    tm = {};
  },
  register: function(e, t) {
    tm[e] = t;
  },
  unregister: function(e) {
    delete tm[e];
  },
  get: function(e) {
    return tm[e] || document.getElementById(e) || document.getElementsByName(e)[0] || document.getElementsByClassName(e)[0];
  },
  setActiveLink: function(e) {
    return s3 = e;
  },
  getActiveLink: function() {
    return s3;
  },
  scrollTo: function(e, t) {
    var n = this.get(e);
    if (!n) {
      console.warn("target Element not found");
      return;
    }
    t = vFe({}, t, { absolute: !1 });
    var r = t.containerId, o = t.container, i = void 0;
    r ? i = document.getElementById(r) : o && o.nodeType ? i = o : i = document, t.absolute = !0;
    var a = t.horizontal, s = bFe.default.scrollOffset(i, n, a) + (t.offset || 0);
    if (!t.smooth) {
      em.default.registered.begin && em.default.registered.begin(e, n), i === document ? t.horizontal ? window.scrollTo(s, 0) : window.scrollTo(0, s) : i.scrollTop = s, em.default.registered.end && em.default.registered.end(e, n);
      return;
    }
    CFe.default.animateTopScroll(s, t, e, n);
  }
};
var Jk = { exports: {} }, lO = { exports: {} }, In = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var a3;
function OFe() {
  if (a3) return In;
  a3 = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, g = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, m = e ? Symbol.for("react.block") : 60121, v = e ? Symbol.for("react.fundamental") : 60117, E = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
  function M(y) {
    if (typeof y == "object" && y !== null) {
      var C = y.$$typeof;
      switch (C) {
        case t:
          switch (y = y.type, y) {
            case l:
            case u:
            case r:
            case i:
            case o:
            case p:
              return y;
            default:
              switch (y = y && y.$$typeof, y) {
                case s:
                case c:
                case f:
                case g:
                case a:
                  return y;
                default:
                  return C;
              }
          }
        case n:
          return C;
      }
    }
  }
  function O(y) {
    return M(y) === u;
  }
  return In.AsyncMode = l, In.ConcurrentMode = u, In.ContextConsumer = s, In.ContextProvider = a, In.Element = t, In.ForwardRef = c, In.Fragment = r, In.Lazy = f, In.Memo = g, In.Portal = n, In.Profiler = i, In.StrictMode = o, In.Suspense = p, In.isAsyncMode = function(y) {
    return O(y) || M(y) === l;
  }, In.isConcurrentMode = O, In.isContextConsumer = function(y) {
    return M(y) === s;
  }, In.isContextProvider = function(y) {
    return M(y) === a;
  }, In.isElement = function(y) {
    return typeof y == "object" && y !== null && y.$$typeof === t;
  }, In.isForwardRef = function(y) {
    return M(y) === c;
  }, In.isFragment = function(y) {
    return M(y) === r;
  }, In.isLazy = function(y) {
    return M(y) === f;
  }, In.isMemo = function(y) {
    return M(y) === g;
  }, In.isPortal = function(y) {
    return M(y) === n;
  }, In.isProfiler = function(y) {
    return M(y) === i;
  }, In.isStrictMode = function(y) {
    return M(y) === o;
  }, In.isSuspense = function(y) {
    return M(y) === p;
  }, In.isValidElementType = function(y) {
    return typeof y == "string" || typeof y == "function" || y === r || y === u || y === i || y === o || y === p || y === d || typeof y == "object" && y !== null && (y.$$typeof === f || y.$$typeof === g || y.$$typeof === a || y.$$typeof === s || y.$$typeof === c || y.$$typeof === v || y.$$typeof === E || y.$$typeof === w || y.$$typeof === m);
  }, In.typeOf = M, In;
}
var Wn = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var l3;
function EFe() {
  return l3 || (l3 = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, g = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, m = e ? Symbol.for("react.block") : 60121, v = e ? Symbol.for("react.fundamental") : 60117, E = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
    function M(B) {
      return typeof B == "string" || typeof B == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      B === r || B === u || B === i || B === o || B === p || B === d || typeof B == "object" && B !== null && (B.$$typeof === f || B.$$typeof === g || B.$$typeof === a || B.$$typeof === s || B.$$typeof === c || B.$$typeof === v || B.$$typeof === E || B.$$typeof === w || B.$$typeof === m);
    }
    function O(B) {
      if (typeof B == "object" && B !== null) {
        var ue = B.$$typeof;
        switch (ue) {
          case t:
            var fe = B.type;
            switch (fe) {
              case l:
              case u:
              case r:
              case i:
              case o:
              case p:
                return fe;
              default:
                var oe = fe && fe.$$typeof;
                switch (oe) {
                  case s:
                  case c:
                  case f:
                  case g:
                  case a:
                    return oe;
                  default:
                    return ue;
                }
            }
          case n:
            return ue;
        }
      }
    }
    var y = l, C = u, _ = s, F = a, L = t, N = c, R = r, W = f, V = g, z = n, Z = i, K = o, X = p, te = !1;
    function J(B) {
      return te || (te = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), P(B) || O(B) === l;
    }
    function P(B) {
      return O(B) === u;
    }
    function D(B) {
      return O(B) === s;
    }
    function H(B) {
      return O(B) === a;
    }
    function S(B) {
      return typeof B == "object" && B !== null && B.$$typeof === t;
    }
    function $(B) {
      return O(B) === c;
    }
    function x(B) {
      return O(B) === r;
    }
    function j(B) {
      return O(B) === f;
    }
    function U(B) {
      return O(B) === g;
    }
    function T(B) {
      return O(B) === n;
    }
    function q(B) {
      return O(B) === i;
    }
    function A(B) {
      return O(B) === o;
    }
    function Y(B) {
      return O(B) === p;
    }
    Wn.AsyncMode = y, Wn.ConcurrentMode = C, Wn.ContextConsumer = _, Wn.ContextProvider = F, Wn.Element = L, Wn.ForwardRef = N, Wn.Fragment = R, Wn.Lazy = W, Wn.Memo = V, Wn.Portal = z, Wn.Profiler = Z, Wn.StrictMode = K, Wn.Suspense = X, Wn.isAsyncMode = J, Wn.isConcurrentMode = P, Wn.isContextConsumer = D, Wn.isContextProvider = H, Wn.isElement = S, Wn.isForwardRef = $, Wn.isFragment = x, Wn.isLazy = j, Wn.isMemo = U, Wn.isPortal = T, Wn.isProfiler = q, Wn.isStrictMode = A, Wn.isSuspense = Y, Wn.isValidElementType = M, Wn.typeOf = O;
  }()), Wn;
}
var u3;
function gY() {
  return u3 || (u3 = 1, process.env.NODE_ENV === "production" ? lO.exports = OFe() : lO.exports = EFe()), lO.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var uO, c3;
function kFe() {
  if (c3) return uO;
  c3 = 1;
  var e = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, n = Object.prototype.propertyIsEnumerable;
  function r(i) {
    if (i == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(i);
  }
  function o() {
    try {
      if (!Object.assign)
        return !1;
      var i = new String("abc");
      if (i[5] = "de", Object.getOwnPropertyNames(i)[0] === "5")
        return !1;
      for (var a = {}, s = 0; s < 10; s++)
        a["_" + String.fromCharCode(s)] = s;
      var l = Object.getOwnPropertyNames(a).map(function(c) {
        return a[c];
      });
      if (l.join("") !== "0123456789")
        return !1;
      var u = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(c) {
        u[c] = c;
      }), Object.keys(Object.assign({}, u)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return uO = o() ? Object.assign : function(i, a) {
    for (var s, l = r(i), u, c = 1; c < arguments.length; c++) {
      s = Object(arguments[c]);
      for (var p in s)
        t.call(s, p) && (l[p] = s[p]);
      if (e) {
        u = e(s);
        for (var d = 0; d < u.length; d++)
          n.call(s, u[d]) && (l[u[d]] = s[u[d]]);
      }
    }
    return l;
  }, uO;
}
var cO, p3;
function oS() {
  if (p3) return cO;
  p3 = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return cO = e, cO;
}
var d3, f3;
function mY() {
  return f3 || (f3 = 1, d3 = Function.call.bind(Object.prototype.hasOwnProperty)), d3;
}
var pO, h3;
function LFe() {
  if (h3) return pO;
  h3 = 1;
  var e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = oS(), n = {}, r = mY();
    e = function(i) {
      var a = "Warning: " + i;
      typeof console < "u" && console.error(a);
      try {
        throw new Error(a);
      } catch {
      }
    };
  }
  function o(i, a, s, l, u) {
    if (process.env.NODE_ENV !== "production") {
      for (var c in i)
        if (r(i, c)) {
          var p;
          try {
            if (typeof i[c] != "function") {
              var d = Error(
                (l || "React class") + ": " + s + " type `" + c + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof i[c] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw d.name = "Invariant Violation", d;
            }
            p = i[c](a, c, l, s, null, t);
          } catch (f) {
            p = f;
          }
          if (p && !(p instanceof Error) && e(
            (l || "React class") + ": type specification of " + s + " `" + c + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof p + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), p instanceof Error && !(p.message in n)) {
            n[p.message] = !0;
            var g = u ? u() : "";
            e(
              "Failed " + s + " type: " + p.message + (g ?? "")
            );
          }
        }
    }
  }
  return o.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (n = {});
  }, pO = o, pO;
}
var dO, g3;
function PFe() {
  if (g3) return dO;
  g3 = 1;
  var e = gY(), t = kFe(), n = oS(), r = mY(), o = LFe(), i = function() {
  };
  process.env.NODE_ENV !== "production" && (i = function(s) {
    var l = "Warning: " + s;
    typeof console < "u" && console.error(l);
    try {
      throw new Error(l);
    } catch {
    }
  });
  function a() {
    return null;
  }
  return dO = function(s, l) {
    var u = typeof Symbol == "function" && Symbol.iterator, c = "@@iterator";
    function p(P) {
      var D = P && (u && P[u] || P[c]);
      if (typeof D == "function")
        return D;
    }
    var d = "<<anonymous>>", g = {
      array: E("array"),
      bigint: E("bigint"),
      bool: E("boolean"),
      func: E("function"),
      number: E("number"),
      object: E("object"),
      string: E("string"),
      symbol: E("symbol"),
      any: w(),
      arrayOf: M,
      element: O(),
      elementType: y(),
      instanceOf: C,
      node: N(),
      objectOf: F,
      oneOf: _,
      oneOfType: L,
      shape: W,
      exact: V
    };
    function f(P, D) {
      return P === D ? P !== 0 || 1 / P === 1 / D : P !== P && D !== D;
    }
    function m(P, D) {
      this.message = P, this.data = D && typeof D == "object" ? D : {}, this.stack = "";
    }
    m.prototype = Error.prototype;
    function v(P) {
      if (process.env.NODE_ENV !== "production")
        var D = {}, H = 0;
      function S(x, j, U, T, q, A, Y) {
        if (T = T || d, A = A || U, Y !== n) {
          if (l) {
            var B = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw B.name = "Invariant Violation", B;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var ue = T + ":" + U;
            !D[ue] && // Avoid spamming the console because they are often not actionable except for lib authors
            H < 3 && (i(
              "You are manually calling a React.PropTypes validation function for the `" + A + "` prop on `" + T + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), D[ue] = !0, H++);
          }
        }
        return j[U] == null ? x ? j[U] === null ? new m("The " + q + " `" + A + "` is marked as required " + ("in `" + T + "`, but its value is `null`.")) : new m("The " + q + " `" + A + "` is marked as required in " + ("`" + T + "`, but its value is `undefined`.")) : null : P(j, U, T, q, A);
      }
      var $ = S.bind(null, !1);
      return $.isRequired = S.bind(null, !0), $;
    }
    function E(P) {
      function D(H, S, $, x, j, U) {
        var T = H[S], q = K(T);
        if (q !== P) {
          var A = X(T);
          return new m(
            "Invalid " + x + " `" + j + "` of type " + ("`" + A + "` supplied to `" + $ + "`, expected ") + ("`" + P + "`."),
            { expectedType: P }
          );
        }
        return null;
      }
      return v(D);
    }
    function w() {
      return v(a);
    }
    function M(P) {
      function D(H, S, $, x, j) {
        if (typeof P != "function")
          return new m("Property `" + j + "` of component `" + $ + "` has invalid PropType notation inside arrayOf.");
        var U = H[S];
        if (!Array.isArray(U)) {
          var T = K(U);
          return new m("Invalid " + x + " `" + j + "` of type " + ("`" + T + "` supplied to `" + $ + "`, expected an array."));
        }
        for (var q = 0; q < U.length; q++) {
          var A = P(U, q, $, x, j + "[" + q + "]", n);
          if (A instanceof Error)
            return A;
        }
        return null;
      }
      return v(D);
    }
    function O() {
      function P(D, H, S, $, x) {
        var j = D[H];
        if (!s(j)) {
          var U = K(j);
          return new m("Invalid " + $ + " `" + x + "` of type " + ("`" + U + "` supplied to `" + S + "`, expected a single ReactElement."));
        }
        return null;
      }
      return v(P);
    }
    function y() {
      function P(D, H, S, $, x) {
        var j = D[H];
        if (!e.isValidElementType(j)) {
          var U = K(j);
          return new m("Invalid " + $ + " `" + x + "` of type " + ("`" + U + "` supplied to `" + S + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return v(P);
    }
    function C(P) {
      function D(H, S, $, x, j) {
        if (!(H[S] instanceof P)) {
          var U = P.name || d, T = J(H[S]);
          return new m("Invalid " + x + " `" + j + "` of type " + ("`" + T + "` supplied to `" + $ + "`, expected ") + ("instance of `" + U + "`."));
        }
        return null;
      }
      return v(D);
    }
    function _(P) {
      if (!Array.isArray(P))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? i(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : i("Invalid argument supplied to oneOf, expected an array.")), a;
      function D(H, S, $, x, j) {
        for (var U = H[S], T = 0; T < P.length; T++)
          if (f(U, P[T]))
            return null;
        var q = JSON.stringify(P, function(A, Y) {
          var B = X(Y);
          return B === "symbol" ? String(Y) : Y;
        });
        return new m("Invalid " + x + " `" + j + "` of value `" + String(U) + "` " + ("supplied to `" + $ + "`, expected one of " + q + "."));
      }
      return v(D);
    }
    function F(P) {
      function D(H, S, $, x, j) {
        if (typeof P != "function")
          return new m("Property `" + j + "` of component `" + $ + "` has invalid PropType notation inside objectOf.");
        var U = H[S], T = K(U);
        if (T !== "object")
          return new m("Invalid " + x + " `" + j + "` of type " + ("`" + T + "` supplied to `" + $ + "`, expected an object."));
        for (var q in U)
          if (r(U, q)) {
            var A = P(U, q, $, x, j + "." + q, n);
            if (A instanceof Error)
              return A;
          }
        return null;
      }
      return v(D);
    }
    function L(P) {
      if (!Array.isArray(P))
        return process.env.NODE_ENV !== "production" && i("Invalid argument supplied to oneOfType, expected an instance of array."), a;
      for (var D = 0; D < P.length; D++) {
        var H = P[D];
        if (typeof H != "function")
          return i(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + te(H) + " at index " + D + "."
          ), a;
      }
      function S($, x, j, U, T) {
        for (var q = [], A = 0; A < P.length; A++) {
          var Y = P[A], B = Y($, x, j, U, T, n);
          if (B == null)
            return null;
          B.data && r(B.data, "expectedType") && q.push(B.data.expectedType);
        }
        var ue = q.length > 0 ? ", expected one of type [" + q.join(", ") + "]" : "";
        return new m("Invalid " + U + " `" + T + "` supplied to " + ("`" + j + "`" + ue + "."));
      }
      return v(S);
    }
    function N() {
      function P(D, H, S, $, x) {
        return z(D[H]) ? null : new m("Invalid " + $ + " `" + x + "` supplied to " + ("`" + S + "`, expected a ReactNode."));
      }
      return v(P);
    }
    function R(P, D, H, S, $) {
      return new m(
        (P || "React class") + ": " + D + " type `" + H + "." + S + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + $ + "`."
      );
    }
    function W(P) {
      function D(H, S, $, x, j) {
        var U = H[S], T = K(U);
        if (T !== "object")
          return new m("Invalid " + x + " `" + j + "` of type `" + T + "` " + ("supplied to `" + $ + "`, expected `object`."));
        for (var q in P) {
          var A = P[q];
          if (typeof A != "function")
            return R($, x, j, q, X(A));
          var Y = A(U, q, $, x, j + "." + q, n);
          if (Y)
            return Y;
        }
        return null;
      }
      return v(D);
    }
    function V(P) {
      function D(H, S, $, x, j) {
        var U = H[S], T = K(U);
        if (T !== "object")
          return new m("Invalid " + x + " `" + j + "` of type `" + T + "` " + ("supplied to `" + $ + "`, expected `object`."));
        var q = t({}, H[S], P);
        for (var A in q) {
          var Y = P[A];
          if (r(P, A) && typeof Y != "function")
            return R($, x, j, A, X(Y));
          if (!Y)
            return new m(
              "Invalid " + x + " `" + j + "` key `" + A + "` supplied to `" + $ + "`.\nBad object: " + JSON.stringify(H[S], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(P), null, "  ")
            );
          var B = Y(U, A, $, x, j + "." + A, n);
          if (B)
            return B;
        }
        return null;
      }
      return v(D);
    }
    function z(P) {
      switch (typeof P) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !P;
        case "object":
          if (Array.isArray(P))
            return P.every(z);
          if (P === null || s(P))
            return !0;
          var D = p(P);
          if (D) {
            var H = D.call(P), S;
            if (D !== P.entries) {
              for (; !(S = H.next()).done; )
                if (!z(S.value))
                  return !1;
            } else
              for (; !(S = H.next()).done; ) {
                var $ = S.value;
                if ($ && !z($[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function Z(P, D) {
      return P === "symbol" ? !0 : D ? D["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && D instanceof Symbol : !1;
    }
    function K(P) {
      var D = typeof P;
      return Array.isArray(P) ? "array" : P instanceof RegExp ? "object" : Z(D, P) ? "symbol" : D;
    }
    function X(P) {
      if (typeof P > "u" || P === null)
        return "" + P;
      var D = K(P);
      if (D === "object") {
        if (P instanceof Date)
          return "date";
        if (P instanceof RegExp)
          return "regexp";
      }
      return D;
    }
    function te(P) {
      var D = X(P);
      switch (D) {
        case "array":
        case "object":
          return "an " + D;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + D;
        default:
          return D;
      }
    }
    function J(P) {
      return !P.constructor || !P.constructor.name ? d : P.constructor.name;
    }
    return g.checkPropTypes = o, g.resetWarningCache = o.resetWarningCache, g.PropTypes = g, g;
  }, dO;
}
var fO, m3;
function _Fe() {
  if (m3) return fO;
  m3 = 1;
  var e = oS();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, fO = function() {
    function r(a, s, l, u, c, p) {
      if (p !== e) {
        var d = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw d.name = "Invariant Violation", d;
      }
    }
    r.isRequired = r;
    function o() {
      return r;
    }
    var i = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: o,
      element: r,
      elementType: r,
      instanceOf: o,
      node: r,
      objectOf: o,
      oneOf: o,
      oneOfType: o,
      shape: o,
      exact: o,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return i.PropTypes = i, i;
  }, fO;
}
if (process.env.NODE_ENV !== "production") {
  var SFe = gY(), MFe = !0;
  Jk.exports = PFe()(SFe.isElement, MFe);
} else
  Jk.exports = _Fe()();
var d0 = Jk.exports, f0 = {};
Object.defineProperty(f0, "__esModule", {
  value: !0
});
var DFe = th, hO = TFe(DFe);
function TFe(e) {
  return e && e.__esModule ? e : { default: e };
}
var jFe = {
  mountFlag: !1,
  initialized: !1,
  scroller: null,
  containers: {},
  mount: function(e) {
    this.scroller = e, this.handleHashChange = this.handleHashChange.bind(this), window.addEventListener("hashchange", this.handleHashChange), this.initStateFromHash(), this.mountFlag = !0;
  },
  mapContainer: function(e, t) {
    this.containers[e] = t;
  },
  isMounted: function() {
    return this.mountFlag;
  },
  isInitialized: function() {
    return this.initialized;
  },
  initStateFromHash: function() {
    var e = this, t = this.getHash();
    t ? window.setTimeout(function() {
      e.scrollTo(t, !0), e.initialized = !0;
    }, 10) : this.initialized = !0;
  },
  scrollTo: function(e, t) {
    var n = this.scroller, r = n.get(e);
    if (r && (t || e !== n.getActiveLink())) {
      var o = this.containers[e] || document;
      n.scrollTo(e, { container: o });
    }
  },
  getHash: function() {
    return hO.default.getHash();
  },
  changeHash: function(e, t) {
    this.isInitialized() && hO.default.getHash() !== e && hO.default.updateHash(e, t);
  },
  handleHashChange: function() {
    this.scrollTo(this.getHash());
  },
  unmount: function() {
    this.scroller = null, this.containers = null, window.removeEventListener("hashchange", this.handleHashChange);
  }
};
f0.default = jFe;
Object.defineProperty(Jf, "__esModule", {
  value: !0
});
var nm = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, AFe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), IFe = we, v3 = oh(IFe), RFe = Qf, rm = oh(RFe), BFe = Nc, NFe = oh(BFe), FFe = d0, Br = oh(FFe), zFe = f0, Ta = oh(zFe);
function oh(e) {
  return e && e.__esModule ? e : { default: e };
}
function UFe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function HFe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function $Fe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var y3 = {
  to: Br.default.string.isRequired,
  containerId: Br.default.string,
  container: Br.default.object,
  activeClass: Br.default.string,
  activeStyle: Br.default.object,
  spy: Br.default.bool,
  horizontal: Br.default.bool,
  smooth: Br.default.oneOfType([Br.default.bool, Br.default.string]),
  offset: Br.default.number,
  delay: Br.default.number,
  isDynamic: Br.default.bool,
  onClick: Br.default.func,
  duration: Br.default.oneOfType([Br.default.number, Br.default.func]),
  absolute: Br.default.bool,
  onSetActive: Br.default.func,
  onSetInactive: Br.default.func,
  ignoreCancelEvents: Br.default.bool,
  hashSpy: Br.default.bool,
  saveHashHistory: Br.default.bool,
  spyThrottle: Br.default.number
};
Jf.default = function(e, t) {
  var n = t || NFe.default, r = function(i) {
    $Fe(a, i);
    function a(s) {
      UFe(this, a);
      var l = HFe(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
      return o.call(l), l.state = {
        active: !1
      }, l.beforeUnmountCallbacks = [], l;
    }
    return AFe(a, [{
      key: "getScrollSpyContainer",
      value: function() {
        var s = this.props.containerId, l = this.props.container;
        return s && !l ? document.getElementById(s) : l && l.nodeType ? l : document;
      }
    }, {
      key: "componentDidMount",
      value: function() {
        if (this.props.spy || this.props.hashSpy) {
          var s = this.getScrollSpyContainer();
          if (!rm.default.isMounted(s)) {
            var l = rm.default.mount(s, this.props.spyThrottle);
            this.beforeUnmountCallbacks.push(l);
          }
          this.props.hashSpy && (Ta.default.isMounted() || Ta.default.mount(n), Ta.default.mapContainer(this.props.to, s)), rm.default.addSpyHandler(this.spyHandler, s), this.setState({
            container: s
          });
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        rm.default.unmount(this.stateHandler, this.spyHandler), this.beforeUnmountCallbacks.forEach(function(s) {
          return s();
        });
      }
    }, {
      key: "render",
      value: function() {
        var s = "";
        this.state && this.state.active ? s = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : s = this.props.className;
        var l = {};
        this.state && this.state.active ? l = nm({}, this.props.style, this.props.activeStyle) : l = nm({}, this.props.style);
        var u = nm({}, this.props);
        for (var c in y3)
          u.hasOwnProperty(c) && delete u[c];
        return u.className = s, u.style = l, u.onClick = this.handleClick, v3.default.createElement(e, u);
      }
    }]), a;
  }(v3.default.PureComponent), o = function() {
    var i = this;
    this.scrollTo = function(a, s) {
      n.scrollTo(a, nm({}, i.state, s));
    }, this.handleClick = function(a) {
      i.props.onClick && i.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), i.scrollTo(i.props.to, i.props);
    }, this.spyHandler = function(a, s) {
      var l = i.getScrollSpyContainer();
      if (!(Ta.default.isMounted() && !Ta.default.isInitialized())) {
        var u = i.props.horizontal, c = i.props.to, p = null, d = void 0, g = void 0;
        if (u) {
          var f = 0, m = 0, v = 0;
          if (l.getBoundingClientRect) {
            var E = l.getBoundingClientRect();
            v = E.left;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var w = p.getBoundingClientRect();
            f = w.left - v + a, m = f + w.width;
          }
          var M = a - i.props.offset;
          d = M >= Math.floor(f) && M < Math.floor(m), g = M < Math.floor(f) || M >= Math.floor(m);
        } else {
          var O = 0, y = 0, C = 0;
          if (l.getBoundingClientRect) {
            var _ = l.getBoundingClientRect();
            C = _.top;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var F = p.getBoundingClientRect();
            O = F.top - C + s, y = O + F.height;
          }
          var L = s - i.props.offset;
          d = L >= Math.floor(O) && L < Math.floor(y), g = L < Math.floor(O) || L >= Math.floor(y);
        }
        var N = n.getActiveLink();
        if (g) {
          if (c === N && n.setActiveLink(void 0), i.props.hashSpy && Ta.default.getHash() === c) {
            var R = i.props.saveHashHistory, W = R === void 0 ? !1 : R;
            Ta.default.changeHash("", W);
          }
          i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive(c, p));
        }
        if (d && (N !== c || i.state.active === !1)) {
          n.setActiveLink(c);
          var V = i.props.saveHashHistory, z = V === void 0 ? !1 : V;
          i.props.hashSpy && Ta.default.changeHash(c, z), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(c, p));
        }
      }
    };
  };
  return r.propTypes = y3, r.defaultProps = { offset: 0 }, r;
};
Object.defineProperty(Q_, "__esModule", {
  value: !0
});
var WFe = we, b3 = vY(WFe), VFe = Jf, ZFe = vY(VFe);
function vY(e) {
  return e && e.__esModule ? e : { default: e };
}
function qFe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function w3(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function GFe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var KFe = function(e) {
  GFe(t, e);
  function t() {
    var n, r, o, i;
    qFe(this, t);
    for (var a = arguments.length, s = Array(a), l = 0; l < a; l++)
      s[l] = arguments[l];
    return i = (r = (o = w3(this, (n = t.__proto__ || Object.getPrototypeOf(t)).call.apply(n, [this].concat(s))), o), o.render = function() {
      return b3.default.createElement(
        "a",
        o.props,
        o.props.children
      );
    }, r), w3(o, i);
  }
  return t;
}(b3.default.Component);
Q_.default = (0, ZFe.default)(KFe);
var iS = {};
Object.defineProperty(iS, "__esModule", {
  value: !0
});
var YFe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), XFe = we, C3 = yY(XFe), JFe = Jf, QFe = yY(JFe);
function yY(e) {
  return e && e.__esModule ? e : { default: e };
}
function e2e(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function t2e(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function n2e(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var r2e = function(e) {
  n2e(t, e);
  function t() {
    return e2e(this, t), t2e(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return YFe(t, [{
    key: "render",
    value: function() {
      return C3.default.createElement(
        "button",
        this.props,
        this.props.children
      );
    }
  }]), t;
}(C3.default.Component);
iS.default = (0, QFe.default)(r2e);
var sS = {}, h0 = {};
Object.defineProperty(h0, "__esModule", {
  value: !0
});
var o2e = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, i2e = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), s2e = we, x3 = g0(s2e), a2e = pl;
g0(a2e);
var l2e = Nc, O3 = g0(l2e), u2e = d0, E3 = g0(u2e);
function g0(e) {
  return e && e.__esModule ? e : { default: e };
}
function c2e(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function p2e(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function d2e(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
h0.default = function(e) {
  var t = function(n) {
    d2e(r, n);
    function r(o) {
      c2e(this, r);
      var i = p2e(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
      return i.childBindings = {
        domNode: null
      }, i;
    }
    return i2e(r, [{
      key: "componentDidMount",
      value: function() {
        if (typeof window > "u")
          return !1;
        this.registerElems(this.props.name);
      }
    }, {
      key: "componentDidUpdate",
      value: function(o) {
        this.props.name !== o.name && this.registerElems(this.props.name);
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        if (typeof window > "u")
          return !1;
        O3.default.unregister(this.props.name);
      }
    }, {
      key: "registerElems",
      value: function(o) {
        O3.default.register(o, this.childBindings.domNode);
      }
    }, {
      key: "render",
      value: function() {
        return x3.default.createElement(e, o2e({}, this.props, { parentBindings: this.childBindings }));
      }
    }]), r;
  }(x3.default.Component);
  return t.propTypes = {
    name: E3.default.string,
    id: E3.default.string
  }, t;
};
Object.defineProperty(sS, "__esModule", {
  value: !0
});
var k3 = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, f2e = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), h2e = we, L3 = aS(h2e), g2e = h0, m2e = aS(g2e), v2e = d0, P3 = aS(v2e);
function aS(e) {
  return e && e.__esModule ? e : { default: e };
}
function y2e(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function b2e(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function w2e(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var bY = function(e) {
  w2e(t, e);
  function t() {
    return y2e(this, t), b2e(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return f2e(t, [{
    key: "render",
    value: function() {
      var n = this, r = k3({}, this.props);
      return delete r.name, r.parentBindings && delete r.parentBindings, L3.default.createElement(
        "div",
        k3({}, r, { ref: function(o) {
          n.props.parentBindings.domNode = o;
        } }),
        this.props.children
      );
    }
  }]), t;
}(L3.default.Component);
bY.propTypes = {
  name: P3.default.string,
  id: P3.default.string
};
sS.default = (0, m2e.default)(bY);
var gO = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, _3 = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}();
function S3(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function M3(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function D3(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var om = we, Wl = Qf, mO = Nc, Qr = d0, ja = f0, T3 = {
  to: Qr.string.isRequired,
  containerId: Qr.string,
  container: Qr.object,
  activeClass: Qr.string,
  spy: Qr.bool,
  smooth: Qr.oneOfType([Qr.bool, Qr.string]),
  offset: Qr.number,
  delay: Qr.number,
  isDynamic: Qr.bool,
  onClick: Qr.func,
  duration: Qr.oneOfType([Qr.number, Qr.func]),
  absolute: Qr.bool,
  onSetActive: Qr.func,
  onSetInactive: Qr.func,
  ignoreCancelEvents: Qr.bool,
  hashSpy: Qr.bool,
  spyThrottle: Qr.number
}, C2e = {
  Scroll: function(e, t) {
    console.warn("Helpers.Scroll is deprecated since v1.7.0");
    var n = t || mO, r = function(i) {
      D3(a, i);
      function a(s) {
        S3(this, a);
        var l = M3(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
        return o.call(l), l.state = {
          active: !1
        }, l;
      }
      return _3(a, [{
        key: "getScrollSpyContainer",
        value: function() {
          var s = this.props.containerId, l = this.props.container;
          return s ? document.getElementById(s) : l && l.nodeType ? l : document;
        }
      }, {
        key: "componentDidMount",
        value: function() {
          if (this.props.spy || this.props.hashSpy) {
            var s = this.getScrollSpyContainer();
            Wl.isMounted(s) || Wl.mount(s, this.props.spyThrottle), this.props.hashSpy && (ja.isMounted() || ja.mount(n), ja.mapContainer(this.props.to, s)), this.props.spy && Wl.addStateHandler(this.stateHandler), Wl.addSpyHandler(this.spyHandler, s), this.setState({
              container: s
            });
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          Wl.unmount(this.stateHandler, this.spyHandler);
        }
      }, {
        key: "render",
        value: function() {
          var s = "";
          this.state && this.state.active ? s = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : s = this.props.className;
          var l = gO({}, this.props);
          for (var u in T3)
            l.hasOwnProperty(u) && delete l[u];
          return l.className = s, l.onClick = this.handleClick, om.createElement(e, l);
        }
      }]), a;
    }(om.Component), o = function() {
      var i = this;
      this.scrollTo = function(a, s) {
        n.scrollTo(a, gO({}, i.state, s));
      }, this.handleClick = function(a) {
        i.props.onClick && i.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), i.scrollTo(i.props.to, i.props);
      }, this.stateHandler = function() {
        n.getActiveLink() !== i.props.to && (i.state !== null && i.state.active && i.props.onSetInactive && i.props.onSetInactive(), i.setState({ active: !1 }));
      }, this.spyHandler = function(a) {
        var s = i.getScrollSpyContainer();
        if (!(ja.isMounted() && !ja.isInitialized())) {
          var l = i.props.to, u = null, c = 0, p = 0, d = 0;
          if (s.getBoundingClientRect) {
            var g = s.getBoundingClientRect();
            d = g.top;
          }
          if (!u || i.props.isDynamic) {
            if (u = n.get(l), !u)
              return;
            var f = u.getBoundingClientRect();
            c = f.top - d + a, p = c + f.height;
          }
          var m = a - i.props.offset, v = m >= Math.floor(c) && m < Math.floor(p), E = m < Math.floor(c) || m >= Math.floor(p), w = n.getActiveLink();
          if (E)
            return l === w && n.setActiveLink(void 0), i.props.hashSpy && ja.getHash() === l && ja.changeHash(), i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive()), Wl.updateStates();
          if (v && w !== l)
            return n.setActiveLink(l), i.props.hashSpy && ja.changeHash(l), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(l)), Wl.updateStates();
        }
      };
    };
    return r.propTypes = T3, r.defaultProps = { offset: 0 }, r;
  },
  Element: function(e) {
    console.warn("Helpers.Element is deprecated since v1.7.0");
    var t = function(n) {
      D3(r, n);
      function r(o) {
        S3(this, r);
        var i = M3(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
        return i.childBindings = {
          domNode: null
        }, i;
      }
      return _3(r, [{
        key: "componentDidMount",
        value: function() {
          if (typeof window > "u")
            return !1;
          this.registerElems(this.props.name);
        }
      }, {
        key: "componentDidUpdate",
        value: function(o) {
          this.props.name !== o.name && this.registerElems(this.props.name);
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          if (typeof window > "u")
            return !1;
          mO.unregister(this.props.name);
        }
      }, {
        key: "registerElems",
        value: function(o) {
          mO.register(o, this.childBindings.domNode);
        }
      }, {
        key: "render",
        value: function() {
          return om.createElement(e, gO({}, this.props, { parentBindings: this.childBindings }));
        }
      }]), r;
    }(om.Component);
    return t.propTypes = {
      name: Qr.string,
      id: Qr.string
    }, t;
  }
}, x2e = C2e;
Object.defineProperty(ho, "__esModule", {
  value: !0
});
ho.Helpers = ho.ScrollElement = ho.ScrollLink = ho.animateScroll = ho.scrollSpy = ho.Events = ho.scroller = ho.Element = ho.Button = ho.Link = void 0;
var O2e = Q_, wY = Ns(O2e), E2e = iS, CY = Ns(E2e), k2e = sS, xY = Ns(k2e), L2e = Nc, OY = Ns(L2e), P2e = nh, EY = Ns(P2e), _2e = Qf, kY = Ns(_2e), S2e = u0, LY = Ns(S2e), M2e = Jf, PY = Ns(M2e), D2e = h0, _Y = Ns(D2e), T2e = x2e, SY = Ns(T2e);
function Ns(e) {
  return e && e.__esModule ? e : { default: e };
}
ho.Link = wY.default;
ho.Button = CY.default;
ho.Element = xY.default;
ho.scroller = OY.default;
ho.Events = EY.default;
ho.scrollSpy = kY.default;
ho.animateScroll = LY.default;
ho.ScrollLink = PY.default;
ho.ScrollElement = _Y.default;
ho.Helpers = SY.default;
ho.default = { Link: wY.default, Button: CY.default, Element: xY.default, scroller: OY.default, Events: EY.default, scrollSpy: kY.default, animateScroll: LY.default, ScrollLink: PY.default, ScrollElement: _Y.default, Helpers: SY.default };
Ke({});
Ke({});
Ke({});
function cf(e) {
  "@babel/helpers - typeof";
  return cf = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, cf(e);
}
function j2e(e, t) {
  if (cf(e) != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (cf(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function A2e(e) {
  var t = j2e(e, "string");
  return cf(t) == "symbol" ? t : t + "";
}
function Le(e, t, n) {
  return (t = A2e(t)) in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function MY(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var vO, j3;
function I2e() {
  if (j3) return vO;
  j3 = 1;
  var e = process.env.NODE_ENV, t = function(n, r, o, i, a, s, l, u) {
    if (e !== "production" && r === void 0)
      throw new Error("invariant requires an error message argument");
    if (!n) {
      var c;
      if (r === void 0)
        c = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
      else {
        var p = [o, i, a, s, l, u], d = 0;
        c = new Error(r.replace(/%s/g, function() {
          return p[d++];
        })), c.name = "Invariant Violation";
      }
      throw c.framesToPop = 1, c;
    }
  };
  return vO = t, vO;
}
var R2e = I2e(), Oo = /* @__PURE__ */ MY(R2e), Bt = Ke(null);
function B2e() {
  Oo(!!ge, "useGoogleMap is React hook and requires React version 16.8+");
  var e = ge(Bt);
  return Oo(!!e, "useGoogleMap needs a GoogleMap available up in the tree"), e;
}
function N2e(e, t, n) {
  return Object.keys(e).reduce(function(r, o) {
    return t(r, e[o], o);
  }, n);
}
function F2e(e, t) {
  Object.keys(e).forEach((n) => t(e[n], n));
}
function z2e(e, t, n, r) {
  var o = {}, i = (a, s) => {
    var l = n[s];
    l !== t[s] && (o[s] = l, a(r, l));
  };
  return F2e(e, i), o;
}
function U2e(e, t, n) {
  var r = N2e(n, function(o, i, a) {
    return typeof e[a] == "function" && o.push(google.maps.event.addListener(t, i, e[a])), o;
  }, []);
  return r;
}
function H2e(e) {
  google.maps.event.removeListener(e);
}
function yn() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  e.forEach(H2e);
}
function dn(e) {
  var {
    updaterMap: t,
    eventMap: n,
    prevProps: r,
    nextProps: o,
    instance: i
  } = e, a = U2e(o, i, n);
  return z2e(t, r, o, i), a;
}
function $2e(e) {
  var {
    children: t,
    options: n,
    id: r,
    mapContainerStyle: o,
    mapContainerClassName: i,
    center: a,
    // clickableIcons,
    // extraMapTypes,
    // heading,
    // mapTypeId,
    onClick: s,
    onDblClick: l,
    onDrag: u,
    onDragEnd: c,
    onDragStart: p,
    onMouseMove: d,
    onMouseOut: g,
    onMouseOver: f,
    onMouseDown: m,
    onMouseUp: v,
    onRightClick: E,
    // onMapTypeIdChanged,
    // onTilesLoaded,
    // onBoundsChanged,
    onCenterChanged: w,
    // onHeadingChanged,
    // onIdle,
    // onProjectionChanged,
    // onResize,
    // onTiltChanged,
    // onZoomChanged,
    onLoad: M,
    onUnmount: O
  } = e, [y, C] = k(null), _ = ut(null), [F, L] = k(null), [N, R] = k(null), [W, V] = k(null), [z, Z] = k(null), [K, X] = k(null), [te, J] = k(null), [P, D] = k(null), [H, S] = k(null), [$, x] = k(null), [j, U] = k(null), [T, q] = k(null), [A, Y] = k(null);
  return h(() => {
    n && y !== null && y.setOptions(n);
  }, [y, n]), h(() => {
    y !== null && typeof a < "u" && y.setCenter(a);
  }, [y, a]), h(() => {
    y && l && (N !== null && google.maps.event.removeListener(N), R(google.maps.event.addListener(y, "dblclick", l)));
  }, [l]), h(() => {
    y && c && (W !== null && google.maps.event.removeListener(W), V(google.maps.event.addListener(y, "dragend", c)));
  }, [c]), h(() => {
    y && p && (z !== null && google.maps.event.removeListener(z), Z(google.maps.event.addListener(y, "dragstart", p)));
  }, [p]), h(() => {
    y && m && (K !== null && google.maps.event.removeListener(K), X(google.maps.event.addListener(y, "mousedown", m)));
  }, [m]), h(() => {
    y && d && (te !== null && google.maps.event.removeListener(te), J(google.maps.event.addListener(y, "mousemove", d)));
  }, [d]), h(() => {
    y && g && (P !== null && google.maps.event.removeListener(P), D(google.maps.event.addListener(y, "mouseout", g)));
  }, [g]), h(() => {
    y && f && (H !== null && google.maps.event.removeListener(H), S(google.maps.event.addListener(y, "mouseover", f)));
  }, [f]), h(() => {
    y && v && ($ !== null && google.maps.event.removeListener($), x(google.maps.event.addListener(y, "mouseup", v)));
  }, [v]), h(() => {
    y && E && (j !== null && google.maps.event.removeListener(j), U(google.maps.event.addListener(y, "rightclick", E)));
  }, [E]), h(() => {
    y && s && (T !== null && google.maps.event.removeListener(T), q(google.maps.event.addListener(y, "click", s)));
  }, [s]), h(() => {
    y && u && (A !== null && google.maps.event.removeListener(A), Y(google.maps.event.addListener(y, "drag", u)));
  }, [u]), h(() => {
    y && w && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(y, "center_changed", w)));
  }, [s]), h(() => {
    var B = _.current === null ? null : new google.maps.Map(_.current, n);
    return C(B), B !== null && M && M(B), () => {
      B !== null && O && O(B);
    };
  }, []), Sn.jsx("div", {
    id: r,
    ref: _,
    style: o,
    className: i,
    children: Sn.jsx(Bt.Provider, {
      value: y,
      children: y !== null ? t : null
    })
  });
}
ve($2e);
function A3(e, t, n, r, o, i, a) {
  try {
    var s = e[i](a), l = s.value;
  } catch (u) {
    return void n(u);
  }
  s.done ? t(l) : Promise.resolve(l).then(r, o);
}
function DY(e) {
  return function() {
    var t = this, n = arguments;
    return new Promise(function(r, o) {
      var i = e.apply(t, n);
      function a(l) {
        A3(i, r, o, a, s, "next", l);
      }
      function s(l) {
        A3(i, r, o, a, s, "throw", l);
      }
      a(void 0);
    });
  };
}
function TY(e) {
  var {
    googleMapsApiKey: t,
    googleMapsClientId: n,
    version: r = "weekly",
    language: o,
    region: i,
    libraries: a,
    channel: s,
    mapIds: l,
    authReferrerPolicy: u
  } = e, c = [];
  return Oo(t && n || !(t && n), "You need to specify either googleMapsApiKey or googleMapsClientId for @react-google-maps/api load script to work. You cannot use both at the same time."), t ? c.push("key=".concat(t)) : n && c.push("client=".concat(n)), r && c.push("v=".concat(r)), o && c.push("language=".concat(o)), i && c.push("region=".concat(i)), a && a.length && c.push("libraries=".concat(a.sort().join(","))), s && c.push("channel=".concat(s)), l && l.length && c.push("map_ids=".concat(l.join(","))), u && c.push("auth_referrer_policy=".concat(u)), c.push("loading=async"), c.push("callback=initMap"), "https://maps.googleapis.com/maps/api/js?".concat(c.join("&"));
}
var gu = typeof document < "u";
function jY(e) {
  var {
    url: t,
    id: n,
    nonce: r
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } = e;
  return gu ? new Promise(function(o, i) {
    var a = document.getElementById(n), s = window;
    if (a) {
      var l = a.getAttribute("data-state");
      if (a.src === t && l !== "error") {
        if (l === "ready")
          return o(n);
        var u = s.initMap, c = a.onerror;
        s.initMap = function() {
          u && u(), o(n);
        }, a.onerror = function(d) {
          c && c(d), i(d);
        };
        return;
      } else
        a.remove();
    }
    var p = document.createElement("script");
    p.type = "text/javascript", p.src = t, p.id = n, p.async = !0, p.nonce = r || "", p.onerror = function(d) {
      p.setAttribute("data-state", "error"), i(d);
    }, s.initMap = function() {
      p.setAttribute("data-state", "ready"), o(n);
    }, document.head.appendChild(p);
  }).catch((o) => {
    throw console.error("injectScript error: ", o), o;
  }) : Promise.reject(new Error("document is undefined"));
}
function I3(e) {
  var t = e.href;
  return t && (t.indexOf("https://fonts.googleapis.com/css?family=Roboto") === 0 || t.indexOf("https://fonts.googleapis.com/css?family=Google+Sans+Text") === 0) ? !0 : (
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.styleSheet.cssText = "", !0) : (
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.innerHTML = "", !0) : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.innerHTML
      )
    )
  );
}
function AY() {
  var e = document.getElementsByTagName("head")[0];
  if (e) {
    var t = e.insertBefore.bind(e);
    e.insertBefore = function(r, o) {
      return I3(r) || Reflect.apply(t, e, [r, o]), r;
    };
    var n = e.appendChild.bind(e);
    e.appendChild = function(r) {
      return I3(r) || Reflect.apply(n, e, [r]), r;
    };
  }
}
var yp = !1;
function IY() {
  return Sn.jsx("div", {
    children: "Loading..."
  });
}
var Qk = {
  id: "script-loader",
  version: "weekly"
};
class W2e extends pe {
  constructor() {
    super(...arguments), Le(this, "check", null), Le(this, "state", {
      loaded: !1
    }), Le(this, "cleanupCallback", () => {
      delete window.google.maps, this.injectScript();
    }), Le(this, "isCleaningUp", /* @__PURE__ */ DY(function* () {
      function t(n) {
        if (!yp)
          n();
        else if (gu)
          var r = window.setInterval(function() {
            yp || (window.clearInterval(r), n());
          }, 1);
      }
      return new Promise(t);
    })), Le(this, "cleanup", () => {
      yp = !0;
      var t = document.getElementById(this.props.id);
      t && t.parentNode && t.parentNode.removeChild(t), Array.prototype.slice.call(document.getElementsByTagName("script")).filter(function(n) {
        return typeof n.src == "string" && n.src.includes("maps.googleapis");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("link")).filter(function(n) {
        return n.href === "https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Google+Sans";
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("style")).filter(function(n) {
        return n.innerText !== void 0 && n.innerText.length > 0 && n.innerText.includes(".gm-");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      });
    }), Le(this, "injectScript", () => {
      this.props.preventGoogleFontsLoading && AY(), Oo(!!this.props.id, 'LoadScript requires "id" prop to be a string: %s', this.props.id);
      var t = {
        id: this.props.id,
        nonce: this.props.nonce,
        url: TY(this.props)
      };
      jY(t).then(() => {
        this.props.onLoad && this.props.onLoad(), this.setState(function() {
          return {
            loaded: !0
          };
        });
      }).catch((n) => {
        this.props.onError && this.props.onError(n), console.error(`
          There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(this.props.googleMapsApiKey || "-", ") or Client ID (").concat(this.props.googleMapsClientId || "-", `) to <LoadScript />
          Otherwise it is a Network issue.
        `));
      });
    }), Le(this, "getRef", (t) => {
      this.check = t;
    });
  }
  componentDidMount() {
    if (gu) {
      if (window.google && window.google.maps && !yp) {
        console.error("google api is already presented");
        return;
      }
      this.isCleaningUp().then(this.injectScript).catch(function(t) {
        console.error("Error at injecting script after cleaning up: ", t);
      });
    }
  }
  componentDidUpdate(t) {
    this.props.libraries !== t.libraries && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), gu && t.language !== this.props.language && (this.cleanup(), this.setState(function() {
      return {
        loaded: !1
      };
    }, this.cleanupCallback));
  }
  componentWillUnmount() {
    if (gu) {
      this.cleanup();
      var t = () => {
        this.check || (delete window.google, yp = !1);
      };
      window.setTimeout(t, 1), this.props.onUnmount && this.props.onUnmount();
    }
  }
  render() {
    return Sn.jsxs(Sn.Fragment, {
      children: [Sn.jsx("div", {
        ref: this.getRef
      }), this.state.loaded ? this.props.children : this.props.loadingElement || Sn.jsx(IY, {})]
    });
  }
}
Le(W2e, "defaultProps", Qk);
function V2e(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.includes(r)) continue;
    n[r] = e[r];
  }
  return n;
}
function lS(e, t) {
  if (e == null) return {};
  var n, r, o = V2e(e, t);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (r = 0; r < i.length; r++) n = i[r], t.includes(n) || {}.propertyIsEnumerable.call(e, n) && (o[n] = e[n]);
  }
  return o;
}
var R3;
function Z2e(e) {
  var {
    id: t = Qk.id,
    version: n = Qk.version,
    nonce: r,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    preventGoogleFontsLoading: u,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  } = e, g = ut(!1), [f, m] = k(!1), [v, E] = k(void 0);
  h(function() {
    return g.current = !0, () => {
      g.current = !1;
    };
  }, []), h(function() {
    gu && u && AY();
  }, [u]), h(function() {
    f && Oo(!!window.google, "useLoadScript was marked as loaded, but window.google is not present. Something went wrong.");
  }, [f]);
  var w = TY({
    version: n,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  });
  h(function() {
    if (!gu)
      return;
    function O() {
      g.current && (m(!0), R3 = w);
    }
    if (window.google && window.google.maps && R3 === w) {
      O();
      return;
    }
    jY({
      id: t,
      url: w,
      nonce: r
    }).then(O).catch(function(y) {
      g.current && E(y), console.warn(`
        There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(o || "-", ") or Client ID (").concat(i || "-", `)
        Otherwise it is a Network issue.
      `)), console.error(y);
    });
  }, [t, w, r]);
  var M = ut(void 0);
  return h(function() {
    M.current && l !== M.current && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), M.current = l;
  }, [l]), {
    isLoaded: f,
    loadError: v,
    url: w
  };
}
var q2e = ["loadingElement", "onLoad", "onError", "onUnmount", "children"], G2e = Sn.jsx(IY, {});
function K2e(e) {
  var {
    loadingElement: t,
    onLoad: n,
    onError: r,
    onUnmount: o,
    children: i
  } = e, a = lS(e, q2e), {
    isLoaded: s,
    loadError: l
  } = Z2e(a);
  return h(function() {
    s && typeof n == "function" && n();
  }, [s, n]), h(function() {
    l && typeof r == "function" && r(l);
  }, [l, r]), h(function() {
    return () => {
      o && o();
    };
  }, [o]), s ? i : t || G2e;
}
ve(K2e);
var B3;
(function(e) {
  e[e.INITIALIZED = 0] = "INITIALIZED", e[e.LOADING = 1] = "LOADING", e[e.SUCCESS = 2] = "SUCCESS", e[e.FAILURE = 3] = "FAILURE";
})(B3 || (B3 = {}));
function N3(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ky(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? N3(Object(n), !0).forEach(function(r) {
      Le(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : N3(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var F3 = {}, z3 = {
  options(e, t) {
    e.setOptions(t);
  }
};
function Y2e(e) {
  var {
    options: t,
    onLoad: n,
    onUnmount: r
  } = e, o = ge(Bt), [i, a] = k(null);
  return h(() => {
    i !== null && i.setMap(o);
  }, [o]), h(() => {
    t && i !== null && i.setOptions(t);
  }, [i, t]), h(() => {
    var s = new google.maps.TrafficLayer(ky(ky({}, t), {}, {
      map: o
    }));
    return a(s), n && n(s), () => {
      i !== null && (r && r(i), i.setMap(null));
    };
  }, []), null;
}
ve(Y2e);
class X2e extends pe {
  constructor() {
    super(...arguments), Le(this, "state", {
      trafficLayer: null
    }), Le(this, "setTrafficLayerCallback", () => {
      this.state.trafficLayer !== null && this.props.onLoad && this.props.onLoad(this.state.trafficLayer);
    }), Le(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = new google.maps.TrafficLayer(ky(ky({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = dn({
      updaterMap: z3,
      eventMap: F3,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        trafficLayer: t
      };
    }, this.setTrafficLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.trafficLayer !== null && (yn(this.registeredEvents), this.registeredEvents = dn({
      updaterMap: z3,
      eventMap: F3,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.trafficLayer
    }));
  }
  componentWillUnmount() {
    this.state.trafficLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.trafficLayer), yn(this.registeredEvents), this.state.trafficLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Le(X2e, "contextType", Bt);
function J2e(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = ge(Bt), [o, i] = k(null);
  return h(() => {
    o !== null && o.setMap(r);
  }, [r]), h(() => {
    var a = new google.maps.BicyclingLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      a !== null && (n && n(a), a.setMap(null));
    };
  }, []), null;
}
ve(J2e);
class Q2e extends pe {
  constructor() {
    super(...arguments), Le(this, "state", {
      bicyclingLayer: null
    }), Le(this, "setBicyclingLayerCallback", () => {
      this.state.bicyclingLayer !== null && (this.state.bicyclingLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.bicyclingLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.BicyclingLayer();
    this.setState(() => ({
      bicyclingLayer: t
    }), this.setBicyclingLayerCallback);
  }
  componentWillUnmount() {
    this.state.bicyclingLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.bicyclingLayer), this.state.bicyclingLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Le(Q2e, "contextType", Bt);
function eze(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = ge(Bt), [o, i] = k(null);
  return h(() => {
    o !== null && o.setMap(r);
  }, [r]), h(() => {
    var a = new google.maps.TransitLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      o !== null && (n && n(o), o.setMap(null));
    };
  }, []), null;
}
ve(eze);
class tze extends pe {
  constructor() {
    super(...arguments), Le(this, "state", {
      transitLayer: null
    }), Le(this, "setTransitLayerCallback", () => {
      this.state.transitLayer !== null && (this.state.transitLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.transitLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.TransitLayer();
    this.setState(function() {
      return {
        transitLayer: t
      };
    }, this.setTransitLayerCallback);
  }
  componentWillUnmount() {
    this.state.transitLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.transitLayer), this.state.transitLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Le(tze, "contextType", Bt);
function U3(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Ly(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? U3(Object(n), !0).forEach(function(r) {
      Le(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : U3(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var H3 = {
  onCircleComplete: "circlecomplete",
  onMarkerComplete: "markercomplete",
  onOverlayComplete: "overlaycomplete",
  onPolygonComplete: "polygoncomplete",
  onPolylineComplete: "polylinecomplete",
  onRectangleComplete: "rectanglecomplete"
}, $3 = {
  drawingMode(e, t) {
    e.setDrawingMode(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function nze(e) {
  var {
    options: t,
    drawingMode: n,
    onCircleComplete: r,
    onMarkerComplete: o,
    onOverlayComplete: i,
    onPolygonComplete: a,
    onPolylineComplete: s,
    onRectangleComplete: l,
    onLoad: u,
    onUnmount: c
  } = e, p = ge(Bt), [d, g] = k(null), [f, m] = k(null), [v, E] = k(null), [w, M] = k(null), [O, y] = k(null), [C, _] = k(null), [F, L] = k(null);
  return h(() => {
    d !== null && d.setMap(p);
  }, [p]), h(() => {
    t && d !== null && d.setOptions(t);
  }, [d, t]), h(() => {
    d !== null && d.setDrawingMode(n ?? null);
  }, [d, n]), h(() => {
    d && r && (f !== null && google.maps.event.removeListener(f), m(google.maps.event.addListener(d, "circlecomplete", r)));
  }, [d, r]), h(() => {
    d && o && (v !== null && google.maps.event.removeListener(v), E(google.maps.event.addListener(d, "markercomplete", o)));
  }, [d, o]), h(() => {
    d && i && (w !== null && google.maps.event.removeListener(w), M(google.maps.event.addListener(d, "overlaycomplete", i)));
  }, [d, i]), h(() => {
    d && a && (O !== null && google.maps.event.removeListener(O), y(google.maps.event.addListener(d, "polygoncomplete", a)));
  }, [d, a]), h(() => {
    d && s && (C !== null && google.maps.event.removeListener(C), _(google.maps.event.addListener(d, "polylinecomplete", s)));
  }, [d, s]), h(() => {
    d && l && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(d, "rectanglecomplete", l)));
  }, [d, l]), h(() => {
    Oo(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
    var N = new google.maps.drawing.DrawingManager(Ly(Ly({}, t), {}, {
      map: p
    }));
    return n && N.setDrawingMode(n), r && m(google.maps.event.addListener(N, "circlecomplete", r)), o && E(google.maps.event.addListener(N, "markercomplete", o)), i && M(google.maps.event.addListener(N, "overlaycomplete", i)), a && y(google.maps.event.addListener(N, "polygoncomplete", a)), s && _(google.maps.event.addListener(N, "polylinecomplete", s)), l && L(google.maps.event.addListener(N, "rectanglecomplete", l)), g(N), u && u(N), () => {
      d !== null && (f && google.maps.event.removeListener(f), v && google.maps.event.removeListener(v), w && google.maps.event.removeListener(w), O && google.maps.event.removeListener(O), C && google.maps.event.removeListener(C), F && google.maps.event.removeListener(F), c && c(d), d.setMap(null));
    };
  }, []), null;
}
ve(nze);
class rze extends pe {
  constructor(t) {
    super(t), Le(this, "registeredEvents", []), Le(this, "state", {
      drawingManager: null
    }), Le(this, "setDrawingManagerCallback", () => {
      this.state.drawingManager !== null && this.props.onLoad && this.props.onLoad(this.state.drawingManager);
    }), Oo(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
  }
  componentDidMount() {
    var t = new google.maps.drawing.DrawingManager(Ly(Ly({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = dn({
      updaterMap: $3,
      eventMap: H3,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        drawingManager: t
      };
    }, this.setDrawingManagerCallback);
  }
  componentDidUpdate(t) {
    this.state.drawingManager !== null && (yn(this.registeredEvents), this.registeredEvents = dn({
      updaterMap: $3,
      eventMap: H3,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.drawingManager
    }));
  }
  componentWillUnmount() {
    this.state.drawingManager !== null && (this.props.onUnmount && this.props.onUnmount(this.state.drawingManager), yn(this.registeredEvents), this.state.drawingManager.setMap(null));
  }
  render() {
    return null;
  }
}
Le(rze, "contextType", Bt);
function W3(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function lc(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? W3(Object(n), !0).forEach(function(r) {
      Le(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : W3(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var V3 = {
  onAnimationChanged: "animation_changed",
  onClick: "click",
  onClickableChanged: "clickable_changed",
  onCursorChanged: "cursor_changed",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDraggableChanged: "draggable_changed",
  onDragStart: "dragstart",
  onFlatChanged: "flat_changed",
  onIconChanged: "icon_changed",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onPositionChanged: "position_changed",
  onRightClick: "rightclick",
  onShapeChanged: "shape_changed",
  onTitleChanged: "title_changed",
  onVisibleChanged: "visible_changed",
  onZindexChanged: "zindex_changed"
}, Z3 = {
  animation(e, t) {
    e.setAnimation(t);
  },
  clickable(e, t) {
    e.setClickable(t);
  },
  cursor(e, t) {
    e.setCursor(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  icon(e, t) {
    e.setIcon(t);
  },
  label(e, t) {
    e.setLabel(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  opacity(e, t) {
    e.setOpacity(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  shape(e, t) {
    e.setShape(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, Py = {};
function oze(e) {
  var {
    position: t,
    options: n,
    clusterer: r,
    noClustererRedraw: o,
    children: i,
    draggable: a,
    visible: s,
    animation: l,
    clickable: u,
    cursor: c,
    icon: p,
    label: d,
    opacity: g,
    shape: f,
    title: m,
    zIndex: v,
    onClick: E,
    onDblClick: w,
    onDrag: M,
    onDragEnd: O,
    onDragStart: y,
    onMouseOut: C,
    onMouseOver: _,
    onMouseUp: F,
    onMouseDown: L,
    onRightClick: N,
    onClickableChanged: R,
    onCursorChanged: W,
    onAnimationChanged: V,
    onDraggableChanged: z,
    onFlatChanged: Z,
    onIconChanged: K,
    onPositionChanged: X,
    onShapeChanged: te,
    onTitleChanged: J,
    onVisibleChanged: P,
    onZindexChanged: D,
    onLoad: H,
    onUnmount: S
  } = e, $ = ge(Bt), [x, j] = k(null), [U, T] = k(null), [q, A] = k(null), [Y, B] = k(null), [ue, fe] = k(null), [oe, Ae] = k(null), [Ze, Ge] = k(null), [Ie, et] = k(null), [Ye, _e] = k(null), [Qe, at] = k(null), [Pe, Me] = k(null), [Je, We] = k(null), [Re, nt] = k(null), [De, yt] = k(null), [ot, st] = k(null), [ct, bt] = k(null), [pt, dt] = k(null), [tt, Xe] = k(null), [wt, Ct] = k(null), [ft, bn] = k(null), [ht, wn] = k(null), [gt, Mt] = k(null);
  h(() => {
    x !== null && x.setMap($);
  }, [$]), h(() => {
    typeof n < "u" && x !== null && x.setOptions(n);
  }, [x, n]), h(() => {
    typeof a < "u" && x !== null && x.setDraggable(a);
  }, [x, a]), h(() => {
    t && x !== null && x.setPosition(t);
  }, [x, t]), h(() => {
    typeof s < "u" && x !== null && x.setVisible(s);
  }, [x, s]), h(() => {
    x == null || x.setAnimation(l);
  }, [x, l]), h(() => {
    x && u !== void 0 && x.setClickable(u);
  }, [x, u]), h(() => {
    x && c !== void 0 && x.setCursor(c);
  }, [x, c]), h(() => {
    x && p !== void 0 && x.setIcon(p);
  }, [x, p]), h(() => {
    x && d !== void 0 && x.setLabel(d);
  }, [x, d]), h(() => {
    x && g !== void 0 && x.setOpacity(g);
  }, [x, g]), h(() => {
    x && f !== void 0 && x.setShape(f);
  }, [x, f]), h(() => {
    x && m !== void 0 && x.setTitle(m);
  }, [x, m]), h(() => {
    x && v !== void 0 && x.setZIndex(v);
  }, [x, v]), h(() => {
    x && w && (U !== null && google.maps.event.removeListener(U), T(google.maps.event.addListener(x, "dblclick", w)));
  }, [w]), h(() => {
    x && O && (q !== null && google.maps.event.removeListener(q), A(google.maps.event.addListener(x, "dragend", O)));
  }, [O]), h(() => {
    x && y && (Y !== null && google.maps.event.removeListener(Y), B(google.maps.event.addListener(x, "dragstart", y)));
  }, [y]), h(() => {
    x && L && (ue !== null && google.maps.event.removeListener(ue), fe(google.maps.event.addListener(x, "mousedown", L)));
  }, [L]), h(() => {
    x && C && (oe !== null && google.maps.event.removeListener(oe), Ae(google.maps.event.addListener(x, "mouseout", C)));
  }, [C]), h(() => {
    x && _ && (Ze !== null && google.maps.event.removeListener(Ze), Ge(google.maps.event.addListener(x, "mouseover", _)));
  }, [_]), h(() => {
    x && F && (Ie !== null && google.maps.event.removeListener(Ie), et(google.maps.event.addListener(x, "mouseup", F)));
  }, [F]), h(() => {
    x && N && (Ye !== null && google.maps.event.removeListener(Ye), _e(google.maps.event.addListener(x, "rightclick", N)));
  }, [N]), h(() => {
    x && E && (Qe !== null && google.maps.event.removeListener(Qe), at(google.maps.event.addListener(x, "click", E)));
  }, [E]), h(() => {
    x && M && (Pe !== null && google.maps.event.removeListener(Pe), Me(google.maps.event.addListener(x, "drag", M)));
  }, [M]), h(() => {
    x && R && (Je !== null && google.maps.event.removeListener(Je), We(google.maps.event.addListener(x, "clickable_changed", R)));
  }, [R]), h(() => {
    x && W && (Re !== null && google.maps.event.removeListener(Re), nt(google.maps.event.addListener(x, "cursor_changed", W)));
  }, [W]), h(() => {
    x && V && (De !== null && google.maps.event.removeListener(De), yt(google.maps.event.addListener(x, "animation_changed", V)));
  }, [V]), h(() => {
    x && z && (ot !== null && google.maps.event.removeListener(ot), st(google.maps.event.addListener(x, "draggable_changed", z)));
  }, [z]), h(() => {
    x && Z && (ct !== null && google.maps.event.removeListener(ct), bt(google.maps.event.addListener(x, "flat_changed", Z)));
  }, [Z]), h(() => {
    x && K && (pt !== null && google.maps.event.removeListener(pt), dt(google.maps.event.addListener(x, "icon_changed", K)));
  }, [K]), h(() => {
    x && X && (tt !== null && google.maps.event.removeListener(tt), Xe(google.maps.event.addListener(x, "position_changed", X)));
  }, [X]), h(() => {
    x && te && (wt !== null && google.maps.event.removeListener(wt), Ct(google.maps.event.addListener(x, "shape_changed", te)));
  }, [te]), h(() => {
    x && J && (ft !== null && google.maps.event.removeListener(ft), bn(google.maps.event.addListener(x, "title_changed", J)));
  }, [J]), h(() => {
    x && P && (ht !== null && google.maps.event.removeListener(ht), wn(google.maps.event.addListener(x, "visible_changed", P)));
  }, [P]), h(() => {
    x && D && (gt !== null && google.maps.event.removeListener(gt), Mt(google.maps.event.addListener(x, "zindex_changed", D)));
  }, [D]), h(() => {
    var mt = lc(lc(lc({}, n || Py), r ? Py : {
      map: $
    }), {}, {
      position: t
    }), re = new google.maps.Marker(mt);
    return r ? r.addMarker(re, !!o) : re.setMap($), t && re.setPosition(t), typeof s < "u" && re.setVisible(s), typeof a < "u" && re.setDraggable(a), typeof u < "u" && re.setClickable(u), typeof c == "string" && re.setCursor(c), p && re.setIcon(p), typeof d < "u" && re.setLabel(d), typeof g < "u" && re.setOpacity(g), f && re.setShape(f), typeof m == "string" && re.setTitle(m), typeof v == "number" && re.setZIndex(v), w && T(google.maps.event.addListener(re, "dblclick", w)), O && A(google.maps.event.addListener(re, "dragend", O)), y && B(google.maps.event.addListener(re, "dragstart", y)), L && fe(google.maps.event.addListener(re, "mousedown", L)), C && Ae(google.maps.event.addListener(re, "mouseout", C)), _ && Ge(google.maps.event.addListener(re, "mouseover", _)), F && et(google.maps.event.addListener(re, "mouseup", F)), N && _e(google.maps.event.addListener(re, "rightclick", N)), E && at(google.maps.event.addListener(re, "click", E)), M && Me(google.maps.event.addListener(re, "drag", M)), R && We(google.maps.event.addListener(re, "clickable_changed", R)), W && nt(google.maps.event.addListener(re, "cursor_changed", W)), V && yt(google.maps.event.addListener(re, "animation_changed", V)), z && st(google.maps.event.addListener(re, "draggable_changed", z)), Z && bt(google.maps.event.addListener(re, "flat_changed", Z)), K && dt(google.maps.event.addListener(re, "icon_changed", K)), X && Xe(google.maps.event.addListener(re, "position_changed", X)), te && Ct(google.maps.event.addListener(re, "shape_changed", te)), J && bn(google.maps.event.addListener(re, "title_changed", J)), P && wn(google.maps.event.addListener(re, "visible_changed", P)), D && Mt(google.maps.event.addListener(re, "zindex_changed", D)), j(re), H && H(re), () => {
      U !== null && google.maps.event.removeListener(U), q !== null && google.maps.event.removeListener(q), Y !== null && google.maps.event.removeListener(Y), ue !== null && google.maps.event.removeListener(ue), oe !== null && google.maps.event.removeListener(oe), Ze !== null && google.maps.event.removeListener(Ze), Ie !== null && google.maps.event.removeListener(Ie), Ye !== null && google.maps.event.removeListener(Ye), Qe !== null && google.maps.event.removeListener(Qe), Je !== null && google.maps.event.removeListener(Je), Re !== null && google.maps.event.removeListener(Re), De !== null && google.maps.event.removeListener(De), ot !== null && google.maps.event.removeListener(ot), ct !== null && google.maps.event.removeListener(ct), pt !== null && google.maps.event.removeListener(pt), tt !== null && google.maps.event.removeListener(tt), ft !== null && google.maps.event.removeListener(ft), ht !== null && google.maps.event.removeListener(ht), gt !== null && google.maps.event.removeListener(gt), S && S(re), r ? r.removeMarker(re, !!o) : re && re.setMap(null);
    };
  }, []);
  var ir = Cn(() => i ? lt.map(i, (mt) => {
    if (!yi(mt))
      return mt;
    var re = mt;
    return bi(re, {
      anchor: x
    });
  }) : null, [i, x]);
  return Sn.jsx(Sn.Fragment, {
    children: ir
  }) || null;
}
ve(oze);
class ize extends pe {
  constructor() {
    super(...arguments), Le(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this;
    return DY(function* () {
      var n = lc(lc(lc({}, t.props.options || Py), t.props.clusterer ? Py : {
        map: t.context
      }), {}, {
        position: t.props.position
      });
      t.marker = new google.maps.Marker(n), t.props.clusterer ? t.props.clusterer.addMarker(t.marker, !!t.props.noClustererRedraw) : t.marker.setMap(t.context), t.registeredEvents = dn({
        updaterMap: Z3,
        eventMap: V3,
        prevProps: {},
        nextProps: t.props,
        instance: t.marker
      }), t.props.onLoad && t.props.onLoad(t.marker);
    })();
  }
  componentDidUpdate(t) {
    this.marker && (yn(this.registeredEvents), this.registeredEvents = dn({
      updaterMap: Z3,
      eventMap: V3,
      prevProps: t,
      nextProps: this.props,
      instance: this.marker
    }));
  }
  componentWillUnmount() {
    this.marker && (this.props.onUnmount && this.props.onUnmount(this.marker), yn(this.registeredEvents), this.props.clusterer ? this.props.clusterer.removeMarker(this.marker, !!this.props.noClustererRedraw) : this.marker && this.marker.setMap(null));
  }
  render() {
    var t = this.props.children ? lt.map(this.props.children, (n) => {
      if (!yi(n))
        return n;
      var r = n;
      return bi(r, {
        anchor: this.marker
      });
    }) : null;
    return t || null;
  }
}
Le(ize, "contextType", Bt);
var sze = (
  /** @class */
  function() {
    function e(t, n) {
      t.getClusterer().extend(e, google.maps.OverlayView), this.cluster = t, this.clusterClassName = this.cluster.getClusterer().getClusterClass(), this.className = this.clusterClassName, this.styles = n, this.center = void 0, this.div = null, this.sums = null, this.visible = !1, this.boundsChangedListener = null, this.url = "", this.height = 0, this.width = 0, this.anchorText = [0, 0], this.anchorIcon = [0, 0], this.textColor = "black", this.textSize = 11, this.textDecoration = "none", this.fontWeight = "bold", this.fontStyle = "normal", this.fontFamily = "Arial,sans-serif", this.backgroundPosition = "0 0", this.cMouseDownInCluster = null, this.cDraggingMapByCluster = null, this.timeOut = null, this.setMap(t.getMap()), this.onBoundsChanged = this.onBoundsChanged.bind(this), this.onMouseDown = this.onMouseDown.bind(this), this.onClick = this.onClick.bind(this), this.onMouseOver = this.onMouseOver.bind(this), this.onMouseOut = this.onMouseOut.bind(this), this.onAdd = this.onAdd.bind(this), this.onRemove = this.onRemove.bind(this), this.draw = this.draw.bind(this), this.hide = this.hide.bind(this), this.show = this.show.bind(this), this.useStyle = this.useStyle.bind(this), this.setCenter = this.setCenter.bind(this), this.getPosFromLatLng = this.getPosFromLatLng.bind(this);
    }
    return e.prototype.onBoundsChanged = function() {
      this.cDraggingMapByCluster = this.cMouseDownInCluster;
    }, e.prototype.onMouseDown = function() {
      this.cMouseDownInCluster = !0, this.cDraggingMapByCluster = !1;
    }, e.prototype.onClick = function(t) {
      if (this.cMouseDownInCluster = !1, !this.cDraggingMapByCluster) {
        var n = this.cluster.getClusterer();
        if (google.maps.event.trigger(n, "click", this.cluster), google.maps.event.trigger(n, "clusterclick", this.cluster), n.getZoomOnClick()) {
          var r = n.getMaxZoom(), o = this.cluster.getBounds(), i = n.getMap();
          i !== null && "fitBounds" in i && i.fitBounds(o), this.timeOut = window.setTimeout(function() {
            var a = n.getMap();
            if (a !== null) {
              "fitBounds" in a && a.fitBounds(o);
              var s = a.getZoom() || 0;
              r !== null && s > r && a.setZoom(r + 1);
            }
          }, 100);
        }
        t.cancelBubble = !0, t.stopPropagation && t.stopPropagation();
      }
    }, e.prototype.onMouseOver = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseover", this.cluster);
    }, e.prototype.onMouseOut = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseout", this.cluster);
    }, e.prototype.onAdd = function() {
      var t;
      this.div = document.createElement("div"), this.div.className = this.className, this.visible && this.show(), (t = this.getPanes()) === null || t === void 0 || t.overlayMouseTarget.appendChild(this.div);
      var n = this.getMap();
      n !== null && (this.boundsChangedListener = google.maps.event.addListener(n, "bounds_changed", this.onBoundsChanged), this.div.addEventListener("mousedown", this.onMouseDown), this.div.addEventListener("click", this.onClick), this.div.addEventListener("mouseover", this.onMouseOver), this.div.addEventListener("mouseout", this.onMouseOut));
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.hide(), this.boundsChangedListener !== null && google.maps.event.removeListener(this.boundsChangedListener), this.div.removeEventListener("mousedown", this.onMouseDown), this.div.removeEventListener("click", this.onClick), this.div.removeEventListener("mouseover", this.onMouseOver), this.div.removeEventListener("mouseout", this.onMouseOut), this.div.parentNode.removeChild(this.div), this.timeOut !== null && (window.clearTimeout(this.timeOut), this.timeOut = null), this.div = null);
    }, e.prototype.draw = function() {
      if (this.visible && this.div !== null && this.center) {
        var t = this.getPosFromLatLng(this.center);
        this.div.style.top = t !== null ? "".concat(t.y, "px") : "0", this.div.style.left = t !== null ? "".concat(t.x, "px") : "0";
      }
    }, e.prototype.hide = function() {
      this.div && (this.div.style.display = "none"), this.visible = !1;
    }, e.prototype.show = function() {
      var t, n, r, o, i, a;
      if (this.div && this.center) {
        var s = this.sums === null || typeof this.sums.title > "u" || this.sums.title === "" ? this.cluster.getClusterer().getTitle() : this.sums.title, l = this.backgroundPosition.split(" "), u = parseInt(((t = l[0]) === null || t === void 0 ? void 0 : t.replace(/^\s+|\s+$/g, "")) || "0", 10), c = parseInt(((n = l[1]) === null || n === void 0 ? void 0 : n.replace(/^\s+|\s+$/g, "")) || "0", 10), p = this.getPosFromLatLng(this.center);
        this.div.className = this.className, this.div.setAttribute("style", "cursor: pointer; position: absolute; top: ".concat(p !== null ? "".concat(p.y, "px") : "0", "; left: ").concat(p !== null ? "".concat(p.x, "px") : "0", "; width: ").concat(this.width, "px; height: ").concat(this.height, "px; "));
        var d = document.createElement("img");
        d.alt = s, d.src = this.url, d.width = this.width, d.height = this.height, d.setAttribute("style", "position: absolute; top: ".concat(c, "px; left: ").concat(u, "px")), this.cluster.getClusterer().enableRetinaIcons || (d.style.clip = "rect(-".concat(c, "px, -").concat(u + this.width, "px, -").concat(c + this.height, ", -").concat(u, ")"));
        var g = document.createElement("div");
        g.setAttribute("style", "position: absolute; top: ".concat(this.anchorText[0], "px; left: ").concat(this.anchorText[1], "px; color: ").concat(this.textColor, "; font-size: ").concat(this.textSize, "px; font-family: ").concat(this.fontFamily, "; font-weight: ").concat(this.fontWeight, "; fontStyle: ").concat(this.fontStyle, "; text-decoration: ").concat(this.textDecoration, "; text-align: center; width: ").concat(this.width, "px; line-height: ").concat(this.height, "px")), !((r = this.sums) === null || r === void 0) && r.text && (g.innerText = "".concat((o = this.sums) === null || o === void 0 ? void 0 : o.text)), !((i = this.sums) === null || i === void 0) && i.html && (g.innerHTML = "".concat((a = this.sums) === null || a === void 0 ? void 0 : a.html)), this.div.innerHTML = "", this.div.appendChild(d), this.div.appendChild(g), this.div.title = s, this.div.style.display = "";
      }
      this.visible = !0;
    }, e.prototype.useStyle = function(t) {
      this.sums = t;
      var n = this.cluster.getClusterer().getStyles(), r = n[Math.min(n.length - 1, Math.max(0, t.index - 1))];
      r && (this.url = r.url, this.height = r.height, this.width = r.width, r.className && (this.className = "".concat(this.clusterClassName, " ").concat(r.className)), this.anchorText = r.anchorText || [0, 0], this.anchorIcon = r.anchorIcon || [this.height / 2, this.width / 2], this.textColor = r.textColor || "black", this.textSize = r.textSize || 11, this.textDecoration = r.textDecoration || "none", this.fontWeight = r.fontWeight || "bold", this.fontStyle = r.fontStyle || "normal", this.fontFamily = r.fontFamily || "Arial,sans-serif", this.backgroundPosition = r.backgroundPosition || "0 0");
    }, e.prototype.setCenter = function(t) {
      this.center = t;
    }, e.prototype.getPosFromLatLng = function(t) {
      var n = this.getProjection().fromLatLngToDivPixel(t);
      return n !== null && (n.x -= this.anchorIcon[1], n.y -= this.anchorIcon[0]), n;
    }, e;
  }()
), aze = (
  /** @class */
  function() {
    function e(t) {
      this.markerClusterer = t, this.map = this.markerClusterer.getMap(), this.gridSize = this.markerClusterer.getGridSize(), this.minClusterSize = this.markerClusterer.getMinimumClusterSize(), this.averageCenter = this.markerClusterer.getAverageCenter(), this.markers = [], this.center = void 0, this.bounds = null, this.clusterIcon = new sze(this, this.markerClusterer.getStyles()), this.getSize = this.getSize.bind(this), this.getMarkers = this.getMarkers.bind(this), this.getCenter = this.getCenter.bind(this), this.getMap = this.getMap.bind(this), this.getClusterer = this.getClusterer.bind(this), this.getBounds = this.getBounds.bind(this), this.remove = this.remove.bind(this), this.addMarker = this.addMarker.bind(this), this.isMarkerInClusterBounds = this.isMarkerInClusterBounds.bind(this), this.calculateBounds = this.calculateBounds.bind(this), this.updateIcon = this.updateIcon.bind(this), this.isMarkerAlreadyAdded = this.isMarkerAlreadyAdded.bind(this);
    }
    return e.prototype.getSize = function() {
      return this.markers.length;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getCenter = function() {
      return this.center;
    }, e.prototype.getMap = function() {
      return this.map;
    }, e.prototype.getClusterer = function() {
      return this.markerClusterer;
    }, e.prototype.getBounds = function() {
      for (var t = new google.maps.LatLngBounds(this.center, this.center), n = this.getMarkers(), r = 0, o = n; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && t.extend(a);
      }
      return t;
    }, e.prototype.remove = function() {
      this.clusterIcon.setMap(null), this.markers = [], delete this.markers;
    }, e.prototype.addMarker = function(t) {
      var n;
      if (this.isMarkerAlreadyAdded(t))
        return !1;
      if (this.center) {
        if (this.averageCenter) {
          var r = t.getPosition();
          if (r) {
            var o = this.markers.length + 1;
            this.center = new google.maps.LatLng((this.center.lat() * (o - 1) + r.lat()) / o, (this.center.lng() * (o - 1) + r.lng()) / o), this.calculateBounds();
          }
        }
      } else {
        var r = t.getPosition();
        r && (this.center = r, this.calculateBounds());
      }
      t.isAdded = !0, this.markers.push(t);
      var i = this.markers.length, a = this.markerClusterer.getMaxZoom(), s = (n = this.map) === null || n === void 0 ? void 0 : n.getZoom();
      if (a !== null && typeof s < "u" && s > a)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i < this.minClusterSize)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i === this.minClusterSize)
        for (var l = 0, u = this.markers; l < u.length; l++) {
          var c = u[l];
          c.setMap(null);
        }
      else
        t.setMap(null);
      return !0;
    }, e.prototype.isMarkerInClusterBounds = function(t) {
      if (this.bounds !== null) {
        var n = t.getPosition();
        if (n)
          return this.bounds.contains(n);
      }
      return !1;
    }, e.prototype.calculateBounds = function() {
      this.bounds = this.markerClusterer.getExtendedBounds(new google.maps.LatLngBounds(this.center, this.center));
    }, e.prototype.updateIcon = function() {
      var t, n = this.markers.length, r = this.markerClusterer.getMaxZoom(), o = (t = this.map) === null || t === void 0 ? void 0 : t.getZoom();
      if (r !== null && typeof o < "u" && o > r) {
        this.clusterIcon.hide();
        return;
      }
      if (n < this.minClusterSize) {
        this.clusterIcon.hide();
        return;
      }
      this.center && this.clusterIcon.setCenter(this.center), this.clusterIcon.useStyle(this.markerClusterer.getCalculator()(this.markers, this.markerClusterer.getStyles().length)), this.clusterIcon.show();
    }, e.prototype.isMarkerAlreadyAdded = function(t) {
      if (this.markers.includes)
        return this.markers.includes(t);
      for (var n = 0; n < this.markers.length; n++)
        if (t === this.markers[n])
          return !0;
      return !1;
    }, e;
  }()
);
function lze(e, t) {
  var n = e.length, r = n.toString().length, o = Math.min(r, t);
  return {
    text: n.toString(),
    index: o,
    title: ""
  };
}
var uze = 2e3, cze = 500, pze = "https://developers.google.com/maps/documentation/javascript/examples/markerclusterer/m", dze = "png", fze = [53, 56, 66, 78, 90], hze = "cluster", RY = (
  /** @class */
  function() {
    function e(t, n, r) {
      n === void 0 && (n = []), r === void 0 && (r = {}), this.getMinimumClusterSize = this.getMinimumClusterSize.bind(this), this.setMinimumClusterSize = this.setMinimumClusterSize.bind(this), this.getEnableRetinaIcons = this.getEnableRetinaIcons.bind(this), this.setEnableRetinaIcons = this.setEnableRetinaIcons.bind(this), this.addToClosestCluster = this.addToClosestCluster.bind(this), this.getImageExtension = this.getImageExtension.bind(this), this.setImageExtension = this.setImageExtension.bind(this), this.getExtendedBounds = this.getExtendedBounds.bind(this), this.getAverageCenter = this.getAverageCenter.bind(this), this.setAverageCenter = this.setAverageCenter.bind(this), this.getTotalClusters = this.getTotalClusters.bind(this), this.fitMapToMarkers = this.fitMapToMarkers.bind(this), this.getIgnoreHidden = this.getIgnoreHidden.bind(this), this.setIgnoreHidden = this.setIgnoreHidden.bind(this), this.getClusterClass = this.getClusterClass.bind(this), this.setClusterClass = this.setClusterClass.bind(this), this.getTotalMarkers = this.getTotalMarkers.bind(this), this.getZoomOnClick = this.getZoomOnClick.bind(this), this.setZoomOnClick = this.setZoomOnClick.bind(this), this.getBatchSizeIE = this.getBatchSizeIE.bind(this), this.setBatchSizeIE = this.setBatchSizeIE.bind(this), this.createClusters = this.createClusters.bind(this), this.onZoomChanged = this.onZoomChanged.bind(this), this.getImageSizes = this.getImageSizes.bind(this), this.setImageSizes = this.setImageSizes.bind(this), this.getCalculator = this.getCalculator.bind(this), this.setCalculator = this.setCalculator.bind(this), this.removeMarkers = this.removeMarkers.bind(this), this.resetViewport = this.resetViewport.bind(this), this.getImagePath = this.getImagePath.bind(this), this.setImagePath = this.setImagePath.bind(this), this.pushMarkerTo = this.pushMarkerTo.bind(this), this.removeMarker = this.removeMarker.bind(this), this.clearMarkers = this.clearMarkers.bind(this), this.setupStyles = this.setupStyles.bind(this), this.getGridSize = this.getGridSize.bind(this), this.setGridSize = this.setGridSize.bind(this), this.getClusters = this.getClusters.bind(this), this.getMaxZoom = this.getMaxZoom.bind(this), this.setMaxZoom = this.setMaxZoom.bind(this), this.getMarkers = this.getMarkers.bind(this), this.addMarkers = this.addMarkers.bind(this), this.getStyles = this.getStyles.bind(this), this.setStyles = this.setStyles.bind(this), this.addMarker = this.addMarker.bind(this), this.onRemove = this.onRemove.bind(this), this.getTitle = this.getTitle.bind(this), this.setTitle = this.setTitle.bind(this), this.repaint = this.repaint.bind(this), this.onIdle = this.onIdle.bind(this), this.redraw = this.redraw.bind(this), this.onAdd = this.onAdd.bind(this), this.draw = this.draw.bind(this), this.extend = this.extend.bind(this), this.extend(e, google.maps.OverlayView), this.markers = [], this.clusters = [], this.listeners = [], this.activeMap = null, this.ready = !1, this.gridSize = r.gridSize || 60, this.minClusterSize = r.minimumClusterSize || 2, this.maxZoom = r.maxZoom || null, this.styles = r.styles || [], this.title = r.title || "", this.zoomOnClick = !0, r.zoomOnClick !== void 0 && (this.zoomOnClick = r.zoomOnClick), this.averageCenter = !1, r.averageCenter !== void 0 && (this.averageCenter = r.averageCenter), this.ignoreHidden = !1, r.ignoreHidden !== void 0 && (this.ignoreHidden = r.ignoreHidden), this.enableRetinaIcons = !1, r.enableRetinaIcons !== void 0 && (this.enableRetinaIcons = r.enableRetinaIcons), this.imagePath = r.imagePath || pze, this.imageExtension = r.imageExtension || dze, this.imageSizes = r.imageSizes || fze, this.calculator = r.calculator || lze, this.batchSize = r.batchSize || uze, this.batchSizeIE = r.batchSizeIE || cze, this.clusterClass = r.clusterClass || hze, navigator.userAgent.toLowerCase().indexOf("msie") !== -1 && (this.batchSize = this.batchSizeIE), this.timerRefStatic = null, this.setupStyles(), this.addMarkers(n, !0), this.setMap(t);
    }
    return e.prototype.onZoomChanged = function() {
      var t, n;
      this.resetViewport(!1), (((t = this.getMap()) === null || t === void 0 ? void 0 : t.getZoom()) === (this.get("minZoom") || 0) || ((n = this.getMap()) === null || n === void 0 ? void 0 : n.getZoom()) === this.get("maxZoom")) && google.maps.event.trigger(this, "idle");
    }, e.prototype.onIdle = function() {
      this.redraw();
    }, e.prototype.onAdd = function() {
      var t = this.getMap();
      this.activeMap = t, this.ready = !0, this.repaint(), t !== null && (this.listeners = [google.maps.event.addListener(t, "zoom_changed", this.onZoomChanged), google.maps.event.addListener(t, "idle", this.onIdle)]);
    }, e.prototype.onRemove = function() {
      for (var t = 0, n = this.markers; t < n.length; t++) {
        var r = n[t];
        r.getMap() !== this.activeMap && r.setMap(this.activeMap);
      }
      for (var o = 0, i = this.clusters; o < i.length; o++) {
        var a = i[o];
        a.remove();
      }
      this.clusters = [];
      for (var s = 0, l = this.listeners; s < l.length; s++) {
        var u = l[s];
        google.maps.event.removeListener(u);
      }
      this.listeners = [], this.activeMap = null, this.ready = !1;
    }, e.prototype.draw = function() {
    }, e.prototype.getMap = function() {
      return null;
    }, e.prototype.getPanes = function() {
      return null;
    }, e.prototype.getProjection = function() {
      return {
        fromContainerPixelToLatLng: function() {
          return null;
        },
        fromDivPixelToLatLng: function() {
          return null;
        },
        fromLatLngToContainerPixel: function() {
          return null;
        },
        fromLatLngToDivPixel: function() {
          return null;
        },
        getVisibleRegion: function() {
          return null;
        },
        getWorldWidth: function() {
          return 0;
        }
      };
    }, e.prototype.setMap = function() {
    }, e.prototype.addListener = function() {
      return {
        remove: function() {
        }
      };
    }, e.prototype.bindTo = function() {
    }, e.prototype.get = function() {
    }, e.prototype.notify = function() {
    }, e.prototype.set = function() {
    }, e.prototype.setValues = function() {
    }, e.prototype.unbind = function() {
    }, e.prototype.unbindAll = function() {
    }, e.prototype.setupStyles = function() {
      if (!(this.styles.length > 0))
        for (var t = 0; t < this.imageSizes.length; t++)
          this.styles.push({
            url: "".concat(this.imagePath + (t + 1), ".").concat(this.imageExtension),
            height: this.imageSizes[t] || 0,
            width: this.imageSizes[t] || 0
          });
    }, e.prototype.fitMapToMarkers = function() {
      for (var t = this.getMarkers(), n = new google.maps.LatLngBounds(), r = 0, o = t; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && n.extend(a);
      }
      var s = this.getMap();
      s !== null && "fitBounds" in s && s.fitBounds(n);
    }, e.prototype.getGridSize = function() {
      return this.gridSize;
    }, e.prototype.setGridSize = function(t) {
      this.gridSize = t;
    }, e.prototype.getMinimumClusterSize = function() {
      return this.minClusterSize;
    }, e.prototype.setMinimumClusterSize = function(t) {
      this.minClusterSize = t;
    }, e.prototype.getMaxZoom = function() {
      return this.maxZoom;
    }, e.prototype.setMaxZoom = function(t) {
      this.maxZoom = t;
    }, e.prototype.getStyles = function() {
      return this.styles;
    }, e.prototype.setStyles = function(t) {
      this.styles = t;
    }, e.prototype.getTitle = function() {
      return this.title;
    }, e.prototype.setTitle = function(t) {
      this.title = t;
    }, e.prototype.getZoomOnClick = function() {
      return this.zoomOnClick;
    }, e.prototype.setZoomOnClick = function(t) {
      this.zoomOnClick = t;
    }, e.prototype.getAverageCenter = function() {
      return this.averageCenter;
    }, e.prototype.setAverageCenter = function(t) {
      this.averageCenter = t;
    }, e.prototype.getIgnoreHidden = function() {
      return this.ignoreHidden;
    }, e.prototype.setIgnoreHidden = function(t) {
      this.ignoreHidden = t;
    }, e.prototype.getEnableRetinaIcons = function() {
      return this.enableRetinaIcons;
    }, e.prototype.setEnableRetinaIcons = function(t) {
      this.enableRetinaIcons = t;
    }, e.prototype.getImageExtension = function() {
      return this.imageExtension;
    }, e.prototype.setImageExtension = function(t) {
      this.imageExtension = t;
    }, e.prototype.getImagePath = function() {
      return this.imagePath;
    }, e.prototype.setImagePath = function(t) {
      this.imagePath = t;
    }, e.prototype.getImageSizes = function() {
      return this.imageSizes;
    }, e.prototype.setImageSizes = function(t) {
      this.imageSizes = t;
    }, e.prototype.getCalculator = function() {
      return this.calculator;
    }, e.prototype.setCalculator = function(t) {
      this.calculator = t;
    }, e.prototype.getBatchSizeIE = function() {
      return this.batchSizeIE;
    }, e.prototype.setBatchSizeIE = function(t) {
      this.batchSizeIE = t;
    }, e.prototype.getClusterClass = function() {
      return this.clusterClass;
    }, e.prototype.setClusterClass = function(t) {
      this.clusterClass = t;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getTotalMarkers = function() {
      return this.markers.length;
    }, e.prototype.getClusters = function() {
      return this.clusters;
    }, e.prototype.getTotalClusters = function() {
      return this.clusters.length;
    }, e.prototype.addMarker = function(t, n) {
      this.pushMarkerTo(t), n || this.redraw();
    }, e.prototype.addMarkers = function(t, n) {
      for (var r in t)
        if (Object.prototype.hasOwnProperty.call(t, r)) {
          var o = t[r];
          o && this.pushMarkerTo(o);
        }
      n || this.redraw();
    }, e.prototype.pushMarkerTo = function(t) {
      var n = this;
      t.getDraggable() && google.maps.event.addListener(t, "dragend", function() {
        n.ready && (t.isAdded = !1, n.repaint());
      }), t.isAdded = !1, this.markers.push(t);
    }, e.prototype.removeMarker_ = function(t) {
      var n = -1;
      if (this.markers.indexOf)
        n = this.markers.indexOf(t);
      else
        for (var r = 0; r < this.markers.length; r++)
          if (t === this.markers[r]) {
            n = r;
            break;
          }
      return n === -1 ? !1 : (t.setMap(null), this.markers.splice(n, 1), !0);
    }, e.prototype.removeMarker = function(t, n) {
      var r = this.removeMarker_(t);
      return !n && r && this.repaint(), r;
    }, e.prototype.removeMarkers = function(t, n) {
      for (var r = !1, o = 0, i = t; o < i.length; o++) {
        var a = i[o];
        r = r || this.removeMarker_(a);
      }
      return !n && r && this.repaint(), r;
    }, e.prototype.clearMarkers = function() {
      this.resetViewport(!0), this.markers = [];
    }, e.prototype.repaint = function() {
      var t = this.clusters.slice();
      this.clusters = [], this.resetViewport(!1), this.redraw(), setTimeout(function() {
        for (var n = 0, r = t; n < r.length; n++) {
          var o = r[n];
          o.remove();
        }
      }, 0);
    }, e.prototype.getExtendedBounds = function(t) {
      var n = this.getProjection(), r = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getNorthEast().lat(), t.getNorthEast().lng())
      );
      r !== null && (r.x += this.gridSize, r.y -= this.gridSize);
      var o = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getSouthWest().lat(), t.getSouthWest().lng())
      );
      if (o !== null && (o.x -= this.gridSize, o.y += this.gridSize), r !== null) {
        var i = n.fromDivPixelToLatLng(r);
        i !== null && t.extend(i);
      }
      if (o !== null) {
        var a = n.fromDivPixelToLatLng(o);
        a !== null && t.extend(a);
      }
      return t;
    }, e.prototype.redraw = function() {
      this.createClusters(0);
    }, e.prototype.resetViewport = function(t) {
      for (var n = 0, r = this.clusters; n < r.length; n++) {
        var o = r[n];
        o.remove();
      }
      this.clusters = [];
      for (var i = 0, a = this.markers; i < a.length; i++) {
        var s = a[i];
        s.isAdded = !1, t && s.setMap(null);
      }
    }, e.prototype.distanceBetweenPoints = function(t, n) {
      var r = 6371, o = (n.lat() - t.lat()) * Math.PI / 180, i = (n.lng() - t.lng()) * Math.PI / 180, a = Math.sin(o / 2) * Math.sin(o / 2) + Math.cos(t.lat() * Math.PI / 180) * Math.cos(n.lat() * Math.PI / 180) * Math.sin(i / 2) * Math.sin(i / 2);
      return r * (2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)));
    }, e.prototype.isMarkerInBounds = function(t, n) {
      var r = t.getPosition();
      return r ? n.contains(r) : !1;
    }, e.prototype.addToClosestCluster = function(t) {
      for (var n, r = 4e4, o = null, i = 0, a = this.clusters; i < a.length; i++) {
        var s = a[i];
        n = s;
        var l = n.getCenter(), u = t.getPosition();
        if (l && u) {
          var c = this.distanceBetweenPoints(l, u);
          c < r && (r = c, o = n);
        }
      }
      o && o.isMarkerInClusterBounds(t) ? o.addMarker(t) : (n = new aze(this), n.addMarker(t), this.clusters.push(n));
    }, e.prototype.createClusters = function(t) {
      var n = this;
      if (this.ready) {
        t === 0 && (google.maps.event.trigger(this, "clusteringbegin", this), this.timerRefStatic !== null && (window.clearTimeout(this.timerRefStatic), delete this.timerRefStatic));
        for (var r = this.getMap(), o = r !== null && ("getBounds" in r) ? r.getBounds() : null, i = (r == null ? void 0 : r.getZoom()) || 0, a = i > 3 ? new google.maps.LatLngBounds(o == null ? void 0 : o.getSouthWest(), o == null ? void 0 : o.getNorthEast()) : new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625)), s = this.getExtendedBounds(a), l = Math.min(t + this.batchSize, this.markers.length), u = t; u < l; u++) {
          var c = this.markers[u];
          c && !c.isAdded && this.isMarkerInBounds(c, s) && (!this.ignoreHidden || this.ignoreHidden && c.getVisible()) && this.addToClosestCluster(c);
        }
        if (l < this.markers.length)
          this.timerRefStatic = window.setTimeout(function() {
            n.createClusters(l);
          }, 0);
        else {
          this.timerRefStatic = null, google.maps.event.trigger(this, "clusteringend", this);
          for (var p = 0, d = this.clusters; p < d.length; p++) {
            var g = d[p];
            g.updateIcon();
          }
        }
      }
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype) {
          var i = o;
          this.prototype[i] = r.prototype[i];
        }
        return this;
      }).apply(t, [n]);
    }, e;
  }()
);
function q3(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function gze(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? q3(Object(n), !0).forEach(function(r) {
      Le(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : q3(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var is = {
  onClick: "click",
  onClusteringBegin: "clusteringbegin",
  onClusteringEnd: "clusteringend",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover"
}, Pn = {
  averageCenter(e, t) {
    e.setAverageCenter(t);
  },
  batchSizeIE(e, t) {
    e.setBatchSizeIE(t);
  },
  calculator(e, t) {
    e.setCalculator(t);
  },
  clusterClass(e, t) {
    e.setClusterClass(t);
  },
  enableRetinaIcons(e, t) {
    e.setEnableRetinaIcons(t);
  },
  gridSize(e, t) {
    e.setGridSize(t);
  },
  ignoreHidden(e, t) {
    e.setIgnoreHidden(t);
  },
  imageExtension(e, t) {
    e.setImageExtension(t);
  },
  imagePath(e, t) {
    e.setImagePath(t);
  },
  imageSizes(e, t) {
    e.setImageSizes(t);
  },
  maxZoom(e, t) {
    e.setMaxZoom(t);
  },
  minimumClusterSize(e, t) {
    e.setMinimumClusterSize(t);
  },
  styles(e, t) {
    e.setStyles(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  zoomOnClick(e, t) {
    e.setZoomOnClick(t);
  }
}, mze = {};
function vze(e) {
  var {
    children: t,
    options: n,
    averageCenter: r,
    batchSizeIE: o,
    calculator: i,
    clusterClass: a,
    enableRetinaIcons: s,
    gridSize: l,
    ignoreHidden: u,
    imageExtension: c,
    imagePath: p,
    imageSizes: d,
    maxZoom: g,
    minimumClusterSize: f,
    styles: m,
    title: v,
    zoomOnClick: E,
    onClick: w,
    onClusteringBegin: M,
    onClusteringEnd: O,
    onMouseOver: y,
    onMouseOut: C,
    onLoad: _,
    onUnmount: F
  } = e, [L, N] = k(null), R = ge(Bt), [W, V] = k(null), [z, Z] = k(null), [K, X] = k(null), [te, J] = k(null), [P, D] = k(null);
  return h(() => {
    L && C && (te !== null && google.maps.event.removeListener(te), J(google.maps.event.addListener(L, is.onMouseOut, C)));
  }, [C]), h(() => {
    L && y && (P !== null && google.maps.event.removeListener(P), D(google.maps.event.addListener(L, is.onMouseOver, y)));
  }, [y]), h(() => {
    L && w && (W !== null && google.maps.event.removeListener(W), V(google.maps.event.addListener(L, is.onClick, w)));
  }, [w]), h(() => {
    L && M && (z !== null && google.maps.event.removeListener(z), Z(google.maps.event.addListener(L, is.onClusteringBegin, M)));
  }, [M]), h(() => {
    L && O && (K !== null && google.maps.event.removeListener(K), Z(google.maps.event.addListener(L, is.onClusteringEnd, O)));
  }, [O]), h(() => {
    typeof r < "u" && L !== null && Pn.averageCenter(L, r);
  }, [L, r]), h(() => {
    typeof o < "u" && L !== null && Pn.batchSizeIE(L, o);
  }, [L, o]), h(() => {
    typeof i < "u" && L !== null && Pn.calculator(L, i);
  }, [L, i]), h(() => {
    typeof a < "u" && L !== null && Pn.clusterClass(L, a);
  }, [L, a]), h(() => {
    typeof s < "u" && L !== null && Pn.enableRetinaIcons(L, s);
  }, [L, s]), h(() => {
    typeof l < "u" && L !== null && Pn.gridSize(L, l);
  }, [L, l]), h(() => {
    typeof u < "u" && L !== null && Pn.ignoreHidden(L, u);
  }, [L, u]), h(() => {
    typeof c < "u" && L !== null && Pn.imageExtension(L, c);
  }, [L, c]), h(() => {
    typeof p < "u" && L !== null && Pn.imagePath(L, p);
  }, [L, p]), h(() => {
    typeof d < "u" && L !== null && Pn.imageSizes(L, d);
  }, [L, d]), h(() => {
    typeof g < "u" && L !== null && Pn.maxZoom(L, g);
  }, [L, g]), h(() => {
    typeof f < "u" && L !== null && Pn.minimumClusterSize(L, f);
  }, [L, f]), h(() => {
    typeof m < "u" && L !== null && Pn.styles(L, m);
  }, [L, m]), h(() => {
    typeof v < "u" && L !== null && Pn.title(L, v);
  }, [L, v]), h(() => {
    typeof E < "u" && L !== null && Pn.zoomOnClick(L, E);
  }, [L, E]), h(() => {
    if (R) {
      var H = gze({}, n || mze), S = new RY(R, [], H);
      return r && Pn.averageCenter(S, r), o && Pn.batchSizeIE(S, o), i && Pn.calculator(S, i), a && Pn.clusterClass(S, a), s && Pn.enableRetinaIcons(S, s), l && Pn.gridSize(S, l), u && Pn.ignoreHidden(S, u), c && Pn.imageExtension(S, c), p && Pn.imagePath(S, p), d && Pn.imageSizes(S, d), g && Pn.maxZoom(S, g), f && Pn.minimumClusterSize(S, f), m && Pn.styles(S, m), v && Pn.title(S, v), E && Pn.zoomOnClick(S, E), C && J(google.maps.event.addListener(S, is.onMouseOut, C)), y && D(google.maps.event.addListener(S, is.onMouseOver, y)), w && V(google.maps.event.addListener(S, is.onClick, w)), M && Z(google.maps.event.addListener(S, is.onClusteringBegin, M)), O && X(google.maps.event.addListener(S, is.onClusteringEnd, O)), N(S), _ && _(S), () => {
        te !== null && google.maps.event.removeListener(te), P !== null && google.maps.event.removeListener(P), W !== null && google.maps.event.removeListener(W), z !== null && google.maps.event.removeListener(z), K !== null && google.maps.event.removeListener(K), F && F(S);
      };
    }
  }, []), L !== null && t(L) || null;
}
ve(vze);
class yze extends pe {
  constructor() {
    super(...arguments), Le(this, "registeredEvents", []), Le(this, "state", {
      markerClusterer: null
    }), Le(this, "setClustererCallback", () => {
      this.state.markerClusterer !== null && this.props.onLoad && this.props.onLoad(this.state.markerClusterer);
    });
  }
  componentDidMount() {
    if (this.context) {
      var t = new RY(this.context, [], this.props.options);
      this.registeredEvents = dn({
        updaterMap: Pn,
        eventMap: is,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        markerClusterer: t
      }), this.setClustererCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.markerClusterer && (yn(this.registeredEvents), this.registeredEvents = dn({
      updaterMap: Pn,
      eventMap: is,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.markerClusterer
    }));
  }
  componentWillUnmount() {
    this.state.markerClusterer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.markerClusterer), yn(this.registeredEvents), this.state.markerClusterer.setMap(null));
  }
  render() {
    return this.state.markerClusterer !== null ? this.props.children(this.state.markerClusterer) : null;
  }
}
Le(yze, "contextType", Bt);
function G3(e) {
  e.cancelBubble = !0, e.stopPropagation && e.stopPropagation();
}
var BY = (
  /** @class */
  function() {
    function e(t) {
      t === void 0 && (t = {}), this.getCloseClickHandler = this.getCloseClickHandler.bind(this), this.closeClickHandler = this.closeClickHandler.bind(this), this.createInfoBoxDiv = this.createInfoBoxDiv.bind(this), this.addClickHandler = this.addClickHandler.bind(this), this.getCloseBoxImg = this.getCloseBoxImg.bind(this), this.getBoxWidths = this.getBoxWidths.bind(this), this.setBoxStyle = this.setBoxStyle.bind(this), this.setPosition = this.setPosition.bind(this), this.getPosition = this.getPosition.bind(this), this.setOptions = this.setOptions.bind(this), this.setContent = this.setContent.bind(this), this.setVisible = this.setVisible.bind(this), this.getContent = this.getContent.bind(this), this.getVisible = this.getVisible.bind(this), this.setZIndex = this.setZIndex.bind(this), this.getZIndex = this.getZIndex.bind(this), this.onRemove = this.onRemove.bind(this), this.panBox = this.panBox.bind(this), this.extend = this.extend.bind(this), this.close = this.close.bind(this), this.draw = this.draw.bind(this), this.show = this.show.bind(this), this.hide = this.hide.bind(this), this.open = this.open.bind(this), this.extend(e, google.maps.OverlayView), this.content = t.content || "", this.disableAutoPan = t.disableAutoPan || !1, this.maxWidth = t.maxWidth || 0, this.pixelOffset = t.pixelOffset || new google.maps.Size(0, 0), this.position = t.position || new google.maps.LatLng(0, 0), this.zIndex = t.zIndex || null, this.boxClass = t.boxClass || "infoBox", this.boxStyle = t.boxStyle || {}, this.closeBoxMargin = t.closeBoxMargin || "2px", this.closeBoxURL = t.closeBoxURL || "http://www.google.com/intl/en_us/mapfiles/close.gif", t.closeBoxURL === "" && (this.closeBoxURL = ""), this.infoBoxClearance = t.infoBoxClearance || new google.maps.Size(1, 1), typeof t.visible > "u" && (typeof t.isHidden > "u" ? t.visible = !0 : t.visible = !t.isHidden), this.isHidden = !t.visible, this.alignBottom = t.alignBottom || !1, this.pane = t.pane || "floatPane", this.enableEventPropagation = t.enableEventPropagation || !1, this.div = null, this.closeListener = null, this.moveListener = null, this.mapListener = null, this.contextListener = null, this.eventListeners = null, this.fixedWidthSet = null;
    }
    return e.prototype.createInfoBoxDiv = function() {
      var t = this, n = function(u) {
        u.returnValue = !1, u.preventDefault && u.preventDefault(), t.enableEventPropagation || G3(u);
      };
      if (!this.div) {
        this.div = document.createElement("div"), this.setBoxStyle(), typeof this.content == "string" ? this.div.innerHTML = this.getCloseBoxImg() + this.content : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(this.content));
        var r = this.getPanes();
        if (r !== null && r[this.pane].appendChild(this.div), this.addClickHandler(), this.div.style.width)
          this.fixedWidthSet = !0;
        else if (this.maxWidth !== 0 && this.div.offsetWidth > this.maxWidth)
          this.div.style.width = this.maxWidth + "px", this.fixedWidthSet = !0;
        else {
          var o = this.getBoxWidths();
          this.div.style.width = this.div.offsetWidth - o.left - o.right + "px", this.fixedWidthSet = !1;
        }
        if (this.panBox(this.disableAutoPan), !this.enableEventPropagation) {
          this.eventListeners = [];
          for (var i = ["mousedown", "mouseover", "mouseout", "mouseup", "click", "dblclick", "touchstart", "touchend", "touchmove"], a = 0, s = i; a < s.length; a++) {
            var l = s[a];
            this.eventListeners.push(google.maps.event.addListener(this.div, l, G3));
          }
          this.eventListeners.push(google.maps.event.addListener(this.div, "mouseover", function() {
            t.div && (t.div.style.cursor = "default");
          }));
        }
        this.contextListener = google.maps.event.addListener(this.div, "contextmenu", n), google.maps.event.trigger(this, "domready");
      }
    }, e.prototype.getCloseBoxImg = function() {
      var t = "";
      return this.closeBoxURL !== "" && (t = '<img alt=""', t += ' aria-hidden="true"', t += " src='" + this.closeBoxURL + "'", t += " align=right", t += " style='", t += " position: relative;", t += " cursor: pointer;", t += " margin: " + this.closeBoxMargin + ";", t += "'>"), t;
    }, e.prototype.addClickHandler = function() {
      this.closeListener = this.div && this.div.firstChild && this.closeBoxURL !== "" ? google.maps.event.addListener(this.div.firstChild, "click", this.getCloseClickHandler()) : null;
    }, e.prototype.closeClickHandler = function(t) {
      t.cancelBubble = !0, t.stopPropagation && t.stopPropagation(), google.maps.event.trigger(this, "closeclick"), this.close();
    }, e.prototype.getCloseClickHandler = function() {
      return this.closeClickHandler;
    }, e.prototype.panBox = function(t) {
      if (this.div && !t) {
        var n = this.getMap();
        if (n instanceof google.maps.Map) {
          var r = 0, o = 0, i = n.getBounds();
          i && !i.contains(this.position) && n.setCenter(this.position);
          var a = n.getDiv(), s = a.offsetWidth, l = a.offsetHeight, u = this.pixelOffset.width, c = this.pixelOffset.height, p = this.div.offsetWidth, d = this.div.offsetHeight, g = this.infoBoxClearance.width, f = this.infoBoxClearance.height, m = this.getProjection(), v = m.fromLatLngToContainerPixel(this.position);
          v !== null && (v.x < -u + g ? r = v.x + u - g : v.x + p + u + g > s && (r = v.x + p + u + g - s), this.alignBottom ? v.y < -c + f + d ? o = v.y + c - f - d : v.y + c + f > l && (o = v.y + c + f - l) : v.y < -c + f ? o = v.y + c - f : v.y + d + c + f > l && (o = v.y + d + c + f - l)), r === 0 && o === 0 || n.panBy(r, o);
        }
      }
    }, e.prototype.setBoxStyle = function() {
      if (this.div) {
        this.div.className = this.boxClass, this.div.style.cssText = "";
        var t = this.boxStyle;
        for (var n in t)
          Object.prototype.hasOwnProperty.call(t, n) && (this.div.style[n] = t[n]);
        if (this.div.style.webkitTransform = "translateZ(0)", typeof this.div.style.opacity < "u" && this.div.style.opacity !== "") {
          var r = parseFloat(this.div.style.opacity || "");
          this.div.style.msFilter = '"progid:DXImageTransform.Microsoft.Alpha(Opacity=' + r * 100 + ')"', this.div.style.filter = "alpha(opacity=" + r * 100 + ")";
        }
        this.div.style.position = "absolute", this.div.style.visibility = "hidden", this.zIndex !== null && (this.div.style.zIndex = this.zIndex + ""), this.div.style.overflow || (this.div.style.overflow = "auto");
      }
    }, e.prototype.getBoxWidths = function() {
      var t = {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0
      };
      if (!this.div)
        return t;
      if (document.defaultView) {
        var n = this.div.ownerDocument, r = n && n.defaultView ? n.defaultView.getComputedStyle(this.div, "") : null;
        r && (t.top = parseInt(r.borderTopWidth || "", 10) || 0, t.bottom = parseInt(r.borderBottomWidth || "", 10) || 0, t.left = parseInt(r.borderLeftWidth || "", 10) || 0, t.right = parseInt(r.borderRightWidth || "", 10) || 0);
      } else if (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        document.documentElement.currentStyle
      ) {
        var o = this.div.currentStyle;
        o && (t.top = parseInt(o.borderTopWidth || "", 10) || 0, t.bottom = parseInt(o.borderBottomWidth || "", 10) || 0, t.left = parseInt(o.borderLeftWidth || "", 10) || 0, t.right = parseInt(o.borderRightWidth || "", 10) || 0);
      }
      return t;
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.div.parentNode.removeChild(this.div), this.div = null);
    }, e.prototype.draw = function() {
      if (this.createInfoBoxDiv(), this.div) {
        var t = this.getProjection(), n = t.fromLatLngToDivPixel(this.position);
        n !== null && (this.div.style.left = n.x + this.pixelOffset.width + "px", this.alignBottom ? this.div.style.bottom = -(n.y + this.pixelOffset.height) + "px" : this.div.style.top = n.y + this.pixelOffset.height + "px"), this.isHidden ? this.div.style.visibility = "hidden" : this.div.style.visibility = "visible";
      }
    }, e.prototype.setOptions = function(t) {
      t === void 0 && (t = {}), typeof t.boxClass < "u" && (this.boxClass = t.boxClass, this.setBoxStyle()), typeof t.boxStyle < "u" && (this.boxStyle = t.boxStyle, this.setBoxStyle()), typeof t.content < "u" && this.setContent(t.content), typeof t.disableAutoPan < "u" && (this.disableAutoPan = t.disableAutoPan), typeof t.maxWidth < "u" && (this.maxWidth = t.maxWidth), typeof t.pixelOffset < "u" && (this.pixelOffset = t.pixelOffset), typeof t.alignBottom < "u" && (this.alignBottom = t.alignBottom), typeof t.position < "u" && this.setPosition(t.position), typeof t.zIndex < "u" && this.setZIndex(t.zIndex), typeof t.closeBoxMargin < "u" && (this.closeBoxMargin = t.closeBoxMargin), typeof t.closeBoxURL < "u" && (this.closeBoxURL = t.closeBoxURL), typeof t.infoBoxClearance < "u" && (this.infoBoxClearance = t.infoBoxClearance), typeof t.isHidden < "u" && (this.isHidden = t.isHidden), typeof t.visible < "u" && (this.isHidden = !t.visible), typeof t.enableEventPropagation < "u" && (this.enableEventPropagation = t.enableEventPropagation), this.div && this.draw();
    }, e.prototype.setContent = function(t) {
      this.content = t, this.div && (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.fixedWidthSet || (this.div.style.width = ""), typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t)), this.fixedWidthSet || (this.div.style.width = this.div.offsetWidth + "px", typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t))), this.addClickHandler()), google.maps.event.trigger(this, "content_changed");
    }, e.prototype.setPosition = function(t) {
      this.position = t, this.div && this.draw(), google.maps.event.trigger(this, "position_changed");
    }, e.prototype.setVisible = function(t) {
      this.isHidden = !t, this.div && (this.div.style.visibility = this.isHidden ? "hidden" : "visible");
    }, e.prototype.setZIndex = function(t) {
      this.zIndex = t, this.div && (this.div.style.zIndex = t + ""), google.maps.event.trigger(this, "zindex_changed");
    }, e.prototype.getContent = function() {
      return this.content;
    }, e.prototype.getPosition = function() {
      return this.position;
    }, e.prototype.getZIndex = function() {
      return this.zIndex;
    }, e.prototype.getVisible = function() {
      var t = this.getMap();
      return typeof t > "u" || t === null ? !1 : !this.isHidden;
    }, e.prototype.show = function() {
      this.isHidden = !1, this.div && (this.div.style.visibility = "visible");
    }, e.prototype.hide = function() {
      this.isHidden = !0, this.div && (this.div.style.visibility = "hidden");
    }, e.prototype.open = function(t, n) {
      var r = this;
      n && (this.position = n.getPosition(), this.moveListener = google.maps.event.addListener(n, "position_changed", function() {
        var o = n.getPosition();
        r.setPosition(o);
      }), this.mapListener = google.maps.event.addListener(n, "map_changed", function() {
        r.setMap(n.map);
      })), this.setMap(t), this.div && this.panBox();
    }, e.prototype.close = function() {
      if (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.eventListeners) {
        for (var t = 0, n = this.eventListeners; t < n.length; t++) {
          var r = n[t];
          google.maps.event.removeListener(r);
        }
        this.eventListeners = null;
      }
      this.moveListener && (google.maps.event.removeListener(this.moveListener), this.moveListener = null), this.mapListener && (google.maps.event.removeListener(this.mapListener), this.mapListener = null), this.contextListener && (google.maps.event.removeListener(this.contextListener), this.contextListener = null), this.setMap(null);
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype)
          Object.prototype.hasOwnProperty.call(this, o) || (this.prototype[o] = r.prototype[o]);
        return this;
      }).apply(t, [n]);
    }, e;
  }()
), bze = ["position"], wze = ["position"];
function K3(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function _y(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? K3(Object(n), !0).forEach(function(r) {
      Le(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : K3(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Y3 = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, X3 = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    t instanceof google.maps.LatLng ? e.setPosition(t) : e.setPosition(new google.maps.LatLng(t.lat, t.lng));
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, Cze = {};
function xze(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, g = ge(Bt), [f, m] = k(null), [v, E] = k(null), [w, M] = k(null), [O, y] = k(null), [C, _] = k(null), [F, L] = k(null), N = ut(null);
  return h(() => {
    g && f !== null && (f.close(), n ? f.open(g, n) : f.getPosition() && f.open(g));
  }, [g, f, n]), h(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), h(() => {
    if (o && f !== null) {
      var R = o instanceof google.maps.LatLng ? o : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        new google.maps.LatLng(o.lat, o.lng)
      );
      f.setPosition(R);
    }
  }, [o]), h(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), h(() => {
    f && a && (v !== null && google.maps.event.removeListener(v), E(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), h(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), M(google.maps.event.addListener(f, "domready", s)));
  }, [s]), h(() => {
    f && l && (O !== null && google.maps.event.removeListener(O), y(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), h(() => {
    f && u && (C !== null && google.maps.event.removeListener(C), _(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), h(() => {
    f && c && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), h(() => {
    if (g) {
      var R = r || Cze, {
        position: W
      } = R, V = lS(R, bze), z;
      W && !(W instanceof google.maps.LatLng) && (z = new google.maps.LatLng(W.lat, W.lng));
      var Z = new BY(_y(_y({}, V), z ? {
        position: z
      } : {}));
      N.current = document.createElement("div"), m(Z), a && E(google.maps.event.addListener(Z, "closeclick", a)), s && M(google.maps.event.addListener(Z, "domready", s)), l && y(google.maps.event.addListener(Z, "content_changed", l)), u && _(google.maps.event.addListener(Z, "position_changed", u)), c && L(google.maps.event.addListener(Z, "zindex_changed", c)), Z.setContent(N.current), n ? Z.open(g, n) : Z.getPosition() ? Z.open(g) : Oo(!1, "You must provide either an anchor or a position prop for <InfoBox>."), p && p(Z);
    }
    return () => {
      f !== null && (v && google.maps.event.removeListener(v), O && google.maps.event.removeListener(O), w && google.maps.event.removeListener(w), C && google.maps.event.removeListener(C), F && google.maps.event.removeListener(F), d && d(f), f.close());
    };
  }, []), N.current ? or(lt.only(t), N.current) : null;
}
ve(xze);
class Oze extends pe {
  constructor() {
    super(...arguments), Le(this, "registeredEvents", []), Le(this, "containerElement", null), Le(this, "state", {
      infoBox: null
    }), Le(this, "open", (t, n) => {
      n ? this.context !== null && t.open(this.context, n) : t.getPosition() ? this.context !== null && t.open(this.context) : Oo(!1, "You must provide either an anchor or a position prop for <InfoBox>.");
    }), Le(this, "setInfoBoxCallback", () => {
      this.state.infoBox !== null && this.containerElement !== null && (this.state.infoBox.setContent(this.containerElement), this.open(this.state.infoBox, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoBox));
    });
  }
  componentDidMount() {
    var t = this.props.options || {}, {
      position: n
    } = t, r = lS(t, wze), o;
    n && !(n instanceof google.maps.LatLng) && (o = new google.maps.LatLng(n.lat, n.lng));
    var i = new BY(_y(_y({}, r), o ? {
      position: o
    } : {}));
    this.containerElement = document.createElement("div"), this.registeredEvents = dn({
      updaterMap: X3,
      eventMap: Y3,
      prevProps: {},
      nextProps: this.props,
      instance: i
    }), this.setState({
      infoBox: i
    }, this.setInfoBoxCallback);
  }
  componentDidUpdate(t) {
    var {
      infoBox: n
    } = this.state;
    n !== null && (yn(this.registeredEvents), this.registeredEvents = dn({
      updaterMap: X3,
      eventMap: Y3,
      prevProps: t,
      nextProps: this.props,
      instance: n
    }));
  }
  componentWillUnmount() {
    var {
      onUnmount: t
    } = this.props, {
      infoBox: n
    } = this.state;
    n !== null && (t && t(n), yn(this.registeredEvents), n.close());
  }
  render() {
    return this.containerElement ? or(lt.only(this.props.children), this.containerElement) : null;
  }
}
Le(Oze, "contextType", Bt);
var J3, Q3;
function Eze() {
  return Q3 || (Q3 = 1, J3 = function e(t, n) {
    if (t === n) return !0;
    if (t && n && typeof t == "object" && typeof n == "object") {
      if (t.constructor !== n.constructor) return !1;
      var r, o, i;
      if (Array.isArray(t)) {
        if (r = t.length, r != n.length) return !1;
        for (o = r; o-- !== 0; ) if (!e(t[o], n[o])) return !1;
        return !0;
      }
      if (t.constructor === RegExp) return t.source === n.source && t.flags === n.flags;
      if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === n.valueOf();
      if (t.toString !== Object.prototype.toString) return t.toString() === n.toString();
      if (i = Object.keys(t), r = i.length, r !== Object.keys(n).length) return !1;
      for (o = r; o-- !== 0; ) if (!Object.prototype.hasOwnProperty.call(n, i[o])) return !1;
      for (o = r; o-- !== 0; ) {
        var a = i[o];
        if (!e(t[a], n[a])) return !1;
      }
      return !0;
    }
    return t !== t && n !== n;
  }), J3;
}
var kze = Eze(), eW = /* @__PURE__ */ MY(kze), tW = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array], yO = 1, bp = 8;
class uS {
  /**
   * Creates an index from raw `ArrayBuffer` data.
   * @param {ArrayBuffer} data
   */
  static from(t) {
    if (!(t instanceof ArrayBuffer))
      throw new Error("Data must be an instance of ArrayBuffer.");
    var [n, r] = new Uint8Array(t, 0, 2);
    if (n !== 219)
      throw new Error("Data does not appear to be in a KDBush format.");
    var o = r >> 4;
    if (o !== yO)
      throw new Error("Got v".concat(o, " data when expected v").concat(yO, "."));
    var i = tW[r & 15];
    if (!i)
      throw new Error("Unrecognized array type.");
    var [a] = new Uint16Array(t, 2, 1), [s] = new Uint32Array(t, 4, 1);
    return new uS(s, a, i, t);
  }
  /**
   * Creates an index that will hold a given number of items.
   * @param {number} numItems
   * @param {number} [nodeSize=64] Size of the KD-tree node (64 by default).
   * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).
   * @param {ArrayBuffer} [data] (For internal use only)
   */
  constructor(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 64, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Float64Array, o = arguments.length > 3 ? arguments[3] : void 0;
    if (isNaN(t) || t < 0) throw new Error("Unpexpected numItems value: ".concat(t, "."));
    this.numItems = +t, this.nodeSize = Math.min(Math.max(+n, 2), 65535), this.ArrayType = r, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
    var i = tW.indexOf(this.ArrayType), a = t * 2 * this.ArrayType.BYTES_PER_ELEMENT, s = t * this.IndexArrayType.BYTES_PER_ELEMENT, l = (8 - s % 8) % 8;
    if (i < 0)
      throw new Error("Unexpected typed array class: ".concat(r, "."));
    o && o instanceof ArrayBuffer ? (this.data = o, this.ids = new this.IndexArrayType(this.data, bp, t), this.coords = new this.ArrayType(this.data, bp + s + l, t * 2), this._pos = t * 2, this._finished = !0) : (this.data = new ArrayBuffer(bp + a + s + l), this.ids = new this.IndexArrayType(this.data, bp, t), this.coords = new this.ArrayType(this.data, bp + s + l, t * 2), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, (yO << 4) + i]), new Uint16Array(this.data, 2, 1)[0] = n, new Uint32Array(this.data, 4, 1)[0] = t);
  }
  /**
   * Add a point to the index.
   * @param {number} x
   * @param {number} y
   * @returns {number} An incremental index associated with the added item (starting from `0`).
   */
  add(t, n) {
    var r = this._pos >> 1;
    return this.ids[r] = r, this.coords[this._pos++] = t, this.coords[this._pos++] = n, r;
  }
  /**
   * Perform indexing of the added points.
   */
  finish() {
    var t = this._pos >> 1;
    if (t !== this.numItems)
      throw new Error("Added ".concat(t, " items when expected ").concat(this.numItems, "."));
    return e1(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
  }
  /**
   * Search the index for items within a given bounding box.
   * @param {number} minX
   * @param {number} minY
   * @param {number} maxX
   * @param {number} maxY
   * @returns {number[]} An array of indices correponding to the found items.
   */
  range(t, n, r, o) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: i,
      coords: a,
      nodeSize: s
    } = this, l = [0, i.length - 1, 0], u = []; l.length; ) {
      var c = l.pop() || 0, p = l.pop() || 0, d = l.pop() || 0;
      if (p - d <= s) {
        for (var g = d; g <= p; g++) {
          var f = a[2 * g], m = a[2 * g + 1];
          f >= t && f <= r && m >= n && m <= o && u.push(i[g]);
        }
        continue;
      }
      var v = d + p >> 1, E = a[2 * v], w = a[2 * v + 1];
      E >= t && E <= r && w >= n && w <= o && u.push(i[v]), (c === 0 ? t <= E : n <= w) && (l.push(d), l.push(v - 1), l.push(1 - c)), (c === 0 ? r >= E : o >= w) && (l.push(v + 1), l.push(p), l.push(1 - c));
    }
    return u;
  }
  /**
   * Search the index for items within a given radius.
   * @param {number} qx
   * @param {number} qy
   * @param {number} r Query radius.
   * @returns {number[]} An array of indices correponding to the found items.
   */
  within(t, n, r) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: o,
      coords: i,
      nodeSize: a
    } = this, s = [0, o.length - 1, 0], l = [], u = r * r; s.length; ) {
      var c = s.pop() || 0, p = s.pop() || 0, d = s.pop() || 0;
      if (p - d <= a) {
        for (var g = d; g <= p; g++)
          nW(i[2 * g], i[2 * g + 1], t, n) <= u && l.push(o[g]);
        continue;
      }
      var f = d + p >> 1, m = i[2 * f], v = i[2 * f + 1];
      nW(m, v, t, n) <= u && l.push(o[f]), (c === 0 ? t - r <= m : n - r <= v) && (s.push(d), s.push(f - 1), s.push(1 - c)), (c === 0 ? t + r >= m : n + r >= v) && (s.push(f + 1), s.push(p), s.push(1 - c));
    }
    return l;
  }
}
function e1(e, t, n, r, o, i) {
  if (!(o - r <= n)) {
    var a = r + o >> 1;
    NY(e, t, a, r, o, i), e1(e, t, n, r, a - 1, 1 - i), e1(e, t, n, a + 1, o, 1 - i);
  }
}
function NY(e, t, n, r, o, i) {
  for (; o > r; ) {
    if (o - r > 600) {
      var a = o - r + 1, s = n - r + 1, l = Math.log(a), u = 0.5 * Math.exp(2 * l / 3), c = 0.5 * Math.sqrt(l * u * (a - u) / a) * (s - a / 2 < 0 ? -1 : 1), p = Math.max(r, Math.floor(n - s * u / a + c)), d = Math.min(o, Math.floor(n + (a - s) * u / a + c));
      NY(e, t, n, p, d, i);
    }
    var g = t[2 * n + i], f = r, m = o;
    for (wp(e, t, r, n), t[2 * o + i] > g && wp(e, t, r, o); f < m; ) {
      for (wp(e, t, f, m), f++, m--; t[2 * f + i] < g; ) f++;
      for (; t[2 * m + i] > g; ) m--;
    }
    t[2 * r + i] === g ? wp(e, t, r, m) : (m++, wp(e, t, m, o)), m <= n && (r = m + 1), n <= m && (o = m - 1);
  }
}
function wp(e, t, n, r) {
  bO(e, n, r), bO(t, 2 * n, 2 * r), bO(t, 2 * n + 1, 2 * r + 1);
}
function bO(e, t, n) {
  var r = e[t];
  e[t] = e[n], e[n] = r;
}
function nW(e, t, n, r) {
  var o = e - n, i = t - r;
  return o * o + i * i;
}
var Lze = {
  minZoom: 0,
  // min zoom to generate clusters on
  maxZoom: 16,
  // max zoom level to cluster the points on
  minPoints: 2,
  // minimum points to form a cluster
  radius: 40,
  // cluster radius in pixels
  extent: 512,
  // tile extent (radius is calculated relative to it)
  nodeSize: 64,
  // size of the KD-tree leaf node, affects performance
  log: !1,
  // whether to log timing info
  // whether to generate numeric ids for input features (in vector tiles)
  generateId: !1,
  // a reduce function for calculating custom cluster properties
  reduce: null,
  // (accumulated, props) => { accumulated.sum += props.sum; }
  // properties to use for individual points when running the reducer
  map: (e) => e
  // props => ({sum: props.my_value})
}, rW = Math.fround || /* @__PURE__ */ ((e) => (t) => (e[0] = +t, e[0]))(new Float32Array(1)), Vl = 2, Ka = 3, wO = 4, Ha = 5, FY = 6;
class Pze {
  constructor(t) {
    this.options = Object.assign(Object.create(Lze), t), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
  }
  load(t) {
    var {
      log: n,
      minZoom: r,
      maxZoom: o
    } = this.options;
    n && console.time("total time");
    var i = "prepare ".concat(t.length, " points");
    n && console.time(i), this.points = t;
    for (var a = [], s = 0; s < t.length; s++) {
      var l = t[s];
      if (l.geometry) {
        var [u, c] = l.geometry.coordinates, p = rW(im(u)), d = rW(sm(c));
        a.push(
          p,
          d,
          // projected point coordinates
          1 / 0,
          // the last zoom the point was processed at
          s,
          // index of the source feature in the original input array
          -1,
          // parent cluster id
          1
          // number of points in a cluster
        ), this.options.reduce && a.push(0);
      }
    }
    var g = this.trees[o + 1] = this._createTree(a);
    n && console.timeEnd(i);
    for (var f = o; f >= r; f--) {
      var m = +Date.now();
      g = this.trees[f] = this._createTree(this._cluster(g, f)), n && console.log("z%d: %d clusters in %dms", f, g.numItems, +Date.now() - m);
    }
    return n && console.timeEnd("total time"), this;
  }
  getClusters(t, n) {
    var r = ((t[0] + 180) % 360 + 360) % 360 - 180, o = Math.max(-90, Math.min(90, t[1])), i = t[2] === 180 ? 180 : ((t[2] + 180) % 360 + 360) % 360 - 180, a = Math.max(-90, Math.min(90, t[3]));
    if (t[2] - t[0] >= 360)
      r = -180, i = 180;
    else if (r > i) {
      var s = this.getClusters([r, o, 180, a], n), l = this.getClusters([-180, o, i, a], n);
      return s.concat(l);
    }
    var u = this.trees[this._limitZoom(n)], c = u.range(im(r), sm(a), im(i), sm(o)), p = u.data, d = [];
    for (var g of c) {
      var f = this.stride * g;
      d.push(p[f + Ha] > 1 ? oW(p, f, this.clusterProps) : this.points[p[f + Ka]]);
    }
    return d;
  }
  getChildren(t) {
    var n = this._getOriginId(t), r = this._getOriginZoom(t), o = "No cluster with the specified id.", i = this.trees[r];
    if (!i) throw new Error(o);
    var a = i.data;
    if (n * this.stride >= a.length) throw new Error(o);
    var s = this.options.radius / (this.options.extent * Math.pow(2, r - 1)), l = a[n * this.stride], u = a[n * this.stride + 1], c = i.within(l, u, s), p = [];
    for (var d of c) {
      var g = d * this.stride;
      a[g + wO] === t && p.push(a[g + Ha] > 1 ? oW(a, g, this.clusterProps) : this.points[a[g + Ka]]);
    }
    if (p.length === 0) throw new Error(o);
    return p;
  }
  getLeaves(t, n, r) {
    n = n || 10, r = r || 0;
    var o = [];
    return this._appendLeaves(o, t, n, r, 0), o;
  }
  getTile(t, n, r) {
    var o = this.trees[this._limitZoom(t)], i = Math.pow(2, t), {
      extent: a,
      radius: s
    } = this.options, l = s / a, u = (r - l) / i, c = (r + 1 + l) / i, p = {
      features: []
    };
    return this._addTileFeatures(o.range((n - l) / i, u, (n + 1 + l) / i, c), o.data, n, r, i, p), n === 0 && this._addTileFeatures(o.range(1 - l / i, u, 1, c), o.data, i, r, i, p), n === i - 1 && this._addTileFeatures(o.range(0, u, l / i, c), o.data, -1, r, i, p), p.features.length ? p : null;
  }
  getClusterExpansionZoom(t) {
    for (var n = this._getOriginZoom(t) - 1; n <= this.options.maxZoom; ) {
      var r = this.getChildren(t);
      if (n++, r.length !== 1) break;
      t = r[0].properties.cluster_id;
    }
    return n;
  }
  _appendLeaves(t, n, r, o, i) {
    var a = this.getChildren(n);
    for (var s of a) {
      var l = s.properties;
      if (l && l.cluster ? i + l.point_count <= o ? i += l.point_count : i = this._appendLeaves(t, l.cluster_id, r, o, i) : i < o ? i++ : t.push(s), t.length === r) break;
    }
    return i;
  }
  _createTree(t) {
    for (var n = new uS(t.length / this.stride | 0, this.options.nodeSize, Float32Array), r = 0; r < t.length; r += this.stride) n.add(t[r], t[r + 1]);
    return n.finish(), n.data = t, n;
  }
  _addTileFeatures(t, n, r, o, i, a) {
    for (var s of t) {
      var l = s * this.stride, u = n[l + Ha] > 1, c = void 0, p = void 0, d = void 0;
      if (u)
        c = zY(n, l, this.clusterProps), p = n[l], d = n[l + 1];
      else {
        var g = this.points[n[l + Ka]];
        c = g.properties;
        var [f, m] = g.geometry.coordinates;
        p = im(f), d = sm(m);
      }
      var v = {
        type: 1,
        geometry: [[Math.round(this.options.extent * (p * i - r)), Math.round(this.options.extent * (d * i - o))]],
        tags: c
      }, E = void 0;
      u || this.options.generateId ? E = n[l + Ka] : E = this.points[n[l + Ka]].id, E !== void 0 && (v.id = E), a.features.push(v);
    }
  }
  _limitZoom(t) {
    return Math.max(this.options.minZoom, Math.min(Math.floor(+t), this.options.maxZoom + 1));
  }
  _cluster(t, n) {
    for (var {
      radius: r,
      extent: o,
      reduce: i,
      minPoints: a
    } = this.options, s = r / (o * Math.pow(2, n)), l = t.data, u = [], c = this.stride, p = 0; p < l.length; p += c)
      if (!(l[p + Vl] <= n)) {
        l[p + Vl] = n;
        var d = l[p], g = l[p + 1], f = t.within(l[p], l[p + 1], s), m = l[p + Ha], v = m;
        for (var E of f) {
          var w = E * c;
          l[w + Vl] > n && (v += l[w + Ha]);
        }
        if (v > m && v >= a) {
          var M = d * m, O = g * m, y = void 0, C = -1, _ = ((p / c | 0) << 5) + (n + 1) + this.points.length;
          for (var F of f) {
            var L = F * c;
            if (!(l[L + Vl] <= n)) {
              l[L + Vl] = n;
              var N = l[L + Ha];
              M += l[L] * N, O += l[L + 1] * N, l[L + wO] = _, i && (y || (y = this._map(l, p, !0), C = this.clusterProps.length, this.clusterProps.push(y)), i(y, this._map(l, L)));
            }
          }
          l[p + wO] = _, u.push(M / v, O / v, 1 / 0, _, -1, v), i && u.push(C);
        } else {
          for (var R = 0; R < c; R++) u.push(l[p + R]);
          if (v > 1)
            for (var W of f) {
              var V = W * c;
              if (!(l[V + Vl] <= n)) {
                l[V + Vl] = n;
                for (var z = 0; z < c; z++) u.push(l[V + z]);
              }
            }
        }
      }
    return u;
  }
  // get index of the point from which the cluster originated
  _getOriginId(t) {
    return t - this.points.length >> 5;
  }
  // get zoom of the point from which the cluster originated
  _getOriginZoom(t) {
    return (t - this.points.length) % 32;
  }
  _map(t, n, r) {
    if (t[n + Ha] > 1) {
      var o = this.clusterProps[t[n + FY]];
      return r ? Object.assign({}, o) : o;
    }
    var i = this.points[t[n + Ka]].properties, a = this.options.map(i);
    return r && a === i ? Object.assign({}, a) : a;
  }
}
function oW(e, t, n) {
  return {
    type: "Feature",
    id: e[t + Ka],
    properties: zY(e, t, n),
    geometry: {
      type: "Point",
      coordinates: [_ze(e[t]), Sze(e[t + 1])]
    }
  };
}
function zY(e, t, n) {
  var r = e[t + Ha], o = r >= 1e4 ? "".concat(Math.round(r / 1e3), "k") : r >= 1e3 ? "".concat(Math.round(r / 100) / 10, "k") : r, i = e[t + FY], a = i === -1 ? {} : Object.assign({}, n[i]);
  return Object.assign(a, {
    cluster: !0,
    cluster_id: e[t + Ka],
    point_count: r,
    point_count_abbreviated: o
  });
}
function im(e) {
  return e / 360 + 0.5;
}
function sm(e) {
  var t = Math.sin(e * Math.PI / 180), n = 0.5 - 0.25 * Math.log((1 + t) / (1 - t)) / Math.PI;
  return n < 0 ? 0 : n > 1 ? 1 : n;
}
function _ze(e) {
  return (e - 0.5) * 360;
}
function Sze(e) {
  var t = (180 - e * 360) * Math.PI / 180;
  return 360 * Math.atan(Math.exp(t)) / Math.PI - 90;
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function Mze(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
    t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
  return n;
}
class Ni {
  static isAdvancedMarkerAvailable(t) {
    return google.maps.marker && t.getMapCapabilities().isAdvancedMarkersAvailable === !0;
  }
  static isAdvancedMarker(t) {
    return google.maps.marker && t instanceof google.maps.marker.AdvancedMarkerElement;
  }
  static setMap(t, n) {
    this.isAdvancedMarker(t) ? t.map = n : t.setMap(n);
  }
  static getPosition(t) {
    if (this.isAdvancedMarker(t)) {
      if (t.position) {
        if (t.position instanceof google.maps.LatLng)
          return t.position;
        if (t.position.lat && t.position.lng)
          return new google.maps.LatLng(t.position.lat, t.position.lng);
      }
      return new google.maps.LatLng(null);
    }
    return t.getPosition();
  }
  static getVisible(t) {
    return this.isAdvancedMarker(t) ? !0 : t.getVisible();
  }
}
class t1 {
  constructor(t) {
    var {
      markers: n,
      position: r
    } = t;
    this.markers = n, r && (r instanceof google.maps.LatLng ? this._position = r : this._position = new google.maps.LatLng(r));
  }
  get bounds() {
    if (!(this.markers.length === 0 && !this._position)) {
      var t = new google.maps.LatLngBounds(this._position, this._position);
      for (var n of this.markers)
        t.extend(Ni.getPosition(n));
      return t;
    }
  }
  get position() {
    return this._position || this.bounds.getCenter();
  }
  /**
   * Get the count of **visible** markers.
   */
  get count() {
    return this.markers.filter((t) => Ni.getVisible(t)).length;
  }
  /**
   * Add a marker to the cluster.
   */
  push(t) {
    this.markers.push(t);
  }
  /**
   * Cleanup references and remove marker from map.
   */
  delete() {
    this.marker && (Ni.setMap(this.marker, null), this.marker = void 0), this.markers.length = 0;
  }
}
class Dze {
  constructor(t) {
    var {
      maxZoom: n = 16
    } = t;
    this.maxZoom = n;
  }
  /**
   * Helper function to bypass clustering based upon some map state such as
   * zoom, number of markers, etc.
   *
   * ```typescript
   *  cluster({markers, map}: AlgorithmInput): Cluster[] {
   *    if (shouldBypassClustering(map)) {
   *      return this.noop({markers})
   *    }
   * }
   * ```
   */
  noop(t) {
    var {
      markers: n
    } = t;
    return Tze(n);
  }
}
var Tze = (e) => {
  var t = e.map((n) => new t1({
    position: Ni.getPosition(n),
    markers: [n]
  }));
  return t;
};
class jze extends Dze {
  constructor(t) {
    var {
      maxZoom: n,
      radius: r = 60
    } = t, o = Mze(t, ["maxZoom", "radius"]);
    super({
      maxZoom: n
    }), this.state = {
      zoom: -1
    }, this.superCluster = new Pze(Object.assign({
      maxZoom: this.maxZoom,
      radius: r
    }, o));
  }
  calculate(t) {
    var n = !1, r = {
      zoom: t.map.getZoom()
    };
    if (!eW(t.markers, this.markers)) {
      n = !0, this.markers = [...t.markers];
      var o = this.markers.map((i) => {
        var a = Ni.getPosition(i), s = [a.lng(), a.lat()];
        return {
          type: "Feature",
          geometry: {
            type: "Point",
            coordinates: s
          },
          properties: {
            marker: i
          }
        };
      });
      this.superCluster.load(o);
    }
    return n || (this.state.zoom <= this.maxZoom || r.zoom <= this.maxZoom) && (n = !eW(this.state, r)), this.state = r, n && (this.clusters = this.cluster(t)), {
      clusters: this.clusters,
      changed: n
    };
  }
  cluster(t) {
    var {
      map: n
    } = t;
    return this.superCluster.getClusters([-180, -90, 180, 90], Math.round(n.getZoom())).map((r) => this.transformCluster(r));
  }
  transformCluster(t) {
    var {
      geometry: {
        coordinates: [n, r]
      },
      properties: o
    } = t;
    if (o.cluster)
      return new t1({
        markers: this.superCluster.getLeaves(o.cluster_id, 1 / 0).map((a) => a.properties.marker),
        position: {
          lat: r,
          lng: n
        }
      });
    var i = o.marker;
    return new t1({
      markers: [i],
      position: Ni.getPosition(i)
    });
  }
}
class Aze {
  constructor(t, n) {
    this.markers = {
      sum: t.length
    };
    var r = n.map((i) => i.count), o = r.reduce((i, a) => i + a, 0);
    this.clusters = {
      count: n.length,
      markers: {
        mean: o / n.length,
        sum: o,
        min: Math.min(...r),
        max: Math.max(...r)
      }
    };
  }
}
class Ize {
  /**
   * The default render function for the library used by {@link MarkerClusterer}.
   *
   * Currently set to use the following:
   *
   * ```typescript
   * // change color if this cluster has more markers than the mean cluster
   * const color =
   *   count > Math.max(10, stats.clusters.markers.mean)
   *     ? "#ff0000"
   *     : "#0000ff";
   *
   * // create svg url with fill color
   * const svg = window.btoa(`
   * <svg fill="${color}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240">
   *   <circle cx="120" cy="120" opacity=".6" r="70" />
   *   <circle cx="120" cy="120" opacity=".3" r="90" />
   *   <circle cx="120" cy="120" opacity=".2" r="110" />
   *   <circle cx="120" cy="120" opacity=".1" r="130" />
   * </svg>`);
   *
   * // create marker using svg icon
   * return new google.maps.Marker({
   *   position,
   *   icon: {
   *     url: `data:image/svg+xml;base64,${svg}`,
   *     scaledSize: new google.maps.Size(45, 45),
   *   },
   *   label: {
   *     text: String(count),
   *     color: "rgba(255,255,255,0.9)",
   *     fontSize: "12px",
   *   },
   *   // adjust zIndex to be above other markers
   *   zIndex: 1000 + count,
   * });
   * ```
   */
  render(t, n, r) {
    var {
      count: o,
      position: i
    } = t, a = o > Math.max(10, n.clusters.markers.mean) ? "#ff0000" : "#0000ff", s = '<svg fill="'.concat(a, `" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" width="50" height="50">
<circle cx="120" cy="120" opacity=".6" r="70" />
<circle cx="120" cy="120" opacity=".3" r="90" />
<circle cx="120" cy="120" opacity=".2" r="110" />
<text x="50%" y="50%" style="fill:#fff" text-anchor="middle" font-size="50" dominant-baseline="middle" font-family="roboto,arial,sans-serif">`).concat(o, `</text>
</svg>`), l = "Cluster of ".concat(o, " markers"), u = Number(google.maps.Marker.MAX_ZINDEX) + o;
    if (Ni.isAdvancedMarkerAvailable(r)) {
      var c = new DOMParser(), p = c.parseFromString(s, "image/svg+xml").documentElement;
      p.setAttribute("transform", "translate(0 25)");
      var d = {
        map: r,
        position: i,
        zIndex: u,
        title: l,
        content: p
      };
      return new google.maps.marker.AdvancedMarkerElement(d);
    }
    var g = {
      position: i,
      zIndex: u,
      title: l,
      icon: {
        url: "data:image/svg+xml;base64,".concat(btoa(s)),
        anchor: new google.maps.Point(25, 25)
      }
    };
    return new google.maps.Marker(g);
  }
}
function Rze(e, t) {
  for (var n in t.prototype)
    e.prototype[n] = t.prototype[n];
}
class cS {
  constructor() {
    Rze(cS, google.maps.OverlayView);
  }
}
var pd;
(function(e) {
  e.CLUSTERING_BEGIN = "clusteringbegin", e.CLUSTERING_END = "clusteringend", e.CLUSTER_CLICK = "click";
})(pd || (pd = {}));
var Bze = (e, t, n) => {
  n.fitBounds(t.bounds);
};
class Nze extends cS {
  constructor(t) {
    var {
      map: n,
      markers: r = [],
      algorithmOptions: o = {},
      algorithm: i = new jze(o),
      renderer: a = new Ize(),
      onClusterClick: s = Bze
    } = t;
    super(), this.markers = [...r], this.clusters = [], this.algorithm = i, this.renderer = a, this.onClusterClick = s, n && this.setMap(n);
  }
  addMarker(t, n) {
    this.markers.includes(t) || (this.markers.push(t), n || this.render());
  }
  addMarkers(t, n) {
    t.forEach((r) => {
      this.addMarker(r, !0);
    }), n || this.render();
  }
  removeMarker(t, n) {
    var r = this.markers.indexOf(t);
    return r === -1 ? !1 : (Ni.setMap(t, null), this.markers.splice(r, 1), n || this.render(), !0);
  }
  removeMarkers(t, n) {
    var r = !1;
    return t.forEach((o) => {
      r = this.removeMarker(o, !0) || r;
    }), r && !n && this.render(), r;
  }
  clearMarkers(t) {
    this.markers.length = 0, t || this.render();
  }
  /**
   * Recalculates and draws all the marker clusters.
   */
  render() {
    var t = this.getMap();
    if (t instanceof google.maps.Map && t.getProjection()) {
      google.maps.event.trigger(this, pd.CLUSTERING_BEGIN, this);
      var {
        clusters: n,
        changed: r
      } = this.algorithm.calculate({
        markers: this.markers,
        map: t,
        mapCanvasProjection: this.getProjection()
      });
      if (r || r == null) {
        var o = /* @__PURE__ */ new Set();
        for (var i of n)
          i.markers.length == 1 && o.add(i.markers[0]);
        var a = [];
        for (var s of this.clusters)
          s.marker != null && (s.markers.length == 1 ? o.has(s.marker) || Ni.setMap(s.marker, null) : a.push(s.marker));
        this.clusters = n, this.renderClusters(), requestAnimationFrame(() => a.forEach((l) => Ni.setMap(l, null)));
      }
      google.maps.event.trigger(this, pd.CLUSTERING_END, this);
    }
  }
  onAdd() {
    this.idleListener = this.getMap().addListener("idle", this.render.bind(this)), this.render();
  }
  onRemove() {
    google.maps.event.removeListener(this.idleListener), this.reset();
  }
  reset() {
    this.markers.forEach((t) => Ni.setMap(t, null)), this.clusters.forEach((t) => t.delete()), this.clusters = [];
  }
  renderClusters() {
    var t = new Aze(this.markers, this.clusters), n = this.getMap();
    this.clusters.forEach((r) => {
      r.markers.length === 1 ? r.marker = r.markers[0] : (r.marker = this.renderer.render(r, t, n), r.markers.forEach((o) => Ni.setMap(o, null)), this.onClusterClick && r.marker.addListener(
        "click",
        /* istanbul ignore next */
        (o) => {
          google.maps.event.trigger(this, pd.CLUSTER_CLICK, r), this.onClusterClick(o, r, n);
        }
      )), Ni.setMap(r.marker, n);
    });
  }
}
function iW(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function sW(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? iW(Object(n), !0).forEach(function(r) {
      Le(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : iW(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function Fze(e) {
  var t = B2e(), [n, r] = k(null);
  return h(() => {
    if (t && n === null) {
      var o = new Nze(sW(sW({}, e), {}, {
        map: t
      }));
      r(o);
    }
  }, [t]), n;
}
function zze(e) {
  var {
    children: t,
    options: n
  } = e, r = Fze(n);
  return r !== null ? t(r) : null;
}
ve(zze);
var aW = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, lW = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
function Uze(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, g = ge(Bt), [f, m] = k(null), [v, E] = k(null), [w, M] = k(null), [O, y] = k(null), [C, _] = k(null), [F, L] = k(null), N = ut(null);
  return h(() => {
    f !== null && (f.close(), n ? f.open(g, n) : f.getPosition() && f.open(g));
  }, [g, f, n]), h(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), h(() => {
    o && f !== null && f.setPosition(o);
  }, [o]), h(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), h(() => {
    f && a && (v !== null && google.maps.event.removeListener(v), E(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), h(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), M(google.maps.event.addListener(f, "domready", s)));
  }, [s]), h(() => {
    f && l && (O !== null && google.maps.event.removeListener(O), y(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), h(() => {
    f && u && (C !== null && google.maps.event.removeListener(C), _(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), h(() => {
    f && c && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), h(() => {
    var R = new google.maps.InfoWindow(r);
    return m(R), N.current = document.createElement("div"), a && E(google.maps.event.addListener(R, "closeclick", a)), s && M(google.maps.event.addListener(R, "domready", s)), l && y(google.maps.event.addListener(R, "content_changed", l)), u && _(google.maps.event.addListener(R, "position_changed", u)), c && L(google.maps.event.addListener(R, "zindex_changed", c)), R.setContent(N.current), o && R.setPosition(o), i && R.setZIndex(i), n ? R.open(g, n) : R.getPosition() ? R.open(g) : Oo(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>."), p && p(R), () => {
      v && google.maps.event.removeListener(v), O && google.maps.event.removeListener(O), w && google.maps.event.removeListener(w), C && google.maps.event.removeListener(C), F && google.maps.event.removeListener(F), d && d(R), R.close();
    };
  }, []), N.current ? or(lt.only(t), N.current) : null;
}
ve(Uze);
class Hze extends pe {
  constructor() {
    super(...arguments), Le(this, "registeredEvents", []), Le(this, "containerElement", null), Le(this, "state", {
      infoWindow: null
    }), Le(this, "open", (t, n) => {
      n ? t.open(this.context, n) : t.getPosition() ? t.open(this.context) : Oo(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>.");
    }), Le(this, "setInfoWindowCallback", () => {
      this.state.infoWindow !== null && this.containerElement !== null && (this.state.infoWindow.setContent(this.containerElement), this.open(this.state.infoWindow, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoWindow));
    });
  }
  componentDidMount() {
    var t = new google.maps.InfoWindow(this.props.options);
    this.containerElement = document.createElement("div"), this.registeredEvents = dn({
      updaterMap: lW,
      eventMap: aW,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(() => ({
      infoWindow: t
    }), this.setInfoWindowCallback);
  }
  componentDidUpdate(t) {
    this.state.infoWindow !== null && (yn(this.registeredEvents), this.registeredEvents = dn({
      updaterMap: lW,
      eventMap: aW,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.infoWindow
    }));
  }
  componentWillUnmount() {
    this.state.infoWindow !== null && (yn(this.registeredEvents), this.props.onUnmount && this.props.onUnmount(this.state.infoWindow), this.state.infoWindow.close());
  }
  render() {
    return this.containerElement ? or(lt.only(this.props.children), this.containerElement) : null;
  }
}
Le(Hze, "contextType", Bt);
function uW(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Sy(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? uW(Object(n), !0).forEach(function(r) {
      Le(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : uW(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var cW = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, pW = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, $ze = {};
function Wze(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: g,
    onRightClick: f,
    onClick: m,
    onDrag: v,
    onLoad: E,
    onUnmount: w
  } = e, M = ge(Bt), [O, y] = k(null), [C, _] = k(null), [F, L] = k(null), [N, R] = k(null), [W, V] = k(null), [z, Z] = k(null), [K, X] = k(null), [te, J] = k(null), [P, D] = k(null), [H, S] = k(null), [$, x] = k(null), [j, U] = k(null);
  return h(() => {
    O !== null && O.setMap(M);
  }, [M]), h(() => {
    typeof t < "u" && O !== null && O.setOptions(t);
  }, [O, t]), h(() => {
    typeof n < "u" && O !== null && O.setDraggable(n);
  }, [O, n]), h(() => {
    typeof r < "u" && O !== null && O.setEditable(r);
  }, [O, r]), h(() => {
    typeof o < "u" && O !== null && O.setVisible(o);
  }, [O, o]), h(() => {
    typeof i < "u" && O !== null && O.setPath(i);
  }, [O, i]), h(() => {
    O && a && (C !== null && google.maps.event.removeListener(C), _(google.maps.event.addListener(O, "dblclick", a)));
  }, [a]), h(() => {
    O && s && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(O, "dragend", s)));
  }, [s]), h(() => {
    O && l && (N !== null && google.maps.event.removeListener(N), R(google.maps.event.addListener(O, "dragstart", l)));
  }, [l]), h(() => {
    O && u && (W !== null && google.maps.event.removeListener(W), V(google.maps.event.addListener(O, "mousedown", u)));
  }, [u]), h(() => {
    O && c && (z !== null && google.maps.event.removeListener(z), Z(google.maps.event.addListener(O, "mousemove", c)));
  }, [c]), h(() => {
    O && p && (K !== null && google.maps.event.removeListener(K), X(google.maps.event.addListener(O, "mouseout", p)));
  }, [p]), h(() => {
    O && d && (te !== null && google.maps.event.removeListener(te), J(google.maps.event.addListener(O, "mouseover", d)));
  }, [d]), h(() => {
    O && g && (P !== null && google.maps.event.removeListener(P), D(google.maps.event.addListener(O, "mouseup", g)));
  }, [g]), h(() => {
    O && f && (H !== null && google.maps.event.removeListener(H), S(google.maps.event.addListener(O, "rightclick", f)));
  }, [f]), h(() => {
    O && m && ($ !== null && google.maps.event.removeListener($), x(google.maps.event.addListener(O, "click", m)));
  }, [m]), h(() => {
    O && v && (j !== null && google.maps.event.removeListener(j), U(google.maps.event.addListener(O, "drag", v)));
  }, [v]), h(() => {
    var T = new google.maps.Polyline(Sy(Sy({}, t || $ze), {}, {
      map: M
    }));
    return i && T.setPath(i), typeof o < "u" && T.setVisible(o), typeof r < "u" && T.setEditable(r), typeof n < "u" && T.setDraggable(n), a && _(google.maps.event.addListener(T, "dblclick", a)), s && L(google.maps.event.addListener(T, "dragend", s)), l && R(google.maps.event.addListener(T, "dragstart", l)), u && V(google.maps.event.addListener(T, "mousedown", u)), c && Z(google.maps.event.addListener(T, "mousemove", c)), p && X(google.maps.event.addListener(T, "mouseout", p)), d && J(google.maps.event.addListener(T, "mouseover", d)), g && D(google.maps.event.addListener(T, "mouseup", g)), f && S(google.maps.event.addListener(T, "rightclick", f)), m && x(google.maps.event.addListener(T, "click", m)), v && U(google.maps.event.addListener(T, "drag", v)), y(T), E && E(T), () => {
      C !== null && google.maps.event.removeListener(C), F !== null && google.maps.event.removeListener(F), N !== null && google.maps.event.removeListener(N), W !== null && google.maps.event.removeListener(W), z !== null && google.maps.event.removeListener(z), K !== null && google.maps.event.removeListener(K), te !== null && google.maps.event.removeListener(te), P !== null && google.maps.event.removeListener(P), H !== null && google.maps.event.removeListener(H), $ !== null && google.maps.event.removeListener($), w && w(T), T.setMap(null);
    };
  }, []), null;
}
ve(Wze);
class Vze extends pe {
  constructor() {
    super(...arguments), Le(this, "registeredEvents", []), Le(this, "state", {
      polyline: null
    }), Le(this, "setPolylineCallback", () => {
      this.state.polyline !== null && this.props.onLoad && this.props.onLoad(this.state.polyline);
    });
  }
  componentDidMount() {
    var t = new google.maps.Polyline(Sy(Sy({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = dn({
      updaterMap: pW,
      eventMap: cW,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        polyline: t
      };
    }, this.setPolylineCallback);
  }
  componentDidUpdate(t) {
    this.state.polyline !== null && (yn(this.registeredEvents), this.registeredEvents = dn({
      updaterMap: pW,
      eventMap: cW,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.polyline
    }));
  }
  componentWillUnmount() {
    this.state.polyline !== null && (this.props.onUnmount && this.props.onUnmount(this.state.polyline), yn(this.registeredEvents), this.state.polyline.setMap(null));
  }
  render() {
    return null;
  }
}
Le(Vze, "contextType", Bt);
function dW(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function fW(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? dW(Object(n), !0).forEach(function(r) {
      Le(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : dW(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var hW = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, gW = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  paths(e, t) {
    e.setPaths(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function Zze(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    paths: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: g,
    onMouseUp: f,
    onRightClick: m,
    onClick: v,
    onDrag: E,
    onLoad: w,
    onUnmount: M,
    onEdit: O
  } = e, y = ge(Bt), [C, _] = k(null), [F, L] = k(null), [N, R] = k(null), [W, V] = k(null), [z, Z] = k(null), [K, X] = k(null), [te, J] = k(null), [P, D] = k(null), [H, S] = k(null), [$, x] = k(null), [j, U] = k(null), [T, q] = k(null);
  return h(() => {
    C !== null && C.setMap(y);
  }, [y]), h(() => {
    typeof t < "u" && C !== null && C.setOptions(t);
  }, [C, t]), h(() => {
    typeof n < "u" && C !== null && C.setDraggable(n);
  }, [C, n]), h(() => {
    typeof r < "u" && C !== null && C.setEditable(r);
  }, [C, r]), h(() => {
    typeof o < "u" && C !== null && C.setVisible(o);
  }, [C, o]), h(() => {
    typeof i < "u" && C !== null && C.setPath(i);
  }, [C, i]), h(() => {
    typeof a < "u" && C !== null && C.setPaths(a);
  }, [C, a]), h(() => {
    C && typeof s == "function" && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(C, "dblclick", s)));
  }, [s]), h(() => {
    C && (google.maps.event.addListener(C.getPath(), "insert_at", () => {
      O == null || O(C);
    }), google.maps.event.addListener(C.getPath(), "set_at", () => {
      O == null || O(C);
    }), google.maps.event.addListener(C.getPath(), "remove_at", () => {
      O == null || O(C);
    }));
  }, [C, O]), h(() => {
    C && typeof l == "function" && (N !== null && google.maps.event.removeListener(N), R(google.maps.event.addListener(C, "dragend", l)));
  }, [l]), h(() => {
    C && typeof u == "function" && (W !== null && google.maps.event.removeListener(W), V(google.maps.event.addListener(C, "dragstart", u)));
  }, [u]), h(() => {
    C && typeof c == "function" && (z !== null && google.maps.event.removeListener(z), Z(google.maps.event.addListener(C, "mousedown", c)));
  }, [c]), h(() => {
    C && typeof p == "function" && (K !== null && google.maps.event.removeListener(K), X(google.maps.event.addListener(C, "mousemove", p)));
  }, [p]), h(() => {
    C && typeof d == "function" && (te !== null && google.maps.event.removeListener(te), J(google.maps.event.addListener(C, "mouseout", d)));
  }, [d]), h(() => {
    C && typeof g == "function" && (P !== null && google.maps.event.removeListener(P), D(google.maps.event.addListener(C, "mouseover", g)));
  }, [g]), h(() => {
    C && typeof f == "function" && (H !== null && google.maps.event.removeListener(H), S(google.maps.event.addListener(C, "mouseup", f)));
  }, [f]), h(() => {
    C && typeof m == "function" && ($ !== null && google.maps.event.removeListener($), x(google.maps.event.addListener(C, "rightclick", m)));
  }, [m]), h(() => {
    C && typeof v == "function" && (j !== null && google.maps.event.removeListener(j), U(google.maps.event.addListener(C, "click", v)));
  }, [v]), h(() => {
    C && typeof E == "function" && (T !== null && google.maps.event.removeListener(T), q(google.maps.event.addListener(C, "drag", E)));
  }, [E]), h(() => {
    var A = new google.maps.Polygon(fW(fW({}, t), {}, {
      map: y
    }));
    return i && A.setPath(i), a && A.setPaths(a), typeof o < "u" && A.setVisible(o), typeof r < "u" && A.setEditable(r), typeof n < "u" && A.setDraggable(n), s && L(google.maps.event.addListener(A, "dblclick", s)), l && R(google.maps.event.addListener(A, "dragend", l)), u && V(google.maps.event.addListener(A, "dragstart", u)), c && Z(google.maps.event.addListener(A, "mousedown", c)), p && X(google.maps.event.addListener(A, "mousemove", p)), d && J(google.maps.event.addListener(A, "mouseout", d)), g && D(google.maps.event.addListener(A, "mouseover", g)), f && S(google.maps.event.addListener(A, "mouseup", f)), m && x(google.maps.event.addListener(A, "rightclick", m)), v && U(google.maps.event.addListener(A, "click", v)), E && q(google.maps.event.addListener(A, "drag", E)), _(A), w && w(A), () => {
      F !== null && google.maps.event.removeListener(F), N !== null && google.maps.event.removeListener(N), W !== null && google.maps.event.removeListener(W), z !== null && google.maps.event.removeListener(z), K !== null && google.maps.event.removeListener(K), te !== null && google.maps.event.removeListener(te), P !== null && google.maps.event.removeListener(P), H !== null && google.maps.event.removeListener(H), $ !== null && google.maps.event.removeListener($), j !== null && google.maps.event.removeListener(j), M && M(A), A.setMap(null);
    };
  }, []), null;
}
ve(Zze);
class qze extends pe {
  constructor() {
    super(...arguments), Le(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this.props.options || {};
    this.polygon = new google.maps.Polygon(t), this.polygon.setMap(this.context), this.registeredEvents = dn({
      updaterMap: gW,
      eventMap: hW,
      prevProps: {},
      nextProps: this.props,
      instance: this.polygon
    }), this.props.onLoad && this.props.onLoad(this.polygon);
  }
  componentDidUpdate(t) {
    this.polygon && (yn(this.registeredEvents), this.registeredEvents = dn({
      updaterMap: gW,
      eventMap: hW,
      prevProps: t,
      nextProps: this.props,
      instance: this.polygon
    }));
  }
  componentWillUnmount() {
    this.polygon && (this.props.onUnmount && this.props.onUnmount(this.polygon), yn(this.registeredEvents), this.polygon && this.polygon.setMap(null));
  }
  render() {
    return null;
  }
}
Le(qze, "contextType", Bt);
function mW(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function My(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? mW(Object(n), !0).forEach(function(r) {
      Le(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : mW(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var vW = {
  onBoundsChanged: "bounds_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, yW = {
  bounds(e, t) {
    e.setBounds(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function Gze(e) {
  var {
    options: t,
    bounds: n,
    draggable: r,
    editable: o,
    visible: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: g,
    onRightClick: f,
    onClick: m,
    onDrag: v,
    onBoundsChanged: E,
    onLoad: w,
    onUnmount: M
  } = e, O = ge(Bt), [y, C] = k(null), [_, F] = k(null), [L, N] = k(null), [R, W] = k(null), [V, z] = k(null), [Z, K] = k(null), [X, te] = k(null), [J, P] = k(null), [D, H] = k(null), [S, $] = k(null), [x, j] = k(null), [U, T] = k(null), [q, A] = k(null);
  return h(() => {
    y !== null && y.setMap(O);
  }, [O]), h(() => {
    typeof t < "u" && y !== null && y.setOptions(t);
  }, [y, t]), h(() => {
    typeof r < "u" && y !== null && y.setDraggable(r);
  }, [y, r]), h(() => {
    typeof o < "u" && y !== null && y.setEditable(o);
  }, [y, o]), h(() => {
    typeof i < "u" && y !== null && y.setVisible(i);
  }, [y, i]), h(() => {
    typeof n < "u" && y !== null && y.setBounds(n);
  }, [y, n]), h(() => {
    y && a && (_ !== null && google.maps.event.removeListener(_), F(google.maps.event.addListener(y, "dblclick", a)));
  }, [a]), h(() => {
    y && s && (L !== null && google.maps.event.removeListener(L), N(google.maps.event.addListener(y, "dragend", s)));
  }, [s]), h(() => {
    y && l && (R !== null && google.maps.event.removeListener(R), W(google.maps.event.addListener(y, "dragstart", l)));
  }, [l]), h(() => {
    y && u && (V !== null && google.maps.event.removeListener(V), z(google.maps.event.addListener(y, "mousedown", u)));
  }, [u]), h(() => {
    y && c && (Z !== null && google.maps.event.removeListener(Z), K(google.maps.event.addListener(y, "mousemove", c)));
  }, [c]), h(() => {
    y && p && (X !== null && google.maps.event.removeListener(X), te(google.maps.event.addListener(y, "mouseout", p)));
  }, [p]), h(() => {
    y && d && (J !== null && google.maps.event.removeListener(J), P(google.maps.event.addListener(y, "mouseover", d)));
  }, [d]), h(() => {
    y && g && (D !== null && google.maps.event.removeListener(D), H(google.maps.event.addListener(y, "mouseup", g)));
  }, [g]), h(() => {
    y && f && (S !== null && google.maps.event.removeListener(S), $(google.maps.event.addListener(y, "rightclick", f)));
  }, [f]), h(() => {
    y && m && (x !== null && google.maps.event.removeListener(x), j(google.maps.event.addListener(y, "click", m)));
  }, [m]), h(() => {
    y && v && (U !== null && google.maps.event.removeListener(U), T(google.maps.event.addListener(y, "drag", v)));
  }, [v]), h(() => {
    y && E && (q !== null && google.maps.event.removeListener(q), A(google.maps.event.addListener(y, "bounds_changed", E)));
  }, [E]), h(() => {
    var Y = new google.maps.Rectangle(My(My({}, t), {}, {
      map: O
    }));
    return typeof i < "u" && Y.setVisible(i), typeof o < "u" && Y.setEditable(o), typeof r < "u" && Y.setDraggable(r), typeof n < "u" && Y.setBounds(n), a && F(google.maps.event.addListener(Y, "dblclick", a)), s && N(google.maps.event.addListener(Y, "dragend", s)), l && W(google.maps.event.addListener(Y, "dragstart", l)), u && z(google.maps.event.addListener(Y, "mousedown", u)), c && K(google.maps.event.addListener(Y, "mousemove", c)), p && te(google.maps.event.addListener(Y, "mouseout", p)), d && P(google.maps.event.addListener(Y, "mouseover", d)), g && H(google.maps.event.addListener(Y, "mouseup", g)), f && $(google.maps.event.addListener(Y, "rightclick", f)), m && j(google.maps.event.addListener(Y, "click", m)), v && T(google.maps.event.addListener(Y, "drag", v)), E && A(google.maps.event.addListener(Y, "bounds_changed", E)), C(Y), w && w(Y), () => {
      _ !== null && google.maps.event.removeListener(_), L !== null && google.maps.event.removeListener(L), R !== null && google.maps.event.removeListener(R), V !== null && google.maps.event.removeListener(V), Z !== null && google.maps.event.removeListener(Z), X !== null && google.maps.event.removeListener(X), J !== null && google.maps.event.removeListener(J), D !== null && google.maps.event.removeListener(D), S !== null && google.maps.event.removeListener(S), x !== null && google.maps.event.removeListener(x), U !== null && google.maps.event.removeListener(U), q !== null && google.maps.event.removeListener(q), M && M(Y), Y.setMap(null);
    };
  }, []), null;
}
ve(Gze);
class Kze extends pe {
  constructor() {
    super(...arguments), Le(this, "registeredEvents", []), Le(this, "state", {
      rectangle: null
    }), Le(this, "setRectangleCallback", () => {
      this.state.rectangle !== null && this.props.onLoad && this.props.onLoad(this.state.rectangle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Rectangle(My(My({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = dn({
      updaterMap: yW,
      eventMap: vW,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        rectangle: t
      };
    }, this.setRectangleCallback);
  }
  componentDidUpdate(t) {
    this.state.rectangle !== null && (yn(this.registeredEvents), this.registeredEvents = dn({
      updaterMap: yW,
      eventMap: vW,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.rectangle
    }));
  }
  componentWillUnmount() {
    this.state.rectangle !== null && (this.props.onUnmount && this.props.onUnmount(this.state.rectangle), yn(this.registeredEvents), this.state.rectangle.setMap(null));
  }
  render() {
    return null;
  }
}
Le(Kze, "contextType", Bt);
function bW(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Dy(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? bW(Object(n), !0).forEach(function(r) {
      Le(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : bW(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var wW = {
  onCenterChanged: "center_changed",
  onRadiusChanged: "radius_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, CW = {
  center(e, t) {
    e.setCenter(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  radius(e, t) {
    e.setRadius(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, Yze = {};
function Xze(e) {
  var {
    options: t,
    center: n,
    radius: r,
    draggable: o,
    editable: i,
    visible: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: g,
    onMouseUp: f,
    onRightClick: m,
    onClick: v,
    onDrag: E,
    onCenterChanged: w,
    onRadiusChanged: M,
    onLoad: O,
    onUnmount: y
  } = e, C = ge(Bt), [_, F] = k(null), [L, N] = k(null), [R, W] = k(null), [V, z] = k(null), [Z, K] = k(null), [X, te] = k(null), [J, P] = k(null), [D, H] = k(null), [S, $] = k(null), [x, j] = k(null), [U, T] = k(null), [q, A] = k(null), [Y, B] = k(null), [ue, fe] = k(null);
  return h(() => {
    _ !== null && _.setMap(C);
  }, [C]), h(() => {
    typeof t < "u" && _ !== null && _.setOptions(t);
  }, [_, t]), h(() => {
    typeof o < "u" && _ !== null && _.setDraggable(o);
  }, [_, o]), h(() => {
    typeof i < "u" && _ !== null && _.setEditable(i);
  }, [_, i]), h(() => {
    typeof a < "u" && _ !== null && _.setVisible(a);
  }, [_, a]), h(() => {
    typeof r == "number" && _ !== null && _.setRadius(r);
  }, [_, r]), h(() => {
    typeof n < "u" && _ !== null && _.setCenter(n);
  }, [_, n]), h(() => {
    _ && s && (L !== null && google.maps.event.removeListener(L), N(google.maps.event.addListener(_, "dblclick", s)));
  }, [s]), h(() => {
    _ && l && (R !== null && google.maps.event.removeListener(R), W(google.maps.event.addListener(_, "dragend", l)));
  }, [l]), h(() => {
    _ && u && (V !== null && google.maps.event.removeListener(V), z(google.maps.event.addListener(_, "dragstart", u)));
  }, [u]), h(() => {
    _ && c && (Z !== null && google.maps.event.removeListener(Z), K(google.maps.event.addListener(_, "mousedown", c)));
  }, [c]), h(() => {
    _ && p && (X !== null && google.maps.event.removeListener(X), te(google.maps.event.addListener(_, "mousemove", p)));
  }, [p]), h(() => {
    _ && d && (J !== null && google.maps.event.removeListener(J), P(google.maps.event.addListener(_, "mouseout", d)));
  }, [d]), h(() => {
    _ && g && (D !== null && google.maps.event.removeListener(D), H(google.maps.event.addListener(_, "mouseover", g)));
  }, [g]), h(() => {
    _ && f && (S !== null && google.maps.event.removeListener(S), $(google.maps.event.addListener(_, "mouseup", f)));
  }, [f]), h(() => {
    _ && m && (x !== null && google.maps.event.removeListener(x), j(google.maps.event.addListener(_, "rightclick", m)));
  }, [m]), h(() => {
    _ && v && (U !== null && google.maps.event.removeListener(U), T(google.maps.event.addListener(_, "click", v)));
  }, [v]), h(() => {
    _ && E && (q !== null && google.maps.event.removeListener(q), A(google.maps.event.addListener(_, "drag", E)));
  }, [E]), h(() => {
    _ && w && (Y !== null && google.maps.event.removeListener(Y), B(google.maps.event.addListener(_, "center_changed", w)));
  }, [v]), h(() => {
    _ && M && (ue !== null && google.maps.event.removeListener(ue), fe(google.maps.event.addListener(_, "radius_changed", M)));
  }, [M]), h(() => {
    var oe = new google.maps.Circle(Dy(Dy({}, t || Yze), {}, {
      map: C
    }));
    return typeof r == "number" && oe.setRadius(r), typeof n < "u" && oe.setCenter(n), typeof r == "number" && oe.setRadius(r), typeof a < "u" && oe.setVisible(a), typeof i < "u" && oe.setEditable(i), typeof o < "u" && oe.setDraggable(o), s && N(google.maps.event.addListener(oe, "dblclick", s)), l && W(google.maps.event.addListener(oe, "dragend", l)), u && z(google.maps.event.addListener(oe, "dragstart", u)), c && K(google.maps.event.addListener(oe, "mousedown", c)), p && te(google.maps.event.addListener(oe, "mousemove", p)), d && P(google.maps.event.addListener(oe, "mouseout", d)), g && H(google.maps.event.addListener(oe, "mouseover", g)), f && $(google.maps.event.addListener(oe, "mouseup", f)), m && j(google.maps.event.addListener(oe, "rightclick", m)), v && T(google.maps.event.addListener(oe, "click", v)), E && A(google.maps.event.addListener(oe, "drag", E)), w && B(google.maps.event.addListener(oe, "center_changed", w)), M && fe(google.maps.event.addListener(oe, "radius_changed", M)), F(oe), O && O(oe), () => {
      L !== null && google.maps.event.removeListener(L), R !== null && google.maps.event.removeListener(R), V !== null && google.maps.event.removeListener(V), Z !== null && google.maps.event.removeListener(Z), X !== null && google.maps.event.removeListener(X), J !== null && google.maps.event.removeListener(J), D !== null && google.maps.event.removeListener(D), S !== null && google.maps.event.removeListener(S), x !== null && google.maps.event.removeListener(x), U !== null && google.maps.event.removeListener(U), Y !== null && google.maps.event.removeListener(Y), ue !== null && google.maps.event.removeListener(ue), y && y(oe), oe.setMap(null);
    };
  }, []), null;
}
ve(Xze);
class Jze extends pe {
  constructor() {
    super(...arguments), Le(this, "registeredEvents", []), Le(this, "state", {
      circle: null
    }), Le(this, "setCircleCallback", () => {
      this.state.circle !== null && this.props.onLoad && this.props.onLoad(this.state.circle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Circle(Dy(Dy({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = dn({
      updaterMap: CW,
      eventMap: wW,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        circle: t
      };
    }, this.setCircleCallback);
  }
  componentDidUpdate(t) {
    this.state.circle !== null && (yn(this.registeredEvents), this.registeredEvents = dn({
      updaterMap: CW,
      eventMap: wW,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.circle
    }));
  }
  componentWillUnmount() {
    if (this.state.circle !== null) {
      var t;
      this.props.onUnmount && this.props.onUnmount(this.state.circle), yn(this.registeredEvents), (t = this.state.circle) === null || t === void 0 || t.setMap(null);
    }
  }
  render() {
    return null;
  }
}
Le(Jze, "contextType", Bt);
function xW(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Ty(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? xW(Object(n), !0).forEach(function(r) {
      Le(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : xW(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var OW = {
  onClick: "click",
  onDblClick: "dblclick",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onAddFeature: "addfeature",
  onRemoveFeature: "removefeature",
  onRemoveProperty: "removeproperty",
  onSetGeometry: "setgeometry",
  onSetProperty: "setproperty"
}, EW = {
  add(e, t) {
    e.add(t);
  },
  addgeojson(e, t, n) {
    e.addGeoJson(t, n);
  },
  contains(e, t) {
    e.contains(t);
  },
  foreach(e, t) {
    e.forEach(t);
  },
  loadgeojson(e, t, n, r) {
    e.loadGeoJson(t, n, r);
  },
  overridestyle(e, t, n) {
    e.overrideStyle(t, n);
  },
  remove(e, t) {
    e.remove(t);
  },
  revertstyle(e, t) {
    e.revertStyle(t);
  },
  controlposition(e, t) {
    e.setControlPosition(t);
  },
  controls(e, t) {
    e.setControls(t);
  },
  drawingmode(e, t) {
    e.setDrawingMode(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  style(e, t) {
    e.setStyle(t);
  },
  togeojson(e, t) {
    e.toGeoJson(t);
  }
};
function Qze(e) {
  var {
    options: t,
    onClick: n,
    onDblClick: r,
    onMouseDown: o,
    onMouseMove: i,
    onMouseOut: a,
    onMouseOver: s,
    onMouseUp: l,
    onRightClick: u,
    onAddFeature: c,
    onRemoveFeature: p,
    onRemoveProperty: d,
    onSetGeometry: g,
    onSetProperty: f,
    onLoad: m,
    onUnmount: v
  } = e, E = ge(Bt), [w, M] = k(null), [O, y] = k(null), [C, _] = k(null), [F, L] = k(null), [N, R] = k(null), [W, V] = k(null), [z, Z] = k(null), [K, X] = k(null), [te, J] = k(null), [P, D] = k(null), [H, S] = k(null), [$, x] = k(null), [j, U] = k(null), [T, q] = k(null);
  return h(() => {
    w !== null && w.setMap(E);
  }, [E]), h(() => {
    w && r && (O !== null && google.maps.event.removeListener(O), y(google.maps.event.addListener(w, "dblclick", r)));
  }, [r]), h(() => {
    w && o && (C !== null && google.maps.event.removeListener(C), _(google.maps.event.addListener(w, "mousedown", o)));
  }, [o]), h(() => {
    w && i && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(w, "mousemove", i)));
  }, [i]), h(() => {
    w && a && (N !== null && google.maps.event.removeListener(N), R(google.maps.event.addListener(w, "mouseout", a)));
  }, [a]), h(() => {
    w && s && (W !== null && google.maps.event.removeListener(W), V(google.maps.event.addListener(w, "mouseover", s)));
  }, [s]), h(() => {
    w && l && (z !== null && google.maps.event.removeListener(z), Z(google.maps.event.addListener(w, "mouseup", l)));
  }, [l]), h(() => {
    w && u && (K !== null && google.maps.event.removeListener(K), X(google.maps.event.addListener(w, "rightclick", u)));
  }, [u]), h(() => {
    w && n && (te !== null && google.maps.event.removeListener(te), J(google.maps.event.addListener(w, "click", n)));
  }, [n]), h(() => {
    w && c && (P !== null && google.maps.event.removeListener(P), D(google.maps.event.addListener(w, "addfeature", c)));
  }, [c]), h(() => {
    w && p && (H !== null && google.maps.event.removeListener(H), S(google.maps.event.addListener(w, "removefeature", p)));
  }, [p]), h(() => {
    w && d && ($ !== null && google.maps.event.removeListener($), x(google.maps.event.addListener(w, "removeproperty", d)));
  }, [d]), h(() => {
    w && g && (j !== null && google.maps.event.removeListener(j), U(google.maps.event.addListener(w, "setgeometry", g)));
  }, [g]), h(() => {
    w && f && (T !== null && google.maps.event.removeListener(T), q(google.maps.event.addListener(w, "setproperty", f)));
  }, [f]), h(() => {
    if (E !== null) {
      var A = new google.maps.Data(Ty(Ty({}, t), {}, {
        map: E
      }));
      r && y(google.maps.event.addListener(A, "dblclick", r)), o && _(google.maps.event.addListener(A, "mousedown", o)), i && L(google.maps.event.addListener(A, "mousemove", i)), a && R(google.maps.event.addListener(A, "mouseout", a)), s && V(google.maps.event.addListener(A, "mouseover", s)), l && Z(google.maps.event.addListener(A, "mouseup", l)), u && X(google.maps.event.addListener(A, "rightclick", u)), n && J(google.maps.event.addListener(A, "click", n)), c && D(google.maps.event.addListener(A, "addfeature", c)), p && S(google.maps.event.addListener(A, "removefeature", p)), d && x(google.maps.event.addListener(A, "removeproperty", d)), g && U(google.maps.event.addListener(A, "setgeometry", g)), f && q(google.maps.event.addListener(A, "setproperty", f)), M(A), m && m(A);
    }
    return () => {
      w && (O !== null && google.maps.event.removeListener(O), C !== null && google.maps.event.removeListener(C), F !== null && google.maps.event.removeListener(F), N !== null && google.maps.event.removeListener(N), W !== null && google.maps.event.removeListener(W), z !== null && google.maps.event.removeListener(z), K !== null && google.maps.event.removeListener(K), te !== null && google.maps.event.removeListener(te), P !== null && google.maps.event.removeListener(P), H !== null && google.maps.event.removeListener(H), $ !== null && google.maps.event.removeListener($), j !== null && google.maps.event.removeListener(j), T !== null && google.maps.event.removeListener(T), v && v(w), w.setMap(null));
    };
  }, []), null;
}
ve(Qze);
class eUe extends pe {
  constructor() {
    super(...arguments), Le(this, "registeredEvents", []), Le(this, "state", {
      data: null
    }), Le(this, "setDataCallback", () => {
      this.state.data !== null && this.props.onLoad && this.props.onLoad(this.state.data);
    });
  }
  componentDidMount() {
    if (this.context !== null) {
      var t = new google.maps.Data(Ty(Ty({}, this.props.options), {}, {
        map: this.context
      }));
      this.registeredEvents = dn({
        updaterMap: EW,
        eventMap: OW,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        data: t
      }), this.setDataCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.data !== null && (yn(this.registeredEvents), this.registeredEvents = dn({
      updaterMap: EW,
      eventMap: OW,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.data
    }));
  }
  componentWillUnmount() {
    this.state.data !== null && (this.props.onUnmount && this.props.onUnmount(this.state.data), yn(this.registeredEvents), this.state.data && this.state.data.setMap(null));
  }
  render() {
    return null;
  }
}
Le(eUe, "contextType", Bt);
function kW(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function LW(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? kW(Object(n), !0).forEach(function(r) {
      Le(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : kW(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var PW = {
  onClick: "click",
  onDefaultViewportChanged: "defaultviewport_changed",
  onStatusChanged: "status_changed"
}, _W = {
  options(e, t) {
    e.setOptions(t);
  },
  url(e, t) {
    e.setUrl(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
class tUe extends pe {
  constructor() {
    super(...arguments), Le(this, "registeredEvents", []), Le(this, "state", {
      kmlLayer: null
    }), Le(this, "setKmlLayerCallback", () => {
      this.state.kmlLayer !== null && this.props.onLoad && this.props.onLoad(this.state.kmlLayer);
    });
  }
  componentDidMount() {
    var t = new google.maps.KmlLayer(LW(LW({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = dn({
      updaterMap: _W,
      eventMap: PW,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        kmlLayer: t
      };
    }, this.setKmlLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.kmlLayer !== null && (yn(this.registeredEvents), this.registeredEvents = dn({
      updaterMap: _W,
      eventMap: PW,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.kmlLayer
    }));
  }
  componentWillUnmount() {
    this.state.kmlLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.kmlLayer), yn(this.registeredEvents), this.state.kmlLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Le(tUe, "contextType", Bt);
function UY(e, t) {
  return typeof t == "function" ? t(e.offsetWidth, e.offsetHeight) : {
    x: 0,
    y: 0
  };
}
function nUe(e, t) {
  return new t(e.lat, e.lng);
}
function rUe(e, t) {
  return new t(new google.maps.LatLng(e.ne.lat, e.ne.lng), new google.maps.LatLng(e.sw.lat, e.sw.lng));
}
function oUe(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function iUe(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function sUe(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n.getNorthEast()), o = e && e.fromLatLngToDivPixel(n.getSouthWest());
  return r && o ? {
    left: "".concat(o.x + t.x, "px"),
    top: "".concat(r.y + t.y, "px"),
    width: "".concat(r.x - o.x - t.x, "px"),
    height: "".concat(o.y - r.y - t.y, "px")
  } : {
    left: "-9999px",
    top: "-9999px"
  };
}
function aUe(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n);
  if (r) {
    var {
      x: o,
      y: i
    } = r;
    return {
      left: "".concat(o + t.x, "px"),
      top: "".concat(i + t.y, "px")
    };
  }
  return {
    left: "-9999px",
    top: "-9999px"
  };
}
function HY(e, t, n, r) {
  return n !== void 0 ? sUe(e, t, iUe(n, google.maps.LatLngBounds, rUe)) : aUe(e, t, oUe(r, google.maps.LatLng, nUe));
}
function lUe(e, t) {
  return e.left === t.left && e.top === t.top && e.width === t.height && e.height === t.height;
}
function SW(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function uUe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? SW(Object(n), !0).forEach(function(r) {
      Le(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : SW(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function cUe(e, t, n, r, o) {
  class i extends google.maps.OverlayView {
    constructor(s, l, u, c) {
      super(), this.container = s, this.pane = l, this.position = u, this.bounds = c;
    }
    onAdd() {
      var s, l = (s = this.getPanes()) === null || s === void 0 ? void 0 : s[this.pane];
      l == null || l.appendChild(this.container);
    }
    draw() {
      var s = this.getProjection(), l = uUe({}, this.container ? UY(this.container, o) : {
        x: 0,
        y: 0
      }), u = HY(s, l, this.bounds, this.position);
      for (var [c, p] of Object.entries(u))
        this.container.style[c] = p;
    }
    onRemove() {
      this.container.parentNode !== null && this.container.parentNode.removeChild(this.container);
    }
  }
  return new i(e, t, n, r);
}
function MW(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function pUe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? MW(Object(n), !0).forEach(function(r) {
      Le(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : MW(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function DW(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLng ? e : new google.maps.LatLng(e.lat, e.lng);
  return t + "";
}
function TW(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLngBounds ? e : new google.maps.LatLngBounds(new google.maps.LatLng(e.south, e.east), new google.maps.LatLng(e.north, e.west));
  return t + "";
}
function dUe(e) {
  var {
    position: t,
    bounds: n,
    mapPaneName: r,
    zIndex: o,
    onLoad: i,
    onUnmount: a,
    getPixelPositionOffset: s,
    children: l
  } = e, u = ge(Bt), c = Cn(() => {
    var d = document.createElement("div");
    return d.style.position = "absolute", d;
  }, []), p = Cn(() => cUe(c, r, t, n, s), [c, r, t, n]);
  return h(() => (i == null || i(p), p == null || p.setMap(u), () => {
    a == null || a(p), p == null || p.setMap(null);
  }), [u, p]), h(() => {
    c.style.zIndex = "".concat(o);
  }, [o, c]), wi.createPortal(l, c);
}
ve(dUe);
class Fc extends pe {
  constructor(t) {
    super(t), Le(this, "state", {
      paneEl: null,
      containerStyle: {
        // set initial position
        position: "absolute"
      }
    }), Le(this, "updatePane", () => {
      var r = this.props.mapPaneName, o = this.overlayView.getPanes();
      Oo(!!r, "OverlayView requires props.mapPaneName but got %s", r), o ? this.setState({
        paneEl: o[r]
      }) : this.setState({
        paneEl: null
      });
    }), Le(this, "onAdd", () => {
      var r, o;
      this.updatePane(), (r = (o = this.props).onLoad) === null || r === void 0 || r.call(o, this.overlayView);
    }), Le(this, "onPositionElement", () => {
      var r = this.overlayView.getProjection(), o = pUe({
        x: 0,
        y: 0
      }, this.containerRef.current ? UY(this.containerRef.current, this.props.getPixelPositionOffset) : {}), i = HY(r, o, this.props.bounds, this.props.position);
      if (!lUe(i, {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        left: this.state.containerStyle.left,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        top: this.state.containerStyle.top,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        width: this.state.containerStyle.width,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        height: this.state.containerStyle.height
      })) {
        var a, s, l, u;
        this.setState({
          containerStyle: {
            top: (a = i.top) !== null && a !== void 0 ? a : 0,
            left: (s = i.left) !== null && s !== void 0 ? s : 0,
            width: (l = i.width) !== null && l !== void 0 ? l : 0,
            height: (u = i.height) !== null && u !== void 0 ? u : 0,
            position: "absolute"
          }
        });
      }
    }), Le(this, "draw", () => {
      this.onPositionElement();
    }), Le(this, "onRemove", () => {
      var r, o;
      this.setState(() => ({
        paneEl: null
      })), (r = (o = this.props).onUnmount) === null || r === void 0 || r.call(o, this.overlayView);
    }), this.containerRef = mo();
    var n = new google.maps.OverlayView();
    n.onAdd = this.onAdd, n.draw = this.draw, n.onRemove = this.onRemove, this.overlayView = n;
  }
  componentDidMount() {
    this.overlayView.setMap(this.context);
  }
  componentDidUpdate(t) {
    var n = DW(t.position), r = DW(this.props.position), o = TW(t.bounds), i = TW(this.props.bounds);
    (n !== r || o !== i) && this.overlayView.draw(), t.mapPaneName !== this.props.mapPaneName && this.updatePane();
  }
  componentWillUnmount() {
    this.overlayView.setMap(null);
  }
  render() {
    var t = this.state.paneEl;
    return t ? wi.createPortal(Sn.jsx("div", {
      ref: this.containerRef,
      style: this.state.containerStyle,
      children: lt.only(this.props.children)
    }), t) : null;
  }
}
Le(Fc, "FLOAT_PANE", "floatPane");
Le(Fc, "MAP_PANE", "mapPane");
Le(Fc, "MARKER_LAYER", "markerLayer");
Le(Fc, "OVERLAY_LAYER", "overlayLayer");
Le(Fc, "OVERLAY_MOUSE_TARGET", "overlayMouseTarget");
Le(Fc, "contextType", Bt);
function fUe() {
}
function jW(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function AW(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? jW(Object(n), !0).forEach(function(r) {
      Le(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : jW(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var IW = {
  onDblClick: "dblclick",
  onClick: "click"
}, RW = {
  opacity(e, t) {
    e.setOpacity(t);
  }
};
function hUe(e) {
  var {
    url: t,
    bounds: n,
    options: r,
    visible: o
  } = e, i = ge(Bt), a = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east)), s = Cn(() => new google.maps.GroundOverlay(t, a, r), []);
  return h(() => {
    s !== null && s.setMap(i);
  }, [i]), h(() => {
    typeof t < "u" && s !== null && (s.set("url", t), s.setMap(i));
  }, [s, t]), h(() => {
    typeof o < "u" && s !== null && s.setOpacity(o ? 1 : 0);
  }, [s, o]), h(() => {
    var l = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east));
    typeof n < "u" && s !== null && (s.set("bounds", l), s.setMap(i));
  }, [s, n]), null;
}
ve(hUe);
class $Y extends pe {
  constructor() {
    super(...arguments), Le(this, "registeredEvents", []), Le(this, "state", {
      groundOverlay: null
    }), Le(this, "setGroundOverlayCallback", () => {
      this.state.groundOverlay !== null && this.props.onLoad && this.props.onLoad(this.state.groundOverlay);
    });
  }
  componentDidMount() {
    Oo(!!this.props.url || !!this.props.bounds, "For GroundOverlay, url and bounds are passed in to constructor and are immutable after instantiated. This is the behavior of Google Maps JavaScript API v3 ( See https://developers.google.com/maps/documentation/javascript/reference#GroundOverlay) Hence, use the corresponding two props provided by `react-google-maps-api`, url and bounds. In some cases, you'll need the GroundOverlay component to reflect the changes of url and bounds. You can leverage the React's key property to remount the component. Typically, just `key={url}` would serve your need. See https://github.com/tomchentw/react-google-maps/issues/655");
    var t = new google.maps.GroundOverlay(this.props.url, this.props.bounds, AW(AW({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = dn({
      updaterMap: RW,
      eventMap: IW,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        groundOverlay: t
      };
    }, this.setGroundOverlayCallback);
  }
  componentDidUpdate(t) {
    this.state.groundOverlay !== null && (yn(this.registeredEvents), this.registeredEvents = dn({
      updaterMap: RW,
      eventMap: IW,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.groundOverlay
    }));
  }
  componentWillUnmount() {
    this.state.groundOverlay && (this.props.onUnmount && this.props.onUnmount(this.state.groundOverlay), this.state.groundOverlay.setMap(null));
  }
  render() {
    return null;
  }
}
Le($Y, "defaultProps", {
  onLoad: fUe
});
Le($Y, "contextType", Bt);
function BW(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function jy(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? BW(Object(n), !0).forEach(function(r) {
      Le(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : BW(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var NW = {}, FW = {
  data(e, t) {
    e.setData(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function gUe(e) {
  var {
    data: t,
    onLoad: n,
    onUnmount: r,
    options: o
  } = e, i = ge(Bt), [a, s] = k(null);
  return h(() => {
    google.maps.visualization || Oo(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} in useJsApiScript? %s', google.maps.visualization);
  }, []), h(() => {
    Oo(!!t, "data property is required in HeatmapLayer %s", t);
  }, [t]), h(() => {
    a !== null && a.setMap(i);
  }, [i]), h(() => {
    o && a !== null && a.setOptions(o);
  }, [a, o]), h(() => {
    var l = new google.maps.visualization.HeatmapLayer(jy(jy({}, o), {}, {
      data: t,
      map: i
    }));
    return s(l), n && n(l), () => {
      a !== null && (r && r(a), a.setMap(null));
    };
  }, []), null;
}
ve(gUe);
class mUe extends pe {
  constructor() {
    super(...arguments), Le(this, "registeredEvents", []), Le(this, "state", {
      heatmapLayer: null
    }), Le(this, "setHeatmapLayerCallback", () => {
      this.state.heatmapLayer !== null && this.props.onLoad && this.props.onLoad(this.state.heatmapLayer);
    });
  }
  componentDidMount() {
    Oo(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} to <LoadScript />? %s', google.maps.visualization), Oo(!!this.props.data, "data property is required in HeatmapLayer %s", this.props.data);
    var t = new google.maps.visualization.HeatmapLayer(jy(jy({}, this.props.options), {}, {
      data: this.props.data,
      map: this.context
    }));
    this.registeredEvents = dn({
      updaterMap: FW,
      eventMap: NW,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        heatmapLayer: t
      };
    }, this.setHeatmapLayerCallback);
  }
  componentDidUpdate(t) {
    yn(this.registeredEvents), this.registeredEvents = dn({
      updaterMap: FW,
      eventMap: NW,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.heatmapLayer
    });
  }
  componentWillUnmount() {
    this.state.heatmapLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.heatmapLayer), yn(this.registeredEvents), this.state.heatmapLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Le(mUe, "contextType", Bt);
var zW = {
  onCloseClick: "closeclick",
  onPanoChanged: "pano_changed",
  onPositionChanged: "position_changed",
  onPovChanged: "pov_changed",
  onResize: "resize",
  onStatusChanged: "status_changed",
  onVisibleChanged: "visible_changed",
  onZoomChanged: "zoom_changed"
}, UW = {
  register(e, t, n) {
    e.registerPanoProvider(t, n);
  },
  links(e, t) {
    e.setLinks(t);
  },
  motionTracking(e, t) {
    e.setMotionTracking(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  pano(e, t) {
    e.setPano(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  pov(e, t) {
    e.setPov(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zoom(e, t) {
    e.setZoom(t);
  }
};
class vUe extends pe {
  constructor() {
    super(...arguments), Le(this, "registeredEvents", []), Le(this, "state", {
      streetViewPanorama: null
    }), Le(this, "setStreetViewPanoramaCallback", () => {
      this.state.streetViewPanorama !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewPanorama);
    });
  }
  componentDidMount() {
    var t, n, r = (t = (n = this.context) === null || n === void 0 ? void 0 : n.getStreetView()) !== null && t !== void 0 ? t : null;
    this.registeredEvents = dn({
      updaterMap: UW,
      eventMap: zW,
      prevProps: {},
      nextProps: this.props,
      instance: r
    }), this.setState(() => ({
      streetViewPanorama: r
    }), this.setStreetViewPanoramaCallback);
  }
  componentDidUpdate(t) {
    this.state.streetViewPanorama !== null && (yn(this.registeredEvents), this.registeredEvents = dn({
      updaterMap: UW,
      eventMap: zW,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.streetViewPanorama
    }));
  }
  componentWillUnmount() {
    this.state.streetViewPanorama !== null && (this.props.onUnmount && this.props.onUnmount(this.state.streetViewPanorama), yn(this.registeredEvents), this.state.streetViewPanorama.setVisible(!1));
  }
  render() {
    return null;
  }
}
Le(vUe, "contextType", Bt);
class yUe extends pe {
  constructor() {
    super(...arguments), Le(this, "state", {
      streetViewService: null
    }), Le(this, "setStreetViewServiceCallback", () => {
      this.state.streetViewService !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewService);
    });
  }
  componentDidMount() {
    var t = new google.maps.StreetViewService();
    this.setState(function() {
      return {
        streetViewService: t
      };
    }, this.setStreetViewServiceCallback);
  }
  componentWillUnmount() {
    this.state.streetViewService !== null && this.props.onUnmount && this.props.onUnmount(this.state.streetViewService);
  }
  render() {
    return null;
  }
}
Le(yUe, "contextType", Bt);
var HW = {
  onDirectionsChanged: "directions_changed"
}, $W = {
  directions(e, t) {
    e.setDirections(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  panel(e, t) {
    e.setPanel(t);
  },
  routeIndex(e, t) {
    e.setRouteIndex(t);
  }
};
class bUe extends pe {
  constructor() {
    super(...arguments), Le(this, "registeredEvents", []), Le(this, "state", {
      directionsRenderer: null
    }), Le(this, "setDirectionsRendererCallback", () => {
      this.state.directionsRenderer !== null && (this.state.directionsRenderer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.directionsRenderer));
    });
  }
  componentDidMount() {
    var t = new google.maps.DirectionsRenderer(this.props.options);
    this.registeredEvents = dn({
      updaterMap: $W,
      eventMap: HW,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        directionsRenderer: t
      };
    }, this.setDirectionsRendererCallback);
  }
  componentDidUpdate(t) {
    this.state.directionsRenderer !== null && (yn(this.registeredEvents), this.registeredEvents = dn({
      updaterMap: $W,
      eventMap: HW,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.directionsRenderer
    }));
  }
  componentWillUnmount() {
    this.state.directionsRenderer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.directionsRenderer), yn(this.registeredEvents), this.state.directionsRenderer && this.state.directionsRenderer.setMap(null));
  }
  render() {
    return null;
  }
}
Le(bUe, "contextType", Bt);
var WW = {
  onPlacesChanged: "places_changed"
}, VW = {
  bounds(e, t) {
    e.setBounds(t);
  }
};
class wUe extends pe {
  constructor() {
    super(...arguments), Le(this, "registeredEvents", []), Le(this, "containerElement", mo()), Le(this, "state", {
      searchBox: null
    }), Le(this, "setSearchBoxCallback", () => {
      this.state.searchBox !== null && this.props.onLoad && this.props.onLoad(this.state.searchBox);
    });
  }
  componentDidMount() {
    if (Oo(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places), this.containerElement !== null && this.containerElement.current !== null) {
      var t = this.containerElement.current.querySelector("input");
      if (t !== null) {
        var n = new google.maps.places.SearchBox(t, this.props.options);
        this.registeredEvents = dn({
          updaterMap: VW,
          eventMap: WW,
          prevProps: {},
          nextProps: this.props,
          instance: n
        }), this.setState(function() {
          return {
            searchBox: n
          };
        }, this.setSearchBoxCallback);
      }
    }
  }
  componentDidUpdate(t) {
    this.state.searchBox !== null && (yn(this.registeredEvents), this.registeredEvents = dn({
      updaterMap: VW,
      eventMap: WW,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.searchBox
    }));
  }
  componentWillUnmount() {
    this.state.searchBox !== null && (this.props.onUnmount && this.props.onUnmount(this.state.searchBox), yn(this.registeredEvents));
  }
  render() {
    return Sn.jsx("div", {
      ref: this.containerElement,
      children: lt.only(this.props.children)
    });
  }
}
Le(wUe, "contextType", Bt);
var ZW = {
  onPlaceChanged: "place_changed"
}, qW = {
  bounds(e, t) {
    e.setBounds(t);
  },
  restrictions(e, t) {
    e.setComponentRestrictions(t);
  },
  fields(e, t) {
    e.setFields(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  types(e, t) {
    e.setTypes(t);
  }
};
class WY extends pe {
  constructor() {
    super(...arguments), Le(this, "registeredEvents", []), Le(this, "containerElement", mo()), Le(this, "state", {
      autocomplete: null
    }), Le(this, "setAutocompleteCallback", () => {
      this.state.autocomplete !== null && this.props.onLoad && this.props.onLoad(this.state.autocomplete);
    });
  }
  componentDidMount() {
    var t;
    Oo(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places);
    var n = (t = this.containerElement.current) === null || t === void 0 ? void 0 : t.querySelector("input");
    if (n) {
      var r = new google.maps.places.Autocomplete(n, this.props.options);
      this.registeredEvents = dn({
        updaterMap: qW,
        eventMap: ZW,
        prevProps: {},
        nextProps: this.props,
        instance: r
      }), this.setState(() => ({
        autocomplete: r
      }), this.setAutocompleteCallback);
    }
  }
  componentDidUpdate(t) {
    yn(this.registeredEvents), this.registeredEvents = dn({
      updaterMap: qW,
      eventMap: ZW,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.autocomplete
    });
  }
  componentWillUnmount() {
    this.state.autocomplete !== null && yn(this.registeredEvents);
  }
  render() {
    return Sn.jsx("div", {
      ref: this.containerElement,
      className: this.props.className,
      children: lt.only(this.props.children)
    });
  }
}
Le(WY, "defaultProps", {
  className: ""
});
Le(WY, "contextType", Bt);
let CUe = { data: "" }, xUe = (e) => typeof window == "object" ? ((e ? e.querySelector("#_goober") : window._goober) || Object.assign((e || document.head).appendChild(document.createElement("style")), { innerHTML: " ", id: "_goober" })).firstChild : e || CUe, OUe = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g, EUe = /\/\*[^]*?\*\/|  +/g, GW = /\n+/g, ol = (e, t) => {
  let n = "", r = "", o = "";
  for (let i in e) {
    let a = e[i];
    i[0] == "@" ? i[1] == "i" ? n = i + " " + a + ";" : r += i[1] == "f" ? ol(a, i) : i + "{" + ol(a, i[1] == "k" ? "" : t) + "}" : typeof a == "object" ? r += ol(a, t ? t.replace(/([^,])+/g, (s) => i.replace(/([^,]*:\S+\([^)]*\))|([^,])+/g, (l) => /&/.test(l) ? l.replace(/&/g, s) : s ? s + " " + l : l)) : i) : a != null && (i = /^--/.test(i) ? i : i.replace(/[A-Z]/g, "-$&").toLowerCase(), o += ol.p ? ol.p(i, a) : i + ":" + a + ";");
  }
  return n + (t && o ? t + "{" + o + "}" : o) + r;
}, Js = {}, VY = (e) => {
  if (typeof e == "object") {
    let t = "";
    for (let n in e) t += n + VY(e[n]);
    return t;
  }
  return e;
}, kUe = (e, t, n, r, o) => {
  let i = VY(e), a = Js[i] || (Js[i] = ((l) => {
    let u = 0, c = 11;
    for (; u < l.length; ) c = 101 * c + l.charCodeAt(u++) >>> 0;
    return "go" + c;
  })(i));
  if (!Js[a]) {
    let l = i !== e ? e : ((u) => {
      let c, p, d = [{}];
      for (; c = OUe.exec(u.replace(EUe, "")); ) c[4] ? d.shift() : c[3] ? (p = c[3].replace(GW, " ").trim(), d.unshift(d[0][p] = d[0][p] || {})) : d[0][c[1]] = c[2].replace(GW, " ").trim();
      return d[0];
    })(e);
    Js[a] = ol(o ? { ["@keyframes " + a]: l } : l, n ? "" : "." + a);
  }
  let s = n && Js.g ? Js.g : null;
  return n && (Js.g = Js[a]), ((l, u, c, p) => {
    p ? u.data = u.data.replace(p, l) : u.data.indexOf(l) === -1 && (u.data = c ? l + u.data : u.data + l);
  })(Js[a], t, r, s), a;
}, LUe = (e, t, n) => e.reduce((r, o, i) => {
  let a = t[i];
  if (a && a.call) {
    let s = a(n), l = s && s.props && s.props.className || /^go/.test(s) && s;
    a = l ? "." + l : s && typeof s == "object" ? s.props ? "" : ol(s, "") : s === !1 ? "" : s;
  }
  return r + o + (a ?? "");
}, "");
function m0(e) {
  let t = this || {}, n = e.call ? e(t.p) : e;
  return kUe(n.unshift ? n.raw ? LUe(n, [].slice.call(arguments, 1), t.p) : n.reduce((r, o) => Object.assign(r, o && o.call ? o(t.p) : o), {}) : n, xUe(t.target), t.g, t.o, t.k);
}
let ZY, n1, r1;
m0.bind({ g: 1 });
let fa = m0.bind({ k: 1 });
function PUe(e, t, n, r) {
  ol.p = t, ZY = e, n1 = n, r1 = r;
}
function Dl(e, t) {
  let n = this || {};
  return function() {
    let r = arguments;
    function o(i, a) {
      let s = Object.assign({}, i), l = s.className || o.className;
      n.p = Object.assign({ theme: n1 && n1() }, s), n.o = / *go\d+/.test(l), s.className = m0.apply(n, r) + (l ? " " + l : "");
      let u = e;
      return e[0] && (u = s.as || e, delete s.as), r1 && u[0] && r1(s), ZY(u, s);
    }
    return o;
  };
}
var _Ue = (e) => typeof e == "function", SUe = (e, t) => _Ue(e) ? e(t) : e, MUe = /* @__PURE__ */ (() => {
  let e;
  return () => {
    if (e === void 0 && typeof window < "u") {
      let t = matchMedia("(prefers-reduced-motion: reduce)");
      e = !t || t.matches;
    }
    return e;
  };
})(), DUe = fa`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`, TUe = fa`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`, jUe = fa`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`, AUe = Dl("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${DUe} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${TUe} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${(e) => e.secondary || "#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${jUe} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`, IUe = fa`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, RUe = Dl("div")`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${(e) => e.secondary || "#e0e0e0"};
  border-right-color: ${(e) => e.primary || "#616161"};
  animation: ${IUe} 1s linear infinite;
`, BUe = fa`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`, NUe = fa`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`, FUe = Dl("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${BUe} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${NUe} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${(e) => e.secondary || "#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`, zUe = Dl("div")`
  position: absolute;
`, UUe = Dl("div")`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`, HUe = fa`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`, $Ue = Dl("div")`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${HUe} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`, WUe = ({ toast: e }) => {
  let { icon: t, type: n, iconTheme: r } = e;
  return t !== void 0 ? typeof t == "string" ? Be.createElement($Ue, null, t) : t : n === "blank" ? null : Be.createElement(UUe, null, Be.createElement(RUe, { ...r }), n !== "loading" && Be.createElement(zUe, null, n === "error" ? Be.createElement(AUe, { ...r }) : Be.createElement(FUe, { ...r })));
}, VUe = (e) => `
0% {transform: translate3d(0,${e * -200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`, ZUe = (e) => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${e * -150}%,-1px) scale(.6); opacity:0;}
`, qUe = "0%{opacity:0;} 100%{opacity:1;}", GUe = "0%{opacity:1;} 100%{opacity:0;}", KUe = Dl("div")`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`, YUe = Dl("div")`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`, XUe = (e, t) => {
  let n = e.includes("top") ? 1 : -1, [r, o] = MUe() ? [qUe, GUe] : [VUe(n), ZUe(n)];
  return { animation: t ? `${fa(r)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards` : `${fa(o)} 0.4s forwards cubic-bezier(.06,.71,.55,1)` };
};
Be.memo(({ toast: e, position: t, style: n, children: r }) => {
  let o = e.height ? XUe(e.position || t || "top-center", e.visible) : { opacity: 0 }, i = Be.createElement(WUe, { toast: e }), a = Be.createElement(YUe, { ...e.ariaProps }, SUe(e.message, e));
  return Be.createElement(KUe, { className: e.className, style: { ...o, ...n, ...e.style } }, typeof r == "function" ? r({ icon: i, message: a }) : Be.createElement(Be.Fragment, null, i, a));
});
PUe(Be.createElement);
m0`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`;
function JUe(e) {
  const { error: t } = e, n = "arkynAudioUploadError";
  return t ? /* @__PURE__ */ Q.jsx("strong", { className: n, children: t }) : /* @__PURE__ */ Q.jsx(Q.Fragment, {});
}
function QUe(e) {
  const { label: t, showAsterisk: n } = e, o = `arkynAudioUploadLabel ${n ? "asteriskTrue" : "asteriskFalse"}`;
  return /* @__PURE__ */ Q.jsx("strong", { className: o.trim(), children: t });
}
function eHe(e) {
  const { onChange: t, value: n, disableDrag: r = !1, onDragging: o } = e, [i, a] = k(!1), s = ut(null), l = () => {
    a(!0);
  }, u = () => {
    a(!1);
  }, c = (f) => {
    if (r || !i || !s.current) return;
    const m = s.current.getBoundingClientRect(), v = f.clientX - m.left, E = Math.min(Math.max(v / m.width * 100, 0), 100);
    t(E);
  }, p = (f) => {
    if (!s.current) return;
    const m = s.current.getBoundingClientRect(), v = f.clientX - m.left, E = Math.min(Math.max(v / m.width * 100, 0), 100);
    t(E);
  };
  h(() => (i ? (o && o(!0), document.addEventListener("mousemove", c), document.addEventListener("mouseup", u)) : (o && o(!1), document.removeEventListener("mousemove", c), document.removeEventListener("mouseup", u)), () => {
    document.removeEventListener("mousemove", c), document.removeEventListener("mouseup", u);
  }), [i]);
  const g = `arkynSliderTrack ${i ? "isDragging" : "isNotDragging"}`;
  return /* @__PURE__ */ Q.jsxs(
    "div",
    {
      className: g,
      ref: s,
      onMouseDown: l,
      onClick: p,
      children: [
        /* @__PURE__ */ Q.jsx("div", { className: "arkynSliderFill", style: { width: `${n}%` } }),
        /* @__PURE__ */ Q.jsx("div", { className: "arkynSliderThumb", style: { left: `${n}%` } })
      ]
    }
  );
}
function tHe(e) {
  var _, F, L, N;
  const {
    filePath: t,
    disabled: n,
    acceptAudio: r,
    handleSelectFile: o,
    isLoading: i,
    reSendAudio: a,
    changeAudioButtonText: s
  } = e, [l, u] = k(0), c = ut(null), [p, d] = k(!1), [g, f] = k(!1);
  h(() => {
    const R = c.current;
    if (!R) return;
    const W = () => {
      const V = R.duration, Z = R.currentTime / V * 100;
      u(Z);
    };
    return R.addEventListener("timeupdate", W), () => {
      R.removeEventListener("timeupdate", W);
    };
  }, []);
  function m(R) {
    const W = c.current;
    if (!W) return;
    const V = W.duration, z = R / 100 * V;
    W.currentTime = z;
  }
  function v() {
    var R;
    (R = c.current) == null || R.play(), f(!0);
  }
  function E() {
    var R;
    (R = c.current) == null || R.pause(), f(!1);
  }
  function w() {
    g ? E() : v();
  }
  const M = (_ = c.current) == null ? void 0 : _.currentTime, O = (F = c.current) == null ? void 0 : F.duration;
  function y(R) {
    if (!R) return "00:00";
    const W = Math.floor(R / 60), V = Math.floor(R % 60), z = String(W).padStart(2, "0"), Z = String(V).padStart(2, "0");
    return `${z}:${Z}`;
  }
  p || !g ? (L = c.current) == null || L.pause() : g && ((N = c.current) == null || N.play());
  function C() {
    if (n) return;
    const R = document.createElement("input");
    R.type = "file", R.accept = r, R.onchange = (W) => {
      var z;
      const V = (z = W.target.files) == null ? void 0 : z[0];
      V && o(V);
    }, R.click();
  }
  return /* @__PURE__ */ Q.jsxs("div", { className: "arkynAudioUploadHasFileContentContainer", children: [
    /* @__PURE__ */ Q.jsx("audio", { ref: c, src: t, onEnded: E }),
    /* @__PURE__ */ Q.jsxs("div", { className: "arkynAudioUploadAudioPlayer", children: [
      /* @__PURE__ */ Q.jsxs("button", { type: "button", onClick: w, children: [
        g && /* @__PURE__ */ Q.jsx(ZJ, {}),
        !g && /* @__PURE__ */ Q.jsx(qJ, {})
      ] }),
      /* @__PURE__ */ Q.jsx("p", { children: y(M) }),
      /* @__PURE__ */ Q.jsx(
        eHe,
        {
          value: l,
          onChange: m,
          onDragging: d
        }
      ),
      /* @__PURE__ */ Q.jsx("p", { children: y(O) })
    ] }),
    /* @__PURE__ */ Q.jsx(Roe, {}),
    /* @__PURE__ */ Q.jsxs("div", { className: "arkynAudioUploadButtonsContainer", children: [
      !!a && /* @__PURE__ */ Q.jsx(ABe, { orientation: "bottom", text: "Reenviar udio", children: /* @__PURE__ */ Q.jsx(
        jBe,
        {
          type: "button",
          "aria-label": "resend image",
          variant: "outline",
          scheme: "danger",
          size: "sm",
          isLoading: i,
          onClick: a,
          icon: x1,
          disabled: n
        }
      ) }),
      /* @__PURE__ */ Q.jsx(
        K_,
        {
          isLoading: i,
          onClick: C,
          variant: "outline",
          size: "sm",
          type: "button",
          disabled: n,
          children: s
        }
      )
    ] })
  ] });
}
function nHe(e) {
  const {
    dropAudioText: t,
    isLoading: n,
    acceptAudio: r,
    handleSelectFile: o,
    selectAudioButtonText: i,
    disabled: a
  } = e;
  function s(u) {
    if (a) return;
    u.preventDefault();
    const c = u.dataTransfer.files[0];
    c && o(c);
  }
  function l() {
    if (a) return;
    const u = document.createElement("input");
    u.type = "file", u.accept = r, u.onchange = (c) => {
      var d;
      const p = (d = c.target.files) == null ? void 0 : d[0];
      p && o(p);
    }, u.click();
  }
  return /* @__PURE__ */ Q.jsxs("div", { onDrop: s, className: "arkynAudioUploadNoFileContent", children: [
    /* @__PURE__ */ Q.jsx(
      K_,
      {
        isLoading: n,
        onClick: l,
        variant: "ghost",
        size: "sm",
        type: "button",
        disabled: a,
        children: i
      }
    ),
    /* @__PURE__ */ Q.jsx("p", { children: t })
  ] });
}
function L4e(e) {
  const {
    name: t,
    label: n,
    fileName: r = "file",
    method: o = "POST",
    onUpload: i,
    fileResponseName: a = "url",
    selectAudioButtonText: s = "Selecionar arquivo de udio",
    dropAudioText: l = "Ou arraste e solte um arquivo de udio aqui",
    changeAudioButtonText: u = "Trocar arquivo de udio",
    acceptAudio: c = "audio/*",
    action: p,
    defaultValue: d = "",
    showAsterisk: g = !1,
    disabled: f = !1
  } = e, v = TBe()[t], [E, w] = k(d), [M, O] = k(""), [y, C] = k(null), [_, F] = k(d), [L, N] = k(!1);
  async function R(X) {
    if (f) return;
    N(!0), C(X), O("");
    const te = new FormData();
    te.append(r, X), await fetch(p, { method: o, body: te }).then(async (J) => await J.json()).then((J) => {
      J != null && J.error ? O(J.error) : w(J == null ? void 0 : J[a]), i && i(J == null ? void 0 : J[a]);
    }).catch((J) => {
      console.error(J), O("Erro ao enviar audio");
    }).finally(() => N(!1));
  }
  function W(X) {
    if (!f) {
      if (console.log(X.type), X.type.indexOf("audio") === -1) {
        O("O arquivo selecionado no  um arquivo de udio");
        return;
      }
      F(URL.createObjectURL(X)), R(X);
    }
  }
  const V = v || M, K = `arkynAudioUpload ${V ? "hasError" : "noHasError"} ${_ ? "hasAudio" : "noHasAudio"}`;
  return /* @__PURE__ */ Q.jsxs("div", { className: "arkynAudioUploadContainer", children: [
    n && /* @__PURE__ */ Q.jsx(QUe, { label: n, showAsterisk: g }),
    /* @__PURE__ */ Q.jsxs("div", { className: K, children: [
      /* @__PURE__ */ Q.jsx("input", { type: "hidden", name: t, value: E || "" }),
      !_ && /* @__PURE__ */ Q.jsx(
        nHe,
        {
          disabled: f,
          isLoading: L,
          acceptAudio: c,
          dropAudioText: l,
          handleSelectFile: W,
          selectAudioButtonText: s
        }
      ),
      _ && /* @__PURE__ */ Q.jsx(
        tHe,
        {
          filePath: _,
          acceptAudio: c,
          changeAudioButtonText: u,
          disabled: f,
          handleSelectFile: W,
          isLoading: L,
          reSendAudio: V && y ? () => R(y) : void 0
        }
      )
    ] }),
    V && /* @__PURE__ */ Q.jsx(JUe, { error: V })
  ] });
}
function pf(e) {
  const {
    isLoading: t = !1,
    scheme: n = "primary",
    variant: r = "solid",
    loadingText: o,
    size: i = "md",
    leftIcon: a,
    rightIcon: s,
    disabled: l,
    className: u = "",
    children: c,
    ...p
  } = e, g = { xs: 12, sm: 16, md: 20, lg: 24 }[i], v = `arkynButton ${t ? "loadingTrue" : "loadingFalse"} ${r} ${n} ${i} ${o ? "loadingTextTrue" : "loadingTextFalse"} ${u}`;
  return /* @__PURE__ */ Q.jsxs("button", { className: v, disabled: l || t, ...p, children: [
    /* @__PURE__ */ Q.jsxs("div", { className: "arkynButtonSpinner", children: [
      /* @__PURE__ */ Q.jsx(Ts, { size: g, strokeWidth: 2.5 }),
      o && o
    ] }),
    /* @__PURE__ */ Q.jsxs("div", { className: "arkynButtonContent", children: [
      Fm(g, a),
      c,
      Fm(g, s)
    ] })
  ] });
}
function pS() {
  const e = k1(), t = F6(), n = L1(), [r, o] = k(null);
  function i(u, c) {
    return JSON.stringify(u) === JSON.stringify(c);
  }
  function a() {
    r && o(null);
  }
  h(() => {
    var c, p;
    let u = ((p = (c = n[0]) == null ? void 0 : c.data) == null ? void 0 : p.fieldErrors) || {};
    i(r, u) || Object.entries(u).length !== 0 && o(u);
  }, [n, e]), h(() => {
    var u;
    ((u = n[0]) == null ? void 0 : u.state) === "submitting" && a();
  }, [n, t]);
  const s = (e == null ? void 0 : e.fieldErrors) || r;
  let l = {};
  return Object.entries(s || {}).forEach(([u, c]) => {
    typeof c == "string" && typeof u == "string" && (l[u] = c);
  }), l;
}
const qY = Ke({});
function KW(e) {
  var p;
  const {
    children: t,
    className: n,
    id: r,
    ...o
  } = e, i = pS(), a = ut(null), s = ((p = a.current) == null ? void 0 : p.name) || "", l = (i == null ? void 0 : i[s]) || null, u = UJ(), c = `arkynFormController ${n}`;
  return /* @__PURE__ */ Q.jsx(qY.Provider, { value: { error: l, id: u, inputRef: a }, children: /* @__PURE__ */ Q.jsx(
    "section",
    {
      id: r || s || void 0,
      className: c.trim(),
      ...o,
      children: t
    }
  ) });
}
function ni() {
  return ge(qY);
}
function P4e(e) {
  const {
    name: t,
    className: n = "",
    size: r = "md",
    isError: o,
    defaultChecked: i = !1,
    checked: a = null,
    onCheck: s,
    value: l,
    ...u
  } = e, { id: c, inputRef: p, error: d } = ni(), g = o || !!d, [f, m] = k(i || !1), v = typeof a == "boolean" ? a : f, M = `arkynCheckbox ${r} ${g ? "errorTrue" : "errorFalse"} ${v ? "checkedTrue" : "checkedFalse"} ${n}`;
  function O() {
    const y = f;
    m(!y), s && s(y ? "" : l || "checked");
  }
  return /* @__PURE__ */ Q.jsxs(
    "button",
    {
      id: c,
      type: "button",
      className: M,
      onClick: O,
      ...u,
      children: [
        /* @__PURE__ */ Q.jsx(
          "input",
          {
            type: "hidden",
            name: t,
            ref: p,
            value: v ? l || "checked" : ""
          }
        ),
        /* @__PURE__ */ Q.jsx(Zy, {})
      ]
    }
  );
}
function rHe(e) {
  const { error: t } = e, n = "arkynFileUploadError";
  return t ? /* @__PURE__ */ Q.jsx("strong", { className: n, children: t }) : /* @__PURE__ */ Q.jsx(Q.Fragment, {});
}
function oHe(e) {
  const { label: t, showAsterisk: n } = e, o = `arkynFileUploadLabel ${n ? "asteriskTrue" : "asteriskFalse"}`;
  return /* @__PURE__ */ Q.jsx("strong", { className: o.trim(), children: t });
}
function GY(e) {
  const {
    isLoading: t = !1,
    scheme: n = "primary",
    variant: r = "solid",
    size: o = "md",
    icon: i,
    disabled: a,
    className: s = "",
    ...l
  } = e, u = { xs: 12, sm: 16, md: 20, lg: 24 }, p = `arkynIconButton ${r} ${n} ${o} ${t ? "loadingTrue" : "loadingFalse"} ${s}`;
  return /* @__PURE__ */ Q.jsxs(
    "button",
    {
      disabled: a || t,
      className: p.trim(),
      ...l,
      children: [
        /* @__PURE__ */ Q.jsx("div", { className: "arkynIconButtonSpinner", children: /* @__PURE__ */ Q.jsx(Ts, { size: u[o], strokeWidth: 2.5 }) }),
        /* @__PURE__ */ Q.jsx("div", { className: "arkynIconButtonContent", children: /* @__PURE__ */ Q.jsx(i, { size: u[o], strokeWidth: 2.5 }) })
      ]
    }
  );
}
function KY(e) {
  const {
    text: t,
    size: n = "lg",
    children: r,
    orientation: o = "top",
    className: i = "",
    ...a
  } = e, s = `arkynTooltip ${n} ${o} ${i}`;
  return /* @__PURE__ */ Q.jsxs("div", { className: s.trim(), ...a, children: [
    r,
    /* @__PURE__ */ Q.jsx("div", { className: "arkynTooltipText", children: t })
  ] });
}
function iHe(e) {
  const {
    disabled: t,
    file: n,
    isLoading: r,
    acceptFile: o,
    changeFileButtonText: i,
    handleSelectFile: a,
    reSendFile: s
  } = e;
  function l() {
    if (t) return;
    const c = document.createElement("input");
    c.type = "file", c.accept = o, c.onchange = (p) => {
      var g;
      const d = (g = p.target.files) == null ? void 0 : g[0];
      d && a(d);
    }, c.click();
  }
  function u() {
    return n.type.startsWith("image/") ? /* @__PURE__ */ Q.jsx(GJ, {}) : n.type.startsWith("audio/") ? /* @__PURE__ */ Q.jsx(KJ, {}) : n.type.startsWith("application/zip") ? /* @__PURE__ */ Q.jsx(YJ, {}) : /* @__PURE__ */ Q.jsx(XJ, {});
  }
  return /* @__PURE__ */ Q.jsxs("div", { className: "arkynFileUploadHasFileContent", children: [
    /* @__PURE__ */ Q.jsxs("section", { className: "arkynFileUploadFileContainer", children: [
      /* @__PURE__ */ Q.jsx(u, {}),
      /* @__PURE__ */ Q.jsx("p", { children: n.name })
    ] }),
    /* @__PURE__ */ Q.jsx(x8, {}),
    /* @__PURE__ */ Q.jsxs("div", { className: "arkynFileUploadButtonsContainer", children: [
      !!s && /* @__PURE__ */ Q.jsx(KY, { orientation: "bottom", text: "Reenviar arquivo", children: /* @__PURE__ */ Q.jsx(
        GY,
        {
          type: "button",
          "aria-label": "resend file",
          variant: "outline",
          scheme: "danger",
          size: "sm",
          isLoading: r,
          onClick: s,
          icon: x1,
          disabled: t
        }
      ) }),
      /* @__PURE__ */ Q.jsx(
        pf,
        {
          isLoading: r,
          onClick: l,
          variant: "outline",
          size: "sm",
          type: "button",
          disabled: t,
          children: i
        }
      )
    ] })
  ] });
}
function sHe(e) {
  const {
    dropFileText: t,
    isLoading: n,
    acceptFile: r,
    handleSelectFile: o,
    selectFileButtonText: i,
    disabled: a
  } = e;
  function s(u) {
    if (a) return;
    u.preventDefault();
    const c = u.dataTransfer.files[0];
    c && o(c);
  }
  function l() {
    if (a) return;
    const u = document.createElement("input");
    u.type = "file", u.accept = r, u.onchange = (c) => {
      var d;
      const p = (d = c.target.files) == null ? void 0 : d[0];
      p && o(p);
    }, u.click();
  }
  return /* @__PURE__ */ Q.jsxs("div", { onDrop: s, className: "arkynFileUploadNoFileContent", children: [
    /* @__PURE__ */ Q.jsx(
      K_,
      {
        isLoading: n,
        onClick: l,
        variant: "ghost",
        size: "sm",
        type: "button",
        disabled: a,
        children: i
      }
    ),
    /* @__PURE__ */ Q.jsx("p", { children: t })
  ] });
}
function _4e(e) {
  const {
    name: t,
    label: n,
    showAsterisk: r = !1,
    action: o,
    fileName: i = "file",
    method: a = "POST",
    acceptFile: s = "*",
    fileResponseName: l = "url",
    changeFileButtonText: u = "Alterar arquivo",
    selectFileButtonText: c = "Selecionar arquivo",
    dropFileText: p = "Ou arraste e solte o arquivo aqui",
    onUpload: d,
    disabled: g = !1
  } = e, m = pS()[t], [v, E] = k(""), [w, M] = k(""), [O, y] = k(null), [C, _] = k(!1);
  async function F(z) {
    if (g) return;
    _(!0), y(z), M("");
    const Z = new FormData();
    Z.append(i, z), await fetch(o, { method: a, body: Z }).then(async (K) => await K.json()).then((K) => {
      K != null && K.error ? M(K.error) : E(K == null ? void 0 : K[l]), d && d(K == null ? void 0 : K[l]);
    }).catch((K) => {
      console.error(K), M("Erro ao enviar o arquivo");
    }).finally(() => _(!1));
  }
  function L(z) {
    g || F(z);
  }
  const N = m || w, V = `arkynFileUpload ${N ? "hasError" : "noHasError"} ${O ? "hasFile" : "noHasFile"}`;
  return /* @__PURE__ */ Q.jsxs("div", { className: "arkynFileUploadContainer", children: [
    n && /* @__PURE__ */ Q.jsx(oHe, { label: n, showAsterisk: r }),
    /* @__PURE__ */ Q.jsxs("div", { className: V, children: [
      /* @__PURE__ */ Q.jsx("input", { type: "hidden", name: t, value: v || "" }),
      !O && /* @__PURE__ */ Q.jsx(
        sHe,
        {
          disabled: g,
          isLoading: C,
          acceptFile: s,
          dropFileText: p,
          handleSelectFile: L,
          selectFileButtonText: c
        }
      ),
      O && /* @__PURE__ */ Q.jsx(
        iHe,
        {
          disabled: g,
          isLoading: C,
          acceptFile: s,
          file: O,
          handleSelectFile: L,
          changeFileButtonText: u,
          reSendFile: N && O ? () => F(O) : void 0
        }
      )
    ] }),
    N && /* @__PURE__ */ Q.jsx(rHe, { error: N })
  ] });
}
function S4e(e) {
  const { children: t, className: n, ...r } = e, o = `arkynFormError ${n}`, { error: i } = ni();
  return t ? /* @__PURE__ */ Q.jsx("strong", { className: o.trim(), ...r, children: t }) : i ? /* @__PURE__ */ Q.jsx("strong", { className: o.trim(), ...r, children: i }) : /* @__PURE__ */ Q.jsx(Q.Fragment, {});
}
function YW(e) {
  const {
    showAsterisk: t = !1,
    className: n = "",
    ...r
  } = e, { id: o } = ni(), a = `arkynFormLabel ${t ? "asteriskTrue" : "asteriskFalse"} ${n}`;
  return /* @__PURE__ */ Q.jsx("label", { className: a.trim(), htmlFor: o, ...r });
}
function aHe(e) {
  const {
    disabled: t,
    filePath: n,
    isLoading: r,
    acceptImage: o,
    changeImageButtonText: i,
    handleSelectFile: a,
    reSendImage: s
  } = e;
  function l() {
    if (t) return;
    const u = document.createElement("input");
    u.type = "file", u.accept = o, u.onchange = (c) => {
      var d;
      const p = (d = c.target.files) == null ? void 0 : d[0];
      p && a(p);
    }, u.click();
  }
  return /* @__PURE__ */ Q.jsxs(
    "div",
    {
      className: "arkynImageUploadHasFileContent",
      style: { backgroundImage: `url("${n}")` },
      children: [
        s && /* @__PURE__ */ Q.jsx(KY, { orientation: "bottom", text: "Reenviar imagem", children: /* @__PURE__ */ Q.jsx(
          GY,
          {
            type: "button",
            "aria-label": "resend image",
            variant: "outline",
            scheme: "danger",
            size: "sm",
            isLoading: r,
            onClick: s,
            icon: x1,
            disabled: t
          }
        ) }),
        /* @__PURE__ */ Q.jsx(
          pf,
          {
            isLoading: r,
            onClick: l,
            variant: "outline",
            size: "sm",
            type: "button",
            disabled: t,
            children: i
          }
        )
      ]
    }
  );
}
function lHe(e) {
  const { error: t } = e, n = "arkynImageUploadError";
  return t ? /* @__PURE__ */ Q.jsx("strong", { className: n, children: t }) : /* @__PURE__ */ Q.jsx(Q.Fragment, {});
}
function uHe(e) {
  const { label: t, showAsterisk: n } = e, o = `arkynImageUploadLabel ${n ? "asteriskTrue" : "asteriskFalse"}`;
  return /* @__PURE__ */ Q.jsx("strong", { className: o.trim(), children: t });
}
function cHe(e) {
  const {
    dropImageText: t,
    isLoading: n,
    acceptImage: r,
    handleSelectFile: o,
    selectImageButtonText: i,
    disabled: a
  } = e;
  function s(u) {
    if (a) return;
    u.preventDefault();
    const c = u.dataTransfer.files[0];
    c && o(c);
  }
  function l() {
    if (a) return;
    const u = document.createElement("input");
    u.type = "file", u.accept = r, u.onchange = (c) => {
      var d;
      const p = (d = c.target.files) == null ? void 0 : d[0];
      p && o(p);
    }, u.click();
  }
  return /* @__PURE__ */ Q.jsxs("div", { onDrop: s, className: "arkynImageUploadNoFileContent", children: [
    /* @__PURE__ */ Q.jsx(
      pf,
      {
        isLoading: n,
        onClick: l,
        variant: "ghost",
        size: "sm",
        type: "button",
        disabled: a,
        children: i
      }
    ),
    /* @__PURE__ */ Q.jsx("p", { children: t })
  ] });
}
function pHe(e) {
  const {
    name: t,
    defaultValue: n = "",
    label: r,
    showAsterisk: o = !1,
    action: i,
    fileName: a = "file",
    method: s = "POST",
    acceptImage: l = "image/*",
    fileResponseName: u = "url",
    changeImageButtonText: c = "Alterar imagem",
    selectImageButtonText: p = "Selecionar imagem",
    dropImageText: d = "Ou arraste e solte a imagem aqui",
    onUpload: g,
    disabled: f = !1
  } = e, v = pS()[t], [E, w] = k(n), [M, O] = k(""), [y, C] = k(null), [_, F] = k(n), [L, N] = k(!1);
  async function R(X) {
    if (f) return;
    N(!0), C(X), O("");
    const te = new FormData();
    te.append(a, X), await fetch(i, { method: s, body: te }).then(async (J) => await J.json()).then((J) => {
      J != null && J.error ? O(J.error) : w(J == null ? void 0 : J[u]), g && g(J == null ? void 0 : J[u]);
    }).catch((J) => {
      console.error(J), O("Erro ao enviar imagem");
    }).finally(() => N(!1));
  }
  function W(X) {
    f || (F(URL.createObjectURL(X)), R(X));
  }
  const V = v || M, K = `arkynImageUpload ${V ? "hasError" : "noHasError"} ${_ ? "hasImage" : "noHasImage"}`;
  return /* @__PURE__ */ Q.jsxs("div", { className: "arkynImageUploadContainer", children: [
    r && /* @__PURE__ */ Q.jsx(uHe, { label: r, showAsterisk: o }),
    /* @__PURE__ */ Q.jsxs("div", { className: K, children: [
      /* @__PURE__ */ Q.jsx("input", { type: "hidden", name: t, value: E || "" }),
      !_ && /* @__PURE__ */ Q.jsx(
        cHe,
        {
          disabled: f,
          isLoading: L,
          acceptImage: l,
          dropImageText: d,
          handleSelectFile: W,
          selectImageButtonText: p
        }
      ),
      _ && /* @__PURE__ */ Q.jsx(
        aHe,
        {
          disabled: f,
          isLoading: L,
          acceptImage: l,
          filePath: _,
          handleSelectFile: W,
          changeImageButtonText: c,
          reSendImage: V && y ? () => R(y) : void 0
        }
      )
    ] }),
    V && /* @__PURE__ */ Q.jsx(lHe, { error: V })
  ] });
}
function ll(e, t, n) {
  if (!e) return /* @__PURE__ */ Q.jsx(Q.Fragment, {});
  if (typeof e == "string") return /* @__PURE__ */ Q.jsx("p", { className: n, children: e });
  const r = e;
  return /* @__PURE__ */ Q.jsx("p", { className: n, children: /* @__PURE__ */ Q.jsx(r, { color: "var(--secondary-600)", size: t, strokeWidth: 2.5 }) });
}
function dS(e) {
  return e && e.replace(/[^0-9]/g, "");
}
function YY(e, t) {
  let n = "", r = 0;
  return Array.from(e).forEach((o, i) => {
    t[i + r].match(/[0-9]/) || (n += t[i + r], r++), n += o;
  }), n;
}
function XY(e) {
  return e.length > 11 ? "CNPJ" : "CPF";
}
const fS = {
  CPF: "999.999.999-999",
  CNPJ: "99.999.999/9999-99"
}, JY = dS(fS.CNPJ).length;
function dHe(e, t) {
  const {
    isLoading: n,
    isError: r,
    size: o = "md",
    className: i = "",
    variant: a = "solid",
    prefix: s,
    sufix: l,
    leftIcon: u,
    rightIcon: c,
    disabled: p,
    defaultValue: d,
    readOnly: g,
    onFocus: f,
    onBlur: m,
    title: v,
    style: E,
    onChange: w,
    ...M
  } = e;
  function O(z) {
    let Z = dS(z);
    const K = XY(Z);
    if (!(Z.length > JY))
      return Z = YY(Z, fS[K]), Z;
  }
  const y = c ? "right" : "left", R = `arkyn_input ${s ? "hasPrefix" : ""} ${l ? "hasSufix" : ""} ${a} ${o} ${p || g || n ? "opacity" : ""} ${r ? "errored" : ""} ${t ? "focused" : ""} ${i}`, V = { md: 20, lg: 20 }[o];
  return {
    isLoading: n,
    className: R,
    prefix: ll(s, V, "prefix"),
    sufix: ll(l, V, "sufix"),
    LeftIcon: u,
    RightIcon: c,
    defaultValue: O(d || ""),
    disabled: p,
    readOnly: g,
    onFocus: f,
    onBlur: m,
    title: v,
    style: E,
    onChange: w,
    loadingPosition: y,
    iconSize: V,
    Spinner: /* @__PURE__ */ Q.jsx(Ts, { className: "spinner", size: V, strokeWidth: 2.5 }),
    ...M
  };
}
function fHe(e) {
  const [t, n] = k(!1), r = ut(null), { inputRef: o, id: i, error: a } = ni(), s = o || r, l = e.isError || !!a, {
    disabled: u,
    title: c,
    style: p,
    className: d,
    prefix: g,
    sufix: f,
    iconSize: m,
    loadingPosition: v,
    isLoading: E,
    LeftIcon: w,
    readOnly: M,
    onFocus: O,
    onBlur: y,
    RightIcon: C,
    Spinner: _,
    onChange: F,
    value: L,
    defaultValue: N,
    ...R
  } = dHe({ ...e, id: i, isError: l }, t), [W, V] = k(N), z = w && !E, Z = C && !E, K = v === "left" && E, X = v === "right" && E;
  function te() {
    u || !(s != null && s.current) || (n(!0), s.current.focus());
  }
  function J(H) {
    let S = dS(H.target.value);
    const $ = XY(S);
    S.length > JY || (S = YY(S, fS[$]), H.target.value = S, V(S), F && F(H));
  }
  function P(H) {
    n(!0), O && O(H);
  }
  function D(H) {
    n(!1), y && y(H);
  }
  return /* @__PURE__ */ Q.jsxs(
    "section",
    {
      title: c,
      style: p,
      onClick: te,
      className: d,
      children: [
        g,
        K && _,
        z && /* @__PURE__ */ Q.jsx(w, { size: m, strokeWidth: 2.5 }),
        /* @__PURE__ */ Q.jsx(
          "input",
          {
            disabled: u || E,
            readOnly: M,
            ref: s,
            value: L || W,
            onFocus: P,
            onChange: J,
            onBlur: D,
            ...R
          }
        ),
        Z && /* @__PURE__ */ Q.jsx(C, { size: m, strokeWidth: 2.5 }),
        X && _,
        f
      ]
    }
  );
}
const hHe = 3, gHe = (e = "pt-BR", t, n = "BRL", r = !0) => new Intl.NumberFormat(e, {
  style: "currency",
  currency: n,
  currencyDisplay: "symbol",
  minimumFractionDigits: 2,
  maximumFractionDigits: 2
}).format(t).slice(r ? hHe : 0), am = 2, XW = (e) => typeof e == "number" ? e : Number(e.toString().replace(/[^0-9-]/g, "")), o1 = (e) => {
  let t = e;
  return typeof e == "string" ? (t = XW(e), t % 1 !== 0 && (t = t.toFixed(am))) : t = Number.isInteger(e) ? Number(e) * 10 ** am : e.toFixed(am), XW(t) / 10 ** am;
}, JW = (e, t, n) => {
  if (!t) return [0, ""];
  const r = o1(t), o = gHe(e, r, n);
  return [r, o];
};
function mHe(e, t) {
  const {
    isLoading: n,
    isError: r,
    size: o = "md",
    className: i = "",
    variant: a = "solid",
    prefix: s,
    sufix: l,
    leftIcon: u,
    rightIcon: c,
    disabled: p,
    readOnly: d,
    onFocus: g,
    onBlur: f,
    title: m,
    style: v,
    // showCents = false,
    max: E = 1e9,
    locale: w = "pt-BR",
    currency: M = "BRL",
    ...O
  } = e, y = c ? "right" : "left", R = `arkyn_input ${s ? "hasPrefix" : ""} ${l ? "hasSufix" : ""} ${a} ${o} ${p || d || n ? "opacity" : ""} ${r ? "errored" : ""} ${t ? "focused" : ""} ${i}`, V = { md: 20, lg: 20 }[o];
  return {
    isLoading: n,
    className: R,
    prefix: ll(s, V, "prefix"),
    sufix: ll(l, V, "sufix"),
    LeftIcon: u,
    RightIcon: c,
    disabled: p,
    locale: w,
    currency: M,
    readOnly: d,
    onFocus: g,
    onBlur: f,
    title: m,
    style: v,
    max: E,
    // showCents,
    loadingPosition: y,
    iconSize: V,
    Spinner: /* @__PURE__ */ Q.jsx(Ts, { className: "spinner", size: V, strokeWidth: 2.5 }),
    ...O
  };
}
function vHe(e) {
  const [t, n] = k(!1), [r, o] = k("0"), i = ut(null), { inputRef: a, id: s, error: l } = ni(), u = a || i, c = e.isError || !!l, {
    disabled: p,
    title: d,
    style: g,
    className: f,
    prefix: m,
    sufix: v,
    iconSize: E,
    loadingPosition: w,
    isLoading: M,
    LeftIcon: O,
    readOnly: y,
    onFocus: C,
    onBlur: _,
    RightIcon: F,
    Spinner: L,
    value: N,
    max: R,
    onChangeValue: W,
    onKeyPress: V,
    currency: z,
    locale: Z,
    name: K,
    defaultValue: X,
    ...te
  } = mHe({ ...e, id: s, isError: c }, t), J = O && !M, P = F && !M, D = w === "left" && M, H = w === "right" && M;
  function S() {
    p || !(u != null && u.current) || (n(!0), u.current.focus());
  }
  function $(q) {
    n(!0), C && C(q);
  }
  function x(q) {
    n(!1), _ && _(q);
  }
  const j = (q) => {
    const [A, Y] = JW(
      Z,
      q,
      z
    );
    return !R || A <= R ? (o(Y), [A, Y]) : [o1(r), r];
  }, U = (q) => {
    q.preventDefault();
    const [A, Y] = j(q.target.value);
    W && W(q, String(A), String(Y));
  }, T = (q) => V && V(q, q.key, q.key);
  return h(() => {
    const q = N || +X || void 0, [, A] = JW(Z, q, z);
    o(A);
  }, [z, X, N]), /* @__PURE__ */ Q.jsxs(
    "section",
    {
      title: d,
      style: g,
      onClick: S,
      className: f,
      children: [
        m,
        D && L,
        J && /* @__PURE__ */ Q.jsx(O, { size: E, strokeWidth: 2.5 }),
        /* @__PURE__ */ Q.jsx(
          "input",
          {
            value: r,
            onChange: U,
            onBlur: x,
            onFocus: $,
            onKeyUp: T,
            disabled: p || M,
            readOnly: y,
            ...te
          }
        ),
        /* @__PURE__ */ Q.jsx(
          "input",
          {
            type: "hidden",
            ref: u,
            name: K,
            value: o1(r)
          }
        ),
        H && L,
        P && /* @__PURE__ */ Q.jsx(F, { size: E, strokeWidth: 2.5 }),
        v
      ]
    }
  );
}
function yHe(e, t) {
  const {
    isLoading: n,
    isError: r,
    size: o = "md",
    className: i = "",
    variant: a = "solid",
    prefix: s,
    sufix: l,
    leftIcon: u,
    rightIcon: c,
    disabled: p,
    readOnly: d,
    onFocus: g,
    onBlur: f,
    title: m,
    style: v,
    onChange: E,
    showMask: w = !1,
    type: M,
    ...O
  } = e, y = c ? "right" : "left", R = `arkyn_input ${s ? "hasPrefix" : ""} ${l ? "hasSufix" : ""} ${a} ${o} ${p || d || n ? "opacity" : ""} ${r ? "errored" : ""} ${t ? "focused" : ""} ${i}`, V = { md: 20, lg: 20 }[o];
  return {
    isLoading: n,
    className: R,
    prefix: ll(s, V, "prefix"),
    sufix: ll(l, V, "sufix"),
    LeftIcon: u,
    RightIcon: c,
    disabled: p,
    readOnly: d,
    onFocus: g,
    onBlur: f,
    title: m,
    style: v,
    onChange: E,
    loadingPosition: y,
    iconSize: V,
    showMask: w,
    Spinner: /* @__PURE__ */ Q.jsx(Ts, { className: "spinner", size: V, strokeWidth: 2.5 }),
    ...O
  };
}
const bHe = to((e, t) => /* @__PURE__ */ Q.jsx("input", { ref: t, ...e }));
function wHe(e) {
  const [t, n] = k(!1), r = ut(null), { inputRef: o, id: i, error: a } = ni(), s = o || r, l = e.isError || !!a, {
    disabled: u,
    title: c,
    style: p,
    className: d,
    prefix: g,
    sufix: f,
    iconSize: m,
    loadingPosition: v,
    isLoading: E,
    LeftIcon: w,
    readOnly: M,
    onFocus: O,
    onBlur: y,
    RightIcon: C,
    Spinner: _,
    ...F
  } = yHe({ ...e, id: i, isError: l }, t), L = w && !E, N = C && !E, R = v === "left" && E, W = v === "right" && E;
  function V() {
    u || !(s != null && s.current) || (n(!0), s.current.focus());
  }
  function z(K) {
    n(!0), O && O(K);
  }
  function Z(K) {
    n(!1), y && y(K);
  }
  return /* @__PURE__ */ Q.jsxs(
    "section",
    {
      title: c,
      style: p,
      onClick: V,
      className: d,
      children: [
        g,
        R && _,
        L && /* @__PURE__ */ Q.jsx(w, { size: m, strokeWidth: 2.5 }),
        /* @__PURE__ */ Q.jsx(
          cl,
          {
            component: bHe,
            ref: s,
            onFocus: z,
            onBlur: Z,
            disabled: u,
            ...F
          }
        ),
        N && /* @__PURE__ */ Q.jsx(C, { size: m, strokeWidth: 2.5 }),
        W && _,
        f
      ]
    }
  );
}
function CHe(e, t) {
  const {
    isLoading: n,
    isError: r,
    size: o = "md",
    className: i = "",
    variant: a = "solid",
    prefix: s,
    sufix: l,
    leftIcon: u,
    rightIcon: c,
    disabled: p,
    readOnly: d,
    onFocus: g,
    onBlur: f,
    title: m,
    style: v,
    onChange: E,
    ...w
  } = e, M = c ? "right" : "left", L = `arkyn_input ${s ? "hasPrefix" : ""} ${l ? "hasSufix" : ""} ${a} ${o} ${p || d || n ? "opacity" : ""} ${r ? "errored" : ""} ${t ? "focused" : ""} ${i}`, R = { md: 20, lg: 20 }[o];
  return {
    isLoading: n,
    className: L,
    prefix: ll(s, R, "prefix"),
    sufix: ll(l, R, "sufix"),
    LeftIcon: u,
    RightIcon: c,
    disabled: p,
    readOnly: d,
    onFocus: g,
    onBlur: f,
    title: m,
    style: v,
    onChange: E,
    loadingPosition: M,
    iconSize: R,
    Spinner: /* @__PURE__ */ Q.jsx(Ts, { className: "spinner", size: R, strokeWidth: 2.5 }),
    ...w
  };
}
function xHe(e) {
  const [t, n] = k(!1), r = ut(null), { inputRef: o, id: i, error: a } = ni(), s = o || r, l = e.isError || !!a, {
    disabled: u,
    title: c,
    style: p,
    className: d,
    prefix: g,
    sufix: f,
    iconSize: m,
    loadingPosition: v,
    isLoading: E,
    LeftIcon: w,
    readOnly: M,
    onFocus: O,
    onBlur: y,
    RightIcon: C,
    type: _,
    Spinner: F,
    ...L
  } = CHe({ ...e, id: i, isError: l }, t), N = w && !E, R = C && !E, W = v === "left" && E, V = v === "right" && E;
  function z() {
    u || !(s != null && s.current) || (n(!0), s.current.focus());
  }
  function Z(X) {
    n(!0), O && O(X);
  }
  function K(X) {
    n(!1), y && y(X);
  }
  return _ === "hidden" ? /* @__PURE__ */ Q.jsx(
    "input",
    {
      style: { display: "none" },
      readOnly: !0,
      type: "text",
      ref: s,
      ...L
    }
  ) : /* @__PURE__ */ Q.jsxs(
    "section",
    {
      title: c,
      style: p,
      onClick: z,
      className: d,
      children: [
        g,
        W && F,
        N && /* @__PURE__ */ Q.jsx(w, { size: m, strokeWidth: 2.5 }),
        /* @__PURE__ */ Q.jsx(
          "input",
          {
            disabled: u || E,
            readOnly: M,
            ref: s,
            onFocus: Z,
            onBlur: K,
            type: _,
            ...L
          }
        ),
        R && /* @__PURE__ */ Q.jsx(C, { size: m, strokeWidth: 2.5 }),
        V && F,
        f
      ]
    }
  );
}
function v0(e) {
  return e.type === "currency" ? /* @__PURE__ */ Q.jsx(vHe, { ...e }) : e.type === "masked" ? /* @__PURE__ */ Q.jsx(wHe, { ...e }) : e.type === "cpf-cnpj" ? /* @__PURE__ */ Q.jsx(fHe, { ...e }) : /* @__PURE__ */ Q.jsx(xHe, { ...e });
}
function OHe(e) {
  const { iconSize: t, isLoading: n, disabled: r, readOnly: o, isFocused: i } = e, l = `arkynMultiSelectChevron ${r || o ? "notAnimate" : ""} ${i ? "focused" : ""}`;
  return n ? /* @__PURE__ */ Q.jsx(Q.Fragment, {}) : /* @__PURE__ */ Q.jsx(O1, { className: l, size: t, strokeWidth: 2.5 });
}
function EHe(e) {
  const {
    children: t,
    handleContainerFocus: n,
    disabled: r,
    isError: o,
    isLoading: i,
    isFocused: a,
    className: s,
    readOnly: l,
    variant: u,
    size: c,
    id: p,
    prefixExists: d
  } = e, g = d ? "hasPrefix" : "", f = o ? "errored" : "", m = r || l || i ? "opacity" : "", v = a ? "focused" : "";
  return /* @__PURE__ */ Q.jsx(
    "section",
    {
      id: p,
      className: `arkynMultiSelectContainer ${g} ${u} ${c} ${m} ${f} ${v} ${s}`,
      onClick: n,
      children: t
    }
  );
}
function kHe(e) {
  const { children: t, size: n } = e, r = `arkynMultiSelectContent ${n}`;
  return /* @__PURE__ */ Q.jsx("div", { className: r, children: t });
}
function LHe(e) {
  const { label: t, value: n, handleChangeValue: r } = e;
  return /* @__PURE__ */ Q.jsxs("div", { className: "arkynMultiSelectMark", children: [
    t,
    /* @__PURE__ */ Q.jsx(
      "button",
      {
        type: "button",
        onClick: (o) => {
          o.stopPropagation(), r(n);
        },
        children: /* @__PURE__ */ Q.jsx(E1, {})
      }
    )
  ] });
}
function PHe(e) {
  const { label: t, optionHasSelected: n, handleChangeValue: r, value: o, size: i } = e, a = n(o) ? "active" : "", s = `arkynMultiSelectOption ${i} ${a}`;
  return /* @__PURE__ */ Q.jsxs("div", { onClick: () => r(o), className: s, children: [
    t,
    " ",
    /* @__PURE__ */ Q.jsx(Zy, {})
  ] });
}
function _He(e) {
  const { children: t, isFocused: n, isSearchable: r, onSearch: o } = e;
  function i(a) {
    r && o(a.target.value);
  }
  return n ? /* @__PURE__ */ Q.jsxs("div", { className: "arkynMultiSelectOptionsContainer", children: [
    r && /* @__PURE__ */ Q.jsx(
      v0,
      {
        type: "search",
        name: "search-select",
        variant: "underline",
        leftIcon: N6,
        onChange: i
      }
    ),
    t
  ] }) : /* @__PURE__ */ Q.jsx(Q.Fragment, {});
}
function SHe(e) {
  const { isFocused: t, handleBlur: n } = e;
  return t ? /* @__PURE__ */ Q.jsx("aside", { className: "arkynMultiSelectOverlay", onClick: n }) : /* @__PURE__ */ Q.jsx(Q.Fragment, {});
}
function MHe(e) {
  const { iconSize: t, isLoading: n } = e;
  return n ? /* @__PURE__ */ Q.jsx(
    Ts,
    {
      className: "arkynMultiSelectSpinner",
      size: t,
      strokeWidth: 2.5
    }
  ) : /* @__PURE__ */ Q.jsx(Q.Fragment, {});
}
function M4e(e) {
  const {
    name: t,
    options: n,
    className: r = "",
    placeholder: o = "Selecione...",
    closeOnSelect: i = !1,
    defaultValue: a = [],
    isError: s,
    isLoading: l = !1,
    readOnly: u = !1,
    isSearchable: c = !1,
    leftIcon: p,
    onSearch: d,
    onSelect: g,
    onBlur: f,
    notFoundText: m = "Sem opes disponveis",
    onFocus: v,
    disabled: E = !1,
    prefix: w,
    size: M = "md",
    value: O,
    variant: y = "solid"
  } = e, C = ni(), _ = ut(null), F = C.inputRef || _, L = C.id, N = s || !!C.error, W = { md: 20, lg: 20 }[M], V = C8(w, W, "prefix"), [z, Z] = k(""), [K, X] = k(!1), [te, J] = k(a), P = O || te;
  function D(T) {
    return P.includes(T);
  }
  function H(T) {
    const q = n.find((A) => A.value === T);
    return (q == null ? void 0 : q.label) || "";
  }
  function S() {
    E || !(F != null && F.current) || K || (X(!0), F.current.focus(), v && v());
  }
  function $() {
    X(!1), f && F.current && F.current.blur();
  }
  function x(T) {
    Z(T), d && d(T);
  }
  function j(T) {
    D(T) ? J(te.filter((q) => q !== T)) : J([...te, T]), g && g(te), i && $();
  }
  const U = n.filter((T) => !!(e.onSearch || !e.isSearchable || T.label.toLowerCase().includes(z.toLowerCase())));
  return /* @__PURE__ */ Q.jsxs(
    EHe,
    {
      handleContainerFocus: S,
      disabled: E,
      isError: N,
      isFocused: K,
      isLoading: l,
      readOnly: u,
      size: M,
      variant: y,
      className: r,
      prefixExists: !!w,
      id: L,
      children: [
        /* @__PURE__ */ Q.jsx(
          "input",
          {
            ref: F,
            name: t,
            value: JSON.stringify(P),
            type: "hidden"
          }
        ),
        V,
        p && /* @__PURE__ */ Q.jsx(p, { size: W, strokeWidth: 2.5 }),
        /* @__PURE__ */ Q.jsxs(kHe, { size: M, children: [
          P.map((T) => /* @__PURE__ */ Q.jsx(
            LHe,
            {
              label: H(T),
              value: T,
              handleChangeValue: j
            },
            T
          )),
          P.length <= 0 && /* @__PURE__ */ Q.jsx("p", { children: o })
        ] }),
        /* @__PURE__ */ Q.jsxs(
          _He,
          {
            isFocused: K,
            isSearchable: c,
            onSearch: x,
            children: [
              U.map(({ label: T, value: q }) => /* @__PURE__ */ Q.jsx(
                PHe,
                {
                  label: T,
                  value: q,
                  size: M,
                  handleChangeValue: j,
                  optionHasSelected: D
                },
                q
              )),
              U.length <= 0 && /* @__PURE__ */ Q.jsx("p", { children: m })
            ]
          }
        ),
        /* @__PURE__ */ Q.jsx(
          OHe,
          {
            disabled: E,
            isFocused: K,
            readOnly: u,
            iconSize: W,
            isLoading: l
          }
        ),
        /* @__PURE__ */ Q.jsx(MHe, { iconSize: W, isLoading: l }),
        /* @__PURE__ */ Q.jsx(SHe, { handleBlur: $, isFocused: K })
      ]
    }
  );
}
const tc = [
  {
    name: "Afghanistan",
    code: "+93",
    prefix: null,
    iso: "AF",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/af.svg",
    mask: "__-___-____"
  },
  {
    name: "Aland Islands",
    code: "+358",
    prefix: null,
    iso: "AX",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ax.svg",
    mask: "(___)___-__-__"
  },
  {
    name: "Albania",
    code: "+355",
    prefix: null,
    iso: "AL",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/al.svg",
    mask: "(___)___-___"
  },
  {
    name: "Algeria",
    code: "+213",
    prefix: null,
    iso: "DZ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/dz.svg",
    mask: "__-___-____"
  },
  {
    name: "American Samoa",
    code: "+1",
    prefix: "684",
    iso: "AS",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/as.svg",
    mask: "(684)___-____"
  },
  {
    name: "Andorra",
    code: "+376",
    prefix: null,
    iso: "AD",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ad.svg",
    mask: "___-___"
  },
  {
    name: "Angola",
    code: "+244",
    prefix: null,
    iso: "AO",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ao.svg",
    mask: "(___)___-___"
  },
  {
    name: "Anguilla",
    code: "+1",
    prefix: "264",
    iso: "AI",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ai.svg",
    mask: "(264)___-____"
  },
  {
    name: "Antarctica",
    code: "+672",
    prefix: "1",
    iso: "AQ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/aq.svg",
    mask: "1__-___"
  },
  {
    name: "Antigua and Barbuda",
    code: "+1",
    prefix: "268",
    iso: "AG",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ag.svg",
    mask: "(268)___-____"
  },
  {
    name: "Argentina",
    code: "+54",
    prefix: null,
    iso: "AR",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ar.svg",
    mask: "(___)___-____"
  },
  {
    name: "Armenia",
    code: "+374",
    prefix: null,
    iso: "AM",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/am.svg",
    mask: "__-___-___"
  },
  {
    name: "Aruba",
    code: "+297",
    prefix: null,
    iso: "AW",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/aw.svg",
    mask: "___-____"
  },
  {
    name: "Ascension Island",
    code: "+247",
    prefix: null,
    iso: "AC",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/sh.svg",
    mask: "____"
  },
  {
    name: "Australia",
    code: "+61",
    prefix: null,
    iso: "AU",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/au.svg",
    mask: "_-____-____"
  },
  {
    name: "Austria",
    code: "+43",
    prefix: null,
    iso: "AT",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/at.svg",
    mask: "(___)___-____"
  },
  {
    name: "Azerbaijan",
    code: "+994",
    prefix: null,
    iso: "AZ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/az.svg",
    mask: "__-___-__-__"
  },
  {
    name: "Bahamas",
    code: "+1",
    prefix: "242",
    iso: "BS",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/bs.svg",
    mask: "(242)___-____"
  },
  {
    name: "Bahrain",
    code: "+973",
    prefix: null,
    iso: "BH",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/bh.svg",
    mask: "____-____"
  },
  {
    name: "Bangladesh",
    code: "+880",
    prefix: "1",
    iso: "BD",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/bd.svg",
    mask: "1___-______"
  },
  {
    name: "Barbados",
    code: "+1",
    prefix: "246",
    iso: "BB",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/bb.svg",
    mask: "(246)___-____"
  },
  {
    name: "Belarus",
    code: "+375",
    prefix: null,
    iso: "BY",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/by.svg",
    mask: "(__)___-__-__"
  },
  {
    name: "Belgium",
    code: "+32",
    prefix: null,
    iso: "BE",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/be.svg",
    mask: "(___)___-___"
  },
  {
    name: "Belize",
    code: "+501",
    prefix: null,
    iso: "BZ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/bz.svg",
    mask: "___-____"
  },
  {
    name: "Benin",
    code: "+229",
    prefix: null,
    iso: "BJ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/bj.svg",
    mask: "__-__-____"
  },
  {
    name: "Bermuda",
    code: "+1",
    prefix: "441",
    iso: "BM",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/bm.svg",
    mask: "(441)___-____"
  },
  {
    name: "Bhutan",
    code: "+975",
    prefix: null,
    iso: "BT",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/bt.svg",
    mask: "_-___-___"
  },
  {
    name: "Bolivia",
    code: "+591",
    prefix: null,
    iso: "BO",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/bo.svg",
    mask: "_-___-____"
  },
  {
    name: "Bosnia and Herzegovina",
    code: "+387",
    prefix: null,
    iso: "BA",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ba.svg",
    mask: "__-_____"
  },
  {
    name: "Botswana",
    code: "+267",
    prefix: null,
    iso: "BW",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/bw.svg",
    mask: "__-___-___"
  },
  {
    name: "Brasil",
    code: "+55",
    prefix: null,
    iso: "BR",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/br.svg",
    mask: "(__) _____-____"
  },
  {
    name: "British Indian Ocean Territory",
    code: "+246",
    prefix: null,
    iso: "IO",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/io.svg",
    mask: "___-____"
  },
  {
    name: "Brunei Darussalam",
    code: "+673",
    prefix: null,
    iso: "BN",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/bn.svg",
    mask: "___-____"
  },
  {
    name: "Bulgaria",
    code: "+359",
    prefix: null,
    iso: "BG",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/bg.svg",
    mask: "(___)___-___"
  },
  {
    name: "Burkina Faso",
    code: "+226",
    prefix: null,
    iso: "BF",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/bf.svg",
    mask: "__-__-____"
  },
  {
    name: "Burundi",
    code: "+257",
    prefix: null,
    iso: "BI",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/bi.svg",
    mask: "__-__-____"
  },
  {
    name: "Cambodia",
    code: "+855",
    prefix: null,
    iso: "KH",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/kh.svg",
    mask: "__-___-___"
  },
  {
    name: "Cameroon",
    code: "+237",
    prefix: null,
    iso: "CM",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/cm.svg",
    mask: "____-____"
  },
  {
    name: "Canada",
    code: "+1",
    prefix: null,
    iso: "CA",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ca.svg",
    mask: "(___)___-____"
  },
  {
    name: "Cape Verde",
    code: "+238",
    prefix: null,
    iso: "CV",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/cv.svg",
    mask: "(___)__-__"
  },
  {
    name: "Cayman Islands",
    code: "+1",
    prefix: "345",
    iso: "KY",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ky.svg",
    mask: "(345)___-____"
  },
  {
    name: "Central African Republic",
    code: "+236",
    prefix: null,
    iso: "CF",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/cf.svg",
    mask: "__-__-____"
  },
  {
    name: "Chad",
    code: "+235",
    prefix: null,
    iso: "TD",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/td.svg",
    mask: "__-__-__-__"
  },
  {
    name: "Chile",
    code: "+56",
    prefix: null,
    iso: "CL",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/cl.svg",
    mask: "_-____-____"
  },
  {
    name: "China",
    code: "+86",
    prefix: null,
    iso: "CN",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/cn.svg",
    mask: "__-_____-_____"
  },
  {
    name: "Christmas Island",
    code: "+61",
    prefix: null,
    iso: "CX",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/cx.svg",
    mask: "_-____-____"
  },
  {
    name: "Cocos (Keeling) Islands",
    code: "+61",
    prefix: null,
    iso: "CC",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/cc.svg",
    mask: "_-____-____"
  },
  {
    name: "Colombia",
    code: "+57",
    prefix: null,
    iso: "CO",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/co.svg",
    mask: "(___)___-____"
  },
  {
    name: "Comoros",
    code: "+269",
    prefix: null,
    iso: "KM",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/km.svg",
    mask: "__-_____"
  },
  {
    name: "Congo",
    code: "+242",
    prefix: null,
    iso: "CG",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/cg.svg",
    mask: "__-_____"
  },
  {
    name: "Cook Islands",
    code: "+682",
    prefix: null,
    iso: "CK",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ck.svg",
    mask: "__-___"
  },
  {
    name: "Costa Rica",
    code: "+506",
    prefix: null,
    iso: "CR",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/cr.svg",
    mask: "____-____"
  },
  {
    name: "Croatia",
    code: "+385",
    prefix: null,
    iso: "HR",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/hr.svg",
    mask: "__-___-___"
  },
  {
    name: "Cuba",
    code: "+53",
    prefix: null,
    iso: "CU",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/cu.svg",
    mask: "_-___-____"
  },
  {
    name: "Cyprus",
    code: "+357",
    prefix: null,
    iso: "CY",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/cy.svg",
    mask: "__-___-___"
  },
  {
    name: "Czech Republic",
    code: "+420",
    prefix: null,
    iso: "CZ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/cz.svg",
    mask: "(___)___-___"
  },
  {
    name: "Democratic Republic of the Congo",
    code: "+243",
    prefix: null,
    iso: "CD",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/cd.svg",
    mask: "(___)___-___"
  },
  {
    name: "Denmark",
    code: "+45",
    prefix: null,
    iso: "DK",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/dk.svg",
    mask: "__-__-__-__"
  },
  {
    name: "Djibouti",
    code: "+253",
    prefix: null,
    iso: "DJ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/dj.svg",
    mask: "__-__-__-__"
  },
  {
    name: "Dominica",
    code: "+1",
    prefix: "767",
    iso: "DM",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/dm.svg",
    mask: "(767)___-____"
  },
  {
    name: "Dominican Republic",
    code: "+1",
    prefix: "849",
    iso: "DO",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/do.svg",
    mask: "(894)___-____"
  },
  {
    name: "Ecuador",
    code: "+593",
    prefix: null,
    iso: "EC",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ec.svg",
    mask: "__-___-____"
  },
  {
    name: "Egypt",
    code: "+20",
    prefix: null,
    iso: "EG",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/eg.svg",
    mask: "(___)___-____"
  },
  {
    name: "El Salvador",
    code: "+503",
    prefix: null,
    iso: "SV",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/sv.svg",
    mask: "__-__-____"
  },
  {
    name: "Equatorial Guinea",
    code: "+240",
    prefix: null,
    iso: "GQ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/gq.svg",
    mask: "__-___-____"
  },
  {
    name: "Eritrea",
    code: "+291",
    prefix: null,
    iso: "ER",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/er.svg",
    mask: "_-___-___"
  },
  {
    name: "Estonia",
    code: "+372",
    prefix: null,
    iso: "EE",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ee.svg",
    mask: "____-____"
  },
  {
    name: "Eswatini",
    code: "+268",
    prefix: null,
    iso: "SZ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/sz.svg",
    mask: "__-__-____"
  },
  {
    name: "Ethiopia",
    code: "+251",
    prefix: null,
    iso: "ET",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/et.svg",
    mask: "__-___-____"
  },
  {
    name: "Falkland Islands (Malvinas)",
    code: "+500",
    prefix: null,
    iso: "FK",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/fk.svg",
    mask: "_____"
  },
  {
    name: "Faroe Islands",
    code: "+298",
    prefix: null,
    iso: "FO",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/fo.svg",
    mask: "__ __ __"
  },
  {
    name: "Fiji",
    code: "+679",
    prefix: null,
    iso: "FJ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/fj.svg",
    mask: "__-_____"
  },
  {
    name: "Finland",
    code: "+358",
    prefix: null,
    iso: "FI",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/fi.svg",
    mask: "__ ___ ____"
  },
  {
    name: "France",
    code: "+33",
    prefix: null,
    iso: "FR",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/fr.svg",
    mask: "_ __ __ __ __"
  },
  {
    name: "French Guiana",
    code: "+594",
    prefix: null,
    iso: "GF",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/gf.svg",
    mask: "___ __ __ __"
  },
  {
    name: "French Polynesia",
    code: "+689",
    prefix: null,
    iso: "PF",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/pf.svg",
    mask: "__ __ __ __"
  },
  {
    name: "Gabon",
    code: "+241",
    prefix: null,
    iso: "GA",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ga.svg",
    mask: "_ __ __ __"
  },
  {
    name: "Gambia",
    code: "+220",
    prefix: null,
    iso: "GM",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/gm.svg",
    mask: "___ ____"
  },
  {
    name: "Georgia",
    code: "+995",
    prefix: null,
    iso: "GE",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ge.svg",
    mask: "(___)___-___"
  },
  {
    name: "Germany",
    code: "+49",
    prefix: "3",
    iso: "DE",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/de.svg",
    mask: "(3____) __-____"
  },
  {
    name: "Ghana",
    code: "+233",
    prefix: "03",
    iso: "GH",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/gh.svg",
    mask: "03_ ___ ____"
  },
  {
    name: "Gibraltar",
    code: "+350",
    prefix: null,
    iso: "GI",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/gi.svg",
    mask: "___-_____"
  },
  {
    name: "Greece",
    code: "+30",
    prefix: null,
    iso: "GR",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/gr.svg",
    mask: "(___)___-____"
  },
  {
    name: "Greenland",
    code: "+299",
    prefix: null,
    iso: "GL",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/gl.svg",
    mask: "__-__-__"
  },
  {
    name: "Grenada",
    code: "+1",
    prefix: "473",
    iso: "GD",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/gd.svg",
    mask: "(473)___-____"
  },
  {
    name: "Guadeloupe",
    code: "+590",
    prefix: null,
    iso: "GP",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/gp.svg",
    mask: "___ __ __ __"
  },
  {
    name: "Guam",
    code: "+1",
    prefix: "671",
    iso: "GU",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/gu.svg",
    mask: "671 ___ ____"
  },
  {
    name: "Guatemala",
    code: "+502",
    prefix: null,
    iso: "GT",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/gt.svg",
    mask: "_-___-____"
  },
  {
    name: "Guernsey",
    code: "+44",
    prefix: null,
    iso: "GG",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/gg.svg",
    mask: "(____)______"
  },
  {
    name: "Guinea",
    code: "+224",
    prefix: null,
    iso: "GN",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/gn.svg",
    mask: "__-___-___"
  },
  {
    name: "Guinea-Bissau",
    code: "+245",
    prefix: null,
    iso: "GW",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/gw.svg",
    mask: "_-______"
  },
  {
    name: "Guyana",
    code: "+592",
    prefix: null,
    iso: "GY",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/gy.svg",
    mask: "___-____"
  },
  {
    name: "Haiti",
    code: "+509",
    prefix: null,
    iso: "HT",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ht.svg",
    mask: "__-__-____"
  },
  {
    name: "Holy See (Vatican City State)",
    code: "+39",
    prefix: "06698",
    iso: "VA",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/va.svg",
    mask: "06 698_____"
  },
  {
    name: "Honduras",
    code: "+504",
    prefix: null,
    iso: "HN",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/hn.svg",
    mask: "____-____"
  },
  {
    name: "Hong Kong",
    code: "+852",
    prefix: null,
    iso: "HK",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/hk.svg",
    mask: "____-____"
  },
  {
    name: "Hungary",
    code: "+36",
    prefix: null,
    iso: "HU",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/hu.svg",
    mask: "__ ___ ____"
  },
  {
    name: "Iceland",
    code: "+354",
    prefix: null,
    iso: "IS",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/is.svg",
    mask: "___-____"
  },
  {
    name: "India",
    code: "+91",
    prefix: null,
    iso: "IN",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/in.svg",
    mask: "(____)___-___"
  },
  {
    name: "Indonesia",
    code: "+62",
    prefix: "8",
    iso: "ID",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/id.svg",
    mask: "(8__)___-__-___"
  },
  {
    name: "Iran",
    code: "+98",
    prefix: null,
    iso: "IR",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ir.svg",
    mask: "(___)___-____"
  },
  {
    name: "Iraq",
    code: "+964",
    prefix: null,
    iso: "IQ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/iq.svg",
    mask: "(___)___-____"
  },
  {
    name: "Ireland",
    code: "+353",
    prefix: null,
    iso: "IE",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ie.svg",
    mask: "(___)___-___"
  },
  {
    name: "Isle of Man",
    code: "+44",
    prefix: null,
    iso: "IM",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/im.svg",
    mask: "(____)______"
  },
  {
    name: "Israel",
    code: "+972",
    prefix: "5",
    iso: "IL",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/il.svg",
    mask: "__-___-____"
  },
  {
    name: "Italy",
    code: "+39",
    prefix: null,
    iso: "IT",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/it.svg",
    mask: "(___)____-___"
  },
  {
    name: "Ivory Coast / Cote d'Ivoire",
    code: "+225",
    prefix: null,
    iso: "CI",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ci.svg",
    mask: "__-___-___"
  },
  {
    name: "Jamaica",
    code: "+1",
    prefix: "876",
    iso: "JM",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/jm.svg",
    mask: "(876)___-____"
  },
  {
    name: "Japan",
    code: "+81",
    prefix: null,
    iso: "JP",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/jp.svg",
    mask: "__-____-____"
  },
  {
    name: "Jersey",
    code: "+44",
    prefix: null,
    iso: "JE",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/je.svg",
    mask: "(____)____-______"
  },
  {
    name: "Jordan",
    code: "+962",
    prefix: null,
    iso: "JO",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/jo.svg",
    mask: "_-____-____"
  },
  {
    name: "Kazakhstan",
    code: "+77",
    prefix: null,
    iso: "KZ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/kz.svg",
    mask: "(_____) _ __ __"
  },
  {
    name: "Kenya",
    code: "+254",
    prefix: null,
    iso: "KE",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ke.svg",
    mask: "___-______"
  },
  {
    name: "Kiribati",
    code: "+686",
    prefix: null,
    iso: "KI",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ki.svg",
    mask: "__-___"
  },
  {
    name: "Korea, Democratic People's Republic of Korea",
    code: "+850",
    prefix: null,
    iso: "KP",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/kp.svg",
    mask: "____-_____________"
  },
  {
    name: "Korea, Republic of South Korea",
    code: "+82",
    prefix: null,
    iso: "KR",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/kr.svg",
    mask: "__-___-____"
  },
  {
    name: "Kosovo",
    code: "+383",
    prefix: null,
    iso: "XK",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/xk.svg",
    mask: "___-___-___"
  },
  {
    name: "Kuwait",
    code: "+965",
    prefix: null,
    iso: "KW",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/kw.svg",
    mask: "____-____"
  },
  {
    name: "Kyrgyzstan",
    code: "+996",
    prefix: null,
    iso: "KG",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/kg.svg",
    mask: "(___)___-___"
  },
  {
    name: "Laos",
    code: "+856",
    prefix: "20",
    iso: "LA",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/la.svg",
    mask: "(20__)___-___"
  },
  {
    name: "Latvia",
    code: "+371",
    prefix: null,
    iso: "LV",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/lv.svg",
    mask: "__-___-___"
  },
  {
    name: "Lebanon",
    code: "+961",
    prefix: null,
    iso: "LB",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/lb.svg",
    mask: "__-___-___"
  },
  {
    name: "Lesotho",
    code: "+266",
    prefix: null,
    iso: "LS",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ls.svg",
    mask: "_-___-____"
  },
  {
    name: "Liberia",
    code: "+231",
    prefix: null,
    iso: "LR",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/lr.svg",
    mask: "__-___-___"
  },
  {
    name: "Libya",
    code: "+218",
    prefix: "21",
    iso: "LY",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ly.svg",
    mask: "21-___-____"
  },
  {
    name: "Liechtenstein",
    code: "+423",
    prefix: null,
    iso: "LI",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/li.svg",
    mask: "(___)___-____"
  },
  {
    name: "Lithuania",
    code: "+370",
    prefix: null,
    iso: "LT",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/lt.svg",
    mask: "(___)__-___"
  },
  {
    name: "Luxembourg",
    code: "+352",
    prefix: null,
    iso: "LU",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/lu.svg",
    mask: "(___)___-___"
  },
  {
    name: "Macau",
    code: "+853",
    prefix: null,
    iso: "MO",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/mo.svg",
    mask: "____-____"
  },
  {
    name: "Madagascar",
    code: "+261",
    prefix: null,
    iso: "MG",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/mg.svg",
    mask: "__-__-_____"
  },
  {
    name: "Malawi",
    code: "+265",
    prefix: null,
    iso: "MW",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/mw.svg",
    mask: "_-____-____"
  },
  {
    name: "Malaysia",
    code: "+60",
    prefix: null,
    iso: "MY",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/my.svg",
    mask: "__-___-____"
  },
  {
    name: "Maldives",
    code: "+960",
    prefix: null,
    iso: "MV",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/mv.svg",
    mask: "___-____"
  },
  {
    name: "Mali",
    code: "+223",
    prefix: null,
    iso: "ML",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ml.svg",
    mask: "__-__-____"
  },
  {
    name: "Malta",
    code: "+356",
    prefix: null,
    iso: "MT",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/mt.svg",
    mask: "____-____"
  },
  {
    name: "Marshall Islands",
    code: "+692",
    prefix: null,
    iso: "MH",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/mh.svg",
    mask: "___-____"
  },
  {
    name: "Martinique",
    code: "+596",
    prefix: null,
    iso: "MQ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/mq.svg",
    mask: "(___)__-__-__"
  },
  {
    name: "Mauritania",
    code: "+222",
    prefix: null,
    iso: "MR",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/mr.svg",
    mask: "__-__-____"
  },
  {
    name: "Mauritius",
    code: "+230",
    prefix: null,
    iso: "MU",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/mu.svg",
    mask: "___-____"
  },
  {
    name: "Mayotte",
    code: "+262",
    prefix: null,
    iso: "YT",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/yt.svg",
    mask: "_____-____"
  },
  {
    name: "Mexico",
    code: "+52",
    prefix: null,
    iso: "MX",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/mx.svg",
    mask: "(___)___-____"
  },
  {
    name: "Micronesia, Federated States of Micronesia",
    code: "+691",
    prefix: null,
    iso: "FM",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/fm.svg",
    mask: "___-____"
  },
  {
    name: "Moldova",
    code: "+373",
    prefix: null,
    iso: "MD",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/md.svg",
    mask: "____-____"
  },
  {
    name: "Monaco",
    code: "+377",
    prefix: null,
    iso: "MC",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/mc.svg",
    mask: "(___)___-___"
  },
  {
    name: "Mongolia",
    code: "+976",
    prefix: null,
    iso: "MN",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/mn.svg",
    mask: "__-__-____"
  },
  {
    name: "Montenegro",
    code: "+382",
    prefix: null,
    iso: "ME",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/me.svg",
    mask: "__-___-___"
  },
  {
    name: "Montserrat",
    code: "+1",
    prefix: "664",
    iso: "MS",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ms.svg",
    mask: "(664)___-____"
  },
  {
    name: "Morocco",
    code: "+212",
    prefix: null,
    iso: "MA",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ma.svg",
    mask: "__-____-___"
  },
  {
    name: "Mozambique",
    code: "+258",
    prefix: null,
    iso: "MZ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/mz.svg",
    mask: "__-___-___"
  },
  {
    name: "Myanmar",
    code: "+95",
    prefix: null,
    iso: "MM",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/mm.svg",
    mask: "__-___-___"
  },
  {
    name: "Namibia",
    code: "+264",
    prefix: null,
    iso: "NA",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/na.svg",
    mask: "__-___-____"
  },
  {
    name: "Nauru",
    code: "+674",
    prefix: null,
    iso: "NR",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/nr.svg",
    mask: "___-____"
  },
  {
    name: "Nepal",
    code: "+977",
    prefix: null,
    iso: "NP",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/np.svg",
    mask: "__-___-___"
  },
  {
    name: "Netherlands",
    code: "+31",
    prefix: null,
    iso: "NL",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/nl.svg",
    mask: "__-___-____"
  },
  {
    name: "New Caledonia",
    code: "+687",
    prefix: null,
    iso: "NC",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/nc.svg",
    mask: "__-____"
  },
  {
    name: "New Zealand",
    code: "+64",
    prefix: null,
    iso: "NZ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/nz.svg",
    mask: "(___)___-____"
  },
  {
    name: "Nicaragua",
    code: "+505",
    prefix: null,
    iso: "NI",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ni.svg",
    mask: "____-____"
  },
  {
    name: "Niger",
    code: "+227",
    prefix: null,
    iso: "NE",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ne.svg",
    mask: "__-__-____"
  },
  {
    name: "Nigeria",
    code: "+234",
    prefix: null,
    iso: "NG",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ng.svg",
    mask: "(___)___-____"
  },
  {
    name: "Niue",
    code: "+683",
    prefix: null,
    iso: "NU",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/nu.svg",
    mask: "____"
  },
  {
    name: "Norfolk Island",
    code: "+672",
    prefix: "3",
    iso: "NF",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/nf.svg",
    mask: "3__-___"
  },
  {
    name: "North Macedonia",
    code: "+389",
    prefix: null,
    iso: "MK",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/mk.svg",
    mask: "__-___-___"
  },
  {
    name: "Northern Mariana Islands",
    code: "+1",
    prefix: "670",
    iso: "MP",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/mp.svg",
    mask: "(670)___-____"
  },
  {
    name: "Norway",
    code: "+47",
    prefix: null,
    iso: "NO",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/no.svg",
    mask: "(___)__-___"
  },
  {
    name: "Oman",
    code: "+968",
    prefix: null,
    iso: "OM",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/om.svg",
    mask: "__-___-___"
  },
  {
    name: "Pakistan",
    code: "+92",
    prefix: null,
    iso: "PK",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/pk.svg",
    mask: "(___)___-____"
  },
  {
    name: "Palau",
    code: "+680",
    prefix: null,
    iso: "PW",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/pw.svg",
    mask: "___-____"
  },
  {
    name: "Palestine",
    code: "+970",
    prefix: null,
    iso: "PS",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ps.svg",
    mask: "__-___-____"
  },
  {
    name: "Panama",
    code: "+507",
    prefix: null,
    iso: "PA",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/pa.svg",
    mask: "___-____"
  },
  {
    name: "Papua New Guinea",
    code: "+675",
    prefix: null,
    iso: "PG",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/pg.svg",
    mask: "(___)__-___"
  },
  {
    name: "Paraguay",
    code: "+595",
    prefix: null,
    iso: "PY",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/py.svg",
    mask: "(___)___-___"
  },
  {
    name: "Peru",
    code: "+51",
    prefix: null,
    iso: "PE",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/pe.svg",
    mask: "(___)___-___"
  },
  {
    name: "Philippines",
    code: "+63",
    prefix: null,
    iso: "PH",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ph.svg",
    mask: "(___)___-____"
  },
  {
    name: "Pitcairn",
    code: "+870",
    prefix: null,
    iso: "PN",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/pn.svg",
    mask: "___-___-___"
  },
  {
    name: "Poland",
    code: "+48",
    prefix: null,
    iso: "PL",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/pl.svg",
    mask: "(___)___-___"
  },
  {
    name: "Portugal",
    code: "+351",
    prefix: null,
    iso: "PT",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/pt.svg",
    mask: "__-___-____"
  },
  {
    name: "Puerto Rico",
    code: "+1",
    prefix: null,
    iso: "PR",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/pr.svg",
    mask: "(___) ___ ____"
  },
  {
    name: "Qatar",
    code: "+974",
    prefix: null,
    iso: "QA",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/qa.svg",
    mask: "____-____"
  },
  {
    name: "Reunion",
    code: "+262",
    prefix: null,
    iso: "RE",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/re.svg",
    mask: "_____-____"
  },
  {
    name: "Romania",
    code: "+40",
    prefix: null,
    iso: "RO",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ro.svg",
    mask: "__-___-____"
  },
  {
    name: "Russia",
    code: "+7",
    prefix: null,
    iso: "RU",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ru.svg",
    mask: "(___)___-__-__"
  },
  {
    name: "Rwanda",
    code: "+250",
    prefix: null,
    iso: "RW",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/rw.svg",
    mask: "(___)___-___"
  },
  {
    name: "Saint Barthelemy",
    code: "+590",
    prefix: null,
    iso: "BL",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/bl.svg",
    mask: "___-__-__-__"
  },
  {
    name: "Saint Helena, Ascension and Tristan Da Cunha",
    code: "+290",
    prefix: null,
    iso: "SH",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/sh.svg",
    mask: "____"
  },
  {
    name: "Saint Kitts and Nevis",
    code: "+1",
    prefix: null,
    iso: "KN",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/kn.svg",
    mask: "(869)___-____"
  },
  {
    name: "Saint Lucia",
    code: "+1",
    prefix: "758",
    iso: "LC",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/lc.svg",
    mask: "(758)___-____"
  },
  {
    name: "Saint Martin",
    code: "+590",
    prefix: null,
    iso: "MF",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/mf.svg",
    mask: "(___)___-___"
  },
  {
    name: "Saint Pierre and Miquelon",
    code: "+508",
    prefix: null,
    iso: "PM",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/pm.svg",
    mask: "__-____"
  },
  {
    name: "Saint Vincent and the Grenadines",
    code: "+1",
    prefix: "784",
    iso: "VC",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/vc.svg",
    mask: "(784)___-____"
  },
  {
    name: "Samoa",
    code: "+685",
    prefix: null,
    iso: "WS",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ws.svg",
    mask: "__-____"
  },
  {
    name: "San Marino",
    code: "+378",
    prefix: null,
    iso: "SM",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/sm.svg",
    mask: "____-______"
  },
  {
    name: "Sao Tome and Principe",
    code: "+239",
    prefix: null,
    iso: "ST",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/st.svg",
    mask: "__-_____"
  },
  {
    name: "Saudi Arabia",
    code: "+966",
    prefix: null,
    iso: "SA",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/sa.svg",
    mask: "_-____-____"
  },
  {
    name: "Senegal",
    code: "+221",
    prefix: null,
    iso: "SN",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/sn.svg",
    mask: "__-___-____"
  },
  {
    name: "Serbia",
    code: "+381",
    prefix: null,
    iso: "RS",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/rs.svg",
    mask: "__-___-____"
  },
  {
    name: "Seychelles",
    code: "+248",
    prefix: null,
    iso: "SC",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/sc.svg",
    mask: "_-___-___"
  },
  {
    name: "Sierra Leone",
    code: "+232",
    prefix: null,
    iso: "SL",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/sl.svg",
    mask: "__-______"
  },
  {
    name: "Singapore",
    code: "+65",
    prefix: null,
    iso: "SG",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/sg.svg",
    mask: "____-____"
  },
  {
    name: "Sint Maarten",
    code: "+1",
    prefix: "721",
    iso: "SX",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/sx.svg",
    mask: "(721)___-____"
  },
  {
    name: "Slovakia",
    code: "+421",
    prefix: null,
    iso: "SK",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/sk.svg",
    mask: "(___)___-___"
  },
  {
    name: "Slovenia",
    code: "+386",
    prefix: null,
    iso: "SI",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/si.svg",
    mask: "__-___-___"
  },
  {
    name: "Solomon Islands",
    code: "+677",
    prefix: null,
    iso: "SB",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/sb.svg",
    mask: "___-____"
  },
  {
    name: "Somalia",
    code: "+252",
    prefix: null,
    iso: "SO",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/so.svg",
    mask: "__-___-___"
  },
  {
    name: "South Africa",
    code: "+27",
    prefix: null,
    iso: "ZA",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/za.svg",
    mask: "__-___-____"
  },
  {
    name: "South Georgia and the South Sandwich Islands",
    code: "+500",
    prefix: null,
    iso: "GS",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/gs.svg",
    mask: "_____"
  },
  {
    name: "South Sudan",
    code: "+211",
    prefix: null,
    iso: "SS",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ss.svg",
    mask: "__-___-____"
  },
  {
    name: "Spain",
    code: "+34",
    prefix: null,
    iso: "ES",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/es.svg",
    mask: "(___)___-___"
  },
  {
    name: "Sri Lanka",
    code: "+94",
    prefix: null,
    iso: "LK",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/lk.svg",
    mask: "__-___-____"
  },
  {
    name: "Sudan",
    code: "+249",
    prefix: null,
    iso: "SD",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/sd.svg",
    mask: "__-___-____"
  },
  {
    name: "Suriname",
    code: "+597",
    prefix: null,
    iso: "SR",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/sr.svg",
    mask: "___-____"
  },
  {
    name: "Svalbard and Jan Mayen",
    code: "+47",
    prefix: null,
    iso: "SJ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/sj.svg",
    mask: "(___)__-___"
  },
  {
    name: "Sweden",
    code: "+46",
    prefix: null,
    iso: "SE",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/se.svg",
    mask: "__-___-____"
  },
  {
    name: "Switzerland",
    code: "+41",
    prefix: null,
    iso: "CH",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ch.svg",
    mask: "__-___-____"
  },
  {
    name: "Syrian Arab Republic",
    code: "+963",
    prefix: null,
    iso: "SY",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/sy.svg",
    mask: "__-____-___"
  },
  {
    name: "Taiwan",
    code: "+886",
    prefix: null,
    iso: "TW",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/tw.svg",
    mask: "_-____-____"
  },
  {
    name: "Tajikistan",
    code: "+992",
    prefix: null,
    iso: "TJ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/tj.svg",
    mask: "__-___-____"
  },
  {
    name: "United Republic of Tanzania",
    code: "+255",
    prefix: null,
    iso: "TZ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/tz.svg",
    mask: "__-___-____"
  },
  {
    name: "Thailand",
    code: "+66",
    prefix: null,
    iso: "TH",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/th.svg",
    mask: "__-___-____"
  },
  {
    name: "Timor-Leste",
    code: "+670",
    prefix: null,
    iso: "TL",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/tl.svg",
    mask: "___-_____"
  },
  {
    name: "Togo",
    code: "+228",
    prefix: null,
    iso: "TG",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/tg.svg",
    mask: "__-___-___"
  },
  {
    name: "Tokelau",
    code: "+690",
    prefix: null,
    iso: "TK",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/tk.svg",
    mask: "____"
  },
  {
    name: "Tonga",
    code: "+676",
    prefix: null,
    iso: "TO",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/to.svg",
    mask: "_____"
  },
  {
    name: "Trinidad and Tobago",
    code: "+1",
    prefix: "868",
    iso: "TT",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/tt.svg",
    mask: "(868)___-____"
  },
  {
    name: "Tunisia",
    code: "+216",
    prefix: null,
    iso: "TN",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/tn.svg",
    mask: "__-___-___"
  },
  {
    name: "Turkey",
    code: "+90",
    prefix: null,
    iso: "TR",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/tr.svg",
    mask: "(___)___-____"
  },
  {
    name: "Turkmenistan",
    code: "+993",
    prefix: null,
    iso: "TM",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/tm.svg",
    mask: "_-___-____"
  },
  {
    name: "Turks and Caicos Islands",
    code: "+1",
    prefix: "249",
    iso: "TC",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/tc.svg",
    mask: "(249)___-___"
  },
  {
    name: "Tuvalu",
    code: "+688",
    prefix: null,
    iso: "TV",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/tv.svg",
    mask: "______"
  },
  {
    name: "Uganda",
    code: "+256",
    prefix: null,
    iso: "UG",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ug.svg",
    mask: "(___)___-___"
  },
  {
    name: "Ukraine",
    code: "+380",
    prefix: null,
    iso: "UA",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ua.svg",
    mask: "(__)___-__-__"
  },
  {
    name: "United Arab Emirates",
    code: "+971",
    prefix: null,
    iso: "AE",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ae.svg",
    mask: "_-___-____"
  },
  {
    name: "United Kingdom",
    code: "+44",
    prefix: null,
    iso: "GB",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/gb.svg",
    mask: "__-____-____"
  },
  {
    name: "United States",
    code: "+1",
    prefix: "408",
    iso: "US",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/us.svg",
    mask: "(408)___-____"
  },
  {
    name: "Uruguay",
    code: "+598",
    prefix: null,
    iso: "UY",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/uy.svg",
    mask: "_-___-__-__"
  },
  {
    name: "Uzbekistan",
    code: "+998",
    prefix: null,
    iso: "UZ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/uz.svg",
    mask: "__-___-____"
  },
  {
    name: "Vanuatu",
    code: "+678",
    prefix: null,
    iso: "VU",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/vu.svg",
    mask: "__-_____"
  },
  {
    name: "Venezuela, Bolivarian Republic of Venezuela",
    code: "+58",
    prefix: null,
    iso: "VE",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ve.svg",
    mask: "(___)___-____"
  },
  {
    name: "Vietnam",
    code: "+84",
    prefix: null,
    iso: "VN",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/vn.svg",
    mask: "(___)____-___"
  },
  {
    name: "Virgin Islands, British",
    code: "+1",
    prefix: "284",
    iso: "VG",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/vg.svg",
    mask: "(284)___-____"
  },
  {
    name: "Virgin Islands, U.S.",
    code: "+1",
    prefix: "340",
    iso: "VI",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/vi.svg",
    mask: "(340)___-____"
  },
  {
    name: "Wallis and Futuna",
    code: "+681",
    prefix: null,
    iso: "WF",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/wf.svg",
    mask: "__-____"
  },
  {
    name: "Yemen",
    code: "+967",
    prefix: null,
    iso: "YE",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ye.svg",
    mask: "___-___-___"
  },
  {
    name: "Zambia",
    code: "+260",
    prefix: null,
    iso: "ZM",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/zm.svg",
    mask: "__-___-____"
  },
  {
    name: "Zimbabwe",
    code: "+263",
    prefix: null,
    iso: "ZW",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/zw.svg",
    mask: "_-______"
  }
];
function DHe(e) {
  const {
    children: t,
    onFocus: n,
    disabled: r,
    isError: o,
    isLoading: i,
    isFocused: a,
    className: s = "",
    readOnly: l,
    variant: u,
    size: c,
    id: p
  } = e, m = `arkynPhoneInputContainer ${u} ${c} ${r || l || i ? "opacity" : ""} ${o ? "errored" : ""} ${a ? "focused" : ""} ${s}`;
  return /* @__PURE__ */ Q.jsx("section", { id: p, className: m.trim(), onClick: n, children: t });
}
function THe(e) {
  const { isOpen: t, onClick: n } = e;
  return t ? /* @__PURE__ */ Q.jsx("aside", { className: "arkynPhoneInputCountriesOverlay", onClick: n }) : /* @__PURE__ */ Q.jsx(Q.Fragment, {});
}
function jHe(e) {
  const { country: t, isActive: n, handleChangeValue: r, size: o } = e, a = `arkynPhoneInputCountryOption ${o} ${n ? "active" : ""}`;
  return /* @__PURE__ */ Q.jsxs("div", { onClick: () => r(t), className: a, children: [
    /* @__PURE__ */ Q.jsx("img", { src: t.flag, alt: t.name, className: "flag" }),
    t.name,
    " ",
    /* @__PURE__ */ Q.jsx("span", { children: t.code }),
    /* @__PURE__ */ Q.jsx(Zy, { className: "check" })
  ] });
}
function AHe(e) {
  const { children: t, isOpen: n, onSearch: r, search: o, placeholder: i } = e;
  function a(s) {
    r(s.target.value);
  }
  return n ? /* @__PURE__ */ Q.jsxs("div", { className: "arkynPhoneInputCountryOptionsContainer", children: [
    /* @__PURE__ */ Q.jsx(
      "input",
      {
        type: "search",
        name: "search-select",
        className: "arkynPhoneInputCountryOptionsContainerSearchSelect",
        value: o,
        id: "input-search",
        placeholder: i,
        onChange: a
      }
    ),
    t
  ] }) : /* @__PURE__ */ Q.jsx(Q.Fragment, {});
}
function IHe(e) {
  const { currentCountry: t, onClick: n } = e;
  return /* @__PURE__ */ Q.jsxs("div", { className: "phoneInputSelectCountry", onClick: n, children: [
    /* @__PURE__ */ Q.jsx(
      "img",
      {
        className: "flag",
        src: t.flag,
        alt: t.name
      }
    ),
    /* @__PURE__ */ Q.jsx(O1, { className: "chevronDown", strokeWidth: 2.5 }),
    /* @__PURE__ */ Q.jsx(x8, { orientation: "vertical" })
  ] });
}
function hS(e) {
  return e && e.replace(/[^0-9]/g, "");
}
const gS = {
  EIGTH: "(99) 9999-9999",
  NINE: "(99) 99999-9999"
};
function QY(e, t) {
  let n = "", r = 0;
  for (let o = 0; o < t.length; o++)
    if (t[o] === "9")
      if (r < e.length)
        n += e[r], r++;
      else
        break;
    else if (r < e.length)
      n += t[o];
    else
      break;
  return n;
}
function eX(e) {
  return e.length > 10 ? "NINE" : "EIGTH";
}
const tX = hS(gS.NINE).length, RHe = to((e, t) => /* @__PURE__ */ Q.jsx("input", { ref: t, ...e })), BHe = to(
  (e, t) => {
    const { onFocus: n, onBlur: r, size: o, onChange: i, value: a, currentCountry: s, disabled: l } = e, [u, c] = k(!1);
    h(() => {
      u ? i(s.mask) : c(!0);
    }, [s]);
    const p = `phoneInputMask ${o}`;
    function d(g) {
      let f = hS(g.target.value);
      const m = eX(f);
      f.length > tX || (f = QY(f, gS[m]), g.target.value = f, i(f));
    }
    return s.code === "+55" ? /* @__PURE__ */ Q.jsx(
      "input",
      {
        value: a,
        onChange: d,
        className: p,
        onFocus: n,
        onBlur: r,
        disabled: l,
        ref: t
      }
    ) : /* @__PURE__ */ Q.jsx(
      cl,
      {
        value: a,
        onChange: (g) => i(g.target.value),
        className: p,
        component: RHe,
        onFocus: n,
        onBlur: r,
        disabled: l,
        mask: s.mask,
        showMask: !0,
        replacement: { _: /\d/ },
        ref: t
      }
    );
  }
);
function QW(e, t) {
  if (t.code === "+55") {
    let o = hS(e);
    const i = eX(o);
    return o.length > tX ? void 0 : (o = QY(o, gS[i]), o);
  }
  let r = t.mask;
  if (t.prefix) {
    const o = /\$+/g;
    r = r.replace(o, t.prefix);
  }
  for (let o = 0, i = 0; o < r.length && i < e.length; o++)
    r[o] === "_" && (r = r.substring(0, o) + e[i] + r.substring(o + 1), i++);
  return r;
}
function NHe(e, t) {
  const n = tc.find(
    (r) => r.code === e && r.prefix === t
  );
  return n || null;
}
function FHe(e) {
  const t = tc.find((n) => n.code === e);
  return t || null;
}
function zHe(e) {
  const t = e.split(" ")[0].split("-")[0], n = e.split(" ")[0].split("-")[1], r = e.split(" ")[1];
  if (!t || !r)
    return { country: null, formattedNumber: "" };
  if (n) {
    const s = NHe(t, n);
    if (!s) return { country: null, formattedNumber: "" };
    const l = QW(r, s);
    return { country: s, formattedNumber: l };
  }
  const o = FHe(t);
  if (!o) return { country: null, formattedNumber: "" };
  const i = QW(r, o);
  return { country: o, formattedNumber: i };
}
function D4e(e) {
  const {
    defaultCountry: t,
    className: n = "",
    disabled: r = !1,
    isError: o = !1,
    isLoading: i = !1,
    readOnly: a = !1,
    size: s = "md",
    defaultValue: l = "",
    variant: u = "solid",
    name: c,
    onChange: p,
    searchCountryPlaceholder: d = "Pesquisar pas",
    notFoundCountryText: g = "Nenhum pas encontrado",
    ...f
  } = e, m = zHe(l), [v, E] = k(!1), [w, M] = k(""), [O, y] = k(!1), [C, _] = k(m.formattedNumber || ""), [F, L] = k(() => {
    if (m.country) return m.country;
    const S = tc.find(($) => $.iso === t);
    return S || tc[30];
  }), { id: N, inputRef: R, error: W } = ni(), V = o || !!W, z = ut(null);
  function Z() {
    v || O || (E(!0), z.current && z.current.focus());
  }
  function K() {
    y(!0), E(!0);
  }
  function X() {
    y(!1), E(!1);
  }
  function te() {
    E(!0);
  }
  function J() {
    E(!1);
  }
  function P(S) {
    return S.name.toLowerCase().includes(w.toLowerCase());
  }
  function D(S) {
    return F.prefix ? S.replace(F.prefix, "").replaceAll(" ", "").replaceAll("-", "").replaceAll("(", "").replaceAll(")", "").trim() : S.replaceAll(" ", "").replaceAll("-", "").replaceAll("(", "").replaceAll(")", "").trim();
  }
  function H(S) {
    let $ = F.code;
    return F.prefix && ($ += `-${F.prefix}`), $ += " ", $ += D(S || C), $;
  }
  return /* @__PURE__ */ Q.jsxs(
    DHe,
    {
      id: N,
      disabled: r,
      isError: V,
      isLoading: i,
      isFocused: v,
      readOnly: a,
      size: s,
      variant: u,
      className: n,
      onFocus: Z,
      children: [
        /* @__PURE__ */ Q.jsx(
          IHe,
          {
            currentCountry: F,
            onClick: K,
            size: s
          }
        ),
        /* @__PURE__ */ Q.jsxs(
          AHe,
          {
            isOpen: O,
            search: w,
            placeholder: d,
            onSearch: M,
            children: [
              tc.filter((S) => P(S)).map((S) => /* @__PURE__ */ Q.jsx(
                jHe,
                {
                  country: S,
                  handleChangeValue: () => {
                    L(S), y(!1), _(S.mask);
                  },
                  isActive: S.iso === F.iso,
                  size: s
                },
                S.iso
              )),
              tc.filter((S) => P(S)).length === 0 && /* @__PURE__ */ Q.jsx("p", { children: g })
            ]
          }
        ),
        /* @__PURE__ */ Q.jsx(
          THe,
          {
            isOpen: O,
            onClick: X
          }
        ),
        /* @__PURE__ */ Q.jsx(
          BHe,
          {
            ref: z,
            currentCountry: F,
            value: C,
            onChange: (S) => {
              _(S), p && p(H(S));
            },
            disabled: r,
            onBlur: J,
            onFocus: te,
            size: s
          }
        ),
        /* @__PURE__ */ Q.jsx("input", { ref: R, type: "hidden", name: c, value: H() })
      ]
    }
  );
}
const nX = Ke({});
function UHe() {
  return ge(nX);
}
function T4e(e) {
  const {
    defaultValue: t,
    name: n,
    value: r,
    onChange: o,
    size: i = "md",
    className: a = "",
    ...s
  } = e, [l, u] = k(t || ""), { inputRef: c, id: p } = ni();
  function d(f) {
    u(f), o && o(f);
  }
  const g = `arkynRadioGroup ${i} ${a}`;
  return /* @__PURE__ */ Q.jsxs(
    nX.Provider,
    {
      value: { onChange: d, value: r || l, size: i },
      children: [
        /* @__PURE__ */ Q.jsx(
          "input",
          {
            style: { display: "none" },
            type: "text",
            id: p,
            readOnly: !0,
            name: n,
            ref: c,
            value: r || l
          }
        ),
        /* @__PURE__ */ Q.jsx("div", { className: g.trim(), ...s })
      ]
    }
  );
}
function j4e(e) {
  const {
    value: t,
    size: n,
    disabled: r,
    children: o,
    className: i = "",
    ...a
  } = e, { onChange: s, size: l, value: u } = UHe(), { error: c } = ni(), m = `arkynRadioBox ${n || l} ${u === t ? "checkedTrue" : "checkedFalse"} ${c ? "errorTrue" : "errorFalse"} ${r ? "disabledTrue" : "disabledFalse"} ${i}`;
  return /* @__PURE__ */ Q.jsxs("label", { className: m.trim(), children: [
    /* @__PURE__ */ Q.jsx(
      "button",
      {
        type: "button",
        disabled: r,
        onClick: () => s(t),
        onFocus: () => s(t),
        ...a
      }
    ),
    o
  ] });
}
var Ca = {};
Object.defineProperty(Ca, "__esModule", {
  value: !0
});
var HHe = typeof window < "u" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform), CO = {
  alt: "altKey",
  control: "ctrlKey",
  meta: "metaKey",
  shift: "shiftKey"
}, rX = {
  add: "+",
  break: "pause",
  cmd: "meta",
  command: "meta",
  ctl: "control",
  ctrl: "control",
  del: "delete",
  down: "arrowdown",
  esc: "escape",
  ins: "insert",
  left: "arrowleft",
  mod: HHe ? "meta" : "control",
  opt: "alt",
  option: "alt",
  return: "enter",
  right: "arrowright",
  space: " ",
  spacebar: " ",
  up: "arrowup",
  win: "meta",
  windows: "meta"
}, mS = {
  backspace: 8,
  tab: 9,
  enter: 13,
  shift: 16,
  control: 17,
  alt: 18,
  pause: 19,
  capslock: 20,
  escape: 27,
  " ": 32,
  pageup: 33,
  pagedown: 34,
  end: 35,
  home: 36,
  arrowleft: 37,
  arrowup: 38,
  arrowright: 39,
  arrowdown: 40,
  insert: 45,
  delete: 46,
  meta: 91,
  numlock: 144,
  scrolllock: 145,
  ";": 186,
  "=": 187,
  ",": 188,
  "-": 189,
  ".": 190,
  "/": 191,
  "`": 192,
  "[": 219,
  "\\": 220,
  "]": 221,
  "'": 222
};
for (var lm = 1; lm < 20; lm++)
  mS["f" + lm] = 111 + lm;
function y0(e, t, n) {
  t && !("byKey" in t) && (n = t, t = null), Array.isArray(e) || (e = [e]);
  var r = e.map(function(a) {
    return oX(a, t);
  }), o = function(s) {
    return r.some(function(l) {
      return iX(l, s);
    });
  }, i = n == null ? o : o(n);
  return i;
}
function $He(e, t) {
  return y0(e, t);
}
function WHe(e, t) {
  return y0(e, { byKey: !0 }, t);
}
function oX(e, t) {
  var n = t && t.byKey, r = {};
  e = e.replace("++", "+add");
  var o = e.split("+"), i = o.length;
  for (var a in CO)
    r[CO[a]] = !1;
  var s = !0, l = !1, u = void 0;
  try {
    for (var c = o[Symbol.iterator](), p; !(s = (p = c.next()).done); s = !0) {
      var d = p.value, g = d.endsWith("?") && d.length > 1;
      g && (d = d.slice(0, -1));
      var f = vS(d), m = CO[f];
      if (d.length > 1 && !m && !rX[d] && !mS[f])
        throw new TypeError('Unknown modifier: "' + d + '"');
      (i === 1 || !m) && (n ? r.key = f : r.which = sX(d)), m && (r[m] = g ? null : !0);
    }
  } catch (v) {
    l = !0, u = v;
  } finally {
    try {
      !s && c.return && c.return();
    } finally {
      if (l)
        throw u;
    }
  }
  return r;
}
function iX(e, t) {
  for (var n in e) {
    var r = e[n], o = void 0;
    if (r != null && (n === "key" && t.key != null ? o = t.key.toLowerCase() : n === "which" ? o = r === 91 && t.which === 93 ? 91 : t.which : o = t[n], !(o == null && r === !1) && o !== r))
      return !1;
  }
  return !0;
}
function sX(e) {
  e = vS(e);
  var t = mS[e] || e.toUpperCase().charCodeAt(0);
  return t;
}
function vS(e) {
  return e = e.toLowerCase(), e = rX[e] || e, e;
}
var VHe = Ca.default = y0, xO = Ca.isHotkey = y0;
Ca.isCodeHotkey = $He;
Ca.isKeyHotkey = WHe;
Ca.parseHotkey = oX;
Ca.compareHotkey = iX;
Ca.toKeyCode = sX;
Ca.toKeyName = vS;
var ZHe = {
  /**
   * Check if a value is a `History` object.
   */
  isHistory(e) {
    return Lo(e) && Array.isArray(e.redos) && Array.isArray(e.undos) && (e.redos.length === 0 || sl.isOperationList(e.redos[0].operations)) && (e.undos.length === 0 || sl.isOperationList(e.undos[0].operations));
  }
}, OO = /* @__PURE__ */ new WeakMap(), Cp = /* @__PURE__ */ new WeakMap(), mu = {
  /**
   * Check if a value is a `HistoryEditor` object.
   */
  isHistoryEditor(e) {
    return ZHe.isHistory(e.history) && ee.isEditor(e);
  },
  /**
   * Get the merge flag's current value.
   */
  isMerging(e) {
    return Cp.get(e);
  },
  /**
   * Get the saving flag's current value.
   */
  isSaving(e) {
    return OO.get(e);
  },
  /**
   * Redo to the previous saved state.
   */
  redo(e) {
    e.redo();
  },
  /**
   * Undo to the previous saved state.
   */
  undo(e) {
    e.undo();
  },
  /**
   * Apply a series of changes inside a synchronous `fn`, These operations will
   * be merged into the previous history.
   */
  withMerging(e, t) {
    var n = mu.isMerging(e);
    Cp.set(e, !0), t(), Cp.set(e, n);
  },
  /**
   * Apply a series of changes inside a synchronous `fn`, without merging any of
   * the new operations into previous save point in the history.
   */
  withoutMerging(e, t) {
    var n = mu.isMerging(e);
    Cp.set(e, !1), t(), Cp.set(e, n);
  },
  /**
   * Apply a series of changes inside a synchronous `fn`, without saving any of
   * their operations into the history.
   */
  withoutSaving(e, t) {
    var n = mu.isSaving(e);
    OO.set(e, !1), t(), OO.set(e, n);
  }
}, qHe = (e) => {
  var t = e, {
    apply: n
  } = t;
  return t.history = {
    undos: [],
    redos: []
  }, t.redo = () => {
    var {
      history: r
    } = t, {
      redos: o
    } = r;
    if (o.length > 0) {
      var i = o[o.length - 1];
      i.selectionBefore && Te.setSelection(t, i.selectionBefore), mu.withoutSaving(t, () => {
        ee.withoutNormalizing(t, () => {
          for (var a of i.operations)
            t.apply(a);
        });
      }), r.redos.pop(), t.writeHistory("undos", i);
    }
  }, t.undo = () => {
    var {
      history: r
    } = t, {
      undos: o
    } = r;
    if (o.length > 0) {
      var i = o[o.length - 1];
      mu.withoutSaving(t, () => {
        ee.withoutNormalizing(t, () => {
          var a = i.operations.map(sl.inverse).reverse();
          for (var s of a)
            t.apply(s);
          i.selectionBefore && Te.setSelection(t, i.selectionBefore);
        });
      }), t.writeHistory("redos", i), r.undos.pop();
    }
  }, t.apply = (r) => {
    var {
      operations: o,
      history: i
    } = t, {
      undos: a
    } = i, s = a[a.length - 1], l = s && s.operations[s.operations.length - 1], u = mu.isSaving(t), c = mu.isMerging(t);
    if (u == null && (u = KHe(r)), u) {
      if (c == null && (s == null ? c = !1 : o.length !== 0 ? c = !0 : c = GHe(r, l)), s && c)
        s.operations.push(r);
      else {
        var p = {
          operations: [r],
          selectionBefore: t.selection
        };
        t.writeHistory("undos", p);
      }
      for (; a.length > 100; )
        a.shift();
      i.redos = [];
    }
    n(r);
  }, t.writeHistory = (r, o) => {
    t.history[r].push(o);
  }, t;
}, GHe = (e, t) => !!(t && e.type === "insert_text" && t.type === "insert_text" && e.offset === t.offset + t.text.length && ae.equals(e.path, t.path) || t && e.type === "remove_text" && t.type === "remove_text" && e.offset + e.text.length === t.offset && ae.equals(e.path, t.path)), KHe = (e, t) => e.type !== "set_selection", YHe = QHe, aX = "---", lX = "A-Za-z--------", XHe = new RegExp("^[^" + lX + "]*[" + aX + "]"), JHe = new RegExp("^[^" + aX + "]*[" + lX + "]");
function QHe(e) {
  return e = String(e || ""), XHe.test(e) ? "rtl" : JHe.test(e) ? "ltr" : "neutral";
}
const uX = /* @__PURE__ */ qy(YHe);
function e$e(e) {
  var t = typeof e;
  return e != null && (t == "object" || t == "function");
}
var yS = e$e, t$e = typeof Xn == "object" && Xn && Xn.Object === Object && Xn, n$e = t$e, r$e = n$e, o$e = typeof self == "object" && self && self.Object === Object && self, i$e = r$e || o$e || Function("return this")(), cX = i$e, s$e = cX, a$e = function() {
  return s$e.Date.now();
}, l$e = a$e, u$e = /\s/;
function c$e(e) {
  for (var t = e.length; t-- && u$e.test(e.charAt(t)); )
    ;
  return t;
}
var p$e = c$e, d$e = p$e, f$e = /^\s+/;
function h$e(e) {
  return e && e.slice(0, d$e(e) + 1).replace(f$e, "");
}
var g$e = h$e, m$e = cX, v$e = m$e.Symbol, pX = v$e, eV = pX, dX = Object.prototype, y$e = dX.hasOwnProperty, b$e = dX.toString, xp = eV ? eV.toStringTag : void 0;
function w$e(e) {
  var t = y$e.call(e, xp), n = e[xp];
  try {
    e[xp] = void 0;
    var r = !0;
  } catch {
  }
  var o = b$e.call(e);
  return r && (t ? e[xp] = n : delete e[xp]), o;
}
var C$e = w$e, x$e = Object.prototype, O$e = x$e.toString;
function E$e(e) {
  return O$e.call(e);
}
var k$e = E$e, tV = pX, L$e = C$e, P$e = k$e, _$e = "[object Null]", S$e = "[object Undefined]", nV = tV ? tV.toStringTag : void 0;
function M$e(e) {
  return e == null ? e === void 0 ? S$e : _$e : nV && nV in Object(e) ? L$e(e) : P$e(e);
}
var D$e = M$e;
function T$e(e) {
  return e != null && typeof e == "object";
}
var j$e = T$e, A$e = D$e, I$e = j$e, R$e = "[object Symbol]";
function B$e(e) {
  return typeof e == "symbol" || I$e(e) && A$e(e) == R$e;
}
var N$e = B$e, F$e = g$e, rV = yS, z$e = N$e, oV = NaN, U$e = /^[-+]0x[0-9a-f]+$/i, H$e = /^0b[01]+$/i, $$e = /^0o[0-7]+$/i, W$e = parseInt;
function V$e(e) {
  if (typeof e == "number")
    return e;
  if (z$e(e))
    return oV;
  if (rV(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = rV(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = F$e(e);
  var n = H$e.test(e);
  return n || $$e.test(e) ? W$e(e.slice(2), n ? 2 : 8) : U$e.test(e) ? oV : +e;
}
var Z$e = V$e, q$e = yS, EO = l$e, iV = Z$e, G$e = "Expected a function", K$e = Math.max, Y$e = Math.min;
function X$e(e, t, n) {
  var r, o, i, a, s, l, u = 0, c = !1, p = !1, d = !0;
  if (typeof e != "function")
    throw new TypeError(G$e);
  t = iV(t) || 0, q$e(n) && (c = !!n.leading, p = "maxWait" in n, i = p ? K$e(iV(n.maxWait) || 0, t) : i, d = "trailing" in n ? !!n.trailing : d);
  function g(C) {
    var _ = r, F = o;
    return r = o = void 0, u = C, a = e.apply(F, _), a;
  }
  function f(C) {
    return u = C, s = setTimeout(E, t), c ? g(C) : a;
  }
  function m(C) {
    var _ = C - l, F = C - u, L = t - _;
    return p ? Y$e(L, i - F) : L;
  }
  function v(C) {
    var _ = C - l, F = C - u;
    return l === void 0 || _ >= t || _ < 0 || p && F >= i;
  }
  function E() {
    var C = EO();
    if (v(C))
      return w(C);
    s = setTimeout(E, m(C));
  }
  function w(C) {
    return s = void 0, d && r ? g(C) : (r = o = void 0, a);
  }
  function M() {
    s !== void 0 && clearTimeout(s), u = 0, r = l = o = s = void 0;
  }
  function O() {
    return s === void 0 ? a : w(EO());
  }
  function y() {
    var C = EO(), _ = v(C);
    if (r = arguments, o = this, l = C, _) {
      if (s === void 0)
        return f(l);
      if (p)
        return clearTimeout(s), s = setTimeout(E, t), g(l);
    }
    return s === void 0 && (s = setTimeout(E, t)), a;
  }
  return y.cancel = M, y.flush = O, y;
}
var fX = X$e;
const J$e = /* @__PURE__ */ qy(fX);
var Q$e = fX, e3e = yS, t3e = "Expected a function";
function n3e(e, t, n) {
  var r = !0, o = !0;
  if (typeof e != "function")
    throw new TypeError(t3e);
  return e3e(n) && (r = "leading" in n ? !!n.leading : r, o = "trailing" in n ? !!n.trailing : o), Q$e(e, t, {
    leading: r,
    maxWait: t,
    trailing: o
  });
}
var r3e = n3e;
const o3e = /* @__PURE__ */ qy(r3e), sV = (e) => typeof e == "object" && e != null && e.nodeType === 1, aV = (e, t) => (!t || e !== "hidden") && e !== "visible" && e !== "clip", um = (e, t) => {
  if (e.clientHeight < e.scrollHeight || e.clientWidth < e.scrollWidth) {
    const n = getComputedStyle(e, null);
    return aV(n.overflowY, t) || aV(n.overflowX, t) || ((r) => {
      const o = ((i) => {
        if (!i.ownerDocument || !i.ownerDocument.defaultView) return null;
        try {
          return i.ownerDocument.defaultView.frameElement;
        } catch {
          return null;
        }
      })(r);
      return !!o && (o.clientHeight < r.scrollHeight || o.clientWidth < r.scrollWidth);
    })(e);
  }
  return !1;
}, cm = (e, t, n, r, o, i, a, s) => i < e && a > t || i > e && a < t ? 0 : i <= e && s <= n || a >= t && s >= n ? i - e - r : a > t && s < n || i < e && s > n ? a - t + o : 0, i3e = (e) => {
  const t = e.parentElement;
  return t ?? (e.getRootNode().host || null);
}, lV = (e, t) => {
  var n, r, o, i;
  if (typeof document > "u") return [];
  const { scrollMode: a, block: s, inline: l, boundary: u, skipOverflowHiddenElements: c } = t, p = typeof u == "function" ? u : (K) => K !== u;
  if (!sV(e)) throw new TypeError("Invalid target");
  const d = document.scrollingElement || document.documentElement, g = [];
  let f = e;
  for (; sV(f) && p(f); ) {
    if (f = i3e(f), f === d) {
      g.push(f);
      break;
    }
    f != null && f === document.body && um(f) && !um(document.documentElement) || f != null && um(f, c) && g.push(f);
  }
  const m = (r = (n = window.visualViewport) == null ? void 0 : n.width) != null ? r : innerWidth, v = (i = (o = window.visualViewport) == null ? void 0 : o.height) != null ? i : innerHeight, { scrollX: E, scrollY: w } = window, { height: M, width: O, top: y, right: C, bottom: _, left: F } = e.getBoundingClientRect(), { top: L, right: N, bottom: R, left: W } = ((K) => {
    const X = window.getComputedStyle(K);
    return { top: parseFloat(X.scrollMarginTop) || 0, right: parseFloat(X.scrollMarginRight) || 0, bottom: parseFloat(X.scrollMarginBottom) || 0, left: parseFloat(X.scrollMarginLeft) || 0 };
  })(e);
  let V = s === "start" || s === "nearest" ? y - L : s === "end" ? _ + R : y + M / 2 - L + R, z = l === "center" ? F + O / 2 - W + N : l === "end" ? C + N : F - W;
  const Z = [];
  for (let K = 0; K < g.length; K++) {
    const X = g[K], { height: te, width: J, top: P, right: D, bottom: H, left: S } = X.getBoundingClientRect();
    if (a === "if-needed" && y >= 0 && F >= 0 && _ <= v && C <= m && (X === d && !um(X) || y >= P && _ <= H && F >= S && C <= D)) return Z;
    const $ = getComputedStyle(X), x = parseInt($.borderLeftWidth, 10), j = parseInt($.borderTopWidth, 10), U = parseInt($.borderRightWidth, 10), T = parseInt($.borderBottomWidth, 10);
    let q = 0, A = 0;
    const Y = "offsetWidth" in X ? X.offsetWidth - X.clientWidth - x - U : 0, B = "offsetHeight" in X ? X.offsetHeight - X.clientHeight - j - T : 0, ue = "offsetWidth" in X ? X.offsetWidth === 0 ? 0 : J / X.offsetWidth : 0, fe = "offsetHeight" in X ? X.offsetHeight === 0 ? 0 : te / X.offsetHeight : 0;
    if (d === X) q = s === "start" ? V : s === "end" ? V - v : s === "nearest" ? cm(w, w + v, v, j, T, w + V, w + V + M, M) : V - v / 2, A = l === "start" ? z : l === "center" ? z - m / 2 : l === "end" ? z - m : cm(E, E + m, m, x, U, E + z, E + z + O, O), q = Math.max(0, q + w), A = Math.max(0, A + E);
    else {
      q = s === "start" ? V - P - j : s === "end" ? V - H + T + B : s === "nearest" ? cm(P, H, te, j, T + B, V, V + M, M) : V - (P + te / 2) + B / 2, A = l === "start" ? z - S - x : l === "center" ? z - (S + J / 2) + Y / 2 : l === "end" ? z - D + U + Y : cm(S, D, J, x, U + Y, z, z + O, O);
      const { scrollLeft: oe, scrollTop: Ae } = X;
      q = fe === 0 ? 0 : Math.max(0, Math.min(Ae + q / fe, X.scrollHeight - te / fe + B)), A = ue === 0 ? 0 : Math.max(0, Math.min(oe + A / ue, X.scrollWidth - J / ue + Y)), V += Ae - q, z += oe - A;
    }
    Z.push({ el: X, top: q, left: A });
  }
  return Z;
}, s3e = (e) => e === !1 ? { block: "end", inline: "nearest" } : ((t) => t === Object(t) && Object.keys(t).length !== 0)(e) ? e : { block: "start", inline: "nearest" };
function a3e(e, t) {
  if (!e.isConnected || !((o) => {
    let i = o;
    for (; i && i.parentNode; ) {
      if (i.parentNode === document) return !0;
      i = i.parentNode instanceof ShadowRoot ? i.parentNode.host : i.parentNode;
    }
    return !1;
  })(e)) return;
  const n = ((o) => {
    const i = window.getComputedStyle(o);
    return { top: parseFloat(i.scrollMarginTop) || 0, right: parseFloat(i.scrollMarginRight) || 0, bottom: parseFloat(i.scrollMarginBottom) || 0, left: parseFloat(i.scrollMarginLeft) || 0 };
  })(e);
  if (((o) => typeof o == "object" && typeof o.behavior == "function")(t)) return t.behavior(lV(e, t));
  const r = typeof t == "boolean" || t == null ? void 0 : t.behavior;
  for (const { el: o, top: i, left: a } of lV(e, s3e(t))) {
    const s = i - n.top + n.bottom, l = a - n.left + n.right;
    o.scroll({ top: s, left: l, behavior: r });
  }
}
var wu = [], l3e = function() {
  return wu.some(function(e) {
    return e.activeTargets.length > 0;
  });
}, u3e = function() {
  return wu.some(function(e) {
    return e.skippedTargets.length > 0;
  });
}, uV = "ResizeObserver loop completed with undelivered notifications.", c3e = function() {
  var e;
  typeof ErrorEvent == "function" ? e = new ErrorEvent("error", {
    message: uV
  }) : (e = document.createEvent("Event"), e.initEvent("error", !1, !1), e.message = uV), window.dispatchEvent(e);
}, df;
(function(e) {
  e.BORDER_BOX = "border-box", e.CONTENT_BOX = "content-box", e.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(df || (df = {}));
var Cu = function(e) {
  return Object.freeze(e);
}, p3e = /* @__PURE__ */ function() {
  function e(t, n) {
    this.inlineSize = t, this.blockSize = n, Cu(this);
  }
  return e;
}(), hX = function() {
  function e(t, n, r, o) {
    return this.x = t, this.y = n, this.width = r, this.height = o, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, Cu(this);
  }
  return e.prototype.toJSON = function() {
    var t = this, n = t.x, r = t.y, o = t.top, i = t.right, a = t.bottom, s = t.left, l = t.width, u = t.height;
    return { x: n, y: r, top: o, right: i, bottom: a, left: s, width: l, height: u };
  }, e.fromRect = function(t) {
    return new e(t.x, t.y, t.width, t.height);
  }, e;
}(), bS = function(e) {
  return e instanceof SVGElement && "getBBox" in e;
}, gX = function(e) {
  if (bS(e)) {
    var t = e.getBBox(), n = t.width, r = t.height;
    return !n && !r;
  }
  var o = e, i = o.offsetWidth, a = o.offsetHeight;
  return !(i || a || e.getClientRects().length);
}, cV = function(e) {
  var t;
  if (e instanceof Element)
    return !0;
  var n = (t = e == null ? void 0 : e.ownerDocument) === null || t === void 0 ? void 0 : t.defaultView;
  return !!(n && e instanceof n.Element);
}, d3e = function(e) {
  switch (e.tagName) {
    case "INPUT":
      if (e.type !== "image")
        break;
    case "VIDEO":
    case "AUDIO":
    case "EMBED":
    case "OBJECT":
    case "CANVAS":
    case "IFRAME":
    case "IMG":
      return !0;
  }
  return !1;
}, dd = typeof window < "u" ? window : {}, pm = /* @__PURE__ */ new WeakMap(), pV = /auto|scroll/, f3e = /^tb|vertical/, h3e = /msie|trident/i.test(dd.navigator && dd.navigator.userAgent), vs = function(e) {
  return parseFloat(e || "0");
}, uc = function(e, t, n) {
  return e === void 0 && (e = 0), t === void 0 && (t = 0), n === void 0 && (n = !1), new p3e((n ? t : e) || 0, (n ? e : t) || 0);
}, dV = Cu({
  devicePixelContentBoxSize: uc(),
  borderBoxSize: uc(),
  contentBoxSize: uc(),
  contentRect: new hX(0, 0, 0, 0)
}), mX = function(e, t) {
  if (t === void 0 && (t = !1), pm.has(e) && !t)
    return pm.get(e);
  if (gX(e))
    return pm.set(e, dV), dV;
  var n = getComputedStyle(e), r = bS(e) && e.ownerSVGElement && e.getBBox(), o = !h3e && n.boxSizing === "border-box", i = f3e.test(n.writingMode || ""), a = !r && pV.test(n.overflowY || ""), s = !r && pV.test(n.overflowX || ""), l = r ? 0 : vs(n.paddingTop), u = r ? 0 : vs(n.paddingRight), c = r ? 0 : vs(n.paddingBottom), p = r ? 0 : vs(n.paddingLeft), d = r ? 0 : vs(n.borderTopWidth), g = r ? 0 : vs(n.borderRightWidth), f = r ? 0 : vs(n.borderBottomWidth), m = r ? 0 : vs(n.borderLeftWidth), v = p + u, E = l + c, w = m + g, M = d + f, O = s ? e.offsetHeight - M - e.clientHeight : 0, y = a ? e.offsetWidth - w - e.clientWidth : 0, C = o ? v + w : 0, _ = o ? E + M : 0, F = r ? r.width : vs(n.width) - C - y, L = r ? r.height : vs(n.height) - _ - O, N = F + v + y + w, R = L + E + O + M, W = Cu({
    devicePixelContentBoxSize: uc(Math.round(F * devicePixelRatio), Math.round(L * devicePixelRatio), i),
    borderBoxSize: uc(N, R, i),
    contentBoxSize: uc(F, L, i),
    contentRect: new hX(p, l, F, L)
  });
  return pm.set(e, W), W;
}, vX = function(e, t, n) {
  var r = mX(e, n), o = r.borderBoxSize, i = r.contentBoxSize, a = r.devicePixelContentBoxSize;
  switch (t) {
    case df.DEVICE_PIXEL_CONTENT_BOX:
      return a;
    case df.BORDER_BOX:
      return o;
    default:
      return i;
  }
}, g3e = /* @__PURE__ */ function() {
  function e(t) {
    var n = mX(t);
    this.target = t, this.contentRect = n.contentRect, this.borderBoxSize = Cu([n.borderBoxSize]), this.contentBoxSize = Cu([n.contentBoxSize]), this.devicePixelContentBoxSize = Cu([n.devicePixelContentBoxSize]);
  }
  return e;
}(), yX = function(e) {
  if (gX(e))
    return 1 / 0;
  for (var t = 0, n = e.parentNode; n; )
    t += 1, n = n.parentNode;
  return t;
}, m3e = function() {
  var e = 1 / 0, t = [];
  wu.forEach(function(a) {
    if (a.activeTargets.length !== 0) {
      var s = [];
      a.activeTargets.forEach(function(u) {
        var c = new g3e(u.target), p = yX(u.target);
        s.push(c), u.lastReportedSize = vX(u.target, u.observedBox), p < e && (e = p);
      }), t.push(function() {
        a.callback.call(a.observer, s, a.observer);
      }), a.activeTargets.splice(0, a.activeTargets.length);
    }
  });
  for (var n = 0, r = t; n < r.length; n++) {
    var o = r[n];
    o();
  }
  return e;
}, fV = function(e) {
  wu.forEach(function(n) {
    n.activeTargets.splice(0, n.activeTargets.length), n.skippedTargets.splice(0, n.skippedTargets.length), n.observationTargets.forEach(function(o) {
      o.isActive() && (yX(o.target) > e ? n.activeTargets.push(o) : n.skippedTargets.push(o));
    });
  });
}, v3e = function() {
  var e = 0;
  for (fV(e); l3e(); )
    e = m3e(), fV(e);
  return u3e() && c3e(), e > 0;
}, kO, bX = [], y3e = function() {
  return bX.splice(0).forEach(function(e) {
    return e();
  });
}, b3e = function(e) {
  if (!kO) {
    var t = 0, n = document.createTextNode(""), r = { characterData: !0 };
    new MutationObserver(function() {
      return y3e();
    }).observe(n, r), kO = function() {
      n.textContent = "".concat(t ? t-- : t++);
    };
  }
  bX.push(e), kO();
}, w3e = function(e) {
  b3e(function() {
    requestAnimationFrame(e);
  });
}, jm = 0, C3e = function() {
  return !!jm;
}, x3e = 250, O3e = { attributes: !0, characterData: !0, childList: !0, subtree: !0 }, hV = [
  "resize",
  "load",
  "transitionend",
  "animationend",
  "animationstart",
  "animationiteration",
  "keyup",
  "keydown",
  "mouseup",
  "mousedown",
  "mouseover",
  "mouseout",
  "blur",
  "focus"
], gV = function(e) {
  return e === void 0 && (e = 0), Date.now() + e;
}, LO = !1, E3e = function() {
  function e() {
    var t = this;
    this.stopped = !0, this.listener = function() {
      return t.schedule();
    };
  }
  return e.prototype.run = function(t) {
    var n = this;
    if (t === void 0 && (t = x3e), !LO) {
      LO = !0;
      var r = gV(t);
      w3e(function() {
        var o = !1;
        try {
          o = v3e();
        } finally {
          if (LO = !1, t = r - gV(), !C3e())
            return;
          o ? n.run(1e3) : t > 0 ? n.run(t) : n.start();
        }
      });
    }
  }, e.prototype.schedule = function() {
    this.stop(), this.run();
  }, e.prototype.observe = function() {
    var t = this, n = function() {
      return t.observer && t.observer.observe(document.body, O3e);
    };
    document.body ? n() : dd.addEventListener("DOMContentLoaded", n);
  }, e.prototype.start = function() {
    var t = this;
    this.stopped && (this.stopped = !1, this.observer = new MutationObserver(this.listener), this.observe(), hV.forEach(function(n) {
      return dd.addEventListener(n, t.listener, !0);
    }));
  }, e.prototype.stop = function() {
    var t = this;
    this.stopped || (this.observer && this.observer.disconnect(), hV.forEach(function(n) {
      return dd.removeEventListener(n, t.listener, !0);
    }), this.stopped = !0);
  }, e;
}(), i1 = new E3e(), mV = function(e) {
  !jm && e > 0 && i1.start(), jm += e, !jm && i1.stop();
}, k3e = function(e) {
  return !bS(e) && !d3e(e) && getComputedStyle(e).display === "inline";
}, L3e = function() {
  function e(t, n) {
    this.target = t, this.observedBox = n || df.CONTENT_BOX, this.lastReportedSize = {
      inlineSize: 0,
      blockSize: 0
    };
  }
  return e.prototype.isActive = function() {
    var t = vX(this.target, this.observedBox, !0);
    return k3e(this.target) && (this.lastReportedSize = t), this.lastReportedSize.inlineSize !== t.inlineSize || this.lastReportedSize.blockSize !== t.blockSize;
  }, e;
}(), P3e = /* @__PURE__ */ function() {
  function e(t, n) {
    this.activeTargets = [], this.skippedTargets = [], this.observationTargets = [], this.observer = t, this.callback = n;
  }
  return e;
}(), dm = /* @__PURE__ */ new WeakMap(), vV = function(e, t) {
  for (var n = 0; n < e.length; n += 1)
    if (e[n].target === t)
      return n;
  return -1;
}, fm = function() {
  function e() {
  }
  return e.connect = function(t, n) {
    var r = new P3e(t, n);
    dm.set(t, r);
  }, e.observe = function(t, n, r) {
    var o = dm.get(t), i = o.observationTargets.length === 0;
    vV(o.observationTargets, n) < 0 && (i && wu.push(o), o.observationTargets.push(new L3e(n, r && r.box)), mV(1), i1.schedule());
  }, e.unobserve = function(t, n) {
    var r = dm.get(t), o = vV(r.observationTargets, n), i = r.observationTargets.length === 1;
    o >= 0 && (i && wu.splice(wu.indexOf(r), 1), r.observationTargets.splice(o, 1), mV(-1));
  }, e.disconnect = function(t) {
    var n = this, r = dm.get(t);
    r.observationTargets.slice().forEach(function(o) {
      return n.unobserve(t, o.target);
    }), r.activeTargets.splice(0, r.activeTargets.length);
  }, e;
}(), _3e = function() {
  function e(t) {
    if (arguments.length === 0)
      throw new TypeError("Failed to construct 'ResizeObserver': 1 argument required, but only 0 present.");
    if (typeof t != "function")
      throw new TypeError("Failed to construct 'ResizeObserver': The callback provided as parameter 1 is not a function.");
    fm.connect(this, t);
  }
  return e.prototype.observe = function(t, n) {
    if (arguments.length === 0)
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': 1 argument required, but only 0 present.");
    if (!cV(t))
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': parameter 1 is not of type 'Element");
    fm.observe(this, t, n);
  }, e.prototype.unobserve = function(t) {
    if (arguments.length === 0)
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': 1 argument required, but only 0 present.");
    if (!cV(t))
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': parameter 1 is not of type 'Element");
    fm.unobserve(this, t);
  }, e.prototype.disconnect = function() {
    fm.disconnect(this);
  }, e.toString = function() {
    return "function ResizeObserver () { [polyfill code] }";
  }, e;
}();
function S3e(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), o, i;
  for (i = 0; i < r.length; i++)
    o = r[i], !(t.indexOf(o) >= 0) && (n[o] = e[o]);
  return n;
}
function bc(e, t) {
  if (e == null) return {};
  var n = S3e(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (o = 0; o < i.length; o++)
      r = i[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
function ff(e) {
  "@babel/helpers - typeof";
  return ff = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, ff(e);
}
function M3e(e, t) {
  if (ff(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (ff(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function D3e(e) {
  var t = M3e(e, "string");
  return ff(t) === "symbol" ? t : String(t);
}
function ls(e, t, n) {
  return t = D3e(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
var wS = /* @__PURE__ */ Ke(null), Tl = () => {
  var e = ge(wS);
  if (!e)
    throw new Error("The `useSlateStatic` hook must be used inside the <Slate> component's context.");
  return e;
}, PO, _O, wX = parseInt(we.version.split(".")[0], 10), CX = typeof navigator < "u" && typeof window < "u" && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream, yV = typeof navigator < "u" && /Mac OS X/.test(navigator.userAgent), qo = typeof navigator < "u" && /Android/.test(navigator.userAgent), nc = typeof navigator < "u" && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent), nu = typeof navigator < "u" && /AppleWebKit(?!.*Chrome)/i.test(navigator.userAgent), T3e = typeof navigator < "u" && /Edge?\/(?:[0-6][0-9]|[0-7][0-8])(?:\.)/i.test(navigator.userAgent), xX = typeof navigator < "u" && /Chrome/i.test(navigator.userAgent), j3e = typeof navigator < "u" && /Chrome?\/(?:[0-7][0-5]|[0-6][0-9])(?:\.)/i.test(navigator.userAgent), A3e = qo && typeof navigator < "u" && /Chrome?\/(?:[0-5]?\d)(?:\.)/i.test(navigator.userAgent), I3e = typeof navigator < "u" && /^(?!.*Seamonkey)(?=.*Firefox\/(?:[0-7][0-9]|[0-8][0-6])(?:\.)).*/i.test(navigator.userAgent), R3e = typeof navigator < "u" && /.*UCBrowser/.test(navigator.userAgent), B3e = typeof navigator < "u" && /.*Wechat/.test(navigator.userAgent) && !/.*MacWechat/.test(navigator.userAgent), Am = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u";
typeof navigator < "u" && /Safari/.test(navigator.userAgent) && /Version\/(\d+)/.test(navigator.userAgent) && ((PO = navigator.userAgent.match(/Version\/(\d+)/)) !== null && PO !== void 0 && PO[1] && parseInt((_O = navigator.userAgent.match(/Version\/(\d+)/)) === null || _O === void 0 ? void 0 : _O[1], 10) < 17);
var Aa = (!j3e || !A3e) && !T3e && // globalThis is undefined in older browsers
typeof globalThis < "u" && globalThis.InputEvent && // @ts-ignore The `getTargetRanges` property isn't recognized.
typeof globalThis.InputEvent.prototype.getTargetRanges == "function", cc = /* @__PURE__ */ new WeakMap(), CS = /* @__PURE__ */ new WeakMap(), xS = /* @__PURE__ */ new WeakMap(), OX = /* @__PURE__ */ new WeakMap(), Im = /* @__PURE__ */ new WeakMap(), s1 = /* @__PURE__ */ new WeakMap(), hf = /* @__PURE__ */ new WeakMap(), xu = /* @__PURE__ */ new WeakMap(), Ay = /* @__PURE__ */ new WeakMap(), b0 = /* @__PURE__ */ new WeakMap(), a1 = /* @__PURE__ */ new WeakMap(), al = /* @__PURE__ */ new WeakMap(), vu = /* @__PURE__ */ new WeakMap(), fd = /* @__PURE__ */ new WeakMap(), l1 = /* @__PURE__ */ new WeakMap(), OS = /* @__PURE__ */ new WeakMap(), us = /* @__PURE__ */ new WeakMap(), sa = /* @__PURE__ */ new WeakMap(), ri = /* @__PURE__ */ new WeakMap(), Ya = /* @__PURE__ */ new WeakMap(), Xa = /* @__PURE__ */ new WeakMap(), EX = /* @__PURE__ */ new WeakMap(), wc = Symbol("placeholder"), kX = Symbol("mark-placeholder"), LX = globalThis.Node, N3e = globalThis.Text, ES = (e) => e && e.ownerDocument && e.ownerDocument.defaultView || null, F3e = (e) => ul(e) && e.nodeType === 8, as = (e) => ul(e) && e.nodeType === 1, ul = (e) => {
  var t = ES(e);
  return !!t && e instanceof t.Node;
}, u1 = (e) => {
  var t = e && e.anchorNode && ES(e.anchorNode);
  return !!t && e instanceof t.Selection;
}, PX = (e) => ul(e) && e.nodeType === 3, z3e = (e) => e.clipboardData && e.clipboardData.getData("text/plain") !== "" && e.clipboardData.types.length === 1, U3e = (e) => {
  var [t, n] = e;
  if (as(t) && t.childNodes.length) {
    var r = n === t.childNodes.length, o = r ? n - 1 : n;
    for ([t, o] = _X(t, o, r ? "backward" : "forward"), r = o < n; as(t) && t.childNodes.length; ) {
      var i = r ? t.childNodes.length - 1 : 0;
      t = $3e(t, i, r ? "backward" : "forward");
    }
    n = r && t.textContent != null ? t.textContent.length : 0;
  }
  return [t, n];
}, H3e = (e) => {
  for (var t = e && e.parentNode; t; ) {
    if (t.toString() === "[object ShadowRoot]")
      return !0;
    t = t.parentNode;
  }
  return !1;
}, _X = (e, t, n) => {
  for (var {
    childNodes: r
  } = e, o = r[t], i = t, a = !1, s = !1; (F3e(o) || as(o) && o.childNodes.length === 0 || as(o) && o.getAttribute("contenteditable") === "false") && !(a && s); ) {
    if (i >= r.length) {
      a = !0, i = t - 1, n = "backward";
      continue;
    }
    if (i < 0) {
      s = !0, i = t + 1, n = "forward";
      continue;
    }
    o = r[i], t = i, i += n === "forward" ? 1 : -1;
  }
  return [o, t];
}, $3e = (e, t, n) => {
  var [r] = _X(e, t, n);
  return r;
}, SX = (e) => {
  var t = "";
  if (PX(e) && e.nodeValue)
    return e.nodeValue;
  if (as(e)) {
    for (var n of Array.from(e.childNodes))
      t += SX(n);
    var r = getComputedStyle(e).getPropertyValue("display");
    (r === "block" || r === "list" || e.tagName === "BR") && (t += `
`);
  }
  return t;
}, W3e = /data-slate-fragment="(.+?)"/m, V3e = (e) => {
  var t = e.getData("text/html"), [, n] = t.match(W3e) || [];
  return n;
}, hd = (e) => e.getSelection != null ? e.getSelection() : document.getSelection(), kS = (e, t, n) => {
  var {
    target: r
  } = t;
  if (as(r) && r.matches('[contentEditable="false"]'))
    return !1;
  var {
    document: o
  } = be.getWindow(e);
  if (o.contains(r))
    return be.hasDOMNode(e, r, {
      editable: !0
    });
  var i = n.find((a) => {
    var {
      addedNodes: s,
      removedNodes: l
    } = a;
    for (var u of s)
      if (u === r || u.contains(r))
        return !0;
    for (var c of l)
      if (c === r || c.contains(r))
        return !0;
  });
  return !i || i === t ? !1 : kS(e, i, n);
}, Z3e = () => {
  for (var e = document.activeElement; (t = e) !== null && t !== void 0 && t.shadowRoot && (n = e.shadowRoot) !== null && n !== void 0 && n.activeElement; ) {
    var t, n, r;
    e = (r = e) === null || r === void 0 || (r = r.shadowRoot) === null || r === void 0 ? void 0 : r.activeElement;
  }
  return e;
}, bV = (e, t) => !!(e.compareDocumentPosition(t) & LX.DOCUMENT_POSITION_PRECEDING), q3e = (e, t) => !!(e.compareDocumentPosition(t) & LX.DOCUMENT_POSITION_FOLLOWING), G3e = 0;
class K3e {
  constructor() {
    ls(this, "id", void 0), this.id = "".concat(G3e++);
  }
}
var be = {
  androidPendingDiffs: (e) => ri.get(e),
  androidScheduleFlush: (e) => {
    var t;
    (t = OS.get(e)) === null || t === void 0 || t();
  },
  blur: (e) => {
    var t = be.toDOMNode(e, e), n = be.findDocumentOrShadowRoot(e);
    al.set(e, !1), n.activeElement === t && t.blur();
  },
  deselect: (e) => {
    var {
      selection: t
    } = e, n = be.findDocumentOrShadowRoot(e), r = hd(n);
    r && r.rangeCount > 0 && r.removeAllRanges(), t && Te.deselect(e);
  },
  findDocumentOrShadowRoot: (e) => {
    var t = be.toDOMNode(e, e), n = t.getRootNode();
    return n instanceof Document || n instanceof ShadowRoot ? n : t.ownerDocument;
  },
  findEventRange: (e, t) => {
    "nativeEvent" in t && (t = t.nativeEvent);
    var {
      clientX: n,
      clientY: r,
      target: o
    } = t;
    if (n == null || r == null)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var i = be.toSlateNode(e, t.target), a = be.findPath(e, i);
    if (rt.isElement(i) && ee.isVoid(e, i)) {
      var s = o.getBoundingClientRect(), l = e.isInline(i) ? n - s.left < s.left + s.width - n : r - s.top < s.top + s.height - r, u = ee.point(e, a, {
        edge: l ? "start" : "end"
      }), c = l ? ee.before(e, u) : ee.after(e, u);
      if (c) {
        var p = ee.range(e, c);
        return p;
      }
    }
    var d, {
      document: g
    } = be.getWindow(e);
    if (g.caretRangeFromPoint)
      d = g.caretRangeFromPoint(n, r);
    else {
      var f = g.caretPositionFromPoint(n, r);
      f && (d = g.createRange(), d.setStart(f.offsetNode, f.offset), d.setEnd(f.offsetNode, f.offset));
    }
    if (!d)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var m = be.toSlateRange(e, d, {
      exactMatch: !1,
      suppressThrow: !1
    });
    return m;
  },
  findKey: (e, t) => {
    var n = Ay.get(t);
    return n || (n = new K3e(), Ay.set(t, n)), n;
  },
  findPath: (e, t) => {
    for (var n = [], r = t; ; ) {
      var o = xS.get(r);
      if (o == null) {
        if (ee.isEditor(r))
          return n;
        break;
      }
      var i = CS.get(r);
      if (i == null)
        break;
      n.unshift(i), r = o;
    }
    throw new Error("Unable to find the path for Slate node: ".concat(ko.stringify(t)));
  },
  focus: function(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      retries: 5
    };
    if (!al.get(t)) {
      if (n.retries <= 0)
        throw new Error("Could not set focus, editor seems stuck with pending operations");
      if (t.operations.length > 0) {
        setTimeout(() => {
          be.focus(t, {
            retries: n.retries - 1
          });
        }, 10);
        return;
      }
      var r = be.toDOMNode(t, t), o = be.findDocumentOrShadowRoot(t);
      if (o.activeElement !== r) {
        if (t.selection && o instanceof Document) {
          var i = hd(o), a = be.toDOMRange(t, t.selection);
          i == null || i.removeAllRanges(), i == null || i.addRange(a);
        }
        t.selection || Te.select(t, ee.start(t, [])), al.set(t, !0), r.focus({
          preventScroll: !0
        });
      }
    }
  },
  getWindow: (e) => {
    var t = OX.get(e);
    if (!t)
      throw new Error("Unable to find a host window element for this editor");
    return t;
  },
  hasDOMNode: function(t, n) {
    var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      editable: o = !1
    } = r, i = be.toDOMNode(t, t), a;
    try {
      a = as(n) ? n : n.parentElement;
    } catch (s) {
      if (s instanceof Error && !s.message.includes('Permission denied to access property "nodeType"'))
        throw s;
    }
    return a ? a.closest("[data-slate-editor]") === i && (!o || a.isContentEditable ? !0 : typeof a.isContentEditable == "boolean" && // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined
    // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable="false"(readOnly)
    a.closest('[contenteditable="false"]') === i || !!a.getAttribute("data-slate-zero-width")) : !1;
  },
  hasEditableTarget: (e, t) => ul(t) && be.hasDOMNode(e, t, {
    editable: !0
  }),
  hasRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t;
    return ee.hasPath(e, n.path) && ee.hasPath(e, r.path);
  },
  hasSelectableTarget: (e, t) => be.hasEditableTarget(e, t) || be.isTargetInsideNonReadonlyVoid(e, t),
  hasTarget: (e, t) => ul(t) && be.hasDOMNode(e, t),
  insertData: (e, t) => {
    e.insertData(t);
  },
  insertFragmentData: (e, t) => e.insertFragmentData(t),
  insertTextData: (e, t) => e.insertTextData(t),
  isComposing: (e) => !!vu.get(e),
  isFocused: (e) => !!al.get(e),
  isReadOnly: (e) => !!a1.get(e),
  isTargetInsideNonReadonlyVoid: (e, t) => {
    if (a1.get(e)) return !1;
    var n = be.hasTarget(e, t) && be.toSlateNode(e, t);
    return rt.isElement(n) && ee.isVoid(e, n);
  },
  setFragmentData: (e, t, n) => e.setFragmentData(t, n),
  toDOMNode: (e, t) => {
    var n = b0.get(e), r = ee.isEditor(t) ? Im.get(e) : n == null ? void 0 : n.get(be.findKey(e, t));
    if (!r)
      throw new Error("Cannot resolve a DOM node from Slate node: ".concat(ko.stringify(t)));
    return r;
  },
  toDOMPoint: (e, t) => {
    var [n] = ee.node(e, t.path), r = be.toDOMNode(e, n), o;
    ee.void(e, {
      at: t
    }) && (t = {
      path: t.path,
      offset: 0
    });
    for (var i = "[data-slate-string], [data-slate-zero-width]", a = Array.from(r.querySelectorAll(i)), s = 0, l = 0; l < a.length; l++) {
      var u = a[l], c = u.childNodes[0];
      if (!(c == null || c.textContent == null)) {
        var {
          length: p
        } = c.textContent, d = u.getAttribute("data-slate-length"), g = d == null ? p : parseInt(d, 10), f = s + g, m = a[l + 1];
        if (t.offset === f && m !== null && m !== void 0 && m.hasAttribute("data-slate-mark-placeholder")) {
          var v, E = m.childNodes[0];
          o = [
            // COMPAT: If we don't explicity set the dom point to be on the actual
            // dom text element, chrome will put the selection behind the actual dom
            // text element, causing domRange.getBoundingClientRect() calls on a collapsed
            // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)
            // which will cause issues when scrolling to it.
            E instanceof N3e ? E : m,
            (v = m.textContent) !== null && v !== void 0 && v.startsWith("\uFEFF") ? 1 : 0
          ];
          break;
        }
        if (t.offset <= f) {
          var w = Math.min(p, Math.max(0, t.offset - s));
          o = [c, w];
          break;
        }
        s = f;
      }
    }
    if (!o)
      throw new Error("Cannot resolve a DOM point from Slate point: ".concat(ko.stringify(t)));
    return o;
  },
  toDOMRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t, o = me.isBackward(t), i = be.toDOMPoint(e, n), a = me.isCollapsed(t) ? i : be.toDOMPoint(e, r), s = be.getWindow(e), l = s.document.createRange(), [u, c] = o ? a : i, [p, d] = o ? i : a, g = as(u) ? u : u.parentElement, f = !!g.getAttribute("data-slate-zero-width"), m = as(p) ? p : p.parentElement, v = !!m.getAttribute("data-slate-zero-width");
    return l.setStart(u, f ? 1 : c), l.setEnd(p, v ? 1 : d), l;
  },
  toSlateNode: (e, t) => {
    var n = as(t) ? t : t.parentElement;
    n && !n.hasAttribute("data-slate-node") && (n = n.closest("[data-slate-node]"));
    var r = n ? hf.get(n) : null;
    if (!r)
      throw new Error("Cannot resolve a Slate node from DOM node: ".concat(n));
    return r;
  },
  toSlatePoint: (e, t, n) => {
    var {
      exactMatch: r,
      suppressThrow: o,
      searchDirection: i = "backward"
    } = n, [a, s] = r ? t : U3e(t), l = a.parentNode, u = null, c = 0;
    if (l) {
      var p, d, g = be.toDOMNode(e, e), f = l.closest('[data-slate-void="true"]'), m = f && g.contains(f) ? f : null, v = l.closest('[contenteditable="false"]'), E = v && g.contains(v) ? v : null, w = l.closest("[data-slate-leaf]"), M = null;
      if (w) {
        if (u = w.closest('[data-slate-node="text"]'), u) {
          var O = be.getWindow(e), y = O.document.createRange();
          y.setStart(u, 0), y.setEnd(a, s);
          var C = y.cloneContents(), _ = [...Array.prototype.slice.call(C.querySelectorAll("[data-slate-zero-width]")), ...Array.prototype.slice.call(C.querySelectorAll("[contenteditable=false]"))];
          _.forEach((S) => {
            if (qo && !r && S.hasAttribute("data-slate-zero-width") && S.textContent.length > 0 && S.textContext !== "\uFEFF") {
              S.textContent.startsWith("\uFEFF") && (S.textContent = S.textContent.slice(1));
              return;
            }
            S.parentNode.removeChild(S);
          }), c = C.textContent.length, M = u;
        }
      } else if (m) {
        for (var F = m.querySelectorAll("[data-slate-leaf]"), L = 0; L < F.length; L++) {
          var N = F[L];
          if (be.hasDOMNode(e, N)) {
            w = N;
            break;
          }
        }
        w ? (u = w.closest('[data-slate-node="text"]'), M = w, c = M.textContent.length, M.querySelectorAll("[data-slate-zero-width]").forEach((S) => {
          c -= S.textContent.length;
        })) : c = 1;
      } else if (E) {
        var R = (S) => S ? S.querySelectorAll(
          // Exclude leaf nodes in nested editors
          "[data-slate-leaf]:not(:scope [data-slate-editor] [data-slate-leaf])"
        ) : [], W = E.closest('[data-slate-node="element"]');
        if (i === "forward") {
          var V, z = [...R(W), ...R(W == null ? void 0 : W.nextElementSibling)];
          w = (V = z.find((S) => q3e(E, S))) !== null && V !== void 0 ? V : null;
        } else {
          var Z, K = [...R(W == null ? void 0 : W.previousElementSibling), ...R(W)];
          w = (Z = K.findLast((S) => bV(E, S))) !== null && Z !== void 0 ? Z : null;
        }
        w && (u = w.closest('[data-slate-node="text"]'), M = w, i === "forward" ? c = 0 : (c = M.textContent.length, M.querySelectorAll("[data-slate-zero-width]").forEach((S) => {
          c -= S.textContent.length;
        })));
      }
      M && c === M.textContent.length && // COMPAT: Android IMEs might remove the zero width space while composing,
      // and we don't add it for line-breaks.
      qo && M.getAttribute("data-slate-zero-width") === "z" && (p = M.textContent) !== null && p !== void 0 && p.startsWith("\uFEFF") && // COMPAT: If the parent node is a Slate zero-width space, editor is
      // because the text node should have no characters. However, during IME
      // composition the ASCII characters will be prepended to the zero-width
      // space, so subtract 1 from the offset to account for the zero-width
      // space character.
      (l.hasAttribute("data-slate-zero-width") || // COMPAT: In Firefox, `range.cloneContents()` returns an extra trailing '\n'
      // when the document ends with a new-line character. This results in the offset
      // length being off by one, so we need to subtract one to account for this.
      nc && (d = M.textContent) !== null && d !== void 0 && d.endsWith(`

`)) && c--;
    }
    if (qo && !u && !r) {
      var X = l.hasAttribute("data-slate-node") ? l : l.closest("[data-slate-node]");
      if (X && be.hasDOMNode(e, X, {
        editable: !0
      })) {
        var te = be.toSlateNode(e, X), {
          path: J,
          offset: P
        } = ee.start(e, be.findPath(e, te));
        return X.querySelector("[data-slate-leaf]") || (P = s), {
          path: J,
          offset: P
        };
      }
    }
    if (!u) {
      if (o)
        return null;
      throw new Error("Cannot resolve a Slate point from DOM point: ".concat(t));
    }
    var D = be.toSlateNode(e, u), H = be.findPath(e, D);
    return {
      path: H,
      offset: c
    };
  },
  toSlateRange: (e, t, n) => {
    var r, {
      exactMatch: o,
      suppressThrow: i
    } = n, a = u1(t) ? t.anchorNode : t.startContainer, s, l, u, c, p;
    if (a)
      if (u1(t)) {
        if (nc && t.rangeCount > 1) {
          u = t.focusNode;
          var d = t.getRangeAt(0), g = t.getRangeAt(t.rangeCount - 1);
          if (u instanceof HTMLTableRowElement && d.startContainer instanceof HTMLTableRowElement && g.startContainer instanceof HTMLTableRowElement) {
            let C = function(_) {
              return _.childElementCount > 0 ? C(_.children[0]) : _;
            };
            var f = d.startContainer, m = g.startContainer, v = C(f.children[d.startOffset]), E = C(m.children[g.startOffset]);
            c = 0, E.childNodes.length > 0 ? s = E.childNodes[0] : s = E, v.childNodes.length > 0 ? u = v.childNodes[0] : u = v, E instanceof HTMLElement ? l = E.innerHTML.length : l = 0;
          } else
            d.startContainer === u ? (s = g.endContainer, l = g.endOffset, c = d.startOffset) : (s = d.startContainer, l = d.endOffset, c = g.startOffset);
        } else
          s = t.anchorNode, l = t.anchorOffset, u = t.focusNode, c = t.focusOffset;
        xX && H3e(s) || nc ? p = t.anchorNode === t.focusNode && t.anchorOffset === t.focusOffset : p = t.isCollapsed;
      } else
        s = t.startContainer, l = t.startOffset, u = t.endContainer, c = t.endOffset, p = t.collapsed;
    if (s == null || u == null || l == null || c == null)
      throw new Error("Cannot resolve a Slate range from DOM range: ".concat(t));
    nc && (r = u.textContent) !== null && r !== void 0 && r.endsWith(`

`) && c === u.textContent.length && c--;
    var w = be.toSlatePoint(e, [s, l], {
      exactMatch: o,
      suppressThrow: i
    });
    if (!w)
      return null;
    var M = bV(s, u) || s === u && c < l, O = p ? w : be.toSlatePoint(e, [u, c], {
      exactMatch: o,
      suppressThrow: i,
      searchDirection: M ? "forward" : "backward"
    });
    if (!O)
      return null;
    var y = {
      anchor: w,
      focus: O
    };
    return me.isExpanded(y) && me.isForward(y) && as(u) && ee.void(e, {
      at: y.focus,
      mode: "highest"
    }) && (y = ee.unhangRange(e, y, {
      voids: !0
    })), y;
  }
};
function Y3e(e, t) {
  var {
    path: n,
    diff: r
  } = t;
  if (!ee.hasPath(e, n))
    return !1;
  var o = qe.get(e, n);
  if (!it.isText(o))
    return !1;
  if (r.start !== o.text.length || r.text.length === 0)
    return o.text.slice(r.start, r.start + r.text.length) === r.text;
  var i = ae.next(n);
  if (!ee.hasPath(e, i))
    return !1;
  var a = qe.get(e, i);
  return it.isText(a) && a.text.startsWith(r.text);
}
function MX(e) {
  for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)
    n[r - 1] = arguments[r];
  return n.reduce((o, i) => o.slice(0, i.start) + i.text + o.slice(i.end), e);
}
function X3e(e, t) {
  for (var n = Math.min(e.length, t.length), r = 0; r < n; r++)
    if (e.charAt(r) !== t.charAt(r))
      return r;
  return n;
}
function J3e(e, t, n) {
  for (var r = Math.min(e.length, t.length, n), o = 0; o < r; o++)
    if (e.charAt(e.length - o - 1) !== t.charAt(t.length - o - 1))
      return o;
  return r;
}
function DX(e, t) {
  var {
    start: n,
    end: r,
    text: o
  } = t, i = e.slice(n, r), a = X3e(i, o), s = Math.min(i.length - a, o.length - a), l = J3e(i, o, s), u = {
    start: n + a,
    end: r - l,
    text: o.slice(a, o.length - l)
  };
  return u.start === u.end && u.text.length === 0 ? null : u;
}
function Q3e(e, t, n) {
  var r = Math.min(t.start, n.start), o = Math.max(0, Math.min(t.start + t.text.length, n.end) - n.start), i = MX(e, t, n), a = Math.max(n.start + n.text.length, t.start + t.text.length + (t.start + t.text.length > n.start ? n.text.length : 0) - o), s = i.slice(r, a), l = Math.max(t.end, n.end - t.text.length + (t.end - t.start));
  return DX(e, {
    start: r,
    end: l,
    text: s
  });
}
function eWe(e) {
  var {
    path: t,
    diff: n
  } = e;
  return {
    anchor: {
      path: t,
      offset: n.start
    },
    focus: {
      path: t,
      offset: n.end
    }
  };
}
function c1(e, t) {
  var {
    path: n,
    offset: r
  } = t;
  if (!ee.hasPath(e, n))
    return null;
  var o = qe.get(e, n);
  if (!it.isText(o))
    return null;
  var i = ee.above(e, {
    match: (s) => rt.isElement(s) && ee.isBlock(e, s),
    at: n
  });
  if (!i)
    return null;
  for (; r > o.text.length; ) {
    var a = ee.next(e, {
      at: n,
      match: it.isText
    });
    if (!a || !ae.isDescendant(a[1], i[1]))
      return null;
    r -= o.text.length, o = a[0], n = a[1];
  }
  return {
    path: n,
    offset: r
  };
}
function wV(e, t) {
  var n = c1(e, t.anchor);
  if (!n)
    return null;
  if (me.isCollapsed(t))
    return {
      anchor: n,
      focus: n
    };
  var r = c1(e, t.focus);
  return r ? {
    anchor: n,
    focus: r
  } : null;
}
function p1(e, t, n) {
  var r = ri.get(e), o = r == null ? void 0 : r.find((c) => {
    var {
      path: p
    } = c;
    return ae.equals(p, t.path);
  });
  if (!o || t.offset <= o.diff.start)
    return Nt.transform(t, n, {
      affinity: "backward"
    });
  var {
    diff: i
  } = o;
  if (t.offset <= i.start + i.text.length) {
    var a = {
      path: t.path,
      offset: i.start
    }, s = Nt.transform(a, n, {
      affinity: "backward"
    });
    return s ? {
      path: s.path,
      offset: s.offset + t.offset - i.start
    } : null;
  }
  var l = {
    path: t.path,
    offset: t.offset - i.text.length + i.end - i.start
  }, u = Nt.transform(l, n, {
    affinity: "backward"
  });
  return u ? n.type === "split_node" && ae.equals(n.path, t.path) && l.offset < n.position && i.start < n.position ? u : {
    path: u.path,
    offset: u.offset + i.text.length - i.end + i.start
  } : null;
}
function CV(e, t, n) {
  var r = p1(e, t.anchor, n);
  if (!r)
    return null;
  if (me.isCollapsed(t))
    return {
      anchor: r,
      focus: r
    };
  var o = p1(e, t.focus, n);
  return o ? {
    anchor: r,
    focus: o
  } : null;
}
function tWe(e, t) {
  var {
    path: n,
    diff: r,
    id: o
  } = e;
  switch (t.type) {
    case "insert_text":
      return !ae.equals(t.path, n) || t.offset >= r.end ? e : t.offset <= r.start ? {
        diff: {
          start: t.text.length + r.start,
          end: t.text.length + r.end,
          text: r.text
        },
        id: o,
        path: n
      } : {
        diff: {
          start: r.start,
          end: r.end + t.text.length,
          text: r.text
        },
        id: o,
        path: n
      };
    case "remove_text":
      return !ae.equals(t.path, n) || t.offset >= r.end ? e : t.offset + t.text.length <= r.start ? {
        diff: {
          start: r.start - t.text.length,
          end: r.end - t.text.length,
          text: r.text
        },
        id: o,
        path: n
      } : {
        diff: {
          start: r.start,
          end: r.end - t.text.length,
          text: r.text
        },
        id: o,
        path: n
      };
    case "split_node":
      return !ae.equals(t.path, n) || t.position >= r.end ? {
        diff: r,
        id: o,
        path: ae.transform(n, t, {
          affinity: "backward"
        })
      } : t.position > r.start ? {
        diff: {
          start: r.start,
          end: Math.min(t.position, r.end),
          text: r.text
        },
        id: o,
        path: n
      } : {
        diff: {
          start: r.start - t.position,
          end: r.end - t.position,
          text: r.text
        },
        id: o,
        path: ae.transform(n, t, {
          affinity: "forward"
        })
      };
    case "merge_node":
      return ae.equals(t.path, n) ? {
        diff: {
          start: r.start + t.position,
          end: r.end + t.position,
          text: r.text
        },
        id: o,
        path: ae.transform(n, t)
      } : {
        diff: r,
        id: o,
        path: ae.transform(n, t)
      };
  }
  var i = ae.transform(n, t);
  return i ? {
    diff: r,
    path: i,
    id: o
  } : null;
}
function xV(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function hm(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? xV(Object(n), !0).forEach(function(r) {
      ls(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : xV(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var nWe = 25, rWe = 200, oWe = function() {
}, iWe = (e) => (e == null ? void 0 : e.constructor.name) === "DataTransfer";
function sWe(e) {
  var {
    editor: t,
    scheduleOnDOMSelectionChange: n,
    onDOMSelectionChange: r
  } = e, o = !1, i = null, a = null, s = null, l = 0, u = !1, c = () => {
    var W = Xa.get(t);
    if (Xa.delete(t), W) {
      var {
        selection: V
      } = t, z = wV(t, W);
      z && (!V || !me.equals(z, V)) && Te.select(t, z);
    }
  }, p = () => {
    var W = Ya.get(t);
    if (Ya.delete(t), !!W) {
      if (W.at) {
        var V = Nt.isPoint(W.at) ? c1(t, W.at) : wV(t, W.at);
        if (!V)
          return;
        var z = ee.range(t, V);
        (!t.selection || !me.equals(t.selection, z)) && Te.select(t, V);
      }
      W.run();
    }
  }, d = () => {
    if (a && (clearTimeout(a), a = null), s && (clearTimeout(s), s = null), !O() && !M()) {
      c();
      return;
    }
    o || (o = !0, setTimeout(() => o = !1)), M() && (o = "action");
    var W = t.selection && ee.rangeRef(t, t.selection, {
      affinity: "forward"
    });
    sa.set(t, t.marks), oWe("flush", Ya.get(t), ri.get(t));
    for (var V = O(), z; z = (Z = ri.get(t)) === null || Z === void 0 ? void 0 : Z[0]; ) {
      var Z, K, X = us.get(t);
      X !== void 0 && (us.delete(t), t.marks = X), X && u === !1 && (u = null);
      var te = eWe(z);
      (!t.selection || !me.equals(t.selection, te)) && Te.select(t, te), z.diff.text ? ee.insertText(t, z.diff.text) : ee.deleteFragment(t), ri.set(t, (K = ri.get(t)) === null || K === void 0 ? void 0 : K.filter((D) => {
        var {
          id: H
        } = D;
        return H !== z.id;
      })), Y3e(t, z) || (V = !1, Ya.delete(t), sa.delete(t), o = "action", Xa.delete(t), n.cancel(), r.cancel(), W == null || W.unref());
    }
    var J = W == null ? void 0 : W.unref();
    if (J && !Xa.get(t) && (!t.selection || !me.equals(J, t.selection)) && Te.select(t, J), M()) {
      p();
      return;
    }
    V && n(), n.flush(), r.flush(), c();
    var P = sa.get(t);
    sa.delete(t), P !== void 0 && (t.marks = P, t.onChange());
  }, g = (W) => {
    i && clearTimeout(i), i = setTimeout(() => {
      vu.set(t, !1), d();
    }, nWe);
  }, f = (W) => {
    vu.set(t, !0), i && (clearTimeout(i), i = null);
  }, m = function() {
    var V = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1, z = s1.get(t);
    if (z) {
      if (O() || V) {
        z.style.display = "none";
        return;
      }
      z.style.removeProperty("display");
    }
  }, v = (W, V) => {
    var z, Z = (z = ri.get(t)) !== null && z !== void 0 ? z : [];
    ri.set(t, Z);
    var K = qe.leaf(t, W), X = Z.findIndex((P) => ae.equals(P.path, W));
    if (X < 0) {
      var te = DX(K.text, V);
      te && Z.push({
        path: W,
        diff: V,
        id: l++
      }), m();
      return;
    }
    var J = Q3e(K.text, Z[X].diff, V);
    if (!J) {
      Z.splice(X, 1), m();
      return;
    }
    Z[X] = hm(hm({}, Z[X]), {}, {
      diff: J
    });
  }, E = function(V) {
    var {
      at: z
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    u = !1, Xa.delete(t), n.cancel(), r.cancel(), M() && d(), Ya.set(t, {
      at: z,
      run: V
    }), s = setTimeout(d);
  }, w = (W) => {
    var V;
    if (a && (clearTimeout(a), a = null), !cc.get(t)) {
      var {
        inputType: z
      } = W, Z = null, K = W.dataTransfer || W.data || void 0;
      u !== !1 && z !== "insertText" && z !== "insertCompositionText" && (u = !1);
      var [X] = W.getTargetRanges();
      X && (Z = be.toSlateRange(t, X, {
        exactMatch: !1,
        suppressThrow: !0
      }));
      var te = be.getWindow(t), J = te.getSelection();
      if (!Z && J && (X = J, Z = be.toSlateRange(t, J, {
        exactMatch: !1,
        suppressThrow: !0
      })), Z = (V = Z) !== null && V !== void 0 ? V : t.selection, !!Z) {
        var P = !0;
        if (z.startsWith("delete")) {
          if (me.isExpanded(Z)) {
            var [D, H] = me.edges(Z), S = qe.leaf(t, D.path);
            if (S.text.length === D.offset && H.offset === 0) {
              var $ = ee.next(t, {
                at: D.path,
                match: it.isText
              });
              $ && ae.equals($[1], H.path) && (Z = {
                anchor: H,
                focus: H
              });
            }
          }
          var x = z.endsWith("Backward") ? "backward" : "forward", [j, U] = me.edges(Z), [T, q] = ee.leaf(t, j.path), A = {
            text: "",
            start: j.offset,
            end: U.offset
          }, Y = ri.get(t), B = Y == null ? void 0 : Y.find((We) => ae.equals(We.path, q)), ue = B ? [B.diff, A] : [A], fe = MX(T.text, ...ue);
          if (fe.length === 0 && (P = !1), me.isExpanded(Z)) {
            if (P && ae.equals(Z.anchor.path, Z.focus.path)) {
              var oe = {
                path: Z.anchor.path,
                offset: j.offset
              }, Ae = ee.range(t, oe, oe);
              return _(Ae), v(Z.anchor.path, {
                text: "",
                end: U.offset,
                start: j.offset
              });
            }
            return E(() => ee.deleteFragment(t, {
              direction: x
            }), {
              at: Z
            });
          }
        }
        switch (z) {
          case "deleteByComposition":
          case "deleteByCut":
          case "deleteByDrag":
            return E(() => ee.deleteFragment(t), {
              at: Z
            });
          case "deleteContent":
          case "deleteContentForward": {
            var {
              anchor: Ze
            } = Z;
            if (P && me.isCollapsed(Z)) {
              var Ge = qe.leaf(t, Ze.path);
              if (Ze.offset < Ge.text.length)
                return v(Ze.path, {
                  text: "",
                  start: Ze.offset,
                  end: Ze.offset + 1
                });
            }
            return E(() => ee.deleteForward(t), {
              at: Z
            });
          }
          case "deleteContentBackward": {
            var Ie, {
              anchor: et
            } = Z, Ye = u1(X) ? X.isCollapsed : !!((Ie = X) !== null && Ie !== void 0 && Ie.collapsed);
            return P && Ye && me.isCollapsed(Z) && et.offset > 0 ? v(et.path, {
              text: "",
              start: et.offset - 1,
              end: et.offset
            }) : E(() => ee.deleteBackward(t), {
              at: Z
            });
          }
          case "deleteEntireSoftLine":
            return E(() => {
              ee.deleteBackward(t, {
                unit: "line"
              }), ee.deleteForward(t, {
                unit: "line"
              });
            }, {
              at: Z
            });
          case "deleteHardLineBackward":
            return E(() => ee.deleteBackward(t, {
              unit: "block"
            }), {
              at: Z
            });
          case "deleteSoftLineBackward":
            return E(() => ee.deleteBackward(t, {
              unit: "line"
            }), {
              at: Z
            });
          case "deleteHardLineForward":
            return E(() => ee.deleteForward(t, {
              unit: "block"
            }), {
              at: Z
            });
          case "deleteSoftLineForward":
            return E(() => ee.deleteForward(t, {
              unit: "line"
            }), {
              at: Z
            });
          case "deleteWordBackward":
            return E(() => ee.deleteBackward(t, {
              unit: "word"
            }), {
              at: Z
            });
          case "deleteWordForward":
            return E(() => ee.deleteForward(t, {
              unit: "word"
            }), {
              at: Z
            });
          case "insertLineBreak":
            return E(() => ee.insertSoftBreak(t), {
              at: Z
            });
          case "insertParagraph":
            return E(() => ee.insertBreak(t), {
              at: Z
            });
          case "insertCompositionText":
          case "deleteCompositionText":
          case "insertFromComposition":
          case "insertFromDrop":
          case "insertFromPaste":
          case "insertFromYank":
          case "insertReplacementText":
          case "insertText": {
            if (iWe(K))
              return E(() => be.insertData(t, K), {
                at: Z
              });
            var _e = K ?? "";
            if (us.get(t) && (_e = _e.replace("\uFEFF", "")), z === "insertText" && /.*\n.*\n$/.test(_e) && (_e = _e.slice(0, -1)), _e.includes(`
`))
              return E(() => {
                var We = _e.split(`
`);
                We.forEach((Re, nt) => {
                  Re && ee.insertText(t, Re), nt !== We.length - 1 && ee.insertSoftBreak(t);
                });
              }, {
                at: Z
              });
            if (ae.equals(Z.anchor.path, Z.focus.path)) {
              var [Qe, at] = me.edges(Z), Pe = {
                start: Qe.offset,
                end: at.offset,
                text: _e
              };
              if (_e && u && z === "insertCompositionText") {
                var Me = u.start + u.text.search(/\S|$/), Je = Pe.start + Pe.text.search(/\S|$/);
                Je === Me + 1 && Pe.end === u.start + u.text.length ? (Pe.start -= 1, u = null, N()) : u = !1;
              } else z === "insertText" ? u === null ? u = Pe : u && me.isCollapsed(Z) && u.end + u.text.length === Qe.offset ? u = hm(hm({}, u), {}, {
                text: u.text + _e
              }) : u = !1 : u = !1;
              if (P) {
                v(Qe.path, Pe);
                return;
              }
            }
            return E(() => ee.insertText(t, _e), {
              at: Z
            });
          }
        }
      }
    }
  }, M = () => !!Ya.get(t), O = () => {
    var W;
    return !!((W = ri.get(t)) !== null && W !== void 0 && W.length);
  }, y = () => M() || O(), C = () => o, _ = (W) => {
    Xa.set(t, W), a && (clearTimeout(a), a = null);
    var {
      selection: V
    } = t;
    if (W) {
      var z = !V || !ae.equals(V.anchor.path, W.anchor.path), Z = !V || !ae.equals(V.anchor.path.slice(0, -1), W.anchor.path.slice(0, -1));
      (z && u || Z) && (u = !1), (z || O()) && (a = setTimeout(d, rWe));
    }
  }, F = () => {
    (M() || !O()) && d();
  }, L = (W) => {
    O() || (m(!0), setTimeout(m));
  }, N = () => {
    M() || (s = setTimeout(d));
  }, R = (W) => {
    if (!(O() || M()) && W.some((z) => kS(t, z, W))) {
      var V;
      (V = EX.get(t)) === null || V === void 0 || V();
    }
  };
  return {
    flush: d,
    scheduleFlush: N,
    hasPendingDiffs: O,
    hasPendingAction: M,
    hasPendingChanges: y,
    isFlushing: C,
    handleUserSelect: _,
    handleCompositionEnd: g,
    handleCompositionStart: f,
    handleDOMBeforeInput: w,
    handleKeyDown: L,
    handleDomMutations: R,
    handleInput: F
  };
}
function aWe() {
  var e = ut(!1);
  return h(() => (e.current = !0, () => {
    e.current = !1;
  }), []), e.current;
}
var gf = Am ? HJ : h;
function lWe(e, t, n) {
  var [r] = k(() => new MutationObserver(t));
  gf(() => {
    r.takeRecords();
  }), h(() => {
    if (!e.current)
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    return r.observe(e.current, n), () => r.disconnect();
  }, [r, e, n]);
}
var uWe = ["node"];
function OV(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function cWe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? OV(Object(n), !0).forEach(function(r) {
      ls(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : OV(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var pWe = {
  subtree: !0,
  childList: !0,
  characterData: !0
}, dWe = qo ? (e) => {
  var {
    node: t
  } = e, n = bc(e, uWe);
  if (!qo)
    return null;
  var r = Tl(), o = aWe(), [i] = k(() => sWe(cWe({
    editor: r
  }, n)));
  return lWe(t, i.handleDomMutations, pWe), OS.set(r, i.scheduleFlush), o && i.flush(), i;
} : () => null, fWe = ["anchor", "focus"], hWe = ["anchor", "focus"], gWe = (e, t) => Object.keys(e).length === Object.keys(t).length && Object.keys(e).every((n) => t.hasOwnProperty(n) && e[n] === t[n]), TX = (e, t) => {
  var n = bc(e, fWe), r = bc(t, hWe);
  return e[wc] === t[wc] && gWe(n, r);
}, mWe = (e, t) => {
  if (e.length !== t.length)
    return !1;
  for (var n = 0; n < e.length; n++) {
    var r = e[n], o = t[n];
    if (!me.equals(r, o) || !TX(r, o))
      return !1;
  }
  return !0;
}, vWe = (e, t) => {
  if (e.length !== t.length)
    return !1;
  for (var n = 0; n < e.length; n++) {
    var r = e[n], o = t[n];
    if (r.anchor.offset !== o.anchor.offset || r.focus.offset !== o.focus.offset || !TX(r, o))
      return !1;
  }
  return !0;
};
function EV(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function yWe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? EV(Object(n), !0).forEach(function(r) {
      ls(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : EV(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var bWe = (e) => {
  var {
    isLast: t,
    leaf: n,
    parent: r,
    text: o
  } = e, i = Tl(), a = be.findPath(i, o), s = ae.parent(a), l = !!n[kX];
  return i.isVoid(r) ? /* @__PURE__ */ we.createElement(SO, {
    length: qe.string(r).length
  }) : n.text === "" && r.children[r.children.length - 1] === o && !i.isInline(r) && ee.string(i, s) === "" ? /* @__PURE__ */ we.createElement(SO, {
    isLineBreak: !0,
    isMarkPlaceholder: l
  }) : n.text === "" ? /* @__PURE__ */ we.createElement(SO, {
    isMarkPlaceholder: l
  }) : t && n.text.slice(-1) === `
` ? /* @__PURE__ */ we.createElement(kV, {
    isTrailing: !0,
    text: n.text
  }) : /* @__PURE__ */ we.createElement(kV, {
    text: n.text
  });
}, kV = (e) => {
  var {
    text: t,
    isTrailing: n = !1
  } = e, r = ut(null), o = () => "".concat(t ?? "").concat(n ? `
` : ""), [i] = k(o);
  return gf(() => {
    var a = o();
    r.current && r.current.textContent !== a && (r.current.textContent = a);
  }), /* @__PURE__ */ we.createElement(wWe, {
    ref: r
  }, i);
}, wWe = /* @__PURE__ */ ve(/* @__PURE__ */ to((e, t) => /* @__PURE__ */ we.createElement("span", {
  "data-slate-string": !0,
  ref: t
}, e.children))), SO = (e) => {
  var {
    length: t = 0,
    isLineBreak: n = !1,
    isMarkPlaceholder: r = !1
  } = e, o = {
    "data-slate-zero-width": n ? "n" : "z",
    "data-slate-length": t
  };
  return r && (o["data-slate-mark-placeholder"] = !0), /* @__PURE__ */ we.createElement("span", yWe({}, o), !(qo || CX) || !n ? "\uFEFF" : null, n ? /* @__PURE__ */ we.createElement("br", null) : null);
};
function LV(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function jX(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? LV(Object(n), !0).forEach(function(r) {
      ls(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : LV(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var CWe = qo ? 300 : 0;
function xWe(e, t) {
  e.current && (e.current.disconnect(), t && (e.current = null));
}
function PV(e) {
  e.current && (clearTimeout(e.current), e.current = null);
}
var OWe = (e) => {
  var {
    leaf: t,
    isLast: n,
    text: r,
    parent: o,
    renderPlaceholder: i,
    renderLeaf: a = (w) => /* @__PURE__ */ we.createElement(kWe, jX({}, w))
  } = e, s = Tl(), l = ut(null), u = ut(null), [c, p] = k(!1), d = ut(null), g = Nn((w) => {
    if (xWe(l, w == null), w == null) {
      var M;
      s1.delete(s), (M = t.onPlaceholderResize) === null || M === void 0 || M.call(t, null);
    } else {
      if (s1.set(s, w), !l.current) {
        var O = window.ResizeObserver || _3e;
        l.current = new O(() => {
          var y;
          (y = t.onPlaceholderResize) === null || y === void 0 || y.call(t, w);
        });
      }
      l.current.observe(w), u.current = w;
    }
  }, [u, t, s]), f = /* @__PURE__ */ we.createElement(bWe, {
    isLast: n,
    leaf: t,
    parent: o,
    text: r
  }), m = !!t[wc];
  if (h(() => (m ? d.current || (d.current = setTimeout(() => {
    p(!0), d.current = null;
  }, CWe)) : (PV(d), p(!1)), () => PV(d)), [m, p]), m && c) {
    var v = {
      children: t.placeholder,
      attributes: {
        "data-slate-placeholder": !0,
        style: {
          position: "absolute",
          top: 0,
          pointerEvents: "none",
          width: "100%",
          maxWidth: "100%",
          display: "block",
          opacity: "0.333",
          userSelect: "none",
          textDecoration: "none",
          // Fixes https://github.com/udecode/plate/issues/2315
          WebkitUserModify: nu ? "inherit" : void 0
        },
        contentEditable: !1,
        ref: g
      }
    };
    f = /* @__PURE__ */ we.createElement(we.Fragment, null, i(v), f);
  }
  var E = {
    "data-slate-leaf": !0
  };
  return a({
    attributes: E,
    children: f,
    leaf: t,
    text: r
  });
}, EWe = /* @__PURE__ */ we.memo(OWe, (e, t) => t.parent === e.parent && t.isLast === e.isLast && t.renderLeaf === e.renderLeaf && t.renderPlaceholder === e.renderPlaceholder && t.text === e.text && it.equals(t.leaf, e.leaf) && t.leaf[wc] === e.leaf[wc]), kWe = (e) => {
  var {
    attributes: t,
    children: n
  } = e;
  return /* @__PURE__ */ we.createElement("span", jX({}, t), n);
}, LWe = (e) => {
  for (var {
    decorations: t,
    isLast: n,
    parent: r,
    renderPlaceholder: o,
    renderLeaf: i,
    text: a
  } = e, s = Tl(), l = ut(null), u = it.decorations(a, t), c = be.findKey(s, a), p = [], d = 0; d < u.length; d++) {
    var g = u[d];
    p.push(/* @__PURE__ */ we.createElement(EWe, {
      isLast: n && d === u.length - 1,
      key: "".concat(c.id, "-").concat(d),
      renderPlaceholder: o,
      leaf: g,
      text: a,
      parent: r,
      renderLeaf: i
    }));
  }
  var f = Nn((m) => {
    var v = b0.get(s);
    m ? (v == null || v.set(c, m), xu.set(a, m), hf.set(m, a)) : (v == null || v.delete(c), xu.delete(a), l.current && hf.delete(l.current)), l.current = m;
  }, [l, s, c, a]);
  return /* @__PURE__ */ we.createElement("span", {
    "data-slate-node": "text",
    ref: f
  }, p);
}, AX = /* @__PURE__ */ we.memo(LWe, (e, t) => t.parent === e.parent && t.isLast === e.isLast && t.renderLeaf === e.renderLeaf && t.renderPlaceholder === e.renderPlaceholder && t.text === e.text && vWe(t.decorations, e.decorations));
function _V(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function d1(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? _V(Object(n), !0).forEach(function(r) {
      ls(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : _V(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var PWe = (e) => {
  var {
    decorations: t,
    element: n,
    renderElement: r = (w) => /* @__PURE__ */ we.createElement(SWe, d1({}, w)),
    renderPlaceholder: o,
    renderLeaf: i,
    selection: a
  } = e, s = Tl(), l = TWe(), u = s.isInline(n), c = be.findKey(s, n), p = Nn((w) => {
    var M = b0.get(s);
    w ? (M == null || M.set(c, w), xu.set(n, w), hf.set(w, n)) : (M == null || M.delete(c), xu.delete(n));
  }, [s, c, n]), d = RX({
    decorations: t,
    node: n,
    renderElement: r,
    renderPlaceholder: o,
    renderLeaf: i,
    selection: a
  }), g = {
    "data-slate-node": "element",
    ref: p
  };
  if (u && (g["data-slate-inline"] = !0), !u && ee.hasInlines(s, n)) {
    var f = qe.string(n), m = uX(f);
    m === "rtl" && (g.dir = m);
  }
  if (ee.isVoid(s, n)) {
    g["data-slate-void"] = !0, !l && u && (g.contentEditable = !1);
    var v = u ? "span" : "div", [[E]] = qe.texts(n);
    d = /* @__PURE__ */ we.createElement(v, {
      "data-slate-spacer": !0,
      style: {
        height: "0",
        color: "transparent",
        outline: "none",
        position: "absolute"
      }
    }, /* @__PURE__ */ we.createElement(AX, {
      renderPlaceholder: o,
      decorations: [],
      isLast: !1,
      parent: n,
      text: E
    })), CS.set(E, 0), xS.set(E, n);
  }
  return r({
    attributes: g,
    children: d,
    element: n
  });
}, _We = /* @__PURE__ */ we.memo(PWe, (e, t) => e.element === t.element && e.renderElement === t.renderElement && e.renderLeaf === t.renderLeaf && e.renderPlaceholder === t.renderPlaceholder && mWe(e.decorations, t.decorations) && (e.selection === t.selection || !!e.selection && !!t.selection && me.equals(e.selection, t.selection))), SWe = (e) => {
  var {
    attributes: t,
    children: n,
    element: r
  } = e, o = Tl(), i = o.isInline(r) ? "span" : "div";
  return /* @__PURE__ */ we.createElement(i, d1(d1({}, t), {}, {
    style: {
      position: "relative"
    }
  }), n);
}, IX = /* @__PURE__ */ Ke(() => []), MWe = () => ge(IX), DWe = /* @__PURE__ */ Ke(!1), RX = (e) => {
  var {
    decorations: t,
    node: n,
    renderElement: r,
    renderPlaceholder: o,
    renderLeaf: i,
    selection: a
  } = e, s = MWe(), l = Tl();
  cc.set(l, !1);
  for (var u = be.findPath(l, n), c = [], p = rt.isElement(n) && !l.isInline(n) && ee.hasInlines(l, n), d = 0; d < n.children.length; d++) {
    var g = u.concat(d), f = n.children[d], m = be.findKey(l, f), v = ee.range(l, g), E = a && me.intersection(v, a), w = s([f, g]);
    for (var M of t) {
      var O = me.intersection(M, v);
      O && w.push(O);
    }
    rt.isElement(f) ? c.push(/* @__PURE__ */ we.createElement(DWe.Provider, {
      key: "provider-".concat(m.id),
      value: !!E
    }, /* @__PURE__ */ we.createElement(_We, {
      decorations: w,
      element: f,
      key: m.id,
      renderElement: r,
      renderPlaceholder: o,
      renderLeaf: i,
      selection: E
    }))) : c.push(/* @__PURE__ */ we.createElement(AX, {
      decorations: w,
      key: m.id,
      isLast: p && d === n.children.length - 1,
      parent: n,
      renderPlaceholder: o,
      renderLeaf: i,
      text: f
    })), CS.set(f, d), xS.set(f, n);
  }
  return c;
}, BX = /* @__PURE__ */ Ke(!1), TWe = () => ge(BX), NX = /* @__PURE__ */ Ke(null), w0 = () => {
  var e = ge(NX);
  if (!e)
    throw new Error("The `useSlate` hook must be used inside the <Slate> component's context.");
  var {
    editor: t
  } = e;
  return t;
};
function jWe() {
  var e = Tl(), t = ut(!1), n = ut(0), r = Nn(() => {
    if (!t.current) {
      t.current = !0;
      var o = be.getWindow(e);
      o.cancelAnimationFrame(n.current), n.current = o.requestAnimationFrame(() => {
        t.current = !1;
      });
    }
  }, [e]);
  return h(() => () => cancelAnimationFrame(n.current), []), {
    receivedUserInput: t,
    onUserInput: r
  };
}
var AWe = 3, IWe = {
  bold: "mod+b",
  compose: ["down", "left", "right", "up", "backspace", "enter"],
  moveBackward: "left",
  moveForward: "right",
  moveWordBackward: "ctrl+left",
  moveWordForward: "ctrl+right",
  deleteBackward: "shift?+backspace",
  deleteForward: "shift?+delete",
  extendBackward: "shift+left",
  extendForward: "shift+right",
  italic: "mod+i",
  insertSoftBreak: "shift+enter",
  splitBlock: "enter",
  undo: "mod+z"
}, RWe = {
  moveLineBackward: "opt+up",
  moveLineForward: "opt+down",
  moveWordBackward: "opt+left",
  moveWordForward: "opt+right",
  deleteBackward: ["ctrl+backspace", "ctrl+h"],
  deleteForward: ["ctrl+delete", "ctrl+d"],
  deleteLineBackward: "cmd+shift?+backspace",
  deleteLineForward: ["cmd+shift?+delete", "ctrl+k"],
  deleteWordBackward: "opt+shift?+backspace",
  deleteWordForward: "opt+shift?+delete",
  extendLineBackward: "opt+shift+up",
  extendLineForward: "opt+shift+down",
  redo: "cmd+shift+z",
  transposeCharacter: "ctrl+t"
}, BWe = {
  deleteWordBackward: "ctrl+shift?+backspace",
  deleteWordForward: "ctrl+shift?+delete",
  redo: ["ctrl+y", "ctrl+shift+z"]
}, Nr = (e) => {
  var t = IWe[e], n = RWe[e], r = BWe[e], o = t && xO(t), i = n && xO(n), a = r && xO(r);
  return (s) => !!(o && o(s) || yV && i && i(s) || !yV && a && a(s));
}, zr = {
  isBold: Nr("bold"),
  isCompose: Nr("compose"),
  isMoveBackward: Nr("moveBackward"),
  isMoveForward: Nr("moveForward"),
  isDeleteBackward: Nr("deleteBackward"),
  isDeleteForward: Nr("deleteForward"),
  isDeleteLineBackward: Nr("deleteLineBackward"),
  isDeleteLineForward: Nr("deleteLineForward"),
  isDeleteWordBackward: Nr("deleteWordBackward"),
  isDeleteWordForward: Nr("deleteWordForward"),
  isExtendBackward: Nr("extendBackward"),
  isExtendForward: Nr("extendForward"),
  isExtendLineBackward: Nr("extendLineBackward"),
  isExtendLineForward: Nr("extendLineForward"),
  isItalic: Nr("italic"),
  isMoveLineBackward: Nr("moveLineBackward"),
  isMoveLineForward: Nr("moveLineForward"),
  isMoveWordBackward: Nr("moveWordBackward"),
  isMoveWordForward: Nr("moveWordForward"),
  isRedo: Nr("redo"),
  isSoftBreak: Nr("insertSoftBreak"),
  isSplitBlock: Nr("splitBlock"),
  isTransposeCharacter: Nr("transposeCharacter"),
  isUndo: Nr("undo")
}, NWe = (e, t) => {
  var n = [], r = () => {
    n = [];
  }, o = (a) => {
    if (t.current) {
      var s = a.filter((l) => kS(e, l, a));
      n.push(...s);
    }
  };
  function i() {
    n.length > 0 && (n.reverse().forEach((a) => {
      a.type !== "characterData" && (a.removedNodes.forEach((s) => {
        a.target.insertBefore(s, a.nextSibling);
      }), a.addedNodes.forEach((s) => {
        a.target.removeChild(s);
      }));
    }), r());
  }
  return {
    registerMutations: o,
    restoreDOM: i,
    clear: r
  };
}, FWe = {
  subtree: !0,
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0
};
class FX extends Wu {
  constructor() {
    super(...arguments), ls(this, "context", null), ls(this, "manager", null), ls(this, "mutationObserver", null);
  }
  observe() {
    var t, {
      node: n
    } = this.props;
    if (!n.current)
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    (t = this.mutationObserver) === null || t === void 0 || t.observe(n.current, FWe);
  }
  componentDidMount() {
    var {
      receivedUserInput: t
    } = this.props, n = this.context;
    this.manager = NWe(n, t), this.mutationObserver = new MutationObserver(this.manager.registerMutations), this.observe();
  }
  getSnapshotBeforeUpdate() {
    var t, n, r, o = (t = this.mutationObserver) === null || t === void 0 ? void 0 : t.takeRecords();
    if (o != null && o.length) {
      var i;
      (i = this.manager) === null || i === void 0 || i.registerMutations(o);
    }
    return (n = this.mutationObserver) === null || n === void 0 || n.disconnect(), (r = this.manager) === null || r === void 0 || r.restoreDOM(), null;
  }
  componentDidUpdate() {
    var t;
    (t = this.manager) === null || t === void 0 || t.clear(), this.observe();
  }
  componentWillUnmount() {
    var t;
    (t = this.mutationObserver) === null || t === void 0 || t.disconnect();
  }
  render() {
    return this.props.children;
  }
}
ls(FX, "contextType", wS);
var zWe = qo ? FX : (e) => {
  var {
    children: t
  } = e;
  return /* @__PURE__ */ we.createElement(we.Fragment, null, t);
}, UWe = /* @__PURE__ */ Ke(!1), HWe = ["autoFocus", "decorate", "onDOMBeforeInput", "placeholder", "readOnly", "renderElement", "renderLeaf", "renderPlaceholder", "scrollSelectionIntoView", "style", "as", "disableDefaultStyles"], $We = ["text"];
function SV(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ys(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? SV(Object(n), !0).forEach(function(r) {
      ls(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : SV(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var WWe = (e) => /* @__PURE__ */ we.createElement(we.Fragment, null, RX(e)), VWe = /* @__PURE__ */ to((e, t) => {
  var n = Nn((j) => /* @__PURE__ */ we.createElement(ZWe, ys({}, j)), []), {
    autoFocus: r,
    decorate: o = qWe,
    onDOMBeforeInput: i,
    placeholder: a,
    readOnly: s = !1,
    renderElement: l,
    renderLeaf: u,
    renderPlaceholder: c = n,
    scrollSelectionIntoView: p = GWe,
    style: d = {},
    as: g = "div",
    disableDefaultStyles: f = !1
  } = e, m = bc(e, HWe), v = w0(), [E, w] = k(!1), M = ut(null), O = ut([]), [y, C] = k(), _ = ut(!1), {
    onUserInput: F,
    receivedUserInput: L
  } = jWe(), [, N] = $J((j) => j + 1, 0);
  EX.set(v, N), a1.set(v, s);
  var R = Cn(() => ({
    isDraggingInternally: !1,
    isUpdatingSelection: !1,
    latestElement: null,
    hasMarkPlaceholder: !1
  }), []);
  h(() => {
    M.current && r && M.current.focus();
  }, [r]);
  var W = ut(), V = Cn(() => o3e(() => {
    if (cc.get(v)) {
      V();
      return;
    }
    var j = be.toDOMNode(v, v), U = j.getRootNode();
    if (!_.current && nu && U instanceof ShadowRoot) {
      _.current = !0;
      var T = Z3e();
      T ? document.execCommand("indent") : Te.deselect(v), _.current = !1;
      return;
    }
    var q = W.current;
    if ((qo || !be.isComposing(v)) && (!R.isUpdatingSelection || q != null && q.isFlushing()) && !R.isDraggingInternally) {
      var A = be.findDocumentOrShadowRoot(v), {
        activeElement: Y
      } = A, B = be.toDOMNode(v, v), ue = hd(A);
      if (Y === B ? (R.latestElement = Y, al.set(v, !0)) : al.delete(v), !ue)
        return Te.deselect(v);
      var {
        anchorNode: fe,
        focusNode: oe
      } = ue, Ae = be.hasEditableTarget(v, fe) || be.isTargetInsideNonReadonlyVoid(v, fe), Ze = be.hasTarget(v, oe);
      if (Ae && Ze) {
        var Ge = be.toSlateRange(v, ue, {
          exactMatch: !1,
          suppressThrow: !0
        });
        Ge && (!be.isComposing(v) && !(q != null && q.hasPendingChanges()) && !(q != null && q.isFlushing()) ? Te.select(v, Ge) : q == null || q.handleUserSelect(Ge));
      }
      s && (!Ae || !Ze) && Te.deselect(v);
    }
  }, 100), [v, s, R]), z = Cn(() => J$e(V, 0), [V]);
  W.current = dWe({
    node: M,
    onDOMSelectionChange: V,
    scheduleOnDOMSelectionChange: z
  }), gf(() => {
    var j, U, T;
    M.current && (T = ES(M.current)) ? (OX.set(v, T), Im.set(v, M.current), xu.set(v, M.current), hf.set(M.current, v)) : xu.delete(v);
    var {
      selection: q
    } = v, A = be.findDocumentOrShadowRoot(v), Y = hd(A);
    if (!(!Y || !be.isFocused(v) || (j = W.current) !== null && j !== void 0 && j.hasPendingAction())) {
      var B = (Ae) => {
        var Ze = Y.type !== "None";
        if (!(!q && !Ze)) {
          var Ge = Y.focusNode, Ie;
          if (nc && Y.rangeCount > 1) {
            var et = Y.getRangeAt(0), Ye = Y.getRangeAt(Y.rangeCount - 1);
            et.startContainer === Ge ? Ie = Ye.endContainer : Ie = et.startContainer;
          } else
            Ie = Y.anchorNode;
          var _e = Im.get(v), Qe = !1;
          if (_e.contains(Ie) && _e.contains(Ge) && (Qe = !0), Ze && Qe && q && !Ae) {
            var at = be.toSlateRange(v, Y, {
              exactMatch: !0,
              // domSelection is not necessarily a valid Slate range
              // (e.g. when clicking on contentEditable:false element)
              suppressThrow: !0
            });
            if (at && me.equals(at, q)) {
              var Pe;
              if (!R.hasMarkPlaceholder || (Pe = Ie) !== null && Pe !== void 0 && (Pe = Pe.parentElement) !== null && Pe !== void 0 && Pe.hasAttribute("data-slate-mark-placeholder"))
                return;
            }
          }
          if (q && !be.hasRange(v, q)) {
            v.selection = be.toSlateRange(v, Y, {
              exactMatch: !1,
              suppressThrow: !0
            });
            return;
          }
          R.isUpdatingSelection = !0;
          var Me = q && be.toDOMRange(v, q);
          return Me ? (be.isComposing(v) && !qo ? Y.collapseToEnd() : me.isBackward(q) ? Y.setBaseAndExtent(Me.endContainer, Me.endOffset, Me.startContainer, Me.startOffset) : Y.setBaseAndExtent(Me.startContainer, Me.startOffset, Me.endContainer, Me.endOffset), p(v, Me)) : Y.removeAllRanges(), Me;
        }
      };
      Y.rangeCount <= 1 && B();
      var ue = ((U = W.current) === null || U === void 0 ? void 0 : U.isFlushing()) === "action";
      if (!qo || !ue) {
        setTimeout(() => {
          R.isUpdatingSelection = !1;
        });
        return;
      }
      var fe = null, oe = requestAnimationFrame(() => {
        if (ue) {
          var Ae = (Ze) => {
            try {
              var Ge = be.toDOMNode(v, v);
              Ge.focus(), B(Ze);
            } catch {
            }
          };
          Ae(), fe = setTimeout(() => {
            Ae(!0), R.isUpdatingSelection = !1;
          });
        }
      });
      return () => {
        cancelAnimationFrame(oe), fe && clearTimeout(fe);
      };
    }
  });
  var Z = Nn((j) => {
    var U = be.toDOMNode(v, v), T = U.getRootNode();
    if (_ != null && _.current && nu && T instanceof ShadowRoot) {
      var q = j.getTargetRanges(), A = q[0], Y = new window.Range();
      Y.setStart(A.startContainer, A.startOffset), Y.setEnd(A.endContainer, A.endOffset);
      var B = be.toSlateRange(v, Y, {
        exactMatch: !1,
        suppressThrow: !1
      });
      Te.select(v, B), j.preventDefault(), j.stopImmediatePropagation();
      return;
    }
    if (F(), !s && be.hasEditableTarget(v, j.target) && !KWe(j, i)) {
      var ue;
      if (W.current)
        return W.current.handleDOMBeforeInput(j);
      z.flush(), V.flush();
      var {
        selection: fe
      } = v, {
        inputType: oe
      } = j, Ae = j.dataTransfer || j.data || void 0, Ze = oe === "insertCompositionText" || oe === "deleteCompositionText";
      if (Ze && be.isComposing(v))
        return;
      var Ge = !1;
      if (oe === "insertText" && fe && me.isCollapsed(fe) && // Only use native character insertion for single characters a-z or space for now.
      // Long-press events (hold a + press 4 = ) to choose a special character otherwise
      // causes duplicate inserts.
      j.data && j.data.length === 1 && /[a-z ]/i.test(j.data) && // Chrome has issues correctly editing the start of nodes: https://bugs.chromium.org/p/chromium/issues/detail?id=1249405
      // When there is an inline element, e.g. a link, and you select
      // right after it (the start of the next node).
      fe.anchor.offset !== 0 && (Ge = !0, v.marks && (Ge = !1), !cc.get(v))) {
        var Ie, et, {
          anchor: Ye
        } = fe, [_e, Qe] = be.toDOMPoint(v, Ye), at = (Ie = _e.parentElement) === null || Ie === void 0 ? void 0 : Ie.closest("a"), Pe = be.getWindow(v);
        if (Ge && at && be.hasDOMNode(v, at)) {
          var Me, Je = Pe == null ? void 0 : Pe.document.createTreeWalker(at, NodeFilter.SHOW_TEXT).lastChild();
          Je === _e && ((Me = Je.textContent) === null || Me === void 0 ? void 0 : Me.length) === Qe && (Ge = !1);
        }
        if (Ge && _e.parentElement && (Pe == null || (et = Pe.getComputedStyle(_e.parentElement)) === null || et === void 0 ? void 0 : et.whiteSpace) === "pre") {
          var We = ee.above(v, {
            at: Ye.path,
            match: (st) => rt.isElement(st) && ee.isBlock(v, st)
          });
          We && qe.string(We[0]).includes("	") && (Ge = !1);
        }
      }
      if ((!oe.startsWith("delete") || oe.startsWith("deleteBy")) && !cc.get(v)) {
        var [Re] = j.getTargetRanges();
        if (Re) {
          var nt = be.toSlateRange(v, Re, {
            exactMatch: !1,
            suppressThrow: !1
          });
          if (!fe || !me.equals(fe, nt)) {
            Ge = !1;
            var De = !Ze && v.selection && ee.rangeRef(v, v.selection);
            Te.select(v, nt), De && fd.set(v, De);
          }
        }
      }
      if (Ze)
        return;
      if (Ge || j.preventDefault(), fe && me.isExpanded(fe) && oe.startsWith("delete")) {
        var yt = oe.endsWith("Backward") ? "backward" : "forward";
        ee.deleteFragment(v, {
          direction: yt
        });
        return;
      }
      switch (oe) {
        case "deleteByComposition":
        case "deleteByCut":
        case "deleteByDrag": {
          ee.deleteFragment(v);
          break;
        }
        case "deleteContent":
        case "deleteContentForward": {
          ee.deleteForward(v);
          break;
        }
        case "deleteContentBackward": {
          ee.deleteBackward(v);
          break;
        }
        case "deleteEntireSoftLine": {
          ee.deleteBackward(v, {
            unit: "line"
          }), ee.deleteForward(v, {
            unit: "line"
          });
          break;
        }
        case "deleteHardLineBackward": {
          ee.deleteBackward(v, {
            unit: "block"
          });
          break;
        }
        case "deleteSoftLineBackward": {
          ee.deleteBackward(v, {
            unit: "line"
          });
          break;
        }
        case "deleteHardLineForward": {
          ee.deleteForward(v, {
            unit: "block"
          });
          break;
        }
        case "deleteSoftLineForward": {
          ee.deleteForward(v, {
            unit: "line"
          });
          break;
        }
        case "deleteWordBackward": {
          ee.deleteBackward(v, {
            unit: "word"
          });
          break;
        }
        case "deleteWordForward": {
          ee.deleteForward(v, {
            unit: "word"
          });
          break;
        }
        case "insertLineBreak":
          ee.insertSoftBreak(v);
          break;
        case "insertParagraph": {
          ee.insertBreak(v);
          break;
        }
        case "insertFromComposition":
        case "insertFromDrop":
        case "insertFromPaste":
        case "insertFromYank":
        case "insertReplacementText":
        case "insertText": {
          oe === "insertFromComposition" && be.isComposing(v) && (w(!1), vu.set(v, !1)), (Ae == null ? void 0 : Ae.constructor.name) === "DataTransfer" ? be.insertData(v, Ae) : typeof Ae == "string" && (Ge ? O.current.push(() => ee.insertText(v, Ae)) : ee.insertText(v, Ae));
          break;
        }
      }
      var ot = (ue = fd.get(v)) === null || ue === void 0 ? void 0 : ue.unref();
      fd.delete(v), ot && (!v.selection || !me.equals(v.selection, ot)) && Te.select(v, ot);
    }
  }, [v, V, F, i, s, z]), K = Nn((j) => {
    j == null ? (V.cancel(), z.cancel(), Im.delete(v), xu.delete(v), M.current && Aa && M.current.removeEventListener("beforeinput", Z)) : Aa && j.addEventListener("beforeinput", Z), M.current = j, typeof t == "function" ? t(j) : t && (t.current = j);
  }, [V, z, v, Z, t]);
  gf(() => {
    var j = be.getWindow(v);
    j.document.addEventListener("selectionchange", z);
    var U = () => {
      R.isDraggingInternally = !1;
    };
    return j.document.addEventListener("dragend", U), j.document.addEventListener("drop", U), () => {
      j.document.removeEventListener("selectionchange", z), j.document.removeEventListener("dragend", U), j.document.removeEventListener("drop", U);
    };
  }, [z, R]);
  var X = o([v, []]), te = a && v.children.length === 1 && Array.from(qe.texts(v)).length === 1 && qe.string(v) === "" && !E, J = Nn((j) => {
    if (j && te) {
      var U;
      C((U = j.getBoundingClientRect()) === null || U === void 0 ? void 0 : U.height);
    } else
      C(void 0);
  }, [te]);
  if (te) {
    var P = ee.start(v, []);
    X.push({
      [wc]: !0,
      placeholder: a,
      onPlaceholderResize: J,
      anchor: P,
      focus: P
    });
  }
  var {
    marks: D
  } = v;
  if (R.hasMarkPlaceholder = !1, v.selection && me.isCollapsed(v.selection) && D) {
    var {
      anchor: H
    } = v.selection, S = qe.leaf(v, H.path), $ = bc(S, $We);
    if (!it.equals(S, D, {
      loose: !0
    })) {
      R.hasMarkPlaceholder = !0;
      var x = Object.fromEntries(Object.keys($).map((j) => [j, null]));
      X.push(ys(ys(ys({
        [kX]: !0
      }, x), D), {}, {
        anchor: H,
        focus: H
      }));
    }
  }
  return h(() => {
    setTimeout(() => {
      var {
        selection: j
      } = v;
      if (j) {
        var {
          anchor: U
        } = j, T = qe.leaf(v, U.path);
        if (D && !it.equals(T, D, {
          loose: !0
        })) {
          us.set(v, D);
          return;
        }
      }
      us.delete(v);
    });
  }), /* @__PURE__ */ we.createElement(BX.Provider, {
    value: s
  }, /* @__PURE__ */ we.createElement(UWe.Provider, {
    value: E
  }, /* @__PURE__ */ we.createElement(IX.Provider, {
    value: o
  }, /* @__PURE__ */ we.createElement(zWe, {
    node: M,
    receivedUserInput: L
  }, /* @__PURE__ */ we.createElement(g, ys(ys({
    role: s ? void 0 : "textbox",
    "aria-multiline": s ? void 0 : !0
  }, m), {}, {
    // COMPAT: Certain browsers don't support the `beforeinput` event, so we'd
    // have to use hacks to make these replacement-based features work.
    // For SSR situations HAS_BEFORE_INPUT_SUPPORT is false and results in prop
    // mismatch warning app moves to browser. Pass-through consumer props when
    // not CAN_USE_DOM (SSR) and default to falsy value
    spellCheck: Aa || !Am ? m.spellCheck : !1,
    autoCorrect: Aa || !Am ? m.autoCorrect : "false",
    autoCapitalize: Aa || !Am ? m.autoCapitalize : "false",
    "data-slate-editor": !0,
    "data-slate-node": "value",
    // explicitly set this
    contentEditable: !s,
    // in some cases, a decoration needs access to the range / selection to decorate a text node,
    // then you will select the whole text node when you select part the of text
    // this magic zIndex="-1" will fix it
    zindex: -1,
    suppressContentEditableWarning: !0,
    ref: K,
    style: ys(ys({}, f ? {} : ys({
      // Allow positioning relative to the editable element.
      position: "relative",
      // Preserve adjacent whitespace and new lines.
      whiteSpace: "pre-wrap",
      // Allow words to break if they are too long.
      wordWrap: "break-word"
    }, y ? {
      minHeight: y
    } : {})), d),
    onBeforeInput: Nn((j) => {
      if (!Aa && !s && !Vo(j, m.onBeforeInput) && be.hasSelectableTarget(v, j.target) && (j.preventDefault(), !be.isComposing(v))) {
        var U = j.data;
        ee.insertText(v, U);
      }
    }, [m.onBeforeInput, v, s]),
    onInput: Nn((j) => {
      if (!Vo(j, m.onInput)) {
        if (W.current) {
          W.current.handleInput();
          return;
        }
        for (var U of O.current)
          U();
        if (O.current = [], !be.isFocused(v)) {
          var T = j.nativeEvent, q = v;
          if (T.inputType === "historyUndo" && typeof q.undo == "function") {
            q.undo();
            return;
          }
          if (T.inputType === "historyRedo" && typeof q.redo == "function") {
            q.redo();
            return;
          }
        }
      }
    }, [m.onInput, v]),
    onBlur: Nn((j) => {
      if (!(s || R.isUpdatingSelection || !be.hasSelectableTarget(v, j.target) || Vo(j, m.onBlur))) {
        var U = be.findDocumentOrShadowRoot(v);
        if (R.latestElement !== U.activeElement) {
          var {
            relatedTarget: T
          } = j, q = be.toDOMNode(v, v);
          if (T !== q && !(as(T) && T.hasAttribute("data-slate-spacer"))) {
            if (T != null && ul(T) && be.hasDOMNode(v, T)) {
              var A = be.toSlateNode(v, T);
              if (rt.isElement(A) && !v.isVoid(A))
                return;
            }
            if (nu) {
              var Y = hd(U);
              Y == null || Y.removeAllRanges();
            }
            al.delete(v);
          }
        }
      }
    }, [s, R.isUpdatingSelection, R.latestElement, v, m.onBlur]),
    onClick: Nn((j) => {
      if (be.hasTarget(v, j.target) && !Vo(j, m.onClick) && ul(j.target)) {
        var U = be.toSlateNode(v, j.target), T = be.findPath(v, U);
        if (!ee.hasPath(v, T) || qe.get(v, T) !== U)
          return;
        if (j.detail === AWe && T.length >= 1) {
          var q = T;
          if (!(rt.isElement(U) && ee.isBlock(v, U))) {
            var A, Y = ee.above(v, {
              match: (Ge) => rt.isElement(Ge) && ee.isBlock(v, Ge),
              at: T
            });
            q = (A = Y == null ? void 0 : Y[1]) !== null && A !== void 0 ? A : T.slice(0, 1);
          }
          var B = ee.range(v, q);
          Te.select(v, B);
          return;
        }
        if (s)
          return;
        var ue = ee.start(v, T), fe = ee.end(v, T), oe = ee.void(v, {
          at: ue
        }), Ae = ee.void(v, {
          at: fe
        });
        if (oe && Ae && ae.equals(oe[1], Ae[1])) {
          var Ze = ee.range(v, ue);
          Te.select(v, Ze);
        }
      }
    }, [v, m.onClick, s]),
    onCompositionEnd: Nn((j) => {
      if (be.hasSelectableTarget(v, j.target)) {
        var U;
        if (be.isComposing(v) && Promise.resolve().then(() => {
          w(!1), vu.set(v, !1);
        }), (U = W.current) === null || U === void 0 || U.handleCompositionEnd(j), Vo(j, m.onCompositionEnd) || qo)
          return;
        if (!nu && !I3e && !CX && !B3e && !R3e && j.data) {
          var T = us.get(v);
          us.delete(v), T !== void 0 && (sa.set(v, v.marks), v.marks = T), ee.insertText(v, j.data);
          var q = sa.get(v);
          sa.delete(v), q !== void 0 && (v.marks = q);
        }
      }
    }, [m.onCompositionEnd, v]),
    onCompositionUpdate: Nn((j) => {
      be.hasSelectableTarget(v, j.target) && !Vo(j, m.onCompositionUpdate) && (be.isComposing(v) || (w(!0), vu.set(v, !0)));
    }, [m.onCompositionUpdate, v]),
    onCompositionStart: Nn((j) => {
      if (be.hasSelectableTarget(v, j.target)) {
        var U;
        if ((U = W.current) === null || U === void 0 || U.handleCompositionStart(j), Vo(j, m.onCompositionStart) || qo)
          return;
        w(!0);
        var {
          selection: T
        } = v;
        if (T && me.isExpanded(T)) {
          ee.deleteFragment(v);
          return;
        }
      }
    }, [m.onCompositionStart, v]),
    onCopy: Nn((j) => {
      be.hasSelectableTarget(v, j.target) && !Vo(j, m.onCopy) && !MV(j) && (j.preventDefault(), be.setFragmentData(v, j.clipboardData, "copy"));
    }, [m.onCopy, v]),
    onCut: Nn((j) => {
      if (!s && be.hasSelectableTarget(v, j.target) && !Vo(j, m.onCut) && !MV(j)) {
        j.preventDefault(), be.setFragmentData(v, j.clipboardData, "cut");
        var {
          selection: U
        } = v;
        if (U)
          if (me.isExpanded(U))
            ee.deleteFragment(v);
          else {
            var T = qe.parent(v, U.anchor.path);
            ee.isVoid(v, T) && Te.delete(v);
          }
      }
    }, [s, v, m.onCut]),
    onDragOver: Nn((j) => {
      if (be.hasTarget(v, j.target) && !Vo(j, m.onDragOver)) {
        var U = be.toSlateNode(v, j.target);
        rt.isElement(U) && ee.isVoid(v, U) && j.preventDefault();
      }
    }, [m.onDragOver, v]),
    onDragStart: Nn((j) => {
      if (!s && be.hasTarget(v, j.target) && !Vo(j, m.onDragStart)) {
        var U = be.toSlateNode(v, j.target), T = be.findPath(v, U), q = rt.isElement(U) && ee.isVoid(v, U) || ee.void(v, {
          at: T,
          voids: !0
        });
        if (q) {
          var A = ee.range(v, T);
          Te.select(v, A);
        }
        R.isDraggingInternally = !0, be.setFragmentData(v, j.dataTransfer, "drag");
      }
    }, [s, v, m.onDragStart, R]),
    onDrop: Nn((j) => {
      if (!s && be.hasTarget(v, j.target) && !Vo(j, m.onDrop)) {
        j.preventDefault();
        var U = v.selection, T = be.findEventRange(v, j), q = j.dataTransfer;
        Te.select(v, T), R.isDraggingInternally && U && !me.equals(U, T) && !ee.void(v, {
          at: T,
          voids: !0
        }) && Te.delete(v, {
          at: U
        }), be.insertData(v, q), be.isFocused(v) || be.focus(v);
      }
    }, [s, v, m.onDrop, R]),
    onDragEnd: Nn((j) => {
      !s && R.isDraggingInternally && m.onDragEnd && be.hasTarget(v, j.target) && m.onDragEnd(j);
    }, [s, R, m, v]),
    onFocus: Nn((j) => {
      if (!s && !R.isUpdatingSelection && be.hasEditableTarget(v, j.target) && !Vo(j, m.onFocus)) {
        var U = be.toDOMNode(v, v), T = be.findDocumentOrShadowRoot(v);
        if (R.latestElement = T.activeElement, nc && j.target !== U) {
          U.focus();
          return;
        }
        al.set(v, !0);
      }
    }, [s, R, v, m.onFocus]),
    onKeyDown: Nn((j) => {
      if (!s && be.hasEditableTarget(v, j.target)) {
        var U;
        (U = W.current) === null || U === void 0 || U.handleKeyDown(j);
        var {
          nativeEvent: T
        } = j;
        if (be.isComposing(v) && T.isComposing === !1 && (vu.set(v, !1), w(!1)), Vo(j, m.onKeyDown) || be.isComposing(v))
          return;
        var {
          selection: q
        } = v, A = v.children[q !== null ? q.focus.path[0] : 0], Y = uX(qe.string(A)) === "rtl";
        if (zr.isRedo(T)) {
          j.preventDefault();
          var B = v;
          typeof B.redo == "function" && B.redo();
          return;
        }
        if (zr.isUndo(T)) {
          j.preventDefault();
          var ue = v;
          typeof ue.undo == "function" && ue.undo();
          return;
        }
        if (zr.isMoveLineBackward(T)) {
          j.preventDefault(), Te.move(v, {
            unit: "line",
            reverse: !0
          });
          return;
        }
        if (zr.isMoveLineForward(T)) {
          j.preventDefault(), Te.move(v, {
            unit: "line"
          });
          return;
        }
        if (zr.isExtendLineBackward(T)) {
          j.preventDefault(), Te.move(v, {
            unit: "line",
            edge: "focus",
            reverse: !0
          });
          return;
        }
        if (zr.isExtendLineForward(T)) {
          j.preventDefault(), Te.move(v, {
            unit: "line",
            edge: "focus"
          });
          return;
        }
        if (zr.isMoveBackward(T)) {
          j.preventDefault(), q && me.isCollapsed(q) ? Te.move(v, {
            reverse: !Y
          }) : Te.collapse(v, {
            edge: Y ? "end" : "start"
          });
          return;
        }
        if (zr.isMoveForward(T)) {
          j.preventDefault(), q && me.isCollapsed(q) ? Te.move(v, {
            reverse: Y
          }) : Te.collapse(v, {
            edge: Y ? "start" : "end"
          });
          return;
        }
        if (zr.isMoveWordBackward(T)) {
          j.preventDefault(), q && me.isExpanded(q) && Te.collapse(v, {
            edge: "focus"
          }), Te.move(v, {
            unit: "word",
            reverse: !Y
          });
          return;
        }
        if (zr.isMoveWordForward(T)) {
          j.preventDefault(), q && me.isExpanded(q) && Te.collapse(v, {
            edge: "focus"
          }), Te.move(v, {
            unit: "word",
            reverse: Y
          });
          return;
        }
        if (Aa) {
          if ((xX || nu) && q && (zr.isDeleteBackward(T) || zr.isDeleteForward(T)) && me.isCollapsed(q)) {
            var fe = qe.parent(v, q.anchor.path);
            if (rt.isElement(fe) && ee.isVoid(v, fe) && (ee.isInline(v, fe) || ee.isBlock(v, fe))) {
              j.preventDefault(), ee.deleteBackward(v, {
                unit: "block"
              });
              return;
            }
          }
        } else {
          if (zr.isBold(T) || zr.isItalic(T) || zr.isTransposeCharacter(T)) {
            j.preventDefault();
            return;
          }
          if (zr.isSoftBreak(T)) {
            j.preventDefault(), ee.insertSoftBreak(v);
            return;
          }
          if (zr.isSplitBlock(T)) {
            j.preventDefault(), ee.insertBreak(v);
            return;
          }
          if (zr.isDeleteBackward(T)) {
            j.preventDefault(), q && me.isExpanded(q) ? ee.deleteFragment(v, {
              direction: "backward"
            }) : ee.deleteBackward(v);
            return;
          }
          if (zr.isDeleteForward(T)) {
            j.preventDefault(), q && me.isExpanded(q) ? ee.deleteFragment(v, {
              direction: "forward"
            }) : ee.deleteForward(v);
            return;
          }
          if (zr.isDeleteLineBackward(T)) {
            j.preventDefault(), q && me.isExpanded(q) ? ee.deleteFragment(v, {
              direction: "backward"
            }) : ee.deleteBackward(v, {
              unit: "line"
            });
            return;
          }
          if (zr.isDeleteLineForward(T)) {
            j.preventDefault(), q && me.isExpanded(q) ? ee.deleteFragment(v, {
              direction: "forward"
            }) : ee.deleteForward(v, {
              unit: "line"
            });
            return;
          }
          if (zr.isDeleteWordBackward(T)) {
            j.preventDefault(), q && me.isExpanded(q) ? ee.deleteFragment(v, {
              direction: "backward"
            }) : ee.deleteBackward(v, {
              unit: "word"
            });
            return;
          }
          if (zr.isDeleteWordForward(T)) {
            j.preventDefault(), q && me.isExpanded(q) ? ee.deleteFragment(v, {
              direction: "forward"
            }) : ee.deleteForward(v, {
              unit: "word"
            });
            return;
          }
        }
      }
    }, [s, v, m.onKeyDown]),
    onPaste: Nn((j) => {
      !s && be.hasEditableTarget(v, j.target) && !Vo(j, m.onPaste) && (!Aa || z3e(j.nativeEvent) || nu) && (j.preventDefault(), be.insertData(v, j.clipboardData));
    }, [s, v, m.onPaste])
  }), /* @__PURE__ */ we.createElement(WWe, {
    decorations: X,
    node: v,
    renderElement: l,
    renderPlaceholder: c,
    renderLeaf: u,
    selection: v.selection
  }))))));
}), ZWe = (e) => {
  var {
    attributes: t,
    children: n
  } = e;
  return (
    // COMPAT: Artificially add a line-break to the end on the placeholder element
    // to prevent Android IMEs to pick up its content in autocorrect and to auto-capitalize the first letter
    /* @__PURE__ */ we.createElement("span", ys({}, t), n, qo && /* @__PURE__ */ we.createElement("br", null))
  );
}, qWe = () => [], GWe = (e, t) => {
  if (t.getBoundingClientRect && (!e.selection || e.selection && me.isCollapsed(e.selection))) {
    var n = t.startContainer.parentElement;
    n.getBoundingClientRect = t.getBoundingClientRect.bind(t), a3e(n, {
      scrollMode: "if-needed"
    }), delete n.getBoundingClientRect;
  }
}, Vo = (e, t) => {
  if (!t)
    return !1;
  var n = t(e);
  return n ?? (e.isDefaultPrevented() || e.isPropagationStopped());
}, MV = (e) => ul(e.target) && (e.target instanceof HTMLInputElement || e.target instanceof HTMLTextAreaElement), KWe = (e, t) => {
  if (!t)
    return !1;
  var n = t(e);
  return n ?? e.defaultPrevented;
}, YWe = /* @__PURE__ */ Ke(!1), XWe = /* @__PURE__ */ Ke({});
function JWe(e) {
  var t = ut([]).current, n = ut({
    editor: e
  }).current, r = Nn((i) => {
    n.editor = i, t.forEach((a) => a(i));
  }, [t, n]), o = Cn(() => ({
    getSlate: () => n.editor,
    addEventListener: (i) => (t.push(i), () => {
      t.splice(t.indexOf(i), 1);
    })
  }), [t, n]);
  return {
    selectorContext: o,
    onChange: r
  };
}
var QWe = ["editor", "children", "onChange", "onSelectionChange", "onValueChange", "initialValue"], eVe = (e) => {
  var {
    editor: t,
    children: n,
    onChange: r,
    onSelectionChange: o,
    onValueChange: i,
    initialValue: a
  } = e, s = bc(e, QWe), [l, u] = we.useState(() => {
    if (!qe.isNodeList(a))
      throw new Error("[Slate] initialValue is invalid! Expected a list of elements but got: ".concat(ko.stringify(a)));
    if (!ee.isEditor(t))
      throw new Error("[Slate] editor is invalid! You passed: ".concat(ko.stringify(t)));
    return t.children = a, Object.assign(t, s), {
      v: 0,
      editor: t
    };
  }), {
    selectorContext: c,
    onChange: p
  } = JWe(t), d = Nn((m) => {
    var v;
    switch (r && r(t.children), m == null || (v = m.operation) === null || v === void 0 ? void 0 : v.type) {
      case "set_selection":
        o == null || o(t.selection);
        break;
      default:
        i == null || i(t.children);
    }
    u((E) => ({
      v: E.v + 1,
      editor: t
    })), p(t);
  }, [t, p, r, o, i]);
  h(() => (l1.set(t, d), () => {
    l1.set(t, () => {
    });
  }), [t, d]);
  var [g, f] = k(be.isFocused(t));
  return h(() => {
    f(be.isFocused(t));
  }, [t]), gf(() => {
    var m = () => f(be.isFocused(t));
    return wX >= 17 ? (document.addEventListener("focusin", m), document.addEventListener("focusout", m), () => {
      document.removeEventListener("focusin", m), document.removeEventListener("focusout", m);
    }) : (document.addEventListener("focus", m, !0), document.addEventListener("blur", m, !0), () => {
      document.removeEventListener("focus", m, !0), document.removeEventListener("blur", m, !0);
    });
  }, []), /* @__PURE__ */ we.createElement(XWe.Provider, {
    value: c
  }, /* @__PURE__ */ we.createElement(NX.Provider, {
    value: l
  }, /* @__PURE__ */ we.createElement(wS.Provider, {
    value: l.editor
  }, /* @__PURE__ */ we.createElement(YWe.Provider, {
    value: g
  }, n))));
}, DV = (e, t) => {
  var n = (t.top + t.bottom) / 2;
  return e.top <= n && e.bottom >= n;
}, TV = (e, t, n) => {
  var r = be.toDOMRange(e, t).getBoundingClientRect(), o = be.toDOMRange(e, n).getBoundingClientRect();
  return DV(r, o) && DV(o, r);
}, tVe = (e, t) => {
  var n = ee.range(e, me.end(t)), r = Array.from(ee.positions(e, {
    at: t
  })), o = 0, i = r.length, a = Math.floor(i / 2);
  if (TV(e, ee.range(e, r[o]), n))
    return ee.range(e, r[o], n);
  if (r.length < 2)
    return ee.range(e, r[r.length - 1], n);
  for (; a !== r.length && a !== o; )
    TV(e, ee.range(e, r[a]), n) ? i = a : o = a, a = Math.floor((o + i) / 2);
  return ee.range(e, r[i], n);
};
function jV(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function AV(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? jV(Object(n), !0).forEach(function(r) {
      ls(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : jV(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var nVe = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "x-slate-fragment", r = t, {
    apply: o,
    onChange: i,
    deleteBackward: a,
    addMark: s,
    removeMark: l
  } = r;
  return b0.set(r, /* @__PURE__ */ new WeakMap()), r.addMark = (u, c) => {
    var p, d;
    (p = OS.get(r)) === null || p === void 0 || p(), !us.get(r) && (d = ri.get(r)) !== null && d !== void 0 && d.length && us.set(r, null), sa.delete(r), s(u, c);
  }, r.removeMark = (u) => {
    var c;
    !us.get(r) && (c = ri.get(r)) !== null && c !== void 0 && c.length && us.set(r, null), sa.delete(r), l(u);
  }, r.deleteBackward = (u) => {
    if (u !== "line")
      return a(u);
    if (r.selection && me.isCollapsed(r.selection)) {
      var c = ee.above(r, {
        match: (f) => rt.isElement(f) && ee.isBlock(r, f),
        at: r.selection
      });
      if (c) {
        var [, p] = c, d = ee.range(r, p, r.selection.anchor), g = tVe(r, d);
        me.isCollapsed(g) || Te.delete(r, {
          at: g
        });
      }
    }
  }, r.apply = (u) => {
    var c = [], p = [], d = ri.get(r);
    if (d != null && d.length) {
      var g = d.map((z) => tWe(z, u)).filter(Boolean);
      ri.set(r, g);
    }
    var f = Xa.get(r);
    f && Xa.set(r, CV(r, f, u));
    var m = Ya.get(r);
    if (m != null && m.at) {
      var v = Nt.isPoint(m == null ? void 0 : m.at) ? p1(r, m.at, u) : CV(r, m.at, u);
      Ya.set(r, v ? AV(AV({}, m), {}, {
        at: v
      }) : null);
    }
    switch (u.type) {
      case "insert_text":
      case "remove_text":
      case "set_node":
      case "split_node": {
        c.push(...Qu(r, u.path));
        break;
      }
      case "set_selection": {
        var E;
        (E = fd.get(r)) === null || E === void 0 || E.unref(), fd.delete(r);
        break;
      }
      case "insert_node":
      case "remove_node": {
        c.push(...Qu(r, ae.parent(u.path)));
        break;
      }
      case "merge_node": {
        var w = ae.previous(u.path);
        c.push(...Qu(r, w));
        break;
      }
      case "move_node": {
        var M = ae.common(ae.parent(u.path), ae.parent(u.newPath));
        c.push(...Qu(r, M));
        var O;
        ae.isBefore(u.path, u.newPath) ? (c.push(...Qu(r, ae.parent(u.path))), O = u.newPath) : (c.push(...Qu(r, ae.parent(u.newPath))), O = u.path);
        var y = qe.get(t, ae.parent(O)), C = be.findKey(r, y), _ = ee.pathRef(r, ae.parent(O));
        p.push([_, C]);
        break;
      }
    }
    switch (o(u), u.type) {
      case "insert_node":
      case "remove_node":
      case "merge_node":
      case "move_node":
      case "split_node":
        cc.set(r, !0);
    }
    for (var [F, L] of c) {
      var [N] = ee.node(r, F);
      Ay.set(N, L);
    }
    for (var [R, W] of p) {
      if (R.current) {
        var [V] = ee.node(r, R.current);
        Ay.set(V, W);
      }
      R.unref();
    }
  }, r.setFragmentData = (u) => {
    var {
      selection: c
    } = r;
    if (c) {
      var [p, d] = me.edges(c), g = ee.void(r, {
        at: p.path
      }), f = ee.void(r, {
        at: d.path
      });
      if (!(me.isCollapsed(c) && !g)) {
        var m = be.toDOMRange(r, c), v = m.cloneContents(), E = v.childNodes[0];
        if (v.childNodes.forEach((N) => {
          N.textContent && N.textContent.trim() !== "" && (E = N);
        }), f) {
          var [w] = f, M = m.cloneRange(), O = be.toDOMNode(r, w);
          M.setEndAfter(O), v = M.cloneContents();
        }
        if (g && (E = v.querySelector("[data-slate-spacer]")), Array.from(v.querySelectorAll("[data-slate-zero-width]")).forEach((N) => {
          var R = N.getAttribute("data-slate-zero-width") === "n";
          N.textContent = R ? `
` : "";
        }), PX(E)) {
          var y = E.ownerDocument.createElement("span");
          y.style.whiteSpace = "pre", y.appendChild(E), v.appendChild(y), E = y;
        }
        var C = r.getFragment(), _ = JSON.stringify(C), F = window.btoa(encodeURIComponent(_));
        E.setAttribute("data-slate-fragment", F), u.setData("application/".concat(n), F);
        var L = v.ownerDocument.createElement("div");
        return L.appendChild(v), L.setAttribute("hidden", "true"), v.ownerDocument.body.appendChild(L), u.setData("text/html", L.innerHTML), u.setData("text/plain", SX(L)), v.ownerDocument.body.removeChild(L), u;
      }
    }
  }, r.insertData = (u) => {
    r.insertFragmentData(u) || r.insertTextData(u);
  }, r.insertFragmentData = (u) => {
    var c = u.getData("application/".concat(n)) || V3e(u);
    if (c) {
      var p = decodeURIComponent(window.atob(c)), d = JSON.parse(p);
      return r.insertFragment(d), !0;
    }
    return !1;
  }, r.insertTextData = (u) => {
    var c = u.getData("text/plain");
    if (c) {
      var p = c.split(/\r\n|\r|\n/), d = !1;
      for (var g of p)
        d && Te.splitNodes(r, {
          always: !0
        }), r.insertText(g), d = !0;
      return !0;
    }
    return !1;
  }, r.onChange = (u) => {
    var c = wX < 18 ? pl.unstable_batchedUpdates : (p) => p();
    c(() => {
      var p = l1.get(r);
      p && p(u), i(u);
    });
  }, r;
}, Qu = (e, t) => {
  var n = [];
  for (var [r, o] of ee.levels(e, {
    at: t
  })) {
    var i = be.findKey(e, r);
    n.push([o, i]);
  }
  return n;
};
function zX(e, t, n = "type") {
  const { selection: r } = e;
  if (!r) return !1;
  const [o] = Array.from(
    ee.nodes(e, {
      at: ee.unhangRange(e, r),
      match: (i) => !ee.isEditor(i) && rt.isElement(i) && i[n] === t
    })
  );
  return !!o;
}
const IV = ["listItem", "numberedList"], Rm = ["left", "center", "right", "justify"];
function rVe(e, t) {
  const n = Rm.includes(t) ? "align" : "type", r = zX(e, t, n), o = IV.includes(t);
  Te.unwrapNodes(e, {
    match: (a) => !ee.isEditor(a) && rt.isElement(a) && IV.includes(a.type) && !Rm.includes(t),
    split: !0
  });
  let i;
  if (Rm.includes(t) ? i = { align: r ? void 0 : t } : i = {
    type: r ? "paragraph" : o ? "listItem" : t
  }, Te.setNodes(e, i), !r && o) {
    const a = { type: t, children: [] };
    Te.wrapNodes(e, a);
  }
}
function Zl({ format: e, icon: t }) {
  const n = w0(), r = Rm.includes(e) ? "align" : "type", i = zX(n, e, r) ? "activeTrue" : "activeFalse";
  function a(s) {
    s.preventDefault(), rVe(n, e);
  }
  return /* @__PURE__ */ Q.jsx(
    "button",
    {
      type: "button",
      className: "arkynRichTextBlockButton " + i,
      onMouseDown: a,
      children: /* @__PURE__ */ Q.jsx(t, {})
    }
  );
}
function oVe({ attributes: e, children: t, element: n }) {
  const r = { textAlign: n.align };
  switch (n.type) {
    case "blockQuote":
      return /* @__PURE__ */ Q.jsx(
        "blockquote",
        {
          className: "arkynElementBlockquote",
          style: r,
          ...e,
          children: t
        }
      );
    case "bulletedList":
      return /* @__PURE__ */ Q.jsx("ul", { className: "arkynElementBulletList", style: r, ...e, children: t });
    case "headingOne":
      return /* @__PURE__ */ Q.jsx("h1", { className: "arkynElementHeadingOne", style: r, ...e, children: t });
    case "headingTwo":
      return /* @__PURE__ */ Q.jsx("h2", { className: "arkynElementHeadingTwo", style: r, ...e, children: t });
    case "listItem":
      return /* @__PURE__ */ Q.jsx("li", { className: "arkynElementListItem", style: r, ...e, children: t });
    case "numberedList":
      return /* @__PURE__ */ Q.jsx("ol", { className: "arkynElementNumberedList", style: r, ...e, children: t });
    case "image":
      return /* @__PURE__ */ Q.jsxs("div", { style: r, ...e, children: [
        /* @__PURE__ */ Q.jsx(
          "img",
          {
            className: "arkynElementImage",
            alt: "arkynElementImage",
            src: (n == null ? void 0 : n.src) || ""
          }
        ),
        t
      ] });
    default:
      return /* @__PURE__ */ Q.jsx("p", { className: "arkynElementParagraph", style: r, ...e, children: t });
  }
}
const UX = Ke({});
function iVe(e) {
  const {
    isVisibled: t,
    makeInvisible: n,
    children: r,
    className: o = "",
    ...i
  } = e, s = `arkynModalContainer ${t ? "visibleTrue" : "visibleFalse"} ${o}`;
  return /* @__PURE__ */ Q.jsx(UX.Provider, { value: { makeInvisible: n }, children: /* @__PURE__ */ Q.jsx(U6, { children: t && /* @__PURE__ */ Q.jsxs("aside", { className: s.trim(), ...i, children: [
    /* @__PURE__ */ Q.jsx(
      vd.div,
      {
        className: "arkynModalContainerOverlay",
        transition: { duration: 0.15, ease: "easeOut" },
        initial: { opacity: 0 },
        animate: { opacity: 1 },
        exit: { opacity: 0 },
        onClick: n
      }
    ),
    /* @__PURE__ */ Q.jsx(
      vd.div,
      {
        className: "arkynModalContainerContent",
        transition: { duration: 0.15, ease: "easeOut" },
        initial: { opacity: 0, scale: 0.75 },
        animate: { opacity: 1, scale: 1 },
        exit: { opacity: 0, scale: 0 },
        children: r
      }
    )
  ] }) }) });
}
function sVe(e) {
  const { alignment: t = "right", className: n, ...r } = e, o = `arkynModalFooter ${t} ${n}`;
  return /* @__PURE__ */ Q.jsx("footer", { className: o.trim(), ...r });
}
function aVe(e) {
  const {
    showCloseButton: t = !0,
    className: n,
    children: r,
    ...o
  } = e, { makeInvisible: i } = ge(UX), a = `arkynModalHeader ${n}`;
  return /* @__PURE__ */ Q.jsxs("header", { className: a.trim(), ...o, children: [
    r,
    t && /* @__PURE__ */ Q.jsx(
      "button",
      {
        type: "button",
        onClick: i,
        "aria-label": "Close modal button",
        className: "arkynModalHeaderCloseButton",
        children: /* @__PURE__ */ Q.jsx(E1, { size: 24 })
      }
    )
  ] });
}
const f1 = Ke({});
function lVe() {
  if (!f1)
    throw new Error("useTabContext must be used within a TabProvider");
  return ge(f1);
}
function uVe(e) {
  const {
    children: t,
    onClick: n,
    defaultActive: r,
    className: o,
    ...i
  } = e, [a, s] = k(r || ""), [l, u] = k(!0), c = ut(null), p = `arkynTabContainer ${o || ""}`, [d, g] = k({
    width: "0px",
    left: "0px",
    transition: "none"
  }), f = (v, E) => {
    const w = v.getBoundingClientRect(), M = c.current.getBoundingClientRect(), O = E ? void 0 : "none";
    u(!1), g({
      transition: O,
      width: `${w.width}px`,
      left: `${w.left - M.left}px`
    });
  };
  h(() => {
    const v = c.current;
    if (!v) return;
    let E = null;
    E = v.querySelector("button.activeTrue"), E && f(E);
  }, []);
  const m = (v) => {
    const E = v.target;
    E && (s(E.value), E.classList.add("activeTrue"), f(E, !0), n && n(E.value));
  };
  return /* @__PURE__ */ Q.jsxs("nav", { ref: c, className: p.trim(), ...i, children: [
    /* @__PURE__ */ Q.jsx(f1.Provider, { value: { handleTabClick: m, showInitialTab: l, value: a }, children: t }),
    /* @__PURE__ */ Q.jsx("div", { className: "activeLine", style: d })
  ] });
}
function RV(e) {
  const { children: t, className: n = "", onClick: r, ...o } = e, { value: i, showInitialTab: a, handleTabClick: s } = lVe(), l = i === o.value && i ? "activeTrue" : "activeFalse", c = `arkynTabButton ${i === o.value && a ? "showBorderBottom" : ""} ${l} ${n}`;
  function p(d) {
    s(d), r && r(d);
  }
  return /* @__PURE__ */ Q.jsx(
    "button",
    {
      onClick: p,
      className: c.trim(),
      ...o,
      type: "button",
      children: t
    }
  );
}
function cVe(e) {
  const {
    action: t,
    tabLabels: n = ["Adicionar URL", "Upload de arquivo"],
    modalCancelButton: r = "Cancelar",
    modalConfirmButton: o = "Confirmar",
    modalInputImageLabel: i = "Imagem:",
    modalInputUrlLabel: a = "URL da imagem:",
    modalTitle: s = "Inserir imagem"
  } = e, l = w0(), [u, c] = k(!1), [p, d] = k(""), [g, f] = k("url");
  function m(v) {
    v.preventDefault(), !(!p || p === "") && (l.insertNodes([
      { type: "paragraph", children: [{ text: "" }] },
      { type: "image", src: p, children: [{ text: "" }] },
      { type: "paragraph", children: [{ text: "" }] }
    ]), c(!1));
  }
  return /* @__PURE__ */ Q.jsxs(Q.Fragment, { children: [
    /* @__PURE__ */ Q.jsx(
      "button",
      {
        type: "button",
        className: "arkynRichTextInsertImage",
        onMouseDown: () => c(!0),
        children: /* @__PURE__ */ Q.jsx(JJ, {})
      }
    ),
    /* @__PURE__ */ Q.jsxs(
      iVe,
      {
        isVisibled: u,
        makeInvisible: () => c(!1),
        children: [
          /* @__PURE__ */ Q.jsx(aVe, { children: s }),
          /* @__PURE__ */ Q.jsxs("div", { className: "arkynRichTextInsertImageModalContent", children: [
            /* @__PURE__ */ Q.jsxs(uVe, { defaultActive: g, onClick: f, children: [
              /* @__PURE__ */ Q.jsx(RV, { value: "url", children: n[0] }),
              /* @__PURE__ */ Q.jsx(RV, { value: "file", children: n[1] })
            ] }),
            g === "url" && /* @__PURE__ */ Q.jsxs(Q.Fragment, { children: [
              /* @__PURE__ */ Q.jsxs(KW, { children: [
                /* @__PURE__ */ Q.jsx(YW, { children: a }),
                /* @__PURE__ */ Q.jsx(
                  v0,
                  {
                    type: "text",
                    name: "richTextimageURL",
                    defaultValue: p,
                    onChange: (v) => d(v.target.value)
                  }
                )
              ] }),
              p && /* @__PURE__ */ Q.jsx(
                "img",
                {
                  className: "arkynRichTextInsertImageModalPreviewImage",
                  src: p,
                  alt: "preview"
                }
              )
            ] }),
            g === "file" && /* @__PURE__ */ Q.jsxs(KW, { children: [
              /* @__PURE__ */ Q.jsx(YW, { children: i }),
              /* @__PURE__ */ Q.jsx(
                pHe,
                {
                  name: "richTextimageURL",
                  action: t,
                  defaultValue: p,
                  onUpload: (v) => d(v || "")
                }
              )
            ] })
          ] }),
          /* @__PURE__ */ Q.jsxs(sVe, { children: [
            /* @__PURE__ */ Q.jsx(
              pf,
              {
                type: "button",
                scheme: "danger",
                variant: "outline",
                onClick: () => c(!1),
                children: r
              }
            ),
            /* @__PURE__ */ Q.jsx(pf, { type: "button", onClick: m, children: o })
          ] })
        ]
      }
    )
  ] });
}
function pVe({ attributes: e, children: t, leaf: n }) {
  return n.bold && (t = /* @__PURE__ */ Q.jsx("strong", { children: t })), n.code && (t = /* @__PURE__ */ Q.jsx("code", { children: t })), n.italic && (t = /* @__PURE__ */ Q.jsx("em", { children: t })), n.underline && (t = /* @__PURE__ */ Q.jsx("u", { children: t })), /* @__PURE__ */ Q.jsx("span", { ...e, children: t });
}
function HX(e, t) {
  const n = ee.marks(e);
  return n ? n[t] === !0 : !1;
}
function $X(e, t) {
  HX(e, t) ? ee.removeMark(e, t) : ee.addMark(e, t, !0);
}
function gm({ format: e, icon: t }) {
  const n = w0(), o = HX(n, e) ? "activeTrue" : "activeFalse";
  function i(a) {
    a.preventDefault(), $X(n, e);
  }
  return /* @__PURE__ */ Q.jsx(
    "button",
    {
      type: "button",
      className: "arkynRichTextMarkButton " + o,
      onMouseDown: i,
      children: /* @__PURE__ */ Q.jsx(t, {})
    }
  );
}
function dVe({ children: e }) {
  return /* @__PURE__ */ Q.jsx("div", { className: "arkynRichTextToolbar", children: e });
}
function BV(e) {
  return e.map((t) => qe.string(t)).join("");
}
const NV = {
  "mod+b": "bold",
  "mod+i": "italic",
  "mod+u": "underline",
  "mod+`": "code"
}, mm = [
  {
    type: "paragraph",
    children: [{ text: "" }]
  }
];
function A4e(e) {
  const {
    name: t,
    hiddenButtons: n,
    imageConfig: r,
    defaultValue: o = "[]",
    enforceCharacterLimit: i = !1,
    onChangeCharactersCount: a,
    maxLimit: s = 2e3,
    onChange: l,
    isError: u
  } = e, c = Cn(() => qHe(nVe(Gte())), []), { id: p, inputRef: d, error: g } = ni(), f = ut(null);
  function m() {
    try {
      const X = JSON.parse(o);
      return !Array.isArray(X) || X.length <= 0 ? mm : X.every(
        (J) => typeof J == "object" && J !== null && "type" in J && "children" in J
      ) ? X : mm;
    } catch {
      return mm;
    }
  }
  const v = BV(m()), [E, w] = k(v.length), [M, O] = k(
    JSON.stringify(m()) || "[]"
  ), [y, C] = k(!1), _ = d || f, F = u || !!g, L = Nn(pVe, []), N = Nn(oVe, []);
  function R(X) {
    const te = BV(X);
    w(te.length), a && a(te.length), !(i && te.length >= s) && (O(JSON.stringify(X)), l && l(X), c.children = X, Te.setNodes(c, { children: X }));
  }
  const W = y ? "focusTrue" : "focusFalse", z = `arkynRichText ${F || s < E ? "errorTrue" : "errorFalse"} ${W}`, Z = s - E;
  function K(X) {
    return !(n != null && n.includes(X));
  }
  return /* @__PURE__ */ Q.jsxs(
    eVe,
    {
      editor: c,
      initialValue: m(),
      onChange: R,
      onValueChange: R,
      children: [
        /* @__PURE__ */ Q.jsxs("div", { className: z, children: [
          /* @__PURE__ */ Q.jsxs(dVe, { children: [
            K("headingOne") && /* @__PURE__ */ Q.jsx(Zl, { format: "headingOne", icon: QJ }),
            K("headingTwo") && /* @__PURE__ */ Q.jsx(Zl, { format: "headingTwo", icon: eQ }),
            K("blockQuote") && /* @__PURE__ */ Q.jsx(Zl, { format: "blockQuote", icon: tQ }),
            K("bold") && /* @__PURE__ */ Q.jsx(gm, { format: "bold", icon: nQ }),
            K("italic") && /* @__PURE__ */ Q.jsx(gm, { format: "italic", icon: rQ }),
            K("underline") && /* @__PURE__ */ Q.jsx(gm, { format: "underline", icon: oQ }),
            K("code") && /* @__PURE__ */ Q.jsx(gm, { format: "code", icon: iQ }),
            K("left") && /* @__PURE__ */ Q.jsx(Zl, { format: "left", icon: sQ }),
            K("right") && /* @__PURE__ */ Q.jsx(Zl, { format: "right", icon: aQ }),
            K("center") && /* @__PURE__ */ Q.jsx(Zl, { format: "center", icon: lQ }),
            K("justify") && /* @__PURE__ */ Q.jsx(Zl, { format: "justify", icon: uQ }),
            r && K("image") && /* @__PURE__ */ Q.jsx(cVe, { ...r })
          ] }),
          /* @__PURE__ */ Q.jsx(
            VWe,
            {
              className: "editorContainer",
              renderElement: N,
              renderLeaf: L,
              spellCheck: !0,
              id: p,
              onFocus: () => C(!0),
              onBlur: () => C(!1),
              onKeyDown: (X) => {
                for (const te in NV)
                  if (VHe(te, X)) {
                    X.preventDefault();
                    const J = NV[te];
                    $X(c, J);
                  }
              }
            }
          ),
          Z < 0 && /* @__PURE__ */ Q.jsx("div", { className: "restatesCharacters", children: Z })
        ] }),
        /* @__PURE__ */ Q.jsx("input", { type: "hidden", ref: _, name: t, value: M }),
        /* @__PURE__ */ Q.jsx("input", { type: "hidden", name: `${t}Count`, value: E })
      ]
    }
  );
}
function fVe(e, t) {
  const {
    isLoading: n,
    isError: r,
    size: o = "md",
    className: i = "",
    variant: a = "solid",
    prefix: s,
    leftIcon: l,
    disabled: u,
    readOnly: c,
    onFocus: p,
    onBlur: d,
    title: g,
    style: f,
    closeOnSelect: m = !0,
    ...v
  } = e, y = `arkyn_select ${s ? "hasPrefix" : ""} ${a} ${o} ${u || c || n ? "opacity" : ""} ${r ? "errored" : ""} ${t ? "focused" : ""} ${i}`, _ = { md: 20, lg: 20 }[o];
  return {
    isLoading: n,
    className: y,
    prefix: C8(s, _, "prefix"),
    LeftIcon: l,
    disabled: u || n || c,
    onFocus: p,
    onBlur: d,
    title: g,
    closeOnSelect: m,
    style: f,
    iconSize: _,
    Spinner: /* @__PURE__ */ Q.jsx(Ts, { className: "spinner", size: _, strokeWidth: 2.5 }),
    ...v
  };
}
function I4e(e) {
  var U;
  const [t, n] = k(""), [r, o] = k(!1), { inputRef: i, id: a, error: s } = ni(), l = ut(null), u = i || l, c = e.isError || !!s, {
    disabled: p,
    title: d,
    style: g,
    className: f,
    prefix: m,
    iconSize: v,
    isLoading: E,
    LeftIcon: w,
    value: M = null,
    defaultValue: O = "",
    onFocus: y,
    onBlur: C,
    Spinner: _,
    name: F,
    placeholder: L,
    onSelect: N,
    options: R,
    optionMaxHeight: W,
    closeOnSelect: V,
    isSearchable: z,
    onSearch: Z,
    ...K
  } = fVe({ ...e, id: a, isError: c }, r), [X, te] = k(O);
  function J() {
    p || !(u != null && u.current) || r || (o(!0), u.current.focus());
  }
  function P(T) {
    Z && (n(""), Z(T.target.value)), Z || n(T.target.value);
  }
  function D(T) {
    r || (o(!0), y && y(T));
  }
  function H() {
    o(!1), C && u.current && u.current.blur();
  }
  function S(T) {
    const { label: q, value: A } = T;
    te(X !== A ? A : ""), N && N({ label: q, value: A }), V && H();
  }
  const $ = typeof M == "string" ? M : X, x = ((U = R.find((T) => T.value === $)) == null ? void 0 : U.label) || "", j = () => {
    if (!r && x) return !0;
    if (!r && !x) return !1;
    if (r && x) return !0;
    if (r && !x) return !1;
  };
  return /* @__PURE__ */ Q.jsxs(Q.Fragment, { children: [
    /* @__PURE__ */ Q.jsxs(
      "section",
      {
        title: d,
        style: g,
        onClick: J,
        className: `${f} placeholder_dark_${j()}`,
        children: [
          m,
          w && /* @__PURE__ */ Q.jsx(w, { size: v, strokeWidth: 2.5 }),
          /* @__PURE__ */ Q.jsx(
            "input",
            {
              disabled: p,
              readOnly: !0,
              placeholder: x || L,
              onFocus: D,
              ...K
            }
          ),
          /* @__PURE__ */ Q.jsx(
            "input",
            {
              type: "hidden",
              ref: u,
              name: F,
              value: $ || "",
              readOnly: !0
            }
          ),
          r && /* @__PURE__ */ Q.jsxs(
            "div",
            {
              className: "arkyn_select_content",
              style: { overflow: "auto", maxHeight: W },
              children: [
                z && /* @__PURE__ */ Q.jsx(
                  v0,
                  {
                    type: "search",
                    name: "search-select",
                    variant: "underline",
                    leftIcon: N6,
                    onChange: P
                  }
                ),
                R.filter((T) => !!(e.onSearch || !e.isSearchable || T.label.toLowerCase().includes(t.toLowerCase()))).map(({ label: T, value: q }) => /* @__PURE__ */ Q.jsxs(
                  "div",
                  {
                    onClick: () => S({ label: T, value: q }),
                    className: $ === q ? "arkyn_select_option active" : "arkyn_select_option",
                    children: [
                      T,
                      " ",
                      /* @__PURE__ */ Q.jsx(Zy, {})
                    ]
                  },
                  q
                )),
                R.length <= 0 && /* @__PURE__ */ Q.jsx("p", { children: "Sem opes disponveis" })
              ]
            }
          ),
          !E && /* @__PURE__ */ Q.jsx(
            O1,
            {
              className: "arkyn_select_arrow",
              size: v,
              strokeWidth: 2.5
            }
          ),
          E && _
        ]
      }
    ),
    r && /* @__PURE__ */ Q.jsx("aside", { className: "arkyn_select_overlay", onClick: H })
  ] });
}
function R4e(e) {
  const {
    size: t = "lg",
    defaultChecked: n = !1,
    checked: r = null,
    value: o,
    unCheckedValue: i = "",
    name: a,
    className: s = "",
    onCheck: l,
    ...u
  } = e, [c, p] = k(n), { id: d, inputRef: g } = ni(), f = typeof r == "boolean" ? r : c;
  function m() {
    p(!c), l && l(f ? i : o || "checked");
  }
  const E = `arkynSwitch ${f ? "checkedTrue" : "checkedFalse"} ${t} ${s}`;
  return /* @__PURE__ */ Q.jsx("button", { type: "button", onClick: m, className: E, ...u, children: /* @__PURE__ */ Q.jsx(
    "input",
    {
      id: d,
      type: "hidden",
      name: a,
      ref: g,
      onClick: m,
      value: f ? o || "checked" : i
    }
  ) });
}
function B4e(e) {
  const {
    variant: t = "solid",
    size: n = "md",
    className: r,
    disabled: o = !1,
    readOnly: i = !1,
    onFocus: a,
    onBlur: s,
    title: l,
    style: u,
    ...c
  } = e, [p, d] = k(!1), { inputRef: g, id: f, error: m } = ni(), v = ut(null), E = g || v, M = e.isError || !!m ? "errorTrue" : "errorFalse", C = `arkynTextarea ${t} ${n} ${o || i ? "opacityTrue" : "opacityFalse"} ${M} ${p ? "focusedTrue" : "focusedFalse"} ${r}`;
  function _() {
    o || !(E != null && E.current) || (d(!0), E.current.focus());
  }
  function F(N) {
    d(!0), a && a(N);
  }
  function L(N) {
    d(!1), s && s(N);
  }
  return /* @__PURE__ */ Q.jsx(
    "section",
    {
      title: l,
      style: u,
      onClick: _,
      className: C,
      children: /* @__PURE__ */ Q.jsx(
        "textarea",
        {
          id: f,
          disabled: o,
          readOnly: i,
          ref: E,
          onFocus: F,
          onBlur: L,
          ...c
        }
      )
    }
  );
}
function N4e(e) {
  const { className: t = "", ...n } = e, r = `arkynBreadcrumbContainer ${t}`;
  return /* @__PURE__ */ Q.jsx("nav", { className: r, ...n });
}
function F4e(e) {
  const { pathname: t } = P1(), {
    className: n = "",
    disabled: r = !1,
    children: o,
    to: i,
    ...a
  } = e, l = `arkynBreadcrumbLink ${t === i ? "active" : "inactive"} ${n}`;
  return r ? /* @__PURE__ */ Q.jsxs("p", { className: l, children: [
    /* @__PURE__ */ Q.jsx(ZO, { size: 14, strokeWidth: 2.5 }),
    o
  ] }) : /* @__PURE__ */ Q.jsxs(dQ, { to: i, className: l, ...a, children: [
    /* @__PURE__ */ Q.jsx(ZO, { size: 14, strokeWidth: 2.5 }),
    o
  ] });
}
function WX(e = "") {
  const t = P1(), n = new URLSearchParams(t.search), r = e ? `${e}:` : "", o = (i) => {
    Object.entries(i).forEach(([a, s]) => {
      s === void 0 ? n.delete(`${r}${a}`) : n.set(`${r}${a}`, String(s));
    });
  };
  return {
    getParam: (i) => n.get(`${r}${i}`),
    getScopedSearch: (i) => {
      o(i);
      let a = n.toString();
      return a && (a = "?" + a), a;
    }
  };
}
function FV(e, t) {
  return [...new Array(t - e)].map((n, r) => e + r + 1).filter((n) => n > 0);
}
function z4e(e) {
  const {
    scope: t,
    totalCountRegisters: n,
    perPageKey: r = "per_page",
    pageKey: o = "page",
    siblingsCount: i = 2,
    currentPage: a = 1,
    registerPerPage: s = 20,
    ...l
  } = e, u = z6(), { getParam: c, getScopedSearch: p } = WX(t), d = Number(c("page")) || a, g = Number(c("per_page")) || s, f = Math.ceil(n / g), m = d > 1 ? FV(d - 1 - i, d - 1) : [], v = d < f ? FV(
    d,
    Math.min(d + i, f)
  ) : [];
  function E(w) {
    u(p({ page: w }));
  }
  return /* @__PURE__ */ Q.jsxs("div", { className: "arkynPagination", ...l, children: [
    /* @__PURE__ */ Q.jsx(
      "button",
      {
        className: "arkynPaginationIconButton",
        disabled: d <= 1,
        onClick: () => E(d - 1),
        children: /* @__PURE__ */ Q.jsx(cQ, {})
      }
    ),
    d > 1 + i && /* @__PURE__ */ Q.jsxs(Q.Fragment, { children: [
      /* @__PURE__ */ Q.jsx(
        "button",
        {
          className: "arkynPaginationPageButton",
          onClick: () => E(1),
          children: "1"
        }
      ),
      d > 2 + i && /* @__PURE__ */ Q.jsx("button", { disabled: !0, className: "arkynPaginationSpread", children: /* @__PURE__ */ Q.jsx(FS, {}) })
    ] }),
    m.length > 0 && m.map((w, M) => /* @__PURE__ */ Q.jsx(
      "button",
      {
        onClick: () => E(w),
        className: "arkynPaginationPageButton",
        children: w
      },
      M
    )),
    /* @__PURE__ */ Q.jsx("button", { className: "arkynPaginationCurrent", disabled: !0, children: d }),
    v.length > 0 && v.map((w, M) => /* @__PURE__ */ Q.jsx(
      "button",
      {
        onClick: () => E(w),
        className: "arkynPaginationPageButton",
        children: w
      },
      M
    )),
    d + i < f && /* @__PURE__ */ Q.jsxs(Q.Fragment, { children: [
      d + 1 + i < f && /* @__PURE__ */ Q.jsx("button", { disabled: !0, className: "arkynPaginationSpread", children: /* @__PURE__ */ Q.jsx(FS, {}) }),
      /* @__PURE__ */ Q.jsx(
        "button",
        {
          className: "arkynPaginationPageButton",
          onClick: () => E(f),
          children: f
        }
      )
    ] }),
    /* @__PURE__ */ Q.jsx(
      "button",
      {
        className: "arkynPaginationIconButton",
        disabled: d >= f,
        onClick: () => E(d + 1),
        children: /* @__PURE__ */ Q.jsx(ZO, {})
      }
    )
  ] });
}
const VX = Ke({});
function U4e(e) {
  const {
    isVisibled: t,
    makeInvisible: n,
    orientation: r = "left",
    children: o,
    className: i,
    ...a
  } = e, s = r === "left" ? "-100%" : "100%", u = `arkynDrawerContainer ${r} ${t ? "visibleTrue" : "visibleFalse"} ${i}`;
  return /* @__PURE__ */ Q.jsx(VX.Provider, { value: { makeInvisible: n }, children: /* @__PURE__ */ Q.jsx(U6, { children: t && /* @__PURE__ */ Q.jsxs("aside", { className: u.trim(), ...a, children: [
    /* @__PURE__ */ Q.jsx(
      vd.div,
      {
        className: "arkynDrawerContainerOverlay",
        transition: { duration: 0.15, ease: "easeOut" },
        initial: { opacity: 0 },
        animate: { opacity: 1 },
        exit: { opacity: 0 },
        onClick: n
      }
    ),
    /* @__PURE__ */ Q.jsx(
      vd.div,
      {
        className: "arkynDrawerContainerContent",
        transition: { ease: "easeOut", duration: 0.15 },
        initial: { transform: `translateX(${s})` },
        animate: { transform: "translateX(0px)" },
        exit: { transform: `translateX(${s})` },
        children: o
      }
    )
  ] }) }) });
}
function H4e(e) {
  const {
    showCloseButton: t = !0,
    className: n,
    children: r,
    ...o
  } = e, { makeInvisible: i } = ge(VX), a = `arkynDrawerHeader ${n}`;
  return /* @__PURE__ */ Q.jsxs("header", { className: a.trim(), ...o, children: [
    r,
    t && /* @__PURE__ */ Q.jsx(
      "button",
      {
        className: "arkynDrawerHeaderCloseButton",
        type: "button",
        onClick: i,
        "aria-label": "Close drawer",
        children: /* @__PURE__ */ Q.jsx(E1, { size: 24 })
      }
    )
  ] });
}
function $4e(e) {
  const {
    children: t,
    button: n,
    closeOnClick: r,
    className: o = "",
    orientation: i = "bottomLeft"
  } = e, [a, s] = k(!1), u = `arkynPopover ${i} ${a ? "visibleTrue" : "visibleFalse"} ${o}`;
  function c() {
    a || s(!0);
  }
  return /* @__PURE__ */ Q.jsxs("div", { className: u, onClick: c, children: [
    n,
    /* @__PURE__ */ Q.jsx(
      vd.div,
      {
        style: { visibility: a ? "visible" : "hidden" },
        transition: { ease: "easeOut", duration: 0 },
        initial: { opacity: 0 },
        animate: { opacity: a ? 1 : 0 },
        exit: { opacity: 0 },
        onClick: () => r && s(!1),
        className: "arkynPopoverContent",
        children: t
      }
    ),
    a && /* @__PURE__ */ Q.jsx("div", { onClick: () => s(!1), className: "arkynPopoverOverlay" })
  ] });
}
function W4e(e) {
  const { message: t, type: n } = e, r = `arkynToast ${n}}`;
  function o() {
    switch (n) {
      case "success":
        return /* @__PURE__ */ Q.jsx(B6, {});
      case "danger":
        return /* @__PURE__ */ Q.jsx(R6, {});
      default:
        return /* @__PURE__ */ Q.jsx(I6, {});
    }
  }
  return /* @__PURE__ */ Q.jsxs("div", { className: r, children: [
    /* @__PURE__ */ Q.jsxs("div", { children: [
      /* @__PURE__ */ Q.jsx("div", { className: "bg" }),
      /* @__PURE__ */ Q.jsx(o, {})
    ] }),
    /* @__PURE__ */ Q.jsx("p", { children: /* @__PURE__ */ Q.jsx("span", { children: t }) })
  ] });
}
var go = {}, LS = {}, ih = {}, sh = {}, ZX = "Expected a function", zV = NaN, hVe = "[object Symbol]", gVe = /^\s+|\s+$/g, mVe = /^[-+]0x[0-9a-f]+$/i, vVe = /^0b[01]+$/i, yVe = /^0o[0-7]+$/i, bVe = parseInt, wVe = typeof Xn == "object" && Xn && Xn.Object === Object && Xn, CVe = typeof self == "object" && self && self.Object === Object && self, xVe = wVe || CVe || Function("return this")(), OVe = Object.prototype, EVe = OVe.toString, kVe = Math.max, LVe = Math.min, MO = function() {
  return xVe.Date.now();
};
function PVe(e, t, n) {
  var r, o, i, a, s, l, u = 0, c = !1, p = !1, d = !0;
  if (typeof e != "function")
    throw new TypeError(ZX);
  t = UV(t) || 0, Iy(n) && (c = !!n.leading, p = "maxWait" in n, i = p ? kVe(UV(n.maxWait) || 0, t) : i, d = "trailing" in n ? !!n.trailing : d);
  function g(C) {
    var _ = r, F = o;
    return r = o = void 0, u = C, a = e.apply(F, _), a;
  }
  function f(C) {
    return u = C, s = setTimeout(E, t), c ? g(C) : a;
  }
  function m(C) {
    var _ = C - l, F = C - u, L = t - _;
    return p ? LVe(L, i - F) : L;
  }
  function v(C) {
    var _ = C - l, F = C - u;
    return l === void 0 || _ >= t || _ < 0 || p && F >= i;
  }
  function E() {
    var C = MO();
    if (v(C))
      return w(C);
    s = setTimeout(E, m(C));
  }
  function w(C) {
    return s = void 0, d && r ? g(C) : (r = o = void 0, a);
  }
  function M() {
    s !== void 0 && clearTimeout(s), u = 0, r = l = o = s = void 0;
  }
  function O() {
    return s === void 0 ? a : w(MO());
  }
  function y() {
    var C = MO(), _ = v(C);
    if (r = arguments, o = this, l = C, _) {
      if (s === void 0)
        return f(l);
      if (p)
        return s = setTimeout(E, t), g(l);
    }
    return s === void 0 && (s = setTimeout(E, t)), a;
  }
  return y.cancel = M, y.flush = O, y;
}
function _Ve(e, t, n) {
  var r = !0, o = !0;
  if (typeof e != "function")
    throw new TypeError(ZX);
  return Iy(n) && (r = "leading" in n ? !!n.leading : r, o = "trailing" in n ? !!n.trailing : o), PVe(e, t, {
    leading: r,
    maxWait: t,
    trailing: o
  });
}
function Iy(e) {
  var t = typeof e;
  return !!e && (t == "object" || t == "function");
}
function SVe(e) {
  return !!e && typeof e == "object";
}
function MVe(e) {
  return typeof e == "symbol" || SVe(e) && EVe.call(e) == hVe;
}
function UV(e) {
  if (typeof e == "number")
    return e;
  if (MVe(e))
    return zV;
  if (Iy(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = Iy(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = e.replace(gVe, "");
  var n = vVe.test(e);
  return n || yVe.test(e) ? bVe(e.slice(2), n ? 2 : 8) : mVe.test(e) ? zV : +e;
}
var DVe = _Ve, ah = {};
Object.defineProperty(ah, "__esModule", {
  value: !0
});
ah.addPassiveEventListener = function(t, n, r) {
  var o = r.name;
  o || (o = n, console.warn("Listener must be a named function.")), Bm.has(n) || Bm.set(n, /* @__PURE__ */ new Set());
  var i = Bm.get(n);
  if (!i.has(o)) {
    var a = function() {
      var s = !1;
      try {
        var l = Object.defineProperty({}, "passive", {
          get: function() {
            s = !0;
          }
        });
        window.addEventListener("test", null, l);
      } catch {
      }
      return s;
    }();
    t.addEventListener(n, r, a ? { passive: !0 } : !1), i.add(o);
  }
};
ah.removePassiveEventListener = function(t, n, r) {
  t.removeEventListener(n, r), Bm.get(n).delete(r.name || n);
};
var Bm = /* @__PURE__ */ new Map();
Object.defineProperty(sh, "__esModule", {
  value: !0
});
var TVe = DVe, jVe = AVe(TVe), HV = ah;
function AVe(e) {
  return e && e.__esModule ? e : { default: e };
}
var IVe = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 66;
  return (0, jVe.default)(t, n);
}, qr = {
  spyCallbacks: [],
  spySetState: [],
  scrollSpyContainers: [],
  mount: function(t, n) {
    if (t) {
      var r = IVe(function(o) {
        qr.scrollHandler(t);
      }, n);
      return qr.scrollSpyContainers.push(t), (0, HV.addPassiveEventListener)(t, "scroll", r), function() {
        (0, HV.removePassiveEventListener)(t, "scroll", r), qr.scrollSpyContainers.splice(qr.scrollSpyContainers.indexOf(t), 1);
      };
    }
    return function() {
    };
  },
  isMounted: function(t) {
    return qr.scrollSpyContainers.indexOf(t) !== -1;
  },
  currentPositionX: function(t) {
    if (t === document) {
      var n = window.scrollY !== void 0, r = (document.compatMode || "") === "CSS1Compat";
      return n ? window.scrollX : r ? document.documentElement.scrollLeft : document.body.scrollLeft;
    } else
      return t.scrollLeft;
  },
  currentPositionY: function(t) {
    if (t === document) {
      var n = window.scrollX !== void 0, r = (document.compatMode || "") === "CSS1Compat";
      return n ? window.scrollY : r ? document.documentElement.scrollTop : document.body.scrollTop;
    } else
      return t.scrollTop;
  },
  scrollHandler: function(t) {
    var n = qr.scrollSpyContainers[qr.scrollSpyContainers.indexOf(t)].spyCallbacks || [];
    n.forEach(function(r) {
      return r(qr.currentPositionX(t), qr.currentPositionY(t));
    });
  },
  addStateHandler: function(t) {
    qr.spySetState.push(t);
  },
  addSpyHandler: function(t, n) {
    var r = qr.scrollSpyContainers[qr.scrollSpyContainers.indexOf(n)];
    r.spyCallbacks || (r.spyCallbacks = []), r.spyCallbacks.push(t);
  },
  updateStates: function() {
    qr.spySetState.forEach(function(t) {
      return t();
    });
  },
  unmount: function(t, n) {
    qr.scrollSpyContainers.forEach(function(r) {
      return r.spyCallbacks && r.spyCallbacks.length && r.spyCallbacks.indexOf(n) > -1 && r.spyCallbacks.splice(r.spyCallbacks.indexOf(n), 1);
    }), qr.spySetState && qr.spySetState.length && qr.spySetState.indexOf(t) > -1 && qr.spySetState.splice(qr.spySetState.indexOf(t), 1), document.removeEventListener("scroll", qr.scrollHandler);
  },
  update: function() {
    return qr.scrollSpyContainers.forEach(function(t) {
      return qr.scrollHandler(t);
    });
  }
};
sh.default = qr;
var zc = {}, lh = {};
Object.defineProperty(lh, "__esModule", {
  value: !0
});
var RVe = function(t, n) {
  var r = t.indexOf("#") === 0 ? t.substring(1) : t, o = r ? "#" + r : "", i = window && window.location, a = o ? i.pathname + i.search + o : i.pathname + i.search;
  n ? history.pushState(history.state, "", a) : history.replaceState(history.state, "", a);
}, BVe = function() {
  return window.location.hash.replace(/^#/, "");
}, NVe = function(t) {
  return function(n) {
    return t.contains ? t != n && t.contains(n) : !!(t.compareDocumentPosition(n) & 16);
  };
}, FVe = function(t) {
  return getComputedStyle(t).position !== "static";
}, DO = function(t, n) {
  for (var r = t.offsetTop, o = t.offsetParent; o && !n(o); )
    r += o.offsetTop, o = o.offsetParent;
  return { offsetTop: r, offsetParent: o };
}, zVe = function(t, n, r) {
  if (r)
    return t === document ? n.getBoundingClientRect().left + (window.scrollX || window.pageXOffset) : getComputedStyle(t).position !== "static" ? n.offsetLeft : n.offsetLeft - t.offsetLeft;
  if (t === document)
    return n.getBoundingClientRect().top + (window.scrollY || window.pageYOffset);
  if (FVe(t)) {
    if (n.offsetParent !== t) {
      var o = function(c) {
        return c === t || c === document;
      }, i = DO(n, o), a = i.offsetTop, s = i.offsetParent;
      if (s !== t)
        throw new Error("Seems containerElement is not an ancestor of the Element");
      return a;
    }
    return n.offsetTop;
  }
  if (n.offsetParent === t.offsetParent)
    return n.offsetTop - t.offsetTop;
  var l = function(c) {
    return c === document;
  };
  return DO(n, l).offsetTop - DO(t, l).offsetTop;
};
lh.default = {
  updateHash: RVe,
  getHash: BVe,
  filterElementInContainer: NVe,
  scrollOffset: zVe
};
var C0 = {}, PS = {};
Object.defineProperty(PS, "__esModule", {
  value: !0
});
PS.default = {
  /*
   * https://github.com/oblador/angular-scroll (duScrollDefaultEasing)
   */
  defaultEasing: function(t) {
    return t < 0.5 ? Math.pow(t * 2, 2) / 2 : 1 - Math.pow((1 - t) * 2, 2) / 2;
  },
  /*
   * https://gist.github.com/gre/1650294
   */
  // no easing, no acceleration
  linear: function(t) {
    return t;
  },
  // accelerating from zero velocity
  easeInQuad: function(t) {
    return t * t;
  },
  // decelerating to zero velocity
  easeOutQuad: function(t) {
    return t * (2 - t);
  },
  // acceleration until halfway, then deceleration
  easeInOutQuad: function(t) {
    return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
  },
  // accelerating from zero velocity 
  easeInCubic: function(t) {
    return t * t * t;
  },
  // decelerating to zero velocity 
  easeOutCubic: function(t) {
    return --t * t * t + 1;
  },
  // acceleration until halfway, then deceleration 
  easeInOutCubic: function(t) {
    return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
  },
  // accelerating from zero velocity 
  easeInQuart: function(t) {
    return t * t * t * t;
  },
  // decelerating to zero velocity 
  easeOutQuart: function(t) {
    return 1 - --t * t * t * t;
  },
  // acceleration until halfway, then deceleration
  easeInOutQuart: function(t) {
    return t < 0.5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t;
  },
  // accelerating from zero velocity
  easeInQuint: function(t) {
    return t * t * t * t * t;
  },
  // decelerating to zero velocity
  easeOutQuint: function(t) {
    return 1 + --t * t * t * t * t;
  },
  // acceleration until halfway, then deceleration 
  easeInOutQuint: function(t) {
    return t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t;
  }
};
var _S = {};
Object.defineProperty(_S, "__esModule", {
  value: !0
});
var UVe = ah, HVe = ["mousedown", "wheel", "touchmove", "keydown"];
_S.default = {
  subscribe: function(t) {
    return typeof document < "u" && HVe.forEach(function(n) {
      return (0, UVe.addPassiveEventListener)(document, n, t);
    });
  }
};
var uh = {};
Object.defineProperty(uh, "__esModule", {
  value: !0
});
var h1 = {
  registered: {},
  scrollEvent: {
    register: function(t, n) {
      h1.registered[t] = n;
    },
    remove: function(t) {
      h1.registered[t] = null;
    }
  }
};
uh.default = h1;
Object.defineProperty(C0, "__esModule", {
  value: !0
});
var $Ve = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, WVe = lh;
x0(WVe);
var VVe = PS, $V = x0(VVe), ZVe = _S, qVe = x0(ZVe), GVe = uh, ks = x0(GVe);
function x0(e) {
  return e && e.__esModule ? e : { default: e };
}
var qX = function(t) {
  return $V.default[t.smooth] || $V.default.defaultEasing;
}, KVe = function(t) {
  return typeof t == "function" ? t : function() {
    return t;
  };
}, YVe = function() {
  if (typeof window < "u")
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame;
}, g1 = function() {
  return YVe() || function(e, t, n) {
    window.setTimeout(e, n || 1e3 / 60, (/* @__PURE__ */ new Date()).getTime());
  };
}(), GX = function() {
  return {
    currentPosition: 0,
    startPosition: 0,
    targetPosition: 0,
    progress: 0,
    duration: 0,
    cancel: !1,
    target: null,
    containerElement: null,
    to: null,
    start: null,
    delta: null,
    percent: null,
    delayTimeout: null
  };
}, KX = function(t) {
  var n = t.data.containerElement;
  if (n && n !== document && n !== document.body)
    return n.scrollLeft;
  var r = window.pageXOffset !== void 0, o = (document.compatMode || "") === "CSS1Compat";
  return r ? window.pageXOffset : o ? document.documentElement.scrollLeft : document.body.scrollLeft;
}, YX = function(t) {
  var n = t.data.containerElement;
  if (n && n !== document && n !== document.body)
    return n.scrollTop;
  var r = window.pageXOffset !== void 0, o = (document.compatMode || "") === "CSS1Compat";
  return r ? window.pageYOffset : o ? document.documentElement.scrollTop : document.body.scrollTop;
}, XVe = function(t) {
  var n = t.data.containerElement;
  if (n && n !== document && n !== document.body)
    return n.scrollWidth - n.offsetWidth;
  var r = document.body, o = document.documentElement;
  return Math.max(r.scrollWidth, r.offsetWidth, o.clientWidth, o.scrollWidth, o.offsetWidth);
}, JVe = function(t) {
  var n = t.data.containerElement;
  if (n && n !== document && n !== document.body)
    return n.scrollHeight - n.offsetHeight;
  var r = document.body, o = document.documentElement;
  return Math.max(r.scrollHeight, r.offsetHeight, o.clientHeight, o.scrollHeight, o.offsetHeight);
}, QVe = function e(t, n, r) {
  var o = n.data;
  if (!n.ignoreCancelEvents && o.cancel) {
    ks.default.registered.end && ks.default.registered.end(o.to, o.target, o.currentPositionY);
    return;
  }
  if (o.delta = Math.round(o.targetPosition - o.startPosition), o.start === null && (o.start = r), o.progress = r - o.start, o.percent = o.progress >= o.duration ? 1 : t(o.progress / o.duration), o.currentPosition = o.startPosition + Math.ceil(o.delta * o.percent), o.containerElement && o.containerElement !== document && o.containerElement !== document.body ? n.horizontal ? o.containerElement.scrollLeft = o.currentPosition : o.containerElement.scrollTop = o.currentPosition : n.horizontal ? window.scrollTo(o.currentPosition, 0) : window.scrollTo(0, o.currentPosition), o.percent < 1) {
    var i = e.bind(null, t, n);
    g1.call(window, i);
    return;
  }
  ks.default.registered.end && ks.default.registered.end(o.to, o.target, o.currentPosition);
}, SS = function(t) {
  t.data.containerElement = t ? t.containerId ? document.getElementById(t.containerId) : t.container && t.container.nodeType ? t.container : document : null;
}, ch = function(t, n, r, o) {
  n.data = n.data || GX(), window.clearTimeout(n.data.delayTimeout);
  var i = function() {
    n.data.cancel = !0;
  };
  if (qVe.default.subscribe(i), SS(n), n.data.start = null, n.data.cancel = !1, n.data.startPosition = n.horizontal ? KX(n) : YX(n), n.data.targetPosition = n.absolute ? t : t + n.data.startPosition, n.data.startPosition === n.data.targetPosition) {
    ks.default.registered.end && ks.default.registered.end(n.data.to, n.data.target, n.data.currentPosition);
    return;
  }
  n.data.delta = Math.round(n.data.targetPosition - n.data.startPosition), n.data.duration = KVe(n.duration)(n.data.delta), n.data.duration = isNaN(parseFloat(n.data.duration)) ? 1e3 : parseFloat(n.data.duration), n.data.to = r, n.data.target = o;
  var a = qX(n), s = QVe.bind(null, a, n);
  if (n && n.delay > 0) {
    n.data.delayTimeout = window.setTimeout(function() {
      ks.default.registered.begin && ks.default.registered.begin(n.data.to, n.data.target), g1.call(window, s);
    }, n.delay);
    return;
  }
  ks.default.registered.begin && ks.default.registered.begin(n.data.to, n.data.target), g1.call(window, s);
}, O0 = function(t) {
  return t = $Ve({}, t), t.data = t.data || GX(), t.absolute = !0, t;
}, e9e = function(t) {
  ch(0, O0(t));
}, t9e = function(t, n) {
  ch(t, O0(n));
}, n9e = function(t) {
  t = O0(t), SS(t), ch(t.horizontal ? XVe(t) : JVe(t), t);
}, r9e = function(t, n) {
  n = O0(n), SS(n);
  var r = n.horizontal ? KX(n) : YX(n);
  ch(t + r, n);
};
C0.default = {
  animateTopScroll: ch,
  getAnimationType: qX,
  scrollToTop: e9e,
  scrollToBottom: n9e,
  scrollTo: t9e,
  scrollMore: r9e
};
Object.defineProperty(zc, "__esModule", {
  value: !0
});
var o9e = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, i9e = lh, s9e = MS(i9e), a9e = C0, l9e = MS(a9e), u9e = uh, vm = MS(u9e);
function MS(e) {
  return e && e.__esModule ? e : { default: e };
}
var ym = {}, WV = void 0;
zc.default = {
  unmount: function() {
    ym = {};
  },
  register: function(t, n) {
    ym[t] = n;
  },
  unregister: function(t) {
    delete ym[t];
  },
  get: function(t) {
    return ym[t] || document.getElementById(t) || document.getElementsByName(t)[0] || document.getElementsByClassName(t)[0];
  },
  setActiveLink: function(t) {
    return WV = t;
  },
  getActiveLink: function() {
    return WV;
  },
  scrollTo: function(t, n) {
    var r = this.get(t);
    if (!r) {
      console.warn("target Element not found");
      return;
    }
    n = o9e({}, n, { absolute: !1 });
    var o = n.containerId, i = n.container, a = void 0;
    o ? a = document.getElementById(o) : i && i.nodeType ? a = i : a = document, n.absolute = !0;
    var s = n.horizontal, l = s9e.default.scrollOffset(a, r, s) + (n.offset || 0);
    if (!n.smooth) {
      vm.default.registered.begin && vm.default.registered.begin(t, r), a === document ? n.horizontal ? window.scrollTo(l, 0) : window.scrollTo(0, l) : a.scrollTop = l, vm.default.registered.end && vm.default.registered.end(t, r);
      return;
    }
    l9e.default.animateTopScroll(l, n, t, r);
  }
};
var m1 = { exports: {} }, bm = { exports: {} }, Rn = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var VV;
function c9e() {
  if (VV) return Rn;
  VV = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, g = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, m = e ? Symbol.for("react.block") : 60121, v = e ? Symbol.for("react.fundamental") : 60117, E = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
  function M(y) {
    if (typeof y == "object" && y !== null) {
      var C = y.$$typeof;
      switch (C) {
        case t:
          switch (y = y.type, y) {
            case l:
            case u:
            case r:
            case i:
            case o:
            case p:
              return y;
            default:
              switch (y = y && y.$$typeof, y) {
                case s:
                case c:
                case f:
                case g:
                case a:
                  return y;
                default:
                  return C;
              }
          }
        case n:
          return C;
      }
    }
  }
  function O(y) {
    return M(y) === u;
  }
  return Rn.AsyncMode = l, Rn.ConcurrentMode = u, Rn.ContextConsumer = s, Rn.ContextProvider = a, Rn.Element = t, Rn.ForwardRef = c, Rn.Fragment = r, Rn.Lazy = f, Rn.Memo = g, Rn.Portal = n, Rn.Profiler = i, Rn.StrictMode = o, Rn.Suspense = p, Rn.isAsyncMode = function(y) {
    return O(y) || M(y) === l;
  }, Rn.isConcurrentMode = O, Rn.isContextConsumer = function(y) {
    return M(y) === s;
  }, Rn.isContextProvider = function(y) {
    return M(y) === a;
  }, Rn.isElement = function(y) {
    return typeof y == "object" && y !== null && y.$$typeof === t;
  }, Rn.isForwardRef = function(y) {
    return M(y) === c;
  }, Rn.isFragment = function(y) {
    return M(y) === r;
  }, Rn.isLazy = function(y) {
    return M(y) === f;
  }, Rn.isMemo = function(y) {
    return M(y) === g;
  }, Rn.isPortal = function(y) {
    return M(y) === n;
  }, Rn.isProfiler = function(y) {
    return M(y) === i;
  }, Rn.isStrictMode = function(y) {
    return M(y) === o;
  }, Rn.isSuspense = function(y) {
    return M(y) === p;
  }, Rn.isValidElementType = function(y) {
    return typeof y == "string" || typeof y == "function" || y === r || y === u || y === i || y === o || y === p || y === d || typeof y == "object" && y !== null && (y.$$typeof === f || y.$$typeof === g || y.$$typeof === a || y.$$typeof === s || y.$$typeof === c || y.$$typeof === v || y.$$typeof === E || y.$$typeof === w || y.$$typeof === m);
  }, Rn.typeOf = M, Rn;
}
var Bn = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var ZV;
function p9e() {
  return ZV || (ZV = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, g = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, m = e ? Symbol.for("react.block") : 60121, v = e ? Symbol.for("react.fundamental") : 60117, E = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
    function M(B) {
      return typeof B == "string" || typeof B == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      B === r || B === u || B === i || B === o || B === p || B === d || typeof B == "object" && B !== null && (B.$$typeof === f || B.$$typeof === g || B.$$typeof === a || B.$$typeof === s || B.$$typeof === c || B.$$typeof === v || B.$$typeof === E || B.$$typeof === w || B.$$typeof === m);
    }
    function O(B) {
      if (typeof B == "object" && B !== null) {
        var ue = B.$$typeof;
        switch (ue) {
          case t:
            var fe = B.type;
            switch (fe) {
              case l:
              case u:
              case r:
              case i:
              case o:
              case p:
                return fe;
              default:
                var oe = fe && fe.$$typeof;
                switch (oe) {
                  case s:
                  case c:
                  case f:
                  case g:
                  case a:
                    return oe;
                  default:
                    return ue;
                }
            }
          case n:
            return ue;
        }
      }
    }
    var y = l, C = u, _ = s, F = a, L = t, N = c, R = r, W = f, V = g, z = n, Z = i, K = o, X = p, te = !1;
    function J(B) {
      return te || (te = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), P(B) || O(B) === l;
    }
    function P(B) {
      return O(B) === u;
    }
    function D(B) {
      return O(B) === s;
    }
    function H(B) {
      return O(B) === a;
    }
    function S(B) {
      return typeof B == "object" && B !== null && B.$$typeof === t;
    }
    function $(B) {
      return O(B) === c;
    }
    function x(B) {
      return O(B) === r;
    }
    function j(B) {
      return O(B) === f;
    }
    function U(B) {
      return O(B) === g;
    }
    function T(B) {
      return O(B) === n;
    }
    function q(B) {
      return O(B) === i;
    }
    function A(B) {
      return O(B) === o;
    }
    function Y(B) {
      return O(B) === p;
    }
    Bn.AsyncMode = y, Bn.ConcurrentMode = C, Bn.ContextConsumer = _, Bn.ContextProvider = F, Bn.Element = L, Bn.ForwardRef = N, Bn.Fragment = R, Bn.Lazy = W, Bn.Memo = V, Bn.Portal = z, Bn.Profiler = Z, Bn.StrictMode = K, Bn.Suspense = X, Bn.isAsyncMode = J, Bn.isConcurrentMode = P, Bn.isContextConsumer = D, Bn.isContextProvider = H, Bn.isElement = S, Bn.isForwardRef = $, Bn.isFragment = x, Bn.isLazy = j, Bn.isMemo = U, Bn.isPortal = T, Bn.isProfiler = q, Bn.isStrictMode = A, Bn.isSuspense = Y, Bn.isValidElementType = M, Bn.typeOf = O;
  }()), Bn;
}
var qV;
function XX() {
  return qV || (qV = 1, process.env.NODE_ENV === "production" ? bm.exports = c9e() : bm.exports = p9e()), bm.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var TO, GV;
function d9e() {
  if (GV) return TO;
  GV = 1;
  var e = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, n = Object.prototype.propertyIsEnumerable;
  function r(i) {
    if (i == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(i);
  }
  function o() {
    try {
      if (!Object.assign)
        return !1;
      var i = new String("abc");
      if (i[5] = "de", Object.getOwnPropertyNames(i)[0] === "5")
        return !1;
      for (var a = {}, s = 0; s < 10; s++)
        a["_" + String.fromCharCode(s)] = s;
      var l = Object.getOwnPropertyNames(a).map(function(c) {
        return a[c];
      });
      if (l.join("") !== "0123456789")
        return !1;
      var u = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(c) {
        u[c] = c;
      }), Object.keys(Object.assign({}, u)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return TO = o() ? Object.assign : function(i, a) {
    for (var s, l = r(i), u, c = 1; c < arguments.length; c++) {
      s = Object(arguments[c]);
      for (var p in s)
        t.call(s, p) && (l[p] = s[p]);
      if (e) {
        u = e(s);
        for (var d = 0; d < u.length; d++)
          n.call(s, u[d]) && (l[u[d]] = s[u[d]]);
      }
    }
    return l;
  }, TO;
}
var jO, KV;
function DS() {
  if (KV) return jO;
  KV = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return jO = e, jO;
}
var AO, YV;
function JX() {
  return YV || (YV = 1, AO = Function.call.bind(Object.prototype.hasOwnProperty)), AO;
}
var IO, XV;
function f9e() {
  if (XV) return IO;
  XV = 1;
  var e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = DS(), n = {}, r = JX();
    e = function(i) {
      var a = "Warning: " + i;
      typeof console < "u" && console.error(a);
      try {
        throw new Error(a);
      } catch {
      }
    };
  }
  function o(i, a, s, l, u) {
    if (process.env.NODE_ENV !== "production") {
      for (var c in i)
        if (r(i, c)) {
          var p;
          try {
            if (typeof i[c] != "function") {
              var d = Error(
                (l || "React class") + ": " + s + " type `" + c + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof i[c] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw d.name = "Invariant Violation", d;
            }
            p = i[c](a, c, l, s, null, t);
          } catch (f) {
            p = f;
          }
          if (p && !(p instanceof Error) && e(
            (l || "React class") + ": type specification of " + s + " `" + c + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof p + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), p instanceof Error && !(p.message in n)) {
            n[p.message] = !0;
            var g = u ? u() : "";
            e(
              "Failed " + s + " type: " + p.message + (g ?? "")
            );
          }
        }
    }
  }
  return o.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (n = {});
  }, IO = o, IO;
}
var RO, JV;
function h9e() {
  if (JV) return RO;
  JV = 1;
  var e = XX(), t = d9e(), n = DS(), r = JX(), o = f9e(), i = function() {
  };
  process.env.NODE_ENV !== "production" && (i = function(s) {
    var l = "Warning: " + s;
    typeof console < "u" && console.error(l);
    try {
      throw new Error(l);
    } catch {
    }
  });
  function a() {
    return null;
  }
  return RO = function(s, l) {
    var u = typeof Symbol == "function" && Symbol.iterator, c = "@@iterator";
    function p(P) {
      var D = P && (u && P[u] || P[c]);
      if (typeof D == "function")
        return D;
    }
    var d = "<<anonymous>>", g = {
      array: E("array"),
      bigint: E("bigint"),
      bool: E("boolean"),
      func: E("function"),
      number: E("number"),
      object: E("object"),
      string: E("string"),
      symbol: E("symbol"),
      any: w(),
      arrayOf: M,
      element: O(),
      elementType: y(),
      instanceOf: C,
      node: N(),
      objectOf: F,
      oneOf: _,
      oneOfType: L,
      shape: W,
      exact: V
    };
    function f(P, D) {
      return P === D ? P !== 0 || 1 / P === 1 / D : P !== P && D !== D;
    }
    function m(P, D) {
      this.message = P, this.data = D && typeof D == "object" ? D : {}, this.stack = "";
    }
    m.prototype = Error.prototype;
    function v(P) {
      if (process.env.NODE_ENV !== "production")
        var D = {}, H = 0;
      function S(x, j, U, T, q, A, Y) {
        if (T = T || d, A = A || U, Y !== n) {
          if (l) {
            var B = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw B.name = "Invariant Violation", B;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var ue = T + ":" + U;
            !D[ue] && // Avoid spamming the console because they are often not actionable except for lib authors
            H < 3 && (i(
              "You are manually calling a React.PropTypes validation function for the `" + A + "` prop on `" + T + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), D[ue] = !0, H++);
          }
        }
        return j[U] == null ? x ? j[U] === null ? new m("The " + q + " `" + A + "` is marked as required " + ("in `" + T + "`, but its value is `null`.")) : new m("The " + q + " `" + A + "` is marked as required in " + ("`" + T + "`, but its value is `undefined`.")) : null : P(j, U, T, q, A);
      }
      var $ = S.bind(null, !1);
      return $.isRequired = S.bind(null, !0), $;
    }
    function E(P) {
      function D(H, S, $, x, j, U) {
        var T = H[S], q = K(T);
        if (q !== P) {
          var A = X(T);
          return new m(
            "Invalid " + x + " `" + j + "` of type " + ("`" + A + "` supplied to `" + $ + "`, expected ") + ("`" + P + "`."),
            { expectedType: P }
          );
        }
        return null;
      }
      return v(D);
    }
    function w() {
      return v(a);
    }
    function M(P) {
      function D(H, S, $, x, j) {
        if (typeof P != "function")
          return new m("Property `" + j + "` of component `" + $ + "` has invalid PropType notation inside arrayOf.");
        var U = H[S];
        if (!Array.isArray(U)) {
          var T = K(U);
          return new m("Invalid " + x + " `" + j + "` of type " + ("`" + T + "` supplied to `" + $ + "`, expected an array."));
        }
        for (var q = 0; q < U.length; q++) {
          var A = P(U, q, $, x, j + "[" + q + "]", n);
          if (A instanceof Error)
            return A;
        }
        return null;
      }
      return v(D);
    }
    function O() {
      function P(D, H, S, $, x) {
        var j = D[H];
        if (!s(j)) {
          var U = K(j);
          return new m("Invalid " + $ + " `" + x + "` of type " + ("`" + U + "` supplied to `" + S + "`, expected a single ReactElement."));
        }
        return null;
      }
      return v(P);
    }
    function y() {
      function P(D, H, S, $, x) {
        var j = D[H];
        if (!e.isValidElementType(j)) {
          var U = K(j);
          return new m("Invalid " + $ + " `" + x + "` of type " + ("`" + U + "` supplied to `" + S + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return v(P);
    }
    function C(P) {
      function D(H, S, $, x, j) {
        if (!(H[S] instanceof P)) {
          var U = P.name || d, T = J(H[S]);
          return new m("Invalid " + x + " `" + j + "` of type " + ("`" + T + "` supplied to `" + $ + "`, expected ") + ("instance of `" + U + "`."));
        }
        return null;
      }
      return v(D);
    }
    function _(P) {
      if (!Array.isArray(P))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? i(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : i("Invalid argument supplied to oneOf, expected an array.")), a;
      function D(H, S, $, x, j) {
        for (var U = H[S], T = 0; T < P.length; T++)
          if (f(U, P[T]))
            return null;
        var q = JSON.stringify(P, function(Y, B) {
          var ue = X(B);
          return ue === "symbol" ? String(B) : B;
        });
        return new m("Invalid " + x + " `" + j + "` of value `" + String(U) + "` " + ("supplied to `" + $ + "`, expected one of " + q + "."));
      }
      return v(D);
    }
    function F(P) {
      function D(H, S, $, x, j) {
        if (typeof P != "function")
          return new m("Property `" + j + "` of component `" + $ + "` has invalid PropType notation inside objectOf.");
        var U = H[S], T = K(U);
        if (T !== "object")
          return new m("Invalid " + x + " `" + j + "` of type " + ("`" + T + "` supplied to `" + $ + "`, expected an object."));
        for (var q in U)
          if (r(U, q)) {
            var A = P(U, q, $, x, j + "." + q, n);
            if (A instanceof Error)
              return A;
          }
        return null;
      }
      return v(D);
    }
    function L(P) {
      if (!Array.isArray(P))
        return process.env.NODE_ENV !== "production" && i("Invalid argument supplied to oneOfType, expected an instance of array."), a;
      for (var D = 0; D < P.length; D++) {
        var H = P[D];
        if (typeof H != "function")
          return i(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + te(H) + " at index " + D + "."
          ), a;
      }
      function S($, x, j, U, T) {
        for (var q = [], A = 0; A < P.length; A++) {
          var Y = P[A], B = Y($, x, j, U, T, n);
          if (B == null)
            return null;
          B.data && r(B.data, "expectedType") && q.push(B.data.expectedType);
        }
        var ue = q.length > 0 ? ", expected one of type [" + q.join(", ") + "]" : "";
        return new m("Invalid " + U + " `" + T + "` supplied to " + ("`" + j + "`" + ue + "."));
      }
      return v(S);
    }
    function N() {
      function P(D, H, S, $, x) {
        return z(D[H]) ? null : new m("Invalid " + $ + " `" + x + "` supplied to " + ("`" + S + "`, expected a ReactNode."));
      }
      return v(P);
    }
    function R(P, D, H, S, $) {
      return new m(
        (P || "React class") + ": " + D + " type `" + H + "." + S + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + $ + "`."
      );
    }
    function W(P) {
      function D(H, S, $, x, j) {
        var U = H[S], T = K(U);
        if (T !== "object")
          return new m("Invalid " + x + " `" + j + "` of type `" + T + "` " + ("supplied to `" + $ + "`, expected `object`."));
        for (var q in P) {
          var A = P[q];
          if (typeof A != "function")
            return R($, x, j, q, X(A));
          var Y = A(U, q, $, x, j + "." + q, n);
          if (Y)
            return Y;
        }
        return null;
      }
      return v(D);
    }
    function V(P) {
      function D(H, S, $, x, j) {
        var U = H[S], T = K(U);
        if (T !== "object")
          return new m("Invalid " + x + " `" + j + "` of type `" + T + "` " + ("supplied to `" + $ + "`, expected `object`."));
        var q = t({}, H[S], P);
        for (var A in q) {
          var Y = P[A];
          if (r(P, A) && typeof Y != "function")
            return R($, x, j, A, X(Y));
          if (!Y)
            return new m(
              "Invalid " + x + " `" + j + "` key `" + A + "` supplied to `" + $ + "`.\nBad object: " + JSON.stringify(H[S], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(P), null, "  ")
            );
          var B = Y(U, A, $, x, j + "." + A, n);
          if (B)
            return B;
        }
        return null;
      }
      return v(D);
    }
    function z(P) {
      switch (typeof P) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !P;
        case "object":
          if (Array.isArray(P))
            return P.every(z);
          if (P === null || s(P))
            return !0;
          var D = p(P);
          if (D) {
            var H = D.call(P), S;
            if (D !== P.entries) {
              for (; !(S = H.next()).done; )
                if (!z(S.value))
                  return !1;
            } else
              for (; !(S = H.next()).done; ) {
                var $ = S.value;
                if ($ && !z($[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function Z(P, D) {
      return P === "symbol" ? !0 : D ? D["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && D instanceof Symbol : !1;
    }
    function K(P) {
      var D = typeof P;
      return Array.isArray(P) ? "array" : P instanceof RegExp ? "object" : Z(D, P) ? "symbol" : D;
    }
    function X(P) {
      if (typeof P > "u" || P === null)
        return "" + P;
      var D = K(P);
      if (D === "object") {
        if (P instanceof Date)
          return "date";
        if (P instanceof RegExp)
          return "regexp";
      }
      return D;
    }
    function te(P) {
      var D = X(P);
      switch (D) {
        case "array":
        case "object":
          return "an " + D;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + D;
        default:
          return D;
      }
    }
    function J(P) {
      return !P.constructor || !P.constructor.name ? d : P.constructor.name;
    }
    return g.checkPropTypes = o, g.resetWarningCache = o.resetWarningCache, g.PropTypes = g, g;
  }, RO;
}
var BO, QV;
function g9e() {
  if (QV) return BO;
  QV = 1;
  var e = DS();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, BO = function() {
    function r(a, s, l, u, c, p) {
      if (p !== e) {
        var d = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw d.name = "Invariant Violation", d;
      }
    }
    r.isRequired = r;
    function o() {
      return r;
    }
    var i = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: o,
      element: r,
      elementType: r,
      instanceOf: o,
      node: r,
      objectOf: o,
      oneOf: o,
      oneOfType: o,
      shape: o,
      exact: o,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return i.PropTypes = i, i;
  }, BO;
}
if (process.env.NODE_ENV !== "production") {
  var m9e = XX(), v9e = !0;
  m1.exports = h9e()(m9e.isElement, v9e);
} else
  m1.exports = g9e()();
var E0 = m1.exports, k0 = {};
Object.defineProperty(k0, "__esModule", {
  value: !0
});
var y9e = lh, NO = b9e(y9e);
function b9e(e) {
  return e && e.__esModule ? e : { default: e };
}
var w9e = {
  mountFlag: !1,
  initialized: !1,
  scroller: null,
  containers: {},
  mount: function(t) {
    this.scroller = t, this.handleHashChange = this.handleHashChange.bind(this), window.addEventListener("hashchange", this.handleHashChange), this.initStateFromHash(), this.mountFlag = !0;
  },
  mapContainer: function(t, n) {
    this.containers[t] = n;
  },
  isMounted: function() {
    return this.mountFlag;
  },
  isInitialized: function() {
    return this.initialized;
  },
  initStateFromHash: function() {
    var t = this, n = this.getHash();
    n ? window.setTimeout(function() {
      t.scrollTo(n, !0), t.initialized = !0;
    }, 10) : this.initialized = !0;
  },
  scrollTo: function(t, n) {
    var r = this.scroller, o = r.get(t);
    if (o && (n || t !== r.getActiveLink())) {
      var i = this.containers[t] || document;
      r.scrollTo(t, { container: i });
    }
  },
  getHash: function() {
    return NO.default.getHash();
  },
  changeHash: function(t, n) {
    this.isInitialized() && NO.default.getHash() !== t && NO.default.updateHash(t, n);
  },
  handleHashChange: function() {
    this.scrollTo(this.getHash());
  },
  unmount: function() {
    this.scroller = null, this.containers = null, window.removeEventListener("hashchange", this.handleHashChange);
  }
};
k0.default = w9e;
Object.defineProperty(ih, "__esModule", {
  value: !0
});
var wm = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, C9e = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), x9e = we, e9 = ph(x9e), O9e = sh, Cm = ph(O9e), E9e = zc, k9e = ph(E9e), L9e = E0, Fr = ph(L9e), P9e = k0, Ia = ph(P9e);
function ph(e) {
  return e && e.__esModule ? e : { default: e };
}
function _9e(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function S9e(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function M9e(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var t9 = {
  to: Fr.default.string.isRequired,
  containerId: Fr.default.string,
  container: Fr.default.object,
  activeClass: Fr.default.string,
  activeStyle: Fr.default.object,
  spy: Fr.default.bool,
  horizontal: Fr.default.bool,
  smooth: Fr.default.oneOfType([Fr.default.bool, Fr.default.string]),
  offset: Fr.default.number,
  delay: Fr.default.number,
  isDynamic: Fr.default.bool,
  onClick: Fr.default.func,
  duration: Fr.default.oneOfType([Fr.default.number, Fr.default.func]),
  absolute: Fr.default.bool,
  onSetActive: Fr.default.func,
  onSetInactive: Fr.default.func,
  ignoreCancelEvents: Fr.default.bool,
  hashSpy: Fr.default.bool,
  saveHashHistory: Fr.default.bool,
  spyThrottle: Fr.default.number
};
ih.default = function(e, t) {
  var n = t || k9e.default, r = function(i) {
    M9e(a, i);
    function a(s) {
      _9e(this, a);
      var l = S9e(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
      return o.call(l), l.state = {
        active: !1
      }, l.beforeUnmountCallbacks = [], l;
    }
    return C9e(a, [{
      key: "getScrollSpyContainer",
      value: function() {
        var l = this.props.containerId, u = this.props.container;
        return l && !u ? document.getElementById(l) : u && u.nodeType ? u : document;
      }
    }, {
      key: "componentDidMount",
      value: function() {
        if (this.props.spy || this.props.hashSpy) {
          var l = this.getScrollSpyContainer();
          if (!Cm.default.isMounted(l)) {
            var u = Cm.default.mount(l, this.props.spyThrottle);
            this.beforeUnmountCallbacks.push(u);
          }
          this.props.hashSpy && (Ia.default.isMounted() || Ia.default.mount(n), Ia.default.mapContainer(this.props.to, l)), Cm.default.addSpyHandler(this.spyHandler, l), this.setState({
            container: l
          });
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        Cm.default.unmount(this.stateHandler, this.spyHandler), this.beforeUnmountCallbacks.forEach(function(l) {
          return l();
        });
      }
    }, {
      key: "render",
      value: function() {
        var l = "";
        this.state && this.state.active ? l = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : l = this.props.className;
        var u = {};
        this.state && this.state.active ? u = wm({}, this.props.style, this.props.activeStyle) : u = wm({}, this.props.style);
        var c = wm({}, this.props);
        for (var p in t9)
          c.hasOwnProperty(p) && delete c[p];
        return c.className = l, c.style = u, c.onClick = this.handleClick, e9.default.createElement(e, c);
      }
    }]), a;
  }(e9.default.PureComponent), o = function() {
    var a = this;
    this.scrollTo = function(s, l) {
      n.scrollTo(s, wm({}, a.state, l));
    }, this.handleClick = function(s) {
      a.props.onClick && a.props.onClick(s), s.stopPropagation && s.stopPropagation(), s.preventDefault && s.preventDefault(), a.scrollTo(a.props.to, a.props);
    }, this.spyHandler = function(s, l) {
      var u = a.getScrollSpyContainer();
      if (!(Ia.default.isMounted() && !Ia.default.isInitialized())) {
        var c = a.props.horizontal, p = a.props.to, d = null, g = void 0, f = void 0;
        if (c) {
          var m = 0, v = 0, E = 0;
          if (u.getBoundingClientRect) {
            var w = u.getBoundingClientRect();
            E = w.left;
          }
          if (!d || a.props.isDynamic) {
            if (d = n.get(p), !d)
              return;
            var M = d.getBoundingClientRect();
            m = M.left - E + s, v = m + M.width;
          }
          var O = s - a.props.offset;
          g = O >= Math.floor(m) && O < Math.floor(v), f = O < Math.floor(m) || O >= Math.floor(v);
        } else {
          var y = 0, C = 0, _ = 0;
          if (u.getBoundingClientRect) {
            var F = u.getBoundingClientRect();
            _ = F.top;
          }
          if (!d || a.props.isDynamic) {
            if (d = n.get(p), !d)
              return;
            var L = d.getBoundingClientRect();
            y = L.top - _ + l, C = y + L.height;
          }
          var N = l - a.props.offset;
          g = N >= Math.floor(y) && N < Math.floor(C), f = N < Math.floor(y) || N >= Math.floor(C);
        }
        var R = n.getActiveLink();
        if (f) {
          if (p === R && n.setActiveLink(void 0), a.props.hashSpy && Ia.default.getHash() === p) {
            var W = a.props.saveHashHistory, V = W === void 0 ? !1 : W;
            Ia.default.changeHash("", V);
          }
          a.props.spy && a.state.active && (a.setState({ active: !1 }), a.props.onSetInactive && a.props.onSetInactive(p, d));
        }
        if (g && (R !== p || a.state.active === !1)) {
          n.setActiveLink(p);
          var z = a.props.saveHashHistory, Z = z === void 0 ? !1 : z;
          a.props.hashSpy && Ia.default.changeHash(p, Z), a.props.spy && (a.setState({ active: !0 }), a.props.onSetActive && a.props.onSetActive(p, d));
        }
      }
    };
  };
  return r.propTypes = t9, r.defaultProps = { offset: 0 }, r;
};
Object.defineProperty(LS, "__esModule", {
  value: !0
});
var D9e = we, n9 = QX(D9e), T9e = ih, j9e = QX(T9e);
function QX(e) {
  return e && e.__esModule ? e : { default: e };
}
function A9e(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function r9(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function I9e(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var R9e = function(e) {
  I9e(t, e);
  function t() {
    var n, r, o, i;
    A9e(this, t);
    for (var a = arguments.length, s = Array(a), l = 0; l < a; l++)
      s[l] = arguments[l];
    return i = (r = (o = r9(this, (n = t.__proto__ || Object.getPrototypeOf(t)).call.apply(n, [this].concat(s))), o), o.render = function() {
      return n9.default.createElement(
        "a",
        o.props,
        o.props.children
      );
    }, r), r9(o, i);
  }
  return t;
}(n9.default.Component);
LS.default = (0, j9e.default)(R9e);
var TS = {};
Object.defineProperty(TS, "__esModule", {
  value: !0
});
var B9e = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), N9e = we, o9 = eJ(N9e), F9e = ih, z9e = eJ(F9e);
function eJ(e) {
  return e && e.__esModule ? e : { default: e };
}
function U9e(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function H9e(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function $9e(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var W9e = function(e) {
  $9e(t, e);
  function t() {
    return U9e(this, t), H9e(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return B9e(t, [{
    key: "render",
    value: function() {
      return o9.default.createElement(
        "button",
        this.props,
        this.props.children
      );
    }
  }]), t;
}(o9.default.Component);
TS.default = (0, z9e.default)(W9e);
var jS = {}, L0 = {};
Object.defineProperty(L0, "__esModule", {
  value: !0
});
var V9e = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, Z9e = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), q9e = we, i9 = P0(q9e), G9e = pl;
P0(G9e);
var K9e = zc, s9 = P0(K9e), Y9e = E0, a9 = P0(Y9e);
function P0(e) {
  return e && e.__esModule ? e : { default: e };
}
function X9e(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function J9e(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function Q9e(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
L0.default = function(e) {
  var t = function(n) {
    Q9e(r, n);
    function r(o) {
      X9e(this, r);
      var i = J9e(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
      return i.childBindings = {
        domNode: null
      }, i;
    }
    return Z9e(r, [{
      key: "componentDidMount",
      value: function() {
        if (typeof window > "u")
          return !1;
        this.registerElems(this.props.name);
      }
    }, {
      key: "componentDidUpdate",
      value: function(i) {
        this.props.name !== i.name && this.registerElems(this.props.name);
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        if (typeof window > "u")
          return !1;
        s9.default.unregister(this.props.name);
      }
    }, {
      key: "registerElems",
      value: function(i) {
        s9.default.register(i, this.childBindings.domNode);
      }
    }, {
      key: "render",
      value: function() {
        return i9.default.createElement(e, V9e({}, this.props, { parentBindings: this.childBindings }));
      }
    }]), r;
  }(i9.default.Component);
  return t.propTypes = {
    name: a9.default.string,
    id: a9.default.string
  }, t;
};
Object.defineProperty(jS, "__esModule", {
  value: !0
});
var l9 = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, e6e = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), t6e = we, u9 = AS(t6e), n6e = L0, r6e = AS(n6e), o6e = E0, c9 = AS(o6e);
function AS(e) {
  return e && e.__esModule ? e : { default: e };
}
function i6e(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function s6e(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function a6e(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var tJ = function(e) {
  a6e(t, e);
  function t() {
    return i6e(this, t), s6e(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return e6e(t, [{
    key: "render",
    value: function() {
      var r = this, o = l9({}, this.props);
      return delete o.name, o.parentBindings && delete o.parentBindings, u9.default.createElement(
        "div",
        l9({}, o, { ref: function(a) {
          r.props.parentBindings.domNode = a;
        } }),
        this.props.children
      );
    }
  }]), t;
}(u9.default.Component);
tJ.propTypes = {
  name: c9.default.string,
  id: c9.default.string
};
jS.default = (0, r6e.default)(tJ);
var FO = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, p9 = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}();
function d9(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function f9(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function h9(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var xm = we, ql = sh, zO = zc, eo = E0, Ra = k0, g9 = {
  to: eo.string.isRequired,
  containerId: eo.string,
  container: eo.object,
  activeClass: eo.string,
  spy: eo.bool,
  smooth: eo.oneOfType([eo.bool, eo.string]),
  offset: eo.number,
  delay: eo.number,
  isDynamic: eo.bool,
  onClick: eo.func,
  duration: eo.oneOfType([eo.number, eo.func]),
  absolute: eo.bool,
  onSetActive: eo.func,
  onSetInactive: eo.func,
  ignoreCancelEvents: eo.bool,
  hashSpy: eo.bool,
  spyThrottle: eo.number
}, l6e = {
  Scroll: function(t, n) {
    console.warn("Helpers.Scroll is deprecated since v1.7.0");
    var r = n || zO, o = function(a) {
      h9(s, a);
      function s(l) {
        d9(this, s);
        var u = f9(this, (s.__proto__ || Object.getPrototypeOf(s)).call(this, l));
        return i.call(u), u.state = {
          active: !1
        }, u;
      }
      return p9(s, [{
        key: "getScrollSpyContainer",
        value: function() {
          var u = this.props.containerId, c = this.props.container;
          return u ? document.getElementById(u) : c && c.nodeType ? c : document;
        }
      }, {
        key: "componentDidMount",
        value: function() {
          if (this.props.spy || this.props.hashSpy) {
            var u = this.getScrollSpyContainer();
            ql.isMounted(u) || ql.mount(u, this.props.spyThrottle), this.props.hashSpy && (Ra.isMounted() || Ra.mount(r), Ra.mapContainer(this.props.to, u)), this.props.spy && ql.addStateHandler(this.stateHandler), ql.addSpyHandler(this.spyHandler, u), this.setState({
              container: u
            });
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          ql.unmount(this.stateHandler, this.spyHandler);
        }
      }, {
        key: "render",
        value: function() {
          var u = "";
          this.state && this.state.active ? u = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : u = this.props.className;
          var c = FO({}, this.props);
          for (var p in g9)
            c.hasOwnProperty(p) && delete c[p];
          return c.className = u, c.onClick = this.handleClick, xm.createElement(t, c);
        }
      }]), s;
    }(xm.Component), i = function() {
      var s = this;
      this.scrollTo = function(l, u) {
        r.scrollTo(l, FO({}, s.state, u));
      }, this.handleClick = function(l) {
        s.props.onClick && s.props.onClick(l), l.stopPropagation && l.stopPropagation(), l.preventDefault && l.preventDefault(), s.scrollTo(s.props.to, s.props);
      }, this.stateHandler = function() {
        r.getActiveLink() !== s.props.to && (s.state !== null && s.state.active && s.props.onSetInactive && s.props.onSetInactive(), s.setState({ active: !1 }));
      }, this.spyHandler = function(l) {
        var u = s.getScrollSpyContainer();
        if (!(Ra.isMounted() && !Ra.isInitialized())) {
          var c = s.props.to, p = null, d = 0, g = 0, f = 0;
          if (u.getBoundingClientRect) {
            var m = u.getBoundingClientRect();
            f = m.top;
          }
          if (!p || s.props.isDynamic) {
            if (p = r.get(c), !p)
              return;
            var v = p.getBoundingClientRect();
            d = v.top - f + l, g = d + v.height;
          }
          var E = l - s.props.offset, w = E >= Math.floor(d) && E < Math.floor(g), M = E < Math.floor(d) || E >= Math.floor(g), O = r.getActiveLink();
          if (M)
            return c === O && r.setActiveLink(void 0), s.props.hashSpy && Ra.getHash() === c && Ra.changeHash(), s.props.spy && s.state.active && (s.setState({ active: !1 }), s.props.onSetInactive && s.props.onSetInactive()), ql.updateStates();
          if (w && O !== c)
            return r.setActiveLink(c), s.props.hashSpy && Ra.changeHash(c), s.props.spy && (s.setState({ active: !0 }), s.props.onSetActive && s.props.onSetActive(c)), ql.updateStates();
        }
      };
    };
    return o.propTypes = g9, o.defaultProps = { offset: 0 }, o;
  },
  Element: function(t) {
    console.warn("Helpers.Element is deprecated since v1.7.0");
    var n = function(r) {
      h9(o, r);
      function o(i) {
        d9(this, o);
        var a = f9(this, (o.__proto__ || Object.getPrototypeOf(o)).call(this, i));
        return a.childBindings = {
          domNode: null
        }, a;
      }
      return p9(o, [{
        key: "componentDidMount",
        value: function() {
          if (typeof window > "u")
            return !1;
          this.registerElems(this.props.name);
        }
      }, {
        key: "componentDidUpdate",
        value: function(a) {
          this.props.name !== a.name && this.registerElems(this.props.name);
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          if (typeof window > "u")
            return !1;
          zO.unregister(this.props.name);
        }
      }, {
        key: "registerElems",
        value: function(a) {
          zO.register(a, this.childBindings.domNode);
        }
      }, {
        key: "render",
        value: function() {
          return xm.createElement(t, FO({}, this.props, { parentBindings: this.childBindings }));
        }
      }]), o;
    }(xm.Component);
    return n.propTypes = {
      name: eo.string,
      id: eo.string
    }, n;
  }
}, u6e = l6e;
Object.defineProperty(go, "__esModule", {
  value: !0
});
go.Helpers = go.ScrollElement = go.ScrollLink = dJ = go.animateScroll = go.scrollSpy = go.Events = go.scroller = go.Element = go.Button = go.Link = void 0;
var c6e = LS, nJ = Fs(c6e), p6e = TS, rJ = Fs(p6e), d6e = jS, oJ = Fs(d6e), f6e = zc, iJ = Fs(f6e), h6e = uh, sJ = Fs(h6e), g6e = sh, aJ = Fs(g6e), m6e = C0, lJ = Fs(m6e), v6e = ih, uJ = Fs(v6e), y6e = L0, cJ = Fs(y6e), b6e = u6e, pJ = Fs(b6e);
function Fs(e) {
  return e && e.__esModule ? e : { default: e };
}
go.Link = nJ.default;
go.Button = rJ.default;
go.Element = oJ.default;
go.scroller = iJ.default;
go.Events = sJ.default;
go.scrollSpy = aJ.default;
var dJ = go.animateScroll = lJ.default;
go.ScrollLink = uJ.default;
go.ScrollElement = cJ.default;
go.Helpers = pJ.default;
go.default = { Link: nJ.default, Button: rJ.default, Element: oJ.default, scroller: iJ.default, Events: sJ.default, scrollSpy: aJ.default, animateScroll: lJ.default, ScrollLink: uJ.default, ScrollElement: cJ.default, Helpers: pJ.default };
const IS = Ke({}), fJ = Ke({});
function w6e() {
  const e = ge(fJ);
  if (Object.entries(e).length === 0)
    throw new Error("useToast must be used within a Provider");
  return e;
}
function m9(e) {
  return e && typeof e.title == "string" && typeof e.message == "string" && (e.size === void 0 || e.size === "md" || e.size === "lg") && (e.type === "success" || e.type === "danger");
}
function V4e() {
  const e = k1(), { closeModal: t, closeAll: n, modalIsOpen: r } = ge(IS), { showToast: o } = w6e(), { getParam: i } = WX(), { pathname: a } = P1(), s = z6(), l = i("closeAllModals"), u = L1();
  h(() => {
    var d, g;
    const c = ((g = (d = u[0]) == null ? void 0 : d.data) == null ? void 0 : g.closeModalKey) || "", p = r(c);
    c && p && t(c);
  }, [u]), h(() => {
    l === "true" && (n(), s(a));
  }, [l]), h(() => {
    const c = e == null ? void 0 : e.closeModalKey;
    c && t(c);
  }, [e]), h(() => {
    const c = e == null ? void 0 : e.closeAllModals;
    typeof c == "boolean" && c && n();
  }, [e]), h(() => {
    const c = e == null ? void 0 : e.toast, p = e == null ? void 0 : e.message;
    m9(c) && o(c), !m9(c) && p && o({ message: p, type: "danger" });
  }, [e]), h(() => {
    var c, p;
    if (typeof ((c = e == null ? void 0 : e.data) == null ? void 0 : c.scrollTo) == "string") {
      const d = document.getElementById((p = e == null ? void 0 : e.data) == null ? void 0 : p.scrollTo);
      d && dJ.scrollTo(d.offsetTop - 200);
    }
  }, [e]);
}
const hJ = Ke({});
function Z4e(e) {
  const t = ge(hJ);
  if (Object.entries(t).length === 0)
    throw new Error("useDrawer must be used within a Provider");
  if (e) {
    const {
      drawerData: n,
      drawerIsOpen: r,
      openDrawer: o,
      closeDrawer: i
    } = t, a = r(e), s = n(e);
    return { drawerIsOpen: a, drawerData: s, openDrawer: (c) => o(e, c), closeDrawer: () => i(e) };
  } else
    return t;
}
function C6e() {
  return () => {
  };
}
function x6e() {
  return WJ(
    C6e,
    () => !0,
    () => !1
  );
}
function q4e(e) {
  const t = ge(IS);
  if (Object.entries(t).length === 0)
    throw new Error("useModal must be used within a Provider");
  if (e) {
    const {
      modalData: n,
      modalIsOpen: r,
      openModal: o,
      closeModal: i
    } = t, a = r(e), s = n(e);
    return { modalIsOpen: a, modalData: s, openModal: (c) => o(e, c), closeModal: () => i(e) };
  } else
    return t;
}
function G4e(e) {
  const { children: t = !1 } = e, [n, r] = k([]);
  function o(l) {
    return !!n.some((u) => u.key === l);
  }
  function i(l) {
    var u;
    return (u = n.find((c) => c.key === l)) == null ? void 0 : u.data;
  }
  function a(l, u) {
    const c = o(l);
    r(c ? (p) => [...p.filter((g) => g.key !== l), { key: l, data: u }] : [...n, { key: l, data: u }]);
  }
  function s(l) {
    r(n.filter((u) => u.key !== l));
  }
  return /* @__PURE__ */ Q.jsx(
    hJ.Provider,
    {
      value: { drawerIsOpen: o, drawerData: i, openDrawer: a, closeDrawer: s },
      children: t
    }
  );
}
function mf(e) {
  "@babel/helpers - typeof";
  return mf = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, mf(e);
}
function O6e(e, t) {
  if (mf(e) != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (mf(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function E6e(e) {
  var t = O6e(e, "string");
  return mf(t) == "symbol" ? t : t + "";
}
function ye(e, t, n) {
  return (t = E6e(t)) in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function gJ(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var UO, v9;
function k6e() {
  if (v9) return UO;
  v9 = 1;
  var e = process.env.NODE_ENV, t = function(r, o, i, a, s, l, u, c) {
    if (e !== "production" && o === void 0)
      throw new Error("invariant requires an error message argument");
    if (!r) {
      var p;
      if (o === void 0)
        p = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
      else {
        var d = [i, a, s, l, u, c], g = 0;
        p = new Error(o.replace(/%s/g, function() {
          return d[g++];
        })), p.name = "Invariant Violation";
      }
      throw p.framesToPop = 1, p;
    }
  };
  return UO = t, UO;
}
var L6e = k6e(), Eo = /* @__PURE__ */ gJ(L6e), Dt = Ke(null);
function P6e() {
  Eo(!!ge, "useGoogleMap is React hook and requires React version 16.8+");
  var e = ge(Dt);
  return Eo(!!e, "useGoogleMap needs a GoogleMap available up in the tree"), e;
}
function _6e(e, t, n) {
  return Object.keys(e).reduce(function(o, i) {
    return t(o, e[i], i);
  }, n);
}
function S6e(e, t) {
  Object.keys(e).forEach((n) => t(e[n], n));
}
function M6e(e, t, n, r) {
  var o = {}, i = (a, s) => {
    var l = n[s];
    l !== t[s] && (o[s] = l, a(r, l));
  };
  return S6e(e, i), o;
}
function D6e(e, t, n) {
  var r = _6e(n, function(i, a, s) {
    return typeof e[s] == "function" && i.push(google.maps.event.addListener(t, a, e[s])), i;
  }, []);
  return r;
}
function T6e(e) {
  google.maps.event.removeListener(e);
}
function Qt() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  e.forEach(T6e);
}
function Vt(e) {
  var {
    updaterMap: t,
    eventMap: n,
    prevProps: r,
    nextProps: o,
    instance: i
  } = e, a = D6e(o, i, n);
  return M6e(t, r, o, i), a;
}
var y9 = {
  onDblClick: "dblclick",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMapTypeIdChanged: "maptypeid_changed",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseDown: "mousedown",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onTilesLoaded: "tilesloaded",
  onBoundsChanged: "bounds_changed",
  onCenterChanged: "center_changed",
  onClick: "click",
  onDrag: "drag",
  onHeadingChanged: "heading_changed",
  onIdle: "idle",
  onProjectionChanged: "projection_changed",
  onResize: "resize",
  onTiltChanged: "tilt_changed",
  onZoomChanged: "zoom_changed"
}, b9 = {
  extraMapTypes(e, t) {
    t.forEach(function(r, o) {
      e.mapTypes.set(String(o), r);
    });
  },
  center(e, t) {
    e.setCenter(t);
  },
  clickableIcons(e, t) {
    e.setClickableIcons(t);
  },
  heading(e, t) {
    e.setHeading(t);
  },
  mapTypeId(e, t) {
    e.setMapTypeId(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  streetView(e, t) {
    e.setStreetView(t);
  },
  tilt(e, t) {
    e.setTilt(t);
  },
  zoom(e, t) {
    e.setZoom(t);
  }
};
function j6e(e) {
  var {
    children: t,
    options: n,
    id: r,
    mapContainerStyle: o,
    mapContainerClassName: i,
    center: a,
    // clickableIcons,
    // extraMapTypes,
    // heading,
    // mapTypeId,
    onClick: s,
    onDblClick: l,
    onDrag: u,
    onDragEnd: c,
    onDragStart: p,
    onMouseMove: d,
    onMouseOut: g,
    onMouseOver: f,
    onMouseDown: m,
    onMouseUp: v,
    onRightClick: E,
    // onMapTypeIdChanged,
    // onTilesLoaded,
    // onBoundsChanged,
    onCenterChanged: w,
    // onHeadingChanged,
    // onIdle,
    // onProjectionChanged,
    // onResize,
    // onTiltChanged,
    // onZoomChanged,
    onLoad: M,
    onUnmount: O
  } = e, [y, C] = k(null), _ = ut(null), [F, L] = k(null), [N, R] = k(null), [W, V] = k(null), [z, Z] = k(null), [K, X] = k(null), [te, J] = k(null), [P, D] = k(null), [H, S] = k(null), [$, x] = k(null), [j, U] = k(null), [T, q] = k(null), [A, Y] = k(null);
  return h(() => {
    n && y !== null && y.setOptions(n);
  }, [y, n]), h(() => {
    y !== null && typeof a < "u" && y.setCenter(a);
  }, [y, a]), h(() => {
    y && l && (N !== null && google.maps.event.removeListener(N), R(google.maps.event.addListener(y, "dblclick", l)));
  }, [l]), h(() => {
    y && c && (W !== null && google.maps.event.removeListener(W), V(google.maps.event.addListener(y, "dragend", c)));
  }, [c]), h(() => {
    y && p && (z !== null && google.maps.event.removeListener(z), Z(google.maps.event.addListener(y, "dragstart", p)));
  }, [p]), h(() => {
    y && m && (K !== null && google.maps.event.removeListener(K), X(google.maps.event.addListener(y, "mousedown", m)));
  }, [m]), h(() => {
    y && d && (te !== null && google.maps.event.removeListener(te), J(google.maps.event.addListener(y, "mousemove", d)));
  }, [d]), h(() => {
    y && g && (P !== null && google.maps.event.removeListener(P), D(google.maps.event.addListener(y, "mouseout", g)));
  }, [g]), h(() => {
    y && f && (H !== null && google.maps.event.removeListener(H), S(google.maps.event.addListener(y, "mouseover", f)));
  }, [f]), h(() => {
    y && v && ($ !== null && google.maps.event.removeListener($), x(google.maps.event.addListener(y, "mouseup", v)));
  }, [v]), h(() => {
    y && E && (j !== null && google.maps.event.removeListener(j), U(google.maps.event.addListener(y, "rightclick", E)));
  }, [E]), h(() => {
    y && s && (T !== null && google.maps.event.removeListener(T), q(google.maps.event.addListener(y, "click", s)));
  }, [s]), h(() => {
    y && u && (A !== null && google.maps.event.removeListener(A), Y(google.maps.event.addListener(y, "drag", u)));
  }, [u]), h(() => {
    y && w && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(y, "center_changed", w)));
  }, [s]), h(() => {
    var B = _.current === null ? null : new google.maps.Map(_.current, n);
    return C(B), B !== null && M && M(B), () => {
      B !== null && O && O(B);
    };
  }, []), Q.jsx("div", {
    id: r,
    ref: _,
    style: o,
    className: i,
    children: Q.jsx(Dt.Provider, {
      value: y,
      children: y !== null ? t : null
    })
  });
}
ve(j6e);
let A6e = class extends pe {
  constructor() {
    super(...arguments), ye(this, "state", {
      map: null
    }), ye(this, "registeredEvents", []), ye(this, "mapRef", null), ye(this, "getInstance", () => this.mapRef === null ? null : new google.maps.Map(this.mapRef, this.props.options)), ye(this, "panTo", (t) => {
      var n = this.getInstance();
      n && n.panTo(t);
    }), ye(this, "setMapCallback", () => {
      this.state.map !== null && this.props.onLoad && this.props.onLoad(this.state.map);
    }), ye(this, "getRef", (t) => {
      this.mapRef = t;
    });
  }
  componentDidMount() {
    var t = this.getInstance();
    this.registeredEvents = Vt({
      updaterMap: b9,
      eventMap: y9,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        map: t
      };
    }, this.setMapCallback);
  }
  componentDidUpdate(t) {
    this.state.map !== null && (Qt(this.registeredEvents), this.registeredEvents = Vt({
      updaterMap: b9,
      eventMap: y9,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.map
    }));
  }
  componentWillUnmount() {
    this.state.map !== null && (this.props.onUnmount && this.props.onUnmount(this.state.map), Qt(this.registeredEvents));
  }
  render() {
    return Q.jsx("div", {
      id: this.props.id,
      ref: this.getRef,
      style: this.props.mapContainerStyle,
      className: this.props.mapContainerClassName,
      children: Q.jsx(Dt.Provider, {
        value: this.state.map,
        children: this.state.map !== null ? this.props.children : null
      })
    });
  }
};
function w9(e, t, n, r, o, i, a) {
  try {
    var s = e[i](a), l = s.value;
  } catch (u) {
    return void n(u);
  }
  s.done ? t(l) : Promise.resolve(l).then(r, o);
}
function mJ(e) {
  return function() {
    var t = this, n = arguments;
    return new Promise(function(r, o) {
      var i = e.apply(t, n);
      function a(l) {
        w9(i, r, o, a, s, "next", l);
      }
      function s(l) {
        w9(i, r, o, a, s, "throw", l);
      }
      a(void 0);
    });
  };
}
function vJ(e) {
  var {
    googleMapsApiKey: t,
    googleMapsClientId: n,
    version: r = "weekly",
    language: o,
    region: i,
    libraries: a,
    channel: s,
    mapIds: l,
    authReferrerPolicy: u
  } = e, c = [];
  return Eo(t && n || !(t && n), "You need to specify either googleMapsApiKey or googleMapsClientId for @react-google-maps/api load script to work. You cannot use both at the same time."), t ? c.push("key=".concat(t)) : n && c.push("client=".concat(n)), r && c.push("v=".concat(r)), o && c.push("language=".concat(o)), i && c.push("region=".concat(i)), a && a.length && c.push("libraries=".concat(a.sort().join(","))), s && c.push("channel=".concat(s)), l && l.length && c.push("map_ids=".concat(l.join(","))), u && c.push("auth_referrer_policy=".concat(u)), c.push("loading=async"), c.push("callback=initMap"), "https://maps.googleapis.com/maps/api/js?".concat(c.join("&"));
}
var yu = typeof document < "u";
function yJ(e) {
  var {
    url: t,
    id: n,
    nonce: r
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } = e;
  return yu ? new Promise(function(i, a) {
    var s = document.getElementById(n), l = window;
    if (s) {
      var u = s.getAttribute("data-state");
      if (s.src === t && u !== "error") {
        if (u === "ready")
          return i(n);
        var c = l.initMap, p = s.onerror;
        l.initMap = function() {
          c && c(), i(n);
        }, s.onerror = function(g) {
          p && p(g), a(g);
        };
        return;
      } else
        s.remove();
    }
    var d = document.createElement("script");
    d.type = "text/javascript", d.src = t, d.id = n, d.async = !0, d.nonce = r || "", d.onerror = function(f) {
      d.setAttribute("data-state", "error"), a(f);
    }, l.initMap = function() {
      d.setAttribute("data-state", "ready"), i(n);
    }, document.head.appendChild(d);
  }).catch((o) => {
    throw console.error("injectScript error: ", o), o;
  }) : Promise.reject(new Error("document is undefined"));
}
function C9(e) {
  var t = e.href;
  return t && (t.indexOf("https://fonts.googleapis.com/css?family=Roboto") === 0 || t.indexOf("https://fonts.googleapis.com/css?family=Google+Sans+Text") === 0) ? !0 : (
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.styleSheet.cssText = "", !0) : (
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.innerHTML = "", !0) : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.innerHTML
      )
    )
  );
}
function bJ() {
  var e = document.getElementsByTagName("head")[0];
  if (e) {
    var t = e.insertBefore.bind(e);
    e.insertBefore = function(o, i) {
      return C9(o) || Reflect.apply(t, e, [o, i]), o;
    };
    var n = e.appendChild.bind(e);
    e.appendChild = function(o) {
      return C9(o) || Reflect.apply(n, e, [o]), o;
    };
  }
}
var Op = !1;
function wJ() {
  return Q.jsx("div", {
    children: "Loading..."
  });
}
var v1 = {
  id: "script-loader",
  version: "weekly"
};
class CJ extends pe {
  constructor() {
    super(...arguments), ye(this, "check", null), ye(this, "state", {
      loaded: !1
    }), ye(this, "cleanupCallback", () => {
      delete window.google.maps, this.injectScript();
    }), ye(this, "isCleaningUp", /* @__PURE__ */ mJ(function* () {
      function t(n) {
        if (!Op)
          n();
        else if (yu)
          var r = window.setInterval(function() {
            Op || (window.clearInterval(r), n());
          }, 1);
      }
      return new Promise(t);
    })), ye(this, "cleanup", () => {
      Op = !0;
      var t = document.getElementById(this.props.id);
      t && t.parentNode && t.parentNode.removeChild(t), Array.prototype.slice.call(document.getElementsByTagName("script")).filter(function(r) {
        return typeof r.src == "string" && r.src.includes("maps.googleapis");
      }).forEach(function(r) {
        r.parentNode && r.parentNode.removeChild(r);
      }), Array.prototype.slice.call(document.getElementsByTagName("link")).filter(function(r) {
        return r.href === "https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Google+Sans";
      }).forEach(function(r) {
        r.parentNode && r.parentNode.removeChild(r);
      }), Array.prototype.slice.call(document.getElementsByTagName("style")).filter(function(r) {
        return r.innerText !== void 0 && r.innerText.length > 0 && r.innerText.includes(".gm-");
      }).forEach(function(r) {
        r.parentNode && r.parentNode.removeChild(r);
      });
    }), ye(this, "injectScript", () => {
      this.props.preventGoogleFontsLoading && bJ(), Eo(!!this.props.id, 'LoadScript requires "id" prop to be a string: %s', this.props.id);
      var t = {
        id: this.props.id,
        nonce: this.props.nonce,
        url: vJ(this.props)
      };
      yJ(t).then(() => {
        this.props.onLoad && this.props.onLoad(), this.setState(function() {
          return {
            loaded: !0
          };
        });
      }).catch((n) => {
        this.props.onError && this.props.onError(n), console.error(`
          There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(this.props.googleMapsApiKey || "-", ") or Client ID (").concat(this.props.googleMapsClientId || "-", `) to <LoadScript />
          Otherwise it is a Network issue.
        `));
      });
    }), ye(this, "getRef", (t) => {
      this.check = t;
    });
  }
  componentDidMount() {
    if (yu) {
      if (window.google && window.google.maps && !Op) {
        console.error("google api is already presented");
        return;
      }
      this.isCleaningUp().then(this.injectScript).catch(function(n) {
        console.error("Error at injecting script after cleaning up: ", n);
      });
    }
  }
  componentDidUpdate(t) {
    this.props.libraries !== t.libraries && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), yu && t.language !== this.props.language && (this.cleanup(), this.setState(function() {
      return {
        loaded: !1
      };
    }, this.cleanupCallback));
  }
  componentWillUnmount() {
    if (yu) {
      this.cleanup();
      var t = () => {
        this.check || (delete window.google, Op = !1);
      };
      window.setTimeout(t, 1), this.props.onUnmount && this.props.onUnmount();
    }
  }
  render() {
    return Q.jsxs(Q.Fragment, {
      children: [Q.jsx("div", {
        ref: this.getRef
      }), this.state.loaded ? this.props.children : this.props.loadingElement || Q.jsx(wJ, {})]
    });
  }
}
ye(CJ, "defaultProps", v1);
function I6e(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.includes(r)) continue;
    n[r] = e[r];
  }
  return n;
}
function RS(e, t) {
  if (e == null) return {};
  var n, r, o = I6e(e, t);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (r = 0; r < i.length; r++) n = i[r], t.includes(n) || {}.propertyIsEnumerable.call(e, n) && (o[n] = e[n]);
  }
  return o;
}
var x9;
function R6e(e) {
  var {
    id: t = v1.id,
    version: n = v1.version,
    nonce: r,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    preventGoogleFontsLoading: u,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  } = e, g = ut(!1), [f, m] = k(!1), [v, E] = k(void 0);
  h(function() {
    return g.current = !0, () => {
      g.current = !1;
    };
  }, []), h(function() {
    yu && u && bJ();
  }, [u]), h(function() {
    f && Eo(!!window.google, "useLoadScript was marked as loaded, but window.google is not present. Something went wrong.");
  }, [f]);
  var w = vJ({
    version: n,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  });
  h(function() {
    if (!yu)
      return;
    function y() {
      g.current && (m(!0), x9 = w);
    }
    if (window.google && window.google.maps && x9 === w) {
      y();
      return;
    }
    yJ({
      id: t,
      url: w,
      nonce: r
    }).then(y).catch(function(_) {
      g.current && E(_), console.warn(`
        There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(o || "-", ") or Client ID (").concat(i || "-", `)
        Otherwise it is a Network issue.
      `)), console.error(_);
    });
  }, [t, w, r]);
  var M = ut(void 0);
  return h(function() {
    M.current && l !== M.current && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), M.current = l;
  }, [l]), {
    isLoaded: f,
    loadError: v,
    url: w
  };
}
var B6e = ["loadingElement", "onLoad", "onError", "onUnmount", "children"], N6e = Q.jsx(wJ, {});
function F6e(e) {
  var {
    loadingElement: t,
    onLoad: n,
    onError: r,
    onUnmount: o,
    children: i
  } = e, a = RS(e, B6e), {
    isLoaded: s,
    loadError: l
  } = R6e(a);
  return h(function() {
    s && typeof n == "function" && n();
  }, [s, n]), h(function() {
    l && typeof r == "function" && r(l);
  }, [l, r]), h(function() {
    return () => {
      o && o();
    };
  }, [o]), s ? i : t || N6e;
}
ve(F6e);
var O9;
(function(e) {
  e[e.INITIALIZED = 0] = "INITIALIZED", e[e.LOADING = 1] = "LOADING", e[e.SUCCESS = 2] = "SUCCESS", e[e.FAILURE = 3] = "FAILURE";
})(O9 || (O9 = {}));
function E9(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Ry(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? E9(Object(n), !0).forEach(function(r) {
      ye(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : E9(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var k9 = {}, L9 = {
  options(e, t) {
    e.setOptions(t);
  }
};
function z6e(e) {
  var {
    options: t,
    onLoad: n,
    onUnmount: r
  } = e, o = ge(Dt), [i, a] = k(null);
  return h(() => {
    i !== null && i.setMap(o);
  }, [o]), h(() => {
    t && i !== null && i.setOptions(t);
  }, [i, t]), h(() => {
    var s = new google.maps.TrafficLayer(Ry(Ry({}, t), {}, {
      map: o
    }));
    return a(s), n && n(s), () => {
      i !== null && (r && r(i), i.setMap(null));
    };
  }, []), null;
}
ve(z6e);
class U6e extends pe {
  constructor() {
    super(...arguments), ye(this, "state", {
      trafficLayer: null
    }), ye(this, "setTrafficLayerCallback", () => {
      this.state.trafficLayer !== null && this.props.onLoad && this.props.onLoad(this.state.trafficLayer);
    }), ye(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = new google.maps.TrafficLayer(Ry(Ry({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Vt({
      updaterMap: L9,
      eventMap: k9,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        trafficLayer: t
      };
    }, this.setTrafficLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.trafficLayer !== null && (Qt(this.registeredEvents), this.registeredEvents = Vt({
      updaterMap: L9,
      eventMap: k9,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.trafficLayer
    }));
  }
  componentWillUnmount() {
    this.state.trafficLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.trafficLayer), Qt(this.registeredEvents), this.state.trafficLayer.setMap(null));
  }
  render() {
    return null;
  }
}
ye(U6e, "contextType", Dt);
function H6e(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = ge(Dt), [o, i] = k(null);
  return h(() => {
    o !== null && o.setMap(r);
  }, [r]), h(() => {
    var a = new google.maps.BicyclingLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      a !== null && (n && n(a), a.setMap(null));
    };
  }, []), null;
}
ve(H6e);
class $6e extends pe {
  constructor() {
    super(...arguments), ye(this, "state", {
      bicyclingLayer: null
    }), ye(this, "setBicyclingLayerCallback", () => {
      this.state.bicyclingLayer !== null && (this.state.bicyclingLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.bicyclingLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.BicyclingLayer();
    this.setState(() => ({
      bicyclingLayer: t
    }), this.setBicyclingLayerCallback);
  }
  componentWillUnmount() {
    this.state.bicyclingLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.bicyclingLayer), this.state.bicyclingLayer.setMap(null));
  }
  render() {
    return null;
  }
}
ye($6e, "contextType", Dt);
function W6e(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = ge(Dt), [o, i] = k(null);
  return h(() => {
    o !== null && o.setMap(r);
  }, [r]), h(() => {
    var a = new google.maps.TransitLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      o !== null && (n && n(o), o.setMap(null));
    };
  }, []), null;
}
ve(W6e);
class V6e extends pe {
  constructor() {
    super(...arguments), ye(this, "state", {
      transitLayer: null
    }), ye(this, "setTransitLayerCallback", () => {
      this.state.transitLayer !== null && (this.state.transitLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.transitLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.TransitLayer();
    this.setState(function() {
      return {
        transitLayer: t
      };
    }, this.setTransitLayerCallback);
  }
  componentWillUnmount() {
    this.state.transitLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.transitLayer), this.state.transitLayer.setMap(null));
  }
  render() {
    return null;
  }
}
ye(V6e, "contextType", Dt);
function P9(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function By(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? P9(Object(n), !0).forEach(function(r) {
      ye(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : P9(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var _9 = {
  onCircleComplete: "circlecomplete",
  onMarkerComplete: "markercomplete",
  onOverlayComplete: "overlaycomplete",
  onPolygonComplete: "polygoncomplete",
  onPolylineComplete: "polylinecomplete",
  onRectangleComplete: "rectanglecomplete"
}, S9 = {
  drawingMode(e, t) {
    e.setDrawingMode(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function Z6e(e) {
  var {
    options: t,
    drawingMode: n,
    onCircleComplete: r,
    onMarkerComplete: o,
    onOverlayComplete: i,
    onPolygonComplete: a,
    onPolylineComplete: s,
    onRectangleComplete: l,
    onLoad: u,
    onUnmount: c
  } = e, p = ge(Dt), [d, g] = k(null), [f, m] = k(null), [v, E] = k(null), [w, M] = k(null), [O, y] = k(null), [C, _] = k(null), [F, L] = k(null);
  return h(() => {
    d !== null && d.setMap(p);
  }, [p]), h(() => {
    t && d !== null && d.setOptions(t);
  }, [d, t]), h(() => {
    d !== null && d.setDrawingMode(n ?? null);
  }, [d, n]), h(() => {
    d && r && (f !== null && google.maps.event.removeListener(f), m(google.maps.event.addListener(d, "circlecomplete", r)));
  }, [d, r]), h(() => {
    d && o && (v !== null && google.maps.event.removeListener(v), E(google.maps.event.addListener(d, "markercomplete", o)));
  }, [d, o]), h(() => {
    d && i && (w !== null && google.maps.event.removeListener(w), M(google.maps.event.addListener(d, "overlaycomplete", i)));
  }, [d, i]), h(() => {
    d && a && (O !== null && google.maps.event.removeListener(O), y(google.maps.event.addListener(d, "polygoncomplete", a)));
  }, [d, a]), h(() => {
    d && s && (C !== null && google.maps.event.removeListener(C), _(google.maps.event.addListener(d, "polylinecomplete", s)));
  }, [d, s]), h(() => {
    d && l && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(d, "rectanglecomplete", l)));
  }, [d, l]), h(() => {
    Eo(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
    var N = new google.maps.drawing.DrawingManager(By(By({}, t), {}, {
      map: p
    }));
    return n && N.setDrawingMode(n), r && m(google.maps.event.addListener(N, "circlecomplete", r)), o && E(google.maps.event.addListener(N, "markercomplete", o)), i && M(google.maps.event.addListener(N, "overlaycomplete", i)), a && y(google.maps.event.addListener(N, "polygoncomplete", a)), s && _(google.maps.event.addListener(N, "polylinecomplete", s)), l && L(google.maps.event.addListener(N, "rectanglecomplete", l)), g(N), u && u(N), () => {
      d !== null && (f && google.maps.event.removeListener(f), v && google.maps.event.removeListener(v), w && google.maps.event.removeListener(w), O && google.maps.event.removeListener(O), C && google.maps.event.removeListener(C), F && google.maps.event.removeListener(F), c && c(d), d.setMap(null));
    };
  }, []), null;
}
ve(Z6e);
class q6e extends pe {
  constructor(t) {
    super(t), ye(this, "registeredEvents", []), ye(this, "state", {
      drawingManager: null
    }), ye(this, "setDrawingManagerCallback", () => {
      this.state.drawingManager !== null && this.props.onLoad && this.props.onLoad(this.state.drawingManager);
    }), Eo(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
  }
  componentDidMount() {
    var t = new google.maps.drawing.DrawingManager(By(By({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Vt({
      updaterMap: S9,
      eventMap: _9,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        drawingManager: t
      };
    }, this.setDrawingManagerCallback);
  }
  componentDidUpdate(t) {
    this.state.drawingManager !== null && (Qt(this.registeredEvents), this.registeredEvents = Vt({
      updaterMap: S9,
      eventMap: _9,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.drawingManager
    }));
  }
  componentWillUnmount() {
    this.state.drawingManager !== null && (this.props.onUnmount && this.props.onUnmount(this.state.drawingManager), Qt(this.registeredEvents), this.state.drawingManager.setMap(null));
  }
  render() {
    return null;
  }
}
ye(q6e, "contextType", Dt);
function M9(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function pc(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? M9(Object(n), !0).forEach(function(r) {
      ye(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : M9(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var D9 = {
  onAnimationChanged: "animation_changed",
  onClick: "click",
  onClickableChanged: "clickable_changed",
  onCursorChanged: "cursor_changed",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDraggableChanged: "draggable_changed",
  onDragStart: "dragstart",
  onFlatChanged: "flat_changed",
  onIconChanged: "icon_changed",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onPositionChanged: "position_changed",
  onRightClick: "rightclick",
  onShapeChanged: "shape_changed",
  onTitleChanged: "title_changed",
  onVisibleChanged: "visible_changed",
  onZindexChanged: "zindex_changed"
}, T9 = {
  animation(e, t) {
    e.setAnimation(t);
  },
  clickable(e, t) {
    e.setClickable(t);
  },
  cursor(e, t) {
    e.setCursor(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  icon(e, t) {
    e.setIcon(t);
  },
  label(e, t) {
    e.setLabel(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  opacity(e, t) {
    e.setOpacity(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  shape(e, t) {
    e.setShape(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, Ny = {};
function G6e(e) {
  var {
    position: t,
    options: n,
    clusterer: r,
    noClustererRedraw: o,
    children: i,
    draggable: a,
    visible: s,
    animation: l,
    clickable: u,
    cursor: c,
    icon: p,
    label: d,
    opacity: g,
    shape: f,
    title: m,
    zIndex: v,
    onClick: E,
    onDblClick: w,
    onDrag: M,
    onDragEnd: O,
    onDragStart: y,
    onMouseOut: C,
    onMouseOver: _,
    onMouseUp: F,
    onMouseDown: L,
    onRightClick: N,
    onClickableChanged: R,
    onCursorChanged: W,
    onAnimationChanged: V,
    onDraggableChanged: z,
    onFlatChanged: Z,
    onIconChanged: K,
    onPositionChanged: X,
    onShapeChanged: te,
    onTitleChanged: J,
    onVisibleChanged: P,
    onZindexChanged: D,
    onLoad: H,
    onUnmount: S
  } = e, $ = ge(Dt), [x, j] = k(null), [U, T] = k(null), [q, A] = k(null), [Y, B] = k(null), [ue, fe] = k(null), [oe, Ae] = k(null), [Ze, Ge] = k(null), [Ie, et] = k(null), [Ye, _e] = k(null), [Qe, at] = k(null), [Pe, Me] = k(null), [Je, We] = k(null), [Re, nt] = k(null), [De, yt] = k(null), [ot, st] = k(null), [ct, bt] = k(null), [pt, dt] = k(null), [tt, Xe] = k(null), [wt, Ct] = k(null), [ft, bn] = k(null), [ht, wn] = k(null), [gt, Mt] = k(null);
  h(() => {
    x !== null && x.setMap($);
  }, [$]), h(() => {
    typeof n < "u" && x !== null && x.setOptions(n);
  }, [x, n]), h(() => {
    typeof a < "u" && x !== null && x.setDraggable(a);
  }, [x, a]), h(() => {
    t && x !== null && x.setPosition(t);
  }, [x, t]), h(() => {
    typeof s < "u" && x !== null && x.setVisible(s);
  }, [x, s]), h(() => {
    x == null || x.setAnimation(l);
  }, [x, l]), h(() => {
    x && u !== void 0 && x.setClickable(u);
  }, [x, u]), h(() => {
    x && c !== void 0 && x.setCursor(c);
  }, [x, c]), h(() => {
    x && p !== void 0 && x.setIcon(p);
  }, [x, p]), h(() => {
    x && d !== void 0 && x.setLabel(d);
  }, [x, d]), h(() => {
    x && g !== void 0 && x.setOpacity(g);
  }, [x, g]), h(() => {
    x && f !== void 0 && x.setShape(f);
  }, [x, f]), h(() => {
    x && m !== void 0 && x.setTitle(m);
  }, [x, m]), h(() => {
    x && v !== void 0 && x.setZIndex(v);
  }, [x, v]), h(() => {
    x && w && (U !== null && google.maps.event.removeListener(U), T(google.maps.event.addListener(x, "dblclick", w)));
  }, [w]), h(() => {
    x && O && (q !== null && google.maps.event.removeListener(q), A(google.maps.event.addListener(x, "dragend", O)));
  }, [O]), h(() => {
    x && y && (Y !== null && google.maps.event.removeListener(Y), B(google.maps.event.addListener(x, "dragstart", y)));
  }, [y]), h(() => {
    x && L && (ue !== null && google.maps.event.removeListener(ue), fe(google.maps.event.addListener(x, "mousedown", L)));
  }, [L]), h(() => {
    x && C && (oe !== null && google.maps.event.removeListener(oe), Ae(google.maps.event.addListener(x, "mouseout", C)));
  }, [C]), h(() => {
    x && _ && (Ze !== null && google.maps.event.removeListener(Ze), Ge(google.maps.event.addListener(x, "mouseover", _)));
  }, [_]), h(() => {
    x && F && (Ie !== null && google.maps.event.removeListener(Ie), et(google.maps.event.addListener(x, "mouseup", F)));
  }, [F]), h(() => {
    x && N && (Ye !== null && google.maps.event.removeListener(Ye), _e(google.maps.event.addListener(x, "rightclick", N)));
  }, [N]), h(() => {
    x && E && (Qe !== null && google.maps.event.removeListener(Qe), at(google.maps.event.addListener(x, "click", E)));
  }, [E]), h(() => {
    x && M && (Pe !== null && google.maps.event.removeListener(Pe), Me(google.maps.event.addListener(x, "drag", M)));
  }, [M]), h(() => {
    x && R && (Je !== null && google.maps.event.removeListener(Je), We(google.maps.event.addListener(x, "clickable_changed", R)));
  }, [R]), h(() => {
    x && W && (Re !== null && google.maps.event.removeListener(Re), nt(google.maps.event.addListener(x, "cursor_changed", W)));
  }, [W]), h(() => {
    x && V && (De !== null && google.maps.event.removeListener(De), yt(google.maps.event.addListener(x, "animation_changed", V)));
  }, [V]), h(() => {
    x && z && (ot !== null && google.maps.event.removeListener(ot), st(google.maps.event.addListener(x, "draggable_changed", z)));
  }, [z]), h(() => {
    x && Z && (ct !== null && google.maps.event.removeListener(ct), bt(google.maps.event.addListener(x, "flat_changed", Z)));
  }, [Z]), h(() => {
    x && K && (pt !== null && google.maps.event.removeListener(pt), dt(google.maps.event.addListener(x, "icon_changed", K)));
  }, [K]), h(() => {
    x && X && (tt !== null && google.maps.event.removeListener(tt), Xe(google.maps.event.addListener(x, "position_changed", X)));
  }, [X]), h(() => {
    x && te && (wt !== null && google.maps.event.removeListener(wt), Ct(google.maps.event.addListener(x, "shape_changed", te)));
  }, [te]), h(() => {
    x && J && (ft !== null && google.maps.event.removeListener(ft), bn(google.maps.event.addListener(x, "title_changed", J)));
  }, [J]), h(() => {
    x && P && (ht !== null && google.maps.event.removeListener(ht), wn(google.maps.event.addListener(x, "visible_changed", P)));
  }, [P]), h(() => {
    x && D && (gt !== null && google.maps.event.removeListener(gt), Mt(google.maps.event.addListener(x, "zindex_changed", D)));
  }, [D]), h(() => {
    var mt = pc(pc(pc({}, n || Ny), r ? Ny : {
      map: $
    }), {}, {
      position: t
    }), re = new google.maps.Marker(mt);
    return r ? r.addMarker(re, !!o) : re.setMap($), t && re.setPosition(t), typeof s < "u" && re.setVisible(s), typeof a < "u" && re.setDraggable(a), typeof u < "u" && re.setClickable(u), typeof c == "string" && re.setCursor(c), p && re.setIcon(p), typeof d < "u" && re.setLabel(d), typeof g < "u" && re.setOpacity(g), f && re.setShape(f), typeof m == "string" && re.setTitle(m), typeof v == "number" && re.setZIndex(v), w && T(google.maps.event.addListener(re, "dblclick", w)), O && A(google.maps.event.addListener(re, "dragend", O)), y && B(google.maps.event.addListener(re, "dragstart", y)), L && fe(google.maps.event.addListener(re, "mousedown", L)), C && Ae(google.maps.event.addListener(re, "mouseout", C)), _ && Ge(google.maps.event.addListener(re, "mouseover", _)), F && et(google.maps.event.addListener(re, "mouseup", F)), N && _e(google.maps.event.addListener(re, "rightclick", N)), E && at(google.maps.event.addListener(re, "click", E)), M && Me(google.maps.event.addListener(re, "drag", M)), R && We(google.maps.event.addListener(re, "clickable_changed", R)), W && nt(google.maps.event.addListener(re, "cursor_changed", W)), V && yt(google.maps.event.addListener(re, "animation_changed", V)), z && st(google.maps.event.addListener(re, "draggable_changed", z)), Z && bt(google.maps.event.addListener(re, "flat_changed", Z)), K && dt(google.maps.event.addListener(re, "icon_changed", K)), X && Xe(google.maps.event.addListener(re, "position_changed", X)), te && Ct(google.maps.event.addListener(re, "shape_changed", te)), J && bn(google.maps.event.addListener(re, "title_changed", J)), P && wn(google.maps.event.addListener(re, "visible_changed", P)), D && Mt(google.maps.event.addListener(re, "zindex_changed", D)), j(re), H && H(re), () => {
      U !== null && google.maps.event.removeListener(U), q !== null && google.maps.event.removeListener(q), Y !== null && google.maps.event.removeListener(Y), ue !== null && google.maps.event.removeListener(ue), oe !== null && google.maps.event.removeListener(oe), Ze !== null && google.maps.event.removeListener(Ze), Ie !== null && google.maps.event.removeListener(Ie), Ye !== null && google.maps.event.removeListener(Ye), Qe !== null && google.maps.event.removeListener(Qe), Je !== null && google.maps.event.removeListener(Je), Re !== null && google.maps.event.removeListener(Re), De !== null && google.maps.event.removeListener(De), ot !== null && google.maps.event.removeListener(ot), ct !== null && google.maps.event.removeListener(ct), pt !== null && google.maps.event.removeListener(pt), tt !== null && google.maps.event.removeListener(tt), ft !== null && google.maps.event.removeListener(ft), ht !== null && google.maps.event.removeListener(ht), gt !== null && google.maps.event.removeListener(gt), S && S(re), r ? r.removeMarker(re, !!o) : re && re.setMap(null);
    };
  }, []);
  var ir = Cn(() => i ? lt.map(i, (mt) => {
    if (!yi(mt))
      return mt;
    var re = mt;
    return bi(re, {
      anchor: x
    });
  }) : null, [i, x]);
  return Q.jsx(Q.Fragment, {
    children: ir
  }) || null;
}
ve(G6e);
class xJ extends pe {
  constructor() {
    super(...arguments), ye(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this;
    return mJ(function* () {
      var n = pc(pc(pc({}, t.props.options || Ny), t.props.clusterer ? Ny : {
        map: t.context
      }), {}, {
        position: t.props.position
      });
      t.marker = new google.maps.Marker(n), t.props.clusterer ? t.props.clusterer.addMarker(t.marker, !!t.props.noClustererRedraw) : t.marker.setMap(t.context), t.registeredEvents = Vt({
        updaterMap: T9,
        eventMap: D9,
        prevProps: {},
        nextProps: t.props,
        instance: t.marker
      }), t.props.onLoad && t.props.onLoad(t.marker);
    })();
  }
  componentDidUpdate(t) {
    this.marker && (Qt(this.registeredEvents), this.registeredEvents = Vt({
      updaterMap: T9,
      eventMap: D9,
      prevProps: t,
      nextProps: this.props,
      instance: this.marker
    }));
  }
  componentWillUnmount() {
    this.marker && (this.props.onUnmount && this.props.onUnmount(this.marker), Qt(this.registeredEvents), this.props.clusterer ? this.props.clusterer.removeMarker(this.marker, !!this.props.noClustererRedraw) : this.marker && this.marker.setMap(null));
  }
  render() {
    var t = this.props.children ? lt.map(this.props.children, (n) => {
      if (!yi(n))
        return n;
      var r = n;
      return bi(r, {
        anchor: this.marker
      });
    }) : null;
    return t || null;
  }
}
ye(xJ, "contextType", Dt);
var K6e = (
  /** @class */
  function() {
    function e(t, n) {
      t.getClusterer().extend(e, google.maps.OverlayView), this.cluster = t, this.clusterClassName = this.cluster.getClusterer().getClusterClass(), this.className = this.clusterClassName, this.styles = n, this.center = void 0, this.div = null, this.sums = null, this.visible = !1, this.boundsChangedListener = null, this.url = "", this.height = 0, this.width = 0, this.anchorText = [0, 0], this.anchorIcon = [0, 0], this.textColor = "black", this.textSize = 11, this.textDecoration = "none", this.fontWeight = "bold", this.fontStyle = "normal", this.fontFamily = "Arial,sans-serif", this.backgroundPosition = "0 0", this.cMouseDownInCluster = null, this.cDraggingMapByCluster = null, this.timeOut = null, this.setMap(t.getMap()), this.onBoundsChanged = this.onBoundsChanged.bind(this), this.onMouseDown = this.onMouseDown.bind(this), this.onClick = this.onClick.bind(this), this.onMouseOver = this.onMouseOver.bind(this), this.onMouseOut = this.onMouseOut.bind(this), this.onAdd = this.onAdd.bind(this), this.onRemove = this.onRemove.bind(this), this.draw = this.draw.bind(this), this.hide = this.hide.bind(this), this.show = this.show.bind(this), this.useStyle = this.useStyle.bind(this), this.setCenter = this.setCenter.bind(this), this.getPosFromLatLng = this.getPosFromLatLng.bind(this);
    }
    return e.prototype.onBoundsChanged = function() {
      this.cDraggingMapByCluster = this.cMouseDownInCluster;
    }, e.prototype.onMouseDown = function() {
      this.cMouseDownInCluster = !0, this.cDraggingMapByCluster = !1;
    }, e.prototype.onClick = function(t) {
      if (this.cMouseDownInCluster = !1, !this.cDraggingMapByCluster) {
        var n = this.cluster.getClusterer();
        if (google.maps.event.trigger(n, "click", this.cluster), google.maps.event.trigger(n, "clusterclick", this.cluster), n.getZoomOnClick()) {
          var r = n.getMaxZoom(), o = this.cluster.getBounds(), i = n.getMap();
          i !== null && "fitBounds" in i && i.fitBounds(o), this.timeOut = window.setTimeout(function() {
            var a = n.getMap();
            if (a !== null) {
              "fitBounds" in a && a.fitBounds(o);
              var s = a.getZoom() || 0;
              r !== null && s > r && a.setZoom(r + 1);
            }
          }, 100);
        }
        t.cancelBubble = !0, t.stopPropagation && t.stopPropagation();
      }
    }, e.prototype.onMouseOver = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseover", this.cluster);
    }, e.prototype.onMouseOut = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseout", this.cluster);
    }, e.prototype.onAdd = function() {
      var t;
      this.div = document.createElement("div"), this.div.className = this.className, this.visible && this.show(), (t = this.getPanes()) === null || t === void 0 || t.overlayMouseTarget.appendChild(this.div);
      var n = this.getMap();
      n !== null && (this.boundsChangedListener = google.maps.event.addListener(n, "bounds_changed", this.onBoundsChanged), this.div.addEventListener("mousedown", this.onMouseDown), this.div.addEventListener("click", this.onClick), this.div.addEventListener("mouseover", this.onMouseOver), this.div.addEventListener("mouseout", this.onMouseOut));
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.hide(), this.boundsChangedListener !== null && google.maps.event.removeListener(this.boundsChangedListener), this.div.removeEventListener("mousedown", this.onMouseDown), this.div.removeEventListener("click", this.onClick), this.div.removeEventListener("mouseover", this.onMouseOver), this.div.removeEventListener("mouseout", this.onMouseOut), this.div.parentNode.removeChild(this.div), this.timeOut !== null && (window.clearTimeout(this.timeOut), this.timeOut = null), this.div = null);
    }, e.prototype.draw = function() {
      if (this.visible && this.div !== null && this.center) {
        var t = this.getPosFromLatLng(this.center);
        this.div.style.top = t !== null ? "".concat(t.y, "px") : "0", this.div.style.left = t !== null ? "".concat(t.x, "px") : "0";
      }
    }, e.prototype.hide = function() {
      this.div && (this.div.style.display = "none"), this.visible = !1;
    }, e.prototype.show = function() {
      var t, n, r, o, i, a;
      if (this.div && this.center) {
        var s = this.sums === null || typeof this.sums.title > "u" || this.sums.title === "" ? this.cluster.getClusterer().getTitle() : this.sums.title, l = this.backgroundPosition.split(" "), u = parseInt(((t = l[0]) === null || t === void 0 ? void 0 : t.replace(/^\s+|\s+$/g, "")) || "0", 10), c = parseInt(((n = l[1]) === null || n === void 0 ? void 0 : n.replace(/^\s+|\s+$/g, "")) || "0", 10), p = this.getPosFromLatLng(this.center);
        this.div.className = this.className, this.div.setAttribute("style", "cursor: pointer; position: absolute; top: ".concat(p !== null ? "".concat(p.y, "px") : "0", "; left: ").concat(p !== null ? "".concat(p.x, "px") : "0", "; width: ").concat(this.width, "px; height: ").concat(this.height, "px; "));
        var d = document.createElement("img");
        d.alt = s, d.src = this.url, d.width = this.width, d.height = this.height, d.setAttribute("style", "position: absolute; top: ".concat(c, "px; left: ").concat(u, "px")), this.cluster.getClusterer().enableRetinaIcons || (d.style.clip = "rect(-".concat(c, "px, -").concat(u + this.width, "px, -").concat(c + this.height, ", -").concat(u, ")"));
        var g = document.createElement("div");
        g.setAttribute("style", "position: absolute; top: ".concat(this.anchorText[0], "px; left: ").concat(this.anchorText[1], "px; color: ").concat(this.textColor, "; font-size: ").concat(this.textSize, "px; font-family: ").concat(this.fontFamily, "; font-weight: ").concat(this.fontWeight, "; fontStyle: ").concat(this.fontStyle, "; text-decoration: ").concat(this.textDecoration, "; text-align: center; width: ").concat(this.width, "px; line-height: ").concat(this.height, "px")), !((r = this.sums) === null || r === void 0) && r.text && (g.innerText = "".concat((o = this.sums) === null || o === void 0 ? void 0 : o.text)), !((i = this.sums) === null || i === void 0) && i.html && (g.innerHTML = "".concat((a = this.sums) === null || a === void 0 ? void 0 : a.html)), this.div.innerHTML = "", this.div.appendChild(d), this.div.appendChild(g), this.div.title = s, this.div.style.display = "";
      }
      this.visible = !0;
    }, e.prototype.useStyle = function(t) {
      this.sums = t;
      var n = this.cluster.getClusterer().getStyles(), r = n[Math.min(n.length - 1, Math.max(0, t.index - 1))];
      r && (this.url = r.url, this.height = r.height, this.width = r.width, r.className && (this.className = "".concat(this.clusterClassName, " ").concat(r.className)), this.anchorText = r.anchorText || [0, 0], this.anchorIcon = r.anchorIcon || [this.height / 2, this.width / 2], this.textColor = r.textColor || "black", this.textSize = r.textSize || 11, this.textDecoration = r.textDecoration || "none", this.fontWeight = r.fontWeight || "bold", this.fontStyle = r.fontStyle || "normal", this.fontFamily = r.fontFamily || "Arial,sans-serif", this.backgroundPosition = r.backgroundPosition || "0 0");
    }, e.prototype.setCenter = function(t) {
      this.center = t;
    }, e.prototype.getPosFromLatLng = function(t) {
      var n = this.getProjection().fromLatLngToDivPixel(t);
      return n !== null && (n.x -= this.anchorIcon[1], n.y -= this.anchorIcon[0]), n;
    }, e;
  }()
), Y6e = (
  /** @class */
  function() {
    function e(t) {
      this.markerClusterer = t, this.map = this.markerClusterer.getMap(), this.gridSize = this.markerClusterer.getGridSize(), this.minClusterSize = this.markerClusterer.getMinimumClusterSize(), this.averageCenter = this.markerClusterer.getAverageCenter(), this.markers = [], this.center = void 0, this.bounds = null, this.clusterIcon = new K6e(this, this.markerClusterer.getStyles()), this.getSize = this.getSize.bind(this), this.getMarkers = this.getMarkers.bind(this), this.getCenter = this.getCenter.bind(this), this.getMap = this.getMap.bind(this), this.getClusterer = this.getClusterer.bind(this), this.getBounds = this.getBounds.bind(this), this.remove = this.remove.bind(this), this.addMarker = this.addMarker.bind(this), this.isMarkerInClusterBounds = this.isMarkerInClusterBounds.bind(this), this.calculateBounds = this.calculateBounds.bind(this), this.updateIcon = this.updateIcon.bind(this), this.isMarkerAlreadyAdded = this.isMarkerAlreadyAdded.bind(this);
    }
    return e.prototype.getSize = function() {
      return this.markers.length;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getCenter = function() {
      return this.center;
    }, e.prototype.getMap = function() {
      return this.map;
    }, e.prototype.getClusterer = function() {
      return this.markerClusterer;
    }, e.prototype.getBounds = function() {
      for (var t = new google.maps.LatLngBounds(this.center, this.center), n = this.getMarkers(), r = 0, o = n; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && t.extend(a);
      }
      return t;
    }, e.prototype.remove = function() {
      this.clusterIcon.setMap(null), this.markers = [], delete this.markers;
    }, e.prototype.addMarker = function(t) {
      var n;
      if (this.isMarkerAlreadyAdded(t))
        return !1;
      if (this.center) {
        if (this.averageCenter) {
          var r = t.getPosition();
          if (r) {
            var o = this.markers.length + 1;
            this.center = new google.maps.LatLng((this.center.lat() * (o - 1) + r.lat()) / o, (this.center.lng() * (o - 1) + r.lng()) / o), this.calculateBounds();
          }
        }
      } else {
        var r = t.getPosition();
        r && (this.center = r, this.calculateBounds());
      }
      t.isAdded = !0, this.markers.push(t);
      var i = this.markers.length, a = this.markerClusterer.getMaxZoom(), s = (n = this.map) === null || n === void 0 ? void 0 : n.getZoom();
      if (a !== null && typeof s < "u" && s > a)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i < this.minClusterSize)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i === this.minClusterSize)
        for (var l = 0, u = this.markers; l < u.length; l++) {
          var c = u[l];
          c.setMap(null);
        }
      else
        t.setMap(null);
      return !0;
    }, e.prototype.isMarkerInClusterBounds = function(t) {
      if (this.bounds !== null) {
        var n = t.getPosition();
        if (n)
          return this.bounds.contains(n);
      }
      return !1;
    }, e.prototype.calculateBounds = function() {
      this.bounds = this.markerClusterer.getExtendedBounds(new google.maps.LatLngBounds(this.center, this.center));
    }, e.prototype.updateIcon = function() {
      var t, n = this.markers.length, r = this.markerClusterer.getMaxZoom(), o = (t = this.map) === null || t === void 0 ? void 0 : t.getZoom();
      if (r !== null && typeof o < "u" && o > r) {
        this.clusterIcon.hide();
        return;
      }
      if (n < this.minClusterSize) {
        this.clusterIcon.hide();
        return;
      }
      this.center && this.clusterIcon.setCenter(this.center), this.clusterIcon.useStyle(this.markerClusterer.getCalculator()(this.markers, this.markerClusterer.getStyles().length)), this.clusterIcon.show();
    }, e.prototype.isMarkerAlreadyAdded = function(t) {
      if (this.markers.includes)
        return this.markers.includes(t);
      for (var n = 0; n < this.markers.length; n++)
        if (t === this.markers[n])
          return !0;
      return !1;
    }, e;
  }()
);
function X6e(e, t) {
  var n = e.length, r = n.toString().length, o = Math.min(r, t);
  return {
    text: n.toString(),
    index: o,
    title: ""
  };
}
var J6e = 2e3, Q6e = 500, e8e = "https://developers.google.com/maps/documentation/javascript/examples/markerclusterer/m", t8e = "png", n8e = [53, 56, 66, 78, 90], r8e = "cluster", OJ = (
  /** @class */
  function() {
    function e(t, n, r) {
      n === void 0 && (n = []), r === void 0 && (r = {}), this.getMinimumClusterSize = this.getMinimumClusterSize.bind(this), this.setMinimumClusterSize = this.setMinimumClusterSize.bind(this), this.getEnableRetinaIcons = this.getEnableRetinaIcons.bind(this), this.setEnableRetinaIcons = this.setEnableRetinaIcons.bind(this), this.addToClosestCluster = this.addToClosestCluster.bind(this), this.getImageExtension = this.getImageExtension.bind(this), this.setImageExtension = this.setImageExtension.bind(this), this.getExtendedBounds = this.getExtendedBounds.bind(this), this.getAverageCenter = this.getAverageCenter.bind(this), this.setAverageCenter = this.setAverageCenter.bind(this), this.getTotalClusters = this.getTotalClusters.bind(this), this.fitMapToMarkers = this.fitMapToMarkers.bind(this), this.getIgnoreHidden = this.getIgnoreHidden.bind(this), this.setIgnoreHidden = this.setIgnoreHidden.bind(this), this.getClusterClass = this.getClusterClass.bind(this), this.setClusterClass = this.setClusterClass.bind(this), this.getTotalMarkers = this.getTotalMarkers.bind(this), this.getZoomOnClick = this.getZoomOnClick.bind(this), this.setZoomOnClick = this.setZoomOnClick.bind(this), this.getBatchSizeIE = this.getBatchSizeIE.bind(this), this.setBatchSizeIE = this.setBatchSizeIE.bind(this), this.createClusters = this.createClusters.bind(this), this.onZoomChanged = this.onZoomChanged.bind(this), this.getImageSizes = this.getImageSizes.bind(this), this.setImageSizes = this.setImageSizes.bind(this), this.getCalculator = this.getCalculator.bind(this), this.setCalculator = this.setCalculator.bind(this), this.removeMarkers = this.removeMarkers.bind(this), this.resetViewport = this.resetViewport.bind(this), this.getImagePath = this.getImagePath.bind(this), this.setImagePath = this.setImagePath.bind(this), this.pushMarkerTo = this.pushMarkerTo.bind(this), this.removeMarker = this.removeMarker.bind(this), this.clearMarkers = this.clearMarkers.bind(this), this.setupStyles = this.setupStyles.bind(this), this.getGridSize = this.getGridSize.bind(this), this.setGridSize = this.setGridSize.bind(this), this.getClusters = this.getClusters.bind(this), this.getMaxZoom = this.getMaxZoom.bind(this), this.setMaxZoom = this.setMaxZoom.bind(this), this.getMarkers = this.getMarkers.bind(this), this.addMarkers = this.addMarkers.bind(this), this.getStyles = this.getStyles.bind(this), this.setStyles = this.setStyles.bind(this), this.addMarker = this.addMarker.bind(this), this.onRemove = this.onRemove.bind(this), this.getTitle = this.getTitle.bind(this), this.setTitle = this.setTitle.bind(this), this.repaint = this.repaint.bind(this), this.onIdle = this.onIdle.bind(this), this.redraw = this.redraw.bind(this), this.onAdd = this.onAdd.bind(this), this.draw = this.draw.bind(this), this.extend = this.extend.bind(this), this.extend(e, google.maps.OverlayView), this.markers = [], this.clusters = [], this.listeners = [], this.activeMap = null, this.ready = !1, this.gridSize = r.gridSize || 60, this.minClusterSize = r.minimumClusterSize || 2, this.maxZoom = r.maxZoom || null, this.styles = r.styles || [], this.title = r.title || "", this.zoomOnClick = !0, r.zoomOnClick !== void 0 && (this.zoomOnClick = r.zoomOnClick), this.averageCenter = !1, r.averageCenter !== void 0 && (this.averageCenter = r.averageCenter), this.ignoreHidden = !1, r.ignoreHidden !== void 0 && (this.ignoreHidden = r.ignoreHidden), this.enableRetinaIcons = !1, r.enableRetinaIcons !== void 0 && (this.enableRetinaIcons = r.enableRetinaIcons), this.imagePath = r.imagePath || e8e, this.imageExtension = r.imageExtension || t8e, this.imageSizes = r.imageSizes || n8e, this.calculator = r.calculator || X6e, this.batchSize = r.batchSize || J6e, this.batchSizeIE = r.batchSizeIE || Q6e, this.clusterClass = r.clusterClass || r8e, navigator.userAgent.toLowerCase().indexOf("msie") !== -1 && (this.batchSize = this.batchSizeIE), this.timerRefStatic = null, this.setupStyles(), this.addMarkers(n, !0), this.setMap(t);
    }
    return e.prototype.onZoomChanged = function() {
      var t, n;
      this.resetViewport(!1), (((t = this.getMap()) === null || t === void 0 ? void 0 : t.getZoom()) === (this.get("minZoom") || 0) || ((n = this.getMap()) === null || n === void 0 ? void 0 : n.getZoom()) === this.get("maxZoom")) && google.maps.event.trigger(this, "idle");
    }, e.prototype.onIdle = function() {
      this.redraw();
    }, e.prototype.onAdd = function() {
      var t = this.getMap();
      this.activeMap = t, this.ready = !0, this.repaint(), t !== null && (this.listeners = [google.maps.event.addListener(t, "zoom_changed", this.onZoomChanged), google.maps.event.addListener(t, "idle", this.onIdle)]);
    }, e.prototype.onRemove = function() {
      for (var t = 0, n = this.markers; t < n.length; t++) {
        var r = n[t];
        r.getMap() !== this.activeMap && r.setMap(this.activeMap);
      }
      for (var o = 0, i = this.clusters; o < i.length; o++) {
        var a = i[o];
        a.remove();
      }
      this.clusters = [];
      for (var s = 0, l = this.listeners; s < l.length; s++) {
        var u = l[s];
        google.maps.event.removeListener(u);
      }
      this.listeners = [], this.activeMap = null, this.ready = !1;
    }, e.prototype.draw = function() {
    }, e.prototype.getMap = function() {
      return null;
    }, e.prototype.getPanes = function() {
      return null;
    }, e.prototype.getProjection = function() {
      return {
        fromContainerPixelToLatLng: function() {
          return null;
        },
        fromDivPixelToLatLng: function() {
          return null;
        },
        fromLatLngToContainerPixel: function() {
          return null;
        },
        fromLatLngToDivPixel: function() {
          return null;
        },
        getVisibleRegion: function() {
          return null;
        },
        getWorldWidth: function() {
          return 0;
        }
      };
    }, e.prototype.setMap = function() {
    }, e.prototype.addListener = function() {
      return {
        remove: function() {
        }
      };
    }, e.prototype.bindTo = function() {
    }, e.prototype.get = function() {
    }, e.prototype.notify = function() {
    }, e.prototype.set = function() {
    }, e.prototype.setValues = function() {
    }, e.prototype.unbind = function() {
    }, e.prototype.unbindAll = function() {
    }, e.prototype.setupStyles = function() {
      if (!(this.styles.length > 0))
        for (var t = 0; t < this.imageSizes.length; t++)
          this.styles.push({
            url: "".concat(this.imagePath + (t + 1), ".").concat(this.imageExtension),
            height: this.imageSizes[t] || 0,
            width: this.imageSizes[t] || 0
          });
    }, e.prototype.fitMapToMarkers = function() {
      for (var t = this.getMarkers(), n = new google.maps.LatLngBounds(), r = 0, o = t; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && n.extend(a);
      }
      var s = this.getMap();
      s !== null && "fitBounds" in s && s.fitBounds(n);
    }, e.prototype.getGridSize = function() {
      return this.gridSize;
    }, e.prototype.setGridSize = function(t) {
      this.gridSize = t;
    }, e.prototype.getMinimumClusterSize = function() {
      return this.minClusterSize;
    }, e.prototype.setMinimumClusterSize = function(t) {
      this.minClusterSize = t;
    }, e.prototype.getMaxZoom = function() {
      return this.maxZoom;
    }, e.prototype.setMaxZoom = function(t) {
      this.maxZoom = t;
    }, e.prototype.getStyles = function() {
      return this.styles;
    }, e.prototype.setStyles = function(t) {
      this.styles = t;
    }, e.prototype.getTitle = function() {
      return this.title;
    }, e.prototype.setTitle = function(t) {
      this.title = t;
    }, e.prototype.getZoomOnClick = function() {
      return this.zoomOnClick;
    }, e.prototype.setZoomOnClick = function(t) {
      this.zoomOnClick = t;
    }, e.prototype.getAverageCenter = function() {
      return this.averageCenter;
    }, e.prototype.setAverageCenter = function(t) {
      this.averageCenter = t;
    }, e.prototype.getIgnoreHidden = function() {
      return this.ignoreHidden;
    }, e.prototype.setIgnoreHidden = function(t) {
      this.ignoreHidden = t;
    }, e.prototype.getEnableRetinaIcons = function() {
      return this.enableRetinaIcons;
    }, e.prototype.setEnableRetinaIcons = function(t) {
      this.enableRetinaIcons = t;
    }, e.prototype.getImageExtension = function() {
      return this.imageExtension;
    }, e.prototype.setImageExtension = function(t) {
      this.imageExtension = t;
    }, e.prototype.getImagePath = function() {
      return this.imagePath;
    }, e.prototype.setImagePath = function(t) {
      this.imagePath = t;
    }, e.prototype.getImageSizes = function() {
      return this.imageSizes;
    }, e.prototype.setImageSizes = function(t) {
      this.imageSizes = t;
    }, e.prototype.getCalculator = function() {
      return this.calculator;
    }, e.prototype.setCalculator = function(t) {
      this.calculator = t;
    }, e.prototype.getBatchSizeIE = function() {
      return this.batchSizeIE;
    }, e.prototype.setBatchSizeIE = function(t) {
      this.batchSizeIE = t;
    }, e.prototype.getClusterClass = function() {
      return this.clusterClass;
    }, e.prototype.setClusterClass = function(t) {
      this.clusterClass = t;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getTotalMarkers = function() {
      return this.markers.length;
    }, e.prototype.getClusters = function() {
      return this.clusters;
    }, e.prototype.getTotalClusters = function() {
      return this.clusters.length;
    }, e.prototype.addMarker = function(t, n) {
      this.pushMarkerTo(t), n || this.redraw();
    }, e.prototype.addMarkers = function(t, n) {
      for (var r in t)
        if (Object.prototype.hasOwnProperty.call(t, r)) {
          var o = t[r];
          o && this.pushMarkerTo(o);
        }
      n || this.redraw();
    }, e.prototype.pushMarkerTo = function(t) {
      var n = this;
      t.getDraggable() && google.maps.event.addListener(t, "dragend", function() {
        n.ready && (t.isAdded = !1, n.repaint());
      }), t.isAdded = !1, this.markers.push(t);
    }, e.prototype.removeMarker_ = function(t) {
      var n = -1;
      if (this.markers.indexOf)
        n = this.markers.indexOf(t);
      else
        for (var r = 0; r < this.markers.length; r++)
          if (t === this.markers[r]) {
            n = r;
            break;
          }
      return n === -1 ? !1 : (t.setMap(null), this.markers.splice(n, 1), !0);
    }, e.prototype.removeMarker = function(t, n) {
      var r = this.removeMarker_(t);
      return !n && r && this.repaint(), r;
    }, e.prototype.removeMarkers = function(t, n) {
      for (var r = !1, o = 0, i = t; o < i.length; o++) {
        var a = i[o];
        r = r || this.removeMarker_(a);
      }
      return !n && r && this.repaint(), r;
    }, e.prototype.clearMarkers = function() {
      this.resetViewport(!0), this.markers = [];
    }, e.prototype.repaint = function() {
      var t = this.clusters.slice();
      this.clusters = [], this.resetViewport(!1), this.redraw(), setTimeout(function() {
        for (var r = 0, o = t; r < o.length; r++) {
          var i = o[r];
          i.remove();
        }
      }, 0);
    }, e.prototype.getExtendedBounds = function(t) {
      var n = this.getProjection(), r = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getNorthEast().lat(), t.getNorthEast().lng())
      );
      r !== null && (r.x += this.gridSize, r.y -= this.gridSize);
      var o = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getSouthWest().lat(), t.getSouthWest().lng())
      );
      if (o !== null && (o.x -= this.gridSize, o.y += this.gridSize), r !== null) {
        var i = n.fromDivPixelToLatLng(r);
        i !== null && t.extend(i);
      }
      if (o !== null) {
        var a = n.fromDivPixelToLatLng(o);
        a !== null && t.extend(a);
      }
      return t;
    }, e.prototype.redraw = function() {
      this.createClusters(0);
    }, e.prototype.resetViewport = function(t) {
      for (var n = 0, r = this.clusters; n < r.length; n++) {
        var o = r[n];
        o.remove();
      }
      this.clusters = [];
      for (var i = 0, a = this.markers; i < a.length; i++) {
        var s = a[i];
        s.isAdded = !1, t && s.setMap(null);
      }
    }, e.prototype.distanceBetweenPoints = function(t, n) {
      var r = 6371, o = (n.lat() - t.lat()) * Math.PI / 180, i = (n.lng() - t.lng()) * Math.PI / 180, a = Math.sin(o / 2) * Math.sin(o / 2) + Math.cos(t.lat() * Math.PI / 180) * Math.cos(n.lat() * Math.PI / 180) * Math.sin(i / 2) * Math.sin(i / 2);
      return r * (2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)));
    }, e.prototype.isMarkerInBounds = function(t, n) {
      var r = t.getPosition();
      return r ? n.contains(r) : !1;
    }, e.prototype.addToClosestCluster = function(t) {
      for (var n, r = 4e4, o = null, i = 0, a = this.clusters; i < a.length; i++) {
        var s = a[i];
        n = s;
        var l = n.getCenter(), u = t.getPosition();
        if (l && u) {
          var c = this.distanceBetweenPoints(l, u);
          c < r && (r = c, o = n);
        }
      }
      o && o.isMarkerInClusterBounds(t) ? o.addMarker(t) : (n = new Y6e(this), n.addMarker(t), this.clusters.push(n));
    }, e.prototype.createClusters = function(t) {
      var n = this;
      if (this.ready) {
        t === 0 && (google.maps.event.trigger(this, "clusteringbegin", this), this.timerRefStatic !== null && (window.clearTimeout(this.timerRefStatic), delete this.timerRefStatic));
        for (var r = this.getMap(), o = r !== null && ("getBounds" in r) ? r.getBounds() : null, i = (r == null ? void 0 : r.getZoom()) || 0, a = i > 3 ? new google.maps.LatLngBounds(o == null ? void 0 : o.getSouthWest(), o == null ? void 0 : o.getNorthEast()) : new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625)), s = this.getExtendedBounds(a), l = Math.min(t + this.batchSize, this.markers.length), u = t; u < l; u++) {
          var c = this.markers[u];
          c && !c.isAdded && this.isMarkerInBounds(c, s) && (!this.ignoreHidden || this.ignoreHidden && c.getVisible()) && this.addToClosestCluster(c);
        }
        if (l < this.markers.length)
          this.timerRefStatic = window.setTimeout(function() {
            n.createClusters(l);
          }, 0);
        else {
          this.timerRefStatic = null, google.maps.event.trigger(this, "clusteringend", this);
          for (var p = 0, d = this.clusters; p < d.length; p++) {
            var g = d[p];
            g.updateIcon();
          }
        }
      }
    }, e.prototype.extend = function(t, n) {
      return (function(o) {
        for (var i in o.prototype) {
          var a = i;
          this.prototype[a] = o.prototype[a];
        }
        return this;
      }).apply(t, [n]);
    }, e;
  }()
);
function j9(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function o8e(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? j9(Object(n), !0).forEach(function(r) {
      ye(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : j9(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var ss = {
  onClick: "click",
  onClusteringBegin: "clusteringbegin",
  onClusteringEnd: "clusteringend",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover"
}, _n = {
  averageCenter(e, t) {
    e.setAverageCenter(t);
  },
  batchSizeIE(e, t) {
    e.setBatchSizeIE(t);
  },
  calculator(e, t) {
    e.setCalculator(t);
  },
  clusterClass(e, t) {
    e.setClusterClass(t);
  },
  enableRetinaIcons(e, t) {
    e.setEnableRetinaIcons(t);
  },
  gridSize(e, t) {
    e.setGridSize(t);
  },
  ignoreHidden(e, t) {
    e.setIgnoreHidden(t);
  },
  imageExtension(e, t) {
    e.setImageExtension(t);
  },
  imagePath(e, t) {
    e.setImagePath(t);
  },
  imageSizes(e, t) {
    e.setImageSizes(t);
  },
  maxZoom(e, t) {
    e.setMaxZoom(t);
  },
  minimumClusterSize(e, t) {
    e.setMinimumClusterSize(t);
  },
  styles(e, t) {
    e.setStyles(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  zoomOnClick(e, t) {
    e.setZoomOnClick(t);
  }
}, i8e = {};
function s8e(e) {
  var {
    children: t,
    options: n,
    averageCenter: r,
    batchSizeIE: o,
    calculator: i,
    clusterClass: a,
    enableRetinaIcons: s,
    gridSize: l,
    ignoreHidden: u,
    imageExtension: c,
    imagePath: p,
    imageSizes: d,
    maxZoom: g,
    minimumClusterSize: f,
    styles: m,
    title: v,
    zoomOnClick: E,
    onClick: w,
    onClusteringBegin: M,
    onClusteringEnd: O,
    onMouseOver: y,
    onMouseOut: C,
    onLoad: _,
    onUnmount: F
  } = e, [L, N] = k(null), R = ge(Dt), [W, V] = k(null), [z, Z] = k(null), [K, X] = k(null), [te, J] = k(null), [P, D] = k(null);
  return h(() => {
    L && C && (te !== null && google.maps.event.removeListener(te), J(google.maps.event.addListener(L, ss.onMouseOut, C)));
  }, [C]), h(() => {
    L && y && (P !== null && google.maps.event.removeListener(P), D(google.maps.event.addListener(L, ss.onMouseOver, y)));
  }, [y]), h(() => {
    L && w && (W !== null && google.maps.event.removeListener(W), V(google.maps.event.addListener(L, ss.onClick, w)));
  }, [w]), h(() => {
    L && M && (z !== null && google.maps.event.removeListener(z), Z(google.maps.event.addListener(L, ss.onClusteringBegin, M)));
  }, [M]), h(() => {
    L && O && (K !== null && google.maps.event.removeListener(K), Z(google.maps.event.addListener(L, ss.onClusteringEnd, O)));
  }, [O]), h(() => {
    typeof r < "u" && L !== null && _n.averageCenter(L, r);
  }, [L, r]), h(() => {
    typeof o < "u" && L !== null && _n.batchSizeIE(L, o);
  }, [L, o]), h(() => {
    typeof i < "u" && L !== null && _n.calculator(L, i);
  }, [L, i]), h(() => {
    typeof a < "u" && L !== null && _n.clusterClass(L, a);
  }, [L, a]), h(() => {
    typeof s < "u" && L !== null && _n.enableRetinaIcons(L, s);
  }, [L, s]), h(() => {
    typeof l < "u" && L !== null && _n.gridSize(L, l);
  }, [L, l]), h(() => {
    typeof u < "u" && L !== null && _n.ignoreHidden(L, u);
  }, [L, u]), h(() => {
    typeof c < "u" && L !== null && _n.imageExtension(L, c);
  }, [L, c]), h(() => {
    typeof p < "u" && L !== null && _n.imagePath(L, p);
  }, [L, p]), h(() => {
    typeof d < "u" && L !== null && _n.imageSizes(L, d);
  }, [L, d]), h(() => {
    typeof g < "u" && L !== null && _n.maxZoom(L, g);
  }, [L, g]), h(() => {
    typeof f < "u" && L !== null && _n.minimumClusterSize(L, f);
  }, [L, f]), h(() => {
    typeof m < "u" && L !== null && _n.styles(L, m);
  }, [L, m]), h(() => {
    typeof v < "u" && L !== null && _n.title(L, v);
  }, [L, v]), h(() => {
    typeof E < "u" && L !== null && _n.zoomOnClick(L, E);
  }, [L, E]), h(() => {
    if (R) {
      var H = o8e({}, n || i8e), S = new OJ(R, [], H);
      return r && _n.averageCenter(S, r), o && _n.batchSizeIE(S, o), i && _n.calculator(S, i), a && _n.clusterClass(S, a), s && _n.enableRetinaIcons(S, s), l && _n.gridSize(S, l), u && _n.ignoreHidden(S, u), c && _n.imageExtension(S, c), p && _n.imagePath(S, p), d && _n.imageSizes(S, d), g && _n.maxZoom(S, g), f && _n.minimumClusterSize(S, f), m && _n.styles(S, m), v && _n.title(S, v), E && _n.zoomOnClick(S, E), C && J(google.maps.event.addListener(S, ss.onMouseOut, C)), y && D(google.maps.event.addListener(S, ss.onMouseOver, y)), w && V(google.maps.event.addListener(S, ss.onClick, w)), M && Z(google.maps.event.addListener(S, ss.onClusteringBegin, M)), O && X(google.maps.event.addListener(S, ss.onClusteringEnd, O)), N(S), _ && _(S), () => {
        te !== null && google.maps.event.removeListener(te), P !== null && google.maps.event.removeListener(P), W !== null && google.maps.event.removeListener(W), z !== null && google.maps.event.removeListener(z), K !== null && google.maps.event.removeListener(K), F && F(S);
      };
    }
  }, []), L !== null && t(L) || null;
}
ve(s8e);
class a8e extends pe {
  constructor() {
    super(...arguments), ye(this, "registeredEvents", []), ye(this, "state", {
      markerClusterer: null
    }), ye(this, "setClustererCallback", () => {
      this.state.markerClusterer !== null && this.props.onLoad && this.props.onLoad(this.state.markerClusterer);
    });
  }
  componentDidMount() {
    if (this.context) {
      var t = new OJ(this.context, [], this.props.options);
      this.registeredEvents = Vt({
        updaterMap: _n,
        eventMap: ss,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        markerClusterer: t
      }), this.setClustererCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.markerClusterer && (Qt(this.registeredEvents), this.registeredEvents = Vt({
      updaterMap: _n,
      eventMap: ss,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.markerClusterer
    }));
  }
  componentWillUnmount() {
    this.state.markerClusterer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.markerClusterer), Qt(this.registeredEvents), this.state.markerClusterer.setMap(null));
  }
  render() {
    return this.state.markerClusterer !== null ? this.props.children(this.state.markerClusterer) : null;
  }
}
ye(a8e, "contextType", Dt);
function A9(e) {
  e.cancelBubble = !0, e.stopPropagation && e.stopPropagation();
}
var EJ = (
  /** @class */
  function() {
    function e(t) {
      t === void 0 && (t = {}), this.getCloseClickHandler = this.getCloseClickHandler.bind(this), this.closeClickHandler = this.closeClickHandler.bind(this), this.createInfoBoxDiv = this.createInfoBoxDiv.bind(this), this.addClickHandler = this.addClickHandler.bind(this), this.getCloseBoxImg = this.getCloseBoxImg.bind(this), this.getBoxWidths = this.getBoxWidths.bind(this), this.setBoxStyle = this.setBoxStyle.bind(this), this.setPosition = this.setPosition.bind(this), this.getPosition = this.getPosition.bind(this), this.setOptions = this.setOptions.bind(this), this.setContent = this.setContent.bind(this), this.setVisible = this.setVisible.bind(this), this.getContent = this.getContent.bind(this), this.getVisible = this.getVisible.bind(this), this.setZIndex = this.setZIndex.bind(this), this.getZIndex = this.getZIndex.bind(this), this.onRemove = this.onRemove.bind(this), this.panBox = this.panBox.bind(this), this.extend = this.extend.bind(this), this.close = this.close.bind(this), this.draw = this.draw.bind(this), this.show = this.show.bind(this), this.hide = this.hide.bind(this), this.open = this.open.bind(this), this.extend(e, google.maps.OverlayView), this.content = t.content || "", this.disableAutoPan = t.disableAutoPan || !1, this.maxWidth = t.maxWidth || 0, this.pixelOffset = t.pixelOffset || new google.maps.Size(0, 0), this.position = t.position || new google.maps.LatLng(0, 0), this.zIndex = t.zIndex || null, this.boxClass = t.boxClass || "infoBox", this.boxStyle = t.boxStyle || {}, this.closeBoxMargin = t.closeBoxMargin || "2px", this.closeBoxURL = t.closeBoxURL || "http://www.google.com/intl/en_us/mapfiles/close.gif", t.closeBoxURL === "" && (this.closeBoxURL = ""), this.infoBoxClearance = t.infoBoxClearance || new google.maps.Size(1, 1), typeof t.visible > "u" && (typeof t.isHidden > "u" ? t.visible = !0 : t.visible = !t.isHidden), this.isHidden = !t.visible, this.alignBottom = t.alignBottom || !1, this.pane = t.pane || "floatPane", this.enableEventPropagation = t.enableEventPropagation || !1, this.div = null, this.closeListener = null, this.moveListener = null, this.mapListener = null, this.contextListener = null, this.eventListeners = null, this.fixedWidthSet = null;
    }
    return e.prototype.createInfoBoxDiv = function() {
      var t = this, n = function(c) {
        c.returnValue = !1, c.preventDefault && c.preventDefault(), t.enableEventPropagation || A9(c);
      };
      if (!this.div) {
        this.div = document.createElement("div"), this.setBoxStyle(), typeof this.content == "string" ? this.div.innerHTML = this.getCloseBoxImg() + this.content : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(this.content));
        var r = this.getPanes();
        if (r !== null && r[this.pane].appendChild(this.div), this.addClickHandler(), this.div.style.width)
          this.fixedWidthSet = !0;
        else if (this.maxWidth !== 0 && this.div.offsetWidth > this.maxWidth)
          this.div.style.width = this.maxWidth + "px", this.fixedWidthSet = !0;
        else {
          var o = this.getBoxWidths();
          this.div.style.width = this.div.offsetWidth - o.left - o.right + "px", this.fixedWidthSet = !1;
        }
        if (this.panBox(this.disableAutoPan), !this.enableEventPropagation) {
          this.eventListeners = [];
          for (var i = ["mousedown", "mouseover", "mouseout", "mouseup", "click", "dblclick", "touchstart", "touchend", "touchmove"], a = 0, s = i; a < s.length; a++) {
            var l = s[a];
            this.eventListeners.push(google.maps.event.addListener(this.div, l, A9));
          }
          this.eventListeners.push(google.maps.event.addListener(this.div, "mouseover", function() {
            t.div && (t.div.style.cursor = "default");
          }));
        }
        this.contextListener = google.maps.event.addListener(this.div, "contextmenu", n), google.maps.event.trigger(this, "domready");
      }
    }, e.prototype.getCloseBoxImg = function() {
      var t = "";
      return this.closeBoxURL !== "" && (t = '<img alt=""', t += ' aria-hidden="true"', t += " src='" + this.closeBoxURL + "'", t += " align=right", t += " style='", t += " position: relative;", t += " cursor: pointer;", t += " margin: " + this.closeBoxMargin + ";", t += "'>"), t;
    }, e.prototype.addClickHandler = function() {
      this.closeListener = this.div && this.div.firstChild && this.closeBoxURL !== "" ? google.maps.event.addListener(this.div.firstChild, "click", this.getCloseClickHandler()) : null;
    }, e.prototype.closeClickHandler = function(t) {
      t.cancelBubble = !0, t.stopPropagation && t.stopPropagation(), google.maps.event.trigger(this, "closeclick"), this.close();
    }, e.prototype.getCloseClickHandler = function() {
      return this.closeClickHandler;
    }, e.prototype.panBox = function(t) {
      if (this.div && !t) {
        var n = this.getMap();
        if (n instanceof google.maps.Map) {
          var r = 0, o = 0, i = n.getBounds();
          i && !i.contains(this.position) && n.setCenter(this.position);
          var a = n.getDiv(), s = a.offsetWidth, l = a.offsetHeight, u = this.pixelOffset.width, c = this.pixelOffset.height, p = this.div.offsetWidth, d = this.div.offsetHeight, g = this.infoBoxClearance.width, f = this.infoBoxClearance.height, m = this.getProjection(), v = m.fromLatLngToContainerPixel(this.position);
          v !== null && (v.x < -u + g ? r = v.x + u - g : v.x + p + u + g > s && (r = v.x + p + u + g - s), this.alignBottom ? v.y < -c + f + d ? o = v.y + c - f - d : v.y + c + f > l && (o = v.y + c + f - l) : v.y < -c + f ? o = v.y + c - f : v.y + d + c + f > l && (o = v.y + d + c + f - l)), r === 0 && o === 0 || n.panBy(r, o);
        }
      }
    }, e.prototype.setBoxStyle = function() {
      if (this.div) {
        this.div.className = this.boxClass, this.div.style.cssText = "";
        var t = this.boxStyle;
        for (var n in t)
          Object.prototype.hasOwnProperty.call(t, n) && (this.div.style[n] = t[n]);
        if (this.div.style.webkitTransform = "translateZ(0)", typeof this.div.style.opacity < "u" && this.div.style.opacity !== "") {
          var r = parseFloat(this.div.style.opacity || "");
          this.div.style.msFilter = '"progid:DXImageTransform.Microsoft.Alpha(Opacity=' + r * 100 + ')"', this.div.style.filter = "alpha(opacity=" + r * 100 + ")";
        }
        this.div.style.position = "absolute", this.div.style.visibility = "hidden", this.zIndex !== null && (this.div.style.zIndex = this.zIndex + ""), this.div.style.overflow || (this.div.style.overflow = "auto");
      }
    }, e.prototype.getBoxWidths = function() {
      var t = {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0
      };
      if (!this.div)
        return t;
      if (document.defaultView) {
        var n = this.div.ownerDocument, r = n && n.defaultView ? n.defaultView.getComputedStyle(this.div, "") : null;
        r && (t.top = parseInt(r.borderTopWidth || "", 10) || 0, t.bottom = parseInt(r.borderBottomWidth || "", 10) || 0, t.left = parseInt(r.borderLeftWidth || "", 10) || 0, t.right = parseInt(r.borderRightWidth || "", 10) || 0);
      } else if (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        document.documentElement.currentStyle
      ) {
        var o = this.div.currentStyle;
        o && (t.top = parseInt(o.borderTopWidth || "", 10) || 0, t.bottom = parseInt(o.borderBottomWidth || "", 10) || 0, t.left = parseInt(o.borderLeftWidth || "", 10) || 0, t.right = parseInt(o.borderRightWidth || "", 10) || 0);
      }
      return t;
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.div.parentNode.removeChild(this.div), this.div = null);
    }, e.prototype.draw = function() {
      if (this.createInfoBoxDiv(), this.div) {
        var t = this.getProjection(), n = t.fromLatLngToDivPixel(this.position);
        n !== null && (this.div.style.left = n.x + this.pixelOffset.width + "px", this.alignBottom ? this.div.style.bottom = -(n.y + this.pixelOffset.height) + "px" : this.div.style.top = n.y + this.pixelOffset.height + "px"), this.isHidden ? this.div.style.visibility = "hidden" : this.div.style.visibility = "visible";
      }
    }, e.prototype.setOptions = function(t) {
      t === void 0 && (t = {}), typeof t.boxClass < "u" && (this.boxClass = t.boxClass, this.setBoxStyle()), typeof t.boxStyle < "u" && (this.boxStyle = t.boxStyle, this.setBoxStyle()), typeof t.content < "u" && this.setContent(t.content), typeof t.disableAutoPan < "u" && (this.disableAutoPan = t.disableAutoPan), typeof t.maxWidth < "u" && (this.maxWidth = t.maxWidth), typeof t.pixelOffset < "u" && (this.pixelOffset = t.pixelOffset), typeof t.alignBottom < "u" && (this.alignBottom = t.alignBottom), typeof t.position < "u" && this.setPosition(t.position), typeof t.zIndex < "u" && this.setZIndex(t.zIndex), typeof t.closeBoxMargin < "u" && (this.closeBoxMargin = t.closeBoxMargin), typeof t.closeBoxURL < "u" && (this.closeBoxURL = t.closeBoxURL), typeof t.infoBoxClearance < "u" && (this.infoBoxClearance = t.infoBoxClearance), typeof t.isHidden < "u" && (this.isHidden = t.isHidden), typeof t.visible < "u" && (this.isHidden = !t.visible), typeof t.enableEventPropagation < "u" && (this.enableEventPropagation = t.enableEventPropagation), this.div && this.draw();
    }, e.prototype.setContent = function(t) {
      this.content = t, this.div && (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.fixedWidthSet || (this.div.style.width = ""), typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t)), this.fixedWidthSet || (this.div.style.width = this.div.offsetWidth + "px", typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t))), this.addClickHandler()), google.maps.event.trigger(this, "content_changed");
    }, e.prototype.setPosition = function(t) {
      this.position = t, this.div && this.draw(), google.maps.event.trigger(this, "position_changed");
    }, e.prototype.setVisible = function(t) {
      this.isHidden = !t, this.div && (this.div.style.visibility = this.isHidden ? "hidden" : "visible");
    }, e.prototype.setZIndex = function(t) {
      this.zIndex = t, this.div && (this.div.style.zIndex = t + ""), google.maps.event.trigger(this, "zindex_changed");
    }, e.prototype.getContent = function() {
      return this.content;
    }, e.prototype.getPosition = function() {
      return this.position;
    }, e.prototype.getZIndex = function() {
      return this.zIndex;
    }, e.prototype.getVisible = function() {
      var t = this.getMap();
      return typeof t > "u" || t === null ? !1 : !this.isHidden;
    }, e.prototype.show = function() {
      this.isHidden = !1, this.div && (this.div.style.visibility = "visible");
    }, e.prototype.hide = function() {
      this.isHidden = !0, this.div && (this.div.style.visibility = "hidden");
    }, e.prototype.open = function(t, n) {
      var r = this;
      n && (this.position = n.getPosition(), this.moveListener = google.maps.event.addListener(n, "position_changed", function() {
        var o = n.getPosition();
        r.setPosition(o);
      }), this.mapListener = google.maps.event.addListener(n, "map_changed", function() {
        r.setMap(n.map);
      })), this.setMap(t), this.div && this.panBox();
    }, e.prototype.close = function() {
      if (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.eventListeners) {
        for (var t = 0, n = this.eventListeners; t < n.length; t++) {
          var r = n[t];
          google.maps.event.removeListener(r);
        }
        this.eventListeners = null;
      }
      this.moveListener && (google.maps.event.removeListener(this.moveListener), this.moveListener = null), this.mapListener && (google.maps.event.removeListener(this.mapListener), this.mapListener = null), this.contextListener && (google.maps.event.removeListener(this.contextListener), this.contextListener = null), this.setMap(null);
    }, e.prototype.extend = function(t, n) {
      return (function(o) {
        for (var i in o.prototype)
          Object.prototype.hasOwnProperty.call(this, i) || (this.prototype[i] = o.prototype[i]);
        return this;
      }).apply(t, [n]);
    }, e;
  }()
), l8e = ["position"], u8e = ["position"];
function I9(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Fy(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? I9(Object(n), !0).forEach(function(r) {
      ye(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : I9(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var R9 = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, B9 = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    t instanceof google.maps.LatLng ? e.setPosition(t) : e.setPosition(new google.maps.LatLng(t.lat, t.lng));
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, c8e = {};
function p8e(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, g = ge(Dt), [f, m] = k(null), [v, E] = k(null), [w, M] = k(null), [O, y] = k(null), [C, _] = k(null), [F, L] = k(null), N = ut(null);
  return h(() => {
    g && f !== null && (f.close(), n ? f.open(g, n) : f.getPosition() && f.open(g));
  }, [g, f, n]), h(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), h(() => {
    if (o && f !== null) {
      var R = o instanceof google.maps.LatLng ? o : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        new google.maps.LatLng(o.lat, o.lng)
      );
      f.setPosition(R);
    }
  }, [o]), h(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), h(() => {
    f && a && (v !== null && google.maps.event.removeListener(v), E(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), h(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), M(google.maps.event.addListener(f, "domready", s)));
  }, [s]), h(() => {
    f && l && (O !== null && google.maps.event.removeListener(O), y(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), h(() => {
    f && u && (C !== null && google.maps.event.removeListener(C), _(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), h(() => {
    f && c && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), h(() => {
    if (g) {
      var R = r || c8e, {
        position: W
      } = R, V = RS(R, l8e), z;
      W && !(W instanceof google.maps.LatLng) && (z = new google.maps.LatLng(W.lat, W.lng));
      var Z = new EJ(Fy(Fy({}, V), z ? {
        position: z
      } : {}));
      N.current = document.createElement("div"), m(Z), a && E(google.maps.event.addListener(Z, "closeclick", a)), s && M(google.maps.event.addListener(Z, "domready", s)), l && y(google.maps.event.addListener(Z, "content_changed", l)), u && _(google.maps.event.addListener(Z, "position_changed", u)), c && L(google.maps.event.addListener(Z, "zindex_changed", c)), Z.setContent(N.current), n ? Z.open(g, n) : Z.getPosition() ? Z.open(g) : Eo(!1, "You must provide either an anchor or a position prop for <InfoBox>."), p && p(Z);
    }
    return () => {
      f !== null && (v && google.maps.event.removeListener(v), O && google.maps.event.removeListener(O), w && google.maps.event.removeListener(w), C && google.maps.event.removeListener(C), F && google.maps.event.removeListener(F), d && d(f), f.close());
    };
  }, []), N.current ? or(lt.only(t), N.current) : null;
}
ve(p8e);
class d8e extends pe {
  constructor() {
    super(...arguments), ye(this, "registeredEvents", []), ye(this, "containerElement", null), ye(this, "state", {
      infoBox: null
    }), ye(this, "open", (t, n) => {
      n ? this.context !== null && t.open(this.context, n) : t.getPosition() ? this.context !== null && t.open(this.context) : Eo(!1, "You must provide either an anchor or a position prop for <InfoBox>.");
    }), ye(this, "setInfoBoxCallback", () => {
      this.state.infoBox !== null && this.containerElement !== null && (this.state.infoBox.setContent(this.containerElement), this.open(this.state.infoBox, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoBox));
    });
  }
  componentDidMount() {
    var t = this.props.options || {}, {
      position: n
    } = t, r = RS(t, u8e), o;
    n && !(n instanceof google.maps.LatLng) && (o = new google.maps.LatLng(n.lat, n.lng));
    var i = new EJ(Fy(Fy({}, r), o ? {
      position: o
    } : {}));
    this.containerElement = document.createElement("div"), this.registeredEvents = Vt({
      updaterMap: B9,
      eventMap: R9,
      prevProps: {},
      nextProps: this.props,
      instance: i
    }), this.setState({
      infoBox: i
    }, this.setInfoBoxCallback);
  }
  componentDidUpdate(t) {
    var {
      infoBox: n
    } = this.state;
    n !== null && (Qt(this.registeredEvents), this.registeredEvents = Vt({
      updaterMap: B9,
      eventMap: R9,
      prevProps: t,
      nextProps: this.props,
      instance: n
    }));
  }
  componentWillUnmount() {
    var {
      onUnmount: t
    } = this.props, {
      infoBox: n
    } = this.state;
    n !== null && (t && t(n), Qt(this.registeredEvents), n.close());
  }
  render() {
    return this.containerElement ? or(lt.only(this.props.children), this.containerElement) : null;
  }
}
ye(d8e, "contextType", Dt);
var HO, N9;
function f8e() {
  return N9 || (N9 = 1, HO = function e(t, n) {
    if (t === n) return !0;
    if (t && n && typeof t == "object" && typeof n == "object") {
      if (t.constructor !== n.constructor) return !1;
      var r, o, i;
      if (Array.isArray(t)) {
        if (r = t.length, r != n.length) return !1;
        for (o = r; o-- !== 0; ) if (!e(t[o], n[o])) return !1;
        return !0;
      }
      if (t.constructor === RegExp) return t.source === n.source && t.flags === n.flags;
      if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === n.valueOf();
      if (t.toString !== Object.prototype.toString) return t.toString() === n.toString();
      if (i = Object.keys(t), r = i.length, r !== Object.keys(n).length) return !1;
      for (o = r; o-- !== 0; ) if (!Object.prototype.hasOwnProperty.call(n, i[o])) return !1;
      for (o = r; o-- !== 0; ) {
        var a = i[o];
        if (!e(t[a], n[a])) return !1;
      }
      return !0;
    }
    return t !== t && n !== n;
  }), HO;
}
var h8e = f8e(), F9 = /* @__PURE__ */ gJ(h8e), z9 = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array], $O = 1, Ep = 8;
class BS {
  /**
   * Creates an index from raw `ArrayBuffer` data.
   * @param {ArrayBuffer} data
   */
  static from(t) {
    if (!(t instanceof ArrayBuffer))
      throw new Error("Data must be an instance of ArrayBuffer.");
    var [n, r] = new Uint8Array(t, 0, 2);
    if (n !== 219)
      throw new Error("Data does not appear to be in a KDBush format.");
    var o = r >> 4;
    if (o !== $O)
      throw new Error("Got v".concat(o, " data when expected v").concat($O, "."));
    var i = z9[r & 15];
    if (!i)
      throw new Error("Unrecognized array type.");
    var [a] = new Uint16Array(t, 2, 1), [s] = new Uint32Array(t, 4, 1);
    return new BS(s, a, i, t);
  }
  /**
   * Creates an index that will hold a given number of items.
   * @param {number} numItems
   * @param {number} [nodeSize=64] Size of the KD-tree node (64 by default).
   * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).
   * @param {ArrayBuffer} [data] (For internal use only)
   */
  constructor(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 64, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Float64Array, o = arguments.length > 3 ? arguments[3] : void 0;
    if (isNaN(t) || t < 0) throw new Error("Unpexpected numItems value: ".concat(t, "."));
    this.numItems = +t, this.nodeSize = Math.min(Math.max(+n, 2), 65535), this.ArrayType = r, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
    var i = z9.indexOf(this.ArrayType), a = t * 2 * this.ArrayType.BYTES_PER_ELEMENT, s = t * this.IndexArrayType.BYTES_PER_ELEMENT, l = (8 - s % 8) % 8;
    if (i < 0)
      throw new Error("Unexpected typed array class: ".concat(r, "."));
    o && o instanceof ArrayBuffer ? (this.data = o, this.ids = new this.IndexArrayType(this.data, Ep, t), this.coords = new this.ArrayType(this.data, Ep + s + l, t * 2), this._pos = t * 2, this._finished = !0) : (this.data = new ArrayBuffer(Ep + a + s + l), this.ids = new this.IndexArrayType(this.data, Ep, t), this.coords = new this.ArrayType(this.data, Ep + s + l, t * 2), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, ($O << 4) + i]), new Uint16Array(this.data, 2, 1)[0] = n, new Uint32Array(this.data, 4, 1)[0] = t);
  }
  /**
   * Add a point to the index.
   * @param {number} x
   * @param {number} y
   * @returns {number} An incremental index associated with the added item (starting from `0`).
   */
  add(t, n) {
    var r = this._pos >> 1;
    return this.ids[r] = r, this.coords[this._pos++] = t, this.coords[this._pos++] = n, r;
  }
  /**
   * Perform indexing of the added points.
   */
  finish() {
    var t = this._pos >> 1;
    if (t !== this.numItems)
      throw new Error("Added ".concat(t, " items when expected ").concat(this.numItems, "."));
    return y1(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
  }
  /**
   * Search the index for items within a given bounding box.
   * @param {number} minX
   * @param {number} minY
   * @param {number} maxX
   * @param {number} maxY
   * @returns {number[]} An array of indices correponding to the found items.
   */
  range(t, n, r, o) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: i,
      coords: a,
      nodeSize: s
    } = this, l = [0, i.length - 1, 0], u = []; l.length; ) {
      var c = l.pop() || 0, p = l.pop() || 0, d = l.pop() || 0;
      if (p - d <= s) {
        for (var g = d; g <= p; g++) {
          var f = a[2 * g], m = a[2 * g + 1];
          f >= t && f <= r && m >= n && m <= o && u.push(i[g]);
        }
        continue;
      }
      var v = d + p >> 1, E = a[2 * v], w = a[2 * v + 1];
      E >= t && E <= r && w >= n && w <= o && u.push(i[v]), (c === 0 ? t <= E : n <= w) && (l.push(d), l.push(v - 1), l.push(1 - c)), (c === 0 ? r >= E : o >= w) && (l.push(v + 1), l.push(p), l.push(1 - c));
    }
    return u;
  }
  /**
   * Search the index for items within a given radius.
   * @param {number} qx
   * @param {number} qy
   * @param {number} r Query radius.
   * @returns {number[]} An array of indices correponding to the found items.
   */
  within(t, n, r) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: o,
      coords: i,
      nodeSize: a
    } = this, s = [0, o.length - 1, 0], l = [], u = r * r; s.length; ) {
      var c = s.pop() || 0, p = s.pop() || 0, d = s.pop() || 0;
      if (p - d <= a) {
        for (var g = d; g <= p; g++)
          U9(i[2 * g], i[2 * g + 1], t, n) <= u && l.push(o[g]);
        continue;
      }
      var f = d + p >> 1, m = i[2 * f], v = i[2 * f + 1];
      U9(m, v, t, n) <= u && l.push(o[f]), (c === 0 ? t - r <= m : n - r <= v) && (s.push(d), s.push(f - 1), s.push(1 - c)), (c === 0 ? t + r >= m : n + r >= v) && (s.push(f + 1), s.push(p), s.push(1 - c));
    }
    return l;
  }
}
function y1(e, t, n, r, o, i) {
  if (!(o - r <= n)) {
    var a = r + o >> 1;
    kJ(e, t, a, r, o, i), y1(e, t, n, r, a - 1, 1 - i), y1(e, t, n, a + 1, o, 1 - i);
  }
}
function kJ(e, t, n, r, o, i) {
  for (; o > r; ) {
    if (o - r > 600) {
      var a = o - r + 1, s = n - r + 1, l = Math.log(a), u = 0.5 * Math.exp(2 * l / 3), c = 0.5 * Math.sqrt(l * u * (a - u) / a) * (s - a / 2 < 0 ? -1 : 1), p = Math.max(r, Math.floor(n - s * u / a + c)), d = Math.min(o, Math.floor(n + (a - s) * u / a + c));
      kJ(e, t, n, p, d, i);
    }
    var g = t[2 * n + i], f = r, m = o;
    for (kp(e, t, r, n), t[2 * o + i] > g && kp(e, t, r, o); f < m; ) {
      for (kp(e, t, f, m), f++, m--; t[2 * f + i] < g; ) f++;
      for (; t[2 * m + i] > g; ) m--;
    }
    t[2 * r + i] === g ? kp(e, t, r, m) : (m++, kp(e, t, m, o)), m <= n && (r = m + 1), n <= m && (o = m - 1);
  }
}
function kp(e, t, n, r) {
  WO(e, n, r), WO(t, 2 * n, 2 * r), WO(t, 2 * n + 1, 2 * r + 1);
}
function WO(e, t, n) {
  var r = e[t];
  e[t] = e[n], e[n] = r;
}
function U9(e, t, n, r) {
  var o = e - n, i = t - r;
  return o * o + i * i;
}
var g8e = {
  minZoom: 0,
  // min zoom to generate clusters on
  maxZoom: 16,
  // max zoom level to cluster the points on
  minPoints: 2,
  // minimum points to form a cluster
  radius: 40,
  // cluster radius in pixels
  extent: 512,
  // tile extent (radius is calculated relative to it)
  nodeSize: 64,
  // size of the KD-tree leaf node, affects performance
  log: !1,
  // whether to log timing info
  // whether to generate numeric ids for input features (in vector tiles)
  generateId: !1,
  // a reduce function for calculating custom cluster properties
  reduce: null,
  // (accumulated, props) => { accumulated.sum += props.sum; }
  // properties to use for individual points when running the reducer
  map: (e) => e
  // props => ({sum: props.my_value})
}, H9 = Math.fround || /* @__PURE__ */ ((e) => (t) => (e[0] = +t, e[0]))(new Float32Array(1)), Gl = 2, Ja = 3, VO = 4, $a = 5, LJ = 6;
class m8e {
  constructor(t) {
    this.options = Object.assign(Object.create(g8e), t), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
  }
  load(t) {
    var {
      log: n,
      minZoom: r,
      maxZoom: o
    } = this.options;
    n && console.time("total time");
    var i = "prepare ".concat(t.length, " points");
    n && console.time(i), this.points = t;
    for (var a = [], s = 0; s < t.length; s++) {
      var l = t[s];
      if (l.geometry) {
        var [u, c] = l.geometry.coordinates, p = H9(Om(u)), d = H9(Em(c));
        a.push(
          p,
          d,
          // projected point coordinates
          1 / 0,
          // the last zoom the point was processed at
          s,
          // index of the source feature in the original input array
          -1,
          // parent cluster id
          1
          // number of points in a cluster
        ), this.options.reduce && a.push(0);
      }
    }
    var g = this.trees[o + 1] = this._createTree(a);
    n && console.timeEnd(i);
    for (var f = o; f >= r; f--) {
      var m = +Date.now();
      g = this.trees[f] = this._createTree(this._cluster(g, f)), n && console.log("z%d: %d clusters in %dms", f, g.numItems, +Date.now() - m);
    }
    return n && console.timeEnd("total time"), this;
  }
  getClusters(t, n) {
    var r = ((t[0] + 180) % 360 + 360) % 360 - 180, o = Math.max(-90, Math.min(90, t[1])), i = t[2] === 180 ? 180 : ((t[2] + 180) % 360 + 360) % 360 - 180, a = Math.max(-90, Math.min(90, t[3]));
    if (t[2] - t[0] >= 360)
      r = -180, i = 180;
    else if (r > i) {
      var s = this.getClusters([r, o, 180, a], n), l = this.getClusters([-180, o, i, a], n);
      return s.concat(l);
    }
    var u = this.trees[this._limitZoom(n)], c = u.range(Om(r), Em(a), Om(i), Em(o)), p = u.data, d = [];
    for (var g of c) {
      var f = this.stride * g;
      d.push(p[f + $a] > 1 ? $9(p, f, this.clusterProps) : this.points[p[f + Ja]]);
    }
    return d;
  }
  getChildren(t) {
    var n = this._getOriginId(t), r = this._getOriginZoom(t), o = "No cluster with the specified id.", i = this.trees[r];
    if (!i) throw new Error(o);
    var a = i.data;
    if (n * this.stride >= a.length) throw new Error(o);
    var s = this.options.radius / (this.options.extent * Math.pow(2, r - 1)), l = a[n * this.stride], u = a[n * this.stride + 1], c = i.within(l, u, s), p = [];
    for (var d of c) {
      var g = d * this.stride;
      a[g + VO] === t && p.push(a[g + $a] > 1 ? $9(a, g, this.clusterProps) : this.points[a[g + Ja]]);
    }
    if (p.length === 0) throw new Error(o);
    return p;
  }
  getLeaves(t, n, r) {
    n = n || 10, r = r || 0;
    var o = [];
    return this._appendLeaves(o, t, n, r, 0), o;
  }
  getTile(t, n, r) {
    var o = this.trees[this._limitZoom(t)], i = Math.pow(2, t), {
      extent: a,
      radius: s
    } = this.options, l = s / a, u = (r - l) / i, c = (r + 1 + l) / i, p = {
      features: []
    };
    return this._addTileFeatures(o.range((n - l) / i, u, (n + 1 + l) / i, c), o.data, n, r, i, p), n === 0 && this._addTileFeatures(o.range(1 - l / i, u, 1, c), o.data, i, r, i, p), n === i - 1 && this._addTileFeatures(o.range(0, u, l / i, c), o.data, -1, r, i, p), p.features.length ? p : null;
  }
  getClusterExpansionZoom(t) {
    for (var n = this._getOriginZoom(t) - 1; n <= this.options.maxZoom; ) {
      var r = this.getChildren(t);
      if (n++, r.length !== 1) break;
      t = r[0].properties.cluster_id;
    }
    return n;
  }
  _appendLeaves(t, n, r, o, i) {
    var a = this.getChildren(n);
    for (var s of a) {
      var l = s.properties;
      if (l && l.cluster ? i + l.point_count <= o ? i += l.point_count : i = this._appendLeaves(t, l.cluster_id, r, o, i) : i < o ? i++ : t.push(s), t.length === r) break;
    }
    return i;
  }
  _createTree(t) {
    for (var n = new BS(t.length / this.stride | 0, this.options.nodeSize, Float32Array), r = 0; r < t.length; r += this.stride) n.add(t[r], t[r + 1]);
    return n.finish(), n.data = t, n;
  }
  _addTileFeatures(t, n, r, o, i, a) {
    for (var s of t) {
      var l = s * this.stride, u = n[l + $a] > 1, c = void 0, p = void 0, d = void 0;
      if (u)
        c = PJ(n, l, this.clusterProps), p = n[l], d = n[l + 1];
      else {
        var g = this.points[n[l + Ja]];
        c = g.properties;
        var [f, m] = g.geometry.coordinates;
        p = Om(f), d = Em(m);
      }
      var v = {
        type: 1,
        geometry: [[Math.round(this.options.extent * (p * i - r)), Math.round(this.options.extent * (d * i - o))]],
        tags: c
      }, E = void 0;
      u || this.options.generateId ? E = n[l + Ja] : E = this.points[n[l + Ja]].id, E !== void 0 && (v.id = E), a.features.push(v);
    }
  }
  _limitZoom(t) {
    return Math.max(this.options.minZoom, Math.min(Math.floor(+t), this.options.maxZoom + 1));
  }
  _cluster(t, n) {
    for (var {
      radius: r,
      extent: o,
      reduce: i,
      minPoints: a
    } = this.options, s = r / (o * Math.pow(2, n)), l = t.data, u = [], c = this.stride, p = 0; p < l.length; p += c)
      if (!(l[p + Gl] <= n)) {
        l[p + Gl] = n;
        var d = l[p], g = l[p + 1], f = t.within(l[p], l[p + 1], s), m = l[p + $a], v = m;
        for (var E of f) {
          var w = E * c;
          l[w + Gl] > n && (v += l[w + $a]);
        }
        if (v > m && v >= a) {
          var M = d * m, O = g * m, y = void 0, C = -1, _ = ((p / c | 0) << 5) + (n + 1) + this.points.length;
          for (var F of f) {
            var L = F * c;
            if (!(l[L + Gl] <= n)) {
              l[L + Gl] = n;
              var N = l[L + $a];
              M += l[L] * N, O += l[L + 1] * N, l[L + VO] = _, i && (y || (y = this._map(l, p, !0), C = this.clusterProps.length, this.clusterProps.push(y)), i(y, this._map(l, L)));
            }
          }
          l[p + VO] = _, u.push(M / v, O / v, 1 / 0, _, -1, v), i && u.push(C);
        } else {
          for (var R = 0; R < c; R++) u.push(l[p + R]);
          if (v > 1)
            for (var W of f) {
              var V = W * c;
              if (!(l[V + Gl] <= n)) {
                l[V + Gl] = n;
                for (var z = 0; z < c; z++) u.push(l[V + z]);
              }
            }
        }
      }
    return u;
  }
  // get index of the point from which the cluster originated
  _getOriginId(t) {
    return t - this.points.length >> 5;
  }
  // get zoom of the point from which the cluster originated
  _getOriginZoom(t) {
    return (t - this.points.length) % 32;
  }
  _map(t, n, r) {
    if (t[n + $a] > 1) {
      var o = this.clusterProps[t[n + LJ]];
      return r ? Object.assign({}, o) : o;
    }
    var i = this.points[t[n + Ja]].properties, a = this.options.map(i);
    return r && a === i ? Object.assign({}, a) : a;
  }
}
function $9(e, t, n) {
  return {
    type: "Feature",
    id: e[t + Ja],
    properties: PJ(e, t, n),
    geometry: {
      type: "Point",
      coordinates: [v8e(e[t]), y8e(e[t + 1])]
    }
  };
}
function PJ(e, t, n) {
  var r = e[t + $a], o = r >= 1e4 ? "".concat(Math.round(r / 1e3), "k") : r >= 1e3 ? "".concat(Math.round(r / 100) / 10, "k") : r, i = e[t + LJ], a = i === -1 ? {} : Object.assign({}, n[i]);
  return Object.assign(a, {
    cluster: !0,
    cluster_id: e[t + Ja],
    point_count: r,
    point_count_abbreviated: o
  });
}
function Om(e) {
  return e / 360 + 0.5;
}
function Em(e) {
  var t = Math.sin(e * Math.PI / 180), n = 0.5 - 0.25 * Math.log((1 + t) / (1 - t)) / Math.PI;
  return n < 0 ? 0 : n > 1 ? 1 : n;
}
function v8e(e) {
  return (e - 0.5) * 360;
}
function y8e(e) {
  var t = (180 - e * 360) * Math.PI / 180;
  return 360 * Math.atan(Math.exp(t)) / Math.PI - 90;
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function b8e(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
    t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
  return n;
}
class Fi {
  static isAdvancedMarkerAvailable(t) {
    return google.maps.marker && t.getMapCapabilities().isAdvancedMarkersAvailable === !0;
  }
  static isAdvancedMarker(t) {
    return google.maps.marker && t instanceof google.maps.marker.AdvancedMarkerElement;
  }
  static setMap(t, n) {
    this.isAdvancedMarker(t) ? t.map = n : t.setMap(n);
  }
  static getPosition(t) {
    if (this.isAdvancedMarker(t)) {
      if (t.position) {
        if (t.position instanceof google.maps.LatLng)
          return t.position;
        if (t.position.lat && t.position.lng)
          return new google.maps.LatLng(t.position.lat, t.position.lng);
      }
      return new google.maps.LatLng(null);
    }
    return t.getPosition();
  }
  static getVisible(t) {
    return this.isAdvancedMarker(t) ? !0 : t.getVisible();
  }
}
class b1 {
  constructor(t) {
    var {
      markers: n,
      position: r
    } = t;
    this.markers = n, r && (r instanceof google.maps.LatLng ? this._position = r : this._position = new google.maps.LatLng(r));
  }
  get bounds() {
    if (!(this.markers.length === 0 && !this._position)) {
      var t = new google.maps.LatLngBounds(this._position, this._position);
      for (var n of this.markers)
        t.extend(Fi.getPosition(n));
      return t;
    }
  }
  get position() {
    return this._position || this.bounds.getCenter();
  }
  /**
   * Get the count of **visible** markers.
   */
  get count() {
    return this.markers.filter((t) => Fi.getVisible(t)).length;
  }
  /**
   * Add a marker to the cluster.
   */
  push(t) {
    this.markers.push(t);
  }
  /**
   * Cleanup references and remove marker from map.
   */
  delete() {
    this.marker && (Fi.setMap(this.marker, null), this.marker = void 0), this.markers.length = 0;
  }
}
class w8e {
  constructor(t) {
    var {
      maxZoom: n = 16
    } = t;
    this.maxZoom = n;
  }
  /**
   * Helper function to bypass clustering based upon some map state such as
   * zoom, number of markers, etc.
   *
   * ```typescript
   *  cluster({markers, map}: AlgorithmInput): Cluster[] {
   *    if (shouldBypassClustering(map)) {
   *      return this.noop({markers})
   *    }
   * }
   * ```
   */
  noop(t) {
    var {
      markers: n
    } = t;
    return C8e(n);
  }
}
var C8e = (e) => {
  var t = e.map((n) => new b1({
    position: Fi.getPosition(n),
    markers: [n]
  }));
  return t;
};
class x8e extends w8e {
  constructor(t) {
    var {
      maxZoom: n,
      radius: r = 60
    } = t, o = b8e(t, ["maxZoom", "radius"]);
    super({
      maxZoom: n
    }), this.state = {
      zoom: -1
    }, this.superCluster = new m8e(Object.assign({
      maxZoom: this.maxZoom,
      radius: r
    }, o));
  }
  calculate(t) {
    var n = !1, r = {
      zoom: t.map.getZoom()
    };
    if (!F9(t.markers, this.markers)) {
      n = !0, this.markers = [...t.markers];
      var o = this.markers.map((i) => {
        var a = Fi.getPosition(i), s = [a.lng(), a.lat()];
        return {
          type: "Feature",
          geometry: {
            type: "Point",
            coordinates: s
          },
          properties: {
            marker: i
          }
        };
      });
      this.superCluster.load(o);
    }
    return n || (this.state.zoom <= this.maxZoom || r.zoom <= this.maxZoom) && (n = !F9(this.state, r)), this.state = r, n && (this.clusters = this.cluster(t)), {
      clusters: this.clusters,
      changed: n
    };
  }
  cluster(t) {
    var {
      map: n
    } = t;
    return this.superCluster.getClusters([-180, -90, 180, 90], Math.round(n.getZoom())).map((r) => this.transformCluster(r));
  }
  transformCluster(t) {
    var {
      geometry: {
        coordinates: [n, r]
      },
      properties: o
    } = t;
    if (o.cluster)
      return new b1({
        markers: this.superCluster.getLeaves(o.cluster_id, 1 / 0).map((a) => a.properties.marker),
        position: {
          lat: r,
          lng: n
        }
      });
    var i = o.marker;
    return new b1({
      markers: [i],
      position: Fi.getPosition(i)
    });
  }
}
class O8e {
  constructor(t, n) {
    this.markers = {
      sum: t.length
    };
    var r = n.map((i) => i.count), o = r.reduce((i, a) => i + a, 0);
    this.clusters = {
      count: n.length,
      markers: {
        mean: o / n.length,
        sum: o,
        min: Math.min(...r),
        max: Math.max(...r)
      }
    };
  }
}
class E8e {
  /**
   * The default render function for the library used by {@link MarkerClusterer}.
   *
   * Currently set to use the following:
   *
   * ```typescript
   * // change color if this cluster has more markers than the mean cluster
   * const color =
   *   count > Math.max(10, stats.clusters.markers.mean)
   *     ? "#ff0000"
   *     : "#0000ff";
   *
   * // create svg url with fill color
   * const svg = window.btoa(`
   * <svg fill="${color}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240">
   *   <circle cx="120" cy="120" opacity=".6" r="70" />
   *   <circle cx="120" cy="120" opacity=".3" r="90" />
   *   <circle cx="120" cy="120" opacity=".2" r="110" />
   *   <circle cx="120" cy="120" opacity=".1" r="130" />
   * </svg>`);
   *
   * // create marker using svg icon
   * return new google.maps.Marker({
   *   position,
   *   icon: {
   *     url: `data:image/svg+xml;base64,${svg}`,
   *     scaledSize: new google.maps.Size(45, 45),
   *   },
   *   label: {
   *     text: String(count),
   *     color: "rgba(255,255,255,0.9)",
   *     fontSize: "12px",
   *   },
   *   // adjust zIndex to be above other markers
   *   zIndex: 1000 + count,
   * });
   * ```
   */
  render(t, n, r) {
    var {
      count: o,
      position: i
    } = t, a = o > Math.max(10, n.clusters.markers.mean) ? "#ff0000" : "#0000ff", s = '<svg fill="'.concat(a, `" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" width="50" height="50">
<circle cx="120" cy="120" opacity=".6" r="70" />
<circle cx="120" cy="120" opacity=".3" r="90" />
<circle cx="120" cy="120" opacity=".2" r="110" />
<text x="50%" y="50%" style="fill:#fff" text-anchor="middle" font-size="50" dominant-baseline="middle" font-family="roboto,arial,sans-serif">`).concat(o, `</text>
</svg>`), l = "Cluster of ".concat(o, " markers"), u = Number(google.maps.Marker.MAX_ZINDEX) + o;
    if (Fi.isAdvancedMarkerAvailable(r)) {
      var c = new DOMParser(), p = c.parseFromString(s, "image/svg+xml").documentElement;
      p.setAttribute("transform", "translate(0 25)");
      var d = {
        map: r,
        position: i,
        zIndex: u,
        title: l,
        content: p
      };
      return new google.maps.marker.AdvancedMarkerElement(d);
    }
    var g = {
      position: i,
      zIndex: u,
      title: l,
      icon: {
        url: "data:image/svg+xml;base64,".concat(btoa(s)),
        anchor: new google.maps.Point(25, 25)
      }
    };
    return new google.maps.Marker(g);
  }
}
function k8e(e, t) {
  for (var n in t.prototype)
    e.prototype[n] = t.prototype[n];
}
class NS {
  constructor() {
    k8e(NS, google.maps.OverlayView);
  }
}
var gd;
(function(e) {
  e.CLUSTERING_BEGIN = "clusteringbegin", e.CLUSTERING_END = "clusteringend", e.CLUSTER_CLICK = "click";
})(gd || (gd = {}));
var L8e = (e, t, n) => {
  n.fitBounds(t.bounds);
};
class P8e extends NS {
  constructor(t) {
    var {
      map: n,
      markers: r = [],
      algorithmOptions: o = {},
      algorithm: i = new x8e(o),
      renderer: a = new E8e(),
      onClusterClick: s = L8e
    } = t;
    super(), this.markers = [...r], this.clusters = [], this.algorithm = i, this.renderer = a, this.onClusterClick = s, n && this.setMap(n);
  }
  addMarker(t, n) {
    this.markers.includes(t) || (this.markers.push(t), n || this.render());
  }
  addMarkers(t, n) {
    t.forEach((r) => {
      this.addMarker(r, !0);
    }), n || this.render();
  }
  removeMarker(t, n) {
    var r = this.markers.indexOf(t);
    return r === -1 ? !1 : (Fi.setMap(t, null), this.markers.splice(r, 1), n || this.render(), !0);
  }
  removeMarkers(t, n) {
    var r = !1;
    return t.forEach((o) => {
      r = this.removeMarker(o, !0) || r;
    }), r && !n && this.render(), r;
  }
  clearMarkers(t) {
    this.markers.length = 0, t || this.render();
  }
  /**
   * Recalculates and draws all the marker clusters.
   */
  render() {
    var t = this.getMap();
    if (t instanceof google.maps.Map && t.getProjection()) {
      google.maps.event.trigger(this, gd.CLUSTERING_BEGIN, this);
      var {
        clusters: n,
        changed: r
      } = this.algorithm.calculate({
        markers: this.markers,
        map: t,
        mapCanvasProjection: this.getProjection()
      });
      if (r || r == null) {
        var o = /* @__PURE__ */ new Set();
        for (var i of n)
          i.markers.length == 1 && o.add(i.markers[0]);
        var a = [];
        for (var s of this.clusters)
          s.marker != null && (s.markers.length == 1 ? o.has(s.marker) || Fi.setMap(s.marker, null) : a.push(s.marker));
        this.clusters = n, this.renderClusters(), requestAnimationFrame(() => a.forEach((l) => Fi.setMap(l, null)));
      }
      google.maps.event.trigger(this, gd.CLUSTERING_END, this);
    }
  }
  onAdd() {
    this.idleListener = this.getMap().addListener("idle", this.render.bind(this)), this.render();
  }
  onRemove() {
    google.maps.event.removeListener(this.idleListener), this.reset();
  }
  reset() {
    this.markers.forEach((t) => Fi.setMap(t, null)), this.clusters.forEach((t) => t.delete()), this.clusters = [];
  }
  renderClusters() {
    var t = new O8e(this.markers, this.clusters), n = this.getMap();
    this.clusters.forEach((r) => {
      r.markers.length === 1 ? r.marker = r.markers[0] : (r.marker = this.renderer.render(r, t, n), r.markers.forEach((o) => Fi.setMap(o, null)), this.onClusterClick && r.marker.addListener(
        "click",
        /* istanbul ignore next */
        (o) => {
          google.maps.event.trigger(this, gd.CLUSTER_CLICK, r), this.onClusterClick(o, r, n);
        }
      )), Fi.setMap(r.marker, n);
    });
  }
}
function W9(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function V9(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? W9(Object(n), !0).forEach(function(r) {
      ye(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : W9(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function _8e(e) {
  var t = P6e(), [n, r] = k(null);
  return h(() => {
    if (t && n === null) {
      var o = new P8e(V9(V9({}, e), {}, {
        map: t
      }));
      r(o);
    }
  }, [t]), n;
}
function S8e(e) {
  var {
    children: t,
    options: n
  } = e, r = _8e(n);
  return r !== null ? t(r) : null;
}
ve(S8e);
var Z9 = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, q9 = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
function M8e(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, g = ge(Dt), [f, m] = k(null), [v, E] = k(null), [w, M] = k(null), [O, y] = k(null), [C, _] = k(null), [F, L] = k(null), N = ut(null);
  return h(() => {
    f !== null && (f.close(), n ? f.open(g, n) : f.getPosition() && f.open(g));
  }, [g, f, n]), h(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), h(() => {
    o && f !== null && f.setPosition(o);
  }, [o]), h(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), h(() => {
    f && a && (v !== null && google.maps.event.removeListener(v), E(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), h(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), M(google.maps.event.addListener(f, "domready", s)));
  }, [s]), h(() => {
    f && l && (O !== null && google.maps.event.removeListener(O), y(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), h(() => {
    f && u && (C !== null && google.maps.event.removeListener(C), _(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), h(() => {
    f && c && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), h(() => {
    var R = new google.maps.InfoWindow(r);
    return m(R), N.current = document.createElement("div"), a && E(google.maps.event.addListener(R, "closeclick", a)), s && M(google.maps.event.addListener(R, "domready", s)), l && y(google.maps.event.addListener(R, "content_changed", l)), u && _(google.maps.event.addListener(R, "position_changed", u)), c && L(google.maps.event.addListener(R, "zindex_changed", c)), R.setContent(N.current), o && R.setPosition(o), i && R.setZIndex(i), n ? R.open(g, n) : R.getPosition() ? R.open(g) : Eo(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>."), p && p(R), () => {
      v && google.maps.event.removeListener(v), O && google.maps.event.removeListener(O), w && google.maps.event.removeListener(w), C && google.maps.event.removeListener(C), F && google.maps.event.removeListener(F), d && d(R), R.close();
    };
  }, []), N.current ? or(lt.only(t), N.current) : null;
}
ve(M8e);
class D8e extends pe {
  constructor() {
    super(...arguments), ye(this, "registeredEvents", []), ye(this, "containerElement", null), ye(this, "state", {
      infoWindow: null
    }), ye(this, "open", (t, n) => {
      n ? t.open(this.context, n) : t.getPosition() ? t.open(this.context) : Eo(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>.");
    }), ye(this, "setInfoWindowCallback", () => {
      this.state.infoWindow !== null && this.containerElement !== null && (this.state.infoWindow.setContent(this.containerElement), this.open(this.state.infoWindow, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoWindow));
    });
  }
  componentDidMount() {
    var t = new google.maps.InfoWindow(this.props.options);
    this.containerElement = document.createElement("div"), this.registeredEvents = Vt({
      updaterMap: q9,
      eventMap: Z9,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(() => ({
      infoWindow: t
    }), this.setInfoWindowCallback);
  }
  componentDidUpdate(t) {
    this.state.infoWindow !== null && (Qt(this.registeredEvents), this.registeredEvents = Vt({
      updaterMap: q9,
      eventMap: Z9,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.infoWindow
    }));
  }
  componentWillUnmount() {
    this.state.infoWindow !== null && (Qt(this.registeredEvents), this.props.onUnmount && this.props.onUnmount(this.state.infoWindow), this.state.infoWindow.close());
  }
  render() {
    return this.containerElement ? or(lt.only(this.props.children), this.containerElement) : null;
  }
}
ye(D8e, "contextType", Dt);
function G9(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function zy(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? G9(Object(n), !0).forEach(function(r) {
      ye(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : G9(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var K9 = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, Y9 = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, T8e = {};
function j8e(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: g,
    onRightClick: f,
    onClick: m,
    onDrag: v,
    onLoad: E,
    onUnmount: w
  } = e, M = ge(Dt), [O, y] = k(null), [C, _] = k(null), [F, L] = k(null), [N, R] = k(null), [W, V] = k(null), [z, Z] = k(null), [K, X] = k(null), [te, J] = k(null), [P, D] = k(null), [H, S] = k(null), [$, x] = k(null), [j, U] = k(null);
  return h(() => {
    O !== null && O.setMap(M);
  }, [M]), h(() => {
    typeof t < "u" && O !== null && O.setOptions(t);
  }, [O, t]), h(() => {
    typeof n < "u" && O !== null && O.setDraggable(n);
  }, [O, n]), h(() => {
    typeof r < "u" && O !== null && O.setEditable(r);
  }, [O, r]), h(() => {
    typeof o < "u" && O !== null && O.setVisible(o);
  }, [O, o]), h(() => {
    typeof i < "u" && O !== null && O.setPath(i);
  }, [O, i]), h(() => {
    O && a && (C !== null && google.maps.event.removeListener(C), _(google.maps.event.addListener(O, "dblclick", a)));
  }, [a]), h(() => {
    O && s && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(O, "dragend", s)));
  }, [s]), h(() => {
    O && l && (N !== null && google.maps.event.removeListener(N), R(google.maps.event.addListener(O, "dragstart", l)));
  }, [l]), h(() => {
    O && u && (W !== null && google.maps.event.removeListener(W), V(google.maps.event.addListener(O, "mousedown", u)));
  }, [u]), h(() => {
    O && c && (z !== null && google.maps.event.removeListener(z), Z(google.maps.event.addListener(O, "mousemove", c)));
  }, [c]), h(() => {
    O && p && (K !== null && google.maps.event.removeListener(K), X(google.maps.event.addListener(O, "mouseout", p)));
  }, [p]), h(() => {
    O && d && (te !== null && google.maps.event.removeListener(te), J(google.maps.event.addListener(O, "mouseover", d)));
  }, [d]), h(() => {
    O && g && (P !== null && google.maps.event.removeListener(P), D(google.maps.event.addListener(O, "mouseup", g)));
  }, [g]), h(() => {
    O && f && (H !== null && google.maps.event.removeListener(H), S(google.maps.event.addListener(O, "rightclick", f)));
  }, [f]), h(() => {
    O && m && ($ !== null && google.maps.event.removeListener($), x(google.maps.event.addListener(O, "click", m)));
  }, [m]), h(() => {
    O && v && (j !== null && google.maps.event.removeListener(j), U(google.maps.event.addListener(O, "drag", v)));
  }, [v]), h(() => {
    var T = new google.maps.Polyline(zy(zy({}, t || T8e), {}, {
      map: M
    }));
    return i && T.setPath(i), typeof o < "u" && T.setVisible(o), typeof r < "u" && T.setEditable(r), typeof n < "u" && T.setDraggable(n), a && _(google.maps.event.addListener(T, "dblclick", a)), s && L(google.maps.event.addListener(T, "dragend", s)), l && R(google.maps.event.addListener(T, "dragstart", l)), u && V(google.maps.event.addListener(T, "mousedown", u)), c && Z(google.maps.event.addListener(T, "mousemove", c)), p && X(google.maps.event.addListener(T, "mouseout", p)), d && J(google.maps.event.addListener(T, "mouseover", d)), g && D(google.maps.event.addListener(T, "mouseup", g)), f && S(google.maps.event.addListener(T, "rightclick", f)), m && x(google.maps.event.addListener(T, "click", m)), v && U(google.maps.event.addListener(T, "drag", v)), y(T), E && E(T), () => {
      C !== null && google.maps.event.removeListener(C), F !== null && google.maps.event.removeListener(F), N !== null && google.maps.event.removeListener(N), W !== null && google.maps.event.removeListener(W), z !== null && google.maps.event.removeListener(z), K !== null && google.maps.event.removeListener(K), te !== null && google.maps.event.removeListener(te), P !== null && google.maps.event.removeListener(P), H !== null && google.maps.event.removeListener(H), $ !== null && google.maps.event.removeListener($), w && w(T), T.setMap(null);
    };
  }, []), null;
}
ve(j8e);
class A8e extends pe {
  constructor() {
    super(...arguments), ye(this, "registeredEvents", []), ye(this, "state", {
      polyline: null
    }), ye(this, "setPolylineCallback", () => {
      this.state.polyline !== null && this.props.onLoad && this.props.onLoad(this.state.polyline);
    });
  }
  componentDidMount() {
    var t = new google.maps.Polyline(zy(zy({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Vt({
      updaterMap: Y9,
      eventMap: K9,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        polyline: t
      };
    }, this.setPolylineCallback);
  }
  componentDidUpdate(t) {
    this.state.polyline !== null && (Qt(this.registeredEvents), this.registeredEvents = Vt({
      updaterMap: Y9,
      eventMap: K9,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.polyline
    }));
  }
  componentWillUnmount() {
    this.state.polyline !== null && (this.props.onUnmount && this.props.onUnmount(this.state.polyline), Qt(this.registeredEvents), this.state.polyline.setMap(null));
  }
  render() {
    return null;
  }
}
ye(A8e, "contextType", Dt);
function X9(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function J9(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? X9(Object(n), !0).forEach(function(r) {
      ye(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : X9(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Q9 = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, e6 = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  paths(e, t) {
    e.setPaths(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function I8e(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    paths: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: g,
    onMouseUp: f,
    onRightClick: m,
    onClick: v,
    onDrag: E,
    onLoad: w,
    onUnmount: M,
    onEdit: O
  } = e, y = ge(Dt), [C, _] = k(null), [F, L] = k(null), [N, R] = k(null), [W, V] = k(null), [z, Z] = k(null), [K, X] = k(null), [te, J] = k(null), [P, D] = k(null), [H, S] = k(null), [$, x] = k(null), [j, U] = k(null), [T, q] = k(null);
  return h(() => {
    C !== null && C.setMap(y);
  }, [y]), h(() => {
    typeof t < "u" && C !== null && C.setOptions(t);
  }, [C, t]), h(() => {
    typeof n < "u" && C !== null && C.setDraggable(n);
  }, [C, n]), h(() => {
    typeof r < "u" && C !== null && C.setEditable(r);
  }, [C, r]), h(() => {
    typeof o < "u" && C !== null && C.setVisible(o);
  }, [C, o]), h(() => {
    typeof i < "u" && C !== null && C.setPath(i);
  }, [C, i]), h(() => {
    typeof a < "u" && C !== null && C.setPaths(a);
  }, [C, a]), h(() => {
    C && typeof s == "function" && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(C, "dblclick", s)));
  }, [s]), h(() => {
    C && (google.maps.event.addListener(C.getPath(), "insert_at", () => {
      O == null || O(C);
    }), google.maps.event.addListener(C.getPath(), "set_at", () => {
      O == null || O(C);
    }), google.maps.event.addListener(C.getPath(), "remove_at", () => {
      O == null || O(C);
    }));
  }, [C, O]), h(() => {
    C && typeof l == "function" && (N !== null && google.maps.event.removeListener(N), R(google.maps.event.addListener(C, "dragend", l)));
  }, [l]), h(() => {
    C && typeof u == "function" && (W !== null && google.maps.event.removeListener(W), V(google.maps.event.addListener(C, "dragstart", u)));
  }, [u]), h(() => {
    C && typeof c == "function" && (z !== null && google.maps.event.removeListener(z), Z(google.maps.event.addListener(C, "mousedown", c)));
  }, [c]), h(() => {
    C && typeof p == "function" && (K !== null && google.maps.event.removeListener(K), X(google.maps.event.addListener(C, "mousemove", p)));
  }, [p]), h(() => {
    C && typeof d == "function" && (te !== null && google.maps.event.removeListener(te), J(google.maps.event.addListener(C, "mouseout", d)));
  }, [d]), h(() => {
    C && typeof g == "function" && (P !== null && google.maps.event.removeListener(P), D(google.maps.event.addListener(C, "mouseover", g)));
  }, [g]), h(() => {
    C && typeof f == "function" && (H !== null && google.maps.event.removeListener(H), S(google.maps.event.addListener(C, "mouseup", f)));
  }, [f]), h(() => {
    C && typeof m == "function" && ($ !== null && google.maps.event.removeListener($), x(google.maps.event.addListener(C, "rightclick", m)));
  }, [m]), h(() => {
    C && typeof v == "function" && (j !== null && google.maps.event.removeListener(j), U(google.maps.event.addListener(C, "click", v)));
  }, [v]), h(() => {
    C && typeof E == "function" && (T !== null && google.maps.event.removeListener(T), q(google.maps.event.addListener(C, "drag", E)));
  }, [E]), h(() => {
    var A = new google.maps.Polygon(J9(J9({}, t), {}, {
      map: y
    }));
    return i && A.setPath(i), a && A.setPaths(a), typeof o < "u" && A.setVisible(o), typeof r < "u" && A.setEditable(r), typeof n < "u" && A.setDraggable(n), s && L(google.maps.event.addListener(A, "dblclick", s)), l && R(google.maps.event.addListener(A, "dragend", l)), u && V(google.maps.event.addListener(A, "dragstart", u)), c && Z(google.maps.event.addListener(A, "mousedown", c)), p && X(google.maps.event.addListener(A, "mousemove", p)), d && J(google.maps.event.addListener(A, "mouseout", d)), g && D(google.maps.event.addListener(A, "mouseover", g)), f && S(google.maps.event.addListener(A, "mouseup", f)), m && x(google.maps.event.addListener(A, "rightclick", m)), v && U(google.maps.event.addListener(A, "click", v)), E && q(google.maps.event.addListener(A, "drag", E)), _(A), w && w(A), () => {
      F !== null && google.maps.event.removeListener(F), N !== null && google.maps.event.removeListener(N), W !== null && google.maps.event.removeListener(W), z !== null && google.maps.event.removeListener(z), K !== null && google.maps.event.removeListener(K), te !== null && google.maps.event.removeListener(te), P !== null && google.maps.event.removeListener(P), H !== null && google.maps.event.removeListener(H), $ !== null && google.maps.event.removeListener($), j !== null && google.maps.event.removeListener(j), M && M(A), A.setMap(null);
    };
  }, []), null;
}
ve(I8e);
class R8e extends pe {
  constructor() {
    super(...arguments), ye(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this.props.options || {};
    this.polygon = new google.maps.Polygon(t), this.polygon.setMap(this.context), this.registeredEvents = Vt({
      updaterMap: e6,
      eventMap: Q9,
      prevProps: {},
      nextProps: this.props,
      instance: this.polygon
    }), this.props.onLoad && this.props.onLoad(this.polygon);
  }
  componentDidUpdate(t) {
    this.polygon && (Qt(this.registeredEvents), this.registeredEvents = Vt({
      updaterMap: e6,
      eventMap: Q9,
      prevProps: t,
      nextProps: this.props,
      instance: this.polygon
    }));
  }
  componentWillUnmount() {
    this.polygon && (this.props.onUnmount && this.props.onUnmount(this.polygon), Qt(this.registeredEvents), this.polygon && this.polygon.setMap(null));
  }
  render() {
    return null;
  }
}
ye(R8e, "contextType", Dt);
function t6(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Uy(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? t6(Object(n), !0).forEach(function(r) {
      ye(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : t6(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var n6 = {
  onBoundsChanged: "bounds_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, r6 = {
  bounds(e, t) {
    e.setBounds(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function B8e(e) {
  var {
    options: t,
    bounds: n,
    draggable: r,
    editable: o,
    visible: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: g,
    onRightClick: f,
    onClick: m,
    onDrag: v,
    onBoundsChanged: E,
    onLoad: w,
    onUnmount: M
  } = e, O = ge(Dt), [y, C] = k(null), [_, F] = k(null), [L, N] = k(null), [R, W] = k(null), [V, z] = k(null), [Z, K] = k(null), [X, te] = k(null), [J, P] = k(null), [D, H] = k(null), [S, $] = k(null), [x, j] = k(null), [U, T] = k(null), [q, A] = k(null);
  return h(() => {
    y !== null && y.setMap(O);
  }, [O]), h(() => {
    typeof t < "u" && y !== null && y.setOptions(t);
  }, [y, t]), h(() => {
    typeof r < "u" && y !== null && y.setDraggable(r);
  }, [y, r]), h(() => {
    typeof o < "u" && y !== null && y.setEditable(o);
  }, [y, o]), h(() => {
    typeof i < "u" && y !== null && y.setVisible(i);
  }, [y, i]), h(() => {
    typeof n < "u" && y !== null && y.setBounds(n);
  }, [y, n]), h(() => {
    y && a && (_ !== null && google.maps.event.removeListener(_), F(google.maps.event.addListener(y, "dblclick", a)));
  }, [a]), h(() => {
    y && s && (L !== null && google.maps.event.removeListener(L), N(google.maps.event.addListener(y, "dragend", s)));
  }, [s]), h(() => {
    y && l && (R !== null && google.maps.event.removeListener(R), W(google.maps.event.addListener(y, "dragstart", l)));
  }, [l]), h(() => {
    y && u && (V !== null && google.maps.event.removeListener(V), z(google.maps.event.addListener(y, "mousedown", u)));
  }, [u]), h(() => {
    y && c && (Z !== null && google.maps.event.removeListener(Z), K(google.maps.event.addListener(y, "mousemove", c)));
  }, [c]), h(() => {
    y && p && (X !== null && google.maps.event.removeListener(X), te(google.maps.event.addListener(y, "mouseout", p)));
  }, [p]), h(() => {
    y && d && (J !== null && google.maps.event.removeListener(J), P(google.maps.event.addListener(y, "mouseover", d)));
  }, [d]), h(() => {
    y && g && (D !== null && google.maps.event.removeListener(D), H(google.maps.event.addListener(y, "mouseup", g)));
  }, [g]), h(() => {
    y && f && (S !== null && google.maps.event.removeListener(S), $(google.maps.event.addListener(y, "rightclick", f)));
  }, [f]), h(() => {
    y && m && (x !== null && google.maps.event.removeListener(x), j(google.maps.event.addListener(y, "click", m)));
  }, [m]), h(() => {
    y && v && (U !== null && google.maps.event.removeListener(U), T(google.maps.event.addListener(y, "drag", v)));
  }, [v]), h(() => {
    y && E && (q !== null && google.maps.event.removeListener(q), A(google.maps.event.addListener(y, "bounds_changed", E)));
  }, [E]), h(() => {
    var Y = new google.maps.Rectangle(Uy(Uy({}, t), {}, {
      map: O
    }));
    return typeof i < "u" && Y.setVisible(i), typeof o < "u" && Y.setEditable(o), typeof r < "u" && Y.setDraggable(r), typeof n < "u" && Y.setBounds(n), a && F(google.maps.event.addListener(Y, "dblclick", a)), s && N(google.maps.event.addListener(Y, "dragend", s)), l && W(google.maps.event.addListener(Y, "dragstart", l)), u && z(google.maps.event.addListener(Y, "mousedown", u)), c && K(google.maps.event.addListener(Y, "mousemove", c)), p && te(google.maps.event.addListener(Y, "mouseout", p)), d && P(google.maps.event.addListener(Y, "mouseover", d)), g && H(google.maps.event.addListener(Y, "mouseup", g)), f && $(google.maps.event.addListener(Y, "rightclick", f)), m && j(google.maps.event.addListener(Y, "click", m)), v && T(google.maps.event.addListener(Y, "drag", v)), E && A(google.maps.event.addListener(Y, "bounds_changed", E)), C(Y), w && w(Y), () => {
      _ !== null && google.maps.event.removeListener(_), L !== null && google.maps.event.removeListener(L), R !== null && google.maps.event.removeListener(R), V !== null && google.maps.event.removeListener(V), Z !== null && google.maps.event.removeListener(Z), X !== null && google.maps.event.removeListener(X), J !== null && google.maps.event.removeListener(J), D !== null && google.maps.event.removeListener(D), S !== null && google.maps.event.removeListener(S), x !== null && google.maps.event.removeListener(x), U !== null && google.maps.event.removeListener(U), q !== null && google.maps.event.removeListener(q), M && M(Y), Y.setMap(null);
    };
  }, []), null;
}
ve(B8e);
class N8e extends pe {
  constructor() {
    super(...arguments), ye(this, "registeredEvents", []), ye(this, "state", {
      rectangle: null
    }), ye(this, "setRectangleCallback", () => {
      this.state.rectangle !== null && this.props.onLoad && this.props.onLoad(this.state.rectangle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Rectangle(Uy(Uy({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Vt({
      updaterMap: r6,
      eventMap: n6,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        rectangle: t
      };
    }, this.setRectangleCallback);
  }
  componentDidUpdate(t) {
    this.state.rectangle !== null && (Qt(this.registeredEvents), this.registeredEvents = Vt({
      updaterMap: r6,
      eventMap: n6,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.rectangle
    }));
  }
  componentWillUnmount() {
    this.state.rectangle !== null && (this.props.onUnmount && this.props.onUnmount(this.state.rectangle), Qt(this.registeredEvents), this.state.rectangle.setMap(null));
  }
  render() {
    return null;
  }
}
ye(N8e, "contextType", Dt);
function o6(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Hy(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? o6(Object(n), !0).forEach(function(r) {
      ye(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : o6(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var i6 = {
  onCenterChanged: "center_changed",
  onRadiusChanged: "radius_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, s6 = {
  center(e, t) {
    e.setCenter(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  radius(e, t) {
    e.setRadius(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, F8e = {};
function z8e(e) {
  var {
    options: t,
    center: n,
    radius: r,
    draggable: o,
    editable: i,
    visible: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: g,
    onMouseUp: f,
    onRightClick: m,
    onClick: v,
    onDrag: E,
    onCenterChanged: w,
    onRadiusChanged: M,
    onLoad: O,
    onUnmount: y
  } = e, C = ge(Dt), [_, F] = k(null), [L, N] = k(null), [R, W] = k(null), [V, z] = k(null), [Z, K] = k(null), [X, te] = k(null), [J, P] = k(null), [D, H] = k(null), [S, $] = k(null), [x, j] = k(null), [U, T] = k(null), [q, A] = k(null), [Y, B] = k(null), [ue, fe] = k(null);
  return h(() => {
    _ !== null && _.setMap(C);
  }, [C]), h(() => {
    typeof t < "u" && _ !== null && _.setOptions(t);
  }, [_, t]), h(() => {
    typeof o < "u" && _ !== null && _.setDraggable(o);
  }, [_, o]), h(() => {
    typeof i < "u" && _ !== null && _.setEditable(i);
  }, [_, i]), h(() => {
    typeof a < "u" && _ !== null && _.setVisible(a);
  }, [_, a]), h(() => {
    typeof r == "number" && _ !== null && _.setRadius(r);
  }, [_, r]), h(() => {
    typeof n < "u" && _ !== null && _.setCenter(n);
  }, [_, n]), h(() => {
    _ && s && (L !== null && google.maps.event.removeListener(L), N(google.maps.event.addListener(_, "dblclick", s)));
  }, [s]), h(() => {
    _ && l && (R !== null && google.maps.event.removeListener(R), W(google.maps.event.addListener(_, "dragend", l)));
  }, [l]), h(() => {
    _ && u && (V !== null && google.maps.event.removeListener(V), z(google.maps.event.addListener(_, "dragstart", u)));
  }, [u]), h(() => {
    _ && c && (Z !== null && google.maps.event.removeListener(Z), K(google.maps.event.addListener(_, "mousedown", c)));
  }, [c]), h(() => {
    _ && p && (X !== null && google.maps.event.removeListener(X), te(google.maps.event.addListener(_, "mousemove", p)));
  }, [p]), h(() => {
    _ && d && (J !== null && google.maps.event.removeListener(J), P(google.maps.event.addListener(_, "mouseout", d)));
  }, [d]), h(() => {
    _ && g && (D !== null && google.maps.event.removeListener(D), H(google.maps.event.addListener(_, "mouseover", g)));
  }, [g]), h(() => {
    _ && f && (S !== null && google.maps.event.removeListener(S), $(google.maps.event.addListener(_, "mouseup", f)));
  }, [f]), h(() => {
    _ && m && (x !== null && google.maps.event.removeListener(x), j(google.maps.event.addListener(_, "rightclick", m)));
  }, [m]), h(() => {
    _ && v && (U !== null && google.maps.event.removeListener(U), T(google.maps.event.addListener(_, "click", v)));
  }, [v]), h(() => {
    _ && E && (q !== null && google.maps.event.removeListener(q), A(google.maps.event.addListener(_, "drag", E)));
  }, [E]), h(() => {
    _ && w && (Y !== null && google.maps.event.removeListener(Y), B(google.maps.event.addListener(_, "center_changed", w)));
  }, [v]), h(() => {
    _ && M && (ue !== null && google.maps.event.removeListener(ue), fe(google.maps.event.addListener(_, "radius_changed", M)));
  }, [M]), h(() => {
    var oe = new google.maps.Circle(Hy(Hy({}, t || F8e), {}, {
      map: C
    }));
    return typeof r == "number" && oe.setRadius(r), typeof n < "u" && oe.setCenter(n), typeof r == "number" && oe.setRadius(r), typeof a < "u" && oe.setVisible(a), typeof i < "u" && oe.setEditable(i), typeof o < "u" && oe.setDraggable(o), s && N(google.maps.event.addListener(oe, "dblclick", s)), l && W(google.maps.event.addListener(oe, "dragend", l)), u && z(google.maps.event.addListener(oe, "dragstart", u)), c && K(google.maps.event.addListener(oe, "mousedown", c)), p && te(google.maps.event.addListener(oe, "mousemove", p)), d && P(google.maps.event.addListener(oe, "mouseout", d)), g && H(google.maps.event.addListener(oe, "mouseover", g)), f && $(google.maps.event.addListener(oe, "mouseup", f)), m && j(google.maps.event.addListener(oe, "rightclick", m)), v && T(google.maps.event.addListener(oe, "click", v)), E && A(google.maps.event.addListener(oe, "drag", E)), w && B(google.maps.event.addListener(oe, "center_changed", w)), M && fe(google.maps.event.addListener(oe, "radius_changed", M)), F(oe), O && O(oe), () => {
      L !== null && google.maps.event.removeListener(L), R !== null && google.maps.event.removeListener(R), V !== null && google.maps.event.removeListener(V), Z !== null && google.maps.event.removeListener(Z), X !== null && google.maps.event.removeListener(X), J !== null && google.maps.event.removeListener(J), D !== null && google.maps.event.removeListener(D), S !== null && google.maps.event.removeListener(S), x !== null && google.maps.event.removeListener(x), U !== null && google.maps.event.removeListener(U), Y !== null && google.maps.event.removeListener(Y), ue !== null && google.maps.event.removeListener(ue), y && y(oe), oe.setMap(null);
    };
  }, []), null;
}
ve(z8e);
class U8e extends pe {
  constructor() {
    super(...arguments), ye(this, "registeredEvents", []), ye(this, "state", {
      circle: null
    }), ye(this, "setCircleCallback", () => {
      this.state.circle !== null && this.props.onLoad && this.props.onLoad(this.state.circle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Circle(Hy(Hy({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Vt({
      updaterMap: s6,
      eventMap: i6,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        circle: t
      };
    }, this.setCircleCallback);
  }
  componentDidUpdate(t) {
    this.state.circle !== null && (Qt(this.registeredEvents), this.registeredEvents = Vt({
      updaterMap: s6,
      eventMap: i6,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.circle
    }));
  }
  componentWillUnmount() {
    if (this.state.circle !== null) {
      var t;
      this.props.onUnmount && this.props.onUnmount(this.state.circle), Qt(this.registeredEvents), (t = this.state.circle) === null || t === void 0 || t.setMap(null);
    }
  }
  render() {
    return null;
  }
}
ye(U8e, "contextType", Dt);
function a6(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function $y(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? a6(Object(n), !0).forEach(function(r) {
      ye(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : a6(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var l6 = {
  onClick: "click",
  onDblClick: "dblclick",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onAddFeature: "addfeature",
  onRemoveFeature: "removefeature",
  onRemoveProperty: "removeproperty",
  onSetGeometry: "setgeometry",
  onSetProperty: "setproperty"
}, u6 = {
  add(e, t) {
    e.add(t);
  },
  addgeojson(e, t, n) {
    e.addGeoJson(t, n);
  },
  contains(e, t) {
    e.contains(t);
  },
  foreach(e, t) {
    e.forEach(t);
  },
  loadgeojson(e, t, n, r) {
    e.loadGeoJson(t, n, r);
  },
  overridestyle(e, t, n) {
    e.overrideStyle(t, n);
  },
  remove(e, t) {
    e.remove(t);
  },
  revertstyle(e, t) {
    e.revertStyle(t);
  },
  controlposition(e, t) {
    e.setControlPosition(t);
  },
  controls(e, t) {
    e.setControls(t);
  },
  drawingmode(e, t) {
    e.setDrawingMode(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  style(e, t) {
    e.setStyle(t);
  },
  togeojson(e, t) {
    e.toGeoJson(t);
  }
};
function H8e(e) {
  var {
    options: t,
    onClick: n,
    onDblClick: r,
    onMouseDown: o,
    onMouseMove: i,
    onMouseOut: a,
    onMouseOver: s,
    onMouseUp: l,
    onRightClick: u,
    onAddFeature: c,
    onRemoveFeature: p,
    onRemoveProperty: d,
    onSetGeometry: g,
    onSetProperty: f,
    onLoad: m,
    onUnmount: v
  } = e, E = ge(Dt), [w, M] = k(null), [O, y] = k(null), [C, _] = k(null), [F, L] = k(null), [N, R] = k(null), [W, V] = k(null), [z, Z] = k(null), [K, X] = k(null), [te, J] = k(null), [P, D] = k(null), [H, S] = k(null), [$, x] = k(null), [j, U] = k(null), [T, q] = k(null);
  return h(() => {
    w !== null && w.setMap(E);
  }, [E]), h(() => {
    w && r && (O !== null && google.maps.event.removeListener(O), y(google.maps.event.addListener(w, "dblclick", r)));
  }, [r]), h(() => {
    w && o && (C !== null && google.maps.event.removeListener(C), _(google.maps.event.addListener(w, "mousedown", o)));
  }, [o]), h(() => {
    w && i && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(w, "mousemove", i)));
  }, [i]), h(() => {
    w && a && (N !== null && google.maps.event.removeListener(N), R(google.maps.event.addListener(w, "mouseout", a)));
  }, [a]), h(() => {
    w && s && (W !== null && google.maps.event.removeListener(W), V(google.maps.event.addListener(w, "mouseover", s)));
  }, [s]), h(() => {
    w && l && (z !== null && google.maps.event.removeListener(z), Z(google.maps.event.addListener(w, "mouseup", l)));
  }, [l]), h(() => {
    w && u && (K !== null && google.maps.event.removeListener(K), X(google.maps.event.addListener(w, "rightclick", u)));
  }, [u]), h(() => {
    w && n && (te !== null && google.maps.event.removeListener(te), J(google.maps.event.addListener(w, "click", n)));
  }, [n]), h(() => {
    w && c && (P !== null && google.maps.event.removeListener(P), D(google.maps.event.addListener(w, "addfeature", c)));
  }, [c]), h(() => {
    w && p && (H !== null && google.maps.event.removeListener(H), S(google.maps.event.addListener(w, "removefeature", p)));
  }, [p]), h(() => {
    w && d && ($ !== null && google.maps.event.removeListener($), x(google.maps.event.addListener(w, "removeproperty", d)));
  }, [d]), h(() => {
    w && g && (j !== null && google.maps.event.removeListener(j), U(google.maps.event.addListener(w, "setgeometry", g)));
  }, [g]), h(() => {
    w && f && (T !== null && google.maps.event.removeListener(T), q(google.maps.event.addListener(w, "setproperty", f)));
  }, [f]), h(() => {
    if (E !== null) {
      var A = new google.maps.Data($y($y({}, t), {}, {
        map: E
      }));
      r && y(google.maps.event.addListener(A, "dblclick", r)), o && _(google.maps.event.addListener(A, "mousedown", o)), i && L(google.maps.event.addListener(A, "mousemove", i)), a && R(google.maps.event.addListener(A, "mouseout", a)), s && V(google.maps.event.addListener(A, "mouseover", s)), l && Z(google.maps.event.addListener(A, "mouseup", l)), u && X(google.maps.event.addListener(A, "rightclick", u)), n && J(google.maps.event.addListener(A, "click", n)), c && D(google.maps.event.addListener(A, "addfeature", c)), p && S(google.maps.event.addListener(A, "removefeature", p)), d && x(google.maps.event.addListener(A, "removeproperty", d)), g && U(google.maps.event.addListener(A, "setgeometry", g)), f && q(google.maps.event.addListener(A, "setproperty", f)), M(A), m && m(A);
    }
    return () => {
      w && (O !== null && google.maps.event.removeListener(O), C !== null && google.maps.event.removeListener(C), F !== null && google.maps.event.removeListener(F), N !== null && google.maps.event.removeListener(N), W !== null && google.maps.event.removeListener(W), z !== null && google.maps.event.removeListener(z), K !== null && google.maps.event.removeListener(K), te !== null && google.maps.event.removeListener(te), P !== null && google.maps.event.removeListener(P), H !== null && google.maps.event.removeListener(H), $ !== null && google.maps.event.removeListener($), j !== null && google.maps.event.removeListener(j), T !== null && google.maps.event.removeListener(T), v && v(w), w.setMap(null));
    };
  }, []), null;
}
ve(H8e);
class $8e extends pe {
  constructor() {
    super(...arguments), ye(this, "registeredEvents", []), ye(this, "state", {
      data: null
    }), ye(this, "setDataCallback", () => {
      this.state.data !== null && this.props.onLoad && this.props.onLoad(this.state.data);
    });
  }
  componentDidMount() {
    if (this.context !== null) {
      var t = new google.maps.Data($y($y({}, this.props.options), {}, {
        map: this.context
      }));
      this.registeredEvents = Vt({
        updaterMap: u6,
        eventMap: l6,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        data: t
      }), this.setDataCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.data !== null && (Qt(this.registeredEvents), this.registeredEvents = Vt({
      updaterMap: u6,
      eventMap: l6,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.data
    }));
  }
  componentWillUnmount() {
    this.state.data !== null && (this.props.onUnmount && this.props.onUnmount(this.state.data), Qt(this.registeredEvents), this.state.data && this.state.data.setMap(null));
  }
  render() {
    return null;
  }
}
ye($8e, "contextType", Dt);
function c6(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function p6(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? c6(Object(n), !0).forEach(function(r) {
      ye(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : c6(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var d6 = {
  onClick: "click",
  onDefaultViewportChanged: "defaultviewport_changed",
  onStatusChanged: "status_changed"
}, f6 = {
  options(e, t) {
    e.setOptions(t);
  },
  url(e, t) {
    e.setUrl(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
class W8e extends pe {
  constructor() {
    super(...arguments), ye(this, "registeredEvents", []), ye(this, "state", {
      kmlLayer: null
    }), ye(this, "setKmlLayerCallback", () => {
      this.state.kmlLayer !== null && this.props.onLoad && this.props.onLoad(this.state.kmlLayer);
    });
  }
  componentDidMount() {
    var t = new google.maps.KmlLayer(p6(p6({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Vt({
      updaterMap: f6,
      eventMap: d6,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        kmlLayer: t
      };
    }, this.setKmlLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.kmlLayer !== null && (Qt(this.registeredEvents), this.registeredEvents = Vt({
      updaterMap: f6,
      eventMap: d6,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.kmlLayer
    }));
  }
  componentWillUnmount() {
    this.state.kmlLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.kmlLayer), Qt(this.registeredEvents), this.state.kmlLayer.setMap(null));
  }
  render() {
    return null;
  }
}
ye(W8e, "contextType", Dt);
function _J(e, t) {
  return typeof t == "function" ? t(e.offsetWidth, e.offsetHeight) : {
    x: 0,
    y: 0
  };
}
function V8e(e, t) {
  return new t(e.lat, e.lng);
}
function Z8e(e, t) {
  return new t(new google.maps.LatLng(e.ne.lat, e.ne.lng), new google.maps.LatLng(e.sw.lat, e.sw.lng));
}
function q8e(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function G8e(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function K8e(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n.getNorthEast()), o = e && e.fromLatLngToDivPixel(n.getSouthWest());
  return r && o ? {
    left: "".concat(o.x + t.x, "px"),
    top: "".concat(r.y + t.y, "px"),
    width: "".concat(r.x - o.x - t.x, "px"),
    height: "".concat(o.y - r.y - t.y, "px")
  } : {
    left: "-9999px",
    top: "-9999px"
  };
}
function Y8e(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n);
  if (r) {
    var {
      x: o,
      y: i
    } = r;
    return {
      left: "".concat(o + t.x, "px"),
      top: "".concat(i + t.y, "px")
    };
  }
  return {
    left: "-9999px",
    top: "-9999px"
  };
}
function SJ(e, t, n, r) {
  return n !== void 0 ? K8e(e, t, G8e(n, google.maps.LatLngBounds, Z8e)) : Y8e(e, t, q8e(r, google.maps.LatLng, V8e));
}
function X8e(e, t) {
  return e.left === t.left && e.top === t.top && e.width === t.height && e.height === t.height;
}
function h6(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function J8e(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? h6(Object(n), !0).forEach(function(r) {
      ye(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : h6(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function Q8e(e, t, n, r, o) {
  class i extends google.maps.OverlayView {
    constructor(s, l, u, c) {
      super(), this.container = s, this.pane = l, this.position = u, this.bounds = c;
    }
    onAdd() {
      var s, l = (s = this.getPanes()) === null || s === void 0 ? void 0 : s[this.pane];
      l == null || l.appendChild(this.container);
    }
    draw() {
      var s = this.getProjection(), l = J8e({}, this.container ? _J(this.container, o) : {
        x: 0,
        y: 0
      }), u = SJ(s, l, this.bounds, this.position);
      for (var [c, p] of Object.entries(u))
        this.container.style[c] = p;
    }
    onRemove() {
      this.container.parentNode !== null && this.container.parentNode.removeChild(this.container);
    }
  }
  return new i(e, t, n, r);
}
function g6(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function e5e(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? g6(Object(n), !0).forEach(function(r) {
      ye(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : g6(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function m6(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLng ? e : new google.maps.LatLng(e.lat, e.lng);
  return t + "";
}
function v6(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLngBounds ? e : new google.maps.LatLngBounds(new google.maps.LatLng(e.south, e.east), new google.maps.LatLng(e.north, e.west));
  return t + "";
}
function t5e(e) {
  var {
    position: t,
    bounds: n,
    mapPaneName: r,
    zIndex: o,
    onLoad: i,
    onUnmount: a,
    getPixelPositionOffset: s,
    children: l
  } = e, u = ge(Dt), c = Cn(() => {
    var d = document.createElement("div");
    return d.style.position = "absolute", d;
  }, []), p = Cn(() => Q8e(c, r, t, n, s), [c, r, t, n]);
  return h(() => (i == null || i(p), p == null || p.setMap(u), () => {
    a == null || a(p), p == null || p.setMap(null);
  }), [u, p]), h(() => {
    c.style.zIndex = "".concat(o);
  }, [o, c]), wi.createPortal(l, c);
}
ve(t5e);
class Uc extends pe {
  constructor(t) {
    super(t), ye(this, "state", {
      paneEl: null,
      containerStyle: {
        // set initial position
        position: "absolute"
      }
    }), ye(this, "updatePane", () => {
      var r = this.props.mapPaneName, o = this.overlayView.getPanes();
      Eo(!!r, "OverlayView requires props.mapPaneName but got %s", r), o ? this.setState({
        paneEl: o[r]
      }) : this.setState({
        paneEl: null
      });
    }), ye(this, "onAdd", () => {
      var r, o;
      this.updatePane(), (r = (o = this.props).onLoad) === null || r === void 0 || r.call(o, this.overlayView);
    }), ye(this, "onPositionElement", () => {
      var r = this.overlayView.getProjection(), o = e5e({
        x: 0,
        y: 0
      }, this.containerRef.current ? _J(this.containerRef.current, this.props.getPixelPositionOffset) : {}), i = SJ(r, o, this.props.bounds, this.props.position);
      if (!X8e(i, {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        left: this.state.containerStyle.left,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        top: this.state.containerStyle.top,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        width: this.state.containerStyle.width,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        height: this.state.containerStyle.height
      })) {
        var a, s, l, u;
        this.setState({
          containerStyle: {
            top: (a = i.top) !== null && a !== void 0 ? a : 0,
            left: (s = i.left) !== null && s !== void 0 ? s : 0,
            width: (l = i.width) !== null && l !== void 0 ? l : 0,
            height: (u = i.height) !== null && u !== void 0 ? u : 0,
            position: "absolute"
          }
        });
      }
    }), ye(this, "draw", () => {
      this.onPositionElement();
    }), ye(this, "onRemove", () => {
      var r, o;
      this.setState(() => ({
        paneEl: null
      })), (r = (o = this.props).onUnmount) === null || r === void 0 || r.call(o, this.overlayView);
    }), this.containerRef = mo();
    var n = new google.maps.OverlayView();
    n.onAdd = this.onAdd, n.draw = this.draw, n.onRemove = this.onRemove, this.overlayView = n;
  }
  componentDidMount() {
    this.overlayView.setMap(this.context);
  }
  componentDidUpdate(t) {
    var n = m6(t.position), r = m6(this.props.position), o = v6(t.bounds), i = v6(this.props.bounds);
    (n !== r || o !== i) && this.overlayView.draw(), t.mapPaneName !== this.props.mapPaneName && this.updatePane();
  }
  componentWillUnmount() {
    this.overlayView.setMap(null);
  }
  render() {
    var t = this.state.paneEl;
    return t ? wi.createPortal(Q.jsx("div", {
      ref: this.containerRef,
      style: this.state.containerStyle,
      children: lt.only(this.props.children)
    }), t) : null;
  }
}
ye(Uc, "FLOAT_PANE", "floatPane");
ye(Uc, "MAP_PANE", "mapPane");
ye(Uc, "MARKER_LAYER", "markerLayer");
ye(Uc, "OVERLAY_LAYER", "overlayLayer");
ye(Uc, "OVERLAY_MOUSE_TARGET", "overlayMouseTarget");
ye(Uc, "contextType", Dt);
function n5e() {
}
function y6(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function b6(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? y6(Object(n), !0).forEach(function(r) {
      ye(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : y6(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var w6 = {
  onDblClick: "dblclick",
  onClick: "click"
}, C6 = {
  opacity(e, t) {
    e.setOpacity(t);
  }
};
function r5e(e) {
  var {
    url: t,
    bounds: n,
    options: r,
    visible: o
  } = e, i = ge(Dt), a = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east)), s = Cn(() => new google.maps.GroundOverlay(t, a, r), []);
  return h(() => {
    s !== null && s.setMap(i);
  }, [i]), h(() => {
    typeof t < "u" && s !== null && (s.set("url", t), s.setMap(i));
  }, [s, t]), h(() => {
    typeof o < "u" && s !== null && s.setOpacity(o ? 1 : 0);
  }, [s, o]), h(() => {
    var l = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east));
    typeof n < "u" && s !== null && (s.set("bounds", l), s.setMap(i));
  }, [s, n]), null;
}
ve(r5e);
class MJ extends pe {
  constructor() {
    super(...arguments), ye(this, "registeredEvents", []), ye(this, "state", {
      groundOverlay: null
    }), ye(this, "setGroundOverlayCallback", () => {
      this.state.groundOverlay !== null && this.props.onLoad && this.props.onLoad(this.state.groundOverlay);
    });
  }
  componentDidMount() {
    Eo(!!this.props.url || !!this.props.bounds, "For GroundOverlay, url and bounds are passed in to constructor and are immutable after instantiated. This is the behavior of Google Maps JavaScript API v3 ( See https://developers.google.com/maps/documentation/javascript/reference#GroundOverlay) Hence, use the corresponding two props provided by `react-google-maps-api`, url and bounds. In some cases, you'll need the GroundOverlay component to reflect the changes of url and bounds. You can leverage the React's key property to remount the component. Typically, just `key={url}` would serve your need. See https://github.com/tomchentw/react-google-maps/issues/655");
    var t = new google.maps.GroundOverlay(this.props.url, this.props.bounds, b6(b6({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Vt({
      updaterMap: C6,
      eventMap: w6,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        groundOverlay: t
      };
    }, this.setGroundOverlayCallback);
  }
  componentDidUpdate(t) {
    this.state.groundOverlay !== null && (Qt(this.registeredEvents), this.registeredEvents = Vt({
      updaterMap: C6,
      eventMap: w6,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.groundOverlay
    }));
  }
  componentWillUnmount() {
    this.state.groundOverlay && (this.props.onUnmount && this.props.onUnmount(this.state.groundOverlay), this.state.groundOverlay.setMap(null));
  }
  render() {
    return null;
  }
}
ye(MJ, "defaultProps", {
  onLoad: n5e
});
ye(MJ, "contextType", Dt);
function x6(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Wy(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? x6(Object(n), !0).forEach(function(r) {
      ye(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : x6(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var O6 = {}, E6 = {
  data(e, t) {
    e.setData(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function o5e(e) {
  var {
    data: t,
    onLoad: n,
    onUnmount: r,
    options: o
  } = e, i = ge(Dt), [a, s] = k(null);
  return h(() => {
    google.maps.visualization || Eo(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} in useJsApiScript? %s', google.maps.visualization);
  }, []), h(() => {
    Eo(!!t, "data property is required in HeatmapLayer %s", t);
  }, [t]), h(() => {
    a !== null && a.setMap(i);
  }, [i]), h(() => {
    o && a !== null && a.setOptions(o);
  }, [a, o]), h(() => {
    var l = new google.maps.visualization.HeatmapLayer(Wy(Wy({}, o), {}, {
      data: t,
      map: i
    }));
    return s(l), n && n(l), () => {
      a !== null && (r && r(a), a.setMap(null));
    };
  }, []), null;
}
ve(o5e);
class i5e extends pe {
  constructor() {
    super(...arguments), ye(this, "registeredEvents", []), ye(this, "state", {
      heatmapLayer: null
    }), ye(this, "setHeatmapLayerCallback", () => {
      this.state.heatmapLayer !== null && this.props.onLoad && this.props.onLoad(this.state.heatmapLayer);
    });
  }
  componentDidMount() {
    Eo(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} to <LoadScript />? %s', google.maps.visualization), Eo(!!this.props.data, "data property is required in HeatmapLayer %s", this.props.data);
    var t = new google.maps.visualization.HeatmapLayer(Wy(Wy({}, this.props.options), {}, {
      data: this.props.data,
      map: this.context
    }));
    this.registeredEvents = Vt({
      updaterMap: E6,
      eventMap: O6,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        heatmapLayer: t
      };
    }, this.setHeatmapLayerCallback);
  }
  componentDidUpdate(t) {
    Qt(this.registeredEvents), this.registeredEvents = Vt({
      updaterMap: E6,
      eventMap: O6,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.heatmapLayer
    });
  }
  componentWillUnmount() {
    this.state.heatmapLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.heatmapLayer), Qt(this.registeredEvents), this.state.heatmapLayer.setMap(null));
  }
  render() {
    return null;
  }
}
ye(i5e, "contextType", Dt);
var k6 = {
  onCloseClick: "closeclick",
  onPanoChanged: "pano_changed",
  onPositionChanged: "position_changed",
  onPovChanged: "pov_changed",
  onResize: "resize",
  onStatusChanged: "status_changed",
  onVisibleChanged: "visible_changed",
  onZoomChanged: "zoom_changed"
}, L6 = {
  register(e, t, n) {
    e.registerPanoProvider(t, n);
  },
  links(e, t) {
    e.setLinks(t);
  },
  motionTracking(e, t) {
    e.setMotionTracking(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  pano(e, t) {
    e.setPano(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  pov(e, t) {
    e.setPov(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zoom(e, t) {
    e.setZoom(t);
  }
};
class s5e extends pe {
  constructor() {
    super(...arguments), ye(this, "registeredEvents", []), ye(this, "state", {
      streetViewPanorama: null
    }), ye(this, "setStreetViewPanoramaCallback", () => {
      this.state.streetViewPanorama !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewPanorama);
    });
  }
  componentDidMount() {
    var t, n, r = (t = (n = this.context) === null || n === void 0 ? void 0 : n.getStreetView()) !== null && t !== void 0 ? t : null;
    this.registeredEvents = Vt({
      updaterMap: L6,
      eventMap: k6,
      prevProps: {},
      nextProps: this.props,
      instance: r
    }), this.setState(() => ({
      streetViewPanorama: r
    }), this.setStreetViewPanoramaCallback);
  }
  componentDidUpdate(t) {
    this.state.streetViewPanorama !== null && (Qt(this.registeredEvents), this.registeredEvents = Vt({
      updaterMap: L6,
      eventMap: k6,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.streetViewPanorama
    }));
  }
  componentWillUnmount() {
    this.state.streetViewPanorama !== null && (this.props.onUnmount && this.props.onUnmount(this.state.streetViewPanorama), Qt(this.registeredEvents), this.state.streetViewPanorama.setVisible(!1));
  }
  render() {
    return null;
  }
}
ye(s5e, "contextType", Dt);
class a5e extends pe {
  constructor() {
    super(...arguments), ye(this, "state", {
      streetViewService: null
    }), ye(this, "setStreetViewServiceCallback", () => {
      this.state.streetViewService !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewService);
    });
  }
  componentDidMount() {
    var t = new google.maps.StreetViewService();
    this.setState(function() {
      return {
        streetViewService: t
      };
    }, this.setStreetViewServiceCallback);
  }
  componentWillUnmount() {
    this.state.streetViewService !== null && this.props.onUnmount && this.props.onUnmount(this.state.streetViewService);
  }
  render() {
    return null;
  }
}
ye(a5e, "contextType", Dt);
var P6 = {
  onDirectionsChanged: "directions_changed"
}, _6 = {
  directions(e, t) {
    e.setDirections(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  panel(e, t) {
    e.setPanel(t);
  },
  routeIndex(e, t) {
    e.setRouteIndex(t);
  }
};
class l5e extends pe {
  constructor() {
    super(...arguments), ye(this, "registeredEvents", []), ye(this, "state", {
      directionsRenderer: null
    }), ye(this, "setDirectionsRendererCallback", () => {
      this.state.directionsRenderer !== null && (this.state.directionsRenderer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.directionsRenderer));
    });
  }
  componentDidMount() {
    var t = new google.maps.DirectionsRenderer(this.props.options);
    this.registeredEvents = Vt({
      updaterMap: _6,
      eventMap: P6,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        directionsRenderer: t
      };
    }, this.setDirectionsRendererCallback);
  }
  componentDidUpdate(t) {
    this.state.directionsRenderer !== null && (Qt(this.registeredEvents), this.registeredEvents = Vt({
      updaterMap: _6,
      eventMap: P6,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.directionsRenderer
    }));
  }
  componentWillUnmount() {
    this.state.directionsRenderer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.directionsRenderer), Qt(this.registeredEvents), this.state.directionsRenderer && this.state.directionsRenderer.setMap(null));
  }
  render() {
    return null;
  }
}
ye(l5e, "contextType", Dt);
var S6 = {
  onPlacesChanged: "places_changed"
}, M6 = {
  bounds(e, t) {
    e.setBounds(t);
  }
};
class DJ extends pe {
  constructor() {
    super(...arguments), ye(this, "registeredEvents", []), ye(this, "containerElement", mo()), ye(this, "state", {
      searchBox: null
    }), ye(this, "setSearchBoxCallback", () => {
      this.state.searchBox !== null && this.props.onLoad && this.props.onLoad(this.state.searchBox);
    });
  }
  componentDidMount() {
    if (Eo(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places), this.containerElement !== null && this.containerElement.current !== null) {
      var t = this.containerElement.current.querySelector("input");
      if (t !== null) {
        var n = new google.maps.places.SearchBox(t, this.props.options);
        this.registeredEvents = Vt({
          updaterMap: M6,
          eventMap: S6,
          prevProps: {},
          nextProps: this.props,
          instance: n
        }), this.setState(function() {
          return {
            searchBox: n
          };
        }, this.setSearchBoxCallback);
      }
    }
  }
  componentDidUpdate(t) {
    this.state.searchBox !== null && (Qt(this.registeredEvents), this.registeredEvents = Vt({
      updaterMap: M6,
      eventMap: S6,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.searchBox
    }));
  }
  componentWillUnmount() {
    this.state.searchBox !== null && (this.props.onUnmount && this.props.onUnmount(this.state.searchBox), Qt(this.registeredEvents));
  }
  render() {
    return Q.jsx("div", {
      ref: this.containerElement,
      children: lt.only(this.props.children)
    });
  }
}
ye(DJ, "contextType", Dt);
var D6 = {
  onPlaceChanged: "place_changed"
}, T6 = {
  bounds(e, t) {
    e.setBounds(t);
  },
  restrictions(e, t) {
    e.setComponentRestrictions(t);
  },
  fields(e, t) {
    e.setFields(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  types(e, t) {
    e.setTypes(t);
  }
};
class TJ extends pe {
  constructor() {
    super(...arguments), ye(this, "registeredEvents", []), ye(this, "containerElement", mo()), ye(this, "state", {
      autocomplete: null
    }), ye(this, "setAutocompleteCallback", () => {
      this.state.autocomplete !== null && this.props.onLoad && this.props.onLoad(this.state.autocomplete);
    });
  }
  componentDidMount() {
    var t;
    Eo(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places);
    var n = (t = this.containerElement.current) === null || t === void 0 ? void 0 : t.querySelector("input");
    if (n) {
      var r = new google.maps.places.Autocomplete(n, this.props.options);
      this.registeredEvents = Vt({
        updaterMap: T6,
        eventMap: D6,
        prevProps: {},
        nextProps: this.props,
        instance: r
      }), this.setState(() => ({
        autocomplete: r
      }), this.setAutocompleteCallback);
    }
  }
  componentDidUpdate(t) {
    Qt(this.registeredEvents), this.registeredEvents = Vt({
      updaterMap: T6,
      eventMap: D6,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.autocomplete
    });
  }
  componentWillUnmount() {
    this.state.autocomplete !== null && Qt(this.registeredEvents);
  }
  render() {
    return Q.jsx("div", {
      ref: this.containerElement,
      className: this.props.className,
      children: lt.only(this.props.children)
    });
  }
}
ye(TJ, "defaultProps", {
  className: ""
});
ye(TJ, "contextType", Dt);
function Y4e({
  googleMapsApiKey: e,
  children: t,
  ...n
}) {
  return /* @__PURE__ */ Q.jsx(
    CJ,
    {
      libraries: ["places", "marker", "maps"],
      googleMapsApiKey: e,
      ...n,
      children: t
    }
  );
}
function X4e(e) {
  const { children: t = !1 } = e, [n, r] = k([]);
  function o(u) {
    return !!n.some((c) => c.key === u);
  }
  function i(u) {
    var c;
    return (c = n.find((p) => p.key === u)) == null ? void 0 : c.data;
  }
  function a(u, c) {
    const p = o(u);
    r(p ? (d) => [...d.filter((f) => f.key !== u), { key: u, data: c }] : [...n, { key: u, data: c }]);
  }
  function s(u) {
    r(n.filter((c) => c.key !== u));
  }
  function l() {
    r([]);
  }
  return /* @__PURE__ */ Q.jsx(
    IS.Provider,
    {
      value: { modalIsOpen: o, modalData: i, openModal: a, closeModal: s, closeAll: l },
      children: t
    }
  );
}
let u5e = { data: "" }, c5e = (e) => typeof window == "object" ? ((e ? e.querySelector("#_goober") : window._goober) || Object.assign((e || document.head).appendChild(document.createElement("style")), { innerHTML: " ", id: "_goober" })).firstChild : e || u5e, p5e = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g, d5e = /\/\*[^]*?\*\/|  +/g, j6 = /\n+/g, il = (e, t) => {
  let n = "", r = "", o = "";
  for (let i in e) {
    let a = e[i];
    i[0] == "@" ? i[1] == "i" ? n = i + " " + a + ";" : r += i[1] == "f" ? il(a, i) : i + "{" + il(a, i[1] == "k" ? "" : t) + "}" : typeof a == "object" ? r += il(a, t ? t.replace(/([^,])+/g, (s) => i.replace(/([^,]*:\S+\([^)]*\))|([^,])+/g, (l) => /&/.test(l) ? l.replace(/&/g, s) : s ? s + " " + l : l)) : i) : a != null && (i = /^--/.test(i) ? i : i.replace(/[A-Z]/g, "-$&").toLowerCase(), o += il.p ? il.p(i, a) : i + ":" + a + ";");
  }
  return n + (t && o ? t + "{" + o + "}" : o) + r;
}, Qs = {}, jJ = (e) => {
  if (typeof e == "object") {
    let t = "";
    for (let n in e) t += n + jJ(e[n]);
    return t;
  }
  return e;
}, f5e = (e, t, n, r, o) => {
  let i = jJ(e), a = Qs[i] || (Qs[i] = ((l) => {
    let u = 0, c = 11;
    for (; u < l.length; ) c = 101 * c + l.charCodeAt(u++) >>> 0;
    return "go" + c;
  })(i));
  if (!Qs[a]) {
    let l = i !== e ? e : ((u) => {
      let c, p, d = [{}];
      for (; c = p5e.exec(u.replace(d5e, "")); ) c[4] ? d.shift() : c[3] ? (p = c[3].replace(j6, " ").trim(), d.unshift(d[0][p] = d[0][p] || {})) : d[0][c[1]] = c[2].replace(j6, " ").trim();
      return d[0];
    })(e);
    Qs[a] = il(o ? { ["@keyframes " + a]: l } : l, n ? "" : "." + a);
  }
  let s = n && Qs.g ? Qs.g : null;
  return n && (Qs.g = Qs[a]), ((l, u, c, p) => {
    p ? u.data = u.data.replace(p, l) : u.data.indexOf(l) === -1 && (u.data = c ? l + u.data : u.data + l);
  })(Qs[a], t, r, s), a;
}, h5e = (e, t, n) => e.reduce((r, o, i) => {
  let a = t[i];
  if (a && a.call) {
    let s = a(n), l = s && s.props && s.props.className || /^go/.test(s) && s;
    a = l ? "." + l : s && typeof s == "object" ? s.props ? "" : il(s, "") : s === !1 ? "" : s;
  }
  return r + o + (a ?? "");
}, "");
function _0(e) {
  let t = this || {}, n = e.call ? e(t.p) : e;
  return f5e(n.unshift ? n.raw ? h5e(n, [].slice.call(arguments, 1), t.p) : n.reduce((r, o) => Object.assign(r, o && o.call ? o(t.p) : o), {}) : n, c5e(t.target), t.g, t.o, t.k);
}
let AJ, w1, C1;
_0.bind({ g: 1 });
let ha = _0.bind({ k: 1 });
function g5e(e, t, n, r) {
  il.p = t, AJ = e, w1 = n, C1 = r;
}
function jl(e, t) {
  let n = this || {};
  return function() {
    let r = arguments;
    function o(i, a) {
      let s = Object.assign({}, i), l = s.className || o.className;
      n.p = Object.assign({ theme: w1 && w1() }, s), n.o = / *go\d+/.test(l), s.className = _0.apply(n, r) + (l ? " " + l : "");
      let u = e;
      return e[0] && (u = s.as || e, delete s.as), C1 && u[0] && C1(s), AJ(u, s);
    }
    return o;
  };
}
var m5e = (e) => typeof e == "function", Vy = (e, t) => m5e(e) ? e(t) : e, v5e = /* @__PURE__ */ (() => {
  let e = 0;
  return () => (++e).toString();
})(), IJ = /* @__PURE__ */ (() => {
  let e;
  return () => {
    if (e === void 0 && typeof window < "u") {
      let t = matchMedia("(prefers-reduced-motion: reduce)");
      e = !t || t.matches;
    }
    return e;
  };
})(), y5e = 20, RJ = (e, t) => {
  switch (t.type) {
    case 0:
      return { ...e, toasts: [t.toast, ...e.toasts].slice(0, y5e) };
    case 1:
      return { ...e, toasts: e.toasts.map((i) => i.id === t.toast.id ? { ...i, ...t.toast } : i) };
    case 2:
      let { toast: n } = t;
      return RJ(e, { type: e.toasts.find((i) => i.id === n.id) ? 1 : 0, toast: n });
    case 3:
      let { toastId: r } = t;
      return { ...e, toasts: e.toasts.map((i) => i.id === r || r === void 0 ? { ...i, dismissed: !0, visible: !1 } : i) };
    case 4:
      return t.toastId === void 0 ? { ...e, toasts: [] } : { ...e, toasts: e.toasts.filter((i) => i.id !== t.toastId) };
    case 5:
      return { ...e, pausedAt: t.time };
    case 6:
      let o = t.time - (e.pausedAt || 0);
      return { ...e, pausedAt: void 0, toasts: e.toasts.map((i) => ({ ...i, pauseDuration: i.pauseDuration + o })) };
  }
}, Nm = [], bu = { toasts: [], pausedAt: void 0 }, Ju = (e) => {
  bu = RJ(bu, e), Nm.forEach((t) => {
    t(bu);
  });
}, b5e = { blank: 4e3, error: 4e3, success: 2e3, loading: 1 / 0, custom: 4e3 }, w5e = (e = {}) => {
  let [t, n] = k(bu), r = ut(bu);
  h(() => (r.current !== bu && n(bu), Nm.push(n), () => {
    let i = Nm.indexOf(n);
    i > -1 && Nm.splice(i, 1);
  }), []);
  let o = t.toasts.map((i) => {
    var a, s, l;
    return { ...e, ...e[i.type], ...i, removeDelay: i.removeDelay || ((a = e[i.type]) == null ? void 0 : a.removeDelay) || (e == null ? void 0 : e.removeDelay), duration: i.duration || ((s = e[i.type]) == null ? void 0 : s.duration) || (e == null ? void 0 : e.duration) || b5e[i.type], style: { ...e.style, ...(l = e[i.type]) == null ? void 0 : l.style, ...i.style } };
  });
  return { ...t, toasts: o };
}, C5e = (e, t = "blank", n) => ({ createdAt: Date.now(), visible: !0, dismissed: !1, type: t, ariaProps: { role: "status", "aria-live": "polite" }, message: e, pauseDuration: 0, ...n, id: (n == null ? void 0 : n.id) || v5e() }), dh = (e) => (t, n) => {
  let r = C5e(t, e, n);
  return Ju({ type: 2, toast: r }), r.id;
}, Zo = (e, t) => dh("blank")(e, t);
Zo.error = dh("error");
Zo.success = dh("success");
Zo.loading = dh("loading");
Zo.custom = dh("custom");
Zo.dismiss = (e) => {
  Ju({ type: 3, toastId: e });
};
Zo.remove = (e) => Ju({ type: 4, toastId: e });
Zo.promise = (e, t, n) => {
  let r = Zo.loading(t.loading, { ...n, ...n == null ? void 0 : n.loading });
  return typeof e == "function" && (e = e()), e.then((o) => {
    let i = t.success ? Vy(t.success, o) : void 0;
    return i ? Zo.success(i, { id: r, ...n, ...n == null ? void 0 : n.success }) : Zo.dismiss(r), o;
  }).catch((o) => {
    let i = t.error ? Vy(t.error, o) : void 0;
    i ? Zo.error(i, { id: r, ...n, ...n == null ? void 0 : n.error }) : Zo.dismiss(r);
  }), e;
};
var x5e = (e, t) => {
  Ju({ type: 1, toast: { id: e, height: t } });
}, O5e = () => {
  Ju({ type: 5, time: Date.now() });
}, md = /* @__PURE__ */ new Map(), E5e = 1e3, k5e = (e, t = E5e) => {
  if (md.has(e)) return;
  let n = setTimeout(() => {
    md.delete(e), Ju({ type: 4, toastId: e });
  }, t);
  md.set(e, n);
}, L5e = (e) => {
  let { toasts: t, pausedAt: n } = w5e(e);
  h(() => {
    if (n) return;
    let i = Date.now(), a = t.map((s) => {
      if (s.duration === 1 / 0) return;
      let l = (s.duration || 0) + s.pauseDuration - (i - s.createdAt);
      if (l < 0) {
        s.visible && Zo.dismiss(s.id);
        return;
      }
      return setTimeout(() => Zo.dismiss(s.id), l);
    });
    return () => {
      a.forEach((s) => s && clearTimeout(s));
    };
  }, [t, n]);
  let r = Nn(() => {
    n && Ju({ type: 6, time: Date.now() });
  }, [n]), o = Nn((i, a) => {
    let { reverseOrder: s = !1, gutter: l = 8, defaultPosition: u } = a || {}, c = t.filter((g) => (g.position || u) === (i.position || u) && g.height), p = c.findIndex((g) => g.id === i.id), d = c.filter((g, f) => f < p && g.visible).length;
    return c.filter((g) => g.visible).slice(...s ? [d + 1] : [0, d]).reduce((g, f) => g + (f.height || 0) + l, 0);
  }, [t]);
  return h(() => {
    t.forEach((i) => {
      if (i.dismissed) k5e(i.id, i.removeDelay);
      else {
        let a = md.get(i.id);
        a && (clearTimeout(a), md.delete(i.id));
      }
    });
  }, [t]), { toasts: t, handlers: { updateHeight: x5e, startPause: O5e, endPause: r, calculateOffset: o } };
}, P5e = ha`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`, _5e = ha`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`, S5e = ha`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`, M5e = jl("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${P5e} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${_5e} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${(e) => e.secondary || "#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${S5e} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`, D5e = ha`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, T5e = jl("div")`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${(e) => e.secondary || "#e0e0e0"};
  border-right-color: ${(e) => e.primary || "#616161"};
  animation: ${D5e} 1s linear infinite;
`, j5e = ha`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`, A5e = ha`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`, I5e = jl("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${j5e} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${A5e} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${(e) => e.secondary || "#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`, R5e = jl("div")`
  position: absolute;
`, B5e = jl("div")`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`, N5e = ha`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`, F5e = jl("div")`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${N5e} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`, z5e = ({ toast: e }) => {
  let { icon: t, type: n, iconTheme: r } = e;
  return t !== void 0 ? typeof t == "string" ? Be.createElement(F5e, null, t) : t : n === "blank" ? null : Be.createElement(B5e, null, Be.createElement(T5e, { ...r }), n !== "loading" && Be.createElement(R5e, null, n === "error" ? Be.createElement(M5e, { ...r }) : Be.createElement(I5e, { ...r })));
}, U5e = (e) => `
0% {transform: translate3d(0,${e * -200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`, H5e = (e) => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${e * -150}%,-1px) scale(.6); opacity:0;}
`, $5e = "0%{opacity:0;} 100%{opacity:1;}", W5e = "0%{opacity:1;} 100%{opacity:0;}", V5e = jl("div")`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`, Z5e = jl("div")`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`, q5e = (e, t) => {
  let n = e.includes("top") ? 1 : -1, [r, o] = IJ() ? [$5e, W5e] : [U5e(n), H5e(n)];
  return { animation: t ? `${ha(r)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards` : `${ha(o)} 0.4s forwards cubic-bezier(.06,.71,.55,1)` };
}, G5e = Be.memo(({ toast: e, position: t, style: n, children: r }) => {
  let o = e.height ? q5e(e.position || t || "top-center", e.visible) : { opacity: 0 }, i = Be.createElement(z5e, { toast: e }), a = Be.createElement(Z5e, { ...e.ariaProps }, Vy(e.message, e));
  return Be.createElement(V5e, { className: e.className, style: { ...o, ...n, ...e.style } }, typeof r == "function" ? r({ icon: i, message: a }) : Be.createElement(Be.Fragment, null, i, a));
});
g5e(Be.createElement);
var K5e = ({ id: e, className: t, style: n, onHeightUpdate: r, children: o }) => {
  let i = Be.useCallback((a) => {
    if (a) {
      let s = () => {
        let l = a.getBoundingClientRect().height;
        r(e, l);
      };
      s(), new MutationObserver(s).observe(a, { subtree: !0, childList: !0, characterData: !0 });
    }
  }, [e, r]);
  return Be.createElement("div", { ref: i, className: t, style: n }, o);
}, Y5e = (e, t) => {
  let n = e.includes("top"), r = n ? { top: 0 } : { bottom: 0 }, o = e.includes("center") ? { justifyContent: "center" } : e.includes("right") ? { justifyContent: "flex-end" } : {};
  return { left: 0, right: 0, display: "flex", position: "absolute", transition: IJ() ? void 0 : "all 230ms cubic-bezier(.21,1.02,.73,1)", transform: `translateY(${t * (n ? 1 : -1)}px)`, ...r, ...o };
}, X5e = _0`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`, km = 16, J5e = ({ reverseOrder: e, position: t = "top-center", toastOptions: n, gutter: r, children: o, containerStyle: i, containerClassName: a }) => {
  let { toasts: s, handlers: l } = L5e(n);
  return Be.createElement("div", { id: "_rht_toaster", style: { position: "fixed", zIndex: 9999, top: km, left: km, right: km, bottom: km, pointerEvents: "none", ...i }, className: a, onMouseEnter: l.startPause, onMouseLeave: l.endPause }, s.map((u) => {
    let c = u.position || t, p = l.calculateOffset(u, { reverseOrder: e, gutter: r, defaultPosition: t }), d = Y5e(c, p);
    return Be.createElement(K5e, { id: u.id, key: u.id, onHeightUpdate: l.updateHeight, className: u.visible ? X5e : "", style: d }, u.type === "custom" ? Vy(u.message, u) : o ? o(u) : Be.createElement(G5e, { toast: u, position: c }));
  }));
}, A6 = Zo;
function J4e({ children: e }) {
  function t(n) {
    switch (n.type) {
      case "success":
        return A6.success(n.message, {
          style: {
            background: "#10B981",
            color: "#ffffff",
            padding: "12px 16px",
            fontSize: "14px",
            fontWeight: 600
          },
          iconTheme: {
            primary: "#059669",
            secondary: "#ffffff"
          }
        });
      case "danger":
        return A6.error(n.message, {
          style: {
            background: "#E11D48",
            color: "#ffffff",
            padding: "12px 16px",
            fontSize: "14px",
            fontWeight: 600
          },
          iconTheme: {
            primary: "#BE123C",
            secondary: "#ffffff"
          }
        });
    }
  }
  return /* @__PURE__ */ Q.jsxs(fJ.Provider, { value: { showToast: t }, children: [
    /* @__PURE__ */ Q.jsx(
      J5e,
      {
        position: "top-right",
        containerStyle: { zIndex: 999999999999999 }
      }
    ),
    e
  ] });
}
function BJ({ children: e, fallback: t = null }) {
  return x6e() ? /* @__PURE__ */ Q.jsx(Q.Fragment, { children: e() }) : /* @__PURE__ */ Q.jsx(Q.Fragment, { children: t });
}
let Q5e = class {
  constructor(t, n) {
    fh(this, "pixelId");
    fh(this, "autoConfig");
    fh(this, "initialized");
    this.pixelId = t, this.autoConfig = (n == null ? void 0 : n.autoConfig) || !0, this.initialized = !1;
  }
  loadFacebookPixel() {
    if (window.fbq) return;
    const t = function(...o) {
      t.callMethod ? t.callMethod.apply(t, o) : t.queue.push(o);
    };
    window._fbq || (window._fbq = t), t.push = t, t.loaded = !0, t.version = "2.0", t.queue = [];
    const n = document.createElement("script");
    n.async = !0, n.src = "https://connect.facebook.net/en_US/fbevents.js";
    const r = document.getElementsByTagName("script")[0];
    if (!r.parentNode)
      throw new Error("No script tag found in the document");
    r.parentNode.insertBefore(n, r), window.fbq = t;
  }
  init(t = {}) {
    if (this.initialized = typeof window < "u" && !!window.fbq, this.loadFacebookPixel(), !window.fbq)
      throw new Error("window.fbq is not defined");
    this.autoConfig === !1 ? window.fbq("set", "autoConfig", !1, this.pixelId) : window.fbq("init", this.pixelId, t), this.initialized = !0;
  }
  pageView() {
    this.initialized && window.fbq && window.fbq("track", "PageView");
  }
  track(t, n) {
    this.initialized && window.fbq && window.fbq("track", t, n);
  }
  trackSingle(t, n, r) {
    this.initialized && window.fbq && window.fbq("trackSingle", t, n, r);
  }
  trackCustom(t, n) {
    this.initialized && window.fbq && window.fbq("trackCustom", t, n);
  }
  trackSingleCustom(t, n, r) {
    this.initialized && window.fbq && window.fbq("trackSingle", t, n, r);
  }
  grantConsent() {
    this.initialized && window.fbq && window.fbq("consent", "grant");
  }
  revokeConsent() {
    this.initialized && window.fbq && window.fbq("consent", "revoke");
  }
};
function e4e(e) {
  const {
    pixelId: t,
    options: n,
    pageView: r,
    track: o,
    trackCustom: i,
    trackSingle: a,
    trackSingleCustom: s,
    grantConsent: l,
    revokeConsent: u
  } = e, c = new Q5e(t, n);
  return c.init(), r && c.pageView(), l && c.grantConsent(), u && c.revokeConsent(), o && c.track(...o), i && c.trackCustom(...i), a && c.trackSingle(t, ...a), s && c.trackSingleCustom(t, ...s), /* @__PURE__ */ Q.jsx(Q.Fragment, {});
}
function e7e(e) {
  return process.env.NODE_ENV !== "production" && !e.showInDevMode ? /* @__PURE__ */ Q.jsx(Q.Fragment, {}) : /* @__PURE__ */ Q.jsx(BJ, { children: () => /* @__PURE__ */ Q.jsx(e4e, { ...e }) });
}
function t7e({
  coordinates: e,
  zoom: t = 18,
  draggable: n = !1,
  className: r,
  ...o
}) {
  return e ? /* @__PURE__ */ Q.jsx("div", { className: "arkynGoogleMapPinned " + r, ...o, children: /* @__PURE__ */ Q.jsx(
    A6e,
    {
      zoom: t,
      center: e,
      mapContainerStyle: {
        borderRadius: "var(--rounded-cards)",
        width: "100%",
        height: "100%"
      },
      children: /* @__PURE__ */ Q.jsx(xJ, { draggable: n, position: e })
    }
  ) }) : /* @__PURE__ */ Q.jsx("div", { className: "arkynGoogleMapPinnedEmpty " + r, ...o, children: /* @__PURE__ */ Q.jsx(pQ, {}) });
}
function n7e({
  onChange: e,
  onPlaceChanged: t,
  options: n,
  ...r
}) {
  const [o, i] = k(null), a = (l) => i(l), s = () => {
    var g, f, m, v;
    const u = o.getPlaces()[0], c = u == null ? void 0 : u.address_components;
    function p(E) {
      const w = c.find((M) => M.types[0] === E);
      return w ? w.long_name : "";
    }
    function d(E) {
      const w = c.find((M) => M.types[0] === E);
      return w ? w.short_name : "";
    }
    if (u) {
      const E = p("route"), w = p("street_number"), M = p("sublocality_level_1"), O = p("administrative_area_level_2"), y = p("administrative_area_level_1"), C = d("administrative_area_level_1"), _ = p("postal_code"), F = (f = (g = u.geometry) == null ? void 0 : g.location) == null ? void 0 : f.lat(), L = (v = (m = u.geometry) == null ? void 0 : m.location) == null ? void 0 : v.lng();
      t && t({
        street: E,
        city: O,
        state: y,
        district: M,
        cep: _,
        streetNumber: w,
        stateShortName: C,
        coordinates: { lat: F, lng: L }
      });
    }
  };
  return /* @__PURE__ */ Q.jsx(
    DJ,
    {
      onLoad: a,
      onPlacesChanged: s,
      options: n,
      children: /* @__PURE__ */ Q.jsx(v0, { type: "text", onChange: (l) => e(l.target.value), ...r })
    }
  );
}
function NJ(e) {
  const { dataLayer: t, dataLayerName: n } = e;
  return `
  window.${n} = window.${n} || [];
  window.${n}.push(${JSON.stringify(t)})`;
}
function t4e(e) {
  const { id: t, events: n, dataLayer: r, dataLayerName: o, preview: i, auth: a } = e, s = `&gtm_auth=${a}`, l = `&gtm_preview=${i}`;
  t || console.warn("GTM Id is required");
  const u = `
    <iframe src="https://www.googletagmanager.com/ns.html?id=${t}${s}${l}&gtm_cookies_win=x"
      height="0" width="0" style="display:none;visibility:hidden" id="tag-manager"></iframe>`, c = `
    (function(w,d,s,l,i){w[l]=w[l]||[];
      w[l].push({'gtm.start': new Date().getTime(),event:'gtm.js', ${JSON.stringify(
    n
  ).slice(1, -1)}});
      var f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';
      j.async=true;j.src='https://www.googletagmanager.com/gtm.js?id='+i+dl+'${s}${l}&gtm_cookies_win=x';
      f.parentNode.insertBefore(j,f);
    })(window,document,'script','${o}','${t}');`, p = NJ({ dataLayer: r, dataLayerName: o });
  return {
    iframe: u,
    script: c,
    dataLayerVar: p
  };
}
let n4e = class {
  initializeDataScript(t) {
    const n = document.createElement("script");
    return n.innerHTML = t, n;
  }
  initializeGTMElements(t) {
    const n = t4e(t), r = () => {
      const a = document.createElement("noscript");
      return a.innerHTML = n.iframe, a;
    }, o = () => {
      const a = document.createElement("script");
      return a.innerHTML = n.script, a;
    }, i = this.initializeDataScript(n.dataLayerVar);
    return {
      noScript: r,
      script: o,
      dataScript: i
    };
  }
  initializeDataLayer(t) {
    const { dataLayer: n, dataLayerName: r } = t;
    if (window[r]) return window[r].push(n);
    const o = NJ({ dataLayer: n, dataLayerName: r }), i = this.initializeDataScript(o);
    document.head.insertBefore(i, document.head.childNodes[0]);
  }
  initialize(t) {
    const {
      events: n,
      gtmId: r,
      dataLayer: o,
      auth: i = "",
      preview: a = "",
      dataLayerName: s = "dataLayer"
    } = t, l = this.initializeGTMElements({
      id: r,
      events: n,
      dataLayer: o || void 0,
      dataLayerName: s,
      auth: i,
      preview: a
    });
    o && document.head.appendChild(l.dataScript), document.head.insertBefore(l.script(), document.head.childNodes[0]), document.body.insertBefore(l.noScript(), document.body.childNodes[0]);
  }
};
function r4e(e) {
  return new n4e().initialize(e), /* @__PURE__ */ Q.jsx(Q.Fragment, {});
}
function o7e(e) {
  const {
    gtmId: t,
    auth: n = "",
    preview: r = "",
    dataLayerName: o = "dataLayer",
    events: i = {},
    dataLayer: a = {},
    showInDevMode: s = !1
  } = e;
  return process.env.NODE_ENV !== "production" && !s ? /* @__PURE__ */ Q.jsx(Q.Fragment, {}) : /* @__PURE__ */ Q.jsx(BJ, { children: () => /* @__PURE__ */ Q.jsx(
    r4e,
    {
      auth: n,
      dataLayer: a,
      dataLayerName: o,
      events: i,
      gtmId: t,
      preview: r
    }
  ) });
}
export {
  p4e as AlertContainer,
  d4e as AlertContent,
  f4e as AlertDescription,
  h4e as AlertIcon,
  gQ as AlertTitle,
  L4e as AudioUpload,
  y4e as Badge,
  N4e as BreadcrumbContainer,
  F4e as BreadcrumbLink,
  pf as Button,
  b4e as Card,
  P4e as Checkbox,
  BJ as ClientOnly,
  x8 as Divider,
  U4e as DrawerContainer,
  H4e as DrawerHeader,
  G4e as DrawerProvider,
  e7e as FacebookPixel,
  _4e as FileUpload,
  KW as FormController,
  S4e as FormError,
  YW as FormLabel,
  t7e as GoogleMap,
  Y4e as GoogleProvider,
  n7e as GoogleSearchPlaces,
  o7e as GoogleTagManager,
  GY as IconButton,
  pHe as ImageUpload,
  v0 as Input,
  iVe as ModalContainer,
  sVe as ModalFooter,
  aVe as ModalHeader,
  X4e as ModalProvider,
  M4e as MultiSelect,
  z4e as Pagination,
  D4e as PhoneInput,
  $4e as Popover,
  j4e as RadioBox,
  T4e as RadioGroup,
  A4e as RichText,
  I4e as Select,
  w4e as Skeleton,
  eHe as Slider,
  R4e as Switch,
  RV as TabButton,
  uVe as TabContainer,
  C4e as TableBody,
  x4e as TableCaption,
  O4e as TableContainer,
  E4e as TableFooter,
  k4e as TableHeader,
  B4e as Textarea,
  W4e as Toast,
  J4e as ToastProvider,
  KY as Tooltip,
  g4e as getHtmlFromRichTextValue,
  m4e as getRichTextValueFromHtml,
  v4e as isHtml,
  C8 as morpheme,
  V4e as useAutomation,
  Z4e as useDrawer,
  pS as useFieldErrors,
  ni as useFormController,
  x6e as useHydrated,
  q4e as useModal,
  WX as useScopedParams,
  w6e as useToast
};
