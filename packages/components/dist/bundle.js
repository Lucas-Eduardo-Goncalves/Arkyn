var j4 = Object.defineProperty;
var A4 = (e, t, n) => t in e ? j4(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n;
var Sd = (e, t, n) => A4(e, typeof t != "symbol" ? t + "" : t, n);
import * as $e from "react";
import ke, { createContext as Ze, useContext as ye, Children as at, forwardRef as Vr, useState as k, useEffect as v, memo as Ee, useRef as rt, useMemo as Tn, isValidElement as bi, cloneElement as wi, Component as pu, PureComponent as pe, createRef as Qr, useId as B4, useCallback as En, useLayoutEffect as I4, useReducer as R4, useSyncExternalStore as N4 } from "react";
import { Info as YU, AlertTriangle as F4, XCircle as JU, CheckCircle2 as QU, Loader2 as Gi, Pause as z4, Play as U4, RefreshCw as Yx, Check as Mm, FileImage as $4, FileAudio as H4, FileArchive as W4, File as V4, ChevronDown as Jx, X as Qx, Search as e$, Image as q4, Heading1 as Z4, Heading2 as G4, Quote as X4, Bold as K4, Italic as Y4, Underline as J4, Code as Q4, AlignLeft as e7, AlignRight as t7, AlignCenter as n7, AlignJustify as r7, ChevronRight as Fw, ChevronLeft as o7, Ellipsis as N1, MapPinned as i7 } from "lucide-react";
import { useActionData as eO, useNavigation as t$, useFetchers as tO, useLocation as nO, Link as s7, useNavigate as n$ } from "@remix-run/react";
import { InputMask as Il } from "@react-input/mask";
import { AnimatePresence as r$, motion as Gc } from "framer-motion";
import * as Ci from "react-dom";
import Rl, { createPortal as yr } from "react-dom";
var Nn = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Dm(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var zw = { exports: {} }, Mu = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var F1;
function a7() {
  if (F1) return Mu;
  F1 = 1;
  var e = ke, t = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, o = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, i = { key: !0, ref: !0, __self: !0, __source: !0 };
  function a(s, l, u) {
    var c, p = {}, d = null, h = null;
    u !== void 0 && (d = "" + u), l.key !== void 0 && (d = "" + l.key), l.ref !== void 0 && (h = l.ref);
    for (c in l) r.call(l, c) && !i.hasOwnProperty(c) && (p[c] = l[c]);
    if (s && s.defaultProps) for (c in l = s.defaultProps, l) p[c] === void 0 && (p[c] = l[c]);
    return { $$typeof: t, type: s, key: d, ref: h, props: p, _owner: o.current };
  }
  return Mu.Fragment = n, Mu.jsx = a, Mu.jsxs = a, Mu;
}
var Du = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var z1;
function l7() {
  return z1 || (z1 = 1, process.env.NODE_ENV !== "production" && function() {
    var e = ke, t = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), a = Symbol.for("react.provider"), s = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), c = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), d = Symbol.for("react.lazy"), h = Symbol.for("react.offscreen"), f = Symbol.iterator, m = "@@iterator";
    function g(b) {
      if (b === null || typeof b != "object")
        return null;
      var B = f && b[f] || b[m];
      return typeof B == "function" ? B : null;
    }
    var E = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function w(b) {
      {
        for (var B = arguments.length, G = new Array(B > 1 ? B - 1 : 0), ne = 1; ne < B; ne++)
          G[ne - 1] = arguments[ne];
        M("error", b, G);
      }
    }
    function M(b, B, G) {
      {
        var ne = E.ReactDebugCurrentFrame, le = ne.getStackAddendum();
        le !== "" && (B += "%s", G = G.concat([le]));
        var ce = G.map(function(ae) {
          return String(ae);
        });
        ce.unshift("Warning: " + B), Function.prototype.apply.call(console[b], console, ce);
      }
    }
    var x = !1, y = !1, C = !1, P = !1, F = !1, L;
    L = Symbol.for("react.module.reference");
    function N(b) {
      return !!(typeof b == "string" || typeof b == "function" || b === r || b === i || F || b === o || b === u || b === c || P || b === h || x || y || C || typeof b == "object" && b !== null && (b.$$typeof === d || b.$$typeof === p || b.$$typeof === a || b.$$typeof === s || b.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      b.$$typeof === L || b.getModuleId !== void 0));
    }
    function I(b, B, G) {
      var ne = b.displayName;
      if (ne)
        return ne;
      var le = B.displayName || B.name || "";
      return le !== "" ? G + "(" + le + ")" : G;
    }
    function H(b) {
      return b.displayName || "Context";
    }
    function V(b) {
      if (b == null)
        return null;
      if (typeof b.tag == "number" && w("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof b == "function")
        return b.displayName || b.name || null;
      if (typeof b == "string")
        return b;
      switch (b) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case i:
          return "Profiler";
        case o:
          return "StrictMode";
        case u:
          return "Suspense";
        case c:
          return "SuspenseList";
      }
      if (typeof b == "object")
        switch (b.$$typeof) {
          case s:
            var B = b;
            return H(B) + ".Consumer";
          case a:
            var G = b;
            return H(G._context) + ".Provider";
          case l:
            return I(b, b.render, "ForwardRef");
          case p:
            var ne = b.displayName || null;
            return ne !== null ? ne : V(b.type) || "Memo";
          case d: {
            var le = b, ce = le._payload, ae = le._init;
            try {
              return V(ae(ce));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var z = Object.assign, q = 0, K, J, te, ee, _, D, $;
    function S() {
    }
    S.__reactDisabledLog = !0;
    function W() {
      {
        if (q === 0) {
          K = console.log, J = console.info, te = console.warn, ee = console.error, _ = console.group, D = console.groupCollapsed, $ = console.groupEnd;
          var b = {
            configurable: !0,
            enumerable: !0,
            value: S,
            writable: !0
          };
          Object.defineProperties(console, {
            info: b,
            log: b,
            warn: b,
            error: b,
            group: b,
            groupCollapsed: b,
            groupEnd: b
          });
        }
        q++;
      }
    }
    function O() {
      {
        if (q--, q === 0) {
          var b = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: z({}, b, {
              value: K
            }),
            info: z({}, b, {
              value: J
            }),
            warn: z({}, b, {
              value: te
            }),
            error: z({}, b, {
              value: ee
            }),
            group: z({}, b, {
              value: _
            }),
            groupCollapsed: z({}, b, {
              value: D
            }),
            groupEnd: z({}, b, {
              value: $
            })
          });
        }
        q < 0 && w("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var T = E.ReactCurrentDispatcher, U;
    function j(b, B, G) {
      {
        if (U === void 0)
          try {
            throw Error();
          } catch (le) {
            var ne = le.stack.trim().match(/\n( *(at )?)/);
            U = ne && ne[1] || "";
          }
        return `
` + U + b;
      }
    }
    var Z = !1, A;
    {
      var Q = typeof WeakMap == "function" ? WeakMap : Map;
      A = new Q();
    }
    function R(b, B) {
      if (!b || Z)
        return "";
      {
        var G = A.get(b);
        if (G !== void 0)
          return G;
      }
      var ne;
      Z = !0;
      var le = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var ce;
      ce = T.current, T.current = null, W();
      try {
        if (B) {
          var ae = function() {
            throw Error();
          };
          if (Object.defineProperty(ae.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(ae, []);
            } catch (Ne) {
              ne = Ne;
            }
            Reflect.construct(b, [], ae);
          } else {
            try {
              ae.call();
            } catch (Ne) {
              ne = Ne;
            }
            b.call(ae.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Ne) {
            ne = Ne;
          }
          b();
        }
      } catch (Ne) {
        if (Ne && ne && typeof Ne.stack == "string") {
          for (var ie = Ne.stack.split(`
`), Me = ne.stack.split(`
`), he = ie.length - 1, me = Me.length - 1; he >= 1 && me >= 0 && ie[he] !== Me[me]; )
            me--;
          for (; he >= 1 && me >= 0; he--, me--)
            if (ie[he] !== Me[me]) {
              if (he !== 1 || me !== 1)
                do
                  if (he--, me--, me < 0 || ie[he] !== Me[me]) {
                    var qe = `
` + ie[he].replace(" at new ", " at ");
                    return b.displayName && qe.includes("<anonymous>") && (qe = qe.replace("<anonymous>", b.displayName)), typeof b == "function" && A.set(b, qe), qe;
                  }
                while (he >= 1 && me >= 0);
              break;
            }
        }
      } finally {
        Z = !1, T.current = ce, O(), Error.prepareStackTrace = le;
      }
      var Lt = b ? b.displayName || b.name : "", gt = Lt ? j(Lt) : "";
      return typeof b == "function" && A.set(b, gt), gt;
    }
    function ue(b, B, G) {
      return R(b, !1);
    }
    function fe(b) {
      var B = b.prototype;
      return !!(B && B.isReactComponent);
    }
    function oe(b, B, G) {
      if (b == null)
        return "";
      if (typeof b == "function")
        return R(b, fe(b));
      if (typeof b == "string")
        return j(b);
      switch (b) {
        case u:
          return j("Suspense");
        case c:
          return j("SuspenseList");
      }
      if (typeof b == "object")
        switch (b.$$typeof) {
          case l:
            return ue(b.render);
          case p:
            return oe(b.type, B, G);
          case d: {
            var ne = b, le = ne._payload, ce = ne._init;
            try {
              return oe(ce(le), B, G);
            } catch {
            }
          }
        }
      return "";
    }
    var Re = Object.prototype.hasOwnProperty, He = {}, Ve = E.ReactDebugCurrentFrame;
    function ze(b) {
      if (b) {
        var B = b._owner, G = oe(b.type, b._source, B ? B.type : null);
        Ve.setExtraStackFrame(G);
      } else
        Ve.setExtraStackFrame(null);
    }
    function et(b, B, G, ne, le) {
      {
        var ce = Function.call.bind(Re);
        for (var ae in b)
          if (ce(b, ae)) {
            var ie = void 0;
            try {
              if (typeof b[ae] != "function") {
                var Me = Error((ne || "React class") + ": " + G + " type `" + ae + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof b[ae] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw Me.name = "Invariant Violation", Me;
              }
              ie = b[ae](B, ae, ne, G, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (he) {
              ie = he;
            }
            ie && !(ie instanceof Error) && (ze(le), w("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", ne || "React class", G, ae, typeof ie), ze(null)), ie instanceof Error && !(ie.message in He) && (He[ie.message] = !0, ze(le), w("Failed %s type: %s", G, ie.message), ze(null));
          }
      }
    }
    var Ge = Array.isArray;
    function Pe(b) {
      return Ge(b);
    }
    function Ye(b) {
      {
        var B = typeof Symbol == "function" && Symbol.toStringTag, G = B && b[Symbol.toStringTag] || b.constructor.name || "Object";
        return G;
      }
    }
    function it(b) {
      try {
        return _e(b), !1;
      } catch {
        return !0;
      }
    }
    function _e(b) {
      return "" + b;
    }
    function Se(b) {
      if (it(b))
        return w("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Ye(b)), _e(b);
    }
    var Ke = E.ReactCurrentOwner, We = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, Ue, nt;
    function Ie(b) {
      if (Re.call(b, "ref")) {
        var B = Object.getOwnPropertyDescriptor(b, "ref").get;
        if (B && B.isReactWarning)
          return !1;
      }
      return b.ref !== void 0;
    }
    function xt(b) {
      if (Re.call(b, "key")) {
        var B = Object.getOwnPropertyDescriptor(b, "key").get;
        if (B && B.isReactWarning)
          return !1;
      }
      return b.key !== void 0;
    }
    function ot(b, B) {
      typeof b.ref == "string" && Ke.current;
    }
    function st(b, B) {
      {
        var G = function() {
          Ue || (Ue = !0, w("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", B));
        };
        G.isReactWarning = !0, Object.defineProperty(b, "key", {
          get: G,
          configurable: !0
        });
      }
    }
    function lt(b, B) {
      {
        var G = function() {
          nt || (nt = !0, w("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", B));
        };
        G.isReactWarning = !0, Object.defineProperty(b, "ref", {
          get: G,
          configurable: !0
        });
      }
    }
    var Ot = function(b, B, G, ne, le, ce, ae) {
      var ie = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: b,
        key: B,
        ref: G,
        props: ae,
        // Record the component responsible for creating this element.
        _owner: ce
      };
      return ie._store = {}, Object.defineProperty(ie._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(ie, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ne
      }), Object.defineProperty(ie, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: le
      }), Object.freeze && (Object.freeze(ie.props), Object.freeze(ie)), ie;
    };
    function ut(b, B, G, ne, le) {
      {
        var ce, ae = {}, ie = null, Me = null;
        G !== void 0 && (Se(G), ie = "" + G), xt(B) && (Se(B.key), ie = "" + B.key), Ie(B) && (Me = B.ref, ot(B, le));
        for (ce in B)
          Re.call(B, ce) && !We.hasOwnProperty(ce) && (ae[ce] = B[ce]);
        if (b && b.defaultProps) {
          var he = b.defaultProps;
          for (ce in he)
            ae[ce] === void 0 && (ae[ce] = he[ce]);
        }
        if (ie || Me) {
          var me = typeof b == "function" ? b.displayName || b.name || "Unknown" : b;
          ie && st(ae, me), Me && lt(ae, me);
        }
        return Ot(b, ie, Me, le, ne, Ke.current, ae);
      }
    }
    var ct = E.ReactCurrentOwner, tt = E.ReactDebugCurrentFrame;
    function Xe(b) {
      if (b) {
        var B = b._owner, G = oe(b.type, b._source, B ? B.type : null);
        tt.setExtraStackFrame(G);
      } else
        tt.setExtraStackFrame(null);
    }
    var Et;
    Et = !1;
    function kt(b) {
      return typeof b == "object" && b !== null && b.$$typeof === t;
    }
    function pt() {
      {
        if (ct.current) {
          var b = V(ct.current.type);
          if (b)
            return `

Check the render method of \`` + b + "`.";
        }
        return "";
      }
    }
    function kn(b) {
      return "";
    }
    var dt = {};
    function Ln(b) {
      {
        var B = pt();
        if (!B) {
          var G = typeof b == "string" ? b : b.displayName || b.name;
          G && (B = `

Check the top-level render call using <` + G + ">.");
        }
        return B;
      }
    }
    function ft(b, B) {
      {
        if (!b._store || b._store.validated || b.key != null)
          return;
        b._store.validated = !0;
        var G = Ln(B);
        if (dt[G])
          return;
        dt[G] = !0;
        var ne = "";
        b && b._owner && b._owner !== ct.current && (ne = " It was passed a child from " + V(b._owner.type) + "."), Xe(b), w('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', G, ne), Xe(null);
      }
    }
    function rn(b, B) {
      {
        if (typeof b != "object")
          return;
        if (Pe(b))
          for (var G = 0; G < b.length; G++) {
            var ne = b[G];
            kt(ne) && ft(ne, B);
          }
        else if (kt(b))
          b._store && (b._store.validated = !0);
        else if (b) {
          var le = g(b);
          if (typeof le == "function" && le !== b.entries)
            for (var ce = le.call(b), ae; !(ae = ce.next()).done; )
              kt(ae.value) && ft(ae.value, B);
        }
      }
    }
    function br(b) {
      {
        var B = b.type;
        if (B == null || typeof B == "string")
          return;
        var G;
        if (typeof B == "function")
          G = B.propTypes;
        else if (typeof B == "object" && (B.$$typeof === l || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        B.$$typeof === p))
          G = B.propTypes;
        else
          return;
        if (G) {
          var ne = V(B);
          et(G, b.props, "prop", ne, b);
        } else if (B.PropTypes !== void 0 && !Et) {
          Et = !0;
          var le = V(B);
          w("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", le || "Unknown");
        }
        typeof B.getDefaultProps == "function" && !B.getDefaultProps.isReactClassApproved && w("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function ht(b) {
      {
        for (var B = Object.keys(b.props), G = 0; G < B.length; G++) {
          var ne = B[G];
          if (ne !== "children" && ne !== "key") {
            Xe(b), w("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", ne), Xe(null);
            break;
          }
        }
        b.ref !== null && (Xe(b), w("Invalid attribute `ref` supplied to `React.Fragment`."), Xe(null));
      }
    }
    var re = {};
    function eo(b, B, G, ne, le, ce) {
      {
        var ae = N(b);
        if (!ae) {
          var ie = "";
          (b === void 0 || typeof b == "object" && b !== null && Object.keys(b).length === 0) && (ie += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var Me = kn();
          Me ? ie += Me : ie += pt();
          var he;
          b === null ? he = "null" : Pe(b) ? he = "array" : b !== void 0 && b.$$typeof === t ? (he = "<" + (V(b.type) || "Unknown") + " />", ie = " Did you accidentally export a JSX literal instead of a component?") : he = typeof b, w("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", he, ie);
        }
        var me = ut(b, B, G, le, ce);
        if (me == null)
          return me;
        if (ae) {
          var qe = B.children;
          if (qe !== void 0)
            if (ne)
              if (Pe(qe)) {
                for (var Lt = 0; Lt < qe.length; Lt++)
                  rn(qe[Lt], b);
                Object.freeze && Object.freeze(qe);
              } else
                w("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              rn(qe, b);
        }
        if (Re.call(B, "key")) {
          var gt = V(b), Ne = Object.keys(B).filter(function(_i) {
            return _i !== "key";
          }), wr = Ne.length > 0 ? "{key: someKey, " + Ne.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!re[gt + wr]) {
            var Li = Ne.length > 0 ? "{" + Ne.join(": ..., ") + ": ...}" : "{}";
            w(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, wr, gt, Li, gt), re[gt + wr] = !0;
          }
        }
        return b === r ? ht(me) : br(me), me;
      }
    }
    function xi(b, B, G) {
      return eo(b, B, G, !0);
    }
    function Oi(b, B, G) {
      return eo(b, B, G, !1);
    }
    var Ei = Oi, ki = xi;
    Du.Fragment = r, Du.jsx = Ei, Du.jsxs = ki;
  }()), Du;
}
process.env.NODE_ENV === "production" ? zw.exports = a7() : zw.exports = l7();
var X = zw.exports;
function u7(e) {
  const { className: t, ...n } = e, r = `arkynAlertTitle ${t}`;
  return /* @__PURE__ */ X.jsx("div", { className: r.trim(), ...n });
}
const o$ = Ze({});
function c7() {
  return ye(o$);
}
function sRe(e) {
  const { schema: t, children: n, className: r, ...o } = e, s = !((u) => {
    let c = !1;
    const p = (d) => {
      Array.isArray(d) ? d.forEach(p) : d && typeof d == "object" && "type" in d && (d.type === u7 ? c = !0 : d.props && d.props.children && p(d.props.children));
    };
    return p(u), c;
  })(n) ? "nonExistsAlertTitle" : "existsAlertTitle", l = `arkynAlertContainer ${t} ${s} ${r}`;
  return /* @__PURE__ */ X.jsx(o$.Provider, { value: e, children: /* @__PURE__ */ X.jsx("div", { className: l.trim(), ...o, children: n }) });
}
function aRe(e) {
  const { className: t, ...n } = e, r = `arkynAlertContent ${t}`;
  return /* @__PURE__ */ X.jsx("div", { className: r.trim(), ...n });
}
function lRe(e) {
  const { className: t, ...n } = e, r = `arkynAlertDescription ${t}`;
  return /* @__PURE__ */ X.jsx("div", { className: r.trim(), ...n });
}
function uRe(e) {
  const { className: t, ...n } = e, { schema: r } = c7(), o = `arkynAlertIcon ${r} ${t}`;
  switch (r) {
    case "success":
      return /* @__PURE__ */ X.jsx(QU, { className: o, ...n });
    case "danger":
      return /* @__PURE__ */ X.jsx(JU, { className: o, ...n });
    case "warning":
      return /* @__PURE__ */ X.jsx(F4, { className: o, ...n });
    case "info":
      return /* @__PURE__ */ X.jsx(YU, { className: o, ...n });
  }
}
function Fh(e, t) {
  return t ? /* @__PURE__ */ X.jsx(t, { size: e, strokeWidth: 2.5 }) : /* @__PURE__ */ X.jsx(X.Fragment, {});
}
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function U1(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function to(e) {
  var t, n;
  return U1(e) === !1 ? !1 : (t = e.constructor, t === void 0 ? !0 : (n = t.prototype, !(U1(n) === !1 || n.hasOwnProperty("isPrototypeOf") === !1)));
}
var i$ = Symbol.for("immer-nothing"), $1 = Symbol.for("immer-draftable"), Qo = Symbol.for("immer-state"), p7 = process.env.NODE_ENV !== "production" ? [
  // All error codes, starting by 0:
  function(e) {
    return `The plugin for '${e}' has not been loaded into Immer. To enable the plugin, import and call \`enable${e}()\` when initializing your application.`;
  },
  function(e) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${e}'`;
  },
  "This object has been frozen and should not be mutated",
  function(e) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + e;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(e) {
    return `'current' expects a draft, got: ${e}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(e) {
    return `'original' expects a draft, got: ${e}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function Mo(e, ...t) {
  if (process.env.NODE_ENV !== "production") {
    const n = p7[e], r = typeof n == "function" ? n.apply(null, t) : n;
    throw new Error(`[Immer] ${r}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var ru = Object.getPrototypeOf;
function yl(e) {
  return !!e && !!e[Qo];
}
function bl(e) {
  var t;
  return e ? s$(e) || Array.isArray(e) || !!e[$1] || !!((t = e.constructor) != null && t[$1]) || jm(e) || Am(e) : !1;
}
var d7 = Object.prototype.constructor.toString();
function s$(e) {
  if (!e || typeof e != "object")
    return !1;
  const t = ru(e);
  if (t === null)
    return !0;
  const n = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
  return n === Object ? !0 : typeof n == "function" && Function.toString.call(n) === d7;
}
function zh(e, t) {
  Tm(e) === 0 ? Reflect.ownKeys(e).forEach((n) => {
    t(n, e[n], e);
  }) : e.forEach((n, r) => t(r, n, e));
}
function Tm(e) {
  const t = e[Qo];
  return t ? t.type_ : Array.isArray(e) ? 1 : jm(e) ? 2 : Am(e) ? 3 : 0;
}
function Uw(e, t) {
  return Tm(e) === 2 ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t);
}
function a$(e, t, n) {
  const r = Tm(e);
  r === 2 ? e.set(t, n) : r === 3 ? e.add(n) : e[t] = n;
}
function f7(e, t) {
  return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && t !== t;
}
function jm(e) {
  return e instanceof Map;
}
function Am(e) {
  return e instanceof Set;
}
function Za(e) {
  return e.copy_ || e.base_;
}
function $w(e, t) {
  if (jm(e))
    return new Map(e);
  if (Am(e))
    return new Set(e);
  if (Array.isArray(e))
    return Array.prototype.slice.call(e);
  const n = s$(e);
  if (t === !0 || t === "class_only" && !n) {
    const r = Object.getOwnPropertyDescriptors(e);
    delete r[Qo];
    let o = Reflect.ownKeys(r);
    for (let i = 0; i < o.length; i++) {
      const a = o[i], s = r[a];
      s.writable === !1 && (s.writable = !0, s.configurable = !0), (s.get || s.set) && (r[a] = {
        configurable: !0,
        writable: !0,
        // could live with !!desc.set as well here...
        enumerable: s.enumerable,
        value: e[a]
      });
    }
    return Object.create(ru(e), r);
  } else {
    const r = ru(e);
    if (r !== null && n)
      return { ...e };
    const o = Object.create(r);
    return Object.assign(o, e);
  }
}
function rO(e, t = !1) {
  return Bm(e) || yl(e) || !bl(e) || (Tm(e) > 1 && (e.set = e.add = e.clear = e.delete = h7), Object.freeze(e), t && Object.entries(e).forEach(([n, r]) => rO(r, !0))), e;
}
function h7() {
  Mo(2);
}
function Bm(e) {
  return Object.isFrozen(e);
}
var g7 = {};
function wl(e) {
  const t = g7[e];
  return t || Mo(0, e), t;
}
var Xc;
function l$() {
  return Xc;
}
function m7(e, t) {
  return {
    drafts_: [],
    parent_: e,
    immer_: t,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0
  };
}
function H1(e, t) {
  t && (wl("Patches"), e.patches_ = [], e.inversePatches_ = [], e.patchListener_ = t);
}
function Hw(e) {
  Ww(e), e.drafts_.forEach(v7), e.drafts_ = null;
}
function Ww(e) {
  e === Xc && (Xc = e.parent_);
}
function W1(e) {
  return Xc = m7(Xc, e);
}
function v7(e) {
  const t = e[Qo];
  t.type_ === 0 || t.type_ === 1 ? t.revoke_() : t.revoked_ = !0;
}
function V1(e, t) {
  t.unfinalizedDrafts_ = t.drafts_.length;
  const n = t.drafts_[0];
  return e !== void 0 && e !== n ? (n[Qo].modified_ && (Hw(t), Mo(4)), bl(e) && (e = Uh(t, e), t.parent_ || $h(t, e)), t.patches_ && wl("Patches").generateReplacementPatches_(
    n[Qo].base_,
    e,
    t.patches_,
    t.inversePatches_
  )) : e = Uh(t, n, []), Hw(t), t.patches_ && t.patchListener_(t.patches_, t.inversePatches_), e !== i$ ? e : void 0;
}
function Uh(e, t, n) {
  if (Bm(t))
    return t;
  const r = t[Qo];
  if (!r)
    return zh(
      t,
      (o, i) => q1(e, r, t, o, i, n)
    ), t;
  if (r.scope_ !== e)
    return t;
  if (!r.modified_)
    return $h(e, r.base_, !0), r.base_;
  if (!r.finalized_) {
    r.finalized_ = !0, r.scope_.unfinalizedDrafts_--;
    const o = r.copy_;
    let i = o, a = !1;
    r.type_ === 3 && (i = new Set(o), o.clear(), a = !0), zh(
      i,
      (s, l) => q1(e, r, o, s, l, n, a)
    ), $h(e, o, !1), n && e.patches_ && wl("Patches").generatePatches_(
      r,
      n,
      e.patches_,
      e.inversePatches_
    );
  }
  return r.copy_;
}
function q1(e, t, n, r, o, i, a) {
  if (process.env.NODE_ENV !== "production" && o === n && Mo(5), yl(o)) {
    const s = i && t && t.type_ !== 3 && // Set objects are atomic since they have no keys.
    !Uw(t.assigned_, r) ? i.concat(r) : void 0, l = Uh(e, o, s);
    if (a$(n, r, l), yl(l))
      e.canAutoFreeze_ = !1;
    else
      return;
  } else a && n.add(o);
  if (bl(o) && !Bm(o)) {
    if (!e.immer_.autoFreeze_ && e.unfinalizedDrafts_ < 1)
      return;
    Uh(e, o), (!t || !t.scope_.parent_) && typeof r != "symbol" && Object.prototype.propertyIsEnumerable.call(n, r) && $h(e, o);
  }
}
function $h(e, t, n = !1) {
  !e.parent_ && e.immer_.autoFreeze_ && e.canAutoFreeze_ && rO(t, n);
}
function y7(e, t) {
  const n = Array.isArray(e), r = {
    type_: n ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: t ? t.scope_ : l$(),
    // True for both shallow and deep changes.
    modified_: !1,
    // Used during finalization.
    finalized_: !1,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: t,
    // The base state.
    base_: e,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: !1
  };
  let o = r, i = oO;
  n && (o = [r], i = Kc);
  const { revoke: a, proxy: s } = Proxy.revocable(o, i);
  return r.draft_ = s, r.revoke_ = a, s;
}
var oO = {
  get(e, t) {
    if (t === Qo)
      return e;
    const n = Za(e);
    if (!Uw(n, t))
      return b7(e, n, t);
    const r = n[t];
    return e.finalized_ || !bl(r) ? r : r === Zy(e.base_, t) ? (Gy(e), e.copy_[t] = qw(r, e)) : r;
  },
  has(e, t) {
    return t in Za(e);
  },
  ownKeys(e) {
    return Reflect.ownKeys(Za(e));
  },
  set(e, t, n) {
    const r = u$(Za(e), t);
    if (r != null && r.set)
      return r.set.call(e.draft_, n), !0;
    if (!e.modified_) {
      const o = Zy(Za(e), t), i = o == null ? void 0 : o[Qo];
      if (i && i.base_ === n)
        return e.copy_[t] = n, e.assigned_[t] = !1, !0;
      if (f7(n, o) && (n !== void 0 || Uw(e.base_, t)))
        return !0;
      Gy(e), Vw(e);
    }
    return e.copy_[t] === n && // special case: handle new props with value 'undefined'
    (n !== void 0 || t in e.copy_) || // special case: NaN
    Number.isNaN(n) && Number.isNaN(e.copy_[t]) || (e.copy_[t] = n, e.assigned_[t] = !0), !0;
  },
  deleteProperty(e, t) {
    return Zy(e.base_, t) !== void 0 || t in e.base_ ? (e.assigned_[t] = !1, Gy(e), Vw(e)) : delete e.assigned_[t], e.copy_ && delete e.copy_[t], !0;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(e, t) {
    const n = Za(e), r = Reflect.getOwnPropertyDescriptor(n, t);
    return r && {
      writable: !0,
      configurable: e.type_ !== 1 || t !== "length",
      enumerable: r.enumerable,
      value: n[t]
    };
  },
  defineProperty() {
    Mo(11);
  },
  getPrototypeOf(e) {
    return ru(e.base_);
  },
  setPrototypeOf() {
    Mo(12);
  }
}, Kc = {};
zh(oO, (e, t) => {
  Kc[e] = function() {
    return arguments[0] = arguments[0][0], t.apply(this, arguments);
  };
});
Kc.deleteProperty = function(e, t) {
  return process.env.NODE_ENV !== "production" && isNaN(parseInt(t)) && Mo(13), Kc.set.call(this, e, t, void 0);
};
Kc.set = function(e, t, n) {
  return process.env.NODE_ENV !== "production" && t !== "length" && isNaN(parseInt(t)) && Mo(14), oO.set.call(this, e[0], t, n, e[0]);
};
function Zy(e, t) {
  const n = e[Qo];
  return (n ? Za(n) : e)[t];
}
function b7(e, t, n) {
  var o;
  const r = u$(t, n);
  return r ? "value" in r ? r.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (o = r.get) == null ? void 0 : o.call(e.draft_)
  ) : void 0;
}
function u$(e, t) {
  if (!(t in e))
    return;
  let n = ru(e);
  for (; n; ) {
    const r = Object.getOwnPropertyDescriptor(n, t);
    if (r)
      return r;
    n = ru(n);
  }
}
function Vw(e) {
  e.modified_ || (e.modified_ = !0, e.parent_ && Vw(e.parent_));
}
function Gy(e) {
  e.copy_ || (e.copy_ = $w(
    e.base_,
    e.scope_.immer_.useStrictShallowCopy_
  ));
}
var w7 = class {
  constructor(e) {
    this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.produce = (t, n, r) => {
      if (typeof t == "function" && typeof n != "function") {
        const i = n;
        n = t;
        const a = this;
        return function(l = i, ...u) {
          return a.produce(l, (c) => n.call(this, c, ...u));
        };
      }
      typeof n != "function" && Mo(6), r !== void 0 && typeof r != "function" && Mo(7);
      let o;
      if (bl(t)) {
        const i = W1(this), a = qw(t, void 0);
        let s = !0;
        try {
          o = n(a), s = !1;
        } finally {
          s ? Hw(i) : Ww(i);
        }
        return H1(i, r), V1(o, i);
      } else if (!t || typeof t != "object") {
        if (o = n(t), o === void 0 && (o = t), o === i$ && (o = void 0), this.autoFreeze_ && rO(o, !0), r) {
          const i = [], a = [];
          wl("Patches").generateReplacementPatches_(t, o, i, a), r(i, a);
        }
        return o;
      } else
        Mo(1, t);
    }, this.produceWithPatches = (t, n) => {
      if (typeof t == "function")
        return (a, ...s) => this.produceWithPatches(a, (l) => t(l, ...s));
      let r, o;
      return [this.produce(t, n, (a, s) => {
        r = a, o = s;
      }), r, o];
    }, typeof (e == null ? void 0 : e.autoFreeze) == "boolean" && this.setAutoFreeze(e.autoFreeze), typeof (e == null ? void 0 : e.useStrictShallowCopy) == "boolean" && this.setUseStrictShallowCopy(e.useStrictShallowCopy);
  }
  createDraft(e) {
    bl(e) || Mo(8), yl(e) && (e = C7(e));
    const t = W1(this), n = qw(e, void 0);
    return n[Qo].isManual_ = !0, Ww(t), n;
  }
  finishDraft(e, t) {
    const n = e && e[Qo];
    (!n || !n.isManual_) && Mo(9);
    const { scope_: r } = n;
    return H1(r, t), V1(void 0, r);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(e) {
    this.autoFreeze_ = e;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(e) {
    this.useStrictShallowCopy_ = e;
  }
  applyPatches(e, t) {
    let n;
    for (n = t.length - 1; n >= 0; n--) {
      const o = t[n];
      if (o.path.length === 0 && o.op === "replace") {
        e = o.value;
        break;
      }
    }
    n > -1 && (t = t.slice(n + 1));
    const r = wl("Patches").applyPatches_;
    return yl(e) ? r(e, t) : this.produce(
      e,
      (o) => r(o, t)
    );
  }
};
function qw(e, t) {
  const n = jm(e) ? wl("MapSet").proxyMap_(e, t) : Am(e) ? wl("MapSet").proxySet_(e, t) : y7(e, t);
  return (t ? t.scope_ : l$()).drafts_.push(n), n;
}
function C7(e) {
  return yl(e) || Mo(10, e), c$(e);
}
function c$(e) {
  if (!bl(e) || Bm(e))
    return e;
  const t = e[Qo];
  let n;
  if (t) {
    if (!t.modified_)
      return t.base_;
    t.finalized_ = !0, n = $w(e, t.scope_.immer_.useStrictShallowCopy_);
  } else
    n = $w(e, !0);
  return zh(n, (r, o) => {
    a$(n, r, c$(o));
  }), t && (t.finalized_ = !1), n;
}
var ei = new w7(), iO = ei.produce;
ei.produceWithPatches.bind(
  ei
);
ei.setAutoFreeze.bind(ei);
ei.setUseStrictShallowCopy.bind(ei);
ei.applyPatches.bind(ei);
var Z1 = ei.createDraft.bind(ei), G1 = ei.finishDraft.bind(ei), x7 = {
  transform(e, t) {
    var {
      current: n,
      affinity: r
    } = e;
    if (n != null) {
      var o = se.transform(n, t, {
        affinity: r
      });
      e.current = o, o == null && e.unref();
    }
  }
}, O7 = {
  transform(e, t) {
    var {
      current: n,
      affinity: r
    } = e;
    if (n != null) {
      var o = jt.transform(n, t, {
        affinity: r
      });
      e.current = o, o == null && e.unref();
    }
  }
}, E7 = {
  transform(e, t) {
    var {
      current: n,
      affinity: r
    } = e;
    if (n != null) {
      var o = de.transform(n, t, {
        affinity: r
      });
      e.current = o, o == null && e.unref();
    }
  }
}, Hh = /* @__PURE__ */ new WeakMap(), Wh = /* @__PURE__ */ new WeakMap(), wc = /* @__PURE__ */ new WeakMap(), p$ = /* @__PURE__ */ new WeakMap(), X1 = /* @__PURE__ */ new WeakMap(), K1 = /* @__PURE__ */ new WeakMap(), Y1 = /* @__PURE__ */ new WeakMap(), se = {
  ancestors(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = se.levels(e, t);
    return n ? r = r.slice(1) : r = r.slice(0, -1), r;
  },
  common(e, t) {
    for (var n = [], r = 0; r < e.length && r < t.length; r++) {
      var o = e[r], i = t[r];
      if (o !== i)
        break;
      n.push(o);
    }
    return n;
  },
  compare(e, t) {
    for (var n = Math.min(e.length, t.length), r = 0; r < n; r++) {
      if (e[r] < t[r]) return -1;
      if (e[r] > t[r]) return 1;
    }
    return 0;
  },
  endsAfter(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return se.equals(r, o) && i > a;
  },
  endsAt(e, t) {
    var n = e.length, r = e.slice(0, n), o = t.slice(0, n);
    return se.equals(r, o);
  },
  endsBefore(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return se.equals(r, o) && i < a;
  },
  equals(e, t) {
    return e.length === t.length && e.every((n, r) => n === t[r]);
  },
  hasPrevious(e) {
    return e[e.length - 1] > 0;
  },
  isAfter(e, t) {
    return se.compare(e, t) === 1;
  },
  isAncestor(e, t) {
    return e.length < t.length && se.compare(e, t) === 0;
  },
  isBefore(e, t) {
    return se.compare(e, t) === -1;
  },
  isChild(e, t) {
    return e.length === t.length + 1 && se.compare(e, t) === 0;
  },
  isCommon(e, t) {
    return e.length <= t.length && se.compare(e, t) === 0;
  },
  isDescendant(e, t) {
    return e.length > t.length && se.compare(e, t) === 0;
  },
  isParent(e, t) {
    return e.length + 1 === t.length && se.compare(e, t) === 0;
  },
  isPath(e) {
    return Array.isArray(e) && (e.length === 0 || typeof e[0] == "number");
  },
  isSibling(e, t) {
    if (e.length !== t.length)
      return !1;
    var n = e.slice(0, -1), r = t.slice(0, -1), o = e[e.length - 1], i = t[t.length - 1];
    return o !== i && se.equals(n, r);
  },
  levels(e) {
    for (var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = [], o = 0; o <= e.length; o++)
      r.push(e.slice(0, o));
    return n && r.reverse(), r;
  },
  next(e) {
    if (e.length === 0)
      throw new Error("Cannot get the next path of a root path [".concat(e, "], because it has no next index."));
    var t = e[e.length - 1];
    return e.slice(0, -1).concat(t + 1);
  },
  operationCanTransformPath(e) {
    switch (e.type) {
      case "insert_node":
      case "remove_node":
      case "merge_node":
      case "split_node":
      case "move_node":
        return !0;
      default:
        return !1;
    }
  },
  parent(e) {
    if (e.length === 0)
      throw new Error("Cannot get the parent path of the root path [".concat(e, "]."));
    return e.slice(0, -1);
  },
  previous(e) {
    if (e.length === 0)
      throw new Error("Cannot get the previous path of a root path [".concat(e, "], because it has no previous index."));
    var t = e[e.length - 1];
    if (t <= 0)
      throw new Error("Cannot get the previous path of a first child path [".concat(e, "] because it would result in a negative index."));
    return e.slice(0, -1).concat(t - 1);
  },
  relative(e, t) {
    if (!se.isAncestor(t, e) && !se.equals(e, t))
      throw new Error("Cannot get the relative path of [".concat(e, "] inside ancestor [").concat(t, "], because it is not above or equal to the path."));
    return e.slice(t.length);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!e) return null;
    var r = [...e], {
      affinity: o = "forward"
    } = n;
    if (e.length === 0)
      return r;
    switch (t.type) {
      case "insert_node": {
        var {
          path: i
        } = t;
        (se.equals(i, r) || se.endsBefore(i, r) || se.isAncestor(i, r)) && (r[i.length - 1] += 1);
        break;
      }
      case "remove_node": {
        var {
          path: a
        } = t;
        if (se.equals(a, r) || se.isAncestor(a, r))
          return null;
        se.endsBefore(a, r) && (r[a.length - 1] -= 1);
        break;
      }
      case "merge_node": {
        var {
          path: s,
          position: l
        } = t;
        se.equals(s, r) || se.endsBefore(s, r) ? r[s.length - 1] -= 1 : se.isAncestor(s, r) && (r[s.length - 1] -= 1, r[s.length] += l);
        break;
      }
      case "split_node": {
        var {
          path: u,
          position: c
        } = t;
        if (se.equals(u, r)) {
          if (o === "forward")
            r[r.length - 1] += 1;
          else if (o !== "backward") return null;
        } else se.endsBefore(u, r) ? r[u.length - 1] += 1 : se.isAncestor(u, r) && e[u.length] >= c && (r[u.length - 1] += 1, r[u.length] -= c);
        break;
      }
      case "move_node": {
        var {
          path: p,
          newPath: d
        } = t;
        if (se.equals(p, d))
          return r;
        if (se.isAncestor(p, r) || se.equals(p, r)) {
          var h = d.slice();
          return se.endsBefore(p, d) && p.length < d.length && (h[p.length - 1] -= 1), h.concat(r.slice(p.length));
        } else se.isSibling(p, d) && (se.isAncestor(d, r) || se.equals(d, r)) ? se.endsBefore(p, r) ? r[p.length - 1] -= 1 : r[p.length - 1] += 1 : se.endsBefore(d, r) || se.equals(d, r) || se.isAncestor(d, r) ? (se.endsBefore(p, r) && (r[p.length - 1] -= 1), r[d.length - 1] += 1) : se.endsBefore(p, r) && (se.equals(d, r) && (r[d.length - 1] += 1), r[p.length - 1] -= 1);
        break;
      }
    }
    return r;
  }
};
function Yc(e) {
  "@babel/helpers - typeof";
  return Yc = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Yc(e);
}
function k7(e, t) {
  if (Yc(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (Yc(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function L7(e) {
  var t = k7(e, "string");
  return Yc(t) === "symbol" ? t : String(t);
}
function Co(e, t, n) {
  return t = L7(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function J1(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Tu(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? J1(Object(n), !0).forEach(function(r) {
      Co(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : J1(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var _7 = (e, t, n) => {
  switch (n.type) {
    case "insert_node": {
      var {
        path: r,
        node: o
      } = n, i = Fe.parent(e, r), a = r[r.length - 1];
      if (a > i.children.length)
        throw new Error('Cannot apply an "insert_node" operation at path ['.concat(r, "] because the destination is past the end of the node."));
      if (i.children.splice(a, 0, o), t)
        for (var [s, l] of de.points(t))
          t[l] = jt.transform(s, n);
      break;
    }
    case "insert_text": {
      var {
        path: u,
        offset: c,
        text: p
      } = n;
      if (p.length === 0) break;
      var d = Fe.leaf(e, u), h = d.text.slice(0, c), f = d.text.slice(c);
      if (d.text = h + p + f, t)
        for (var [m, g] of de.points(t))
          t[g] = jt.transform(m, n);
      break;
    }
    case "merge_node": {
      var {
        path: E
      } = n, w = Fe.get(e, E), M = se.previous(E), x = Fe.get(e, M), y = Fe.parent(e, E), C = E[E.length - 1];
      if (Qe.isText(w) && Qe.isText(x))
        x.text += w.text;
      else if (!Qe.isText(w) && !Qe.isText(x))
        x.children.push(...w.children);
      else
        throw new Error('Cannot apply a "merge_node" operation at path ['.concat(E, "] to nodes of different interfaces: ").concat(Jr.stringify(w), " ").concat(Jr.stringify(x)));
      if (y.children.splice(C, 1), t)
        for (var [P, F] of de.points(t))
          t[F] = jt.transform(P, n);
      break;
    }
    case "move_node": {
      var {
        path: L,
        newPath: N
      } = n;
      if (se.isAncestor(L, N))
        throw new Error("Cannot move a path [".concat(L, "] to new path [").concat(N, "] because the destination is inside itself."));
      var I = Fe.get(e, L), H = Fe.parent(e, L), V = L[L.length - 1];
      H.children.splice(V, 1);
      var z = se.transform(L, n), q = Fe.get(e, se.parent(z)), K = z[z.length - 1];
      if (q.children.splice(K, 0, I), t)
        for (var [J, te] of de.points(t))
          t[te] = jt.transform(J, n);
      break;
    }
    case "remove_node": {
      var {
        path: ee
      } = n, _ = ee[ee.length - 1], D = Fe.parent(e, ee);
      if (D.children.splice(_, 1), t)
        for (var [$, S] of de.points(t)) {
          var W = jt.transform($, n);
          if (t != null && W != null)
            t[S] = W;
          else {
            var O = void 0, T = void 0;
            for (var [U, j] of Fe.texts(e))
              if (se.compare(j, ee) === -1)
                O = [U, j];
              else {
                T = [U, j];
                break;
              }
            var Z = !1;
            O && T && (se.equals(T[1], ee) ? Z = !se.hasPrevious(T[1]) : Z = se.common(O[1], ee).length < se.common(T[1], ee).length), O && !Z ? ($.path = O[1], $.offset = O[0].text.length) : T ? ($.path = T[1], $.offset = 0) : t = null;
          }
        }
      break;
    }
    case "remove_text": {
      var {
        path: A,
        offset: Q,
        text: R
      } = n;
      if (R.length === 0) break;
      var ue = Fe.leaf(e, A), fe = ue.text.slice(0, Q), oe = ue.text.slice(Q + R.length);
      if (ue.text = fe + oe, t)
        for (var [Re, He] of de.points(t))
          t[He] = jt.transform(Re, n);
      break;
    }
    case "set_node": {
      var {
        path: Ve,
        properties: ze,
        newProperties: et
      } = n;
      if (Ve.length === 0)
        throw new Error("Cannot set properties on the root node!");
      var Ge = Fe.get(e, Ve);
      for (var Pe in et) {
        if (Pe === "children" || Pe === "text")
          throw new Error('Cannot set the "'.concat(Pe, '" property of nodes!'));
        var Ye = et[Pe];
        Ye == null ? delete Ge[Pe] : Ge[Pe] = Ye;
      }
      for (var it in ze)
        et.hasOwnProperty(it) || delete Ge[it];
      break;
    }
    case "set_selection": {
      var {
        newProperties: _e
      } = n;
      if (_e == null)
        t = _e;
      else {
        if (t == null) {
          if (!de.isRange(_e))
            throw new Error('Cannot apply an incomplete "set_selection" operation properties '.concat(Jr.stringify(_e), " when there is no current selection."));
          t = Tu({}, _e);
        }
        for (var Se in _e) {
          var Ke = _e[Se];
          if (Ke == null) {
            if (Se === "anchor" || Se === "focus")
              throw new Error('Cannot remove the "'.concat(Se, '" selection property'));
            delete t[Se];
          } else
            t[Se] = Ke;
        }
      }
      break;
    }
    case "split_node": {
      var {
        path: We,
        position: Ue,
        properties: nt
      } = n;
      if (We.length === 0)
        throw new Error('Cannot apply a "split_node" operation at path ['.concat(We, "] because the root node cannot be split."));
      var Ie = Fe.get(e, We), xt = Fe.parent(e, We), ot = We[We.length - 1], st;
      if (Qe.isText(Ie)) {
        var lt = Ie.text.slice(0, Ue), Ot = Ie.text.slice(Ue);
        Ie.text = lt, st = Tu(Tu({}, nt), {}, {
          text: Ot
        });
      } else {
        var ut = Ie.children.slice(0, Ue), ct = Ie.children.slice(Ue);
        Ie.children = ut, st = Tu(Tu({}, nt), {}, {
          children: ct
        });
      }
      if (xt.children.splice(ot + 1, 0, st), t)
        for (var [tt, Xe] of de.points(t))
          t[Xe] = jt.transform(tt, n);
      break;
    }
  }
  return t;
}, P7 = {
  transform(e, t) {
    e.children = Z1(e.children);
    var n = e.selection && Z1(e.selection);
    try {
      n = _7(e, n, t);
    } finally {
      e.children = G1(e.children), n ? e.selection = yl(n) ? G1(n) : n : e.selection = null;
    }
  }
}, S7 = {
  insertNodes(e, t, n) {
    e.insertNodes(t, n);
  },
  liftNodes(e, t) {
    e.liftNodes(t);
  },
  mergeNodes(e, t) {
    e.mergeNodes(t);
  },
  moveNodes(e, t) {
    e.moveNodes(t);
  },
  removeNodes(e, t) {
    e.removeNodes(t);
  },
  setNodes(e, t, n) {
    e.setNodes(t, n);
  },
  splitNodes(e, t) {
    e.splitNodes(t);
  },
  unsetNodes(e, t, n) {
    e.unsetNodes(t, n);
  },
  unwrapNodes(e, t) {
    e.unwrapNodes(t);
  },
  wrapNodes(e, t, n) {
    e.wrapNodes(t, n);
  }
}, M7 = {
  collapse(e, t) {
    e.collapse(t);
  },
  deselect(e) {
    e.deselect();
  },
  move(e, t) {
    e.move(t);
  },
  select(e, t) {
    e.select(t);
  },
  setPoint(e, t, n) {
    e.setPoint(t, n);
  },
  setSelection(e, t) {
    e.setSelection(t);
  }
}, d$ = (e, t) => {
  for (var n in e) {
    var r = e[n], o = t[n];
    if (to(r) && to(o)) {
      if (!d$(r, o)) return !1;
    } else if (Array.isArray(r) && Array.isArray(o)) {
      if (r.length !== o.length) return !1;
      for (var i = 0; i < r.length; i++)
        if (r[i] !== o[i]) return !1;
    } else if (r !== o)
      return !1;
  }
  for (var a in t)
    if (e[a] === void 0 && t[a] !== void 0)
      return !1;
  return !0;
};
function D7(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), o, i;
  for (i = 0; i < r.length; i++)
    o = r[i], !(t.indexOf(o) >= 0) && (n[o] = e[o]);
  return n;
}
function bs(e, t) {
  if (e == null) return {};
  var n = D7(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (o = 0; o < i.length; o++)
      r = i[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
var T7 = ["anchor", "focus"];
function Q1(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function j7(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Q1(Object(n), !0).forEach(function(r) {
      Co(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Q1(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var de = {
  edges(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, {
      anchor: r,
      focus: o
    } = e;
    return de.isBackward(e) === n ? [r, o] : [o, r];
  },
  end(e) {
    var [, t] = de.edges(e);
    return t;
  },
  equals(e, t) {
    return jt.equals(e.anchor, t.anchor) && jt.equals(e.focus, t.focus);
  },
  includes(e, t) {
    if (de.isRange(t)) {
      if (de.includes(e, t.anchor) || de.includes(e, t.focus))
        return !0;
      var [n, r] = de.edges(e), [o, i] = de.edges(t);
      return jt.isBefore(n, o) && jt.isAfter(r, i);
    }
    var [a, s] = de.edges(e), l = !1, u = !1;
    return jt.isPoint(t) ? (l = jt.compare(t, a) >= 0, u = jt.compare(t, s) <= 0) : (l = se.compare(t, a.path) >= 0, u = se.compare(t, s.path) <= 0), l && u;
  },
  intersection(e, t) {
    var n = bs(e, T7), [r, o] = de.edges(e), [i, a] = de.edges(t), s = jt.isBefore(r, i) ? i : r, l = jt.isBefore(o, a) ? o : a;
    return jt.isBefore(l, s) ? null : j7({
      anchor: s,
      focus: l
    }, n);
  },
  isBackward(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return jt.isAfter(t, n);
  },
  isCollapsed(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return jt.equals(t, n);
  },
  isExpanded(e) {
    return !de.isCollapsed(e);
  },
  isForward(e) {
    return !de.isBackward(e);
  },
  isRange(e) {
    return to(e) && jt.isPoint(e.anchor) && jt.isPoint(e.focus);
  },
  *points(e) {
    yield [e.anchor, "anchor"], yield [e.focus, "focus"];
  },
  start(e) {
    var [t] = de.edges(e);
    return t;
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return iO(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "inward"
      } = n, i, a;
      if (o === "inward") {
        var s = de.isCollapsed(r);
        de.isForward(r) ? (i = "forward", a = s ? i : "backward") : (i = "backward", a = s ? i : "forward");
      } else o === "outward" ? de.isForward(r) ? (i = "backward", a = "forward") : (i = "forward", a = "backward") : (i = o, a = o);
      var l = jt.transform(r.anchor, t, {
        affinity: i
      }), u = jt.transform(r.focus, t, {
        affinity: a
      });
      if (!l || !u)
        return null;
      r.anchor = l, r.focus = u;
    });
  }
}, eL = (e) => to(e) && Fe.isNodeList(e.children) && !Y.isEditor(e), Je = {
  isAncestor(e) {
    return to(e) && Fe.isNodeList(e.children);
  },
  isElement: eL,
  isElementList(e) {
    return Array.isArray(e) && e.every((t) => Je.isElement(t));
  },
  isElementProps(e) {
    return e.children !== void 0;
  },
  isElementType: function(t, n) {
    var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "type";
    return eL(t) && t[r] === n;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "children" && e[n] !== t[n])
        return !1;
    return !0;
  }
}, A7 = ["children"], B7 = ["text"], tL = /* @__PURE__ */ new WeakMap(), Fe = {
  ancestor(e, t) {
    var n = Fe.get(e, t);
    if (Qe.isText(n))
      throw new Error("Cannot get the ancestor node at path [".concat(t, "] because it refers to a text node instead: ").concat(Jr.stringify(n)));
    return n;
  },
  ancestors(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of se.ancestors(t, n)) {
        var o = Fe.ancestor(e, r), i = [o, r];
        yield i;
      }
    }();
  },
  child(e, t) {
    if (Qe.isText(e))
      throw new Error("Cannot get the child of a text node: ".concat(Jr.stringify(e)));
    var n = e.children[t];
    if (n == null)
      throw new Error("Cannot get child at index `".concat(t, "` in node: ").concat(Jr.stringify(e)));
    return n;
  },
  children(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var {
        reverse: r = !1
      } = n, o = Fe.ancestor(e, t), {
        children: i
      } = o, a = r ? i.length - 1 : 0; r ? a >= 0 : a < i.length; ) {
        var s = Fe.child(o, a), l = t.concat(a);
        yield [s, l], a = r ? a - 1 : a + 1;
      }
    }();
  },
  common(e, t, n) {
    var r = se.common(t, n), o = Fe.get(e, r);
    return [o, r];
  },
  descendant(e, t) {
    var n = Fe.get(e, t);
    if (Y.isEditor(n))
      throw new Error("Cannot get the descendant node at path [".concat(t, "] because it refers to the root editor node instead: ").concat(Jr.stringify(n)));
    return n;
  },
  descendants(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Fe.nodes(e, t))
        r.length !== 0 && (yield [n, r]);
    }();
  },
  elements(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Fe.nodes(e, t))
        Je.isElement(n) && (yield [n, r]);
    }();
  },
  extractProps(e) {
    if (Je.isAncestor(e)) {
      var t = bs(e, A7);
      return t;
    } else {
      var t = bs(e, B7);
      return t;
    }
  },
  first(e, t) {
    for (var n = t.slice(), r = Fe.get(e, n); r && !(Qe.isText(r) || r.children.length === 0); )
      r = r.children[0], n.push(0);
    return [r, n];
  },
  fragment(e, t) {
    if (Qe.isText(e))
      throw new Error("Cannot get a fragment starting from a root text node: ".concat(Jr.stringify(e)));
    var n = iO({
      children: e.children
    }, (r) => {
      var [o, i] = de.edges(t), a = Fe.nodes(r, {
        reverse: !0,
        pass: (d) => {
          var [, h] = d;
          return !de.includes(t, h);
        }
      });
      for (var [, s] of a) {
        if (!de.includes(t, s)) {
          var l = Fe.parent(r, s), u = s[s.length - 1];
          l.children.splice(u, 1);
        }
        if (se.equals(s, i.path)) {
          var c = Fe.leaf(r, s);
          c.text = c.text.slice(0, i.offset);
        }
        if (se.equals(s, o.path)) {
          var p = Fe.leaf(r, s);
          p.text = p.text.slice(o.offset);
        }
      }
      Y.isEditor(r) && (r.selection = null);
    });
    return n.children;
  },
  get(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (Qe.isText(n) || !n.children[o])
        throw new Error("Cannot find a descendant at path [".concat(t, "] in node: ").concat(Jr.stringify(e)));
      n = n.children[o];
    }
    return n;
  },
  has(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (Qe.isText(n) || !n.children[o])
        return !1;
      n = n.children[o];
    }
    return !0;
  },
  isNode(e) {
    return Qe.isText(e) || Je.isElement(e) || Y.isEditor(e);
  },
  isNodeList(e) {
    if (!Array.isArray(e))
      return !1;
    var t = tL.get(e);
    if (t !== void 0)
      return t;
    var n = e.every((r) => Fe.isNode(r));
    return tL.set(e, n), n;
  },
  last(e, t) {
    for (var n = t.slice(), r = Fe.get(e, n); r && !(Qe.isText(r) || r.children.length === 0); ) {
      var o = r.children.length - 1;
      r = r.children[o], n.push(o);
    }
    return [r, n];
  },
  leaf(e, t) {
    var n = Fe.get(e, t);
    if (!Qe.isText(n))
      throw new Error("Cannot get the leaf node at path [".concat(t, "] because it refers to a non-leaf node: ").concat(Jr.stringify(n)));
    return n;
  },
  levels(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of se.levels(t, n)) {
        var o = Fe.get(e, r);
        yield [o, r];
      }
    }();
  },
  matches(e, t) {
    return Je.isElement(e) && Je.isElementProps(t) && Je.matches(e, t) || Qe.isText(e) && Qe.isTextProps(t) && Qe.matches(e, t);
  },
  nodes(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var {
        pass: n,
        reverse: r = !1
      } = t, {
        from: o = [],
        to: i
      } = t, a = /* @__PURE__ */ new Set(), s = [], l = e; !(i && (r ? se.isBefore(s, i) : se.isAfter(s, i))); ) {
        if (a.has(l) || (yield [l, s]), !a.has(l) && !Qe.isText(l) && l.children.length !== 0 && (n == null || n([l, s]) === !1)) {
          a.add(l);
          var u = r ? l.children.length - 1 : 0;
          se.isAncestor(s, o) && (u = o[s.length]), s = s.concat(u), l = Fe.get(e, s);
          continue;
        }
        if (s.length === 0)
          break;
        if (!r) {
          var c = se.next(s);
          if (Fe.has(e, c)) {
            s = c, l = Fe.get(e, s);
            continue;
          }
        }
        if (r && s[s.length - 1] !== 0) {
          var p = se.previous(s);
          s = p, l = Fe.get(e, s);
          continue;
        }
        s = se.parent(s), l = Fe.get(e, s), a.add(l);
      }
    }();
  },
  parent(e, t) {
    var n = se.parent(t), r = Fe.get(e, n);
    if (Qe.isText(r))
      throw new Error("Cannot get the parent of path [".concat(t, "] because it does not exist in the root."));
    return r;
  },
  string(e) {
    return Qe.isText(e) ? e.text : e.children.map(Fe.string).join("");
  },
  texts(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Fe.nodes(e, t))
        Qe.isText(n) && (yield [n, r]);
    }();
  }
};
function nL(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function er(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? nL(Object(n), !0).forEach(function(r) {
      Co(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : nL(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var pa = {
  isNodeOperation(e) {
    return pa.isOperation(e) && e.type.endsWith("_node");
  },
  isOperation(e) {
    if (!to(e))
      return !1;
    switch (e.type) {
      case "insert_node":
        return se.isPath(e.path) && Fe.isNode(e.node);
      case "insert_text":
        return typeof e.offset == "number" && typeof e.text == "string" && se.isPath(e.path);
      case "merge_node":
        return typeof e.position == "number" && se.isPath(e.path) && to(e.properties);
      case "move_node":
        return se.isPath(e.path) && se.isPath(e.newPath);
      case "remove_node":
        return se.isPath(e.path) && Fe.isNode(e.node);
      case "remove_text":
        return typeof e.offset == "number" && typeof e.text == "string" && se.isPath(e.path);
      case "set_node":
        return se.isPath(e.path) && to(e.properties) && to(e.newProperties);
      case "set_selection":
        return e.properties === null && de.isRange(e.newProperties) || e.newProperties === null && de.isRange(e.properties) || to(e.properties) && to(e.newProperties);
      case "split_node":
        return se.isPath(e.path) && typeof e.position == "number" && to(e.properties);
      default:
        return !1;
    }
  },
  isOperationList(e) {
    return Array.isArray(e) && e.every((t) => pa.isOperation(t));
  },
  isSelectionOperation(e) {
    return pa.isOperation(e) && e.type.endsWith("_selection");
  },
  isTextOperation(e) {
    return pa.isOperation(e) && e.type.endsWith("_text");
  },
  inverse(e) {
    switch (e.type) {
      case "insert_node":
        return er(er({}, e), {}, {
          type: "remove_node"
        });
      case "insert_text":
        return er(er({}, e), {}, {
          type: "remove_text"
        });
      case "merge_node":
        return er(er({}, e), {}, {
          type: "split_node",
          path: se.previous(e.path)
        });
      case "move_node": {
        var {
          newPath: t,
          path: n
        } = e;
        if (se.equals(t, n))
          return e;
        if (se.isSibling(n, t))
          return er(er({}, e), {}, {
            path: t,
            newPath: n
          });
        var r = se.transform(n, e), o = se.transform(se.next(n), e);
        return er(er({}, e), {}, {
          path: r,
          newPath: o
        });
      }
      case "remove_node":
        return er(er({}, e), {}, {
          type: "insert_node"
        });
      case "remove_text":
        return er(er({}, e), {}, {
          type: "insert_text"
        });
      case "set_node": {
        var {
          properties: i,
          newProperties: a
        } = e;
        return er(er({}, e), {}, {
          properties: a,
          newProperties: i
        });
      }
      case "set_selection": {
        var {
          properties: s,
          newProperties: l
        } = e;
        return s == null ? er(er({}, e), {}, {
          properties: l,
          newProperties: null
        }) : l == null ? er(er({}, e), {}, {
          properties: null,
          newProperties: s
        }) : er(er({}, e), {}, {
          properties: l,
          newProperties: s
        });
      }
      case "split_node":
        return er(er({}, e), {}, {
          type: "merge_node",
          path: se.next(e.path)
        });
    }
  }
}, rL = /* @__PURE__ */ new WeakMap(), I7 = (e) => {
  var t = rL.get(e);
  if (t !== void 0)
    return t;
  if (!to(e))
    return !1;
  var n = typeof e.addMark == "function" && typeof e.apply == "function" && typeof e.deleteFragment == "function" && typeof e.insertBreak == "function" && typeof e.insertSoftBreak == "function" && typeof e.insertFragment == "function" && typeof e.insertNode == "function" && typeof e.insertText == "function" && typeof e.isElementReadOnly == "function" && typeof e.isInline == "function" && typeof e.isSelectable == "function" && typeof e.isVoid == "function" && typeof e.normalizeNode == "function" && typeof e.onChange == "function" && typeof e.removeMark == "function" && typeof e.getDirtyPaths == "function" && (e.marks === null || to(e.marks)) && (e.selection === null || de.isRange(e.selection)) && Fe.isNodeList(e.children) && pa.isOperationList(e.operations);
  return rL.set(e, n), n;
}, Y = {
  above(e, t) {
    return e.above(t);
  },
  addMark(e, t, n) {
    e.addMark(t, n);
  },
  after(e, t, n) {
    return e.after(t, n);
  },
  before(e, t, n) {
    return e.before(t, n);
  },
  deleteBackward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteBackward(n);
  },
  deleteForward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteForward(n);
  },
  deleteFragment(e, t) {
    e.deleteFragment(t);
  },
  edges(e, t) {
    return e.edges(t);
  },
  elementReadOnly(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return e.elementReadOnly(t);
  },
  end(e, t) {
    return e.end(t);
  },
  first(e, t) {
    return e.first(t);
  },
  fragment(e, t) {
    return e.fragment(t);
  },
  hasBlocks(e, t) {
    return e.hasBlocks(t);
  },
  hasInlines(e, t) {
    return e.hasInlines(t);
  },
  hasPath(e, t) {
    return e.hasPath(t);
  },
  hasTexts(e, t) {
    return e.hasTexts(t);
  },
  insertBreak(e) {
    e.insertBreak();
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertNode(e, t) {
    e.insertNode(t);
  },
  insertSoftBreak(e) {
    e.insertSoftBreak();
  },
  insertText(e, t) {
    e.insertText(t);
  },
  isBlock(e, t) {
    return e.isBlock(t);
  },
  isEdge(e, t, n) {
    return e.isEdge(t, n);
  },
  isEditor(e) {
    return I7(e);
  },
  isElementReadOnly(e, t) {
    return e.isElementReadOnly(t);
  },
  isEmpty(e, t) {
    return e.isEmpty(t);
  },
  isEnd(e, t, n) {
    return e.isEnd(t, n);
  },
  isInline(e, t) {
    return e.isInline(t);
  },
  isNormalizing(e) {
    return e.isNormalizing();
  },
  isSelectable(e, t) {
    return e.isSelectable(t);
  },
  isStart(e, t, n) {
    return e.isStart(t, n);
  },
  isVoid(e, t) {
    return e.isVoid(t);
  },
  last(e, t) {
    return e.last(t);
  },
  leaf(e, t, n) {
    return e.leaf(t, n);
  },
  levels(e, t) {
    return e.levels(t);
  },
  marks(e) {
    return e.getMarks();
  },
  next(e, t) {
    return e.next(t);
  },
  node(e, t, n) {
    return e.node(t, n);
  },
  nodes(e, t) {
    return e.nodes(t);
  },
  normalize(e, t) {
    e.normalize(t);
  },
  parent(e, t, n) {
    return e.parent(t, n);
  },
  path(e, t, n) {
    return e.path(t, n);
  },
  pathRef(e, t, n) {
    return e.pathRef(t, n);
  },
  pathRefs(e) {
    return e.pathRefs();
  },
  point(e, t, n) {
    return e.point(t, n);
  },
  pointRef(e, t, n) {
    return e.pointRef(t, n);
  },
  pointRefs(e) {
    return e.pointRefs();
  },
  positions(e, t) {
    return e.positions(t);
  },
  previous(e, t) {
    return e.previous(t);
  },
  range(e, t, n) {
    return e.range(t, n);
  },
  rangeRef(e, t, n) {
    return e.rangeRef(t, n);
  },
  rangeRefs(e) {
    return e.rangeRefs();
  },
  removeMark(e, t) {
    e.removeMark(t);
  },
  setNormalizing(e, t) {
    e.setNormalizing(t);
  },
  start(e, t) {
    return e.start(t);
  },
  string(e, t, n) {
    return e.string(t, n);
  },
  unhangRange(e, t, n) {
    return e.unhangRange(t, n);
  },
  void(e, t) {
    return e.void(t);
  },
  withoutNormalizing(e, t) {
    e.withoutNormalizing(t);
  },
  shouldMergeNodesRemovePrevNode: (e, t, n) => e.shouldMergeNodesRemovePrevNode(t, n)
}, R7 = {
  isSpan(e) {
    return Array.isArray(e) && e.length === 2 && e.every(se.isPath);
  }
};
function oL(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function iL(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? oL(Object(n), !0).forEach(function(r) {
      Co(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : oL(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var jt = {
  compare(e, t) {
    var n = se.compare(e.path, t.path);
    return n === 0 ? e.offset < t.offset ? -1 : e.offset > t.offset ? 1 : 0 : n;
  },
  isAfter(e, t) {
    return jt.compare(e, t) === 1;
  },
  isBefore(e, t) {
    return jt.compare(e, t) === -1;
  },
  equals(e, t) {
    return e.offset === t.offset && se.equals(e.path, t.path);
  },
  isPoint(e) {
    return to(e) && typeof e.offset == "number" && se.isPath(e.path);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return iO(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "forward"
      } = n, {
        path: i,
        offset: a
      } = r;
      switch (t.type) {
        case "insert_node":
        case "move_node": {
          r.path = se.transform(i, t, n);
          break;
        }
        case "insert_text": {
          se.equals(t.path, i) && (t.offset < a || t.offset === a && o === "forward") && (r.offset += t.text.length);
          break;
        }
        case "merge_node": {
          se.equals(t.path, i) && (r.offset += t.position), r.path = se.transform(i, t, n);
          break;
        }
        case "remove_text": {
          se.equals(t.path, i) && t.offset <= a && (r.offset -= Math.min(a - t.offset, t.text.length));
          break;
        }
        case "remove_node": {
          if (se.equals(t.path, i) || se.isAncestor(t.path, i))
            return null;
          r.path = se.transform(i, t, n);
          break;
        }
        case "split_node": {
          if (se.equals(t.path, i)) {
            if (t.position === a && o == null)
              return null;
            (t.position < a || t.position === a && o === "forward") && (r.offset -= t.position, r.path = se.transform(i, t, iL(iL({}, n), {}, {
              affinity: "forward"
            })));
          } else
            r.path = se.transform(i, t, n);
          break;
        }
      }
    });
  }
}, sL = void 0, Jr = {
  setScrubber(e) {
    sL = e;
  },
  stringify(e) {
    return JSON.stringify(e, sL);
  }
}, N7 = ["text"], F7 = ["anchor", "focus"];
function aL(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ts(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? aL(Object(n), !0).forEach(function(r) {
      Co(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : aL(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Qe = {
  equals(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      loose: r = !1
    } = n;
    function o(i) {
      var a = bs(i, N7);
      return a;
    }
    return d$(r ? o(e) : e, r ? o(t) : t);
  },
  isText(e) {
    return to(e) && typeof e.text == "string";
  },
  isTextList(e) {
    return Array.isArray(e) && e.every((t) => Qe.isText(t));
  },
  isTextProps(e) {
    return e.text !== void 0;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "text" && (!e.hasOwnProperty(n) || e[n] !== t[n]))
        return !1;
    return !0;
  },
  decorations(e, t) {
    var n = [ts({}, e)];
    for (var r of t) {
      var o = bs(r, F7), [i, a] = de.edges(r), s = [], l = 0, u = i.offset, c = a.offset;
      for (var p of n) {
        var {
          length: d
        } = p.text, h = l;
        if (l += d, u <= h && l <= c) {
          Object.assign(p, o), s.push(p);
          continue;
        }
        if (u !== c && (u === l || c === h) || u > l || c < h || c === h && h !== 0) {
          s.push(p);
          continue;
        }
        var f = p, m = void 0, g = void 0;
        if (c < l) {
          var E = c - h;
          g = ts(ts({}, f), {}, {
            text: f.text.slice(E)
          }), f = ts(ts({}, f), {}, {
            text: f.text.slice(0, E)
          });
        }
        if (u > h) {
          var w = u - h;
          m = ts(ts({}, f), {}, {
            text: f.text.slice(0, w)
          }), f = ts(ts({}, f), {}, {
            text: f.text.slice(w)
          });
        }
        Object.assign(f, o), m && s.push(m), s.push(f), g && s.push(g);
      }
      n = s;
    }
    return n;
  }
}, sO = (e) => e.selection ? e.selection : e.children.length > 0 ? Y.end(e, []) : [0], du = (e, t) => {
  var [n] = Y.node(e, t);
  return (r) => r === n;
}, aO = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, r = !n, o = n ? V7(t) : t, i = mt.None, a = mt.None, s = 0, l = null, u = null;
  for (var c of o) {
    var p = c.codePointAt(0);
    if (!p) break;
    var d = rq(c, p);
    if ([i, a] = r ? [a, d] : [d, i], ql(i, mt.ZWJ) && ql(a, mt.ExtPict) && (r ? l = lL(t.substring(0, s)) : l = lL(t.substring(0, t.length - s)), !l) || ql(i, mt.RI) && ql(a, mt.RI) && (u !== null ? u = !u : r ? u = !0 : u = lq(t.substring(0, t.length - s)), !u) || i !== mt.None && a !== mt.None && iq(i, a))
      break;
    s += c.length;
  }
  return s || 1;
}, z7 = /\s/, U7 = /[\u002B\u0021-\u0023\u0025-\u002A\u002C-\u002F\u003A\u003B\u003F\u0040\u005B-\u005D\u005F\u007B\u007D\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E3B\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]/, $7 = /['\u2018\u2019]/, H7 = function(t) {
  for (var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, r = 0, o = !1; t.length > 0; ) {
    var i = aO(t, n), [a, s] = lO(t, i, n);
    if (W7(a, s, n))
      o = !0, r += i;
    else if (!o)
      r += i;
    else
      break;
    t = s;
  }
  return r;
}, lO = (e, t, n) => {
  if (n) {
    var r = e.length - t;
    return [e.slice(r, e.length), e.slice(0, r)];
  }
  return [e.slice(0, t), e.slice(t)];
}, W7 = function e(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
  if (z7.test(t))
    return !1;
  if ($7.test(t)) {
    var o = aO(n, r), [i, a] = lO(n, o, r);
    if (e(i, a, r))
      return !0;
  }
  return !U7.test(t);
}, V7 = function* (t) {
  for (var n = t.length - 1, r = 0; r < t.length; r++) {
    var o = t.charAt(n - r);
    if (Z7(o.charCodeAt(0))) {
      var i = t.charAt(n - r - 1);
      if (q7(i.charCodeAt(0))) {
        yield i + o, r++;
        continue;
      }
    }
    yield o;
  }
}, q7 = (e) => e >= 55296 && e <= 56319, Z7 = (e) => e >= 56320 && e <= 57343, mt;
(function(e) {
  e[e.None = 0] = "None", e[e.Extend = 1] = "Extend", e[e.ZWJ = 2] = "ZWJ", e[e.RI = 4] = "RI", e[e.Prepend = 8] = "Prepend", e[e.SpacingMark = 16] = "SpacingMark", e[e.L = 32] = "L", e[e.V = 64] = "V", e[e.T = 128] = "T", e[e.LV = 256] = "LV", e[e.LVT = 512] = "LVT", e[e.ExtPict = 1024] = "ExtPict", e[e.Any = 2048] = "Any";
})(mt || (mt = {}));
var G7 = /^(?:[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09BE\u09C1-\u09C4\u09CD\u09D7\u09E2\u09E3\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01\u0B3C\u0B3E\u0B3F\u0B41-\u0B44\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B82\u0BBE\u0BC0\u0BCD\u0BD7\u0C00\u0C04\u0C3C\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CBF\u0CC2\u0CC6\u0CCC\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D3E\u0D41-\u0D44\u0D4D\u0D57\u0D62\u0D63\u0D81\u0DCA\u0DCF\u0DD2-\u0DD4\u0DD6\u0DDF\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732\u1733\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u180F\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ACE\u1B00-\u1B03\u1B34-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DFF\u200C\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA82C\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFF9E\uFF9F]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD803[\uDD24-\uDD27\uDEAB\uDEAC\uDEFD-\uDEFF\uDF46-\uDF50\uDF82-\uDF85]|\uD804[\uDC01\uDC38-\uDC46\uDC70\uDC73\uDC74\uDC7F-\uDC81\uDCB3-\uDCB6\uDCB9\uDCBA\uDCC2\uDD00-\uDD02\uDD27-\uDD2B\uDD2D-\uDD34\uDD73\uDD80\uDD81\uDDB6-\uDDBE\uDDC9-\uDDCC\uDDCF\uDE2F-\uDE31\uDE34\uDE36\uDE37\uDE3E\uDE41\uDEDF\uDEE3-\uDEEA\uDF00\uDF01\uDF3B\uDF3C\uDF3E\uDF40\uDF57\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC38-\uDC3F\uDC42-\uDC44\uDC46\uDC5E\uDCB0\uDCB3-\uDCB8\uDCBA\uDCBD\uDCBF\uDCC0\uDCC2\uDCC3\uDDAF\uDDB2-\uDDB5\uDDBC\uDDBD\uDDBF\uDDC0\uDDDC\uDDDD\uDE33-\uDE3A\uDE3D\uDE3F\uDE40\uDEAB\uDEAD\uDEB0-\uDEB5\uDEB7\uDF1D-\uDF1F\uDF22-\uDF25\uDF27-\uDF2B]|\uD806[\uDC2F-\uDC37\uDC39\uDC3A\uDD30\uDD3B\uDD3C\uDD3E\uDD43\uDDD4-\uDDD7\uDDDA\uDDDB\uDDE0\uDE01-\uDE0A\uDE33-\uDE38\uDE3B-\uDE3E\uDE47\uDE51-\uDE56\uDE59-\uDE5B\uDE8A-\uDE96\uDE98\uDE99]|\uD807[\uDC30-\uDC36\uDC38-\uDC3D\uDC3F\uDC92-\uDCA7\uDCAA-\uDCB0\uDCB2\uDCB3\uDCB5\uDCB6\uDD31-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD45\uDD47\uDD90\uDD91\uDD95\uDD97\uDEF3\uDEF4\uDF00\uDF01\uDF36-\uDF3A\uDF40\uDF42]|\uD80D[\uDC40\uDC47-\uDC55]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF4F\uDF8F-\uDF92\uDFE4]|\uD82F[\uDC9D\uDC9E]|\uD833[\uDF00-\uDF2D\uDF30-\uDF46]|\uD834[\uDD65\uDD67-\uDD69\uDD6E-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A\uDC8F\uDD30-\uDD36\uDEAE\uDEEC-\uDEEF]|\uD839[\uDCEC-\uDCEF]|\uD83A[\uDCD0-\uDCD6\uDD44-\uDD4A]|\uD83C[\uDFFB-\uDFFF]|\uDB40[\uDC20-\uDC7F\uDD00-\uDDEF])$/, X7 = /^(?:[\u0600-\u0605\u06DD\u070F\u0890\u0891\u08E2\u0D4E]|\uD804[\uDCBD\uDCCD\uDDC2\uDDC3]|\uD806[\uDD3F\uDD41\uDE3A\uDE84-\uDE89]|\uD807\uDD46)$/, K7 = /^(?:[\u0903\u093B\u093E-\u0940\u0949-\u094C\u094E\u094F\u0982\u0983\u09BF\u09C0\u09C7\u09C8\u09CB\u09CC\u0A03\u0A3E-\u0A40\u0A83\u0ABE-\u0AC0\u0AC9\u0ACB\u0ACC\u0B02\u0B03\u0B40\u0B47\u0B48\u0B4B\u0B4C\u0BBF\u0BC1\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCC\u0C01-\u0C03\u0C41-\u0C44\u0C82\u0C83\u0CBE\u0CC0\u0CC1\u0CC3\u0CC4\u0CC7\u0CC8\u0CCA\u0CCB\u0D02\u0D03\u0D3F\u0D40\u0D46-\u0D48\u0D4A-\u0D4C\u0D82\u0D83\u0DD0\u0DD1\u0DD8-\u0DDE\u0DF2\u0DF3\u0E33\u0EB3\u0F3E\u0F3F\u0F7F\u1031\u103B\u103C\u1056\u1057\u1084\u1715\u1734\u17B6\u17BE-\u17C5\u17C7\u17C8\u1923-\u1926\u1929-\u192B\u1930\u1931\u1933-\u1938\u1A19\u1A1A\u1A55\u1A57\u1A6D-\u1A72\u1B04\u1B3B\u1B3D-\u1B41\u1B43\u1B44\u1B82\u1BA1\u1BA6\u1BA7\u1BAA\u1BE7\u1BEA-\u1BEC\u1BEE\u1BF2\u1BF3\u1C24-\u1C2B\u1C34\u1C35\u1CE1\u1CF7\uA823\uA824\uA827\uA880\uA881\uA8B4-\uA8C3\uA952\uA953\uA983\uA9B4\uA9B5\uA9BA\uA9BB\uA9BE-\uA9C0\uAA2F\uAA30\uAA33\uAA34\uAA4D\uAAEB\uAAEE\uAAEF\uAAF5\uABE3\uABE4\uABE6\uABE7\uABE9\uABEA\uABEC]|\uD804[\uDC00\uDC02\uDC82\uDCB0-\uDCB2\uDCB7\uDCB8\uDD2C\uDD45\uDD46\uDD82\uDDB3-\uDDB5\uDDBF\uDDC0\uDDCE\uDE2C-\uDE2E\uDE32\uDE33\uDE35\uDEE0-\uDEE2\uDF02\uDF03\uDF3F\uDF41-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF62\uDF63]|\uD805[\uDC35-\uDC37\uDC40\uDC41\uDC45\uDCB1\uDCB2\uDCB9\uDCBB\uDCBC\uDCBE\uDCC1\uDDB0\uDDB1\uDDB8-\uDDBB\uDDBE\uDE30-\uDE32\uDE3B\uDE3C\uDE3E\uDEAC\uDEAE\uDEAF\uDEB6\uDF26]|\uD806[\uDC2C-\uDC2E\uDC38\uDD31-\uDD35\uDD37\uDD38\uDD3D\uDD40\uDD42\uDDD1-\uDDD3\uDDDC-\uDDDF\uDDE4\uDE39\uDE57\uDE58\uDE97]|\uD807[\uDC2F\uDC3E\uDCA9\uDCB1\uDCB4\uDD8A-\uDD8E\uDD93\uDD94\uDD96\uDEF5\uDEF6]|\uD81B[\uDF51-\uDF87\uDFF0\uDFF1]|\uD834[\uDD66\uDD6D])$/, Y7 = /^[\u1100-\u115F\uA960-\uA97C]$/, J7 = /^[\u1160-\u11A7\uD7B0-\uD7C6]$/, Q7 = /^[\u11A8-\u11FF\uD7CB-\uD7FB]$/, eq = /^[\uAC00\uAC1C\uAC38\uAC54\uAC70\uAC8C\uACA8\uACC4\uACE0\uACFC\uAD18\uAD34\uAD50\uAD6C\uAD88\uADA4\uADC0\uADDC\uADF8\uAE14\uAE30\uAE4C\uAE68\uAE84\uAEA0\uAEBC\uAED8\uAEF4\uAF10\uAF2C\uAF48\uAF64\uAF80\uAF9C\uAFB8\uAFD4\uAFF0\uB00C\uB028\uB044\uB060\uB07C\uB098\uB0B4\uB0D0\uB0EC\uB108\uB124\uB140\uB15C\uB178\uB194\uB1B0\uB1CC\uB1E8\uB204\uB220\uB23C\uB258\uB274\uB290\uB2AC\uB2C8\uB2E4\uB300\uB31C\uB338\uB354\uB370\uB38C\uB3A8\uB3C4\uB3E0\uB3FC\uB418\uB434\uB450\uB46C\uB488\uB4A4\uB4C0\uB4DC\uB4F8\uB514\uB530\uB54C\uB568\uB584\uB5A0\uB5BC\uB5D8\uB5F4\uB610\uB62C\uB648\uB664\uB680\uB69C\uB6B8\uB6D4\uB6F0\uB70C\uB728\uB744\uB760\uB77C\uB798\uB7B4\uB7D0\uB7EC\uB808\uB824\uB840\uB85C\uB878\uB894\uB8B0\uB8CC\uB8E8\uB904\uB920\uB93C\uB958\uB974\uB990\uB9AC\uB9C8\uB9E4\uBA00\uBA1C\uBA38\uBA54\uBA70\uBA8C\uBAA8\uBAC4\uBAE0\uBAFC\uBB18\uBB34\uBB50\uBB6C\uBB88\uBBA4\uBBC0\uBBDC\uBBF8\uBC14\uBC30\uBC4C\uBC68\uBC84\uBCA0\uBCBC\uBCD8\uBCF4\uBD10\uBD2C\uBD48\uBD64\uBD80\uBD9C\uBDB8\uBDD4\uBDF0\uBE0C\uBE28\uBE44\uBE60\uBE7C\uBE98\uBEB4\uBED0\uBEEC\uBF08\uBF24\uBF40\uBF5C\uBF78\uBF94\uBFB0\uBFCC\uBFE8\uC004\uC020\uC03C\uC058\uC074\uC090\uC0AC\uC0C8\uC0E4\uC100\uC11C\uC138\uC154\uC170\uC18C\uC1A8\uC1C4\uC1E0\uC1FC\uC218\uC234\uC250\uC26C\uC288\uC2A4\uC2C0\uC2DC\uC2F8\uC314\uC330\uC34C\uC368\uC384\uC3A0\uC3BC\uC3D8\uC3F4\uC410\uC42C\uC448\uC464\uC480\uC49C\uC4B8\uC4D4\uC4F0\uC50C\uC528\uC544\uC560\uC57C\uC598\uC5B4\uC5D0\uC5EC\uC608\uC624\uC640\uC65C\uC678\uC694\uC6B0\uC6CC\uC6E8\uC704\uC720\uC73C\uC758\uC774\uC790\uC7AC\uC7C8\uC7E4\uC800\uC81C\uC838\uC854\uC870\uC88C\uC8A8\uC8C4\uC8E0\uC8FC\uC918\uC934\uC950\uC96C\uC988\uC9A4\uC9C0\uC9DC\uC9F8\uCA14\uCA30\uCA4C\uCA68\uCA84\uCAA0\uCABC\uCAD8\uCAF4\uCB10\uCB2C\uCB48\uCB64\uCB80\uCB9C\uCBB8\uCBD4\uCBF0\uCC0C\uCC28\uCC44\uCC60\uCC7C\uCC98\uCCB4\uCCD0\uCCEC\uCD08\uCD24\uCD40\uCD5C\uCD78\uCD94\uCDB0\uCDCC\uCDE8\uCE04\uCE20\uCE3C\uCE58\uCE74\uCE90\uCEAC\uCEC8\uCEE4\uCF00\uCF1C\uCF38\uCF54\uCF70\uCF8C\uCFA8\uCFC4\uCFE0\uCFFC\uD018\uD034\uD050\uD06C\uD088\uD0A4\uD0C0\uD0DC\uD0F8\uD114\uD130\uD14C\uD168\uD184\uD1A0\uD1BC\uD1D8\uD1F4\uD210\uD22C\uD248\uD264\uD280\uD29C\uD2B8\uD2D4\uD2F0\uD30C\uD328\uD344\uD360\uD37C\uD398\uD3B4\uD3D0\uD3EC\uD408\uD424\uD440\uD45C\uD478\uD494\uD4B0\uD4CC\uD4E8\uD504\uD520\uD53C\uD558\uD574\uD590\uD5AC\uD5C8\uD5E4\uD600\uD61C\uD638\uD654\uD670\uD68C\uD6A8\uD6C4\uD6E0\uD6FC\uD718\uD734\uD750\uD76C\uD788]$/, tq = /^[\uAC01-\uAC1B\uAC1D-\uAC37\uAC39-\uAC53\uAC55-\uAC6F\uAC71-\uAC8B\uAC8D-\uACA7\uACA9-\uACC3\uACC5-\uACDF\uACE1-\uACFB\uACFD-\uAD17\uAD19-\uAD33\uAD35-\uAD4F\uAD51-\uAD6B\uAD6D-\uAD87\uAD89-\uADA3\uADA5-\uADBF\uADC1-\uADDB\uADDD-\uADF7\uADF9-\uAE13\uAE15-\uAE2F\uAE31-\uAE4B\uAE4D-\uAE67\uAE69-\uAE83\uAE85-\uAE9F\uAEA1-\uAEBB\uAEBD-\uAED7\uAED9-\uAEF3\uAEF5-\uAF0F\uAF11-\uAF2B\uAF2D-\uAF47\uAF49-\uAF63\uAF65-\uAF7F\uAF81-\uAF9B\uAF9D-\uAFB7\uAFB9-\uAFD3\uAFD5-\uAFEF\uAFF1-\uB00B\uB00D-\uB027\uB029-\uB043\uB045-\uB05F\uB061-\uB07B\uB07D-\uB097\uB099-\uB0B3\uB0B5-\uB0CF\uB0D1-\uB0EB\uB0ED-\uB107\uB109-\uB123\uB125-\uB13F\uB141-\uB15B\uB15D-\uB177\uB179-\uB193\uB195-\uB1AF\uB1B1-\uB1CB\uB1CD-\uB1E7\uB1E9-\uB203\uB205-\uB21F\uB221-\uB23B\uB23D-\uB257\uB259-\uB273\uB275-\uB28F\uB291-\uB2AB\uB2AD-\uB2C7\uB2C9-\uB2E3\uB2E5-\uB2FF\uB301-\uB31B\uB31D-\uB337\uB339-\uB353\uB355-\uB36F\uB371-\uB38B\uB38D-\uB3A7\uB3A9-\uB3C3\uB3C5-\uB3DF\uB3E1-\uB3FB\uB3FD-\uB417\uB419-\uB433\uB435-\uB44F\uB451-\uB46B\uB46D-\uB487\uB489-\uB4A3\uB4A5-\uB4BF\uB4C1-\uB4DB\uB4DD-\uB4F7\uB4F9-\uB513\uB515-\uB52F\uB531-\uB54B\uB54D-\uB567\uB569-\uB583\uB585-\uB59F\uB5A1-\uB5BB\uB5BD-\uB5D7\uB5D9-\uB5F3\uB5F5-\uB60F\uB611-\uB62B\uB62D-\uB647\uB649-\uB663\uB665-\uB67F\uB681-\uB69B\uB69D-\uB6B7\uB6B9-\uB6D3\uB6D5-\uB6EF\uB6F1-\uB70B\uB70D-\uB727\uB729-\uB743\uB745-\uB75F\uB761-\uB77B\uB77D-\uB797\uB799-\uB7B3\uB7B5-\uB7CF\uB7D1-\uB7EB\uB7ED-\uB807\uB809-\uB823\uB825-\uB83F\uB841-\uB85B\uB85D-\uB877\uB879-\uB893\uB895-\uB8AF\uB8B1-\uB8CB\uB8CD-\uB8E7\uB8E9-\uB903\uB905-\uB91F\uB921-\uB93B\uB93D-\uB957\uB959-\uB973\uB975-\uB98F\uB991-\uB9AB\uB9AD-\uB9C7\uB9C9-\uB9E3\uB9E5-\uB9FF\uBA01-\uBA1B\uBA1D-\uBA37\uBA39-\uBA53\uBA55-\uBA6F\uBA71-\uBA8B\uBA8D-\uBAA7\uBAA9-\uBAC3\uBAC5-\uBADF\uBAE1-\uBAFB\uBAFD-\uBB17\uBB19-\uBB33\uBB35-\uBB4F\uBB51-\uBB6B\uBB6D-\uBB87\uBB89-\uBBA3\uBBA5-\uBBBF\uBBC1-\uBBDB\uBBDD-\uBBF7\uBBF9-\uBC13\uBC15-\uBC2F\uBC31-\uBC4B\uBC4D-\uBC67\uBC69-\uBC83\uBC85-\uBC9F\uBCA1-\uBCBB\uBCBD-\uBCD7\uBCD9-\uBCF3\uBCF5-\uBD0F\uBD11-\uBD2B\uBD2D-\uBD47\uBD49-\uBD63\uBD65-\uBD7F\uBD81-\uBD9B\uBD9D-\uBDB7\uBDB9-\uBDD3\uBDD5-\uBDEF\uBDF1-\uBE0B\uBE0D-\uBE27\uBE29-\uBE43\uBE45-\uBE5F\uBE61-\uBE7B\uBE7D-\uBE97\uBE99-\uBEB3\uBEB5-\uBECF\uBED1-\uBEEB\uBEED-\uBF07\uBF09-\uBF23\uBF25-\uBF3F\uBF41-\uBF5B\uBF5D-\uBF77\uBF79-\uBF93\uBF95-\uBFAF\uBFB1-\uBFCB\uBFCD-\uBFE7\uBFE9-\uC003\uC005-\uC01F\uC021-\uC03B\uC03D-\uC057\uC059-\uC073\uC075-\uC08F\uC091-\uC0AB\uC0AD-\uC0C7\uC0C9-\uC0E3\uC0E5-\uC0FF\uC101-\uC11B\uC11D-\uC137\uC139-\uC153\uC155-\uC16F\uC171-\uC18B\uC18D-\uC1A7\uC1A9-\uC1C3\uC1C5-\uC1DF\uC1E1-\uC1FB\uC1FD-\uC217\uC219-\uC233\uC235-\uC24F\uC251-\uC26B\uC26D-\uC287\uC289-\uC2A3\uC2A5-\uC2BF\uC2C1-\uC2DB\uC2DD-\uC2F7\uC2F9-\uC313\uC315-\uC32F\uC331-\uC34B\uC34D-\uC367\uC369-\uC383\uC385-\uC39F\uC3A1-\uC3BB\uC3BD-\uC3D7\uC3D9-\uC3F3\uC3F5-\uC40F\uC411-\uC42B\uC42D-\uC447\uC449-\uC463\uC465-\uC47F\uC481-\uC49B\uC49D-\uC4B7\uC4B9-\uC4D3\uC4D5-\uC4EF\uC4F1-\uC50B\uC50D-\uC527\uC529-\uC543\uC545-\uC55F\uC561-\uC57B\uC57D-\uC597\uC599-\uC5B3\uC5B5-\uC5CF\uC5D1-\uC5EB\uC5ED-\uC607\uC609-\uC623\uC625-\uC63F\uC641-\uC65B\uC65D-\uC677\uC679-\uC693\uC695-\uC6AF\uC6B1-\uC6CB\uC6CD-\uC6E7\uC6E9-\uC703\uC705-\uC71F\uC721-\uC73B\uC73D-\uC757\uC759-\uC773\uC775-\uC78F\uC791-\uC7AB\uC7AD-\uC7C7\uC7C9-\uC7E3\uC7E5-\uC7FF\uC801-\uC81B\uC81D-\uC837\uC839-\uC853\uC855-\uC86F\uC871-\uC88B\uC88D-\uC8A7\uC8A9-\uC8C3\uC8C5-\uC8DF\uC8E1-\uC8FB\uC8FD-\uC917\uC919-\uC933\uC935-\uC94F\uC951-\uC96B\uC96D-\uC987\uC989-\uC9A3\uC9A5-\uC9BF\uC9C1-\uC9DB\uC9DD-\uC9F7\uC9F9-\uCA13\uCA15-\uCA2F\uCA31-\uCA4B\uCA4D-\uCA67\uCA69-\uCA83\uCA85-\uCA9F\uCAA1-\uCABB\uCABD-\uCAD7\uCAD9-\uCAF3\uCAF5-\uCB0F\uCB11-\uCB2B\uCB2D-\uCB47\uCB49-\uCB63\uCB65-\uCB7F\uCB81-\uCB9B\uCB9D-\uCBB7\uCBB9-\uCBD3\uCBD5-\uCBEF\uCBF1-\uCC0B\uCC0D-\uCC27\uCC29-\uCC43\uCC45-\uCC5F\uCC61-\uCC7B\uCC7D-\uCC97\uCC99-\uCCB3\uCCB5-\uCCCF\uCCD1-\uCCEB\uCCED-\uCD07\uCD09-\uCD23\uCD25-\uCD3F\uCD41-\uCD5B\uCD5D-\uCD77\uCD79-\uCD93\uCD95-\uCDAF\uCDB1-\uCDCB\uCDCD-\uCDE7\uCDE9-\uCE03\uCE05-\uCE1F\uCE21-\uCE3B\uCE3D-\uCE57\uCE59-\uCE73\uCE75-\uCE8F\uCE91-\uCEAB\uCEAD-\uCEC7\uCEC9-\uCEE3\uCEE5-\uCEFF\uCF01-\uCF1B\uCF1D-\uCF37\uCF39-\uCF53\uCF55-\uCF6F\uCF71-\uCF8B\uCF8D-\uCFA7\uCFA9-\uCFC3\uCFC5-\uCFDF\uCFE1-\uCFFB\uCFFD-\uD017\uD019-\uD033\uD035-\uD04F\uD051-\uD06B\uD06D-\uD087\uD089-\uD0A3\uD0A5-\uD0BF\uD0C1-\uD0DB\uD0DD-\uD0F7\uD0F9-\uD113\uD115-\uD12F\uD131-\uD14B\uD14D-\uD167\uD169-\uD183\uD185-\uD19F\uD1A1-\uD1BB\uD1BD-\uD1D7\uD1D9-\uD1F3\uD1F5-\uD20F\uD211-\uD22B\uD22D-\uD247\uD249-\uD263\uD265-\uD27F\uD281-\uD29B\uD29D-\uD2B7\uD2B9-\uD2D3\uD2D5-\uD2EF\uD2F1-\uD30B\uD30D-\uD327\uD329-\uD343\uD345-\uD35F\uD361-\uD37B\uD37D-\uD397\uD399-\uD3B3\uD3B5-\uD3CF\uD3D1-\uD3EB\uD3ED-\uD407\uD409-\uD423\uD425-\uD43F\uD441-\uD45B\uD45D-\uD477\uD479-\uD493\uD495-\uD4AF\uD4B1-\uD4CB\uD4CD-\uD4E7\uD4E9-\uD503\uD505-\uD51F\uD521-\uD53B\uD53D-\uD557\uD559-\uD573\uD575-\uD58F\uD591-\uD5AB\uD5AD-\uD5C7\uD5C9-\uD5E3\uD5E5-\uD5FF\uD601-\uD61B\uD61D-\uD637\uD639-\uD653\uD655-\uD66F\uD671-\uD68B\uD68D-\uD6A7\uD6A9-\uD6C3\uD6C5-\uD6DF\uD6E1-\uD6FB\uD6FD-\uD717\uD719-\uD733\uD735-\uD74F\uD751-\uD76B\uD76D-\uD787\uD789-\uD7A3]$/, nq = /^(?:[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u2388\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2605\u2607-\u2612\u2614-\u2685\u2690-\u2705\u2708-\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763-\u2767\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC00-\uDCFF\uDD0D-\uDD0F\uDD2F\uDD6C-\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDAD-\uDDE5\uDE01-\uDE0F\uDE1A\uDE2F\uDE32-\uDE3A\uDE3C-\uDE3F\uDE49-\uDFFA]|\uD83D[\uDC00-\uDD3D\uDD46-\uDE4F\uDE80-\uDEFF\uDF74-\uDF7F\uDFD5-\uDFFF]|\uD83E[\uDC0C-\uDC0F\uDC48-\uDC4F\uDC5A-\uDC5F\uDC88-\uDC8F\uDCAE-\uDCFF\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDEFF]|\uD83F[\uDC00-\uDFFD])$/, rq = (e, t) => {
  var n = mt.Any;
  return e.search(G7) !== -1 && (n |= mt.Extend), t === 8205 && (n |= mt.ZWJ), t >= 127462 && t <= 127487 && (n |= mt.RI), e.search(X7) !== -1 && (n |= mt.Prepend), e.search(K7) !== -1 && (n |= mt.SpacingMark), e.search(Y7) !== -1 && (n |= mt.L), e.search(J7) !== -1 && (n |= mt.V), e.search(Q7) !== -1 && (n |= mt.T), e.search(eq) !== -1 && (n |= mt.LV), e.search(tq) !== -1 && (n |= mt.LVT), e.search(nq) !== -1 && (n |= mt.ExtPict), n;
};
function ql(e, t) {
  return (e & t) !== 0;
}
var oq = [
  // GB6
  [mt.L, mt.L | mt.V | mt.LV | mt.LVT],
  // GB7
  [mt.LV | mt.V, mt.V | mt.T],
  // GB8
  [mt.LVT | mt.T, mt.T],
  // GB9
  [mt.Any, mt.Extend | mt.ZWJ],
  // GB9a
  [mt.Any, mt.SpacingMark],
  // GB9b
  [mt.Prepend, mt.Any],
  // GB11
  [mt.ZWJ, mt.ExtPict],
  // GB12 and GB13
  [mt.RI, mt.RI]
];
function iq(e, t) {
  return oq.findIndex((n) => ql(e, n[0]) && ql(t, n[1])) === -1;
}
var sq = /(?:[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u2388\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2605\u2607-\u2612\u2614-\u2685\u2690-\u2705\u2708-\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763-\u2767\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC00-\uDCFF\uDD0D-\uDD0F\uDD2F\uDD6C-\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDAD-\uDDE5\uDE01-\uDE0F\uDE1A\uDE2F\uDE32-\uDE3A\uDE3C-\uDE3F\uDE49-\uDFFA]|\uD83D[\uDC00-\uDD3D\uDD46-\uDE4F\uDE80-\uDEFF\uDF74-\uDF7F\uDFD5-\uDFFF]|\uD83E[\uDC0C-\uDC0F\uDC48-\uDC4F\uDC5A-\uDC5F\uDC88-\uDC8F\uDCAE-\uDCFF\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDEFF]|\uD83F[\uDC00-\uDFFD])(?:[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09BE\u09C1-\u09C4\u09CD\u09D7\u09E2\u09E3\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01\u0B3C\u0B3E\u0B3F\u0B41-\u0B44\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B82\u0BBE\u0BC0\u0BCD\u0BD7\u0C00\u0C04\u0C3C\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CBF\u0CC2\u0CC6\u0CCC\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D3E\u0D41-\u0D44\u0D4D\u0D57\u0D62\u0D63\u0D81\u0DCA\u0DCF\u0DD2-\u0DD4\u0DD6\u0DDF\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732\u1733\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u180F\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ACE\u1B00-\u1B03\u1B34-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DFF\u200C\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA82C\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFF9E\uFF9F]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD803[\uDD24-\uDD27\uDEAB\uDEAC\uDEFD-\uDEFF\uDF46-\uDF50\uDF82-\uDF85]|\uD804[\uDC01\uDC38-\uDC46\uDC70\uDC73\uDC74\uDC7F-\uDC81\uDCB3-\uDCB6\uDCB9\uDCBA\uDCC2\uDD00-\uDD02\uDD27-\uDD2B\uDD2D-\uDD34\uDD73\uDD80\uDD81\uDDB6-\uDDBE\uDDC9-\uDDCC\uDDCF\uDE2F-\uDE31\uDE34\uDE36\uDE37\uDE3E\uDE41\uDEDF\uDEE3-\uDEEA\uDF00\uDF01\uDF3B\uDF3C\uDF3E\uDF40\uDF57\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC38-\uDC3F\uDC42-\uDC44\uDC46\uDC5E\uDCB0\uDCB3-\uDCB8\uDCBA\uDCBD\uDCBF\uDCC0\uDCC2\uDCC3\uDDAF\uDDB2-\uDDB5\uDDBC\uDDBD\uDDBF\uDDC0\uDDDC\uDDDD\uDE33-\uDE3A\uDE3D\uDE3F\uDE40\uDEAB\uDEAD\uDEB0-\uDEB5\uDEB7\uDF1D-\uDF1F\uDF22-\uDF25\uDF27-\uDF2B]|\uD806[\uDC2F-\uDC37\uDC39\uDC3A\uDD30\uDD3B\uDD3C\uDD3E\uDD43\uDDD4-\uDDD7\uDDDA\uDDDB\uDDE0\uDE01-\uDE0A\uDE33-\uDE38\uDE3B-\uDE3E\uDE47\uDE51-\uDE56\uDE59-\uDE5B\uDE8A-\uDE96\uDE98\uDE99]|\uD807[\uDC30-\uDC36\uDC38-\uDC3D\uDC3F\uDC92-\uDCA7\uDCAA-\uDCB0\uDCB2\uDCB3\uDCB5\uDCB6\uDD31-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD45\uDD47\uDD90\uDD91\uDD95\uDD97\uDEF3\uDEF4\uDF00\uDF01\uDF36-\uDF3A\uDF40\uDF42]|\uD80D[\uDC40\uDC47-\uDC55]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF4F\uDF8F-\uDF92\uDFE4]|\uD82F[\uDC9D\uDC9E]|\uD833[\uDF00-\uDF2D\uDF30-\uDF46]|\uD834[\uDD65\uDD67-\uDD69\uDD6E-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A\uDC8F\uDD30-\uDD36\uDEAE\uDEEC-\uDEEF]|\uD839[\uDCEC-\uDCEF]|\uD83A[\uDCD0-\uDCD6\uDD44-\uDD4A]|\uD83C[\uDFFB-\uDFFF]|\uDB40[\uDC20-\uDC7F\uDD00-\uDDEF])*\u200D$/, lL = (e) => e.search(sq) !== -1, aq = /(?:\uD83C[\uDDE6-\uDDFF])+$/g, lq = (e) => {
  var t = e.match(aq);
  if (t === null)
    return !1;
  var n = t[0].length / 2;
  return n % 2 === 1;
}, uq = {
  delete(e, t) {
    e.delete(t);
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertText(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Y.withoutNormalizing(e, () => {
      var {
        voids: r = !1
      } = n, {
        at: o = sO(e)
      } = n;
      if (se.isPath(o) && (o = Y.range(e, o)), de.isRange(o))
        if (de.isCollapsed(o))
          o = o.anchor;
        else {
          var i = de.end(o);
          if (!r && Y.void(e, {
            at: i
          }))
            return;
          var a = de.start(o), s = Y.pointRef(e, a), l = Y.pointRef(e, i);
          Le.delete(e, {
            at: o,
            voids: r
          });
          var u = s.unref(), c = l.unref();
          o = u || c, Le.setSelection(e, {
            anchor: o,
            focus: o
          });
        }
      if (!(!r && Y.void(e, {
        at: o
      }) || Y.elementReadOnly(e, {
        at: o
      }))) {
        var {
          path: p,
          offset: d
        } = o;
        t.length > 0 && e.apply({
          type: "insert_text",
          path: p,
          offset: d,
          text: t
        });
      }
    });
  }
};
function uL(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Md(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? uL(Object(n), !0).forEach(function(r) {
      Co(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : uL(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Le = Md(Md(Md(Md({}, P7), S7), M7), uq), _h = /* @__PURE__ */ new WeakMap(), cq = (e) => _h.get(e) || !1, pq = (e, t, n) => {
  var r = _h.get(e) || !1;
  _h.set(e, !0);
  try {
    t(), n();
  } finally {
    _h.set(e, r);
  }
};
function f$(e, t, n) {
  var r = Hh.get(e) || [], o = Wh.get(e) || /* @__PURE__ */ new Set(), i, a, s = (p) => {
    if (p) {
      var d = p.join(",");
      a.has(d) || (a.add(d), i.push(p));
    }
  };
  if (n) {
    i = [], a = /* @__PURE__ */ new Set();
    for (var l of r) {
      var u = n(l);
      s(u);
    }
  } else
    i = r, a = o;
  for (var c of t)
    s(c);
  Hh.set(e, i), Wh.set(e, a);
}
var dq = (e, t) => {
  for (var n of Y.pathRefs(e))
    x7.transform(n, t);
  for (var r of Y.pointRefs(e))
    O7.transform(r, t);
  for (var o of Y.rangeRefs(e))
    E7.transform(o, t);
  if (!cq(e)) {
    var i = se.operationCanTransformPath(t) ? (a) => se.transform(a, t) : void 0;
    f$(e, e.getDirtyPaths(t), i);
  }
  Le.transform(e, t), e.operations.push(t), Y.normalize(e, {
    operation: t
  }), t.type === "set_selection" && (e.marks = null), wc.get(e) || (wc.set(e, !0), Promise.resolve().then(() => {
    wc.set(e, !1), e.onChange({
      operation: t
    }), e.operations = [];
  }));
}, fq = (e, t) => {
  switch (t.type) {
    case "insert_text":
    case "remove_text":
    case "set_node": {
      var {
        path: n
      } = t;
      return se.levels(n);
    }
    case "insert_node": {
      var {
        node: r,
        path: o
      } = t, i = se.levels(o), a = Qe.isText(r) ? [] : Array.from(Fe.nodes(r), (N) => {
        var [, I] = N;
        return o.concat(I);
      });
      return [...i, ...a];
    }
    case "merge_node": {
      var {
        path: s
      } = t, l = se.ancestors(s), u = se.previous(s);
      return [...l, u];
    }
    case "move_node": {
      var {
        path: c,
        newPath: p
      } = t;
      if (se.equals(c, p))
        return [];
      var d = [], h = [];
      for (var f of se.ancestors(c)) {
        var m = se.transform(f, t);
        d.push(m);
      }
      for (var g of se.ancestors(p)) {
        var E = se.transform(g, t);
        h.push(E);
      }
      var w = h[h.length - 1], M = p[p.length - 1], x = w.concat(M);
      return [...d, ...h, x];
    }
    case "remove_node": {
      var {
        path: y
      } = t, C = se.ancestors(y);
      return [...C];
    }
    case "split_node": {
      var {
        path: P
      } = t, F = se.levels(P), L = se.next(P);
      return [...F, L];
    }
    default:
      return [];
  }
}, hq = (e) => {
  var {
    selection: t
  } = e;
  return t ? Fe.fragment(e, t) : [];
}, gq = (e, t) => {
  var [n, r] = t;
  if (!Qe.isText(n)) {
    if (Je.isElement(n) && n.children.length === 0) {
      var o = {
        text: ""
      };
      Le.insertNodes(e, o, {
        at: r.concat(0),
        voids: !0
      });
      return;
    }
    for (var i = Y.isEditor(n) ? !1 : Je.isElement(n) && (e.isInline(n) || n.children.length === 0 || Qe.isText(n.children[0]) || e.isInline(n.children[0])), a = 0, s = 0; s < n.children.length; s++, a++) {
      var l = Fe.get(e, r);
      if (!Qe.isText(l)) {
        var u = l.children[a], c = l.children[a - 1], p = s === n.children.length - 1, d = Qe.isText(u) || Je.isElement(u) && e.isInline(u);
        if (d !== i)
          Le.removeNodes(e, {
            at: r.concat(a),
            voids: !0
          }), a--;
        else if (Je.isElement(u)) {
          if (e.isInline(u)) {
            if (c == null || !Qe.isText(c)) {
              var h = {
                text: ""
              };
              Le.insertNodes(e, h, {
                at: r.concat(a),
                voids: !0
              }), a++;
            } else if (p) {
              var f = {
                text: ""
              };
              Le.insertNodes(e, f, {
                at: r.concat(a + 1),
                voids: !0
              }), a++;
            }
          }
        } else {
          if (!Qe.isText(u) && !("children" in u)) {
            var m = u;
            m.children = [];
          }
          c != null && Qe.isText(c) && (Qe.equals(u, c, {
            loose: !0
          }) ? (Le.mergeNodes(e, {
            at: r.concat(a),
            voids: !0
          }), a--) : c.text === "" ? (Le.removeNodes(e, {
            at: r.concat(a - 1),
            voids: !0
          }), a--) : u.text === "" && (Le.removeNodes(e, {
            at: r.concat(a),
            voids: !0
          }), a--));
        }
      }
    }
  }
}, mq = (e, t) => {
  var {
    iteration: n,
    initialDirtyPathsLength: r
  } = t, o = r * 42;
  if (n > o)
    throw new Error("Could not completely normalize the editor after ".concat(o, " iterations! This is usually due to incorrect normalization logic that leaves a node in an invalid state."));
  return !0;
}, vq = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    voids: r = !1,
    mode: o = "lowest",
    at: i = t.selection,
    match: a
  } = n;
  if (i) {
    var s = Y.path(t, i), l = o === "lowest";
    for (var [u, c] of Y.levels(t, {
      at: s,
      voids: r,
      match: a,
      reverse: l
    }))
      if (!Qe.isText(u)) {
        if (de.isRange(i)) {
          if (se.isAncestor(c, i.anchor.path) && se.isAncestor(c, i.focus.path))
            return [u, c];
        } else if (!se.equals(s, c))
          return [u, c];
      }
  }
};
function cL(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function pL(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? cL(Object(n), !0).forEach(function(r) {
      Co(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : cL(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var yq = (e, t, n) => {
  var {
    selection: r
  } = e;
  if (r) {
    var o = (p, d) => {
      if (!Qe.isText(p))
        return !1;
      var [h, f] = Y.parent(e, d);
      return !e.isVoid(h) || e.markableVoid(h);
    }, i = de.isExpanded(r), a = !1;
    if (!i) {
      var [s, l] = Y.node(e, r);
      if (s && o(s, l)) {
        var [u] = Y.parent(e, l);
        a = u && e.markableVoid(u);
      }
    }
    if (i || a)
      Le.setNodes(e, {
        [t]: n
      }, {
        match: o,
        split: !0,
        voids: !0
      });
    else {
      var c = pL(pL({}, Y.marks(e) || {}), {}, {
        [t]: n
      });
      e.marks = c, wc.get(e) || e.onChange();
    }
  }
};
function dL(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function fL(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? dL(Object(n), !0).forEach(function(r) {
      Co(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : dL(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var bq = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, o = Y.point(t, n, {
    edge: "end"
  }), i = Y.end(t, []), a = {
    anchor: o,
    focus: i
  }, {
    distance: s = 1
  } = r, l = 0, u;
  for (var c of Y.positions(t, fL(fL({}, r), {}, {
    at: a
  }))) {
    if (l > s)
      break;
    l !== 0 && (u = c), l++;
  }
  return u;
};
function hL(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function gL(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? hL(Object(n), !0).forEach(function(r) {
      Co(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : hL(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var wq = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, o = Y.start(t, []), i = Y.point(t, n, {
    edge: "start"
  }), a = {
    anchor: o,
    focus: i
  }, {
    distance: s = 1
  } = r, l = 0, u;
  for (var c of Y.positions(t, gL(gL({}, r), {}, {
    at: a,
    reverse: !0
  }))) {
    if (l > s)
      break;
    l !== 0 && (u = c), l++;
  }
  return u;
}, Cq = (e, t) => {
  var {
    selection: n
  } = e;
  n && de.isCollapsed(n) && Le.delete(e, {
    unit: t,
    reverse: !0
  });
}, xq = (e, t) => {
  var {
    selection: n
  } = e;
  n && de.isCollapsed(n) && Le.delete(e, {
    unit: t
  });
}, Oq = function(t) {
  var {
    direction: n = "forward"
  } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    selection: r
  } = t;
  r && de.isExpanded(r) && Le.delete(t, {
    reverse: n === "backward"
  });
}, Eq = (e, t) => [Y.start(e, t), Y.end(e, t)];
function mL(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function vL(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? mL(Object(n), !0).forEach(function(r) {
      Co(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : mL(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var kq = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return Y.above(t, vL(vL({}, n), {}, {
    match: (r) => Je.isElement(r) && Y.isElementReadOnly(t, r)
  }));
}, Lq = (e, t) => Y.point(e, t, {
  edge: "end"
}), _q = (e, t) => {
  var n = Y.path(e, t, {
    edge: "start"
  });
  return Y.node(e, n);
}, Pq = (e, t) => {
  var n = Y.range(e, t);
  return Fe.fragment(e, n);
};
function yL(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function bL(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? yL(Object(n), !0).forEach(function(r) {
      Co(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : yL(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Sq = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return Y.above(t, bL(bL({}, n), {}, {
    match: (r) => Je.isElement(r) && Y.isVoid(t, r)
  }));
}, Mq = (e, t) => t.children.some((n) => Je.isElement(n) && Y.isBlock(e, n)), Dq = (e, t) => t.children.some((n) => Qe.isText(n) || Y.isInline(e, n)), Tq = (e, t) => Fe.has(e, t), jq = (e, t) => t.children.every((n) => Qe.isText(n)), Aq = (e) => {
  Le.splitNodes(e, {
    always: !0
  });
}, Bq = (e, t, n) => {
  Le.insertNodes(e, t, n);
}, Iq = (e) => {
  Le.splitNodes(e, {
    always: !0
  });
};
function wL(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Rq(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? wL(Object(n), !0).forEach(function(r) {
      Co(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : wL(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Nq = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    selection: o,
    marks: i
  } = t;
  if (o) {
    if (i) {
      var a = Rq({
        text: n
      }, i);
      Le.insertNodes(t, a, {
        at: r.at,
        voids: r.voids
      });
    } else
      Le.insertText(t, n, r);
    t.marks = null;
  }
}, Fq = (e, t) => !e.isInline(t), zq = (e, t, n) => Y.isStart(e, t, n) || Y.isEnd(e, t, n), Uq = (e, t) => {
  var {
    children: n
  } = t, [r] = n;
  return n.length === 0 || n.length === 1 && Qe.isText(r) && r.text === "" && !e.isVoid(t);
}, $q = (e, t, n) => {
  var r = Y.end(e, n);
  return jt.equals(t, r);
}, Hq = (e) => {
  var t = p$.get(e);
  return t === void 0 ? !0 : t;
}, Wq = (e, t, n) => {
  if (t.offset !== 0)
    return !1;
  var r = Y.start(e, n);
  return jt.equals(t, r);
}, Vq = (e, t) => {
  var n = Y.path(e, t, {
    edge: "end"
  });
  return Y.node(e, n);
}, qq = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, o = Y.path(t, n, r), i = Fe.leaf(t, o);
  return [i, o];
};
function Zq(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return function* () {
    var {
      at: n = e.selection,
      reverse: r = !1,
      voids: o = !1
    } = t, {
      match: i
    } = t;
    if (i == null && (i = () => !0), !!n) {
      var a = [], s = Y.path(e, n);
      for (var [l, u] of Fe.levels(e, s))
        if (i(l, u) && (a.push([l, u]), !o && Je.isElement(l) && Y.isVoid(e, l)))
          break;
      r && a.reverse(), yield* a;
    }
  }();
}
var Gq = ["text"], Xq = ["text"], Kq = function(t) {
  var {
    marks: n,
    selection: r
  } = t;
  if (!r)
    return null;
  var {
    anchor: o,
    focus: i
  } = r;
  if (n)
    return n;
  if (de.isExpanded(r)) {
    var a = Y.isEnd(t, o, o.path);
    if (a) {
      var s = Y.after(t, o);
      s && (o = s);
    }
    var [l] = Y.nodes(t, {
      match: Qe.isText,
      at: {
        anchor: o,
        focus: i
      }
    });
    if (l) {
      var [u] = l, c = bs(u, Gq);
      return c;
    } else
      return {};
  }
  var {
    path: p
  } = o, [d] = Y.leaf(t, p);
  if (o.offset === 0) {
    var h = Y.previous(t, {
      at: p,
      match: Qe.isText
    }), f = Y.above(t, {
      match: (x) => Je.isElement(x) && Y.isVoid(t, x) && t.markableVoid(x)
    });
    if (!f) {
      var m = Y.above(t, {
        match: (x) => Je.isElement(x) && Y.isBlock(t, x)
      });
      if (h && m) {
        var [g, E] = h, [, w] = m;
        se.isAncestor(w, E) && (d = g);
      }
    }
  }
  var M = bs(d, Xq);
  return M;
}, Yq = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    mode: r = "lowest",
    voids: o = !1
  } = n, {
    match: i,
    at: a = t.selection
  } = n;
  if (a) {
    var s = Y.after(t, a, {
      voids: o
    });
    if (s) {
      var [, l] = Y.last(t, []), u = [s.path, l];
      if (se.isPath(a) && a.length === 0)
        throw new Error("Cannot get the next node from the root node!");
      if (i == null)
        if (se.isPath(a)) {
          var [c] = Y.parent(t, a);
          i = (d) => c.children.includes(d);
        } else
          i = () => !0;
      var [p] = Y.nodes(t, {
        at: u,
        match: i,
        mode: r,
        voids: o
      });
      return p;
    }
  }
}, Jq = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, o = Y.path(t, n, r), i = Fe.get(t, o);
  return [i, o];
};
function Qq(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return function* () {
    var {
      at: n = e.selection,
      mode: r = "all",
      universal: o = !1,
      reverse: i = !1,
      voids: a = !1,
      ignoreNonSelectable: s = !1
    } = t, {
      match: l
    } = t;
    if (l || (l = () => !0), !!n) {
      var u, c;
      if (R7.isSpan(n))
        u = n[0], c = n[1];
      else {
        var p = Y.path(e, n, {
          edge: "start"
        }), d = Y.path(e, n, {
          edge: "end"
        });
        u = i ? d : p, c = i ? p : d;
      }
      var h = Fe.nodes(e, {
        reverse: i,
        from: u,
        to: c,
        pass: (x) => {
          var [y] = x;
          return Je.isElement(y) ? !!(!a && (Y.isVoid(e, y) || Y.isElementReadOnly(e, y)) || s && !Y.isSelectable(e, y)) : !1;
        }
      }), f = [], m;
      for (var [g, E] of h)
        if (!(s && Je.isElement(g) && !Y.isSelectable(e, g))) {
          var w = m && se.compare(E, m[1]) === 0;
          if (!(r === "highest" && w)) {
            if (!l(g, E)) {
              if (o && !w && Qe.isText(g))
                return;
              continue;
            }
            if (r === "lowest" && w) {
              m = [g, E];
              continue;
            }
            var M = r === "lowest" ? m : [g, E];
            M && (o ? f.push(M) : yield M), m = [g, E];
          }
        }
      r === "lowest" && m && (o ? f.push(m) : yield m), o && (yield* f);
    }
  }();
}
var eZ = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    force: r = !1,
    operation: o
  } = n, i = (c) => Hh.get(c) || [], a = (c) => Wh.get(c) || /* @__PURE__ */ new Set(), s = (c) => {
    var p = i(c).pop(), d = p.join(",");
    return a(c).delete(d), p;
  };
  if (Y.isNormalizing(t)) {
    if (r) {
      var l = Array.from(Fe.nodes(t), (c) => {
        var [, p] = c;
        return p;
      }), u = new Set(l.map((c) => c.join(",")));
      Hh.set(t, l), Wh.set(t, u);
    }
    i(t).length !== 0 && Y.withoutNormalizing(t, () => {
      for (var c of i(t))
        if (Fe.has(t, c)) {
          var p = Y.node(t, c), [d, h] = p;
          Je.isElement(d) && d.children.length === 0 && t.normalizeNode(p, {
            operation: o
          });
        }
      for (var f = i(t), m = f.length, g = 0; f.length !== 0; ) {
        if (!t.shouldNormalize({
          dirtyPaths: f,
          iteration: g,
          initialDirtyPathsLength: m,
          operation: o
        }))
          return;
        var E = s(t);
        if (Fe.has(t, E)) {
          var w = Y.node(t, E);
          t.normalizeNode(w, {
            operation: o
          });
        }
        g++, f = i(t);
      }
    });
  }
}, tZ = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, o = Y.path(t, n, r), i = se.parent(o), a = Y.node(t, i);
  return a;
}, nZ = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    affinity: o = "forward"
  } = r, i = {
    current: n,
    affinity: o,
    unref() {
      var {
        current: s
      } = i, l = Y.pathRefs(t);
      return l.delete(i), i.current = null, s;
    }
  }, a = Y.pathRefs(t);
  return a.add(i), i;
}, rZ = (e) => {
  var t = X1.get(e);
  return t || (t = /* @__PURE__ */ new Set(), X1.set(e, t)), t;
}, oZ = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    depth: o,
    edge: i
  } = r;
  if (se.isPath(n)) {
    if (i === "start") {
      var [, a] = Fe.first(t, n);
      n = a;
    } else if (i === "end") {
      var [, s] = Fe.last(t, n);
      n = s;
    }
  }
  return de.isRange(n) && (i === "start" ? n = de.start(n) : i === "end" ? n = de.end(n) : n = se.common(n.anchor.path, n.focus.path)), jt.isPoint(n) && (n = n.path), o != null && (n = n.slice(0, o)), n;
}, iZ = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    affinity: o = "forward"
  } = r, i = {
    current: n,
    affinity: o,
    unref() {
      var {
        current: s
      } = i, l = Y.pointRefs(t);
      return l.delete(i), i.current = null, s;
    }
  }, a = Y.pointRefs(t);
  return a.add(i), i;
}, sZ = (e) => {
  var t = K1.get(e);
  return t || (t = /* @__PURE__ */ new Set(), K1.set(e, t)), t;
}, aZ = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    edge: o = "start"
  } = r;
  if (se.isPath(n)) {
    var i;
    if (o === "end") {
      var [, a] = Fe.last(t, n);
      i = a;
    } else {
      var [, s] = Fe.first(t, n);
      i = s;
    }
    var l = Fe.get(t, i);
    if (!Qe.isText(l))
      throw new Error("Cannot get the ".concat(o, " point in the node at path [").concat(n, "] because it has no ").concat(o, " text node."));
    return {
      path: i,
      offset: o === "end" ? l.text.length : 0
    };
  }
  if (de.isRange(n)) {
    var [u, c] = de.edges(n);
    return o === "start" ? u : c;
  }
  return n;
};
function lZ(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return function* () {
    var {
      at: n = e.selection,
      unit: r = "offset",
      reverse: o = !1,
      voids: i = !1,
      ignoreNonSelectable: a = !1
    } = t;
    if (!n)
      return;
    var s = Y.range(e, n), [l, u] = de.edges(s), c = o ? u : l, p = !1, d = "", h = 0, f = 0, m = 0;
    for (var [g, E] of Y.nodes(e, {
      at: n,
      reverse: o,
      voids: i,
      ignoreNonSelectable: a
    })) {
      if (Je.isElement(g)) {
        if (!i && (e.isVoid(g) || e.isElementReadOnly(g))) {
          yield Y.start(e, E);
          continue;
        }
        if (e.isInline(g)) continue;
        if (Y.hasInlines(e, g)) {
          var w = se.isAncestor(E, u.path) ? u : Y.end(e, E), M = se.isAncestor(E, l.path) ? l : Y.start(e, E);
          d = Y.string(e, {
            anchor: M,
            focus: w
          }, {
            voids: i
          }), p = !0;
        }
      }
      if (Qe.isText(g)) {
        var x = se.equals(E, c.path);
        for (x ? (f = o ? c.offset : g.text.length - c.offset, m = c.offset) : (f = g.text.length, m = o ? f : 0), (x || p || r === "offset") && (yield {
          path: E,
          offset: m
        }, p = !1); ; ) {
          if (h === 0) {
            if (d === "") break;
            h = y(d, r, o), d = lO(d, h, o)[1];
          }
          if (m = o ? m - h : m + h, f = f - h, f < 0) {
            h = -f;
            break;
          }
          h = 0, yield {
            path: E,
            offset: m
          };
        }
      }
    }
    function y(C, P, F) {
      return P === "character" ? aO(C, F) : P === "word" ? H7(C, F) : P === "line" || P === "block" ? C.length : 1;
    }
  }();
}
var uZ = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    mode: r = "lowest",
    voids: o = !1
  } = n, {
    match: i,
    at: a = t.selection
  } = n;
  if (a) {
    var s = Y.before(t, a, {
      voids: o
    });
    if (s) {
      var [, l] = Y.first(t, []), u = [s.path, l];
      if (se.isPath(a) && a.length === 0)
        throw new Error("Cannot get the previous node from the root node!");
      if (i == null)
        if (se.isPath(a)) {
          var [c] = Y.parent(t, a);
          i = (d) => c.children.includes(d);
        } else
          i = () => !0;
      var [p] = Y.nodes(t, {
        reverse: !0,
        at: u,
        match: i,
        mode: r,
        voids: o
      });
      return p;
    }
  }
}, cZ = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    affinity: o = "forward"
  } = r, i = {
    current: n,
    affinity: o,
    unref() {
      var {
        current: s
      } = i, l = Y.rangeRefs(t);
      return l.delete(i), i.current = null, s;
    }
  }, a = Y.rangeRefs(t);
  return a.add(i), i;
}, pZ = (e) => {
  var t = Y1.get(e);
  return t || (t = /* @__PURE__ */ new Set(), Y1.set(e, t)), t;
}, dZ = (e, t, n) => {
  if (de.isRange(t) && !n)
    return t;
  var r = Y.start(e, t), o = Y.end(e, n || t);
  return {
    anchor: r,
    focus: o
  };
};
function CL(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function fZ(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? CL(Object(n), !0).forEach(function(r) {
      Co(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : CL(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var hZ = (e, t) => {
  var {
    selection: n
  } = e;
  if (n) {
    var r = (c, p) => {
      if (!Qe.isText(c))
        return !1;
      var [d, h] = Y.parent(e, p);
      return !e.isVoid(d) || e.markableVoid(d);
    }, o = de.isExpanded(n), i = !1;
    if (!o) {
      var [a, s] = Y.node(e, n);
      if (a && r(a, s)) {
        var [l] = Y.parent(e, s);
        i = l && e.markableVoid(l);
      }
    }
    if (o || i)
      Le.unsetNodes(e, t, {
        match: r,
        split: !0,
        voids: !0
      });
    else {
      var u = fZ({}, Y.marks(e) || {});
      delete u[t], e.marks = u, wc.get(e) || e.onChange();
    }
  }
}, gZ = (e, t) => {
  p$.set(e, t);
}, mZ = (e, t) => Y.point(e, t, {
  edge: "start"
}), vZ = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    voids: o = !1
  } = r, i = Y.range(t, n), [a, s] = de.edges(i), l = "";
  for (var [u, c] of Y.nodes(t, {
    at: i,
    match: Qe.isText,
    voids: o
  })) {
    var p = u.text;
    se.equals(c, s.path) && (p = p.slice(0, s.offset)), se.equals(c, a.path) && (p = p.slice(a.offset)), l += p;
  }
  return l;
}, yZ = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    voids: o = !1
  } = r, [i, a] = de.edges(n);
  if (i.offset !== 0 || a.offset !== 0 || de.isCollapsed(n) || se.hasPrevious(a.path))
    return n;
  var s = Y.above(t, {
    at: a,
    match: (f) => Je.isElement(f) && Y.isBlock(t, f),
    voids: o
  }), l = s ? s[1] : [], u = Y.start(t, i), c = {
    anchor: u,
    focus: a
  }, p = !0;
  for (var [d, h] of Y.nodes(t, {
    at: c,
    match: Qe.isText,
    reverse: !0,
    voids: o
  })) {
    if (p) {
      p = !1;
      continue;
    }
    if (d.text !== "" || se.isBefore(h, l)) {
      a = {
        path: h,
        offset: d.text.length
      };
      break;
    }
  }
  return {
    anchor: i,
    focus: a
  };
}, bZ = (e, t) => {
  var n = Y.isNormalizing(e);
  Y.setNormalizing(e, !1);
  try {
    t();
  } finally {
    Y.setNormalizing(e, n);
  }
  Y.normalize(e);
}, wZ = (e, t, n) => {
  var [r, o] = t;
  return Je.isElement(r) && Y.isEmpty(e, r) || Qe.isText(r) && r.text === "" && o[o.length - 1] !== 0;
}, CZ = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  Y.withoutNormalizing(t, () => {
    var r, o, {
      reverse: i = !1,
      unit: a = "character",
      distance: s = 1,
      voids: l = !1
    } = n, {
      at: u = t.selection,
      hanging: c = !1
    } = n;
    if (u) {
      var p = !1;
      if (de.isRange(u) && de.isCollapsed(u) && (p = !0, u = u.anchor), jt.isPoint(u)) {
        var d = Y.void(t, {
          at: u,
          mode: "highest"
        });
        if (!l && d) {
          var [, h] = d;
          u = h;
        } else {
          var f = {
            unit: a,
            distance: s
          }, m = i ? Y.before(t, u, f) || Y.start(t, []) : Y.after(t, u, f) || Y.end(t, []);
          u = {
            anchor: u,
            focus: m
          }, c = !0;
        }
      }
      if (se.isPath(u)) {
        Le.removeNodes(t, {
          at: u,
          voids: l
        });
        return;
      }
      if (!de.isCollapsed(u)) {
        if (!c) {
          var [, g] = de.edges(u), E = Y.end(t, []);
          jt.equals(g, E) || (u = Y.unhangRange(t, u, {
            voids: l
          }));
        }
        var [w, M] = de.edges(u), x = Y.above(t, {
          match: (fe) => Je.isElement(fe) && Y.isBlock(t, fe),
          at: w,
          voids: l
        }), y = Y.above(t, {
          match: (fe) => Je.isElement(fe) && Y.isBlock(t, fe),
          at: M,
          voids: l
        }), C = x && y && !se.equals(x[1], y[1]), P = se.equals(w.path, M.path), F = l ? null : (r = Y.void(t, {
          at: w,
          mode: "highest"
        })) !== null && r !== void 0 ? r : Y.elementReadOnly(t, {
          at: w,
          mode: "highest"
        }), L = l ? null : (o = Y.void(t, {
          at: M,
          mode: "highest"
        })) !== null && o !== void 0 ? o : Y.elementReadOnly(t, {
          at: M,
          mode: "highest"
        });
        if (F) {
          var N = Y.before(t, w);
          N && x && se.isAncestor(x[1], N.path) && (w = N);
        }
        if (L) {
          var I = Y.after(t, M);
          I && y && se.isAncestor(y[1], I.path) && (M = I);
        }
        var H = [], V;
        for (var z of Y.nodes(t, {
          at: u,
          voids: l
        })) {
          var [q, K] = z;
          V && se.compare(K, V) === 0 || (!l && Je.isElement(q) && (Y.isVoid(t, q) || Y.isElementReadOnly(t, q)) || !se.isCommon(K, w.path) && !se.isCommon(K, M.path)) && (H.push(z), V = K);
        }
        var J = Array.from(H, (fe) => {
          var [, oe] = fe;
          return Y.pathRef(t, oe);
        }), te = Y.pointRef(t, w), ee = Y.pointRef(t, M), _ = "";
        if (!P && !F) {
          var D = te.current, [$] = Y.leaf(t, D), {
            path: S
          } = D, {
            offset: W
          } = w, O = $.text.slice(W);
          O.length > 0 && (t.apply({
            type: "remove_text",
            path: S,
            offset: W,
            text: O
          }), _ = O);
        }
        if (J.reverse().map((fe) => fe.unref()).filter((fe) => fe !== null).forEach((fe) => Le.removeNodes(t, {
          at: fe,
          voids: l
        })), !L) {
          var T = ee.current, [U] = Y.leaf(t, T), {
            path: j
          } = T, Z = P ? w.offset : 0, A = U.text.slice(Z, M.offset);
          A.length > 0 && (t.apply({
            type: "remove_text",
            path: j,
            offset: Z,
            text: A
          }), _ = A);
        }
        !P && C && ee.current && te.current && Le.mergeNodes(t, {
          at: ee.current,
          hanging: !0,
          voids: l
        }), p && i && a === "character" && _.length > 1 && _.match(/[\u0E00-\u0E7F]+/) && Le.insertText(t, _.slice(0, _.length - s));
        var Q = te.unref(), R = ee.unref(), ue = i ? Q || R : R || Q;
        n.at == null && ue && Le.select(t, ue);
      }
    }
  });
}, xZ = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Y.withoutNormalizing(t, () => {
    var {
      hanging: o = !1,
      voids: i = !1
    } = r, {
      at: a = sO(t),
      batchDirty: s = !0
    } = r;
    if (n.length) {
      if (de.isRange(a))
        if (o || (a = Y.unhangRange(t, a, {
          voids: i
        })), de.isCollapsed(a))
          a = a.anchor;
        else {
          var [, l] = de.edges(a);
          if (!i && Y.void(t, {
            at: l
          }))
            return;
          var u = Y.pointRef(t, l);
          Le.delete(t, {
            at: a
          }), a = u.unref();
        }
      else se.isPath(a) && (a = Y.start(t, a));
      if (!(!i && Y.void(t, {
        at: a
      }))) {
        var c = Y.above(t, {
          at: a,
          match: (O) => Je.isElement(O) && Y.isInline(t, O),
          mode: "highest",
          voids: i
        });
        if (c) {
          var [, p] = c;
          if (Y.isEnd(t, a, p)) {
            var d = Y.after(t, p);
            a = d;
          } else if (Y.isStart(t, a, p)) {
            var h = Y.before(t, p);
            a = h;
          }
        }
        var f = Y.above(t, {
          match: (O) => Je.isElement(O) && Y.isBlock(t, O),
          at: a,
          voids: i
        }), [, m] = f, g = Y.isStart(t, a, m), E = Y.isEnd(t, a, m), w = g && E, M = !g || g && E, x = !E, [, y] = Fe.first({
          children: n
        }, []), [, C] = Fe.last({
          children: n
        }, []), P = [], F = (O) => {
          var [T, U] = O, j = U.length === 0;
          return j ? !1 : w ? !0 : !(M && se.isAncestor(U, y) && Je.isElement(T) && !t.isVoid(T) && !t.isInline(T) || x && se.isAncestor(U, C) && Je.isElement(T) && !t.isVoid(T) && !t.isInline(T));
        };
        for (var L of Fe.nodes({
          children: n
        }, {
          pass: F
        }))
          F(L) && P.push(L);
        var N = [], I = [], H = [], V = !0, z = !1;
        for (var [q] of P)
          Je.isElement(q) && !t.isInline(q) ? (V = !1, z = !0, I.push(q)) : V ? N.push(q) : H.push(q);
        var [K] = Y.nodes(t, {
          at: a,
          match: (O) => Qe.isText(O) || Y.isInline(t, O),
          mode: "highest",
          voids: i
        }), [, J] = K, te = Y.isStart(t, a, J), ee = Y.isEnd(t, a, J), _ = Y.pathRef(t, E && !H.length ? se.next(m) : m), D = Y.pathRef(t, ee ? se.next(J) : J);
        Le.splitNodes(t, {
          at: a,
          match: (O) => z ? Je.isElement(O) && Y.isBlock(t, O) : Qe.isText(O) || Y.isInline(t, O),
          mode: z ? "lowest" : "highest",
          always: z && (!g || N.length > 0) && (!E || H.length > 0),
          voids: i
        });
        var $ = Y.pathRef(t, !te || te && ee ? se.next(J) : J);
        if (Le.insertNodes(t, N, {
          at: $.current,
          match: (O) => Qe.isText(O) || Y.isInline(t, O),
          mode: "highest",
          voids: i,
          batchDirty: s
        }), w && !N.length && I.length && !H.length && Le.delete(t, {
          at: m,
          voids: i
        }), Le.insertNodes(t, I, {
          at: _.current,
          match: (O) => Je.isElement(O) && Y.isBlock(t, O),
          mode: "lowest",
          voids: i,
          batchDirty: s
        }), Le.insertNodes(t, H, {
          at: D.current,
          match: (O) => Qe.isText(O) || Y.isInline(t, O),
          mode: "highest",
          voids: i,
          batchDirty: s
        }), !r.at) {
          var S;
          if (H.length > 0 && D.current ? S = se.previous(D.current) : I.length > 0 && _.current ? S = se.previous(_.current) : $.current && (S = se.previous($.current)), S) {
            var W = Y.end(t, S);
            Le.select(t, W);
          }
        }
        $.unref(), _.unref(), D.unref();
      }
    }
  });
}, OZ = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    edge: r = "anchor"
  } = n, {
    selection: o
  } = t;
  if (o) {
    if (r === "anchor")
      Le.select(t, o.anchor);
    else if (r === "focus")
      Le.select(t, o.focus);
    else if (r === "start") {
      var [i] = de.edges(o);
      Le.select(t, i);
    } else if (r === "end") {
      var [, a] = de.edges(o);
      Le.select(t, a);
    }
  } else return;
}, EZ = (e) => {
  var {
    selection: t
  } = e;
  t && e.apply({
    type: "set_selection",
    properties: t,
    newProperties: null
  });
}, kZ = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    selection: r
  } = t, {
    distance: o = 1,
    unit: i = "character",
    reverse: a = !1
  } = n, {
    edge: s = null
  } = n;
  if (r) {
    s === "start" && (s = de.isBackward(r) ? "focus" : "anchor"), s === "end" && (s = de.isBackward(r) ? "anchor" : "focus");
    var {
      anchor: l,
      focus: u
    } = r, c = {
      distance: o,
      unit: i,
      ignoreNonSelectable: !0
    }, p = {};
    if (s == null || s === "anchor") {
      var d = a ? Y.before(t, l, c) : Y.after(t, l, c);
      d && (p.anchor = d);
    }
    if (s == null || s === "focus") {
      var h = a ? Y.before(t, u, c) : Y.after(t, u, c);
      h && (p.focus = h);
    }
    Le.setSelection(t, p);
  }
}, LZ = (e, t) => {
  var {
    selection: n
  } = e;
  if (t = Y.range(e, t), n) {
    Le.setSelection(e, t);
    return;
  }
  if (!de.isRange(t))
    throw new Error("When setting the selection and the current selection is `null` you must provide at least an `anchor` and `focus`, but you passed: ".concat(Jr.stringify(t)));
  e.apply({
    type: "set_selection",
    properties: n,
    newProperties: t
  });
};
function xL(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function OL(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? xL(Object(n), !0).forEach(function(r) {
      Co(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : xL(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var _Z = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    selection: o
  } = t, {
    edge: i = "both"
  } = r;
  if (o) {
    i === "start" && (i = de.isBackward(o) ? "focus" : "anchor"), i === "end" && (i = de.isBackward(o) ? "anchor" : "focus");
    var {
      anchor: a,
      focus: s
    } = o, l = i === "anchor" ? a : s;
    Le.setSelection(t, {
      [i === "anchor" ? "anchor" : "focus"]: OL(OL({}, l), n)
    });
  }
}, PZ = (e, t) => {
  var {
    selection: n
  } = e, r = {}, o = {};
  if (n) {
    for (var i in t)
      (i === "anchor" && t.anchor != null && !jt.equals(t.anchor, n.anchor) || i === "focus" && t.focus != null && !jt.equals(t.focus, n.focus) || i !== "anchor" && i !== "focus" && t[i] !== n[i]) && (r[i] = n[i], o[i] = t[i]);
    Object.keys(r).length > 0 && e.apply({
      type: "set_selection",
      properties: r,
      newProperties: o
    });
  }
}, SZ = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Y.withoutNormalizing(t, () => {
    var {
      hanging: o = !1,
      voids: i = !1,
      mode: a = "lowest",
      batchDirty: s = !0
    } = r, {
      at: l,
      match: u,
      select: c
    } = r;
    if (Fe.isNode(n) && (n = [n]), n.length !== 0) {
      var [p] = n;
      if (l || (l = sO(t), c !== !1 && (c = !0)), c == null && (c = !1), de.isRange(l))
        if (o || (l = Y.unhangRange(t, l, {
          voids: i
        })), de.isCollapsed(l))
          l = l.anchor;
        else {
          var [, d] = de.edges(l), h = Y.pointRef(t, d);
          Le.delete(t, {
            at: l
          }), l = h.unref();
        }
      if (jt.isPoint(l)) {
        u == null && (Qe.isText(p) ? u = (N) => Qe.isText(N) : t.isInline(p) ? u = (N) => Qe.isText(N) || Y.isInline(t, N) : u = (N) => Je.isElement(N) && Y.isBlock(t, N));
        var [f] = Y.nodes(t, {
          at: l.path,
          match: u,
          mode: a,
          voids: i
        });
        if (f) {
          var [, m] = f, g = Y.pathRef(t, m), E = Y.isEnd(t, l, m);
          Le.splitNodes(t, {
            at: l,
            match: u,
            mode: a,
            voids: i
          });
          var w = g.unref();
          l = E ? se.next(w) : w;
        } else
          return;
      }
      var M = se.parent(l), x = l[l.length - 1];
      if (!(!i && Y.void(t, {
        at: M
      }))) {
        if (s) {
          var y = [], C = se.levels(M);
          pq(t, () => {
            var N = function() {
              var V = M.concat(x);
              x++;
              var z = {
                type: "insert_node",
                path: V,
                node: I
              };
              t.apply(z), l = se.next(l), y.push(z), Qe.isText ? C.push(...Array.from(Fe.nodes(I), (q) => {
                var [, K] = q;
                return V.concat(K);
              })) : C.push(V);
            };
            for (var I of n)
              N();
          }, () => {
            f$(t, C, (N) => {
              var I = N;
              for (var H of y)
                if (se.operationCanTransformPath(H) && (I = se.transform(I, H), !I))
                  return null;
              return I;
            });
          });
        } else
          for (var P of n) {
            var F = M.concat(x);
            x++, t.apply({
              type: "insert_node",
              path: F,
              node: P
            }), l = se.next(l);
          }
        if (l = se.previous(l), c) {
          var L = Y.end(t, l);
          L && Le.select(t, L);
        }
      }
    }
  });
}, MZ = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  Y.withoutNormalizing(t, () => {
    var {
      at: r = t.selection,
      mode: o = "lowest",
      voids: i = !1
    } = n, {
      match: a
    } = n;
    if (a == null && (a = se.isPath(r) ? du(t, r) : (x) => Je.isElement(x) && Y.isBlock(t, x)), !!r) {
      var s = Y.nodes(t, {
        at: r,
        match: a,
        mode: o,
        voids: i
      }), l = Array.from(s, (x) => {
        var [, y] = x;
        return Y.pathRef(t, y);
      });
      for (var u of l) {
        var c = u.unref();
        if (c.length < 2)
          throw new Error("Cannot lift node at a path [".concat(c, "] because it has a depth of less than `2`."));
        var p = Y.node(t, se.parent(c)), [d, h] = p, f = c[c.length - 1], {
          length: m
        } = d.children;
        if (m === 1) {
          var g = se.next(h);
          Le.moveNodes(t, {
            at: c,
            to: g,
            voids: i
          }), Le.removeNodes(t, {
            at: h,
            voids: i
          });
        } else if (f === 0)
          Le.moveNodes(t, {
            at: c,
            to: h,
            voids: i
          });
        else if (f === m - 1) {
          var E = se.next(h);
          Le.moveNodes(t, {
            at: c,
            to: E,
            voids: i
          });
        } else {
          var w = se.next(c), M = se.next(h);
          Le.splitNodes(t, {
            at: w,
            voids: i
          }), Le.moveNodes(t, {
            at: c,
            to: M,
            voids: i
          });
        }
      }
    }
  });
}, DZ = ["text"], TZ = ["children"], h$ = (e, t) => {
  if (Je.isElement(t)) {
    var n = t;
    return Y.isVoid(e, t) ? !0 : n.children.length === 1 ? h$(e, n.children[0]) : !1;
  } else return !Y.isEditor(t);
}, jZ = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  Y.withoutNormalizing(t, () => {
    var {
      match: r,
      at: o = t.selection
    } = n, {
      hanging: i = !1,
      voids: a = !1,
      mode: s = "lowest"
    } = n;
    if (o) {
      if (r == null)
        if (se.isPath(o)) {
          var [l] = Y.parent(t, o);
          r = (N) => l.children.includes(N);
        } else
          r = (N) => Je.isElement(N) && Y.isBlock(t, N);
      if (!i && de.isRange(o) && (o = Y.unhangRange(t, o, {
        voids: a
      })), de.isRange(o))
        if (de.isCollapsed(o))
          o = o.anchor;
        else {
          var [, u] = de.edges(o), c = Y.pointRef(t, u);
          Le.delete(t, {
            at: o
          }), o = c.unref(), n.at == null && Le.select(t, o);
        }
      var [p] = Y.nodes(t, {
        at: o,
        match: r,
        voids: a,
        mode: s
      }), d = Y.previous(t, {
        at: o,
        match: r,
        voids: a,
        mode: s
      });
      if (!(!p || !d)) {
        var [h, f] = p, [m, g] = d;
        if (!(f.length === 0 || g.length === 0)) {
          var E = se.next(g), w = se.common(f, g), M = se.isSibling(f, g), x = Array.from(Y.levels(t, {
            at: f
          }), (N) => {
            var [I] = N;
            return I;
          }).slice(w.length).slice(0, -1), y = Y.above(t, {
            at: f,
            mode: "highest",
            match: (N) => x.includes(N) && h$(t, N)
          }), C = y && Y.pathRef(t, y[1]), P, F;
          if (Qe.isText(h) && Qe.isText(m)) {
            var L = bs(h, DZ);
            F = m.text.length, P = L;
          } else if (Je.isElement(h) && Je.isElement(m)) {
            var L = bs(h, TZ);
            F = m.children.length, P = L;
          } else
            throw new Error("Cannot merge the node at path [".concat(f, "] with the previous sibling because it is not the same kind: ").concat(Jr.stringify(h), " ").concat(Jr.stringify(m)));
          M || Le.moveNodes(t, {
            at: f,
            to: E,
            voids: a
          }), C && Le.removeNodes(t, {
            at: C.current,
            voids: a
          }), Y.shouldMergeNodesRemovePrevNode(t, d, p) ? Le.removeNodes(t, {
            at: g,
            voids: a
          }) : t.apply({
            type: "merge_node",
            path: E,
            position: F,
            properties: P
          }), C && C.unref();
        }
      }
    }
  });
}, AZ = (e, t) => {
  Y.withoutNormalizing(e, () => {
    var {
      to: n,
      at: r = e.selection,
      mode: o = "lowest",
      voids: i = !1
    } = t, {
      match: a
    } = t;
    if (r) {
      a == null && (a = se.isPath(r) ? du(e, r) : (h) => Je.isElement(h) && Y.isBlock(e, h));
      var s = Y.pathRef(e, n), l = Y.nodes(e, {
        at: r,
        match: a,
        mode: o,
        voids: i
      }), u = Array.from(l, (h) => {
        var [, f] = h;
        return Y.pathRef(e, f);
      });
      for (var c of u) {
        var p = c.unref(), d = s.current;
        p.length !== 0 && e.apply({
          type: "move_node",
          path: p,
          newPath: d
        }), s.current && se.isSibling(d, p) && se.isAfter(d, p) && (s.current = se.next(s.current));
      }
      s.unref();
    }
  });
}, BZ = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  Y.withoutNormalizing(t, () => {
    var {
      hanging: r = !1,
      voids: o = !1,
      mode: i = "lowest"
    } = n, {
      at: a = t.selection,
      match: s
    } = n;
    if (a) {
      s == null && (s = se.isPath(a) ? du(t, a) : (h) => Je.isElement(h) && Y.isBlock(t, h)), !r && de.isRange(a) && (a = Y.unhangRange(t, a, {
        voids: o
      }));
      var l = Y.nodes(t, {
        at: a,
        match: s,
        mode: i,
        voids: o
      }), u = Array.from(l, (h) => {
        var [, f] = h;
        return Y.pathRef(t, f);
      });
      for (var c of u) {
        var p = c.unref();
        if (p) {
          var [d] = Y.node(t, p);
          t.apply({
            type: "remove_node",
            path: p,
            node: d
          });
        }
      }
    }
  });
}, IZ = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Y.withoutNormalizing(t, () => {
    var {
      match: o,
      at: i = t.selection,
      compare: a,
      merge: s
    } = r, {
      hanging: l = !1,
      mode: u = "lowest",
      split: c = !1,
      voids: p = !1
    } = r;
    if (i) {
      if (o == null && (o = se.isPath(i) ? du(t, i) : (F) => Je.isElement(F) && Y.isBlock(t, F)), !l && de.isRange(i) && (i = Y.unhangRange(t, i, {
        voids: p
      })), c && de.isRange(i)) {
        if (de.isCollapsed(i) && Y.leaf(t, i.anchor)[0].text.length > 0)
          return;
        var d = Y.rangeRef(t, i, {
          affinity: "inward"
        }), [h, f] = de.edges(i), m = u === "lowest" ? "lowest" : "highest", g = Y.isEnd(t, f, f.path);
        Le.splitNodes(t, {
          at: f,
          match: o,
          mode: m,
          voids: p,
          always: !g
        });
        var E = Y.isStart(t, h, h.path);
        Le.splitNodes(t, {
          at: h,
          match: o,
          mode: m,
          voids: p,
          always: !E
        }), i = d.unref(), r.at == null && Le.select(t, i);
      }
      a || (a = (F, L) => F !== L);
      for (var [w, M] of Y.nodes(t, {
        at: i,
        match: o,
        mode: u,
        voids: p
      })) {
        var x = {}, y = {};
        if (M.length !== 0) {
          var C = !1;
          for (var P in n)
            P === "children" || P === "text" || a(n[P], w[P]) && (C = !0, w.hasOwnProperty(P) && (x[P] = w[P]), s ? n[P] != null && (y[P] = s(w[P], n[P])) : n[P] != null && (y[P] = n[P]));
          C && t.apply({
            type: "set_node",
            path: M,
            properties: x,
            newProperties: y
          });
        }
      }
    }
  });
}, RZ = (e, t) => {
  if (de.isCollapsed(t))
    return t.anchor;
  var [, n] = de.edges(t), r = Y.pointRef(e, n);
  return Le.delete(e, {
    at: t
  }), r.unref();
}, NZ = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  Y.withoutNormalizing(t, () => {
    var {
      mode: r = "lowest",
      voids: o = !1
    } = n, {
      match: i,
      at: a = t.selection,
      height: s = 0,
      always: l = !1
    } = n;
    if (i == null && (i = (ee) => Je.isElement(ee) && Y.isBlock(t, ee)), de.isRange(a) && (a = RZ(t, a)), se.isPath(a)) {
      var u = a, c = Y.point(t, u), [p] = Y.parent(t, u);
      i = (ee) => ee === p, s = c.path.length - u.length + 1, a = c, l = !0;
    }
    if (a) {
      var d = Y.pointRef(t, a, {
        affinity: "backward"
      }), h;
      try {
        var [f] = Y.nodes(t, {
          at: a,
          match: i,
          mode: r,
          voids: o
        });
        if (!f)
          return;
        var m = Y.void(t, {
          at: a,
          mode: "highest"
        }), g = 0;
        if (!o && m) {
          var [E, w] = m;
          if (Je.isElement(E) && t.isInline(E)) {
            var M = Y.after(t, w);
            if (!M) {
              var x = {
                text: ""
              }, y = se.next(w);
              Le.insertNodes(t, x, {
                at: y,
                voids: o
              }), M = Y.point(t, y);
            }
            a = M, l = !0;
          }
          var C = a.path.length - w.length;
          s = C + 1, l = !0;
        }
        h = Y.pointRef(t, a);
        var P = a.path.length - s, [, F] = f, L = a.path.slice(0, P), N = s === 0 ? a.offset : a.path[P] + g;
        for (var [I, H] of Y.levels(t, {
          at: L,
          reverse: !0,
          voids: o
        })) {
          var V = !1;
          if (H.length < F.length || H.length === 0 || !o && Je.isElement(I) && Y.isVoid(t, I))
            break;
          var z = d.current, q = Y.isEnd(t, z, H);
          if (l || !d || !Y.isEdge(t, z, H)) {
            V = !0;
            var K = Fe.extractProps(I);
            t.apply({
              type: "split_node",
              path: H,
              position: N,
              properties: K
            });
          }
          N = H[H.length - 1] + (V || q ? 1 : 0);
        }
        if (n.at == null) {
          var J = h.current || Y.end(t, []);
          Le.select(t, J);
        }
      } finally {
        var te;
        d.unref(), (te = h) === null || te === void 0 || te.unref();
      }
    }
  });
}, FZ = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Array.isArray(n) || (n = [n]);
  var o = {};
  for (var i of n)
    o[i] = null;
  Le.setNodes(t, o, r);
}, zZ = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  Y.withoutNormalizing(t, () => {
    var {
      mode: r = "lowest",
      split: o = !1,
      voids: i = !1
    } = n, {
      at: a = t.selection,
      match: s
    } = n;
    if (a) {
      s == null && (s = se.isPath(a) ? du(t, a) : (h) => Je.isElement(h) && Y.isBlock(t, h)), se.isPath(a) && (a = Y.range(t, a));
      var l = de.isRange(a) ? Y.rangeRef(t, a) : null, u = Y.nodes(t, {
        at: a,
        match: s,
        mode: r,
        voids: i
      }), c = Array.from(
        u,
        (h) => {
          var [, f] = h;
          return Y.pathRef(t, f);
        }
        // unwrapNode will call liftNode which does not support splitting the node when nested.
        // If we do not reverse the order and call it from top to the bottom, it will remove all blocks
        // that wrap target node. So we reverse the order.
      ).reverse(), p = function() {
        var f = d.unref(), [m] = Y.node(t, f), g = Y.range(t, f);
        o && l && (g = de.intersection(l.current, g)), Le.liftNodes(t, {
          at: g,
          match: (E) => Je.isAncestor(m) && m.children.includes(E),
          voids: i
        });
      };
      for (var d of c)
        p();
      l && l.unref();
    }
  });
};
function EL(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function kL(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? EL(Object(n), !0).forEach(function(r) {
      Co(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : EL(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var UZ = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Y.withoutNormalizing(t, () => {
    var {
      mode: o = "lowest",
      split: i = !1,
      voids: a = !1
    } = r, {
      match: s,
      at: l = t.selection
    } = r;
    if (l) {
      if (s == null && (se.isPath(l) ? s = du(t, l) : t.isInline(n) ? s = (g) => Je.isElement(g) && Y.isInline(t, g) || Qe.isText(g) : s = (g) => Je.isElement(g) && Y.isBlock(t, g)), i && de.isRange(l)) {
        var [u, c] = de.edges(l), p = Y.rangeRef(t, l, {
          affinity: "inward"
        });
        Le.splitNodes(t, {
          at: c,
          match: s,
          voids: a
        }), Le.splitNodes(t, {
          at: u,
          match: s,
          voids: a
        }), l = p.unref(), r.at == null && Le.select(t, l);
      }
      var d = Array.from(Y.nodes(t, {
        at: l,
        match: t.isInline(n) ? (g) => Je.isElement(g) && Y.isBlock(t, g) : (g) => Y.isEditor(g),
        mode: "lowest",
        voids: a
      })), h = function() {
        var E = de.isRange(l) ? de.intersection(l, Y.range(t, m)) : l;
        if (!E)
          return 0;
        var w = Array.from(Y.nodes(t, {
          at: E,
          match: s,
          mode: o,
          voids: a
        }));
        if (w.length > 0) {
          var [M] = w, x = w[w.length - 1], [, y] = M, [, C] = x;
          if (y.length === 0 && C.length === 0)
            return 0;
          var P = se.equals(y, C) ? se.parent(y) : se.common(y, C), F = Y.range(t, y, C), L = Y.node(t, P), [N] = L, I = P.length + 1, H = se.next(C.slice(0, I)), V = kL(kL({}, n), {}, {
            children: []
          });
          Le.insertNodes(t, V, {
            at: H,
            voids: a
          }), Le.moveNodes(t, {
            at: F,
            match: (z) => Je.isAncestor(N) && N.children.includes(z),
            to: H.concat(0),
            voids: a
          });
        }
      }, f;
      for (var [, m] of d)
        f = h();
    }
  });
}, $Z = () => {
  var e = {
    children: [],
    operations: [],
    selection: null,
    marks: null,
    isElementReadOnly: () => !1,
    isInline: () => !1,
    isSelectable: () => !0,
    isVoid: () => !1,
    markableVoid: () => !1,
    onChange: () => {
    },
    // Core
    apply: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return dq(e, ...r);
    },
    // Editor
    addMark: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return yq(e, ...r);
    },
    deleteBackward: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Cq(e, ...r);
    },
    deleteForward: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return xq(e, ...r);
    },
    deleteFragment: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Oq(e, ...r);
    },
    getFragment: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return hq(e, ...r);
    },
    insertBreak: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Aq(e, ...r);
    },
    insertSoftBreak: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Iq(e, ...r);
    },
    insertFragment: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return xZ(e, ...r);
    },
    insertNode: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Bq(e, ...r);
    },
    insertText: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Nq(e, ...r);
    },
    normalizeNode: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return gq(e, ...r);
    },
    removeMark: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return hZ(e, ...r);
    },
    getDirtyPaths: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return fq(e, ...r);
    },
    shouldNormalize: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return mq(e, ...r);
    },
    // Editor interface
    above: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return vq(e, ...r);
    },
    after: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return bq(e, ...r);
    },
    before: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return wq(e, ...r);
    },
    collapse: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return OZ(e, ...r);
    },
    delete: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return CZ(e, ...r);
    },
    deselect: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return EZ(e, ...r);
    },
    edges: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Eq(e, ...r);
    },
    elementReadOnly: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return kq(e, ...r);
    },
    end: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Lq(e, ...r);
    },
    first: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return _q(e, ...r);
    },
    fragment: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Pq(e, ...r);
    },
    getMarks: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Kq(e, ...r);
    },
    hasBlocks: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Mq(e, ...r);
    },
    hasInlines: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Dq(e, ...r);
    },
    hasPath: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Tq(e, ...r);
    },
    hasTexts: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return jq(e, ...r);
    },
    insertNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return SZ(e, ...r);
    },
    isBlock: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Fq(e, ...r);
    },
    isEdge: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return zq(e, ...r);
    },
    isEmpty: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Uq(e, ...r);
    },
    isEnd: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return $q(e, ...r);
    },
    isNormalizing: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Hq(e, ...r);
    },
    isStart: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Wq(e, ...r);
    },
    last: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Vq(e, ...r);
    },
    leaf: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return qq(e, ...r);
    },
    levels: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Zq(e, ...r);
    },
    liftNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return MZ(e, ...r);
    },
    mergeNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return jZ(e, ...r);
    },
    move: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return kZ(e, ...r);
    },
    moveNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return AZ(e, ...r);
    },
    next: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Yq(e, ...r);
    },
    node: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Jq(e, ...r);
    },
    nodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Qq(e, ...r);
    },
    normalize: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return eZ(e, ...r);
    },
    parent: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return tZ(e, ...r);
    },
    path: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return oZ(e, ...r);
    },
    pathRef: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return nZ(e, ...r);
    },
    pathRefs: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return rZ(e, ...r);
    },
    point: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return aZ(e, ...r);
    },
    pointRef: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return iZ(e, ...r);
    },
    pointRefs: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return sZ(e, ...r);
    },
    positions: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return lZ(e, ...r);
    },
    previous: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return uZ(e, ...r);
    },
    range: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return dZ(e, ...r);
    },
    rangeRef: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return cZ(e, ...r);
    },
    rangeRefs: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return pZ(e, ...r);
    },
    removeNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return BZ(e, ...r);
    },
    select: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return LZ(e, ...r);
    },
    setNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return IZ(e, ...r);
    },
    setNormalizing: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return gZ(e, ...r);
    },
    setPoint: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return _Z(e, ...r);
    },
    setSelection: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return PZ(e, ...r);
    },
    splitNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return NZ(e, ...r);
    },
    start: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return mZ(e, ...r);
    },
    string: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return vZ(e, ...r);
    },
    unhangRange: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return yZ(e, ...r);
    },
    unsetNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return FZ(e, ...r);
    },
    unwrapNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return zZ(e, ...r);
    },
    void: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Sq(e, ...r);
    },
    withoutNormalizing: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return bZ(e, ...r);
    },
    wrapNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return UZ(e, ...r);
    },
    shouldMergeNodesRemovePrevNode: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return wZ(e, ...r);
    }
  };
  return e;
};
const g$ = (e) => {
  if (Qe.isText(e)) {
    let t = e.text;
    return e.bold && (t = `<strong>${t}</strong>`), e.code && (t = `<code>${t}</code>`), e.italic && (t = `<em>${t}</em>`), e.underline && (t = `<u>${t}</u>`), t;
  }
  if (Je.isElement(e)) {
    const t = e.children.map((r) => g$(r)).join(""), n = e.align || "left";
    switch (e.type) {
      case "image":
        return `<img src="${e.src}" class="align_${n}" />`;
      case "paragraph":
        return `<p class="align_${n}">${t}</p>`;
      case "blockQuote":
        return `<blockquote class="align_${n}">${t}</blockquote>`;
      case "bulletedList":
        return `<ul class="align_${n}">${t}</ul>`;
      case "headingOne":
        return `<h1 class="align_${n}">${t}</h1>`;
      case "headingTwo":
        return `<h2 class="align_${n}">${t}</h2>`;
      case "listItem":
        return `<li class="align_${n}">${t}</li>`;
      case "numberedList":
        return `<ol class="align_${n}">${t}</ol>`;
      default:
        return t;
    }
  }
  return "";
}, cRe = (e) => e.map((t) => g$(t)).join("");
var m$ = {}, uO = {}, cO = {}, Nl = {}, pO = {}, dO = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Doctype = e.CDATA = e.Tag = e.Style = e.Script = e.Comment = e.Directive = e.Text = e.Root = e.isTag = e.ElementType = void 0;
  var t;
  (function(r) {
    r.Root = "root", r.Text = "text", r.Directive = "directive", r.Comment = "comment", r.Script = "script", r.Style = "style", r.Tag = "tag", r.CDATA = "cdata", r.Doctype = "doctype";
  })(t = e.ElementType || (e.ElementType = {}));
  function n(r) {
    return r.type === t.Tag || r.type === t.Script || r.type === t.Style;
  }
  e.isTag = n, e.Root = t.Root, e.Text = t.Text, e.Directive = t.Directive, e.Comment = t.Comment, e.Script = t.Script, e.Style = t.Style, e.Tag = t.Tag, e.CDATA = t.CDATA, e.Doctype = t.Doctype;
})(dO);
var zt = {}, ga = Nn && Nn.__extends || /* @__PURE__ */ function() {
  var e = function(t, n) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, o) {
      r.__proto__ = o;
    } || function(r, o) {
      for (var i in o) Object.prototype.hasOwnProperty.call(o, i) && (r[i] = o[i]);
    }, e(t, n);
  };
  return function(t, n) {
    if (typeof n != "function" && n !== null)
      throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
    e(t, n);
    function r() {
      this.constructor = t;
    }
    t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
  };
}(), Cc = Nn && Nn.__assign || function() {
  return Cc = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) {
      t = arguments[n];
      for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
    }
    return e;
  }, Cc.apply(this, arguments);
};
Object.defineProperty(zt, "__esModule", { value: !0 });
zt.cloneNode = zt.hasChildren = zt.isDocument = zt.isDirective = zt.isComment = zt.isText = zt.isCDATA = zt.isTag = zt.Element = zt.Document = zt.CDATA = zt.NodeWithChildren = zt.ProcessingInstruction = zt.Comment = zt.Text = zt.DataNode = zt.Node = void 0;
var Io = dO, fO = (
  /** @class */
  function() {
    function e() {
      this.parent = null, this.prev = null, this.next = null, this.startIndex = null, this.endIndex = null;
    }
    return Object.defineProperty(e.prototype, "parentNode", {
      // Read-write aliases for properties
      /**
       * Same as {@link parent}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.parent;
      },
      set: function(t) {
        this.parent = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "previousSibling", {
      /**
       * Same as {@link prev}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.prev;
      },
      set: function(t) {
        this.prev = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "nextSibling", {
      /**
       * Same as {@link next}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.next;
      },
      set: function(t) {
        this.next = t;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.cloneNode = function(t) {
      return t === void 0 && (t = !1), hO(this, t);
    }, e;
  }()
);
zt.Node = fO;
var Im = (
  /** @class */
  function(e) {
    ga(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.data = n, r;
    }
    return Object.defineProperty(t.prototype, "nodeValue", {
      /**
       * Same as {@link data}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.data;
      },
      set: function(n) {
        this.data = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(fO)
);
zt.DataNode = Im;
var v$ = (
  /** @class */
  function(e) {
    ga(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Io.ElementType.Text, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 3;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Im)
);
zt.Text = v$;
var y$ = (
  /** @class */
  function(e) {
    ga(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Io.ElementType.Comment, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 8;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Im)
);
zt.Comment = y$;
var b$ = (
  /** @class */
  function(e) {
    ga(t, e);
    function t(n, r) {
      var o = e.call(this, r) || this;
      return o.name = n, o.type = Io.ElementType.Directive, o;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Im)
);
zt.ProcessingInstruction = b$;
var Rm = (
  /** @class */
  function(e) {
    ga(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.children = n, r;
    }
    return Object.defineProperty(t.prototype, "firstChild", {
      // Aliases
      /** First child of the node. */
      get: function() {
        var n;
        return (n = this.children[0]) !== null && n !== void 0 ? n : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "lastChild", {
      /** Last child of the node. */
      get: function() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "childNodes", {
      /**
       * Same as {@link children}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.children;
      },
      set: function(n) {
        this.children = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(fO)
);
zt.NodeWithChildren = Rm;
var w$ = (
  /** @class */
  function(e) {
    ga(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Io.ElementType.CDATA, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 4;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Rm)
);
zt.CDATA = w$;
var C$ = (
  /** @class */
  function(e) {
    ga(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Io.ElementType.Root, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 9;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Rm)
);
zt.Document = C$;
var x$ = (
  /** @class */
  function(e) {
    ga(t, e);
    function t(n, r, o, i) {
      o === void 0 && (o = []), i === void 0 && (i = n === "script" ? Io.ElementType.Script : n === "style" ? Io.ElementType.Style : Io.ElementType.Tag);
      var a = e.call(this, o) || this;
      return a.name = n, a.attribs = r, a.type = i, a;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "tagName", {
      // DOM Level 1 aliases
      /**
       * Same as {@link name}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.name;
      },
      set: function(n) {
        this.name = n;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "attributes", {
      get: function() {
        var n = this;
        return Object.keys(this.attribs).map(function(r) {
          var o, i;
          return {
            name: r,
            value: n.attribs[r],
            namespace: (o = n["x-attribsNamespace"]) === null || o === void 0 ? void 0 : o[r],
            prefix: (i = n["x-attribsPrefix"]) === null || i === void 0 ? void 0 : i[r]
          };
        });
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Rm)
);
zt.Element = x$;
function O$(e) {
  return (0, Io.isTag)(e);
}
zt.isTag = O$;
function E$(e) {
  return e.type === Io.ElementType.CDATA;
}
zt.isCDATA = E$;
function k$(e) {
  return e.type === Io.ElementType.Text;
}
zt.isText = k$;
function L$(e) {
  return e.type === Io.ElementType.Comment;
}
zt.isComment = L$;
function _$(e) {
  return e.type === Io.ElementType.Directive;
}
zt.isDirective = _$;
function P$(e) {
  return e.type === Io.ElementType.Root;
}
zt.isDocument = P$;
function HZ(e) {
  return Object.prototype.hasOwnProperty.call(e, "children");
}
zt.hasChildren = HZ;
function hO(e, t) {
  t === void 0 && (t = !1);
  var n;
  if (k$(e))
    n = new v$(e.data);
  else if (L$(e))
    n = new y$(e.data);
  else if (O$(e)) {
    var r = t ? Xy(e.children) : [], o = new x$(e.name, Cc({}, e.attribs), r);
    r.forEach(function(l) {
      return l.parent = o;
    }), e.namespace != null && (o.namespace = e.namespace), e["x-attribsNamespace"] && (o["x-attribsNamespace"] = Cc({}, e["x-attribsNamespace"])), e["x-attribsPrefix"] && (o["x-attribsPrefix"] = Cc({}, e["x-attribsPrefix"])), n = o;
  } else if (E$(e)) {
    var r = t ? Xy(e.children) : [], i = new w$(r);
    r.forEach(function(u) {
      return u.parent = i;
    }), n = i;
  } else if (P$(e)) {
    var r = t ? Xy(e.children) : [], a = new C$(r);
    r.forEach(function(u) {
      return u.parent = a;
    }), e["x-mode"] && (a["x-mode"] = e["x-mode"]), n = a;
  } else if (_$(e)) {
    var s = new b$(e.name, e.data);
    e["x-name"] != null && (s["x-name"] = e["x-name"], s["x-publicId"] = e["x-publicId"], s["x-systemId"] = e["x-systemId"]), n = s;
  } else
    throw new Error("Not implemented yet: ".concat(e.type));
  return n.startIndex = e.startIndex, n.endIndex = e.endIndex, e.sourceCodeLocation != null && (n.sourceCodeLocation = e.sourceCodeLocation), n;
}
zt.cloneNode = hO;
function Xy(e) {
  for (var t = e.map(function(r) {
    return hO(r, !0);
  }), n = 1; n < t.length; n++)
    t[n].prev = t[n - 1], t[n - 1].next = t[n];
  return t;
}
(function(e) {
  var t = Nn && Nn.__createBinding || (Object.create ? function(s, l, u, c) {
    c === void 0 && (c = u);
    var p = Object.getOwnPropertyDescriptor(l, u);
    (!p || ("get" in p ? !l.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
      return l[u];
    } }), Object.defineProperty(s, c, p);
  } : function(s, l, u, c) {
    c === void 0 && (c = u), s[c] = l[u];
  }), n = Nn && Nn.__exportStar || function(s, l) {
    for (var u in s) u !== "default" && !Object.prototype.hasOwnProperty.call(l, u) && t(l, s, u);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.DomHandler = void 0;
  var r = dO, o = zt;
  n(zt, e);
  var i = {
    withStartIndices: !1,
    withEndIndices: !1,
    xmlMode: !1
  }, a = (
    /** @class */
    function() {
      function s(l, u, c) {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null, typeof u == "function" && (c = u, u = i), typeof l == "object" && (u = l, l = void 0), this.callback = l ?? null, this.options = u ?? i, this.elementCB = c ?? null;
      }
      return s.prototype.onparserinit = function(l) {
        this.parser = l;
      }, s.prototype.onreset = function() {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null;
      }, s.prototype.onend = function() {
        this.done || (this.done = !0, this.parser = null, this.handleCallback(null));
      }, s.prototype.onerror = function(l) {
        this.handleCallback(l);
      }, s.prototype.onclosetag = function() {
        this.lastNode = null;
        var l = this.tagStack.pop();
        this.options.withEndIndices && (l.endIndex = this.parser.endIndex), this.elementCB && this.elementCB(l);
      }, s.prototype.onopentag = function(l, u) {
        var c = this.options.xmlMode ? r.ElementType.Tag : void 0, p = new o.Element(l, u, void 0, c);
        this.addNode(p), this.tagStack.push(p);
      }, s.prototype.ontext = function(l) {
        var u = this.lastNode;
        if (u && u.type === r.ElementType.Text)
          u.data += l, this.options.withEndIndices && (u.endIndex = this.parser.endIndex);
        else {
          var c = new o.Text(l);
          this.addNode(c), this.lastNode = c;
        }
      }, s.prototype.oncomment = function(l) {
        if (this.lastNode && this.lastNode.type === r.ElementType.Comment) {
          this.lastNode.data += l;
          return;
        }
        var u = new o.Comment(l);
        this.addNode(u), this.lastNode = u;
      }, s.prototype.oncommentend = function() {
        this.lastNode = null;
      }, s.prototype.oncdatastart = function() {
        var l = new o.Text(""), u = new o.CDATA([l]);
        this.addNode(u), l.parent = u, this.lastNode = l;
      }, s.prototype.oncdataend = function() {
        this.lastNode = null;
      }, s.prototype.onprocessinginstruction = function(l, u) {
        var c = new o.ProcessingInstruction(l, u);
        this.addNode(c);
      }, s.prototype.handleCallback = function(l) {
        if (typeof this.callback == "function")
          this.callback(l, this.dom);
        else if (l)
          throw l;
      }, s.prototype.addNode = function(l) {
        var u = this.tagStack[this.tagStack.length - 1], c = u.children[u.children.length - 1];
        this.options.withStartIndices && (l.startIndex = this.parser.startIndex), this.options.withEndIndices && (l.endIndex = this.parser.endIndex), u.children.push(l), c && (l.prev = c, c.next = l), l.parent = u, this.lastNode = null;
      }, s;
    }()
  );
  e.DomHandler = a, e.default = a;
})(pO);
var S$ = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CARRIAGE_RETURN_PLACEHOLDER_REGEX = e.CARRIAGE_RETURN_PLACEHOLDER = e.CARRIAGE_RETURN_REGEX = e.CARRIAGE_RETURN = e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES = void 0, e.CASE_SENSITIVE_TAG_NAMES = [
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "linearGradient",
    "radialGradient",
    "textPath"
  ], e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES.reduce(function(t, n) {
    return t[n.toLowerCase()] = n, t;
  }, {}), e.CARRIAGE_RETURN = "\r", e.CARRIAGE_RETURN_REGEX = new RegExp(e.CARRIAGE_RETURN, "g"), e.CARRIAGE_RETURN_PLACEHOLDER = "__HTML_DOM_PARSER_CARRIAGE_RETURN_PLACEHOLDER_".concat(Date.now(), "__"), e.CARRIAGE_RETURN_PLACEHOLDER_REGEX = new RegExp(e.CARRIAGE_RETURN_PLACEHOLDER, "g");
})(S$);
Object.defineProperty(Nl, "__esModule", { value: !0 });
Nl.formatAttributes = M$;
Nl.escapeSpecialCharacters = qZ;
Nl.revertEscapedCharacters = D$;
Nl.formatDOM = T$;
var Dd = pO, Jc = S$;
function WZ(e) {
  return Jc.CASE_SENSITIVE_TAG_NAMES_MAP[e];
}
function M$(e) {
  for (var t = {}, n = 0, r = e.length; n < r; n++) {
    var o = e[n];
    t[o.name] = o.value;
  }
  return t;
}
function VZ(e) {
  e = e.toLowerCase();
  var t = WZ(e);
  return t || e;
}
function qZ(e) {
  return e.replace(Jc.CARRIAGE_RETURN_REGEX, Jc.CARRIAGE_RETURN_PLACEHOLDER);
}
function D$(e) {
  return e.replace(Jc.CARRIAGE_RETURN_PLACEHOLDER_REGEX, Jc.CARRIAGE_RETURN);
}
function T$(e, t, n) {
  t === void 0 && (t = null);
  for (var r = [], o, i = 0, a = e.length; i < a; i++) {
    var s = e[i];
    switch (s.nodeType) {
      case 1: {
        var l = VZ(s.nodeName);
        o = new Dd.Element(l, M$(s.attributes)), o.children = T$(
          // template children are on content
          l === "template" ? s.content.childNodes : s.childNodes,
          o
        );
        break;
      }
      case 3:
        o = new Dd.Text(D$(s.nodeValue));
        break;
      case 8:
        o = new Dd.Comment(s.nodeValue);
        break;
      default:
        continue;
    }
    var u = r[i - 1] || null;
    u && (u.next = o), o.parent = t, o.prev = u, o.next = null, r.push(o);
  }
  return n && (o = new Dd.ProcessingInstruction(n.substring(0, n.indexOf(" ")).toLowerCase(), n), o.next = r[0] || null, o.parent = t, r.unshift(o), r[1] && (r[1].prev = r[0])), r;
}
Object.defineProperty(cO, "__esModule", { value: !0 });
cO.default = YZ;
var ZZ = Nl, LL = "html", _L = "head", Td = "body", GZ = /<([a-zA-Z]+[0-9]?)/, PL = /<head[^]*>/i, SL = /<body[^]*>/i, Vh = function(e, t) {
  throw new Error("This browser does not support `document.implementation.createHTMLDocument`");
}, Zw = function(e, t) {
  throw new Error("This browser does not support `DOMParser.prototype.parseFromString`");
}, ML = typeof window == "object" && window.DOMParser;
if (typeof ML == "function") {
  var XZ = new ML(), KZ = "text/html";
  Zw = function(e, t) {
    return t && (e = "<".concat(t, ">").concat(e, "</").concat(t, ">")), XZ.parseFromString(e, KZ);
  }, Vh = Zw;
}
if (typeof document == "object" && document.implementation) {
  var jd = document.implementation.createHTMLDocument();
  Vh = function(e, t) {
    if (t) {
      var n = jd.documentElement.querySelector(t);
      return n && (n.innerHTML = e), jd;
    }
    return jd.documentElement.innerHTML = e, jd;
  };
}
var Ad = typeof document == "object" && document.createElement("template"), Gw;
Ad && Ad.content && (Gw = function(e) {
  return Ad.innerHTML = e, Ad.content.childNodes;
});
function YZ(e) {
  var t, n;
  e = (0, ZZ.escapeSpecialCharacters)(e);
  var r = e.match(GZ), o = r && r[1] ? r[1].toLowerCase() : "";
  switch (o) {
    case LL: {
      var i = Zw(e);
      if (!PL.test(e)) {
        var a = i.querySelector(_L);
        (t = a == null ? void 0 : a.parentNode) === null || t === void 0 || t.removeChild(a);
      }
      if (!SL.test(e)) {
        var a = i.querySelector(Td);
        (n = a == null ? void 0 : a.parentNode) === null || n === void 0 || n.removeChild(a);
      }
      return i.querySelectorAll(LL);
    }
    case _L:
    case Td: {
      var s = Vh(e).querySelectorAll(o);
      return SL.test(e) && PL.test(e) ? s[0].parentNode.childNodes : s;
    }
    default: {
      if (Gw)
        return Gw(e);
      var a = Vh(e, Td).querySelector(Td);
      return a.childNodes;
    }
  }
}
var JZ = Nn && Nn.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(uO, "__esModule", { value: !0 });
uO.default = nG;
var QZ = JZ(cO), eG = Nl, tG = /<(![a-zA-Z\s]+)>/;
function nG(e) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e)
    return [];
  var t = e.match(tG), n = t ? t[1] : void 0;
  return (0, eG.formatDOM)((0, QZ.default)(e), null, n);
}
var Nm = {}, Si = {}, Fm = {}, rG = 0;
Fm.SAME = rG;
var oG = 1;
Fm.CAMELCASE = oG;
Fm.possibleStandardNames = {
  accept: 0,
  acceptCharset: 1,
  "accept-charset": "acceptCharset",
  accessKey: 1,
  action: 0,
  allowFullScreen: 1,
  alt: 0,
  as: 0,
  async: 0,
  autoCapitalize: 1,
  autoComplete: 1,
  autoCorrect: 1,
  autoFocus: 1,
  autoPlay: 1,
  autoSave: 1,
  capture: 0,
  cellPadding: 1,
  cellSpacing: 1,
  challenge: 0,
  charSet: 1,
  checked: 0,
  children: 0,
  cite: 0,
  class: "className",
  classID: 1,
  className: 1,
  cols: 0,
  colSpan: 1,
  content: 0,
  contentEditable: 1,
  contextMenu: 1,
  controls: 0,
  controlsList: 1,
  coords: 0,
  crossOrigin: 1,
  dangerouslySetInnerHTML: 1,
  data: 0,
  dateTime: 1,
  default: 0,
  defaultChecked: 1,
  defaultValue: 1,
  defer: 0,
  dir: 0,
  disabled: 0,
  disablePictureInPicture: 1,
  disableRemotePlayback: 1,
  download: 0,
  draggable: 0,
  encType: 1,
  enterKeyHint: 1,
  for: "htmlFor",
  form: 0,
  formMethod: 1,
  formAction: 1,
  formEncType: 1,
  formNoValidate: 1,
  formTarget: 1,
  frameBorder: 1,
  headers: 0,
  height: 0,
  hidden: 0,
  high: 0,
  href: 0,
  hrefLang: 1,
  htmlFor: 1,
  httpEquiv: 1,
  "http-equiv": "httpEquiv",
  icon: 0,
  id: 0,
  innerHTML: 1,
  inputMode: 1,
  integrity: 0,
  is: 0,
  itemID: 1,
  itemProp: 1,
  itemRef: 1,
  itemScope: 1,
  itemType: 1,
  keyParams: 1,
  keyType: 1,
  kind: 0,
  label: 0,
  lang: 0,
  list: 0,
  loop: 0,
  low: 0,
  manifest: 0,
  marginWidth: 1,
  marginHeight: 1,
  max: 0,
  maxLength: 1,
  media: 0,
  mediaGroup: 1,
  method: 0,
  min: 0,
  minLength: 1,
  multiple: 0,
  muted: 0,
  name: 0,
  noModule: 1,
  nonce: 0,
  noValidate: 1,
  open: 0,
  optimum: 0,
  pattern: 0,
  placeholder: 0,
  playsInline: 1,
  poster: 0,
  preload: 0,
  profile: 0,
  radioGroup: 1,
  readOnly: 1,
  referrerPolicy: 1,
  rel: 0,
  required: 0,
  reversed: 0,
  role: 0,
  rows: 0,
  rowSpan: 1,
  sandbox: 0,
  scope: 0,
  scoped: 0,
  scrolling: 0,
  seamless: 0,
  selected: 0,
  shape: 0,
  size: 0,
  sizes: 0,
  span: 0,
  spellCheck: 1,
  src: 0,
  srcDoc: 1,
  srcLang: 1,
  srcSet: 1,
  start: 0,
  step: 0,
  style: 0,
  summary: 0,
  tabIndex: 1,
  target: 0,
  title: 0,
  type: 0,
  useMap: 1,
  value: 0,
  width: 0,
  wmode: 0,
  wrap: 0,
  about: 0,
  accentHeight: 1,
  "accent-height": "accentHeight",
  accumulate: 0,
  additive: 0,
  alignmentBaseline: 1,
  "alignment-baseline": "alignmentBaseline",
  allowReorder: 1,
  alphabetic: 0,
  amplitude: 0,
  arabicForm: 1,
  "arabic-form": "arabicForm",
  ascent: 0,
  attributeName: 1,
  attributeType: 1,
  autoReverse: 1,
  azimuth: 0,
  baseFrequency: 1,
  baselineShift: 1,
  "baseline-shift": "baselineShift",
  baseProfile: 1,
  bbox: 0,
  begin: 0,
  bias: 0,
  by: 0,
  calcMode: 1,
  capHeight: 1,
  "cap-height": "capHeight",
  clip: 0,
  clipPath: 1,
  "clip-path": "clipPath",
  clipPathUnits: 1,
  clipRule: 1,
  "clip-rule": "clipRule",
  color: 0,
  colorInterpolation: 1,
  "color-interpolation": "colorInterpolation",
  colorInterpolationFilters: 1,
  "color-interpolation-filters": "colorInterpolationFilters",
  colorProfile: 1,
  "color-profile": "colorProfile",
  colorRendering: 1,
  "color-rendering": "colorRendering",
  contentScriptType: 1,
  contentStyleType: 1,
  cursor: 0,
  cx: 0,
  cy: 0,
  d: 0,
  datatype: 0,
  decelerate: 0,
  descent: 0,
  diffuseConstant: 1,
  direction: 0,
  display: 0,
  divisor: 0,
  dominantBaseline: 1,
  "dominant-baseline": "dominantBaseline",
  dur: 0,
  dx: 0,
  dy: 0,
  edgeMode: 1,
  elevation: 0,
  enableBackground: 1,
  "enable-background": "enableBackground",
  end: 0,
  exponent: 0,
  externalResourcesRequired: 1,
  fill: 0,
  fillOpacity: 1,
  "fill-opacity": "fillOpacity",
  fillRule: 1,
  "fill-rule": "fillRule",
  filter: 0,
  filterRes: 1,
  filterUnits: 1,
  floodOpacity: 1,
  "flood-opacity": "floodOpacity",
  floodColor: 1,
  "flood-color": "floodColor",
  focusable: 0,
  fontFamily: 1,
  "font-family": "fontFamily",
  fontSize: 1,
  "font-size": "fontSize",
  fontSizeAdjust: 1,
  "font-size-adjust": "fontSizeAdjust",
  fontStretch: 1,
  "font-stretch": "fontStretch",
  fontStyle: 1,
  "font-style": "fontStyle",
  fontVariant: 1,
  "font-variant": "fontVariant",
  fontWeight: 1,
  "font-weight": "fontWeight",
  format: 0,
  from: 0,
  fx: 0,
  fy: 0,
  g1: 0,
  g2: 0,
  glyphName: 1,
  "glyph-name": "glyphName",
  glyphOrientationHorizontal: 1,
  "glyph-orientation-horizontal": "glyphOrientationHorizontal",
  glyphOrientationVertical: 1,
  "glyph-orientation-vertical": "glyphOrientationVertical",
  glyphRef: 1,
  gradientTransform: 1,
  gradientUnits: 1,
  hanging: 0,
  horizAdvX: 1,
  "horiz-adv-x": "horizAdvX",
  horizOriginX: 1,
  "horiz-origin-x": "horizOriginX",
  ideographic: 0,
  imageRendering: 1,
  "image-rendering": "imageRendering",
  in2: 0,
  in: 0,
  inlist: 0,
  intercept: 0,
  k1: 0,
  k2: 0,
  k3: 0,
  k4: 0,
  k: 0,
  kernelMatrix: 1,
  kernelUnitLength: 1,
  kerning: 0,
  keyPoints: 1,
  keySplines: 1,
  keyTimes: 1,
  lengthAdjust: 1,
  letterSpacing: 1,
  "letter-spacing": "letterSpacing",
  lightingColor: 1,
  "lighting-color": "lightingColor",
  limitingConeAngle: 1,
  local: 0,
  markerEnd: 1,
  "marker-end": "markerEnd",
  markerHeight: 1,
  markerMid: 1,
  "marker-mid": "markerMid",
  markerStart: 1,
  "marker-start": "markerStart",
  markerUnits: 1,
  markerWidth: 1,
  mask: 0,
  maskContentUnits: 1,
  maskUnits: 1,
  mathematical: 0,
  mode: 0,
  numOctaves: 1,
  offset: 0,
  opacity: 0,
  operator: 0,
  order: 0,
  orient: 0,
  orientation: 0,
  origin: 0,
  overflow: 0,
  overlinePosition: 1,
  "overline-position": "overlinePosition",
  overlineThickness: 1,
  "overline-thickness": "overlineThickness",
  paintOrder: 1,
  "paint-order": "paintOrder",
  panose1: 0,
  "panose-1": "panose1",
  pathLength: 1,
  patternContentUnits: 1,
  patternTransform: 1,
  patternUnits: 1,
  pointerEvents: 1,
  "pointer-events": "pointerEvents",
  points: 0,
  pointsAtX: 1,
  pointsAtY: 1,
  pointsAtZ: 1,
  prefix: 0,
  preserveAlpha: 1,
  preserveAspectRatio: 1,
  primitiveUnits: 1,
  property: 0,
  r: 0,
  radius: 0,
  refX: 1,
  refY: 1,
  renderingIntent: 1,
  "rendering-intent": "renderingIntent",
  repeatCount: 1,
  repeatDur: 1,
  requiredExtensions: 1,
  requiredFeatures: 1,
  resource: 0,
  restart: 0,
  result: 0,
  results: 0,
  rotate: 0,
  rx: 0,
  ry: 0,
  scale: 0,
  security: 0,
  seed: 0,
  shapeRendering: 1,
  "shape-rendering": "shapeRendering",
  slope: 0,
  spacing: 0,
  specularConstant: 1,
  specularExponent: 1,
  speed: 0,
  spreadMethod: 1,
  startOffset: 1,
  stdDeviation: 1,
  stemh: 0,
  stemv: 0,
  stitchTiles: 1,
  stopColor: 1,
  "stop-color": "stopColor",
  stopOpacity: 1,
  "stop-opacity": "stopOpacity",
  strikethroughPosition: 1,
  "strikethrough-position": "strikethroughPosition",
  strikethroughThickness: 1,
  "strikethrough-thickness": "strikethroughThickness",
  string: 0,
  stroke: 0,
  strokeDasharray: 1,
  "stroke-dasharray": "strokeDasharray",
  strokeDashoffset: 1,
  "stroke-dashoffset": "strokeDashoffset",
  strokeLinecap: 1,
  "stroke-linecap": "strokeLinecap",
  strokeLinejoin: 1,
  "stroke-linejoin": "strokeLinejoin",
  strokeMiterlimit: 1,
  "stroke-miterlimit": "strokeMiterlimit",
  strokeWidth: 1,
  "stroke-width": "strokeWidth",
  strokeOpacity: 1,
  "stroke-opacity": "strokeOpacity",
  suppressContentEditableWarning: 1,
  suppressHydrationWarning: 1,
  surfaceScale: 1,
  systemLanguage: 1,
  tableValues: 1,
  targetX: 1,
  targetY: 1,
  textAnchor: 1,
  "text-anchor": "textAnchor",
  textDecoration: 1,
  "text-decoration": "textDecoration",
  textLength: 1,
  textRendering: 1,
  "text-rendering": "textRendering",
  to: 0,
  transform: 0,
  typeof: 0,
  u1: 0,
  u2: 0,
  underlinePosition: 1,
  "underline-position": "underlinePosition",
  underlineThickness: 1,
  "underline-thickness": "underlineThickness",
  unicode: 0,
  unicodeBidi: 1,
  "unicode-bidi": "unicodeBidi",
  unicodeRange: 1,
  "unicode-range": "unicodeRange",
  unitsPerEm: 1,
  "units-per-em": "unitsPerEm",
  unselectable: 0,
  vAlphabetic: 1,
  "v-alphabetic": "vAlphabetic",
  values: 0,
  vectorEffect: 1,
  "vector-effect": "vectorEffect",
  version: 0,
  vertAdvY: 1,
  "vert-adv-y": "vertAdvY",
  vertOriginX: 1,
  "vert-origin-x": "vertOriginX",
  vertOriginY: 1,
  "vert-origin-y": "vertOriginY",
  vHanging: 1,
  "v-hanging": "vHanging",
  vIdeographic: 1,
  "v-ideographic": "vIdeographic",
  viewBox: 1,
  viewTarget: 1,
  visibility: 0,
  vMathematical: 1,
  "v-mathematical": "vMathematical",
  vocab: 0,
  widths: 0,
  wordSpacing: 1,
  "word-spacing": "wordSpacing",
  writingMode: 1,
  "writing-mode": "writingMode",
  x1: 0,
  x2: 0,
  x: 0,
  xChannelSelector: 1,
  xHeight: 1,
  "x-height": "xHeight",
  xlinkActuate: 1,
  "xlink:actuate": "xlinkActuate",
  xlinkArcrole: 1,
  "xlink:arcrole": "xlinkArcrole",
  xlinkHref: 1,
  "xlink:href": "xlinkHref",
  xlinkRole: 1,
  "xlink:role": "xlinkRole",
  xlinkShow: 1,
  "xlink:show": "xlinkShow",
  xlinkTitle: 1,
  "xlink:title": "xlinkTitle",
  xlinkType: 1,
  "xlink:type": "xlinkType",
  xmlBase: 1,
  "xml:base": "xmlBase",
  xmlLang: 1,
  "xml:lang": "xmlLang",
  xmlns: 0,
  "xml:space": "xmlSpace",
  xmlnsXlink: 1,
  "xmlns:xlink": "xmlnsXlink",
  xmlSpace: 1,
  y1: 0,
  y2: 0,
  y: 0,
  yChannelSelector: 1,
  z: 0,
  zoomAndPan: 1
};
const j$ = 0, ma = 1, zm = 2, Um = 3, gO = 4, A$ = 5, B$ = 6;
function iG(e) {
  return so.hasOwnProperty(e) ? so[e] : null;
}
function xo(e, t, n, r, o, i, a) {
  this.acceptsBooleans = t === zm || t === Um || t === gO, this.attributeName = r, this.attributeNamespace = o, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = i, this.removeEmptyString = a;
}
const so = {}, sG = [
  "children",
  "dangerouslySetInnerHTML",
  // TODO: This prevents the assignment of defaultValue to regular
  // elements (not just inputs). Now that ReactDOMInput assigns to the
  // defaultValue property -- do we need this?
  "defaultValue",
  "defaultChecked",
  "innerHTML",
  "suppressContentEditableWarning",
  "suppressHydrationWarning",
  "style"
];
sG.forEach((e) => {
  so[e] = new xo(
    e,
    j$,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"]
].forEach(([e, t]) => {
  so[e] = new xo(
    e,
    ma,
    !1,
    // mustUseProperty
    t,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["contentEditable", "draggable", "spellCheck", "value"].forEach((e) => {
  so[e] = new xo(
    e,
    zm,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha"
].forEach((e) => {
  so[e] = new xo(
    e,
    zm,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "allowFullScreen",
  "async",
  // Note: there is a special case that prevents it from being written to the DOM
  // on the client side because the browsers are inconsistent. Instead we call focus().
  "autoFocus",
  "autoPlay",
  "controls",
  "default",
  "defer",
  "disabled",
  "disablePictureInPicture",
  "disableRemotePlayback",
  "formNoValidate",
  "hidden",
  "loop",
  "noModule",
  "noValidate",
  "open",
  "playsInline",
  "readOnly",
  "required",
  "reversed",
  "scoped",
  "seamless",
  // Microdata
  "itemScope"
].forEach((e) => {
  so[e] = new xo(
    e,
    Um,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "checked",
  // Note: `option.selected` is not updated if `select.multiple` is
  // disabled with `removeAttribute`. We have special logic for handling this.
  "multiple",
  "muted",
  "selected"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  so[e] = new xo(
    e,
    Um,
    !0,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "capture",
  "download"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  so[e] = new xo(
    e,
    gO,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "cols",
  "rows",
  "size",
  "span"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  so[e] = new xo(
    e,
    B$,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["rowSpan", "start"].forEach((e) => {
  so[e] = new xo(
    e,
    A$,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const mO = /[\-\:]([a-z])/g, vO = (e) => e[1].toUpperCase();
[
  "accent-height",
  "alignment-baseline",
  "arabic-form",
  "baseline-shift",
  "cap-height",
  "clip-path",
  "clip-rule",
  "color-interpolation",
  "color-interpolation-filters",
  "color-profile",
  "color-rendering",
  "dominant-baseline",
  "enable-background",
  "fill-opacity",
  "fill-rule",
  "flood-color",
  "flood-opacity",
  "font-family",
  "font-size",
  "font-size-adjust",
  "font-stretch",
  "font-style",
  "font-variant",
  "font-weight",
  "glyph-name",
  "glyph-orientation-horizontal",
  "glyph-orientation-vertical",
  "horiz-adv-x",
  "horiz-origin-x",
  "image-rendering",
  "letter-spacing",
  "lighting-color",
  "marker-end",
  "marker-mid",
  "marker-start",
  "overline-position",
  "overline-thickness",
  "paint-order",
  "panose-1",
  "pointer-events",
  "rendering-intent",
  "shape-rendering",
  "stop-color",
  "stop-opacity",
  "strikethrough-position",
  "strikethrough-thickness",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "text-anchor",
  "text-decoration",
  "text-rendering",
  "underline-position",
  "underline-thickness",
  "unicode-bidi",
  "unicode-range",
  "units-per-em",
  "v-alphabetic",
  "v-hanging",
  "v-ideographic",
  "v-mathematical",
  "vector-effect",
  "vert-adv-y",
  "vert-origin-x",
  "vert-origin-y",
  "word-spacing",
  "writing-mode",
  "xmlns:xlink",
  "x-height"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(mO, vO);
  so[t] = new xo(
    t,
    ma,
    !1,
    // mustUseProperty
    e,
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xlink:actuate",
  "xlink:arcrole",
  "xlink:role",
  "xlink:show",
  "xlink:title",
  "xlink:type"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(mO, vO);
  so[t] = new xo(
    t,
    ma,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/1999/xlink",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xml:base",
  "xml:lang",
  "xml:space"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(mO, vO);
  so[t] = new xo(
    t,
    ma,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/XML/1998/namespace",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["tabIndex", "crossOrigin"].forEach((e) => {
  so[e] = new xo(
    e,
    ma,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const aG = "xlinkHref";
so[aG] = new xo(
  "xlinkHref",
  ma,
  !1,
  // mustUseProperty
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  // sanitizeURL
  !1
  // removeEmptyString
);
["src", "href", "action", "formAction"].forEach((e) => {
  so[e] = new xo(
    e,
    ma,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !0,
    // sanitizeURL
    !0
    // removeEmptyString
  );
});
const {
  CAMELCASE: lG,
  SAME: uG,
  possibleStandardNames: DL
} = Fm, cG = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", pG = cG + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", dG = RegExp.prototype.test.bind(
  // eslint-disable-next-line no-misleading-character-class
  new RegExp("^(data|aria)-[" + pG + "]*$")
), fG = Object.keys(
  DL
).reduce((e, t) => {
  const n = DL[t];
  return n === uG ? e[t] = t : n === lG ? e[t.toLowerCase()] = t : e[t] = n, e;
}, {});
Si.BOOLEAN = Um;
Si.BOOLEANISH_STRING = zm;
Si.NUMERIC = A$;
Si.OVERLOADED_BOOLEAN = gO;
Si.POSITIVE_NUMERIC = B$;
Si.RESERVED = j$;
Si.STRING = ma;
Si.getPropertyInfo = iG;
Si.isCustomAttribute = dG;
Si.possibleStandardNames = fG;
var yO = {}, bO = {}, TL = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, hG = /\n/g, gG = /^\s*/, mG = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, vG = /^:\s*/, yG = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, bG = /^[;\s]*/, wG = /^\s+|\s+$/g, CG = `
`, jL = "/", AL = "*", el = "", xG = "comment", OG = "declaration", EG = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e) return [];
  t = t || {};
  var n = 1, r = 1;
  function o(f) {
    var m = f.match(hG);
    m && (n += m.length);
    var g = f.lastIndexOf(CG);
    r = ~g ? f.length - g : r + f.length;
  }
  function i() {
    var f = { line: n, column: r };
    return function(m) {
      return m.position = new a(f), u(), m;
    };
  }
  function a(f) {
    this.start = f, this.end = { line: n, column: r }, this.source = t.source;
  }
  a.prototype.content = e;
  function s(f) {
    var m = new Error(
      t.source + ":" + n + ":" + r + ": " + f
    );
    if (m.reason = f, m.filename = t.source, m.line = n, m.column = r, m.source = e, !t.silent) throw m;
  }
  function l(f) {
    var m = f.exec(e);
    if (m) {
      var g = m[0];
      return o(g), e = e.slice(g.length), m;
    }
  }
  function u() {
    l(gG);
  }
  function c(f) {
    var m;
    for (f = f || []; m = p(); )
      m !== !1 && f.push(m);
    return f;
  }
  function p() {
    var f = i();
    if (!(jL != e.charAt(0) || AL != e.charAt(1))) {
      for (var m = 2; el != e.charAt(m) && (AL != e.charAt(m) || jL != e.charAt(m + 1)); )
        ++m;
      if (m += 2, el === e.charAt(m - 1))
        return s("End of comment missing");
      var g = e.slice(2, m - 2);
      return r += 2, o(g), e = e.slice(m), r += 2, f({
        type: xG,
        comment: g
      });
    }
  }
  function d() {
    var f = i(), m = l(mG);
    if (m) {
      if (p(), !l(vG)) return s("property missing ':'");
      var g = l(yG), E = f({
        type: OG,
        property: BL(m[0].replace(TL, el)),
        value: g ? BL(g[0].replace(TL, el)) : el
      });
      return l(bG), E;
    }
  }
  function h() {
    var f = [];
    c(f);
    for (var m; m = d(); )
      m !== !1 && (f.push(m), c(f));
    return f;
  }
  return u(), h();
};
function BL(e) {
  return e ? e.replace(wG, el) : el;
}
var kG = Nn && Nn.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(bO, "__esModule", { value: !0 });
bO.default = _G;
var LG = kG(EG);
function _G(e, t) {
  var n = null;
  if (!e || typeof e != "string")
    return n;
  var r = (0, LG.default)(e), o = typeof t == "function";
  return r.forEach(function(i) {
    if (i.type === "declaration") {
      var a = i.property, s = i.value;
      o ? t(a, s, i) : s && (n = n || {}, n[a] = s);
    }
  }), n;
}
var $m = {};
Object.defineProperty($m, "__esModule", { value: !0 });
$m.camelCase = void 0;
var PG = /^--[a-zA-Z0-9_-]+$/, SG = /-([a-z])/g, MG = /^[^-]+$/, DG = /^-(webkit|moz|ms|o|khtml)-/, TG = /^-(ms)-/, jG = function(e) {
  return !e || MG.test(e) || PG.test(e);
}, AG = function(e, t) {
  return t.toUpperCase();
}, IL = function(e, t) {
  return "".concat(t, "-");
}, BG = function(e, t) {
  return t === void 0 && (t = {}), jG(e) ? e : (e = e.toLowerCase(), t.reactCompat ? e = e.replace(TG, IL) : e = e.replace(DG, IL), e.replace(SG, AG));
};
$m.camelCase = BG;
var IG = Nn && Nn.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
}, RG = IG(bO), NG = $m;
function Xw(e, t) {
  var n = {};
  return !e || typeof e != "string" || (0, RG.default)(e, function(r, o) {
    r && o && (n[(0, NG.camelCase)(r, t)] = o);
  }), n;
}
Xw.default = Xw;
var FG = Xw;
(function(e) {
  var t = Nn && Nn.__importDefault || function(c) {
    return c && c.__esModule ? c : { default: c };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.returnFirstArg = e.canTextBeChildOfNode = e.ELEMENTS_WITH_NO_TEXT_CHILDREN = e.PRESERVE_CUSTOM_ATTRIBUTES = void 0, e.isCustomComponent = i, e.setStyleProp = s;
  var n = ke, r = t(FG), o = /* @__PURE__ */ new Set([
    "annotation-xml",
    "color-profile",
    "font-face",
    "font-face-src",
    "font-face-uri",
    "font-face-format",
    "font-face-name",
    "missing-glyph"
  ]);
  function i(c, p) {
    return c.includes("-") ? !o.has(c) : !!(p && typeof p.is == "string");
  }
  var a = {
    reactCompat: !0
  };
  function s(c, p) {
    if (typeof c == "string") {
      if (!c.trim()) {
        p.style = {};
        return;
      }
      try {
        p.style = (0, r.default)(c, a);
      } catch {
        p.style = {};
      }
    }
  }
  e.PRESERVE_CUSTOM_ATTRIBUTES = Number(n.version.split(".")[0]) >= 16, e.ELEMENTS_WITH_NO_TEXT_CHILDREN = /* @__PURE__ */ new Set([
    "tr",
    "tbody",
    "thead",
    "tfoot",
    "colgroup",
    "table",
    "head",
    "html",
    "frameset"
  ]);
  var l = function(c) {
    return !e.ELEMENTS_WITH_NO_TEXT_CHILDREN.has(c.name);
  };
  e.canTextBeChildOfNode = l;
  var u = function(c) {
    return c;
  };
  e.returnFirstArg = u;
})(yO);
Object.defineProperty(Nm, "__esModule", { value: !0 });
Nm.default = HG;
var uc = Si, RL = yO, zG = ["checked", "value"], UG = ["input", "select", "textarea"], $G = {
  reset: !0,
  submit: !0
};
function HG(e, t) {
  e === void 0 && (e = {});
  var n = {}, r = !!(e.type && $G[e.type]);
  for (var o in e) {
    var i = e[o];
    if ((0, uc.isCustomAttribute)(o)) {
      n[o] = i;
      continue;
    }
    var a = o.toLowerCase(), s = NL(a);
    if (s) {
      var l = (0, uc.getPropertyInfo)(s);
      switch (zG.includes(s) && UG.includes(t) && !r && (s = NL("default" + a)), n[s] = i, l && l.type) {
        case uc.BOOLEAN:
          n[s] = !0;
          break;
        case uc.OVERLOADED_BOOLEAN:
          i === "" && (n[s] = !0);
          break;
      }
      continue;
    }
    RL.PRESERVE_CUSTOM_ATTRIBUTES && (n[o] = i);
  }
  return (0, RL.setStyleProp)(e.style, n), n;
}
function NL(e) {
  return uc.possibleStandardNames[e];
}
var wO = {}, WG = Nn && Nn.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(wO, "__esModule", { value: !0 });
wO.default = I$;
var Ky = ke, VG = WG(Nm), xc = yO, qG = {
  cloneElement: Ky.cloneElement,
  createElement: Ky.createElement,
  isValidElement: Ky.isValidElement
};
function I$(e, t) {
  t === void 0 && (t = {});
  for (var n = [], r = typeof t.replace == "function", o = t.transform || xc.returnFirstArg, i = t.library || qG, a = i.cloneElement, s = i.createElement, l = i.isValidElement, u = e.length, c = 0; c < u; c++) {
    var p = e[c];
    if (r) {
      var d = t.replace(p, c);
      if (l(d)) {
        u > 1 && (d = a(d, {
          key: d.key || c
        })), n.push(o(d, p, c));
        continue;
      }
    }
    if (p.type === "text") {
      var h = !p.data.trim().length;
      if (h && p.parent && !(0, xc.canTextBeChildOfNode)(p.parent) || t.trim && h)
        continue;
      n.push(o(p.data, p, c));
      continue;
    }
    var f = p, m = {};
    ZG(f) ? ((0, xc.setStyleProp)(f.attribs.style, f.attribs), m = f.attribs) : f.attribs && (m = (0, VG.default)(f.attribs, f.name));
    var g = void 0;
    switch (p.type) {
      case "script":
      case "style":
        p.children[0] && (m.dangerouslySetInnerHTML = {
          __html: p.children[0].data
        });
        break;
      case "tag":
        p.name === "textarea" && p.children[0] ? m.defaultValue = p.children[0].data : p.children && p.children.length && (g = I$(p.children, t));
        break;
      default:
        continue;
    }
    u > 1 && (m.key = c), n.push(o(s(p.name, m, g), p, c));
  }
  return n.length === 1 ? n[0] : n;
}
function ZG(e) {
  return xc.PRESERVE_CUSTOM_ATTRIBUTES && e.type === "tag" && (0, xc.isCustomComponent)(e.name, e.attribs);
}
(function(e) {
  var t = Nn && Nn.__importDefault || function(l) {
    return l && l.__esModule ? l : { default: l };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.htmlToDOM = e.domToReact = e.attributesToProps = e.Text = e.ProcessingInstruction = e.Element = e.Comment = void 0, e.default = s;
  var n = t(uO);
  e.htmlToDOM = n.default;
  var r = t(Nm);
  e.attributesToProps = r.default;
  var o = t(wO);
  e.domToReact = o.default;
  var i = pO;
  Object.defineProperty(e, "Comment", { enumerable: !0, get: function() {
    return i.Comment;
  } }), Object.defineProperty(e, "Element", { enumerable: !0, get: function() {
    return i.Element;
  } }), Object.defineProperty(e, "ProcessingInstruction", { enumerable: !0, get: function() {
    return i.ProcessingInstruction;
  } }), Object.defineProperty(e, "Text", { enumerable: !0, get: function() {
    return i.Text;
  } });
  var a = { lowerCaseAttributeNames: !1 };
  function s(l, u) {
    if (typeof l != "string")
      throw new TypeError("First argument must be a string");
    return l ? (0, o.default)((0, n.default)(l, (u == null ? void 0 : u.htmlparser2) || a), u) : [];
  }
})(m$);
const FL = /* @__PURE__ */ Dm(m$), GG = FL.default || FL, Kw = (e) => {
  var r;
  if (typeof e == "string")
    return { text: e };
  const t = Array.isArray(e.props.children) ? e.props.children.map((o) => Kw(o)) : [{ text: e.props.children || "" }], n = (r = e.props.className) == null ? void 0 : r.replace("align_", "");
  switch (e.type) {
    case "img":
      return {
        type: "image",
        align: n,
        src: e.props.src,
        children: [{ text: "" }]
      };
    case "p":
      return { type: "paragraph", align: n, children: t };
    case "blockquote":
      return { type: "blockQuote", align: n, children: t };
    case "ul":
      return { type: "bulletedList", align: n, children: t };
    case "ol":
      return { type: "numberedList", align: n, children: t };
    case "li":
      return { type: "listItem", align: n, children: t };
    case "h1":
      return { type: "headingOne", align: n, children: t };
    case "h2":
      return { type: "headingTwo", align: n, children: t };
    case "strong":
      return { text: e.props.children, bold: !0 };
    case "code":
      return { text: e.props.children, code: !0 };
    case "em":
      return { text: e.props.children, italic: !0 };
    case "u":
      return { text: e.props.children, underline: !0 };
    default:
      return { text: e.props.children || "" };
  }
}, pRe = (e) => {
  const t = GG(e);
  return Array.isArray(t) ? t.map((n) => typeof n == "string" ? { text: n } : Kw(n)) : typeof t == "string" ? [{ text: t }] : [Kw(t)];
}, dRe = (e) => /<\/?[a-z][\s\S]*>/i.test(e);
function R$(e, t, n) {
  if (!e) return /* @__PURE__ */ X.jsx(X.Fragment, {});
  if (typeof e == "string") return /* @__PURE__ */ X.jsx("p", { className: n, children: e });
  const r = e;
  return /* @__PURE__ */ X.jsx("p", { className: n, children: /* @__PURE__ */ X.jsx(r, { color: "var(--secondary-600)", size: t, strokeWidth: 2.5 }) });
}
function fRe(e) {
  const {
    variant: t = "ghost",
    scheme: n = "primary",
    size: r = "md",
    leftIcon: o,
    rightIcon: i,
    className: a = "",
    children: s,
    ...l
  } = e, c = { md: 12, lg: 14 }[r], p = `arkynBadge ${t} ${n} ${r} ${a}`;
  return /* @__PURE__ */ X.jsxs("div", { className: p.trim(), ...l, children: [
    Fh(c, o),
    s,
    Fh(c, i)
  ] });
}
function hRe(e) {
  const { className: t, ...n } = e, r = `arkynCard ${t}`;
  return /* @__PURE__ */ X.jsx("div", { className: r.trim(), ...n });
}
function N$(e) {
  const {
    className: t,
    orientation: n = "horizontal",
    ...r
  } = e, o = `arkynDivider ${n} ${t}`;
  return /* @__PURE__ */ X.jsx("div", { className: o.trim(), ...r });
}
function gRe(e) {
  const { className: t, ...n } = e, r = `arkynSkeleton ${t}`;
  return /* @__PURE__ */ X.jsx("aside", { className: r.trim(), ...n });
}
function mRe(e) {
  const {
    emptyMessage: t = "Nenhum dado adicionado.",
    className: n,
    children: r,
    ...o
  } = e, i = `arkynTableBody ${n}`, a = at.count(r) === 0;
  return /* @__PURE__ */ X.jsx("tbody", { className: i.trim(), ...o, children: a ? /* @__PURE__ */ X.jsx("tr", { className: "arkynTableBodyEmptyLine", children: /* @__PURE__ */ X.jsx("td", { colSpan: 100, children: /* @__PURE__ */ X.jsx("div", { children: t }) }) }) : r });
}
function vRe(e) {
  const { className: t, children: n, ...r } = e, o = `arkynTableCaption ${t}`;
  return /* @__PURE__ */ X.jsx("caption", { className: o.trim(), ...r, children: /* @__PURE__ */ X.jsx("div", { className: "arkynTableCaptionContent", children: n }) });
}
function yRe(e) {
  const { children: t, className: n, ...r } = e, o = `arkynTableContainer ${n}`;
  return /* @__PURE__ */ X.jsx("div", { className: o.trim(), ...r, children: /* @__PURE__ */ X.jsx("table", { children: t }) });
}
function bRe(e) {
  const { className: t, children: n, ...r } = e, o = `arkynTableFooter ${t}`;
  return /* @__PURE__ */ X.jsxs("tfoot", { className: o.trim(), ...r, children: [
    /* @__PURE__ */ X.jsx("tr", { className: "spacingRow" }),
    /* @__PURE__ */ X.jsx("tr", { children: /* @__PURE__ */ X.jsx("th", { colSpan: 100, children: /* @__PURE__ */ X.jsx("div", { className: "arkynTableFooterContent", children: n }) }) })
  ] });
}
function wRe(e) {
  const { className: t, children: n, ...r } = e, o = `arkynTableHeader ${t}`;
  return /* @__PURE__ */ X.jsxs("thead", { className: o.trim(), ...r, children: [
    /* @__PURE__ */ X.jsx("tr", { children: n }),
    /* @__PURE__ */ X.jsx("tr", { className: "spacingRow" })
  ] });
}
var Fn = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function XG(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var Yw = { exports: {} }, ju = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var zL;
function KG() {
  if (zL) return ju;
  zL = 1;
  var e = ke, t = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, o = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, i = { key: !0, ref: !0, __self: !0, __source: !0 };
  function a(s, l, u) {
    var c, p = {}, d = null, h = null;
    u !== void 0 && (d = "" + u), l.key !== void 0 && (d = "" + l.key), l.ref !== void 0 && (h = l.ref);
    for (c in l) r.call(l, c) && !i.hasOwnProperty(c) && (p[c] = l[c]);
    if (s && s.defaultProps) for (c in l = s.defaultProps, l) p[c] === void 0 && (p[c] = l[c]);
    return { $$typeof: t, type: s, key: d, ref: h, props: p, _owner: o.current };
  }
  return ju.Fragment = n, ju.jsx = a, ju.jsxs = a, ju;
}
var Bd = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var UL;
function YG() {
  return UL || (UL = 1, process.env.NODE_ENV !== "production" && function() {
    var e = ke, t = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), a = Symbol.for("react.provider"), s = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), c = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), d = Symbol.for("react.lazy"), h = Symbol.for("react.offscreen"), f = Symbol.iterator, m = "@@iterator";
    function g(b) {
      if (b === null || typeof b != "object")
        return null;
      var B = f && b[f] || b[m];
      return typeof B == "function" ? B : null;
    }
    var E = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function w(b) {
      {
        for (var B = arguments.length, G = new Array(B > 1 ? B - 1 : 0), ne = 1; ne < B; ne++)
          G[ne - 1] = arguments[ne];
        M("error", b, G);
      }
    }
    function M(b, B, G) {
      {
        var ne = E.ReactDebugCurrentFrame, le = ne.getStackAddendum();
        le !== "" && (B += "%s", G = G.concat([le]));
        var ce = G.map(function(ae) {
          return String(ae);
        });
        ce.unshift("Warning: " + B), Function.prototype.apply.call(console[b], console, ce);
      }
    }
    var x = !1, y = !1, C = !1, P = !1, F = !1, L;
    L = Symbol.for("react.module.reference");
    function N(b) {
      return !!(typeof b == "string" || typeof b == "function" || b === r || b === i || F || b === o || b === u || b === c || P || b === h || x || y || C || typeof b == "object" && b !== null && (b.$$typeof === d || b.$$typeof === p || b.$$typeof === a || b.$$typeof === s || b.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      b.$$typeof === L || b.getModuleId !== void 0));
    }
    function I(b, B, G) {
      var ne = b.displayName;
      if (ne)
        return ne;
      var le = B.displayName || B.name || "";
      return le !== "" ? G + "(" + le + ")" : G;
    }
    function H(b) {
      return b.displayName || "Context";
    }
    function V(b) {
      if (b == null)
        return null;
      if (typeof b.tag == "number" && w("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof b == "function")
        return b.displayName || b.name || null;
      if (typeof b == "string")
        return b;
      switch (b) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case i:
          return "Profiler";
        case o:
          return "StrictMode";
        case u:
          return "Suspense";
        case c:
          return "SuspenseList";
      }
      if (typeof b == "object")
        switch (b.$$typeof) {
          case s:
            var B = b;
            return H(B) + ".Consumer";
          case a:
            var G = b;
            return H(G._context) + ".Provider";
          case l:
            return I(b, b.render, "ForwardRef");
          case p:
            var ne = b.displayName || null;
            return ne !== null ? ne : V(b.type) || "Memo";
          case d: {
            var le = b, ce = le._payload, ae = le._init;
            try {
              return V(ae(ce));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var z = Object.assign, q = 0, K, J, te, ee, _, D, $;
    function S() {
    }
    S.__reactDisabledLog = !0;
    function W() {
      {
        if (q === 0) {
          K = console.log, J = console.info, te = console.warn, ee = console.error, _ = console.group, D = console.groupCollapsed, $ = console.groupEnd;
          var b = {
            configurable: !0,
            enumerable: !0,
            value: S,
            writable: !0
          };
          Object.defineProperties(console, {
            info: b,
            log: b,
            warn: b,
            error: b,
            group: b,
            groupCollapsed: b,
            groupEnd: b
          });
        }
        q++;
      }
    }
    function O() {
      {
        if (q--, q === 0) {
          var b = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: z({}, b, {
              value: K
            }),
            info: z({}, b, {
              value: J
            }),
            warn: z({}, b, {
              value: te
            }),
            error: z({}, b, {
              value: ee
            }),
            group: z({}, b, {
              value: _
            }),
            groupCollapsed: z({}, b, {
              value: D
            }),
            groupEnd: z({}, b, {
              value: $
            })
          });
        }
        q < 0 && w("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var T = E.ReactCurrentDispatcher, U;
    function j(b, B, G) {
      {
        if (U === void 0)
          try {
            throw Error();
          } catch (le) {
            var ne = le.stack.trim().match(/\n( *(at )?)/);
            U = ne && ne[1] || "";
          }
        return `
` + U + b;
      }
    }
    var Z = !1, A;
    {
      var Q = typeof WeakMap == "function" ? WeakMap : Map;
      A = new Q();
    }
    function R(b, B) {
      if (!b || Z)
        return "";
      {
        var G = A.get(b);
        if (G !== void 0)
          return G;
      }
      var ne;
      Z = !0;
      var le = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var ce;
      ce = T.current, T.current = null, W();
      try {
        if (B) {
          var ae = function() {
            throw Error();
          };
          if (Object.defineProperty(ae.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(ae, []);
            } catch (Ne) {
              ne = Ne;
            }
            Reflect.construct(b, [], ae);
          } else {
            try {
              ae.call();
            } catch (Ne) {
              ne = Ne;
            }
            b.call(ae.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Ne) {
            ne = Ne;
          }
          b();
        }
      } catch (Ne) {
        if (Ne && ne && typeof Ne.stack == "string") {
          for (var ie = Ne.stack.split(`
`), Me = ne.stack.split(`
`), he = ie.length - 1, me = Me.length - 1; he >= 1 && me >= 0 && ie[he] !== Me[me]; )
            me--;
          for (; he >= 1 && me >= 0; he--, me--)
            if (ie[he] !== Me[me]) {
              if (he !== 1 || me !== 1)
                do
                  if (he--, me--, me < 0 || ie[he] !== Me[me]) {
                    var qe = `
` + ie[he].replace(" at new ", " at ");
                    return b.displayName && qe.includes("<anonymous>") && (qe = qe.replace("<anonymous>", b.displayName)), typeof b == "function" && A.set(b, qe), qe;
                  }
                while (he >= 1 && me >= 0);
              break;
            }
        }
      } finally {
        Z = !1, T.current = ce, O(), Error.prepareStackTrace = le;
      }
      var Lt = b ? b.displayName || b.name : "", gt = Lt ? j(Lt) : "";
      return typeof b == "function" && A.set(b, gt), gt;
    }
    function ue(b, B, G) {
      return R(b, !1);
    }
    function fe(b) {
      var B = b.prototype;
      return !!(B && B.isReactComponent);
    }
    function oe(b, B, G) {
      if (b == null)
        return "";
      if (typeof b == "function")
        return R(b, fe(b));
      if (typeof b == "string")
        return j(b);
      switch (b) {
        case u:
          return j("Suspense");
        case c:
          return j("SuspenseList");
      }
      if (typeof b == "object")
        switch (b.$$typeof) {
          case l:
            return ue(b.render);
          case p:
            return oe(b.type, B, G);
          case d: {
            var ne = b, le = ne._payload, ce = ne._init;
            try {
              return oe(ce(le), B, G);
            } catch {
            }
          }
        }
      return "";
    }
    var Re = Object.prototype.hasOwnProperty, He = {}, Ve = E.ReactDebugCurrentFrame;
    function ze(b) {
      if (b) {
        var B = b._owner, G = oe(b.type, b._source, B ? B.type : null);
        Ve.setExtraStackFrame(G);
      } else
        Ve.setExtraStackFrame(null);
    }
    function et(b, B, G, ne, le) {
      {
        var ce = Function.call.bind(Re);
        for (var ae in b)
          if (ce(b, ae)) {
            var ie = void 0;
            try {
              if (typeof b[ae] != "function") {
                var Me = Error((ne || "React class") + ": " + G + " type `" + ae + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof b[ae] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw Me.name = "Invariant Violation", Me;
              }
              ie = b[ae](B, ae, ne, G, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (he) {
              ie = he;
            }
            ie && !(ie instanceof Error) && (ze(le), w("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", ne || "React class", G, ae, typeof ie), ze(null)), ie instanceof Error && !(ie.message in He) && (He[ie.message] = !0, ze(le), w("Failed %s type: %s", G, ie.message), ze(null));
          }
      }
    }
    var Ge = Array.isArray;
    function Pe(b) {
      return Ge(b);
    }
    function Ye(b) {
      {
        var B = typeof Symbol == "function" && Symbol.toStringTag, G = B && b[Symbol.toStringTag] || b.constructor.name || "Object";
        return G;
      }
    }
    function it(b) {
      try {
        return _e(b), !1;
      } catch {
        return !0;
      }
    }
    function _e(b) {
      return "" + b;
    }
    function Se(b) {
      if (it(b))
        return w("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Ye(b)), _e(b);
    }
    var Ke = E.ReactCurrentOwner, We = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, Ue, nt;
    function Ie(b) {
      if (Re.call(b, "ref")) {
        var B = Object.getOwnPropertyDescriptor(b, "ref").get;
        if (B && B.isReactWarning)
          return !1;
      }
      return b.ref !== void 0;
    }
    function xt(b) {
      if (Re.call(b, "key")) {
        var B = Object.getOwnPropertyDescriptor(b, "key").get;
        if (B && B.isReactWarning)
          return !1;
      }
      return b.key !== void 0;
    }
    function ot(b, B) {
      typeof b.ref == "string" && Ke.current;
    }
    function st(b, B) {
      {
        var G = function() {
          Ue || (Ue = !0, w("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", B));
        };
        G.isReactWarning = !0, Object.defineProperty(b, "key", {
          get: G,
          configurable: !0
        });
      }
    }
    function lt(b, B) {
      {
        var G = function() {
          nt || (nt = !0, w("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", B));
        };
        G.isReactWarning = !0, Object.defineProperty(b, "ref", {
          get: G,
          configurable: !0
        });
      }
    }
    var Ot = function(b, B, G, ne, le, ce, ae) {
      var ie = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: b,
        key: B,
        ref: G,
        props: ae,
        // Record the component responsible for creating this element.
        _owner: ce
      };
      return ie._store = {}, Object.defineProperty(ie._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(ie, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ne
      }), Object.defineProperty(ie, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: le
      }), Object.freeze && (Object.freeze(ie.props), Object.freeze(ie)), ie;
    };
    function ut(b, B, G, ne, le) {
      {
        var ce, ae = {}, ie = null, Me = null;
        G !== void 0 && (Se(G), ie = "" + G), xt(B) && (Se(B.key), ie = "" + B.key), Ie(B) && (Me = B.ref, ot(B));
        for (ce in B)
          Re.call(B, ce) && !We.hasOwnProperty(ce) && (ae[ce] = B[ce]);
        if (b && b.defaultProps) {
          var he = b.defaultProps;
          for (ce in he)
            ae[ce] === void 0 && (ae[ce] = he[ce]);
        }
        if (ie || Me) {
          var me = typeof b == "function" ? b.displayName || b.name || "Unknown" : b;
          ie && st(ae, me), Me && lt(ae, me);
        }
        return Ot(b, ie, Me, le, ne, Ke.current, ae);
      }
    }
    var ct = E.ReactCurrentOwner, tt = E.ReactDebugCurrentFrame;
    function Xe(b) {
      if (b) {
        var B = b._owner, G = oe(b.type, b._source, B ? B.type : null);
        tt.setExtraStackFrame(G);
      } else
        tt.setExtraStackFrame(null);
    }
    var Et;
    Et = !1;
    function kt(b) {
      return typeof b == "object" && b !== null && b.$$typeof === t;
    }
    function pt() {
      {
        if (ct.current) {
          var b = V(ct.current.type);
          if (b)
            return `

Check the render method of \`` + b + "`.";
        }
        return "";
      }
    }
    function kn(b) {
      return "";
    }
    var dt = {};
    function Ln(b) {
      {
        var B = pt();
        if (!B) {
          var G = typeof b == "string" ? b : b.displayName || b.name;
          G && (B = `

Check the top-level render call using <` + G + ">.");
        }
        return B;
      }
    }
    function ft(b, B) {
      {
        if (!b._store || b._store.validated || b.key != null)
          return;
        b._store.validated = !0;
        var G = Ln(B);
        if (dt[G])
          return;
        dt[G] = !0;
        var ne = "";
        b && b._owner && b._owner !== ct.current && (ne = " It was passed a child from " + V(b._owner.type) + "."), Xe(b), w('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', G, ne), Xe(null);
      }
    }
    function rn(b, B) {
      {
        if (typeof b != "object")
          return;
        if (Pe(b))
          for (var G = 0; G < b.length; G++) {
            var ne = b[G];
            kt(ne) && ft(ne, B);
          }
        else if (kt(b))
          b._store && (b._store.validated = !0);
        else if (b) {
          var le = g(b);
          if (typeof le == "function" && le !== b.entries)
            for (var ce = le.call(b), ae; !(ae = ce.next()).done; )
              kt(ae.value) && ft(ae.value, B);
        }
      }
    }
    function br(b) {
      {
        var B = b.type;
        if (B == null || typeof B == "string")
          return;
        var G;
        if (typeof B == "function")
          G = B.propTypes;
        else if (typeof B == "object" && (B.$$typeof === l || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        B.$$typeof === p))
          G = B.propTypes;
        else
          return;
        if (G) {
          var ne = V(B);
          et(G, b.props, "prop", ne, b);
        } else if (B.PropTypes !== void 0 && !Et) {
          Et = !0;
          var le = V(B);
          w("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", le || "Unknown");
        }
        typeof B.getDefaultProps == "function" && !B.getDefaultProps.isReactClassApproved && w("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function ht(b) {
      {
        for (var B = Object.keys(b.props), G = 0; G < B.length; G++) {
          var ne = B[G];
          if (ne !== "children" && ne !== "key") {
            Xe(b), w("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", ne), Xe(null);
            break;
          }
        }
        b.ref !== null && (Xe(b), w("Invalid attribute `ref` supplied to `React.Fragment`."), Xe(null));
      }
    }
    var re = {};
    function eo(b, B, G, ne, le, ce) {
      {
        var ae = N(b);
        if (!ae) {
          var ie = "";
          (b === void 0 || typeof b == "object" && b !== null && Object.keys(b).length === 0) && (ie += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var Me = kn();
          Me ? ie += Me : ie += pt();
          var he;
          b === null ? he = "null" : Pe(b) ? he = "array" : b !== void 0 && b.$$typeof === t ? (he = "<" + (V(b.type) || "Unknown") + " />", ie = " Did you accidentally export a JSX literal instead of a component?") : he = typeof b, w("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", he, ie);
        }
        var me = ut(b, B, G, le, ce);
        if (me == null)
          return me;
        if (ae) {
          var qe = B.children;
          if (qe !== void 0)
            if (ne)
              if (Pe(qe)) {
                for (var Lt = 0; Lt < qe.length; Lt++)
                  rn(qe[Lt], b);
                Object.freeze && Object.freeze(qe);
              } else
                w("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              rn(qe, b);
        }
        if (Re.call(B, "key")) {
          var gt = V(b), Ne = Object.keys(B).filter(function(_i) {
            return _i !== "key";
          }), wr = Ne.length > 0 ? "{key: someKey, " + Ne.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!re[gt + wr]) {
            var Li = Ne.length > 0 ? "{" + Ne.join(": ..., ") + ": ...}" : "{}";
            w(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, wr, gt, Li, gt), re[gt + wr] = !0;
          }
        }
        return b === r ? ht(me) : br(me), me;
      }
    }
    function xi(b, B, G) {
      return eo(b, B, G, !0);
    }
    function Oi(b, B, G) {
      return eo(b, B, G, !1);
    }
    var Ei = Oi, ki = xi;
    Bd.Fragment = r, Bd.jsx = Ei, Bd.jsxs = ki;
  }()), Bd;
}
process.env.NODE_ENV === "production" ? Yw.exports = KG() : Yw.exports = YG();
var mn = Yw.exports;
Ze({});
function $L(e, t) {
  return t ? /* @__PURE__ */ mn.jsx(t, { size: e, strokeWidth: 2.5 }) : /* @__PURE__ */ mn.jsx(mn.Fragment, {});
}
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function HL(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function fo(e) {
  var t, n;
  return HL(e) === !1 ? !1 : (t = e.constructor, t === void 0 ? !0 : (n = t.prototype, !(HL(n) === !1 || n.hasOwnProperty("isPrototypeOf") === !1)));
}
var F$ = Symbol.for("immer-nothing"), WL = Symbol.for("immer-draftable"), ti = Symbol.for("immer-state"), JG = process.env.NODE_ENV !== "production" ? [
  // All error codes, starting by 0:
  function(e) {
    return `The plugin for '${e}' has not been loaded into Immer. To enable the plugin, import and call \`enable${e}()\` when initializing your application.`;
  },
  function(e) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${e}'`;
  },
  "This object has been frozen and should not be mutated",
  function(e) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + e;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(e) {
    return `'current' expects a draft, got: ${e}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(e) {
    return `'original' expects a draft, got: ${e}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function Do(e, ...t) {
  if (process.env.NODE_ENV !== "production") {
    const n = JG[e], r = typeof n == "function" ? n.apply(null, t) : n;
    throw new Error(`[Immer] ${r}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var ou = Object.getPrototypeOf;
function Cl(e) {
  return !!e && !!e[ti];
}
function xl(e) {
  var t;
  return e ? z$(e) || Array.isArray(e) || !!e[WL] || !!((t = e.constructor) != null && t[WL]) || Wm(e) || Vm(e) : !1;
}
var QG = Object.prototype.constructor.toString();
function z$(e) {
  if (!e || typeof e != "object")
    return !1;
  const t = ou(e);
  if (t === null)
    return !0;
  const n = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
  return n === Object ? !0 : typeof n == "function" && Function.toString.call(n) === QG;
}
function qh(e, t) {
  Hm(e) === 0 ? Reflect.ownKeys(e).forEach((n) => {
    t(n, e[n], e);
  }) : e.forEach((n, r) => t(r, n, e));
}
function Hm(e) {
  const t = e[ti];
  return t ? t.type_ : Array.isArray(e) ? 1 : Wm(e) ? 2 : Vm(e) ? 3 : 0;
}
function Jw(e, t) {
  return Hm(e) === 2 ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t);
}
function U$(e, t, n) {
  const r = Hm(e);
  r === 2 ? e.set(t, n) : r === 3 ? e.add(n) : e[t] = n;
}
function eX(e, t) {
  return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && t !== t;
}
function Wm(e) {
  return e instanceof Map;
}
function Vm(e) {
  return e instanceof Set;
}
function Ga(e) {
  return e.copy_ || e.base_;
}
function Qw(e, t) {
  if (Wm(e))
    return new Map(e);
  if (Vm(e))
    return new Set(e);
  if (Array.isArray(e))
    return Array.prototype.slice.call(e);
  const n = z$(e);
  if (t === !0 || t === "class_only" && !n) {
    const r = Object.getOwnPropertyDescriptors(e);
    delete r[ti];
    let o = Reflect.ownKeys(r);
    for (let i = 0; i < o.length; i++) {
      const a = o[i], s = r[a];
      s.writable === !1 && (s.writable = !0, s.configurable = !0), (s.get || s.set) && (r[a] = {
        configurable: !0,
        writable: !0,
        // could live with !!desc.set as well here...
        enumerable: s.enumerable,
        value: e[a]
      });
    }
    return Object.create(ou(e), r);
  } else {
    const r = ou(e);
    if (r !== null && n)
      return { ...e };
    const o = Object.create(r);
    return Object.assign(o, e);
  }
}
function CO(e, t = !1) {
  return qm(e) || Cl(e) || !xl(e) || (Hm(e) > 1 && (e.set = e.add = e.clear = e.delete = tX), Object.freeze(e), t && Object.entries(e).forEach(([n, r]) => CO(r, !0))), e;
}
function tX() {
  Do(2);
}
function qm(e) {
  return Object.isFrozen(e);
}
var nX = {};
function Ol(e) {
  const t = nX[e];
  return t || Do(0, e), t;
}
var Qc;
function $$() {
  return Qc;
}
function rX(e, t) {
  return {
    drafts_: [],
    parent_: e,
    immer_: t,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0
  };
}
function VL(e, t) {
  t && (Ol("Patches"), e.patches_ = [], e.inversePatches_ = [], e.patchListener_ = t);
}
function eC(e) {
  tC(e), e.drafts_.forEach(oX), e.drafts_ = null;
}
function tC(e) {
  e === Qc && (Qc = e.parent_);
}
function qL(e) {
  return Qc = rX(Qc, e);
}
function oX(e) {
  const t = e[ti];
  t.type_ === 0 || t.type_ === 1 ? t.revoke_() : t.revoked_ = !0;
}
function ZL(e, t) {
  t.unfinalizedDrafts_ = t.drafts_.length;
  const n = t.drafts_[0];
  return e !== void 0 && e !== n ? (n[ti].modified_ && (eC(t), Do(4)), xl(e) && (e = Zh(t, e), t.parent_ || Gh(t, e)), t.patches_ && Ol("Patches").generateReplacementPatches_(
    n[ti].base_,
    e,
    t.patches_,
    t.inversePatches_
  )) : e = Zh(t, n, []), eC(t), t.patches_ && t.patchListener_(t.patches_, t.inversePatches_), e !== F$ ? e : void 0;
}
function Zh(e, t, n) {
  if (qm(t))
    return t;
  const r = t[ti];
  if (!r)
    return qh(
      t,
      (o, i) => GL(e, r, t, o, i, n)
    ), t;
  if (r.scope_ !== e)
    return t;
  if (!r.modified_)
    return Gh(e, r.base_, !0), r.base_;
  if (!r.finalized_) {
    r.finalized_ = !0, r.scope_.unfinalizedDrafts_--;
    const o = r.copy_;
    let i = o, a = !1;
    r.type_ === 3 && (i = new Set(o), o.clear(), a = !0), qh(
      i,
      (s, l) => GL(e, r, o, s, l, n, a)
    ), Gh(e, o, !1), n && e.patches_ && Ol("Patches").generatePatches_(
      r,
      n,
      e.patches_,
      e.inversePatches_
    );
  }
  return r.copy_;
}
function GL(e, t, n, r, o, i, a) {
  if (process.env.NODE_ENV !== "production" && o === n && Do(5), Cl(o)) {
    const s = i && t && t.type_ !== 3 && // Set objects are atomic since they have no keys.
    !Jw(t.assigned_, r) ? i.concat(r) : void 0, l = Zh(e, o, s);
    if (U$(n, r, l), Cl(l))
      e.canAutoFreeze_ = !1;
    else
      return;
  } else a && n.add(o);
  if (xl(o) && !qm(o)) {
    if (!e.immer_.autoFreeze_ && e.unfinalizedDrafts_ < 1)
      return;
    Zh(e, o), (!t || !t.scope_.parent_) && typeof r != "symbol" && Object.prototype.propertyIsEnumerable.call(n, r) && Gh(e, o);
  }
}
function Gh(e, t, n = !1) {
  !e.parent_ && e.immer_.autoFreeze_ && e.canAutoFreeze_ && CO(t, n);
}
function iX(e, t) {
  const n = Array.isArray(e), r = {
    type_: n ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: t ? t.scope_ : $$(),
    // True for both shallow and deep changes.
    modified_: !1,
    // Used during finalization.
    finalized_: !1,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: t,
    // The base state.
    base_: e,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: !1
  };
  let o = r, i = xO;
  n && (o = [r], i = ep);
  const { revoke: a, proxy: s } = Proxy.revocable(o, i);
  return r.draft_ = s, r.revoke_ = a, s;
}
var xO = {
  get(e, t) {
    if (t === ti)
      return e;
    const n = Ga(e);
    if (!Jw(n, t))
      return sX(e, n, t);
    const r = n[t];
    return e.finalized_ || !xl(r) ? r : r === Yy(e.base_, t) ? (Jy(e), e.copy_[t] = rC(r, e)) : r;
  },
  has(e, t) {
    return t in Ga(e);
  },
  ownKeys(e) {
    return Reflect.ownKeys(Ga(e));
  },
  set(e, t, n) {
    const r = H$(Ga(e), t);
    if (r != null && r.set)
      return r.set.call(e.draft_, n), !0;
    if (!e.modified_) {
      const o = Yy(Ga(e), t), i = o == null ? void 0 : o[ti];
      if (i && i.base_ === n)
        return e.copy_[t] = n, e.assigned_[t] = !1, !0;
      if (eX(n, o) && (n !== void 0 || Jw(e.base_, t)))
        return !0;
      Jy(e), nC(e);
    }
    return e.copy_[t] === n && // special case: handle new props with value 'undefined'
    (n !== void 0 || t in e.copy_) || // special case: NaN
    Number.isNaN(n) && Number.isNaN(e.copy_[t]) || (e.copy_[t] = n, e.assigned_[t] = !0), !0;
  },
  deleteProperty(e, t) {
    return Yy(e.base_, t) !== void 0 || t in e.base_ ? (e.assigned_[t] = !1, Jy(e), nC(e)) : delete e.assigned_[t], e.copy_ && delete e.copy_[t], !0;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(e, t) {
    const n = Ga(e), r = Reflect.getOwnPropertyDescriptor(n, t);
    return r && {
      writable: !0,
      configurable: e.type_ !== 1 || t !== "length",
      enumerable: r.enumerable,
      value: n[t]
    };
  },
  defineProperty() {
    Do(11);
  },
  getPrototypeOf(e) {
    return ou(e.base_);
  },
  setPrototypeOf() {
    Do(12);
  }
}, ep = {};
qh(xO, (e, t) => {
  ep[e] = function() {
    return arguments[0] = arguments[0][0], t.apply(this, arguments);
  };
});
ep.deleteProperty = function(e, t) {
  return process.env.NODE_ENV !== "production" && isNaN(parseInt(t)) && Do(13), ep.set.call(this, e, t, void 0);
};
ep.set = function(e, t, n) {
  return process.env.NODE_ENV !== "production" && t !== "length" && isNaN(parseInt(t)) && Do(14), xO.set.call(this, e[0], t, n, e[0]);
};
function Yy(e, t) {
  const n = e[ti];
  return (n ? Ga(n) : e)[t];
}
function sX(e, t, n) {
  var r;
  const o = H$(t, n);
  return o ? "value" in o ? o.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (r = o.get) == null ? void 0 : r.call(e.draft_)
  ) : void 0;
}
function H$(e, t) {
  if (!(t in e))
    return;
  let n = ou(e);
  for (; n; ) {
    const r = Object.getOwnPropertyDescriptor(n, t);
    if (r)
      return r;
    n = ou(n);
  }
}
function nC(e) {
  e.modified_ || (e.modified_ = !0, e.parent_ && nC(e.parent_));
}
function Jy(e) {
  e.copy_ || (e.copy_ = Qw(
    e.base_,
    e.scope_.immer_.useStrictShallowCopy_
  ));
}
var aX = class {
  constructor(e) {
    this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.produce = (t, n, r) => {
      if (typeof t == "function" && typeof n != "function") {
        const i = n;
        n = t;
        const a = this;
        return function(s = i, ...l) {
          return a.produce(s, (u) => n.call(this, u, ...l));
        };
      }
      typeof n != "function" && Do(6), r !== void 0 && typeof r != "function" && Do(7);
      let o;
      if (xl(t)) {
        const i = qL(this), a = rC(t, void 0);
        let s = !0;
        try {
          o = n(a), s = !1;
        } finally {
          s ? eC(i) : tC(i);
        }
        return VL(i, r), ZL(o, i);
      } else if (!t || typeof t != "object") {
        if (o = n(t), o === void 0 && (o = t), o === F$ && (o = void 0), this.autoFreeze_ && CO(o, !0), r) {
          const i = [], a = [];
          Ol("Patches").generateReplacementPatches_(t, o, i, a), r(i, a);
        }
        return o;
      } else
        Do(1, t);
    }, this.produceWithPatches = (t, n) => {
      if (typeof t == "function")
        return (i, ...a) => this.produceWithPatches(i, (s) => t(s, ...a));
      let r, o;
      return [this.produce(t, n, (i, a) => {
        r = i, o = a;
      }), r, o];
    }, typeof (e == null ? void 0 : e.autoFreeze) == "boolean" && this.setAutoFreeze(e.autoFreeze), typeof (e == null ? void 0 : e.useStrictShallowCopy) == "boolean" && this.setUseStrictShallowCopy(e.useStrictShallowCopy);
  }
  createDraft(e) {
    xl(e) || Do(8), Cl(e) && (e = lX(e));
    const t = qL(this), n = rC(e, void 0);
    return n[ti].isManual_ = !0, tC(t), n;
  }
  finishDraft(e, t) {
    const n = e && e[ti];
    (!n || !n.isManual_) && Do(9);
    const { scope_: r } = n;
    return VL(r, t), ZL(void 0, r);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(e) {
    this.autoFreeze_ = e;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(e) {
    this.useStrictShallowCopy_ = e;
  }
  applyPatches(e, t) {
    let n;
    for (n = t.length - 1; n >= 0; n--) {
      const o = t[n];
      if (o.path.length === 0 && o.op === "replace") {
        e = o.value;
        break;
      }
    }
    n > -1 && (t = t.slice(n + 1));
    const r = Ol("Patches").applyPatches_;
    return Cl(e) ? r(e, t) : this.produce(
      e,
      (o) => r(o, t)
    );
  }
};
function rC(e, t) {
  const n = Wm(e) ? Ol("MapSet").proxyMap_(e, t) : Vm(e) ? Ol("MapSet").proxySet_(e, t) : iX(e, t);
  return (t ? t.scope_ : $$()).drafts_.push(n), n;
}
function lX(e) {
  return Cl(e) || Do(10, e), W$(e);
}
function W$(e) {
  if (!xl(e) || qm(e))
    return e;
  const t = e[ti];
  let n;
  if (t) {
    if (!t.modified_)
      return t.base_;
    t.finalized_ = !0, n = Qw(e, t.scope_.immer_.useStrictShallowCopy_);
  } else
    n = Qw(e, !0);
  return qh(n, (r, o) => {
    U$(n, r, W$(o));
  }), t && (t.finalized_ = !1), n;
}
var ni = new aX(), OO = ni.produce;
ni.produceWithPatches.bind(
  ni
);
ni.setAutoFreeze.bind(ni);
ni.setUseStrictShallowCopy.bind(ni);
ni.applyPatches.bind(ni);
var XL = ni.createDraft.bind(ni), KL = ni.finishDraft.bind(ni), De = {
  ancestors(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = De.levels(e, t);
    return n ? r = r.slice(1) : r = r.slice(0, -1), r;
  },
  common(e, t) {
    for (var n = [], r = 0; r < e.length && r < t.length; r++) {
      var o = e[r], i = t[r];
      if (o !== i)
        break;
      n.push(o);
    }
    return n;
  },
  compare(e, t) {
    for (var n = Math.min(e.length, t.length), r = 0; r < n; r++) {
      if (e[r] < t[r]) return -1;
      if (e[r] > t[r]) return 1;
    }
    return 0;
  },
  endsAfter(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return De.equals(r, o) && i > a;
  },
  endsAt(e, t) {
    var n = e.length, r = e.slice(0, n), o = t.slice(0, n);
    return De.equals(r, o);
  },
  endsBefore(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return De.equals(r, o) && i < a;
  },
  equals(e, t) {
    return e.length === t.length && e.every((n, r) => n === t[r]);
  },
  hasPrevious(e) {
    return e[e.length - 1] > 0;
  },
  isAfter(e, t) {
    return De.compare(e, t) === 1;
  },
  isAncestor(e, t) {
    return e.length < t.length && De.compare(e, t) === 0;
  },
  isBefore(e, t) {
    return De.compare(e, t) === -1;
  },
  isChild(e, t) {
    return e.length === t.length + 1 && De.compare(e, t) === 0;
  },
  isCommon(e, t) {
    return e.length <= t.length && De.compare(e, t) === 0;
  },
  isDescendant(e, t) {
    return e.length > t.length && De.compare(e, t) === 0;
  },
  isParent(e, t) {
    return e.length + 1 === t.length && De.compare(e, t) === 0;
  },
  isPath(e) {
    return Array.isArray(e) && (e.length === 0 || typeof e[0] == "number");
  },
  isSibling(e, t) {
    if (e.length !== t.length)
      return !1;
    var n = e.slice(0, -1), r = t.slice(0, -1), o = e[e.length - 1], i = t[t.length - 1];
    return o !== i && De.equals(n, r);
  },
  levels(e) {
    for (var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = [], o = 0; o <= e.length; o++)
      r.push(e.slice(0, o));
    return n && r.reverse(), r;
  },
  next(e) {
    if (e.length === 0)
      throw new Error("Cannot get the next path of a root path [".concat(e, "], because it has no next index."));
    var t = e[e.length - 1];
    return e.slice(0, -1).concat(t + 1);
  },
  operationCanTransformPath(e) {
    switch (e.type) {
      case "insert_node":
      case "remove_node":
      case "merge_node":
      case "split_node":
      case "move_node":
        return !0;
      default:
        return !1;
    }
  },
  parent(e) {
    if (e.length === 0)
      throw new Error("Cannot get the parent path of the root path [".concat(e, "]."));
    return e.slice(0, -1);
  },
  previous(e) {
    if (e.length === 0)
      throw new Error("Cannot get the previous path of a root path [".concat(e, "], because it has no previous index."));
    var t = e[e.length - 1];
    if (t <= 0)
      throw new Error("Cannot get the previous path of a first child path [".concat(e, "] because it would result in a negative index."));
    return e.slice(0, -1).concat(t - 1);
  },
  relative(e, t) {
    if (!De.isAncestor(t, e) && !De.equals(e, t))
      throw new Error("Cannot get the relative path of [".concat(e, "] inside ancestor [").concat(t, "], because it is not above or equal to the path."));
    return e.slice(t.length);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!e) return null;
    var r = [...e], {
      affinity: o = "forward"
    } = n;
    if (e.length === 0)
      return r;
    switch (t.type) {
      case "insert_node": {
        var {
          path: i
        } = t;
        (De.equals(i, r) || De.endsBefore(i, r) || De.isAncestor(i, r)) && (r[i.length - 1] += 1);
        break;
      }
      case "remove_node": {
        var {
          path: a
        } = t;
        if (De.equals(a, r) || De.isAncestor(a, r))
          return null;
        De.endsBefore(a, r) && (r[a.length - 1] -= 1);
        break;
      }
      case "merge_node": {
        var {
          path: s,
          position: l
        } = t;
        De.equals(s, r) || De.endsBefore(s, r) ? r[s.length - 1] -= 1 : De.isAncestor(s, r) && (r[s.length - 1] -= 1, r[s.length] += l);
        break;
      }
      case "split_node": {
        var {
          path: u,
          position: c
        } = t;
        if (De.equals(u, r)) {
          if (o === "forward")
            r[r.length - 1] += 1;
          else if (o !== "backward") return null;
        } else De.endsBefore(u, r) ? r[u.length - 1] += 1 : De.isAncestor(u, r) && e[u.length] >= c && (r[u.length - 1] += 1, r[u.length] -= c);
        break;
      }
      case "move_node": {
        var {
          path: p,
          newPath: d
        } = t;
        if (De.equals(p, d))
          return r;
        if (De.isAncestor(p, r) || De.equals(p, r)) {
          var h = d.slice();
          return De.endsBefore(p, d) && p.length < d.length && (h[p.length - 1] -= 1), h.concat(r.slice(p.length));
        } else De.isSibling(p, d) && (De.isAncestor(d, r) || De.equals(d, r)) ? De.endsBefore(p, r) ? r[p.length - 1] -= 1 : r[p.length - 1] += 1 : De.endsBefore(d, r) || De.equals(d, r) || De.isAncestor(d, r) ? (De.endsBefore(p, r) && (r[p.length - 1] -= 1), r[d.length - 1] += 1) : De.endsBefore(p, r) && (De.equals(d, r) && (r[d.length - 1] += 1), r[p.length - 1] -= 1);
        break;
      }
    }
    return r;
  }
};
function tp(e) {
  "@babel/helpers - typeof";
  return tp = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, tp(e);
}
function uX(e, t) {
  if (tp(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (tp(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function cX(e) {
  var t = uX(e, "string");
  return tp(t) === "symbol" ? t : String(t);
}
function fu(e, t, n) {
  return t = cX(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function YL(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Au(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? YL(Object(n), !0).forEach(function(r) {
      fu(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : YL(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var pX = (e, t, n) => {
  switch (n.type) {
    case "insert_node": {
      var {
        path: r,
        node: o
      } = n, i = vt.parent(e, r), a = r[r.length - 1];
      if (a > i.children.length)
        throw new Error('Cannot apply an "insert_node" operation at path ['.concat(r, "] because the destination is past the end of the node."));
      if (i.children.splice(a, 0, o), t)
        for (var [s, l] of At.points(t))
          t[l] = Xn.transform(s, n);
      break;
    }
    case "insert_text": {
      var {
        path: u,
        offset: c,
        text: p
      } = n;
      if (p.length === 0) break;
      var d = vt.leaf(e, u), h = d.text.slice(0, c), f = d.text.slice(c);
      if (d.text = h + p + f, t)
        for (var [m, g] of At.points(t))
          t[g] = Xn.transform(m, n);
      break;
    }
    case "merge_node": {
      var {
        path: E
      } = n, w = vt.get(e, E), M = De.previous(E), x = vt.get(e, M), y = vt.parent(e, E), C = E[E.length - 1];
      if (Ar.isText(w) && Ar.isText(x))
        x.text += w.text;
      else if (!Ar.isText(w) && !Ar.isText(x))
        x.children.push(...w.children);
      else
        throw new Error('Cannot apply a "merge_node" operation at path ['.concat(E, "] to nodes of different interfaces: ").concat($o.stringify(w), " ").concat($o.stringify(x)));
      if (y.children.splice(C, 1), t)
        for (var [P, F] of At.points(t))
          t[F] = Xn.transform(P, n);
      break;
    }
    case "move_node": {
      var {
        path: L,
        newPath: N
      } = n;
      if (De.isAncestor(L, N))
        throw new Error("Cannot move a path [".concat(L, "] to new path [").concat(N, "] because the destination is inside itself."));
      var I = vt.get(e, L), H = vt.parent(e, L), V = L[L.length - 1];
      H.children.splice(V, 1);
      var z = De.transform(L, n), q = vt.get(e, De.parent(z)), K = z[z.length - 1];
      if (q.children.splice(K, 0, I), t)
        for (var [J, te] of At.points(t))
          t[te] = Xn.transform(J, n);
      break;
    }
    case "remove_node": {
      var {
        path: ee
      } = n, _ = ee[ee.length - 1], D = vt.parent(e, ee);
      if (D.children.splice(_, 1), t)
        for (var [$, S] of At.points(t)) {
          var W = Xn.transform($, n);
          if (t != null && W != null)
            t[S] = W;
          else {
            var O = void 0, T = void 0;
            for (var [U, j] of vt.texts(e))
              if (De.compare(j, ee) === -1)
                O = [U, j];
              else {
                T = [U, j];
                break;
              }
            var Z = !1;
            O && T && (De.equals(T[1], ee) ? Z = !De.hasPrevious(T[1]) : Z = De.common(O[1], ee).length < De.common(T[1], ee).length), O && !Z ? ($.path = O[1], $.offset = O[0].text.length) : T ? ($.path = T[1], $.offset = 0) : t = null;
          }
        }
      break;
    }
    case "remove_text": {
      var {
        path: A,
        offset: Q,
        text: R
      } = n;
      if (R.length === 0) break;
      var ue = vt.leaf(e, A), fe = ue.text.slice(0, Q), oe = ue.text.slice(Q + R.length);
      if (ue.text = fe + oe, t)
        for (var [Re, He] of At.points(t))
          t[He] = Xn.transform(Re, n);
      break;
    }
    case "set_node": {
      var {
        path: Ve,
        properties: ze,
        newProperties: et
      } = n;
      if (Ve.length === 0)
        throw new Error("Cannot set properties on the root node!");
      var Ge = vt.get(e, Ve);
      for (var Pe in et) {
        if (Pe === "children" || Pe === "text")
          throw new Error('Cannot set the "'.concat(Pe, '" property of nodes!'));
        var Ye = et[Pe];
        Ye == null ? delete Ge[Pe] : Ge[Pe] = Ye;
      }
      for (var it in ze)
        et.hasOwnProperty(it) || delete Ge[it];
      break;
    }
    case "set_selection": {
      var {
        newProperties: _e
      } = n;
      if (_e == null)
        t = _e;
      else {
        if (t == null) {
          if (!At.isRange(_e))
            throw new Error('Cannot apply an incomplete "set_selection" operation properties '.concat($o.stringify(_e), " when there is no current selection."));
          t = Au({}, _e);
        }
        for (var Se in _e) {
          var Ke = _e[Se];
          if (Ke == null) {
            if (Se === "anchor" || Se === "focus")
              throw new Error('Cannot remove the "'.concat(Se, '" selection property'));
            delete t[Se];
          } else
            t[Se] = Ke;
        }
      }
      break;
    }
    case "split_node": {
      var {
        path: We,
        position: Ue,
        properties: nt
      } = n;
      if (We.length === 0)
        throw new Error('Cannot apply a "split_node" operation at path ['.concat(We, "] because the root node cannot be split."));
      var Ie = vt.get(e, We), xt = vt.parent(e, We), ot = We[We.length - 1], st;
      if (Ar.isText(Ie)) {
        var lt = Ie.text.slice(0, Ue), Ot = Ie.text.slice(Ue);
        Ie.text = lt, st = Au(Au({}, nt), {}, {
          text: Ot
        });
      } else {
        var ut = Ie.children.slice(0, Ue), ct = Ie.children.slice(Ue);
        Ie.children = ut, st = Au(Au({}, nt), {}, {
          children: ct
        });
      }
      if (xt.children.splice(ot + 1, 0, st), t)
        for (var [tt, Xe] of At.points(t))
          t[Xe] = Xn.transform(tt, n);
      break;
    }
  }
  return t;
}, dX = {
  transform(e, t) {
    e.children = XL(e.children);
    var n = e.selection && XL(e.selection);
    try {
      n = pX(e, n, t);
    } finally {
      e.children = KL(e.children), n ? e.selection = Cl(n) ? KL(n) : n : e.selection = null;
    }
  }
}, fX = {
  insertNodes(e, t, n) {
    e.insertNodes(t, n);
  },
  liftNodes(e, t) {
    e.liftNodes(t);
  },
  mergeNodes(e, t) {
    e.mergeNodes(t);
  },
  moveNodes(e, t) {
    e.moveNodes(t);
  },
  removeNodes(e, t) {
    e.removeNodes(t);
  },
  setNodes(e, t, n) {
    e.setNodes(t, n);
  },
  splitNodes(e, t) {
    e.splitNodes(t);
  },
  unsetNodes(e, t, n) {
    e.unsetNodes(t, n);
  },
  unwrapNodes(e, t) {
    e.unwrapNodes(t);
  },
  wrapNodes(e, t, n) {
    e.wrapNodes(t, n);
  }
}, hX = {
  collapse(e, t) {
    e.collapse(t);
  },
  deselect(e) {
    e.deselect();
  },
  move(e, t) {
    e.move(t);
  },
  select(e, t) {
    e.select(t);
  },
  setPoint(e, t, n) {
    e.setPoint(t, n);
  },
  setSelection(e, t) {
    e.setSelection(t);
  }
}, V$ = (e, t) => {
  for (var n in e) {
    var r = e[n], o = t[n];
    if (fo(r) && fo(o)) {
      if (!V$(r, o)) return !1;
    } else if (Array.isArray(r) && Array.isArray(o)) {
      if (r.length !== o.length) return !1;
      for (var i = 0; i < r.length; i++)
        if (r[i] !== o[i]) return !1;
    } else if (r !== o)
      return !1;
  }
  for (var a in t)
    if (e[a] === void 0 && t[a] !== void 0)
      return !1;
  return !0;
};
function gX(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), o, i;
  for (i = 0; i < r.length; i++)
    o = r[i], !(t.indexOf(o) >= 0) && (n[o] = e[o]);
  return n;
}
function np(e, t) {
  if (e == null) return {};
  var n = gX(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (o = 0; o < i.length; o++)
      r = i[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
var mX = ["anchor", "focus"];
function JL(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function vX(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? JL(Object(n), !0).forEach(function(r) {
      fu(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : JL(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var At = {
  edges(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, {
      anchor: r,
      focus: o
    } = e;
    return At.isBackward(e) === n ? [r, o] : [o, r];
  },
  end(e) {
    var [, t] = At.edges(e);
    return t;
  },
  equals(e, t) {
    return Xn.equals(e.anchor, t.anchor) && Xn.equals(e.focus, t.focus);
  },
  includes(e, t) {
    if (At.isRange(t)) {
      if (At.includes(e, t.anchor) || At.includes(e, t.focus))
        return !0;
      var [n, r] = At.edges(e), [o, i] = At.edges(t);
      return Xn.isBefore(n, o) && Xn.isAfter(r, i);
    }
    var [a, s] = At.edges(e), l = !1, u = !1;
    return Xn.isPoint(t) ? (l = Xn.compare(t, a) >= 0, u = Xn.compare(t, s) <= 0) : (l = De.compare(t, a.path) >= 0, u = De.compare(t, s.path) <= 0), l && u;
  },
  intersection(e, t) {
    var n = np(e, mX), [r, o] = At.edges(e), [i, a] = At.edges(t), s = Xn.isBefore(r, i) ? i : r, l = Xn.isBefore(o, a) ? o : a;
    return Xn.isBefore(l, s) ? null : vX({
      anchor: s,
      focus: l
    }, n);
  },
  isBackward(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return Xn.isAfter(t, n);
  },
  isCollapsed(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return Xn.equals(t, n);
  },
  isExpanded(e) {
    return !At.isCollapsed(e);
  },
  isForward(e) {
    return !At.isBackward(e);
  },
  isRange(e) {
    return fo(e) && Xn.isPoint(e.anchor) && Xn.isPoint(e.focus);
  },
  *points(e) {
    yield [e.anchor, "anchor"], yield [e.focus, "focus"];
  },
  start(e) {
    var [t] = At.edges(e);
    return t;
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return OO(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "inward"
      } = n, i, a;
      if (o === "inward") {
        var s = At.isCollapsed(r);
        At.isForward(r) ? (i = "forward", a = s ? i : "backward") : (i = "backward", a = s ? i : "forward");
      } else o === "outward" ? At.isForward(r) ? (i = "backward", a = "forward") : (i = "forward", a = "backward") : (i = o, a = o);
      var l = Xn.transform(r.anchor, t, {
        affinity: i
      }), u = Xn.transform(r.focus, t, {
        affinity: a
      });
      if (!l || !u)
        return null;
      r.anchor = l, r.focus = u;
    });
  }
}, QL = (e) => fo(e) && vt.isNodeList(e.children) && !jn.isEditor(e), fs = {
  isAncestor(e) {
    return fo(e) && vt.isNodeList(e.children);
  },
  isElement: QL,
  isElementList(e) {
    return Array.isArray(e) && e.every((t) => fs.isElement(t));
  },
  isElementProps(e) {
    return e.children !== void 0;
  },
  isElementType: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "type";
    return QL(e) && e[n] === t;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "children" && e[n] !== t[n])
        return !1;
    return !0;
  }
}, yX = ["children"], bX = ["text"], e_ = /* @__PURE__ */ new WeakMap(), vt = {
  ancestor(e, t) {
    var n = vt.get(e, t);
    if (Ar.isText(n))
      throw new Error("Cannot get the ancestor node at path [".concat(t, "] because it refers to a text node instead: ").concat($o.stringify(n)));
    return n;
  },
  ancestors(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of De.ancestors(t, n)) {
        var o = vt.ancestor(e, r), i = [o, r];
        yield i;
      }
    }();
  },
  child(e, t) {
    if (Ar.isText(e))
      throw new Error("Cannot get the child of a text node: ".concat($o.stringify(e)));
    var n = e.children[t];
    if (n == null)
      throw new Error("Cannot get child at index `".concat(t, "` in node: ").concat($o.stringify(e)));
    return n;
  },
  children(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var {
        reverse: r = !1
      } = n, o = vt.ancestor(e, t), {
        children: i
      } = o, a = r ? i.length - 1 : 0; r ? a >= 0 : a < i.length; ) {
        var s = vt.child(o, a), l = t.concat(a);
        yield [s, l], a = r ? a - 1 : a + 1;
      }
    }();
  },
  common(e, t, n) {
    var r = De.common(t, n), o = vt.get(e, r);
    return [o, r];
  },
  descendant(e, t) {
    var n = vt.get(e, t);
    if (jn.isEditor(n))
      throw new Error("Cannot get the descendant node at path [".concat(t, "] because it refers to the root editor node instead: ").concat($o.stringify(n)));
    return n;
  },
  descendants(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of vt.nodes(e, t))
        r.length !== 0 && (yield [n, r]);
    }();
  },
  elements(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of vt.nodes(e, t))
        fs.isElement(n) && (yield [n, r]);
    }();
  },
  extractProps(e) {
    if (fs.isAncestor(e)) {
      var t = np(e, yX);
      return t;
    } else {
      var t = np(e, bX);
      return t;
    }
  },
  first(e, t) {
    for (var n = t.slice(), r = vt.get(e, n); r && !(Ar.isText(r) || r.children.length === 0); )
      r = r.children[0], n.push(0);
    return [r, n];
  },
  fragment(e, t) {
    if (Ar.isText(e))
      throw new Error("Cannot get a fragment starting from a root text node: ".concat($o.stringify(e)));
    var n = OO({
      children: e.children
    }, (r) => {
      var [o, i] = At.edges(t), a = vt.nodes(r, {
        reverse: !0,
        pass: (d) => {
          var [, h] = d;
          return !At.includes(t, h);
        }
      });
      for (var [, s] of a) {
        if (!At.includes(t, s)) {
          var l = vt.parent(r, s), u = s[s.length - 1];
          l.children.splice(u, 1);
        }
        if (De.equals(s, i.path)) {
          var c = vt.leaf(r, s);
          c.text = c.text.slice(0, i.offset);
        }
        if (De.equals(s, o.path)) {
          var p = vt.leaf(r, s);
          p.text = p.text.slice(o.offset);
        }
      }
      jn.isEditor(r) && (r.selection = null);
    });
    return n.children;
  },
  get(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (Ar.isText(n) || !n.children[o])
        throw new Error("Cannot find a descendant at path [".concat(t, "] in node: ").concat($o.stringify(e)));
      n = n.children[o];
    }
    return n;
  },
  has(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (Ar.isText(n) || !n.children[o])
        return !1;
      n = n.children[o];
    }
    return !0;
  },
  isNode(e) {
    return Ar.isText(e) || fs.isElement(e) || jn.isEditor(e);
  },
  isNodeList(e) {
    if (!Array.isArray(e))
      return !1;
    var t = e_.get(e);
    if (t !== void 0)
      return t;
    var n = e.every((r) => vt.isNode(r));
    return e_.set(e, n), n;
  },
  last(e, t) {
    for (var n = t.slice(), r = vt.get(e, n); r && !(Ar.isText(r) || r.children.length === 0); ) {
      var o = r.children.length - 1;
      r = r.children[o], n.push(o);
    }
    return [r, n];
  },
  leaf(e, t) {
    var n = vt.get(e, t);
    if (!Ar.isText(n))
      throw new Error("Cannot get the leaf node at path [".concat(t, "] because it refers to a non-leaf node: ").concat($o.stringify(n)));
    return n;
  },
  levels(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of De.levels(t, n)) {
        var o = vt.get(e, r);
        yield [o, r];
      }
    }();
  },
  matches(e, t) {
    return fs.isElement(e) && fs.isElementProps(t) && fs.matches(e, t) || Ar.isText(e) && Ar.isTextProps(t) && Ar.matches(e, t);
  },
  nodes(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var {
        pass: n,
        reverse: r = !1
      } = t, {
        from: o = [],
        to: i
      } = t, a = /* @__PURE__ */ new Set(), s = [], l = e; !(i && (r ? De.isBefore(s, i) : De.isAfter(s, i))); ) {
        if (a.has(l) || (yield [l, s]), !a.has(l) && !Ar.isText(l) && l.children.length !== 0 && (n == null || n([l, s]) === !1)) {
          a.add(l);
          var u = r ? l.children.length - 1 : 0;
          De.isAncestor(s, o) && (u = o[s.length]), s = s.concat(u), l = vt.get(e, s);
          continue;
        }
        if (s.length === 0)
          break;
        if (!r) {
          var c = De.next(s);
          if (vt.has(e, c)) {
            s = c, l = vt.get(e, s);
            continue;
          }
        }
        if (r && s[s.length - 1] !== 0) {
          var p = De.previous(s);
          s = p, l = vt.get(e, s);
          continue;
        }
        s = De.parent(s), l = vt.get(e, s), a.add(l);
      }
    }();
  },
  parent(e, t) {
    var n = De.parent(t), r = vt.get(e, n);
    if (Ar.isText(r))
      throw new Error("Cannot get the parent of path [".concat(t, "] because it does not exist in the root."));
    return r;
  },
  string(e) {
    return Ar.isText(e) ? e.text : e.children.map(vt.string).join("");
  },
  texts(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of vt.nodes(e, t))
        Ar.isText(n) && (yield [n, r]);
    }();
  }
};
function t_(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function tr(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? t_(Object(n), !0).forEach(function(r) {
      fu(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : t_(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var cc = {
  isNodeOperation(e) {
    return cc.isOperation(e) && e.type.endsWith("_node");
  },
  isOperation(e) {
    if (!fo(e))
      return !1;
    switch (e.type) {
      case "insert_node":
        return De.isPath(e.path) && vt.isNode(e.node);
      case "insert_text":
        return typeof e.offset == "number" && typeof e.text == "string" && De.isPath(e.path);
      case "merge_node":
        return typeof e.position == "number" && De.isPath(e.path) && fo(e.properties);
      case "move_node":
        return De.isPath(e.path) && De.isPath(e.newPath);
      case "remove_node":
        return De.isPath(e.path) && vt.isNode(e.node);
      case "remove_text":
        return typeof e.offset == "number" && typeof e.text == "string" && De.isPath(e.path);
      case "set_node":
        return De.isPath(e.path) && fo(e.properties) && fo(e.newProperties);
      case "set_selection":
        return e.properties === null && At.isRange(e.newProperties) || e.newProperties === null && At.isRange(e.properties) || fo(e.properties) && fo(e.newProperties);
      case "split_node":
        return De.isPath(e.path) && typeof e.position == "number" && fo(e.properties);
      default:
        return !1;
    }
  },
  isOperationList(e) {
    return Array.isArray(e) && e.every((t) => cc.isOperation(t));
  },
  isSelectionOperation(e) {
    return cc.isOperation(e) && e.type.endsWith("_selection");
  },
  isTextOperation(e) {
    return cc.isOperation(e) && e.type.endsWith("_text");
  },
  inverse(e) {
    switch (e.type) {
      case "insert_node":
        return tr(tr({}, e), {}, {
          type: "remove_node"
        });
      case "insert_text":
        return tr(tr({}, e), {}, {
          type: "remove_text"
        });
      case "merge_node":
        return tr(tr({}, e), {}, {
          type: "split_node",
          path: De.previous(e.path)
        });
      case "move_node": {
        var {
          newPath: t,
          path: n
        } = e;
        if (De.equals(t, n))
          return e;
        if (De.isSibling(n, t))
          return tr(tr({}, e), {}, {
            path: t,
            newPath: n
          });
        var r = De.transform(n, e), o = De.transform(De.next(n), e);
        return tr(tr({}, e), {}, {
          path: r,
          newPath: o
        });
      }
      case "remove_node":
        return tr(tr({}, e), {}, {
          type: "insert_node"
        });
      case "remove_text":
        return tr(tr({}, e), {}, {
          type: "insert_text"
        });
      case "set_node": {
        var {
          properties: i,
          newProperties: a
        } = e;
        return tr(tr({}, e), {}, {
          properties: a,
          newProperties: i
        });
      }
      case "set_selection": {
        var {
          properties: s,
          newProperties: l
        } = e;
        return s == null ? tr(tr({}, e), {}, {
          properties: l,
          newProperties: null
        }) : l == null ? tr(tr({}, e), {}, {
          properties: null,
          newProperties: s
        }) : tr(tr({}, e), {}, {
          properties: l,
          newProperties: s
        });
      }
      case "split_node":
        return tr(tr({}, e), {}, {
          type: "merge_node",
          path: De.next(e.path)
        });
    }
  }
}, n_ = /* @__PURE__ */ new WeakMap(), wX = (e) => {
  var t = n_.get(e);
  if (t !== void 0)
    return t;
  if (!fo(e))
    return !1;
  var n = typeof e.addMark == "function" && typeof e.apply == "function" && typeof e.deleteFragment == "function" && typeof e.insertBreak == "function" && typeof e.insertSoftBreak == "function" && typeof e.insertFragment == "function" && typeof e.insertNode == "function" && typeof e.insertText == "function" && typeof e.isElementReadOnly == "function" && typeof e.isInline == "function" && typeof e.isSelectable == "function" && typeof e.isVoid == "function" && typeof e.normalizeNode == "function" && typeof e.onChange == "function" && typeof e.removeMark == "function" && typeof e.getDirtyPaths == "function" && (e.marks === null || fo(e.marks)) && (e.selection === null || At.isRange(e.selection)) && vt.isNodeList(e.children) && cc.isOperationList(e.operations);
  return n_.set(e, n), n;
}, jn = {
  above(e, t) {
    return e.above(t);
  },
  addMark(e, t, n) {
    e.addMark(t, n);
  },
  after(e, t, n) {
    return e.after(t, n);
  },
  before(e, t, n) {
    return e.before(t, n);
  },
  deleteBackward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteBackward(n);
  },
  deleteForward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteForward(n);
  },
  deleteFragment(e, t) {
    e.deleteFragment(t);
  },
  edges(e, t) {
    return e.edges(t);
  },
  elementReadOnly(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return e.elementReadOnly(t);
  },
  end(e, t) {
    return e.end(t);
  },
  first(e, t) {
    return e.first(t);
  },
  fragment(e, t) {
    return e.fragment(t);
  },
  hasBlocks(e, t) {
    return e.hasBlocks(t);
  },
  hasInlines(e, t) {
    return e.hasInlines(t);
  },
  hasPath(e, t) {
    return e.hasPath(t);
  },
  hasTexts(e, t) {
    return e.hasTexts(t);
  },
  insertBreak(e) {
    e.insertBreak();
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertNode(e, t) {
    e.insertNode(t);
  },
  insertSoftBreak(e) {
    e.insertSoftBreak();
  },
  insertText(e, t) {
    e.insertText(t);
  },
  isBlock(e, t) {
    return e.isBlock(t);
  },
  isEdge(e, t, n) {
    return e.isEdge(t, n);
  },
  isEditor(e) {
    return wX(e);
  },
  isElementReadOnly(e, t) {
    return e.isElementReadOnly(t);
  },
  isEmpty(e, t) {
    return e.isEmpty(t);
  },
  isEnd(e, t, n) {
    return e.isEnd(t, n);
  },
  isInline(e, t) {
    return e.isInline(t);
  },
  isNormalizing(e) {
    return e.isNormalizing();
  },
  isSelectable(e, t) {
    return e.isSelectable(t);
  },
  isStart(e, t, n) {
    return e.isStart(t, n);
  },
  isVoid(e, t) {
    return e.isVoid(t);
  },
  last(e, t) {
    return e.last(t);
  },
  leaf(e, t, n) {
    return e.leaf(t, n);
  },
  levels(e, t) {
    return e.levels(t);
  },
  marks(e) {
    return e.getMarks();
  },
  next(e, t) {
    return e.next(t);
  },
  node(e, t, n) {
    return e.node(t, n);
  },
  nodes(e, t) {
    return e.nodes(t);
  },
  normalize(e, t) {
    e.normalize(t);
  },
  parent(e, t, n) {
    return e.parent(t, n);
  },
  path(e, t, n) {
    return e.path(t, n);
  },
  pathRef(e, t, n) {
    return e.pathRef(t, n);
  },
  pathRefs(e) {
    return e.pathRefs();
  },
  point(e, t, n) {
    return e.point(t, n);
  },
  pointRef(e, t, n) {
    return e.pointRef(t, n);
  },
  pointRefs(e) {
    return e.pointRefs();
  },
  positions(e, t) {
    return e.positions(t);
  },
  previous(e, t) {
    return e.previous(t);
  },
  range(e, t, n) {
    return e.range(t, n);
  },
  rangeRef(e, t, n) {
    return e.rangeRef(t, n);
  },
  rangeRefs(e) {
    return e.rangeRefs();
  },
  removeMark(e, t) {
    e.removeMark(t);
  },
  setNormalizing(e, t) {
    e.setNormalizing(t);
  },
  start(e, t) {
    return e.start(t);
  },
  string(e, t, n) {
    return e.string(t, n);
  },
  unhangRange(e, t, n) {
    return e.unhangRange(t, n);
  },
  void(e, t) {
    return e.void(t);
  },
  withoutNormalizing(e, t) {
    e.withoutNormalizing(t);
  },
  shouldMergeNodesRemovePrevNode: (e, t, n) => e.shouldMergeNodesRemovePrevNode(t, n)
};
function r_(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function o_(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? r_(Object(n), !0).forEach(function(r) {
      fu(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : r_(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Xn = {
  compare(e, t) {
    var n = De.compare(e.path, t.path);
    return n === 0 ? e.offset < t.offset ? -1 : e.offset > t.offset ? 1 : 0 : n;
  },
  isAfter(e, t) {
    return Xn.compare(e, t) === 1;
  },
  isBefore(e, t) {
    return Xn.compare(e, t) === -1;
  },
  equals(e, t) {
    return e.offset === t.offset && De.equals(e.path, t.path);
  },
  isPoint(e) {
    return fo(e) && typeof e.offset == "number" && De.isPath(e.path);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return OO(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "forward"
      } = n, {
        path: i,
        offset: a
      } = r;
      switch (t.type) {
        case "insert_node":
        case "move_node": {
          r.path = De.transform(i, t, n);
          break;
        }
        case "insert_text": {
          De.equals(t.path, i) && (t.offset < a || t.offset === a && o === "forward") && (r.offset += t.text.length);
          break;
        }
        case "merge_node": {
          De.equals(t.path, i) && (r.offset += t.position), r.path = De.transform(i, t, n);
          break;
        }
        case "remove_text": {
          De.equals(t.path, i) && t.offset <= a && (r.offset -= Math.min(a - t.offset, t.text.length));
          break;
        }
        case "remove_node": {
          if (De.equals(t.path, i) || De.isAncestor(t.path, i))
            return null;
          r.path = De.transform(i, t, n);
          break;
        }
        case "split_node": {
          if (De.equals(t.path, i)) {
            if (t.position === a && o == null)
              return null;
            (t.position < a || t.position === a && o === "forward") && (r.offset -= t.position, r.path = De.transform(i, t, o_(o_({}, n), {}, {
              affinity: "forward"
            })));
          } else
            r.path = De.transform(i, t, n);
          break;
        }
      }
    });
  }
}, i_ = void 0, $o = {
  setScrubber(e) {
    i_ = e;
  },
  stringify(e) {
    return JSON.stringify(e, i_);
  }
}, CX = ["text"], xX = ["anchor", "focus"];
function s_(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ns(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? s_(Object(n), !0).forEach(function(r) {
      fu(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : s_(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Ar = {
  equals(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      loose: r = !1
    } = n;
    function o(i) {
      var a = np(i, CX);
      return a;
    }
    return V$(r ? o(e) : e, r ? o(t) : t);
  },
  isText(e) {
    return fo(e) && typeof e.text == "string";
  },
  isTextList(e) {
    return Array.isArray(e) && e.every((t) => Ar.isText(t));
  },
  isTextProps(e) {
    return e.text !== void 0;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "text" && (!e.hasOwnProperty(n) || e[n] !== t[n]))
        return !1;
    return !0;
  },
  decorations(e, t) {
    var n = [ns({}, e)];
    for (var r of t) {
      var o = np(r, xX), [i, a] = At.edges(r), s = [], l = 0, u = i.offset, c = a.offset;
      for (var p of n) {
        var {
          length: d
        } = p.text, h = l;
        if (l += d, u <= h && l <= c) {
          Object.assign(p, o), s.push(p);
          continue;
        }
        if (u !== c && (u === l || c === h) || u > l || c < h || c === h && h !== 0) {
          s.push(p);
          continue;
        }
        var f = p, m = void 0, g = void 0;
        if (c < l) {
          var E = c - h;
          g = ns(ns({}, f), {}, {
            text: f.text.slice(E)
          }), f = ns(ns({}, f), {}, {
            text: f.text.slice(0, E)
          });
        }
        if (u > h) {
          var w = u - h;
          m = ns(ns({}, f), {}, {
            text: f.text.slice(0, w)
          }), f = ns(ns({}, f), {}, {
            text: f.text.slice(w)
          });
        }
        Object.assign(f, o), m && s.push(m), s.push(f), g && s.push(g);
      }
      n = s;
    }
    return n;
  }
}, OX = (e) => e.selection ? e.selection : e.children.length > 0 ? jn.end(e, []) : [0], Wn;
(function(e) {
  e[e.None = 0] = "None", e[e.Extend = 1] = "Extend", e[e.ZWJ = 2] = "ZWJ", e[e.RI = 4] = "RI", e[e.Prepend = 8] = "Prepend", e[e.SpacingMark = 16] = "SpacingMark", e[e.L = 32] = "L", e[e.V = 64] = "V", e[e.T = 128] = "T", e[e.LV = 256] = "LV", e[e.LVT = 512] = "LVT", e[e.ExtPict = 1024] = "ExtPict", e[e.Any = 2048] = "Any";
})(Wn || (Wn = {}));
Wn.L, Wn.L | Wn.V | Wn.LV | Wn.LVT, Wn.LV | Wn.V, Wn.V | Wn.T, Wn.LVT | Wn.T, Wn.T, Wn.Any, Wn.Extend | Wn.ZWJ, Wn.Any, Wn.SpacingMark, Wn.Prepend, Wn.Any, Wn.ZWJ, Wn.ExtPict, Wn.RI, Wn.RI;
var EX = {
  delete(e, t) {
    e.delete(t);
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertText(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    jn.withoutNormalizing(e, () => {
      var {
        voids: r = !1
      } = n, {
        at: o = OX(e)
      } = n;
      if (De.isPath(o) && (o = jn.range(e, o)), At.isRange(o))
        if (At.isCollapsed(o))
          o = o.anchor;
        else {
          var i = At.end(o);
          if (!r && jn.void(e, {
            at: i
          }))
            return;
          var a = At.start(o), s = jn.pointRef(e, a), l = jn.pointRef(e, i);
          Xh.delete(e, {
            at: o,
            voids: r
          });
          var u = s.unref(), c = l.unref();
          o = u || c, Xh.setSelection(e, {
            anchor: o,
            focus: o
          });
        }
      if (!(!r && jn.void(e, {
        at: o
      }) || jn.elementReadOnly(e, {
        at: o
      }))) {
        var {
          path: p,
          offset: d
        } = o;
        t.length > 0 && e.apply({
          type: "insert_text",
          path: p,
          offset: d,
          text: t
        });
      }
    });
  }
};
function a_(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Id(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? a_(Object(n), !0).forEach(function(r) {
      fu(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : a_(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Xh = Id(Id(Id(Id({}, dX), fX), hX), EX), q$ = {}, EO = {}, kO = {}, Fl = {}, LO = {}, _O = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Doctype = e.CDATA = e.Tag = e.Style = e.Script = e.Comment = e.Directive = e.Text = e.Root = e.isTag = e.ElementType = void 0;
  var t;
  (function(r) {
    r.Root = "root", r.Text = "text", r.Directive = "directive", r.Comment = "comment", r.Script = "script", r.Style = "style", r.Tag = "tag", r.CDATA = "cdata", r.Doctype = "doctype";
  })(t = e.ElementType || (e.ElementType = {}));
  function n(r) {
    return r.type === t.Tag || r.type === t.Script || r.type === t.Style;
  }
  e.isTag = n, e.Root = t.Root, e.Text = t.Text, e.Directive = t.Directive, e.Comment = t.Comment, e.Script = t.Script, e.Style = t.Style, e.Tag = t.Tag, e.CDATA = t.CDATA, e.Doctype = t.Doctype;
})(_O);
var Ut = {}, va = Fn && Fn.__extends || /* @__PURE__ */ function() {
  var e = function(t, n) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, o) {
      r.__proto__ = o;
    } || function(r, o) {
      for (var i in o) Object.prototype.hasOwnProperty.call(o, i) && (r[i] = o[i]);
    }, e(t, n);
  };
  return function(t, n) {
    if (typeof n != "function" && n !== null)
      throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
    e(t, n);
    function r() {
      this.constructor = t;
    }
    t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
  };
}(), Oc = Fn && Fn.__assign || function() {
  return Oc = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) {
      t = arguments[n];
      for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
    }
    return e;
  }, Oc.apply(this, arguments);
};
Object.defineProperty(Ut, "__esModule", { value: !0 });
Ut.cloneNode = Ut.hasChildren = Ut.isDocument = Ut.isDirective = Ut.isComment = Ut.isText = Ut.isCDATA = Ut.isTag = Ut.Element = Ut.Document = Ut.CDATA = Ut.NodeWithChildren = Ut.ProcessingInstruction = Ut.Comment = Ut.Text = Ut.DataNode = Ut.Node = void 0;
var Ro = _O, PO = (
  /** @class */
  function() {
    function e() {
      this.parent = null, this.prev = null, this.next = null, this.startIndex = null, this.endIndex = null;
    }
    return Object.defineProperty(e.prototype, "parentNode", {
      // Read-write aliases for properties
      /**
       * Same as {@link parent}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.parent;
      },
      set: function(t) {
        this.parent = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "previousSibling", {
      /**
       * Same as {@link prev}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.prev;
      },
      set: function(t) {
        this.prev = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "nextSibling", {
      /**
       * Same as {@link next}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.next;
      },
      set: function(t) {
        this.next = t;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.cloneNode = function(t) {
      return t === void 0 && (t = !1), SO(this, t);
    }, e;
  }()
);
Ut.Node = PO;
var Zm = (
  /** @class */
  function(e) {
    va(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.data = n, r;
    }
    return Object.defineProperty(t.prototype, "nodeValue", {
      /**
       * Same as {@link data}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.data;
      },
      set: function(n) {
        this.data = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(PO)
);
Ut.DataNode = Zm;
var Z$ = (
  /** @class */
  function(e) {
    va(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Ro.ElementType.Text, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 3;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Zm)
);
Ut.Text = Z$;
var G$ = (
  /** @class */
  function(e) {
    va(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Ro.ElementType.Comment, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 8;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Zm)
);
Ut.Comment = G$;
var X$ = (
  /** @class */
  function(e) {
    va(t, e);
    function t(n, r) {
      var o = e.call(this, r) || this;
      return o.name = n, o.type = Ro.ElementType.Directive, o;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Zm)
);
Ut.ProcessingInstruction = X$;
var Gm = (
  /** @class */
  function(e) {
    va(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.children = n, r;
    }
    return Object.defineProperty(t.prototype, "firstChild", {
      // Aliases
      /** First child of the node. */
      get: function() {
        var n;
        return (n = this.children[0]) !== null && n !== void 0 ? n : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "lastChild", {
      /** Last child of the node. */
      get: function() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "childNodes", {
      /**
       * Same as {@link children}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.children;
      },
      set: function(n) {
        this.children = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(PO)
);
Ut.NodeWithChildren = Gm;
var K$ = (
  /** @class */
  function(e) {
    va(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Ro.ElementType.CDATA, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 4;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Gm)
);
Ut.CDATA = K$;
var Y$ = (
  /** @class */
  function(e) {
    va(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Ro.ElementType.Root, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 9;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Gm)
);
Ut.Document = Y$;
var J$ = (
  /** @class */
  function(e) {
    va(t, e);
    function t(n, r, o, i) {
      o === void 0 && (o = []), i === void 0 && (i = n === "script" ? Ro.ElementType.Script : n === "style" ? Ro.ElementType.Style : Ro.ElementType.Tag);
      var a = e.call(this, o) || this;
      return a.name = n, a.attribs = r, a.type = i, a;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "tagName", {
      // DOM Level 1 aliases
      /**
       * Same as {@link name}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.name;
      },
      set: function(n) {
        this.name = n;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "attributes", {
      get: function() {
        var n = this;
        return Object.keys(this.attribs).map(function(r) {
          var o, i;
          return {
            name: r,
            value: n.attribs[r],
            namespace: (o = n["x-attribsNamespace"]) === null || o === void 0 ? void 0 : o[r],
            prefix: (i = n["x-attribsPrefix"]) === null || i === void 0 ? void 0 : i[r]
          };
        });
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Gm)
);
Ut.Element = J$;
function Q$(e) {
  return (0, Ro.isTag)(e);
}
Ut.isTag = Q$;
function e3(e) {
  return e.type === Ro.ElementType.CDATA;
}
Ut.isCDATA = e3;
function t3(e) {
  return e.type === Ro.ElementType.Text;
}
Ut.isText = t3;
function n3(e) {
  return e.type === Ro.ElementType.Comment;
}
Ut.isComment = n3;
function r3(e) {
  return e.type === Ro.ElementType.Directive;
}
Ut.isDirective = r3;
function o3(e) {
  return e.type === Ro.ElementType.Root;
}
Ut.isDocument = o3;
function kX(e) {
  return Object.prototype.hasOwnProperty.call(e, "children");
}
Ut.hasChildren = kX;
function SO(e, t) {
  t === void 0 && (t = !1);
  var n;
  if (t3(e))
    n = new Z$(e.data);
  else if (n3(e))
    n = new G$(e.data);
  else if (Q$(e)) {
    var r = t ? Qy(e.children) : [], o = new J$(e.name, Oc({}, e.attribs), r);
    r.forEach(function(l) {
      return l.parent = o;
    }), e.namespace != null && (o.namespace = e.namespace), e["x-attribsNamespace"] && (o["x-attribsNamespace"] = Oc({}, e["x-attribsNamespace"])), e["x-attribsPrefix"] && (o["x-attribsPrefix"] = Oc({}, e["x-attribsPrefix"])), n = o;
  } else if (e3(e)) {
    var r = t ? Qy(e.children) : [], i = new K$(r);
    r.forEach(function(u) {
      return u.parent = i;
    }), n = i;
  } else if (o3(e)) {
    var r = t ? Qy(e.children) : [], a = new Y$(r);
    r.forEach(function(u) {
      return u.parent = a;
    }), e["x-mode"] && (a["x-mode"] = e["x-mode"]), n = a;
  } else if (r3(e)) {
    var s = new X$(e.name, e.data);
    e["x-name"] != null && (s["x-name"] = e["x-name"], s["x-publicId"] = e["x-publicId"], s["x-systemId"] = e["x-systemId"]), n = s;
  } else
    throw new Error("Not implemented yet: ".concat(e.type));
  return n.startIndex = e.startIndex, n.endIndex = e.endIndex, e.sourceCodeLocation != null && (n.sourceCodeLocation = e.sourceCodeLocation), n;
}
Ut.cloneNode = SO;
function Qy(e) {
  for (var t = e.map(function(r) {
    return SO(r, !0);
  }), n = 1; n < t.length; n++)
    t[n].prev = t[n - 1], t[n - 1].next = t[n];
  return t;
}
(function(e) {
  var t = Fn && Fn.__createBinding || (Object.create ? function(s, l, u, c) {
    c === void 0 && (c = u);
    var p = Object.getOwnPropertyDescriptor(l, u);
    (!p || ("get" in p ? !l.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
      return l[u];
    } }), Object.defineProperty(s, c, p);
  } : function(s, l, u, c) {
    c === void 0 && (c = u), s[c] = l[u];
  }), n = Fn && Fn.__exportStar || function(s, l) {
    for (var u in s) u !== "default" && !Object.prototype.hasOwnProperty.call(l, u) && t(l, s, u);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.DomHandler = void 0;
  var r = _O, o = Ut;
  n(Ut, e);
  var i = {
    withStartIndices: !1,
    withEndIndices: !1,
    xmlMode: !1
  }, a = (
    /** @class */
    function() {
      function s(l, u, c) {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null, typeof u == "function" && (c = u, u = i), typeof l == "object" && (u = l, l = void 0), this.callback = l ?? null, this.options = u ?? i, this.elementCB = c ?? null;
      }
      return s.prototype.onparserinit = function(l) {
        this.parser = l;
      }, s.prototype.onreset = function() {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null;
      }, s.prototype.onend = function() {
        this.done || (this.done = !0, this.parser = null, this.handleCallback(null));
      }, s.prototype.onerror = function(l) {
        this.handleCallback(l);
      }, s.prototype.onclosetag = function() {
        this.lastNode = null;
        var l = this.tagStack.pop();
        this.options.withEndIndices && (l.endIndex = this.parser.endIndex), this.elementCB && this.elementCB(l);
      }, s.prototype.onopentag = function(l, u) {
        var c = this.options.xmlMode ? r.ElementType.Tag : void 0, p = new o.Element(l, u, void 0, c);
        this.addNode(p), this.tagStack.push(p);
      }, s.prototype.ontext = function(l) {
        var u = this.lastNode;
        if (u && u.type === r.ElementType.Text)
          u.data += l, this.options.withEndIndices && (u.endIndex = this.parser.endIndex);
        else {
          var c = new o.Text(l);
          this.addNode(c), this.lastNode = c;
        }
      }, s.prototype.oncomment = function(l) {
        if (this.lastNode && this.lastNode.type === r.ElementType.Comment) {
          this.lastNode.data += l;
          return;
        }
        var u = new o.Comment(l);
        this.addNode(u), this.lastNode = u;
      }, s.prototype.oncommentend = function() {
        this.lastNode = null;
      }, s.prototype.oncdatastart = function() {
        var l = new o.Text(""), u = new o.CDATA([l]);
        this.addNode(u), l.parent = u, this.lastNode = l;
      }, s.prototype.oncdataend = function() {
        this.lastNode = null;
      }, s.prototype.onprocessinginstruction = function(l, u) {
        var c = new o.ProcessingInstruction(l, u);
        this.addNode(c);
      }, s.prototype.handleCallback = function(l) {
        if (typeof this.callback == "function")
          this.callback(l, this.dom);
        else if (l)
          throw l;
      }, s.prototype.addNode = function(l) {
        var u = this.tagStack[this.tagStack.length - 1], c = u.children[u.children.length - 1];
        this.options.withStartIndices && (l.startIndex = this.parser.startIndex), this.options.withEndIndices && (l.endIndex = this.parser.endIndex), u.children.push(l), c && (l.prev = c, c.next = l), l.parent = u, this.lastNode = null;
      }, s;
    }()
  );
  e.DomHandler = a, e.default = a;
})(LO);
var i3 = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CARRIAGE_RETURN_PLACEHOLDER_REGEX = e.CARRIAGE_RETURN_PLACEHOLDER = e.CARRIAGE_RETURN_REGEX = e.CARRIAGE_RETURN = e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES = void 0, e.CASE_SENSITIVE_TAG_NAMES = [
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "linearGradient",
    "radialGradient",
    "textPath"
  ], e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES.reduce(function(t, n) {
    return t[n.toLowerCase()] = n, t;
  }, {}), e.CARRIAGE_RETURN = "\r", e.CARRIAGE_RETURN_REGEX = new RegExp(e.CARRIAGE_RETURN, "g"), e.CARRIAGE_RETURN_PLACEHOLDER = "__HTML_DOM_PARSER_CARRIAGE_RETURN_PLACEHOLDER_".concat(Date.now(), "__"), e.CARRIAGE_RETURN_PLACEHOLDER_REGEX = new RegExp(e.CARRIAGE_RETURN_PLACEHOLDER, "g");
})(i3);
Object.defineProperty(Fl, "__esModule", { value: !0 });
Fl.formatAttributes = s3;
Fl.escapeSpecialCharacters = PX;
Fl.revertEscapedCharacters = a3;
Fl.formatDOM = l3;
var Rd = LO, rp = i3;
function LX(e) {
  return rp.CASE_SENSITIVE_TAG_NAMES_MAP[e];
}
function s3(e) {
  for (var t = {}, n = 0, r = e.length; n < r; n++) {
    var o = e[n];
    t[o.name] = o.value;
  }
  return t;
}
function _X(e) {
  e = e.toLowerCase();
  var t = LX(e);
  return t || e;
}
function PX(e) {
  return e.replace(rp.CARRIAGE_RETURN_REGEX, rp.CARRIAGE_RETURN_PLACEHOLDER);
}
function a3(e) {
  return e.replace(rp.CARRIAGE_RETURN_PLACEHOLDER_REGEX, rp.CARRIAGE_RETURN);
}
function l3(e, t, n) {
  t === void 0 && (t = null);
  for (var r = [], o, i = 0, a = e.length; i < a; i++) {
    var s = e[i];
    switch (s.nodeType) {
      case 1: {
        var l = _X(s.nodeName);
        o = new Rd.Element(l, s3(s.attributes)), o.children = l3(
          // template children are on content
          l === "template" ? s.content.childNodes : s.childNodes,
          o
        );
        break;
      }
      case 3:
        o = new Rd.Text(a3(s.nodeValue));
        break;
      case 8:
        o = new Rd.Comment(s.nodeValue);
        break;
      default:
        continue;
    }
    var u = r[i - 1] || null;
    u && (u.next = o), o.parent = t, o.prev = u, o.next = null, r.push(o);
  }
  return n && (o = new Rd.ProcessingInstruction(n.substring(0, n.indexOf(" ")).toLowerCase(), n), o.next = r[0] || null, o.parent = t, r.unshift(o), r[1] && (r[1].prev = r[0])), r;
}
Object.defineProperty(kO, "__esModule", { value: !0 });
kO.default = jX;
var SX = Fl, l_ = "html", u_ = "head", Nd = "body", MX = /<([a-zA-Z]+[0-9]?)/, c_ = /<head[^]*>/i, p_ = /<body[^]*>/i, Kh = function(e, t) {
  throw new Error("This browser does not support `document.implementation.createHTMLDocument`");
}, oC = function(e, t) {
  throw new Error("This browser does not support `DOMParser.prototype.parseFromString`");
}, d_ = typeof window == "object" && window.DOMParser;
if (typeof d_ == "function") {
  var DX = new d_(), TX = "text/html";
  oC = function(e, t) {
    return t && (e = "<".concat(t, ">").concat(e, "</").concat(t, ">")), DX.parseFromString(e, TX);
  }, Kh = oC;
}
if (typeof document == "object" && document.implementation) {
  var Fd = document.implementation.createHTMLDocument();
  Kh = function(e, t) {
    if (t) {
      var n = Fd.documentElement.querySelector(t);
      return n && (n.innerHTML = e), Fd;
    }
    return Fd.documentElement.innerHTML = e, Fd;
  };
}
var zd = typeof document == "object" && document.createElement("template"), iC;
zd && zd.content && (iC = function(e) {
  return zd.innerHTML = e, zd.content.childNodes;
});
function jX(e) {
  var t, n;
  e = (0, SX.escapeSpecialCharacters)(e);
  var r = e.match(MX), o = r && r[1] ? r[1].toLowerCase() : "";
  switch (o) {
    case l_: {
      var i = oC(e);
      if (!c_.test(e)) {
        var a = i.querySelector(u_);
        (t = a == null ? void 0 : a.parentNode) === null || t === void 0 || t.removeChild(a);
      }
      if (!p_.test(e)) {
        var a = i.querySelector(Nd);
        (n = a == null ? void 0 : a.parentNode) === null || n === void 0 || n.removeChild(a);
      }
      return i.querySelectorAll(l_);
    }
    case u_:
    case Nd: {
      var s = Kh(e).querySelectorAll(o);
      return p_.test(e) && c_.test(e) ? s[0].parentNode.childNodes : s;
    }
    default: {
      if (iC)
        return iC(e);
      var a = Kh(e, Nd).querySelector(Nd);
      return a.childNodes;
    }
  }
}
var AX = Fn && Fn.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(EO, "__esModule", { value: !0 });
EO.default = NX;
var BX = AX(kO), IX = Fl, RX = /<(![a-zA-Z\s]+)>/;
function NX(e) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e)
    return [];
  var t = e.match(RX), n = t ? t[1] : void 0;
  return (0, IX.formatDOM)((0, BX.default)(e), null, n);
}
var Xm = {}, Mi = {}, Km = {}, FX = 0;
Km.SAME = FX;
var zX = 1;
Km.CAMELCASE = zX;
Km.possibleStandardNames = {
  accept: 0,
  acceptCharset: 1,
  "accept-charset": "acceptCharset",
  accessKey: 1,
  action: 0,
  allowFullScreen: 1,
  alt: 0,
  as: 0,
  async: 0,
  autoCapitalize: 1,
  autoComplete: 1,
  autoCorrect: 1,
  autoFocus: 1,
  autoPlay: 1,
  autoSave: 1,
  capture: 0,
  cellPadding: 1,
  cellSpacing: 1,
  challenge: 0,
  charSet: 1,
  checked: 0,
  children: 0,
  cite: 0,
  class: "className",
  classID: 1,
  className: 1,
  cols: 0,
  colSpan: 1,
  content: 0,
  contentEditable: 1,
  contextMenu: 1,
  controls: 0,
  controlsList: 1,
  coords: 0,
  crossOrigin: 1,
  dangerouslySetInnerHTML: 1,
  data: 0,
  dateTime: 1,
  default: 0,
  defaultChecked: 1,
  defaultValue: 1,
  defer: 0,
  dir: 0,
  disabled: 0,
  disablePictureInPicture: 1,
  disableRemotePlayback: 1,
  download: 0,
  draggable: 0,
  encType: 1,
  enterKeyHint: 1,
  for: "htmlFor",
  form: 0,
  formMethod: 1,
  formAction: 1,
  formEncType: 1,
  formNoValidate: 1,
  formTarget: 1,
  frameBorder: 1,
  headers: 0,
  height: 0,
  hidden: 0,
  high: 0,
  href: 0,
  hrefLang: 1,
  htmlFor: 1,
  httpEquiv: 1,
  "http-equiv": "httpEquiv",
  icon: 0,
  id: 0,
  innerHTML: 1,
  inputMode: 1,
  integrity: 0,
  is: 0,
  itemID: 1,
  itemProp: 1,
  itemRef: 1,
  itemScope: 1,
  itemType: 1,
  keyParams: 1,
  keyType: 1,
  kind: 0,
  label: 0,
  lang: 0,
  list: 0,
  loop: 0,
  low: 0,
  manifest: 0,
  marginWidth: 1,
  marginHeight: 1,
  max: 0,
  maxLength: 1,
  media: 0,
  mediaGroup: 1,
  method: 0,
  min: 0,
  minLength: 1,
  multiple: 0,
  muted: 0,
  name: 0,
  noModule: 1,
  nonce: 0,
  noValidate: 1,
  open: 0,
  optimum: 0,
  pattern: 0,
  placeholder: 0,
  playsInline: 1,
  poster: 0,
  preload: 0,
  profile: 0,
  radioGroup: 1,
  readOnly: 1,
  referrerPolicy: 1,
  rel: 0,
  required: 0,
  reversed: 0,
  role: 0,
  rows: 0,
  rowSpan: 1,
  sandbox: 0,
  scope: 0,
  scoped: 0,
  scrolling: 0,
  seamless: 0,
  selected: 0,
  shape: 0,
  size: 0,
  sizes: 0,
  span: 0,
  spellCheck: 1,
  src: 0,
  srcDoc: 1,
  srcLang: 1,
  srcSet: 1,
  start: 0,
  step: 0,
  style: 0,
  summary: 0,
  tabIndex: 1,
  target: 0,
  title: 0,
  type: 0,
  useMap: 1,
  value: 0,
  width: 0,
  wmode: 0,
  wrap: 0,
  about: 0,
  accentHeight: 1,
  "accent-height": "accentHeight",
  accumulate: 0,
  additive: 0,
  alignmentBaseline: 1,
  "alignment-baseline": "alignmentBaseline",
  allowReorder: 1,
  alphabetic: 0,
  amplitude: 0,
  arabicForm: 1,
  "arabic-form": "arabicForm",
  ascent: 0,
  attributeName: 1,
  attributeType: 1,
  autoReverse: 1,
  azimuth: 0,
  baseFrequency: 1,
  baselineShift: 1,
  "baseline-shift": "baselineShift",
  baseProfile: 1,
  bbox: 0,
  begin: 0,
  bias: 0,
  by: 0,
  calcMode: 1,
  capHeight: 1,
  "cap-height": "capHeight",
  clip: 0,
  clipPath: 1,
  "clip-path": "clipPath",
  clipPathUnits: 1,
  clipRule: 1,
  "clip-rule": "clipRule",
  color: 0,
  colorInterpolation: 1,
  "color-interpolation": "colorInterpolation",
  colorInterpolationFilters: 1,
  "color-interpolation-filters": "colorInterpolationFilters",
  colorProfile: 1,
  "color-profile": "colorProfile",
  colorRendering: 1,
  "color-rendering": "colorRendering",
  contentScriptType: 1,
  contentStyleType: 1,
  cursor: 0,
  cx: 0,
  cy: 0,
  d: 0,
  datatype: 0,
  decelerate: 0,
  descent: 0,
  diffuseConstant: 1,
  direction: 0,
  display: 0,
  divisor: 0,
  dominantBaseline: 1,
  "dominant-baseline": "dominantBaseline",
  dur: 0,
  dx: 0,
  dy: 0,
  edgeMode: 1,
  elevation: 0,
  enableBackground: 1,
  "enable-background": "enableBackground",
  end: 0,
  exponent: 0,
  externalResourcesRequired: 1,
  fill: 0,
  fillOpacity: 1,
  "fill-opacity": "fillOpacity",
  fillRule: 1,
  "fill-rule": "fillRule",
  filter: 0,
  filterRes: 1,
  filterUnits: 1,
  floodOpacity: 1,
  "flood-opacity": "floodOpacity",
  floodColor: 1,
  "flood-color": "floodColor",
  focusable: 0,
  fontFamily: 1,
  "font-family": "fontFamily",
  fontSize: 1,
  "font-size": "fontSize",
  fontSizeAdjust: 1,
  "font-size-adjust": "fontSizeAdjust",
  fontStretch: 1,
  "font-stretch": "fontStretch",
  fontStyle: 1,
  "font-style": "fontStyle",
  fontVariant: 1,
  "font-variant": "fontVariant",
  fontWeight: 1,
  "font-weight": "fontWeight",
  format: 0,
  from: 0,
  fx: 0,
  fy: 0,
  g1: 0,
  g2: 0,
  glyphName: 1,
  "glyph-name": "glyphName",
  glyphOrientationHorizontal: 1,
  "glyph-orientation-horizontal": "glyphOrientationHorizontal",
  glyphOrientationVertical: 1,
  "glyph-orientation-vertical": "glyphOrientationVertical",
  glyphRef: 1,
  gradientTransform: 1,
  gradientUnits: 1,
  hanging: 0,
  horizAdvX: 1,
  "horiz-adv-x": "horizAdvX",
  horizOriginX: 1,
  "horiz-origin-x": "horizOriginX",
  ideographic: 0,
  imageRendering: 1,
  "image-rendering": "imageRendering",
  in2: 0,
  in: 0,
  inlist: 0,
  intercept: 0,
  k1: 0,
  k2: 0,
  k3: 0,
  k4: 0,
  k: 0,
  kernelMatrix: 1,
  kernelUnitLength: 1,
  kerning: 0,
  keyPoints: 1,
  keySplines: 1,
  keyTimes: 1,
  lengthAdjust: 1,
  letterSpacing: 1,
  "letter-spacing": "letterSpacing",
  lightingColor: 1,
  "lighting-color": "lightingColor",
  limitingConeAngle: 1,
  local: 0,
  markerEnd: 1,
  "marker-end": "markerEnd",
  markerHeight: 1,
  markerMid: 1,
  "marker-mid": "markerMid",
  markerStart: 1,
  "marker-start": "markerStart",
  markerUnits: 1,
  markerWidth: 1,
  mask: 0,
  maskContentUnits: 1,
  maskUnits: 1,
  mathematical: 0,
  mode: 0,
  numOctaves: 1,
  offset: 0,
  opacity: 0,
  operator: 0,
  order: 0,
  orient: 0,
  orientation: 0,
  origin: 0,
  overflow: 0,
  overlinePosition: 1,
  "overline-position": "overlinePosition",
  overlineThickness: 1,
  "overline-thickness": "overlineThickness",
  paintOrder: 1,
  "paint-order": "paintOrder",
  panose1: 0,
  "panose-1": "panose1",
  pathLength: 1,
  patternContentUnits: 1,
  patternTransform: 1,
  patternUnits: 1,
  pointerEvents: 1,
  "pointer-events": "pointerEvents",
  points: 0,
  pointsAtX: 1,
  pointsAtY: 1,
  pointsAtZ: 1,
  prefix: 0,
  preserveAlpha: 1,
  preserveAspectRatio: 1,
  primitiveUnits: 1,
  property: 0,
  r: 0,
  radius: 0,
  refX: 1,
  refY: 1,
  renderingIntent: 1,
  "rendering-intent": "renderingIntent",
  repeatCount: 1,
  repeatDur: 1,
  requiredExtensions: 1,
  requiredFeatures: 1,
  resource: 0,
  restart: 0,
  result: 0,
  results: 0,
  rotate: 0,
  rx: 0,
  ry: 0,
  scale: 0,
  security: 0,
  seed: 0,
  shapeRendering: 1,
  "shape-rendering": "shapeRendering",
  slope: 0,
  spacing: 0,
  specularConstant: 1,
  specularExponent: 1,
  speed: 0,
  spreadMethod: 1,
  startOffset: 1,
  stdDeviation: 1,
  stemh: 0,
  stemv: 0,
  stitchTiles: 1,
  stopColor: 1,
  "stop-color": "stopColor",
  stopOpacity: 1,
  "stop-opacity": "stopOpacity",
  strikethroughPosition: 1,
  "strikethrough-position": "strikethroughPosition",
  strikethroughThickness: 1,
  "strikethrough-thickness": "strikethroughThickness",
  string: 0,
  stroke: 0,
  strokeDasharray: 1,
  "stroke-dasharray": "strokeDasharray",
  strokeDashoffset: 1,
  "stroke-dashoffset": "strokeDashoffset",
  strokeLinecap: 1,
  "stroke-linecap": "strokeLinecap",
  strokeLinejoin: 1,
  "stroke-linejoin": "strokeLinejoin",
  strokeMiterlimit: 1,
  "stroke-miterlimit": "strokeMiterlimit",
  strokeWidth: 1,
  "stroke-width": "strokeWidth",
  strokeOpacity: 1,
  "stroke-opacity": "strokeOpacity",
  suppressContentEditableWarning: 1,
  suppressHydrationWarning: 1,
  surfaceScale: 1,
  systemLanguage: 1,
  tableValues: 1,
  targetX: 1,
  targetY: 1,
  textAnchor: 1,
  "text-anchor": "textAnchor",
  textDecoration: 1,
  "text-decoration": "textDecoration",
  textLength: 1,
  textRendering: 1,
  "text-rendering": "textRendering",
  to: 0,
  transform: 0,
  typeof: 0,
  u1: 0,
  u2: 0,
  underlinePosition: 1,
  "underline-position": "underlinePosition",
  underlineThickness: 1,
  "underline-thickness": "underlineThickness",
  unicode: 0,
  unicodeBidi: 1,
  "unicode-bidi": "unicodeBidi",
  unicodeRange: 1,
  "unicode-range": "unicodeRange",
  unitsPerEm: 1,
  "units-per-em": "unitsPerEm",
  unselectable: 0,
  vAlphabetic: 1,
  "v-alphabetic": "vAlphabetic",
  values: 0,
  vectorEffect: 1,
  "vector-effect": "vectorEffect",
  version: 0,
  vertAdvY: 1,
  "vert-adv-y": "vertAdvY",
  vertOriginX: 1,
  "vert-origin-x": "vertOriginX",
  vertOriginY: 1,
  "vert-origin-y": "vertOriginY",
  vHanging: 1,
  "v-hanging": "vHanging",
  vIdeographic: 1,
  "v-ideographic": "vIdeographic",
  viewBox: 1,
  viewTarget: 1,
  visibility: 0,
  vMathematical: 1,
  "v-mathematical": "vMathematical",
  vocab: 0,
  widths: 0,
  wordSpacing: 1,
  "word-spacing": "wordSpacing",
  writingMode: 1,
  "writing-mode": "writingMode",
  x1: 0,
  x2: 0,
  x: 0,
  xChannelSelector: 1,
  xHeight: 1,
  "x-height": "xHeight",
  xlinkActuate: 1,
  "xlink:actuate": "xlinkActuate",
  xlinkArcrole: 1,
  "xlink:arcrole": "xlinkArcrole",
  xlinkHref: 1,
  "xlink:href": "xlinkHref",
  xlinkRole: 1,
  "xlink:role": "xlinkRole",
  xlinkShow: 1,
  "xlink:show": "xlinkShow",
  xlinkTitle: 1,
  "xlink:title": "xlinkTitle",
  xlinkType: 1,
  "xlink:type": "xlinkType",
  xmlBase: 1,
  "xml:base": "xmlBase",
  xmlLang: 1,
  "xml:lang": "xmlLang",
  xmlns: 0,
  "xml:space": "xmlSpace",
  xmlnsXlink: 1,
  "xmlns:xlink": "xmlnsXlink",
  xmlSpace: 1,
  y1: 0,
  y2: 0,
  y: 0,
  yChannelSelector: 1,
  z: 0,
  zoomAndPan: 1
};
const u3 = 0, ya = 1, Ym = 2, Jm = 3, MO = 4, c3 = 5, p3 = 6;
function UX(e) {
  return ao.hasOwnProperty(e) ? ao[e] : null;
}
function Oo(e, t, n, r, o, i, a) {
  this.acceptsBooleans = t === Ym || t === Jm || t === MO, this.attributeName = r, this.attributeNamespace = o, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = i, this.removeEmptyString = a;
}
const ao = {}, $X = [
  "children",
  "dangerouslySetInnerHTML",
  // TODO: This prevents the assignment of defaultValue to regular
  // elements (not just inputs). Now that ReactDOMInput assigns to the
  // defaultValue property -- do we need this?
  "defaultValue",
  "defaultChecked",
  "innerHTML",
  "suppressContentEditableWarning",
  "suppressHydrationWarning",
  "style"
];
$X.forEach((e) => {
  ao[e] = new Oo(
    e,
    u3,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"]
].forEach(([e, t]) => {
  ao[e] = new Oo(
    e,
    ya,
    !1,
    // mustUseProperty
    t,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["contentEditable", "draggable", "spellCheck", "value"].forEach((e) => {
  ao[e] = new Oo(
    e,
    Ym,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha"
].forEach((e) => {
  ao[e] = new Oo(
    e,
    Ym,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "allowFullScreen",
  "async",
  // Note: there is a special case that prevents it from being written to the DOM
  // on the client side because the browsers are inconsistent. Instead we call focus().
  "autoFocus",
  "autoPlay",
  "controls",
  "default",
  "defer",
  "disabled",
  "disablePictureInPicture",
  "disableRemotePlayback",
  "formNoValidate",
  "hidden",
  "loop",
  "noModule",
  "noValidate",
  "open",
  "playsInline",
  "readOnly",
  "required",
  "reversed",
  "scoped",
  "seamless",
  // Microdata
  "itemScope"
].forEach((e) => {
  ao[e] = new Oo(
    e,
    Jm,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "checked",
  // Note: `option.selected` is not updated if `select.multiple` is
  // disabled with `removeAttribute`. We have special logic for handling this.
  "multiple",
  "muted",
  "selected"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  ao[e] = new Oo(
    e,
    Jm,
    !0,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "capture",
  "download"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  ao[e] = new Oo(
    e,
    MO,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "cols",
  "rows",
  "size",
  "span"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  ao[e] = new Oo(
    e,
    p3,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["rowSpan", "start"].forEach((e) => {
  ao[e] = new Oo(
    e,
    c3,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const DO = /[\-\:]([a-z])/g, TO = (e) => e[1].toUpperCase();
[
  "accent-height",
  "alignment-baseline",
  "arabic-form",
  "baseline-shift",
  "cap-height",
  "clip-path",
  "clip-rule",
  "color-interpolation",
  "color-interpolation-filters",
  "color-profile",
  "color-rendering",
  "dominant-baseline",
  "enable-background",
  "fill-opacity",
  "fill-rule",
  "flood-color",
  "flood-opacity",
  "font-family",
  "font-size",
  "font-size-adjust",
  "font-stretch",
  "font-style",
  "font-variant",
  "font-weight",
  "glyph-name",
  "glyph-orientation-horizontal",
  "glyph-orientation-vertical",
  "horiz-adv-x",
  "horiz-origin-x",
  "image-rendering",
  "letter-spacing",
  "lighting-color",
  "marker-end",
  "marker-mid",
  "marker-start",
  "overline-position",
  "overline-thickness",
  "paint-order",
  "panose-1",
  "pointer-events",
  "rendering-intent",
  "shape-rendering",
  "stop-color",
  "stop-opacity",
  "strikethrough-position",
  "strikethrough-thickness",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "text-anchor",
  "text-decoration",
  "text-rendering",
  "underline-position",
  "underline-thickness",
  "unicode-bidi",
  "unicode-range",
  "units-per-em",
  "v-alphabetic",
  "v-hanging",
  "v-ideographic",
  "v-mathematical",
  "vector-effect",
  "vert-adv-y",
  "vert-origin-x",
  "vert-origin-y",
  "word-spacing",
  "writing-mode",
  "xmlns:xlink",
  "x-height"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(DO, TO);
  ao[t] = new Oo(
    t,
    ya,
    !1,
    // mustUseProperty
    e,
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xlink:actuate",
  "xlink:arcrole",
  "xlink:role",
  "xlink:show",
  "xlink:title",
  "xlink:type"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(DO, TO);
  ao[t] = new Oo(
    t,
    ya,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/1999/xlink",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xml:base",
  "xml:lang",
  "xml:space"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(DO, TO);
  ao[t] = new Oo(
    t,
    ya,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/XML/1998/namespace",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["tabIndex", "crossOrigin"].forEach((e) => {
  ao[e] = new Oo(
    e,
    ya,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const HX = "xlinkHref";
ao[HX] = new Oo(
  "xlinkHref",
  ya,
  !1,
  // mustUseProperty
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  // sanitizeURL
  !1
  // removeEmptyString
);
["src", "href", "action", "formAction"].forEach((e) => {
  ao[e] = new Oo(
    e,
    ya,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !0,
    // sanitizeURL
    !0
    // removeEmptyString
  );
});
const {
  CAMELCASE: WX,
  SAME: VX,
  possibleStandardNames: f_
} = Km, qX = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", ZX = qX + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", GX = RegExp.prototype.test.bind(
  // eslint-disable-next-line no-misleading-character-class
  new RegExp("^(data|aria)-[" + ZX + "]*$")
), XX = Object.keys(
  f_
).reduce((e, t) => {
  const n = f_[t];
  return n === VX ? e[t] = t : n === WX ? e[t.toLowerCase()] = t : e[t] = n, e;
}, {});
Mi.BOOLEAN = Jm;
Mi.BOOLEANISH_STRING = Ym;
Mi.NUMERIC = c3;
Mi.OVERLOADED_BOOLEAN = MO;
Mi.POSITIVE_NUMERIC = p3;
Mi.RESERVED = u3;
Mi.STRING = ya;
Mi.getPropertyInfo = UX;
Mi.isCustomAttribute = GX;
Mi.possibleStandardNames = XX;
var jO = {}, AO = {}, h_ = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, KX = /\n/g, YX = /^\s*/, JX = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, QX = /^:\s*/, eK = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, tK = /^[;\s]*/, nK = /^\s+|\s+$/g, rK = `
`, g_ = "/", m_ = "*", tl = "", oK = "comment", iK = "declaration", sK = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e) return [];
  t = t || {};
  var n = 1, r = 1;
  function o(f) {
    var m = f.match(KX);
    m && (n += m.length);
    var g = f.lastIndexOf(rK);
    r = ~g ? f.length - g : r + f.length;
  }
  function i() {
    var f = { line: n, column: r };
    return function(m) {
      return m.position = new a(f), u(), m;
    };
  }
  function a(f) {
    this.start = f, this.end = { line: n, column: r }, this.source = t.source;
  }
  a.prototype.content = e;
  function s(f) {
    var m = new Error(
      t.source + ":" + n + ":" + r + ": " + f
    );
    if (m.reason = f, m.filename = t.source, m.line = n, m.column = r, m.source = e, !t.silent) throw m;
  }
  function l(f) {
    var m = f.exec(e);
    if (m) {
      var g = m[0];
      return o(g), e = e.slice(g.length), m;
    }
  }
  function u() {
    l(YX);
  }
  function c(f) {
    var m;
    for (f = f || []; m = p(); )
      m !== !1 && f.push(m);
    return f;
  }
  function p() {
    var f = i();
    if (!(g_ != e.charAt(0) || m_ != e.charAt(1))) {
      for (var m = 2; tl != e.charAt(m) && (m_ != e.charAt(m) || g_ != e.charAt(m + 1)); )
        ++m;
      if (m += 2, tl === e.charAt(m - 1))
        return s("End of comment missing");
      var g = e.slice(2, m - 2);
      return r += 2, o(g), e = e.slice(m), r += 2, f({
        type: oK,
        comment: g
      });
    }
  }
  function d() {
    var f = i(), m = l(JX);
    if (m) {
      if (p(), !l(QX)) return s("property missing ':'");
      var g = l(eK), E = f({
        type: iK,
        property: v_(m[0].replace(h_, tl)),
        value: g ? v_(g[0].replace(h_, tl)) : tl
      });
      return l(tK), E;
    }
  }
  function h() {
    var f = [];
    c(f);
    for (var m; m = d(); )
      m !== !1 && (f.push(m), c(f));
    return f;
  }
  return u(), h();
};
function v_(e) {
  return e ? e.replace(nK, tl) : tl;
}
var aK = Fn && Fn.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(AO, "__esModule", { value: !0 });
AO.default = uK;
var lK = aK(sK);
function uK(e, t) {
  var n = null;
  if (!e || typeof e != "string")
    return n;
  var r = (0, lK.default)(e), o = typeof t == "function";
  return r.forEach(function(i) {
    if (i.type === "declaration") {
      var a = i.property, s = i.value;
      o ? t(a, s, i) : s && (n = n || {}, n[a] = s);
    }
  }), n;
}
var Qm = {};
Object.defineProperty(Qm, "__esModule", { value: !0 });
Qm.camelCase = void 0;
var cK = /^--[a-zA-Z0-9_-]+$/, pK = /-([a-z])/g, dK = /^[^-]+$/, fK = /^-(webkit|moz|ms|o|khtml)-/, hK = /^-(ms)-/, gK = function(e) {
  return !e || dK.test(e) || cK.test(e);
}, mK = function(e, t) {
  return t.toUpperCase();
}, y_ = function(e, t) {
  return "".concat(t, "-");
}, vK = function(e, t) {
  return t === void 0 && (t = {}), gK(e) ? e : (e = e.toLowerCase(), t.reactCompat ? e = e.replace(hK, y_) : e = e.replace(fK, y_), e.replace(pK, mK));
};
Qm.camelCase = vK;
var yK = Fn && Fn.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
}, bK = yK(AO), wK = Qm;
function sC(e, t) {
  var n = {};
  return !e || typeof e != "string" || (0, bK.default)(e, function(r, o) {
    r && o && (n[(0, wK.camelCase)(r, t)] = o);
  }), n;
}
sC.default = sC;
var CK = sC;
(function(e) {
  var t = Fn && Fn.__importDefault || function(c) {
    return c && c.__esModule ? c : { default: c };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.returnFirstArg = e.canTextBeChildOfNode = e.ELEMENTS_WITH_NO_TEXT_CHILDREN = e.PRESERVE_CUSTOM_ATTRIBUTES = void 0, e.isCustomComponent = i, e.setStyleProp = s;
  var n = ke, r = t(CK), o = /* @__PURE__ */ new Set([
    "annotation-xml",
    "color-profile",
    "font-face",
    "font-face-src",
    "font-face-uri",
    "font-face-format",
    "font-face-name",
    "missing-glyph"
  ]);
  function i(c, p) {
    return c.includes("-") ? !o.has(c) : !!(p && typeof p.is == "string");
  }
  var a = {
    reactCompat: !0
  };
  function s(c, p) {
    if (typeof c == "string") {
      if (!c.trim()) {
        p.style = {};
        return;
      }
      try {
        p.style = (0, r.default)(c, a);
      } catch {
        p.style = {};
      }
    }
  }
  e.PRESERVE_CUSTOM_ATTRIBUTES = Number(n.version.split(".")[0]) >= 16, e.ELEMENTS_WITH_NO_TEXT_CHILDREN = /* @__PURE__ */ new Set([
    "tr",
    "tbody",
    "thead",
    "tfoot",
    "colgroup",
    "table",
    "head",
    "html",
    "frameset"
  ]);
  var l = function(c) {
    return !e.ELEMENTS_WITH_NO_TEXT_CHILDREN.has(c.name);
  };
  e.canTextBeChildOfNode = l;
  var u = function(c) {
    return c;
  };
  e.returnFirstArg = u;
})(jO);
Object.defineProperty(Xm, "__esModule", { value: !0 });
Xm.default = kK;
var pc = Mi, b_ = jO, xK = ["checked", "value"], OK = ["input", "select", "textarea"], EK = {
  reset: !0,
  submit: !0
};
function kK(e, t) {
  e === void 0 && (e = {});
  var n = {}, r = !!(e.type && EK[e.type]);
  for (var o in e) {
    var i = e[o];
    if ((0, pc.isCustomAttribute)(o)) {
      n[o] = i;
      continue;
    }
    var a = o.toLowerCase(), s = w_(a);
    if (s) {
      var l = (0, pc.getPropertyInfo)(s);
      switch (xK.includes(s) && OK.includes(t) && !r && (s = w_("default" + a)), n[s] = i, l && l.type) {
        case pc.BOOLEAN:
          n[s] = !0;
          break;
        case pc.OVERLOADED_BOOLEAN:
          i === "" && (n[s] = !0);
          break;
      }
      continue;
    }
    b_.PRESERVE_CUSTOM_ATTRIBUTES && (n[o] = i);
  }
  return (0, b_.setStyleProp)(e.style, n), n;
}
function w_(e) {
  return pc.possibleStandardNames[e];
}
var BO = {}, LK = Fn && Fn.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(BO, "__esModule", { value: !0 });
BO.default = d3;
var eb = ke, _K = LK(Xm), Ec = jO, PK = {
  cloneElement: eb.cloneElement,
  createElement: eb.createElement,
  isValidElement: eb.isValidElement
};
function d3(e, t) {
  t === void 0 && (t = {});
  for (var n = [], r = typeof t.replace == "function", o = t.transform || Ec.returnFirstArg, i = t.library || PK, a = i.cloneElement, s = i.createElement, l = i.isValidElement, u = e.length, c = 0; c < u; c++) {
    var p = e[c];
    if (r) {
      var d = t.replace(p, c);
      if (l(d)) {
        u > 1 && (d = a(d, {
          key: d.key || c
        })), n.push(o(d, p, c));
        continue;
      }
    }
    if (p.type === "text") {
      var h = !p.data.trim().length;
      if (h && p.parent && !(0, Ec.canTextBeChildOfNode)(p.parent) || t.trim && h)
        continue;
      n.push(o(p.data, p, c));
      continue;
    }
    var f = p, m = {};
    SK(f) ? ((0, Ec.setStyleProp)(f.attribs.style, f.attribs), m = f.attribs) : f.attribs && (m = (0, _K.default)(f.attribs, f.name));
    var g = void 0;
    switch (p.type) {
      case "script":
      case "style":
        p.children[0] && (m.dangerouslySetInnerHTML = {
          __html: p.children[0].data
        });
        break;
      case "tag":
        p.name === "textarea" && p.children[0] ? m.defaultValue = p.children[0].data : p.children && p.children.length && (g = d3(p.children, t));
        break;
      default:
        continue;
    }
    u > 1 && (m.key = c), n.push(o(s(p.name, m, g), p, c));
  }
  return n.length === 1 ? n[0] : n;
}
function SK(e) {
  return Ec.PRESERVE_CUSTOM_ATTRIBUTES && e.type === "tag" && (0, Ec.isCustomComponent)(e.name, e.attribs);
}
(function(e) {
  var t = Fn && Fn.__importDefault || function(l) {
    return l && l.__esModule ? l : { default: l };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.htmlToDOM = e.domToReact = e.attributesToProps = e.Text = e.ProcessingInstruction = e.Element = e.Comment = void 0, e.default = s;
  var n = t(EO);
  e.htmlToDOM = n.default;
  var r = t(Xm);
  e.attributesToProps = r.default;
  var o = t(BO);
  e.domToReact = o.default;
  var i = LO;
  Object.defineProperty(e, "Comment", { enumerable: !0, get: function() {
    return i.Comment;
  } }), Object.defineProperty(e, "Element", { enumerable: !0, get: function() {
    return i.Element;
  } }), Object.defineProperty(e, "ProcessingInstruction", { enumerable: !0, get: function() {
    return i.ProcessingInstruction;
  } }), Object.defineProperty(e, "Text", { enumerable: !0, get: function() {
    return i.Text;
  } });
  var a = { lowerCaseAttributeNames: !1 };
  function s(l, u) {
    if (typeof l != "string")
      throw new TypeError("First argument must be a string");
    return l ? (0, o.default)((0, n.default)(l, (u == null ? void 0 : u.htmlparser2) || a), u) : [];
  }
})(q$);
const C_ = /* @__PURE__ */ XG(q$);
C_.default;
function MK(e) {
  const {
    className: t,
    orientation: n = "horizontal",
    ...r
  } = e, o = `arkynDivider ${n} ${t}`;
  return /* @__PURE__ */ mn.jsx("div", { className: o.trim(), ...r });
}
var zn = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function DK(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var aC = { exports: {} }, Bu = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var x_;
function TK() {
  if (x_) return Bu;
  x_ = 1;
  var e = ke, t = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, o = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, i = { key: !0, ref: !0, __self: !0, __source: !0 };
  function a(s, l, u) {
    var c, p = {}, d = null, h = null;
    u !== void 0 && (d = "" + u), l.key !== void 0 && (d = "" + l.key), l.ref !== void 0 && (h = l.ref);
    for (c in l) r.call(l, c) && !i.hasOwnProperty(c) && (p[c] = l[c]);
    if (s && s.defaultProps) for (c in l = s.defaultProps, l) p[c] === void 0 && (p[c] = l[c]);
    return { $$typeof: t, type: s, key: d, ref: h, props: p, _owner: o.current };
  }
  return Bu.Fragment = n, Bu.jsx = a, Bu.jsxs = a, Bu;
}
var Ud = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var O_;
function jK() {
  return O_ || (O_ = 1, process.env.NODE_ENV !== "production" && function() {
    var e = ke, t = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), a = Symbol.for("react.provider"), s = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), c = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), d = Symbol.for("react.lazy"), h = Symbol.for("react.offscreen"), f = Symbol.iterator, m = "@@iterator";
    function g(b) {
      if (b === null || typeof b != "object")
        return null;
      var B = f && b[f] || b[m];
      return typeof B == "function" ? B : null;
    }
    var E = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function w(b) {
      {
        for (var B = arguments.length, G = new Array(B > 1 ? B - 1 : 0), ne = 1; ne < B; ne++)
          G[ne - 1] = arguments[ne];
        M("error", b, G);
      }
    }
    function M(b, B, G) {
      {
        var ne = E.ReactDebugCurrentFrame, le = ne.getStackAddendum();
        le !== "" && (B += "%s", G = G.concat([le]));
        var ce = G.map(function(ae) {
          return String(ae);
        });
        ce.unshift("Warning: " + B), Function.prototype.apply.call(console[b], console, ce);
      }
    }
    var x = !1, y = !1, C = !1, P = !1, F = !1, L;
    L = Symbol.for("react.module.reference");
    function N(b) {
      return !!(typeof b == "string" || typeof b == "function" || b === r || b === i || F || b === o || b === u || b === c || P || b === h || x || y || C || typeof b == "object" && b !== null && (b.$$typeof === d || b.$$typeof === p || b.$$typeof === a || b.$$typeof === s || b.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      b.$$typeof === L || b.getModuleId !== void 0));
    }
    function I(b, B, G) {
      var ne = b.displayName;
      if (ne)
        return ne;
      var le = B.displayName || B.name || "";
      return le !== "" ? G + "(" + le + ")" : G;
    }
    function H(b) {
      return b.displayName || "Context";
    }
    function V(b) {
      if (b == null)
        return null;
      if (typeof b.tag == "number" && w("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof b == "function")
        return b.displayName || b.name || null;
      if (typeof b == "string")
        return b;
      switch (b) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case i:
          return "Profiler";
        case o:
          return "StrictMode";
        case u:
          return "Suspense";
        case c:
          return "SuspenseList";
      }
      if (typeof b == "object")
        switch (b.$$typeof) {
          case s:
            var B = b;
            return H(B) + ".Consumer";
          case a:
            var G = b;
            return H(G._context) + ".Provider";
          case l:
            return I(b, b.render, "ForwardRef");
          case p:
            var ne = b.displayName || null;
            return ne !== null ? ne : V(b.type) || "Memo";
          case d: {
            var le = b, ce = le._payload, ae = le._init;
            try {
              return V(ae(ce));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var z = Object.assign, q = 0, K, J, te, ee, _, D, $;
    function S() {
    }
    S.__reactDisabledLog = !0;
    function W() {
      {
        if (q === 0) {
          K = console.log, J = console.info, te = console.warn, ee = console.error, _ = console.group, D = console.groupCollapsed, $ = console.groupEnd;
          var b = {
            configurable: !0,
            enumerable: !0,
            value: S,
            writable: !0
          };
          Object.defineProperties(console, {
            info: b,
            log: b,
            warn: b,
            error: b,
            group: b,
            groupCollapsed: b,
            groupEnd: b
          });
        }
        q++;
      }
    }
    function O() {
      {
        if (q--, q === 0) {
          var b = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: z({}, b, {
              value: K
            }),
            info: z({}, b, {
              value: J
            }),
            warn: z({}, b, {
              value: te
            }),
            error: z({}, b, {
              value: ee
            }),
            group: z({}, b, {
              value: _
            }),
            groupCollapsed: z({}, b, {
              value: D
            }),
            groupEnd: z({}, b, {
              value: $
            })
          });
        }
        q < 0 && w("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var T = E.ReactCurrentDispatcher, U;
    function j(b, B, G) {
      {
        if (U === void 0)
          try {
            throw Error();
          } catch (le) {
            var ne = le.stack.trim().match(/\n( *(at )?)/);
            U = ne && ne[1] || "";
          }
        return `
` + U + b;
      }
    }
    var Z = !1, A;
    {
      var Q = typeof WeakMap == "function" ? WeakMap : Map;
      A = new Q();
    }
    function R(b, B) {
      if (!b || Z)
        return "";
      {
        var G = A.get(b);
        if (G !== void 0)
          return G;
      }
      var ne;
      Z = !0;
      var le = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var ce;
      ce = T.current, T.current = null, W();
      try {
        if (B) {
          var ae = function() {
            throw Error();
          };
          if (Object.defineProperty(ae.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(ae, []);
            } catch (Ne) {
              ne = Ne;
            }
            Reflect.construct(b, [], ae);
          } else {
            try {
              ae.call();
            } catch (Ne) {
              ne = Ne;
            }
            b.call(ae.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Ne) {
            ne = Ne;
          }
          b();
        }
      } catch (Ne) {
        if (Ne && ne && typeof Ne.stack == "string") {
          for (var ie = Ne.stack.split(`
`), Me = ne.stack.split(`
`), he = ie.length - 1, me = Me.length - 1; he >= 1 && me >= 0 && ie[he] !== Me[me]; )
            me--;
          for (; he >= 1 && me >= 0; he--, me--)
            if (ie[he] !== Me[me]) {
              if (he !== 1 || me !== 1)
                do
                  if (he--, me--, me < 0 || ie[he] !== Me[me]) {
                    var qe = `
` + ie[he].replace(" at new ", " at ");
                    return b.displayName && qe.includes("<anonymous>") && (qe = qe.replace("<anonymous>", b.displayName)), typeof b == "function" && A.set(b, qe), qe;
                  }
                while (he >= 1 && me >= 0);
              break;
            }
        }
      } finally {
        Z = !1, T.current = ce, O(), Error.prepareStackTrace = le;
      }
      var Lt = b ? b.displayName || b.name : "", gt = Lt ? j(Lt) : "";
      return typeof b == "function" && A.set(b, gt), gt;
    }
    function ue(b, B, G) {
      return R(b, !1);
    }
    function fe(b) {
      var B = b.prototype;
      return !!(B && B.isReactComponent);
    }
    function oe(b, B, G) {
      if (b == null)
        return "";
      if (typeof b == "function")
        return R(b, fe(b));
      if (typeof b == "string")
        return j(b);
      switch (b) {
        case u:
          return j("Suspense");
        case c:
          return j("SuspenseList");
      }
      if (typeof b == "object")
        switch (b.$$typeof) {
          case l:
            return ue(b.render);
          case p:
            return oe(b.type, B, G);
          case d: {
            var ne = b, le = ne._payload, ce = ne._init;
            try {
              return oe(ce(le), B, G);
            } catch {
            }
          }
        }
      return "";
    }
    var Re = Object.prototype.hasOwnProperty, He = {}, Ve = E.ReactDebugCurrentFrame;
    function ze(b) {
      if (b) {
        var B = b._owner, G = oe(b.type, b._source, B ? B.type : null);
        Ve.setExtraStackFrame(G);
      } else
        Ve.setExtraStackFrame(null);
    }
    function et(b, B, G, ne, le) {
      {
        var ce = Function.call.bind(Re);
        for (var ae in b)
          if (ce(b, ae)) {
            var ie = void 0;
            try {
              if (typeof b[ae] != "function") {
                var Me = Error((ne || "React class") + ": " + G + " type `" + ae + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof b[ae] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw Me.name = "Invariant Violation", Me;
              }
              ie = b[ae](B, ae, ne, G, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (he) {
              ie = he;
            }
            ie && !(ie instanceof Error) && (ze(le), w("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", ne || "React class", G, ae, typeof ie), ze(null)), ie instanceof Error && !(ie.message in He) && (He[ie.message] = !0, ze(le), w("Failed %s type: %s", G, ie.message), ze(null));
          }
      }
    }
    var Ge = Array.isArray;
    function Pe(b) {
      return Ge(b);
    }
    function Ye(b) {
      {
        var B = typeof Symbol == "function" && Symbol.toStringTag, G = B && b[Symbol.toStringTag] || b.constructor.name || "Object";
        return G;
      }
    }
    function it(b) {
      try {
        return _e(b), !1;
      } catch {
        return !0;
      }
    }
    function _e(b) {
      return "" + b;
    }
    function Se(b) {
      if (it(b))
        return w("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Ye(b)), _e(b);
    }
    var Ke = E.ReactCurrentOwner, We = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, Ue, nt;
    function Ie(b) {
      if (Re.call(b, "ref")) {
        var B = Object.getOwnPropertyDescriptor(b, "ref").get;
        if (B && B.isReactWarning)
          return !1;
      }
      return b.ref !== void 0;
    }
    function xt(b) {
      if (Re.call(b, "key")) {
        var B = Object.getOwnPropertyDescriptor(b, "key").get;
        if (B && B.isReactWarning)
          return !1;
      }
      return b.key !== void 0;
    }
    function ot(b, B) {
      typeof b.ref == "string" && Ke.current;
    }
    function st(b, B) {
      {
        var G = function() {
          Ue || (Ue = !0, w("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", B));
        };
        G.isReactWarning = !0, Object.defineProperty(b, "key", {
          get: G,
          configurable: !0
        });
      }
    }
    function lt(b, B) {
      {
        var G = function() {
          nt || (nt = !0, w("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", B));
        };
        G.isReactWarning = !0, Object.defineProperty(b, "ref", {
          get: G,
          configurable: !0
        });
      }
    }
    var Ot = function(b, B, G, ne, le, ce, ae) {
      var ie = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: b,
        key: B,
        ref: G,
        props: ae,
        // Record the component responsible for creating this element.
        _owner: ce
      };
      return ie._store = {}, Object.defineProperty(ie._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(ie, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ne
      }), Object.defineProperty(ie, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: le
      }), Object.freeze && (Object.freeze(ie.props), Object.freeze(ie)), ie;
    };
    function ut(b, B, G, ne, le) {
      {
        var ce, ae = {}, ie = null, Me = null;
        G !== void 0 && (Se(G), ie = "" + G), xt(B) && (Se(B.key), ie = "" + B.key), Ie(B) && (Me = B.ref, ot(B));
        for (ce in B)
          Re.call(B, ce) && !We.hasOwnProperty(ce) && (ae[ce] = B[ce]);
        if (b && b.defaultProps) {
          var he = b.defaultProps;
          for (ce in he)
            ae[ce] === void 0 && (ae[ce] = he[ce]);
        }
        if (ie || Me) {
          var me = typeof b == "function" ? b.displayName || b.name || "Unknown" : b;
          ie && st(ae, me), Me && lt(ae, me);
        }
        return Ot(b, ie, Me, le, ne, Ke.current, ae);
      }
    }
    var ct = E.ReactCurrentOwner, tt = E.ReactDebugCurrentFrame;
    function Xe(b) {
      if (b) {
        var B = b._owner, G = oe(b.type, b._source, B ? B.type : null);
        tt.setExtraStackFrame(G);
      } else
        tt.setExtraStackFrame(null);
    }
    var Et;
    Et = !1;
    function kt(b) {
      return typeof b == "object" && b !== null && b.$$typeof === t;
    }
    function pt() {
      {
        if (ct.current) {
          var b = V(ct.current.type);
          if (b)
            return `

Check the render method of \`` + b + "`.";
        }
        return "";
      }
    }
    function kn(b) {
      return "";
    }
    var dt = {};
    function Ln(b) {
      {
        var B = pt();
        if (!B) {
          var G = typeof b == "string" ? b : b.displayName || b.name;
          G && (B = `

Check the top-level render call using <` + G + ">.");
        }
        return B;
      }
    }
    function ft(b, B) {
      {
        if (!b._store || b._store.validated || b.key != null)
          return;
        b._store.validated = !0;
        var G = Ln(B);
        if (dt[G])
          return;
        dt[G] = !0;
        var ne = "";
        b && b._owner && b._owner !== ct.current && (ne = " It was passed a child from " + V(b._owner.type) + "."), Xe(b), w('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', G, ne), Xe(null);
      }
    }
    function rn(b, B) {
      {
        if (typeof b != "object")
          return;
        if (Pe(b))
          for (var G = 0; G < b.length; G++) {
            var ne = b[G];
            kt(ne) && ft(ne, B);
          }
        else if (kt(b))
          b._store && (b._store.validated = !0);
        else if (b) {
          var le = g(b);
          if (typeof le == "function" && le !== b.entries)
            for (var ce = le.call(b), ae; !(ae = ce.next()).done; )
              kt(ae.value) && ft(ae.value, B);
        }
      }
    }
    function br(b) {
      {
        var B = b.type;
        if (B == null || typeof B == "string")
          return;
        var G;
        if (typeof B == "function")
          G = B.propTypes;
        else if (typeof B == "object" && (B.$$typeof === l || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        B.$$typeof === p))
          G = B.propTypes;
        else
          return;
        if (G) {
          var ne = V(B);
          et(G, b.props, "prop", ne, b);
        } else if (B.PropTypes !== void 0 && !Et) {
          Et = !0;
          var le = V(B);
          w("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", le || "Unknown");
        }
        typeof B.getDefaultProps == "function" && !B.getDefaultProps.isReactClassApproved && w("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function ht(b) {
      {
        for (var B = Object.keys(b.props), G = 0; G < B.length; G++) {
          var ne = B[G];
          if (ne !== "children" && ne !== "key") {
            Xe(b), w("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", ne), Xe(null);
            break;
          }
        }
        b.ref !== null && (Xe(b), w("Invalid attribute `ref` supplied to `React.Fragment`."), Xe(null));
      }
    }
    var re = {};
    function eo(b, B, G, ne, le, ce) {
      {
        var ae = N(b);
        if (!ae) {
          var ie = "";
          (b === void 0 || typeof b == "object" && b !== null && Object.keys(b).length === 0) && (ie += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var Me = kn();
          Me ? ie += Me : ie += pt();
          var he;
          b === null ? he = "null" : Pe(b) ? he = "array" : b !== void 0 && b.$$typeof === t ? (he = "<" + (V(b.type) || "Unknown") + " />", ie = " Did you accidentally export a JSX literal instead of a component?") : he = typeof b, w("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", he, ie);
        }
        var me = ut(b, B, G, le, ce);
        if (me == null)
          return me;
        if (ae) {
          var qe = B.children;
          if (qe !== void 0)
            if (ne)
              if (Pe(qe)) {
                for (var Lt = 0; Lt < qe.length; Lt++)
                  rn(qe[Lt], b);
                Object.freeze && Object.freeze(qe);
              } else
                w("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              rn(qe, b);
        }
        if (Re.call(B, "key")) {
          var gt = V(b), Ne = Object.keys(B).filter(function(_i) {
            return _i !== "key";
          }), wr = Ne.length > 0 ? "{key: someKey, " + Ne.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!re[gt + wr]) {
            var Li = Ne.length > 0 ? "{" + Ne.join(": ..., ") + ": ...}" : "{}";
            w(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, wr, gt, Li, gt), re[gt + wr] = !0;
          }
        }
        return b === r ? ht(me) : br(me), me;
      }
    }
    function xi(b, B, G) {
      return eo(b, B, G, !0);
    }
    function Oi(b, B, G) {
      return eo(b, B, G, !1);
    }
    var Ei = Oi, ki = xi;
    Ud.Fragment = r, Ud.jsx = Ei, Ud.jsxs = ki;
  }()), Ud;
}
process.env.NODE_ENV === "production" ? aC.exports = TK() : aC.exports = jK();
var no = aC.exports;
Ze({});
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function E_(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function ho(e) {
  var t, n;
  return E_(e) === !1 ? !1 : (t = e.constructor, t === void 0 ? !0 : (n = t.prototype, !(E_(n) === !1 || n.hasOwnProperty("isPrototypeOf") === !1)));
}
var f3 = Symbol.for("immer-nothing"), k_ = Symbol.for("immer-draftable"), ri = Symbol.for("immer-state"), AK = process.env.NODE_ENV !== "production" ? [
  // All error codes, starting by 0:
  function(e) {
    return `The plugin for '${e}' has not been loaded into Immer. To enable the plugin, import and call \`enable${e}()\` when initializing your application.`;
  },
  function(e) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${e}'`;
  },
  "This object has been frozen and should not be mutated",
  function(e) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + e;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(e) {
    return `'current' expects a draft, got: ${e}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(e) {
    return `'original' expects a draft, got: ${e}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function To(e, ...t) {
  if (process.env.NODE_ENV !== "production") {
    const n = AK[e], r = typeof n == "function" ? n.apply(null, t) : n;
    throw new Error(`[Immer] ${r}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var iu = Object.getPrototypeOf;
function El(e) {
  return !!e && !!e[ri];
}
function kl(e) {
  var t;
  return e ? h3(e) || Array.isArray(e) || !!e[k_] || !!((t = e.constructor) != null && t[k_]) || tv(e) || nv(e) : !1;
}
var BK = Object.prototype.constructor.toString();
function h3(e) {
  if (!e || typeof e != "object")
    return !1;
  const t = iu(e);
  if (t === null)
    return !0;
  const n = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
  return n === Object ? !0 : typeof n == "function" && Function.toString.call(n) === BK;
}
function Yh(e, t) {
  ev(e) === 0 ? Reflect.ownKeys(e).forEach((n) => {
    t(n, e[n], e);
  }) : e.forEach((n, r) => t(r, n, e));
}
function ev(e) {
  const t = e[ri];
  return t ? t.type_ : Array.isArray(e) ? 1 : tv(e) ? 2 : nv(e) ? 3 : 0;
}
function lC(e, t) {
  return ev(e) === 2 ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t);
}
function g3(e, t, n) {
  const r = ev(e);
  r === 2 ? e.set(t, n) : r === 3 ? e.add(n) : e[t] = n;
}
function IK(e, t) {
  return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && t !== t;
}
function tv(e) {
  return e instanceof Map;
}
function nv(e) {
  return e instanceof Set;
}
function Xa(e) {
  return e.copy_ || e.base_;
}
function uC(e, t) {
  if (tv(e))
    return new Map(e);
  if (nv(e))
    return new Set(e);
  if (Array.isArray(e))
    return Array.prototype.slice.call(e);
  const n = h3(e);
  if (t === !0 || t === "class_only" && !n) {
    const r = Object.getOwnPropertyDescriptors(e);
    delete r[ri];
    let o = Reflect.ownKeys(r);
    for (let i = 0; i < o.length; i++) {
      const a = o[i], s = r[a];
      s.writable === !1 && (s.writable = !0, s.configurable = !0), (s.get || s.set) && (r[a] = {
        configurable: !0,
        writable: !0,
        // could live with !!desc.set as well here...
        enumerable: s.enumerable,
        value: e[a]
      });
    }
    return Object.create(iu(e), r);
  } else {
    const r = iu(e);
    if (r !== null && n)
      return { ...e };
    const o = Object.create(r);
    return Object.assign(o, e);
  }
}
function IO(e, t = !1) {
  return rv(e) || El(e) || !kl(e) || (ev(e) > 1 && (e.set = e.add = e.clear = e.delete = RK), Object.freeze(e), t && Object.entries(e).forEach(([n, r]) => IO(r, !0))), e;
}
function RK() {
  To(2);
}
function rv(e) {
  return Object.isFrozen(e);
}
var NK = {};
function Ll(e) {
  const t = NK[e];
  return t || To(0, e), t;
}
var op;
function m3() {
  return op;
}
function FK(e, t) {
  return {
    drafts_: [],
    parent_: e,
    immer_: t,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0
  };
}
function L_(e, t) {
  t && (Ll("Patches"), e.patches_ = [], e.inversePatches_ = [], e.patchListener_ = t);
}
function cC(e) {
  pC(e), e.drafts_.forEach(zK), e.drafts_ = null;
}
function pC(e) {
  e === op && (op = e.parent_);
}
function __(e) {
  return op = FK(op, e);
}
function zK(e) {
  const t = e[ri];
  t.type_ === 0 || t.type_ === 1 ? t.revoke_() : t.revoked_ = !0;
}
function P_(e, t) {
  t.unfinalizedDrafts_ = t.drafts_.length;
  const n = t.drafts_[0];
  return e !== void 0 && e !== n ? (n[ri].modified_ && (cC(t), To(4)), kl(e) && (e = Jh(t, e), t.parent_ || Qh(t, e)), t.patches_ && Ll("Patches").generateReplacementPatches_(
    n[ri].base_,
    e,
    t.patches_,
    t.inversePatches_
  )) : e = Jh(t, n, []), cC(t), t.patches_ && t.patchListener_(t.patches_, t.inversePatches_), e !== f3 ? e : void 0;
}
function Jh(e, t, n) {
  if (rv(t))
    return t;
  const r = t[ri];
  if (!r)
    return Yh(
      t,
      (o, i) => S_(e, r, t, o, i, n)
    ), t;
  if (r.scope_ !== e)
    return t;
  if (!r.modified_)
    return Qh(e, r.base_, !0), r.base_;
  if (!r.finalized_) {
    r.finalized_ = !0, r.scope_.unfinalizedDrafts_--;
    const o = r.copy_;
    let i = o, a = !1;
    r.type_ === 3 && (i = new Set(o), o.clear(), a = !0), Yh(
      i,
      (s, l) => S_(e, r, o, s, l, n, a)
    ), Qh(e, o, !1), n && e.patches_ && Ll("Patches").generatePatches_(
      r,
      n,
      e.patches_,
      e.inversePatches_
    );
  }
  return r.copy_;
}
function S_(e, t, n, r, o, i, a) {
  if (process.env.NODE_ENV !== "production" && o === n && To(5), El(o)) {
    const s = i && t && t.type_ !== 3 && // Set objects are atomic since they have no keys.
    !lC(t.assigned_, r) ? i.concat(r) : void 0, l = Jh(e, o, s);
    if (g3(n, r, l), El(l))
      e.canAutoFreeze_ = !1;
    else
      return;
  } else a && n.add(o);
  if (kl(o) && !rv(o)) {
    if (!e.immer_.autoFreeze_ && e.unfinalizedDrafts_ < 1)
      return;
    Jh(e, o), (!t || !t.scope_.parent_) && typeof r != "symbol" && Object.prototype.propertyIsEnumerable.call(n, r) && Qh(e, o);
  }
}
function Qh(e, t, n = !1) {
  !e.parent_ && e.immer_.autoFreeze_ && e.canAutoFreeze_ && IO(t, n);
}
function UK(e, t) {
  const n = Array.isArray(e), r = {
    type_: n ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: t ? t.scope_ : m3(),
    // True for both shallow and deep changes.
    modified_: !1,
    // Used during finalization.
    finalized_: !1,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: t,
    // The base state.
    base_: e,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: !1
  };
  let o = r, i = RO;
  n && (o = [r], i = ip);
  const { revoke: a, proxy: s } = Proxy.revocable(o, i);
  return r.draft_ = s, r.revoke_ = a, s;
}
var RO = {
  get(e, t) {
    if (t === ri)
      return e;
    const n = Xa(e);
    if (!lC(n, t))
      return $K(e, n, t);
    const r = n[t];
    return e.finalized_ || !kl(r) ? r : r === tb(e.base_, t) ? (nb(e), e.copy_[t] = fC(r, e)) : r;
  },
  has(e, t) {
    return t in Xa(e);
  },
  ownKeys(e) {
    return Reflect.ownKeys(Xa(e));
  },
  set(e, t, n) {
    const r = v3(Xa(e), t);
    if (r != null && r.set)
      return r.set.call(e.draft_, n), !0;
    if (!e.modified_) {
      const o = tb(Xa(e), t), i = o == null ? void 0 : o[ri];
      if (i && i.base_ === n)
        return e.copy_[t] = n, e.assigned_[t] = !1, !0;
      if (IK(n, o) && (n !== void 0 || lC(e.base_, t)))
        return !0;
      nb(e), dC(e);
    }
    return e.copy_[t] === n && // special case: handle new props with value 'undefined'
    (n !== void 0 || t in e.copy_) || // special case: NaN
    Number.isNaN(n) && Number.isNaN(e.copy_[t]) || (e.copy_[t] = n, e.assigned_[t] = !0), !0;
  },
  deleteProperty(e, t) {
    return tb(e.base_, t) !== void 0 || t in e.base_ ? (e.assigned_[t] = !1, nb(e), dC(e)) : delete e.assigned_[t], e.copy_ && delete e.copy_[t], !0;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(e, t) {
    const n = Xa(e), r = Reflect.getOwnPropertyDescriptor(n, t);
    return r && {
      writable: !0,
      configurable: e.type_ !== 1 || t !== "length",
      enumerable: r.enumerable,
      value: n[t]
    };
  },
  defineProperty() {
    To(11);
  },
  getPrototypeOf(e) {
    return iu(e.base_);
  },
  setPrototypeOf() {
    To(12);
  }
}, ip = {};
Yh(RO, (e, t) => {
  ip[e] = function() {
    return arguments[0] = arguments[0][0], t.apply(this, arguments);
  };
});
ip.deleteProperty = function(e, t) {
  return process.env.NODE_ENV !== "production" && isNaN(parseInt(t)) && To(13), ip.set.call(this, e, t, void 0);
};
ip.set = function(e, t, n) {
  return process.env.NODE_ENV !== "production" && t !== "length" && isNaN(parseInt(t)) && To(14), RO.set.call(this, e[0], t, n, e[0]);
};
function tb(e, t) {
  const n = e[ri];
  return (n ? Xa(n) : e)[t];
}
function $K(e, t, n) {
  var r;
  const o = v3(t, n);
  return o ? "value" in o ? o.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (r = o.get) == null ? void 0 : r.call(e.draft_)
  ) : void 0;
}
function v3(e, t) {
  if (!(t in e))
    return;
  let n = iu(e);
  for (; n; ) {
    const r = Object.getOwnPropertyDescriptor(n, t);
    if (r)
      return r;
    n = iu(n);
  }
}
function dC(e) {
  e.modified_ || (e.modified_ = !0, e.parent_ && dC(e.parent_));
}
function nb(e) {
  e.copy_ || (e.copy_ = uC(
    e.base_,
    e.scope_.immer_.useStrictShallowCopy_
  ));
}
var HK = class {
  constructor(e) {
    this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.produce = (t, n, r) => {
      if (typeof t == "function" && typeof n != "function") {
        const i = n;
        n = t;
        const a = this;
        return function(s = i, ...l) {
          return a.produce(s, (u) => n.call(this, u, ...l));
        };
      }
      typeof n != "function" && To(6), r !== void 0 && typeof r != "function" && To(7);
      let o;
      if (kl(t)) {
        const i = __(this), a = fC(t, void 0);
        let s = !0;
        try {
          o = n(a), s = !1;
        } finally {
          s ? cC(i) : pC(i);
        }
        return L_(i, r), P_(o, i);
      } else if (!t || typeof t != "object") {
        if (o = n(t), o === void 0 && (o = t), o === f3 && (o = void 0), this.autoFreeze_ && IO(o, !0), r) {
          const i = [], a = [];
          Ll("Patches").generateReplacementPatches_(t, o, i, a), r(i, a);
        }
        return o;
      } else
        To(1, t);
    }, this.produceWithPatches = (t, n) => {
      if (typeof t == "function")
        return (i, ...a) => this.produceWithPatches(i, (s) => t(s, ...a));
      let r, o;
      return [this.produce(t, n, (i, a) => {
        r = i, o = a;
      }), r, o];
    }, typeof (e == null ? void 0 : e.autoFreeze) == "boolean" && this.setAutoFreeze(e.autoFreeze), typeof (e == null ? void 0 : e.useStrictShallowCopy) == "boolean" && this.setUseStrictShallowCopy(e.useStrictShallowCopy);
  }
  createDraft(e) {
    kl(e) || To(8), El(e) && (e = WK(e));
    const t = __(this), n = fC(e, void 0);
    return n[ri].isManual_ = !0, pC(t), n;
  }
  finishDraft(e, t) {
    const n = e && e[ri];
    (!n || !n.isManual_) && To(9);
    const { scope_: r } = n;
    return L_(r, t), P_(void 0, r);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(e) {
    this.autoFreeze_ = e;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(e) {
    this.useStrictShallowCopy_ = e;
  }
  applyPatches(e, t) {
    let n;
    for (n = t.length - 1; n >= 0; n--) {
      const o = t[n];
      if (o.path.length === 0 && o.op === "replace") {
        e = o.value;
        break;
      }
    }
    n > -1 && (t = t.slice(n + 1));
    const r = Ll("Patches").applyPatches_;
    return El(e) ? r(e, t) : this.produce(
      e,
      (o) => r(o, t)
    );
  }
};
function fC(e, t) {
  const n = tv(e) ? Ll("MapSet").proxyMap_(e, t) : nv(e) ? Ll("MapSet").proxySet_(e, t) : UK(e, t);
  return (t ? t.scope_ : m3()).drafts_.push(n), n;
}
function WK(e) {
  return El(e) || To(10, e), y3(e);
}
function y3(e) {
  if (!kl(e) || rv(e))
    return e;
  const t = e[ri];
  let n;
  if (t) {
    if (!t.modified_)
      return t.base_;
    t.finalized_ = !0, n = uC(e, t.scope_.immer_.useStrictShallowCopy_);
  } else
    n = uC(e, !0);
  return Yh(n, (r, o) => {
    g3(n, r, y3(o));
  }), t && (t.finalized_ = !1), n;
}
var oi = new HK(), NO = oi.produce;
oi.produceWithPatches.bind(
  oi
);
oi.setAutoFreeze.bind(oi);
oi.setUseStrictShallowCopy.bind(oi);
oi.applyPatches.bind(oi);
var M_ = oi.createDraft.bind(oi), D_ = oi.finishDraft.bind(oi), Te = {
  ancestors(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = Te.levels(e, t);
    return n ? r = r.slice(1) : r = r.slice(0, -1), r;
  },
  common(e, t) {
    for (var n = [], r = 0; r < e.length && r < t.length; r++) {
      var o = e[r], i = t[r];
      if (o !== i)
        break;
      n.push(o);
    }
    return n;
  },
  compare(e, t) {
    for (var n = Math.min(e.length, t.length), r = 0; r < n; r++) {
      if (e[r] < t[r]) return -1;
      if (e[r] > t[r]) return 1;
    }
    return 0;
  },
  endsAfter(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return Te.equals(r, o) && i > a;
  },
  endsAt(e, t) {
    var n = e.length, r = e.slice(0, n), o = t.slice(0, n);
    return Te.equals(r, o);
  },
  endsBefore(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return Te.equals(r, o) && i < a;
  },
  equals(e, t) {
    return e.length === t.length && e.every((n, r) => n === t[r]);
  },
  hasPrevious(e) {
    return e[e.length - 1] > 0;
  },
  isAfter(e, t) {
    return Te.compare(e, t) === 1;
  },
  isAncestor(e, t) {
    return e.length < t.length && Te.compare(e, t) === 0;
  },
  isBefore(e, t) {
    return Te.compare(e, t) === -1;
  },
  isChild(e, t) {
    return e.length === t.length + 1 && Te.compare(e, t) === 0;
  },
  isCommon(e, t) {
    return e.length <= t.length && Te.compare(e, t) === 0;
  },
  isDescendant(e, t) {
    return e.length > t.length && Te.compare(e, t) === 0;
  },
  isParent(e, t) {
    return e.length + 1 === t.length && Te.compare(e, t) === 0;
  },
  isPath(e) {
    return Array.isArray(e) && (e.length === 0 || typeof e[0] == "number");
  },
  isSibling(e, t) {
    if (e.length !== t.length)
      return !1;
    var n = e.slice(0, -1), r = t.slice(0, -1), o = e[e.length - 1], i = t[t.length - 1];
    return o !== i && Te.equals(n, r);
  },
  levels(e) {
    for (var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = [], o = 0; o <= e.length; o++)
      r.push(e.slice(0, o));
    return n && r.reverse(), r;
  },
  next(e) {
    if (e.length === 0)
      throw new Error("Cannot get the next path of a root path [".concat(e, "], because it has no next index."));
    var t = e[e.length - 1];
    return e.slice(0, -1).concat(t + 1);
  },
  operationCanTransformPath(e) {
    switch (e.type) {
      case "insert_node":
      case "remove_node":
      case "merge_node":
      case "split_node":
      case "move_node":
        return !0;
      default:
        return !1;
    }
  },
  parent(e) {
    if (e.length === 0)
      throw new Error("Cannot get the parent path of the root path [".concat(e, "]."));
    return e.slice(0, -1);
  },
  previous(e) {
    if (e.length === 0)
      throw new Error("Cannot get the previous path of a root path [".concat(e, "], because it has no previous index."));
    var t = e[e.length - 1];
    if (t <= 0)
      throw new Error("Cannot get the previous path of a first child path [".concat(e, "] because it would result in a negative index."));
    return e.slice(0, -1).concat(t - 1);
  },
  relative(e, t) {
    if (!Te.isAncestor(t, e) && !Te.equals(e, t))
      throw new Error("Cannot get the relative path of [".concat(e, "] inside ancestor [").concat(t, "], because it is not above or equal to the path."));
    return e.slice(t.length);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!e) return null;
    var r = [...e], {
      affinity: o = "forward"
    } = n;
    if (e.length === 0)
      return r;
    switch (t.type) {
      case "insert_node": {
        var {
          path: i
        } = t;
        (Te.equals(i, r) || Te.endsBefore(i, r) || Te.isAncestor(i, r)) && (r[i.length - 1] += 1);
        break;
      }
      case "remove_node": {
        var {
          path: a
        } = t;
        if (Te.equals(a, r) || Te.isAncestor(a, r))
          return null;
        Te.endsBefore(a, r) && (r[a.length - 1] -= 1);
        break;
      }
      case "merge_node": {
        var {
          path: s,
          position: l
        } = t;
        Te.equals(s, r) || Te.endsBefore(s, r) ? r[s.length - 1] -= 1 : Te.isAncestor(s, r) && (r[s.length - 1] -= 1, r[s.length] += l);
        break;
      }
      case "split_node": {
        var {
          path: u,
          position: c
        } = t;
        if (Te.equals(u, r)) {
          if (o === "forward")
            r[r.length - 1] += 1;
          else if (o !== "backward") return null;
        } else Te.endsBefore(u, r) ? r[u.length - 1] += 1 : Te.isAncestor(u, r) && e[u.length] >= c && (r[u.length - 1] += 1, r[u.length] -= c);
        break;
      }
      case "move_node": {
        var {
          path: p,
          newPath: d
        } = t;
        if (Te.equals(p, d))
          return r;
        if (Te.isAncestor(p, r) || Te.equals(p, r)) {
          var h = d.slice();
          return Te.endsBefore(p, d) && p.length < d.length && (h[p.length - 1] -= 1), h.concat(r.slice(p.length));
        } else Te.isSibling(p, d) && (Te.isAncestor(d, r) || Te.equals(d, r)) ? Te.endsBefore(p, r) ? r[p.length - 1] -= 1 : r[p.length - 1] += 1 : Te.endsBefore(d, r) || Te.equals(d, r) || Te.isAncestor(d, r) ? (Te.endsBefore(p, r) && (r[p.length - 1] -= 1), r[d.length - 1] += 1) : Te.endsBefore(p, r) && (Te.equals(d, r) && (r[d.length - 1] += 1), r[p.length - 1] -= 1);
        break;
      }
    }
    return r;
  }
};
function sp(e) {
  "@babel/helpers - typeof";
  return sp = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, sp(e);
}
function VK(e, t) {
  if (sp(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (sp(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function qK(e) {
  var t = VK(e, "string");
  return sp(t) === "symbol" ? t : String(t);
}
function hu(e, t, n) {
  return t = qK(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function T_(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Iu(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? T_(Object(n), !0).forEach(function(r) {
      hu(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : T_(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var ZK = (e, t, n) => {
  switch (n.type) {
    case "insert_node": {
      var {
        path: r,
        node: o
      } = n, i = yt.parent(e, r), a = r[r.length - 1];
      if (a > i.children.length)
        throw new Error('Cannot apply an "insert_node" operation at path ['.concat(r, "] because the destination is past the end of the node."));
      if (i.children.splice(a, 0, o), t)
        for (var [s, l] of Bt.points(t))
          t[l] = Kn.transform(s, n);
      break;
    }
    case "insert_text": {
      var {
        path: u,
        offset: c,
        text: p
      } = n;
      if (p.length === 0) break;
      var d = yt.leaf(e, u), h = d.text.slice(0, c), f = d.text.slice(c);
      if (d.text = h + p + f, t)
        for (var [m, g] of Bt.points(t))
          t[g] = Kn.transform(m, n);
      break;
    }
    case "merge_node": {
      var {
        path: E
      } = n, w = yt.get(e, E), M = Te.previous(E), x = yt.get(e, M), y = yt.parent(e, E), C = E[E.length - 1];
      if (Br.isText(w) && Br.isText(x))
        x.text += w.text;
      else if (!Br.isText(w) && !Br.isText(x))
        x.children.push(...w.children);
      else
        throw new Error('Cannot apply a "merge_node" operation at path ['.concat(E, "] to nodes of different interfaces: ").concat(Ho.stringify(w), " ").concat(Ho.stringify(x)));
      if (y.children.splice(C, 1), t)
        for (var [P, F] of Bt.points(t))
          t[F] = Kn.transform(P, n);
      break;
    }
    case "move_node": {
      var {
        path: L,
        newPath: N
      } = n;
      if (Te.isAncestor(L, N))
        throw new Error("Cannot move a path [".concat(L, "] to new path [").concat(N, "] because the destination is inside itself."));
      var I = yt.get(e, L), H = yt.parent(e, L), V = L[L.length - 1];
      H.children.splice(V, 1);
      var z = Te.transform(L, n), q = yt.get(e, Te.parent(z)), K = z[z.length - 1];
      if (q.children.splice(K, 0, I), t)
        for (var [J, te] of Bt.points(t))
          t[te] = Kn.transform(J, n);
      break;
    }
    case "remove_node": {
      var {
        path: ee
      } = n, _ = ee[ee.length - 1], D = yt.parent(e, ee);
      if (D.children.splice(_, 1), t)
        for (var [$, S] of Bt.points(t)) {
          var W = Kn.transform($, n);
          if (t != null && W != null)
            t[S] = W;
          else {
            var O = void 0, T = void 0;
            for (var [U, j] of yt.texts(e))
              if (Te.compare(j, ee) === -1)
                O = [U, j];
              else {
                T = [U, j];
                break;
              }
            var Z = !1;
            O && T && (Te.equals(T[1], ee) ? Z = !Te.hasPrevious(T[1]) : Z = Te.common(O[1], ee).length < Te.common(T[1], ee).length), O && !Z ? ($.path = O[1], $.offset = O[0].text.length) : T ? ($.path = T[1], $.offset = 0) : t = null;
          }
        }
      break;
    }
    case "remove_text": {
      var {
        path: A,
        offset: Q,
        text: R
      } = n;
      if (R.length === 0) break;
      var ue = yt.leaf(e, A), fe = ue.text.slice(0, Q), oe = ue.text.slice(Q + R.length);
      if (ue.text = fe + oe, t)
        for (var [Re, He] of Bt.points(t))
          t[He] = Kn.transform(Re, n);
      break;
    }
    case "set_node": {
      var {
        path: Ve,
        properties: ze,
        newProperties: et
      } = n;
      if (Ve.length === 0)
        throw new Error("Cannot set properties on the root node!");
      var Ge = yt.get(e, Ve);
      for (var Pe in et) {
        if (Pe === "children" || Pe === "text")
          throw new Error('Cannot set the "'.concat(Pe, '" property of nodes!'));
        var Ye = et[Pe];
        Ye == null ? delete Ge[Pe] : Ge[Pe] = Ye;
      }
      for (var it in ze)
        et.hasOwnProperty(it) || delete Ge[it];
      break;
    }
    case "set_selection": {
      var {
        newProperties: _e
      } = n;
      if (_e == null)
        t = _e;
      else {
        if (t == null) {
          if (!Bt.isRange(_e))
            throw new Error('Cannot apply an incomplete "set_selection" operation properties '.concat(Ho.stringify(_e), " when there is no current selection."));
          t = Iu({}, _e);
        }
        for (var Se in _e) {
          var Ke = _e[Se];
          if (Ke == null) {
            if (Se === "anchor" || Se === "focus")
              throw new Error('Cannot remove the "'.concat(Se, '" selection property'));
            delete t[Se];
          } else
            t[Se] = Ke;
        }
      }
      break;
    }
    case "split_node": {
      var {
        path: We,
        position: Ue,
        properties: nt
      } = n;
      if (We.length === 0)
        throw new Error('Cannot apply a "split_node" operation at path ['.concat(We, "] because the root node cannot be split."));
      var Ie = yt.get(e, We), xt = yt.parent(e, We), ot = We[We.length - 1], st;
      if (Br.isText(Ie)) {
        var lt = Ie.text.slice(0, Ue), Ot = Ie.text.slice(Ue);
        Ie.text = lt, st = Iu(Iu({}, nt), {}, {
          text: Ot
        });
      } else {
        var ut = Ie.children.slice(0, Ue), ct = Ie.children.slice(Ue);
        Ie.children = ut, st = Iu(Iu({}, nt), {}, {
          children: ct
        });
      }
      if (xt.children.splice(ot + 1, 0, st), t)
        for (var [tt, Xe] of Bt.points(t))
          t[Xe] = Kn.transform(tt, n);
      break;
    }
  }
  return t;
}, GK = {
  transform(e, t) {
    e.children = M_(e.children);
    var n = e.selection && M_(e.selection);
    try {
      n = ZK(e, n, t);
    } finally {
      e.children = D_(e.children), n ? e.selection = El(n) ? D_(n) : n : e.selection = null;
    }
  }
}, XK = {
  insertNodes(e, t, n) {
    e.insertNodes(t, n);
  },
  liftNodes(e, t) {
    e.liftNodes(t);
  },
  mergeNodes(e, t) {
    e.mergeNodes(t);
  },
  moveNodes(e, t) {
    e.moveNodes(t);
  },
  removeNodes(e, t) {
    e.removeNodes(t);
  },
  setNodes(e, t, n) {
    e.setNodes(t, n);
  },
  splitNodes(e, t) {
    e.splitNodes(t);
  },
  unsetNodes(e, t, n) {
    e.unsetNodes(t, n);
  },
  unwrapNodes(e, t) {
    e.unwrapNodes(t);
  },
  wrapNodes(e, t, n) {
    e.wrapNodes(t, n);
  }
}, KK = {
  collapse(e, t) {
    e.collapse(t);
  },
  deselect(e) {
    e.deselect();
  },
  move(e, t) {
    e.move(t);
  },
  select(e, t) {
    e.select(t);
  },
  setPoint(e, t, n) {
    e.setPoint(t, n);
  },
  setSelection(e, t) {
    e.setSelection(t);
  }
}, b3 = (e, t) => {
  for (var n in e) {
    var r = e[n], o = t[n];
    if (ho(r) && ho(o)) {
      if (!b3(r, o)) return !1;
    } else if (Array.isArray(r) && Array.isArray(o)) {
      if (r.length !== o.length) return !1;
      for (var i = 0; i < r.length; i++)
        if (r[i] !== o[i]) return !1;
    } else if (r !== o)
      return !1;
  }
  for (var a in t)
    if (e[a] === void 0 && t[a] !== void 0)
      return !1;
  return !0;
};
function YK(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), o, i;
  for (i = 0; i < r.length; i++)
    o = r[i], !(t.indexOf(o) >= 0) && (n[o] = e[o]);
  return n;
}
function ap(e, t) {
  if (e == null) return {};
  var n = YK(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (o = 0; o < i.length; o++)
      r = i[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
var JK = ["anchor", "focus"];
function j_(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function QK(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? j_(Object(n), !0).forEach(function(r) {
      hu(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : j_(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Bt = {
  edges(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, {
      anchor: r,
      focus: o
    } = e;
    return Bt.isBackward(e) === n ? [r, o] : [o, r];
  },
  end(e) {
    var [, t] = Bt.edges(e);
    return t;
  },
  equals(e, t) {
    return Kn.equals(e.anchor, t.anchor) && Kn.equals(e.focus, t.focus);
  },
  includes(e, t) {
    if (Bt.isRange(t)) {
      if (Bt.includes(e, t.anchor) || Bt.includes(e, t.focus))
        return !0;
      var [n, r] = Bt.edges(e), [o, i] = Bt.edges(t);
      return Kn.isBefore(n, o) && Kn.isAfter(r, i);
    }
    var [a, s] = Bt.edges(e), l = !1, u = !1;
    return Kn.isPoint(t) ? (l = Kn.compare(t, a) >= 0, u = Kn.compare(t, s) <= 0) : (l = Te.compare(t, a.path) >= 0, u = Te.compare(t, s.path) <= 0), l && u;
  },
  intersection(e, t) {
    var n = ap(e, JK), [r, o] = Bt.edges(e), [i, a] = Bt.edges(t), s = Kn.isBefore(r, i) ? i : r, l = Kn.isBefore(o, a) ? o : a;
    return Kn.isBefore(l, s) ? null : QK({
      anchor: s,
      focus: l
    }, n);
  },
  isBackward(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return Kn.isAfter(t, n);
  },
  isCollapsed(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return Kn.equals(t, n);
  },
  isExpanded(e) {
    return !Bt.isCollapsed(e);
  },
  isForward(e) {
    return !Bt.isBackward(e);
  },
  isRange(e) {
    return ho(e) && Kn.isPoint(e.anchor) && Kn.isPoint(e.focus);
  },
  *points(e) {
    yield [e.anchor, "anchor"], yield [e.focus, "focus"];
  },
  start(e) {
    var [t] = Bt.edges(e);
    return t;
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return NO(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "inward"
      } = n, i, a;
      if (o === "inward") {
        var s = Bt.isCollapsed(r);
        Bt.isForward(r) ? (i = "forward", a = s ? i : "backward") : (i = "backward", a = s ? i : "forward");
      } else o === "outward" ? Bt.isForward(r) ? (i = "backward", a = "forward") : (i = "forward", a = "backward") : (i = o, a = o);
      var l = Kn.transform(r.anchor, t, {
        affinity: i
      }), u = Kn.transform(r.focus, t, {
        affinity: a
      });
      if (!l || !u)
        return null;
      r.anchor = l, r.focus = u;
    });
  }
}, A_ = (e) => ho(e) && yt.isNodeList(e.children) && !An.isEditor(e), hs = {
  isAncestor(e) {
    return ho(e) && yt.isNodeList(e.children);
  },
  isElement: A_,
  isElementList(e) {
    return Array.isArray(e) && e.every((t) => hs.isElement(t));
  },
  isElementProps(e) {
    return e.children !== void 0;
  },
  isElementType: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "type";
    return A_(e) && e[n] === t;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "children" && e[n] !== t[n])
        return !1;
    return !0;
  }
}, eY = ["children"], tY = ["text"], B_ = /* @__PURE__ */ new WeakMap(), yt = {
  ancestor(e, t) {
    var n = yt.get(e, t);
    if (Br.isText(n))
      throw new Error("Cannot get the ancestor node at path [".concat(t, "] because it refers to a text node instead: ").concat(Ho.stringify(n)));
    return n;
  },
  ancestors(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of Te.ancestors(t, n)) {
        var o = yt.ancestor(e, r), i = [o, r];
        yield i;
      }
    }();
  },
  child(e, t) {
    if (Br.isText(e))
      throw new Error("Cannot get the child of a text node: ".concat(Ho.stringify(e)));
    var n = e.children[t];
    if (n == null)
      throw new Error("Cannot get child at index `".concat(t, "` in node: ").concat(Ho.stringify(e)));
    return n;
  },
  children(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var {
        reverse: r = !1
      } = n, o = yt.ancestor(e, t), {
        children: i
      } = o, a = r ? i.length - 1 : 0; r ? a >= 0 : a < i.length; ) {
        var s = yt.child(o, a), l = t.concat(a);
        yield [s, l], a = r ? a - 1 : a + 1;
      }
    }();
  },
  common(e, t, n) {
    var r = Te.common(t, n), o = yt.get(e, r);
    return [o, r];
  },
  descendant(e, t) {
    var n = yt.get(e, t);
    if (An.isEditor(n))
      throw new Error("Cannot get the descendant node at path [".concat(t, "] because it refers to the root editor node instead: ").concat(Ho.stringify(n)));
    return n;
  },
  descendants(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of yt.nodes(e, t))
        r.length !== 0 && (yield [n, r]);
    }();
  },
  elements(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of yt.nodes(e, t))
        hs.isElement(n) && (yield [n, r]);
    }();
  },
  extractProps(e) {
    if (hs.isAncestor(e)) {
      var t = ap(e, eY);
      return t;
    } else {
      var t = ap(e, tY);
      return t;
    }
  },
  first(e, t) {
    for (var n = t.slice(), r = yt.get(e, n); r && !(Br.isText(r) || r.children.length === 0); )
      r = r.children[0], n.push(0);
    return [r, n];
  },
  fragment(e, t) {
    if (Br.isText(e))
      throw new Error("Cannot get a fragment starting from a root text node: ".concat(Ho.stringify(e)));
    var n = NO({
      children: e.children
    }, (r) => {
      var [o, i] = Bt.edges(t), a = yt.nodes(r, {
        reverse: !0,
        pass: (d) => {
          var [, h] = d;
          return !Bt.includes(t, h);
        }
      });
      for (var [, s] of a) {
        if (!Bt.includes(t, s)) {
          var l = yt.parent(r, s), u = s[s.length - 1];
          l.children.splice(u, 1);
        }
        if (Te.equals(s, i.path)) {
          var c = yt.leaf(r, s);
          c.text = c.text.slice(0, i.offset);
        }
        if (Te.equals(s, o.path)) {
          var p = yt.leaf(r, s);
          p.text = p.text.slice(o.offset);
        }
      }
      An.isEditor(r) && (r.selection = null);
    });
    return n.children;
  },
  get(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (Br.isText(n) || !n.children[o])
        throw new Error("Cannot find a descendant at path [".concat(t, "] in node: ").concat(Ho.stringify(e)));
      n = n.children[o];
    }
    return n;
  },
  has(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (Br.isText(n) || !n.children[o])
        return !1;
      n = n.children[o];
    }
    return !0;
  },
  isNode(e) {
    return Br.isText(e) || hs.isElement(e) || An.isEditor(e);
  },
  isNodeList(e) {
    if (!Array.isArray(e))
      return !1;
    var t = B_.get(e);
    if (t !== void 0)
      return t;
    var n = e.every((r) => yt.isNode(r));
    return B_.set(e, n), n;
  },
  last(e, t) {
    for (var n = t.slice(), r = yt.get(e, n); r && !(Br.isText(r) || r.children.length === 0); ) {
      var o = r.children.length - 1;
      r = r.children[o], n.push(o);
    }
    return [r, n];
  },
  leaf(e, t) {
    var n = yt.get(e, t);
    if (!Br.isText(n))
      throw new Error("Cannot get the leaf node at path [".concat(t, "] because it refers to a non-leaf node: ").concat(Ho.stringify(n)));
    return n;
  },
  levels(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of Te.levels(t, n)) {
        var o = yt.get(e, r);
        yield [o, r];
      }
    }();
  },
  matches(e, t) {
    return hs.isElement(e) && hs.isElementProps(t) && hs.matches(e, t) || Br.isText(e) && Br.isTextProps(t) && Br.matches(e, t);
  },
  nodes(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var {
        pass: n,
        reverse: r = !1
      } = t, {
        from: o = [],
        to: i
      } = t, a = /* @__PURE__ */ new Set(), s = [], l = e; !(i && (r ? Te.isBefore(s, i) : Te.isAfter(s, i))); ) {
        if (a.has(l) || (yield [l, s]), !a.has(l) && !Br.isText(l) && l.children.length !== 0 && (n == null || n([l, s]) === !1)) {
          a.add(l);
          var u = r ? l.children.length - 1 : 0;
          Te.isAncestor(s, o) && (u = o[s.length]), s = s.concat(u), l = yt.get(e, s);
          continue;
        }
        if (s.length === 0)
          break;
        if (!r) {
          var c = Te.next(s);
          if (yt.has(e, c)) {
            s = c, l = yt.get(e, s);
            continue;
          }
        }
        if (r && s[s.length - 1] !== 0) {
          var p = Te.previous(s);
          s = p, l = yt.get(e, s);
          continue;
        }
        s = Te.parent(s), l = yt.get(e, s), a.add(l);
      }
    }();
  },
  parent(e, t) {
    var n = Te.parent(t), r = yt.get(e, n);
    if (Br.isText(r))
      throw new Error("Cannot get the parent of path [".concat(t, "] because it does not exist in the root."));
    return r;
  },
  string(e) {
    return Br.isText(e) ? e.text : e.children.map(yt.string).join("");
  },
  texts(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of yt.nodes(e, t))
        Br.isText(n) && (yield [n, r]);
    }();
  }
};
function I_(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function nr(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? I_(Object(n), !0).forEach(function(r) {
      hu(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : I_(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var dc = {
  isNodeOperation(e) {
    return dc.isOperation(e) && e.type.endsWith("_node");
  },
  isOperation(e) {
    if (!ho(e))
      return !1;
    switch (e.type) {
      case "insert_node":
        return Te.isPath(e.path) && yt.isNode(e.node);
      case "insert_text":
        return typeof e.offset == "number" && typeof e.text == "string" && Te.isPath(e.path);
      case "merge_node":
        return typeof e.position == "number" && Te.isPath(e.path) && ho(e.properties);
      case "move_node":
        return Te.isPath(e.path) && Te.isPath(e.newPath);
      case "remove_node":
        return Te.isPath(e.path) && yt.isNode(e.node);
      case "remove_text":
        return typeof e.offset == "number" && typeof e.text == "string" && Te.isPath(e.path);
      case "set_node":
        return Te.isPath(e.path) && ho(e.properties) && ho(e.newProperties);
      case "set_selection":
        return e.properties === null && Bt.isRange(e.newProperties) || e.newProperties === null && Bt.isRange(e.properties) || ho(e.properties) && ho(e.newProperties);
      case "split_node":
        return Te.isPath(e.path) && typeof e.position == "number" && ho(e.properties);
      default:
        return !1;
    }
  },
  isOperationList(e) {
    return Array.isArray(e) && e.every((t) => dc.isOperation(t));
  },
  isSelectionOperation(e) {
    return dc.isOperation(e) && e.type.endsWith("_selection");
  },
  isTextOperation(e) {
    return dc.isOperation(e) && e.type.endsWith("_text");
  },
  inverse(e) {
    switch (e.type) {
      case "insert_node":
        return nr(nr({}, e), {}, {
          type: "remove_node"
        });
      case "insert_text":
        return nr(nr({}, e), {}, {
          type: "remove_text"
        });
      case "merge_node":
        return nr(nr({}, e), {}, {
          type: "split_node",
          path: Te.previous(e.path)
        });
      case "move_node": {
        var {
          newPath: t,
          path: n
        } = e;
        if (Te.equals(t, n))
          return e;
        if (Te.isSibling(n, t))
          return nr(nr({}, e), {}, {
            path: t,
            newPath: n
          });
        var r = Te.transform(n, e), o = Te.transform(Te.next(n), e);
        return nr(nr({}, e), {}, {
          path: r,
          newPath: o
        });
      }
      case "remove_node":
        return nr(nr({}, e), {}, {
          type: "insert_node"
        });
      case "remove_text":
        return nr(nr({}, e), {}, {
          type: "insert_text"
        });
      case "set_node": {
        var {
          properties: i,
          newProperties: a
        } = e;
        return nr(nr({}, e), {}, {
          properties: a,
          newProperties: i
        });
      }
      case "set_selection": {
        var {
          properties: s,
          newProperties: l
        } = e;
        return s == null ? nr(nr({}, e), {}, {
          properties: l,
          newProperties: null
        }) : l == null ? nr(nr({}, e), {}, {
          properties: null,
          newProperties: s
        }) : nr(nr({}, e), {}, {
          properties: l,
          newProperties: s
        });
      }
      case "split_node":
        return nr(nr({}, e), {}, {
          type: "merge_node",
          path: Te.next(e.path)
        });
    }
  }
}, R_ = /* @__PURE__ */ new WeakMap(), nY = (e) => {
  var t = R_.get(e);
  if (t !== void 0)
    return t;
  if (!ho(e))
    return !1;
  var n = typeof e.addMark == "function" && typeof e.apply == "function" && typeof e.deleteFragment == "function" && typeof e.insertBreak == "function" && typeof e.insertSoftBreak == "function" && typeof e.insertFragment == "function" && typeof e.insertNode == "function" && typeof e.insertText == "function" && typeof e.isElementReadOnly == "function" && typeof e.isInline == "function" && typeof e.isSelectable == "function" && typeof e.isVoid == "function" && typeof e.normalizeNode == "function" && typeof e.onChange == "function" && typeof e.removeMark == "function" && typeof e.getDirtyPaths == "function" && (e.marks === null || ho(e.marks)) && (e.selection === null || Bt.isRange(e.selection)) && yt.isNodeList(e.children) && dc.isOperationList(e.operations);
  return R_.set(e, n), n;
}, An = {
  above(e, t) {
    return e.above(t);
  },
  addMark(e, t, n) {
    e.addMark(t, n);
  },
  after(e, t, n) {
    return e.after(t, n);
  },
  before(e, t, n) {
    return e.before(t, n);
  },
  deleteBackward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteBackward(n);
  },
  deleteForward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteForward(n);
  },
  deleteFragment(e, t) {
    e.deleteFragment(t);
  },
  edges(e, t) {
    return e.edges(t);
  },
  elementReadOnly(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return e.elementReadOnly(t);
  },
  end(e, t) {
    return e.end(t);
  },
  first(e, t) {
    return e.first(t);
  },
  fragment(e, t) {
    return e.fragment(t);
  },
  hasBlocks(e, t) {
    return e.hasBlocks(t);
  },
  hasInlines(e, t) {
    return e.hasInlines(t);
  },
  hasPath(e, t) {
    return e.hasPath(t);
  },
  hasTexts(e, t) {
    return e.hasTexts(t);
  },
  insertBreak(e) {
    e.insertBreak();
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertNode(e, t) {
    e.insertNode(t);
  },
  insertSoftBreak(e) {
    e.insertSoftBreak();
  },
  insertText(e, t) {
    e.insertText(t);
  },
  isBlock(e, t) {
    return e.isBlock(t);
  },
  isEdge(e, t, n) {
    return e.isEdge(t, n);
  },
  isEditor(e) {
    return nY(e);
  },
  isElementReadOnly(e, t) {
    return e.isElementReadOnly(t);
  },
  isEmpty(e, t) {
    return e.isEmpty(t);
  },
  isEnd(e, t, n) {
    return e.isEnd(t, n);
  },
  isInline(e, t) {
    return e.isInline(t);
  },
  isNormalizing(e) {
    return e.isNormalizing();
  },
  isSelectable(e, t) {
    return e.isSelectable(t);
  },
  isStart(e, t, n) {
    return e.isStart(t, n);
  },
  isVoid(e, t) {
    return e.isVoid(t);
  },
  last(e, t) {
    return e.last(t);
  },
  leaf(e, t, n) {
    return e.leaf(t, n);
  },
  levels(e, t) {
    return e.levels(t);
  },
  marks(e) {
    return e.getMarks();
  },
  next(e, t) {
    return e.next(t);
  },
  node(e, t, n) {
    return e.node(t, n);
  },
  nodes(e, t) {
    return e.nodes(t);
  },
  normalize(e, t) {
    e.normalize(t);
  },
  parent(e, t, n) {
    return e.parent(t, n);
  },
  path(e, t, n) {
    return e.path(t, n);
  },
  pathRef(e, t, n) {
    return e.pathRef(t, n);
  },
  pathRefs(e) {
    return e.pathRefs();
  },
  point(e, t, n) {
    return e.point(t, n);
  },
  pointRef(e, t, n) {
    return e.pointRef(t, n);
  },
  pointRefs(e) {
    return e.pointRefs();
  },
  positions(e, t) {
    return e.positions(t);
  },
  previous(e, t) {
    return e.previous(t);
  },
  range(e, t, n) {
    return e.range(t, n);
  },
  rangeRef(e, t, n) {
    return e.rangeRef(t, n);
  },
  rangeRefs(e) {
    return e.rangeRefs();
  },
  removeMark(e, t) {
    e.removeMark(t);
  },
  setNormalizing(e, t) {
    e.setNormalizing(t);
  },
  start(e, t) {
    return e.start(t);
  },
  string(e, t, n) {
    return e.string(t, n);
  },
  unhangRange(e, t, n) {
    return e.unhangRange(t, n);
  },
  void(e, t) {
    return e.void(t);
  },
  withoutNormalizing(e, t) {
    e.withoutNormalizing(t);
  },
  shouldMergeNodesRemovePrevNode: (e, t, n) => e.shouldMergeNodesRemovePrevNode(t, n)
};
function N_(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function F_(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? N_(Object(n), !0).forEach(function(r) {
      hu(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : N_(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Kn = {
  compare(e, t) {
    var n = Te.compare(e.path, t.path);
    return n === 0 ? e.offset < t.offset ? -1 : e.offset > t.offset ? 1 : 0 : n;
  },
  isAfter(e, t) {
    return Kn.compare(e, t) === 1;
  },
  isBefore(e, t) {
    return Kn.compare(e, t) === -1;
  },
  equals(e, t) {
    return e.offset === t.offset && Te.equals(e.path, t.path);
  },
  isPoint(e) {
    return ho(e) && typeof e.offset == "number" && Te.isPath(e.path);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return NO(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "forward"
      } = n, {
        path: i,
        offset: a
      } = r;
      switch (t.type) {
        case "insert_node":
        case "move_node": {
          r.path = Te.transform(i, t, n);
          break;
        }
        case "insert_text": {
          Te.equals(t.path, i) && (t.offset < a || t.offset === a && o === "forward") && (r.offset += t.text.length);
          break;
        }
        case "merge_node": {
          Te.equals(t.path, i) && (r.offset += t.position), r.path = Te.transform(i, t, n);
          break;
        }
        case "remove_text": {
          Te.equals(t.path, i) && t.offset <= a && (r.offset -= Math.min(a - t.offset, t.text.length));
          break;
        }
        case "remove_node": {
          if (Te.equals(t.path, i) || Te.isAncestor(t.path, i))
            return null;
          r.path = Te.transform(i, t, n);
          break;
        }
        case "split_node": {
          if (Te.equals(t.path, i)) {
            if (t.position === a && o == null)
              return null;
            (t.position < a || t.position === a && o === "forward") && (r.offset -= t.position, r.path = Te.transform(i, t, F_(F_({}, n), {}, {
              affinity: "forward"
            })));
          } else
            r.path = Te.transform(i, t, n);
          break;
        }
      }
    });
  }
}, z_ = void 0, Ho = {
  setScrubber(e) {
    z_ = e;
  },
  stringify(e) {
    return JSON.stringify(e, z_);
  }
}, rY = ["text"], oY = ["anchor", "focus"];
function U_(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function rs(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? U_(Object(n), !0).forEach(function(r) {
      hu(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : U_(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Br = {
  equals(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      loose: r = !1
    } = n;
    function o(i) {
      var a = ap(i, rY);
      return a;
    }
    return b3(r ? o(e) : e, r ? o(t) : t);
  },
  isText(e) {
    return ho(e) && typeof e.text == "string";
  },
  isTextList(e) {
    return Array.isArray(e) && e.every((t) => Br.isText(t));
  },
  isTextProps(e) {
    return e.text !== void 0;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "text" && (!e.hasOwnProperty(n) || e[n] !== t[n]))
        return !1;
    return !0;
  },
  decorations(e, t) {
    var n = [rs({}, e)];
    for (var r of t) {
      var o = ap(r, oY), [i, a] = Bt.edges(r), s = [], l = 0, u = i.offset, c = a.offset;
      for (var p of n) {
        var {
          length: d
        } = p.text, h = l;
        if (l += d, u <= h && l <= c) {
          Object.assign(p, o), s.push(p);
          continue;
        }
        if (u !== c && (u === l || c === h) || u > l || c < h || c === h && h !== 0) {
          s.push(p);
          continue;
        }
        var f = p, m = void 0, g = void 0;
        if (c < l) {
          var E = c - h;
          g = rs(rs({}, f), {}, {
            text: f.text.slice(E)
          }), f = rs(rs({}, f), {}, {
            text: f.text.slice(0, E)
          });
        }
        if (u > h) {
          var w = u - h;
          m = rs(rs({}, f), {}, {
            text: f.text.slice(0, w)
          }), f = rs(rs({}, f), {}, {
            text: f.text.slice(w)
          });
        }
        Object.assign(f, o), m && s.push(m), s.push(f), g && s.push(g);
      }
      n = s;
    }
    return n;
  }
}, iY = (e) => e.selection ? e.selection : e.children.length > 0 ? An.end(e, []) : [0], Vn;
(function(e) {
  e[e.None = 0] = "None", e[e.Extend = 1] = "Extend", e[e.ZWJ = 2] = "ZWJ", e[e.RI = 4] = "RI", e[e.Prepend = 8] = "Prepend", e[e.SpacingMark = 16] = "SpacingMark", e[e.L = 32] = "L", e[e.V = 64] = "V", e[e.T = 128] = "T", e[e.LV = 256] = "LV", e[e.LVT = 512] = "LVT", e[e.ExtPict = 1024] = "ExtPict", e[e.Any = 2048] = "Any";
})(Vn || (Vn = {}));
Vn.L, Vn.L | Vn.V | Vn.LV | Vn.LVT, Vn.LV | Vn.V, Vn.V | Vn.T, Vn.LVT | Vn.T, Vn.T, Vn.Any, Vn.Extend | Vn.ZWJ, Vn.Any, Vn.SpacingMark, Vn.Prepend, Vn.Any, Vn.ZWJ, Vn.ExtPict, Vn.RI, Vn.RI;
var sY = {
  delete(e, t) {
    e.delete(t);
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertText(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    An.withoutNormalizing(e, () => {
      var {
        voids: r = !1
      } = n, {
        at: o = iY(e)
      } = n;
      if (Te.isPath(o) && (o = An.range(e, o)), Bt.isRange(o))
        if (Bt.isCollapsed(o))
          o = o.anchor;
        else {
          var i = Bt.end(o);
          if (!r && An.void(e, {
            at: i
          }))
            return;
          var a = Bt.start(o), s = An.pointRef(e, a), l = An.pointRef(e, i);
          eg.delete(e, {
            at: o,
            voids: r
          });
          var u = s.unref(), c = l.unref();
          o = u || c, eg.setSelection(e, {
            anchor: o,
            focus: o
          });
        }
      if (!(!r && An.void(e, {
        at: o
      }) || An.elementReadOnly(e, {
        at: o
      }))) {
        var {
          path: p,
          offset: d
        } = o;
        t.length > 0 && e.apply({
          type: "insert_text",
          path: p,
          offset: d,
          text: t
        });
      }
    });
  }
};
function $_(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function $d(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? $_(Object(n), !0).forEach(function(r) {
      hu(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : $_(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var eg = $d($d($d($d({}, GK), XK), KK), sY), w3 = {}, FO = {}, zO = {}, zl = {}, UO = {}, $O = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Doctype = e.CDATA = e.Tag = e.Style = e.Script = e.Comment = e.Directive = e.Text = e.Root = e.isTag = e.ElementType = void 0;
  var t;
  (function(r) {
    r.Root = "root", r.Text = "text", r.Directive = "directive", r.Comment = "comment", r.Script = "script", r.Style = "style", r.Tag = "tag", r.CDATA = "cdata", r.Doctype = "doctype";
  })(t = e.ElementType || (e.ElementType = {}));
  function n(r) {
    return r.type === t.Tag || r.type === t.Script || r.type === t.Style;
  }
  e.isTag = n, e.Root = t.Root, e.Text = t.Text, e.Directive = t.Directive, e.Comment = t.Comment, e.Script = t.Script, e.Style = t.Style, e.Tag = t.Tag, e.CDATA = t.CDATA, e.Doctype = t.Doctype;
})($O);
var $t = {}, ba = zn && zn.__extends || /* @__PURE__ */ function() {
  var e = function(t, n) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, o) {
      r.__proto__ = o;
    } || function(r, o) {
      for (var i in o) Object.prototype.hasOwnProperty.call(o, i) && (r[i] = o[i]);
    }, e(t, n);
  };
  return function(t, n) {
    if (typeof n != "function" && n !== null)
      throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
    e(t, n);
    function r() {
      this.constructor = t;
    }
    t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
  };
}(), kc = zn && zn.__assign || function() {
  return kc = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) {
      t = arguments[n];
      for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
    }
    return e;
  }, kc.apply(this, arguments);
};
Object.defineProperty($t, "__esModule", { value: !0 });
$t.cloneNode = $t.hasChildren = $t.isDocument = $t.isDirective = $t.isComment = $t.isText = $t.isCDATA = $t.isTag = $t.Element = $t.Document = $t.CDATA = $t.NodeWithChildren = $t.ProcessingInstruction = $t.Comment = $t.Text = $t.DataNode = $t.Node = void 0;
var No = $O, HO = (
  /** @class */
  function() {
    function e() {
      this.parent = null, this.prev = null, this.next = null, this.startIndex = null, this.endIndex = null;
    }
    return Object.defineProperty(e.prototype, "parentNode", {
      // Read-write aliases for properties
      /**
       * Same as {@link parent}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.parent;
      },
      set: function(t) {
        this.parent = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "previousSibling", {
      /**
       * Same as {@link prev}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.prev;
      },
      set: function(t) {
        this.prev = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "nextSibling", {
      /**
       * Same as {@link next}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.next;
      },
      set: function(t) {
        this.next = t;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.cloneNode = function(t) {
      return t === void 0 && (t = !1), WO(this, t);
    }, e;
  }()
);
$t.Node = HO;
var ov = (
  /** @class */
  function(e) {
    ba(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.data = n, r;
    }
    return Object.defineProperty(t.prototype, "nodeValue", {
      /**
       * Same as {@link data}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.data;
      },
      set: function(n) {
        this.data = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(HO)
);
$t.DataNode = ov;
var C3 = (
  /** @class */
  function(e) {
    ba(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = No.ElementType.Text, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 3;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(ov)
);
$t.Text = C3;
var x3 = (
  /** @class */
  function(e) {
    ba(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = No.ElementType.Comment, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 8;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(ov)
);
$t.Comment = x3;
var O3 = (
  /** @class */
  function(e) {
    ba(t, e);
    function t(n, r) {
      var o = e.call(this, r) || this;
      return o.name = n, o.type = No.ElementType.Directive, o;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(ov)
);
$t.ProcessingInstruction = O3;
var iv = (
  /** @class */
  function(e) {
    ba(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.children = n, r;
    }
    return Object.defineProperty(t.prototype, "firstChild", {
      // Aliases
      /** First child of the node. */
      get: function() {
        var n;
        return (n = this.children[0]) !== null && n !== void 0 ? n : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "lastChild", {
      /** Last child of the node. */
      get: function() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "childNodes", {
      /**
       * Same as {@link children}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.children;
      },
      set: function(n) {
        this.children = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(HO)
);
$t.NodeWithChildren = iv;
var E3 = (
  /** @class */
  function(e) {
    ba(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = No.ElementType.CDATA, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 4;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(iv)
);
$t.CDATA = E3;
var k3 = (
  /** @class */
  function(e) {
    ba(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = No.ElementType.Root, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 9;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(iv)
);
$t.Document = k3;
var L3 = (
  /** @class */
  function(e) {
    ba(t, e);
    function t(n, r, o, i) {
      o === void 0 && (o = []), i === void 0 && (i = n === "script" ? No.ElementType.Script : n === "style" ? No.ElementType.Style : No.ElementType.Tag);
      var a = e.call(this, o) || this;
      return a.name = n, a.attribs = r, a.type = i, a;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "tagName", {
      // DOM Level 1 aliases
      /**
       * Same as {@link name}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.name;
      },
      set: function(n) {
        this.name = n;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "attributes", {
      get: function() {
        var n = this;
        return Object.keys(this.attribs).map(function(r) {
          var o, i;
          return {
            name: r,
            value: n.attribs[r],
            namespace: (o = n["x-attribsNamespace"]) === null || o === void 0 ? void 0 : o[r],
            prefix: (i = n["x-attribsPrefix"]) === null || i === void 0 ? void 0 : i[r]
          };
        });
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(iv)
);
$t.Element = L3;
function _3(e) {
  return (0, No.isTag)(e);
}
$t.isTag = _3;
function P3(e) {
  return e.type === No.ElementType.CDATA;
}
$t.isCDATA = P3;
function S3(e) {
  return e.type === No.ElementType.Text;
}
$t.isText = S3;
function M3(e) {
  return e.type === No.ElementType.Comment;
}
$t.isComment = M3;
function D3(e) {
  return e.type === No.ElementType.Directive;
}
$t.isDirective = D3;
function T3(e) {
  return e.type === No.ElementType.Root;
}
$t.isDocument = T3;
function aY(e) {
  return Object.prototype.hasOwnProperty.call(e, "children");
}
$t.hasChildren = aY;
function WO(e, t) {
  t === void 0 && (t = !1);
  var n;
  if (S3(e))
    n = new C3(e.data);
  else if (M3(e))
    n = new x3(e.data);
  else if (_3(e)) {
    var r = t ? rb(e.children) : [], o = new L3(e.name, kc({}, e.attribs), r);
    r.forEach(function(l) {
      return l.parent = o;
    }), e.namespace != null && (o.namespace = e.namespace), e["x-attribsNamespace"] && (o["x-attribsNamespace"] = kc({}, e["x-attribsNamespace"])), e["x-attribsPrefix"] && (o["x-attribsPrefix"] = kc({}, e["x-attribsPrefix"])), n = o;
  } else if (P3(e)) {
    var r = t ? rb(e.children) : [], i = new E3(r);
    r.forEach(function(u) {
      return u.parent = i;
    }), n = i;
  } else if (T3(e)) {
    var r = t ? rb(e.children) : [], a = new k3(r);
    r.forEach(function(u) {
      return u.parent = a;
    }), e["x-mode"] && (a["x-mode"] = e["x-mode"]), n = a;
  } else if (D3(e)) {
    var s = new O3(e.name, e.data);
    e["x-name"] != null && (s["x-name"] = e["x-name"], s["x-publicId"] = e["x-publicId"], s["x-systemId"] = e["x-systemId"]), n = s;
  } else
    throw new Error("Not implemented yet: ".concat(e.type));
  return n.startIndex = e.startIndex, n.endIndex = e.endIndex, e.sourceCodeLocation != null && (n.sourceCodeLocation = e.sourceCodeLocation), n;
}
$t.cloneNode = WO;
function rb(e) {
  for (var t = e.map(function(r) {
    return WO(r, !0);
  }), n = 1; n < t.length; n++)
    t[n].prev = t[n - 1], t[n - 1].next = t[n];
  return t;
}
(function(e) {
  var t = zn && zn.__createBinding || (Object.create ? function(s, l, u, c) {
    c === void 0 && (c = u);
    var p = Object.getOwnPropertyDescriptor(l, u);
    (!p || ("get" in p ? !l.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
      return l[u];
    } }), Object.defineProperty(s, c, p);
  } : function(s, l, u, c) {
    c === void 0 && (c = u), s[c] = l[u];
  }), n = zn && zn.__exportStar || function(s, l) {
    for (var u in s) u !== "default" && !Object.prototype.hasOwnProperty.call(l, u) && t(l, s, u);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.DomHandler = void 0;
  var r = $O, o = $t;
  n($t, e);
  var i = {
    withStartIndices: !1,
    withEndIndices: !1,
    xmlMode: !1
  }, a = (
    /** @class */
    function() {
      function s(l, u, c) {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null, typeof u == "function" && (c = u, u = i), typeof l == "object" && (u = l, l = void 0), this.callback = l ?? null, this.options = u ?? i, this.elementCB = c ?? null;
      }
      return s.prototype.onparserinit = function(l) {
        this.parser = l;
      }, s.prototype.onreset = function() {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null;
      }, s.prototype.onend = function() {
        this.done || (this.done = !0, this.parser = null, this.handleCallback(null));
      }, s.prototype.onerror = function(l) {
        this.handleCallback(l);
      }, s.prototype.onclosetag = function() {
        this.lastNode = null;
        var l = this.tagStack.pop();
        this.options.withEndIndices && (l.endIndex = this.parser.endIndex), this.elementCB && this.elementCB(l);
      }, s.prototype.onopentag = function(l, u) {
        var c = this.options.xmlMode ? r.ElementType.Tag : void 0, p = new o.Element(l, u, void 0, c);
        this.addNode(p), this.tagStack.push(p);
      }, s.prototype.ontext = function(l) {
        var u = this.lastNode;
        if (u && u.type === r.ElementType.Text)
          u.data += l, this.options.withEndIndices && (u.endIndex = this.parser.endIndex);
        else {
          var c = new o.Text(l);
          this.addNode(c), this.lastNode = c;
        }
      }, s.prototype.oncomment = function(l) {
        if (this.lastNode && this.lastNode.type === r.ElementType.Comment) {
          this.lastNode.data += l;
          return;
        }
        var u = new o.Comment(l);
        this.addNode(u), this.lastNode = u;
      }, s.prototype.oncommentend = function() {
        this.lastNode = null;
      }, s.prototype.oncdatastart = function() {
        var l = new o.Text(""), u = new o.CDATA([l]);
        this.addNode(u), l.parent = u, this.lastNode = l;
      }, s.prototype.oncdataend = function() {
        this.lastNode = null;
      }, s.prototype.onprocessinginstruction = function(l, u) {
        var c = new o.ProcessingInstruction(l, u);
        this.addNode(c);
      }, s.prototype.handleCallback = function(l) {
        if (typeof this.callback == "function")
          this.callback(l, this.dom);
        else if (l)
          throw l;
      }, s.prototype.addNode = function(l) {
        var u = this.tagStack[this.tagStack.length - 1], c = u.children[u.children.length - 1];
        this.options.withStartIndices && (l.startIndex = this.parser.startIndex), this.options.withEndIndices && (l.endIndex = this.parser.endIndex), u.children.push(l), c && (l.prev = c, c.next = l), l.parent = u, this.lastNode = null;
      }, s;
    }()
  );
  e.DomHandler = a, e.default = a;
})(UO);
var j3 = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CARRIAGE_RETURN_PLACEHOLDER_REGEX = e.CARRIAGE_RETURN_PLACEHOLDER = e.CARRIAGE_RETURN_REGEX = e.CARRIAGE_RETURN = e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES = void 0, e.CASE_SENSITIVE_TAG_NAMES = [
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "linearGradient",
    "radialGradient",
    "textPath"
  ], e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES.reduce(function(t, n) {
    return t[n.toLowerCase()] = n, t;
  }, {}), e.CARRIAGE_RETURN = "\r", e.CARRIAGE_RETURN_REGEX = new RegExp(e.CARRIAGE_RETURN, "g"), e.CARRIAGE_RETURN_PLACEHOLDER = "__HTML_DOM_PARSER_CARRIAGE_RETURN_PLACEHOLDER_".concat(Date.now(), "__"), e.CARRIAGE_RETURN_PLACEHOLDER_REGEX = new RegExp(e.CARRIAGE_RETURN_PLACEHOLDER, "g");
})(j3);
Object.defineProperty(zl, "__esModule", { value: !0 });
zl.formatAttributes = A3;
zl.escapeSpecialCharacters = cY;
zl.revertEscapedCharacters = B3;
zl.formatDOM = I3;
var Hd = UO, lp = j3;
function lY(e) {
  return lp.CASE_SENSITIVE_TAG_NAMES_MAP[e];
}
function A3(e) {
  for (var t = {}, n = 0, r = e.length; n < r; n++) {
    var o = e[n];
    t[o.name] = o.value;
  }
  return t;
}
function uY(e) {
  e = e.toLowerCase();
  var t = lY(e);
  return t || e;
}
function cY(e) {
  return e.replace(lp.CARRIAGE_RETURN_REGEX, lp.CARRIAGE_RETURN_PLACEHOLDER);
}
function B3(e) {
  return e.replace(lp.CARRIAGE_RETURN_PLACEHOLDER_REGEX, lp.CARRIAGE_RETURN);
}
function I3(e, t, n) {
  t === void 0 && (t = null);
  for (var r = [], o, i = 0, a = e.length; i < a; i++) {
    var s = e[i];
    switch (s.nodeType) {
      case 1: {
        var l = uY(s.nodeName);
        o = new Hd.Element(l, A3(s.attributes)), o.children = I3(
          // template children are on content
          l === "template" ? s.content.childNodes : s.childNodes,
          o
        );
        break;
      }
      case 3:
        o = new Hd.Text(B3(s.nodeValue));
        break;
      case 8:
        o = new Hd.Comment(s.nodeValue);
        break;
      default:
        continue;
    }
    var u = r[i - 1] || null;
    u && (u.next = o), o.parent = t, o.prev = u, o.next = null, r.push(o);
  }
  return n && (o = new Hd.ProcessingInstruction(n.substring(0, n.indexOf(" ")).toLowerCase(), n), o.next = r[0] || null, o.parent = t, r.unshift(o), r[1] && (r[1].prev = r[0])), r;
}
Object.defineProperty(zO, "__esModule", { value: !0 });
zO.default = gY;
var pY = zl, H_ = "html", W_ = "head", Wd = "body", dY = /<([a-zA-Z]+[0-9]?)/, V_ = /<head[^]*>/i, q_ = /<body[^]*>/i, tg = function(e, t) {
  throw new Error("This browser does not support `document.implementation.createHTMLDocument`");
}, hC = function(e, t) {
  throw new Error("This browser does not support `DOMParser.prototype.parseFromString`");
}, Z_ = typeof window == "object" && window.DOMParser;
if (typeof Z_ == "function") {
  var fY = new Z_(), hY = "text/html";
  hC = function(e, t) {
    return t && (e = "<".concat(t, ">").concat(e, "</").concat(t, ">")), fY.parseFromString(e, hY);
  }, tg = hC;
}
if (typeof document == "object" && document.implementation) {
  var Vd = document.implementation.createHTMLDocument();
  tg = function(e, t) {
    if (t) {
      var n = Vd.documentElement.querySelector(t);
      return n && (n.innerHTML = e), Vd;
    }
    return Vd.documentElement.innerHTML = e, Vd;
  };
}
var qd = typeof document == "object" && document.createElement("template"), gC;
qd && qd.content && (gC = function(e) {
  return qd.innerHTML = e, qd.content.childNodes;
});
function gY(e) {
  var t, n;
  e = (0, pY.escapeSpecialCharacters)(e);
  var r = e.match(dY), o = r && r[1] ? r[1].toLowerCase() : "";
  switch (o) {
    case H_: {
      var i = hC(e);
      if (!V_.test(e)) {
        var a = i.querySelector(W_);
        (t = a == null ? void 0 : a.parentNode) === null || t === void 0 || t.removeChild(a);
      }
      if (!q_.test(e)) {
        var a = i.querySelector(Wd);
        (n = a == null ? void 0 : a.parentNode) === null || n === void 0 || n.removeChild(a);
      }
      return i.querySelectorAll(H_);
    }
    case W_:
    case Wd: {
      var s = tg(e).querySelectorAll(o);
      return q_.test(e) && V_.test(e) ? s[0].parentNode.childNodes : s;
    }
    default: {
      if (gC)
        return gC(e);
      var a = tg(e, Wd).querySelector(Wd);
      return a.childNodes;
    }
  }
}
var mY = zn && zn.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(FO, "__esModule", { value: !0 });
FO.default = wY;
var vY = mY(zO), yY = zl, bY = /<(![a-zA-Z\s]+)>/;
function wY(e) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e)
    return [];
  var t = e.match(bY), n = t ? t[1] : void 0;
  return (0, yY.formatDOM)((0, vY.default)(e), null, n);
}
var sv = {}, Di = {}, av = {}, CY = 0;
av.SAME = CY;
var xY = 1;
av.CAMELCASE = xY;
av.possibleStandardNames = {
  accept: 0,
  acceptCharset: 1,
  "accept-charset": "acceptCharset",
  accessKey: 1,
  action: 0,
  allowFullScreen: 1,
  alt: 0,
  as: 0,
  async: 0,
  autoCapitalize: 1,
  autoComplete: 1,
  autoCorrect: 1,
  autoFocus: 1,
  autoPlay: 1,
  autoSave: 1,
  capture: 0,
  cellPadding: 1,
  cellSpacing: 1,
  challenge: 0,
  charSet: 1,
  checked: 0,
  children: 0,
  cite: 0,
  class: "className",
  classID: 1,
  className: 1,
  cols: 0,
  colSpan: 1,
  content: 0,
  contentEditable: 1,
  contextMenu: 1,
  controls: 0,
  controlsList: 1,
  coords: 0,
  crossOrigin: 1,
  dangerouslySetInnerHTML: 1,
  data: 0,
  dateTime: 1,
  default: 0,
  defaultChecked: 1,
  defaultValue: 1,
  defer: 0,
  dir: 0,
  disabled: 0,
  disablePictureInPicture: 1,
  disableRemotePlayback: 1,
  download: 0,
  draggable: 0,
  encType: 1,
  enterKeyHint: 1,
  for: "htmlFor",
  form: 0,
  formMethod: 1,
  formAction: 1,
  formEncType: 1,
  formNoValidate: 1,
  formTarget: 1,
  frameBorder: 1,
  headers: 0,
  height: 0,
  hidden: 0,
  high: 0,
  href: 0,
  hrefLang: 1,
  htmlFor: 1,
  httpEquiv: 1,
  "http-equiv": "httpEquiv",
  icon: 0,
  id: 0,
  innerHTML: 1,
  inputMode: 1,
  integrity: 0,
  is: 0,
  itemID: 1,
  itemProp: 1,
  itemRef: 1,
  itemScope: 1,
  itemType: 1,
  keyParams: 1,
  keyType: 1,
  kind: 0,
  label: 0,
  lang: 0,
  list: 0,
  loop: 0,
  low: 0,
  manifest: 0,
  marginWidth: 1,
  marginHeight: 1,
  max: 0,
  maxLength: 1,
  media: 0,
  mediaGroup: 1,
  method: 0,
  min: 0,
  minLength: 1,
  multiple: 0,
  muted: 0,
  name: 0,
  noModule: 1,
  nonce: 0,
  noValidate: 1,
  open: 0,
  optimum: 0,
  pattern: 0,
  placeholder: 0,
  playsInline: 1,
  poster: 0,
  preload: 0,
  profile: 0,
  radioGroup: 1,
  readOnly: 1,
  referrerPolicy: 1,
  rel: 0,
  required: 0,
  reversed: 0,
  role: 0,
  rows: 0,
  rowSpan: 1,
  sandbox: 0,
  scope: 0,
  scoped: 0,
  scrolling: 0,
  seamless: 0,
  selected: 0,
  shape: 0,
  size: 0,
  sizes: 0,
  span: 0,
  spellCheck: 1,
  src: 0,
  srcDoc: 1,
  srcLang: 1,
  srcSet: 1,
  start: 0,
  step: 0,
  style: 0,
  summary: 0,
  tabIndex: 1,
  target: 0,
  title: 0,
  type: 0,
  useMap: 1,
  value: 0,
  width: 0,
  wmode: 0,
  wrap: 0,
  about: 0,
  accentHeight: 1,
  "accent-height": "accentHeight",
  accumulate: 0,
  additive: 0,
  alignmentBaseline: 1,
  "alignment-baseline": "alignmentBaseline",
  allowReorder: 1,
  alphabetic: 0,
  amplitude: 0,
  arabicForm: 1,
  "arabic-form": "arabicForm",
  ascent: 0,
  attributeName: 1,
  attributeType: 1,
  autoReverse: 1,
  azimuth: 0,
  baseFrequency: 1,
  baselineShift: 1,
  "baseline-shift": "baselineShift",
  baseProfile: 1,
  bbox: 0,
  begin: 0,
  bias: 0,
  by: 0,
  calcMode: 1,
  capHeight: 1,
  "cap-height": "capHeight",
  clip: 0,
  clipPath: 1,
  "clip-path": "clipPath",
  clipPathUnits: 1,
  clipRule: 1,
  "clip-rule": "clipRule",
  color: 0,
  colorInterpolation: 1,
  "color-interpolation": "colorInterpolation",
  colorInterpolationFilters: 1,
  "color-interpolation-filters": "colorInterpolationFilters",
  colorProfile: 1,
  "color-profile": "colorProfile",
  colorRendering: 1,
  "color-rendering": "colorRendering",
  contentScriptType: 1,
  contentStyleType: 1,
  cursor: 0,
  cx: 0,
  cy: 0,
  d: 0,
  datatype: 0,
  decelerate: 0,
  descent: 0,
  diffuseConstant: 1,
  direction: 0,
  display: 0,
  divisor: 0,
  dominantBaseline: 1,
  "dominant-baseline": "dominantBaseline",
  dur: 0,
  dx: 0,
  dy: 0,
  edgeMode: 1,
  elevation: 0,
  enableBackground: 1,
  "enable-background": "enableBackground",
  end: 0,
  exponent: 0,
  externalResourcesRequired: 1,
  fill: 0,
  fillOpacity: 1,
  "fill-opacity": "fillOpacity",
  fillRule: 1,
  "fill-rule": "fillRule",
  filter: 0,
  filterRes: 1,
  filterUnits: 1,
  floodOpacity: 1,
  "flood-opacity": "floodOpacity",
  floodColor: 1,
  "flood-color": "floodColor",
  focusable: 0,
  fontFamily: 1,
  "font-family": "fontFamily",
  fontSize: 1,
  "font-size": "fontSize",
  fontSizeAdjust: 1,
  "font-size-adjust": "fontSizeAdjust",
  fontStretch: 1,
  "font-stretch": "fontStretch",
  fontStyle: 1,
  "font-style": "fontStyle",
  fontVariant: 1,
  "font-variant": "fontVariant",
  fontWeight: 1,
  "font-weight": "fontWeight",
  format: 0,
  from: 0,
  fx: 0,
  fy: 0,
  g1: 0,
  g2: 0,
  glyphName: 1,
  "glyph-name": "glyphName",
  glyphOrientationHorizontal: 1,
  "glyph-orientation-horizontal": "glyphOrientationHorizontal",
  glyphOrientationVertical: 1,
  "glyph-orientation-vertical": "glyphOrientationVertical",
  glyphRef: 1,
  gradientTransform: 1,
  gradientUnits: 1,
  hanging: 0,
  horizAdvX: 1,
  "horiz-adv-x": "horizAdvX",
  horizOriginX: 1,
  "horiz-origin-x": "horizOriginX",
  ideographic: 0,
  imageRendering: 1,
  "image-rendering": "imageRendering",
  in2: 0,
  in: 0,
  inlist: 0,
  intercept: 0,
  k1: 0,
  k2: 0,
  k3: 0,
  k4: 0,
  k: 0,
  kernelMatrix: 1,
  kernelUnitLength: 1,
  kerning: 0,
  keyPoints: 1,
  keySplines: 1,
  keyTimes: 1,
  lengthAdjust: 1,
  letterSpacing: 1,
  "letter-spacing": "letterSpacing",
  lightingColor: 1,
  "lighting-color": "lightingColor",
  limitingConeAngle: 1,
  local: 0,
  markerEnd: 1,
  "marker-end": "markerEnd",
  markerHeight: 1,
  markerMid: 1,
  "marker-mid": "markerMid",
  markerStart: 1,
  "marker-start": "markerStart",
  markerUnits: 1,
  markerWidth: 1,
  mask: 0,
  maskContentUnits: 1,
  maskUnits: 1,
  mathematical: 0,
  mode: 0,
  numOctaves: 1,
  offset: 0,
  opacity: 0,
  operator: 0,
  order: 0,
  orient: 0,
  orientation: 0,
  origin: 0,
  overflow: 0,
  overlinePosition: 1,
  "overline-position": "overlinePosition",
  overlineThickness: 1,
  "overline-thickness": "overlineThickness",
  paintOrder: 1,
  "paint-order": "paintOrder",
  panose1: 0,
  "panose-1": "panose1",
  pathLength: 1,
  patternContentUnits: 1,
  patternTransform: 1,
  patternUnits: 1,
  pointerEvents: 1,
  "pointer-events": "pointerEvents",
  points: 0,
  pointsAtX: 1,
  pointsAtY: 1,
  pointsAtZ: 1,
  prefix: 0,
  preserveAlpha: 1,
  preserveAspectRatio: 1,
  primitiveUnits: 1,
  property: 0,
  r: 0,
  radius: 0,
  refX: 1,
  refY: 1,
  renderingIntent: 1,
  "rendering-intent": "renderingIntent",
  repeatCount: 1,
  repeatDur: 1,
  requiredExtensions: 1,
  requiredFeatures: 1,
  resource: 0,
  restart: 0,
  result: 0,
  results: 0,
  rotate: 0,
  rx: 0,
  ry: 0,
  scale: 0,
  security: 0,
  seed: 0,
  shapeRendering: 1,
  "shape-rendering": "shapeRendering",
  slope: 0,
  spacing: 0,
  specularConstant: 1,
  specularExponent: 1,
  speed: 0,
  spreadMethod: 1,
  startOffset: 1,
  stdDeviation: 1,
  stemh: 0,
  stemv: 0,
  stitchTiles: 1,
  stopColor: 1,
  "stop-color": "stopColor",
  stopOpacity: 1,
  "stop-opacity": "stopOpacity",
  strikethroughPosition: 1,
  "strikethrough-position": "strikethroughPosition",
  strikethroughThickness: 1,
  "strikethrough-thickness": "strikethroughThickness",
  string: 0,
  stroke: 0,
  strokeDasharray: 1,
  "stroke-dasharray": "strokeDasharray",
  strokeDashoffset: 1,
  "stroke-dashoffset": "strokeDashoffset",
  strokeLinecap: 1,
  "stroke-linecap": "strokeLinecap",
  strokeLinejoin: 1,
  "stroke-linejoin": "strokeLinejoin",
  strokeMiterlimit: 1,
  "stroke-miterlimit": "strokeMiterlimit",
  strokeWidth: 1,
  "stroke-width": "strokeWidth",
  strokeOpacity: 1,
  "stroke-opacity": "strokeOpacity",
  suppressContentEditableWarning: 1,
  suppressHydrationWarning: 1,
  surfaceScale: 1,
  systemLanguage: 1,
  tableValues: 1,
  targetX: 1,
  targetY: 1,
  textAnchor: 1,
  "text-anchor": "textAnchor",
  textDecoration: 1,
  "text-decoration": "textDecoration",
  textLength: 1,
  textRendering: 1,
  "text-rendering": "textRendering",
  to: 0,
  transform: 0,
  typeof: 0,
  u1: 0,
  u2: 0,
  underlinePosition: 1,
  "underline-position": "underlinePosition",
  underlineThickness: 1,
  "underline-thickness": "underlineThickness",
  unicode: 0,
  unicodeBidi: 1,
  "unicode-bidi": "unicodeBidi",
  unicodeRange: 1,
  "unicode-range": "unicodeRange",
  unitsPerEm: 1,
  "units-per-em": "unitsPerEm",
  unselectable: 0,
  vAlphabetic: 1,
  "v-alphabetic": "vAlphabetic",
  values: 0,
  vectorEffect: 1,
  "vector-effect": "vectorEffect",
  version: 0,
  vertAdvY: 1,
  "vert-adv-y": "vertAdvY",
  vertOriginX: 1,
  "vert-origin-x": "vertOriginX",
  vertOriginY: 1,
  "vert-origin-y": "vertOriginY",
  vHanging: 1,
  "v-hanging": "vHanging",
  vIdeographic: 1,
  "v-ideographic": "vIdeographic",
  viewBox: 1,
  viewTarget: 1,
  visibility: 0,
  vMathematical: 1,
  "v-mathematical": "vMathematical",
  vocab: 0,
  widths: 0,
  wordSpacing: 1,
  "word-spacing": "wordSpacing",
  writingMode: 1,
  "writing-mode": "writingMode",
  x1: 0,
  x2: 0,
  x: 0,
  xChannelSelector: 1,
  xHeight: 1,
  "x-height": "xHeight",
  xlinkActuate: 1,
  "xlink:actuate": "xlinkActuate",
  xlinkArcrole: 1,
  "xlink:arcrole": "xlinkArcrole",
  xlinkHref: 1,
  "xlink:href": "xlinkHref",
  xlinkRole: 1,
  "xlink:role": "xlinkRole",
  xlinkShow: 1,
  "xlink:show": "xlinkShow",
  xlinkTitle: 1,
  "xlink:title": "xlinkTitle",
  xlinkType: 1,
  "xlink:type": "xlinkType",
  xmlBase: 1,
  "xml:base": "xmlBase",
  xmlLang: 1,
  "xml:lang": "xmlLang",
  xmlns: 0,
  "xml:space": "xmlSpace",
  xmlnsXlink: 1,
  "xmlns:xlink": "xmlnsXlink",
  xmlSpace: 1,
  y1: 0,
  y2: 0,
  y: 0,
  yChannelSelector: 1,
  z: 0,
  zoomAndPan: 1
};
const R3 = 0, wa = 1, lv = 2, uv = 3, VO = 4, N3 = 5, F3 = 6;
function OY(e) {
  return lo.hasOwnProperty(e) ? lo[e] : null;
}
function Eo(e, t, n, r, o, i, a) {
  this.acceptsBooleans = t === lv || t === uv || t === VO, this.attributeName = r, this.attributeNamespace = o, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = i, this.removeEmptyString = a;
}
const lo = {}, EY = [
  "children",
  "dangerouslySetInnerHTML",
  // TODO: This prevents the assignment of defaultValue to regular
  // elements (not just inputs). Now that ReactDOMInput assigns to the
  // defaultValue property -- do we need this?
  "defaultValue",
  "defaultChecked",
  "innerHTML",
  "suppressContentEditableWarning",
  "suppressHydrationWarning",
  "style"
];
EY.forEach((e) => {
  lo[e] = new Eo(
    e,
    R3,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"]
].forEach(([e, t]) => {
  lo[e] = new Eo(
    e,
    wa,
    !1,
    // mustUseProperty
    t,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["contentEditable", "draggable", "spellCheck", "value"].forEach((e) => {
  lo[e] = new Eo(
    e,
    lv,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha"
].forEach((e) => {
  lo[e] = new Eo(
    e,
    lv,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "allowFullScreen",
  "async",
  // Note: there is a special case that prevents it from being written to the DOM
  // on the client side because the browsers are inconsistent. Instead we call focus().
  "autoFocus",
  "autoPlay",
  "controls",
  "default",
  "defer",
  "disabled",
  "disablePictureInPicture",
  "disableRemotePlayback",
  "formNoValidate",
  "hidden",
  "loop",
  "noModule",
  "noValidate",
  "open",
  "playsInline",
  "readOnly",
  "required",
  "reversed",
  "scoped",
  "seamless",
  // Microdata
  "itemScope"
].forEach((e) => {
  lo[e] = new Eo(
    e,
    uv,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "checked",
  // Note: `option.selected` is not updated if `select.multiple` is
  // disabled with `removeAttribute`. We have special logic for handling this.
  "multiple",
  "muted",
  "selected"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  lo[e] = new Eo(
    e,
    uv,
    !0,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "capture",
  "download"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  lo[e] = new Eo(
    e,
    VO,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "cols",
  "rows",
  "size",
  "span"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  lo[e] = new Eo(
    e,
    F3,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["rowSpan", "start"].forEach((e) => {
  lo[e] = new Eo(
    e,
    N3,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const qO = /[\-\:]([a-z])/g, ZO = (e) => e[1].toUpperCase();
[
  "accent-height",
  "alignment-baseline",
  "arabic-form",
  "baseline-shift",
  "cap-height",
  "clip-path",
  "clip-rule",
  "color-interpolation",
  "color-interpolation-filters",
  "color-profile",
  "color-rendering",
  "dominant-baseline",
  "enable-background",
  "fill-opacity",
  "fill-rule",
  "flood-color",
  "flood-opacity",
  "font-family",
  "font-size",
  "font-size-adjust",
  "font-stretch",
  "font-style",
  "font-variant",
  "font-weight",
  "glyph-name",
  "glyph-orientation-horizontal",
  "glyph-orientation-vertical",
  "horiz-adv-x",
  "horiz-origin-x",
  "image-rendering",
  "letter-spacing",
  "lighting-color",
  "marker-end",
  "marker-mid",
  "marker-start",
  "overline-position",
  "overline-thickness",
  "paint-order",
  "panose-1",
  "pointer-events",
  "rendering-intent",
  "shape-rendering",
  "stop-color",
  "stop-opacity",
  "strikethrough-position",
  "strikethrough-thickness",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "text-anchor",
  "text-decoration",
  "text-rendering",
  "underline-position",
  "underline-thickness",
  "unicode-bidi",
  "unicode-range",
  "units-per-em",
  "v-alphabetic",
  "v-hanging",
  "v-ideographic",
  "v-mathematical",
  "vector-effect",
  "vert-adv-y",
  "vert-origin-x",
  "vert-origin-y",
  "word-spacing",
  "writing-mode",
  "xmlns:xlink",
  "x-height"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(qO, ZO);
  lo[t] = new Eo(
    t,
    wa,
    !1,
    // mustUseProperty
    e,
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xlink:actuate",
  "xlink:arcrole",
  "xlink:role",
  "xlink:show",
  "xlink:title",
  "xlink:type"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(qO, ZO);
  lo[t] = new Eo(
    t,
    wa,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/1999/xlink",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xml:base",
  "xml:lang",
  "xml:space"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(qO, ZO);
  lo[t] = new Eo(
    t,
    wa,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/XML/1998/namespace",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["tabIndex", "crossOrigin"].forEach((e) => {
  lo[e] = new Eo(
    e,
    wa,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const kY = "xlinkHref";
lo[kY] = new Eo(
  "xlinkHref",
  wa,
  !1,
  // mustUseProperty
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  // sanitizeURL
  !1
  // removeEmptyString
);
["src", "href", "action", "formAction"].forEach((e) => {
  lo[e] = new Eo(
    e,
    wa,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !0,
    // sanitizeURL
    !0
    // removeEmptyString
  );
});
const {
  CAMELCASE: LY,
  SAME: _Y,
  possibleStandardNames: G_
} = av, PY = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", SY = PY + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", MY = RegExp.prototype.test.bind(
  // eslint-disable-next-line no-misleading-character-class
  new RegExp("^(data|aria)-[" + SY + "]*$")
), DY = Object.keys(
  G_
).reduce((e, t) => {
  const n = G_[t];
  return n === _Y ? e[t] = t : n === LY ? e[t.toLowerCase()] = t : e[t] = n, e;
}, {});
Di.BOOLEAN = uv;
Di.BOOLEANISH_STRING = lv;
Di.NUMERIC = N3;
Di.OVERLOADED_BOOLEAN = VO;
Di.POSITIVE_NUMERIC = F3;
Di.RESERVED = R3;
Di.STRING = wa;
Di.getPropertyInfo = OY;
Di.isCustomAttribute = MY;
Di.possibleStandardNames = DY;
var GO = {}, XO = {}, X_ = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, TY = /\n/g, jY = /^\s*/, AY = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, BY = /^:\s*/, IY = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, RY = /^[;\s]*/, NY = /^\s+|\s+$/g, FY = `
`, K_ = "/", Y_ = "*", nl = "", zY = "comment", UY = "declaration", $Y = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e) return [];
  t = t || {};
  var n = 1, r = 1;
  function o(f) {
    var m = f.match(TY);
    m && (n += m.length);
    var g = f.lastIndexOf(FY);
    r = ~g ? f.length - g : r + f.length;
  }
  function i() {
    var f = { line: n, column: r };
    return function(m) {
      return m.position = new a(f), u(), m;
    };
  }
  function a(f) {
    this.start = f, this.end = { line: n, column: r }, this.source = t.source;
  }
  a.prototype.content = e;
  function s(f) {
    var m = new Error(
      t.source + ":" + n + ":" + r + ": " + f
    );
    if (m.reason = f, m.filename = t.source, m.line = n, m.column = r, m.source = e, !t.silent) throw m;
  }
  function l(f) {
    var m = f.exec(e);
    if (m) {
      var g = m[0];
      return o(g), e = e.slice(g.length), m;
    }
  }
  function u() {
    l(jY);
  }
  function c(f) {
    var m;
    for (f = f || []; m = p(); )
      m !== !1 && f.push(m);
    return f;
  }
  function p() {
    var f = i();
    if (!(K_ != e.charAt(0) || Y_ != e.charAt(1))) {
      for (var m = 2; nl != e.charAt(m) && (Y_ != e.charAt(m) || K_ != e.charAt(m + 1)); )
        ++m;
      if (m += 2, nl === e.charAt(m - 1))
        return s("End of comment missing");
      var g = e.slice(2, m - 2);
      return r += 2, o(g), e = e.slice(m), r += 2, f({
        type: zY,
        comment: g
      });
    }
  }
  function d() {
    var f = i(), m = l(AY);
    if (m) {
      if (p(), !l(BY)) return s("property missing ':'");
      var g = l(IY), E = f({
        type: UY,
        property: J_(m[0].replace(X_, nl)),
        value: g ? J_(g[0].replace(X_, nl)) : nl
      });
      return l(RY), E;
    }
  }
  function h() {
    var f = [];
    c(f);
    for (var m; m = d(); )
      m !== !1 && (f.push(m), c(f));
    return f;
  }
  return u(), h();
};
function J_(e) {
  return e ? e.replace(NY, nl) : nl;
}
var HY = zn && zn.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(XO, "__esModule", { value: !0 });
XO.default = VY;
var WY = HY($Y);
function VY(e, t) {
  var n = null;
  if (!e || typeof e != "string")
    return n;
  var r = (0, WY.default)(e), o = typeof t == "function";
  return r.forEach(function(i) {
    if (i.type === "declaration") {
      var a = i.property, s = i.value;
      o ? t(a, s, i) : s && (n = n || {}, n[a] = s);
    }
  }), n;
}
var cv = {};
Object.defineProperty(cv, "__esModule", { value: !0 });
cv.camelCase = void 0;
var qY = /^--[a-zA-Z0-9_-]+$/, ZY = /-([a-z])/g, GY = /^[^-]+$/, XY = /^-(webkit|moz|ms|o|khtml)-/, KY = /^-(ms)-/, YY = function(e) {
  return !e || GY.test(e) || qY.test(e);
}, JY = function(e, t) {
  return t.toUpperCase();
}, Q_ = function(e, t) {
  return "".concat(t, "-");
}, QY = function(e, t) {
  return t === void 0 && (t = {}), YY(e) ? e : (e = e.toLowerCase(), t.reactCompat ? e = e.replace(KY, Q_) : e = e.replace(XY, Q_), e.replace(ZY, JY));
};
cv.camelCase = QY;
var eJ = zn && zn.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
}, tJ = eJ(XO), nJ = cv;
function mC(e, t) {
  var n = {};
  return !e || typeof e != "string" || (0, tJ.default)(e, function(r, o) {
    r && o && (n[(0, nJ.camelCase)(r, t)] = o);
  }), n;
}
mC.default = mC;
var rJ = mC;
(function(e) {
  var t = zn && zn.__importDefault || function(c) {
    return c && c.__esModule ? c : { default: c };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.returnFirstArg = e.canTextBeChildOfNode = e.ELEMENTS_WITH_NO_TEXT_CHILDREN = e.PRESERVE_CUSTOM_ATTRIBUTES = void 0, e.isCustomComponent = i, e.setStyleProp = s;
  var n = ke, r = t(rJ), o = /* @__PURE__ */ new Set([
    "annotation-xml",
    "color-profile",
    "font-face",
    "font-face-src",
    "font-face-uri",
    "font-face-format",
    "font-face-name",
    "missing-glyph"
  ]);
  function i(c, p) {
    return c.includes("-") ? !o.has(c) : !!(p && typeof p.is == "string");
  }
  var a = {
    reactCompat: !0
  };
  function s(c, p) {
    if (typeof c == "string") {
      if (!c.trim()) {
        p.style = {};
        return;
      }
      try {
        p.style = (0, r.default)(c, a);
      } catch {
        p.style = {};
      }
    }
  }
  e.PRESERVE_CUSTOM_ATTRIBUTES = Number(n.version.split(".")[0]) >= 16, e.ELEMENTS_WITH_NO_TEXT_CHILDREN = /* @__PURE__ */ new Set([
    "tr",
    "tbody",
    "thead",
    "tfoot",
    "colgroup",
    "table",
    "head",
    "html",
    "frameset"
  ]);
  var l = function(c) {
    return !e.ELEMENTS_WITH_NO_TEXT_CHILDREN.has(c.name);
  };
  e.canTextBeChildOfNode = l;
  var u = function(c) {
    return c;
  };
  e.returnFirstArg = u;
})(GO);
Object.defineProperty(sv, "__esModule", { value: !0 });
sv.default = aJ;
var fc = Di, eP = GO, oJ = ["checked", "value"], iJ = ["input", "select", "textarea"], sJ = {
  reset: !0,
  submit: !0
};
function aJ(e, t) {
  e === void 0 && (e = {});
  var n = {}, r = !!(e.type && sJ[e.type]);
  for (var o in e) {
    var i = e[o];
    if ((0, fc.isCustomAttribute)(o)) {
      n[o] = i;
      continue;
    }
    var a = o.toLowerCase(), s = tP(a);
    if (s) {
      var l = (0, fc.getPropertyInfo)(s);
      switch (oJ.includes(s) && iJ.includes(t) && !r && (s = tP("default" + a)), n[s] = i, l && l.type) {
        case fc.BOOLEAN:
          n[s] = !0;
          break;
        case fc.OVERLOADED_BOOLEAN:
          i === "" && (n[s] = !0);
          break;
      }
      continue;
    }
    eP.PRESERVE_CUSTOM_ATTRIBUTES && (n[o] = i);
  }
  return (0, eP.setStyleProp)(e.style, n), n;
}
function tP(e) {
  return fc.possibleStandardNames[e];
}
var KO = {}, lJ = zn && zn.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(KO, "__esModule", { value: !0 });
KO.default = z3;
var ob = ke, uJ = lJ(sv), Lc = GO, cJ = {
  cloneElement: ob.cloneElement,
  createElement: ob.createElement,
  isValidElement: ob.isValidElement
};
function z3(e, t) {
  t === void 0 && (t = {});
  for (var n = [], r = typeof t.replace == "function", o = t.transform || Lc.returnFirstArg, i = t.library || cJ, a = i.cloneElement, s = i.createElement, l = i.isValidElement, u = e.length, c = 0; c < u; c++) {
    var p = e[c];
    if (r) {
      var d = t.replace(p, c);
      if (l(d)) {
        u > 1 && (d = a(d, {
          key: d.key || c
        })), n.push(o(d, p, c));
        continue;
      }
    }
    if (p.type === "text") {
      var h = !p.data.trim().length;
      if (h && p.parent && !(0, Lc.canTextBeChildOfNode)(p.parent) || t.trim && h)
        continue;
      n.push(o(p.data, p, c));
      continue;
    }
    var f = p, m = {};
    pJ(f) ? ((0, Lc.setStyleProp)(f.attribs.style, f.attribs), m = f.attribs) : f.attribs && (m = (0, uJ.default)(f.attribs, f.name));
    var g = void 0;
    switch (p.type) {
      case "script":
      case "style":
        p.children[0] && (m.dangerouslySetInnerHTML = {
          __html: p.children[0].data
        });
        break;
      case "tag":
        p.name === "textarea" && p.children[0] ? m.defaultValue = p.children[0].data : p.children && p.children.length && (g = z3(p.children, t));
        break;
      default:
        continue;
    }
    u > 1 && (m.key = c), n.push(o(s(p.name, m, g), p, c));
  }
  return n.length === 1 ? n[0] : n;
}
function pJ(e) {
  return Lc.PRESERVE_CUSTOM_ATTRIBUTES && e.type === "tag" && (0, Lc.isCustomComponent)(e.name, e.attribs);
}
(function(e) {
  var t = zn && zn.__importDefault || function(l) {
    return l && l.__esModule ? l : { default: l };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.htmlToDOM = e.domToReact = e.attributesToProps = e.Text = e.ProcessingInstruction = e.Element = e.Comment = void 0, e.default = s;
  var n = t(FO);
  e.htmlToDOM = n.default;
  var r = t(sv);
  e.attributesToProps = r.default;
  var o = t(KO);
  e.domToReact = o.default;
  var i = UO;
  Object.defineProperty(e, "Comment", { enumerable: !0, get: function() {
    return i.Comment;
  } }), Object.defineProperty(e, "Element", { enumerable: !0, get: function() {
    return i.Element;
  } }), Object.defineProperty(e, "ProcessingInstruction", { enumerable: !0, get: function() {
    return i.ProcessingInstruction;
  } }), Object.defineProperty(e, "Text", { enumerable: !0, get: function() {
    return i.Text;
  } });
  var a = { lowerCaseAttributeNames: !1 };
  function s(l, u) {
    if (typeof l != "string")
      throw new TypeError("First argument must be a string");
    return l ? (0, o.default)((0, n.default)(l, (u == null ? void 0 : u.htmlparser2) || a), u) : [];
  }
})(w3);
const dJ = /* @__PURE__ */ DK(w3);
dJ.default;
var Un = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function fJ(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var vC = { exports: {} }, Ru = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var nP;
function hJ() {
  if (nP) return Ru;
  nP = 1;
  var e = ke, t = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, o = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, i = { key: !0, ref: !0, __self: !0, __source: !0 };
  function a(s, l, u) {
    var c, p = {}, d = null, h = null;
    u !== void 0 && (d = "" + u), l.key !== void 0 && (d = "" + l.key), l.ref !== void 0 && (h = l.ref);
    for (c in l) r.call(l, c) && !i.hasOwnProperty(c) && (p[c] = l[c]);
    if (s && s.defaultProps) for (c in l = s.defaultProps, l) p[c] === void 0 && (p[c] = l[c]);
    return { $$typeof: t, type: s, key: d, ref: h, props: p, _owner: o.current };
  }
  return Ru.Fragment = n, Ru.jsx = a, Ru.jsxs = a, Ru;
}
var Zd = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var rP;
function gJ() {
  return rP || (rP = 1, process.env.NODE_ENV !== "production" && function() {
    var e = ke, t = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), a = Symbol.for("react.provider"), s = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), c = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), d = Symbol.for("react.lazy"), h = Symbol.for("react.offscreen"), f = Symbol.iterator, m = "@@iterator";
    function g(b) {
      if (b === null || typeof b != "object")
        return null;
      var B = f && b[f] || b[m];
      return typeof B == "function" ? B : null;
    }
    var E = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function w(b) {
      {
        for (var B = arguments.length, G = new Array(B > 1 ? B - 1 : 0), ne = 1; ne < B; ne++)
          G[ne - 1] = arguments[ne];
        M("error", b, G);
      }
    }
    function M(b, B, G) {
      {
        var ne = E.ReactDebugCurrentFrame, le = ne.getStackAddendum();
        le !== "" && (B += "%s", G = G.concat([le]));
        var ce = G.map(function(ae) {
          return String(ae);
        });
        ce.unshift("Warning: " + B), Function.prototype.apply.call(console[b], console, ce);
      }
    }
    var x = !1, y = !1, C = !1, P = !1, F = !1, L;
    L = Symbol.for("react.module.reference");
    function N(b) {
      return !!(typeof b == "string" || typeof b == "function" || b === r || b === i || F || b === o || b === u || b === c || P || b === h || x || y || C || typeof b == "object" && b !== null && (b.$$typeof === d || b.$$typeof === p || b.$$typeof === a || b.$$typeof === s || b.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      b.$$typeof === L || b.getModuleId !== void 0));
    }
    function I(b, B, G) {
      var ne = b.displayName;
      if (ne)
        return ne;
      var le = B.displayName || B.name || "";
      return le !== "" ? G + "(" + le + ")" : G;
    }
    function H(b) {
      return b.displayName || "Context";
    }
    function V(b) {
      if (b == null)
        return null;
      if (typeof b.tag == "number" && w("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof b == "function")
        return b.displayName || b.name || null;
      if (typeof b == "string")
        return b;
      switch (b) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case i:
          return "Profiler";
        case o:
          return "StrictMode";
        case u:
          return "Suspense";
        case c:
          return "SuspenseList";
      }
      if (typeof b == "object")
        switch (b.$$typeof) {
          case s:
            var B = b;
            return H(B) + ".Consumer";
          case a:
            var G = b;
            return H(G._context) + ".Provider";
          case l:
            return I(b, b.render, "ForwardRef");
          case p:
            var ne = b.displayName || null;
            return ne !== null ? ne : V(b.type) || "Memo";
          case d: {
            var le = b, ce = le._payload, ae = le._init;
            try {
              return V(ae(ce));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var z = Object.assign, q = 0, K, J, te, ee, _, D, $;
    function S() {
    }
    S.__reactDisabledLog = !0;
    function W() {
      {
        if (q === 0) {
          K = console.log, J = console.info, te = console.warn, ee = console.error, _ = console.group, D = console.groupCollapsed, $ = console.groupEnd;
          var b = {
            configurable: !0,
            enumerable: !0,
            value: S,
            writable: !0
          };
          Object.defineProperties(console, {
            info: b,
            log: b,
            warn: b,
            error: b,
            group: b,
            groupCollapsed: b,
            groupEnd: b
          });
        }
        q++;
      }
    }
    function O() {
      {
        if (q--, q === 0) {
          var b = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: z({}, b, {
              value: K
            }),
            info: z({}, b, {
              value: J
            }),
            warn: z({}, b, {
              value: te
            }),
            error: z({}, b, {
              value: ee
            }),
            group: z({}, b, {
              value: _
            }),
            groupCollapsed: z({}, b, {
              value: D
            }),
            groupEnd: z({}, b, {
              value: $
            })
          });
        }
        q < 0 && w("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var T = E.ReactCurrentDispatcher, U;
    function j(b, B, G) {
      {
        if (U === void 0)
          try {
            throw Error();
          } catch (le) {
            var ne = le.stack.trim().match(/\n( *(at )?)/);
            U = ne && ne[1] || "";
          }
        return `
` + U + b;
      }
    }
    var Z = !1, A;
    {
      var Q = typeof WeakMap == "function" ? WeakMap : Map;
      A = new Q();
    }
    function R(b, B) {
      if (!b || Z)
        return "";
      {
        var G = A.get(b);
        if (G !== void 0)
          return G;
      }
      var ne;
      Z = !0;
      var le = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var ce;
      ce = T.current, T.current = null, W();
      try {
        if (B) {
          var ae = function() {
            throw Error();
          };
          if (Object.defineProperty(ae.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(ae, []);
            } catch (Ne) {
              ne = Ne;
            }
            Reflect.construct(b, [], ae);
          } else {
            try {
              ae.call();
            } catch (Ne) {
              ne = Ne;
            }
            b.call(ae.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Ne) {
            ne = Ne;
          }
          b();
        }
      } catch (Ne) {
        if (Ne && ne && typeof Ne.stack == "string") {
          for (var ie = Ne.stack.split(`
`), Me = ne.stack.split(`
`), he = ie.length - 1, me = Me.length - 1; he >= 1 && me >= 0 && ie[he] !== Me[me]; )
            me--;
          for (; he >= 1 && me >= 0; he--, me--)
            if (ie[he] !== Me[me]) {
              if (he !== 1 || me !== 1)
                do
                  if (he--, me--, me < 0 || ie[he] !== Me[me]) {
                    var qe = `
` + ie[he].replace(" at new ", " at ");
                    return b.displayName && qe.includes("<anonymous>") && (qe = qe.replace("<anonymous>", b.displayName)), typeof b == "function" && A.set(b, qe), qe;
                  }
                while (he >= 1 && me >= 0);
              break;
            }
        }
      } finally {
        Z = !1, T.current = ce, O(), Error.prepareStackTrace = le;
      }
      var Lt = b ? b.displayName || b.name : "", gt = Lt ? j(Lt) : "";
      return typeof b == "function" && A.set(b, gt), gt;
    }
    function ue(b, B, G) {
      return R(b, !1);
    }
    function fe(b) {
      var B = b.prototype;
      return !!(B && B.isReactComponent);
    }
    function oe(b, B, G) {
      if (b == null)
        return "";
      if (typeof b == "function")
        return R(b, fe(b));
      if (typeof b == "string")
        return j(b);
      switch (b) {
        case u:
          return j("Suspense");
        case c:
          return j("SuspenseList");
      }
      if (typeof b == "object")
        switch (b.$$typeof) {
          case l:
            return ue(b.render);
          case p:
            return oe(b.type, B, G);
          case d: {
            var ne = b, le = ne._payload, ce = ne._init;
            try {
              return oe(ce(le), B, G);
            } catch {
            }
          }
        }
      return "";
    }
    var Re = Object.prototype.hasOwnProperty, He = {}, Ve = E.ReactDebugCurrentFrame;
    function ze(b) {
      if (b) {
        var B = b._owner, G = oe(b.type, b._source, B ? B.type : null);
        Ve.setExtraStackFrame(G);
      } else
        Ve.setExtraStackFrame(null);
    }
    function et(b, B, G, ne, le) {
      {
        var ce = Function.call.bind(Re);
        for (var ae in b)
          if (ce(b, ae)) {
            var ie = void 0;
            try {
              if (typeof b[ae] != "function") {
                var Me = Error((ne || "React class") + ": " + G + " type `" + ae + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof b[ae] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw Me.name = "Invariant Violation", Me;
              }
              ie = b[ae](B, ae, ne, G, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (he) {
              ie = he;
            }
            ie && !(ie instanceof Error) && (ze(le), w("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", ne || "React class", G, ae, typeof ie), ze(null)), ie instanceof Error && !(ie.message in He) && (He[ie.message] = !0, ze(le), w("Failed %s type: %s", G, ie.message), ze(null));
          }
      }
    }
    var Ge = Array.isArray;
    function Pe(b) {
      return Ge(b);
    }
    function Ye(b) {
      {
        var B = typeof Symbol == "function" && Symbol.toStringTag, G = B && b[Symbol.toStringTag] || b.constructor.name || "Object";
        return G;
      }
    }
    function it(b) {
      try {
        return _e(b), !1;
      } catch {
        return !0;
      }
    }
    function _e(b) {
      return "" + b;
    }
    function Se(b) {
      if (it(b))
        return w("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Ye(b)), _e(b);
    }
    var Ke = E.ReactCurrentOwner, We = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, Ue, nt;
    function Ie(b) {
      if (Re.call(b, "ref")) {
        var B = Object.getOwnPropertyDescriptor(b, "ref").get;
        if (B && B.isReactWarning)
          return !1;
      }
      return b.ref !== void 0;
    }
    function xt(b) {
      if (Re.call(b, "key")) {
        var B = Object.getOwnPropertyDescriptor(b, "key").get;
        if (B && B.isReactWarning)
          return !1;
      }
      return b.key !== void 0;
    }
    function ot(b, B) {
      typeof b.ref == "string" && Ke.current;
    }
    function st(b, B) {
      {
        var G = function() {
          Ue || (Ue = !0, w("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", B));
        };
        G.isReactWarning = !0, Object.defineProperty(b, "key", {
          get: G,
          configurable: !0
        });
      }
    }
    function lt(b, B) {
      {
        var G = function() {
          nt || (nt = !0, w("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", B));
        };
        G.isReactWarning = !0, Object.defineProperty(b, "ref", {
          get: G,
          configurable: !0
        });
      }
    }
    var Ot = function(b, B, G, ne, le, ce, ae) {
      var ie = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: b,
        key: B,
        ref: G,
        props: ae,
        // Record the component responsible for creating this element.
        _owner: ce
      };
      return ie._store = {}, Object.defineProperty(ie._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(ie, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ne
      }), Object.defineProperty(ie, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: le
      }), Object.freeze && (Object.freeze(ie.props), Object.freeze(ie)), ie;
    };
    function ut(b, B, G, ne, le) {
      {
        var ce, ae = {}, ie = null, Me = null;
        G !== void 0 && (Se(G), ie = "" + G), xt(B) && (Se(B.key), ie = "" + B.key), Ie(B) && (Me = B.ref, ot(B));
        for (ce in B)
          Re.call(B, ce) && !We.hasOwnProperty(ce) && (ae[ce] = B[ce]);
        if (b && b.defaultProps) {
          var he = b.defaultProps;
          for (ce in he)
            ae[ce] === void 0 && (ae[ce] = he[ce]);
        }
        if (ie || Me) {
          var me = typeof b == "function" ? b.displayName || b.name || "Unknown" : b;
          ie && st(ae, me), Me && lt(ae, me);
        }
        return Ot(b, ie, Me, le, ne, Ke.current, ae);
      }
    }
    var ct = E.ReactCurrentOwner, tt = E.ReactDebugCurrentFrame;
    function Xe(b) {
      if (b) {
        var B = b._owner, G = oe(b.type, b._source, B ? B.type : null);
        tt.setExtraStackFrame(G);
      } else
        tt.setExtraStackFrame(null);
    }
    var Et;
    Et = !1;
    function kt(b) {
      return typeof b == "object" && b !== null && b.$$typeof === t;
    }
    function pt() {
      {
        if (ct.current) {
          var b = V(ct.current.type);
          if (b)
            return `

Check the render method of \`` + b + "`.";
        }
        return "";
      }
    }
    function kn(b) {
      return "";
    }
    var dt = {};
    function Ln(b) {
      {
        var B = pt();
        if (!B) {
          var G = typeof b == "string" ? b : b.displayName || b.name;
          G && (B = `

Check the top-level render call using <` + G + ">.");
        }
        return B;
      }
    }
    function ft(b, B) {
      {
        if (!b._store || b._store.validated || b.key != null)
          return;
        b._store.validated = !0;
        var G = Ln(B);
        if (dt[G])
          return;
        dt[G] = !0;
        var ne = "";
        b && b._owner && b._owner !== ct.current && (ne = " It was passed a child from " + V(b._owner.type) + "."), Xe(b), w('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', G, ne), Xe(null);
      }
    }
    function rn(b, B) {
      {
        if (typeof b != "object")
          return;
        if (Pe(b))
          for (var G = 0; G < b.length; G++) {
            var ne = b[G];
            kt(ne) && ft(ne, B);
          }
        else if (kt(b))
          b._store && (b._store.validated = !0);
        else if (b) {
          var le = g(b);
          if (typeof le == "function" && le !== b.entries)
            for (var ce = le.call(b), ae; !(ae = ce.next()).done; )
              kt(ae.value) && ft(ae.value, B);
        }
      }
    }
    function br(b) {
      {
        var B = b.type;
        if (B == null || typeof B == "string")
          return;
        var G;
        if (typeof B == "function")
          G = B.propTypes;
        else if (typeof B == "object" && (B.$$typeof === l || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        B.$$typeof === p))
          G = B.propTypes;
        else
          return;
        if (G) {
          var ne = V(B);
          et(G, b.props, "prop", ne, b);
        } else if (B.PropTypes !== void 0 && !Et) {
          Et = !0;
          var le = V(B);
          w("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", le || "Unknown");
        }
        typeof B.getDefaultProps == "function" && !B.getDefaultProps.isReactClassApproved && w("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function ht(b) {
      {
        for (var B = Object.keys(b.props), G = 0; G < B.length; G++) {
          var ne = B[G];
          if (ne !== "children" && ne !== "key") {
            Xe(b), w("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", ne), Xe(null);
            break;
          }
        }
        b.ref !== null && (Xe(b), w("Invalid attribute `ref` supplied to `React.Fragment`."), Xe(null));
      }
    }
    var re = {};
    function eo(b, B, G, ne, le, ce) {
      {
        var ae = N(b);
        if (!ae) {
          var ie = "";
          (b === void 0 || typeof b == "object" && b !== null && Object.keys(b).length === 0) && (ie += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var Me = kn();
          Me ? ie += Me : ie += pt();
          var he;
          b === null ? he = "null" : Pe(b) ? he = "array" : b !== void 0 && b.$$typeof === t ? (he = "<" + (V(b.type) || "Unknown") + " />", ie = " Did you accidentally export a JSX literal instead of a component?") : he = typeof b, w("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", he, ie);
        }
        var me = ut(b, B, G, le, ce);
        if (me == null)
          return me;
        if (ae) {
          var qe = B.children;
          if (qe !== void 0)
            if (ne)
              if (Pe(qe)) {
                for (var Lt = 0; Lt < qe.length; Lt++)
                  rn(qe[Lt], b);
                Object.freeze && Object.freeze(qe);
              } else
                w("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              rn(qe, b);
        }
        if (Re.call(B, "key")) {
          var gt = V(b), Ne = Object.keys(B).filter(function(_i) {
            return _i !== "key";
          }), wr = Ne.length > 0 ? "{key: someKey, " + Ne.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!re[gt + wr]) {
            var Li = Ne.length > 0 ? "{" + Ne.join(": ..., ") + ": ...}" : "{}";
            w(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, wr, gt, Li, gt), re[gt + wr] = !0;
          }
        }
        return b === r ? ht(me) : br(me), me;
      }
    }
    function xi(b, B, G) {
      return eo(b, B, G, !0);
    }
    function Oi(b, B, G) {
      return eo(b, B, G, !1);
    }
    var Ei = Oi, ki = xi;
    Zd.Fragment = r, Zd.jsx = Ei, Zd.jsxs = ki;
  }()), Zd;
}
process.env.NODE_ENV === "production" ? vC.exports = hJ() : vC.exports = gJ();
var ro = vC.exports;
Ze({});
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function oP(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function go(e) {
  var t, n;
  return oP(e) === !1 ? !1 : (t = e.constructor, t === void 0 ? !0 : (n = t.prototype, !(oP(n) === !1 || n.hasOwnProperty("isPrototypeOf") === !1)));
}
var U3 = Symbol.for("immer-nothing"), iP = Symbol.for("immer-draftable"), ii = Symbol.for("immer-state"), mJ = process.env.NODE_ENV !== "production" ? [
  // All error codes, starting by 0:
  function(e) {
    return `The plugin for '${e}' has not been loaded into Immer. To enable the plugin, import and call \`enable${e}()\` when initializing your application.`;
  },
  function(e) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${e}'`;
  },
  "This object has been frozen and should not be mutated",
  function(e) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + e;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(e) {
    return `'current' expects a draft, got: ${e}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(e) {
    return `'original' expects a draft, got: ${e}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function jo(e, ...t) {
  if (process.env.NODE_ENV !== "production") {
    const n = mJ[e], r = typeof n == "function" ? n.apply(null, t) : n;
    throw new Error(`[Immer] ${r}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var su = Object.getPrototypeOf;
function _l(e) {
  return !!e && !!e[ii];
}
function Pl(e) {
  var t;
  return e ? $3(e) || Array.isArray(e) || !!e[iP] || !!((t = e.constructor) != null && t[iP]) || dv(e) || fv(e) : !1;
}
var vJ = Object.prototype.constructor.toString();
function $3(e) {
  if (!e || typeof e != "object")
    return !1;
  const t = su(e);
  if (t === null)
    return !0;
  const n = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
  return n === Object ? !0 : typeof n == "function" && Function.toString.call(n) === vJ;
}
function ng(e, t) {
  pv(e) === 0 ? Reflect.ownKeys(e).forEach((n) => {
    t(n, e[n], e);
  }) : e.forEach((n, r) => t(r, n, e));
}
function pv(e) {
  const t = e[ii];
  return t ? t.type_ : Array.isArray(e) ? 1 : dv(e) ? 2 : fv(e) ? 3 : 0;
}
function yC(e, t) {
  return pv(e) === 2 ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t);
}
function H3(e, t, n) {
  const r = pv(e);
  r === 2 ? e.set(t, n) : r === 3 ? e.add(n) : e[t] = n;
}
function yJ(e, t) {
  return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && t !== t;
}
function dv(e) {
  return e instanceof Map;
}
function fv(e) {
  return e instanceof Set;
}
function Ka(e) {
  return e.copy_ || e.base_;
}
function bC(e, t) {
  if (dv(e))
    return new Map(e);
  if (fv(e))
    return new Set(e);
  if (Array.isArray(e))
    return Array.prototype.slice.call(e);
  const n = $3(e);
  if (t === !0 || t === "class_only" && !n) {
    const r = Object.getOwnPropertyDescriptors(e);
    delete r[ii];
    let o = Reflect.ownKeys(r);
    for (let i = 0; i < o.length; i++) {
      const a = o[i], s = r[a];
      s.writable === !1 && (s.writable = !0, s.configurable = !0), (s.get || s.set) && (r[a] = {
        configurable: !0,
        writable: !0,
        // could live with !!desc.set as well here...
        enumerable: s.enumerable,
        value: e[a]
      });
    }
    return Object.create(su(e), r);
  } else {
    const r = su(e);
    if (r !== null && n)
      return { ...e };
    const o = Object.create(r);
    return Object.assign(o, e);
  }
}
function YO(e, t = !1) {
  return hv(e) || _l(e) || !Pl(e) || (pv(e) > 1 && (e.set = e.add = e.clear = e.delete = bJ), Object.freeze(e), t && Object.entries(e).forEach(([n, r]) => YO(r, !0))), e;
}
function bJ() {
  jo(2);
}
function hv(e) {
  return Object.isFrozen(e);
}
var wJ = {};
function Sl(e) {
  const t = wJ[e];
  return t || jo(0, e), t;
}
var up;
function W3() {
  return up;
}
function CJ(e, t) {
  return {
    drafts_: [],
    parent_: e,
    immer_: t,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0
  };
}
function sP(e, t) {
  t && (Sl("Patches"), e.patches_ = [], e.inversePatches_ = [], e.patchListener_ = t);
}
function wC(e) {
  CC(e), e.drafts_.forEach(xJ), e.drafts_ = null;
}
function CC(e) {
  e === up && (up = e.parent_);
}
function aP(e) {
  return up = CJ(up, e);
}
function xJ(e) {
  const t = e[ii];
  t.type_ === 0 || t.type_ === 1 ? t.revoke_() : t.revoked_ = !0;
}
function lP(e, t) {
  t.unfinalizedDrafts_ = t.drafts_.length;
  const n = t.drafts_[0];
  return e !== void 0 && e !== n ? (n[ii].modified_ && (wC(t), jo(4)), Pl(e) && (e = rg(t, e), t.parent_ || og(t, e)), t.patches_ && Sl("Patches").generateReplacementPatches_(
    n[ii].base_,
    e,
    t.patches_,
    t.inversePatches_
  )) : e = rg(t, n, []), wC(t), t.patches_ && t.patchListener_(t.patches_, t.inversePatches_), e !== U3 ? e : void 0;
}
function rg(e, t, n) {
  if (hv(t))
    return t;
  const r = t[ii];
  if (!r)
    return ng(
      t,
      (o, i) => uP(e, r, t, o, i, n)
    ), t;
  if (r.scope_ !== e)
    return t;
  if (!r.modified_)
    return og(e, r.base_, !0), r.base_;
  if (!r.finalized_) {
    r.finalized_ = !0, r.scope_.unfinalizedDrafts_--;
    const o = r.copy_;
    let i = o, a = !1;
    r.type_ === 3 && (i = new Set(o), o.clear(), a = !0), ng(
      i,
      (s, l) => uP(e, r, o, s, l, n, a)
    ), og(e, o, !1), n && e.patches_ && Sl("Patches").generatePatches_(
      r,
      n,
      e.patches_,
      e.inversePatches_
    );
  }
  return r.copy_;
}
function uP(e, t, n, r, o, i, a) {
  if (process.env.NODE_ENV !== "production" && o === n && jo(5), _l(o)) {
    const s = i && t && t.type_ !== 3 && // Set objects are atomic since they have no keys.
    !yC(t.assigned_, r) ? i.concat(r) : void 0, l = rg(e, o, s);
    if (H3(n, r, l), _l(l))
      e.canAutoFreeze_ = !1;
    else
      return;
  } else a && n.add(o);
  if (Pl(o) && !hv(o)) {
    if (!e.immer_.autoFreeze_ && e.unfinalizedDrafts_ < 1)
      return;
    rg(e, o), (!t || !t.scope_.parent_) && typeof r != "symbol" && Object.prototype.propertyIsEnumerable.call(n, r) && og(e, o);
  }
}
function og(e, t, n = !1) {
  !e.parent_ && e.immer_.autoFreeze_ && e.canAutoFreeze_ && YO(t, n);
}
function OJ(e, t) {
  const n = Array.isArray(e), r = {
    type_: n ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: t ? t.scope_ : W3(),
    // True for both shallow and deep changes.
    modified_: !1,
    // Used during finalization.
    finalized_: !1,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: t,
    // The base state.
    base_: e,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: !1
  };
  let o = r, i = JO;
  n && (o = [r], i = cp);
  const { revoke: a, proxy: s } = Proxy.revocable(o, i);
  return r.draft_ = s, r.revoke_ = a, s;
}
var JO = {
  get(e, t) {
    if (t === ii)
      return e;
    const n = Ka(e);
    if (!yC(n, t))
      return EJ(e, n, t);
    const r = n[t];
    return e.finalized_ || !Pl(r) ? r : r === ib(e.base_, t) ? (sb(e), e.copy_[t] = OC(r, e)) : r;
  },
  has(e, t) {
    return t in Ka(e);
  },
  ownKeys(e) {
    return Reflect.ownKeys(Ka(e));
  },
  set(e, t, n) {
    const r = V3(Ka(e), t);
    if (r != null && r.set)
      return r.set.call(e.draft_, n), !0;
    if (!e.modified_) {
      const o = ib(Ka(e), t), i = o == null ? void 0 : o[ii];
      if (i && i.base_ === n)
        return e.copy_[t] = n, e.assigned_[t] = !1, !0;
      if (yJ(n, o) && (n !== void 0 || yC(e.base_, t)))
        return !0;
      sb(e), xC(e);
    }
    return e.copy_[t] === n && // special case: handle new props with value 'undefined'
    (n !== void 0 || t in e.copy_) || // special case: NaN
    Number.isNaN(n) && Number.isNaN(e.copy_[t]) || (e.copy_[t] = n, e.assigned_[t] = !0), !0;
  },
  deleteProperty(e, t) {
    return ib(e.base_, t) !== void 0 || t in e.base_ ? (e.assigned_[t] = !1, sb(e), xC(e)) : delete e.assigned_[t], e.copy_ && delete e.copy_[t], !0;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(e, t) {
    const n = Ka(e), r = Reflect.getOwnPropertyDescriptor(n, t);
    return r && {
      writable: !0,
      configurable: e.type_ !== 1 || t !== "length",
      enumerable: r.enumerable,
      value: n[t]
    };
  },
  defineProperty() {
    jo(11);
  },
  getPrototypeOf(e) {
    return su(e.base_);
  },
  setPrototypeOf() {
    jo(12);
  }
}, cp = {};
ng(JO, (e, t) => {
  cp[e] = function() {
    return arguments[0] = arguments[0][0], t.apply(this, arguments);
  };
});
cp.deleteProperty = function(e, t) {
  return process.env.NODE_ENV !== "production" && isNaN(parseInt(t)) && jo(13), cp.set.call(this, e, t, void 0);
};
cp.set = function(e, t, n) {
  return process.env.NODE_ENV !== "production" && t !== "length" && isNaN(parseInt(t)) && jo(14), JO.set.call(this, e[0], t, n, e[0]);
};
function ib(e, t) {
  const n = e[ii];
  return (n ? Ka(n) : e)[t];
}
function EJ(e, t, n) {
  var r;
  const o = V3(t, n);
  return o ? "value" in o ? o.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (r = o.get) == null ? void 0 : r.call(e.draft_)
  ) : void 0;
}
function V3(e, t) {
  if (!(t in e))
    return;
  let n = su(e);
  for (; n; ) {
    const r = Object.getOwnPropertyDescriptor(n, t);
    if (r)
      return r;
    n = su(n);
  }
}
function xC(e) {
  e.modified_ || (e.modified_ = !0, e.parent_ && xC(e.parent_));
}
function sb(e) {
  e.copy_ || (e.copy_ = bC(
    e.base_,
    e.scope_.immer_.useStrictShallowCopy_
  ));
}
var kJ = class {
  constructor(e) {
    this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.produce = (t, n, r) => {
      if (typeof t == "function" && typeof n != "function") {
        const i = n;
        n = t;
        const a = this;
        return function(s = i, ...l) {
          return a.produce(s, (u) => n.call(this, u, ...l));
        };
      }
      typeof n != "function" && jo(6), r !== void 0 && typeof r != "function" && jo(7);
      let o;
      if (Pl(t)) {
        const i = aP(this), a = OC(t, void 0);
        let s = !0;
        try {
          o = n(a), s = !1;
        } finally {
          s ? wC(i) : CC(i);
        }
        return sP(i, r), lP(o, i);
      } else if (!t || typeof t != "object") {
        if (o = n(t), o === void 0 && (o = t), o === U3 && (o = void 0), this.autoFreeze_ && YO(o, !0), r) {
          const i = [], a = [];
          Sl("Patches").generateReplacementPatches_(t, o, i, a), r(i, a);
        }
        return o;
      } else
        jo(1, t);
    }, this.produceWithPatches = (t, n) => {
      if (typeof t == "function")
        return (i, ...a) => this.produceWithPatches(i, (s) => t(s, ...a));
      let r, o;
      return [this.produce(t, n, (i, a) => {
        r = i, o = a;
      }), r, o];
    }, typeof (e == null ? void 0 : e.autoFreeze) == "boolean" && this.setAutoFreeze(e.autoFreeze), typeof (e == null ? void 0 : e.useStrictShallowCopy) == "boolean" && this.setUseStrictShallowCopy(e.useStrictShallowCopy);
  }
  createDraft(e) {
    Pl(e) || jo(8), _l(e) && (e = LJ(e));
    const t = aP(this), n = OC(e, void 0);
    return n[ii].isManual_ = !0, CC(t), n;
  }
  finishDraft(e, t) {
    const n = e && e[ii];
    (!n || !n.isManual_) && jo(9);
    const { scope_: r } = n;
    return sP(r, t), lP(void 0, r);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(e) {
    this.autoFreeze_ = e;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(e) {
    this.useStrictShallowCopy_ = e;
  }
  applyPatches(e, t) {
    let n;
    for (n = t.length - 1; n >= 0; n--) {
      const o = t[n];
      if (o.path.length === 0 && o.op === "replace") {
        e = o.value;
        break;
      }
    }
    n > -1 && (t = t.slice(n + 1));
    const r = Sl("Patches").applyPatches_;
    return _l(e) ? r(e, t) : this.produce(
      e,
      (o) => r(o, t)
    );
  }
};
function OC(e, t) {
  const n = dv(e) ? Sl("MapSet").proxyMap_(e, t) : fv(e) ? Sl("MapSet").proxySet_(e, t) : OJ(e, t);
  return (t ? t.scope_ : W3()).drafts_.push(n), n;
}
function LJ(e) {
  return _l(e) || jo(10, e), q3(e);
}
function q3(e) {
  if (!Pl(e) || hv(e))
    return e;
  const t = e[ii];
  let n;
  if (t) {
    if (!t.modified_)
      return t.base_;
    t.finalized_ = !0, n = bC(e, t.scope_.immer_.useStrictShallowCopy_);
  } else
    n = bC(e, !0);
  return ng(n, (r, o) => {
    H3(n, r, q3(o));
  }), t && (t.finalized_ = !1), n;
}
var si = new kJ(), QO = si.produce;
si.produceWithPatches.bind(
  si
);
si.setAutoFreeze.bind(si);
si.setUseStrictShallowCopy.bind(si);
si.applyPatches.bind(si);
var cP = si.createDraft.bind(si), pP = si.finishDraft.bind(si), je = {
  ancestors(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = je.levels(e, t);
    return n ? r = r.slice(1) : r = r.slice(0, -1), r;
  },
  common(e, t) {
    for (var n = [], r = 0; r < e.length && r < t.length; r++) {
      var o = e[r], i = t[r];
      if (o !== i)
        break;
      n.push(o);
    }
    return n;
  },
  compare(e, t) {
    for (var n = Math.min(e.length, t.length), r = 0; r < n; r++) {
      if (e[r] < t[r]) return -1;
      if (e[r] > t[r]) return 1;
    }
    return 0;
  },
  endsAfter(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return je.equals(r, o) && i > a;
  },
  endsAt(e, t) {
    var n = e.length, r = e.slice(0, n), o = t.slice(0, n);
    return je.equals(r, o);
  },
  endsBefore(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return je.equals(r, o) && i < a;
  },
  equals(e, t) {
    return e.length === t.length && e.every((n, r) => n === t[r]);
  },
  hasPrevious(e) {
    return e[e.length - 1] > 0;
  },
  isAfter(e, t) {
    return je.compare(e, t) === 1;
  },
  isAncestor(e, t) {
    return e.length < t.length && je.compare(e, t) === 0;
  },
  isBefore(e, t) {
    return je.compare(e, t) === -1;
  },
  isChild(e, t) {
    return e.length === t.length + 1 && je.compare(e, t) === 0;
  },
  isCommon(e, t) {
    return e.length <= t.length && je.compare(e, t) === 0;
  },
  isDescendant(e, t) {
    return e.length > t.length && je.compare(e, t) === 0;
  },
  isParent(e, t) {
    return e.length + 1 === t.length && je.compare(e, t) === 0;
  },
  isPath(e) {
    return Array.isArray(e) && (e.length === 0 || typeof e[0] == "number");
  },
  isSibling(e, t) {
    if (e.length !== t.length)
      return !1;
    var n = e.slice(0, -1), r = t.slice(0, -1), o = e[e.length - 1], i = t[t.length - 1];
    return o !== i && je.equals(n, r);
  },
  levels(e) {
    for (var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = [], o = 0; o <= e.length; o++)
      r.push(e.slice(0, o));
    return n && r.reverse(), r;
  },
  next(e) {
    if (e.length === 0)
      throw new Error("Cannot get the next path of a root path [".concat(e, "], because it has no next index."));
    var t = e[e.length - 1];
    return e.slice(0, -1).concat(t + 1);
  },
  operationCanTransformPath(e) {
    switch (e.type) {
      case "insert_node":
      case "remove_node":
      case "merge_node":
      case "split_node":
      case "move_node":
        return !0;
      default:
        return !1;
    }
  },
  parent(e) {
    if (e.length === 0)
      throw new Error("Cannot get the parent path of the root path [".concat(e, "]."));
    return e.slice(0, -1);
  },
  previous(e) {
    if (e.length === 0)
      throw new Error("Cannot get the previous path of a root path [".concat(e, "], because it has no previous index."));
    var t = e[e.length - 1];
    if (t <= 0)
      throw new Error("Cannot get the previous path of a first child path [".concat(e, "] because it would result in a negative index."));
    return e.slice(0, -1).concat(t - 1);
  },
  relative(e, t) {
    if (!je.isAncestor(t, e) && !je.equals(e, t))
      throw new Error("Cannot get the relative path of [".concat(e, "] inside ancestor [").concat(t, "], because it is not above or equal to the path."));
    return e.slice(t.length);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!e) return null;
    var r = [...e], {
      affinity: o = "forward"
    } = n;
    if (e.length === 0)
      return r;
    switch (t.type) {
      case "insert_node": {
        var {
          path: i
        } = t;
        (je.equals(i, r) || je.endsBefore(i, r) || je.isAncestor(i, r)) && (r[i.length - 1] += 1);
        break;
      }
      case "remove_node": {
        var {
          path: a
        } = t;
        if (je.equals(a, r) || je.isAncestor(a, r))
          return null;
        je.endsBefore(a, r) && (r[a.length - 1] -= 1);
        break;
      }
      case "merge_node": {
        var {
          path: s,
          position: l
        } = t;
        je.equals(s, r) || je.endsBefore(s, r) ? r[s.length - 1] -= 1 : je.isAncestor(s, r) && (r[s.length - 1] -= 1, r[s.length] += l);
        break;
      }
      case "split_node": {
        var {
          path: u,
          position: c
        } = t;
        if (je.equals(u, r)) {
          if (o === "forward")
            r[r.length - 1] += 1;
          else if (o !== "backward") return null;
        } else je.endsBefore(u, r) ? r[u.length - 1] += 1 : je.isAncestor(u, r) && e[u.length] >= c && (r[u.length - 1] += 1, r[u.length] -= c);
        break;
      }
      case "move_node": {
        var {
          path: p,
          newPath: d
        } = t;
        if (je.equals(p, d))
          return r;
        if (je.isAncestor(p, r) || je.equals(p, r)) {
          var h = d.slice();
          return je.endsBefore(p, d) && p.length < d.length && (h[p.length - 1] -= 1), h.concat(r.slice(p.length));
        } else je.isSibling(p, d) && (je.isAncestor(d, r) || je.equals(d, r)) ? je.endsBefore(p, r) ? r[p.length - 1] -= 1 : r[p.length - 1] += 1 : je.endsBefore(d, r) || je.equals(d, r) || je.isAncestor(d, r) ? (je.endsBefore(p, r) && (r[p.length - 1] -= 1), r[d.length - 1] += 1) : je.endsBefore(p, r) && (je.equals(d, r) && (r[d.length - 1] += 1), r[p.length - 1] -= 1);
        break;
      }
    }
    return r;
  }
};
function pp(e) {
  "@babel/helpers - typeof";
  return pp = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, pp(e);
}
function _J(e, t) {
  if (pp(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (pp(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function PJ(e) {
  var t = _J(e, "string");
  return pp(t) === "symbol" ? t : String(t);
}
function gu(e, t, n) {
  return t = PJ(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function dP(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Nu(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? dP(Object(n), !0).forEach(function(r) {
      gu(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : dP(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var SJ = (e, t, n) => {
  switch (n.type) {
    case "insert_node": {
      var {
        path: r,
        node: o
      } = n, i = bt.parent(e, r), a = r[r.length - 1];
      if (a > i.children.length)
        throw new Error('Cannot apply an "insert_node" operation at path ['.concat(r, "] because the destination is past the end of the node."));
      if (i.children.splice(a, 0, o), t)
        for (var [s, l] of It.points(t))
          t[l] = Yn.transform(s, n);
      break;
    }
    case "insert_text": {
      var {
        path: u,
        offset: c,
        text: p
      } = n;
      if (p.length === 0) break;
      var d = bt.leaf(e, u), h = d.text.slice(0, c), f = d.text.slice(c);
      if (d.text = h + p + f, t)
        for (var [m, g] of It.points(t))
          t[g] = Yn.transform(m, n);
      break;
    }
    case "merge_node": {
      var {
        path: E
      } = n, w = bt.get(e, E), M = je.previous(E), x = bt.get(e, M), y = bt.parent(e, E), C = E[E.length - 1];
      if (Ir.isText(w) && Ir.isText(x))
        x.text += w.text;
      else if (!Ir.isText(w) && !Ir.isText(x))
        x.children.push(...w.children);
      else
        throw new Error('Cannot apply a "merge_node" operation at path ['.concat(E, "] to nodes of different interfaces: ").concat(Wo.stringify(w), " ").concat(Wo.stringify(x)));
      if (y.children.splice(C, 1), t)
        for (var [P, F] of It.points(t))
          t[F] = Yn.transform(P, n);
      break;
    }
    case "move_node": {
      var {
        path: L,
        newPath: N
      } = n;
      if (je.isAncestor(L, N))
        throw new Error("Cannot move a path [".concat(L, "] to new path [").concat(N, "] because the destination is inside itself."));
      var I = bt.get(e, L), H = bt.parent(e, L), V = L[L.length - 1];
      H.children.splice(V, 1);
      var z = je.transform(L, n), q = bt.get(e, je.parent(z)), K = z[z.length - 1];
      if (q.children.splice(K, 0, I), t)
        for (var [J, te] of It.points(t))
          t[te] = Yn.transform(J, n);
      break;
    }
    case "remove_node": {
      var {
        path: ee
      } = n, _ = ee[ee.length - 1], D = bt.parent(e, ee);
      if (D.children.splice(_, 1), t)
        for (var [$, S] of It.points(t)) {
          var W = Yn.transform($, n);
          if (t != null && W != null)
            t[S] = W;
          else {
            var O = void 0, T = void 0;
            for (var [U, j] of bt.texts(e))
              if (je.compare(j, ee) === -1)
                O = [U, j];
              else {
                T = [U, j];
                break;
              }
            var Z = !1;
            O && T && (je.equals(T[1], ee) ? Z = !je.hasPrevious(T[1]) : Z = je.common(O[1], ee).length < je.common(T[1], ee).length), O && !Z ? ($.path = O[1], $.offset = O[0].text.length) : T ? ($.path = T[1], $.offset = 0) : t = null;
          }
        }
      break;
    }
    case "remove_text": {
      var {
        path: A,
        offset: Q,
        text: R
      } = n;
      if (R.length === 0) break;
      var ue = bt.leaf(e, A), fe = ue.text.slice(0, Q), oe = ue.text.slice(Q + R.length);
      if (ue.text = fe + oe, t)
        for (var [Re, He] of It.points(t))
          t[He] = Yn.transform(Re, n);
      break;
    }
    case "set_node": {
      var {
        path: Ve,
        properties: ze,
        newProperties: et
      } = n;
      if (Ve.length === 0)
        throw new Error("Cannot set properties on the root node!");
      var Ge = bt.get(e, Ve);
      for (var Pe in et) {
        if (Pe === "children" || Pe === "text")
          throw new Error('Cannot set the "'.concat(Pe, '" property of nodes!'));
        var Ye = et[Pe];
        Ye == null ? delete Ge[Pe] : Ge[Pe] = Ye;
      }
      for (var it in ze)
        et.hasOwnProperty(it) || delete Ge[it];
      break;
    }
    case "set_selection": {
      var {
        newProperties: _e
      } = n;
      if (_e == null)
        t = _e;
      else {
        if (t == null) {
          if (!It.isRange(_e))
            throw new Error('Cannot apply an incomplete "set_selection" operation properties '.concat(Wo.stringify(_e), " when there is no current selection."));
          t = Nu({}, _e);
        }
        for (var Se in _e) {
          var Ke = _e[Se];
          if (Ke == null) {
            if (Se === "anchor" || Se === "focus")
              throw new Error('Cannot remove the "'.concat(Se, '" selection property'));
            delete t[Se];
          } else
            t[Se] = Ke;
        }
      }
      break;
    }
    case "split_node": {
      var {
        path: We,
        position: Ue,
        properties: nt
      } = n;
      if (We.length === 0)
        throw new Error('Cannot apply a "split_node" operation at path ['.concat(We, "] because the root node cannot be split."));
      var Ie = bt.get(e, We), xt = bt.parent(e, We), ot = We[We.length - 1], st;
      if (Ir.isText(Ie)) {
        var lt = Ie.text.slice(0, Ue), Ot = Ie.text.slice(Ue);
        Ie.text = lt, st = Nu(Nu({}, nt), {}, {
          text: Ot
        });
      } else {
        var ut = Ie.children.slice(0, Ue), ct = Ie.children.slice(Ue);
        Ie.children = ut, st = Nu(Nu({}, nt), {}, {
          children: ct
        });
      }
      if (xt.children.splice(ot + 1, 0, st), t)
        for (var [tt, Xe] of It.points(t))
          t[Xe] = Yn.transform(tt, n);
      break;
    }
  }
  return t;
}, MJ = {
  transform(e, t) {
    e.children = cP(e.children);
    var n = e.selection && cP(e.selection);
    try {
      n = SJ(e, n, t);
    } finally {
      e.children = pP(e.children), n ? e.selection = _l(n) ? pP(n) : n : e.selection = null;
    }
  }
}, DJ = {
  insertNodes(e, t, n) {
    e.insertNodes(t, n);
  },
  liftNodes(e, t) {
    e.liftNodes(t);
  },
  mergeNodes(e, t) {
    e.mergeNodes(t);
  },
  moveNodes(e, t) {
    e.moveNodes(t);
  },
  removeNodes(e, t) {
    e.removeNodes(t);
  },
  setNodes(e, t, n) {
    e.setNodes(t, n);
  },
  splitNodes(e, t) {
    e.splitNodes(t);
  },
  unsetNodes(e, t, n) {
    e.unsetNodes(t, n);
  },
  unwrapNodes(e, t) {
    e.unwrapNodes(t);
  },
  wrapNodes(e, t, n) {
    e.wrapNodes(t, n);
  }
}, TJ = {
  collapse(e, t) {
    e.collapse(t);
  },
  deselect(e) {
    e.deselect();
  },
  move(e, t) {
    e.move(t);
  },
  select(e, t) {
    e.select(t);
  },
  setPoint(e, t, n) {
    e.setPoint(t, n);
  },
  setSelection(e, t) {
    e.setSelection(t);
  }
}, Z3 = (e, t) => {
  for (var n in e) {
    var r = e[n], o = t[n];
    if (go(r) && go(o)) {
      if (!Z3(r, o)) return !1;
    } else if (Array.isArray(r) && Array.isArray(o)) {
      if (r.length !== o.length) return !1;
      for (var i = 0; i < r.length; i++)
        if (r[i] !== o[i]) return !1;
    } else if (r !== o)
      return !1;
  }
  for (var a in t)
    if (e[a] === void 0 && t[a] !== void 0)
      return !1;
  return !0;
};
function jJ(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), o, i;
  for (i = 0; i < r.length; i++)
    o = r[i], !(t.indexOf(o) >= 0) && (n[o] = e[o]);
  return n;
}
function dp(e, t) {
  if (e == null) return {};
  var n = jJ(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (o = 0; o < i.length; o++)
      r = i[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
var AJ = ["anchor", "focus"];
function fP(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function BJ(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? fP(Object(n), !0).forEach(function(r) {
      gu(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : fP(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var It = {
  edges(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, {
      anchor: r,
      focus: o
    } = e;
    return It.isBackward(e) === n ? [r, o] : [o, r];
  },
  end(e) {
    var [, t] = It.edges(e);
    return t;
  },
  equals(e, t) {
    return Yn.equals(e.anchor, t.anchor) && Yn.equals(e.focus, t.focus);
  },
  includes(e, t) {
    if (It.isRange(t)) {
      if (It.includes(e, t.anchor) || It.includes(e, t.focus))
        return !0;
      var [n, r] = It.edges(e), [o, i] = It.edges(t);
      return Yn.isBefore(n, o) && Yn.isAfter(r, i);
    }
    var [a, s] = It.edges(e), l = !1, u = !1;
    return Yn.isPoint(t) ? (l = Yn.compare(t, a) >= 0, u = Yn.compare(t, s) <= 0) : (l = je.compare(t, a.path) >= 0, u = je.compare(t, s.path) <= 0), l && u;
  },
  intersection(e, t) {
    var n = dp(e, AJ), [r, o] = It.edges(e), [i, a] = It.edges(t), s = Yn.isBefore(r, i) ? i : r, l = Yn.isBefore(o, a) ? o : a;
    return Yn.isBefore(l, s) ? null : BJ({
      anchor: s,
      focus: l
    }, n);
  },
  isBackward(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return Yn.isAfter(t, n);
  },
  isCollapsed(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return Yn.equals(t, n);
  },
  isExpanded(e) {
    return !It.isCollapsed(e);
  },
  isForward(e) {
    return !It.isBackward(e);
  },
  isRange(e) {
    return go(e) && Yn.isPoint(e.anchor) && Yn.isPoint(e.focus);
  },
  *points(e) {
    yield [e.anchor, "anchor"], yield [e.focus, "focus"];
  },
  start(e) {
    var [t] = It.edges(e);
    return t;
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return QO(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "inward"
      } = n, i, a;
      if (o === "inward") {
        var s = It.isCollapsed(r);
        It.isForward(r) ? (i = "forward", a = s ? i : "backward") : (i = "backward", a = s ? i : "forward");
      } else o === "outward" ? It.isForward(r) ? (i = "backward", a = "forward") : (i = "forward", a = "backward") : (i = o, a = o);
      var l = Yn.transform(r.anchor, t, {
        affinity: i
      }), u = Yn.transform(r.focus, t, {
        affinity: a
      });
      if (!l || !u)
        return null;
      r.anchor = l, r.focus = u;
    });
  }
}, hP = (e) => go(e) && bt.isNodeList(e.children) && !Bn.isEditor(e), gs = {
  isAncestor(e) {
    return go(e) && bt.isNodeList(e.children);
  },
  isElement: hP,
  isElementList(e) {
    return Array.isArray(e) && e.every((t) => gs.isElement(t));
  },
  isElementProps(e) {
    return e.children !== void 0;
  },
  isElementType: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "type";
    return hP(e) && e[n] === t;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "children" && e[n] !== t[n])
        return !1;
    return !0;
  }
}, IJ = ["children"], RJ = ["text"], gP = /* @__PURE__ */ new WeakMap(), bt = {
  ancestor(e, t) {
    var n = bt.get(e, t);
    if (Ir.isText(n))
      throw new Error("Cannot get the ancestor node at path [".concat(t, "] because it refers to a text node instead: ").concat(Wo.stringify(n)));
    return n;
  },
  ancestors(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of je.ancestors(t, n)) {
        var o = bt.ancestor(e, r), i = [o, r];
        yield i;
      }
    }();
  },
  child(e, t) {
    if (Ir.isText(e))
      throw new Error("Cannot get the child of a text node: ".concat(Wo.stringify(e)));
    var n = e.children[t];
    if (n == null)
      throw new Error("Cannot get child at index `".concat(t, "` in node: ").concat(Wo.stringify(e)));
    return n;
  },
  children(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var {
        reverse: r = !1
      } = n, o = bt.ancestor(e, t), {
        children: i
      } = o, a = r ? i.length - 1 : 0; r ? a >= 0 : a < i.length; ) {
        var s = bt.child(o, a), l = t.concat(a);
        yield [s, l], a = r ? a - 1 : a + 1;
      }
    }();
  },
  common(e, t, n) {
    var r = je.common(t, n), o = bt.get(e, r);
    return [o, r];
  },
  descendant(e, t) {
    var n = bt.get(e, t);
    if (Bn.isEditor(n))
      throw new Error("Cannot get the descendant node at path [".concat(t, "] because it refers to the root editor node instead: ").concat(Wo.stringify(n)));
    return n;
  },
  descendants(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of bt.nodes(e, t))
        r.length !== 0 && (yield [n, r]);
    }();
  },
  elements(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of bt.nodes(e, t))
        gs.isElement(n) && (yield [n, r]);
    }();
  },
  extractProps(e) {
    if (gs.isAncestor(e)) {
      var t = dp(e, IJ);
      return t;
    } else {
      var t = dp(e, RJ);
      return t;
    }
  },
  first(e, t) {
    for (var n = t.slice(), r = bt.get(e, n); r && !(Ir.isText(r) || r.children.length === 0); )
      r = r.children[0], n.push(0);
    return [r, n];
  },
  fragment(e, t) {
    if (Ir.isText(e))
      throw new Error("Cannot get a fragment starting from a root text node: ".concat(Wo.stringify(e)));
    var n = QO({
      children: e.children
    }, (r) => {
      var [o, i] = It.edges(t), a = bt.nodes(r, {
        reverse: !0,
        pass: (d) => {
          var [, h] = d;
          return !It.includes(t, h);
        }
      });
      for (var [, s] of a) {
        if (!It.includes(t, s)) {
          var l = bt.parent(r, s), u = s[s.length - 1];
          l.children.splice(u, 1);
        }
        if (je.equals(s, i.path)) {
          var c = bt.leaf(r, s);
          c.text = c.text.slice(0, i.offset);
        }
        if (je.equals(s, o.path)) {
          var p = bt.leaf(r, s);
          p.text = p.text.slice(o.offset);
        }
      }
      Bn.isEditor(r) && (r.selection = null);
    });
    return n.children;
  },
  get(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (Ir.isText(n) || !n.children[o])
        throw new Error("Cannot find a descendant at path [".concat(t, "] in node: ").concat(Wo.stringify(e)));
      n = n.children[o];
    }
    return n;
  },
  has(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (Ir.isText(n) || !n.children[o])
        return !1;
      n = n.children[o];
    }
    return !0;
  },
  isNode(e) {
    return Ir.isText(e) || gs.isElement(e) || Bn.isEditor(e);
  },
  isNodeList(e) {
    if (!Array.isArray(e))
      return !1;
    var t = gP.get(e);
    if (t !== void 0)
      return t;
    var n = e.every((r) => bt.isNode(r));
    return gP.set(e, n), n;
  },
  last(e, t) {
    for (var n = t.slice(), r = bt.get(e, n); r && !(Ir.isText(r) || r.children.length === 0); ) {
      var o = r.children.length - 1;
      r = r.children[o], n.push(o);
    }
    return [r, n];
  },
  leaf(e, t) {
    var n = bt.get(e, t);
    if (!Ir.isText(n))
      throw new Error("Cannot get the leaf node at path [".concat(t, "] because it refers to a non-leaf node: ").concat(Wo.stringify(n)));
    return n;
  },
  levels(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of je.levels(t, n)) {
        var o = bt.get(e, r);
        yield [o, r];
      }
    }();
  },
  matches(e, t) {
    return gs.isElement(e) && gs.isElementProps(t) && gs.matches(e, t) || Ir.isText(e) && Ir.isTextProps(t) && Ir.matches(e, t);
  },
  nodes(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var {
        pass: n,
        reverse: r = !1
      } = t, {
        from: o = [],
        to: i
      } = t, a = /* @__PURE__ */ new Set(), s = [], l = e; !(i && (r ? je.isBefore(s, i) : je.isAfter(s, i))); ) {
        if (a.has(l) || (yield [l, s]), !a.has(l) && !Ir.isText(l) && l.children.length !== 0 && (n == null || n([l, s]) === !1)) {
          a.add(l);
          var u = r ? l.children.length - 1 : 0;
          je.isAncestor(s, o) && (u = o[s.length]), s = s.concat(u), l = bt.get(e, s);
          continue;
        }
        if (s.length === 0)
          break;
        if (!r) {
          var c = je.next(s);
          if (bt.has(e, c)) {
            s = c, l = bt.get(e, s);
            continue;
          }
        }
        if (r && s[s.length - 1] !== 0) {
          var p = je.previous(s);
          s = p, l = bt.get(e, s);
          continue;
        }
        s = je.parent(s), l = bt.get(e, s), a.add(l);
      }
    }();
  },
  parent(e, t) {
    var n = je.parent(t), r = bt.get(e, n);
    if (Ir.isText(r))
      throw new Error("Cannot get the parent of path [".concat(t, "] because it does not exist in the root."));
    return r;
  },
  string(e) {
    return Ir.isText(e) ? e.text : e.children.map(bt.string).join("");
  },
  texts(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of bt.nodes(e, t))
        Ir.isText(n) && (yield [n, r]);
    }();
  }
};
function mP(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function rr(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? mP(Object(n), !0).forEach(function(r) {
      gu(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : mP(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var hc = {
  isNodeOperation(e) {
    return hc.isOperation(e) && e.type.endsWith("_node");
  },
  isOperation(e) {
    if (!go(e))
      return !1;
    switch (e.type) {
      case "insert_node":
        return je.isPath(e.path) && bt.isNode(e.node);
      case "insert_text":
        return typeof e.offset == "number" && typeof e.text == "string" && je.isPath(e.path);
      case "merge_node":
        return typeof e.position == "number" && je.isPath(e.path) && go(e.properties);
      case "move_node":
        return je.isPath(e.path) && je.isPath(e.newPath);
      case "remove_node":
        return je.isPath(e.path) && bt.isNode(e.node);
      case "remove_text":
        return typeof e.offset == "number" && typeof e.text == "string" && je.isPath(e.path);
      case "set_node":
        return je.isPath(e.path) && go(e.properties) && go(e.newProperties);
      case "set_selection":
        return e.properties === null && It.isRange(e.newProperties) || e.newProperties === null && It.isRange(e.properties) || go(e.properties) && go(e.newProperties);
      case "split_node":
        return je.isPath(e.path) && typeof e.position == "number" && go(e.properties);
      default:
        return !1;
    }
  },
  isOperationList(e) {
    return Array.isArray(e) && e.every((t) => hc.isOperation(t));
  },
  isSelectionOperation(e) {
    return hc.isOperation(e) && e.type.endsWith("_selection");
  },
  isTextOperation(e) {
    return hc.isOperation(e) && e.type.endsWith("_text");
  },
  inverse(e) {
    switch (e.type) {
      case "insert_node":
        return rr(rr({}, e), {}, {
          type: "remove_node"
        });
      case "insert_text":
        return rr(rr({}, e), {}, {
          type: "remove_text"
        });
      case "merge_node":
        return rr(rr({}, e), {}, {
          type: "split_node",
          path: je.previous(e.path)
        });
      case "move_node": {
        var {
          newPath: t,
          path: n
        } = e;
        if (je.equals(t, n))
          return e;
        if (je.isSibling(n, t))
          return rr(rr({}, e), {}, {
            path: t,
            newPath: n
          });
        var r = je.transform(n, e), o = je.transform(je.next(n), e);
        return rr(rr({}, e), {}, {
          path: r,
          newPath: o
        });
      }
      case "remove_node":
        return rr(rr({}, e), {}, {
          type: "insert_node"
        });
      case "remove_text":
        return rr(rr({}, e), {}, {
          type: "insert_text"
        });
      case "set_node": {
        var {
          properties: i,
          newProperties: a
        } = e;
        return rr(rr({}, e), {}, {
          properties: a,
          newProperties: i
        });
      }
      case "set_selection": {
        var {
          properties: s,
          newProperties: l
        } = e;
        return s == null ? rr(rr({}, e), {}, {
          properties: l,
          newProperties: null
        }) : l == null ? rr(rr({}, e), {}, {
          properties: null,
          newProperties: s
        }) : rr(rr({}, e), {}, {
          properties: l,
          newProperties: s
        });
      }
      case "split_node":
        return rr(rr({}, e), {}, {
          type: "merge_node",
          path: je.next(e.path)
        });
    }
  }
}, vP = /* @__PURE__ */ new WeakMap(), NJ = (e) => {
  var t = vP.get(e);
  if (t !== void 0)
    return t;
  if (!go(e))
    return !1;
  var n = typeof e.addMark == "function" && typeof e.apply == "function" && typeof e.deleteFragment == "function" && typeof e.insertBreak == "function" && typeof e.insertSoftBreak == "function" && typeof e.insertFragment == "function" && typeof e.insertNode == "function" && typeof e.insertText == "function" && typeof e.isElementReadOnly == "function" && typeof e.isInline == "function" && typeof e.isSelectable == "function" && typeof e.isVoid == "function" && typeof e.normalizeNode == "function" && typeof e.onChange == "function" && typeof e.removeMark == "function" && typeof e.getDirtyPaths == "function" && (e.marks === null || go(e.marks)) && (e.selection === null || It.isRange(e.selection)) && bt.isNodeList(e.children) && hc.isOperationList(e.operations);
  return vP.set(e, n), n;
}, Bn = {
  above(e, t) {
    return e.above(t);
  },
  addMark(e, t, n) {
    e.addMark(t, n);
  },
  after(e, t, n) {
    return e.after(t, n);
  },
  before(e, t, n) {
    return e.before(t, n);
  },
  deleteBackward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteBackward(n);
  },
  deleteForward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteForward(n);
  },
  deleteFragment(e, t) {
    e.deleteFragment(t);
  },
  edges(e, t) {
    return e.edges(t);
  },
  elementReadOnly(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return e.elementReadOnly(t);
  },
  end(e, t) {
    return e.end(t);
  },
  first(e, t) {
    return e.first(t);
  },
  fragment(e, t) {
    return e.fragment(t);
  },
  hasBlocks(e, t) {
    return e.hasBlocks(t);
  },
  hasInlines(e, t) {
    return e.hasInlines(t);
  },
  hasPath(e, t) {
    return e.hasPath(t);
  },
  hasTexts(e, t) {
    return e.hasTexts(t);
  },
  insertBreak(e) {
    e.insertBreak();
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertNode(e, t) {
    e.insertNode(t);
  },
  insertSoftBreak(e) {
    e.insertSoftBreak();
  },
  insertText(e, t) {
    e.insertText(t);
  },
  isBlock(e, t) {
    return e.isBlock(t);
  },
  isEdge(e, t, n) {
    return e.isEdge(t, n);
  },
  isEditor(e) {
    return NJ(e);
  },
  isElementReadOnly(e, t) {
    return e.isElementReadOnly(t);
  },
  isEmpty(e, t) {
    return e.isEmpty(t);
  },
  isEnd(e, t, n) {
    return e.isEnd(t, n);
  },
  isInline(e, t) {
    return e.isInline(t);
  },
  isNormalizing(e) {
    return e.isNormalizing();
  },
  isSelectable(e, t) {
    return e.isSelectable(t);
  },
  isStart(e, t, n) {
    return e.isStart(t, n);
  },
  isVoid(e, t) {
    return e.isVoid(t);
  },
  last(e, t) {
    return e.last(t);
  },
  leaf(e, t, n) {
    return e.leaf(t, n);
  },
  levels(e, t) {
    return e.levels(t);
  },
  marks(e) {
    return e.getMarks();
  },
  next(e, t) {
    return e.next(t);
  },
  node(e, t, n) {
    return e.node(t, n);
  },
  nodes(e, t) {
    return e.nodes(t);
  },
  normalize(e, t) {
    e.normalize(t);
  },
  parent(e, t, n) {
    return e.parent(t, n);
  },
  path(e, t, n) {
    return e.path(t, n);
  },
  pathRef(e, t, n) {
    return e.pathRef(t, n);
  },
  pathRefs(e) {
    return e.pathRefs();
  },
  point(e, t, n) {
    return e.point(t, n);
  },
  pointRef(e, t, n) {
    return e.pointRef(t, n);
  },
  pointRefs(e) {
    return e.pointRefs();
  },
  positions(e, t) {
    return e.positions(t);
  },
  previous(e, t) {
    return e.previous(t);
  },
  range(e, t, n) {
    return e.range(t, n);
  },
  rangeRef(e, t, n) {
    return e.rangeRef(t, n);
  },
  rangeRefs(e) {
    return e.rangeRefs();
  },
  removeMark(e, t) {
    e.removeMark(t);
  },
  setNormalizing(e, t) {
    e.setNormalizing(t);
  },
  start(e, t) {
    return e.start(t);
  },
  string(e, t, n) {
    return e.string(t, n);
  },
  unhangRange(e, t, n) {
    return e.unhangRange(t, n);
  },
  void(e, t) {
    return e.void(t);
  },
  withoutNormalizing(e, t) {
    e.withoutNormalizing(t);
  },
  shouldMergeNodesRemovePrevNode: (e, t, n) => e.shouldMergeNodesRemovePrevNode(t, n)
};
function yP(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function bP(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? yP(Object(n), !0).forEach(function(r) {
      gu(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : yP(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Yn = {
  compare(e, t) {
    var n = je.compare(e.path, t.path);
    return n === 0 ? e.offset < t.offset ? -1 : e.offset > t.offset ? 1 : 0 : n;
  },
  isAfter(e, t) {
    return Yn.compare(e, t) === 1;
  },
  isBefore(e, t) {
    return Yn.compare(e, t) === -1;
  },
  equals(e, t) {
    return e.offset === t.offset && je.equals(e.path, t.path);
  },
  isPoint(e) {
    return go(e) && typeof e.offset == "number" && je.isPath(e.path);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return QO(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "forward"
      } = n, {
        path: i,
        offset: a
      } = r;
      switch (t.type) {
        case "insert_node":
        case "move_node": {
          r.path = je.transform(i, t, n);
          break;
        }
        case "insert_text": {
          je.equals(t.path, i) && (t.offset < a || t.offset === a && o === "forward") && (r.offset += t.text.length);
          break;
        }
        case "merge_node": {
          je.equals(t.path, i) && (r.offset += t.position), r.path = je.transform(i, t, n);
          break;
        }
        case "remove_text": {
          je.equals(t.path, i) && t.offset <= a && (r.offset -= Math.min(a - t.offset, t.text.length));
          break;
        }
        case "remove_node": {
          if (je.equals(t.path, i) || je.isAncestor(t.path, i))
            return null;
          r.path = je.transform(i, t, n);
          break;
        }
        case "split_node": {
          if (je.equals(t.path, i)) {
            if (t.position === a && o == null)
              return null;
            (t.position < a || t.position === a && o === "forward") && (r.offset -= t.position, r.path = je.transform(i, t, bP(bP({}, n), {}, {
              affinity: "forward"
            })));
          } else
            r.path = je.transform(i, t, n);
          break;
        }
      }
    });
  }
}, wP = void 0, Wo = {
  setScrubber(e) {
    wP = e;
  },
  stringify(e) {
    return JSON.stringify(e, wP);
  }
}, FJ = ["text"], zJ = ["anchor", "focus"];
function CP(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function os(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? CP(Object(n), !0).forEach(function(r) {
      gu(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : CP(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Ir = {
  equals(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      loose: r = !1
    } = n;
    function o(i) {
      var a = dp(i, FJ);
      return a;
    }
    return Z3(r ? o(e) : e, r ? o(t) : t);
  },
  isText(e) {
    return go(e) && typeof e.text == "string";
  },
  isTextList(e) {
    return Array.isArray(e) && e.every((t) => Ir.isText(t));
  },
  isTextProps(e) {
    return e.text !== void 0;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "text" && (!e.hasOwnProperty(n) || e[n] !== t[n]))
        return !1;
    return !0;
  },
  decorations(e, t) {
    var n = [os({}, e)];
    for (var r of t) {
      var o = dp(r, zJ), [i, a] = It.edges(r), s = [], l = 0, u = i.offset, c = a.offset;
      for (var p of n) {
        var {
          length: d
        } = p.text, h = l;
        if (l += d, u <= h && l <= c) {
          Object.assign(p, o), s.push(p);
          continue;
        }
        if (u !== c && (u === l || c === h) || u > l || c < h || c === h && h !== 0) {
          s.push(p);
          continue;
        }
        var f = p, m = void 0, g = void 0;
        if (c < l) {
          var E = c - h;
          g = os(os({}, f), {}, {
            text: f.text.slice(E)
          }), f = os(os({}, f), {}, {
            text: f.text.slice(0, E)
          });
        }
        if (u > h) {
          var w = u - h;
          m = os(os({}, f), {}, {
            text: f.text.slice(0, w)
          }), f = os(os({}, f), {}, {
            text: f.text.slice(w)
          });
        }
        Object.assign(f, o), m && s.push(m), s.push(f), g && s.push(g);
      }
      n = s;
    }
    return n;
  }
}, UJ = (e) => e.selection ? e.selection : e.children.length > 0 ? Bn.end(e, []) : [0], qn;
(function(e) {
  e[e.None = 0] = "None", e[e.Extend = 1] = "Extend", e[e.ZWJ = 2] = "ZWJ", e[e.RI = 4] = "RI", e[e.Prepend = 8] = "Prepend", e[e.SpacingMark = 16] = "SpacingMark", e[e.L = 32] = "L", e[e.V = 64] = "V", e[e.T = 128] = "T", e[e.LV = 256] = "LV", e[e.LVT = 512] = "LVT", e[e.ExtPict = 1024] = "ExtPict", e[e.Any = 2048] = "Any";
})(qn || (qn = {}));
qn.L, qn.L | qn.V | qn.LV | qn.LVT, qn.LV | qn.V, qn.V | qn.T, qn.LVT | qn.T, qn.T, qn.Any, qn.Extend | qn.ZWJ, qn.Any, qn.SpacingMark, qn.Prepend, qn.Any, qn.ZWJ, qn.ExtPict, qn.RI, qn.RI;
var $J = {
  delete(e, t) {
    e.delete(t);
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertText(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Bn.withoutNormalizing(e, () => {
      var {
        voids: r = !1
      } = n, {
        at: o = UJ(e)
      } = n;
      if (je.isPath(o) && (o = Bn.range(e, o)), It.isRange(o))
        if (It.isCollapsed(o))
          o = o.anchor;
        else {
          var i = It.end(o);
          if (!r && Bn.void(e, {
            at: i
          }))
            return;
          var a = It.start(o), s = Bn.pointRef(e, a), l = Bn.pointRef(e, i);
          ig.delete(e, {
            at: o,
            voids: r
          });
          var u = s.unref(), c = l.unref();
          o = u || c, ig.setSelection(e, {
            anchor: o,
            focus: o
          });
        }
      if (!(!r && Bn.void(e, {
        at: o
      }) || Bn.elementReadOnly(e, {
        at: o
      }))) {
        var {
          path: p,
          offset: d
        } = o;
        t.length > 0 && e.apply({
          type: "insert_text",
          path: p,
          offset: d,
          text: t
        });
      }
    });
  }
};
function xP(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Gd(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? xP(Object(n), !0).forEach(function(r) {
      gu(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : xP(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var ig = Gd(Gd(Gd(Gd({}, MJ), DJ), TJ), $J), G3 = {}, eE = {}, tE = {}, Ul = {}, nE = {}, rE = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Doctype = e.CDATA = e.Tag = e.Style = e.Script = e.Comment = e.Directive = e.Text = e.Root = e.isTag = e.ElementType = void 0;
  var t;
  (function(r) {
    r.Root = "root", r.Text = "text", r.Directive = "directive", r.Comment = "comment", r.Script = "script", r.Style = "style", r.Tag = "tag", r.CDATA = "cdata", r.Doctype = "doctype";
  })(t = e.ElementType || (e.ElementType = {}));
  function n(r) {
    return r.type === t.Tag || r.type === t.Script || r.type === t.Style;
  }
  e.isTag = n, e.Root = t.Root, e.Text = t.Text, e.Directive = t.Directive, e.Comment = t.Comment, e.Script = t.Script, e.Style = t.Style, e.Tag = t.Tag, e.CDATA = t.CDATA, e.Doctype = t.Doctype;
})(rE);
var Ht = {}, Ca = Un && Un.__extends || /* @__PURE__ */ function() {
  var e = function(t, n) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, o) {
      r.__proto__ = o;
    } || function(r, o) {
      for (var i in o) Object.prototype.hasOwnProperty.call(o, i) && (r[i] = o[i]);
    }, e(t, n);
  };
  return function(t, n) {
    if (typeof n != "function" && n !== null)
      throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
    e(t, n);
    function r() {
      this.constructor = t;
    }
    t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
  };
}(), _c = Un && Un.__assign || function() {
  return _c = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) {
      t = arguments[n];
      for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
    }
    return e;
  }, _c.apply(this, arguments);
};
Object.defineProperty(Ht, "__esModule", { value: !0 });
Ht.cloneNode = Ht.hasChildren = Ht.isDocument = Ht.isDirective = Ht.isComment = Ht.isText = Ht.isCDATA = Ht.isTag = Ht.Element = Ht.Document = Ht.CDATA = Ht.NodeWithChildren = Ht.ProcessingInstruction = Ht.Comment = Ht.Text = Ht.DataNode = Ht.Node = void 0;
var Fo = rE, oE = (
  /** @class */
  function() {
    function e() {
      this.parent = null, this.prev = null, this.next = null, this.startIndex = null, this.endIndex = null;
    }
    return Object.defineProperty(e.prototype, "parentNode", {
      // Read-write aliases for properties
      /**
       * Same as {@link parent}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.parent;
      },
      set: function(t) {
        this.parent = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "previousSibling", {
      /**
       * Same as {@link prev}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.prev;
      },
      set: function(t) {
        this.prev = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "nextSibling", {
      /**
       * Same as {@link next}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.next;
      },
      set: function(t) {
        this.next = t;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.cloneNode = function(t) {
      return t === void 0 && (t = !1), iE(this, t);
    }, e;
  }()
);
Ht.Node = oE;
var gv = (
  /** @class */
  function(e) {
    Ca(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.data = n, r;
    }
    return Object.defineProperty(t.prototype, "nodeValue", {
      /**
       * Same as {@link data}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.data;
      },
      set: function(n) {
        this.data = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(oE)
);
Ht.DataNode = gv;
var X3 = (
  /** @class */
  function(e) {
    Ca(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Fo.ElementType.Text, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 3;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(gv)
);
Ht.Text = X3;
var K3 = (
  /** @class */
  function(e) {
    Ca(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Fo.ElementType.Comment, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 8;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(gv)
);
Ht.Comment = K3;
var Y3 = (
  /** @class */
  function(e) {
    Ca(t, e);
    function t(n, r) {
      var o = e.call(this, r) || this;
      return o.name = n, o.type = Fo.ElementType.Directive, o;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(gv)
);
Ht.ProcessingInstruction = Y3;
var mv = (
  /** @class */
  function(e) {
    Ca(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.children = n, r;
    }
    return Object.defineProperty(t.prototype, "firstChild", {
      // Aliases
      /** First child of the node. */
      get: function() {
        var n;
        return (n = this.children[0]) !== null && n !== void 0 ? n : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "lastChild", {
      /** Last child of the node. */
      get: function() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "childNodes", {
      /**
       * Same as {@link children}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.children;
      },
      set: function(n) {
        this.children = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(oE)
);
Ht.NodeWithChildren = mv;
var J3 = (
  /** @class */
  function(e) {
    Ca(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Fo.ElementType.CDATA, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 4;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(mv)
);
Ht.CDATA = J3;
var Q3 = (
  /** @class */
  function(e) {
    Ca(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Fo.ElementType.Root, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 9;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(mv)
);
Ht.Document = Q3;
var eH = (
  /** @class */
  function(e) {
    Ca(t, e);
    function t(n, r, o, i) {
      o === void 0 && (o = []), i === void 0 && (i = n === "script" ? Fo.ElementType.Script : n === "style" ? Fo.ElementType.Style : Fo.ElementType.Tag);
      var a = e.call(this, o) || this;
      return a.name = n, a.attribs = r, a.type = i, a;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "tagName", {
      // DOM Level 1 aliases
      /**
       * Same as {@link name}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.name;
      },
      set: function(n) {
        this.name = n;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "attributes", {
      get: function() {
        var n = this;
        return Object.keys(this.attribs).map(function(r) {
          var o, i;
          return {
            name: r,
            value: n.attribs[r],
            namespace: (o = n["x-attribsNamespace"]) === null || o === void 0 ? void 0 : o[r],
            prefix: (i = n["x-attribsPrefix"]) === null || i === void 0 ? void 0 : i[r]
          };
        });
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(mv)
);
Ht.Element = eH;
function tH(e) {
  return (0, Fo.isTag)(e);
}
Ht.isTag = tH;
function nH(e) {
  return e.type === Fo.ElementType.CDATA;
}
Ht.isCDATA = nH;
function rH(e) {
  return e.type === Fo.ElementType.Text;
}
Ht.isText = rH;
function oH(e) {
  return e.type === Fo.ElementType.Comment;
}
Ht.isComment = oH;
function iH(e) {
  return e.type === Fo.ElementType.Directive;
}
Ht.isDirective = iH;
function sH(e) {
  return e.type === Fo.ElementType.Root;
}
Ht.isDocument = sH;
function HJ(e) {
  return Object.prototype.hasOwnProperty.call(e, "children");
}
Ht.hasChildren = HJ;
function iE(e, t) {
  t === void 0 && (t = !1);
  var n;
  if (rH(e))
    n = new X3(e.data);
  else if (oH(e))
    n = new K3(e.data);
  else if (tH(e)) {
    var r = t ? ab(e.children) : [], o = new eH(e.name, _c({}, e.attribs), r);
    r.forEach(function(l) {
      return l.parent = o;
    }), e.namespace != null && (o.namespace = e.namespace), e["x-attribsNamespace"] && (o["x-attribsNamespace"] = _c({}, e["x-attribsNamespace"])), e["x-attribsPrefix"] && (o["x-attribsPrefix"] = _c({}, e["x-attribsPrefix"])), n = o;
  } else if (nH(e)) {
    var r = t ? ab(e.children) : [], i = new J3(r);
    r.forEach(function(u) {
      return u.parent = i;
    }), n = i;
  } else if (sH(e)) {
    var r = t ? ab(e.children) : [], a = new Q3(r);
    r.forEach(function(u) {
      return u.parent = a;
    }), e["x-mode"] && (a["x-mode"] = e["x-mode"]), n = a;
  } else if (iH(e)) {
    var s = new Y3(e.name, e.data);
    e["x-name"] != null && (s["x-name"] = e["x-name"], s["x-publicId"] = e["x-publicId"], s["x-systemId"] = e["x-systemId"]), n = s;
  } else
    throw new Error("Not implemented yet: ".concat(e.type));
  return n.startIndex = e.startIndex, n.endIndex = e.endIndex, e.sourceCodeLocation != null && (n.sourceCodeLocation = e.sourceCodeLocation), n;
}
Ht.cloneNode = iE;
function ab(e) {
  for (var t = e.map(function(r) {
    return iE(r, !0);
  }), n = 1; n < t.length; n++)
    t[n].prev = t[n - 1], t[n - 1].next = t[n];
  return t;
}
(function(e) {
  var t = Un && Un.__createBinding || (Object.create ? function(s, l, u, c) {
    c === void 0 && (c = u);
    var p = Object.getOwnPropertyDescriptor(l, u);
    (!p || ("get" in p ? !l.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
      return l[u];
    } }), Object.defineProperty(s, c, p);
  } : function(s, l, u, c) {
    c === void 0 && (c = u), s[c] = l[u];
  }), n = Un && Un.__exportStar || function(s, l) {
    for (var u in s) u !== "default" && !Object.prototype.hasOwnProperty.call(l, u) && t(l, s, u);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.DomHandler = void 0;
  var r = rE, o = Ht;
  n(Ht, e);
  var i = {
    withStartIndices: !1,
    withEndIndices: !1,
    xmlMode: !1
  }, a = (
    /** @class */
    function() {
      function s(l, u, c) {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null, typeof u == "function" && (c = u, u = i), typeof l == "object" && (u = l, l = void 0), this.callback = l ?? null, this.options = u ?? i, this.elementCB = c ?? null;
      }
      return s.prototype.onparserinit = function(l) {
        this.parser = l;
      }, s.prototype.onreset = function() {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null;
      }, s.prototype.onend = function() {
        this.done || (this.done = !0, this.parser = null, this.handleCallback(null));
      }, s.prototype.onerror = function(l) {
        this.handleCallback(l);
      }, s.prototype.onclosetag = function() {
        this.lastNode = null;
        var l = this.tagStack.pop();
        this.options.withEndIndices && (l.endIndex = this.parser.endIndex), this.elementCB && this.elementCB(l);
      }, s.prototype.onopentag = function(l, u) {
        var c = this.options.xmlMode ? r.ElementType.Tag : void 0, p = new o.Element(l, u, void 0, c);
        this.addNode(p), this.tagStack.push(p);
      }, s.prototype.ontext = function(l) {
        var u = this.lastNode;
        if (u && u.type === r.ElementType.Text)
          u.data += l, this.options.withEndIndices && (u.endIndex = this.parser.endIndex);
        else {
          var c = new o.Text(l);
          this.addNode(c), this.lastNode = c;
        }
      }, s.prototype.oncomment = function(l) {
        if (this.lastNode && this.lastNode.type === r.ElementType.Comment) {
          this.lastNode.data += l;
          return;
        }
        var u = new o.Comment(l);
        this.addNode(u), this.lastNode = u;
      }, s.prototype.oncommentend = function() {
        this.lastNode = null;
      }, s.prototype.oncdatastart = function() {
        var l = new o.Text(""), u = new o.CDATA([l]);
        this.addNode(u), l.parent = u, this.lastNode = l;
      }, s.prototype.oncdataend = function() {
        this.lastNode = null;
      }, s.prototype.onprocessinginstruction = function(l, u) {
        var c = new o.ProcessingInstruction(l, u);
        this.addNode(c);
      }, s.prototype.handleCallback = function(l) {
        if (typeof this.callback == "function")
          this.callback(l, this.dom);
        else if (l)
          throw l;
      }, s.prototype.addNode = function(l) {
        var u = this.tagStack[this.tagStack.length - 1], c = u.children[u.children.length - 1];
        this.options.withStartIndices && (l.startIndex = this.parser.startIndex), this.options.withEndIndices && (l.endIndex = this.parser.endIndex), u.children.push(l), c && (l.prev = c, c.next = l), l.parent = u, this.lastNode = null;
      }, s;
    }()
  );
  e.DomHandler = a, e.default = a;
})(nE);
var aH = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CARRIAGE_RETURN_PLACEHOLDER_REGEX = e.CARRIAGE_RETURN_PLACEHOLDER = e.CARRIAGE_RETURN_REGEX = e.CARRIAGE_RETURN = e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES = void 0, e.CASE_SENSITIVE_TAG_NAMES = [
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "linearGradient",
    "radialGradient",
    "textPath"
  ], e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES.reduce(function(t, n) {
    return t[n.toLowerCase()] = n, t;
  }, {}), e.CARRIAGE_RETURN = "\r", e.CARRIAGE_RETURN_REGEX = new RegExp(e.CARRIAGE_RETURN, "g"), e.CARRIAGE_RETURN_PLACEHOLDER = "__HTML_DOM_PARSER_CARRIAGE_RETURN_PLACEHOLDER_".concat(Date.now(), "__"), e.CARRIAGE_RETURN_PLACEHOLDER_REGEX = new RegExp(e.CARRIAGE_RETURN_PLACEHOLDER, "g");
})(aH);
Object.defineProperty(Ul, "__esModule", { value: !0 });
Ul.formatAttributes = lH;
Ul.escapeSpecialCharacters = qJ;
Ul.revertEscapedCharacters = uH;
Ul.formatDOM = cH;
var Xd = nE, fp = aH;
function WJ(e) {
  return fp.CASE_SENSITIVE_TAG_NAMES_MAP[e];
}
function lH(e) {
  for (var t = {}, n = 0, r = e.length; n < r; n++) {
    var o = e[n];
    t[o.name] = o.value;
  }
  return t;
}
function VJ(e) {
  e = e.toLowerCase();
  var t = WJ(e);
  return t || e;
}
function qJ(e) {
  return e.replace(fp.CARRIAGE_RETURN_REGEX, fp.CARRIAGE_RETURN_PLACEHOLDER);
}
function uH(e) {
  return e.replace(fp.CARRIAGE_RETURN_PLACEHOLDER_REGEX, fp.CARRIAGE_RETURN);
}
function cH(e, t, n) {
  t === void 0 && (t = null);
  for (var r = [], o, i = 0, a = e.length; i < a; i++) {
    var s = e[i];
    switch (s.nodeType) {
      case 1: {
        var l = VJ(s.nodeName);
        o = new Xd.Element(l, lH(s.attributes)), o.children = cH(
          // template children are on content
          l === "template" ? s.content.childNodes : s.childNodes,
          o
        );
        break;
      }
      case 3:
        o = new Xd.Text(uH(s.nodeValue));
        break;
      case 8:
        o = new Xd.Comment(s.nodeValue);
        break;
      default:
        continue;
    }
    var u = r[i - 1] || null;
    u && (u.next = o), o.parent = t, o.prev = u, o.next = null, r.push(o);
  }
  return n && (o = new Xd.ProcessingInstruction(n.substring(0, n.indexOf(" ")).toLowerCase(), n), o.next = r[0] || null, o.parent = t, r.unshift(o), r[1] && (r[1].prev = r[0])), r;
}
Object.defineProperty(tE, "__esModule", { value: !0 });
tE.default = YJ;
var ZJ = Ul, OP = "html", EP = "head", Kd = "body", GJ = /<([a-zA-Z]+[0-9]?)/, kP = /<head[^]*>/i, LP = /<body[^]*>/i, sg = function(e, t) {
  throw new Error("This browser does not support `document.implementation.createHTMLDocument`");
}, EC = function(e, t) {
  throw new Error("This browser does not support `DOMParser.prototype.parseFromString`");
}, _P = typeof window == "object" && window.DOMParser;
if (typeof _P == "function") {
  var XJ = new _P(), KJ = "text/html";
  EC = function(e, t) {
    return t && (e = "<".concat(t, ">").concat(e, "</").concat(t, ">")), XJ.parseFromString(e, KJ);
  }, sg = EC;
}
if (typeof document == "object" && document.implementation) {
  var Yd = document.implementation.createHTMLDocument();
  sg = function(e, t) {
    if (t) {
      var n = Yd.documentElement.querySelector(t);
      return n && (n.innerHTML = e), Yd;
    }
    return Yd.documentElement.innerHTML = e, Yd;
  };
}
var Jd = typeof document == "object" && document.createElement("template"), kC;
Jd && Jd.content && (kC = function(e) {
  return Jd.innerHTML = e, Jd.content.childNodes;
});
function YJ(e) {
  var t, n;
  e = (0, ZJ.escapeSpecialCharacters)(e);
  var r = e.match(GJ), o = r && r[1] ? r[1].toLowerCase() : "";
  switch (o) {
    case OP: {
      var i = EC(e);
      if (!kP.test(e)) {
        var a = i.querySelector(EP);
        (t = a == null ? void 0 : a.parentNode) === null || t === void 0 || t.removeChild(a);
      }
      if (!LP.test(e)) {
        var a = i.querySelector(Kd);
        (n = a == null ? void 0 : a.parentNode) === null || n === void 0 || n.removeChild(a);
      }
      return i.querySelectorAll(OP);
    }
    case EP:
    case Kd: {
      var s = sg(e).querySelectorAll(o);
      return LP.test(e) && kP.test(e) ? s[0].parentNode.childNodes : s;
    }
    default: {
      if (kC)
        return kC(e);
      var a = sg(e, Kd).querySelector(Kd);
      return a.childNodes;
    }
  }
}
var JJ = Un && Un.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(eE, "__esModule", { value: !0 });
eE.default = nQ;
var QJ = JJ(tE), eQ = Ul, tQ = /<(![a-zA-Z\s]+)>/;
function nQ(e) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e)
    return [];
  var t = e.match(tQ), n = t ? t[1] : void 0;
  return (0, eQ.formatDOM)((0, QJ.default)(e), null, n);
}
var vv = {}, Ti = {}, yv = {}, rQ = 0;
yv.SAME = rQ;
var oQ = 1;
yv.CAMELCASE = oQ;
yv.possibleStandardNames = {
  accept: 0,
  acceptCharset: 1,
  "accept-charset": "acceptCharset",
  accessKey: 1,
  action: 0,
  allowFullScreen: 1,
  alt: 0,
  as: 0,
  async: 0,
  autoCapitalize: 1,
  autoComplete: 1,
  autoCorrect: 1,
  autoFocus: 1,
  autoPlay: 1,
  autoSave: 1,
  capture: 0,
  cellPadding: 1,
  cellSpacing: 1,
  challenge: 0,
  charSet: 1,
  checked: 0,
  children: 0,
  cite: 0,
  class: "className",
  classID: 1,
  className: 1,
  cols: 0,
  colSpan: 1,
  content: 0,
  contentEditable: 1,
  contextMenu: 1,
  controls: 0,
  controlsList: 1,
  coords: 0,
  crossOrigin: 1,
  dangerouslySetInnerHTML: 1,
  data: 0,
  dateTime: 1,
  default: 0,
  defaultChecked: 1,
  defaultValue: 1,
  defer: 0,
  dir: 0,
  disabled: 0,
  disablePictureInPicture: 1,
  disableRemotePlayback: 1,
  download: 0,
  draggable: 0,
  encType: 1,
  enterKeyHint: 1,
  for: "htmlFor",
  form: 0,
  formMethod: 1,
  formAction: 1,
  formEncType: 1,
  formNoValidate: 1,
  formTarget: 1,
  frameBorder: 1,
  headers: 0,
  height: 0,
  hidden: 0,
  high: 0,
  href: 0,
  hrefLang: 1,
  htmlFor: 1,
  httpEquiv: 1,
  "http-equiv": "httpEquiv",
  icon: 0,
  id: 0,
  innerHTML: 1,
  inputMode: 1,
  integrity: 0,
  is: 0,
  itemID: 1,
  itemProp: 1,
  itemRef: 1,
  itemScope: 1,
  itemType: 1,
  keyParams: 1,
  keyType: 1,
  kind: 0,
  label: 0,
  lang: 0,
  list: 0,
  loop: 0,
  low: 0,
  manifest: 0,
  marginWidth: 1,
  marginHeight: 1,
  max: 0,
  maxLength: 1,
  media: 0,
  mediaGroup: 1,
  method: 0,
  min: 0,
  minLength: 1,
  multiple: 0,
  muted: 0,
  name: 0,
  noModule: 1,
  nonce: 0,
  noValidate: 1,
  open: 0,
  optimum: 0,
  pattern: 0,
  placeholder: 0,
  playsInline: 1,
  poster: 0,
  preload: 0,
  profile: 0,
  radioGroup: 1,
  readOnly: 1,
  referrerPolicy: 1,
  rel: 0,
  required: 0,
  reversed: 0,
  role: 0,
  rows: 0,
  rowSpan: 1,
  sandbox: 0,
  scope: 0,
  scoped: 0,
  scrolling: 0,
  seamless: 0,
  selected: 0,
  shape: 0,
  size: 0,
  sizes: 0,
  span: 0,
  spellCheck: 1,
  src: 0,
  srcDoc: 1,
  srcLang: 1,
  srcSet: 1,
  start: 0,
  step: 0,
  style: 0,
  summary: 0,
  tabIndex: 1,
  target: 0,
  title: 0,
  type: 0,
  useMap: 1,
  value: 0,
  width: 0,
  wmode: 0,
  wrap: 0,
  about: 0,
  accentHeight: 1,
  "accent-height": "accentHeight",
  accumulate: 0,
  additive: 0,
  alignmentBaseline: 1,
  "alignment-baseline": "alignmentBaseline",
  allowReorder: 1,
  alphabetic: 0,
  amplitude: 0,
  arabicForm: 1,
  "arabic-form": "arabicForm",
  ascent: 0,
  attributeName: 1,
  attributeType: 1,
  autoReverse: 1,
  azimuth: 0,
  baseFrequency: 1,
  baselineShift: 1,
  "baseline-shift": "baselineShift",
  baseProfile: 1,
  bbox: 0,
  begin: 0,
  bias: 0,
  by: 0,
  calcMode: 1,
  capHeight: 1,
  "cap-height": "capHeight",
  clip: 0,
  clipPath: 1,
  "clip-path": "clipPath",
  clipPathUnits: 1,
  clipRule: 1,
  "clip-rule": "clipRule",
  color: 0,
  colorInterpolation: 1,
  "color-interpolation": "colorInterpolation",
  colorInterpolationFilters: 1,
  "color-interpolation-filters": "colorInterpolationFilters",
  colorProfile: 1,
  "color-profile": "colorProfile",
  colorRendering: 1,
  "color-rendering": "colorRendering",
  contentScriptType: 1,
  contentStyleType: 1,
  cursor: 0,
  cx: 0,
  cy: 0,
  d: 0,
  datatype: 0,
  decelerate: 0,
  descent: 0,
  diffuseConstant: 1,
  direction: 0,
  display: 0,
  divisor: 0,
  dominantBaseline: 1,
  "dominant-baseline": "dominantBaseline",
  dur: 0,
  dx: 0,
  dy: 0,
  edgeMode: 1,
  elevation: 0,
  enableBackground: 1,
  "enable-background": "enableBackground",
  end: 0,
  exponent: 0,
  externalResourcesRequired: 1,
  fill: 0,
  fillOpacity: 1,
  "fill-opacity": "fillOpacity",
  fillRule: 1,
  "fill-rule": "fillRule",
  filter: 0,
  filterRes: 1,
  filterUnits: 1,
  floodOpacity: 1,
  "flood-opacity": "floodOpacity",
  floodColor: 1,
  "flood-color": "floodColor",
  focusable: 0,
  fontFamily: 1,
  "font-family": "fontFamily",
  fontSize: 1,
  "font-size": "fontSize",
  fontSizeAdjust: 1,
  "font-size-adjust": "fontSizeAdjust",
  fontStretch: 1,
  "font-stretch": "fontStretch",
  fontStyle: 1,
  "font-style": "fontStyle",
  fontVariant: 1,
  "font-variant": "fontVariant",
  fontWeight: 1,
  "font-weight": "fontWeight",
  format: 0,
  from: 0,
  fx: 0,
  fy: 0,
  g1: 0,
  g2: 0,
  glyphName: 1,
  "glyph-name": "glyphName",
  glyphOrientationHorizontal: 1,
  "glyph-orientation-horizontal": "glyphOrientationHorizontal",
  glyphOrientationVertical: 1,
  "glyph-orientation-vertical": "glyphOrientationVertical",
  glyphRef: 1,
  gradientTransform: 1,
  gradientUnits: 1,
  hanging: 0,
  horizAdvX: 1,
  "horiz-adv-x": "horizAdvX",
  horizOriginX: 1,
  "horiz-origin-x": "horizOriginX",
  ideographic: 0,
  imageRendering: 1,
  "image-rendering": "imageRendering",
  in2: 0,
  in: 0,
  inlist: 0,
  intercept: 0,
  k1: 0,
  k2: 0,
  k3: 0,
  k4: 0,
  k: 0,
  kernelMatrix: 1,
  kernelUnitLength: 1,
  kerning: 0,
  keyPoints: 1,
  keySplines: 1,
  keyTimes: 1,
  lengthAdjust: 1,
  letterSpacing: 1,
  "letter-spacing": "letterSpacing",
  lightingColor: 1,
  "lighting-color": "lightingColor",
  limitingConeAngle: 1,
  local: 0,
  markerEnd: 1,
  "marker-end": "markerEnd",
  markerHeight: 1,
  markerMid: 1,
  "marker-mid": "markerMid",
  markerStart: 1,
  "marker-start": "markerStart",
  markerUnits: 1,
  markerWidth: 1,
  mask: 0,
  maskContentUnits: 1,
  maskUnits: 1,
  mathematical: 0,
  mode: 0,
  numOctaves: 1,
  offset: 0,
  opacity: 0,
  operator: 0,
  order: 0,
  orient: 0,
  orientation: 0,
  origin: 0,
  overflow: 0,
  overlinePosition: 1,
  "overline-position": "overlinePosition",
  overlineThickness: 1,
  "overline-thickness": "overlineThickness",
  paintOrder: 1,
  "paint-order": "paintOrder",
  panose1: 0,
  "panose-1": "panose1",
  pathLength: 1,
  patternContentUnits: 1,
  patternTransform: 1,
  patternUnits: 1,
  pointerEvents: 1,
  "pointer-events": "pointerEvents",
  points: 0,
  pointsAtX: 1,
  pointsAtY: 1,
  pointsAtZ: 1,
  prefix: 0,
  preserveAlpha: 1,
  preserveAspectRatio: 1,
  primitiveUnits: 1,
  property: 0,
  r: 0,
  radius: 0,
  refX: 1,
  refY: 1,
  renderingIntent: 1,
  "rendering-intent": "renderingIntent",
  repeatCount: 1,
  repeatDur: 1,
  requiredExtensions: 1,
  requiredFeatures: 1,
  resource: 0,
  restart: 0,
  result: 0,
  results: 0,
  rotate: 0,
  rx: 0,
  ry: 0,
  scale: 0,
  security: 0,
  seed: 0,
  shapeRendering: 1,
  "shape-rendering": "shapeRendering",
  slope: 0,
  spacing: 0,
  specularConstant: 1,
  specularExponent: 1,
  speed: 0,
  spreadMethod: 1,
  startOffset: 1,
  stdDeviation: 1,
  stemh: 0,
  stemv: 0,
  stitchTiles: 1,
  stopColor: 1,
  "stop-color": "stopColor",
  stopOpacity: 1,
  "stop-opacity": "stopOpacity",
  strikethroughPosition: 1,
  "strikethrough-position": "strikethroughPosition",
  strikethroughThickness: 1,
  "strikethrough-thickness": "strikethroughThickness",
  string: 0,
  stroke: 0,
  strokeDasharray: 1,
  "stroke-dasharray": "strokeDasharray",
  strokeDashoffset: 1,
  "stroke-dashoffset": "strokeDashoffset",
  strokeLinecap: 1,
  "stroke-linecap": "strokeLinecap",
  strokeLinejoin: 1,
  "stroke-linejoin": "strokeLinejoin",
  strokeMiterlimit: 1,
  "stroke-miterlimit": "strokeMiterlimit",
  strokeWidth: 1,
  "stroke-width": "strokeWidth",
  strokeOpacity: 1,
  "stroke-opacity": "strokeOpacity",
  suppressContentEditableWarning: 1,
  suppressHydrationWarning: 1,
  surfaceScale: 1,
  systemLanguage: 1,
  tableValues: 1,
  targetX: 1,
  targetY: 1,
  textAnchor: 1,
  "text-anchor": "textAnchor",
  textDecoration: 1,
  "text-decoration": "textDecoration",
  textLength: 1,
  textRendering: 1,
  "text-rendering": "textRendering",
  to: 0,
  transform: 0,
  typeof: 0,
  u1: 0,
  u2: 0,
  underlinePosition: 1,
  "underline-position": "underlinePosition",
  underlineThickness: 1,
  "underline-thickness": "underlineThickness",
  unicode: 0,
  unicodeBidi: 1,
  "unicode-bidi": "unicodeBidi",
  unicodeRange: 1,
  "unicode-range": "unicodeRange",
  unitsPerEm: 1,
  "units-per-em": "unitsPerEm",
  unselectable: 0,
  vAlphabetic: 1,
  "v-alphabetic": "vAlphabetic",
  values: 0,
  vectorEffect: 1,
  "vector-effect": "vectorEffect",
  version: 0,
  vertAdvY: 1,
  "vert-adv-y": "vertAdvY",
  vertOriginX: 1,
  "vert-origin-x": "vertOriginX",
  vertOriginY: 1,
  "vert-origin-y": "vertOriginY",
  vHanging: 1,
  "v-hanging": "vHanging",
  vIdeographic: 1,
  "v-ideographic": "vIdeographic",
  viewBox: 1,
  viewTarget: 1,
  visibility: 0,
  vMathematical: 1,
  "v-mathematical": "vMathematical",
  vocab: 0,
  widths: 0,
  wordSpacing: 1,
  "word-spacing": "wordSpacing",
  writingMode: 1,
  "writing-mode": "writingMode",
  x1: 0,
  x2: 0,
  x: 0,
  xChannelSelector: 1,
  xHeight: 1,
  "x-height": "xHeight",
  xlinkActuate: 1,
  "xlink:actuate": "xlinkActuate",
  xlinkArcrole: 1,
  "xlink:arcrole": "xlinkArcrole",
  xlinkHref: 1,
  "xlink:href": "xlinkHref",
  xlinkRole: 1,
  "xlink:role": "xlinkRole",
  xlinkShow: 1,
  "xlink:show": "xlinkShow",
  xlinkTitle: 1,
  "xlink:title": "xlinkTitle",
  xlinkType: 1,
  "xlink:type": "xlinkType",
  xmlBase: 1,
  "xml:base": "xmlBase",
  xmlLang: 1,
  "xml:lang": "xmlLang",
  xmlns: 0,
  "xml:space": "xmlSpace",
  xmlnsXlink: 1,
  "xmlns:xlink": "xmlnsXlink",
  xmlSpace: 1,
  y1: 0,
  y2: 0,
  y: 0,
  yChannelSelector: 1,
  z: 0,
  zoomAndPan: 1
};
const pH = 0, xa = 1, bv = 2, wv = 3, sE = 4, dH = 5, fH = 6;
function iQ(e) {
  return uo.hasOwnProperty(e) ? uo[e] : null;
}
function ko(e, t, n, r, o, i, a) {
  this.acceptsBooleans = t === bv || t === wv || t === sE, this.attributeName = r, this.attributeNamespace = o, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = i, this.removeEmptyString = a;
}
const uo = {}, sQ = [
  "children",
  "dangerouslySetInnerHTML",
  // TODO: This prevents the assignment of defaultValue to regular
  // elements (not just inputs). Now that ReactDOMInput assigns to the
  // defaultValue property -- do we need this?
  "defaultValue",
  "defaultChecked",
  "innerHTML",
  "suppressContentEditableWarning",
  "suppressHydrationWarning",
  "style"
];
sQ.forEach((e) => {
  uo[e] = new ko(
    e,
    pH,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"]
].forEach(([e, t]) => {
  uo[e] = new ko(
    e,
    xa,
    !1,
    // mustUseProperty
    t,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["contentEditable", "draggable", "spellCheck", "value"].forEach((e) => {
  uo[e] = new ko(
    e,
    bv,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha"
].forEach((e) => {
  uo[e] = new ko(
    e,
    bv,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "allowFullScreen",
  "async",
  // Note: there is a special case that prevents it from being written to the DOM
  // on the client side because the browsers are inconsistent. Instead we call focus().
  "autoFocus",
  "autoPlay",
  "controls",
  "default",
  "defer",
  "disabled",
  "disablePictureInPicture",
  "disableRemotePlayback",
  "formNoValidate",
  "hidden",
  "loop",
  "noModule",
  "noValidate",
  "open",
  "playsInline",
  "readOnly",
  "required",
  "reversed",
  "scoped",
  "seamless",
  // Microdata
  "itemScope"
].forEach((e) => {
  uo[e] = new ko(
    e,
    wv,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "checked",
  // Note: `option.selected` is not updated if `select.multiple` is
  // disabled with `removeAttribute`. We have special logic for handling this.
  "multiple",
  "muted",
  "selected"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  uo[e] = new ko(
    e,
    wv,
    !0,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "capture",
  "download"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  uo[e] = new ko(
    e,
    sE,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "cols",
  "rows",
  "size",
  "span"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  uo[e] = new ko(
    e,
    fH,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["rowSpan", "start"].forEach((e) => {
  uo[e] = new ko(
    e,
    dH,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const aE = /[\-\:]([a-z])/g, lE = (e) => e[1].toUpperCase();
[
  "accent-height",
  "alignment-baseline",
  "arabic-form",
  "baseline-shift",
  "cap-height",
  "clip-path",
  "clip-rule",
  "color-interpolation",
  "color-interpolation-filters",
  "color-profile",
  "color-rendering",
  "dominant-baseline",
  "enable-background",
  "fill-opacity",
  "fill-rule",
  "flood-color",
  "flood-opacity",
  "font-family",
  "font-size",
  "font-size-adjust",
  "font-stretch",
  "font-style",
  "font-variant",
  "font-weight",
  "glyph-name",
  "glyph-orientation-horizontal",
  "glyph-orientation-vertical",
  "horiz-adv-x",
  "horiz-origin-x",
  "image-rendering",
  "letter-spacing",
  "lighting-color",
  "marker-end",
  "marker-mid",
  "marker-start",
  "overline-position",
  "overline-thickness",
  "paint-order",
  "panose-1",
  "pointer-events",
  "rendering-intent",
  "shape-rendering",
  "stop-color",
  "stop-opacity",
  "strikethrough-position",
  "strikethrough-thickness",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "text-anchor",
  "text-decoration",
  "text-rendering",
  "underline-position",
  "underline-thickness",
  "unicode-bidi",
  "unicode-range",
  "units-per-em",
  "v-alphabetic",
  "v-hanging",
  "v-ideographic",
  "v-mathematical",
  "vector-effect",
  "vert-adv-y",
  "vert-origin-x",
  "vert-origin-y",
  "word-spacing",
  "writing-mode",
  "xmlns:xlink",
  "x-height"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(aE, lE);
  uo[t] = new ko(
    t,
    xa,
    !1,
    // mustUseProperty
    e,
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xlink:actuate",
  "xlink:arcrole",
  "xlink:role",
  "xlink:show",
  "xlink:title",
  "xlink:type"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(aE, lE);
  uo[t] = new ko(
    t,
    xa,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/1999/xlink",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xml:base",
  "xml:lang",
  "xml:space"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(aE, lE);
  uo[t] = new ko(
    t,
    xa,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/XML/1998/namespace",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["tabIndex", "crossOrigin"].forEach((e) => {
  uo[e] = new ko(
    e,
    xa,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const aQ = "xlinkHref";
uo[aQ] = new ko(
  "xlinkHref",
  xa,
  !1,
  // mustUseProperty
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  // sanitizeURL
  !1
  // removeEmptyString
);
["src", "href", "action", "formAction"].forEach((e) => {
  uo[e] = new ko(
    e,
    xa,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !0,
    // sanitizeURL
    !0
    // removeEmptyString
  );
});
const {
  CAMELCASE: lQ,
  SAME: uQ,
  possibleStandardNames: PP
} = yv, cQ = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", pQ = cQ + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", dQ = RegExp.prototype.test.bind(
  // eslint-disable-next-line no-misleading-character-class
  new RegExp("^(data|aria)-[" + pQ + "]*$")
), fQ = Object.keys(
  PP
).reduce((e, t) => {
  const n = PP[t];
  return n === uQ ? e[t] = t : n === lQ ? e[t.toLowerCase()] = t : e[t] = n, e;
}, {});
Ti.BOOLEAN = wv;
Ti.BOOLEANISH_STRING = bv;
Ti.NUMERIC = dH;
Ti.OVERLOADED_BOOLEAN = sE;
Ti.POSITIVE_NUMERIC = fH;
Ti.RESERVED = pH;
Ti.STRING = xa;
Ti.getPropertyInfo = iQ;
Ti.isCustomAttribute = dQ;
Ti.possibleStandardNames = fQ;
var uE = {}, cE = {}, SP = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, hQ = /\n/g, gQ = /^\s*/, mQ = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, vQ = /^:\s*/, yQ = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, bQ = /^[;\s]*/, wQ = /^\s+|\s+$/g, CQ = `
`, MP = "/", DP = "*", rl = "", xQ = "comment", OQ = "declaration", EQ = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e) return [];
  t = t || {};
  var n = 1, r = 1;
  function o(f) {
    var m = f.match(hQ);
    m && (n += m.length);
    var g = f.lastIndexOf(CQ);
    r = ~g ? f.length - g : r + f.length;
  }
  function i() {
    var f = { line: n, column: r };
    return function(m) {
      return m.position = new a(f), u(), m;
    };
  }
  function a(f) {
    this.start = f, this.end = { line: n, column: r }, this.source = t.source;
  }
  a.prototype.content = e;
  function s(f) {
    var m = new Error(
      t.source + ":" + n + ":" + r + ": " + f
    );
    if (m.reason = f, m.filename = t.source, m.line = n, m.column = r, m.source = e, !t.silent) throw m;
  }
  function l(f) {
    var m = f.exec(e);
    if (m) {
      var g = m[0];
      return o(g), e = e.slice(g.length), m;
    }
  }
  function u() {
    l(gQ);
  }
  function c(f) {
    var m;
    for (f = f || []; m = p(); )
      m !== !1 && f.push(m);
    return f;
  }
  function p() {
    var f = i();
    if (!(MP != e.charAt(0) || DP != e.charAt(1))) {
      for (var m = 2; rl != e.charAt(m) && (DP != e.charAt(m) || MP != e.charAt(m + 1)); )
        ++m;
      if (m += 2, rl === e.charAt(m - 1))
        return s("End of comment missing");
      var g = e.slice(2, m - 2);
      return r += 2, o(g), e = e.slice(m), r += 2, f({
        type: xQ,
        comment: g
      });
    }
  }
  function d() {
    var f = i(), m = l(mQ);
    if (m) {
      if (p(), !l(vQ)) return s("property missing ':'");
      var g = l(yQ), E = f({
        type: OQ,
        property: TP(m[0].replace(SP, rl)),
        value: g ? TP(g[0].replace(SP, rl)) : rl
      });
      return l(bQ), E;
    }
  }
  function h() {
    var f = [];
    c(f);
    for (var m; m = d(); )
      m !== !1 && (f.push(m), c(f));
    return f;
  }
  return u(), h();
};
function TP(e) {
  return e ? e.replace(wQ, rl) : rl;
}
var kQ = Un && Un.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(cE, "__esModule", { value: !0 });
cE.default = _Q;
var LQ = kQ(EQ);
function _Q(e, t) {
  var n = null;
  if (!e || typeof e != "string")
    return n;
  var r = (0, LQ.default)(e), o = typeof t == "function";
  return r.forEach(function(i) {
    if (i.type === "declaration") {
      var a = i.property, s = i.value;
      o ? t(a, s, i) : s && (n = n || {}, n[a] = s);
    }
  }), n;
}
var Cv = {};
Object.defineProperty(Cv, "__esModule", { value: !0 });
Cv.camelCase = void 0;
var PQ = /^--[a-zA-Z0-9_-]+$/, SQ = /-([a-z])/g, MQ = /^[^-]+$/, DQ = /^-(webkit|moz|ms|o|khtml)-/, TQ = /^-(ms)-/, jQ = function(e) {
  return !e || MQ.test(e) || PQ.test(e);
}, AQ = function(e, t) {
  return t.toUpperCase();
}, jP = function(e, t) {
  return "".concat(t, "-");
}, BQ = function(e, t) {
  return t === void 0 && (t = {}), jQ(e) ? e : (e = e.toLowerCase(), t.reactCompat ? e = e.replace(TQ, jP) : e = e.replace(DQ, jP), e.replace(SQ, AQ));
};
Cv.camelCase = BQ;
var IQ = Un && Un.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
}, RQ = IQ(cE), NQ = Cv;
function LC(e, t) {
  var n = {};
  return !e || typeof e != "string" || (0, RQ.default)(e, function(r, o) {
    r && o && (n[(0, NQ.camelCase)(r, t)] = o);
  }), n;
}
LC.default = LC;
var FQ = LC;
(function(e) {
  var t = Un && Un.__importDefault || function(c) {
    return c && c.__esModule ? c : { default: c };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.returnFirstArg = e.canTextBeChildOfNode = e.ELEMENTS_WITH_NO_TEXT_CHILDREN = e.PRESERVE_CUSTOM_ATTRIBUTES = void 0, e.isCustomComponent = i, e.setStyleProp = s;
  var n = ke, r = t(FQ), o = /* @__PURE__ */ new Set([
    "annotation-xml",
    "color-profile",
    "font-face",
    "font-face-src",
    "font-face-uri",
    "font-face-format",
    "font-face-name",
    "missing-glyph"
  ]);
  function i(c, p) {
    return c.includes("-") ? !o.has(c) : !!(p && typeof p.is == "string");
  }
  var a = {
    reactCompat: !0
  };
  function s(c, p) {
    if (typeof c == "string") {
      if (!c.trim()) {
        p.style = {};
        return;
      }
      try {
        p.style = (0, r.default)(c, a);
      } catch {
        p.style = {};
      }
    }
  }
  e.PRESERVE_CUSTOM_ATTRIBUTES = Number(n.version.split(".")[0]) >= 16, e.ELEMENTS_WITH_NO_TEXT_CHILDREN = /* @__PURE__ */ new Set([
    "tr",
    "tbody",
    "thead",
    "tfoot",
    "colgroup",
    "table",
    "head",
    "html",
    "frameset"
  ]);
  var l = function(c) {
    return !e.ELEMENTS_WITH_NO_TEXT_CHILDREN.has(c.name);
  };
  e.canTextBeChildOfNode = l;
  var u = function(c) {
    return c;
  };
  e.returnFirstArg = u;
})(uE);
Object.defineProperty(vv, "__esModule", { value: !0 });
vv.default = HQ;
var gc = Ti, AP = uE, zQ = ["checked", "value"], UQ = ["input", "select", "textarea"], $Q = {
  reset: !0,
  submit: !0
};
function HQ(e, t) {
  e === void 0 && (e = {});
  var n = {}, r = !!(e.type && $Q[e.type]);
  for (var o in e) {
    var i = e[o];
    if ((0, gc.isCustomAttribute)(o)) {
      n[o] = i;
      continue;
    }
    var a = o.toLowerCase(), s = BP(a);
    if (s) {
      var l = (0, gc.getPropertyInfo)(s);
      switch (zQ.includes(s) && UQ.includes(t) && !r && (s = BP("default" + a)), n[s] = i, l && l.type) {
        case gc.BOOLEAN:
          n[s] = !0;
          break;
        case gc.OVERLOADED_BOOLEAN:
          i === "" && (n[s] = !0);
          break;
      }
      continue;
    }
    AP.PRESERVE_CUSTOM_ATTRIBUTES && (n[o] = i);
  }
  return (0, AP.setStyleProp)(e.style, n), n;
}
function BP(e) {
  return gc.possibleStandardNames[e];
}
var pE = {}, WQ = Un && Un.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(pE, "__esModule", { value: !0 });
pE.default = hH;
var lb = ke, VQ = WQ(vv), Pc = uE, qQ = {
  cloneElement: lb.cloneElement,
  createElement: lb.createElement,
  isValidElement: lb.isValidElement
};
function hH(e, t) {
  t === void 0 && (t = {});
  for (var n = [], r = typeof t.replace == "function", o = t.transform || Pc.returnFirstArg, i = t.library || qQ, a = i.cloneElement, s = i.createElement, l = i.isValidElement, u = e.length, c = 0; c < u; c++) {
    var p = e[c];
    if (r) {
      var d = t.replace(p, c);
      if (l(d)) {
        u > 1 && (d = a(d, {
          key: d.key || c
        })), n.push(o(d, p, c));
        continue;
      }
    }
    if (p.type === "text") {
      var h = !p.data.trim().length;
      if (h && p.parent && !(0, Pc.canTextBeChildOfNode)(p.parent) || t.trim && h)
        continue;
      n.push(o(p.data, p, c));
      continue;
    }
    var f = p, m = {};
    ZQ(f) ? ((0, Pc.setStyleProp)(f.attribs.style, f.attribs), m = f.attribs) : f.attribs && (m = (0, VQ.default)(f.attribs, f.name));
    var g = void 0;
    switch (p.type) {
      case "script":
      case "style":
        p.children[0] && (m.dangerouslySetInnerHTML = {
          __html: p.children[0].data
        });
        break;
      case "tag":
        p.name === "textarea" && p.children[0] ? m.defaultValue = p.children[0].data : p.children && p.children.length && (g = hH(p.children, t));
        break;
      default:
        continue;
    }
    u > 1 && (m.key = c), n.push(o(s(p.name, m, g), p, c));
  }
  return n.length === 1 ? n[0] : n;
}
function ZQ(e) {
  return Pc.PRESERVE_CUSTOM_ATTRIBUTES && e.type === "tag" && (0, Pc.isCustomComponent)(e.name, e.attribs);
}
(function(e) {
  var t = Un && Un.__importDefault || function(l) {
    return l && l.__esModule ? l : { default: l };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.htmlToDOM = e.domToReact = e.attributesToProps = e.Text = e.ProcessingInstruction = e.Element = e.Comment = void 0, e.default = s;
  var n = t(eE);
  e.htmlToDOM = n.default;
  var r = t(vv);
  e.attributesToProps = r.default;
  var o = t(pE);
  e.domToReact = o.default;
  var i = nE;
  Object.defineProperty(e, "Comment", { enumerable: !0, get: function() {
    return i.Comment;
  } }), Object.defineProperty(e, "Element", { enumerable: !0, get: function() {
    return i.Element;
  } }), Object.defineProperty(e, "ProcessingInstruction", { enumerable: !0, get: function() {
    return i.ProcessingInstruction;
  } }), Object.defineProperty(e, "Text", { enumerable: !0, get: function() {
    return i.Text;
  } });
  var a = { lowerCaseAttributeNames: !1 };
  function s(l, u) {
    if (typeof l != "string")
      throw new TypeError("First argument must be a string");
    return l ? (0, o.default)((0, n.default)(l, (u == null ? void 0 : u.htmlparser2) || a), u) : [];
  }
})(G3);
const GQ = /* @__PURE__ */ fJ(G3);
GQ.default;
var $n = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function XQ(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var _C = { exports: {} }, Fu = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var IP;
function KQ() {
  if (IP) return Fu;
  IP = 1;
  var e = ke, t = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, o = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, i = { key: !0, ref: !0, __self: !0, __source: !0 };
  function a(s, l, u) {
    var c, p = {}, d = null, h = null;
    u !== void 0 && (d = "" + u), l.key !== void 0 && (d = "" + l.key), l.ref !== void 0 && (h = l.ref);
    for (c in l) r.call(l, c) && !i.hasOwnProperty(c) && (p[c] = l[c]);
    if (s && s.defaultProps) for (c in l = s.defaultProps, l) p[c] === void 0 && (p[c] = l[c]);
    return { $$typeof: t, type: s, key: d, ref: h, props: p, _owner: o.current };
  }
  return Fu.Fragment = n, Fu.jsx = a, Fu.jsxs = a, Fu;
}
var Qd = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var RP;
function YQ() {
  return RP || (RP = 1, process.env.NODE_ENV !== "production" && function() {
    var e = ke, t = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), a = Symbol.for("react.provider"), s = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), c = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), d = Symbol.for("react.lazy"), h = Symbol.for("react.offscreen"), f = Symbol.iterator, m = "@@iterator";
    function g(b) {
      if (b === null || typeof b != "object")
        return null;
      var B = f && b[f] || b[m];
      return typeof B == "function" ? B : null;
    }
    var E = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function w(b) {
      {
        for (var B = arguments.length, G = new Array(B > 1 ? B - 1 : 0), ne = 1; ne < B; ne++)
          G[ne - 1] = arguments[ne];
        M("error", b, G);
      }
    }
    function M(b, B, G) {
      {
        var ne = E.ReactDebugCurrentFrame, le = ne.getStackAddendum();
        le !== "" && (B += "%s", G = G.concat([le]));
        var ce = G.map(function(ae) {
          return String(ae);
        });
        ce.unshift("Warning: " + B), Function.prototype.apply.call(console[b], console, ce);
      }
    }
    var x = !1, y = !1, C = !1, P = !1, F = !1, L;
    L = Symbol.for("react.module.reference");
    function N(b) {
      return !!(typeof b == "string" || typeof b == "function" || b === r || b === i || F || b === o || b === u || b === c || P || b === h || x || y || C || typeof b == "object" && b !== null && (b.$$typeof === d || b.$$typeof === p || b.$$typeof === a || b.$$typeof === s || b.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      b.$$typeof === L || b.getModuleId !== void 0));
    }
    function I(b, B, G) {
      var ne = b.displayName;
      if (ne)
        return ne;
      var le = B.displayName || B.name || "";
      return le !== "" ? G + "(" + le + ")" : G;
    }
    function H(b) {
      return b.displayName || "Context";
    }
    function V(b) {
      if (b == null)
        return null;
      if (typeof b.tag == "number" && w("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof b == "function")
        return b.displayName || b.name || null;
      if (typeof b == "string")
        return b;
      switch (b) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case i:
          return "Profiler";
        case o:
          return "StrictMode";
        case u:
          return "Suspense";
        case c:
          return "SuspenseList";
      }
      if (typeof b == "object")
        switch (b.$$typeof) {
          case s:
            var B = b;
            return H(B) + ".Consumer";
          case a:
            var G = b;
            return H(G._context) + ".Provider";
          case l:
            return I(b, b.render, "ForwardRef");
          case p:
            var ne = b.displayName || null;
            return ne !== null ? ne : V(b.type) || "Memo";
          case d: {
            var le = b, ce = le._payload, ae = le._init;
            try {
              return V(ae(ce));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var z = Object.assign, q = 0, K, J, te, ee, _, D, $;
    function S() {
    }
    S.__reactDisabledLog = !0;
    function W() {
      {
        if (q === 0) {
          K = console.log, J = console.info, te = console.warn, ee = console.error, _ = console.group, D = console.groupCollapsed, $ = console.groupEnd;
          var b = {
            configurable: !0,
            enumerable: !0,
            value: S,
            writable: !0
          };
          Object.defineProperties(console, {
            info: b,
            log: b,
            warn: b,
            error: b,
            group: b,
            groupCollapsed: b,
            groupEnd: b
          });
        }
        q++;
      }
    }
    function O() {
      {
        if (q--, q === 0) {
          var b = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: z({}, b, {
              value: K
            }),
            info: z({}, b, {
              value: J
            }),
            warn: z({}, b, {
              value: te
            }),
            error: z({}, b, {
              value: ee
            }),
            group: z({}, b, {
              value: _
            }),
            groupCollapsed: z({}, b, {
              value: D
            }),
            groupEnd: z({}, b, {
              value: $
            })
          });
        }
        q < 0 && w("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var T = E.ReactCurrentDispatcher, U;
    function j(b, B, G) {
      {
        if (U === void 0)
          try {
            throw Error();
          } catch (le) {
            var ne = le.stack.trim().match(/\n( *(at )?)/);
            U = ne && ne[1] || "";
          }
        return `
` + U + b;
      }
    }
    var Z = !1, A;
    {
      var Q = typeof WeakMap == "function" ? WeakMap : Map;
      A = new Q();
    }
    function R(b, B) {
      if (!b || Z)
        return "";
      {
        var G = A.get(b);
        if (G !== void 0)
          return G;
      }
      var ne;
      Z = !0;
      var le = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var ce;
      ce = T.current, T.current = null, W();
      try {
        if (B) {
          var ae = function() {
            throw Error();
          };
          if (Object.defineProperty(ae.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(ae, []);
            } catch (Ne) {
              ne = Ne;
            }
            Reflect.construct(b, [], ae);
          } else {
            try {
              ae.call();
            } catch (Ne) {
              ne = Ne;
            }
            b.call(ae.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Ne) {
            ne = Ne;
          }
          b();
        }
      } catch (Ne) {
        if (Ne && ne && typeof Ne.stack == "string") {
          for (var ie = Ne.stack.split(`
`), Me = ne.stack.split(`
`), he = ie.length - 1, me = Me.length - 1; he >= 1 && me >= 0 && ie[he] !== Me[me]; )
            me--;
          for (; he >= 1 && me >= 0; he--, me--)
            if (ie[he] !== Me[me]) {
              if (he !== 1 || me !== 1)
                do
                  if (he--, me--, me < 0 || ie[he] !== Me[me]) {
                    var qe = `
` + ie[he].replace(" at new ", " at ");
                    return b.displayName && qe.includes("<anonymous>") && (qe = qe.replace("<anonymous>", b.displayName)), typeof b == "function" && A.set(b, qe), qe;
                  }
                while (he >= 1 && me >= 0);
              break;
            }
        }
      } finally {
        Z = !1, T.current = ce, O(), Error.prepareStackTrace = le;
      }
      var Lt = b ? b.displayName || b.name : "", gt = Lt ? j(Lt) : "";
      return typeof b == "function" && A.set(b, gt), gt;
    }
    function ue(b, B, G) {
      return R(b, !1);
    }
    function fe(b) {
      var B = b.prototype;
      return !!(B && B.isReactComponent);
    }
    function oe(b, B, G) {
      if (b == null)
        return "";
      if (typeof b == "function")
        return R(b, fe(b));
      if (typeof b == "string")
        return j(b);
      switch (b) {
        case u:
          return j("Suspense");
        case c:
          return j("SuspenseList");
      }
      if (typeof b == "object")
        switch (b.$$typeof) {
          case l:
            return ue(b.render);
          case p:
            return oe(b.type, B, G);
          case d: {
            var ne = b, le = ne._payload, ce = ne._init;
            try {
              return oe(ce(le), B, G);
            } catch {
            }
          }
        }
      return "";
    }
    var Re = Object.prototype.hasOwnProperty, He = {}, Ve = E.ReactDebugCurrentFrame;
    function ze(b) {
      if (b) {
        var B = b._owner, G = oe(b.type, b._source, B ? B.type : null);
        Ve.setExtraStackFrame(G);
      } else
        Ve.setExtraStackFrame(null);
    }
    function et(b, B, G, ne, le) {
      {
        var ce = Function.call.bind(Re);
        for (var ae in b)
          if (ce(b, ae)) {
            var ie = void 0;
            try {
              if (typeof b[ae] != "function") {
                var Me = Error((ne || "React class") + ": " + G + " type `" + ae + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof b[ae] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw Me.name = "Invariant Violation", Me;
              }
              ie = b[ae](B, ae, ne, G, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (he) {
              ie = he;
            }
            ie && !(ie instanceof Error) && (ze(le), w("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", ne || "React class", G, ae, typeof ie), ze(null)), ie instanceof Error && !(ie.message in He) && (He[ie.message] = !0, ze(le), w("Failed %s type: %s", G, ie.message), ze(null));
          }
      }
    }
    var Ge = Array.isArray;
    function Pe(b) {
      return Ge(b);
    }
    function Ye(b) {
      {
        var B = typeof Symbol == "function" && Symbol.toStringTag, G = B && b[Symbol.toStringTag] || b.constructor.name || "Object";
        return G;
      }
    }
    function it(b) {
      try {
        return _e(b), !1;
      } catch {
        return !0;
      }
    }
    function _e(b) {
      return "" + b;
    }
    function Se(b) {
      if (it(b))
        return w("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Ye(b)), _e(b);
    }
    var Ke = E.ReactCurrentOwner, We = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, Ue, nt;
    function Ie(b) {
      if (Re.call(b, "ref")) {
        var B = Object.getOwnPropertyDescriptor(b, "ref").get;
        if (B && B.isReactWarning)
          return !1;
      }
      return b.ref !== void 0;
    }
    function xt(b) {
      if (Re.call(b, "key")) {
        var B = Object.getOwnPropertyDescriptor(b, "key").get;
        if (B && B.isReactWarning)
          return !1;
      }
      return b.key !== void 0;
    }
    function ot(b, B) {
      typeof b.ref == "string" && Ke.current;
    }
    function st(b, B) {
      {
        var G = function() {
          Ue || (Ue = !0, w("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", B));
        };
        G.isReactWarning = !0, Object.defineProperty(b, "key", {
          get: G,
          configurable: !0
        });
      }
    }
    function lt(b, B) {
      {
        var G = function() {
          nt || (nt = !0, w("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", B));
        };
        G.isReactWarning = !0, Object.defineProperty(b, "ref", {
          get: G,
          configurable: !0
        });
      }
    }
    var Ot = function(b, B, G, ne, le, ce, ae) {
      var ie = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: b,
        key: B,
        ref: G,
        props: ae,
        // Record the component responsible for creating this element.
        _owner: ce
      };
      return ie._store = {}, Object.defineProperty(ie._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(ie, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ne
      }), Object.defineProperty(ie, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: le
      }), Object.freeze && (Object.freeze(ie.props), Object.freeze(ie)), ie;
    };
    function ut(b, B, G, ne, le) {
      {
        var ce, ae = {}, ie = null, Me = null;
        G !== void 0 && (Se(G), ie = "" + G), xt(B) && (Se(B.key), ie = "" + B.key), Ie(B) && (Me = B.ref, ot(B));
        for (ce in B)
          Re.call(B, ce) && !We.hasOwnProperty(ce) && (ae[ce] = B[ce]);
        if (b && b.defaultProps) {
          var he = b.defaultProps;
          for (ce in he)
            ae[ce] === void 0 && (ae[ce] = he[ce]);
        }
        if (ie || Me) {
          var me = typeof b == "function" ? b.displayName || b.name || "Unknown" : b;
          ie && st(ae, me), Me && lt(ae, me);
        }
        return Ot(b, ie, Me, le, ne, Ke.current, ae);
      }
    }
    var ct = E.ReactCurrentOwner, tt = E.ReactDebugCurrentFrame;
    function Xe(b) {
      if (b) {
        var B = b._owner, G = oe(b.type, b._source, B ? B.type : null);
        tt.setExtraStackFrame(G);
      } else
        tt.setExtraStackFrame(null);
    }
    var Et;
    Et = !1;
    function kt(b) {
      return typeof b == "object" && b !== null && b.$$typeof === t;
    }
    function pt() {
      {
        if (ct.current) {
          var b = V(ct.current.type);
          if (b)
            return `

Check the render method of \`` + b + "`.";
        }
        return "";
      }
    }
    function kn(b) {
      return "";
    }
    var dt = {};
    function Ln(b) {
      {
        var B = pt();
        if (!B) {
          var G = typeof b == "string" ? b : b.displayName || b.name;
          G && (B = `

Check the top-level render call using <` + G + ">.");
        }
        return B;
      }
    }
    function ft(b, B) {
      {
        if (!b._store || b._store.validated || b.key != null)
          return;
        b._store.validated = !0;
        var G = Ln(B);
        if (dt[G])
          return;
        dt[G] = !0;
        var ne = "";
        b && b._owner && b._owner !== ct.current && (ne = " It was passed a child from " + V(b._owner.type) + "."), Xe(b), w('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', G, ne), Xe(null);
      }
    }
    function rn(b, B) {
      {
        if (typeof b != "object")
          return;
        if (Pe(b))
          for (var G = 0; G < b.length; G++) {
            var ne = b[G];
            kt(ne) && ft(ne, B);
          }
        else if (kt(b))
          b._store && (b._store.validated = !0);
        else if (b) {
          var le = g(b);
          if (typeof le == "function" && le !== b.entries)
            for (var ce = le.call(b), ae; !(ae = ce.next()).done; )
              kt(ae.value) && ft(ae.value, B);
        }
      }
    }
    function br(b) {
      {
        var B = b.type;
        if (B == null || typeof B == "string")
          return;
        var G;
        if (typeof B == "function")
          G = B.propTypes;
        else if (typeof B == "object" && (B.$$typeof === l || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        B.$$typeof === p))
          G = B.propTypes;
        else
          return;
        if (G) {
          var ne = V(B);
          et(G, b.props, "prop", ne, b);
        } else if (B.PropTypes !== void 0 && !Et) {
          Et = !0;
          var le = V(B);
          w("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", le || "Unknown");
        }
        typeof B.getDefaultProps == "function" && !B.getDefaultProps.isReactClassApproved && w("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function ht(b) {
      {
        for (var B = Object.keys(b.props), G = 0; G < B.length; G++) {
          var ne = B[G];
          if (ne !== "children" && ne !== "key") {
            Xe(b), w("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", ne), Xe(null);
            break;
          }
        }
        b.ref !== null && (Xe(b), w("Invalid attribute `ref` supplied to `React.Fragment`."), Xe(null));
      }
    }
    var re = {};
    function eo(b, B, G, ne, le, ce) {
      {
        var ae = N(b);
        if (!ae) {
          var ie = "";
          (b === void 0 || typeof b == "object" && b !== null && Object.keys(b).length === 0) && (ie += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var Me = kn();
          Me ? ie += Me : ie += pt();
          var he;
          b === null ? he = "null" : Pe(b) ? he = "array" : b !== void 0 && b.$$typeof === t ? (he = "<" + (V(b.type) || "Unknown") + " />", ie = " Did you accidentally export a JSX literal instead of a component?") : he = typeof b, w("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", he, ie);
        }
        var me = ut(b, B, G, le, ce);
        if (me == null)
          return me;
        if (ae) {
          var qe = B.children;
          if (qe !== void 0)
            if (ne)
              if (Pe(qe)) {
                for (var Lt = 0; Lt < qe.length; Lt++)
                  rn(qe[Lt], b);
                Object.freeze && Object.freeze(qe);
              } else
                w("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              rn(qe, b);
        }
        if (Re.call(B, "key")) {
          var gt = V(b), Ne = Object.keys(B).filter(function(_i) {
            return _i !== "key";
          }), wr = Ne.length > 0 ? "{key: someKey, " + Ne.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!re[gt + wr]) {
            var Li = Ne.length > 0 ? "{" + Ne.join(": ..., ") + ": ...}" : "{}";
            w(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, wr, gt, Li, gt), re[gt + wr] = !0;
          }
        }
        return b === r ? ht(me) : br(me), me;
      }
    }
    function xi(b, B, G) {
      return eo(b, B, G, !0);
    }
    function Oi(b, B, G) {
      return eo(b, B, G, !1);
    }
    var Ei = Oi, ki = xi;
    Qd.Fragment = r, Qd.jsx = Ei, Qd.jsxs = ki;
  }()), Qd;
}
process.env.NODE_ENV === "production" ? _C.exports = KQ() : _C.exports = YQ();
var oo = _C.exports;
Ze({});
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function NP(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function mo(e) {
  var t, n;
  return NP(e) === !1 ? !1 : (t = e.constructor, t === void 0 ? !0 : (n = t.prototype, !(NP(n) === !1 || n.hasOwnProperty("isPrototypeOf") === !1)));
}
var gH = Symbol.for("immer-nothing"), FP = Symbol.for("immer-draftable"), ai = Symbol.for("immer-state"), JQ = process.env.NODE_ENV !== "production" ? [
  // All error codes, starting by 0:
  function(e) {
    return `The plugin for '${e}' has not been loaded into Immer. To enable the plugin, import and call \`enable${e}()\` when initializing your application.`;
  },
  function(e) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${e}'`;
  },
  "This object has been frozen and should not be mutated",
  function(e) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + e;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(e) {
    return `'current' expects a draft, got: ${e}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(e) {
    return `'original' expects a draft, got: ${e}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function Ao(e, ...t) {
  if (process.env.NODE_ENV !== "production") {
    const n = JQ[e], r = typeof n == "function" ? n.apply(null, t) : n;
    throw new Error(`[Immer] ${r}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var au = Object.getPrototypeOf;
function Ml(e) {
  return !!e && !!e[ai];
}
function Dl(e) {
  var t;
  return e ? mH(e) || Array.isArray(e) || !!e[FP] || !!((t = e.constructor) != null && t[FP]) || Ov(e) || Ev(e) : !1;
}
var QQ = Object.prototype.constructor.toString();
function mH(e) {
  if (!e || typeof e != "object")
    return !1;
  const t = au(e);
  if (t === null)
    return !0;
  const n = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
  return n === Object ? !0 : typeof n == "function" && Function.toString.call(n) === QQ;
}
function ag(e, t) {
  xv(e) === 0 ? Reflect.ownKeys(e).forEach((n) => {
    t(n, e[n], e);
  }) : e.forEach((n, r) => t(r, n, e));
}
function xv(e) {
  const t = e[ai];
  return t ? t.type_ : Array.isArray(e) ? 1 : Ov(e) ? 2 : Ev(e) ? 3 : 0;
}
function PC(e, t) {
  return xv(e) === 2 ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t);
}
function vH(e, t, n) {
  const r = xv(e);
  r === 2 ? e.set(t, n) : r === 3 ? e.add(n) : e[t] = n;
}
function eee(e, t) {
  return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && t !== t;
}
function Ov(e) {
  return e instanceof Map;
}
function Ev(e) {
  return e instanceof Set;
}
function Ya(e) {
  return e.copy_ || e.base_;
}
function SC(e, t) {
  if (Ov(e))
    return new Map(e);
  if (Ev(e))
    return new Set(e);
  if (Array.isArray(e))
    return Array.prototype.slice.call(e);
  const n = mH(e);
  if (t === !0 || t === "class_only" && !n) {
    const r = Object.getOwnPropertyDescriptors(e);
    delete r[ai];
    let o = Reflect.ownKeys(r);
    for (let i = 0; i < o.length; i++) {
      const a = o[i], s = r[a];
      s.writable === !1 && (s.writable = !0, s.configurable = !0), (s.get || s.set) && (r[a] = {
        configurable: !0,
        writable: !0,
        // could live with !!desc.set as well here...
        enumerable: s.enumerable,
        value: e[a]
      });
    }
    return Object.create(au(e), r);
  } else {
    const r = au(e);
    if (r !== null && n)
      return { ...e };
    const o = Object.create(r);
    return Object.assign(o, e);
  }
}
function dE(e, t = !1) {
  return kv(e) || Ml(e) || !Dl(e) || (xv(e) > 1 && (e.set = e.add = e.clear = e.delete = tee), Object.freeze(e), t && Object.entries(e).forEach(([n, r]) => dE(r, !0))), e;
}
function tee() {
  Ao(2);
}
function kv(e) {
  return Object.isFrozen(e);
}
var nee = {};
function Tl(e) {
  const t = nee[e];
  return t || Ao(0, e), t;
}
var hp;
function yH() {
  return hp;
}
function ree(e, t) {
  return {
    drafts_: [],
    parent_: e,
    immer_: t,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0
  };
}
function zP(e, t) {
  t && (Tl("Patches"), e.patches_ = [], e.inversePatches_ = [], e.patchListener_ = t);
}
function MC(e) {
  DC(e), e.drafts_.forEach(oee), e.drafts_ = null;
}
function DC(e) {
  e === hp && (hp = e.parent_);
}
function UP(e) {
  return hp = ree(hp, e);
}
function oee(e) {
  const t = e[ai];
  t.type_ === 0 || t.type_ === 1 ? t.revoke_() : t.revoked_ = !0;
}
function $P(e, t) {
  t.unfinalizedDrafts_ = t.drafts_.length;
  const n = t.drafts_[0];
  return e !== void 0 && e !== n ? (n[ai].modified_ && (MC(t), Ao(4)), Dl(e) && (e = lg(t, e), t.parent_ || ug(t, e)), t.patches_ && Tl("Patches").generateReplacementPatches_(
    n[ai].base_,
    e,
    t.patches_,
    t.inversePatches_
  )) : e = lg(t, n, []), MC(t), t.patches_ && t.patchListener_(t.patches_, t.inversePatches_), e !== gH ? e : void 0;
}
function lg(e, t, n) {
  if (kv(t))
    return t;
  const r = t[ai];
  if (!r)
    return ag(
      t,
      (o, i) => HP(e, r, t, o, i, n)
    ), t;
  if (r.scope_ !== e)
    return t;
  if (!r.modified_)
    return ug(e, r.base_, !0), r.base_;
  if (!r.finalized_) {
    r.finalized_ = !0, r.scope_.unfinalizedDrafts_--;
    const o = r.copy_;
    let i = o, a = !1;
    r.type_ === 3 && (i = new Set(o), o.clear(), a = !0), ag(
      i,
      (s, l) => HP(e, r, o, s, l, n, a)
    ), ug(e, o, !1), n && e.patches_ && Tl("Patches").generatePatches_(
      r,
      n,
      e.patches_,
      e.inversePatches_
    );
  }
  return r.copy_;
}
function HP(e, t, n, r, o, i, a) {
  if (process.env.NODE_ENV !== "production" && o === n && Ao(5), Ml(o)) {
    const s = i && t && t.type_ !== 3 && // Set objects are atomic since they have no keys.
    !PC(t.assigned_, r) ? i.concat(r) : void 0, l = lg(e, o, s);
    if (vH(n, r, l), Ml(l))
      e.canAutoFreeze_ = !1;
    else
      return;
  } else a && n.add(o);
  if (Dl(o) && !kv(o)) {
    if (!e.immer_.autoFreeze_ && e.unfinalizedDrafts_ < 1)
      return;
    lg(e, o), (!t || !t.scope_.parent_) && typeof r != "symbol" && Object.prototype.propertyIsEnumerable.call(n, r) && ug(e, o);
  }
}
function ug(e, t, n = !1) {
  !e.parent_ && e.immer_.autoFreeze_ && e.canAutoFreeze_ && dE(t, n);
}
function iee(e, t) {
  const n = Array.isArray(e), r = {
    type_: n ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: t ? t.scope_ : yH(),
    // True for both shallow and deep changes.
    modified_: !1,
    // Used during finalization.
    finalized_: !1,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: t,
    // The base state.
    base_: e,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: !1
  };
  let o = r, i = fE;
  n && (o = [r], i = gp);
  const { revoke: a, proxy: s } = Proxy.revocable(o, i);
  return r.draft_ = s, r.revoke_ = a, s;
}
var fE = {
  get(e, t) {
    if (t === ai)
      return e;
    const n = Ya(e);
    if (!PC(n, t))
      return see(e, n, t);
    const r = n[t];
    return e.finalized_ || !Dl(r) ? r : r === ub(e.base_, t) ? (cb(e), e.copy_[t] = jC(r, e)) : r;
  },
  has(e, t) {
    return t in Ya(e);
  },
  ownKeys(e) {
    return Reflect.ownKeys(Ya(e));
  },
  set(e, t, n) {
    const r = bH(Ya(e), t);
    if (r != null && r.set)
      return r.set.call(e.draft_, n), !0;
    if (!e.modified_) {
      const o = ub(Ya(e), t), i = o == null ? void 0 : o[ai];
      if (i && i.base_ === n)
        return e.copy_[t] = n, e.assigned_[t] = !1, !0;
      if (eee(n, o) && (n !== void 0 || PC(e.base_, t)))
        return !0;
      cb(e), TC(e);
    }
    return e.copy_[t] === n && // special case: handle new props with value 'undefined'
    (n !== void 0 || t in e.copy_) || // special case: NaN
    Number.isNaN(n) && Number.isNaN(e.copy_[t]) || (e.copy_[t] = n, e.assigned_[t] = !0), !0;
  },
  deleteProperty(e, t) {
    return ub(e.base_, t) !== void 0 || t in e.base_ ? (e.assigned_[t] = !1, cb(e), TC(e)) : delete e.assigned_[t], e.copy_ && delete e.copy_[t], !0;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(e, t) {
    const n = Ya(e), r = Reflect.getOwnPropertyDescriptor(n, t);
    return r && {
      writable: !0,
      configurable: e.type_ !== 1 || t !== "length",
      enumerable: r.enumerable,
      value: n[t]
    };
  },
  defineProperty() {
    Ao(11);
  },
  getPrototypeOf(e) {
    return au(e.base_);
  },
  setPrototypeOf() {
    Ao(12);
  }
}, gp = {};
ag(fE, (e, t) => {
  gp[e] = function() {
    return arguments[0] = arguments[0][0], t.apply(this, arguments);
  };
});
gp.deleteProperty = function(e, t) {
  return process.env.NODE_ENV !== "production" && isNaN(parseInt(t)) && Ao(13), gp.set.call(this, e, t, void 0);
};
gp.set = function(e, t, n) {
  return process.env.NODE_ENV !== "production" && t !== "length" && isNaN(parseInt(t)) && Ao(14), fE.set.call(this, e[0], t, n, e[0]);
};
function ub(e, t) {
  const n = e[ai];
  return (n ? Ya(n) : e)[t];
}
function see(e, t, n) {
  var r;
  const o = bH(t, n);
  return o ? "value" in o ? o.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (r = o.get) == null ? void 0 : r.call(e.draft_)
  ) : void 0;
}
function bH(e, t) {
  if (!(t in e))
    return;
  let n = au(e);
  for (; n; ) {
    const r = Object.getOwnPropertyDescriptor(n, t);
    if (r)
      return r;
    n = au(n);
  }
}
function TC(e) {
  e.modified_ || (e.modified_ = !0, e.parent_ && TC(e.parent_));
}
function cb(e) {
  e.copy_ || (e.copy_ = SC(
    e.base_,
    e.scope_.immer_.useStrictShallowCopy_
  ));
}
var aee = class {
  constructor(e) {
    this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.produce = (t, n, r) => {
      if (typeof t == "function" && typeof n != "function") {
        const i = n;
        n = t;
        const a = this;
        return function(s = i, ...l) {
          return a.produce(s, (u) => n.call(this, u, ...l));
        };
      }
      typeof n != "function" && Ao(6), r !== void 0 && typeof r != "function" && Ao(7);
      let o;
      if (Dl(t)) {
        const i = UP(this), a = jC(t, void 0);
        let s = !0;
        try {
          o = n(a), s = !1;
        } finally {
          s ? MC(i) : DC(i);
        }
        return zP(i, r), $P(o, i);
      } else if (!t || typeof t != "object") {
        if (o = n(t), o === void 0 && (o = t), o === gH && (o = void 0), this.autoFreeze_ && dE(o, !0), r) {
          const i = [], a = [];
          Tl("Patches").generateReplacementPatches_(t, o, i, a), r(i, a);
        }
        return o;
      } else
        Ao(1, t);
    }, this.produceWithPatches = (t, n) => {
      if (typeof t == "function")
        return (i, ...a) => this.produceWithPatches(i, (s) => t(s, ...a));
      let r, o;
      return [this.produce(t, n, (i, a) => {
        r = i, o = a;
      }), r, o];
    }, typeof (e == null ? void 0 : e.autoFreeze) == "boolean" && this.setAutoFreeze(e.autoFreeze), typeof (e == null ? void 0 : e.useStrictShallowCopy) == "boolean" && this.setUseStrictShallowCopy(e.useStrictShallowCopy);
  }
  createDraft(e) {
    Dl(e) || Ao(8), Ml(e) && (e = lee(e));
    const t = UP(this), n = jC(e, void 0);
    return n[ai].isManual_ = !0, DC(t), n;
  }
  finishDraft(e, t) {
    const n = e && e[ai];
    (!n || !n.isManual_) && Ao(9);
    const { scope_: r } = n;
    return zP(r, t), $P(void 0, r);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(e) {
    this.autoFreeze_ = e;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(e) {
    this.useStrictShallowCopy_ = e;
  }
  applyPatches(e, t) {
    let n;
    for (n = t.length - 1; n >= 0; n--) {
      const o = t[n];
      if (o.path.length === 0 && o.op === "replace") {
        e = o.value;
        break;
      }
    }
    n > -1 && (t = t.slice(n + 1));
    const r = Tl("Patches").applyPatches_;
    return Ml(e) ? r(e, t) : this.produce(
      e,
      (o) => r(o, t)
    );
  }
};
function jC(e, t) {
  const n = Ov(e) ? Tl("MapSet").proxyMap_(e, t) : Ev(e) ? Tl("MapSet").proxySet_(e, t) : iee(e, t);
  return (t ? t.scope_ : yH()).drafts_.push(n), n;
}
function lee(e) {
  return Ml(e) || Ao(10, e), wH(e);
}
function wH(e) {
  if (!Dl(e) || kv(e))
    return e;
  const t = e[ai];
  let n;
  if (t) {
    if (!t.modified_)
      return t.base_;
    t.finalized_ = !0, n = SC(e, t.scope_.immer_.useStrictShallowCopy_);
  } else
    n = SC(e, !0);
  return ag(n, (r, o) => {
    vH(n, r, wH(o));
  }), t && (t.finalized_ = !1), n;
}
var li = new aee(), hE = li.produce;
li.produceWithPatches.bind(
  li
);
li.setAutoFreeze.bind(li);
li.setUseStrictShallowCopy.bind(li);
li.applyPatches.bind(li);
var WP = li.createDraft.bind(li), VP = li.finishDraft.bind(li), Ae = {
  ancestors(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = Ae.levels(e, t);
    return n ? r = r.slice(1) : r = r.slice(0, -1), r;
  },
  common(e, t) {
    for (var n = [], r = 0; r < e.length && r < t.length; r++) {
      var o = e[r], i = t[r];
      if (o !== i)
        break;
      n.push(o);
    }
    return n;
  },
  compare(e, t) {
    for (var n = Math.min(e.length, t.length), r = 0; r < n; r++) {
      if (e[r] < t[r]) return -1;
      if (e[r] > t[r]) return 1;
    }
    return 0;
  },
  endsAfter(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return Ae.equals(r, o) && i > a;
  },
  endsAt(e, t) {
    var n = e.length, r = e.slice(0, n), o = t.slice(0, n);
    return Ae.equals(r, o);
  },
  endsBefore(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return Ae.equals(r, o) && i < a;
  },
  equals(e, t) {
    return e.length === t.length && e.every((n, r) => n === t[r]);
  },
  hasPrevious(e) {
    return e[e.length - 1] > 0;
  },
  isAfter(e, t) {
    return Ae.compare(e, t) === 1;
  },
  isAncestor(e, t) {
    return e.length < t.length && Ae.compare(e, t) === 0;
  },
  isBefore(e, t) {
    return Ae.compare(e, t) === -1;
  },
  isChild(e, t) {
    return e.length === t.length + 1 && Ae.compare(e, t) === 0;
  },
  isCommon(e, t) {
    return e.length <= t.length && Ae.compare(e, t) === 0;
  },
  isDescendant(e, t) {
    return e.length > t.length && Ae.compare(e, t) === 0;
  },
  isParent(e, t) {
    return e.length + 1 === t.length && Ae.compare(e, t) === 0;
  },
  isPath(e) {
    return Array.isArray(e) && (e.length === 0 || typeof e[0] == "number");
  },
  isSibling(e, t) {
    if (e.length !== t.length)
      return !1;
    var n = e.slice(0, -1), r = t.slice(0, -1), o = e[e.length - 1], i = t[t.length - 1];
    return o !== i && Ae.equals(n, r);
  },
  levels(e) {
    for (var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = [], o = 0; o <= e.length; o++)
      r.push(e.slice(0, o));
    return n && r.reverse(), r;
  },
  next(e) {
    if (e.length === 0)
      throw new Error("Cannot get the next path of a root path [".concat(e, "], because it has no next index."));
    var t = e[e.length - 1];
    return e.slice(0, -1).concat(t + 1);
  },
  operationCanTransformPath(e) {
    switch (e.type) {
      case "insert_node":
      case "remove_node":
      case "merge_node":
      case "split_node":
      case "move_node":
        return !0;
      default:
        return !1;
    }
  },
  parent(e) {
    if (e.length === 0)
      throw new Error("Cannot get the parent path of the root path [".concat(e, "]."));
    return e.slice(0, -1);
  },
  previous(e) {
    if (e.length === 0)
      throw new Error("Cannot get the previous path of a root path [".concat(e, "], because it has no previous index."));
    var t = e[e.length - 1];
    if (t <= 0)
      throw new Error("Cannot get the previous path of a first child path [".concat(e, "] because it would result in a negative index."));
    return e.slice(0, -1).concat(t - 1);
  },
  relative(e, t) {
    if (!Ae.isAncestor(t, e) && !Ae.equals(e, t))
      throw new Error("Cannot get the relative path of [".concat(e, "] inside ancestor [").concat(t, "], because it is not above or equal to the path."));
    return e.slice(t.length);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!e) return null;
    var r = [...e], {
      affinity: o = "forward"
    } = n;
    if (e.length === 0)
      return r;
    switch (t.type) {
      case "insert_node": {
        var {
          path: i
        } = t;
        (Ae.equals(i, r) || Ae.endsBefore(i, r) || Ae.isAncestor(i, r)) && (r[i.length - 1] += 1);
        break;
      }
      case "remove_node": {
        var {
          path: a
        } = t;
        if (Ae.equals(a, r) || Ae.isAncestor(a, r))
          return null;
        Ae.endsBefore(a, r) && (r[a.length - 1] -= 1);
        break;
      }
      case "merge_node": {
        var {
          path: s,
          position: l
        } = t;
        Ae.equals(s, r) || Ae.endsBefore(s, r) ? r[s.length - 1] -= 1 : Ae.isAncestor(s, r) && (r[s.length - 1] -= 1, r[s.length] += l);
        break;
      }
      case "split_node": {
        var {
          path: u,
          position: c
        } = t;
        if (Ae.equals(u, r)) {
          if (o === "forward")
            r[r.length - 1] += 1;
          else if (o !== "backward") return null;
        } else Ae.endsBefore(u, r) ? r[u.length - 1] += 1 : Ae.isAncestor(u, r) && e[u.length] >= c && (r[u.length - 1] += 1, r[u.length] -= c);
        break;
      }
      case "move_node": {
        var {
          path: p,
          newPath: d
        } = t;
        if (Ae.equals(p, d))
          return r;
        if (Ae.isAncestor(p, r) || Ae.equals(p, r)) {
          var h = d.slice();
          return Ae.endsBefore(p, d) && p.length < d.length && (h[p.length - 1] -= 1), h.concat(r.slice(p.length));
        } else Ae.isSibling(p, d) && (Ae.isAncestor(d, r) || Ae.equals(d, r)) ? Ae.endsBefore(p, r) ? r[p.length - 1] -= 1 : r[p.length - 1] += 1 : Ae.endsBefore(d, r) || Ae.equals(d, r) || Ae.isAncestor(d, r) ? (Ae.endsBefore(p, r) && (r[p.length - 1] -= 1), r[d.length - 1] += 1) : Ae.endsBefore(p, r) && (Ae.equals(d, r) && (r[d.length - 1] += 1), r[p.length - 1] -= 1);
        break;
      }
    }
    return r;
  }
};
function mp(e) {
  "@babel/helpers - typeof";
  return mp = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, mp(e);
}
function uee(e, t) {
  if (mp(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (mp(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function cee(e) {
  var t = uee(e, "string");
  return mp(t) === "symbol" ? t : String(t);
}
function mu(e, t, n) {
  return t = cee(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function qP(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function zu(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? qP(Object(n), !0).forEach(function(r) {
      mu(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : qP(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var pee = (e, t, n) => {
  switch (n.type) {
    case "insert_node": {
      var {
        path: r,
        node: o
      } = n, i = wt.parent(e, r), a = r[r.length - 1];
      if (a > i.children.length)
        throw new Error('Cannot apply an "insert_node" operation at path ['.concat(r, "] because the destination is past the end of the node."));
      if (i.children.splice(a, 0, o), t)
        for (var [s, l] of Rt.points(t))
          t[l] = Jn.transform(s, n);
      break;
    }
    case "insert_text": {
      var {
        path: u,
        offset: c,
        text: p
      } = n;
      if (p.length === 0) break;
      var d = wt.leaf(e, u), h = d.text.slice(0, c), f = d.text.slice(c);
      if (d.text = h + p + f, t)
        for (var [m, g] of Rt.points(t))
          t[g] = Jn.transform(m, n);
      break;
    }
    case "merge_node": {
      var {
        path: E
      } = n, w = wt.get(e, E), M = Ae.previous(E), x = wt.get(e, M), y = wt.parent(e, E), C = E[E.length - 1];
      if (Rr.isText(w) && Rr.isText(x))
        x.text += w.text;
      else if (!Rr.isText(w) && !Rr.isText(x))
        x.children.push(...w.children);
      else
        throw new Error('Cannot apply a "merge_node" operation at path ['.concat(E, "] to nodes of different interfaces: ").concat(Vo.stringify(w), " ").concat(Vo.stringify(x)));
      if (y.children.splice(C, 1), t)
        for (var [P, F] of Rt.points(t))
          t[F] = Jn.transform(P, n);
      break;
    }
    case "move_node": {
      var {
        path: L,
        newPath: N
      } = n;
      if (Ae.isAncestor(L, N))
        throw new Error("Cannot move a path [".concat(L, "] to new path [").concat(N, "] because the destination is inside itself."));
      var I = wt.get(e, L), H = wt.parent(e, L), V = L[L.length - 1];
      H.children.splice(V, 1);
      var z = Ae.transform(L, n), q = wt.get(e, Ae.parent(z)), K = z[z.length - 1];
      if (q.children.splice(K, 0, I), t)
        for (var [J, te] of Rt.points(t))
          t[te] = Jn.transform(J, n);
      break;
    }
    case "remove_node": {
      var {
        path: ee
      } = n, _ = ee[ee.length - 1], D = wt.parent(e, ee);
      if (D.children.splice(_, 1), t)
        for (var [$, S] of Rt.points(t)) {
          var W = Jn.transform($, n);
          if (t != null && W != null)
            t[S] = W;
          else {
            var O = void 0, T = void 0;
            for (var [U, j] of wt.texts(e))
              if (Ae.compare(j, ee) === -1)
                O = [U, j];
              else {
                T = [U, j];
                break;
              }
            var Z = !1;
            O && T && (Ae.equals(T[1], ee) ? Z = !Ae.hasPrevious(T[1]) : Z = Ae.common(O[1], ee).length < Ae.common(T[1], ee).length), O && !Z ? ($.path = O[1], $.offset = O[0].text.length) : T ? ($.path = T[1], $.offset = 0) : t = null;
          }
        }
      break;
    }
    case "remove_text": {
      var {
        path: A,
        offset: Q,
        text: R
      } = n;
      if (R.length === 0) break;
      var ue = wt.leaf(e, A), fe = ue.text.slice(0, Q), oe = ue.text.slice(Q + R.length);
      if (ue.text = fe + oe, t)
        for (var [Re, He] of Rt.points(t))
          t[He] = Jn.transform(Re, n);
      break;
    }
    case "set_node": {
      var {
        path: Ve,
        properties: ze,
        newProperties: et
      } = n;
      if (Ve.length === 0)
        throw new Error("Cannot set properties on the root node!");
      var Ge = wt.get(e, Ve);
      for (var Pe in et) {
        if (Pe === "children" || Pe === "text")
          throw new Error('Cannot set the "'.concat(Pe, '" property of nodes!'));
        var Ye = et[Pe];
        Ye == null ? delete Ge[Pe] : Ge[Pe] = Ye;
      }
      for (var it in ze)
        et.hasOwnProperty(it) || delete Ge[it];
      break;
    }
    case "set_selection": {
      var {
        newProperties: _e
      } = n;
      if (_e == null)
        t = _e;
      else {
        if (t == null) {
          if (!Rt.isRange(_e))
            throw new Error('Cannot apply an incomplete "set_selection" operation properties '.concat(Vo.stringify(_e), " when there is no current selection."));
          t = zu({}, _e);
        }
        for (var Se in _e) {
          var Ke = _e[Se];
          if (Ke == null) {
            if (Se === "anchor" || Se === "focus")
              throw new Error('Cannot remove the "'.concat(Se, '" selection property'));
            delete t[Se];
          } else
            t[Se] = Ke;
        }
      }
      break;
    }
    case "split_node": {
      var {
        path: We,
        position: Ue,
        properties: nt
      } = n;
      if (We.length === 0)
        throw new Error('Cannot apply a "split_node" operation at path ['.concat(We, "] because the root node cannot be split."));
      var Ie = wt.get(e, We), xt = wt.parent(e, We), ot = We[We.length - 1], st;
      if (Rr.isText(Ie)) {
        var lt = Ie.text.slice(0, Ue), Ot = Ie.text.slice(Ue);
        Ie.text = lt, st = zu(zu({}, nt), {}, {
          text: Ot
        });
      } else {
        var ut = Ie.children.slice(0, Ue), ct = Ie.children.slice(Ue);
        Ie.children = ut, st = zu(zu({}, nt), {}, {
          children: ct
        });
      }
      if (xt.children.splice(ot + 1, 0, st), t)
        for (var [tt, Xe] of Rt.points(t))
          t[Xe] = Jn.transform(tt, n);
      break;
    }
  }
  return t;
}, dee = {
  transform(e, t) {
    e.children = WP(e.children);
    var n = e.selection && WP(e.selection);
    try {
      n = pee(e, n, t);
    } finally {
      e.children = VP(e.children), n ? e.selection = Ml(n) ? VP(n) : n : e.selection = null;
    }
  }
}, fee = {
  insertNodes(e, t, n) {
    e.insertNodes(t, n);
  },
  liftNodes(e, t) {
    e.liftNodes(t);
  },
  mergeNodes(e, t) {
    e.mergeNodes(t);
  },
  moveNodes(e, t) {
    e.moveNodes(t);
  },
  removeNodes(e, t) {
    e.removeNodes(t);
  },
  setNodes(e, t, n) {
    e.setNodes(t, n);
  },
  splitNodes(e, t) {
    e.splitNodes(t);
  },
  unsetNodes(e, t, n) {
    e.unsetNodes(t, n);
  },
  unwrapNodes(e, t) {
    e.unwrapNodes(t);
  },
  wrapNodes(e, t, n) {
    e.wrapNodes(t, n);
  }
}, hee = {
  collapse(e, t) {
    e.collapse(t);
  },
  deselect(e) {
    e.deselect();
  },
  move(e, t) {
    e.move(t);
  },
  select(e, t) {
    e.select(t);
  },
  setPoint(e, t, n) {
    e.setPoint(t, n);
  },
  setSelection(e, t) {
    e.setSelection(t);
  }
}, CH = (e, t) => {
  for (var n in e) {
    var r = e[n], o = t[n];
    if (mo(r) && mo(o)) {
      if (!CH(r, o)) return !1;
    } else if (Array.isArray(r) && Array.isArray(o)) {
      if (r.length !== o.length) return !1;
      for (var i = 0; i < r.length; i++)
        if (r[i] !== o[i]) return !1;
    } else if (r !== o)
      return !1;
  }
  for (var a in t)
    if (e[a] === void 0 && t[a] !== void 0)
      return !1;
  return !0;
};
function gee(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), o, i;
  for (i = 0; i < r.length; i++)
    o = r[i], !(t.indexOf(o) >= 0) && (n[o] = e[o]);
  return n;
}
function vp(e, t) {
  if (e == null) return {};
  var n = gee(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (o = 0; o < i.length; o++)
      r = i[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
var mee = ["anchor", "focus"];
function ZP(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function vee(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? ZP(Object(n), !0).forEach(function(r) {
      mu(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : ZP(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Rt = {
  edges(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, {
      anchor: r,
      focus: o
    } = e;
    return Rt.isBackward(e) === n ? [r, o] : [o, r];
  },
  end(e) {
    var [, t] = Rt.edges(e);
    return t;
  },
  equals(e, t) {
    return Jn.equals(e.anchor, t.anchor) && Jn.equals(e.focus, t.focus);
  },
  includes(e, t) {
    if (Rt.isRange(t)) {
      if (Rt.includes(e, t.anchor) || Rt.includes(e, t.focus))
        return !0;
      var [n, r] = Rt.edges(e), [o, i] = Rt.edges(t);
      return Jn.isBefore(n, o) && Jn.isAfter(r, i);
    }
    var [a, s] = Rt.edges(e), l = !1, u = !1;
    return Jn.isPoint(t) ? (l = Jn.compare(t, a) >= 0, u = Jn.compare(t, s) <= 0) : (l = Ae.compare(t, a.path) >= 0, u = Ae.compare(t, s.path) <= 0), l && u;
  },
  intersection(e, t) {
    var n = vp(e, mee), [r, o] = Rt.edges(e), [i, a] = Rt.edges(t), s = Jn.isBefore(r, i) ? i : r, l = Jn.isBefore(o, a) ? o : a;
    return Jn.isBefore(l, s) ? null : vee({
      anchor: s,
      focus: l
    }, n);
  },
  isBackward(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return Jn.isAfter(t, n);
  },
  isCollapsed(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return Jn.equals(t, n);
  },
  isExpanded(e) {
    return !Rt.isCollapsed(e);
  },
  isForward(e) {
    return !Rt.isBackward(e);
  },
  isRange(e) {
    return mo(e) && Jn.isPoint(e.anchor) && Jn.isPoint(e.focus);
  },
  *points(e) {
    yield [e.anchor, "anchor"], yield [e.focus, "focus"];
  },
  start(e) {
    var [t] = Rt.edges(e);
    return t;
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return hE(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "inward"
      } = n, i, a;
      if (o === "inward") {
        var s = Rt.isCollapsed(r);
        Rt.isForward(r) ? (i = "forward", a = s ? i : "backward") : (i = "backward", a = s ? i : "forward");
      } else o === "outward" ? Rt.isForward(r) ? (i = "backward", a = "forward") : (i = "forward", a = "backward") : (i = o, a = o);
      var l = Jn.transform(r.anchor, t, {
        affinity: i
      }), u = Jn.transform(r.focus, t, {
        affinity: a
      });
      if (!l || !u)
        return null;
      r.anchor = l, r.focus = u;
    });
  }
}, GP = (e) => mo(e) && wt.isNodeList(e.children) && !In.isEditor(e), ms = {
  isAncestor(e) {
    return mo(e) && wt.isNodeList(e.children);
  },
  isElement: GP,
  isElementList(e) {
    return Array.isArray(e) && e.every((t) => ms.isElement(t));
  },
  isElementProps(e) {
    return e.children !== void 0;
  },
  isElementType: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "type";
    return GP(e) && e[n] === t;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "children" && e[n] !== t[n])
        return !1;
    return !0;
  }
}, yee = ["children"], bee = ["text"], XP = /* @__PURE__ */ new WeakMap(), wt = {
  ancestor(e, t) {
    var n = wt.get(e, t);
    if (Rr.isText(n))
      throw new Error("Cannot get the ancestor node at path [".concat(t, "] because it refers to a text node instead: ").concat(Vo.stringify(n)));
    return n;
  },
  ancestors(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of Ae.ancestors(t, n)) {
        var o = wt.ancestor(e, r), i = [o, r];
        yield i;
      }
    }();
  },
  child(e, t) {
    if (Rr.isText(e))
      throw new Error("Cannot get the child of a text node: ".concat(Vo.stringify(e)));
    var n = e.children[t];
    if (n == null)
      throw new Error("Cannot get child at index `".concat(t, "` in node: ").concat(Vo.stringify(e)));
    return n;
  },
  children(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var {
        reverse: r = !1
      } = n, o = wt.ancestor(e, t), {
        children: i
      } = o, a = r ? i.length - 1 : 0; r ? a >= 0 : a < i.length; ) {
        var s = wt.child(o, a), l = t.concat(a);
        yield [s, l], a = r ? a - 1 : a + 1;
      }
    }();
  },
  common(e, t, n) {
    var r = Ae.common(t, n), o = wt.get(e, r);
    return [o, r];
  },
  descendant(e, t) {
    var n = wt.get(e, t);
    if (In.isEditor(n))
      throw new Error("Cannot get the descendant node at path [".concat(t, "] because it refers to the root editor node instead: ").concat(Vo.stringify(n)));
    return n;
  },
  descendants(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of wt.nodes(e, t))
        r.length !== 0 && (yield [n, r]);
    }();
  },
  elements(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of wt.nodes(e, t))
        ms.isElement(n) && (yield [n, r]);
    }();
  },
  extractProps(e) {
    if (ms.isAncestor(e)) {
      var t = vp(e, yee);
      return t;
    } else {
      var t = vp(e, bee);
      return t;
    }
  },
  first(e, t) {
    for (var n = t.slice(), r = wt.get(e, n); r && !(Rr.isText(r) || r.children.length === 0); )
      r = r.children[0], n.push(0);
    return [r, n];
  },
  fragment(e, t) {
    if (Rr.isText(e))
      throw new Error("Cannot get a fragment starting from a root text node: ".concat(Vo.stringify(e)));
    var n = hE({
      children: e.children
    }, (r) => {
      var [o, i] = Rt.edges(t), a = wt.nodes(r, {
        reverse: !0,
        pass: (d) => {
          var [, h] = d;
          return !Rt.includes(t, h);
        }
      });
      for (var [, s] of a) {
        if (!Rt.includes(t, s)) {
          var l = wt.parent(r, s), u = s[s.length - 1];
          l.children.splice(u, 1);
        }
        if (Ae.equals(s, i.path)) {
          var c = wt.leaf(r, s);
          c.text = c.text.slice(0, i.offset);
        }
        if (Ae.equals(s, o.path)) {
          var p = wt.leaf(r, s);
          p.text = p.text.slice(o.offset);
        }
      }
      In.isEditor(r) && (r.selection = null);
    });
    return n.children;
  },
  get(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (Rr.isText(n) || !n.children[o])
        throw new Error("Cannot find a descendant at path [".concat(t, "] in node: ").concat(Vo.stringify(e)));
      n = n.children[o];
    }
    return n;
  },
  has(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (Rr.isText(n) || !n.children[o])
        return !1;
      n = n.children[o];
    }
    return !0;
  },
  isNode(e) {
    return Rr.isText(e) || ms.isElement(e) || In.isEditor(e);
  },
  isNodeList(e) {
    if (!Array.isArray(e))
      return !1;
    var t = XP.get(e);
    if (t !== void 0)
      return t;
    var n = e.every((r) => wt.isNode(r));
    return XP.set(e, n), n;
  },
  last(e, t) {
    for (var n = t.slice(), r = wt.get(e, n); r && !(Rr.isText(r) || r.children.length === 0); ) {
      var o = r.children.length - 1;
      r = r.children[o], n.push(o);
    }
    return [r, n];
  },
  leaf(e, t) {
    var n = wt.get(e, t);
    if (!Rr.isText(n))
      throw new Error("Cannot get the leaf node at path [".concat(t, "] because it refers to a non-leaf node: ").concat(Vo.stringify(n)));
    return n;
  },
  levels(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of Ae.levels(t, n)) {
        var o = wt.get(e, r);
        yield [o, r];
      }
    }();
  },
  matches(e, t) {
    return ms.isElement(e) && ms.isElementProps(t) && ms.matches(e, t) || Rr.isText(e) && Rr.isTextProps(t) && Rr.matches(e, t);
  },
  nodes(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var {
        pass: n,
        reverse: r = !1
      } = t, {
        from: o = [],
        to: i
      } = t, a = /* @__PURE__ */ new Set(), s = [], l = e; !(i && (r ? Ae.isBefore(s, i) : Ae.isAfter(s, i))); ) {
        if (a.has(l) || (yield [l, s]), !a.has(l) && !Rr.isText(l) && l.children.length !== 0 && (n == null || n([l, s]) === !1)) {
          a.add(l);
          var u = r ? l.children.length - 1 : 0;
          Ae.isAncestor(s, o) && (u = o[s.length]), s = s.concat(u), l = wt.get(e, s);
          continue;
        }
        if (s.length === 0)
          break;
        if (!r) {
          var c = Ae.next(s);
          if (wt.has(e, c)) {
            s = c, l = wt.get(e, s);
            continue;
          }
        }
        if (r && s[s.length - 1] !== 0) {
          var p = Ae.previous(s);
          s = p, l = wt.get(e, s);
          continue;
        }
        s = Ae.parent(s), l = wt.get(e, s), a.add(l);
      }
    }();
  },
  parent(e, t) {
    var n = Ae.parent(t), r = wt.get(e, n);
    if (Rr.isText(r))
      throw new Error("Cannot get the parent of path [".concat(t, "] because it does not exist in the root."));
    return r;
  },
  string(e) {
    return Rr.isText(e) ? e.text : e.children.map(wt.string).join("");
  },
  texts(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of wt.nodes(e, t))
        Rr.isText(n) && (yield [n, r]);
    }();
  }
};
function KP(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function or(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? KP(Object(n), !0).forEach(function(r) {
      mu(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : KP(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var mc = {
  isNodeOperation(e) {
    return mc.isOperation(e) && e.type.endsWith("_node");
  },
  isOperation(e) {
    if (!mo(e))
      return !1;
    switch (e.type) {
      case "insert_node":
        return Ae.isPath(e.path) && wt.isNode(e.node);
      case "insert_text":
        return typeof e.offset == "number" && typeof e.text == "string" && Ae.isPath(e.path);
      case "merge_node":
        return typeof e.position == "number" && Ae.isPath(e.path) && mo(e.properties);
      case "move_node":
        return Ae.isPath(e.path) && Ae.isPath(e.newPath);
      case "remove_node":
        return Ae.isPath(e.path) && wt.isNode(e.node);
      case "remove_text":
        return typeof e.offset == "number" && typeof e.text == "string" && Ae.isPath(e.path);
      case "set_node":
        return Ae.isPath(e.path) && mo(e.properties) && mo(e.newProperties);
      case "set_selection":
        return e.properties === null && Rt.isRange(e.newProperties) || e.newProperties === null && Rt.isRange(e.properties) || mo(e.properties) && mo(e.newProperties);
      case "split_node":
        return Ae.isPath(e.path) && typeof e.position == "number" && mo(e.properties);
      default:
        return !1;
    }
  },
  isOperationList(e) {
    return Array.isArray(e) && e.every((t) => mc.isOperation(t));
  },
  isSelectionOperation(e) {
    return mc.isOperation(e) && e.type.endsWith("_selection");
  },
  isTextOperation(e) {
    return mc.isOperation(e) && e.type.endsWith("_text");
  },
  inverse(e) {
    switch (e.type) {
      case "insert_node":
        return or(or({}, e), {}, {
          type: "remove_node"
        });
      case "insert_text":
        return or(or({}, e), {}, {
          type: "remove_text"
        });
      case "merge_node":
        return or(or({}, e), {}, {
          type: "split_node",
          path: Ae.previous(e.path)
        });
      case "move_node": {
        var {
          newPath: t,
          path: n
        } = e;
        if (Ae.equals(t, n))
          return e;
        if (Ae.isSibling(n, t))
          return or(or({}, e), {}, {
            path: t,
            newPath: n
          });
        var r = Ae.transform(n, e), o = Ae.transform(Ae.next(n), e);
        return or(or({}, e), {}, {
          path: r,
          newPath: o
        });
      }
      case "remove_node":
        return or(or({}, e), {}, {
          type: "insert_node"
        });
      case "remove_text":
        return or(or({}, e), {}, {
          type: "insert_text"
        });
      case "set_node": {
        var {
          properties: i,
          newProperties: a
        } = e;
        return or(or({}, e), {}, {
          properties: a,
          newProperties: i
        });
      }
      case "set_selection": {
        var {
          properties: s,
          newProperties: l
        } = e;
        return s == null ? or(or({}, e), {}, {
          properties: l,
          newProperties: null
        }) : l == null ? or(or({}, e), {}, {
          properties: null,
          newProperties: s
        }) : or(or({}, e), {}, {
          properties: l,
          newProperties: s
        });
      }
      case "split_node":
        return or(or({}, e), {}, {
          type: "merge_node",
          path: Ae.next(e.path)
        });
    }
  }
}, YP = /* @__PURE__ */ new WeakMap(), wee = (e) => {
  var t = YP.get(e);
  if (t !== void 0)
    return t;
  if (!mo(e))
    return !1;
  var n = typeof e.addMark == "function" && typeof e.apply == "function" && typeof e.deleteFragment == "function" && typeof e.insertBreak == "function" && typeof e.insertSoftBreak == "function" && typeof e.insertFragment == "function" && typeof e.insertNode == "function" && typeof e.insertText == "function" && typeof e.isElementReadOnly == "function" && typeof e.isInline == "function" && typeof e.isSelectable == "function" && typeof e.isVoid == "function" && typeof e.normalizeNode == "function" && typeof e.onChange == "function" && typeof e.removeMark == "function" && typeof e.getDirtyPaths == "function" && (e.marks === null || mo(e.marks)) && (e.selection === null || Rt.isRange(e.selection)) && wt.isNodeList(e.children) && mc.isOperationList(e.operations);
  return YP.set(e, n), n;
}, In = {
  above(e, t) {
    return e.above(t);
  },
  addMark(e, t, n) {
    e.addMark(t, n);
  },
  after(e, t, n) {
    return e.after(t, n);
  },
  before(e, t, n) {
    return e.before(t, n);
  },
  deleteBackward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteBackward(n);
  },
  deleteForward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteForward(n);
  },
  deleteFragment(e, t) {
    e.deleteFragment(t);
  },
  edges(e, t) {
    return e.edges(t);
  },
  elementReadOnly(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return e.elementReadOnly(t);
  },
  end(e, t) {
    return e.end(t);
  },
  first(e, t) {
    return e.first(t);
  },
  fragment(e, t) {
    return e.fragment(t);
  },
  hasBlocks(e, t) {
    return e.hasBlocks(t);
  },
  hasInlines(e, t) {
    return e.hasInlines(t);
  },
  hasPath(e, t) {
    return e.hasPath(t);
  },
  hasTexts(e, t) {
    return e.hasTexts(t);
  },
  insertBreak(e) {
    e.insertBreak();
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertNode(e, t) {
    e.insertNode(t);
  },
  insertSoftBreak(e) {
    e.insertSoftBreak();
  },
  insertText(e, t) {
    e.insertText(t);
  },
  isBlock(e, t) {
    return e.isBlock(t);
  },
  isEdge(e, t, n) {
    return e.isEdge(t, n);
  },
  isEditor(e) {
    return wee(e);
  },
  isElementReadOnly(e, t) {
    return e.isElementReadOnly(t);
  },
  isEmpty(e, t) {
    return e.isEmpty(t);
  },
  isEnd(e, t, n) {
    return e.isEnd(t, n);
  },
  isInline(e, t) {
    return e.isInline(t);
  },
  isNormalizing(e) {
    return e.isNormalizing();
  },
  isSelectable(e, t) {
    return e.isSelectable(t);
  },
  isStart(e, t, n) {
    return e.isStart(t, n);
  },
  isVoid(e, t) {
    return e.isVoid(t);
  },
  last(e, t) {
    return e.last(t);
  },
  leaf(e, t, n) {
    return e.leaf(t, n);
  },
  levels(e, t) {
    return e.levels(t);
  },
  marks(e) {
    return e.getMarks();
  },
  next(e, t) {
    return e.next(t);
  },
  node(e, t, n) {
    return e.node(t, n);
  },
  nodes(e, t) {
    return e.nodes(t);
  },
  normalize(e, t) {
    e.normalize(t);
  },
  parent(e, t, n) {
    return e.parent(t, n);
  },
  path(e, t, n) {
    return e.path(t, n);
  },
  pathRef(e, t, n) {
    return e.pathRef(t, n);
  },
  pathRefs(e) {
    return e.pathRefs();
  },
  point(e, t, n) {
    return e.point(t, n);
  },
  pointRef(e, t, n) {
    return e.pointRef(t, n);
  },
  pointRefs(e) {
    return e.pointRefs();
  },
  positions(e, t) {
    return e.positions(t);
  },
  previous(e, t) {
    return e.previous(t);
  },
  range(e, t, n) {
    return e.range(t, n);
  },
  rangeRef(e, t, n) {
    return e.rangeRef(t, n);
  },
  rangeRefs(e) {
    return e.rangeRefs();
  },
  removeMark(e, t) {
    e.removeMark(t);
  },
  setNormalizing(e, t) {
    e.setNormalizing(t);
  },
  start(e, t) {
    return e.start(t);
  },
  string(e, t, n) {
    return e.string(t, n);
  },
  unhangRange(e, t, n) {
    return e.unhangRange(t, n);
  },
  void(e, t) {
    return e.void(t);
  },
  withoutNormalizing(e, t) {
    e.withoutNormalizing(t);
  },
  shouldMergeNodesRemovePrevNode: (e, t, n) => e.shouldMergeNodesRemovePrevNode(t, n)
};
function JP(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function QP(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? JP(Object(n), !0).forEach(function(r) {
      mu(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : JP(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Jn = {
  compare(e, t) {
    var n = Ae.compare(e.path, t.path);
    return n === 0 ? e.offset < t.offset ? -1 : e.offset > t.offset ? 1 : 0 : n;
  },
  isAfter(e, t) {
    return Jn.compare(e, t) === 1;
  },
  isBefore(e, t) {
    return Jn.compare(e, t) === -1;
  },
  equals(e, t) {
    return e.offset === t.offset && Ae.equals(e.path, t.path);
  },
  isPoint(e) {
    return mo(e) && typeof e.offset == "number" && Ae.isPath(e.path);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return hE(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "forward"
      } = n, {
        path: i,
        offset: a
      } = r;
      switch (t.type) {
        case "insert_node":
        case "move_node": {
          r.path = Ae.transform(i, t, n);
          break;
        }
        case "insert_text": {
          Ae.equals(t.path, i) && (t.offset < a || t.offset === a && o === "forward") && (r.offset += t.text.length);
          break;
        }
        case "merge_node": {
          Ae.equals(t.path, i) && (r.offset += t.position), r.path = Ae.transform(i, t, n);
          break;
        }
        case "remove_text": {
          Ae.equals(t.path, i) && t.offset <= a && (r.offset -= Math.min(a - t.offset, t.text.length));
          break;
        }
        case "remove_node": {
          if (Ae.equals(t.path, i) || Ae.isAncestor(t.path, i))
            return null;
          r.path = Ae.transform(i, t, n);
          break;
        }
        case "split_node": {
          if (Ae.equals(t.path, i)) {
            if (t.position === a && o == null)
              return null;
            (t.position < a || t.position === a && o === "forward") && (r.offset -= t.position, r.path = Ae.transform(i, t, QP(QP({}, n), {}, {
              affinity: "forward"
            })));
          } else
            r.path = Ae.transform(i, t, n);
          break;
        }
      }
    });
  }
}, eS = void 0, Vo = {
  setScrubber(e) {
    eS = e;
  },
  stringify(e) {
    return JSON.stringify(e, eS);
  }
}, Cee = ["text"], xee = ["anchor", "focus"];
function tS(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function is(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? tS(Object(n), !0).forEach(function(r) {
      mu(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : tS(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Rr = {
  equals(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      loose: r = !1
    } = n;
    function o(i) {
      var a = vp(i, Cee);
      return a;
    }
    return CH(r ? o(e) : e, r ? o(t) : t);
  },
  isText(e) {
    return mo(e) && typeof e.text == "string";
  },
  isTextList(e) {
    return Array.isArray(e) && e.every((t) => Rr.isText(t));
  },
  isTextProps(e) {
    return e.text !== void 0;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "text" && (!e.hasOwnProperty(n) || e[n] !== t[n]))
        return !1;
    return !0;
  },
  decorations(e, t) {
    var n = [is({}, e)];
    for (var r of t) {
      var o = vp(r, xee), [i, a] = Rt.edges(r), s = [], l = 0, u = i.offset, c = a.offset;
      for (var p of n) {
        var {
          length: d
        } = p.text, h = l;
        if (l += d, u <= h && l <= c) {
          Object.assign(p, o), s.push(p);
          continue;
        }
        if (u !== c && (u === l || c === h) || u > l || c < h || c === h && h !== 0) {
          s.push(p);
          continue;
        }
        var f = p, m = void 0, g = void 0;
        if (c < l) {
          var E = c - h;
          g = is(is({}, f), {}, {
            text: f.text.slice(E)
          }), f = is(is({}, f), {}, {
            text: f.text.slice(0, E)
          });
        }
        if (u > h) {
          var w = u - h;
          m = is(is({}, f), {}, {
            text: f.text.slice(0, w)
          }), f = is(is({}, f), {}, {
            text: f.text.slice(w)
          });
        }
        Object.assign(f, o), m && s.push(m), s.push(f), g && s.push(g);
      }
      n = s;
    }
    return n;
  }
}, Oee = (e) => e.selection ? e.selection : e.children.length > 0 ? In.end(e, []) : [0], Zn;
(function(e) {
  e[e.None = 0] = "None", e[e.Extend = 1] = "Extend", e[e.ZWJ = 2] = "ZWJ", e[e.RI = 4] = "RI", e[e.Prepend = 8] = "Prepend", e[e.SpacingMark = 16] = "SpacingMark", e[e.L = 32] = "L", e[e.V = 64] = "V", e[e.T = 128] = "T", e[e.LV = 256] = "LV", e[e.LVT = 512] = "LVT", e[e.ExtPict = 1024] = "ExtPict", e[e.Any = 2048] = "Any";
})(Zn || (Zn = {}));
Zn.L, Zn.L | Zn.V | Zn.LV | Zn.LVT, Zn.LV | Zn.V, Zn.V | Zn.T, Zn.LVT | Zn.T, Zn.T, Zn.Any, Zn.Extend | Zn.ZWJ, Zn.Any, Zn.SpacingMark, Zn.Prepend, Zn.Any, Zn.ZWJ, Zn.ExtPict, Zn.RI, Zn.RI;
var Eee = {
  delete(e, t) {
    e.delete(t);
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertText(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    In.withoutNormalizing(e, () => {
      var {
        voids: r = !1
      } = n, {
        at: o = Oee(e)
      } = n;
      if (Ae.isPath(o) && (o = In.range(e, o)), Rt.isRange(o))
        if (Rt.isCollapsed(o))
          o = o.anchor;
        else {
          var i = Rt.end(o);
          if (!r && In.void(e, {
            at: i
          }))
            return;
          var a = Rt.start(o), s = In.pointRef(e, a), l = In.pointRef(e, i);
          cg.delete(e, {
            at: o,
            voids: r
          });
          var u = s.unref(), c = l.unref();
          o = u || c, cg.setSelection(e, {
            anchor: o,
            focus: o
          });
        }
      if (!(!r && In.void(e, {
        at: o
      }) || In.elementReadOnly(e, {
        at: o
      }))) {
        var {
          path: p,
          offset: d
        } = o;
        t.length > 0 && e.apply({
          type: "insert_text",
          path: p,
          offset: d,
          text: t
        });
      }
    });
  }
};
function nS(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ef(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? nS(Object(n), !0).forEach(function(r) {
      mu(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : nS(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var cg = ef(ef(ef(ef({}, dee), fee), hee), Eee), xH = {}, gE = {}, mE = {}, $l = {}, vE = {}, yE = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Doctype = e.CDATA = e.Tag = e.Style = e.Script = e.Comment = e.Directive = e.Text = e.Root = e.isTag = e.ElementType = void 0;
  var t;
  (function(r) {
    r.Root = "root", r.Text = "text", r.Directive = "directive", r.Comment = "comment", r.Script = "script", r.Style = "style", r.Tag = "tag", r.CDATA = "cdata", r.Doctype = "doctype";
  })(t = e.ElementType || (e.ElementType = {}));
  function n(r) {
    return r.type === t.Tag || r.type === t.Script || r.type === t.Style;
  }
  e.isTag = n, e.Root = t.Root, e.Text = t.Text, e.Directive = t.Directive, e.Comment = t.Comment, e.Script = t.Script, e.Style = t.Style, e.Tag = t.Tag, e.CDATA = t.CDATA, e.Doctype = t.Doctype;
})(yE);
var Wt = {}, Oa = $n && $n.__extends || /* @__PURE__ */ function() {
  var e = function(t, n) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, o) {
      r.__proto__ = o;
    } || function(r, o) {
      for (var i in o) Object.prototype.hasOwnProperty.call(o, i) && (r[i] = o[i]);
    }, e(t, n);
  };
  return function(t, n) {
    if (typeof n != "function" && n !== null)
      throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
    e(t, n);
    function r() {
      this.constructor = t;
    }
    t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
  };
}(), Sc = $n && $n.__assign || function() {
  return Sc = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) {
      t = arguments[n];
      for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
    }
    return e;
  }, Sc.apply(this, arguments);
};
Object.defineProperty(Wt, "__esModule", { value: !0 });
Wt.cloneNode = Wt.hasChildren = Wt.isDocument = Wt.isDirective = Wt.isComment = Wt.isText = Wt.isCDATA = Wt.isTag = Wt.Element = Wt.Document = Wt.CDATA = Wt.NodeWithChildren = Wt.ProcessingInstruction = Wt.Comment = Wt.Text = Wt.DataNode = Wt.Node = void 0;
var zo = yE, bE = (
  /** @class */
  function() {
    function e() {
      this.parent = null, this.prev = null, this.next = null, this.startIndex = null, this.endIndex = null;
    }
    return Object.defineProperty(e.prototype, "parentNode", {
      // Read-write aliases for properties
      /**
       * Same as {@link parent}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.parent;
      },
      set: function(t) {
        this.parent = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "previousSibling", {
      /**
       * Same as {@link prev}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.prev;
      },
      set: function(t) {
        this.prev = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "nextSibling", {
      /**
       * Same as {@link next}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.next;
      },
      set: function(t) {
        this.next = t;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.cloneNode = function(t) {
      return t === void 0 && (t = !1), wE(this, t);
    }, e;
  }()
);
Wt.Node = bE;
var Lv = (
  /** @class */
  function(e) {
    Oa(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.data = n, r;
    }
    return Object.defineProperty(t.prototype, "nodeValue", {
      /**
       * Same as {@link data}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.data;
      },
      set: function(n) {
        this.data = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(bE)
);
Wt.DataNode = Lv;
var OH = (
  /** @class */
  function(e) {
    Oa(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = zo.ElementType.Text, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 3;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Lv)
);
Wt.Text = OH;
var EH = (
  /** @class */
  function(e) {
    Oa(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = zo.ElementType.Comment, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 8;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Lv)
);
Wt.Comment = EH;
var kH = (
  /** @class */
  function(e) {
    Oa(t, e);
    function t(n, r) {
      var o = e.call(this, r) || this;
      return o.name = n, o.type = zo.ElementType.Directive, o;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Lv)
);
Wt.ProcessingInstruction = kH;
var _v = (
  /** @class */
  function(e) {
    Oa(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.children = n, r;
    }
    return Object.defineProperty(t.prototype, "firstChild", {
      // Aliases
      /** First child of the node. */
      get: function() {
        var n;
        return (n = this.children[0]) !== null && n !== void 0 ? n : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "lastChild", {
      /** Last child of the node. */
      get: function() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "childNodes", {
      /**
       * Same as {@link children}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.children;
      },
      set: function(n) {
        this.children = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(bE)
);
Wt.NodeWithChildren = _v;
var LH = (
  /** @class */
  function(e) {
    Oa(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = zo.ElementType.CDATA, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 4;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(_v)
);
Wt.CDATA = LH;
var _H = (
  /** @class */
  function(e) {
    Oa(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = zo.ElementType.Root, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 9;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(_v)
);
Wt.Document = _H;
var PH = (
  /** @class */
  function(e) {
    Oa(t, e);
    function t(n, r, o, i) {
      o === void 0 && (o = []), i === void 0 && (i = n === "script" ? zo.ElementType.Script : n === "style" ? zo.ElementType.Style : zo.ElementType.Tag);
      var a = e.call(this, o) || this;
      return a.name = n, a.attribs = r, a.type = i, a;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "tagName", {
      // DOM Level 1 aliases
      /**
       * Same as {@link name}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.name;
      },
      set: function(n) {
        this.name = n;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "attributes", {
      get: function() {
        var n = this;
        return Object.keys(this.attribs).map(function(r) {
          var o, i;
          return {
            name: r,
            value: n.attribs[r],
            namespace: (o = n["x-attribsNamespace"]) === null || o === void 0 ? void 0 : o[r],
            prefix: (i = n["x-attribsPrefix"]) === null || i === void 0 ? void 0 : i[r]
          };
        });
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(_v)
);
Wt.Element = PH;
function SH(e) {
  return (0, zo.isTag)(e);
}
Wt.isTag = SH;
function MH(e) {
  return e.type === zo.ElementType.CDATA;
}
Wt.isCDATA = MH;
function DH(e) {
  return e.type === zo.ElementType.Text;
}
Wt.isText = DH;
function TH(e) {
  return e.type === zo.ElementType.Comment;
}
Wt.isComment = TH;
function jH(e) {
  return e.type === zo.ElementType.Directive;
}
Wt.isDirective = jH;
function AH(e) {
  return e.type === zo.ElementType.Root;
}
Wt.isDocument = AH;
function kee(e) {
  return Object.prototype.hasOwnProperty.call(e, "children");
}
Wt.hasChildren = kee;
function wE(e, t) {
  t === void 0 && (t = !1);
  var n;
  if (DH(e))
    n = new OH(e.data);
  else if (TH(e))
    n = new EH(e.data);
  else if (SH(e)) {
    var r = t ? pb(e.children) : [], o = new PH(e.name, Sc({}, e.attribs), r);
    r.forEach(function(l) {
      return l.parent = o;
    }), e.namespace != null && (o.namespace = e.namespace), e["x-attribsNamespace"] && (o["x-attribsNamespace"] = Sc({}, e["x-attribsNamespace"])), e["x-attribsPrefix"] && (o["x-attribsPrefix"] = Sc({}, e["x-attribsPrefix"])), n = o;
  } else if (MH(e)) {
    var r = t ? pb(e.children) : [], i = new LH(r);
    r.forEach(function(u) {
      return u.parent = i;
    }), n = i;
  } else if (AH(e)) {
    var r = t ? pb(e.children) : [], a = new _H(r);
    r.forEach(function(u) {
      return u.parent = a;
    }), e["x-mode"] && (a["x-mode"] = e["x-mode"]), n = a;
  } else if (jH(e)) {
    var s = new kH(e.name, e.data);
    e["x-name"] != null && (s["x-name"] = e["x-name"], s["x-publicId"] = e["x-publicId"], s["x-systemId"] = e["x-systemId"]), n = s;
  } else
    throw new Error("Not implemented yet: ".concat(e.type));
  return n.startIndex = e.startIndex, n.endIndex = e.endIndex, e.sourceCodeLocation != null && (n.sourceCodeLocation = e.sourceCodeLocation), n;
}
Wt.cloneNode = wE;
function pb(e) {
  for (var t = e.map(function(r) {
    return wE(r, !0);
  }), n = 1; n < t.length; n++)
    t[n].prev = t[n - 1], t[n - 1].next = t[n];
  return t;
}
(function(e) {
  var t = $n && $n.__createBinding || (Object.create ? function(s, l, u, c) {
    c === void 0 && (c = u);
    var p = Object.getOwnPropertyDescriptor(l, u);
    (!p || ("get" in p ? !l.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
      return l[u];
    } }), Object.defineProperty(s, c, p);
  } : function(s, l, u, c) {
    c === void 0 && (c = u), s[c] = l[u];
  }), n = $n && $n.__exportStar || function(s, l) {
    for (var u in s) u !== "default" && !Object.prototype.hasOwnProperty.call(l, u) && t(l, s, u);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.DomHandler = void 0;
  var r = yE, o = Wt;
  n(Wt, e);
  var i = {
    withStartIndices: !1,
    withEndIndices: !1,
    xmlMode: !1
  }, a = (
    /** @class */
    function() {
      function s(l, u, c) {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null, typeof u == "function" && (c = u, u = i), typeof l == "object" && (u = l, l = void 0), this.callback = l ?? null, this.options = u ?? i, this.elementCB = c ?? null;
      }
      return s.prototype.onparserinit = function(l) {
        this.parser = l;
      }, s.prototype.onreset = function() {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null;
      }, s.prototype.onend = function() {
        this.done || (this.done = !0, this.parser = null, this.handleCallback(null));
      }, s.prototype.onerror = function(l) {
        this.handleCallback(l);
      }, s.prototype.onclosetag = function() {
        this.lastNode = null;
        var l = this.tagStack.pop();
        this.options.withEndIndices && (l.endIndex = this.parser.endIndex), this.elementCB && this.elementCB(l);
      }, s.prototype.onopentag = function(l, u) {
        var c = this.options.xmlMode ? r.ElementType.Tag : void 0, p = new o.Element(l, u, void 0, c);
        this.addNode(p), this.tagStack.push(p);
      }, s.prototype.ontext = function(l) {
        var u = this.lastNode;
        if (u && u.type === r.ElementType.Text)
          u.data += l, this.options.withEndIndices && (u.endIndex = this.parser.endIndex);
        else {
          var c = new o.Text(l);
          this.addNode(c), this.lastNode = c;
        }
      }, s.prototype.oncomment = function(l) {
        if (this.lastNode && this.lastNode.type === r.ElementType.Comment) {
          this.lastNode.data += l;
          return;
        }
        var u = new o.Comment(l);
        this.addNode(u), this.lastNode = u;
      }, s.prototype.oncommentend = function() {
        this.lastNode = null;
      }, s.prototype.oncdatastart = function() {
        var l = new o.Text(""), u = new o.CDATA([l]);
        this.addNode(u), l.parent = u, this.lastNode = l;
      }, s.prototype.oncdataend = function() {
        this.lastNode = null;
      }, s.prototype.onprocessinginstruction = function(l, u) {
        var c = new o.ProcessingInstruction(l, u);
        this.addNode(c);
      }, s.prototype.handleCallback = function(l) {
        if (typeof this.callback == "function")
          this.callback(l, this.dom);
        else if (l)
          throw l;
      }, s.prototype.addNode = function(l) {
        var u = this.tagStack[this.tagStack.length - 1], c = u.children[u.children.length - 1];
        this.options.withStartIndices && (l.startIndex = this.parser.startIndex), this.options.withEndIndices && (l.endIndex = this.parser.endIndex), u.children.push(l), c && (l.prev = c, c.next = l), l.parent = u, this.lastNode = null;
      }, s;
    }()
  );
  e.DomHandler = a, e.default = a;
})(vE);
var BH = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CARRIAGE_RETURN_PLACEHOLDER_REGEX = e.CARRIAGE_RETURN_PLACEHOLDER = e.CARRIAGE_RETURN_REGEX = e.CARRIAGE_RETURN = e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES = void 0, e.CASE_SENSITIVE_TAG_NAMES = [
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "linearGradient",
    "radialGradient",
    "textPath"
  ], e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES.reduce(function(t, n) {
    return t[n.toLowerCase()] = n, t;
  }, {}), e.CARRIAGE_RETURN = "\r", e.CARRIAGE_RETURN_REGEX = new RegExp(e.CARRIAGE_RETURN, "g"), e.CARRIAGE_RETURN_PLACEHOLDER = "__HTML_DOM_PARSER_CARRIAGE_RETURN_PLACEHOLDER_".concat(Date.now(), "__"), e.CARRIAGE_RETURN_PLACEHOLDER_REGEX = new RegExp(e.CARRIAGE_RETURN_PLACEHOLDER, "g");
})(BH);
Object.defineProperty($l, "__esModule", { value: !0 });
$l.formatAttributes = IH;
$l.escapeSpecialCharacters = Pee;
$l.revertEscapedCharacters = RH;
$l.formatDOM = NH;
var tf = vE, yp = BH;
function Lee(e) {
  return yp.CASE_SENSITIVE_TAG_NAMES_MAP[e];
}
function IH(e) {
  for (var t = {}, n = 0, r = e.length; n < r; n++) {
    var o = e[n];
    t[o.name] = o.value;
  }
  return t;
}
function _ee(e) {
  e = e.toLowerCase();
  var t = Lee(e);
  return t || e;
}
function Pee(e) {
  return e.replace(yp.CARRIAGE_RETURN_REGEX, yp.CARRIAGE_RETURN_PLACEHOLDER);
}
function RH(e) {
  return e.replace(yp.CARRIAGE_RETURN_PLACEHOLDER_REGEX, yp.CARRIAGE_RETURN);
}
function NH(e, t, n) {
  t === void 0 && (t = null);
  for (var r = [], o, i = 0, a = e.length; i < a; i++) {
    var s = e[i];
    switch (s.nodeType) {
      case 1: {
        var l = _ee(s.nodeName);
        o = new tf.Element(l, IH(s.attributes)), o.children = NH(
          // template children are on content
          l === "template" ? s.content.childNodes : s.childNodes,
          o
        );
        break;
      }
      case 3:
        o = new tf.Text(RH(s.nodeValue));
        break;
      case 8:
        o = new tf.Comment(s.nodeValue);
        break;
      default:
        continue;
    }
    var u = r[i - 1] || null;
    u && (u.next = o), o.parent = t, o.prev = u, o.next = null, r.push(o);
  }
  return n && (o = new tf.ProcessingInstruction(n.substring(0, n.indexOf(" ")).toLowerCase(), n), o.next = r[0] || null, o.parent = t, r.unshift(o), r[1] && (r[1].prev = r[0])), r;
}
Object.defineProperty(mE, "__esModule", { value: !0 });
mE.default = jee;
var See = $l, rS = "html", oS = "head", nf = "body", Mee = /<([a-zA-Z]+[0-9]?)/, iS = /<head[^]*>/i, sS = /<body[^]*>/i, pg = function(e, t) {
  throw new Error("This browser does not support `document.implementation.createHTMLDocument`");
}, AC = function(e, t) {
  throw new Error("This browser does not support `DOMParser.prototype.parseFromString`");
}, aS = typeof window == "object" && window.DOMParser;
if (typeof aS == "function") {
  var Dee = new aS(), Tee = "text/html";
  AC = function(e, t) {
    return t && (e = "<".concat(t, ">").concat(e, "</").concat(t, ">")), Dee.parseFromString(e, Tee);
  }, pg = AC;
}
if (typeof document == "object" && document.implementation) {
  var rf = document.implementation.createHTMLDocument();
  pg = function(e, t) {
    if (t) {
      var n = rf.documentElement.querySelector(t);
      return n && (n.innerHTML = e), rf;
    }
    return rf.documentElement.innerHTML = e, rf;
  };
}
var of = typeof document == "object" && document.createElement("template"), BC;
of && of.content && (BC = function(e) {
  return of.innerHTML = e, of.content.childNodes;
});
function jee(e) {
  var t, n;
  e = (0, See.escapeSpecialCharacters)(e);
  var r = e.match(Mee), o = r && r[1] ? r[1].toLowerCase() : "";
  switch (o) {
    case rS: {
      var i = AC(e);
      if (!iS.test(e)) {
        var a = i.querySelector(oS);
        (t = a == null ? void 0 : a.parentNode) === null || t === void 0 || t.removeChild(a);
      }
      if (!sS.test(e)) {
        var a = i.querySelector(nf);
        (n = a == null ? void 0 : a.parentNode) === null || n === void 0 || n.removeChild(a);
      }
      return i.querySelectorAll(rS);
    }
    case oS:
    case nf: {
      var s = pg(e).querySelectorAll(o);
      return sS.test(e) && iS.test(e) ? s[0].parentNode.childNodes : s;
    }
    default: {
      if (BC)
        return BC(e);
      var a = pg(e, nf).querySelector(nf);
      return a.childNodes;
    }
  }
}
var Aee = $n && $n.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(gE, "__esModule", { value: !0 });
gE.default = Nee;
var Bee = Aee(mE), Iee = $l, Ree = /<(![a-zA-Z\s]+)>/;
function Nee(e) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e)
    return [];
  var t = e.match(Ree), n = t ? t[1] : void 0;
  return (0, Iee.formatDOM)((0, Bee.default)(e), null, n);
}
var Pv = {}, ji = {}, Sv = {}, Fee = 0;
Sv.SAME = Fee;
var zee = 1;
Sv.CAMELCASE = zee;
Sv.possibleStandardNames = {
  accept: 0,
  acceptCharset: 1,
  "accept-charset": "acceptCharset",
  accessKey: 1,
  action: 0,
  allowFullScreen: 1,
  alt: 0,
  as: 0,
  async: 0,
  autoCapitalize: 1,
  autoComplete: 1,
  autoCorrect: 1,
  autoFocus: 1,
  autoPlay: 1,
  autoSave: 1,
  capture: 0,
  cellPadding: 1,
  cellSpacing: 1,
  challenge: 0,
  charSet: 1,
  checked: 0,
  children: 0,
  cite: 0,
  class: "className",
  classID: 1,
  className: 1,
  cols: 0,
  colSpan: 1,
  content: 0,
  contentEditable: 1,
  contextMenu: 1,
  controls: 0,
  controlsList: 1,
  coords: 0,
  crossOrigin: 1,
  dangerouslySetInnerHTML: 1,
  data: 0,
  dateTime: 1,
  default: 0,
  defaultChecked: 1,
  defaultValue: 1,
  defer: 0,
  dir: 0,
  disabled: 0,
  disablePictureInPicture: 1,
  disableRemotePlayback: 1,
  download: 0,
  draggable: 0,
  encType: 1,
  enterKeyHint: 1,
  for: "htmlFor",
  form: 0,
  formMethod: 1,
  formAction: 1,
  formEncType: 1,
  formNoValidate: 1,
  formTarget: 1,
  frameBorder: 1,
  headers: 0,
  height: 0,
  hidden: 0,
  high: 0,
  href: 0,
  hrefLang: 1,
  htmlFor: 1,
  httpEquiv: 1,
  "http-equiv": "httpEquiv",
  icon: 0,
  id: 0,
  innerHTML: 1,
  inputMode: 1,
  integrity: 0,
  is: 0,
  itemID: 1,
  itemProp: 1,
  itemRef: 1,
  itemScope: 1,
  itemType: 1,
  keyParams: 1,
  keyType: 1,
  kind: 0,
  label: 0,
  lang: 0,
  list: 0,
  loop: 0,
  low: 0,
  manifest: 0,
  marginWidth: 1,
  marginHeight: 1,
  max: 0,
  maxLength: 1,
  media: 0,
  mediaGroup: 1,
  method: 0,
  min: 0,
  minLength: 1,
  multiple: 0,
  muted: 0,
  name: 0,
  noModule: 1,
  nonce: 0,
  noValidate: 1,
  open: 0,
  optimum: 0,
  pattern: 0,
  placeholder: 0,
  playsInline: 1,
  poster: 0,
  preload: 0,
  profile: 0,
  radioGroup: 1,
  readOnly: 1,
  referrerPolicy: 1,
  rel: 0,
  required: 0,
  reversed: 0,
  role: 0,
  rows: 0,
  rowSpan: 1,
  sandbox: 0,
  scope: 0,
  scoped: 0,
  scrolling: 0,
  seamless: 0,
  selected: 0,
  shape: 0,
  size: 0,
  sizes: 0,
  span: 0,
  spellCheck: 1,
  src: 0,
  srcDoc: 1,
  srcLang: 1,
  srcSet: 1,
  start: 0,
  step: 0,
  style: 0,
  summary: 0,
  tabIndex: 1,
  target: 0,
  title: 0,
  type: 0,
  useMap: 1,
  value: 0,
  width: 0,
  wmode: 0,
  wrap: 0,
  about: 0,
  accentHeight: 1,
  "accent-height": "accentHeight",
  accumulate: 0,
  additive: 0,
  alignmentBaseline: 1,
  "alignment-baseline": "alignmentBaseline",
  allowReorder: 1,
  alphabetic: 0,
  amplitude: 0,
  arabicForm: 1,
  "arabic-form": "arabicForm",
  ascent: 0,
  attributeName: 1,
  attributeType: 1,
  autoReverse: 1,
  azimuth: 0,
  baseFrequency: 1,
  baselineShift: 1,
  "baseline-shift": "baselineShift",
  baseProfile: 1,
  bbox: 0,
  begin: 0,
  bias: 0,
  by: 0,
  calcMode: 1,
  capHeight: 1,
  "cap-height": "capHeight",
  clip: 0,
  clipPath: 1,
  "clip-path": "clipPath",
  clipPathUnits: 1,
  clipRule: 1,
  "clip-rule": "clipRule",
  color: 0,
  colorInterpolation: 1,
  "color-interpolation": "colorInterpolation",
  colorInterpolationFilters: 1,
  "color-interpolation-filters": "colorInterpolationFilters",
  colorProfile: 1,
  "color-profile": "colorProfile",
  colorRendering: 1,
  "color-rendering": "colorRendering",
  contentScriptType: 1,
  contentStyleType: 1,
  cursor: 0,
  cx: 0,
  cy: 0,
  d: 0,
  datatype: 0,
  decelerate: 0,
  descent: 0,
  diffuseConstant: 1,
  direction: 0,
  display: 0,
  divisor: 0,
  dominantBaseline: 1,
  "dominant-baseline": "dominantBaseline",
  dur: 0,
  dx: 0,
  dy: 0,
  edgeMode: 1,
  elevation: 0,
  enableBackground: 1,
  "enable-background": "enableBackground",
  end: 0,
  exponent: 0,
  externalResourcesRequired: 1,
  fill: 0,
  fillOpacity: 1,
  "fill-opacity": "fillOpacity",
  fillRule: 1,
  "fill-rule": "fillRule",
  filter: 0,
  filterRes: 1,
  filterUnits: 1,
  floodOpacity: 1,
  "flood-opacity": "floodOpacity",
  floodColor: 1,
  "flood-color": "floodColor",
  focusable: 0,
  fontFamily: 1,
  "font-family": "fontFamily",
  fontSize: 1,
  "font-size": "fontSize",
  fontSizeAdjust: 1,
  "font-size-adjust": "fontSizeAdjust",
  fontStretch: 1,
  "font-stretch": "fontStretch",
  fontStyle: 1,
  "font-style": "fontStyle",
  fontVariant: 1,
  "font-variant": "fontVariant",
  fontWeight: 1,
  "font-weight": "fontWeight",
  format: 0,
  from: 0,
  fx: 0,
  fy: 0,
  g1: 0,
  g2: 0,
  glyphName: 1,
  "glyph-name": "glyphName",
  glyphOrientationHorizontal: 1,
  "glyph-orientation-horizontal": "glyphOrientationHorizontal",
  glyphOrientationVertical: 1,
  "glyph-orientation-vertical": "glyphOrientationVertical",
  glyphRef: 1,
  gradientTransform: 1,
  gradientUnits: 1,
  hanging: 0,
  horizAdvX: 1,
  "horiz-adv-x": "horizAdvX",
  horizOriginX: 1,
  "horiz-origin-x": "horizOriginX",
  ideographic: 0,
  imageRendering: 1,
  "image-rendering": "imageRendering",
  in2: 0,
  in: 0,
  inlist: 0,
  intercept: 0,
  k1: 0,
  k2: 0,
  k3: 0,
  k4: 0,
  k: 0,
  kernelMatrix: 1,
  kernelUnitLength: 1,
  kerning: 0,
  keyPoints: 1,
  keySplines: 1,
  keyTimes: 1,
  lengthAdjust: 1,
  letterSpacing: 1,
  "letter-spacing": "letterSpacing",
  lightingColor: 1,
  "lighting-color": "lightingColor",
  limitingConeAngle: 1,
  local: 0,
  markerEnd: 1,
  "marker-end": "markerEnd",
  markerHeight: 1,
  markerMid: 1,
  "marker-mid": "markerMid",
  markerStart: 1,
  "marker-start": "markerStart",
  markerUnits: 1,
  markerWidth: 1,
  mask: 0,
  maskContentUnits: 1,
  maskUnits: 1,
  mathematical: 0,
  mode: 0,
  numOctaves: 1,
  offset: 0,
  opacity: 0,
  operator: 0,
  order: 0,
  orient: 0,
  orientation: 0,
  origin: 0,
  overflow: 0,
  overlinePosition: 1,
  "overline-position": "overlinePosition",
  overlineThickness: 1,
  "overline-thickness": "overlineThickness",
  paintOrder: 1,
  "paint-order": "paintOrder",
  panose1: 0,
  "panose-1": "panose1",
  pathLength: 1,
  patternContentUnits: 1,
  patternTransform: 1,
  patternUnits: 1,
  pointerEvents: 1,
  "pointer-events": "pointerEvents",
  points: 0,
  pointsAtX: 1,
  pointsAtY: 1,
  pointsAtZ: 1,
  prefix: 0,
  preserveAlpha: 1,
  preserveAspectRatio: 1,
  primitiveUnits: 1,
  property: 0,
  r: 0,
  radius: 0,
  refX: 1,
  refY: 1,
  renderingIntent: 1,
  "rendering-intent": "renderingIntent",
  repeatCount: 1,
  repeatDur: 1,
  requiredExtensions: 1,
  requiredFeatures: 1,
  resource: 0,
  restart: 0,
  result: 0,
  results: 0,
  rotate: 0,
  rx: 0,
  ry: 0,
  scale: 0,
  security: 0,
  seed: 0,
  shapeRendering: 1,
  "shape-rendering": "shapeRendering",
  slope: 0,
  spacing: 0,
  specularConstant: 1,
  specularExponent: 1,
  speed: 0,
  spreadMethod: 1,
  startOffset: 1,
  stdDeviation: 1,
  stemh: 0,
  stemv: 0,
  stitchTiles: 1,
  stopColor: 1,
  "stop-color": "stopColor",
  stopOpacity: 1,
  "stop-opacity": "stopOpacity",
  strikethroughPosition: 1,
  "strikethrough-position": "strikethroughPosition",
  strikethroughThickness: 1,
  "strikethrough-thickness": "strikethroughThickness",
  string: 0,
  stroke: 0,
  strokeDasharray: 1,
  "stroke-dasharray": "strokeDasharray",
  strokeDashoffset: 1,
  "stroke-dashoffset": "strokeDashoffset",
  strokeLinecap: 1,
  "stroke-linecap": "strokeLinecap",
  strokeLinejoin: 1,
  "stroke-linejoin": "strokeLinejoin",
  strokeMiterlimit: 1,
  "stroke-miterlimit": "strokeMiterlimit",
  strokeWidth: 1,
  "stroke-width": "strokeWidth",
  strokeOpacity: 1,
  "stroke-opacity": "strokeOpacity",
  suppressContentEditableWarning: 1,
  suppressHydrationWarning: 1,
  surfaceScale: 1,
  systemLanguage: 1,
  tableValues: 1,
  targetX: 1,
  targetY: 1,
  textAnchor: 1,
  "text-anchor": "textAnchor",
  textDecoration: 1,
  "text-decoration": "textDecoration",
  textLength: 1,
  textRendering: 1,
  "text-rendering": "textRendering",
  to: 0,
  transform: 0,
  typeof: 0,
  u1: 0,
  u2: 0,
  underlinePosition: 1,
  "underline-position": "underlinePosition",
  underlineThickness: 1,
  "underline-thickness": "underlineThickness",
  unicode: 0,
  unicodeBidi: 1,
  "unicode-bidi": "unicodeBidi",
  unicodeRange: 1,
  "unicode-range": "unicodeRange",
  unitsPerEm: 1,
  "units-per-em": "unitsPerEm",
  unselectable: 0,
  vAlphabetic: 1,
  "v-alphabetic": "vAlphabetic",
  values: 0,
  vectorEffect: 1,
  "vector-effect": "vectorEffect",
  version: 0,
  vertAdvY: 1,
  "vert-adv-y": "vertAdvY",
  vertOriginX: 1,
  "vert-origin-x": "vertOriginX",
  vertOriginY: 1,
  "vert-origin-y": "vertOriginY",
  vHanging: 1,
  "v-hanging": "vHanging",
  vIdeographic: 1,
  "v-ideographic": "vIdeographic",
  viewBox: 1,
  viewTarget: 1,
  visibility: 0,
  vMathematical: 1,
  "v-mathematical": "vMathematical",
  vocab: 0,
  widths: 0,
  wordSpacing: 1,
  "word-spacing": "wordSpacing",
  writingMode: 1,
  "writing-mode": "writingMode",
  x1: 0,
  x2: 0,
  x: 0,
  xChannelSelector: 1,
  xHeight: 1,
  "x-height": "xHeight",
  xlinkActuate: 1,
  "xlink:actuate": "xlinkActuate",
  xlinkArcrole: 1,
  "xlink:arcrole": "xlinkArcrole",
  xlinkHref: 1,
  "xlink:href": "xlinkHref",
  xlinkRole: 1,
  "xlink:role": "xlinkRole",
  xlinkShow: 1,
  "xlink:show": "xlinkShow",
  xlinkTitle: 1,
  "xlink:title": "xlinkTitle",
  xlinkType: 1,
  "xlink:type": "xlinkType",
  xmlBase: 1,
  "xml:base": "xmlBase",
  xmlLang: 1,
  "xml:lang": "xmlLang",
  xmlns: 0,
  "xml:space": "xmlSpace",
  xmlnsXlink: 1,
  "xmlns:xlink": "xmlnsXlink",
  xmlSpace: 1,
  y1: 0,
  y2: 0,
  y: 0,
  yChannelSelector: 1,
  z: 0,
  zoomAndPan: 1
};
const FH = 0, Ea = 1, Mv = 2, Dv = 3, CE = 4, zH = 5, UH = 6;
function Uee(e) {
  return co.hasOwnProperty(e) ? co[e] : null;
}
function Lo(e, t, n, r, o, i, a) {
  this.acceptsBooleans = t === Mv || t === Dv || t === CE, this.attributeName = r, this.attributeNamespace = o, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = i, this.removeEmptyString = a;
}
const co = {}, $ee = [
  "children",
  "dangerouslySetInnerHTML",
  // TODO: This prevents the assignment of defaultValue to regular
  // elements (not just inputs). Now that ReactDOMInput assigns to the
  // defaultValue property -- do we need this?
  "defaultValue",
  "defaultChecked",
  "innerHTML",
  "suppressContentEditableWarning",
  "suppressHydrationWarning",
  "style"
];
$ee.forEach((e) => {
  co[e] = new Lo(
    e,
    FH,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"]
].forEach(([e, t]) => {
  co[e] = new Lo(
    e,
    Ea,
    !1,
    // mustUseProperty
    t,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["contentEditable", "draggable", "spellCheck", "value"].forEach((e) => {
  co[e] = new Lo(
    e,
    Mv,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha"
].forEach((e) => {
  co[e] = new Lo(
    e,
    Mv,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "allowFullScreen",
  "async",
  // Note: there is a special case that prevents it from being written to the DOM
  // on the client side because the browsers are inconsistent. Instead we call focus().
  "autoFocus",
  "autoPlay",
  "controls",
  "default",
  "defer",
  "disabled",
  "disablePictureInPicture",
  "disableRemotePlayback",
  "formNoValidate",
  "hidden",
  "loop",
  "noModule",
  "noValidate",
  "open",
  "playsInline",
  "readOnly",
  "required",
  "reversed",
  "scoped",
  "seamless",
  // Microdata
  "itemScope"
].forEach((e) => {
  co[e] = new Lo(
    e,
    Dv,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "checked",
  // Note: `option.selected` is not updated if `select.multiple` is
  // disabled with `removeAttribute`. We have special logic for handling this.
  "multiple",
  "muted",
  "selected"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  co[e] = new Lo(
    e,
    Dv,
    !0,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "capture",
  "download"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  co[e] = new Lo(
    e,
    CE,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "cols",
  "rows",
  "size",
  "span"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  co[e] = new Lo(
    e,
    UH,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["rowSpan", "start"].forEach((e) => {
  co[e] = new Lo(
    e,
    zH,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const xE = /[\-\:]([a-z])/g, OE = (e) => e[1].toUpperCase();
[
  "accent-height",
  "alignment-baseline",
  "arabic-form",
  "baseline-shift",
  "cap-height",
  "clip-path",
  "clip-rule",
  "color-interpolation",
  "color-interpolation-filters",
  "color-profile",
  "color-rendering",
  "dominant-baseline",
  "enable-background",
  "fill-opacity",
  "fill-rule",
  "flood-color",
  "flood-opacity",
  "font-family",
  "font-size",
  "font-size-adjust",
  "font-stretch",
  "font-style",
  "font-variant",
  "font-weight",
  "glyph-name",
  "glyph-orientation-horizontal",
  "glyph-orientation-vertical",
  "horiz-adv-x",
  "horiz-origin-x",
  "image-rendering",
  "letter-spacing",
  "lighting-color",
  "marker-end",
  "marker-mid",
  "marker-start",
  "overline-position",
  "overline-thickness",
  "paint-order",
  "panose-1",
  "pointer-events",
  "rendering-intent",
  "shape-rendering",
  "stop-color",
  "stop-opacity",
  "strikethrough-position",
  "strikethrough-thickness",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "text-anchor",
  "text-decoration",
  "text-rendering",
  "underline-position",
  "underline-thickness",
  "unicode-bidi",
  "unicode-range",
  "units-per-em",
  "v-alphabetic",
  "v-hanging",
  "v-ideographic",
  "v-mathematical",
  "vector-effect",
  "vert-adv-y",
  "vert-origin-x",
  "vert-origin-y",
  "word-spacing",
  "writing-mode",
  "xmlns:xlink",
  "x-height"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(xE, OE);
  co[t] = new Lo(
    t,
    Ea,
    !1,
    // mustUseProperty
    e,
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xlink:actuate",
  "xlink:arcrole",
  "xlink:role",
  "xlink:show",
  "xlink:title",
  "xlink:type"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(xE, OE);
  co[t] = new Lo(
    t,
    Ea,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/1999/xlink",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xml:base",
  "xml:lang",
  "xml:space"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(xE, OE);
  co[t] = new Lo(
    t,
    Ea,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/XML/1998/namespace",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["tabIndex", "crossOrigin"].forEach((e) => {
  co[e] = new Lo(
    e,
    Ea,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const Hee = "xlinkHref";
co[Hee] = new Lo(
  "xlinkHref",
  Ea,
  !1,
  // mustUseProperty
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  // sanitizeURL
  !1
  // removeEmptyString
);
["src", "href", "action", "formAction"].forEach((e) => {
  co[e] = new Lo(
    e,
    Ea,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !0,
    // sanitizeURL
    !0
    // removeEmptyString
  );
});
const {
  CAMELCASE: Wee,
  SAME: Vee,
  possibleStandardNames: lS
} = Sv, qee = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", Zee = qee + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", Gee = RegExp.prototype.test.bind(
  // eslint-disable-next-line no-misleading-character-class
  new RegExp("^(data|aria)-[" + Zee + "]*$")
), Xee = Object.keys(
  lS
).reduce((e, t) => {
  const n = lS[t];
  return n === Vee ? e[t] = t : n === Wee ? e[t.toLowerCase()] = t : e[t] = n, e;
}, {});
ji.BOOLEAN = Dv;
ji.BOOLEANISH_STRING = Mv;
ji.NUMERIC = zH;
ji.OVERLOADED_BOOLEAN = CE;
ji.POSITIVE_NUMERIC = UH;
ji.RESERVED = FH;
ji.STRING = Ea;
ji.getPropertyInfo = Uee;
ji.isCustomAttribute = Gee;
ji.possibleStandardNames = Xee;
var EE = {}, kE = {}, uS = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, Kee = /\n/g, Yee = /^\s*/, Jee = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, Qee = /^:\s*/, ete = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, tte = /^[;\s]*/, nte = /^\s+|\s+$/g, rte = `
`, cS = "/", pS = "*", ol = "", ote = "comment", ite = "declaration", ste = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e) return [];
  t = t || {};
  var n = 1, r = 1;
  function o(f) {
    var m = f.match(Kee);
    m && (n += m.length);
    var g = f.lastIndexOf(rte);
    r = ~g ? f.length - g : r + f.length;
  }
  function i() {
    var f = { line: n, column: r };
    return function(m) {
      return m.position = new a(f), u(), m;
    };
  }
  function a(f) {
    this.start = f, this.end = { line: n, column: r }, this.source = t.source;
  }
  a.prototype.content = e;
  function s(f) {
    var m = new Error(
      t.source + ":" + n + ":" + r + ": " + f
    );
    if (m.reason = f, m.filename = t.source, m.line = n, m.column = r, m.source = e, !t.silent) throw m;
  }
  function l(f) {
    var m = f.exec(e);
    if (m) {
      var g = m[0];
      return o(g), e = e.slice(g.length), m;
    }
  }
  function u() {
    l(Yee);
  }
  function c(f) {
    var m;
    for (f = f || []; m = p(); )
      m !== !1 && f.push(m);
    return f;
  }
  function p() {
    var f = i();
    if (!(cS != e.charAt(0) || pS != e.charAt(1))) {
      for (var m = 2; ol != e.charAt(m) && (pS != e.charAt(m) || cS != e.charAt(m + 1)); )
        ++m;
      if (m += 2, ol === e.charAt(m - 1))
        return s("End of comment missing");
      var g = e.slice(2, m - 2);
      return r += 2, o(g), e = e.slice(m), r += 2, f({
        type: ote,
        comment: g
      });
    }
  }
  function d() {
    var f = i(), m = l(Jee);
    if (m) {
      if (p(), !l(Qee)) return s("property missing ':'");
      var g = l(ete), E = f({
        type: ite,
        property: dS(m[0].replace(uS, ol)),
        value: g ? dS(g[0].replace(uS, ol)) : ol
      });
      return l(tte), E;
    }
  }
  function h() {
    var f = [];
    c(f);
    for (var m; m = d(); )
      m !== !1 && (f.push(m), c(f));
    return f;
  }
  return u(), h();
};
function dS(e) {
  return e ? e.replace(nte, ol) : ol;
}
var ate = $n && $n.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(kE, "__esModule", { value: !0 });
kE.default = ute;
var lte = ate(ste);
function ute(e, t) {
  var n = null;
  if (!e || typeof e != "string")
    return n;
  var r = (0, lte.default)(e), o = typeof t == "function";
  return r.forEach(function(i) {
    if (i.type === "declaration") {
      var a = i.property, s = i.value;
      o ? t(a, s, i) : s && (n = n || {}, n[a] = s);
    }
  }), n;
}
var Tv = {};
Object.defineProperty(Tv, "__esModule", { value: !0 });
Tv.camelCase = void 0;
var cte = /^--[a-zA-Z0-9_-]+$/, pte = /-([a-z])/g, dte = /^[^-]+$/, fte = /^-(webkit|moz|ms|o|khtml)-/, hte = /^-(ms)-/, gte = function(e) {
  return !e || dte.test(e) || cte.test(e);
}, mte = function(e, t) {
  return t.toUpperCase();
}, fS = function(e, t) {
  return "".concat(t, "-");
}, vte = function(e, t) {
  return t === void 0 && (t = {}), gte(e) ? e : (e = e.toLowerCase(), t.reactCompat ? e = e.replace(hte, fS) : e = e.replace(fte, fS), e.replace(pte, mte));
};
Tv.camelCase = vte;
var yte = $n && $n.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
}, bte = yte(kE), wte = Tv;
function IC(e, t) {
  var n = {};
  return !e || typeof e != "string" || (0, bte.default)(e, function(r, o) {
    r && o && (n[(0, wte.camelCase)(r, t)] = o);
  }), n;
}
IC.default = IC;
var Cte = IC;
(function(e) {
  var t = $n && $n.__importDefault || function(c) {
    return c && c.__esModule ? c : { default: c };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.returnFirstArg = e.canTextBeChildOfNode = e.ELEMENTS_WITH_NO_TEXT_CHILDREN = e.PRESERVE_CUSTOM_ATTRIBUTES = void 0, e.isCustomComponent = i, e.setStyleProp = s;
  var n = ke, r = t(Cte), o = /* @__PURE__ */ new Set([
    "annotation-xml",
    "color-profile",
    "font-face",
    "font-face-src",
    "font-face-uri",
    "font-face-format",
    "font-face-name",
    "missing-glyph"
  ]);
  function i(c, p) {
    return c.includes("-") ? !o.has(c) : !!(p && typeof p.is == "string");
  }
  var a = {
    reactCompat: !0
  };
  function s(c, p) {
    if (typeof c == "string") {
      if (!c.trim()) {
        p.style = {};
        return;
      }
      try {
        p.style = (0, r.default)(c, a);
      } catch {
        p.style = {};
      }
    }
  }
  e.PRESERVE_CUSTOM_ATTRIBUTES = Number(n.version.split(".")[0]) >= 16, e.ELEMENTS_WITH_NO_TEXT_CHILDREN = /* @__PURE__ */ new Set([
    "tr",
    "tbody",
    "thead",
    "tfoot",
    "colgroup",
    "table",
    "head",
    "html",
    "frameset"
  ]);
  var l = function(c) {
    return !e.ELEMENTS_WITH_NO_TEXT_CHILDREN.has(c.name);
  };
  e.canTextBeChildOfNode = l;
  var u = function(c) {
    return c;
  };
  e.returnFirstArg = u;
})(EE);
Object.defineProperty(Pv, "__esModule", { value: !0 });
Pv.default = kte;
var vc = ji, hS = EE, xte = ["checked", "value"], Ote = ["input", "select", "textarea"], Ete = {
  reset: !0,
  submit: !0
};
function kte(e, t) {
  e === void 0 && (e = {});
  var n = {}, r = !!(e.type && Ete[e.type]);
  for (var o in e) {
    var i = e[o];
    if ((0, vc.isCustomAttribute)(o)) {
      n[o] = i;
      continue;
    }
    var a = o.toLowerCase(), s = gS(a);
    if (s) {
      var l = (0, vc.getPropertyInfo)(s);
      switch (xte.includes(s) && Ote.includes(t) && !r && (s = gS("default" + a)), n[s] = i, l && l.type) {
        case vc.BOOLEAN:
          n[s] = !0;
          break;
        case vc.OVERLOADED_BOOLEAN:
          i === "" && (n[s] = !0);
          break;
      }
      continue;
    }
    hS.PRESERVE_CUSTOM_ATTRIBUTES && (n[o] = i);
  }
  return (0, hS.setStyleProp)(e.style, n), n;
}
function gS(e) {
  return vc.possibleStandardNames[e];
}
var LE = {}, Lte = $n && $n.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(LE, "__esModule", { value: !0 });
LE.default = $H;
var db = ke, _te = Lte(Pv), Mc = EE, Pte = {
  cloneElement: db.cloneElement,
  createElement: db.createElement,
  isValidElement: db.isValidElement
};
function $H(e, t) {
  t === void 0 && (t = {});
  for (var n = [], r = typeof t.replace == "function", o = t.transform || Mc.returnFirstArg, i = t.library || Pte, a = i.cloneElement, s = i.createElement, l = i.isValidElement, u = e.length, c = 0; c < u; c++) {
    var p = e[c];
    if (r) {
      var d = t.replace(p, c);
      if (l(d)) {
        u > 1 && (d = a(d, {
          key: d.key || c
        })), n.push(o(d, p, c));
        continue;
      }
    }
    if (p.type === "text") {
      var h = !p.data.trim().length;
      if (h && p.parent && !(0, Mc.canTextBeChildOfNode)(p.parent) || t.trim && h)
        continue;
      n.push(o(p.data, p, c));
      continue;
    }
    var f = p, m = {};
    Ste(f) ? ((0, Mc.setStyleProp)(f.attribs.style, f.attribs), m = f.attribs) : f.attribs && (m = (0, _te.default)(f.attribs, f.name));
    var g = void 0;
    switch (p.type) {
      case "script":
      case "style":
        p.children[0] && (m.dangerouslySetInnerHTML = {
          __html: p.children[0].data
        });
        break;
      case "tag":
        p.name === "textarea" && p.children[0] ? m.defaultValue = p.children[0].data : p.children && p.children.length && (g = $H(p.children, t));
        break;
      default:
        continue;
    }
    u > 1 && (m.key = c), n.push(o(s(p.name, m, g), p, c));
  }
  return n.length === 1 ? n[0] : n;
}
function Ste(e) {
  return Mc.PRESERVE_CUSTOM_ATTRIBUTES && e.type === "tag" && (0, Mc.isCustomComponent)(e.name, e.attribs);
}
(function(e) {
  var t = $n && $n.__importDefault || function(l) {
    return l && l.__esModule ? l : { default: l };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.htmlToDOM = e.domToReact = e.attributesToProps = e.Text = e.ProcessingInstruction = e.Element = e.Comment = void 0, e.default = s;
  var n = t(gE);
  e.htmlToDOM = n.default;
  var r = t(Pv);
  e.attributesToProps = r.default;
  var o = t(LE);
  e.domToReact = o.default;
  var i = vE;
  Object.defineProperty(e, "Comment", { enumerable: !0, get: function() {
    return i.Comment;
  } }), Object.defineProperty(e, "Element", { enumerable: !0, get: function() {
    return i.Element;
  } }), Object.defineProperty(e, "ProcessingInstruction", { enumerable: !0, get: function() {
    return i.ProcessingInstruction;
  } }), Object.defineProperty(e, "Text", { enumerable: !0, get: function() {
    return i.Text;
  } });
  var a = { lowerCaseAttributeNames: !1 };
  function s(l, u) {
    if (typeof l != "string")
      throw new TypeError("First argument must be a string");
    return l ? (0, o.default)((0, n.default)(l, (u == null ? void 0 : u.htmlparser2) || a), u) : [];
  }
})(xH);
const Mte = /* @__PURE__ */ XQ(xH);
Mte.default;
var Hn = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Dte(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var RC = { exports: {} }, Uu = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var mS;
function Tte() {
  if (mS) return Uu;
  mS = 1;
  var e = ke, t = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, o = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, i = { key: !0, ref: !0, __self: !0, __source: !0 };
  function a(s, l, u) {
    var c, p = {}, d = null, h = null;
    u !== void 0 && (d = "" + u), l.key !== void 0 && (d = "" + l.key), l.ref !== void 0 && (h = l.ref);
    for (c in l) r.call(l, c) && !i.hasOwnProperty(c) && (p[c] = l[c]);
    if (s && s.defaultProps) for (c in l = s.defaultProps, l) p[c] === void 0 && (p[c] = l[c]);
    return { $$typeof: t, type: s, key: d, ref: h, props: p, _owner: o.current };
  }
  return Uu.Fragment = n, Uu.jsx = a, Uu.jsxs = a, Uu;
}
var sf = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var vS;
function jte() {
  return vS || (vS = 1, process.env.NODE_ENV !== "production" && function() {
    var e = ke, t = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), a = Symbol.for("react.provider"), s = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), c = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), d = Symbol.for("react.lazy"), h = Symbol.for("react.offscreen"), f = Symbol.iterator, m = "@@iterator";
    function g(b) {
      if (b === null || typeof b != "object")
        return null;
      var B = f && b[f] || b[m];
      return typeof B == "function" ? B : null;
    }
    var E = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function w(b) {
      {
        for (var B = arguments.length, G = new Array(B > 1 ? B - 1 : 0), ne = 1; ne < B; ne++)
          G[ne - 1] = arguments[ne];
        M("error", b, G);
      }
    }
    function M(b, B, G) {
      {
        var ne = E.ReactDebugCurrentFrame, le = ne.getStackAddendum();
        le !== "" && (B += "%s", G = G.concat([le]));
        var ce = G.map(function(ae) {
          return String(ae);
        });
        ce.unshift("Warning: " + B), Function.prototype.apply.call(console[b], console, ce);
      }
    }
    var x = !1, y = !1, C = !1, P = !1, F = !1, L;
    L = Symbol.for("react.module.reference");
    function N(b) {
      return !!(typeof b == "string" || typeof b == "function" || b === r || b === i || F || b === o || b === u || b === c || P || b === h || x || y || C || typeof b == "object" && b !== null && (b.$$typeof === d || b.$$typeof === p || b.$$typeof === a || b.$$typeof === s || b.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      b.$$typeof === L || b.getModuleId !== void 0));
    }
    function I(b, B, G) {
      var ne = b.displayName;
      if (ne)
        return ne;
      var le = B.displayName || B.name || "";
      return le !== "" ? G + "(" + le + ")" : G;
    }
    function H(b) {
      return b.displayName || "Context";
    }
    function V(b) {
      if (b == null)
        return null;
      if (typeof b.tag == "number" && w("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof b == "function")
        return b.displayName || b.name || null;
      if (typeof b == "string")
        return b;
      switch (b) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case i:
          return "Profiler";
        case o:
          return "StrictMode";
        case u:
          return "Suspense";
        case c:
          return "SuspenseList";
      }
      if (typeof b == "object")
        switch (b.$$typeof) {
          case s:
            var B = b;
            return H(B) + ".Consumer";
          case a:
            var G = b;
            return H(G._context) + ".Provider";
          case l:
            return I(b, b.render, "ForwardRef");
          case p:
            var ne = b.displayName || null;
            return ne !== null ? ne : V(b.type) || "Memo";
          case d: {
            var le = b, ce = le._payload, ae = le._init;
            try {
              return V(ae(ce));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var z = Object.assign, q = 0, K, J, te, ee, _, D, $;
    function S() {
    }
    S.__reactDisabledLog = !0;
    function W() {
      {
        if (q === 0) {
          K = console.log, J = console.info, te = console.warn, ee = console.error, _ = console.group, D = console.groupCollapsed, $ = console.groupEnd;
          var b = {
            configurable: !0,
            enumerable: !0,
            value: S,
            writable: !0
          };
          Object.defineProperties(console, {
            info: b,
            log: b,
            warn: b,
            error: b,
            group: b,
            groupCollapsed: b,
            groupEnd: b
          });
        }
        q++;
      }
    }
    function O() {
      {
        if (q--, q === 0) {
          var b = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: z({}, b, {
              value: K
            }),
            info: z({}, b, {
              value: J
            }),
            warn: z({}, b, {
              value: te
            }),
            error: z({}, b, {
              value: ee
            }),
            group: z({}, b, {
              value: _
            }),
            groupCollapsed: z({}, b, {
              value: D
            }),
            groupEnd: z({}, b, {
              value: $
            })
          });
        }
        q < 0 && w("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var T = E.ReactCurrentDispatcher, U;
    function j(b, B, G) {
      {
        if (U === void 0)
          try {
            throw Error();
          } catch (le) {
            var ne = le.stack.trim().match(/\n( *(at )?)/);
            U = ne && ne[1] || "";
          }
        return `
` + U + b;
      }
    }
    var Z = !1, A;
    {
      var Q = typeof WeakMap == "function" ? WeakMap : Map;
      A = new Q();
    }
    function R(b, B) {
      if (!b || Z)
        return "";
      {
        var G = A.get(b);
        if (G !== void 0)
          return G;
      }
      var ne;
      Z = !0;
      var le = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var ce;
      ce = T.current, T.current = null, W();
      try {
        if (B) {
          var ae = function() {
            throw Error();
          };
          if (Object.defineProperty(ae.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(ae, []);
            } catch (Ne) {
              ne = Ne;
            }
            Reflect.construct(b, [], ae);
          } else {
            try {
              ae.call();
            } catch (Ne) {
              ne = Ne;
            }
            b.call(ae.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Ne) {
            ne = Ne;
          }
          b();
        }
      } catch (Ne) {
        if (Ne && ne && typeof Ne.stack == "string") {
          for (var ie = Ne.stack.split(`
`), Me = ne.stack.split(`
`), he = ie.length - 1, me = Me.length - 1; he >= 1 && me >= 0 && ie[he] !== Me[me]; )
            me--;
          for (; he >= 1 && me >= 0; he--, me--)
            if (ie[he] !== Me[me]) {
              if (he !== 1 || me !== 1)
                do
                  if (he--, me--, me < 0 || ie[he] !== Me[me]) {
                    var qe = `
` + ie[he].replace(" at new ", " at ");
                    return b.displayName && qe.includes("<anonymous>") && (qe = qe.replace("<anonymous>", b.displayName)), typeof b == "function" && A.set(b, qe), qe;
                  }
                while (he >= 1 && me >= 0);
              break;
            }
        }
      } finally {
        Z = !1, T.current = ce, O(), Error.prepareStackTrace = le;
      }
      var Lt = b ? b.displayName || b.name : "", gt = Lt ? j(Lt) : "";
      return typeof b == "function" && A.set(b, gt), gt;
    }
    function ue(b, B, G) {
      return R(b, !1);
    }
    function fe(b) {
      var B = b.prototype;
      return !!(B && B.isReactComponent);
    }
    function oe(b, B, G) {
      if (b == null)
        return "";
      if (typeof b == "function")
        return R(b, fe(b));
      if (typeof b == "string")
        return j(b);
      switch (b) {
        case u:
          return j("Suspense");
        case c:
          return j("SuspenseList");
      }
      if (typeof b == "object")
        switch (b.$$typeof) {
          case l:
            return ue(b.render);
          case p:
            return oe(b.type, B, G);
          case d: {
            var ne = b, le = ne._payload, ce = ne._init;
            try {
              return oe(ce(le), B, G);
            } catch {
            }
          }
        }
      return "";
    }
    var Re = Object.prototype.hasOwnProperty, He = {}, Ve = E.ReactDebugCurrentFrame;
    function ze(b) {
      if (b) {
        var B = b._owner, G = oe(b.type, b._source, B ? B.type : null);
        Ve.setExtraStackFrame(G);
      } else
        Ve.setExtraStackFrame(null);
    }
    function et(b, B, G, ne, le) {
      {
        var ce = Function.call.bind(Re);
        for (var ae in b)
          if (ce(b, ae)) {
            var ie = void 0;
            try {
              if (typeof b[ae] != "function") {
                var Me = Error((ne || "React class") + ": " + G + " type `" + ae + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof b[ae] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw Me.name = "Invariant Violation", Me;
              }
              ie = b[ae](B, ae, ne, G, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (he) {
              ie = he;
            }
            ie && !(ie instanceof Error) && (ze(le), w("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", ne || "React class", G, ae, typeof ie), ze(null)), ie instanceof Error && !(ie.message in He) && (He[ie.message] = !0, ze(le), w("Failed %s type: %s", G, ie.message), ze(null));
          }
      }
    }
    var Ge = Array.isArray;
    function Pe(b) {
      return Ge(b);
    }
    function Ye(b) {
      {
        var B = typeof Symbol == "function" && Symbol.toStringTag, G = B && b[Symbol.toStringTag] || b.constructor.name || "Object";
        return G;
      }
    }
    function it(b) {
      try {
        return _e(b), !1;
      } catch {
        return !0;
      }
    }
    function _e(b) {
      return "" + b;
    }
    function Se(b) {
      if (it(b))
        return w("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Ye(b)), _e(b);
    }
    var Ke = E.ReactCurrentOwner, We = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, Ue, nt;
    function Ie(b) {
      if (Re.call(b, "ref")) {
        var B = Object.getOwnPropertyDescriptor(b, "ref").get;
        if (B && B.isReactWarning)
          return !1;
      }
      return b.ref !== void 0;
    }
    function xt(b) {
      if (Re.call(b, "key")) {
        var B = Object.getOwnPropertyDescriptor(b, "key").get;
        if (B && B.isReactWarning)
          return !1;
      }
      return b.key !== void 0;
    }
    function ot(b, B) {
      typeof b.ref == "string" && Ke.current;
    }
    function st(b, B) {
      {
        var G = function() {
          Ue || (Ue = !0, w("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", B));
        };
        G.isReactWarning = !0, Object.defineProperty(b, "key", {
          get: G,
          configurable: !0
        });
      }
    }
    function lt(b, B) {
      {
        var G = function() {
          nt || (nt = !0, w("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", B));
        };
        G.isReactWarning = !0, Object.defineProperty(b, "ref", {
          get: G,
          configurable: !0
        });
      }
    }
    var Ot = function(b, B, G, ne, le, ce, ae) {
      var ie = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: b,
        key: B,
        ref: G,
        props: ae,
        // Record the component responsible for creating this element.
        _owner: ce
      };
      return ie._store = {}, Object.defineProperty(ie._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(ie, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ne
      }), Object.defineProperty(ie, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: le
      }), Object.freeze && (Object.freeze(ie.props), Object.freeze(ie)), ie;
    };
    function ut(b, B, G, ne, le) {
      {
        var ce, ae = {}, ie = null, Me = null;
        G !== void 0 && (Se(G), ie = "" + G), xt(B) && (Se(B.key), ie = "" + B.key), Ie(B) && (Me = B.ref, ot(B));
        for (ce in B)
          Re.call(B, ce) && !We.hasOwnProperty(ce) && (ae[ce] = B[ce]);
        if (b && b.defaultProps) {
          var he = b.defaultProps;
          for (ce in he)
            ae[ce] === void 0 && (ae[ce] = he[ce]);
        }
        if (ie || Me) {
          var me = typeof b == "function" ? b.displayName || b.name || "Unknown" : b;
          ie && st(ae, me), Me && lt(ae, me);
        }
        return Ot(b, ie, Me, le, ne, Ke.current, ae);
      }
    }
    var ct = E.ReactCurrentOwner, tt = E.ReactDebugCurrentFrame;
    function Xe(b) {
      if (b) {
        var B = b._owner, G = oe(b.type, b._source, B ? B.type : null);
        tt.setExtraStackFrame(G);
      } else
        tt.setExtraStackFrame(null);
    }
    var Et;
    Et = !1;
    function kt(b) {
      return typeof b == "object" && b !== null && b.$$typeof === t;
    }
    function pt() {
      {
        if (ct.current) {
          var b = V(ct.current.type);
          if (b)
            return `

Check the render method of \`` + b + "`.";
        }
        return "";
      }
    }
    function kn(b) {
      return "";
    }
    var dt = {};
    function Ln(b) {
      {
        var B = pt();
        if (!B) {
          var G = typeof b == "string" ? b : b.displayName || b.name;
          G && (B = `

Check the top-level render call using <` + G + ">.");
        }
        return B;
      }
    }
    function ft(b, B) {
      {
        if (!b._store || b._store.validated || b.key != null)
          return;
        b._store.validated = !0;
        var G = Ln(B);
        if (dt[G])
          return;
        dt[G] = !0;
        var ne = "";
        b && b._owner && b._owner !== ct.current && (ne = " It was passed a child from " + V(b._owner.type) + "."), Xe(b), w('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', G, ne), Xe(null);
      }
    }
    function rn(b, B) {
      {
        if (typeof b != "object")
          return;
        if (Pe(b))
          for (var G = 0; G < b.length; G++) {
            var ne = b[G];
            kt(ne) && ft(ne, B);
          }
        else if (kt(b))
          b._store && (b._store.validated = !0);
        else if (b) {
          var le = g(b);
          if (typeof le == "function" && le !== b.entries)
            for (var ce = le.call(b), ae; !(ae = ce.next()).done; )
              kt(ae.value) && ft(ae.value, B);
        }
      }
    }
    function br(b) {
      {
        var B = b.type;
        if (B == null || typeof B == "string")
          return;
        var G;
        if (typeof B == "function")
          G = B.propTypes;
        else if (typeof B == "object" && (B.$$typeof === l || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        B.$$typeof === p))
          G = B.propTypes;
        else
          return;
        if (G) {
          var ne = V(B);
          et(G, b.props, "prop", ne, b);
        } else if (B.PropTypes !== void 0 && !Et) {
          Et = !0;
          var le = V(B);
          w("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", le || "Unknown");
        }
        typeof B.getDefaultProps == "function" && !B.getDefaultProps.isReactClassApproved && w("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function ht(b) {
      {
        for (var B = Object.keys(b.props), G = 0; G < B.length; G++) {
          var ne = B[G];
          if (ne !== "children" && ne !== "key") {
            Xe(b), w("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", ne), Xe(null);
            break;
          }
        }
        b.ref !== null && (Xe(b), w("Invalid attribute `ref` supplied to `React.Fragment`."), Xe(null));
      }
    }
    var re = {};
    function eo(b, B, G, ne, le, ce) {
      {
        var ae = N(b);
        if (!ae) {
          var ie = "";
          (b === void 0 || typeof b == "object" && b !== null && Object.keys(b).length === 0) && (ie += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var Me = kn();
          Me ? ie += Me : ie += pt();
          var he;
          b === null ? he = "null" : Pe(b) ? he = "array" : b !== void 0 && b.$$typeof === t ? (he = "<" + (V(b.type) || "Unknown") + " />", ie = " Did you accidentally export a JSX literal instead of a component?") : he = typeof b, w("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", he, ie);
        }
        var me = ut(b, B, G, le, ce);
        if (me == null)
          return me;
        if (ae) {
          var qe = B.children;
          if (qe !== void 0)
            if (ne)
              if (Pe(qe)) {
                for (var Lt = 0; Lt < qe.length; Lt++)
                  rn(qe[Lt], b);
                Object.freeze && Object.freeze(qe);
              } else
                w("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              rn(qe, b);
        }
        if (Re.call(B, "key")) {
          var gt = V(b), Ne = Object.keys(B).filter(function(_i) {
            return _i !== "key";
          }), wr = Ne.length > 0 ? "{key: someKey, " + Ne.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!re[gt + wr]) {
            var Li = Ne.length > 0 ? "{" + Ne.join(": ..., ") + ": ...}" : "{}";
            w(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, wr, gt, Li, gt), re[gt + wr] = !0;
          }
        }
        return b === r ? ht(me) : br(me), me;
      }
    }
    function xi(b, B, G) {
      return eo(b, B, G, !0);
    }
    function Oi(b, B, G) {
      return eo(b, B, G, !1);
    }
    var Ei = Oi, ki = xi;
    sf.Fragment = r, sf.jsx = Ei, sf.jsxs = ki;
  }()), sf;
}
process.env.NODE_ENV === "production" ? RC.exports = Tte() : RC.exports = jte();
var io = RC.exports;
Ze({});
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function yS(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function vo(e) {
  var t, n;
  return yS(e) === !1 ? !1 : (t = e.constructor, t === void 0 ? !0 : (n = t.prototype, !(yS(n) === !1 || n.hasOwnProperty("isPrototypeOf") === !1)));
}
var HH = Symbol.for("immer-nothing"), bS = Symbol.for("immer-draftable"), ui = Symbol.for("immer-state"), Ate = process.env.NODE_ENV !== "production" ? [
  // All error codes, starting by 0:
  function(e) {
    return `The plugin for '${e}' has not been loaded into Immer. To enable the plugin, import and call \`enable${e}()\` when initializing your application.`;
  },
  function(e) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${e}'`;
  },
  "This object has been frozen and should not be mutated",
  function(e) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + e;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(e) {
    return `'current' expects a draft, got: ${e}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(e) {
    return `'original' expects a draft, got: ${e}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function Bo(e, ...t) {
  if (process.env.NODE_ENV !== "production") {
    const n = Ate[e], r = typeof n == "function" ? n.apply(null, t) : n;
    throw new Error(`[Immer] ${r}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var lu = Object.getPrototypeOf;
function jl(e) {
  return !!e && !!e[ui];
}
function Al(e) {
  var t;
  return e ? WH(e) || Array.isArray(e) || !!e[bS] || !!((t = e.constructor) != null && t[bS]) || Av(e) || Bv(e) : !1;
}
var Bte = Object.prototype.constructor.toString();
function WH(e) {
  if (!e || typeof e != "object")
    return !1;
  const t = lu(e);
  if (t === null)
    return !0;
  const n = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
  return n === Object ? !0 : typeof n == "function" && Function.toString.call(n) === Bte;
}
function dg(e, t) {
  jv(e) === 0 ? Reflect.ownKeys(e).forEach((n) => {
    t(n, e[n], e);
  }) : e.forEach((n, r) => t(r, n, e));
}
function jv(e) {
  const t = e[ui];
  return t ? t.type_ : Array.isArray(e) ? 1 : Av(e) ? 2 : Bv(e) ? 3 : 0;
}
function NC(e, t) {
  return jv(e) === 2 ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t);
}
function VH(e, t, n) {
  const r = jv(e);
  r === 2 ? e.set(t, n) : r === 3 ? e.add(n) : e[t] = n;
}
function Ite(e, t) {
  return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && t !== t;
}
function Av(e) {
  return e instanceof Map;
}
function Bv(e) {
  return e instanceof Set;
}
function Ja(e) {
  return e.copy_ || e.base_;
}
function FC(e, t) {
  if (Av(e))
    return new Map(e);
  if (Bv(e))
    return new Set(e);
  if (Array.isArray(e))
    return Array.prototype.slice.call(e);
  const n = WH(e);
  if (t === !0 || t === "class_only" && !n) {
    const r = Object.getOwnPropertyDescriptors(e);
    delete r[ui];
    let o = Reflect.ownKeys(r);
    for (let i = 0; i < o.length; i++) {
      const a = o[i], s = r[a];
      s.writable === !1 && (s.writable = !0, s.configurable = !0), (s.get || s.set) && (r[a] = {
        configurable: !0,
        writable: !0,
        // could live with !!desc.set as well here...
        enumerable: s.enumerable,
        value: e[a]
      });
    }
    return Object.create(lu(e), r);
  } else {
    const r = lu(e);
    if (r !== null && n)
      return { ...e };
    const o = Object.create(r);
    return Object.assign(o, e);
  }
}
function _E(e, t = !1) {
  return Iv(e) || jl(e) || !Al(e) || (jv(e) > 1 && (e.set = e.add = e.clear = e.delete = Rte), Object.freeze(e), t && Object.entries(e).forEach(([n, r]) => _E(r, !0))), e;
}
function Rte() {
  Bo(2);
}
function Iv(e) {
  return Object.isFrozen(e);
}
var Nte = {};
function Bl(e) {
  const t = Nte[e];
  return t || Bo(0, e), t;
}
var bp;
function qH() {
  return bp;
}
function Fte(e, t) {
  return {
    drafts_: [],
    parent_: e,
    immer_: t,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0
  };
}
function wS(e, t) {
  t && (Bl("Patches"), e.patches_ = [], e.inversePatches_ = [], e.patchListener_ = t);
}
function zC(e) {
  UC(e), e.drafts_.forEach(zte), e.drafts_ = null;
}
function UC(e) {
  e === bp && (bp = e.parent_);
}
function CS(e) {
  return bp = Fte(bp, e);
}
function zte(e) {
  const t = e[ui];
  t.type_ === 0 || t.type_ === 1 ? t.revoke_() : t.revoked_ = !0;
}
function xS(e, t) {
  t.unfinalizedDrafts_ = t.drafts_.length;
  const n = t.drafts_[0];
  return e !== void 0 && e !== n ? (n[ui].modified_ && (zC(t), Bo(4)), Al(e) && (e = fg(t, e), t.parent_ || hg(t, e)), t.patches_ && Bl("Patches").generateReplacementPatches_(
    n[ui].base_,
    e,
    t.patches_,
    t.inversePatches_
  )) : e = fg(t, n, []), zC(t), t.patches_ && t.patchListener_(t.patches_, t.inversePatches_), e !== HH ? e : void 0;
}
function fg(e, t, n) {
  if (Iv(t))
    return t;
  const r = t[ui];
  if (!r)
    return dg(
      t,
      (o, i) => OS(e, r, t, o, i, n)
    ), t;
  if (r.scope_ !== e)
    return t;
  if (!r.modified_)
    return hg(e, r.base_, !0), r.base_;
  if (!r.finalized_) {
    r.finalized_ = !0, r.scope_.unfinalizedDrafts_--;
    const o = r.copy_;
    let i = o, a = !1;
    r.type_ === 3 && (i = new Set(o), o.clear(), a = !0), dg(
      i,
      (s, l) => OS(e, r, o, s, l, n, a)
    ), hg(e, o, !1), n && e.patches_ && Bl("Patches").generatePatches_(
      r,
      n,
      e.patches_,
      e.inversePatches_
    );
  }
  return r.copy_;
}
function OS(e, t, n, r, o, i, a) {
  if (process.env.NODE_ENV !== "production" && o === n && Bo(5), jl(o)) {
    const s = i && t && t.type_ !== 3 && // Set objects are atomic since they have no keys.
    !NC(t.assigned_, r) ? i.concat(r) : void 0, l = fg(e, o, s);
    if (VH(n, r, l), jl(l))
      e.canAutoFreeze_ = !1;
    else
      return;
  } else a && n.add(o);
  if (Al(o) && !Iv(o)) {
    if (!e.immer_.autoFreeze_ && e.unfinalizedDrafts_ < 1)
      return;
    fg(e, o), (!t || !t.scope_.parent_) && typeof r != "symbol" && Object.prototype.propertyIsEnumerable.call(n, r) && hg(e, o);
  }
}
function hg(e, t, n = !1) {
  !e.parent_ && e.immer_.autoFreeze_ && e.canAutoFreeze_ && _E(t, n);
}
function Ute(e, t) {
  const n = Array.isArray(e), r = {
    type_: n ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: t ? t.scope_ : qH(),
    // True for both shallow and deep changes.
    modified_: !1,
    // Used during finalization.
    finalized_: !1,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: t,
    // The base state.
    base_: e,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: !1
  };
  let o = r, i = PE;
  n && (o = [r], i = wp);
  const { revoke: a, proxy: s } = Proxy.revocable(o, i);
  return r.draft_ = s, r.revoke_ = a, s;
}
var PE = {
  get(e, t) {
    if (t === ui)
      return e;
    const n = Ja(e);
    if (!NC(n, t))
      return $te(e, n, t);
    const r = n[t];
    return e.finalized_ || !Al(r) ? r : r === fb(e.base_, t) ? (hb(e), e.copy_[t] = HC(r, e)) : r;
  },
  has(e, t) {
    return t in Ja(e);
  },
  ownKeys(e) {
    return Reflect.ownKeys(Ja(e));
  },
  set(e, t, n) {
    const r = ZH(Ja(e), t);
    if (r != null && r.set)
      return r.set.call(e.draft_, n), !0;
    if (!e.modified_) {
      const o = fb(Ja(e), t), i = o == null ? void 0 : o[ui];
      if (i && i.base_ === n)
        return e.copy_[t] = n, e.assigned_[t] = !1, !0;
      if (Ite(n, o) && (n !== void 0 || NC(e.base_, t)))
        return !0;
      hb(e), $C(e);
    }
    return e.copy_[t] === n && // special case: handle new props with value 'undefined'
    (n !== void 0 || t in e.copy_) || // special case: NaN
    Number.isNaN(n) && Number.isNaN(e.copy_[t]) || (e.copy_[t] = n, e.assigned_[t] = !0), !0;
  },
  deleteProperty(e, t) {
    return fb(e.base_, t) !== void 0 || t in e.base_ ? (e.assigned_[t] = !1, hb(e), $C(e)) : delete e.assigned_[t], e.copy_ && delete e.copy_[t], !0;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(e, t) {
    const n = Ja(e), r = Reflect.getOwnPropertyDescriptor(n, t);
    return r && {
      writable: !0,
      configurable: e.type_ !== 1 || t !== "length",
      enumerable: r.enumerable,
      value: n[t]
    };
  },
  defineProperty() {
    Bo(11);
  },
  getPrototypeOf(e) {
    return lu(e.base_);
  },
  setPrototypeOf() {
    Bo(12);
  }
}, wp = {};
dg(PE, (e, t) => {
  wp[e] = function() {
    return arguments[0] = arguments[0][0], t.apply(this, arguments);
  };
});
wp.deleteProperty = function(e, t) {
  return process.env.NODE_ENV !== "production" && isNaN(parseInt(t)) && Bo(13), wp.set.call(this, e, t, void 0);
};
wp.set = function(e, t, n) {
  return process.env.NODE_ENV !== "production" && t !== "length" && isNaN(parseInt(t)) && Bo(14), PE.set.call(this, e[0], t, n, e[0]);
};
function fb(e, t) {
  const n = e[ui];
  return (n ? Ja(n) : e)[t];
}
function $te(e, t, n) {
  var r;
  const o = ZH(t, n);
  return o ? "value" in o ? o.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (r = o.get) == null ? void 0 : r.call(e.draft_)
  ) : void 0;
}
function ZH(e, t) {
  if (!(t in e))
    return;
  let n = lu(e);
  for (; n; ) {
    const r = Object.getOwnPropertyDescriptor(n, t);
    if (r)
      return r;
    n = lu(n);
  }
}
function $C(e) {
  e.modified_ || (e.modified_ = !0, e.parent_ && $C(e.parent_));
}
function hb(e) {
  e.copy_ || (e.copy_ = FC(
    e.base_,
    e.scope_.immer_.useStrictShallowCopy_
  ));
}
var Hte = class {
  constructor(e) {
    this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.produce = (t, n, r) => {
      if (typeof t == "function" && typeof n != "function") {
        const i = n;
        n = t;
        const a = this;
        return function(s = i, ...l) {
          return a.produce(s, (u) => n.call(this, u, ...l));
        };
      }
      typeof n != "function" && Bo(6), r !== void 0 && typeof r != "function" && Bo(7);
      let o;
      if (Al(t)) {
        const i = CS(this), a = HC(t, void 0);
        let s = !0;
        try {
          o = n(a), s = !1;
        } finally {
          s ? zC(i) : UC(i);
        }
        return wS(i, r), xS(o, i);
      } else if (!t || typeof t != "object") {
        if (o = n(t), o === void 0 && (o = t), o === HH && (o = void 0), this.autoFreeze_ && _E(o, !0), r) {
          const i = [], a = [];
          Bl("Patches").generateReplacementPatches_(t, o, i, a), r(i, a);
        }
        return o;
      } else
        Bo(1, t);
    }, this.produceWithPatches = (t, n) => {
      if (typeof t == "function")
        return (i, ...a) => this.produceWithPatches(i, (s) => t(s, ...a));
      let r, o;
      return [this.produce(t, n, (i, a) => {
        r = i, o = a;
      }), r, o];
    }, typeof (e == null ? void 0 : e.autoFreeze) == "boolean" && this.setAutoFreeze(e.autoFreeze), typeof (e == null ? void 0 : e.useStrictShallowCopy) == "boolean" && this.setUseStrictShallowCopy(e.useStrictShallowCopy);
  }
  createDraft(e) {
    Al(e) || Bo(8), jl(e) && (e = Wte(e));
    const t = CS(this), n = HC(e, void 0);
    return n[ui].isManual_ = !0, UC(t), n;
  }
  finishDraft(e, t) {
    const n = e && e[ui];
    (!n || !n.isManual_) && Bo(9);
    const { scope_: r } = n;
    return wS(r, t), xS(void 0, r);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(e) {
    this.autoFreeze_ = e;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(e) {
    this.useStrictShallowCopy_ = e;
  }
  applyPatches(e, t) {
    let n;
    for (n = t.length - 1; n >= 0; n--) {
      const o = t[n];
      if (o.path.length === 0 && o.op === "replace") {
        e = o.value;
        break;
      }
    }
    n > -1 && (t = t.slice(n + 1));
    const r = Bl("Patches").applyPatches_;
    return jl(e) ? r(e, t) : this.produce(
      e,
      (o) => r(o, t)
    );
  }
};
function HC(e, t) {
  const n = Av(e) ? Bl("MapSet").proxyMap_(e, t) : Bv(e) ? Bl("MapSet").proxySet_(e, t) : Ute(e, t);
  return (t ? t.scope_ : qH()).drafts_.push(n), n;
}
function Wte(e) {
  return jl(e) || Bo(10, e), GH(e);
}
function GH(e) {
  if (!Al(e) || Iv(e))
    return e;
  const t = e[ui];
  let n;
  if (t) {
    if (!t.modified_)
      return t.base_;
    t.finalized_ = !0, n = FC(e, t.scope_.immer_.useStrictShallowCopy_);
  } else
    n = FC(e, !0);
  return dg(n, (r, o) => {
    VH(n, r, GH(o));
  }), t && (t.finalized_ = !1), n;
}
var ci = new Hte(), SE = ci.produce;
ci.produceWithPatches.bind(
  ci
);
ci.setAutoFreeze.bind(ci);
ci.setUseStrictShallowCopy.bind(ci);
ci.applyPatches.bind(ci);
var ES = ci.createDraft.bind(ci), kS = ci.finishDraft.bind(ci), Be = {
  ancestors(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = Be.levels(e, t);
    return n ? r = r.slice(1) : r = r.slice(0, -1), r;
  },
  common(e, t) {
    for (var n = [], r = 0; r < e.length && r < t.length; r++) {
      var o = e[r], i = t[r];
      if (o !== i)
        break;
      n.push(o);
    }
    return n;
  },
  compare(e, t) {
    for (var n = Math.min(e.length, t.length), r = 0; r < n; r++) {
      if (e[r] < t[r]) return -1;
      if (e[r] > t[r]) return 1;
    }
    return 0;
  },
  endsAfter(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return Be.equals(r, o) && i > a;
  },
  endsAt(e, t) {
    var n = e.length, r = e.slice(0, n), o = t.slice(0, n);
    return Be.equals(r, o);
  },
  endsBefore(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return Be.equals(r, o) && i < a;
  },
  equals(e, t) {
    return e.length === t.length && e.every((n, r) => n === t[r]);
  },
  hasPrevious(e) {
    return e[e.length - 1] > 0;
  },
  isAfter(e, t) {
    return Be.compare(e, t) === 1;
  },
  isAncestor(e, t) {
    return e.length < t.length && Be.compare(e, t) === 0;
  },
  isBefore(e, t) {
    return Be.compare(e, t) === -1;
  },
  isChild(e, t) {
    return e.length === t.length + 1 && Be.compare(e, t) === 0;
  },
  isCommon(e, t) {
    return e.length <= t.length && Be.compare(e, t) === 0;
  },
  isDescendant(e, t) {
    return e.length > t.length && Be.compare(e, t) === 0;
  },
  isParent(e, t) {
    return e.length + 1 === t.length && Be.compare(e, t) === 0;
  },
  isPath(e) {
    return Array.isArray(e) && (e.length === 0 || typeof e[0] == "number");
  },
  isSibling(e, t) {
    if (e.length !== t.length)
      return !1;
    var n = e.slice(0, -1), r = t.slice(0, -1), o = e[e.length - 1], i = t[t.length - 1];
    return o !== i && Be.equals(n, r);
  },
  levels(e) {
    for (var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = [], o = 0; o <= e.length; o++)
      r.push(e.slice(0, o));
    return n && r.reverse(), r;
  },
  next(e) {
    if (e.length === 0)
      throw new Error("Cannot get the next path of a root path [".concat(e, "], because it has no next index."));
    var t = e[e.length - 1];
    return e.slice(0, -1).concat(t + 1);
  },
  operationCanTransformPath(e) {
    switch (e.type) {
      case "insert_node":
      case "remove_node":
      case "merge_node":
      case "split_node":
      case "move_node":
        return !0;
      default:
        return !1;
    }
  },
  parent(e) {
    if (e.length === 0)
      throw new Error("Cannot get the parent path of the root path [".concat(e, "]."));
    return e.slice(0, -1);
  },
  previous(e) {
    if (e.length === 0)
      throw new Error("Cannot get the previous path of a root path [".concat(e, "], because it has no previous index."));
    var t = e[e.length - 1];
    if (t <= 0)
      throw new Error("Cannot get the previous path of a first child path [".concat(e, "] because it would result in a negative index."));
    return e.slice(0, -1).concat(t - 1);
  },
  relative(e, t) {
    if (!Be.isAncestor(t, e) && !Be.equals(e, t))
      throw new Error("Cannot get the relative path of [".concat(e, "] inside ancestor [").concat(t, "], because it is not above or equal to the path."));
    return e.slice(t.length);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!e) return null;
    var r = [...e], {
      affinity: o = "forward"
    } = n;
    if (e.length === 0)
      return r;
    switch (t.type) {
      case "insert_node": {
        var {
          path: i
        } = t;
        (Be.equals(i, r) || Be.endsBefore(i, r) || Be.isAncestor(i, r)) && (r[i.length - 1] += 1);
        break;
      }
      case "remove_node": {
        var {
          path: a
        } = t;
        if (Be.equals(a, r) || Be.isAncestor(a, r))
          return null;
        Be.endsBefore(a, r) && (r[a.length - 1] -= 1);
        break;
      }
      case "merge_node": {
        var {
          path: s,
          position: l
        } = t;
        Be.equals(s, r) || Be.endsBefore(s, r) ? r[s.length - 1] -= 1 : Be.isAncestor(s, r) && (r[s.length - 1] -= 1, r[s.length] += l);
        break;
      }
      case "split_node": {
        var {
          path: u,
          position: c
        } = t;
        if (Be.equals(u, r)) {
          if (o === "forward")
            r[r.length - 1] += 1;
          else if (o !== "backward") return null;
        } else Be.endsBefore(u, r) ? r[u.length - 1] += 1 : Be.isAncestor(u, r) && e[u.length] >= c && (r[u.length - 1] += 1, r[u.length] -= c);
        break;
      }
      case "move_node": {
        var {
          path: p,
          newPath: d
        } = t;
        if (Be.equals(p, d))
          return r;
        if (Be.isAncestor(p, r) || Be.equals(p, r)) {
          var h = d.slice();
          return Be.endsBefore(p, d) && p.length < d.length && (h[p.length - 1] -= 1), h.concat(r.slice(p.length));
        } else Be.isSibling(p, d) && (Be.isAncestor(d, r) || Be.equals(d, r)) ? Be.endsBefore(p, r) ? r[p.length - 1] -= 1 : r[p.length - 1] += 1 : Be.endsBefore(d, r) || Be.equals(d, r) || Be.isAncestor(d, r) ? (Be.endsBefore(p, r) && (r[p.length - 1] -= 1), r[d.length - 1] += 1) : Be.endsBefore(p, r) && (Be.equals(d, r) && (r[d.length - 1] += 1), r[p.length - 1] -= 1);
        break;
      }
    }
    return r;
  }
};
function Cp(e) {
  "@babel/helpers - typeof";
  return Cp = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Cp(e);
}
function Vte(e, t) {
  if (Cp(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (Cp(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function qte(e) {
  var t = Vte(e, "string");
  return Cp(t) === "symbol" ? t : String(t);
}
function vu(e, t, n) {
  return t = qte(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function LS(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function $u(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? LS(Object(n), !0).forEach(function(r) {
      vu(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : LS(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Zte = (e, t, n) => {
  switch (n.type) {
    case "insert_node": {
      var {
        path: r,
        node: o
      } = n, i = Ct.parent(e, r), a = r[r.length - 1];
      if (a > i.children.length)
        throw new Error('Cannot apply an "insert_node" operation at path ['.concat(r, "] because the destination is past the end of the node."));
      if (i.children.splice(a, 0, o), t)
        for (var [s, l] of Nt.points(t))
          t[l] = Qn.transform(s, n);
      break;
    }
    case "insert_text": {
      var {
        path: u,
        offset: c,
        text: p
      } = n;
      if (p.length === 0) break;
      var d = Ct.leaf(e, u), h = d.text.slice(0, c), f = d.text.slice(c);
      if (d.text = h + p + f, t)
        for (var [m, g] of Nt.points(t))
          t[g] = Qn.transform(m, n);
      break;
    }
    case "merge_node": {
      var {
        path: E
      } = n, w = Ct.get(e, E), M = Be.previous(E), x = Ct.get(e, M), y = Ct.parent(e, E), C = E[E.length - 1];
      if (Nr.isText(w) && Nr.isText(x))
        x.text += w.text;
      else if (!Nr.isText(w) && !Nr.isText(x))
        x.children.push(...w.children);
      else
        throw new Error('Cannot apply a "merge_node" operation at path ['.concat(E, "] to nodes of different interfaces: ").concat(qo.stringify(w), " ").concat(qo.stringify(x)));
      if (y.children.splice(C, 1), t)
        for (var [P, F] of Nt.points(t))
          t[F] = Qn.transform(P, n);
      break;
    }
    case "move_node": {
      var {
        path: L,
        newPath: N
      } = n;
      if (Be.isAncestor(L, N))
        throw new Error("Cannot move a path [".concat(L, "] to new path [").concat(N, "] because the destination is inside itself."));
      var I = Ct.get(e, L), H = Ct.parent(e, L), V = L[L.length - 1];
      H.children.splice(V, 1);
      var z = Be.transform(L, n), q = Ct.get(e, Be.parent(z)), K = z[z.length - 1];
      if (q.children.splice(K, 0, I), t)
        for (var [J, te] of Nt.points(t))
          t[te] = Qn.transform(J, n);
      break;
    }
    case "remove_node": {
      var {
        path: ee
      } = n, _ = ee[ee.length - 1], D = Ct.parent(e, ee);
      if (D.children.splice(_, 1), t)
        for (var [$, S] of Nt.points(t)) {
          var W = Qn.transform($, n);
          if (t != null && W != null)
            t[S] = W;
          else {
            var O = void 0, T = void 0;
            for (var [U, j] of Ct.texts(e))
              if (Be.compare(j, ee) === -1)
                O = [U, j];
              else {
                T = [U, j];
                break;
              }
            var Z = !1;
            O && T && (Be.equals(T[1], ee) ? Z = !Be.hasPrevious(T[1]) : Z = Be.common(O[1], ee).length < Be.common(T[1], ee).length), O && !Z ? ($.path = O[1], $.offset = O[0].text.length) : T ? ($.path = T[1], $.offset = 0) : t = null;
          }
        }
      break;
    }
    case "remove_text": {
      var {
        path: A,
        offset: Q,
        text: R
      } = n;
      if (R.length === 0) break;
      var ue = Ct.leaf(e, A), fe = ue.text.slice(0, Q), oe = ue.text.slice(Q + R.length);
      if (ue.text = fe + oe, t)
        for (var [Re, He] of Nt.points(t))
          t[He] = Qn.transform(Re, n);
      break;
    }
    case "set_node": {
      var {
        path: Ve,
        properties: ze,
        newProperties: et
      } = n;
      if (Ve.length === 0)
        throw new Error("Cannot set properties on the root node!");
      var Ge = Ct.get(e, Ve);
      for (var Pe in et) {
        if (Pe === "children" || Pe === "text")
          throw new Error('Cannot set the "'.concat(Pe, '" property of nodes!'));
        var Ye = et[Pe];
        Ye == null ? delete Ge[Pe] : Ge[Pe] = Ye;
      }
      for (var it in ze)
        et.hasOwnProperty(it) || delete Ge[it];
      break;
    }
    case "set_selection": {
      var {
        newProperties: _e
      } = n;
      if (_e == null)
        t = _e;
      else {
        if (t == null) {
          if (!Nt.isRange(_e))
            throw new Error('Cannot apply an incomplete "set_selection" operation properties '.concat(qo.stringify(_e), " when there is no current selection."));
          t = $u({}, _e);
        }
        for (var Se in _e) {
          var Ke = _e[Se];
          if (Ke == null) {
            if (Se === "anchor" || Se === "focus")
              throw new Error('Cannot remove the "'.concat(Se, '" selection property'));
            delete t[Se];
          } else
            t[Se] = Ke;
        }
      }
      break;
    }
    case "split_node": {
      var {
        path: We,
        position: Ue,
        properties: nt
      } = n;
      if (We.length === 0)
        throw new Error('Cannot apply a "split_node" operation at path ['.concat(We, "] because the root node cannot be split."));
      var Ie = Ct.get(e, We), xt = Ct.parent(e, We), ot = We[We.length - 1], st;
      if (Nr.isText(Ie)) {
        var lt = Ie.text.slice(0, Ue), Ot = Ie.text.slice(Ue);
        Ie.text = lt, st = $u($u({}, nt), {}, {
          text: Ot
        });
      } else {
        var ut = Ie.children.slice(0, Ue), ct = Ie.children.slice(Ue);
        Ie.children = ut, st = $u($u({}, nt), {}, {
          children: ct
        });
      }
      if (xt.children.splice(ot + 1, 0, st), t)
        for (var [tt, Xe] of Nt.points(t))
          t[Xe] = Qn.transform(tt, n);
      break;
    }
  }
  return t;
}, Gte = {
  transform(e, t) {
    e.children = ES(e.children);
    var n = e.selection && ES(e.selection);
    try {
      n = Zte(e, n, t);
    } finally {
      e.children = kS(e.children), n ? e.selection = jl(n) ? kS(n) : n : e.selection = null;
    }
  }
}, Xte = {
  insertNodes(e, t, n) {
    e.insertNodes(t, n);
  },
  liftNodes(e, t) {
    e.liftNodes(t);
  },
  mergeNodes(e, t) {
    e.mergeNodes(t);
  },
  moveNodes(e, t) {
    e.moveNodes(t);
  },
  removeNodes(e, t) {
    e.removeNodes(t);
  },
  setNodes(e, t, n) {
    e.setNodes(t, n);
  },
  splitNodes(e, t) {
    e.splitNodes(t);
  },
  unsetNodes(e, t, n) {
    e.unsetNodes(t, n);
  },
  unwrapNodes(e, t) {
    e.unwrapNodes(t);
  },
  wrapNodes(e, t, n) {
    e.wrapNodes(t, n);
  }
}, Kte = {
  collapse(e, t) {
    e.collapse(t);
  },
  deselect(e) {
    e.deselect();
  },
  move(e, t) {
    e.move(t);
  },
  select(e, t) {
    e.select(t);
  },
  setPoint(e, t, n) {
    e.setPoint(t, n);
  },
  setSelection(e, t) {
    e.setSelection(t);
  }
}, XH = (e, t) => {
  for (var n in e) {
    var r = e[n], o = t[n];
    if (vo(r) && vo(o)) {
      if (!XH(r, o)) return !1;
    } else if (Array.isArray(r) && Array.isArray(o)) {
      if (r.length !== o.length) return !1;
      for (var i = 0; i < r.length; i++)
        if (r[i] !== o[i]) return !1;
    } else if (r !== o)
      return !1;
  }
  for (var a in t)
    if (e[a] === void 0 && t[a] !== void 0)
      return !1;
  return !0;
};
function Yte(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), o, i;
  for (i = 0; i < r.length; i++)
    o = r[i], !(t.indexOf(o) >= 0) && (n[o] = e[o]);
  return n;
}
function xp(e, t) {
  if (e == null) return {};
  var n = Yte(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (o = 0; o < i.length; o++)
      r = i[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
var Jte = ["anchor", "focus"];
function _S(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Qte(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? _S(Object(n), !0).forEach(function(r) {
      vu(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : _S(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Nt = {
  edges(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, {
      anchor: r,
      focus: o
    } = e;
    return Nt.isBackward(e) === n ? [r, o] : [o, r];
  },
  end(e) {
    var [, t] = Nt.edges(e);
    return t;
  },
  equals(e, t) {
    return Qn.equals(e.anchor, t.anchor) && Qn.equals(e.focus, t.focus);
  },
  includes(e, t) {
    if (Nt.isRange(t)) {
      if (Nt.includes(e, t.anchor) || Nt.includes(e, t.focus))
        return !0;
      var [n, r] = Nt.edges(e), [o, i] = Nt.edges(t);
      return Qn.isBefore(n, o) && Qn.isAfter(r, i);
    }
    var [a, s] = Nt.edges(e), l = !1, u = !1;
    return Qn.isPoint(t) ? (l = Qn.compare(t, a) >= 0, u = Qn.compare(t, s) <= 0) : (l = Be.compare(t, a.path) >= 0, u = Be.compare(t, s.path) <= 0), l && u;
  },
  intersection(e, t) {
    var n = xp(e, Jte), [r, o] = Nt.edges(e), [i, a] = Nt.edges(t), s = Qn.isBefore(r, i) ? i : r, l = Qn.isBefore(o, a) ? o : a;
    return Qn.isBefore(l, s) ? null : Qte({
      anchor: s,
      focus: l
    }, n);
  },
  isBackward(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return Qn.isAfter(t, n);
  },
  isCollapsed(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return Qn.equals(t, n);
  },
  isExpanded(e) {
    return !Nt.isCollapsed(e);
  },
  isForward(e) {
    return !Nt.isBackward(e);
  },
  isRange(e) {
    return vo(e) && Qn.isPoint(e.anchor) && Qn.isPoint(e.focus);
  },
  *points(e) {
    yield [e.anchor, "anchor"], yield [e.focus, "focus"];
  },
  start(e) {
    var [t] = Nt.edges(e);
    return t;
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return SE(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "inward"
      } = n, i, a;
      if (o === "inward") {
        var s = Nt.isCollapsed(r);
        Nt.isForward(r) ? (i = "forward", a = s ? i : "backward") : (i = "backward", a = s ? i : "forward");
      } else o === "outward" ? Nt.isForward(r) ? (i = "backward", a = "forward") : (i = "forward", a = "backward") : (i = o, a = o);
      var l = Qn.transform(r.anchor, t, {
        affinity: i
      }), u = Qn.transform(r.focus, t, {
        affinity: a
      });
      if (!l || !u)
        return null;
      r.anchor = l, r.focus = u;
    });
  }
}, PS = (e) => vo(e) && Ct.isNodeList(e.children) && !Rn.isEditor(e), vs = {
  isAncestor(e) {
    return vo(e) && Ct.isNodeList(e.children);
  },
  isElement: PS,
  isElementList(e) {
    return Array.isArray(e) && e.every((t) => vs.isElement(t));
  },
  isElementProps(e) {
    return e.children !== void 0;
  },
  isElementType: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "type";
    return PS(e) && e[n] === t;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "children" && e[n] !== t[n])
        return !1;
    return !0;
  }
}, ene = ["children"], tne = ["text"], SS = /* @__PURE__ */ new WeakMap(), Ct = {
  ancestor(e, t) {
    var n = Ct.get(e, t);
    if (Nr.isText(n))
      throw new Error("Cannot get the ancestor node at path [".concat(t, "] because it refers to a text node instead: ").concat(qo.stringify(n)));
    return n;
  },
  ancestors(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of Be.ancestors(t, n)) {
        var o = Ct.ancestor(e, r), i = [o, r];
        yield i;
      }
    }();
  },
  child(e, t) {
    if (Nr.isText(e))
      throw new Error("Cannot get the child of a text node: ".concat(qo.stringify(e)));
    var n = e.children[t];
    if (n == null)
      throw new Error("Cannot get child at index `".concat(t, "` in node: ").concat(qo.stringify(e)));
    return n;
  },
  children(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var {
        reverse: r = !1
      } = n, o = Ct.ancestor(e, t), {
        children: i
      } = o, a = r ? i.length - 1 : 0; r ? a >= 0 : a < i.length; ) {
        var s = Ct.child(o, a), l = t.concat(a);
        yield [s, l], a = r ? a - 1 : a + 1;
      }
    }();
  },
  common(e, t, n) {
    var r = Be.common(t, n), o = Ct.get(e, r);
    return [o, r];
  },
  descendant(e, t) {
    var n = Ct.get(e, t);
    if (Rn.isEditor(n))
      throw new Error("Cannot get the descendant node at path [".concat(t, "] because it refers to the root editor node instead: ").concat(qo.stringify(n)));
    return n;
  },
  descendants(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Ct.nodes(e, t))
        r.length !== 0 && (yield [n, r]);
    }();
  },
  elements(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Ct.nodes(e, t))
        vs.isElement(n) && (yield [n, r]);
    }();
  },
  extractProps(e) {
    if (vs.isAncestor(e)) {
      var t = xp(e, ene);
      return t;
    } else {
      var t = xp(e, tne);
      return t;
    }
  },
  first(e, t) {
    for (var n = t.slice(), r = Ct.get(e, n); r && !(Nr.isText(r) || r.children.length === 0); )
      r = r.children[0], n.push(0);
    return [r, n];
  },
  fragment(e, t) {
    if (Nr.isText(e))
      throw new Error("Cannot get a fragment starting from a root text node: ".concat(qo.stringify(e)));
    var n = SE({
      children: e.children
    }, (r) => {
      var [o, i] = Nt.edges(t), a = Ct.nodes(r, {
        reverse: !0,
        pass: (d) => {
          var [, h] = d;
          return !Nt.includes(t, h);
        }
      });
      for (var [, s] of a) {
        if (!Nt.includes(t, s)) {
          var l = Ct.parent(r, s), u = s[s.length - 1];
          l.children.splice(u, 1);
        }
        if (Be.equals(s, i.path)) {
          var c = Ct.leaf(r, s);
          c.text = c.text.slice(0, i.offset);
        }
        if (Be.equals(s, o.path)) {
          var p = Ct.leaf(r, s);
          p.text = p.text.slice(o.offset);
        }
      }
      Rn.isEditor(r) && (r.selection = null);
    });
    return n.children;
  },
  get(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (Nr.isText(n) || !n.children[o])
        throw new Error("Cannot find a descendant at path [".concat(t, "] in node: ").concat(qo.stringify(e)));
      n = n.children[o];
    }
    return n;
  },
  has(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (Nr.isText(n) || !n.children[o])
        return !1;
      n = n.children[o];
    }
    return !0;
  },
  isNode(e) {
    return Nr.isText(e) || vs.isElement(e) || Rn.isEditor(e);
  },
  isNodeList(e) {
    if (!Array.isArray(e))
      return !1;
    var t = SS.get(e);
    if (t !== void 0)
      return t;
    var n = e.every((r) => Ct.isNode(r));
    return SS.set(e, n), n;
  },
  last(e, t) {
    for (var n = t.slice(), r = Ct.get(e, n); r && !(Nr.isText(r) || r.children.length === 0); ) {
      var o = r.children.length - 1;
      r = r.children[o], n.push(o);
    }
    return [r, n];
  },
  leaf(e, t) {
    var n = Ct.get(e, t);
    if (!Nr.isText(n))
      throw new Error("Cannot get the leaf node at path [".concat(t, "] because it refers to a non-leaf node: ").concat(qo.stringify(n)));
    return n;
  },
  levels(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of Be.levels(t, n)) {
        var o = Ct.get(e, r);
        yield [o, r];
      }
    }();
  },
  matches(e, t) {
    return vs.isElement(e) && vs.isElementProps(t) && vs.matches(e, t) || Nr.isText(e) && Nr.isTextProps(t) && Nr.matches(e, t);
  },
  nodes(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var {
        pass: n,
        reverse: r = !1
      } = t, {
        from: o = [],
        to: i
      } = t, a = /* @__PURE__ */ new Set(), s = [], l = e; !(i && (r ? Be.isBefore(s, i) : Be.isAfter(s, i))); ) {
        if (a.has(l) || (yield [l, s]), !a.has(l) && !Nr.isText(l) && l.children.length !== 0 && (n == null || n([l, s]) === !1)) {
          a.add(l);
          var u = r ? l.children.length - 1 : 0;
          Be.isAncestor(s, o) && (u = o[s.length]), s = s.concat(u), l = Ct.get(e, s);
          continue;
        }
        if (s.length === 0)
          break;
        if (!r) {
          var c = Be.next(s);
          if (Ct.has(e, c)) {
            s = c, l = Ct.get(e, s);
            continue;
          }
        }
        if (r && s[s.length - 1] !== 0) {
          var p = Be.previous(s);
          s = p, l = Ct.get(e, s);
          continue;
        }
        s = Be.parent(s), l = Ct.get(e, s), a.add(l);
      }
    }();
  },
  parent(e, t) {
    var n = Be.parent(t), r = Ct.get(e, n);
    if (Nr.isText(r))
      throw new Error("Cannot get the parent of path [".concat(t, "] because it does not exist in the root."));
    return r;
  },
  string(e) {
    return Nr.isText(e) ? e.text : e.children.map(Ct.string).join("");
  },
  texts(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Ct.nodes(e, t))
        Nr.isText(n) && (yield [n, r]);
    }();
  }
};
function MS(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ir(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? MS(Object(n), !0).forEach(function(r) {
      vu(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : MS(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var yc = {
  isNodeOperation(e) {
    return yc.isOperation(e) && e.type.endsWith("_node");
  },
  isOperation(e) {
    if (!vo(e))
      return !1;
    switch (e.type) {
      case "insert_node":
        return Be.isPath(e.path) && Ct.isNode(e.node);
      case "insert_text":
        return typeof e.offset == "number" && typeof e.text == "string" && Be.isPath(e.path);
      case "merge_node":
        return typeof e.position == "number" && Be.isPath(e.path) && vo(e.properties);
      case "move_node":
        return Be.isPath(e.path) && Be.isPath(e.newPath);
      case "remove_node":
        return Be.isPath(e.path) && Ct.isNode(e.node);
      case "remove_text":
        return typeof e.offset == "number" && typeof e.text == "string" && Be.isPath(e.path);
      case "set_node":
        return Be.isPath(e.path) && vo(e.properties) && vo(e.newProperties);
      case "set_selection":
        return e.properties === null && Nt.isRange(e.newProperties) || e.newProperties === null && Nt.isRange(e.properties) || vo(e.properties) && vo(e.newProperties);
      case "split_node":
        return Be.isPath(e.path) && typeof e.position == "number" && vo(e.properties);
      default:
        return !1;
    }
  },
  isOperationList(e) {
    return Array.isArray(e) && e.every((t) => yc.isOperation(t));
  },
  isSelectionOperation(e) {
    return yc.isOperation(e) && e.type.endsWith("_selection");
  },
  isTextOperation(e) {
    return yc.isOperation(e) && e.type.endsWith("_text");
  },
  inverse(e) {
    switch (e.type) {
      case "insert_node":
        return ir(ir({}, e), {}, {
          type: "remove_node"
        });
      case "insert_text":
        return ir(ir({}, e), {}, {
          type: "remove_text"
        });
      case "merge_node":
        return ir(ir({}, e), {}, {
          type: "split_node",
          path: Be.previous(e.path)
        });
      case "move_node": {
        var {
          newPath: t,
          path: n
        } = e;
        if (Be.equals(t, n))
          return e;
        if (Be.isSibling(n, t))
          return ir(ir({}, e), {}, {
            path: t,
            newPath: n
          });
        var r = Be.transform(n, e), o = Be.transform(Be.next(n), e);
        return ir(ir({}, e), {}, {
          path: r,
          newPath: o
        });
      }
      case "remove_node":
        return ir(ir({}, e), {}, {
          type: "insert_node"
        });
      case "remove_text":
        return ir(ir({}, e), {}, {
          type: "insert_text"
        });
      case "set_node": {
        var {
          properties: i,
          newProperties: a
        } = e;
        return ir(ir({}, e), {}, {
          properties: a,
          newProperties: i
        });
      }
      case "set_selection": {
        var {
          properties: s,
          newProperties: l
        } = e;
        return s == null ? ir(ir({}, e), {}, {
          properties: l,
          newProperties: null
        }) : l == null ? ir(ir({}, e), {}, {
          properties: null,
          newProperties: s
        }) : ir(ir({}, e), {}, {
          properties: l,
          newProperties: s
        });
      }
      case "split_node":
        return ir(ir({}, e), {}, {
          type: "merge_node",
          path: Be.next(e.path)
        });
    }
  }
}, DS = /* @__PURE__ */ new WeakMap(), nne = (e) => {
  var t = DS.get(e);
  if (t !== void 0)
    return t;
  if (!vo(e))
    return !1;
  var n = typeof e.addMark == "function" && typeof e.apply == "function" && typeof e.deleteFragment == "function" && typeof e.insertBreak == "function" && typeof e.insertSoftBreak == "function" && typeof e.insertFragment == "function" && typeof e.insertNode == "function" && typeof e.insertText == "function" && typeof e.isElementReadOnly == "function" && typeof e.isInline == "function" && typeof e.isSelectable == "function" && typeof e.isVoid == "function" && typeof e.normalizeNode == "function" && typeof e.onChange == "function" && typeof e.removeMark == "function" && typeof e.getDirtyPaths == "function" && (e.marks === null || vo(e.marks)) && (e.selection === null || Nt.isRange(e.selection)) && Ct.isNodeList(e.children) && yc.isOperationList(e.operations);
  return DS.set(e, n), n;
}, Rn = {
  above(e, t) {
    return e.above(t);
  },
  addMark(e, t, n) {
    e.addMark(t, n);
  },
  after(e, t, n) {
    return e.after(t, n);
  },
  before(e, t, n) {
    return e.before(t, n);
  },
  deleteBackward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteBackward(n);
  },
  deleteForward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteForward(n);
  },
  deleteFragment(e, t) {
    e.deleteFragment(t);
  },
  edges(e, t) {
    return e.edges(t);
  },
  elementReadOnly(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return e.elementReadOnly(t);
  },
  end(e, t) {
    return e.end(t);
  },
  first(e, t) {
    return e.first(t);
  },
  fragment(e, t) {
    return e.fragment(t);
  },
  hasBlocks(e, t) {
    return e.hasBlocks(t);
  },
  hasInlines(e, t) {
    return e.hasInlines(t);
  },
  hasPath(e, t) {
    return e.hasPath(t);
  },
  hasTexts(e, t) {
    return e.hasTexts(t);
  },
  insertBreak(e) {
    e.insertBreak();
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertNode(e, t) {
    e.insertNode(t);
  },
  insertSoftBreak(e) {
    e.insertSoftBreak();
  },
  insertText(e, t) {
    e.insertText(t);
  },
  isBlock(e, t) {
    return e.isBlock(t);
  },
  isEdge(e, t, n) {
    return e.isEdge(t, n);
  },
  isEditor(e) {
    return nne(e);
  },
  isElementReadOnly(e, t) {
    return e.isElementReadOnly(t);
  },
  isEmpty(e, t) {
    return e.isEmpty(t);
  },
  isEnd(e, t, n) {
    return e.isEnd(t, n);
  },
  isInline(e, t) {
    return e.isInline(t);
  },
  isNormalizing(e) {
    return e.isNormalizing();
  },
  isSelectable(e, t) {
    return e.isSelectable(t);
  },
  isStart(e, t, n) {
    return e.isStart(t, n);
  },
  isVoid(e, t) {
    return e.isVoid(t);
  },
  last(e, t) {
    return e.last(t);
  },
  leaf(e, t, n) {
    return e.leaf(t, n);
  },
  levels(e, t) {
    return e.levels(t);
  },
  marks(e) {
    return e.getMarks();
  },
  next(e, t) {
    return e.next(t);
  },
  node(e, t, n) {
    return e.node(t, n);
  },
  nodes(e, t) {
    return e.nodes(t);
  },
  normalize(e, t) {
    e.normalize(t);
  },
  parent(e, t, n) {
    return e.parent(t, n);
  },
  path(e, t, n) {
    return e.path(t, n);
  },
  pathRef(e, t, n) {
    return e.pathRef(t, n);
  },
  pathRefs(e) {
    return e.pathRefs();
  },
  point(e, t, n) {
    return e.point(t, n);
  },
  pointRef(e, t, n) {
    return e.pointRef(t, n);
  },
  pointRefs(e) {
    return e.pointRefs();
  },
  positions(e, t) {
    return e.positions(t);
  },
  previous(e, t) {
    return e.previous(t);
  },
  range(e, t, n) {
    return e.range(t, n);
  },
  rangeRef(e, t, n) {
    return e.rangeRef(t, n);
  },
  rangeRefs(e) {
    return e.rangeRefs();
  },
  removeMark(e, t) {
    e.removeMark(t);
  },
  setNormalizing(e, t) {
    e.setNormalizing(t);
  },
  start(e, t) {
    return e.start(t);
  },
  string(e, t, n) {
    return e.string(t, n);
  },
  unhangRange(e, t, n) {
    return e.unhangRange(t, n);
  },
  void(e, t) {
    return e.void(t);
  },
  withoutNormalizing(e, t) {
    e.withoutNormalizing(t);
  },
  shouldMergeNodesRemovePrevNode: (e, t, n) => e.shouldMergeNodesRemovePrevNode(t, n)
};
function TS(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function jS(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? TS(Object(n), !0).forEach(function(r) {
      vu(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : TS(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Qn = {
  compare(e, t) {
    var n = Be.compare(e.path, t.path);
    return n === 0 ? e.offset < t.offset ? -1 : e.offset > t.offset ? 1 : 0 : n;
  },
  isAfter(e, t) {
    return Qn.compare(e, t) === 1;
  },
  isBefore(e, t) {
    return Qn.compare(e, t) === -1;
  },
  equals(e, t) {
    return e.offset === t.offset && Be.equals(e.path, t.path);
  },
  isPoint(e) {
    return vo(e) && typeof e.offset == "number" && Be.isPath(e.path);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return SE(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "forward"
      } = n, {
        path: i,
        offset: a
      } = r;
      switch (t.type) {
        case "insert_node":
        case "move_node": {
          r.path = Be.transform(i, t, n);
          break;
        }
        case "insert_text": {
          Be.equals(t.path, i) && (t.offset < a || t.offset === a && o === "forward") && (r.offset += t.text.length);
          break;
        }
        case "merge_node": {
          Be.equals(t.path, i) && (r.offset += t.position), r.path = Be.transform(i, t, n);
          break;
        }
        case "remove_text": {
          Be.equals(t.path, i) && t.offset <= a && (r.offset -= Math.min(a - t.offset, t.text.length));
          break;
        }
        case "remove_node": {
          if (Be.equals(t.path, i) || Be.isAncestor(t.path, i))
            return null;
          r.path = Be.transform(i, t, n);
          break;
        }
        case "split_node": {
          if (Be.equals(t.path, i)) {
            if (t.position === a && o == null)
              return null;
            (t.position < a || t.position === a && o === "forward") && (r.offset -= t.position, r.path = Be.transform(i, t, jS(jS({}, n), {}, {
              affinity: "forward"
            })));
          } else
            r.path = Be.transform(i, t, n);
          break;
        }
      }
    });
  }
}, AS = void 0, qo = {
  setScrubber(e) {
    AS = e;
  },
  stringify(e) {
    return JSON.stringify(e, AS);
  }
}, rne = ["text"], one = ["anchor", "focus"];
function BS(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ss(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? BS(Object(n), !0).forEach(function(r) {
      vu(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : BS(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Nr = {
  equals(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      loose: r = !1
    } = n;
    function o(i) {
      var a = xp(i, rne);
      return a;
    }
    return XH(r ? o(e) : e, r ? o(t) : t);
  },
  isText(e) {
    return vo(e) && typeof e.text == "string";
  },
  isTextList(e) {
    return Array.isArray(e) && e.every((t) => Nr.isText(t));
  },
  isTextProps(e) {
    return e.text !== void 0;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "text" && (!e.hasOwnProperty(n) || e[n] !== t[n]))
        return !1;
    return !0;
  },
  decorations(e, t) {
    var n = [ss({}, e)];
    for (var r of t) {
      var o = xp(r, one), [i, a] = Nt.edges(r), s = [], l = 0, u = i.offset, c = a.offset;
      for (var p of n) {
        var {
          length: d
        } = p.text, h = l;
        if (l += d, u <= h && l <= c) {
          Object.assign(p, o), s.push(p);
          continue;
        }
        if (u !== c && (u === l || c === h) || u > l || c < h || c === h && h !== 0) {
          s.push(p);
          continue;
        }
        var f = p, m = void 0, g = void 0;
        if (c < l) {
          var E = c - h;
          g = ss(ss({}, f), {}, {
            text: f.text.slice(E)
          }), f = ss(ss({}, f), {}, {
            text: f.text.slice(0, E)
          });
        }
        if (u > h) {
          var w = u - h;
          m = ss(ss({}, f), {}, {
            text: f.text.slice(0, w)
          }), f = ss(ss({}, f), {}, {
            text: f.text.slice(w)
          });
        }
        Object.assign(f, o), m && s.push(m), s.push(f), g && s.push(g);
      }
      n = s;
    }
    return n;
  }
}, ine = (e) => e.selection ? e.selection : e.children.length > 0 ? Rn.end(e, []) : [0], Gn;
(function(e) {
  e[e.None = 0] = "None", e[e.Extend = 1] = "Extend", e[e.ZWJ = 2] = "ZWJ", e[e.RI = 4] = "RI", e[e.Prepend = 8] = "Prepend", e[e.SpacingMark = 16] = "SpacingMark", e[e.L = 32] = "L", e[e.V = 64] = "V", e[e.T = 128] = "T", e[e.LV = 256] = "LV", e[e.LVT = 512] = "LVT", e[e.ExtPict = 1024] = "ExtPict", e[e.Any = 2048] = "Any";
})(Gn || (Gn = {}));
Gn.L, Gn.L | Gn.V | Gn.LV | Gn.LVT, Gn.LV | Gn.V, Gn.V | Gn.T, Gn.LVT | Gn.T, Gn.T, Gn.Any, Gn.Extend | Gn.ZWJ, Gn.Any, Gn.SpacingMark, Gn.Prepend, Gn.Any, Gn.ZWJ, Gn.ExtPict, Gn.RI, Gn.RI;
var sne = {
  delete(e, t) {
    e.delete(t);
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertText(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Rn.withoutNormalizing(e, () => {
      var {
        voids: r = !1
      } = n, {
        at: o = ine(e)
      } = n;
      if (Be.isPath(o) && (o = Rn.range(e, o)), Nt.isRange(o))
        if (Nt.isCollapsed(o))
          o = o.anchor;
        else {
          var i = Nt.end(o);
          if (!r && Rn.void(e, {
            at: i
          }))
            return;
          var a = Nt.start(o), s = Rn.pointRef(e, a), l = Rn.pointRef(e, i);
          gg.delete(e, {
            at: o,
            voids: r
          });
          var u = s.unref(), c = l.unref();
          o = u || c, gg.setSelection(e, {
            anchor: o,
            focus: o
          });
        }
      if (!(!r && Rn.void(e, {
        at: o
      }) || Rn.elementReadOnly(e, {
        at: o
      }))) {
        var {
          path: p,
          offset: d
        } = o;
        t.length > 0 && e.apply({
          type: "insert_text",
          path: p,
          offset: d,
          text: t
        });
      }
    });
  }
};
function IS(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function af(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? IS(Object(n), !0).forEach(function(r) {
      vu(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : IS(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var gg = af(af(af(af({}, Gte), Xte), Kte), sne), KH = {}, ME = {}, DE = {}, Hl = {}, TE = {}, jE = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Doctype = e.CDATA = e.Tag = e.Style = e.Script = e.Comment = e.Directive = e.Text = e.Root = e.isTag = e.ElementType = void 0;
  var t;
  (function(r) {
    r.Root = "root", r.Text = "text", r.Directive = "directive", r.Comment = "comment", r.Script = "script", r.Style = "style", r.Tag = "tag", r.CDATA = "cdata", r.Doctype = "doctype";
  })(t = e.ElementType || (e.ElementType = {}));
  function n(r) {
    return r.type === t.Tag || r.type === t.Script || r.type === t.Style;
  }
  e.isTag = n, e.Root = t.Root, e.Text = t.Text, e.Directive = t.Directive, e.Comment = t.Comment, e.Script = t.Script, e.Style = t.Style, e.Tag = t.Tag, e.CDATA = t.CDATA, e.Doctype = t.Doctype;
})(jE);
var Vt = {}, ka = Hn && Hn.__extends || /* @__PURE__ */ function() {
  var e = function(t, n) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, o) {
      r.__proto__ = o;
    } || function(r, o) {
      for (var i in o) Object.prototype.hasOwnProperty.call(o, i) && (r[i] = o[i]);
    }, e(t, n);
  };
  return function(t, n) {
    if (typeof n != "function" && n !== null)
      throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
    e(t, n);
    function r() {
      this.constructor = t;
    }
    t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
  };
}(), Dc = Hn && Hn.__assign || function() {
  return Dc = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) {
      t = arguments[n];
      for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
    }
    return e;
  }, Dc.apply(this, arguments);
};
Object.defineProperty(Vt, "__esModule", { value: !0 });
Vt.cloneNode = Vt.hasChildren = Vt.isDocument = Vt.isDirective = Vt.isComment = Vt.isText = Vt.isCDATA = Vt.isTag = Vt.Element = Vt.Document = Vt.CDATA = Vt.NodeWithChildren = Vt.ProcessingInstruction = Vt.Comment = Vt.Text = Vt.DataNode = Vt.Node = void 0;
var Uo = jE, AE = (
  /** @class */
  function() {
    function e() {
      this.parent = null, this.prev = null, this.next = null, this.startIndex = null, this.endIndex = null;
    }
    return Object.defineProperty(e.prototype, "parentNode", {
      // Read-write aliases for properties
      /**
       * Same as {@link parent}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.parent;
      },
      set: function(t) {
        this.parent = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "previousSibling", {
      /**
       * Same as {@link prev}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.prev;
      },
      set: function(t) {
        this.prev = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "nextSibling", {
      /**
       * Same as {@link next}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.next;
      },
      set: function(t) {
        this.next = t;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.cloneNode = function(t) {
      return t === void 0 && (t = !1), BE(this, t);
    }, e;
  }()
);
Vt.Node = AE;
var Rv = (
  /** @class */
  function(e) {
    ka(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.data = n, r;
    }
    return Object.defineProperty(t.prototype, "nodeValue", {
      /**
       * Same as {@link data}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.data;
      },
      set: function(n) {
        this.data = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(AE)
);
Vt.DataNode = Rv;
var YH = (
  /** @class */
  function(e) {
    ka(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Uo.ElementType.Text, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 3;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Rv)
);
Vt.Text = YH;
var JH = (
  /** @class */
  function(e) {
    ka(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Uo.ElementType.Comment, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 8;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Rv)
);
Vt.Comment = JH;
var QH = (
  /** @class */
  function(e) {
    ka(t, e);
    function t(n, r) {
      var o = e.call(this, r) || this;
      return o.name = n, o.type = Uo.ElementType.Directive, o;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Rv)
);
Vt.ProcessingInstruction = QH;
var Nv = (
  /** @class */
  function(e) {
    ka(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.children = n, r;
    }
    return Object.defineProperty(t.prototype, "firstChild", {
      // Aliases
      /** First child of the node. */
      get: function() {
        var n;
        return (n = this.children[0]) !== null && n !== void 0 ? n : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "lastChild", {
      /** Last child of the node. */
      get: function() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "childNodes", {
      /**
       * Same as {@link children}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.children;
      },
      set: function(n) {
        this.children = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(AE)
);
Vt.NodeWithChildren = Nv;
var eW = (
  /** @class */
  function(e) {
    ka(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Uo.ElementType.CDATA, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 4;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Nv)
);
Vt.CDATA = eW;
var tW = (
  /** @class */
  function(e) {
    ka(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Uo.ElementType.Root, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 9;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Nv)
);
Vt.Document = tW;
var nW = (
  /** @class */
  function(e) {
    ka(t, e);
    function t(n, r, o, i) {
      o === void 0 && (o = []), i === void 0 && (i = n === "script" ? Uo.ElementType.Script : n === "style" ? Uo.ElementType.Style : Uo.ElementType.Tag);
      var a = e.call(this, o) || this;
      return a.name = n, a.attribs = r, a.type = i, a;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "tagName", {
      // DOM Level 1 aliases
      /**
       * Same as {@link name}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.name;
      },
      set: function(n) {
        this.name = n;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "attributes", {
      get: function() {
        var n = this;
        return Object.keys(this.attribs).map(function(r) {
          var o, i;
          return {
            name: r,
            value: n.attribs[r],
            namespace: (o = n["x-attribsNamespace"]) === null || o === void 0 ? void 0 : o[r],
            prefix: (i = n["x-attribsPrefix"]) === null || i === void 0 ? void 0 : i[r]
          };
        });
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Nv)
);
Vt.Element = nW;
function rW(e) {
  return (0, Uo.isTag)(e);
}
Vt.isTag = rW;
function oW(e) {
  return e.type === Uo.ElementType.CDATA;
}
Vt.isCDATA = oW;
function iW(e) {
  return e.type === Uo.ElementType.Text;
}
Vt.isText = iW;
function sW(e) {
  return e.type === Uo.ElementType.Comment;
}
Vt.isComment = sW;
function aW(e) {
  return e.type === Uo.ElementType.Directive;
}
Vt.isDirective = aW;
function lW(e) {
  return e.type === Uo.ElementType.Root;
}
Vt.isDocument = lW;
function ane(e) {
  return Object.prototype.hasOwnProperty.call(e, "children");
}
Vt.hasChildren = ane;
function BE(e, t) {
  t === void 0 && (t = !1);
  var n;
  if (iW(e))
    n = new YH(e.data);
  else if (sW(e))
    n = new JH(e.data);
  else if (rW(e)) {
    var r = t ? gb(e.children) : [], o = new nW(e.name, Dc({}, e.attribs), r);
    r.forEach(function(l) {
      return l.parent = o;
    }), e.namespace != null && (o.namespace = e.namespace), e["x-attribsNamespace"] && (o["x-attribsNamespace"] = Dc({}, e["x-attribsNamespace"])), e["x-attribsPrefix"] && (o["x-attribsPrefix"] = Dc({}, e["x-attribsPrefix"])), n = o;
  } else if (oW(e)) {
    var r = t ? gb(e.children) : [], i = new eW(r);
    r.forEach(function(u) {
      return u.parent = i;
    }), n = i;
  } else if (lW(e)) {
    var r = t ? gb(e.children) : [], a = new tW(r);
    r.forEach(function(u) {
      return u.parent = a;
    }), e["x-mode"] && (a["x-mode"] = e["x-mode"]), n = a;
  } else if (aW(e)) {
    var s = new QH(e.name, e.data);
    e["x-name"] != null && (s["x-name"] = e["x-name"], s["x-publicId"] = e["x-publicId"], s["x-systemId"] = e["x-systemId"]), n = s;
  } else
    throw new Error("Not implemented yet: ".concat(e.type));
  return n.startIndex = e.startIndex, n.endIndex = e.endIndex, e.sourceCodeLocation != null && (n.sourceCodeLocation = e.sourceCodeLocation), n;
}
Vt.cloneNode = BE;
function gb(e) {
  for (var t = e.map(function(r) {
    return BE(r, !0);
  }), n = 1; n < t.length; n++)
    t[n].prev = t[n - 1], t[n - 1].next = t[n];
  return t;
}
(function(e) {
  var t = Hn && Hn.__createBinding || (Object.create ? function(s, l, u, c) {
    c === void 0 && (c = u);
    var p = Object.getOwnPropertyDescriptor(l, u);
    (!p || ("get" in p ? !l.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
      return l[u];
    } }), Object.defineProperty(s, c, p);
  } : function(s, l, u, c) {
    c === void 0 && (c = u), s[c] = l[u];
  }), n = Hn && Hn.__exportStar || function(s, l) {
    for (var u in s) u !== "default" && !Object.prototype.hasOwnProperty.call(l, u) && t(l, s, u);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.DomHandler = void 0;
  var r = jE, o = Vt;
  n(Vt, e);
  var i = {
    withStartIndices: !1,
    withEndIndices: !1,
    xmlMode: !1
  }, a = (
    /** @class */
    function() {
      function s(l, u, c) {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null, typeof u == "function" && (c = u, u = i), typeof l == "object" && (u = l, l = void 0), this.callback = l ?? null, this.options = u ?? i, this.elementCB = c ?? null;
      }
      return s.prototype.onparserinit = function(l) {
        this.parser = l;
      }, s.prototype.onreset = function() {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null;
      }, s.prototype.onend = function() {
        this.done || (this.done = !0, this.parser = null, this.handleCallback(null));
      }, s.prototype.onerror = function(l) {
        this.handleCallback(l);
      }, s.prototype.onclosetag = function() {
        this.lastNode = null;
        var l = this.tagStack.pop();
        this.options.withEndIndices && (l.endIndex = this.parser.endIndex), this.elementCB && this.elementCB(l);
      }, s.prototype.onopentag = function(l, u) {
        var c = this.options.xmlMode ? r.ElementType.Tag : void 0, p = new o.Element(l, u, void 0, c);
        this.addNode(p), this.tagStack.push(p);
      }, s.prototype.ontext = function(l) {
        var u = this.lastNode;
        if (u && u.type === r.ElementType.Text)
          u.data += l, this.options.withEndIndices && (u.endIndex = this.parser.endIndex);
        else {
          var c = new o.Text(l);
          this.addNode(c), this.lastNode = c;
        }
      }, s.prototype.oncomment = function(l) {
        if (this.lastNode && this.lastNode.type === r.ElementType.Comment) {
          this.lastNode.data += l;
          return;
        }
        var u = new o.Comment(l);
        this.addNode(u), this.lastNode = u;
      }, s.prototype.oncommentend = function() {
        this.lastNode = null;
      }, s.prototype.oncdatastart = function() {
        var l = new o.Text(""), u = new o.CDATA([l]);
        this.addNode(u), l.parent = u, this.lastNode = l;
      }, s.prototype.oncdataend = function() {
        this.lastNode = null;
      }, s.prototype.onprocessinginstruction = function(l, u) {
        var c = new o.ProcessingInstruction(l, u);
        this.addNode(c);
      }, s.prototype.handleCallback = function(l) {
        if (typeof this.callback == "function")
          this.callback(l, this.dom);
        else if (l)
          throw l;
      }, s.prototype.addNode = function(l) {
        var u = this.tagStack[this.tagStack.length - 1], c = u.children[u.children.length - 1];
        this.options.withStartIndices && (l.startIndex = this.parser.startIndex), this.options.withEndIndices && (l.endIndex = this.parser.endIndex), u.children.push(l), c && (l.prev = c, c.next = l), l.parent = u, this.lastNode = null;
      }, s;
    }()
  );
  e.DomHandler = a, e.default = a;
})(TE);
var uW = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CARRIAGE_RETURN_PLACEHOLDER_REGEX = e.CARRIAGE_RETURN_PLACEHOLDER = e.CARRIAGE_RETURN_REGEX = e.CARRIAGE_RETURN = e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES = void 0, e.CASE_SENSITIVE_TAG_NAMES = [
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "linearGradient",
    "radialGradient",
    "textPath"
  ], e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES.reduce(function(t, n) {
    return t[n.toLowerCase()] = n, t;
  }, {}), e.CARRIAGE_RETURN = "\r", e.CARRIAGE_RETURN_REGEX = new RegExp(e.CARRIAGE_RETURN, "g"), e.CARRIAGE_RETURN_PLACEHOLDER = "__HTML_DOM_PARSER_CARRIAGE_RETURN_PLACEHOLDER_".concat(Date.now(), "__"), e.CARRIAGE_RETURN_PLACEHOLDER_REGEX = new RegExp(e.CARRIAGE_RETURN_PLACEHOLDER, "g");
})(uW);
Object.defineProperty(Hl, "__esModule", { value: !0 });
Hl.formatAttributes = cW;
Hl.escapeSpecialCharacters = cne;
Hl.revertEscapedCharacters = pW;
Hl.formatDOM = dW;
var lf = TE, Op = uW;
function lne(e) {
  return Op.CASE_SENSITIVE_TAG_NAMES_MAP[e];
}
function cW(e) {
  for (var t = {}, n = 0, r = e.length; n < r; n++) {
    var o = e[n];
    t[o.name] = o.value;
  }
  return t;
}
function une(e) {
  e = e.toLowerCase();
  var t = lne(e);
  return t || e;
}
function cne(e) {
  return e.replace(Op.CARRIAGE_RETURN_REGEX, Op.CARRIAGE_RETURN_PLACEHOLDER);
}
function pW(e) {
  return e.replace(Op.CARRIAGE_RETURN_PLACEHOLDER_REGEX, Op.CARRIAGE_RETURN);
}
function dW(e, t, n) {
  t === void 0 && (t = null);
  for (var r = [], o, i = 0, a = e.length; i < a; i++) {
    var s = e[i];
    switch (s.nodeType) {
      case 1: {
        var l = une(s.nodeName);
        o = new lf.Element(l, cW(s.attributes)), o.children = dW(
          // template children are on content
          l === "template" ? s.content.childNodes : s.childNodes,
          o
        );
        break;
      }
      case 3:
        o = new lf.Text(pW(s.nodeValue));
        break;
      case 8:
        o = new lf.Comment(s.nodeValue);
        break;
      default:
        continue;
    }
    var u = r[i - 1] || null;
    u && (u.next = o), o.parent = t, o.prev = u, o.next = null, r.push(o);
  }
  return n && (o = new lf.ProcessingInstruction(n.substring(0, n.indexOf(" ")).toLowerCase(), n), o.next = r[0] || null, o.parent = t, r.unshift(o), r[1] && (r[1].prev = r[0])), r;
}
Object.defineProperty(DE, "__esModule", { value: !0 });
DE.default = gne;
var pne = Hl, RS = "html", NS = "head", uf = "body", dne = /<([a-zA-Z]+[0-9]?)/, FS = /<head[^]*>/i, zS = /<body[^]*>/i, mg = function(e, t) {
  throw new Error("This browser does not support `document.implementation.createHTMLDocument`");
}, WC = function(e, t) {
  throw new Error("This browser does not support `DOMParser.prototype.parseFromString`");
}, US = typeof window == "object" && window.DOMParser;
if (typeof US == "function") {
  var fne = new US(), hne = "text/html";
  WC = function(e, t) {
    return t && (e = "<".concat(t, ">").concat(e, "</").concat(t, ">")), fne.parseFromString(e, hne);
  }, mg = WC;
}
if (typeof document == "object" && document.implementation) {
  var cf = document.implementation.createHTMLDocument();
  mg = function(e, t) {
    if (t) {
      var n = cf.documentElement.querySelector(t);
      return n && (n.innerHTML = e), cf;
    }
    return cf.documentElement.innerHTML = e, cf;
  };
}
var pf = typeof document == "object" && document.createElement("template"), VC;
pf && pf.content && (VC = function(e) {
  return pf.innerHTML = e, pf.content.childNodes;
});
function gne(e) {
  var t, n;
  e = (0, pne.escapeSpecialCharacters)(e);
  var r = e.match(dne), o = r && r[1] ? r[1].toLowerCase() : "";
  switch (o) {
    case RS: {
      var i = WC(e);
      if (!FS.test(e)) {
        var a = i.querySelector(NS);
        (t = a == null ? void 0 : a.parentNode) === null || t === void 0 || t.removeChild(a);
      }
      if (!zS.test(e)) {
        var a = i.querySelector(uf);
        (n = a == null ? void 0 : a.parentNode) === null || n === void 0 || n.removeChild(a);
      }
      return i.querySelectorAll(RS);
    }
    case NS:
    case uf: {
      var s = mg(e).querySelectorAll(o);
      return zS.test(e) && FS.test(e) ? s[0].parentNode.childNodes : s;
    }
    default: {
      if (VC)
        return VC(e);
      var a = mg(e, uf).querySelector(uf);
      return a.childNodes;
    }
  }
}
var mne = Hn && Hn.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(ME, "__esModule", { value: !0 });
ME.default = wne;
var vne = mne(DE), yne = Hl, bne = /<(![a-zA-Z\s]+)>/;
function wne(e) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e)
    return [];
  var t = e.match(bne), n = t ? t[1] : void 0;
  return (0, yne.formatDOM)((0, vne.default)(e), null, n);
}
var Fv = {}, Ai = {}, zv = {}, Cne = 0;
zv.SAME = Cne;
var xne = 1;
zv.CAMELCASE = xne;
zv.possibleStandardNames = {
  accept: 0,
  acceptCharset: 1,
  "accept-charset": "acceptCharset",
  accessKey: 1,
  action: 0,
  allowFullScreen: 1,
  alt: 0,
  as: 0,
  async: 0,
  autoCapitalize: 1,
  autoComplete: 1,
  autoCorrect: 1,
  autoFocus: 1,
  autoPlay: 1,
  autoSave: 1,
  capture: 0,
  cellPadding: 1,
  cellSpacing: 1,
  challenge: 0,
  charSet: 1,
  checked: 0,
  children: 0,
  cite: 0,
  class: "className",
  classID: 1,
  className: 1,
  cols: 0,
  colSpan: 1,
  content: 0,
  contentEditable: 1,
  contextMenu: 1,
  controls: 0,
  controlsList: 1,
  coords: 0,
  crossOrigin: 1,
  dangerouslySetInnerHTML: 1,
  data: 0,
  dateTime: 1,
  default: 0,
  defaultChecked: 1,
  defaultValue: 1,
  defer: 0,
  dir: 0,
  disabled: 0,
  disablePictureInPicture: 1,
  disableRemotePlayback: 1,
  download: 0,
  draggable: 0,
  encType: 1,
  enterKeyHint: 1,
  for: "htmlFor",
  form: 0,
  formMethod: 1,
  formAction: 1,
  formEncType: 1,
  formNoValidate: 1,
  formTarget: 1,
  frameBorder: 1,
  headers: 0,
  height: 0,
  hidden: 0,
  high: 0,
  href: 0,
  hrefLang: 1,
  htmlFor: 1,
  httpEquiv: 1,
  "http-equiv": "httpEquiv",
  icon: 0,
  id: 0,
  innerHTML: 1,
  inputMode: 1,
  integrity: 0,
  is: 0,
  itemID: 1,
  itemProp: 1,
  itemRef: 1,
  itemScope: 1,
  itemType: 1,
  keyParams: 1,
  keyType: 1,
  kind: 0,
  label: 0,
  lang: 0,
  list: 0,
  loop: 0,
  low: 0,
  manifest: 0,
  marginWidth: 1,
  marginHeight: 1,
  max: 0,
  maxLength: 1,
  media: 0,
  mediaGroup: 1,
  method: 0,
  min: 0,
  minLength: 1,
  multiple: 0,
  muted: 0,
  name: 0,
  noModule: 1,
  nonce: 0,
  noValidate: 1,
  open: 0,
  optimum: 0,
  pattern: 0,
  placeholder: 0,
  playsInline: 1,
  poster: 0,
  preload: 0,
  profile: 0,
  radioGroup: 1,
  readOnly: 1,
  referrerPolicy: 1,
  rel: 0,
  required: 0,
  reversed: 0,
  role: 0,
  rows: 0,
  rowSpan: 1,
  sandbox: 0,
  scope: 0,
  scoped: 0,
  scrolling: 0,
  seamless: 0,
  selected: 0,
  shape: 0,
  size: 0,
  sizes: 0,
  span: 0,
  spellCheck: 1,
  src: 0,
  srcDoc: 1,
  srcLang: 1,
  srcSet: 1,
  start: 0,
  step: 0,
  style: 0,
  summary: 0,
  tabIndex: 1,
  target: 0,
  title: 0,
  type: 0,
  useMap: 1,
  value: 0,
  width: 0,
  wmode: 0,
  wrap: 0,
  about: 0,
  accentHeight: 1,
  "accent-height": "accentHeight",
  accumulate: 0,
  additive: 0,
  alignmentBaseline: 1,
  "alignment-baseline": "alignmentBaseline",
  allowReorder: 1,
  alphabetic: 0,
  amplitude: 0,
  arabicForm: 1,
  "arabic-form": "arabicForm",
  ascent: 0,
  attributeName: 1,
  attributeType: 1,
  autoReverse: 1,
  azimuth: 0,
  baseFrequency: 1,
  baselineShift: 1,
  "baseline-shift": "baselineShift",
  baseProfile: 1,
  bbox: 0,
  begin: 0,
  bias: 0,
  by: 0,
  calcMode: 1,
  capHeight: 1,
  "cap-height": "capHeight",
  clip: 0,
  clipPath: 1,
  "clip-path": "clipPath",
  clipPathUnits: 1,
  clipRule: 1,
  "clip-rule": "clipRule",
  color: 0,
  colorInterpolation: 1,
  "color-interpolation": "colorInterpolation",
  colorInterpolationFilters: 1,
  "color-interpolation-filters": "colorInterpolationFilters",
  colorProfile: 1,
  "color-profile": "colorProfile",
  colorRendering: 1,
  "color-rendering": "colorRendering",
  contentScriptType: 1,
  contentStyleType: 1,
  cursor: 0,
  cx: 0,
  cy: 0,
  d: 0,
  datatype: 0,
  decelerate: 0,
  descent: 0,
  diffuseConstant: 1,
  direction: 0,
  display: 0,
  divisor: 0,
  dominantBaseline: 1,
  "dominant-baseline": "dominantBaseline",
  dur: 0,
  dx: 0,
  dy: 0,
  edgeMode: 1,
  elevation: 0,
  enableBackground: 1,
  "enable-background": "enableBackground",
  end: 0,
  exponent: 0,
  externalResourcesRequired: 1,
  fill: 0,
  fillOpacity: 1,
  "fill-opacity": "fillOpacity",
  fillRule: 1,
  "fill-rule": "fillRule",
  filter: 0,
  filterRes: 1,
  filterUnits: 1,
  floodOpacity: 1,
  "flood-opacity": "floodOpacity",
  floodColor: 1,
  "flood-color": "floodColor",
  focusable: 0,
  fontFamily: 1,
  "font-family": "fontFamily",
  fontSize: 1,
  "font-size": "fontSize",
  fontSizeAdjust: 1,
  "font-size-adjust": "fontSizeAdjust",
  fontStretch: 1,
  "font-stretch": "fontStretch",
  fontStyle: 1,
  "font-style": "fontStyle",
  fontVariant: 1,
  "font-variant": "fontVariant",
  fontWeight: 1,
  "font-weight": "fontWeight",
  format: 0,
  from: 0,
  fx: 0,
  fy: 0,
  g1: 0,
  g2: 0,
  glyphName: 1,
  "glyph-name": "glyphName",
  glyphOrientationHorizontal: 1,
  "glyph-orientation-horizontal": "glyphOrientationHorizontal",
  glyphOrientationVertical: 1,
  "glyph-orientation-vertical": "glyphOrientationVertical",
  glyphRef: 1,
  gradientTransform: 1,
  gradientUnits: 1,
  hanging: 0,
  horizAdvX: 1,
  "horiz-adv-x": "horizAdvX",
  horizOriginX: 1,
  "horiz-origin-x": "horizOriginX",
  ideographic: 0,
  imageRendering: 1,
  "image-rendering": "imageRendering",
  in2: 0,
  in: 0,
  inlist: 0,
  intercept: 0,
  k1: 0,
  k2: 0,
  k3: 0,
  k4: 0,
  k: 0,
  kernelMatrix: 1,
  kernelUnitLength: 1,
  kerning: 0,
  keyPoints: 1,
  keySplines: 1,
  keyTimes: 1,
  lengthAdjust: 1,
  letterSpacing: 1,
  "letter-spacing": "letterSpacing",
  lightingColor: 1,
  "lighting-color": "lightingColor",
  limitingConeAngle: 1,
  local: 0,
  markerEnd: 1,
  "marker-end": "markerEnd",
  markerHeight: 1,
  markerMid: 1,
  "marker-mid": "markerMid",
  markerStart: 1,
  "marker-start": "markerStart",
  markerUnits: 1,
  markerWidth: 1,
  mask: 0,
  maskContentUnits: 1,
  maskUnits: 1,
  mathematical: 0,
  mode: 0,
  numOctaves: 1,
  offset: 0,
  opacity: 0,
  operator: 0,
  order: 0,
  orient: 0,
  orientation: 0,
  origin: 0,
  overflow: 0,
  overlinePosition: 1,
  "overline-position": "overlinePosition",
  overlineThickness: 1,
  "overline-thickness": "overlineThickness",
  paintOrder: 1,
  "paint-order": "paintOrder",
  panose1: 0,
  "panose-1": "panose1",
  pathLength: 1,
  patternContentUnits: 1,
  patternTransform: 1,
  patternUnits: 1,
  pointerEvents: 1,
  "pointer-events": "pointerEvents",
  points: 0,
  pointsAtX: 1,
  pointsAtY: 1,
  pointsAtZ: 1,
  prefix: 0,
  preserveAlpha: 1,
  preserveAspectRatio: 1,
  primitiveUnits: 1,
  property: 0,
  r: 0,
  radius: 0,
  refX: 1,
  refY: 1,
  renderingIntent: 1,
  "rendering-intent": "renderingIntent",
  repeatCount: 1,
  repeatDur: 1,
  requiredExtensions: 1,
  requiredFeatures: 1,
  resource: 0,
  restart: 0,
  result: 0,
  results: 0,
  rotate: 0,
  rx: 0,
  ry: 0,
  scale: 0,
  security: 0,
  seed: 0,
  shapeRendering: 1,
  "shape-rendering": "shapeRendering",
  slope: 0,
  spacing: 0,
  specularConstant: 1,
  specularExponent: 1,
  speed: 0,
  spreadMethod: 1,
  startOffset: 1,
  stdDeviation: 1,
  stemh: 0,
  stemv: 0,
  stitchTiles: 1,
  stopColor: 1,
  "stop-color": "stopColor",
  stopOpacity: 1,
  "stop-opacity": "stopOpacity",
  strikethroughPosition: 1,
  "strikethrough-position": "strikethroughPosition",
  strikethroughThickness: 1,
  "strikethrough-thickness": "strikethroughThickness",
  string: 0,
  stroke: 0,
  strokeDasharray: 1,
  "stroke-dasharray": "strokeDasharray",
  strokeDashoffset: 1,
  "stroke-dashoffset": "strokeDashoffset",
  strokeLinecap: 1,
  "stroke-linecap": "strokeLinecap",
  strokeLinejoin: 1,
  "stroke-linejoin": "strokeLinejoin",
  strokeMiterlimit: 1,
  "stroke-miterlimit": "strokeMiterlimit",
  strokeWidth: 1,
  "stroke-width": "strokeWidth",
  strokeOpacity: 1,
  "stroke-opacity": "strokeOpacity",
  suppressContentEditableWarning: 1,
  suppressHydrationWarning: 1,
  surfaceScale: 1,
  systemLanguage: 1,
  tableValues: 1,
  targetX: 1,
  targetY: 1,
  textAnchor: 1,
  "text-anchor": "textAnchor",
  textDecoration: 1,
  "text-decoration": "textDecoration",
  textLength: 1,
  textRendering: 1,
  "text-rendering": "textRendering",
  to: 0,
  transform: 0,
  typeof: 0,
  u1: 0,
  u2: 0,
  underlinePosition: 1,
  "underline-position": "underlinePosition",
  underlineThickness: 1,
  "underline-thickness": "underlineThickness",
  unicode: 0,
  unicodeBidi: 1,
  "unicode-bidi": "unicodeBidi",
  unicodeRange: 1,
  "unicode-range": "unicodeRange",
  unitsPerEm: 1,
  "units-per-em": "unitsPerEm",
  unselectable: 0,
  vAlphabetic: 1,
  "v-alphabetic": "vAlphabetic",
  values: 0,
  vectorEffect: 1,
  "vector-effect": "vectorEffect",
  version: 0,
  vertAdvY: 1,
  "vert-adv-y": "vertAdvY",
  vertOriginX: 1,
  "vert-origin-x": "vertOriginX",
  vertOriginY: 1,
  "vert-origin-y": "vertOriginY",
  vHanging: 1,
  "v-hanging": "vHanging",
  vIdeographic: 1,
  "v-ideographic": "vIdeographic",
  viewBox: 1,
  viewTarget: 1,
  visibility: 0,
  vMathematical: 1,
  "v-mathematical": "vMathematical",
  vocab: 0,
  widths: 0,
  wordSpacing: 1,
  "word-spacing": "wordSpacing",
  writingMode: 1,
  "writing-mode": "writingMode",
  x1: 0,
  x2: 0,
  x: 0,
  xChannelSelector: 1,
  xHeight: 1,
  "x-height": "xHeight",
  xlinkActuate: 1,
  "xlink:actuate": "xlinkActuate",
  xlinkArcrole: 1,
  "xlink:arcrole": "xlinkArcrole",
  xlinkHref: 1,
  "xlink:href": "xlinkHref",
  xlinkRole: 1,
  "xlink:role": "xlinkRole",
  xlinkShow: 1,
  "xlink:show": "xlinkShow",
  xlinkTitle: 1,
  "xlink:title": "xlinkTitle",
  xlinkType: 1,
  "xlink:type": "xlinkType",
  xmlBase: 1,
  "xml:base": "xmlBase",
  xmlLang: 1,
  "xml:lang": "xmlLang",
  xmlns: 0,
  "xml:space": "xmlSpace",
  xmlnsXlink: 1,
  "xmlns:xlink": "xmlnsXlink",
  xmlSpace: 1,
  y1: 0,
  y2: 0,
  y: 0,
  yChannelSelector: 1,
  z: 0,
  zoomAndPan: 1
};
const fW = 0, La = 1, Uv = 2, $v = 3, IE = 4, hW = 5, gW = 6;
function One(e) {
  return po.hasOwnProperty(e) ? po[e] : null;
}
function _o(e, t, n, r, o, i, a) {
  this.acceptsBooleans = t === Uv || t === $v || t === IE, this.attributeName = r, this.attributeNamespace = o, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = i, this.removeEmptyString = a;
}
const po = {}, Ene = [
  "children",
  "dangerouslySetInnerHTML",
  // TODO: This prevents the assignment of defaultValue to regular
  // elements (not just inputs). Now that ReactDOMInput assigns to the
  // defaultValue property -- do we need this?
  "defaultValue",
  "defaultChecked",
  "innerHTML",
  "suppressContentEditableWarning",
  "suppressHydrationWarning",
  "style"
];
Ene.forEach((e) => {
  po[e] = new _o(
    e,
    fW,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"]
].forEach(([e, t]) => {
  po[e] = new _o(
    e,
    La,
    !1,
    // mustUseProperty
    t,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["contentEditable", "draggable", "spellCheck", "value"].forEach((e) => {
  po[e] = new _o(
    e,
    Uv,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha"
].forEach((e) => {
  po[e] = new _o(
    e,
    Uv,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "allowFullScreen",
  "async",
  // Note: there is a special case that prevents it from being written to the DOM
  // on the client side because the browsers are inconsistent. Instead we call focus().
  "autoFocus",
  "autoPlay",
  "controls",
  "default",
  "defer",
  "disabled",
  "disablePictureInPicture",
  "disableRemotePlayback",
  "formNoValidate",
  "hidden",
  "loop",
  "noModule",
  "noValidate",
  "open",
  "playsInline",
  "readOnly",
  "required",
  "reversed",
  "scoped",
  "seamless",
  // Microdata
  "itemScope"
].forEach((e) => {
  po[e] = new _o(
    e,
    $v,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "checked",
  // Note: `option.selected` is not updated if `select.multiple` is
  // disabled with `removeAttribute`. We have special logic for handling this.
  "multiple",
  "muted",
  "selected"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  po[e] = new _o(
    e,
    $v,
    !0,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "capture",
  "download"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  po[e] = new _o(
    e,
    IE,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "cols",
  "rows",
  "size",
  "span"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  po[e] = new _o(
    e,
    gW,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["rowSpan", "start"].forEach((e) => {
  po[e] = new _o(
    e,
    hW,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const RE = /[\-\:]([a-z])/g, NE = (e) => e[1].toUpperCase();
[
  "accent-height",
  "alignment-baseline",
  "arabic-form",
  "baseline-shift",
  "cap-height",
  "clip-path",
  "clip-rule",
  "color-interpolation",
  "color-interpolation-filters",
  "color-profile",
  "color-rendering",
  "dominant-baseline",
  "enable-background",
  "fill-opacity",
  "fill-rule",
  "flood-color",
  "flood-opacity",
  "font-family",
  "font-size",
  "font-size-adjust",
  "font-stretch",
  "font-style",
  "font-variant",
  "font-weight",
  "glyph-name",
  "glyph-orientation-horizontal",
  "glyph-orientation-vertical",
  "horiz-adv-x",
  "horiz-origin-x",
  "image-rendering",
  "letter-spacing",
  "lighting-color",
  "marker-end",
  "marker-mid",
  "marker-start",
  "overline-position",
  "overline-thickness",
  "paint-order",
  "panose-1",
  "pointer-events",
  "rendering-intent",
  "shape-rendering",
  "stop-color",
  "stop-opacity",
  "strikethrough-position",
  "strikethrough-thickness",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "text-anchor",
  "text-decoration",
  "text-rendering",
  "underline-position",
  "underline-thickness",
  "unicode-bidi",
  "unicode-range",
  "units-per-em",
  "v-alphabetic",
  "v-hanging",
  "v-ideographic",
  "v-mathematical",
  "vector-effect",
  "vert-adv-y",
  "vert-origin-x",
  "vert-origin-y",
  "word-spacing",
  "writing-mode",
  "xmlns:xlink",
  "x-height"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(RE, NE);
  po[t] = new _o(
    t,
    La,
    !1,
    // mustUseProperty
    e,
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xlink:actuate",
  "xlink:arcrole",
  "xlink:role",
  "xlink:show",
  "xlink:title",
  "xlink:type"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(RE, NE);
  po[t] = new _o(
    t,
    La,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/1999/xlink",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xml:base",
  "xml:lang",
  "xml:space"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(RE, NE);
  po[t] = new _o(
    t,
    La,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/XML/1998/namespace",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["tabIndex", "crossOrigin"].forEach((e) => {
  po[e] = new _o(
    e,
    La,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const kne = "xlinkHref";
po[kne] = new _o(
  "xlinkHref",
  La,
  !1,
  // mustUseProperty
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  // sanitizeURL
  !1
  // removeEmptyString
);
["src", "href", "action", "formAction"].forEach((e) => {
  po[e] = new _o(
    e,
    La,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !0,
    // sanitizeURL
    !0
    // removeEmptyString
  );
});
const {
  CAMELCASE: Lne,
  SAME: _ne,
  possibleStandardNames: $S
} = zv, Pne = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", Sne = Pne + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", Mne = RegExp.prototype.test.bind(
  // eslint-disable-next-line no-misleading-character-class
  new RegExp("^(data|aria)-[" + Sne + "]*$")
), Dne = Object.keys(
  $S
).reduce((e, t) => {
  const n = $S[t];
  return n === _ne ? e[t] = t : n === Lne ? e[t.toLowerCase()] = t : e[t] = n, e;
}, {});
Ai.BOOLEAN = $v;
Ai.BOOLEANISH_STRING = Uv;
Ai.NUMERIC = hW;
Ai.OVERLOADED_BOOLEAN = IE;
Ai.POSITIVE_NUMERIC = gW;
Ai.RESERVED = fW;
Ai.STRING = La;
Ai.getPropertyInfo = One;
Ai.isCustomAttribute = Mne;
Ai.possibleStandardNames = Dne;
var FE = {}, zE = {}, HS = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, Tne = /\n/g, jne = /^\s*/, Ane = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, Bne = /^:\s*/, Ine = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, Rne = /^[;\s]*/, Nne = /^\s+|\s+$/g, Fne = `
`, WS = "/", VS = "*", il = "", zne = "comment", Une = "declaration", $ne = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e) return [];
  t = t || {};
  var n = 1, r = 1;
  function o(f) {
    var m = f.match(Tne);
    m && (n += m.length);
    var g = f.lastIndexOf(Fne);
    r = ~g ? f.length - g : r + f.length;
  }
  function i() {
    var f = { line: n, column: r };
    return function(m) {
      return m.position = new a(f), u(), m;
    };
  }
  function a(f) {
    this.start = f, this.end = { line: n, column: r }, this.source = t.source;
  }
  a.prototype.content = e;
  function s(f) {
    var m = new Error(
      t.source + ":" + n + ":" + r + ": " + f
    );
    if (m.reason = f, m.filename = t.source, m.line = n, m.column = r, m.source = e, !t.silent) throw m;
  }
  function l(f) {
    var m = f.exec(e);
    if (m) {
      var g = m[0];
      return o(g), e = e.slice(g.length), m;
    }
  }
  function u() {
    l(jne);
  }
  function c(f) {
    var m;
    for (f = f || []; m = p(); )
      m !== !1 && f.push(m);
    return f;
  }
  function p() {
    var f = i();
    if (!(WS != e.charAt(0) || VS != e.charAt(1))) {
      for (var m = 2; il != e.charAt(m) && (VS != e.charAt(m) || WS != e.charAt(m + 1)); )
        ++m;
      if (m += 2, il === e.charAt(m - 1))
        return s("End of comment missing");
      var g = e.slice(2, m - 2);
      return r += 2, o(g), e = e.slice(m), r += 2, f({
        type: zne,
        comment: g
      });
    }
  }
  function d() {
    var f = i(), m = l(Ane);
    if (m) {
      if (p(), !l(Bne)) return s("property missing ':'");
      var g = l(Ine), E = f({
        type: Une,
        property: qS(m[0].replace(HS, il)),
        value: g ? qS(g[0].replace(HS, il)) : il
      });
      return l(Rne), E;
    }
  }
  function h() {
    var f = [];
    c(f);
    for (var m; m = d(); )
      m !== !1 && (f.push(m), c(f));
    return f;
  }
  return u(), h();
};
function qS(e) {
  return e ? e.replace(Nne, il) : il;
}
var Hne = Hn && Hn.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(zE, "__esModule", { value: !0 });
zE.default = Vne;
var Wne = Hne($ne);
function Vne(e, t) {
  var n = null;
  if (!e || typeof e != "string")
    return n;
  var r = (0, Wne.default)(e), o = typeof t == "function";
  return r.forEach(function(i) {
    if (i.type === "declaration") {
      var a = i.property, s = i.value;
      o ? t(a, s, i) : s && (n = n || {}, n[a] = s);
    }
  }), n;
}
var Hv = {};
Object.defineProperty(Hv, "__esModule", { value: !0 });
Hv.camelCase = void 0;
var qne = /^--[a-zA-Z0-9_-]+$/, Zne = /-([a-z])/g, Gne = /^[^-]+$/, Xne = /^-(webkit|moz|ms|o|khtml)-/, Kne = /^-(ms)-/, Yne = function(e) {
  return !e || Gne.test(e) || qne.test(e);
}, Jne = function(e, t) {
  return t.toUpperCase();
}, ZS = function(e, t) {
  return "".concat(t, "-");
}, Qne = function(e, t) {
  return t === void 0 && (t = {}), Yne(e) ? e : (e = e.toLowerCase(), t.reactCompat ? e = e.replace(Kne, ZS) : e = e.replace(Xne, ZS), e.replace(Zne, Jne));
};
Hv.camelCase = Qne;
var ere = Hn && Hn.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
}, tre = ere(zE), nre = Hv;
function qC(e, t) {
  var n = {};
  return !e || typeof e != "string" || (0, tre.default)(e, function(r, o) {
    r && o && (n[(0, nre.camelCase)(r, t)] = o);
  }), n;
}
qC.default = qC;
var rre = qC;
(function(e) {
  var t = Hn && Hn.__importDefault || function(c) {
    return c && c.__esModule ? c : { default: c };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.returnFirstArg = e.canTextBeChildOfNode = e.ELEMENTS_WITH_NO_TEXT_CHILDREN = e.PRESERVE_CUSTOM_ATTRIBUTES = void 0, e.isCustomComponent = i, e.setStyleProp = s;
  var n = ke, r = t(rre), o = /* @__PURE__ */ new Set([
    "annotation-xml",
    "color-profile",
    "font-face",
    "font-face-src",
    "font-face-uri",
    "font-face-format",
    "font-face-name",
    "missing-glyph"
  ]);
  function i(c, p) {
    return c.includes("-") ? !o.has(c) : !!(p && typeof p.is == "string");
  }
  var a = {
    reactCompat: !0
  };
  function s(c, p) {
    if (typeof c == "string") {
      if (!c.trim()) {
        p.style = {};
        return;
      }
      try {
        p.style = (0, r.default)(c, a);
      } catch {
        p.style = {};
      }
    }
  }
  e.PRESERVE_CUSTOM_ATTRIBUTES = Number(n.version.split(".")[0]) >= 16, e.ELEMENTS_WITH_NO_TEXT_CHILDREN = /* @__PURE__ */ new Set([
    "tr",
    "tbody",
    "thead",
    "tfoot",
    "colgroup",
    "table",
    "head",
    "html",
    "frameset"
  ]);
  var l = function(c) {
    return !e.ELEMENTS_WITH_NO_TEXT_CHILDREN.has(c.name);
  };
  e.canTextBeChildOfNode = l;
  var u = function(c) {
    return c;
  };
  e.returnFirstArg = u;
})(FE);
Object.defineProperty(Fv, "__esModule", { value: !0 });
Fv.default = are;
var bc = Ai, GS = FE, ore = ["checked", "value"], ire = ["input", "select", "textarea"], sre = {
  reset: !0,
  submit: !0
};
function are(e, t) {
  e === void 0 && (e = {});
  var n = {}, r = !!(e.type && sre[e.type]);
  for (var o in e) {
    var i = e[o];
    if ((0, bc.isCustomAttribute)(o)) {
      n[o] = i;
      continue;
    }
    var a = o.toLowerCase(), s = XS(a);
    if (s) {
      var l = (0, bc.getPropertyInfo)(s);
      switch (ore.includes(s) && ire.includes(t) && !r && (s = XS("default" + a)), n[s] = i, l && l.type) {
        case bc.BOOLEAN:
          n[s] = !0;
          break;
        case bc.OVERLOADED_BOOLEAN:
          i === "" && (n[s] = !0);
          break;
      }
      continue;
    }
    GS.PRESERVE_CUSTOM_ATTRIBUTES && (n[o] = i);
  }
  return (0, GS.setStyleProp)(e.style, n), n;
}
function XS(e) {
  return bc.possibleStandardNames[e];
}
var UE = {}, lre = Hn && Hn.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(UE, "__esModule", { value: !0 });
UE.default = mW;
var mb = ke, ure = lre(Fv), Tc = FE, cre = {
  cloneElement: mb.cloneElement,
  createElement: mb.createElement,
  isValidElement: mb.isValidElement
};
function mW(e, t) {
  t === void 0 && (t = {});
  for (var n = [], r = typeof t.replace == "function", o = t.transform || Tc.returnFirstArg, i = t.library || cre, a = i.cloneElement, s = i.createElement, l = i.isValidElement, u = e.length, c = 0; c < u; c++) {
    var p = e[c];
    if (r) {
      var d = t.replace(p, c);
      if (l(d)) {
        u > 1 && (d = a(d, {
          key: d.key || c
        })), n.push(o(d, p, c));
        continue;
      }
    }
    if (p.type === "text") {
      var h = !p.data.trim().length;
      if (h && p.parent && !(0, Tc.canTextBeChildOfNode)(p.parent) || t.trim && h)
        continue;
      n.push(o(p.data, p, c));
      continue;
    }
    var f = p, m = {};
    pre(f) ? ((0, Tc.setStyleProp)(f.attribs.style, f.attribs), m = f.attribs) : f.attribs && (m = (0, ure.default)(f.attribs, f.name));
    var g = void 0;
    switch (p.type) {
      case "script":
      case "style":
        p.children[0] && (m.dangerouslySetInnerHTML = {
          __html: p.children[0].data
        });
        break;
      case "tag":
        p.name === "textarea" && p.children[0] ? m.defaultValue = p.children[0].data : p.children && p.children.length && (g = mW(p.children, t));
        break;
      default:
        continue;
    }
    u > 1 && (m.key = c), n.push(o(s(p.name, m, g), p, c));
  }
  return n.length === 1 ? n[0] : n;
}
function pre(e) {
  return Tc.PRESERVE_CUSTOM_ATTRIBUTES && e.type === "tag" && (0, Tc.isCustomComponent)(e.name, e.attribs);
}
(function(e) {
  var t = Hn && Hn.__importDefault || function(l) {
    return l && l.__esModule ? l : { default: l };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.htmlToDOM = e.domToReact = e.attributesToProps = e.Text = e.ProcessingInstruction = e.Element = e.Comment = void 0, e.default = s;
  var n = t(ME);
  e.htmlToDOM = n.default;
  var r = t(Fv);
  e.attributesToProps = r.default;
  var o = t(UE);
  e.domToReact = o.default;
  var i = TE;
  Object.defineProperty(e, "Comment", { enumerable: !0, get: function() {
    return i.Comment;
  } }), Object.defineProperty(e, "Element", { enumerable: !0, get: function() {
    return i.Element;
  } }), Object.defineProperty(e, "ProcessingInstruction", { enumerable: !0, get: function() {
    return i.ProcessingInstruction;
  } }), Object.defineProperty(e, "Text", { enumerable: !0, get: function() {
    return i.Text;
  } });
  var a = { lowerCaseAttributeNames: !1 };
  function s(l, u) {
    if (typeof l != "string")
      throw new TypeError("First argument must be a string");
    return l ? (0, o.default)((0, n.default)(l, (u == null ? void 0 : u.htmlparser2) || a), u) : [];
  }
})(KH);
const dre = /* @__PURE__ */ Dte(KH);
dre.default;
Ze({});
function fre(e) {
  return e && e.replace(/[^0-9]/g, "");
}
const hre = {
  CNPJ: "99.999.999/9999-99"
};
fre(hre.CNPJ).length;
Vr((e, t) => /* @__PURE__ */ io.jsx("input", { ref: t, ...e }));
function vW(e) {
  return e && e.replace(/[^0-9]/g, "");
}
const yW = {
  EIGTH: "(99) 9999-9999",
  NINE: "(99) 99999-9999"
};
function gre(e, t) {
  let n = "", r = 0;
  for (let o = 0; o < t.length; o++)
    if (t[o] === "9")
      if (r < e.length)
        n += e[r], r++;
      else
        break;
    else if (r < e.length)
      n += t[o];
    else
      break;
  return n;
}
function mre(e) {
  return e.length > 10 ? "NINE" : "EIGTH";
}
const vre = vW(yW.NINE).length, yre = Vr((e, t) => /* @__PURE__ */ io.jsx("input", { ref: t, ...e }));
Vr(
  (e, t) => {
    const { onFocus: n, onBlur: r, size: o, onChange: i, value: a, currentCountry: s, disabled: l } = e, [u, c] = k(!1);
    v(() => {
      u ? i(s.mask) : c(!0);
    }, [s]);
    const p = `phoneInputMask ${o}`;
    function d(h) {
      let f = vW(h.target.value);
      const m = mre(f);
      f.length > vre || (f = gre(f, yW[m]), h.target.value = f, i(f));
    }
    return s.code === "+55" ? /* @__PURE__ */ io.jsx(
      "input",
      {
        value: a,
        onChange: d,
        className: p,
        onFocus: n,
        onBlur: r,
        disabled: l,
        ref: t
      }
    ) : /* @__PURE__ */ io.jsx(
      Il,
      {
        value: a,
        onChange: (h) => i(h.target.value),
        className: p,
        component: yre,
        onFocus: n,
        onBlur: r,
        disabled: l,
        mask: s.mask,
        showMask: !0,
        replacement: { _: /\d/ },
        ref: t
      }
    );
  }
);
Ze({});
var Ls = {};
Object.defineProperty(Ls, "__esModule", {
  value: !0
});
var bre = typeof window < "u" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform), vb = {
  alt: "altKey",
  control: "ctrlKey",
  meta: "metaKey",
  shift: "shiftKey"
}, bW = {
  add: "+",
  break: "pause",
  cmd: "meta",
  command: "meta",
  ctl: "control",
  ctrl: "control",
  del: "delete",
  down: "arrowdown",
  esc: "escape",
  ins: "insert",
  left: "arrowleft",
  mod: bre ? "meta" : "control",
  opt: "alt",
  option: "alt",
  return: "enter",
  right: "arrowright",
  space: " ",
  spacebar: " ",
  up: "arrowup",
  win: "meta",
  windows: "meta"
}, $E = {
  backspace: 8,
  tab: 9,
  enter: 13,
  shift: 16,
  control: 17,
  alt: 18,
  pause: 19,
  capslock: 20,
  escape: 27,
  " ": 32,
  pageup: 33,
  pagedown: 34,
  end: 35,
  home: 36,
  arrowleft: 37,
  arrowup: 38,
  arrowright: 39,
  arrowdown: 40,
  insert: 45,
  delete: 46,
  meta: 91,
  numlock: 144,
  scrolllock: 145,
  ";": 186,
  "=": 187,
  ",": 188,
  "-": 189,
  ".": 190,
  "/": 191,
  "`": 192,
  "[": 219,
  "\\": 220,
  "]": 221,
  "'": 222
};
for (var df = 1; df < 20; df++)
  $E["f" + df] = 111 + df;
function Wv(e, t, n) {
  t && !("byKey" in t) && (n = t, t = null), Array.isArray(e) || (e = [e]);
  var r = e.map(function(a) {
    return wW(a, t);
  }), o = function(a) {
    return r.some(function(s) {
      return CW(s, a);
    });
  }, i = n == null ? o : o(n);
  return i;
}
function wre(e, t) {
  return Wv(e, t);
}
function Cre(e, t) {
  return Wv(e, { byKey: !0 }, t);
}
function wW(e, t) {
  var n = t && t.byKey, r = {};
  e = e.replace("++", "+add");
  var o = e.split("+"), i = o.length;
  for (var a in vb)
    r[vb[a]] = !1;
  var s = !0, l = !1, u = void 0;
  try {
    for (var c = o[Symbol.iterator](), p; !(s = (p = c.next()).done); s = !0) {
      var d = p.value, h = d.endsWith("?") && d.length > 1;
      h && (d = d.slice(0, -1));
      var f = HE(d), m = vb[f];
      if (d.length > 1 && !m && !bW[d] && !$E[f])
        throw new TypeError('Unknown modifier: "' + d + '"');
      (i === 1 || !m) && (n ? r.key = f : r.which = xW(d)), m && (r[m] = h ? null : !0);
    }
  } catch (g) {
    l = !0, u = g;
  } finally {
    try {
      !s && c.return && c.return();
    } finally {
      if (l)
        throw u;
    }
  }
  return r;
}
function CW(e, t) {
  for (var n in e) {
    var r = e[n], o = void 0;
    if (r != null && (n === "key" && t.key != null ? o = t.key.toLowerCase() : n === "which" ? o = r === 91 && t.which === 93 ? 91 : t.which : o = t[n], !(o == null && r === !1) && o !== r))
      return !1;
  }
  return !0;
}
function xW(e) {
  e = HE(e);
  var t = $E[e] || e.toUpperCase().charCodeAt(0);
  return t;
}
function HE(e) {
  return e = e.toLowerCase(), e = bW[e] || e, e;
}
Ls.default = Wv;
var yb = Ls.isHotkey = Wv;
Ls.isCodeHotkey = wre;
Ls.isKeyHotkey = Cre;
Ls.parseHotkey = wW;
Ls.compareHotkey = CW;
Ls.toKeyCode = xW;
Ls.toKeyName = HE;
var xre = typeof Hn == "object" && Hn && Hn.Object === Object && Hn, Ore = xre, Ere = Ore, kre = typeof self == "object" && self && self.Object === Object && self, Lre = Ere || kre || Function("return this")(), _re = Lre, Pre = _re, Sre = Pre.Symbol, OW = Sre, KS = OW;
KS && KS.toStringTag;
var YS = OW;
YS && YS.toStringTag;
var JS;
(function(e) {
  e.BORDER_BOX = "border-box", e.CONTENT_BOX = "content-box", e.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(JS || (JS = {}));
var WE = function(e) {
  return Object.freeze(e);
}, Mre = /* @__PURE__ */ function() {
  function e(t, n) {
    this.inlineSize = t, this.blockSize = n, WE(this);
  }
  return e;
}(), Dre = function() {
  function e(t, n, r, o) {
    return this.x = t, this.y = n, this.width = r, this.height = o, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, WE(this);
  }
  return e.prototype.toJSON = function() {
    var t = this, n = t.x, r = t.y, o = t.top, i = t.right, a = t.bottom, s = t.left, l = t.width, u = t.height;
    return { x: n, y: r, top: o, right: i, bottom: a, left: s, width: l, height: u };
  }, e.fromRect = function(t) {
    return new e(t.x, t.y, t.width, t.height);
  }, e;
}(), QS = typeof window < "u" ? window : {};
/msie|trident/i.test(QS.navigator && QS.navigator.userAgent);
var bb = function(e, t, n) {
  return e === void 0 && (e = 0), t === void 0 && (t = 0), n === void 0 && (n = !1), new Mre((n ? t : e) || 0, (n ? e : t) || 0);
};
WE({
  devicePixelContentBoxSize: bb(),
  borderBoxSize: bb(),
  contentBoxSize: bb(),
  contentRect: new Dre(0, 0, 0, 0)
});
function Ep(e) {
  "@babel/helpers - typeof";
  return Ep = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Ep(e);
}
function Tre(e, t) {
  if (Ep(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (Ep(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function jre(e) {
  var t = Tre(e, "string");
  return Ep(t) === "symbol" ? t : String(t);
}
function jc(e, t, n) {
  return t = jre(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
var Are = /* @__PURE__ */ Ze(null), wb, Cb;
parseInt(ke.version.split(".")[0], 10);
var eM = typeof navigator < "u" && /Mac OS X/.test(navigator.userAgent), xb = typeof navigator < "u" && /Android/.test(navigator.userAgent), ff = typeof navigator < "u" && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent), Bre = typeof navigator < "u" && /Chrome/i.test(navigator.userAgent);
typeof navigator < "u" && /Safari/.test(navigator.userAgent) && /Version\/(\d+)/.test(navigator.userAgent) && (wb = navigator.userAgent.match(/Version\/(\d+)/)) !== null && wb !== void 0 && wb[1] && parseInt((Cb = navigator.userAgent.match(/Version\/(\d+)/)) === null || Cb === void 0 ? void 0 : Cb[1], 10) < 17;
var Ire = /* @__PURE__ */ new WeakMap(), Rre = /* @__PURE__ */ new WeakMap(), Nre = /* @__PURE__ */ new WeakMap(), Fre = /* @__PURE__ */ new WeakMap(), zre = /* @__PURE__ */ new WeakMap(), tM = /* @__PURE__ */ new WeakMap(), Ure = /* @__PURE__ */ new WeakMap(), nM = /* @__PURE__ */ new WeakMap(), hf = /* @__PURE__ */ new WeakMap(), $re = /* @__PURE__ */ new WeakMap(), Hre = /* @__PURE__ */ new WeakMap(), Wre = /* @__PURE__ */ new WeakMap(), EW = globalThis.Node, Vre = globalThis.Text, kW = (e) => e && e.ownerDocument && e.ownerDocument.defaultView || null, qre = (e) => vg(e) && e.nodeType === 8, Hi = (e) => vg(e) && e.nodeType === 1, vg = (e) => {
  var t = kW(e);
  return !!t && e instanceof t.Node;
}, rM = (e) => {
  var t = e && e.anchorNode && kW(e.anchorNode);
  return !!t && e instanceof t.Selection;
}, Zre = (e) => {
  var [t, n] = e;
  if (Hi(t) && t.childNodes.length) {
    var r = n === t.childNodes.length, o = r ? n - 1 : n;
    for ([t, o] = LW(t, o, r ? "backward" : "forward"), r = o < n; Hi(t) && t.childNodes.length; ) {
      var i = r ? t.childNodes.length - 1 : 0;
      t = Xre(t, i, r ? "backward" : "forward");
    }
    n = r && t.textContent != null ? t.textContent.length : 0;
  }
  return [t, n];
}, Gre = (e) => {
  for (var t = e && e.parentNode; t; ) {
    if (t.toString() === "[object ShadowRoot]")
      return !0;
    t = t.parentNode;
  }
  return !1;
}, LW = (e, t, n) => {
  for (var {
    childNodes: r
  } = e, o = r[t], i = t, a = !1, s = !1; (qre(o) || Hi(o) && o.childNodes.length === 0 || Hi(o) && o.getAttribute("contenteditable") === "false") && !(a && s); ) {
    if (i >= r.length) {
      a = !0, i = t - 1, n = "backward";
      continue;
    }
    if (i < 0) {
      s = !0, i = t + 1, n = "forward";
      continue;
    }
    o = r[i], t = i, i += n === "forward" ? 1 : -1;
  }
  return [o, t];
}, Xre = (e, t, n) => {
  var [r] = LW(e, t, n);
  return r;
}, oM = (e) => e.getSelection != null ? e.getSelection() : document.getSelection(), _W = (e, t, n) => {
  var {
    target: r
  } = t;
  if (Hi(r) && r.matches('[contentEditable="false"]'))
    return !1;
  var {
    document: o
  } = Zt.getWindow(e);
  if (o.contains(r))
    return Zt.hasDOMNode(e, r, {
      editable: !0
    });
  var i = n.find((a) => {
    var {
      addedNodes: s,
      removedNodes: l
    } = a;
    for (var u of s)
      if (u === r || u.contains(r))
        return !0;
    for (var c of l)
      if (c === r || c.contains(r))
        return !0;
  });
  return !i || i === t ? !1 : _W(e, i, n);
}, iM = (e, t) => !!(e.compareDocumentPosition(t) & EW.DOCUMENT_POSITION_PRECEDING), Kre = (e, t) => !!(e.compareDocumentPosition(t) & EW.DOCUMENT_POSITION_FOLLOWING), Yre = 0;
class Jre {
  constructor() {
    jc(this, "id", void 0), this.id = "".concat(Yre++);
  }
}
var Zt = {
  androidPendingDiffs: (e) => Wre.get(e),
  androidScheduleFlush: (e) => {
    var t;
    (t = Hre.get(e)) === null || t === void 0 || t();
  },
  blur: (e) => {
    var t = Zt.toDOMNode(e, e), n = Zt.findDocumentOrShadowRoot(e);
    hf.set(e, !1), n.activeElement === t && t.blur();
  },
  deselect: (e) => {
    var {
      selection: t
    } = e, n = Zt.findDocumentOrShadowRoot(e), r = oM(n);
    r && r.rangeCount > 0 && r.removeAllRanges(), t && gg.deselect(e);
  },
  findDocumentOrShadowRoot: (e) => {
    var t = Zt.toDOMNode(e, e), n = t.getRootNode();
    return n instanceof Document || n instanceof ShadowRoot ? n : t.ownerDocument;
  },
  findEventRange: (e, t) => {
    "nativeEvent" in t && (t = t.nativeEvent);
    var {
      clientX: n,
      clientY: r,
      target: o
    } = t;
    if (n == null || r == null)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var i = Zt.toSlateNode(e, t.target), a = Zt.findPath(e, i);
    if (vs.isElement(i) && Rn.isVoid(e, i)) {
      var s = o.getBoundingClientRect(), l = e.isInline(i) ? n - s.left < s.left + s.width - n : r - s.top < s.top + s.height - r, u = Rn.point(e, a, {
        edge: l ? "start" : "end"
      }), c = l ? Rn.before(e, u) : Rn.after(e, u);
      if (c) {
        var p = Rn.range(e, c);
        return p;
      }
    }
    var d, {
      document: h
    } = Zt.getWindow(e);
    if (h.caretRangeFromPoint)
      d = h.caretRangeFromPoint(n, r);
    else {
      var f = h.caretPositionFromPoint(n, r);
      f && (d = h.createRange(), d.setStart(f.offsetNode, f.offset), d.setEnd(f.offsetNode, f.offset));
    }
    if (!d)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var m = Zt.toSlateRange(e, d, {
      exactMatch: !1,
      suppressThrow: !1
    });
    return m;
  },
  findKey: (e, t) => {
    var n = tM.get(t);
    return n || (n = new Jre(), tM.set(t, n)), n;
  },
  findPath: (e, t) => {
    for (var n = [], r = t; ; ) {
      var o = Rre.get(r);
      if (o == null) {
        if (Rn.isEditor(r))
          return n;
        break;
      }
      var i = Ire.get(r);
      if (i == null)
        break;
      n.unshift(i), r = o;
    }
    throw new Error("Unable to find the path for Slate node: ".concat(qo.stringify(t)));
  },
  focus: function(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      retries: 5
    };
    if (!hf.get(e)) {
      if (t.retries <= 0)
        throw new Error("Could not set focus, editor seems stuck with pending operations");
      if (e.operations.length > 0) {
        setTimeout(() => {
          Zt.focus(e, {
            retries: t.retries - 1
          });
        }, 10);
        return;
      }
      var n = Zt.toDOMNode(e, e), r = Zt.findDocumentOrShadowRoot(e);
      if (r.activeElement !== n) {
        if (e.selection && r instanceof Document) {
          var o = oM(r), i = Zt.toDOMRange(e, e.selection);
          o == null || o.removeAllRanges(), o == null || o.addRange(i);
        }
        e.selection || gg.select(e, Rn.start(e, [])), hf.set(e, !0), n.focus({
          preventScroll: !0
        });
      }
    }
  },
  getWindow: (e) => {
    var t = Nre.get(e);
    if (!t)
      throw new Error("Unable to find a host window element for this editor");
    return t;
  },
  hasDOMNode: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      editable: r = !1
    } = n, o = Zt.toDOMNode(e, e), i;
    try {
      i = Hi(t) ? t : t.parentElement;
    } catch (a) {
      if (a instanceof Error && !a.message.includes('Permission denied to access property "nodeType"'))
        throw a;
    }
    return i ? i.closest("[data-slate-editor]") === o && (!r || i.isContentEditable ? !0 : typeof i.isContentEditable == "boolean" && // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined
    // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable="false"(readOnly)
    i.closest('[contenteditable="false"]') === o || !!i.getAttribute("data-slate-zero-width")) : !1;
  },
  hasEditableTarget: (e, t) => vg(t) && Zt.hasDOMNode(e, t, {
    editable: !0
  }),
  hasRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t;
    return Rn.hasPath(e, n.path) && Rn.hasPath(e, r.path);
  },
  hasSelectableTarget: (e, t) => Zt.hasEditableTarget(e, t) || Zt.isTargetInsideNonReadonlyVoid(e, t),
  hasTarget: (e, t) => vg(t) && Zt.hasDOMNode(e, t),
  insertData: (e, t) => {
    e.insertData(t);
  },
  insertFragmentData: (e, t) => e.insertFragmentData(t),
  insertTextData: (e, t) => e.insertTextData(t),
  isComposing: (e) => !!$re.get(e),
  isFocused: (e) => !!hf.get(e),
  isReadOnly: (e) => !!nM.get(e),
  isTargetInsideNonReadonlyVoid: (e, t) => {
    if (nM.get(e)) return !1;
    var n = Zt.hasTarget(e, t) && Zt.toSlateNode(e, t);
    return vs.isElement(n) && Rn.isVoid(e, n);
  },
  setFragmentData: (e, t, n) => e.setFragmentData(t, n),
  toDOMNode: (e, t) => {
    var n = Ure.get(e), r = Rn.isEditor(t) ? Fre.get(e) : n == null ? void 0 : n.get(Zt.findKey(e, t));
    if (!r)
      throw new Error("Cannot resolve a DOM node from Slate node: ".concat(qo.stringify(t)));
    return r;
  },
  toDOMPoint: (e, t) => {
    var [n] = Rn.node(e, t.path), r = Zt.toDOMNode(e, n), o;
    Rn.void(e, {
      at: t
    }) && (t = {
      path: t.path,
      offset: 0
    });
    for (var i = "[data-slate-string], [data-slate-zero-width]", a = Array.from(r.querySelectorAll(i)), s = 0, l = 0; l < a.length; l++) {
      var u = a[l], c = u.childNodes[0];
      if (!(c == null || c.textContent == null)) {
        var {
          length: p
        } = c.textContent, d = u.getAttribute("data-slate-length"), h = d == null ? p : parseInt(d, 10), f = s + h, m = a[l + 1];
        if (t.offset === f && m !== null && m !== void 0 && m.hasAttribute("data-slate-mark-placeholder")) {
          var g, E = m.childNodes[0];
          o = [
            // COMPAT: If we don't explicity set the dom point to be on the actual
            // dom text element, chrome will put the selection behind the actual dom
            // text element, causing domRange.getBoundingClientRect() calls on a collapsed
            // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)
            // which will cause issues when scrolling to it.
            E instanceof Vre ? E : m,
            (g = m.textContent) !== null && g !== void 0 && g.startsWith("\uFEFF") ? 1 : 0
          ];
          break;
        }
        if (t.offset <= f) {
          var w = Math.min(p, Math.max(0, t.offset - s));
          o = [c, w];
          break;
        }
        s = f;
      }
    }
    if (!o)
      throw new Error("Cannot resolve a DOM point from Slate point: ".concat(qo.stringify(t)));
    return o;
  },
  toDOMRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t, o = Nt.isBackward(t), i = Zt.toDOMPoint(e, n), a = Nt.isCollapsed(t) ? i : Zt.toDOMPoint(e, r), s = Zt.getWindow(e), l = s.document.createRange(), [u, c] = o ? a : i, [p, d] = o ? i : a, h = Hi(u) ? u : u.parentElement, f = !!h.getAttribute("data-slate-zero-width"), m = Hi(p) ? p : p.parentElement, g = !!m.getAttribute("data-slate-zero-width");
    return l.setStart(u, f ? 1 : c), l.setEnd(p, g ? 1 : d), l;
  },
  toSlateNode: (e, t) => {
    var n = Hi(t) ? t : t.parentElement;
    n && !n.hasAttribute("data-slate-node") && (n = n.closest("[data-slate-node]"));
    var r = n ? zre.get(n) : null;
    if (!r)
      throw new Error("Cannot resolve a Slate node from DOM node: ".concat(n));
    return r;
  },
  toSlatePoint: (e, t, n) => {
    var {
      exactMatch: r,
      suppressThrow: o,
      searchDirection: i = "backward"
    } = n, [a, s] = r ? t : Zre(t), l = a.parentNode, u = null, c = 0;
    if (l) {
      var p, d, h = Zt.toDOMNode(e, e), f = l.closest('[data-slate-void="true"]'), m = f && h.contains(f) ? f : null, g = l.closest('[contenteditable="false"]'), E = g && h.contains(g) ? g : null, w = l.closest("[data-slate-leaf]"), M = null;
      if (w) {
        if (u = w.closest('[data-slate-node="text"]'), u) {
          var x = Zt.getWindow(e), y = x.document.createRange();
          y.setStart(u, 0), y.setEnd(a, s);
          var C = y.cloneContents(), P = [...Array.prototype.slice.call(C.querySelectorAll("[data-slate-zero-width]")), ...Array.prototype.slice.call(C.querySelectorAll("[contenteditable=false]"))];
          P.forEach((S) => {
            if (xb && !r && S.hasAttribute("data-slate-zero-width") && S.textContent.length > 0 && S.textContext !== "\uFEFF") {
              S.textContent.startsWith("\uFEFF") && (S.textContent = S.textContent.slice(1));
              return;
            }
            S.parentNode.removeChild(S);
          }), c = C.textContent.length, M = u;
        }
      } else if (m) {
        for (var F = m.querySelectorAll("[data-slate-leaf]"), L = 0; L < F.length; L++) {
          var N = F[L];
          if (Zt.hasDOMNode(e, N)) {
            w = N;
            break;
          }
        }
        w ? (u = w.closest('[data-slate-node="text"]'), M = w, c = M.textContent.length, M.querySelectorAll("[data-slate-zero-width]").forEach((S) => {
          c -= S.textContent.length;
        })) : c = 1;
      } else if (E) {
        var I = (S) => S ? S.querySelectorAll(
          // Exclude leaf nodes in nested editors
          "[data-slate-leaf]:not(:scope [data-slate-editor] [data-slate-leaf])"
        ) : [], H = E.closest('[data-slate-node="element"]');
        if (i === "forward") {
          var V, z = [...I(H), ...I(H == null ? void 0 : H.nextElementSibling)];
          w = (V = z.find((S) => Kre(E, S))) !== null && V !== void 0 ? V : null;
        } else {
          var q, K = [...I(H == null ? void 0 : H.previousElementSibling), ...I(H)];
          w = (q = K.findLast((S) => iM(E, S))) !== null && q !== void 0 ? q : null;
        }
        w && (u = w.closest('[data-slate-node="text"]'), M = w, i === "forward" ? c = 0 : (c = M.textContent.length, M.querySelectorAll("[data-slate-zero-width]").forEach((S) => {
          c -= S.textContent.length;
        })));
      }
      M && c === M.textContent.length && // COMPAT: Android IMEs might remove the zero width space while composing,
      // and we don't add it for line-breaks.
      xb && M.getAttribute("data-slate-zero-width") === "z" && (p = M.textContent) !== null && p !== void 0 && p.startsWith("\uFEFF") && // COMPAT: If the parent node is a Slate zero-width space, editor is
      // because the text node should have no characters. However, during IME
      // composition the ASCII characters will be prepended to the zero-width
      // space, so subtract 1 from the offset to account for the zero-width
      // space character.
      (l.hasAttribute("data-slate-zero-width") || // COMPAT: In Firefox, `range.cloneContents()` returns an extra trailing '\n'
      // when the document ends with a new-line character. This results in the offset
      // length being off by one, so we need to subtract one to account for this.
      ff && (d = M.textContent) !== null && d !== void 0 && d.endsWith(`

`)) && c--;
    }
    if (xb && !u && !r) {
      var J = l.hasAttribute("data-slate-node") ? l : l.closest("[data-slate-node]");
      if (J && Zt.hasDOMNode(e, J, {
        editable: !0
      })) {
        var te = Zt.toSlateNode(e, J), {
          path: ee,
          offset: _
        } = Rn.start(e, Zt.findPath(e, te));
        return J.querySelector("[data-slate-leaf]") || (_ = s), {
          path: ee,
          offset: _
        };
      }
    }
    if (!u) {
      if (o)
        return null;
      throw new Error("Cannot resolve a Slate point from DOM point: ".concat(t));
    }
    var D = Zt.toSlateNode(e, u), $ = Zt.findPath(e, D);
    return {
      path: $,
      offset: c
    };
  },
  toSlateRange: (e, t, n) => {
    var r, {
      exactMatch: o,
      suppressThrow: i
    } = n, a = rM(t) ? t.anchorNode : t.startContainer, s, l, u, c, p;
    if (a)
      if (rM(t)) {
        if (ff && t.rangeCount > 1) {
          u = t.focusNode;
          var d = t.getRangeAt(0), h = t.getRangeAt(t.rangeCount - 1);
          if (u instanceof HTMLTableRowElement && d.startContainer instanceof HTMLTableRowElement && h.startContainer instanceof HTMLTableRowElement) {
            let C = function(P) {
              return P.childElementCount > 0 ? C(P.children[0]) : P;
            };
            var f = d.startContainer, m = h.startContainer, g = C(f.children[d.startOffset]), E = C(m.children[h.startOffset]);
            c = 0, E.childNodes.length > 0 ? s = E.childNodes[0] : s = E, g.childNodes.length > 0 ? u = g.childNodes[0] : u = g, E instanceof HTMLElement ? l = E.innerHTML.length : l = 0;
          } else
            d.startContainer === u ? (s = h.endContainer, l = h.endOffset, c = d.startOffset) : (s = d.startContainer, l = d.endOffset, c = h.startOffset);
        } else
          s = t.anchorNode, l = t.anchorOffset, u = t.focusNode, c = t.focusOffset;
        Bre && Gre(s) || ff ? p = t.anchorNode === t.focusNode && t.anchorOffset === t.focusOffset : p = t.isCollapsed;
      } else
        s = t.startContainer, l = t.startOffset, u = t.endContainer, c = t.endOffset, p = t.collapsed;
    if (s == null || u == null || l == null || c == null)
      throw new Error("Cannot resolve a Slate range from DOM range: ".concat(t));
    ff && (r = u.textContent) !== null && r !== void 0 && r.endsWith(`

`) && c === u.textContent.length && c--;
    var w = Zt.toSlatePoint(e, [s, l], {
      exactMatch: o,
      suppressThrow: i
    });
    if (!w)
      return null;
    var M = iM(s, u) || s === u && c < l, x = p ? w : Zt.toSlatePoint(e, [u, c], {
      exactMatch: o,
      suppressThrow: i,
      searchDirection: M ? "forward" : "backward"
    });
    if (!x)
      return null;
    var y = {
      anchor: w,
      focus: x
    };
    return Nt.isExpanded(y) && Nt.isForward(y) && Hi(u) && Rn.void(e, {
      at: y.focus,
      mode: "highest"
    }) && (y = Rn.unhangRange(e, y, {
      voids: !0
    })), y;
  }
}, Qre = {
  bold: "mod+b",
  compose: ["down", "left", "right", "up", "backspace", "enter"],
  moveBackward: "left",
  moveForward: "right",
  moveWordBackward: "ctrl+left",
  moveWordForward: "ctrl+right",
  deleteBackward: "shift?+backspace",
  deleteForward: "shift?+delete",
  extendBackward: "shift+left",
  extendForward: "shift+right",
  italic: "mod+i",
  insertSoftBreak: "shift+enter",
  splitBlock: "enter",
  undo: "mod+z"
}, eoe = {
  moveLineBackward: "opt+up",
  moveLineForward: "opt+down",
  moveWordBackward: "opt+left",
  moveWordForward: "opt+right",
  deleteBackward: ["ctrl+backspace", "ctrl+h"],
  deleteForward: ["ctrl+delete", "ctrl+d"],
  deleteLineBackward: "cmd+shift?+backspace",
  deleteLineForward: ["cmd+shift?+delete", "ctrl+k"],
  deleteWordBackward: "opt+shift?+backspace",
  deleteWordForward: "opt+shift?+delete",
  extendLineBackward: "opt+shift+up",
  extendLineForward: "opt+shift+down",
  redo: "cmd+shift+z",
  transposeCharacter: "ctrl+t"
}, toe = {
  deleteWordBackward: "ctrl+shift?+backspace",
  deleteWordForward: "ctrl+shift?+delete",
  redo: ["ctrl+y", "ctrl+shift+z"]
}, sr = (e) => {
  var t = Qre[e], n = eoe[e], r = toe[e], o = t && yb(t), i = n && yb(n), a = r && yb(r);
  return (s) => !!(o && o(s) || eM && i && i(s) || !eM && a && a(s));
};
sr("bold"), sr("compose"), sr("moveBackward"), sr("moveForward"), sr("deleteBackward"), sr("deleteForward"), sr("deleteLineBackward"), sr("deleteLineForward"), sr("deleteWordBackward"), sr("deleteWordForward"), sr("extendBackward"), sr("extendForward"), sr("extendLineBackward"), sr("extendLineForward"), sr("italic"), sr("moveLineBackward"), sr("moveLineForward"), sr("moveWordBackward"), sr("moveWordForward"), sr("redo"), sr("insertSoftBreak"), sr("splitBlock"), sr("transposeCharacter"), sr("undo");
var noe = (e, t) => {
  var n = [], r = () => {
    n = [];
  }, o = (a) => {
    if (t.current) {
      var s = a.filter((l) => _W(e, l, a));
      n.push(...s);
    }
  };
  function i() {
    n.length > 0 && (n.reverse().forEach((a) => {
      a.type !== "characterData" && (a.removedNodes.forEach((s) => {
        a.target.insertBefore(s, a.nextSibling);
      }), a.addedNodes.forEach((s) => {
        a.target.removeChild(s);
      }));
    }), r());
  }
  return {
    registerMutations: o,
    restoreDOM: i,
    clear: r
  };
}, roe = {
  subtree: !0,
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0
};
class ooe extends pu {
  constructor() {
    super(...arguments), jc(this, "context", null), jc(this, "manager", null), jc(this, "mutationObserver", null);
  }
  observe() {
    var t, {
      node: n
    } = this.props;
    if (!n.current)
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    (t = this.mutationObserver) === null || t === void 0 || t.observe(n.current, roe);
  }
  componentDidMount() {
    var {
      receivedUserInput: t
    } = this.props, n = this.context;
    this.manager = noe(n, t), this.mutationObserver = new MutationObserver(this.manager.registerMutations), this.observe();
  }
  getSnapshotBeforeUpdate() {
    var t, n, r, o = (t = this.mutationObserver) === null || t === void 0 ? void 0 : t.takeRecords();
    if (o != null && o.length) {
      var i;
      (i = this.manager) === null || i === void 0 || i.registerMutations(o);
    }
    return (n = this.mutationObserver) === null || n === void 0 || n.disconnect(), (r = this.manager) === null || r === void 0 || r.restoreDOM(), null;
  }
  componentDidUpdate() {
    var t;
    (t = this.manager) === null || t === void 0 || t.clear(), this.observe();
  }
  componentWillUnmount() {
    var t;
    (t = this.mutationObserver) === null || t === void 0 || t.disconnect();
  }
  render() {
    return this.props.children;
  }
}
jc(ooe, "contextType", Are);
Ze({});
Ze({});
Ze({});
var Fr = {}, VE = {}, zp = {}, Up = {}, PW = "Expected a function", sM = NaN, ioe = "[object Symbol]", soe = /^\s+|\s+$/g, aoe = /^[-+]0x[0-9a-f]+$/i, loe = /^0b[01]+$/i, uoe = /^0o[0-7]+$/i, coe = parseInt, poe = typeof Hn == "object" && Hn && Hn.Object === Object && Hn, doe = typeof self == "object" && self && self.Object === Object && self, foe = poe || doe || Function("return this")(), hoe = Object.prototype, goe = hoe.toString, moe = Math.max, voe = Math.min, Ob = function() {
  return foe.Date.now();
};
function yoe(e, t, n) {
  var r, o, i, a, s, l, u = 0, c = !1, p = !1, d = !0;
  if (typeof e != "function")
    throw new TypeError(PW);
  t = aM(t) || 0, yg(n) && (c = !!n.leading, p = "maxWait" in n, i = p ? moe(aM(n.maxWait) || 0, t) : i, d = "trailing" in n ? !!n.trailing : d);
  function h(C) {
    var P = r, F = o;
    return r = o = void 0, u = C, a = e.apply(F, P), a;
  }
  function f(C) {
    return u = C, s = setTimeout(E, t), c ? h(C) : a;
  }
  function m(C) {
    var P = C - l, F = C - u, L = t - P;
    return p ? voe(L, i - F) : L;
  }
  function g(C) {
    var P = C - l, F = C - u;
    return l === void 0 || P >= t || P < 0 || p && F >= i;
  }
  function E() {
    var C = Ob();
    if (g(C))
      return w(C);
    s = setTimeout(E, m(C));
  }
  function w(C) {
    return s = void 0, d && r ? h(C) : (r = o = void 0, a);
  }
  function M() {
    s !== void 0 && clearTimeout(s), u = 0, r = l = o = s = void 0;
  }
  function x() {
    return s === void 0 ? a : w(Ob());
  }
  function y() {
    var C = Ob(), P = g(C);
    if (r = arguments, o = this, l = C, P) {
      if (s === void 0)
        return f(l);
      if (p)
        return s = setTimeout(E, t), h(l);
    }
    return s === void 0 && (s = setTimeout(E, t)), a;
  }
  return y.cancel = M, y.flush = x, y;
}
function boe(e, t, n) {
  var r = !0, o = !0;
  if (typeof e != "function")
    throw new TypeError(PW);
  return yg(n) && (r = "leading" in n ? !!n.leading : r, o = "trailing" in n ? !!n.trailing : o), yoe(e, t, {
    leading: r,
    maxWait: t,
    trailing: o
  });
}
function yg(e) {
  var t = typeof e;
  return !!e && (t == "object" || t == "function");
}
function woe(e) {
  return !!e && typeof e == "object";
}
function Coe(e) {
  return typeof e == "symbol" || woe(e) && goe.call(e) == ioe;
}
function aM(e) {
  if (typeof e == "number")
    return e;
  if (Coe(e))
    return sM;
  if (yg(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = yg(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = e.replace(soe, "");
  var n = loe.test(e);
  return n || uoe.test(e) ? coe(e.slice(2), n ? 2 : 8) : aoe.test(e) ? sM : +e;
}
var xoe = boe, $p = {};
Object.defineProperty($p, "__esModule", {
  value: !0
});
$p.addPassiveEventListener = function(e, t, n) {
  var r = n.name;
  r || (r = t, console.warn("Listener must be a named function.")), Ph.has(t) || Ph.set(t, /* @__PURE__ */ new Set());
  var o = Ph.get(t);
  if (!o.has(r)) {
    var i = function() {
      var a = !1;
      try {
        var s = Object.defineProperty({}, "passive", {
          get: function() {
            a = !0;
          }
        });
        window.addEventListener("test", null, s);
      } catch {
      }
      return a;
    }();
    e.addEventListener(t, n, i ? { passive: !0 } : !1), o.add(r);
  }
};
$p.removePassiveEventListener = function(e, t, n) {
  e.removeEventListener(t, n), Ph.get(t).delete(n.name || t);
};
var Ph = /* @__PURE__ */ new Map();
Object.defineProperty(Up, "__esModule", {
  value: !0
});
var Ooe = xoe, Eoe = koe(Ooe), lM = $p;
function koe(e) {
  return e && e.__esModule ? e : { default: e };
}
var Loe = function(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 66;
  return (0, Eoe.default)(e, t);
}, xr = {
  spyCallbacks: [],
  spySetState: [],
  scrollSpyContainers: [],
  mount: function(e, t) {
    if (e) {
      var n = Loe(function(r) {
        xr.scrollHandler(e);
      }, t);
      return xr.scrollSpyContainers.push(e), (0, lM.addPassiveEventListener)(e, "scroll", n), function() {
        (0, lM.removePassiveEventListener)(e, "scroll", n), xr.scrollSpyContainers.splice(xr.scrollSpyContainers.indexOf(e), 1);
      };
    }
    return function() {
    };
  },
  isMounted: function(e) {
    return xr.scrollSpyContainers.indexOf(e) !== -1;
  },
  currentPositionX: function(e) {
    if (e === document) {
      var t = window.scrollY !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.scrollX : n ? document.documentElement.scrollLeft : document.body.scrollLeft;
    } else
      return e.scrollLeft;
  },
  currentPositionY: function(e) {
    if (e === document) {
      var t = window.scrollX !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.scrollY : n ? document.documentElement.scrollTop : document.body.scrollTop;
    } else
      return e.scrollTop;
  },
  scrollHandler: function(e) {
    var t = xr.scrollSpyContainers[xr.scrollSpyContainers.indexOf(e)].spyCallbacks || [];
    t.forEach(function(n) {
      return n(xr.currentPositionX(e), xr.currentPositionY(e));
    });
  },
  addStateHandler: function(e) {
    xr.spySetState.push(e);
  },
  addSpyHandler: function(e, t) {
    var n = xr.scrollSpyContainers[xr.scrollSpyContainers.indexOf(t)];
    n.spyCallbacks || (n.spyCallbacks = []), n.spyCallbacks.push(e);
  },
  updateStates: function() {
    xr.spySetState.forEach(function(e) {
      return e();
    });
  },
  unmount: function(e, t) {
    xr.scrollSpyContainers.forEach(function(n) {
      return n.spyCallbacks && n.spyCallbacks.length && n.spyCallbacks.indexOf(t) > -1 && n.spyCallbacks.splice(n.spyCallbacks.indexOf(t), 1);
    }), xr.spySetState && xr.spySetState.length && xr.spySetState.indexOf(e) > -1 && xr.spySetState.splice(xr.spySetState.indexOf(e), 1), document.removeEventListener("scroll", xr.scrollHandler);
  },
  update: function() {
    return xr.scrollSpyContainers.forEach(function(e) {
      return xr.scrollHandler(e);
    });
  }
};
Up.default = xr;
var yu = {}, Hp = {};
Object.defineProperty(Hp, "__esModule", {
  value: !0
});
var _oe = function(e, t) {
  var n = e.indexOf("#") === 0 ? e.substring(1) : e, r = n ? "#" + n : "", o = window && window.location, i = r ? o.pathname + o.search + r : o.pathname + o.search;
  t ? history.pushState(history.state, "", i) : history.replaceState(history.state, "", i);
}, Poe = function() {
  return window.location.hash.replace(/^#/, "");
}, Soe = function(e) {
  return function(t) {
    return e.contains ? e != t && e.contains(t) : !!(e.compareDocumentPosition(t) & 16);
  };
}, Moe = function(e) {
  return getComputedStyle(e).position !== "static";
}, Eb = function(e, t) {
  for (var n = e.offsetTop, r = e.offsetParent; r && !t(r); )
    n += r.offsetTop, r = r.offsetParent;
  return { offsetTop: n, offsetParent: r };
}, Doe = function(e, t, n) {
  if (n)
    return e === document ? t.getBoundingClientRect().left + (window.scrollX || window.pageXOffset) : getComputedStyle(e).position !== "static" ? t.offsetLeft : t.offsetLeft - e.offsetLeft;
  if (e === document)
    return t.getBoundingClientRect().top + (window.scrollY || window.pageYOffset);
  if (Moe(e)) {
    if (t.offsetParent !== e) {
      var r = function(l) {
        return l === e || l === document;
      }, o = Eb(t, r), i = o.offsetTop, a = o.offsetParent;
      if (a !== e)
        throw new Error("Seems containerElement is not an ancestor of the Element");
      return i;
    }
    return t.offsetTop;
  }
  if (t.offsetParent === e.offsetParent)
    return t.offsetTop - e.offsetTop;
  var s = function(l) {
    return l === document;
  };
  return Eb(t, s).offsetTop - Eb(e, s).offsetTop;
};
Hp.default = {
  updateHash: _oe,
  getHash: Poe,
  filterElementInContainer: Soe,
  scrollOffset: Doe
};
var Vv = {}, qE = {};
Object.defineProperty(qE, "__esModule", {
  value: !0
});
qE.default = {
  /*
   * https://github.com/oblador/angular-scroll (duScrollDefaultEasing)
   */
  defaultEasing: function(e) {
    return e < 0.5 ? Math.pow(e * 2, 2) / 2 : 1 - Math.pow((1 - e) * 2, 2) / 2;
  },
  /*
   * https://gist.github.com/gre/1650294
   */
  // no easing, no acceleration
  linear: function(e) {
    return e;
  },
  // accelerating from zero velocity
  easeInQuad: function(e) {
    return e * e;
  },
  // decelerating to zero velocity
  easeOutQuad: function(e) {
    return e * (2 - e);
  },
  // acceleration until halfway, then deceleration
  easeInOutQuad: function(e) {
    return e < 0.5 ? 2 * e * e : -1 + (4 - 2 * e) * e;
  },
  // accelerating from zero velocity 
  easeInCubic: function(e) {
    return e * e * e;
  },
  // decelerating to zero velocity 
  easeOutCubic: function(e) {
    return --e * e * e + 1;
  },
  // acceleration until halfway, then deceleration 
  easeInOutCubic: function(e) {
    return e < 0.5 ? 4 * e * e * e : (e - 1) * (2 * e - 2) * (2 * e - 2) + 1;
  },
  // accelerating from zero velocity 
  easeInQuart: function(e) {
    return e * e * e * e;
  },
  // decelerating to zero velocity 
  easeOutQuart: function(e) {
    return 1 - --e * e * e * e;
  },
  // acceleration until halfway, then deceleration
  easeInOutQuart: function(e) {
    return e < 0.5 ? 8 * e * e * e * e : 1 - 8 * --e * e * e * e;
  },
  // accelerating from zero velocity
  easeInQuint: function(e) {
    return e * e * e * e * e;
  },
  // decelerating to zero velocity
  easeOutQuint: function(e) {
    return 1 + --e * e * e * e * e;
  },
  // acceleration until halfway, then deceleration 
  easeInOutQuint: function(e) {
    return e < 0.5 ? 16 * e * e * e * e * e : 1 + 16 * --e * e * e * e * e;
  }
};
var ZE = {};
Object.defineProperty(ZE, "__esModule", {
  value: !0
});
var Toe = $p, joe = ["mousedown", "wheel", "touchmove", "keydown"];
ZE.default = {
  subscribe: function(e) {
    return typeof document < "u" && joe.forEach(function(t) {
      return (0, Toe.addPassiveEventListener)(document, t, e);
    });
  }
};
var Wp = {};
Object.defineProperty(Wp, "__esModule", {
  value: !0
});
var ZC = {
  registered: {},
  scrollEvent: {
    register: function(e, t) {
      ZC.registered[e] = t;
    },
    remove: function(e) {
      ZC.registered[e] = null;
    }
  }
};
Wp.default = ZC;
Object.defineProperty(Vv, "__esModule", {
  value: !0
});
var Aoe = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, Boe = Hp;
qv(Boe);
var Ioe = qE, uM = qv(Ioe), Roe = ZE, Noe = qv(Roe), Foe = Wp, Ri = qv(Foe);
function qv(e) {
  return e && e.__esModule ? e : { default: e };
}
var SW = function(e) {
  return uM.default[e.smooth] || uM.default.defaultEasing;
}, zoe = function(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}, Uoe = function() {
  if (typeof window < "u")
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame;
}, GC = function() {
  return Uoe() || function(e, t, n) {
    window.setTimeout(e, n || 1e3 / 60, (/* @__PURE__ */ new Date()).getTime());
  };
}(), MW = function() {
  return {
    currentPosition: 0,
    startPosition: 0,
    targetPosition: 0,
    progress: 0,
    duration: 0,
    cancel: !1,
    target: null,
    containerElement: null,
    to: null,
    start: null,
    delta: null,
    percent: null,
    delayTimeout: null
  };
}, DW = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollLeft;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageXOffset : r ? document.documentElement.scrollLeft : document.body.scrollLeft;
}, TW = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollTop;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageYOffset : r ? document.documentElement.scrollTop : document.body.scrollTop;
}, $oe = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollWidth - t.offsetWidth;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollWidth, n.offsetWidth, r.clientWidth, r.scrollWidth, r.offsetWidth);
}, Hoe = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollHeight - t.offsetHeight;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollHeight, n.offsetHeight, r.clientHeight, r.scrollHeight, r.offsetHeight);
}, Woe = function e(t, n, r) {
  var o = n.data;
  if (!n.ignoreCancelEvents && o.cancel) {
    Ri.default.registered.end && Ri.default.registered.end(o.to, o.target, o.currentPositionY);
    return;
  }
  if (o.delta = Math.round(o.targetPosition - o.startPosition), o.start === null && (o.start = r), o.progress = r - o.start, o.percent = o.progress >= o.duration ? 1 : t(o.progress / o.duration), o.currentPosition = o.startPosition + Math.ceil(o.delta * o.percent), o.containerElement && o.containerElement !== document && o.containerElement !== document.body ? n.horizontal ? o.containerElement.scrollLeft = o.currentPosition : o.containerElement.scrollTop = o.currentPosition : n.horizontal ? window.scrollTo(o.currentPosition, 0) : window.scrollTo(0, o.currentPosition), o.percent < 1) {
    var i = e.bind(null, t, n);
    GC.call(window, i);
    return;
  }
  Ri.default.registered.end && Ri.default.registered.end(o.to, o.target, o.currentPosition);
}, GE = function(e) {
  e.data.containerElement = e ? e.containerId ? document.getElementById(e.containerId) : e.container && e.container.nodeType ? e.container : document : null;
}, Vp = function(e, t, n, r) {
  t.data = t.data || MW(), window.clearTimeout(t.data.delayTimeout);
  var o = function() {
    t.data.cancel = !0;
  };
  if (Noe.default.subscribe(o), GE(t), t.data.start = null, t.data.cancel = !1, t.data.startPosition = t.horizontal ? DW(t) : TW(t), t.data.targetPosition = t.absolute ? e : e + t.data.startPosition, t.data.startPosition === t.data.targetPosition) {
    Ri.default.registered.end && Ri.default.registered.end(t.data.to, t.data.target, t.data.currentPosition);
    return;
  }
  t.data.delta = Math.round(t.data.targetPosition - t.data.startPosition), t.data.duration = zoe(t.duration)(t.data.delta), t.data.duration = isNaN(parseFloat(t.data.duration)) ? 1e3 : parseFloat(t.data.duration), t.data.to = n, t.data.target = r;
  var i = SW(t), a = Woe.bind(null, i, t);
  if (t && t.delay > 0) {
    t.data.delayTimeout = window.setTimeout(function() {
      Ri.default.registered.begin && Ri.default.registered.begin(t.data.to, t.data.target), GC.call(window, a);
    }, t.delay);
    return;
  }
  Ri.default.registered.begin && Ri.default.registered.begin(t.data.to, t.data.target), GC.call(window, a);
}, Zv = function(e) {
  return e = Aoe({}, e), e.data = e.data || MW(), e.absolute = !0, e;
}, Voe = function(e) {
  Vp(0, Zv(e));
}, qoe = function(e, t) {
  Vp(e, Zv(t));
}, Zoe = function(e) {
  e = Zv(e), GE(e), Vp(e.horizontal ? $oe(e) : Hoe(e), e);
}, Goe = function(e, t) {
  t = Zv(t), GE(t);
  var n = t.horizontal ? DW(t) : TW(t);
  Vp(e + n, t);
};
Vv.default = {
  animateTopScroll: Vp,
  getAnimationType: SW,
  scrollToTop: Voe,
  scrollToBottom: Zoe,
  scrollTo: qoe,
  scrollMore: Goe
};
Object.defineProperty(yu, "__esModule", {
  value: !0
});
var Xoe = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, Koe = Hp, Yoe = XE(Koe), Joe = Vv, Qoe = XE(Joe), eie = Wp, gf = XE(eie);
function XE(e) {
  return e && e.__esModule ? e : { default: e };
}
var mf = {}, cM = void 0;
yu.default = {
  unmount: function() {
    mf = {};
  },
  register: function(e, t) {
    mf[e] = t;
  },
  unregister: function(e) {
    delete mf[e];
  },
  get: function(e) {
    return mf[e] || document.getElementById(e) || document.getElementsByName(e)[0] || document.getElementsByClassName(e)[0];
  },
  setActiveLink: function(e) {
    return cM = e;
  },
  getActiveLink: function() {
    return cM;
  },
  scrollTo: function(e, t) {
    var n = this.get(e);
    if (!n) {
      console.warn("target Element not found");
      return;
    }
    t = Xoe({}, t, { absolute: !1 });
    var r = t.containerId, o = t.container, i = void 0;
    r ? i = document.getElementById(r) : o && o.nodeType ? i = o : i = document, t.absolute = !0;
    var a = t.horizontal, s = Yoe.default.scrollOffset(i, n, a) + (t.offset || 0);
    if (!t.smooth) {
      gf.default.registered.begin && gf.default.registered.begin(e, n), i === document ? t.horizontal ? window.scrollTo(s, 0) : window.scrollTo(0, s) : i.scrollTop = s, gf.default.registered.end && gf.default.registered.end(e, n);
      return;
    }
    Qoe.default.animateTopScroll(s, t, e, n);
  }
};
var XC = { exports: {} }, kb = { exports: {} }, vn = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var pM;
function tie() {
  if (pM) return vn;
  pM = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, h = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, m = e ? Symbol.for("react.block") : 60121, g = e ? Symbol.for("react.fundamental") : 60117, E = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
  function M(y) {
    if (typeof y == "object" && y !== null) {
      var C = y.$$typeof;
      switch (C) {
        case t:
          switch (y = y.type, y) {
            case l:
            case u:
            case r:
            case i:
            case o:
            case p:
              return y;
            default:
              switch (y = y && y.$$typeof, y) {
                case s:
                case c:
                case f:
                case h:
                case a:
                  return y;
                default:
                  return C;
              }
          }
        case n:
          return C;
      }
    }
  }
  function x(y) {
    return M(y) === u;
  }
  return vn.AsyncMode = l, vn.ConcurrentMode = u, vn.ContextConsumer = s, vn.ContextProvider = a, vn.Element = t, vn.ForwardRef = c, vn.Fragment = r, vn.Lazy = f, vn.Memo = h, vn.Portal = n, vn.Profiler = i, vn.StrictMode = o, vn.Suspense = p, vn.isAsyncMode = function(y) {
    return x(y) || M(y) === l;
  }, vn.isConcurrentMode = x, vn.isContextConsumer = function(y) {
    return M(y) === s;
  }, vn.isContextProvider = function(y) {
    return M(y) === a;
  }, vn.isElement = function(y) {
    return typeof y == "object" && y !== null && y.$$typeof === t;
  }, vn.isForwardRef = function(y) {
    return M(y) === c;
  }, vn.isFragment = function(y) {
    return M(y) === r;
  }, vn.isLazy = function(y) {
    return M(y) === f;
  }, vn.isMemo = function(y) {
    return M(y) === h;
  }, vn.isPortal = function(y) {
    return M(y) === n;
  }, vn.isProfiler = function(y) {
    return M(y) === i;
  }, vn.isStrictMode = function(y) {
    return M(y) === o;
  }, vn.isSuspense = function(y) {
    return M(y) === p;
  }, vn.isValidElementType = function(y) {
    return typeof y == "string" || typeof y == "function" || y === r || y === u || y === i || y === o || y === p || y === d || typeof y == "object" && y !== null && (y.$$typeof === f || y.$$typeof === h || y.$$typeof === a || y.$$typeof === s || y.$$typeof === c || y.$$typeof === g || y.$$typeof === E || y.$$typeof === w || y.$$typeof === m);
  }, vn.typeOf = M, vn;
}
var _n = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var dM;
function nie() {
  return dM || (dM = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, h = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, m = e ? Symbol.for("react.block") : 60121, g = e ? Symbol.for("react.fundamental") : 60117, E = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
    function M(R) {
      return typeof R == "string" || typeof R == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      R === r || R === u || R === i || R === o || R === p || R === d || typeof R == "object" && R !== null && (R.$$typeof === f || R.$$typeof === h || R.$$typeof === a || R.$$typeof === s || R.$$typeof === c || R.$$typeof === g || R.$$typeof === E || R.$$typeof === w || R.$$typeof === m);
    }
    function x(R) {
      if (typeof R == "object" && R !== null) {
        var ue = R.$$typeof;
        switch (ue) {
          case t:
            var fe = R.type;
            switch (fe) {
              case l:
              case u:
              case r:
              case i:
              case o:
              case p:
                return fe;
              default:
                var oe = fe && fe.$$typeof;
                switch (oe) {
                  case s:
                  case c:
                  case f:
                  case h:
                  case a:
                    return oe;
                  default:
                    return ue;
                }
            }
          case n:
            return ue;
        }
      }
    }
    var y = l, C = u, P = s, F = a, L = t, N = c, I = r, H = f, V = h, z = n, q = i, K = o, J = p, te = !1;
    function ee(R) {
      return te || (te = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), _(R) || x(R) === l;
    }
    function _(R) {
      return x(R) === u;
    }
    function D(R) {
      return x(R) === s;
    }
    function $(R) {
      return x(R) === a;
    }
    function S(R) {
      return typeof R == "object" && R !== null && R.$$typeof === t;
    }
    function W(R) {
      return x(R) === c;
    }
    function O(R) {
      return x(R) === r;
    }
    function T(R) {
      return x(R) === f;
    }
    function U(R) {
      return x(R) === h;
    }
    function j(R) {
      return x(R) === n;
    }
    function Z(R) {
      return x(R) === i;
    }
    function A(R) {
      return x(R) === o;
    }
    function Q(R) {
      return x(R) === p;
    }
    _n.AsyncMode = y, _n.ConcurrentMode = C, _n.ContextConsumer = P, _n.ContextProvider = F, _n.Element = L, _n.ForwardRef = N, _n.Fragment = I, _n.Lazy = H, _n.Memo = V, _n.Portal = z, _n.Profiler = q, _n.StrictMode = K, _n.Suspense = J, _n.isAsyncMode = ee, _n.isConcurrentMode = _, _n.isContextConsumer = D, _n.isContextProvider = $, _n.isElement = S, _n.isForwardRef = W, _n.isFragment = O, _n.isLazy = T, _n.isMemo = U, _n.isPortal = j, _n.isProfiler = Z, _n.isStrictMode = A, _n.isSuspense = Q, _n.isValidElementType = M, _n.typeOf = x;
  }()), _n;
}
var fM;
function jW() {
  return fM || (fM = 1, process.env.NODE_ENV === "production" ? kb.exports = tie() : kb.exports = nie()), kb.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var Lb, hM;
function rie() {
  if (hM) return Lb;
  hM = 1;
  var e = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, n = Object.prototype.propertyIsEnumerable;
  function r(i) {
    if (i == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(i);
  }
  function o() {
    try {
      if (!Object.assign)
        return !1;
      var i = new String("abc");
      if (i[5] = "de", Object.getOwnPropertyNames(i)[0] === "5")
        return !1;
      for (var a = {}, s = 0; s < 10; s++)
        a["_" + String.fromCharCode(s)] = s;
      var l = Object.getOwnPropertyNames(a).map(function(c) {
        return a[c];
      });
      if (l.join("") !== "0123456789")
        return !1;
      var u = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(c) {
        u[c] = c;
      }), Object.keys(Object.assign({}, u)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return Lb = o() ? Object.assign : function(i, a) {
    for (var s, l = r(i), u, c = 1; c < arguments.length; c++) {
      s = Object(arguments[c]);
      for (var p in s)
        t.call(s, p) && (l[p] = s[p]);
      if (e) {
        u = e(s);
        for (var d = 0; d < u.length; d++)
          n.call(s, u[d]) && (l[u[d]] = s[u[d]]);
      }
    }
    return l;
  }, Lb;
}
var _b, gM;
function KE() {
  if (gM) return _b;
  gM = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return _b = e, _b;
}
var mM, vM;
function AW() {
  return vM || (vM = 1, mM = Function.call.bind(Object.prototype.hasOwnProperty)), mM;
}
var Pb, yM;
function oie() {
  if (yM) return Pb;
  yM = 1;
  var e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = KE(), n = {}, r = AW();
    e = function(i) {
      var a = "Warning: " + i;
      typeof console < "u" && console.error(a);
      try {
        throw new Error(a);
      } catch {
      }
    };
  }
  function o(i, a, s, l, u) {
    if (process.env.NODE_ENV !== "production") {
      for (var c in i)
        if (r(i, c)) {
          var p;
          try {
            if (typeof i[c] != "function") {
              var d = Error(
                (l || "React class") + ": " + s + " type `" + c + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof i[c] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw d.name = "Invariant Violation", d;
            }
            p = i[c](a, c, l, s, null, t);
          } catch (f) {
            p = f;
          }
          if (p && !(p instanceof Error) && e(
            (l || "React class") + ": type specification of " + s + " `" + c + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof p + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), p instanceof Error && !(p.message in n)) {
            n[p.message] = !0;
            var h = u ? u() : "";
            e(
              "Failed " + s + " type: " + p.message + (h ?? "")
            );
          }
        }
    }
  }
  return o.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (n = {});
  }, Pb = o, Pb;
}
var Sb, bM;
function iie() {
  if (bM) return Sb;
  bM = 1;
  var e = jW(), t = rie(), n = KE(), r = AW(), o = oie(), i = function() {
  };
  process.env.NODE_ENV !== "production" && (i = function(s) {
    var l = "Warning: " + s;
    typeof console < "u" && console.error(l);
    try {
      throw new Error(l);
    } catch {
    }
  });
  function a() {
    return null;
  }
  return Sb = function(s, l) {
    var u = typeof Symbol == "function" && Symbol.iterator, c = "@@iterator";
    function p(_) {
      var D = _ && (u && _[u] || _[c]);
      if (typeof D == "function")
        return D;
    }
    var d = "<<anonymous>>", h = {
      array: E("array"),
      bigint: E("bigint"),
      bool: E("boolean"),
      func: E("function"),
      number: E("number"),
      object: E("object"),
      string: E("string"),
      symbol: E("symbol"),
      any: w(),
      arrayOf: M,
      element: x(),
      elementType: y(),
      instanceOf: C,
      node: N(),
      objectOf: F,
      oneOf: P,
      oneOfType: L,
      shape: H,
      exact: V
    };
    function f(_, D) {
      return _ === D ? _ !== 0 || 1 / _ === 1 / D : _ !== _ && D !== D;
    }
    function m(_, D) {
      this.message = _, this.data = D && typeof D == "object" ? D : {}, this.stack = "";
    }
    m.prototype = Error.prototype;
    function g(_) {
      if (process.env.NODE_ENV !== "production")
        var D = {}, $ = 0;
      function S(O, T, U, j, Z, A, Q) {
        if (j = j || d, A = A || U, Q !== n) {
          if (l) {
            var R = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw R.name = "Invariant Violation", R;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var ue = j + ":" + U;
            !D[ue] && // Avoid spamming the console because they are often not actionable except for lib authors
            $ < 3 && (i(
              "You are manually calling a React.PropTypes validation function for the `" + A + "` prop on `" + j + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), D[ue] = !0, $++);
          }
        }
        return T[U] == null ? O ? T[U] === null ? new m("The " + Z + " `" + A + "` is marked as required " + ("in `" + j + "`, but its value is `null`.")) : new m("The " + Z + " `" + A + "` is marked as required in " + ("`" + j + "`, but its value is `undefined`.")) : null : _(T, U, j, Z, A);
      }
      var W = S.bind(null, !1);
      return W.isRequired = S.bind(null, !0), W;
    }
    function E(_) {
      function D($, S, W, O, T, U) {
        var j = $[S], Z = K(j);
        if (Z !== _) {
          var A = J(j);
          return new m(
            "Invalid " + O + " `" + T + "` of type " + ("`" + A + "` supplied to `" + W + "`, expected ") + ("`" + _ + "`."),
            { expectedType: _ }
          );
        }
        return null;
      }
      return g(D);
    }
    function w() {
      return g(a);
    }
    function M(_) {
      function D($, S, W, O, T) {
        if (typeof _ != "function")
          return new m("Property `" + T + "` of component `" + W + "` has invalid PropType notation inside arrayOf.");
        var U = $[S];
        if (!Array.isArray(U)) {
          var j = K(U);
          return new m("Invalid " + O + " `" + T + "` of type " + ("`" + j + "` supplied to `" + W + "`, expected an array."));
        }
        for (var Z = 0; Z < U.length; Z++) {
          var A = _(U, Z, W, O, T + "[" + Z + "]", n);
          if (A instanceof Error)
            return A;
        }
        return null;
      }
      return g(D);
    }
    function x() {
      function _(D, $, S, W, O) {
        var T = D[$];
        if (!s(T)) {
          var U = K(T);
          return new m("Invalid " + W + " `" + O + "` of type " + ("`" + U + "` supplied to `" + S + "`, expected a single ReactElement."));
        }
        return null;
      }
      return g(_);
    }
    function y() {
      function _(D, $, S, W, O) {
        var T = D[$];
        if (!e.isValidElementType(T)) {
          var U = K(T);
          return new m("Invalid " + W + " `" + O + "` of type " + ("`" + U + "` supplied to `" + S + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return g(_);
    }
    function C(_) {
      function D($, S, W, O, T) {
        if (!($[S] instanceof _)) {
          var U = _.name || d, j = ee($[S]);
          return new m("Invalid " + O + " `" + T + "` of type " + ("`" + j + "` supplied to `" + W + "`, expected ") + ("instance of `" + U + "`."));
        }
        return null;
      }
      return g(D);
    }
    function P(_) {
      if (!Array.isArray(_))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? i(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : i("Invalid argument supplied to oneOf, expected an array.")), a;
      function D($, S, W, O, T) {
        for (var U = $[S], j = 0; j < _.length; j++)
          if (f(U, _[j]))
            return null;
        var Z = JSON.stringify(_, function(A, Q) {
          var R = J(Q);
          return R === "symbol" ? String(Q) : Q;
        });
        return new m("Invalid " + O + " `" + T + "` of value `" + String(U) + "` " + ("supplied to `" + W + "`, expected one of " + Z + "."));
      }
      return g(D);
    }
    function F(_) {
      function D($, S, W, O, T) {
        if (typeof _ != "function")
          return new m("Property `" + T + "` of component `" + W + "` has invalid PropType notation inside objectOf.");
        var U = $[S], j = K(U);
        if (j !== "object")
          return new m("Invalid " + O + " `" + T + "` of type " + ("`" + j + "` supplied to `" + W + "`, expected an object."));
        for (var Z in U)
          if (r(U, Z)) {
            var A = _(U, Z, W, O, T + "." + Z, n);
            if (A instanceof Error)
              return A;
          }
        return null;
      }
      return g(D);
    }
    function L(_) {
      if (!Array.isArray(_))
        return process.env.NODE_ENV !== "production" && i("Invalid argument supplied to oneOfType, expected an instance of array."), a;
      for (var D = 0; D < _.length; D++) {
        var $ = _[D];
        if (typeof $ != "function")
          return i(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + te($) + " at index " + D + "."
          ), a;
      }
      function S(W, O, T, U, j) {
        for (var Z = [], A = 0; A < _.length; A++) {
          var Q = _[A], R = Q(W, O, T, U, j, n);
          if (R == null)
            return null;
          R.data && r(R.data, "expectedType") && Z.push(R.data.expectedType);
        }
        var ue = Z.length > 0 ? ", expected one of type [" + Z.join(", ") + "]" : "";
        return new m("Invalid " + U + " `" + j + "` supplied to " + ("`" + T + "`" + ue + "."));
      }
      return g(S);
    }
    function N() {
      function _(D, $, S, W, O) {
        return z(D[$]) ? null : new m("Invalid " + W + " `" + O + "` supplied to " + ("`" + S + "`, expected a ReactNode."));
      }
      return g(_);
    }
    function I(_, D, $, S, W) {
      return new m(
        (_ || "React class") + ": " + D + " type `" + $ + "." + S + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + W + "`."
      );
    }
    function H(_) {
      function D($, S, W, O, T) {
        var U = $[S], j = K(U);
        if (j !== "object")
          return new m("Invalid " + O + " `" + T + "` of type `" + j + "` " + ("supplied to `" + W + "`, expected `object`."));
        for (var Z in _) {
          var A = _[Z];
          if (typeof A != "function")
            return I(W, O, T, Z, J(A));
          var Q = A(U, Z, W, O, T + "." + Z, n);
          if (Q)
            return Q;
        }
        return null;
      }
      return g(D);
    }
    function V(_) {
      function D($, S, W, O, T) {
        var U = $[S], j = K(U);
        if (j !== "object")
          return new m("Invalid " + O + " `" + T + "` of type `" + j + "` " + ("supplied to `" + W + "`, expected `object`."));
        var Z = t({}, $[S], _);
        for (var A in Z) {
          var Q = _[A];
          if (r(_, A) && typeof Q != "function")
            return I(W, O, T, A, J(Q));
          if (!Q)
            return new m(
              "Invalid " + O + " `" + T + "` key `" + A + "` supplied to `" + W + "`.\nBad object: " + JSON.stringify($[S], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(_), null, "  ")
            );
          var R = Q(U, A, W, O, T + "." + A, n);
          if (R)
            return R;
        }
        return null;
      }
      return g(D);
    }
    function z(_) {
      switch (typeof _) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !_;
        case "object":
          if (Array.isArray(_))
            return _.every(z);
          if (_ === null || s(_))
            return !0;
          var D = p(_);
          if (D) {
            var $ = D.call(_), S;
            if (D !== _.entries) {
              for (; !(S = $.next()).done; )
                if (!z(S.value))
                  return !1;
            } else
              for (; !(S = $.next()).done; ) {
                var W = S.value;
                if (W && !z(W[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function q(_, D) {
      return _ === "symbol" ? !0 : D ? D["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && D instanceof Symbol : !1;
    }
    function K(_) {
      var D = typeof _;
      return Array.isArray(_) ? "array" : _ instanceof RegExp ? "object" : q(D, _) ? "symbol" : D;
    }
    function J(_) {
      if (typeof _ > "u" || _ === null)
        return "" + _;
      var D = K(_);
      if (D === "object") {
        if (_ instanceof Date)
          return "date";
        if (_ instanceof RegExp)
          return "regexp";
      }
      return D;
    }
    function te(_) {
      var D = J(_);
      switch (D) {
        case "array":
        case "object":
          return "an " + D;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + D;
        default:
          return D;
      }
    }
    function ee(_) {
      return !_.constructor || !_.constructor.name ? d : _.constructor.name;
    }
    return h.checkPropTypes = o, h.resetWarningCache = o.resetWarningCache, h.PropTypes = h, h;
  }, Sb;
}
var Mb, wM;
function sie() {
  if (wM) return Mb;
  wM = 1;
  var e = KE();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, Mb = function() {
    function r(a, s, l, u, c, p) {
      if (p !== e) {
        var d = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw d.name = "Invariant Violation", d;
      }
    }
    r.isRequired = r;
    function o() {
      return r;
    }
    var i = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: o,
      element: r,
      elementType: r,
      instanceOf: o,
      node: r,
      objectOf: o,
      oneOf: o,
      oneOfType: o,
      shape: o,
      exact: o,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return i.PropTypes = i, i;
  }, Mb;
}
if (process.env.NODE_ENV !== "production") {
  var aie = jW(), lie = !0;
  XC.exports = iie()(aie.isElement, lie);
} else
  XC.exports = sie()();
var Gv = XC.exports, Xv = {};
Object.defineProperty(Xv, "__esModule", {
  value: !0
});
var uie = Hp, Db = cie(uie);
function cie(e) {
  return e && e.__esModule ? e : { default: e };
}
var pie = {
  mountFlag: !1,
  initialized: !1,
  scroller: null,
  containers: {},
  mount: function(e) {
    this.scroller = e, this.handleHashChange = this.handleHashChange.bind(this), window.addEventListener("hashchange", this.handleHashChange), this.initStateFromHash(), this.mountFlag = !0;
  },
  mapContainer: function(e, t) {
    this.containers[e] = t;
  },
  isMounted: function() {
    return this.mountFlag;
  },
  isInitialized: function() {
    return this.initialized;
  },
  initStateFromHash: function() {
    var e = this, t = this.getHash();
    t ? window.setTimeout(function() {
      e.scrollTo(t, !0), e.initialized = !0;
    }, 10) : this.initialized = !0;
  },
  scrollTo: function(e, t) {
    var n = this.scroller, r = n.get(e);
    if (r && (t || e !== n.getActiveLink())) {
      var o = this.containers[e] || document;
      n.scrollTo(e, { container: o });
    }
  },
  getHash: function() {
    return Db.default.getHash();
  },
  changeHash: function(e, t) {
    this.isInitialized() && Db.default.getHash() !== e && Db.default.updateHash(e, t);
  },
  handleHashChange: function() {
    this.scrollTo(this.getHash());
  },
  unmount: function() {
    this.scroller = null, this.containers = null, window.removeEventListener("hashchange", this.handleHashChange);
  }
};
Xv.default = pie;
Object.defineProperty(zp, "__esModule", {
  value: !0
});
var vf = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, die = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), fie = ke, CM = qp(fie), hie = Up, yf = qp(hie), gie = yu, mie = qp(gie), vie = Gv, ar = qp(vie), yie = Xv, Ts = qp(yie);
function qp(e) {
  return e && e.__esModule ? e : { default: e };
}
function bie(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function wie(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function Cie(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var xM = {
  to: ar.default.string.isRequired,
  containerId: ar.default.string,
  container: ar.default.object,
  activeClass: ar.default.string,
  activeStyle: ar.default.object,
  spy: ar.default.bool,
  horizontal: ar.default.bool,
  smooth: ar.default.oneOfType([ar.default.bool, ar.default.string]),
  offset: ar.default.number,
  delay: ar.default.number,
  isDynamic: ar.default.bool,
  onClick: ar.default.func,
  duration: ar.default.oneOfType([ar.default.number, ar.default.func]),
  absolute: ar.default.bool,
  onSetActive: ar.default.func,
  onSetInactive: ar.default.func,
  ignoreCancelEvents: ar.default.bool,
  hashSpy: ar.default.bool,
  saveHashHistory: ar.default.bool,
  spyThrottle: ar.default.number
};
zp.default = function(e, t) {
  var n = t || mie.default, r = function(i) {
    Cie(a, i);
    function a(s) {
      bie(this, a);
      var l = wie(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
      return o.call(l), l.state = {
        active: !1
      }, l.beforeUnmountCallbacks = [], l;
    }
    return die(a, [{
      key: "getScrollSpyContainer",
      value: function() {
        var s = this.props.containerId, l = this.props.container;
        return s && !l ? document.getElementById(s) : l && l.nodeType ? l : document;
      }
    }, {
      key: "componentDidMount",
      value: function() {
        if (this.props.spy || this.props.hashSpy) {
          var s = this.getScrollSpyContainer();
          if (!yf.default.isMounted(s)) {
            var l = yf.default.mount(s, this.props.spyThrottle);
            this.beforeUnmountCallbacks.push(l);
          }
          this.props.hashSpy && (Ts.default.isMounted() || Ts.default.mount(n), Ts.default.mapContainer(this.props.to, s)), yf.default.addSpyHandler(this.spyHandler, s), this.setState({
            container: s
          });
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        yf.default.unmount(this.stateHandler, this.spyHandler), this.beforeUnmountCallbacks.forEach(function(s) {
          return s();
        });
      }
    }, {
      key: "render",
      value: function() {
        var s = "";
        this.state && this.state.active ? s = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : s = this.props.className;
        var l = {};
        this.state && this.state.active ? l = vf({}, this.props.style, this.props.activeStyle) : l = vf({}, this.props.style);
        var u = vf({}, this.props);
        for (var c in xM)
          u.hasOwnProperty(c) && delete u[c];
        return u.className = s, u.style = l, u.onClick = this.handleClick, CM.default.createElement(e, u);
      }
    }]), a;
  }(CM.default.PureComponent), o = function() {
    var i = this;
    this.scrollTo = function(a, s) {
      n.scrollTo(a, vf({}, i.state, s));
    }, this.handleClick = function(a) {
      i.props.onClick && i.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), i.scrollTo(i.props.to, i.props);
    }, this.spyHandler = function(a, s) {
      var l = i.getScrollSpyContainer();
      if (!(Ts.default.isMounted() && !Ts.default.isInitialized())) {
        var u = i.props.horizontal, c = i.props.to, p = null, d = void 0, h = void 0;
        if (u) {
          var f = 0, m = 0, g = 0;
          if (l.getBoundingClientRect) {
            var E = l.getBoundingClientRect();
            g = E.left;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var w = p.getBoundingClientRect();
            f = w.left - g + a, m = f + w.width;
          }
          var M = a - i.props.offset;
          d = M >= Math.floor(f) && M < Math.floor(m), h = M < Math.floor(f) || M >= Math.floor(m);
        } else {
          var x = 0, y = 0, C = 0;
          if (l.getBoundingClientRect) {
            var P = l.getBoundingClientRect();
            C = P.top;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var F = p.getBoundingClientRect();
            x = F.top - C + s, y = x + F.height;
          }
          var L = s - i.props.offset;
          d = L >= Math.floor(x) && L < Math.floor(y), h = L < Math.floor(x) || L >= Math.floor(y);
        }
        var N = n.getActiveLink();
        if (h) {
          if (c === N && n.setActiveLink(void 0), i.props.hashSpy && Ts.default.getHash() === c) {
            var I = i.props.saveHashHistory, H = I === void 0 ? !1 : I;
            Ts.default.changeHash("", H);
          }
          i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive(c, p));
        }
        if (d && (N !== c || i.state.active === !1)) {
          n.setActiveLink(c);
          var V = i.props.saveHashHistory, z = V === void 0 ? !1 : V;
          i.props.hashSpy && Ts.default.changeHash(c, z), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(c, p));
        }
      }
    };
  };
  return r.propTypes = xM, r.defaultProps = { offset: 0 }, r;
};
Object.defineProperty(VE, "__esModule", {
  value: !0
});
var xie = ke, OM = BW(xie), Oie = zp, Eie = BW(Oie);
function BW(e) {
  return e && e.__esModule ? e : { default: e };
}
function kie(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function EM(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function Lie(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var _ie = function(e) {
  Lie(t, e);
  function t() {
    var n, r, o, i;
    kie(this, t);
    for (var a = arguments.length, s = Array(a), l = 0; l < a; l++)
      s[l] = arguments[l];
    return i = (r = (o = EM(this, (n = t.__proto__ || Object.getPrototypeOf(t)).call.apply(n, [this].concat(s))), o), o.render = function() {
      return OM.default.createElement(
        "a",
        o.props,
        o.props.children
      );
    }, r), EM(o, i);
  }
  return t;
}(OM.default.Component);
VE.default = (0, Eie.default)(_ie);
var YE = {};
Object.defineProperty(YE, "__esModule", {
  value: !0
});
var Pie = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), Sie = ke, kM = IW(Sie), Mie = zp, Die = IW(Mie);
function IW(e) {
  return e && e.__esModule ? e : { default: e };
}
function Tie(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function jie(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function Aie(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var Bie = function(e) {
  Aie(t, e);
  function t() {
    return Tie(this, t), jie(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return Pie(t, [{
    key: "render",
    value: function() {
      return kM.default.createElement(
        "button",
        this.props,
        this.props.children
      );
    }
  }]), t;
}(kM.default.Component);
YE.default = (0, Die.default)(Bie);
var JE = {}, Kv = {};
Object.defineProperty(Kv, "__esModule", {
  value: !0
});
var Iie = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, Rie = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), Nie = ke, LM = Yv(Nie), Fie = Rl;
Yv(Fie);
var zie = yu, _M = Yv(zie), Uie = Gv, PM = Yv(Uie);
function Yv(e) {
  return e && e.__esModule ? e : { default: e };
}
function $ie(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Hie(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function Wie(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
Kv.default = function(e) {
  var t = function(n) {
    Wie(r, n);
    function r(o) {
      $ie(this, r);
      var i = Hie(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
      return i.childBindings = {
        domNode: null
      }, i;
    }
    return Rie(r, [{
      key: "componentDidMount",
      value: function() {
        if (typeof window > "u")
          return !1;
        this.registerElems(this.props.name);
      }
    }, {
      key: "componentDidUpdate",
      value: function(o) {
        this.props.name !== o.name && this.registerElems(this.props.name);
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        if (typeof window > "u")
          return !1;
        _M.default.unregister(this.props.name);
      }
    }, {
      key: "registerElems",
      value: function(o) {
        _M.default.register(o, this.childBindings.domNode);
      }
    }, {
      key: "render",
      value: function() {
        return LM.default.createElement(e, Iie({}, this.props, { parentBindings: this.childBindings }));
      }
    }]), r;
  }(LM.default.Component);
  return t.propTypes = {
    name: PM.default.string,
    id: PM.default.string
  }, t;
};
Object.defineProperty(JE, "__esModule", {
  value: !0
});
var SM = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, Vie = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), qie = ke, MM = QE(qie), Zie = Kv, Gie = QE(Zie), Xie = Gv, DM = QE(Xie);
function QE(e) {
  return e && e.__esModule ? e : { default: e };
}
function Kie(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Yie(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function Jie(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var RW = function(e) {
  Jie(t, e);
  function t() {
    return Kie(this, t), Yie(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return Vie(t, [{
    key: "render",
    value: function() {
      var n = this, r = SM({}, this.props);
      return delete r.name, r.parentBindings && delete r.parentBindings, MM.default.createElement(
        "div",
        SM({}, r, { ref: function(o) {
          n.props.parentBindings.domNode = o;
        } }),
        this.props.children
      );
    }
  }]), t;
}(MM.default.Component);
RW.propTypes = {
  name: DM.default.string,
  id: DM.default.string
};
JE.default = (0, Gie.default)(RW);
var Tb = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, TM = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}();
function jM(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function AM(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function BM(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var bf = ke, Aa = Up, jb = yu, Pr = Gv, js = Xv, IM = {
  to: Pr.string.isRequired,
  containerId: Pr.string,
  container: Pr.object,
  activeClass: Pr.string,
  spy: Pr.bool,
  smooth: Pr.oneOfType([Pr.bool, Pr.string]),
  offset: Pr.number,
  delay: Pr.number,
  isDynamic: Pr.bool,
  onClick: Pr.func,
  duration: Pr.oneOfType([Pr.number, Pr.func]),
  absolute: Pr.bool,
  onSetActive: Pr.func,
  onSetInactive: Pr.func,
  ignoreCancelEvents: Pr.bool,
  hashSpy: Pr.bool,
  spyThrottle: Pr.number
}, Qie = {
  Scroll: function(e, t) {
    console.warn("Helpers.Scroll is deprecated since v1.7.0");
    var n = t || jb, r = function(i) {
      BM(a, i);
      function a(s) {
        jM(this, a);
        var l = AM(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
        return o.call(l), l.state = {
          active: !1
        }, l;
      }
      return TM(a, [{
        key: "getScrollSpyContainer",
        value: function() {
          var s = this.props.containerId, l = this.props.container;
          return s ? document.getElementById(s) : l && l.nodeType ? l : document;
        }
      }, {
        key: "componentDidMount",
        value: function() {
          if (this.props.spy || this.props.hashSpy) {
            var s = this.getScrollSpyContainer();
            Aa.isMounted(s) || Aa.mount(s, this.props.spyThrottle), this.props.hashSpy && (js.isMounted() || js.mount(n), js.mapContainer(this.props.to, s)), this.props.spy && Aa.addStateHandler(this.stateHandler), Aa.addSpyHandler(this.spyHandler, s), this.setState({
              container: s
            });
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          Aa.unmount(this.stateHandler, this.spyHandler);
        }
      }, {
        key: "render",
        value: function() {
          var s = "";
          this.state && this.state.active ? s = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : s = this.props.className;
          var l = Tb({}, this.props);
          for (var u in IM)
            l.hasOwnProperty(u) && delete l[u];
          return l.className = s, l.onClick = this.handleClick, bf.createElement(e, l);
        }
      }]), a;
    }(bf.Component), o = function() {
      var i = this;
      this.scrollTo = function(a, s) {
        n.scrollTo(a, Tb({}, i.state, s));
      }, this.handleClick = function(a) {
        i.props.onClick && i.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), i.scrollTo(i.props.to, i.props);
      }, this.stateHandler = function() {
        n.getActiveLink() !== i.props.to && (i.state !== null && i.state.active && i.props.onSetInactive && i.props.onSetInactive(), i.setState({ active: !1 }));
      }, this.spyHandler = function(a) {
        var s = i.getScrollSpyContainer();
        if (!(js.isMounted() && !js.isInitialized())) {
          var l = i.props.to, u = null, c = 0, p = 0, d = 0;
          if (s.getBoundingClientRect) {
            var h = s.getBoundingClientRect();
            d = h.top;
          }
          if (!u || i.props.isDynamic) {
            if (u = n.get(l), !u)
              return;
            var f = u.getBoundingClientRect();
            c = f.top - d + a, p = c + f.height;
          }
          var m = a - i.props.offset, g = m >= Math.floor(c) && m < Math.floor(p), E = m < Math.floor(c) || m >= Math.floor(p), w = n.getActiveLink();
          if (E)
            return l === w && n.setActiveLink(void 0), i.props.hashSpy && js.getHash() === l && js.changeHash(), i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive()), Aa.updateStates();
          if (g && w !== l)
            return n.setActiveLink(l), i.props.hashSpy && js.changeHash(l), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(l)), Aa.updateStates();
        }
      };
    };
    return r.propTypes = IM, r.defaultProps = { offset: 0 }, r;
  },
  Element: function(e) {
    console.warn("Helpers.Element is deprecated since v1.7.0");
    var t = function(n) {
      BM(r, n);
      function r(o) {
        jM(this, r);
        var i = AM(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
        return i.childBindings = {
          domNode: null
        }, i;
      }
      return TM(r, [{
        key: "componentDidMount",
        value: function() {
          if (typeof window > "u")
            return !1;
          this.registerElems(this.props.name);
        }
      }, {
        key: "componentDidUpdate",
        value: function(o) {
          this.props.name !== o.name && this.registerElems(this.props.name);
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          if (typeof window > "u")
            return !1;
          jb.unregister(this.props.name);
        }
      }, {
        key: "registerElems",
        value: function(o) {
          jb.register(o, this.childBindings.domNode);
        }
      }, {
        key: "render",
        value: function() {
          return bf.createElement(e, Tb({}, this.props, { parentBindings: this.childBindings }));
        }
      }]), r;
    }(bf.Component);
    return t.propTypes = {
      name: Pr.string,
      id: Pr.string
    }, t;
  }
}, ese = Qie;
Object.defineProperty(Fr, "__esModule", {
  value: !0
});
Fr.Helpers = Fr.ScrollElement = Fr.ScrollLink = Fr.animateScroll = Fr.scrollSpy = Fr.Events = Fr.scroller = Fr.Element = Fr.Button = Fr.Link = void 0;
var tse = VE, NW = Xi(tse), nse = YE, FW = Xi(nse), rse = JE, zW = Xi(rse), ose = yu, UW = Xi(ose), ise = Wp, $W = Xi(ise), sse = Up, HW = Xi(sse), ase = Vv, WW = Xi(ase), lse = zp, VW = Xi(lse), use = Kv, qW = Xi(use), cse = ese, ZW = Xi(cse);
function Xi(e) {
  return e && e.__esModule ? e : { default: e };
}
Fr.Link = NW.default;
Fr.Button = FW.default;
Fr.Element = zW.default;
Fr.scroller = UW.default;
Fr.Events = $W.default;
Fr.scrollSpy = HW.default;
Fr.animateScroll = WW.default;
Fr.ScrollLink = VW.default;
Fr.ScrollElement = qW.default;
Fr.Helpers = ZW.default;
Fr.default = { Link: NW.default, Button: FW.default, Element: zW.default, scroller: UW.default, Events: $W.default, scrollSpy: HW.default, animateScroll: WW.default, ScrollLink: VW.default, ScrollElement: qW.default, Helpers: ZW.default };
Ze({});
Ze({});
Ze({});
function kp(e) {
  "@babel/helpers - typeof";
  return kp = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, kp(e);
}
function pse(e, t) {
  if (kp(e) != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (kp(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function dse(e) {
  var t = pse(e, "string");
  return kp(t) == "symbol" ? t : t + "";
}
function be(e, t, n) {
  return (t = dse(t)) in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function GW(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var Ab, RM;
function fse() {
  if (RM) return Ab;
  RM = 1;
  var e = process.env.NODE_ENV, t = function(n, r, o, i, a, s, l, u) {
    if (e !== "production" && r === void 0)
      throw new Error("invariant requires an error message argument");
    if (!n) {
      var c;
      if (r === void 0)
        c = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
      else {
        var p = [o, i, a, s, l, u], d = 0;
        c = new Error(r.replace(/%s/g, function() {
          return p[d++];
        })), c.name = "Invariant Violation";
      }
      throw c.framesToPop = 1, c;
    }
  };
  return Ab = t, Ab;
}
var hse = fse(), qr = /* @__PURE__ */ GW(hse), Pt = Ze(null);
function gse() {
  qr(!!ye, "useGoogleMap is React hook and requires React version 16.8+");
  var e = ye(Pt);
  return qr(!!e, "useGoogleMap needs a GoogleMap available up in the tree"), e;
}
function mse(e, t, n) {
  return Object.keys(e).reduce(function(r, o) {
    return t(r, e[o], o);
  }, n);
}
function vse(e, t) {
  Object.keys(e).forEach((n) => t(e[n], n));
}
function yse(e, t, n, r) {
  var o = {}, i = (a, s) => {
    var l = n[s];
    l !== t[s] && (o[s] = l, a(r, l));
  };
  return vse(e, i), o;
}
function bse(e, t, n) {
  var r = mse(n, function(o, i, a) {
    return typeof e[a] == "function" && o.push(google.maps.event.addListener(t, i, e[a])), o;
  }, []);
  return r;
}
function wse(e) {
  google.maps.event.removeListener(e);
}
function on() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  e.forEach(wse);
}
function Jt(e) {
  var {
    updaterMap: t,
    eventMap: n,
    prevProps: r,
    nextProps: o,
    instance: i
  } = e, a = bse(o, i, n);
  return yse(t, r, o, i), a;
}
function Cse(e) {
  var {
    children: t,
    options: n,
    id: r,
    mapContainerStyle: o,
    mapContainerClassName: i,
    center: a,
    // clickableIcons,
    // extraMapTypes,
    // heading,
    // mapTypeId,
    onClick: s,
    onDblClick: l,
    onDrag: u,
    onDragEnd: c,
    onDragStart: p,
    onMouseMove: d,
    onMouseOut: h,
    onMouseOver: f,
    onMouseDown: m,
    onMouseUp: g,
    onRightClick: E,
    // onMapTypeIdChanged,
    // onTilesLoaded,
    // onBoundsChanged,
    onCenterChanged: w,
    // onHeadingChanged,
    // onIdle,
    // onProjectionChanged,
    // onResize,
    // onTiltChanged,
    // onZoomChanged,
    onLoad: M,
    onUnmount: x
  } = e, [y, C] = k(null), P = rt(null), [F, L] = k(null), [N, I] = k(null), [H, V] = k(null), [z, q] = k(null), [K, J] = k(null), [te, ee] = k(null), [_, D] = k(null), [$, S] = k(null), [W, O] = k(null), [T, U] = k(null), [j, Z] = k(null), [A, Q] = k(null);
  return v(() => {
    n && y !== null && y.setOptions(n);
  }, [y, n]), v(() => {
    y !== null && typeof a < "u" && y.setCenter(a);
  }, [y, a]), v(() => {
    y && l && (N !== null && google.maps.event.removeListener(N), I(google.maps.event.addListener(y, "dblclick", l)));
  }, [l]), v(() => {
    y && c && (H !== null && google.maps.event.removeListener(H), V(google.maps.event.addListener(y, "dragend", c)));
  }, [c]), v(() => {
    y && p && (z !== null && google.maps.event.removeListener(z), q(google.maps.event.addListener(y, "dragstart", p)));
  }, [p]), v(() => {
    y && m && (K !== null && google.maps.event.removeListener(K), J(google.maps.event.addListener(y, "mousedown", m)));
  }, [m]), v(() => {
    y && d && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(y, "mousemove", d)));
  }, [d]), v(() => {
    y && h && (_ !== null && google.maps.event.removeListener(_), D(google.maps.event.addListener(y, "mouseout", h)));
  }, [h]), v(() => {
    y && f && ($ !== null && google.maps.event.removeListener($), S(google.maps.event.addListener(y, "mouseover", f)));
  }, [f]), v(() => {
    y && g && (W !== null && google.maps.event.removeListener(W), O(google.maps.event.addListener(y, "mouseup", g)));
  }, [g]), v(() => {
    y && E && (T !== null && google.maps.event.removeListener(T), U(google.maps.event.addListener(y, "rightclick", E)));
  }, [E]), v(() => {
    y && s && (j !== null && google.maps.event.removeListener(j), Z(google.maps.event.addListener(y, "click", s)));
  }, [s]), v(() => {
    y && u && (A !== null && google.maps.event.removeListener(A), Q(google.maps.event.addListener(y, "drag", u)));
  }, [u]), v(() => {
    y && w && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(y, "center_changed", w)));
  }, [s]), v(() => {
    var R = P.current === null ? null : new google.maps.Map(P.current, n);
    return C(R), R !== null && M && M(R), () => {
      R !== null && x && x(R);
    };
  }, []), io.jsx("div", {
    id: r,
    ref: P,
    style: o,
    className: i,
    children: io.jsx(Pt.Provider, {
      value: y,
      children: y !== null ? t : null
    })
  });
}
Ee(Cse);
function NM(e, t, n, r, o, i, a) {
  try {
    var s = e[i](a), l = s.value;
  } catch (u) {
    return void n(u);
  }
  s.done ? t(l) : Promise.resolve(l).then(r, o);
}
function XW(e) {
  return function() {
    var t = this, n = arguments;
    return new Promise(function(r, o) {
      var i = e.apply(t, n);
      function a(l) {
        NM(i, r, o, a, s, "next", l);
      }
      function s(l) {
        NM(i, r, o, a, s, "throw", l);
      }
      a(void 0);
    });
  };
}
function KW(e) {
  var {
    googleMapsApiKey: t,
    googleMapsClientId: n,
    version: r = "weekly",
    language: o,
    region: i,
    libraries: a,
    channel: s,
    mapIds: l,
    authReferrerPolicy: u
  } = e, c = [];
  return qr(t && n || !(t && n), "You need to specify either googleMapsApiKey or googleMapsClientId for @react-google-maps/api load script to work. You cannot use both at the same time."), t ? c.push("key=".concat(t)) : n && c.push("client=".concat(n)), r && c.push("v=".concat(r)), o && c.push("language=".concat(o)), i && c.push("region=".concat(i)), a && a.length && c.push("libraries=".concat(a.sort().join(","))), s && c.push("channel=".concat(s)), l && l.length && c.push("map_ids=".concat(l.join(","))), u && c.push("auth_referrer_policy=".concat(u)), c.push("loading=async"), c.push("callback=initMap"), "https://maps.googleapis.com/maps/api/js?".concat(c.join("&"));
}
var sl = typeof document < "u";
function YW(e) {
  var {
    url: t,
    id: n,
    nonce: r
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } = e;
  return sl ? new Promise(function(o, i) {
    var a = document.getElementById(n), s = window;
    if (a) {
      var l = a.getAttribute("data-state");
      if (a.src === t && l !== "error") {
        if (l === "ready")
          return o(n);
        var u = s.initMap, c = a.onerror;
        s.initMap = function() {
          u && u(), o(n);
        }, a.onerror = function(d) {
          c && c(d), i(d);
        };
        return;
      } else
        a.remove();
    }
    var p = document.createElement("script");
    p.type = "text/javascript", p.src = t, p.id = n, p.async = !0, p.nonce = r || "", p.onerror = function(d) {
      p.setAttribute("data-state", "error"), i(d);
    }, s.initMap = function() {
      p.setAttribute("data-state", "ready"), o(n);
    }, document.head.appendChild(p);
  }).catch((o) => {
    throw console.error("injectScript error: ", o), o;
  }) : Promise.reject(new Error("document is undefined"));
}
function FM(e) {
  var t = e.href;
  return t && (t.indexOf("https://fonts.googleapis.com/css?family=Roboto") === 0 || t.indexOf("https://fonts.googleapis.com/css?family=Google+Sans+Text") === 0) ? !0 : (
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.styleSheet.cssText = "", !0) : (
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.innerHTML = "", !0) : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.innerHTML
      )
    )
  );
}
function JW() {
  var e = document.getElementsByTagName("head")[0];
  if (e) {
    var t = e.insertBefore.bind(e);
    e.insertBefore = function(r, o) {
      return FM(r) || Reflect.apply(t, e, [r, o]), r;
    };
    var n = e.appendChild.bind(e);
    e.appendChild = function(r) {
      return FM(r) || Reflect.apply(n, e, [r]), r;
    };
  }
}
var Hu = !1;
function QW() {
  return io.jsx("div", {
    children: "Loading..."
  });
}
var KC = {
  id: "script-loader",
  version: "weekly"
};
class xse extends pe {
  constructor() {
    super(...arguments), be(this, "check", null), be(this, "state", {
      loaded: !1
    }), be(this, "cleanupCallback", () => {
      delete window.google.maps, this.injectScript();
    }), be(this, "isCleaningUp", /* @__PURE__ */ XW(function* () {
      function t(n) {
        if (!Hu)
          n();
        else if (sl)
          var r = window.setInterval(function() {
            Hu || (window.clearInterval(r), n());
          }, 1);
      }
      return new Promise(t);
    })), be(this, "cleanup", () => {
      Hu = !0;
      var t = document.getElementById(this.props.id);
      t && t.parentNode && t.parentNode.removeChild(t), Array.prototype.slice.call(document.getElementsByTagName("script")).filter(function(n) {
        return typeof n.src == "string" && n.src.includes("maps.googleapis");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("link")).filter(function(n) {
        return n.href === "https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Google+Sans";
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("style")).filter(function(n) {
        return n.innerText !== void 0 && n.innerText.length > 0 && n.innerText.includes(".gm-");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      });
    }), be(this, "injectScript", () => {
      this.props.preventGoogleFontsLoading && JW(), qr(!!this.props.id, 'LoadScript requires "id" prop to be a string: %s', this.props.id);
      var t = {
        id: this.props.id,
        nonce: this.props.nonce,
        url: KW(this.props)
      };
      YW(t).then(() => {
        this.props.onLoad && this.props.onLoad(), this.setState(function() {
          return {
            loaded: !0
          };
        });
      }).catch((n) => {
        this.props.onError && this.props.onError(n), console.error(`
          There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(this.props.googleMapsApiKey || "-", ") or Client ID (").concat(this.props.googleMapsClientId || "-", `) to <LoadScript />
          Otherwise it is a Network issue.
        `));
      });
    }), be(this, "getRef", (t) => {
      this.check = t;
    });
  }
  componentDidMount() {
    if (sl) {
      if (window.google && window.google.maps && !Hu) {
        console.error("google api is already presented");
        return;
      }
      this.isCleaningUp().then(this.injectScript).catch(function(t) {
        console.error("Error at injecting script after cleaning up: ", t);
      });
    }
  }
  componentDidUpdate(t) {
    this.props.libraries !== t.libraries && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), sl && t.language !== this.props.language && (this.cleanup(), this.setState(function() {
      return {
        loaded: !1
      };
    }, this.cleanupCallback));
  }
  componentWillUnmount() {
    if (sl) {
      this.cleanup();
      var t = () => {
        this.check || (delete window.google, Hu = !1);
      };
      window.setTimeout(t, 1), this.props.onUnmount && this.props.onUnmount();
    }
  }
  render() {
    return io.jsxs(io.Fragment, {
      children: [io.jsx("div", {
        ref: this.getRef
      }), this.state.loaded ? this.props.children : this.props.loadingElement || io.jsx(QW, {})]
    });
  }
}
be(xse, "defaultProps", KC);
function Ose(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.includes(r)) continue;
    n[r] = e[r];
  }
  return n;
}
function ek(e, t) {
  if (e == null) return {};
  var n, r, o = Ose(e, t);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (r = 0; r < i.length; r++) n = i[r], t.includes(n) || {}.propertyIsEnumerable.call(e, n) && (o[n] = e[n]);
  }
  return o;
}
var zM;
function Ese(e) {
  var {
    id: t = KC.id,
    version: n = KC.version,
    nonce: r,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    preventGoogleFontsLoading: u,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  } = e, h = rt(!1), [f, m] = k(!1), [g, E] = k(void 0);
  v(function() {
    return h.current = !0, () => {
      h.current = !1;
    };
  }, []), v(function() {
    sl && u && JW();
  }, [u]), v(function() {
    f && qr(!!window.google, "useLoadScript was marked as loaded, but window.google is not present. Something went wrong.");
  }, [f]);
  var w = KW({
    version: n,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  });
  v(function() {
    if (!sl)
      return;
    function x() {
      h.current && (m(!0), zM = w);
    }
    if (window.google && window.google.maps && zM === w) {
      x();
      return;
    }
    YW({
      id: t,
      url: w,
      nonce: r
    }).then(x).catch(function(y) {
      h.current && E(y), console.warn(`
        There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(o || "-", ") or Client ID (").concat(i || "-", `)
        Otherwise it is a Network issue.
      `)), console.error(y);
    });
  }, [t, w, r]);
  var M = rt(void 0);
  return v(function() {
    M.current && l !== M.current && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), M.current = l;
  }, [l]), {
    isLoaded: f,
    loadError: g,
    url: w
  };
}
var kse = ["loadingElement", "onLoad", "onError", "onUnmount", "children"], Lse = io.jsx(QW, {});
function _se(e) {
  var {
    loadingElement: t,
    onLoad: n,
    onError: r,
    onUnmount: o,
    children: i
  } = e, a = ek(e, kse), {
    isLoaded: s,
    loadError: l
  } = Ese(a);
  return v(function() {
    s && typeof n == "function" && n();
  }, [s, n]), v(function() {
    l && typeof r == "function" && r(l);
  }, [l, r]), v(function() {
    return () => {
      o && o();
    };
  }, [o]), s ? i : t || Lse;
}
Ee(_se);
var UM;
(function(e) {
  e[e.INITIALIZED = 0] = "INITIALIZED", e[e.LOADING = 1] = "LOADING", e[e.SUCCESS = 2] = "SUCCESS", e[e.FAILURE = 3] = "FAILURE";
})(UM || (UM = {}));
function $M(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function bg(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? $M(Object(n), !0).forEach(function(r) {
      be(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : $M(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var HM = {}, WM = {
  options(e, t) {
    e.setOptions(t);
  }
};
function Pse(e) {
  var {
    options: t,
    onLoad: n,
    onUnmount: r
  } = e, o = ye(Pt), [i, a] = k(null);
  return v(() => {
    i !== null && i.setMap(o);
  }, [o]), v(() => {
    t && i !== null && i.setOptions(t);
  }, [i, t]), v(() => {
    var s = new google.maps.TrafficLayer(bg(bg({}, t), {}, {
      map: o
    }));
    return a(s), n && n(s), () => {
      i !== null && (r && r(i), i.setMap(null));
    };
  }, []), null;
}
Ee(Pse);
class Sse extends pe {
  constructor() {
    super(...arguments), be(this, "state", {
      trafficLayer: null
    }), be(this, "setTrafficLayerCallback", () => {
      this.state.trafficLayer !== null && this.props.onLoad && this.props.onLoad(this.state.trafficLayer);
    }), be(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = new google.maps.TrafficLayer(bg(bg({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Jt({
      updaterMap: WM,
      eventMap: HM,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        trafficLayer: t
      };
    }, this.setTrafficLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.trafficLayer !== null && (on(this.registeredEvents), this.registeredEvents = Jt({
      updaterMap: WM,
      eventMap: HM,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.trafficLayer
    }));
  }
  componentWillUnmount() {
    this.state.trafficLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.trafficLayer), on(this.registeredEvents), this.state.trafficLayer.setMap(null));
  }
  render() {
    return null;
  }
}
be(Sse, "contextType", Pt);
function Mse(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = ye(Pt), [o, i] = k(null);
  return v(() => {
    o !== null && o.setMap(r);
  }, [r]), v(() => {
    var a = new google.maps.BicyclingLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      a !== null && (n && n(a), a.setMap(null));
    };
  }, []), null;
}
Ee(Mse);
class Dse extends pe {
  constructor() {
    super(...arguments), be(this, "state", {
      bicyclingLayer: null
    }), be(this, "setBicyclingLayerCallback", () => {
      this.state.bicyclingLayer !== null && (this.state.bicyclingLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.bicyclingLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.BicyclingLayer();
    this.setState(() => ({
      bicyclingLayer: t
    }), this.setBicyclingLayerCallback);
  }
  componentWillUnmount() {
    this.state.bicyclingLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.bicyclingLayer), this.state.bicyclingLayer.setMap(null));
  }
  render() {
    return null;
  }
}
be(Dse, "contextType", Pt);
function Tse(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = ye(Pt), [o, i] = k(null);
  return v(() => {
    o !== null && o.setMap(r);
  }, [r]), v(() => {
    var a = new google.maps.TransitLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      o !== null && (n && n(o), o.setMap(null));
    };
  }, []), null;
}
Ee(Tse);
class jse extends pe {
  constructor() {
    super(...arguments), be(this, "state", {
      transitLayer: null
    }), be(this, "setTransitLayerCallback", () => {
      this.state.transitLayer !== null && (this.state.transitLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.transitLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.TransitLayer();
    this.setState(function() {
      return {
        transitLayer: t
      };
    }, this.setTransitLayerCallback);
  }
  componentWillUnmount() {
    this.state.transitLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.transitLayer), this.state.transitLayer.setMap(null));
  }
  render() {
    return null;
  }
}
be(jse, "contextType", Pt);
function VM(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function wg(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? VM(Object(n), !0).forEach(function(r) {
      be(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : VM(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var qM = {
  onCircleComplete: "circlecomplete",
  onMarkerComplete: "markercomplete",
  onOverlayComplete: "overlaycomplete",
  onPolygonComplete: "polygoncomplete",
  onPolylineComplete: "polylinecomplete",
  onRectangleComplete: "rectanglecomplete"
}, ZM = {
  drawingMode(e, t) {
    e.setDrawingMode(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function Ase(e) {
  var {
    options: t,
    drawingMode: n,
    onCircleComplete: r,
    onMarkerComplete: o,
    onOverlayComplete: i,
    onPolygonComplete: a,
    onPolylineComplete: s,
    onRectangleComplete: l,
    onLoad: u,
    onUnmount: c
  } = e, p = ye(Pt), [d, h] = k(null), [f, m] = k(null), [g, E] = k(null), [w, M] = k(null), [x, y] = k(null), [C, P] = k(null), [F, L] = k(null);
  return v(() => {
    d !== null && d.setMap(p);
  }, [p]), v(() => {
    t && d !== null && d.setOptions(t);
  }, [d, t]), v(() => {
    d !== null && d.setDrawingMode(n ?? null);
  }, [d, n]), v(() => {
    d && r && (f !== null && google.maps.event.removeListener(f), m(google.maps.event.addListener(d, "circlecomplete", r)));
  }, [d, r]), v(() => {
    d && o && (g !== null && google.maps.event.removeListener(g), E(google.maps.event.addListener(d, "markercomplete", o)));
  }, [d, o]), v(() => {
    d && i && (w !== null && google.maps.event.removeListener(w), M(google.maps.event.addListener(d, "overlaycomplete", i)));
  }, [d, i]), v(() => {
    d && a && (x !== null && google.maps.event.removeListener(x), y(google.maps.event.addListener(d, "polygoncomplete", a)));
  }, [d, a]), v(() => {
    d && s && (C !== null && google.maps.event.removeListener(C), P(google.maps.event.addListener(d, "polylinecomplete", s)));
  }, [d, s]), v(() => {
    d && l && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(d, "rectanglecomplete", l)));
  }, [d, l]), v(() => {
    qr(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
    var N = new google.maps.drawing.DrawingManager(wg(wg({}, t), {}, {
      map: p
    }));
    return n && N.setDrawingMode(n), r && m(google.maps.event.addListener(N, "circlecomplete", r)), o && E(google.maps.event.addListener(N, "markercomplete", o)), i && M(google.maps.event.addListener(N, "overlaycomplete", i)), a && y(google.maps.event.addListener(N, "polygoncomplete", a)), s && P(google.maps.event.addListener(N, "polylinecomplete", s)), l && L(google.maps.event.addListener(N, "rectanglecomplete", l)), h(N), u && u(N), () => {
      d !== null && (f && google.maps.event.removeListener(f), g && google.maps.event.removeListener(g), w && google.maps.event.removeListener(w), x && google.maps.event.removeListener(x), C && google.maps.event.removeListener(C), F && google.maps.event.removeListener(F), c && c(d), d.setMap(null));
    };
  }, []), null;
}
Ee(Ase);
class Bse extends pe {
  constructor(t) {
    super(t), be(this, "registeredEvents", []), be(this, "state", {
      drawingManager: null
    }), be(this, "setDrawingManagerCallback", () => {
      this.state.drawingManager !== null && this.props.onLoad && this.props.onLoad(this.state.drawingManager);
    }), qr(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
  }
  componentDidMount() {
    var t = new google.maps.drawing.DrawingManager(wg(wg({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Jt({
      updaterMap: ZM,
      eventMap: qM,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        drawingManager: t
      };
    }, this.setDrawingManagerCallback);
  }
  componentDidUpdate(t) {
    this.state.drawingManager !== null && (on(this.registeredEvents), this.registeredEvents = Jt({
      updaterMap: ZM,
      eventMap: qM,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.drawingManager
    }));
  }
  componentWillUnmount() {
    this.state.drawingManager !== null && (this.props.onUnmount && this.props.onUnmount(this.state.drawingManager), on(this.registeredEvents), this.state.drawingManager.setMap(null));
  }
  render() {
    return null;
  }
}
be(Bse, "contextType", Pt);
function GM(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Xl(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? GM(Object(n), !0).forEach(function(r) {
      be(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : GM(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var XM = {
  onAnimationChanged: "animation_changed",
  onClick: "click",
  onClickableChanged: "clickable_changed",
  onCursorChanged: "cursor_changed",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDraggableChanged: "draggable_changed",
  onDragStart: "dragstart",
  onFlatChanged: "flat_changed",
  onIconChanged: "icon_changed",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onPositionChanged: "position_changed",
  onRightClick: "rightclick",
  onShapeChanged: "shape_changed",
  onTitleChanged: "title_changed",
  onVisibleChanged: "visible_changed",
  onZindexChanged: "zindex_changed"
}, KM = {
  animation(e, t) {
    e.setAnimation(t);
  },
  clickable(e, t) {
    e.setClickable(t);
  },
  cursor(e, t) {
    e.setCursor(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  icon(e, t) {
    e.setIcon(t);
  },
  label(e, t) {
    e.setLabel(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  opacity(e, t) {
    e.setOpacity(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  shape(e, t) {
    e.setShape(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, Cg = {};
function Ise(e) {
  var {
    position: t,
    options: n,
    clusterer: r,
    noClustererRedraw: o,
    children: i,
    draggable: a,
    visible: s,
    animation: l,
    clickable: u,
    cursor: c,
    icon: p,
    label: d,
    opacity: h,
    shape: f,
    title: m,
    zIndex: g,
    onClick: E,
    onDblClick: w,
    onDrag: M,
    onDragEnd: x,
    onDragStart: y,
    onMouseOut: C,
    onMouseOver: P,
    onMouseUp: F,
    onMouseDown: L,
    onRightClick: N,
    onClickableChanged: I,
    onCursorChanged: H,
    onAnimationChanged: V,
    onDraggableChanged: z,
    onFlatChanged: q,
    onIconChanged: K,
    onPositionChanged: J,
    onShapeChanged: te,
    onTitleChanged: ee,
    onVisibleChanged: _,
    onZindexChanged: D,
    onLoad: $,
    onUnmount: S
  } = e, W = ye(Pt), [O, T] = k(null), [U, j] = k(null), [Z, A] = k(null), [Q, R] = k(null), [ue, fe] = k(null), [oe, Re] = k(null), [He, Ve] = k(null), [ze, et] = k(null), [Ge, Pe] = k(null), [Ye, it] = k(null), [_e, Se] = k(null), [Ke, We] = k(null), [Ue, nt] = k(null), [Ie, xt] = k(null), [ot, st] = k(null), [lt, Ot] = k(null), [ut, ct] = k(null), [tt, Xe] = k(null), [Et, kt] = k(null), [pt, kn] = k(null), [dt, Ln] = k(null), [ft, rn] = k(null);
  v(() => {
    O !== null && O.setMap(W);
  }, [W]), v(() => {
    typeof n < "u" && O !== null && O.setOptions(n);
  }, [O, n]), v(() => {
    typeof a < "u" && O !== null && O.setDraggable(a);
  }, [O, a]), v(() => {
    t && O !== null && O.setPosition(t);
  }, [O, t]), v(() => {
    typeof s < "u" && O !== null && O.setVisible(s);
  }, [O, s]), v(() => {
    O == null || O.setAnimation(l);
  }, [O, l]), v(() => {
    O && u !== void 0 && O.setClickable(u);
  }, [O, u]), v(() => {
    O && c !== void 0 && O.setCursor(c);
  }, [O, c]), v(() => {
    O && p !== void 0 && O.setIcon(p);
  }, [O, p]), v(() => {
    O && d !== void 0 && O.setLabel(d);
  }, [O, d]), v(() => {
    O && h !== void 0 && O.setOpacity(h);
  }, [O, h]), v(() => {
    O && f !== void 0 && O.setShape(f);
  }, [O, f]), v(() => {
    O && m !== void 0 && O.setTitle(m);
  }, [O, m]), v(() => {
    O && g !== void 0 && O.setZIndex(g);
  }, [O, g]), v(() => {
    O && w && (U !== null && google.maps.event.removeListener(U), j(google.maps.event.addListener(O, "dblclick", w)));
  }, [w]), v(() => {
    O && x && (Z !== null && google.maps.event.removeListener(Z), A(google.maps.event.addListener(O, "dragend", x)));
  }, [x]), v(() => {
    O && y && (Q !== null && google.maps.event.removeListener(Q), R(google.maps.event.addListener(O, "dragstart", y)));
  }, [y]), v(() => {
    O && L && (ue !== null && google.maps.event.removeListener(ue), fe(google.maps.event.addListener(O, "mousedown", L)));
  }, [L]), v(() => {
    O && C && (oe !== null && google.maps.event.removeListener(oe), Re(google.maps.event.addListener(O, "mouseout", C)));
  }, [C]), v(() => {
    O && P && (He !== null && google.maps.event.removeListener(He), Ve(google.maps.event.addListener(O, "mouseover", P)));
  }, [P]), v(() => {
    O && F && (ze !== null && google.maps.event.removeListener(ze), et(google.maps.event.addListener(O, "mouseup", F)));
  }, [F]), v(() => {
    O && N && (Ge !== null && google.maps.event.removeListener(Ge), Pe(google.maps.event.addListener(O, "rightclick", N)));
  }, [N]), v(() => {
    O && E && (Ye !== null && google.maps.event.removeListener(Ye), it(google.maps.event.addListener(O, "click", E)));
  }, [E]), v(() => {
    O && M && (_e !== null && google.maps.event.removeListener(_e), Se(google.maps.event.addListener(O, "drag", M)));
  }, [M]), v(() => {
    O && I && (Ke !== null && google.maps.event.removeListener(Ke), We(google.maps.event.addListener(O, "clickable_changed", I)));
  }, [I]), v(() => {
    O && H && (Ue !== null && google.maps.event.removeListener(Ue), nt(google.maps.event.addListener(O, "cursor_changed", H)));
  }, [H]), v(() => {
    O && V && (Ie !== null && google.maps.event.removeListener(Ie), xt(google.maps.event.addListener(O, "animation_changed", V)));
  }, [V]), v(() => {
    O && z && (ot !== null && google.maps.event.removeListener(ot), st(google.maps.event.addListener(O, "draggable_changed", z)));
  }, [z]), v(() => {
    O && q && (lt !== null && google.maps.event.removeListener(lt), Ot(google.maps.event.addListener(O, "flat_changed", q)));
  }, [q]), v(() => {
    O && K && (ut !== null && google.maps.event.removeListener(ut), ct(google.maps.event.addListener(O, "icon_changed", K)));
  }, [K]), v(() => {
    O && J && (tt !== null && google.maps.event.removeListener(tt), Xe(google.maps.event.addListener(O, "position_changed", J)));
  }, [J]), v(() => {
    O && te && (Et !== null && google.maps.event.removeListener(Et), kt(google.maps.event.addListener(O, "shape_changed", te)));
  }, [te]), v(() => {
    O && ee && (pt !== null && google.maps.event.removeListener(pt), kn(google.maps.event.addListener(O, "title_changed", ee)));
  }, [ee]), v(() => {
    O && _ && (dt !== null && google.maps.event.removeListener(dt), Ln(google.maps.event.addListener(O, "visible_changed", _)));
  }, [_]), v(() => {
    O && D && (ft !== null && google.maps.event.removeListener(ft), rn(google.maps.event.addListener(O, "zindex_changed", D)));
  }, [D]), v(() => {
    var ht = Xl(Xl(Xl({}, n || Cg), r ? Cg : {
      map: W
    }), {}, {
      position: t
    }), re = new google.maps.Marker(ht);
    return r ? r.addMarker(re, !!o) : re.setMap(W), t && re.setPosition(t), typeof s < "u" && re.setVisible(s), typeof a < "u" && re.setDraggable(a), typeof u < "u" && re.setClickable(u), typeof c == "string" && re.setCursor(c), p && re.setIcon(p), typeof d < "u" && re.setLabel(d), typeof h < "u" && re.setOpacity(h), f && re.setShape(f), typeof m == "string" && re.setTitle(m), typeof g == "number" && re.setZIndex(g), w && j(google.maps.event.addListener(re, "dblclick", w)), x && A(google.maps.event.addListener(re, "dragend", x)), y && R(google.maps.event.addListener(re, "dragstart", y)), L && fe(google.maps.event.addListener(re, "mousedown", L)), C && Re(google.maps.event.addListener(re, "mouseout", C)), P && Ve(google.maps.event.addListener(re, "mouseover", P)), F && et(google.maps.event.addListener(re, "mouseup", F)), N && Pe(google.maps.event.addListener(re, "rightclick", N)), E && it(google.maps.event.addListener(re, "click", E)), M && Se(google.maps.event.addListener(re, "drag", M)), I && We(google.maps.event.addListener(re, "clickable_changed", I)), H && nt(google.maps.event.addListener(re, "cursor_changed", H)), V && xt(google.maps.event.addListener(re, "animation_changed", V)), z && st(google.maps.event.addListener(re, "draggable_changed", z)), q && Ot(google.maps.event.addListener(re, "flat_changed", q)), K && ct(google.maps.event.addListener(re, "icon_changed", K)), J && Xe(google.maps.event.addListener(re, "position_changed", J)), te && kt(google.maps.event.addListener(re, "shape_changed", te)), ee && kn(google.maps.event.addListener(re, "title_changed", ee)), _ && Ln(google.maps.event.addListener(re, "visible_changed", _)), D && rn(google.maps.event.addListener(re, "zindex_changed", D)), T(re), $ && $(re), () => {
      U !== null && google.maps.event.removeListener(U), Z !== null && google.maps.event.removeListener(Z), Q !== null && google.maps.event.removeListener(Q), ue !== null && google.maps.event.removeListener(ue), oe !== null && google.maps.event.removeListener(oe), He !== null && google.maps.event.removeListener(He), ze !== null && google.maps.event.removeListener(ze), Ge !== null && google.maps.event.removeListener(Ge), Ye !== null && google.maps.event.removeListener(Ye), Ke !== null && google.maps.event.removeListener(Ke), Ue !== null && google.maps.event.removeListener(Ue), Ie !== null && google.maps.event.removeListener(Ie), ot !== null && google.maps.event.removeListener(ot), lt !== null && google.maps.event.removeListener(lt), ut !== null && google.maps.event.removeListener(ut), tt !== null && google.maps.event.removeListener(tt), pt !== null && google.maps.event.removeListener(pt), dt !== null && google.maps.event.removeListener(dt), ft !== null && google.maps.event.removeListener(ft), S && S(re), r ? r.removeMarker(re, !!o) : re && re.setMap(null);
    };
  }, []);
  var br = Tn(() => i ? at.map(i, (ht) => {
    if (!bi(ht))
      return ht;
    var re = ht;
    return wi(re, {
      anchor: O
    });
  }) : null, [i, O]);
  return io.jsx(io.Fragment, {
    children: br
  }) || null;
}
Ee(Ise);
class Rse extends pe {
  constructor() {
    super(...arguments), be(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this;
    return XW(function* () {
      var n = Xl(Xl(Xl({}, t.props.options || Cg), t.props.clusterer ? Cg : {
        map: t.context
      }), {}, {
        position: t.props.position
      });
      t.marker = new google.maps.Marker(n), t.props.clusterer ? t.props.clusterer.addMarker(t.marker, !!t.props.noClustererRedraw) : t.marker.setMap(t.context), t.registeredEvents = Jt({
        updaterMap: KM,
        eventMap: XM,
        prevProps: {},
        nextProps: t.props,
        instance: t.marker
      }), t.props.onLoad && t.props.onLoad(t.marker);
    })();
  }
  componentDidUpdate(t) {
    this.marker && (on(this.registeredEvents), this.registeredEvents = Jt({
      updaterMap: KM,
      eventMap: XM,
      prevProps: t,
      nextProps: this.props,
      instance: this.marker
    }));
  }
  componentWillUnmount() {
    this.marker && (this.props.onUnmount && this.props.onUnmount(this.marker), on(this.registeredEvents), this.props.clusterer ? this.props.clusterer.removeMarker(this.marker, !!this.props.noClustererRedraw) : this.marker && this.marker.setMap(null));
  }
  render() {
    var t = this.props.children ? at.map(this.props.children, (n) => {
      if (!bi(n))
        return n;
      var r = n;
      return wi(r, {
        anchor: this.marker
      });
    }) : null;
    return t || null;
  }
}
be(Rse, "contextType", Pt);
var Nse = (
  /** @class */
  function() {
    function e(t, n) {
      t.getClusterer().extend(e, google.maps.OverlayView), this.cluster = t, this.clusterClassName = this.cluster.getClusterer().getClusterClass(), this.className = this.clusterClassName, this.styles = n, this.center = void 0, this.div = null, this.sums = null, this.visible = !1, this.boundsChangedListener = null, this.url = "", this.height = 0, this.width = 0, this.anchorText = [0, 0], this.anchorIcon = [0, 0], this.textColor = "black", this.textSize = 11, this.textDecoration = "none", this.fontWeight = "bold", this.fontStyle = "normal", this.fontFamily = "Arial,sans-serif", this.backgroundPosition = "0 0", this.cMouseDownInCluster = null, this.cDraggingMapByCluster = null, this.timeOut = null, this.setMap(t.getMap()), this.onBoundsChanged = this.onBoundsChanged.bind(this), this.onMouseDown = this.onMouseDown.bind(this), this.onClick = this.onClick.bind(this), this.onMouseOver = this.onMouseOver.bind(this), this.onMouseOut = this.onMouseOut.bind(this), this.onAdd = this.onAdd.bind(this), this.onRemove = this.onRemove.bind(this), this.draw = this.draw.bind(this), this.hide = this.hide.bind(this), this.show = this.show.bind(this), this.useStyle = this.useStyle.bind(this), this.setCenter = this.setCenter.bind(this), this.getPosFromLatLng = this.getPosFromLatLng.bind(this);
    }
    return e.prototype.onBoundsChanged = function() {
      this.cDraggingMapByCluster = this.cMouseDownInCluster;
    }, e.prototype.onMouseDown = function() {
      this.cMouseDownInCluster = !0, this.cDraggingMapByCluster = !1;
    }, e.prototype.onClick = function(t) {
      if (this.cMouseDownInCluster = !1, !this.cDraggingMapByCluster) {
        var n = this.cluster.getClusterer();
        if (google.maps.event.trigger(n, "click", this.cluster), google.maps.event.trigger(n, "clusterclick", this.cluster), n.getZoomOnClick()) {
          var r = n.getMaxZoom(), o = this.cluster.getBounds(), i = n.getMap();
          i !== null && "fitBounds" in i && i.fitBounds(o), this.timeOut = window.setTimeout(function() {
            var a = n.getMap();
            if (a !== null) {
              "fitBounds" in a && a.fitBounds(o);
              var s = a.getZoom() || 0;
              r !== null && s > r && a.setZoom(r + 1);
            }
          }, 100);
        }
        t.cancelBubble = !0, t.stopPropagation && t.stopPropagation();
      }
    }, e.prototype.onMouseOver = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseover", this.cluster);
    }, e.prototype.onMouseOut = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseout", this.cluster);
    }, e.prototype.onAdd = function() {
      var t;
      this.div = document.createElement("div"), this.div.className = this.className, this.visible && this.show(), (t = this.getPanes()) === null || t === void 0 || t.overlayMouseTarget.appendChild(this.div);
      var n = this.getMap();
      n !== null && (this.boundsChangedListener = google.maps.event.addListener(n, "bounds_changed", this.onBoundsChanged), this.div.addEventListener("mousedown", this.onMouseDown), this.div.addEventListener("click", this.onClick), this.div.addEventListener("mouseover", this.onMouseOver), this.div.addEventListener("mouseout", this.onMouseOut));
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.hide(), this.boundsChangedListener !== null && google.maps.event.removeListener(this.boundsChangedListener), this.div.removeEventListener("mousedown", this.onMouseDown), this.div.removeEventListener("click", this.onClick), this.div.removeEventListener("mouseover", this.onMouseOver), this.div.removeEventListener("mouseout", this.onMouseOut), this.div.parentNode.removeChild(this.div), this.timeOut !== null && (window.clearTimeout(this.timeOut), this.timeOut = null), this.div = null);
    }, e.prototype.draw = function() {
      if (this.visible && this.div !== null && this.center) {
        var t = this.getPosFromLatLng(this.center);
        this.div.style.top = t !== null ? "".concat(t.y, "px") : "0", this.div.style.left = t !== null ? "".concat(t.x, "px") : "0";
      }
    }, e.prototype.hide = function() {
      this.div && (this.div.style.display = "none"), this.visible = !1;
    }, e.prototype.show = function() {
      var t, n, r, o, i, a;
      if (this.div && this.center) {
        var s = this.sums === null || typeof this.sums.title > "u" || this.sums.title === "" ? this.cluster.getClusterer().getTitle() : this.sums.title, l = this.backgroundPosition.split(" "), u = parseInt(((t = l[0]) === null || t === void 0 ? void 0 : t.replace(/^\s+|\s+$/g, "")) || "0", 10), c = parseInt(((n = l[1]) === null || n === void 0 ? void 0 : n.replace(/^\s+|\s+$/g, "")) || "0", 10), p = this.getPosFromLatLng(this.center);
        this.div.className = this.className, this.div.setAttribute("style", "cursor: pointer; position: absolute; top: ".concat(p !== null ? "".concat(p.y, "px") : "0", "; left: ").concat(p !== null ? "".concat(p.x, "px") : "0", "; width: ").concat(this.width, "px; height: ").concat(this.height, "px; "));
        var d = document.createElement("img");
        d.alt = s, d.src = this.url, d.width = this.width, d.height = this.height, d.setAttribute("style", "position: absolute; top: ".concat(c, "px; left: ").concat(u, "px")), this.cluster.getClusterer().enableRetinaIcons || (d.style.clip = "rect(-".concat(c, "px, -").concat(u + this.width, "px, -").concat(c + this.height, ", -").concat(u, ")"));
        var h = document.createElement("div");
        h.setAttribute("style", "position: absolute; top: ".concat(this.anchorText[0], "px; left: ").concat(this.anchorText[1], "px; color: ").concat(this.textColor, "; font-size: ").concat(this.textSize, "px; font-family: ").concat(this.fontFamily, "; font-weight: ").concat(this.fontWeight, "; fontStyle: ").concat(this.fontStyle, "; text-decoration: ").concat(this.textDecoration, "; text-align: center; width: ").concat(this.width, "px; line-height: ").concat(this.height, "px")), !((r = this.sums) === null || r === void 0) && r.text && (h.innerText = "".concat((o = this.sums) === null || o === void 0 ? void 0 : o.text)), !((i = this.sums) === null || i === void 0) && i.html && (h.innerHTML = "".concat((a = this.sums) === null || a === void 0 ? void 0 : a.html)), this.div.innerHTML = "", this.div.appendChild(d), this.div.appendChild(h), this.div.title = s, this.div.style.display = "";
      }
      this.visible = !0;
    }, e.prototype.useStyle = function(t) {
      this.sums = t;
      var n = this.cluster.getClusterer().getStyles(), r = n[Math.min(n.length - 1, Math.max(0, t.index - 1))];
      r && (this.url = r.url, this.height = r.height, this.width = r.width, r.className && (this.className = "".concat(this.clusterClassName, " ").concat(r.className)), this.anchorText = r.anchorText || [0, 0], this.anchorIcon = r.anchorIcon || [this.height / 2, this.width / 2], this.textColor = r.textColor || "black", this.textSize = r.textSize || 11, this.textDecoration = r.textDecoration || "none", this.fontWeight = r.fontWeight || "bold", this.fontStyle = r.fontStyle || "normal", this.fontFamily = r.fontFamily || "Arial,sans-serif", this.backgroundPosition = r.backgroundPosition || "0 0");
    }, e.prototype.setCenter = function(t) {
      this.center = t;
    }, e.prototype.getPosFromLatLng = function(t) {
      var n = this.getProjection().fromLatLngToDivPixel(t);
      return n !== null && (n.x -= this.anchorIcon[1], n.y -= this.anchorIcon[0]), n;
    }, e;
  }()
), Fse = (
  /** @class */
  function() {
    function e(t) {
      this.markerClusterer = t, this.map = this.markerClusterer.getMap(), this.gridSize = this.markerClusterer.getGridSize(), this.minClusterSize = this.markerClusterer.getMinimumClusterSize(), this.averageCenter = this.markerClusterer.getAverageCenter(), this.markers = [], this.center = void 0, this.bounds = null, this.clusterIcon = new Nse(this, this.markerClusterer.getStyles()), this.getSize = this.getSize.bind(this), this.getMarkers = this.getMarkers.bind(this), this.getCenter = this.getCenter.bind(this), this.getMap = this.getMap.bind(this), this.getClusterer = this.getClusterer.bind(this), this.getBounds = this.getBounds.bind(this), this.remove = this.remove.bind(this), this.addMarker = this.addMarker.bind(this), this.isMarkerInClusterBounds = this.isMarkerInClusterBounds.bind(this), this.calculateBounds = this.calculateBounds.bind(this), this.updateIcon = this.updateIcon.bind(this), this.isMarkerAlreadyAdded = this.isMarkerAlreadyAdded.bind(this);
    }
    return e.prototype.getSize = function() {
      return this.markers.length;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getCenter = function() {
      return this.center;
    }, e.prototype.getMap = function() {
      return this.map;
    }, e.prototype.getClusterer = function() {
      return this.markerClusterer;
    }, e.prototype.getBounds = function() {
      for (var t = new google.maps.LatLngBounds(this.center, this.center), n = this.getMarkers(), r = 0, o = n; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && t.extend(a);
      }
      return t;
    }, e.prototype.remove = function() {
      this.clusterIcon.setMap(null), this.markers = [], delete this.markers;
    }, e.prototype.addMarker = function(t) {
      var n;
      if (this.isMarkerAlreadyAdded(t))
        return !1;
      if (this.center) {
        if (this.averageCenter) {
          var r = t.getPosition();
          if (r) {
            var o = this.markers.length + 1;
            this.center = new google.maps.LatLng((this.center.lat() * (o - 1) + r.lat()) / o, (this.center.lng() * (o - 1) + r.lng()) / o), this.calculateBounds();
          }
        }
      } else {
        var r = t.getPosition();
        r && (this.center = r, this.calculateBounds());
      }
      t.isAdded = !0, this.markers.push(t);
      var i = this.markers.length, a = this.markerClusterer.getMaxZoom(), s = (n = this.map) === null || n === void 0 ? void 0 : n.getZoom();
      if (a !== null && typeof s < "u" && s > a)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i < this.minClusterSize)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i === this.minClusterSize)
        for (var l = 0, u = this.markers; l < u.length; l++) {
          var c = u[l];
          c.setMap(null);
        }
      else
        t.setMap(null);
      return !0;
    }, e.prototype.isMarkerInClusterBounds = function(t) {
      if (this.bounds !== null) {
        var n = t.getPosition();
        if (n)
          return this.bounds.contains(n);
      }
      return !1;
    }, e.prototype.calculateBounds = function() {
      this.bounds = this.markerClusterer.getExtendedBounds(new google.maps.LatLngBounds(this.center, this.center));
    }, e.prototype.updateIcon = function() {
      var t, n = this.markers.length, r = this.markerClusterer.getMaxZoom(), o = (t = this.map) === null || t === void 0 ? void 0 : t.getZoom();
      if (r !== null && typeof o < "u" && o > r) {
        this.clusterIcon.hide();
        return;
      }
      if (n < this.minClusterSize) {
        this.clusterIcon.hide();
        return;
      }
      this.center && this.clusterIcon.setCenter(this.center), this.clusterIcon.useStyle(this.markerClusterer.getCalculator()(this.markers, this.markerClusterer.getStyles().length)), this.clusterIcon.show();
    }, e.prototype.isMarkerAlreadyAdded = function(t) {
      if (this.markers.includes)
        return this.markers.includes(t);
      for (var n = 0; n < this.markers.length; n++)
        if (t === this.markers[n])
          return !0;
      return !1;
    }, e;
  }()
);
function zse(e, t) {
  var n = e.length, r = n.toString().length, o = Math.min(r, t);
  return {
    text: n.toString(),
    index: o,
    title: ""
  };
}
var Use = 2e3, $se = 500, Hse = "https://developers.google.com/maps/documentation/javascript/examples/markerclusterer/m", Wse = "png", Vse = [53, 56, 66, 78, 90], qse = "cluster", eV = (
  /** @class */
  function() {
    function e(t, n, r) {
      n === void 0 && (n = []), r === void 0 && (r = {}), this.getMinimumClusterSize = this.getMinimumClusterSize.bind(this), this.setMinimumClusterSize = this.setMinimumClusterSize.bind(this), this.getEnableRetinaIcons = this.getEnableRetinaIcons.bind(this), this.setEnableRetinaIcons = this.setEnableRetinaIcons.bind(this), this.addToClosestCluster = this.addToClosestCluster.bind(this), this.getImageExtension = this.getImageExtension.bind(this), this.setImageExtension = this.setImageExtension.bind(this), this.getExtendedBounds = this.getExtendedBounds.bind(this), this.getAverageCenter = this.getAverageCenter.bind(this), this.setAverageCenter = this.setAverageCenter.bind(this), this.getTotalClusters = this.getTotalClusters.bind(this), this.fitMapToMarkers = this.fitMapToMarkers.bind(this), this.getIgnoreHidden = this.getIgnoreHidden.bind(this), this.setIgnoreHidden = this.setIgnoreHidden.bind(this), this.getClusterClass = this.getClusterClass.bind(this), this.setClusterClass = this.setClusterClass.bind(this), this.getTotalMarkers = this.getTotalMarkers.bind(this), this.getZoomOnClick = this.getZoomOnClick.bind(this), this.setZoomOnClick = this.setZoomOnClick.bind(this), this.getBatchSizeIE = this.getBatchSizeIE.bind(this), this.setBatchSizeIE = this.setBatchSizeIE.bind(this), this.createClusters = this.createClusters.bind(this), this.onZoomChanged = this.onZoomChanged.bind(this), this.getImageSizes = this.getImageSizes.bind(this), this.setImageSizes = this.setImageSizes.bind(this), this.getCalculator = this.getCalculator.bind(this), this.setCalculator = this.setCalculator.bind(this), this.removeMarkers = this.removeMarkers.bind(this), this.resetViewport = this.resetViewport.bind(this), this.getImagePath = this.getImagePath.bind(this), this.setImagePath = this.setImagePath.bind(this), this.pushMarkerTo = this.pushMarkerTo.bind(this), this.removeMarker = this.removeMarker.bind(this), this.clearMarkers = this.clearMarkers.bind(this), this.setupStyles = this.setupStyles.bind(this), this.getGridSize = this.getGridSize.bind(this), this.setGridSize = this.setGridSize.bind(this), this.getClusters = this.getClusters.bind(this), this.getMaxZoom = this.getMaxZoom.bind(this), this.setMaxZoom = this.setMaxZoom.bind(this), this.getMarkers = this.getMarkers.bind(this), this.addMarkers = this.addMarkers.bind(this), this.getStyles = this.getStyles.bind(this), this.setStyles = this.setStyles.bind(this), this.addMarker = this.addMarker.bind(this), this.onRemove = this.onRemove.bind(this), this.getTitle = this.getTitle.bind(this), this.setTitle = this.setTitle.bind(this), this.repaint = this.repaint.bind(this), this.onIdle = this.onIdle.bind(this), this.redraw = this.redraw.bind(this), this.onAdd = this.onAdd.bind(this), this.draw = this.draw.bind(this), this.extend = this.extend.bind(this), this.extend(e, google.maps.OverlayView), this.markers = [], this.clusters = [], this.listeners = [], this.activeMap = null, this.ready = !1, this.gridSize = r.gridSize || 60, this.minClusterSize = r.minimumClusterSize || 2, this.maxZoom = r.maxZoom || null, this.styles = r.styles || [], this.title = r.title || "", this.zoomOnClick = !0, r.zoomOnClick !== void 0 && (this.zoomOnClick = r.zoomOnClick), this.averageCenter = !1, r.averageCenter !== void 0 && (this.averageCenter = r.averageCenter), this.ignoreHidden = !1, r.ignoreHidden !== void 0 && (this.ignoreHidden = r.ignoreHidden), this.enableRetinaIcons = !1, r.enableRetinaIcons !== void 0 && (this.enableRetinaIcons = r.enableRetinaIcons), this.imagePath = r.imagePath || Hse, this.imageExtension = r.imageExtension || Wse, this.imageSizes = r.imageSizes || Vse, this.calculator = r.calculator || zse, this.batchSize = r.batchSize || Use, this.batchSizeIE = r.batchSizeIE || $se, this.clusterClass = r.clusterClass || qse, navigator.userAgent.toLowerCase().indexOf("msie") !== -1 && (this.batchSize = this.batchSizeIE), this.timerRefStatic = null, this.setupStyles(), this.addMarkers(n, !0), this.setMap(t);
    }
    return e.prototype.onZoomChanged = function() {
      var t, n;
      this.resetViewport(!1), (((t = this.getMap()) === null || t === void 0 ? void 0 : t.getZoom()) === (this.get("minZoom") || 0) || ((n = this.getMap()) === null || n === void 0 ? void 0 : n.getZoom()) === this.get("maxZoom")) && google.maps.event.trigger(this, "idle");
    }, e.prototype.onIdle = function() {
      this.redraw();
    }, e.prototype.onAdd = function() {
      var t = this.getMap();
      this.activeMap = t, this.ready = !0, this.repaint(), t !== null && (this.listeners = [google.maps.event.addListener(t, "zoom_changed", this.onZoomChanged), google.maps.event.addListener(t, "idle", this.onIdle)]);
    }, e.prototype.onRemove = function() {
      for (var t = 0, n = this.markers; t < n.length; t++) {
        var r = n[t];
        r.getMap() !== this.activeMap && r.setMap(this.activeMap);
      }
      for (var o = 0, i = this.clusters; o < i.length; o++) {
        var a = i[o];
        a.remove();
      }
      this.clusters = [];
      for (var s = 0, l = this.listeners; s < l.length; s++) {
        var u = l[s];
        google.maps.event.removeListener(u);
      }
      this.listeners = [], this.activeMap = null, this.ready = !1;
    }, e.prototype.draw = function() {
    }, e.prototype.getMap = function() {
      return null;
    }, e.prototype.getPanes = function() {
      return null;
    }, e.prototype.getProjection = function() {
      return {
        fromContainerPixelToLatLng: function() {
          return null;
        },
        fromDivPixelToLatLng: function() {
          return null;
        },
        fromLatLngToContainerPixel: function() {
          return null;
        },
        fromLatLngToDivPixel: function() {
          return null;
        },
        getVisibleRegion: function() {
          return null;
        },
        getWorldWidth: function() {
          return 0;
        }
      };
    }, e.prototype.setMap = function() {
    }, e.prototype.addListener = function() {
      return {
        remove: function() {
        }
      };
    }, e.prototype.bindTo = function() {
    }, e.prototype.get = function() {
    }, e.prototype.notify = function() {
    }, e.prototype.set = function() {
    }, e.prototype.setValues = function() {
    }, e.prototype.unbind = function() {
    }, e.prototype.unbindAll = function() {
    }, e.prototype.setupStyles = function() {
      if (!(this.styles.length > 0))
        for (var t = 0; t < this.imageSizes.length; t++)
          this.styles.push({
            url: "".concat(this.imagePath + (t + 1), ".").concat(this.imageExtension),
            height: this.imageSizes[t] || 0,
            width: this.imageSizes[t] || 0
          });
    }, e.prototype.fitMapToMarkers = function() {
      for (var t = this.getMarkers(), n = new google.maps.LatLngBounds(), r = 0, o = t; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && n.extend(a);
      }
      var s = this.getMap();
      s !== null && "fitBounds" in s && s.fitBounds(n);
    }, e.prototype.getGridSize = function() {
      return this.gridSize;
    }, e.prototype.setGridSize = function(t) {
      this.gridSize = t;
    }, e.prototype.getMinimumClusterSize = function() {
      return this.minClusterSize;
    }, e.prototype.setMinimumClusterSize = function(t) {
      this.minClusterSize = t;
    }, e.prototype.getMaxZoom = function() {
      return this.maxZoom;
    }, e.prototype.setMaxZoom = function(t) {
      this.maxZoom = t;
    }, e.prototype.getStyles = function() {
      return this.styles;
    }, e.prototype.setStyles = function(t) {
      this.styles = t;
    }, e.prototype.getTitle = function() {
      return this.title;
    }, e.prototype.setTitle = function(t) {
      this.title = t;
    }, e.prototype.getZoomOnClick = function() {
      return this.zoomOnClick;
    }, e.prototype.setZoomOnClick = function(t) {
      this.zoomOnClick = t;
    }, e.prototype.getAverageCenter = function() {
      return this.averageCenter;
    }, e.prototype.setAverageCenter = function(t) {
      this.averageCenter = t;
    }, e.prototype.getIgnoreHidden = function() {
      return this.ignoreHidden;
    }, e.prototype.setIgnoreHidden = function(t) {
      this.ignoreHidden = t;
    }, e.prototype.getEnableRetinaIcons = function() {
      return this.enableRetinaIcons;
    }, e.prototype.setEnableRetinaIcons = function(t) {
      this.enableRetinaIcons = t;
    }, e.prototype.getImageExtension = function() {
      return this.imageExtension;
    }, e.prototype.setImageExtension = function(t) {
      this.imageExtension = t;
    }, e.prototype.getImagePath = function() {
      return this.imagePath;
    }, e.prototype.setImagePath = function(t) {
      this.imagePath = t;
    }, e.prototype.getImageSizes = function() {
      return this.imageSizes;
    }, e.prototype.setImageSizes = function(t) {
      this.imageSizes = t;
    }, e.prototype.getCalculator = function() {
      return this.calculator;
    }, e.prototype.setCalculator = function(t) {
      this.calculator = t;
    }, e.prototype.getBatchSizeIE = function() {
      return this.batchSizeIE;
    }, e.prototype.setBatchSizeIE = function(t) {
      this.batchSizeIE = t;
    }, e.prototype.getClusterClass = function() {
      return this.clusterClass;
    }, e.prototype.setClusterClass = function(t) {
      this.clusterClass = t;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getTotalMarkers = function() {
      return this.markers.length;
    }, e.prototype.getClusters = function() {
      return this.clusters;
    }, e.prototype.getTotalClusters = function() {
      return this.clusters.length;
    }, e.prototype.addMarker = function(t, n) {
      this.pushMarkerTo(t), n || this.redraw();
    }, e.prototype.addMarkers = function(t, n) {
      for (var r in t)
        if (Object.prototype.hasOwnProperty.call(t, r)) {
          var o = t[r];
          o && this.pushMarkerTo(o);
        }
      n || this.redraw();
    }, e.prototype.pushMarkerTo = function(t) {
      var n = this;
      t.getDraggable() && google.maps.event.addListener(t, "dragend", function() {
        n.ready && (t.isAdded = !1, n.repaint());
      }), t.isAdded = !1, this.markers.push(t);
    }, e.prototype.removeMarker_ = function(t) {
      var n = -1;
      if (this.markers.indexOf)
        n = this.markers.indexOf(t);
      else
        for (var r = 0; r < this.markers.length; r++)
          if (t === this.markers[r]) {
            n = r;
            break;
          }
      return n === -1 ? !1 : (t.setMap(null), this.markers.splice(n, 1), !0);
    }, e.prototype.removeMarker = function(t, n) {
      var r = this.removeMarker_(t);
      return !n && r && this.repaint(), r;
    }, e.prototype.removeMarkers = function(t, n) {
      for (var r = !1, o = 0, i = t; o < i.length; o++) {
        var a = i[o];
        r = r || this.removeMarker_(a);
      }
      return !n && r && this.repaint(), r;
    }, e.prototype.clearMarkers = function() {
      this.resetViewport(!0), this.markers = [];
    }, e.prototype.repaint = function() {
      var t = this.clusters.slice();
      this.clusters = [], this.resetViewport(!1), this.redraw(), setTimeout(function() {
        for (var n = 0, r = t; n < r.length; n++) {
          var o = r[n];
          o.remove();
        }
      }, 0);
    }, e.prototype.getExtendedBounds = function(t) {
      var n = this.getProjection(), r = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getNorthEast().lat(), t.getNorthEast().lng())
      );
      r !== null && (r.x += this.gridSize, r.y -= this.gridSize);
      var o = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getSouthWest().lat(), t.getSouthWest().lng())
      );
      if (o !== null && (o.x -= this.gridSize, o.y += this.gridSize), r !== null) {
        var i = n.fromDivPixelToLatLng(r);
        i !== null && t.extend(i);
      }
      if (o !== null) {
        var a = n.fromDivPixelToLatLng(o);
        a !== null && t.extend(a);
      }
      return t;
    }, e.prototype.redraw = function() {
      this.createClusters(0);
    }, e.prototype.resetViewport = function(t) {
      for (var n = 0, r = this.clusters; n < r.length; n++) {
        var o = r[n];
        o.remove();
      }
      this.clusters = [];
      for (var i = 0, a = this.markers; i < a.length; i++) {
        var s = a[i];
        s.isAdded = !1, t && s.setMap(null);
      }
    }, e.prototype.distanceBetweenPoints = function(t, n) {
      var r = 6371, o = (n.lat() - t.lat()) * Math.PI / 180, i = (n.lng() - t.lng()) * Math.PI / 180, a = Math.sin(o / 2) * Math.sin(o / 2) + Math.cos(t.lat() * Math.PI / 180) * Math.cos(n.lat() * Math.PI / 180) * Math.sin(i / 2) * Math.sin(i / 2);
      return r * (2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)));
    }, e.prototype.isMarkerInBounds = function(t, n) {
      var r = t.getPosition();
      return r ? n.contains(r) : !1;
    }, e.prototype.addToClosestCluster = function(t) {
      for (var n, r = 4e4, o = null, i = 0, a = this.clusters; i < a.length; i++) {
        var s = a[i];
        n = s;
        var l = n.getCenter(), u = t.getPosition();
        if (l && u) {
          var c = this.distanceBetweenPoints(l, u);
          c < r && (r = c, o = n);
        }
      }
      o && o.isMarkerInClusterBounds(t) ? o.addMarker(t) : (n = new Fse(this), n.addMarker(t), this.clusters.push(n));
    }, e.prototype.createClusters = function(t) {
      var n = this;
      if (this.ready) {
        t === 0 && (google.maps.event.trigger(this, "clusteringbegin", this), this.timerRefStatic !== null && (window.clearTimeout(this.timerRefStatic), delete this.timerRefStatic));
        for (var r = this.getMap(), o = r !== null && ("getBounds" in r) ? r.getBounds() : null, i = (r == null ? void 0 : r.getZoom()) || 0, a = i > 3 ? new google.maps.LatLngBounds(o == null ? void 0 : o.getSouthWest(), o == null ? void 0 : o.getNorthEast()) : new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625)), s = this.getExtendedBounds(a), l = Math.min(t + this.batchSize, this.markers.length), u = t; u < l; u++) {
          var c = this.markers[u];
          c && !c.isAdded && this.isMarkerInBounds(c, s) && (!this.ignoreHidden || this.ignoreHidden && c.getVisible()) && this.addToClosestCluster(c);
        }
        if (l < this.markers.length)
          this.timerRefStatic = window.setTimeout(function() {
            n.createClusters(l);
          }, 0);
        else {
          this.timerRefStatic = null, google.maps.event.trigger(this, "clusteringend", this);
          for (var p = 0, d = this.clusters; p < d.length; p++) {
            var h = d[p];
            h.updateIcon();
          }
        }
      }
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype) {
          var i = o;
          this.prototype[i] = r.prototype[i];
        }
        return this;
      }).apply(t, [n]);
    }, e;
  }()
);
function YM(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Zse(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? YM(Object(n), !0).forEach(function(r) {
      be(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : YM(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var pi = {
  onClick: "click",
  onClusteringBegin: "clusteringbegin",
  onClusteringEnd: "clusteringend",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover"
}, cn = {
  averageCenter(e, t) {
    e.setAverageCenter(t);
  },
  batchSizeIE(e, t) {
    e.setBatchSizeIE(t);
  },
  calculator(e, t) {
    e.setCalculator(t);
  },
  clusterClass(e, t) {
    e.setClusterClass(t);
  },
  enableRetinaIcons(e, t) {
    e.setEnableRetinaIcons(t);
  },
  gridSize(e, t) {
    e.setGridSize(t);
  },
  ignoreHidden(e, t) {
    e.setIgnoreHidden(t);
  },
  imageExtension(e, t) {
    e.setImageExtension(t);
  },
  imagePath(e, t) {
    e.setImagePath(t);
  },
  imageSizes(e, t) {
    e.setImageSizes(t);
  },
  maxZoom(e, t) {
    e.setMaxZoom(t);
  },
  minimumClusterSize(e, t) {
    e.setMinimumClusterSize(t);
  },
  styles(e, t) {
    e.setStyles(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  zoomOnClick(e, t) {
    e.setZoomOnClick(t);
  }
}, Gse = {};
function Xse(e) {
  var {
    children: t,
    options: n,
    averageCenter: r,
    batchSizeIE: o,
    calculator: i,
    clusterClass: a,
    enableRetinaIcons: s,
    gridSize: l,
    ignoreHidden: u,
    imageExtension: c,
    imagePath: p,
    imageSizes: d,
    maxZoom: h,
    minimumClusterSize: f,
    styles: m,
    title: g,
    zoomOnClick: E,
    onClick: w,
    onClusteringBegin: M,
    onClusteringEnd: x,
    onMouseOver: y,
    onMouseOut: C,
    onLoad: P,
    onUnmount: F
  } = e, [L, N] = k(null), I = ye(Pt), [H, V] = k(null), [z, q] = k(null), [K, J] = k(null), [te, ee] = k(null), [_, D] = k(null);
  return v(() => {
    L && C && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(L, pi.onMouseOut, C)));
  }, [C]), v(() => {
    L && y && (_ !== null && google.maps.event.removeListener(_), D(google.maps.event.addListener(L, pi.onMouseOver, y)));
  }, [y]), v(() => {
    L && w && (H !== null && google.maps.event.removeListener(H), V(google.maps.event.addListener(L, pi.onClick, w)));
  }, [w]), v(() => {
    L && M && (z !== null && google.maps.event.removeListener(z), q(google.maps.event.addListener(L, pi.onClusteringBegin, M)));
  }, [M]), v(() => {
    L && x && (K !== null && google.maps.event.removeListener(K), q(google.maps.event.addListener(L, pi.onClusteringEnd, x)));
  }, [x]), v(() => {
    typeof r < "u" && L !== null && cn.averageCenter(L, r);
  }, [L, r]), v(() => {
    typeof o < "u" && L !== null && cn.batchSizeIE(L, o);
  }, [L, o]), v(() => {
    typeof i < "u" && L !== null && cn.calculator(L, i);
  }, [L, i]), v(() => {
    typeof a < "u" && L !== null && cn.clusterClass(L, a);
  }, [L, a]), v(() => {
    typeof s < "u" && L !== null && cn.enableRetinaIcons(L, s);
  }, [L, s]), v(() => {
    typeof l < "u" && L !== null && cn.gridSize(L, l);
  }, [L, l]), v(() => {
    typeof u < "u" && L !== null && cn.ignoreHidden(L, u);
  }, [L, u]), v(() => {
    typeof c < "u" && L !== null && cn.imageExtension(L, c);
  }, [L, c]), v(() => {
    typeof p < "u" && L !== null && cn.imagePath(L, p);
  }, [L, p]), v(() => {
    typeof d < "u" && L !== null && cn.imageSizes(L, d);
  }, [L, d]), v(() => {
    typeof h < "u" && L !== null && cn.maxZoom(L, h);
  }, [L, h]), v(() => {
    typeof f < "u" && L !== null && cn.minimumClusterSize(L, f);
  }, [L, f]), v(() => {
    typeof m < "u" && L !== null && cn.styles(L, m);
  }, [L, m]), v(() => {
    typeof g < "u" && L !== null && cn.title(L, g);
  }, [L, g]), v(() => {
    typeof E < "u" && L !== null && cn.zoomOnClick(L, E);
  }, [L, E]), v(() => {
    if (I) {
      var $ = Zse({}, n || Gse), S = new eV(I, [], $);
      return r && cn.averageCenter(S, r), o && cn.batchSizeIE(S, o), i && cn.calculator(S, i), a && cn.clusterClass(S, a), s && cn.enableRetinaIcons(S, s), l && cn.gridSize(S, l), u && cn.ignoreHidden(S, u), c && cn.imageExtension(S, c), p && cn.imagePath(S, p), d && cn.imageSizes(S, d), h && cn.maxZoom(S, h), f && cn.minimumClusterSize(S, f), m && cn.styles(S, m), g && cn.title(S, g), E && cn.zoomOnClick(S, E), C && ee(google.maps.event.addListener(S, pi.onMouseOut, C)), y && D(google.maps.event.addListener(S, pi.onMouseOver, y)), w && V(google.maps.event.addListener(S, pi.onClick, w)), M && q(google.maps.event.addListener(S, pi.onClusteringBegin, M)), x && J(google.maps.event.addListener(S, pi.onClusteringEnd, x)), N(S), P && P(S), () => {
        te !== null && google.maps.event.removeListener(te), _ !== null && google.maps.event.removeListener(_), H !== null && google.maps.event.removeListener(H), z !== null && google.maps.event.removeListener(z), K !== null && google.maps.event.removeListener(K), F && F(S);
      };
    }
  }, []), L !== null && t(L) || null;
}
Ee(Xse);
class Kse extends pe {
  constructor() {
    super(...arguments), be(this, "registeredEvents", []), be(this, "state", {
      markerClusterer: null
    }), be(this, "setClustererCallback", () => {
      this.state.markerClusterer !== null && this.props.onLoad && this.props.onLoad(this.state.markerClusterer);
    });
  }
  componentDidMount() {
    if (this.context) {
      var t = new eV(this.context, [], this.props.options);
      this.registeredEvents = Jt({
        updaterMap: cn,
        eventMap: pi,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        markerClusterer: t
      }), this.setClustererCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.markerClusterer && (on(this.registeredEvents), this.registeredEvents = Jt({
      updaterMap: cn,
      eventMap: pi,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.markerClusterer
    }));
  }
  componentWillUnmount() {
    this.state.markerClusterer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.markerClusterer), on(this.registeredEvents), this.state.markerClusterer.setMap(null));
  }
  render() {
    return this.state.markerClusterer !== null ? this.props.children(this.state.markerClusterer) : null;
  }
}
be(Kse, "contextType", Pt);
function JM(e) {
  e.cancelBubble = !0, e.stopPropagation && e.stopPropagation();
}
var tV = (
  /** @class */
  function() {
    function e(t) {
      t === void 0 && (t = {}), this.getCloseClickHandler = this.getCloseClickHandler.bind(this), this.closeClickHandler = this.closeClickHandler.bind(this), this.createInfoBoxDiv = this.createInfoBoxDiv.bind(this), this.addClickHandler = this.addClickHandler.bind(this), this.getCloseBoxImg = this.getCloseBoxImg.bind(this), this.getBoxWidths = this.getBoxWidths.bind(this), this.setBoxStyle = this.setBoxStyle.bind(this), this.setPosition = this.setPosition.bind(this), this.getPosition = this.getPosition.bind(this), this.setOptions = this.setOptions.bind(this), this.setContent = this.setContent.bind(this), this.setVisible = this.setVisible.bind(this), this.getContent = this.getContent.bind(this), this.getVisible = this.getVisible.bind(this), this.setZIndex = this.setZIndex.bind(this), this.getZIndex = this.getZIndex.bind(this), this.onRemove = this.onRemove.bind(this), this.panBox = this.panBox.bind(this), this.extend = this.extend.bind(this), this.close = this.close.bind(this), this.draw = this.draw.bind(this), this.show = this.show.bind(this), this.hide = this.hide.bind(this), this.open = this.open.bind(this), this.extend(e, google.maps.OverlayView), this.content = t.content || "", this.disableAutoPan = t.disableAutoPan || !1, this.maxWidth = t.maxWidth || 0, this.pixelOffset = t.pixelOffset || new google.maps.Size(0, 0), this.position = t.position || new google.maps.LatLng(0, 0), this.zIndex = t.zIndex || null, this.boxClass = t.boxClass || "infoBox", this.boxStyle = t.boxStyle || {}, this.closeBoxMargin = t.closeBoxMargin || "2px", this.closeBoxURL = t.closeBoxURL || "http://www.google.com/intl/en_us/mapfiles/close.gif", t.closeBoxURL === "" && (this.closeBoxURL = ""), this.infoBoxClearance = t.infoBoxClearance || new google.maps.Size(1, 1), typeof t.visible > "u" && (typeof t.isHidden > "u" ? t.visible = !0 : t.visible = !t.isHidden), this.isHidden = !t.visible, this.alignBottom = t.alignBottom || !1, this.pane = t.pane || "floatPane", this.enableEventPropagation = t.enableEventPropagation || !1, this.div = null, this.closeListener = null, this.moveListener = null, this.mapListener = null, this.contextListener = null, this.eventListeners = null, this.fixedWidthSet = null;
    }
    return e.prototype.createInfoBoxDiv = function() {
      var t = this, n = function(u) {
        u.returnValue = !1, u.preventDefault && u.preventDefault(), t.enableEventPropagation || JM(u);
      };
      if (!this.div) {
        this.div = document.createElement("div"), this.setBoxStyle(), typeof this.content == "string" ? this.div.innerHTML = this.getCloseBoxImg() + this.content : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(this.content));
        var r = this.getPanes();
        if (r !== null && r[this.pane].appendChild(this.div), this.addClickHandler(), this.div.style.width)
          this.fixedWidthSet = !0;
        else if (this.maxWidth !== 0 && this.div.offsetWidth > this.maxWidth)
          this.div.style.width = this.maxWidth + "px", this.fixedWidthSet = !0;
        else {
          var o = this.getBoxWidths();
          this.div.style.width = this.div.offsetWidth - o.left - o.right + "px", this.fixedWidthSet = !1;
        }
        if (this.panBox(this.disableAutoPan), !this.enableEventPropagation) {
          this.eventListeners = [];
          for (var i = ["mousedown", "mouseover", "mouseout", "mouseup", "click", "dblclick", "touchstart", "touchend", "touchmove"], a = 0, s = i; a < s.length; a++) {
            var l = s[a];
            this.eventListeners.push(google.maps.event.addListener(this.div, l, JM));
          }
          this.eventListeners.push(google.maps.event.addListener(this.div, "mouseover", function() {
            t.div && (t.div.style.cursor = "default");
          }));
        }
        this.contextListener = google.maps.event.addListener(this.div, "contextmenu", n), google.maps.event.trigger(this, "domready");
      }
    }, e.prototype.getCloseBoxImg = function() {
      var t = "";
      return this.closeBoxURL !== "" && (t = '<img alt=""', t += ' aria-hidden="true"', t += " src='" + this.closeBoxURL + "'", t += " align=right", t += " style='", t += " position: relative;", t += " cursor: pointer;", t += " margin: " + this.closeBoxMargin + ";", t += "'>"), t;
    }, e.prototype.addClickHandler = function() {
      this.closeListener = this.div && this.div.firstChild && this.closeBoxURL !== "" ? google.maps.event.addListener(this.div.firstChild, "click", this.getCloseClickHandler()) : null;
    }, e.prototype.closeClickHandler = function(t) {
      t.cancelBubble = !0, t.stopPropagation && t.stopPropagation(), google.maps.event.trigger(this, "closeclick"), this.close();
    }, e.prototype.getCloseClickHandler = function() {
      return this.closeClickHandler;
    }, e.prototype.panBox = function(t) {
      if (this.div && !t) {
        var n = this.getMap();
        if (n instanceof google.maps.Map) {
          var r = 0, o = 0, i = n.getBounds();
          i && !i.contains(this.position) && n.setCenter(this.position);
          var a = n.getDiv(), s = a.offsetWidth, l = a.offsetHeight, u = this.pixelOffset.width, c = this.pixelOffset.height, p = this.div.offsetWidth, d = this.div.offsetHeight, h = this.infoBoxClearance.width, f = this.infoBoxClearance.height, m = this.getProjection(), g = m.fromLatLngToContainerPixel(this.position);
          g !== null && (g.x < -u + h ? r = g.x + u - h : g.x + p + u + h > s && (r = g.x + p + u + h - s), this.alignBottom ? g.y < -c + f + d ? o = g.y + c - f - d : g.y + c + f > l && (o = g.y + c + f - l) : g.y < -c + f ? o = g.y + c - f : g.y + d + c + f > l && (o = g.y + d + c + f - l)), r === 0 && o === 0 || n.panBy(r, o);
        }
      }
    }, e.prototype.setBoxStyle = function() {
      if (this.div) {
        this.div.className = this.boxClass, this.div.style.cssText = "";
        var t = this.boxStyle;
        for (var n in t)
          Object.prototype.hasOwnProperty.call(t, n) && (this.div.style[n] = t[n]);
        if (this.div.style.webkitTransform = "translateZ(0)", typeof this.div.style.opacity < "u" && this.div.style.opacity !== "") {
          var r = parseFloat(this.div.style.opacity || "");
          this.div.style.msFilter = '"progid:DXImageTransform.Microsoft.Alpha(Opacity=' + r * 100 + ')"', this.div.style.filter = "alpha(opacity=" + r * 100 + ")";
        }
        this.div.style.position = "absolute", this.div.style.visibility = "hidden", this.zIndex !== null && (this.div.style.zIndex = this.zIndex + ""), this.div.style.overflow || (this.div.style.overflow = "auto");
      }
    }, e.prototype.getBoxWidths = function() {
      var t = {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0
      };
      if (!this.div)
        return t;
      if (document.defaultView) {
        var n = this.div.ownerDocument, r = n && n.defaultView ? n.defaultView.getComputedStyle(this.div, "") : null;
        r && (t.top = parseInt(r.borderTopWidth || "", 10) || 0, t.bottom = parseInt(r.borderBottomWidth || "", 10) || 0, t.left = parseInt(r.borderLeftWidth || "", 10) || 0, t.right = parseInt(r.borderRightWidth || "", 10) || 0);
      } else if (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        document.documentElement.currentStyle
      ) {
        var o = this.div.currentStyle;
        o && (t.top = parseInt(o.borderTopWidth || "", 10) || 0, t.bottom = parseInt(o.borderBottomWidth || "", 10) || 0, t.left = parseInt(o.borderLeftWidth || "", 10) || 0, t.right = parseInt(o.borderRightWidth || "", 10) || 0);
      }
      return t;
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.div.parentNode.removeChild(this.div), this.div = null);
    }, e.prototype.draw = function() {
      if (this.createInfoBoxDiv(), this.div) {
        var t = this.getProjection(), n = t.fromLatLngToDivPixel(this.position);
        n !== null && (this.div.style.left = n.x + this.pixelOffset.width + "px", this.alignBottom ? this.div.style.bottom = -(n.y + this.pixelOffset.height) + "px" : this.div.style.top = n.y + this.pixelOffset.height + "px"), this.isHidden ? this.div.style.visibility = "hidden" : this.div.style.visibility = "visible";
      }
    }, e.prototype.setOptions = function(t) {
      t === void 0 && (t = {}), typeof t.boxClass < "u" && (this.boxClass = t.boxClass, this.setBoxStyle()), typeof t.boxStyle < "u" && (this.boxStyle = t.boxStyle, this.setBoxStyle()), typeof t.content < "u" && this.setContent(t.content), typeof t.disableAutoPan < "u" && (this.disableAutoPan = t.disableAutoPan), typeof t.maxWidth < "u" && (this.maxWidth = t.maxWidth), typeof t.pixelOffset < "u" && (this.pixelOffset = t.pixelOffset), typeof t.alignBottom < "u" && (this.alignBottom = t.alignBottom), typeof t.position < "u" && this.setPosition(t.position), typeof t.zIndex < "u" && this.setZIndex(t.zIndex), typeof t.closeBoxMargin < "u" && (this.closeBoxMargin = t.closeBoxMargin), typeof t.closeBoxURL < "u" && (this.closeBoxURL = t.closeBoxURL), typeof t.infoBoxClearance < "u" && (this.infoBoxClearance = t.infoBoxClearance), typeof t.isHidden < "u" && (this.isHidden = t.isHidden), typeof t.visible < "u" && (this.isHidden = !t.visible), typeof t.enableEventPropagation < "u" && (this.enableEventPropagation = t.enableEventPropagation), this.div && this.draw();
    }, e.prototype.setContent = function(t) {
      this.content = t, this.div && (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.fixedWidthSet || (this.div.style.width = ""), typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t)), this.fixedWidthSet || (this.div.style.width = this.div.offsetWidth + "px", typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t))), this.addClickHandler()), google.maps.event.trigger(this, "content_changed");
    }, e.prototype.setPosition = function(t) {
      this.position = t, this.div && this.draw(), google.maps.event.trigger(this, "position_changed");
    }, e.prototype.setVisible = function(t) {
      this.isHidden = !t, this.div && (this.div.style.visibility = this.isHidden ? "hidden" : "visible");
    }, e.prototype.setZIndex = function(t) {
      this.zIndex = t, this.div && (this.div.style.zIndex = t + ""), google.maps.event.trigger(this, "zindex_changed");
    }, e.prototype.getContent = function() {
      return this.content;
    }, e.prototype.getPosition = function() {
      return this.position;
    }, e.prototype.getZIndex = function() {
      return this.zIndex;
    }, e.prototype.getVisible = function() {
      var t = this.getMap();
      return typeof t > "u" || t === null ? !1 : !this.isHidden;
    }, e.prototype.show = function() {
      this.isHidden = !1, this.div && (this.div.style.visibility = "visible");
    }, e.prototype.hide = function() {
      this.isHidden = !0, this.div && (this.div.style.visibility = "hidden");
    }, e.prototype.open = function(t, n) {
      var r = this;
      n && (this.position = n.getPosition(), this.moveListener = google.maps.event.addListener(n, "position_changed", function() {
        var o = n.getPosition();
        r.setPosition(o);
      }), this.mapListener = google.maps.event.addListener(n, "map_changed", function() {
        r.setMap(n.map);
      })), this.setMap(t), this.div && this.panBox();
    }, e.prototype.close = function() {
      if (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.eventListeners) {
        for (var t = 0, n = this.eventListeners; t < n.length; t++) {
          var r = n[t];
          google.maps.event.removeListener(r);
        }
        this.eventListeners = null;
      }
      this.moveListener && (google.maps.event.removeListener(this.moveListener), this.moveListener = null), this.mapListener && (google.maps.event.removeListener(this.mapListener), this.mapListener = null), this.contextListener && (google.maps.event.removeListener(this.contextListener), this.contextListener = null), this.setMap(null);
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype)
          Object.prototype.hasOwnProperty.call(this, o) || (this.prototype[o] = r.prototype[o]);
        return this;
      }).apply(t, [n]);
    }, e;
  }()
), Yse = ["position"], Jse = ["position"];
function QM(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function xg(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? QM(Object(n), !0).forEach(function(r) {
      be(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : QM(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var eD = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, tD = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    t instanceof google.maps.LatLng ? e.setPosition(t) : e.setPosition(new google.maps.LatLng(t.lat, t.lng));
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, Qse = {};
function eae(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, h = ye(Pt), [f, m] = k(null), [g, E] = k(null), [w, M] = k(null), [x, y] = k(null), [C, P] = k(null), [F, L] = k(null), N = rt(null);
  return v(() => {
    h && f !== null && (f.close(), n ? f.open(h, n) : f.getPosition() && f.open(h));
  }, [h, f, n]), v(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), v(() => {
    if (o && f !== null) {
      var I = o instanceof google.maps.LatLng ? o : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        new google.maps.LatLng(o.lat, o.lng)
      );
      f.setPosition(I);
    }
  }, [o]), v(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), v(() => {
    f && a && (g !== null && google.maps.event.removeListener(g), E(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), v(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), M(google.maps.event.addListener(f, "domready", s)));
  }, [s]), v(() => {
    f && l && (x !== null && google.maps.event.removeListener(x), y(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), v(() => {
    f && u && (C !== null && google.maps.event.removeListener(C), P(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), v(() => {
    f && c && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), v(() => {
    if (h) {
      var I = r || Qse, {
        position: H
      } = I, V = ek(I, Yse), z;
      H && !(H instanceof google.maps.LatLng) && (z = new google.maps.LatLng(H.lat, H.lng));
      var q = new tV(xg(xg({}, V), z ? {
        position: z
      } : {}));
      N.current = document.createElement("div"), m(q), a && E(google.maps.event.addListener(q, "closeclick", a)), s && M(google.maps.event.addListener(q, "domready", s)), l && y(google.maps.event.addListener(q, "content_changed", l)), u && P(google.maps.event.addListener(q, "position_changed", u)), c && L(google.maps.event.addListener(q, "zindex_changed", c)), q.setContent(N.current), n ? q.open(h, n) : q.getPosition() ? q.open(h) : qr(!1, "You must provide either an anchor or a position prop for <InfoBox>."), p && p(q);
    }
    return () => {
      f !== null && (g && google.maps.event.removeListener(g), x && google.maps.event.removeListener(x), w && google.maps.event.removeListener(w), C && google.maps.event.removeListener(C), F && google.maps.event.removeListener(F), d && d(f), f.close());
    };
  }, []), N.current ? yr(at.only(t), N.current) : null;
}
Ee(eae);
class tae extends pe {
  constructor() {
    super(...arguments), be(this, "registeredEvents", []), be(this, "containerElement", null), be(this, "state", {
      infoBox: null
    }), be(this, "open", (t, n) => {
      n ? this.context !== null && t.open(this.context, n) : t.getPosition() ? this.context !== null && t.open(this.context) : qr(!1, "You must provide either an anchor or a position prop for <InfoBox>.");
    }), be(this, "setInfoBoxCallback", () => {
      this.state.infoBox !== null && this.containerElement !== null && (this.state.infoBox.setContent(this.containerElement), this.open(this.state.infoBox, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoBox));
    });
  }
  componentDidMount() {
    var t = this.props.options || {}, {
      position: n
    } = t, r = ek(t, Jse), o;
    n && !(n instanceof google.maps.LatLng) && (o = new google.maps.LatLng(n.lat, n.lng));
    var i = new tV(xg(xg({}, r), o ? {
      position: o
    } : {}));
    this.containerElement = document.createElement("div"), this.registeredEvents = Jt({
      updaterMap: tD,
      eventMap: eD,
      prevProps: {},
      nextProps: this.props,
      instance: i
    }), this.setState({
      infoBox: i
    }, this.setInfoBoxCallback);
  }
  componentDidUpdate(t) {
    var {
      infoBox: n
    } = this.state;
    n !== null && (on(this.registeredEvents), this.registeredEvents = Jt({
      updaterMap: tD,
      eventMap: eD,
      prevProps: t,
      nextProps: this.props,
      instance: n
    }));
  }
  componentWillUnmount() {
    var {
      onUnmount: t
    } = this.props, {
      infoBox: n
    } = this.state;
    n !== null && (t && t(n), on(this.registeredEvents), n.close());
  }
  render() {
    return this.containerElement ? yr(at.only(this.props.children), this.containerElement) : null;
  }
}
be(tae, "contextType", Pt);
var nD, rD;
function nae() {
  return rD || (rD = 1, nD = function e(t, n) {
    if (t === n) return !0;
    if (t && n && typeof t == "object" && typeof n == "object") {
      if (t.constructor !== n.constructor) return !1;
      var r, o, i;
      if (Array.isArray(t)) {
        if (r = t.length, r != n.length) return !1;
        for (o = r; o-- !== 0; ) if (!e(t[o], n[o])) return !1;
        return !0;
      }
      if (t.constructor === RegExp) return t.source === n.source && t.flags === n.flags;
      if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === n.valueOf();
      if (t.toString !== Object.prototype.toString) return t.toString() === n.toString();
      if (i = Object.keys(t), r = i.length, r !== Object.keys(n).length) return !1;
      for (o = r; o-- !== 0; ) if (!Object.prototype.hasOwnProperty.call(n, i[o])) return !1;
      for (o = r; o-- !== 0; ) {
        var a = i[o];
        if (!e(t[a], n[a])) return !1;
      }
      return !0;
    }
    return t !== t && n !== n;
  }), nD;
}
var rae = nae(), oD = /* @__PURE__ */ GW(rae), iD = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array], Bb = 1, Wu = 8;
class tk {
  /**
   * Creates an index from raw `ArrayBuffer` data.
   * @param {ArrayBuffer} data
   */
  static from(t) {
    if (!(t instanceof ArrayBuffer))
      throw new Error("Data must be an instance of ArrayBuffer.");
    var [n, r] = new Uint8Array(t, 0, 2);
    if (n !== 219)
      throw new Error("Data does not appear to be in a KDBush format.");
    var o = r >> 4;
    if (o !== Bb)
      throw new Error("Got v".concat(o, " data when expected v").concat(Bb, "."));
    var i = iD[r & 15];
    if (!i)
      throw new Error("Unrecognized array type.");
    var [a] = new Uint16Array(t, 2, 1), [s] = new Uint32Array(t, 4, 1);
    return new tk(s, a, i, t);
  }
  /**
   * Creates an index that will hold a given number of items.
   * @param {number} numItems
   * @param {number} [nodeSize=64] Size of the KD-tree node (64 by default).
   * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).
   * @param {ArrayBuffer} [data] (For internal use only)
   */
  constructor(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 64, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Float64Array, o = arguments.length > 3 ? arguments[3] : void 0;
    if (isNaN(t) || t < 0) throw new Error("Unpexpected numItems value: ".concat(t, "."));
    this.numItems = +t, this.nodeSize = Math.min(Math.max(+n, 2), 65535), this.ArrayType = r, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
    var i = iD.indexOf(this.ArrayType), a = t * 2 * this.ArrayType.BYTES_PER_ELEMENT, s = t * this.IndexArrayType.BYTES_PER_ELEMENT, l = (8 - s % 8) % 8;
    if (i < 0)
      throw new Error("Unexpected typed array class: ".concat(r, "."));
    o && o instanceof ArrayBuffer ? (this.data = o, this.ids = new this.IndexArrayType(this.data, Wu, t), this.coords = new this.ArrayType(this.data, Wu + s + l, t * 2), this._pos = t * 2, this._finished = !0) : (this.data = new ArrayBuffer(Wu + a + s + l), this.ids = new this.IndexArrayType(this.data, Wu, t), this.coords = new this.ArrayType(this.data, Wu + s + l, t * 2), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, (Bb << 4) + i]), new Uint16Array(this.data, 2, 1)[0] = n, new Uint32Array(this.data, 4, 1)[0] = t);
  }
  /**
   * Add a point to the index.
   * @param {number} x
   * @param {number} y
   * @returns {number} An incremental index associated with the added item (starting from `0`).
   */
  add(t, n) {
    var r = this._pos >> 1;
    return this.ids[r] = r, this.coords[this._pos++] = t, this.coords[this._pos++] = n, r;
  }
  /**
   * Perform indexing of the added points.
   */
  finish() {
    var t = this._pos >> 1;
    if (t !== this.numItems)
      throw new Error("Added ".concat(t, " items when expected ").concat(this.numItems, "."));
    return YC(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
  }
  /**
   * Search the index for items within a given bounding box.
   * @param {number} minX
   * @param {number} minY
   * @param {number} maxX
   * @param {number} maxY
   * @returns {number[]} An array of indices correponding to the found items.
   */
  range(t, n, r, o) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: i,
      coords: a,
      nodeSize: s
    } = this, l = [0, i.length - 1, 0], u = []; l.length; ) {
      var c = l.pop() || 0, p = l.pop() || 0, d = l.pop() || 0;
      if (p - d <= s) {
        for (var h = d; h <= p; h++) {
          var f = a[2 * h], m = a[2 * h + 1];
          f >= t && f <= r && m >= n && m <= o && u.push(i[h]);
        }
        continue;
      }
      var g = d + p >> 1, E = a[2 * g], w = a[2 * g + 1];
      E >= t && E <= r && w >= n && w <= o && u.push(i[g]), (c === 0 ? t <= E : n <= w) && (l.push(d), l.push(g - 1), l.push(1 - c)), (c === 0 ? r >= E : o >= w) && (l.push(g + 1), l.push(p), l.push(1 - c));
    }
    return u;
  }
  /**
   * Search the index for items within a given radius.
   * @param {number} qx
   * @param {number} qy
   * @param {number} r Query radius.
   * @returns {number[]} An array of indices correponding to the found items.
   */
  within(t, n, r) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: o,
      coords: i,
      nodeSize: a
    } = this, s = [0, o.length - 1, 0], l = [], u = r * r; s.length; ) {
      var c = s.pop() || 0, p = s.pop() || 0, d = s.pop() || 0;
      if (p - d <= a) {
        for (var h = d; h <= p; h++)
          sD(i[2 * h], i[2 * h + 1], t, n) <= u && l.push(o[h]);
        continue;
      }
      var f = d + p >> 1, m = i[2 * f], g = i[2 * f + 1];
      sD(m, g, t, n) <= u && l.push(o[f]), (c === 0 ? t - r <= m : n - r <= g) && (s.push(d), s.push(f - 1), s.push(1 - c)), (c === 0 ? t + r >= m : n + r >= g) && (s.push(f + 1), s.push(p), s.push(1 - c));
    }
    return l;
  }
}
function YC(e, t, n, r, o, i) {
  if (!(o - r <= n)) {
    var a = r + o >> 1;
    nV(e, t, a, r, o, i), YC(e, t, n, r, a - 1, 1 - i), YC(e, t, n, a + 1, o, 1 - i);
  }
}
function nV(e, t, n, r, o, i) {
  for (; o > r; ) {
    if (o - r > 600) {
      var a = o - r + 1, s = n - r + 1, l = Math.log(a), u = 0.5 * Math.exp(2 * l / 3), c = 0.5 * Math.sqrt(l * u * (a - u) / a) * (s - a / 2 < 0 ? -1 : 1), p = Math.max(r, Math.floor(n - s * u / a + c)), d = Math.min(o, Math.floor(n + (a - s) * u / a + c));
      nV(e, t, n, p, d, i);
    }
    var h = t[2 * n + i], f = r, m = o;
    for (Vu(e, t, r, n), t[2 * o + i] > h && Vu(e, t, r, o); f < m; ) {
      for (Vu(e, t, f, m), f++, m--; t[2 * f + i] < h; ) f++;
      for (; t[2 * m + i] > h; ) m--;
    }
    t[2 * r + i] === h ? Vu(e, t, r, m) : (m++, Vu(e, t, m, o)), m <= n && (r = m + 1), n <= m && (o = m - 1);
  }
}
function Vu(e, t, n, r) {
  Ib(e, n, r), Ib(t, 2 * n, 2 * r), Ib(t, 2 * n + 1, 2 * r + 1);
}
function Ib(e, t, n) {
  var r = e[t];
  e[t] = e[n], e[n] = r;
}
function sD(e, t, n, r) {
  var o = e - n, i = t - r;
  return o * o + i * i;
}
var oae = {
  minZoom: 0,
  // min zoom to generate clusters on
  maxZoom: 16,
  // max zoom level to cluster the points on
  minPoints: 2,
  // minimum points to form a cluster
  radius: 40,
  // cluster radius in pixels
  extent: 512,
  // tile extent (radius is calculated relative to it)
  nodeSize: 64,
  // size of the KD-tree leaf node, affects performance
  log: !1,
  // whether to log timing info
  // whether to generate numeric ids for input features (in vector tiles)
  generateId: !1,
  // a reduce function for calculating custom cluster properties
  reduce: null,
  // (accumulated, props) => { accumulated.sum += props.sum; }
  // properties to use for individual points when running the reducer
  map: (e) => e
  // props => ({sum: props.my_value})
}, aD = Math.fround || /* @__PURE__ */ ((e) => (t) => (e[0] = +t, e[0]))(new Float32Array(1)), Ba = 2, Ys = 3, Rb = 4, Vs = 5, rV = 6;
class iae {
  constructor(t) {
    this.options = Object.assign(Object.create(oae), t), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
  }
  load(t) {
    var {
      log: n,
      minZoom: r,
      maxZoom: o
    } = this.options;
    n && console.time("total time");
    var i = "prepare ".concat(t.length, " points");
    n && console.time(i), this.points = t;
    for (var a = [], s = 0; s < t.length; s++) {
      var l = t[s];
      if (l.geometry) {
        var [u, c] = l.geometry.coordinates, p = aD(wf(u)), d = aD(Cf(c));
        a.push(
          p,
          d,
          // projected point coordinates
          1 / 0,
          // the last zoom the point was processed at
          s,
          // index of the source feature in the original input array
          -1,
          // parent cluster id
          1
          // number of points in a cluster
        ), this.options.reduce && a.push(0);
      }
    }
    var h = this.trees[o + 1] = this._createTree(a);
    n && console.timeEnd(i);
    for (var f = o; f >= r; f--) {
      var m = +Date.now();
      h = this.trees[f] = this._createTree(this._cluster(h, f)), n && console.log("z%d: %d clusters in %dms", f, h.numItems, +Date.now() - m);
    }
    return n && console.timeEnd("total time"), this;
  }
  getClusters(t, n) {
    var r = ((t[0] + 180) % 360 + 360) % 360 - 180, o = Math.max(-90, Math.min(90, t[1])), i = t[2] === 180 ? 180 : ((t[2] + 180) % 360 + 360) % 360 - 180, a = Math.max(-90, Math.min(90, t[3]));
    if (t[2] - t[0] >= 360)
      r = -180, i = 180;
    else if (r > i) {
      var s = this.getClusters([r, o, 180, a], n), l = this.getClusters([-180, o, i, a], n);
      return s.concat(l);
    }
    var u = this.trees[this._limitZoom(n)], c = u.range(wf(r), Cf(a), wf(i), Cf(o)), p = u.data, d = [];
    for (var h of c) {
      var f = this.stride * h;
      d.push(p[f + Vs] > 1 ? lD(p, f, this.clusterProps) : this.points[p[f + Ys]]);
    }
    return d;
  }
  getChildren(t) {
    var n = this._getOriginId(t), r = this._getOriginZoom(t), o = "No cluster with the specified id.", i = this.trees[r];
    if (!i) throw new Error(o);
    var a = i.data;
    if (n * this.stride >= a.length) throw new Error(o);
    var s = this.options.radius / (this.options.extent * Math.pow(2, r - 1)), l = a[n * this.stride], u = a[n * this.stride + 1], c = i.within(l, u, s), p = [];
    for (var d of c) {
      var h = d * this.stride;
      a[h + Rb] === t && p.push(a[h + Vs] > 1 ? lD(a, h, this.clusterProps) : this.points[a[h + Ys]]);
    }
    if (p.length === 0) throw new Error(o);
    return p;
  }
  getLeaves(t, n, r) {
    n = n || 10, r = r || 0;
    var o = [];
    return this._appendLeaves(o, t, n, r, 0), o;
  }
  getTile(t, n, r) {
    var o = this.trees[this._limitZoom(t)], i = Math.pow(2, t), {
      extent: a,
      radius: s
    } = this.options, l = s / a, u = (r - l) / i, c = (r + 1 + l) / i, p = {
      features: []
    };
    return this._addTileFeatures(o.range((n - l) / i, u, (n + 1 + l) / i, c), o.data, n, r, i, p), n === 0 && this._addTileFeatures(o.range(1 - l / i, u, 1, c), o.data, i, r, i, p), n === i - 1 && this._addTileFeatures(o.range(0, u, l / i, c), o.data, -1, r, i, p), p.features.length ? p : null;
  }
  getClusterExpansionZoom(t) {
    for (var n = this._getOriginZoom(t) - 1; n <= this.options.maxZoom; ) {
      var r = this.getChildren(t);
      if (n++, r.length !== 1) break;
      t = r[0].properties.cluster_id;
    }
    return n;
  }
  _appendLeaves(t, n, r, o, i) {
    var a = this.getChildren(n);
    for (var s of a) {
      var l = s.properties;
      if (l && l.cluster ? i + l.point_count <= o ? i += l.point_count : i = this._appendLeaves(t, l.cluster_id, r, o, i) : i < o ? i++ : t.push(s), t.length === r) break;
    }
    return i;
  }
  _createTree(t) {
    for (var n = new tk(t.length / this.stride | 0, this.options.nodeSize, Float32Array), r = 0; r < t.length; r += this.stride) n.add(t[r], t[r + 1]);
    return n.finish(), n.data = t, n;
  }
  _addTileFeatures(t, n, r, o, i, a) {
    for (var s of t) {
      var l = s * this.stride, u = n[l + Vs] > 1, c = void 0, p = void 0, d = void 0;
      if (u)
        c = oV(n, l, this.clusterProps), p = n[l], d = n[l + 1];
      else {
        var h = this.points[n[l + Ys]];
        c = h.properties;
        var [f, m] = h.geometry.coordinates;
        p = wf(f), d = Cf(m);
      }
      var g = {
        type: 1,
        geometry: [[Math.round(this.options.extent * (p * i - r)), Math.round(this.options.extent * (d * i - o))]],
        tags: c
      }, E = void 0;
      u || this.options.generateId ? E = n[l + Ys] : E = this.points[n[l + Ys]].id, E !== void 0 && (g.id = E), a.features.push(g);
    }
  }
  _limitZoom(t) {
    return Math.max(this.options.minZoom, Math.min(Math.floor(+t), this.options.maxZoom + 1));
  }
  _cluster(t, n) {
    for (var {
      radius: r,
      extent: o,
      reduce: i,
      minPoints: a
    } = this.options, s = r / (o * Math.pow(2, n)), l = t.data, u = [], c = this.stride, p = 0; p < l.length; p += c)
      if (!(l[p + Ba] <= n)) {
        l[p + Ba] = n;
        var d = l[p], h = l[p + 1], f = t.within(l[p], l[p + 1], s), m = l[p + Vs], g = m;
        for (var E of f) {
          var w = E * c;
          l[w + Ba] > n && (g += l[w + Vs]);
        }
        if (g > m && g >= a) {
          var M = d * m, x = h * m, y = void 0, C = -1, P = ((p / c | 0) << 5) + (n + 1) + this.points.length;
          for (var F of f) {
            var L = F * c;
            if (!(l[L + Ba] <= n)) {
              l[L + Ba] = n;
              var N = l[L + Vs];
              M += l[L] * N, x += l[L + 1] * N, l[L + Rb] = P, i && (y || (y = this._map(l, p, !0), C = this.clusterProps.length, this.clusterProps.push(y)), i(y, this._map(l, L)));
            }
          }
          l[p + Rb] = P, u.push(M / g, x / g, 1 / 0, P, -1, g), i && u.push(C);
        } else {
          for (var I = 0; I < c; I++) u.push(l[p + I]);
          if (g > 1)
            for (var H of f) {
              var V = H * c;
              if (!(l[V + Ba] <= n)) {
                l[V + Ba] = n;
                for (var z = 0; z < c; z++) u.push(l[V + z]);
              }
            }
        }
      }
    return u;
  }
  // get index of the point from which the cluster originated
  _getOriginId(t) {
    return t - this.points.length >> 5;
  }
  // get zoom of the point from which the cluster originated
  _getOriginZoom(t) {
    return (t - this.points.length) % 32;
  }
  _map(t, n, r) {
    if (t[n + Vs] > 1) {
      var o = this.clusterProps[t[n + rV]];
      return r ? Object.assign({}, o) : o;
    }
    var i = this.points[t[n + Ys]].properties, a = this.options.map(i);
    return r && a === i ? Object.assign({}, a) : a;
  }
}
function lD(e, t, n) {
  return {
    type: "Feature",
    id: e[t + Ys],
    properties: oV(e, t, n),
    geometry: {
      type: "Point",
      coordinates: [sae(e[t]), aae(e[t + 1])]
    }
  };
}
function oV(e, t, n) {
  var r = e[t + Vs], o = r >= 1e4 ? "".concat(Math.round(r / 1e3), "k") : r >= 1e3 ? "".concat(Math.round(r / 100) / 10, "k") : r, i = e[t + rV], a = i === -1 ? {} : Object.assign({}, n[i]);
  return Object.assign(a, {
    cluster: !0,
    cluster_id: e[t + Ys],
    point_count: r,
    point_count_abbreviated: o
  });
}
function wf(e) {
  return e / 360 + 0.5;
}
function Cf(e) {
  var t = Math.sin(e * Math.PI / 180), n = 0.5 - 0.25 * Math.log((1 + t) / (1 - t)) / Math.PI;
  return n < 0 ? 0 : n > 1 ? 1 : n;
}
function sae(e) {
  return (e - 0.5) * 360;
}
function aae(e) {
  var t = (180 - e * 360) * Math.PI / 180;
  return 360 * Math.atan(Math.exp(t)) / Math.PI - 90;
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function lae(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
    t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
  return n;
}
class Zo {
  static isAdvancedMarkerAvailable(t) {
    return google.maps.marker && t.getMapCapabilities().isAdvancedMarkersAvailable === !0;
  }
  static isAdvancedMarker(t) {
    return google.maps.marker && t instanceof google.maps.marker.AdvancedMarkerElement;
  }
  static setMap(t, n) {
    this.isAdvancedMarker(t) ? t.map = n : t.setMap(n);
  }
  static getPosition(t) {
    if (this.isAdvancedMarker(t)) {
      if (t.position) {
        if (t.position instanceof google.maps.LatLng)
          return t.position;
        if (t.position.lat && t.position.lng)
          return new google.maps.LatLng(t.position.lat, t.position.lng);
      }
      return new google.maps.LatLng(null);
    }
    return t.getPosition();
  }
  static getVisible(t) {
    return this.isAdvancedMarker(t) ? !0 : t.getVisible();
  }
}
class JC {
  constructor(t) {
    var {
      markers: n,
      position: r
    } = t;
    this.markers = n, r && (r instanceof google.maps.LatLng ? this._position = r : this._position = new google.maps.LatLng(r));
  }
  get bounds() {
    if (!(this.markers.length === 0 && !this._position)) {
      var t = new google.maps.LatLngBounds(this._position, this._position);
      for (var n of this.markers)
        t.extend(Zo.getPosition(n));
      return t;
    }
  }
  get position() {
    return this._position || this.bounds.getCenter();
  }
  /**
   * Get the count of **visible** markers.
   */
  get count() {
    return this.markers.filter((t) => Zo.getVisible(t)).length;
  }
  /**
   * Add a marker to the cluster.
   */
  push(t) {
    this.markers.push(t);
  }
  /**
   * Cleanup references and remove marker from map.
   */
  delete() {
    this.marker && (Zo.setMap(this.marker, null), this.marker = void 0), this.markers.length = 0;
  }
}
let uae = class {
  constructor(e) {
    var {
      maxZoom: t = 16
    } = e;
    this.maxZoom = t;
  }
  /**
   * Helper function to bypass clustering based upon some map state such as
   * zoom, number of markers, etc.
   *
   * ```typescript
   *  cluster({markers, map}: AlgorithmInput): Cluster[] {
   *    if (shouldBypassClustering(map)) {
   *      return this.noop({markers})
   *    }
   * }
   * ```
   */
  noop(e) {
    var {
      markers: t
    } = e;
    return cae(t);
  }
};
var cae = (e) => {
  var t = e.map((n) => new JC({
    position: Zo.getPosition(n),
    markers: [n]
  }));
  return t;
};
class pae extends uae {
  constructor(t) {
    var {
      maxZoom: n,
      radius: r = 60
    } = t, o = lae(t, ["maxZoom", "radius"]);
    super({
      maxZoom: n
    }), this.state = {
      zoom: -1
    }, this.superCluster = new iae(Object.assign({
      maxZoom: this.maxZoom,
      radius: r
    }, o));
  }
  calculate(t) {
    var n = !1, r = {
      zoom: t.map.getZoom()
    };
    if (!oD(t.markers, this.markers)) {
      n = !0, this.markers = [...t.markers];
      var o = this.markers.map((i) => {
        var a = Zo.getPosition(i), s = [a.lng(), a.lat()];
        return {
          type: "Feature",
          geometry: {
            type: "Point",
            coordinates: s
          },
          properties: {
            marker: i
          }
        };
      });
      this.superCluster.load(o);
    }
    return n || (this.state.zoom <= this.maxZoom || r.zoom <= this.maxZoom) && (n = !oD(this.state, r)), this.state = r, n && (this.clusters = this.cluster(t)), {
      clusters: this.clusters,
      changed: n
    };
  }
  cluster(t) {
    var {
      map: n
    } = t;
    return this.superCluster.getClusters([-180, -90, 180, 90], Math.round(n.getZoom())).map((r) => this.transformCluster(r));
  }
  transformCluster(t) {
    var {
      geometry: {
        coordinates: [n, r]
      },
      properties: o
    } = t;
    if (o.cluster)
      return new JC({
        markers: this.superCluster.getLeaves(o.cluster_id, 1 / 0).map((a) => a.properties.marker),
        position: {
          lat: r,
          lng: n
        }
      });
    var i = o.marker;
    return new JC({
      markers: [i],
      position: Zo.getPosition(i)
    });
  }
}
class dae {
  constructor(t, n) {
    this.markers = {
      sum: t.length
    };
    var r = n.map((i) => i.count), o = r.reduce((i, a) => i + a, 0);
    this.clusters = {
      count: n.length,
      markers: {
        mean: o / n.length,
        sum: o,
        min: Math.min(...r),
        max: Math.max(...r)
      }
    };
  }
}
class fae {
  /**
   * The default render function for the library used by {@link MarkerClusterer}.
   *
   * Currently set to use the following:
   *
   * ```typescript
   * // change color if this cluster has more markers than the mean cluster
   * const color =
   *   count > Math.max(10, stats.clusters.markers.mean)
   *     ? "#ff0000"
   *     : "#0000ff";
   *
   * // create svg url with fill color
   * const svg = window.btoa(`
   * <svg fill="${color}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240">
   *   <circle cx="120" cy="120" opacity=".6" r="70" />
   *   <circle cx="120" cy="120" opacity=".3" r="90" />
   *   <circle cx="120" cy="120" opacity=".2" r="110" />
   *   <circle cx="120" cy="120" opacity=".1" r="130" />
   * </svg>`);
   *
   * // create marker using svg icon
   * return new google.maps.Marker({
   *   position,
   *   icon: {
   *     url: `data:image/svg+xml;base64,${svg}`,
   *     scaledSize: new google.maps.Size(45, 45),
   *   },
   *   label: {
   *     text: String(count),
   *     color: "rgba(255,255,255,0.9)",
   *     fontSize: "12px",
   *   },
   *   // adjust zIndex to be above other markers
   *   zIndex: 1000 + count,
   * });
   * ```
   */
  render(t, n, r) {
    var {
      count: o,
      position: i
    } = t, a = o > Math.max(10, n.clusters.markers.mean) ? "#ff0000" : "#0000ff", s = '<svg fill="'.concat(a, `" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" width="50" height="50">
<circle cx="120" cy="120" opacity=".6" r="70" />
<circle cx="120" cy="120" opacity=".3" r="90" />
<circle cx="120" cy="120" opacity=".2" r="110" />
<text x="50%" y="50%" style="fill:#fff" text-anchor="middle" font-size="50" dominant-baseline="middle" font-family="roboto,arial,sans-serif">`).concat(o, `</text>
</svg>`), l = "Cluster of ".concat(o, " markers"), u = Number(google.maps.Marker.MAX_ZINDEX) + o;
    if (Zo.isAdvancedMarkerAvailable(r)) {
      var c = new DOMParser(), p = c.parseFromString(s, "image/svg+xml").documentElement;
      p.setAttribute("transform", "translate(0 25)");
      var d = {
        map: r,
        position: i,
        zIndex: u,
        title: l,
        content: p
      };
      return new google.maps.marker.AdvancedMarkerElement(d);
    }
    var h = {
      position: i,
      zIndex: u,
      title: l,
      icon: {
        url: "data:image/svg+xml;base64,".concat(btoa(s)),
        anchor: new google.maps.Point(25, 25)
      }
    };
    return new google.maps.Marker(h);
  }
}
function hae(e, t) {
  for (var n in t.prototype)
    e.prototype[n] = t.prototype[n];
}
class nk {
  constructor() {
    hae(nk, google.maps.OverlayView);
  }
}
var Ac;
(function(e) {
  e.CLUSTERING_BEGIN = "clusteringbegin", e.CLUSTERING_END = "clusteringend", e.CLUSTER_CLICK = "click";
})(Ac || (Ac = {}));
var gae = (e, t, n) => {
  n.fitBounds(t.bounds);
};
class mae extends nk {
  constructor(t) {
    var {
      map: n,
      markers: r = [],
      algorithmOptions: o = {},
      algorithm: i = new pae(o),
      renderer: a = new fae(),
      onClusterClick: s = gae
    } = t;
    super(), this.markers = [...r], this.clusters = [], this.algorithm = i, this.renderer = a, this.onClusterClick = s, n && this.setMap(n);
  }
  addMarker(t, n) {
    this.markers.includes(t) || (this.markers.push(t), n || this.render());
  }
  addMarkers(t, n) {
    t.forEach((r) => {
      this.addMarker(r, !0);
    }), n || this.render();
  }
  removeMarker(t, n) {
    var r = this.markers.indexOf(t);
    return r === -1 ? !1 : (Zo.setMap(t, null), this.markers.splice(r, 1), n || this.render(), !0);
  }
  removeMarkers(t, n) {
    var r = !1;
    return t.forEach((o) => {
      r = this.removeMarker(o, !0) || r;
    }), r && !n && this.render(), r;
  }
  clearMarkers(t) {
    this.markers.length = 0, t || this.render();
  }
  /**
   * Recalculates and draws all the marker clusters.
   */
  render() {
    var t = this.getMap();
    if (t instanceof google.maps.Map && t.getProjection()) {
      google.maps.event.trigger(this, Ac.CLUSTERING_BEGIN, this);
      var {
        clusters: n,
        changed: r
      } = this.algorithm.calculate({
        markers: this.markers,
        map: t,
        mapCanvasProjection: this.getProjection()
      });
      if (r || r == null) {
        var o = /* @__PURE__ */ new Set();
        for (var i of n)
          i.markers.length == 1 && o.add(i.markers[0]);
        var a = [];
        for (var s of this.clusters)
          s.marker != null && (s.markers.length == 1 ? o.has(s.marker) || Zo.setMap(s.marker, null) : a.push(s.marker));
        this.clusters = n, this.renderClusters(), requestAnimationFrame(() => a.forEach((l) => Zo.setMap(l, null)));
      }
      google.maps.event.trigger(this, Ac.CLUSTERING_END, this);
    }
  }
  onAdd() {
    this.idleListener = this.getMap().addListener("idle", this.render.bind(this)), this.render();
  }
  onRemove() {
    google.maps.event.removeListener(this.idleListener), this.reset();
  }
  reset() {
    this.markers.forEach((t) => Zo.setMap(t, null)), this.clusters.forEach((t) => t.delete()), this.clusters = [];
  }
  renderClusters() {
    var t = new dae(this.markers, this.clusters), n = this.getMap();
    this.clusters.forEach((r) => {
      r.markers.length === 1 ? r.marker = r.markers[0] : (r.marker = this.renderer.render(r, t, n), r.markers.forEach((o) => Zo.setMap(o, null)), this.onClusterClick && r.marker.addListener(
        "click",
        /* istanbul ignore next */
        (o) => {
          google.maps.event.trigger(this, Ac.CLUSTER_CLICK, r), this.onClusterClick(o, r, n);
        }
      )), Zo.setMap(r.marker, n);
    });
  }
}
function uD(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function cD(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? uD(Object(n), !0).forEach(function(r) {
      be(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : uD(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function vae(e) {
  var t = gse(), [n, r] = k(null);
  return v(() => {
    if (t && n === null) {
      var o = new mae(cD(cD({}, e), {}, {
        map: t
      }));
      r(o);
    }
  }, [t]), n;
}
function yae(e) {
  var {
    children: t,
    options: n
  } = e, r = vae(n);
  return r !== null ? t(r) : null;
}
Ee(yae);
var pD = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, dD = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
function bae(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, h = ye(Pt), [f, m] = k(null), [g, E] = k(null), [w, M] = k(null), [x, y] = k(null), [C, P] = k(null), [F, L] = k(null), N = rt(null);
  return v(() => {
    f !== null && (f.close(), n ? f.open(h, n) : f.getPosition() && f.open(h));
  }, [h, f, n]), v(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), v(() => {
    o && f !== null && f.setPosition(o);
  }, [o]), v(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), v(() => {
    f && a && (g !== null && google.maps.event.removeListener(g), E(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), v(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), M(google.maps.event.addListener(f, "domready", s)));
  }, [s]), v(() => {
    f && l && (x !== null && google.maps.event.removeListener(x), y(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), v(() => {
    f && u && (C !== null && google.maps.event.removeListener(C), P(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), v(() => {
    f && c && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), v(() => {
    var I = new google.maps.InfoWindow(r);
    return m(I), N.current = document.createElement("div"), a && E(google.maps.event.addListener(I, "closeclick", a)), s && M(google.maps.event.addListener(I, "domready", s)), l && y(google.maps.event.addListener(I, "content_changed", l)), u && P(google.maps.event.addListener(I, "position_changed", u)), c && L(google.maps.event.addListener(I, "zindex_changed", c)), I.setContent(N.current), o && I.setPosition(o), i && I.setZIndex(i), n ? I.open(h, n) : I.getPosition() ? I.open(h) : qr(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>."), p && p(I), () => {
      g && google.maps.event.removeListener(g), x && google.maps.event.removeListener(x), w && google.maps.event.removeListener(w), C && google.maps.event.removeListener(C), F && google.maps.event.removeListener(F), d && d(I), I.close();
    };
  }, []), N.current ? yr(at.only(t), N.current) : null;
}
Ee(bae);
class wae extends pe {
  constructor() {
    super(...arguments), be(this, "registeredEvents", []), be(this, "containerElement", null), be(this, "state", {
      infoWindow: null
    }), be(this, "open", (t, n) => {
      n ? t.open(this.context, n) : t.getPosition() ? t.open(this.context) : qr(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>.");
    }), be(this, "setInfoWindowCallback", () => {
      this.state.infoWindow !== null && this.containerElement !== null && (this.state.infoWindow.setContent(this.containerElement), this.open(this.state.infoWindow, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoWindow));
    });
  }
  componentDidMount() {
    var t = new google.maps.InfoWindow(this.props.options);
    this.containerElement = document.createElement("div"), this.registeredEvents = Jt({
      updaterMap: dD,
      eventMap: pD,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(() => ({
      infoWindow: t
    }), this.setInfoWindowCallback);
  }
  componentDidUpdate(t) {
    this.state.infoWindow !== null && (on(this.registeredEvents), this.registeredEvents = Jt({
      updaterMap: dD,
      eventMap: pD,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.infoWindow
    }));
  }
  componentWillUnmount() {
    this.state.infoWindow !== null && (on(this.registeredEvents), this.props.onUnmount && this.props.onUnmount(this.state.infoWindow), this.state.infoWindow.close());
  }
  render() {
    return this.containerElement ? yr(at.only(this.props.children), this.containerElement) : null;
  }
}
be(wae, "contextType", Pt);
function fD(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Og(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? fD(Object(n), !0).forEach(function(r) {
      be(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : fD(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var hD = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, gD = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, Cae = {};
function xae(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: h,
    onRightClick: f,
    onClick: m,
    onDrag: g,
    onLoad: E,
    onUnmount: w
  } = e, M = ye(Pt), [x, y] = k(null), [C, P] = k(null), [F, L] = k(null), [N, I] = k(null), [H, V] = k(null), [z, q] = k(null), [K, J] = k(null), [te, ee] = k(null), [_, D] = k(null), [$, S] = k(null), [W, O] = k(null), [T, U] = k(null);
  return v(() => {
    x !== null && x.setMap(M);
  }, [M]), v(() => {
    typeof t < "u" && x !== null && x.setOptions(t);
  }, [x, t]), v(() => {
    typeof n < "u" && x !== null && x.setDraggable(n);
  }, [x, n]), v(() => {
    typeof r < "u" && x !== null && x.setEditable(r);
  }, [x, r]), v(() => {
    typeof o < "u" && x !== null && x.setVisible(o);
  }, [x, o]), v(() => {
    typeof i < "u" && x !== null && x.setPath(i);
  }, [x, i]), v(() => {
    x && a && (C !== null && google.maps.event.removeListener(C), P(google.maps.event.addListener(x, "dblclick", a)));
  }, [a]), v(() => {
    x && s && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(x, "dragend", s)));
  }, [s]), v(() => {
    x && l && (N !== null && google.maps.event.removeListener(N), I(google.maps.event.addListener(x, "dragstart", l)));
  }, [l]), v(() => {
    x && u && (H !== null && google.maps.event.removeListener(H), V(google.maps.event.addListener(x, "mousedown", u)));
  }, [u]), v(() => {
    x && c && (z !== null && google.maps.event.removeListener(z), q(google.maps.event.addListener(x, "mousemove", c)));
  }, [c]), v(() => {
    x && p && (K !== null && google.maps.event.removeListener(K), J(google.maps.event.addListener(x, "mouseout", p)));
  }, [p]), v(() => {
    x && d && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(x, "mouseover", d)));
  }, [d]), v(() => {
    x && h && (_ !== null && google.maps.event.removeListener(_), D(google.maps.event.addListener(x, "mouseup", h)));
  }, [h]), v(() => {
    x && f && ($ !== null && google.maps.event.removeListener($), S(google.maps.event.addListener(x, "rightclick", f)));
  }, [f]), v(() => {
    x && m && (W !== null && google.maps.event.removeListener(W), O(google.maps.event.addListener(x, "click", m)));
  }, [m]), v(() => {
    x && g && (T !== null && google.maps.event.removeListener(T), U(google.maps.event.addListener(x, "drag", g)));
  }, [g]), v(() => {
    var j = new google.maps.Polyline(Og(Og({}, t || Cae), {}, {
      map: M
    }));
    return i && j.setPath(i), typeof o < "u" && j.setVisible(o), typeof r < "u" && j.setEditable(r), typeof n < "u" && j.setDraggable(n), a && P(google.maps.event.addListener(j, "dblclick", a)), s && L(google.maps.event.addListener(j, "dragend", s)), l && I(google.maps.event.addListener(j, "dragstart", l)), u && V(google.maps.event.addListener(j, "mousedown", u)), c && q(google.maps.event.addListener(j, "mousemove", c)), p && J(google.maps.event.addListener(j, "mouseout", p)), d && ee(google.maps.event.addListener(j, "mouseover", d)), h && D(google.maps.event.addListener(j, "mouseup", h)), f && S(google.maps.event.addListener(j, "rightclick", f)), m && O(google.maps.event.addListener(j, "click", m)), g && U(google.maps.event.addListener(j, "drag", g)), y(j), E && E(j), () => {
      C !== null && google.maps.event.removeListener(C), F !== null && google.maps.event.removeListener(F), N !== null && google.maps.event.removeListener(N), H !== null && google.maps.event.removeListener(H), z !== null && google.maps.event.removeListener(z), K !== null && google.maps.event.removeListener(K), te !== null && google.maps.event.removeListener(te), _ !== null && google.maps.event.removeListener(_), $ !== null && google.maps.event.removeListener($), W !== null && google.maps.event.removeListener(W), w && w(j), j.setMap(null);
    };
  }, []), null;
}
Ee(xae);
class Oae extends pe {
  constructor() {
    super(...arguments), be(this, "registeredEvents", []), be(this, "state", {
      polyline: null
    }), be(this, "setPolylineCallback", () => {
      this.state.polyline !== null && this.props.onLoad && this.props.onLoad(this.state.polyline);
    });
  }
  componentDidMount() {
    var t = new google.maps.Polyline(Og(Og({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Jt({
      updaterMap: gD,
      eventMap: hD,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        polyline: t
      };
    }, this.setPolylineCallback);
  }
  componentDidUpdate(t) {
    this.state.polyline !== null && (on(this.registeredEvents), this.registeredEvents = Jt({
      updaterMap: gD,
      eventMap: hD,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.polyline
    }));
  }
  componentWillUnmount() {
    this.state.polyline !== null && (this.props.onUnmount && this.props.onUnmount(this.state.polyline), on(this.registeredEvents), this.state.polyline.setMap(null));
  }
  render() {
    return null;
  }
}
be(Oae, "contextType", Pt);
function mD(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function vD(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? mD(Object(n), !0).forEach(function(r) {
      be(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : mD(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var yD = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, bD = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  paths(e, t) {
    e.setPaths(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function Eae(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    paths: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: h,
    onMouseUp: f,
    onRightClick: m,
    onClick: g,
    onDrag: E,
    onLoad: w,
    onUnmount: M,
    onEdit: x
  } = e, y = ye(Pt), [C, P] = k(null), [F, L] = k(null), [N, I] = k(null), [H, V] = k(null), [z, q] = k(null), [K, J] = k(null), [te, ee] = k(null), [_, D] = k(null), [$, S] = k(null), [W, O] = k(null), [T, U] = k(null), [j, Z] = k(null);
  return v(() => {
    C !== null && C.setMap(y);
  }, [y]), v(() => {
    typeof t < "u" && C !== null && C.setOptions(t);
  }, [C, t]), v(() => {
    typeof n < "u" && C !== null && C.setDraggable(n);
  }, [C, n]), v(() => {
    typeof r < "u" && C !== null && C.setEditable(r);
  }, [C, r]), v(() => {
    typeof o < "u" && C !== null && C.setVisible(o);
  }, [C, o]), v(() => {
    typeof i < "u" && C !== null && C.setPath(i);
  }, [C, i]), v(() => {
    typeof a < "u" && C !== null && C.setPaths(a);
  }, [C, a]), v(() => {
    C && typeof s == "function" && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(C, "dblclick", s)));
  }, [s]), v(() => {
    C && (google.maps.event.addListener(C.getPath(), "insert_at", () => {
      x == null || x(C);
    }), google.maps.event.addListener(C.getPath(), "set_at", () => {
      x == null || x(C);
    }), google.maps.event.addListener(C.getPath(), "remove_at", () => {
      x == null || x(C);
    }));
  }, [C, x]), v(() => {
    C && typeof l == "function" && (N !== null && google.maps.event.removeListener(N), I(google.maps.event.addListener(C, "dragend", l)));
  }, [l]), v(() => {
    C && typeof u == "function" && (H !== null && google.maps.event.removeListener(H), V(google.maps.event.addListener(C, "dragstart", u)));
  }, [u]), v(() => {
    C && typeof c == "function" && (z !== null && google.maps.event.removeListener(z), q(google.maps.event.addListener(C, "mousedown", c)));
  }, [c]), v(() => {
    C && typeof p == "function" && (K !== null && google.maps.event.removeListener(K), J(google.maps.event.addListener(C, "mousemove", p)));
  }, [p]), v(() => {
    C && typeof d == "function" && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(C, "mouseout", d)));
  }, [d]), v(() => {
    C && typeof h == "function" && (_ !== null && google.maps.event.removeListener(_), D(google.maps.event.addListener(C, "mouseover", h)));
  }, [h]), v(() => {
    C && typeof f == "function" && ($ !== null && google.maps.event.removeListener($), S(google.maps.event.addListener(C, "mouseup", f)));
  }, [f]), v(() => {
    C && typeof m == "function" && (W !== null && google.maps.event.removeListener(W), O(google.maps.event.addListener(C, "rightclick", m)));
  }, [m]), v(() => {
    C && typeof g == "function" && (T !== null && google.maps.event.removeListener(T), U(google.maps.event.addListener(C, "click", g)));
  }, [g]), v(() => {
    C && typeof E == "function" && (j !== null && google.maps.event.removeListener(j), Z(google.maps.event.addListener(C, "drag", E)));
  }, [E]), v(() => {
    var A = new google.maps.Polygon(vD(vD({}, t), {}, {
      map: y
    }));
    return i && A.setPath(i), a && A.setPaths(a), typeof o < "u" && A.setVisible(o), typeof r < "u" && A.setEditable(r), typeof n < "u" && A.setDraggable(n), s && L(google.maps.event.addListener(A, "dblclick", s)), l && I(google.maps.event.addListener(A, "dragend", l)), u && V(google.maps.event.addListener(A, "dragstart", u)), c && q(google.maps.event.addListener(A, "mousedown", c)), p && J(google.maps.event.addListener(A, "mousemove", p)), d && ee(google.maps.event.addListener(A, "mouseout", d)), h && D(google.maps.event.addListener(A, "mouseover", h)), f && S(google.maps.event.addListener(A, "mouseup", f)), m && O(google.maps.event.addListener(A, "rightclick", m)), g && U(google.maps.event.addListener(A, "click", g)), E && Z(google.maps.event.addListener(A, "drag", E)), P(A), w && w(A), () => {
      F !== null && google.maps.event.removeListener(F), N !== null && google.maps.event.removeListener(N), H !== null && google.maps.event.removeListener(H), z !== null && google.maps.event.removeListener(z), K !== null && google.maps.event.removeListener(K), te !== null && google.maps.event.removeListener(te), _ !== null && google.maps.event.removeListener(_), $ !== null && google.maps.event.removeListener($), W !== null && google.maps.event.removeListener(W), T !== null && google.maps.event.removeListener(T), M && M(A), A.setMap(null);
    };
  }, []), null;
}
Ee(Eae);
class kae extends pe {
  constructor() {
    super(...arguments), be(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this.props.options || {};
    this.polygon = new google.maps.Polygon(t), this.polygon.setMap(this.context), this.registeredEvents = Jt({
      updaterMap: bD,
      eventMap: yD,
      prevProps: {},
      nextProps: this.props,
      instance: this.polygon
    }), this.props.onLoad && this.props.onLoad(this.polygon);
  }
  componentDidUpdate(t) {
    this.polygon && (on(this.registeredEvents), this.registeredEvents = Jt({
      updaterMap: bD,
      eventMap: yD,
      prevProps: t,
      nextProps: this.props,
      instance: this.polygon
    }));
  }
  componentWillUnmount() {
    this.polygon && (this.props.onUnmount && this.props.onUnmount(this.polygon), on(this.registeredEvents), this.polygon && this.polygon.setMap(null));
  }
  render() {
    return null;
  }
}
be(kae, "contextType", Pt);
function wD(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Eg(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? wD(Object(n), !0).forEach(function(r) {
      be(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : wD(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var CD = {
  onBoundsChanged: "bounds_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, xD = {
  bounds(e, t) {
    e.setBounds(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function Lae(e) {
  var {
    options: t,
    bounds: n,
    draggable: r,
    editable: o,
    visible: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: h,
    onRightClick: f,
    onClick: m,
    onDrag: g,
    onBoundsChanged: E,
    onLoad: w,
    onUnmount: M
  } = e, x = ye(Pt), [y, C] = k(null), [P, F] = k(null), [L, N] = k(null), [I, H] = k(null), [V, z] = k(null), [q, K] = k(null), [J, te] = k(null), [ee, _] = k(null), [D, $] = k(null), [S, W] = k(null), [O, T] = k(null), [U, j] = k(null), [Z, A] = k(null);
  return v(() => {
    y !== null && y.setMap(x);
  }, [x]), v(() => {
    typeof t < "u" && y !== null && y.setOptions(t);
  }, [y, t]), v(() => {
    typeof r < "u" && y !== null && y.setDraggable(r);
  }, [y, r]), v(() => {
    typeof o < "u" && y !== null && y.setEditable(o);
  }, [y, o]), v(() => {
    typeof i < "u" && y !== null && y.setVisible(i);
  }, [y, i]), v(() => {
    typeof n < "u" && y !== null && y.setBounds(n);
  }, [y, n]), v(() => {
    y && a && (P !== null && google.maps.event.removeListener(P), F(google.maps.event.addListener(y, "dblclick", a)));
  }, [a]), v(() => {
    y && s && (L !== null && google.maps.event.removeListener(L), N(google.maps.event.addListener(y, "dragend", s)));
  }, [s]), v(() => {
    y && l && (I !== null && google.maps.event.removeListener(I), H(google.maps.event.addListener(y, "dragstart", l)));
  }, [l]), v(() => {
    y && u && (V !== null && google.maps.event.removeListener(V), z(google.maps.event.addListener(y, "mousedown", u)));
  }, [u]), v(() => {
    y && c && (q !== null && google.maps.event.removeListener(q), K(google.maps.event.addListener(y, "mousemove", c)));
  }, [c]), v(() => {
    y && p && (J !== null && google.maps.event.removeListener(J), te(google.maps.event.addListener(y, "mouseout", p)));
  }, [p]), v(() => {
    y && d && (ee !== null && google.maps.event.removeListener(ee), _(google.maps.event.addListener(y, "mouseover", d)));
  }, [d]), v(() => {
    y && h && (D !== null && google.maps.event.removeListener(D), $(google.maps.event.addListener(y, "mouseup", h)));
  }, [h]), v(() => {
    y && f && (S !== null && google.maps.event.removeListener(S), W(google.maps.event.addListener(y, "rightclick", f)));
  }, [f]), v(() => {
    y && m && (O !== null && google.maps.event.removeListener(O), T(google.maps.event.addListener(y, "click", m)));
  }, [m]), v(() => {
    y && g && (U !== null && google.maps.event.removeListener(U), j(google.maps.event.addListener(y, "drag", g)));
  }, [g]), v(() => {
    y && E && (Z !== null && google.maps.event.removeListener(Z), A(google.maps.event.addListener(y, "bounds_changed", E)));
  }, [E]), v(() => {
    var Q = new google.maps.Rectangle(Eg(Eg({}, t), {}, {
      map: x
    }));
    return typeof i < "u" && Q.setVisible(i), typeof o < "u" && Q.setEditable(o), typeof r < "u" && Q.setDraggable(r), typeof n < "u" && Q.setBounds(n), a && F(google.maps.event.addListener(Q, "dblclick", a)), s && N(google.maps.event.addListener(Q, "dragend", s)), l && H(google.maps.event.addListener(Q, "dragstart", l)), u && z(google.maps.event.addListener(Q, "mousedown", u)), c && K(google.maps.event.addListener(Q, "mousemove", c)), p && te(google.maps.event.addListener(Q, "mouseout", p)), d && _(google.maps.event.addListener(Q, "mouseover", d)), h && $(google.maps.event.addListener(Q, "mouseup", h)), f && W(google.maps.event.addListener(Q, "rightclick", f)), m && T(google.maps.event.addListener(Q, "click", m)), g && j(google.maps.event.addListener(Q, "drag", g)), E && A(google.maps.event.addListener(Q, "bounds_changed", E)), C(Q), w && w(Q), () => {
      P !== null && google.maps.event.removeListener(P), L !== null && google.maps.event.removeListener(L), I !== null && google.maps.event.removeListener(I), V !== null && google.maps.event.removeListener(V), q !== null && google.maps.event.removeListener(q), J !== null && google.maps.event.removeListener(J), ee !== null && google.maps.event.removeListener(ee), D !== null && google.maps.event.removeListener(D), S !== null && google.maps.event.removeListener(S), O !== null && google.maps.event.removeListener(O), U !== null && google.maps.event.removeListener(U), Z !== null && google.maps.event.removeListener(Z), M && M(Q), Q.setMap(null);
    };
  }, []), null;
}
Ee(Lae);
class _ae extends pe {
  constructor() {
    super(...arguments), be(this, "registeredEvents", []), be(this, "state", {
      rectangle: null
    }), be(this, "setRectangleCallback", () => {
      this.state.rectangle !== null && this.props.onLoad && this.props.onLoad(this.state.rectangle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Rectangle(Eg(Eg({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Jt({
      updaterMap: xD,
      eventMap: CD,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        rectangle: t
      };
    }, this.setRectangleCallback);
  }
  componentDidUpdate(t) {
    this.state.rectangle !== null && (on(this.registeredEvents), this.registeredEvents = Jt({
      updaterMap: xD,
      eventMap: CD,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.rectangle
    }));
  }
  componentWillUnmount() {
    this.state.rectangle !== null && (this.props.onUnmount && this.props.onUnmount(this.state.rectangle), on(this.registeredEvents), this.state.rectangle.setMap(null));
  }
  render() {
    return null;
  }
}
be(_ae, "contextType", Pt);
function OD(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function kg(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? OD(Object(n), !0).forEach(function(r) {
      be(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : OD(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var ED = {
  onCenterChanged: "center_changed",
  onRadiusChanged: "radius_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, kD = {
  center(e, t) {
    e.setCenter(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  radius(e, t) {
    e.setRadius(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, Pae = {};
function Sae(e) {
  var {
    options: t,
    center: n,
    radius: r,
    draggable: o,
    editable: i,
    visible: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: h,
    onMouseUp: f,
    onRightClick: m,
    onClick: g,
    onDrag: E,
    onCenterChanged: w,
    onRadiusChanged: M,
    onLoad: x,
    onUnmount: y
  } = e, C = ye(Pt), [P, F] = k(null), [L, N] = k(null), [I, H] = k(null), [V, z] = k(null), [q, K] = k(null), [J, te] = k(null), [ee, _] = k(null), [D, $] = k(null), [S, W] = k(null), [O, T] = k(null), [U, j] = k(null), [Z, A] = k(null), [Q, R] = k(null), [ue, fe] = k(null);
  return v(() => {
    P !== null && P.setMap(C);
  }, [C]), v(() => {
    typeof t < "u" && P !== null && P.setOptions(t);
  }, [P, t]), v(() => {
    typeof o < "u" && P !== null && P.setDraggable(o);
  }, [P, o]), v(() => {
    typeof i < "u" && P !== null && P.setEditable(i);
  }, [P, i]), v(() => {
    typeof a < "u" && P !== null && P.setVisible(a);
  }, [P, a]), v(() => {
    typeof r == "number" && P !== null && P.setRadius(r);
  }, [P, r]), v(() => {
    typeof n < "u" && P !== null && P.setCenter(n);
  }, [P, n]), v(() => {
    P && s && (L !== null && google.maps.event.removeListener(L), N(google.maps.event.addListener(P, "dblclick", s)));
  }, [s]), v(() => {
    P && l && (I !== null && google.maps.event.removeListener(I), H(google.maps.event.addListener(P, "dragend", l)));
  }, [l]), v(() => {
    P && u && (V !== null && google.maps.event.removeListener(V), z(google.maps.event.addListener(P, "dragstart", u)));
  }, [u]), v(() => {
    P && c && (q !== null && google.maps.event.removeListener(q), K(google.maps.event.addListener(P, "mousedown", c)));
  }, [c]), v(() => {
    P && p && (J !== null && google.maps.event.removeListener(J), te(google.maps.event.addListener(P, "mousemove", p)));
  }, [p]), v(() => {
    P && d && (ee !== null && google.maps.event.removeListener(ee), _(google.maps.event.addListener(P, "mouseout", d)));
  }, [d]), v(() => {
    P && h && (D !== null && google.maps.event.removeListener(D), $(google.maps.event.addListener(P, "mouseover", h)));
  }, [h]), v(() => {
    P && f && (S !== null && google.maps.event.removeListener(S), W(google.maps.event.addListener(P, "mouseup", f)));
  }, [f]), v(() => {
    P && m && (O !== null && google.maps.event.removeListener(O), T(google.maps.event.addListener(P, "rightclick", m)));
  }, [m]), v(() => {
    P && g && (U !== null && google.maps.event.removeListener(U), j(google.maps.event.addListener(P, "click", g)));
  }, [g]), v(() => {
    P && E && (Z !== null && google.maps.event.removeListener(Z), A(google.maps.event.addListener(P, "drag", E)));
  }, [E]), v(() => {
    P && w && (Q !== null && google.maps.event.removeListener(Q), R(google.maps.event.addListener(P, "center_changed", w)));
  }, [g]), v(() => {
    P && M && (ue !== null && google.maps.event.removeListener(ue), fe(google.maps.event.addListener(P, "radius_changed", M)));
  }, [M]), v(() => {
    var oe = new google.maps.Circle(kg(kg({}, t || Pae), {}, {
      map: C
    }));
    return typeof r == "number" && oe.setRadius(r), typeof n < "u" && oe.setCenter(n), typeof r == "number" && oe.setRadius(r), typeof a < "u" && oe.setVisible(a), typeof i < "u" && oe.setEditable(i), typeof o < "u" && oe.setDraggable(o), s && N(google.maps.event.addListener(oe, "dblclick", s)), l && H(google.maps.event.addListener(oe, "dragend", l)), u && z(google.maps.event.addListener(oe, "dragstart", u)), c && K(google.maps.event.addListener(oe, "mousedown", c)), p && te(google.maps.event.addListener(oe, "mousemove", p)), d && _(google.maps.event.addListener(oe, "mouseout", d)), h && $(google.maps.event.addListener(oe, "mouseover", h)), f && W(google.maps.event.addListener(oe, "mouseup", f)), m && T(google.maps.event.addListener(oe, "rightclick", m)), g && j(google.maps.event.addListener(oe, "click", g)), E && A(google.maps.event.addListener(oe, "drag", E)), w && R(google.maps.event.addListener(oe, "center_changed", w)), M && fe(google.maps.event.addListener(oe, "radius_changed", M)), F(oe), x && x(oe), () => {
      L !== null && google.maps.event.removeListener(L), I !== null && google.maps.event.removeListener(I), V !== null && google.maps.event.removeListener(V), q !== null && google.maps.event.removeListener(q), J !== null && google.maps.event.removeListener(J), ee !== null && google.maps.event.removeListener(ee), D !== null && google.maps.event.removeListener(D), S !== null && google.maps.event.removeListener(S), O !== null && google.maps.event.removeListener(O), U !== null && google.maps.event.removeListener(U), Q !== null && google.maps.event.removeListener(Q), ue !== null && google.maps.event.removeListener(ue), y && y(oe), oe.setMap(null);
    };
  }, []), null;
}
Ee(Sae);
class Mae extends pe {
  constructor() {
    super(...arguments), be(this, "registeredEvents", []), be(this, "state", {
      circle: null
    }), be(this, "setCircleCallback", () => {
      this.state.circle !== null && this.props.onLoad && this.props.onLoad(this.state.circle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Circle(kg(kg({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Jt({
      updaterMap: kD,
      eventMap: ED,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        circle: t
      };
    }, this.setCircleCallback);
  }
  componentDidUpdate(t) {
    this.state.circle !== null && (on(this.registeredEvents), this.registeredEvents = Jt({
      updaterMap: kD,
      eventMap: ED,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.circle
    }));
  }
  componentWillUnmount() {
    if (this.state.circle !== null) {
      var t;
      this.props.onUnmount && this.props.onUnmount(this.state.circle), on(this.registeredEvents), (t = this.state.circle) === null || t === void 0 || t.setMap(null);
    }
  }
  render() {
    return null;
  }
}
be(Mae, "contextType", Pt);
function LD(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Lg(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? LD(Object(n), !0).forEach(function(r) {
      be(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : LD(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var _D = {
  onClick: "click",
  onDblClick: "dblclick",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onAddFeature: "addfeature",
  onRemoveFeature: "removefeature",
  onRemoveProperty: "removeproperty",
  onSetGeometry: "setgeometry",
  onSetProperty: "setproperty"
}, PD = {
  add(e, t) {
    e.add(t);
  },
  addgeojson(e, t, n) {
    e.addGeoJson(t, n);
  },
  contains(e, t) {
    e.contains(t);
  },
  foreach(e, t) {
    e.forEach(t);
  },
  loadgeojson(e, t, n, r) {
    e.loadGeoJson(t, n, r);
  },
  overridestyle(e, t, n) {
    e.overrideStyle(t, n);
  },
  remove(e, t) {
    e.remove(t);
  },
  revertstyle(e, t) {
    e.revertStyle(t);
  },
  controlposition(e, t) {
    e.setControlPosition(t);
  },
  controls(e, t) {
    e.setControls(t);
  },
  drawingmode(e, t) {
    e.setDrawingMode(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  style(e, t) {
    e.setStyle(t);
  },
  togeojson(e, t) {
    e.toGeoJson(t);
  }
};
function Dae(e) {
  var {
    options: t,
    onClick: n,
    onDblClick: r,
    onMouseDown: o,
    onMouseMove: i,
    onMouseOut: a,
    onMouseOver: s,
    onMouseUp: l,
    onRightClick: u,
    onAddFeature: c,
    onRemoveFeature: p,
    onRemoveProperty: d,
    onSetGeometry: h,
    onSetProperty: f,
    onLoad: m,
    onUnmount: g
  } = e, E = ye(Pt), [w, M] = k(null), [x, y] = k(null), [C, P] = k(null), [F, L] = k(null), [N, I] = k(null), [H, V] = k(null), [z, q] = k(null), [K, J] = k(null), [te, ee] = k(null), [_, D] = k(null), [$, S] = k(null), [W, O] = k(null), [T, U] = k(null), [j, Z] = k(null);
  return v(() => {
    w !== null && w.setMap(E);
  }, [E]), v(() => {
    w && r && (x !== null && google.maps.event.removeListener(x), y(google.maps.event.addListener(w, "dblclick", r)));
  }, [r]), v(() => {
    w && o && (C !== null && google.maps.event.removeListener(C), P(google.maps.event.addListener(w, "mousedown", o)));
  }, [o]), v(() => {
    w && i && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(w, "mousemove", i)));
  }, [i]), v(() => {
    w && a && (N !== null && google.maps.event.removeListener(N), I(google.maps.event.addListener(w, "mouseout", a)));
  }, [a]), v(() => {
    w && s && (H !== null && google.maps.event.removeListener(H), V(google.maps.event.addListener(w, "mouseover", s)));
  }, [s]), v(() => {
    w && l && (z !== null && google.maps.event.removeListener(z), q(google.maps.event.addListener(w, "mouseup", l)));
  }, [l]), v(() => {
    w && u && (K !== null && google.maps.event.removeListener(K), J(google.maps.event.addListener(w, "rightclick", u)));
  }, [u]), v(() => {
    w && n && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(w, "click", n)));
  }, [n]), v(() => {
    w && c && (_ !== null && google.maps.event.removeListener(_), D(google.maps.event.addListener(w, "addfeature", c)));
  }, [c]), v(() => {
    w && p && ($ !== null && google.maps.event.removeListener($), S(google.maps.event.addListener(w, "removefeature", p)));
  }, [p]), v(() => {
    w && d && (W !== null && google.maps.event.removeListener(W), O(google.maps.event.addListener(w, "removeproperty", d)));
  }, [d]), v(() => {
    w && h && (T !== null && google.maps.event.removeListener(T), U(google.maps.event.addListener(w, "setgeometry", h)));
  }, [h]), v(() => {
    w && f && (j !== null && google.maps.event.removeListener(j), Z(google.maps.event.addListener(w, "setproperty", f)));
  }, [f]), v(() => {
    if (E !== null) {
      var A = new google.maps.Data(Lg(Lg({}, t), {}, {
        map: E
      }));
      r && y(google.maps.event.addListener(A, "dblclick", r)), o && P(google.maps.event.addListener(A, "mousedown", o)), i && L(google.maps.event.addListener(A, "mousemove", i)), a && I(google.maps.event.addListener(A, "mouseout", a)), s && V(google.maps.event.addListener(A, "mouseover", s)), l && q(google.maps.event.addListener(A, "mouseup", l)), u && J(google.maps.event.addListener(A, "rightclick", u)), n && ee(google.maps.event.addListener(A, "click", n)), c && D(google.maps.event.addListener(A, "addfeature", c)), p && S(google.maps.event.addListener(A, "removefeature", p)), d && O(google.maps.event.addListener(A, "removeproperty", d)), h && U(google.maps.event.addListener(A, "setgeometry", h)), f && Z(google.maps.event.addListener(A, "setproperty", f)), M(A), m && m(A);
    }
    return () => {
      w && (x !== null && google.maps.event.removeListener(x), C !== null && google.maps.event.removeListener(C), F !== null && google.maps.event.removeListener(F), N !== null && google.maps.event.removeListener(N), H !== null && google.maps.event.removeListener(H), z !== null && google.maps.event.removeListener(z), K !== null && google.maps.event.removeListener(K), te !== null && google.maps.event.removeListener(te), _ !== null && google.maps.event.removeListener(_), $ !== null && google.maps.event.removeListener($), W !== null && google.maps.event.removeListener(W), T !== null && google.maps.event.removeListener(T), j !== null && google.maps.event.removeListener(j), g && g(w), w.setMap(null));
    };
  }, []), null;
}
Ee(Dae);
class Tae extends pe {
  constructor() {
    super(...arguments), be(this, "registeredEvents", []), be(this, "state", {
      data: null
    }), be(this, "setDataCallback", () => {
      this.state.data !== null && this.props.onLoad && this.props.onLoad(this.state.data);
    });
  }
  componentDidMount() {
    if (this.context !== null) {
      var t = new google.maps.Data(Lg(Lg({}, this.props.options), {}, {
        map: this.context
      }));
      this.registeredEvents = Jt({
        updaterMap: PD,
        eventMap: _D,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        data: t
      }), this.setDataCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.data !== null && (on(this.registeredEvents), this.registeredEvents = Jt({
      updaterMap: PD,
      eventMap: _D,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.data
    }));
  }
  componentWillUnmount() {
    this.state.data !== null && (this.props.onUnmount && this.props.onUnmount(this.state.data), on(this.registeredEvents), this.state.data && this.state.data.setMap(null));
  }
  render() {
    return null;
  }
}
be(Tae, "contextType", Pt);
function SD(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function MD(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? SD(Object(n), !0).forEach(function(r) {
      be(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : SD(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var DD = {
  onClick: "click",
  onDefaultViewportChanged: "defaultviewport_changed",
  onStatusChanged: "status_changed"
}, TD = {
  options(e, t) {
    e.setOptions(t);
  },
  url(e, t) {
    e.setUrl(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
class jae extends pe {
  constructor() {
    super(...arguments), be(this, "registeredEvents", []), be(this, "state", {
      kmlLayer: null
    }), be(this, "setKmlLayerCallback", () => {
      this.state.kmlLayer !== null && this.props.onLoad && this.props.onLoad(this.state.kmlLayer);
    });
  }
  componentDidMount() {
    var t = new google.maps.KmlLayer(MD(MD({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Jt({
      updaterMap: TD,
      eventMap: DD,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        kmlLayer: t
      };
    }, this.setKmlLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.kmlLayer !== null && (on(this.registeredEvents), this.registeredEvents = Jt({
      updaterMap: TD,
      eventMap: DD,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.kmlLayer
    }));
  }
  componentWillUnmount() {
    this.state.kmlLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.kmlLayer), on(this.registeredEvents), this.state.kmlLayer.setMap(null));
  }
  render() {
    return null;
  }
}
be(jae, "contextType", Pt);
function iV(e, t) {
  return typeof t == "function" ? t(e.offsetWidth, e.offsetHeight) : {
    x: 0,
    y: 0
  };
}
function Aae(e, t) {
  return new t(e.lat, e.lng);
}
function Bae(e, t) {
  return new t(new google.maps.LatLng(e.ne.lat, e.ne.lng), new google.maps.LatLng(e.sw.lat, e.sw.lng));
}
function Iae(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function Rae(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function Nae(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n.getNorthEast()), o = e && e.fromLatLngToDivPixel(n.getSouthWest());
  return r && o ? {
    left: "".concat(o.x + t.x, "px"),
    top: "".concat(r.y + t.y, "px"),
    width: "".concat(r.x - o.x - t.x, "px"),
    height: "".concat(o.y - r.y - t.y, "px")
  } : {
    left: "-9999px",
    top: "-9999px"
  };
}
function Fae(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n);
  if (r) {
    var {
      x: o,
      y: i
    } = r;
    return {
      left: "".concat(o + t.x, "px"),
      top: "".concat(i + t.y, "px")
    };
  }
  return {
    left: "-9999px",
    top: "-9999px"
  };
}
function sV(e, t, n, r) {
  return n !== void 0 ? Nae(e, t, Rae(n, google.maps.LatLngBounds, Bae)) : Fae(e, t, Iae(r, google.maps.LatLng, Aae));
}
function zae(e, t) {
  return e.left === t.left && e.top === t.top && e.width === t.height && e.height === t.height;
}
function jD(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Uae(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? jD(Object(n), !0).forEach(function(r) {
      be(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : jD(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function $ae(e, t, n, r, o) {
  class i extends google.maps.OverlayView {
    constructor(s, l, u, c) {
      super(), this.container = s, this.pane = l, this.position = u, this.bounds = c;
    }
    onAdd() {
      var s, l = (s = this.getPanes()) === null || s === void 0 ? void 0 : s[this.pane];
      l == null || l.appendChild(this.container);
    }
    draw() {
      var s = this.getProjection(), l = Uae({}, this.container ? iV(this.container, o) : {
        x: 0,
        y: 0
      }), u = sV(s, l, this.bounds, this.position);
      for (var [c, p] of Object.entries(u))
        this.container.style[c] = p;
    }
    onRemove() {
      this.container.parentNode !== null && this.container.parentNode.removeChild(this.container);
    }
  }
  return new i(e, t, n, r);
}
function AD(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Hae(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? AD(Object(n), !0).forEach(function(r) {
      be(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : AD(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function BD(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLng ? e : new google.maps.LatLng(e.lat, e.lng);
  return t + "";
}
function ID(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLngBounds ? e : new google.maps.LatLngBounds(new google.maps.LatLng(e.south, e.east), new google.maps.LatLng(e.north, e.west));
  return t + "";
}
function Wae(e) {
  var {
    position: t,
    bounds: n,
    mapPaneName: r,
    zIndex: o,
    onLoad: i,
    onUnmount: a,
    getPixelPositionOffset: s,
    children: l
  } = e, u = ye(Pt), c = Tn(() => {
    var d = document.createElement("div");
    return d.style.position = "absolute", d;
  }, []), p = Tn(() => $ae(c, r, t, n, s), [c, r, t, n]);
  return v(() => (i == null || i(p), p == null || p.setMap(u), () => {
    a == null || a(p), p == null || p.setMap(null);
  }), [u, p]), v(() => {
    c.style.zIndex = "".concat(o);
  }, [o, c]), Ci.createPortal(l, c);
}
Ee(Wae);
class bu extends pe {
  constructor(t) {
    super(t), be(this, "state", {
      paneEl: null,
      containerStyle: {
        // set initial position
        position: "absolute"
      }
    }), be(this, "updatePane", () => {
      var r = this.props.mapPaneName, o = this.overlayView.getPanes();
      qr(!!r, "OverlayView requires props.mapPaneName but got %s", r), o ? this.setState({
        paneEl: o[r]
      }) : this.setState({
        paneEl: null
      });
    }), be(this, "onAdd", () => {
      var r, o;
      this.updatePane(), (r = (o = this.props).onLoad) === null || r === void 0 || r.call(o, this.overlayView);
    }), be(this, "onPositionElement", () => {
      var r = this.overlayView.getProjection(), o = Hae({
        x: 0,
        y: 0
      }, this.containerRef.current ? iV(this.containerRef.current, this.props.getPixelPositionOffset) : {}), i = sV(r, o, this.props.bounds, this.props.position);
      if (!zae(i, {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        left: this.state.containerStyle.left,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        top: this.state.containerStyle.top,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        width: this.state.containerStyle.width,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        height: this.state.containerStyle.height
      })) {
        var a, s, l, u;
        this.setState({
          containerStyle: {
            top: (a = i.top) !== null && a !== void 0 ? a : 0,
            left: (s = i.left) !== null && s !== void 0 ? s : 0,
            width: (l = i.width) !== null && l !== void 0 ? l : 0,
            height: (u = i.height) !== null && u !== void 0 ? u : 0,
            position: "absolute"
          }
        });
      }
    }), be(this, "draw", () => {
      this.onPositionElement();
    }), be(this, "onRemove", () => {
      var r, o;
      this.setState(() => ({
        paneEl: null
      })), (r = (o = this.props).onUnmount) === null || r === void 0 || r.call(o, this.overlayView);
    }), this.containerRef = Qr();
    var n = new google.maps.OverlayView();
    n.onAdd = this.onAdd, n.draw = this.draw, n.onRemove = this.onRemove, this.overlayView = n;
  }
  componentDidMount() {
    this.overlayView.setMap(this.context);
  }
  componentDidUpdate(t) {
    var n = BD(t.position), r = BD(this.props.position), o = ID(t.bounds), i = ID(this.props.bounds);
    (n !== r || o !== i) && this.overlayView.draw(), t.mapPaneName !== this.props.mapPaneName && this.updatePane();
  }
  componentWillUnmount() {
    this.overlayView.setMap(null);
  }
  render() {
    var t = this.state.paneEl;
    return t ? Ci.createPortal(io.jsx("div", {
      ref: this.containerRef,
      style: this.state.containerStyle,
      children: at.only(this.props.children)
    }), t) : null;
  }
}
be(bu, "FLOAT_PANE", "floatPane");
be(bu, "MAP_PANE", "mapPane");
be(bu, "MARKER_LAYER", "markerLayer");
be(bu, "OVERLAY_LAYER", "overlayLayer");
be(bu, "OVERLAY_MOUSE_TARGET", "overlayMouseTarget");
be(bu, "contextType", Pt);
function Vae() {
}
function RD(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ND(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? RD(Object(n), !0).forEach(function(r) {
      be(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : RD(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var FD = {
  onDblClick: "dblclick",
  onClick: "click"
}, zD = {
  opacity(e, t) {
    e.setOpacity(t);
  }
};
function qae(e) {
  var {
    url: t,
    bounds: n,
    options: r,
    visible: o
  } = e, i = ye(Pt), a = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east)), s = Tn(() => new google.maps.GroundOverlay(t, a, r), []);
  return v(() => {
    s !== null && s.setMap(i);
  }, [i]), v(() => {
    typeof t < "u" && s !== null && (s.set("url", t), s.setMap(i));
  }, [s, t]), v(() => {
    typeof o < "u" && s !== null && s.setOpacity(o ? 1 : 0);
  }, [s, o]), v(() => {
    var l = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east));
    typeof n < "u" && s !== null && (s.set("bounds", l), s.setMap(i));
  }, [s, n]), null;
}
Ee(qae);
class aV extends pe {
  constructor() {
    super(...arguments), be(this, "registeredEvents", []), be(this, "state", {
      groundOverlay: null
    }), be(this, "setGroundOverlayCallback", () => {
      this.state.groundOverlay !== null && this.props.onLoad && this.props.onLoad(this.state.groundOverlay);
    });
  }
  componentDidMount() {
    qr(!!this.props.url || !!this.props.bounds, "For GroundOverlay, url and bounds are passed in to constructor and are immutable after instantiated. This is the behavior of Google Maps JavaScript API v3 ( See https://developers.google.com/maps/documentation/javascript/reference#GroundOverlay) Hence, use the corresponding two props provided by `react-google-maps-api`, url and bounds. In some cases, you'll need the GroundOverlay component to reflect the changes of url and bounds. You can leverage the React's key property to remount the component. Typically, just `key={url}` would serve your need. See https://github.com/tomchentw/react-google-maps/issues/655");
    var t = new google.maps.GroundOverlay(this.props.url, this.props.bounds, ND(ND({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Jt({
      updaterMap: zD,
      eventMap: FD,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        groundOverlay: t
      };
    }, this.setGroundOverlayCallback);
  }
  componentDidUpdate(t) {
    this.state.groundOverlay !== null && (on(this.registeredEvents), this.registeredEvents = Jt({
      updaterMap: zD,
      eventMap: FD,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.groundOverlay
    }));
  }
  componentWillUnmount() {
    this.state.groundOverlay && (this.props.onUnmount && this.props.onUnmount(this.state.groundOverlay), this.state.groundOverlay.setMap(null));
  }
  render() {
    return null;
  }
}
be(aV, "defaultProps", {
  onLoad: Vae
});
be(aV, "contextType", Pt);
function UD(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function _g(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? UD(Object(n), !0).forEach(function(r) {
      be(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : UD(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var $D = {}, HD = {
  data(e, t) {
    e.setData(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function Zae(e) {
  var {
    data: t,
    onLoad: n,
    onUnmount: r,
    options: o
  } = e, i = ye(Pt), [a, s] = k(null);
  return v(() => {
    google.maps.visualization || qr(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} in useJsApiScript? %s', google.maps.visualization);
  }, []), v(() => {
    qr(!!t, "data property is required in HeatmapLayer %s", t);
  }, [t]), v(() => {
    a !== null && a.setMap(i);
  }, [i]), v(() => {
    o && a !== null && a.setOptions(o);
  }, [a, o]), v(() => {
    var l = new google.maps.visualization.HeatmapLayer(_g(_g({}, o), {}, {
      data: t,
      map: i
    }));
    return s(l), n && n(l), () => {
      a !== null && (r && r(a), a.setMap(null));
    };
  }, []), null;
}
Ee(Zae);
class Gae extends pe {
  constructor() {
    super(...arguments), be(this, "registeredEvents", []), be(this, "state", {
      heatmapLayer: null
    }), be(this, "setHeatmapLayerCallback", () => {
      this.state.heatmapLayer !== null && this.props.onLoad && this.props.onLoad(this.state.heatmapLayer);
    });
  }
  componentDidMount() {
    qr(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} to <LoadScript />? %s', google.maps.visualization), qr(!!this.props.data, "data property is required in HeatmapLayer %s", this.props.data);
    var t = new google.maps.visualization.HeatmapLayer(_g(_g({}, this.props.options), {}, {
      data: this.props.data,
      map: this.context
    }));
    this.registeredEvents = Jt({
      updaterMap: HD,
      eventMap: $D,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        heatmapLayer: t
      };
    }, this.setHeatmapLayerCallback);
  }
  componentDidUpdate(t) {
    on(this.registeredEvents), this.registeredEvents = Jt({
      updaterMap: HD,
      eventMap: $D,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.heatmapLayer
    });
  }
  componentWillUnmount() {
    this.state.heatmapLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.heatmapLayer), on(this.registeredEvents), this.state.heatmapLayer.setMap(null));
  }
  render() {
    return null;
  }
}
be(Gae, "contextType", Pt);
var WD = {
  onCloseClick: "closeclick",
  onPanoChanged: "pano_changed",
  onPositionChanged: "position_changed",
  onPovChanged: "pov_changed",
  onResize: "resize",
  onStatusChanged: "status_changed",
  onVisibleChanged: "visible_changed",
  onZoomChanged: "zoom_changed"
}, VD = {
  register(e, t, n) {
    e.registerPanoProvider(t, n);
  },
  links(e, t) {
    e.setLinks(t);
  },
  motionTracking(e, t) {
    e.setMotionTracking(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  pano(e, t) {
    e.setPano(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  pov(e, t) {
    e.setPov(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zoom(e, t) {
    e.setZoom(t);
  }
};
class Xae extends pe {
  constructor() {
    super(...arguments), be(this, "registeredEvents", []), be(this, "state", {
      streetViewPanorama: null
    }), be(this, "setStreetViewPanoramaCallback", () => {
      this.state.streetViewPanorama !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewPanorama);
    });
  }
  componentDidMount() {
    var t, n, r = (t = (n = this.context) === null || n === void 0 ? void 0 : n.getStreetView()) !== null && t !== void 0 ? t : null;
    this.registeredEvents = Jt({
      updaterMap: VD,
      eventMap: WD,
      prevProps: {},
      nextProps: this.props,
      instance: r
    }), this.setState(() => ({
      streetViewPanorama: r
    }), this.setStreetViewPanoramaCallback);
  }
  componentDidUpdate(t) {
    this.state.streetViewPanorama !== null && (on(this.registeredEvents), this.registeredEvents = Jt({
      updaterMap: VD,
      eventMap: WD,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.streetViewPanorama
    }));
  }
  componentWillUnmount() {
    this.state.streetViewPanorama !== null && (this.props.onUnmount && this.props.onUnmount(this.state.streetViewPanorama), on(this.registeredEvents), this.state.streetViewPanorama.setVisible(!1));
  }
  render() {
    return null;
  }
}
be(Xae, "contextType", Pt);
class Kae extends pe {
  constructor() {
    super(...arguments), be(this, "state", {
      streetViewService: null
    }), be(this, "setStreetViewServiceCallback", () => {
      this.state.streetViewService !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewService);
    });
  }
  componentDidMount() {
    var t = new google.maps.StreetViewService();
    this.setState(function() {
      return {
        streetViewService: t
      };
    }, this.setStreetViewServiceCallback);
  }
  componentWillUnmount() {
    this.state.streetViewService !== null && this.props.onUnmount && this.props.onUnmount(this.state.streetViewService);
  }
  render() {
    return null;
  }
}
be(Kae, "contextType", Pt);
var qD = {
  onDirectionsChanged: "directions_changed"
}, ZD = {
  directions(e, t) {
    e.setDirections(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  panel(e, t) {
    e.setPanel(t);
  },
  routeIndex(e, t) {
    e.setRouteIndex(t);
  }
};
class Yae extends pe {
  constructor() {
    super(...arguments), be(this, "registeredEvents", []), be(this, "state", {
      directionsRenderer: null
    }), be(this, "setDirectionsRendererCallback", () => {
      this.state.directionsRenderer !== null && (this.state.directionsRenderer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.directionsRenderer));
    });
  }
  componentDidMount() {
    var t = new google.maps.DirectionsRenderer(this.props.options);
    this.registeredEvents = Jt({
      updaterMap: ZD,
      eventMap: qD,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        directionsRenderer: t
      };
    }, this.setDirectionsRendererCallback);
  }
  componentDidUpdate(t) {
    this.state.directionsRenderer !== null && (on(this.registeredEvents), this.registeredEvents = Jt({
      updaterMap: ZD,
      eventMap: qD,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.directionsRenderer
    }));
  }
  componentWillUnmount() {
    this.state.directionsRenderer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.directionsRenderer), on(this.registeredEvents), this.state.directionsRenderer && this.state.directionsRenderer.setMap(null));
  }
  render() {
    return null;
  }
}
be(Yae, "contextType", Pt);
var GD = {
  onPlacesChanged: "places_changed"
}, XD = {
  bounds(e, t) {
    e.setBounds(t);
  }
};
class Jae extends pe {
  constructor() {
    super(...arguments), be(this, "registeredEvents", []), be(this, "containerElement", Qr()), be(this, "state", {
      searchBox: null
    }), be(this, "setSearchBoxCallback", () => {
      this.state.searchBox !== null && this.props.onLoad && this.props.onLoad(this.state.searchBox);
    });
  }
  componentDidMount() {
    if (qr(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places), this.containerElement !== null && this.containerElement.current !== null) {
      var t = this.containerElement.current.querySelector("input");
      if (t !== null) {
        var n = new google.maps.places.SearchBox(t, this.props.options);
        this.registeredEvents = Jt({
          updaterMap: XD,
          eventMap: GD,
          prevProps: {},
          nextProps: this.props,
          instance: n
        }), this.setState(function() {
          return {
            searchBox: n
          };
        }, this.setSearchBoxCallback);
      }
    }
  }
  componentDidUpdate(t) {
    this.state.searchBox !== null && (on(this.registeredEvents), this.registeredEvents = Jt({
      updaterMap: XD,
      eventMap: GD,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.searchBox
    }));
  }
  componentWillUnmount() {
    this.state.searchBox !== null && (this.props.onUnmount && this.props.onUnmount(this.state.searchBox), on(this.registeredEvents));
  }
  render() {
    return io.jsx("div", {
      ref: this.containerElement,
      children: at.only(this.props.children)
    });
  }
}
be(Jae, "contextType", Pt);
var KD = {
  onPlaceChanged: "place_changed"
}, YD = {
  bounds(e, t) {
    e.setBounds(t);
  },
  restrictions(e, t) {
    e.setComponentRestrictions(t);
  },
  fields(e, t) {
    e.setFields(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  types(e, t) {
    e.setTypes(t);
  }
};
class lV extends pe {
  constructor() {
    super(...arguments), be(this, "registeredEvents", []), be(this, "containerElement", Qr()), be(this, "state", {
      autocomplete: null
    }), be(this, "setAutocompleteCallback", () => {
      this.state.autocomplete !== null && this.props.onLoad && this.props.onLoad(this.state.autocomplete);
    });
  }
  componentDidMount() {
    var t;
    qr(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places);
    var n = (t = this.containerElement.current) === null || t === void 0 ? void 0 : t.querySelector("input");
    if (n) {
      var r = new google.maps.places.Autocomplete(n, this.props.options);
      this.registeredEvents = Jt({
        updaterMap: YD,
        eventMap: KD,
        prevProps: {},
        nextProps: this.props,
        instance: r
      }), this.setState(() => ({
        autocomplete: r
      }), this.setAutocompleteCallback);
    }
  }
  componentDidUpdate(t) {
    on(this.registeredEvents), this.registeredEvents = Jt({
      updaterMap: YD,
      eventMap: KD,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.autocomplete
    });
  }
  componentWillUnmount() {
    this.state.autocomplete !== null && on(this.registeredEvents);
  }
  render() {
    return io.jsx("div", {
      ref: this.containerElement,
      className: this.props.className,
      children: at.only(this.props.children)
    });
  }
}
be(lV, "defaultProps", {
  className: ""
});
be(lV, "contextType", Pt);
let Qae = { data: "" }, ele = (e) => typeof window == "object" ? ((e ? e.querySelector("#_goober") : window._goober) || Object.assign((e || document.head).appendChild(document.createElement("style")), { innerHTML: " ", id: "_goober" })).firstChild : e || Qae, tle = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g, nle = /\/\*[^]*?\*\/|  +/g, JD = /\n+/g, ia = (e, t) => {
  let n = "", r = "", o = "";
  for (let i in e) {
    let a = e[i];
    i[0] == "@" ? i[1] == "i" ? n = i + " " + a + ";" : r += i[1] == "f" ? ia(a, i) : i + "{" + ia(a, i[1] == "k" ? "" : t) + "}" : typeof a == "object" ? r += ia(a, t ? t.replace(/([^,])+/g, (s) => i.replace(/([^,]*:\S+\([^)]*\))|([^,])+/g, (l) => /&/.test(l) ? l.replace(/&/g, s) : s ? s + " " + l : l)) : i) : a != null && (i = /^--/.test(i) ? i : i.replace(/[A-Z]/g, "-$&").toLowerCase(), o += ia.p ? ia.p(i, a) : i + ":" + a + ";");
  }
  return n + (t && o ? t + "{" + o + "}" : o) + r;
}, as = {}, uV = (e) => {
  if (typeof e == "object") {
    let t = "";
    for (let n in e) t += n + uV(e[n]);
    return t;
  }
  return e;
}, rle = (e, t, n, r, o) => {
  let i = uV(e), a = as[i] || (as[i] = ((l) => {
    let u = 0, c = 11;
    for (; u < l.length; ) c = 101 * c + l.charCodeAt(u++) >>> 0;
    return "go" + c;
  })(i));
  if (!as[a]) {
    let l = i !== e ? e : ((u) => {
      let c, p, d = [{}];
      for (; c = tle.exec(u.replace(nle, "")); ) c[4] ? d.shift() : c[3] ? (p = c[3].replace(JD, " ").trim(), d.unshift(d[0][p] = d[0][p] || {})) : d[0][c[1]] = c[2].replace(JD, " ").trim();
      return d[0];
    })(e);
    as[a] = ia(o ? { ["@keyframes " + a]: l } : l, n ? "" : "." + a);
  }
  let s = n && as.g ? as.g : null;
  return n && (as.g = as[a]), ((l, u, c, p) => {
    p ? u.data = u.data.replace(p, l) : u.data.indexOf(l) === -1 && (u.data = c ? l + u.data : u.data + l);
  })(as[a], t, r, s), a;
}, ole = (e, t, n) => e.reduce((r, o, i) => {
  let a = t[i];
  if (a && a.call) {
    let s = a(n), l = s && s.props && s.props.className || /^go/.test(s) && s;
    a = l ? "." + l : s && typeof s == "object" ? s.props ? "" : ia(s, "") : s === !1 ? "" : s;
  }
  return r + o + (a ?? "");
}, "");
function Jv(e) {
  let t = this || {}, n = e.call ? e(t.p) : e;
  return rle(n.unshift ? n.raw ? ole(n, [].slice.call(arguments, 1), t.p) : n.reduce((r, o) => Object.assign(r, o && o.call ? o(t.p) : o), {}) : n, ele(t.target), t.g, t.o, t.k);
}
let cV, QC, ex;
Jv.bind({ g: 1 });
let ws = Jv.bind({ k: 1 });
function ile(e, t, n, r) {
  ia.p = t, cV = e, QC = n, ex = r;
}
function _a(e, t) {
  let n = this || {};
  return function() {
    let r = arguments;
    function o(i, a) {
      let s = Object.assign({}, i), l = s.className || o.className;
      n.p = Object.assign({ theme: QC && QC() }, s), n.o = / *go\d+/.test(l), s.className = Jv.apply(n, r) + (l ? " " + l : "");
      let u = e;
      return e[0] && (u = s.as || e, delete s.as), ex && u[0] && ex(s), cV(u, s);
    }
    return o;
  };
}
var sle = (e) => typeof e == "function", ale = (e, t) => sle(e) ? e(t) : e, lle = /* @__PURE__ */ (() => {
  let e;
  return () => {
    if (e === void 0 && typeof window < "u") {
      let t = matchMedia("(prefers-reduced-motion: reduce)");
      e = !t || t.matches;
    }
    return e;
  };
})(), ule = ws`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`, cle = ws`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`, ple = ws`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`, dle = _a("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${ule} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${cle} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${(e) => e.secondary || "#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${ple} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`, fle = ws`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, hle = _a("div")`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${(e) => e.secondary || "#e0e0e0"};
  border-right-color: ${(e) => e.primary || "#616161"};
  animation: ${fle} 1s linear infinite;
`, gle = ws`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`, mle = ws`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`, vle = _a("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${gle} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${mle} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${(e) => e.secondary || "#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`, yle = _a("div")`
  position: absolute;
`, ble = _a("div")`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`, wle = ws`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`, Cle = _a("div")`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${wle} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`, xle = ({ toast: e }) => {
  let { icon: t, type: n, iconTheme: r } = e;
  return t !== void 0 ? typeof t == "string" ? $e.createElement(Cle, null, t) : t : n === "blank" ? null : $e.createElement(ble, null, $e.createElement(hle, { ...r }), n !== "loading" && $e.createElement(yle, null, n === "error" ? $e.createElement(dle, { ...r }) : $e.createElement(vle, { ...r })));
}, Ole = (e) => `
0% {transform: translate3d(0,${e * -200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`, Ele = (e) => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${e * -150}%,-1px) scale(.6); opacity:0;}
`, kle = "0%{opacity:0;} 100%{opacity:1;}", Lle = "0%{opacity:1;} 100%{opacity:0;}", _le = _a("div")`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`, Ple = _a("div")`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`, Sle = (e, t) => {
  let n = e.includes("top") ? 1 : -1, [r, o] = lle() ? [kle, Lle] : [Ole(n), Ele(n)];
  return { animation: t ? `${ws(r)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards` : `${ws(o)} 0.4s forwards cubic-bezier(.06,.71,.55,1)` };
};
$e.memo(({ toast: e, position: t, style: n, children: r }) => {
  let o = e.height ? Sle(e.position || t || "top-center", e.visible) : { opacity: 0 }, i = $e.createElement(xle, { toast: e }), a = $e.createElement(Ple, { ...e.ariaProps }, ale(e.message, e));
  return $e.createElement(_le, { className: e.className, style: { ...o, ...n, ...e.style } }, typeof r == "function" ? r({ icon: i, message: a }) : $e.createElement($e.Fragment, null, i, a));
});
ile($e.createElement);
Jv`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`;
Ze({});
function Mle(e) {
  return e && e.replace(/[^0-9]/g, "");
}
const Dle = {
  CNPJ: "99.999.999/9999-99"
};
Mle(Dle.CNPJ).length;
Vr((e, t) => /* @__PURE__ */ oo.jsx("input", { ref: t, ...e }));
function pV(e) {
  return e && e.replace(/[^0-9]/g, "");
}
const dV = {
  EIGTH: "(99) 9999-9999",
  NINE: "(99) 99999-9999"
};
function Tle(e, t) {
  let n = "", r = 0;
  for (let o = 0; o < t.length; o++)
    if (t[o] === "9")
      if (r < e.length)
        n += e[r], r++;
      else
        break;
    else if (r < e.length)
      n += t[o];
    else
      break;
  return n;
}
function jle(e) {
  return e.length > 10 ? "NINE" : "EIGTH";
}
const Ale = pV(dV.NINE).length, Ble = Vr((e, t) => /* @__PURE__ */ oo.jsx("input", { ref: t, ...e }));
Vr(
  (e, t) => {
    const { onFocus: n, onBlur: r, size: o, onChange: i, value: a, currentCountry: s, disabled: l } = e, [u, c] = k(!1);
    v(() => {
      u ? i(s.mask) : c(!0);
    }, [s]);
    const p = `phoneInputMask ${o}`;
    function d(h) {
      let f = pV(h.target.value);
      const m = jle(f);
      f.length > Ale || (f = Tle(f, dV[m]), h.target.value = f, i(f));
    }
    return s.code === "+55" ? /* @__PURE__ */ oo.jsx(
      "input",
      {
        value: a,
        onChange: d,
        className: p,
        onFocus: n,
        onBlur: r,
        disabled: l,
        ref: t
      }
    ) : /* @__PURE__ */ oo.jsx(
      Il,
      {
        value: a,
        onChange: (h) => i(h.target.value),
        className: p,
        component: Ble,
        onFocus: n,
        onBlur: r,
        disabled: l,
        mask: s.mask,
        showMask: !0,
        replacement: { _: /\d/ },
        ref: t
      }
    );
  }
);
Ze({});
var _s = {};
Object.defineProperty(_s, "__esModule", {
  value: !0
});
var Ile = typeof window < "u" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform), Nb = {
  alt: "altKey",
  control: "ctrlKey",
  meta: "metaKey",
  shift: "shiftKey"
}, fV = {
  add: "+",
  break: "pause",
  cmd: "meta",
  command: "meta",
  ctl: "control",
  ctrl: "control",
  del: "delete",
  down: "arrowdown",
  esc: "escape",
  ins: "insert",
  left: "arrowleft",
  mod: Ile ? "meta" : "control",
  opt: "alt",
  option: "alt",
  return: "enter",
  right: "arrowright",
  space: " ",
  spacebar: " ",
  up: "arrowup",
  win: "meta",
  windows: "meta"
}, rk = {
  backspace: 8,
  tab: 9,
  enter: 13,
  shift: 16,
  control: 17,
  alt: 18,
  pause: 19,
  capslock: 20,
  escape: 27,
  " ": 32,
  pageup: 33,
  pagedown: 34,
  end: 35,
  home: 36,
  arrowleft: 37,
  arrowup: 38,
  arrowright: 39,
  arrowdown: 40,
  insert: 45,
  delete: 46,
  meta: 91,
  numlock: 144,
  scrolllock: 145,
  ";": 186,
  "=": 187,
  ",": 188,
  "-": 189,
  ".": 190,
  "/": 191,
  "`": 192,
  "[": 219,
  "\\": 220,
  "]": 221,
  "'": 222
};
for (var xf = 1; xf < 20; xf++)
  rk["f" + xf] = 111 + xf;
function Qv(e, t, n) {
  t && !("byKey" in t) && (n = t, t = null), Array.isArray(e) || (e = [e]);
  var r = e.map(function(a) {
    return hV(a, t);
  }), o = function(a) {
    return r.some(function(s) {
      return gV(s, a);
    });
  }, i = n == null ? o : o(n);
  return i;
}
function Rle(e, t) {
  return Qv(e, t);
}
function Nle(e, t) {
  return Qv(e, { byKey: !0 }, t);
}
function hV(e, t) {
  var n = t && t.byKey, r = {};
  e = e.replace("++", "+add");
  var o = e.split("+"), i = o.length;
  for (var a in Nb)
    r[Nb[a]] = !1;
  var s = !0, l = !1, u = void 0;
  try {
    for (var c = o[Symbol.iterator](), p; !(s = (p = c.next()).done); s = !0) {
      var d = p.value, h = d.endsWith("?") && d.length > 1;
      h && (d = d.slice(0, -1));
      var f = ok(d), m = Nb[f];
      if (d.length > 1 && !m && !fV[d] && !rk[f])
        throw new TypeError('Unknown modifier: "' + d + '"');
      (i === 1 || !m) && (n ? r.key = f : r.which = mV(d)), m && (r[m] = h ? null : !0);
    }
  } catch (g) {
    l = !0, u = g;
  } finally {
    try {
      !s && c.return && c.return();
    } finally {
      if (l)
        throw u;
    }
  }
  return r;
}
function gV(e, t) {
  for (var n in e) {
    var r = e[n], o = void 0;
    if (r != null && (n === "key" && t.key != null ? o = t.key.toLowerCase() : n === "which" ? o = r === 91 && t.which === 93 ? 91 : t.which : o = t[n], !(o == null && r === !1) && o !== r))
      return !1;
  }
  return !0;
}
function mV(e) {
  e = ok(e);
  var t = rk[e] || e.toUpperCase().charCodeAt(0);
  return t;
}
function ok(e) {
  return e = e.toLowerCase(), e = fV[e] || e, e;
}
_s.default = Qv;
var Fb = _s.isHotkey = Qv;
_s.isCodeHotkey = Rle;
_s.isKeyHotkey = Nle;
_s.parseHotkey = hV;
_s.compareHotkey = gV;
_s.toKeyCode = mV;
_s.toKeyName = ok;
var Fle = typeof $n == "object" && $n && $n.Object === Object && $n, zle = Fle, Ule = zle, $le = typeof self == "object" && self && self.Object === Object && self, Hle = Ule || $le || Function("return this")(), Wle = Hle, Vle = Wle, qle = Vle.Symbol, vV = qle, QD = vV;
QD && QD.toStringTag;
var eT = vV;
eT && eT.toStringTag;
var tT;
(function(e) {
  e.BORDER_BOX = "border-box", e.CONTENT_BOX = "content-box", e.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(tT || (tT = {}));
var ik = function(e) {
  return Object.freeze(e);
}, Zle = /* @__PURE__ */ function() {
  function e(t, n) {
    this.inlineSize = t, this.blockSize = n, ik(this);
  }
  return e;
}(), Gle = function() {
  function e(t, n, r, o) {
    return this.x = t, this.y = n, this.width = r, this.height = o, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, ik(this);
  }
  return e.prototype.toJSON = function() {
    var t = this, n = t.x, r = t.y, o = t.top, i = t.right, a = t.bottom, s = t.left, l = t.width, u = t.height;
    return { x: n, y: r, top: o, right: i, bottom: a, left: s, width: l, height: u };
  }, e.fromRect = function(t) {
    return new e(t.x, t.y, t.width, t.height);
  }, e;
}(), nT = typeof window < "u" ? window : {};
/msie|trident/i.test(nT.navigator && nT.navigator.userAgent);
var zb = function(e, t, n) {
  return e === void 0 && (e = 0), t === void 0 && (t = 0), n === void 0 && (n = !1), new Zle((n ? t : e) || 0, (n ? e : t) || 0);
};
ik({
  devicePixelContentBoxSize: zb(),
  borderBoxSize: zb(),
  contentBoxSize: zb(),
  contentRect: new Gle(0, 0, 0, 0)
});
function Lp(e) {
  "@babel/helpers - typeof";
  return Lp = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Lp(e);
}
function Xle(e, t) {
  if (Lp(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (Lp(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function Kle(e) {
  var t = Xle(e, "string");
  return Lp(t) === "symbol" ? t : String(t);
}
function Bc(e, t, n) {
  return t = Kle(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
var Yle = /* @__PURE__ */ Ze(null), Ub, $b;
parseInt(ke.version.split(".")[0], 10);
var rT = typeof navigator < "u" && /Mac OS X/.test(navigator.userAgent), Hb = typeof navigator < "u" && /Android/.test(navigator.userAgent), Of = typeof navigator < "u" && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent), Jle = typeof navigator < "u" && /Chrome/i.test(navigator.userAgent);
typeof navigator < "u" && /Safari/.test(navigator.userAgent) && /Version\/(\d+)/.test(navigator.userAgent) && (Ub = navigator.userAgent.match(/Version\/(\d+)/)) !== null && Ub !== void 0 && Ub[1] && parseInt(($b = navigator.userAgent.match(/Version\/(\d+)/)) === null || $b === void 0 ? void 0 : $b[1], 10) < 17;
var Qle = /* @__PURE__ */ new WeakMap(), eue = /* @__PURE__ */ new WeakMap(), tue = /* @__PURE__ */ new WeakMap(), nue = /* @__PURE__ */ new WeakMap(), rue = /* @__PURE__ */ new WeakMap(), oT = /* @__PURE__ */ new WeakMap(), oue = /* @__PURE__ */ new WeakMap(), iT = /* @__PURE__ */ new WeakMap(), Ef = /* @__PURE__ */ new WeakMap(), iue = /* @__PURE__ */ new WeakMap(), sue = /* @__PURE__ */ new WeakMap(), aue = /* @__PURE__ */ new WeakMap(), yV = globalThis.Node, lue = globalThis.Text, bV = (e) => e && e.ownerDocument && e.ownerDocument.defaultView || null, uue = (e) => Pg(e) && e.nodeType === 8, Wi = (e) => Pg(e) && e.nodeType === 1, Pg = (e) => {
  var t = bV(e);
  return !!t && e instanceof t.Node;
}, sT = (e) => {
  var t = e && e.anchorNode && bV(e.anchorNode);
  return !!t && e instanceof t.Selection;
}, cue = (e) => {
  var [t, n] = e;
  if (Wi(t) && t.childNodes.length) {
    var r = n === t.childNodes.length, o = r ? n - 1 : n;
    for ([t, o] = wV(t, o, r ? "backward" : "forward"), r = o < n; Wi(t) && t.childNodes.length; ) {
      var i = r ? t.childNodes.length - 1 : 0;
      t = due(t, i, r ? "backward" : "forward");
    }
    n = r && t.textContent != null ? t.textContent.length : 0;
  }
  return [t, n];
}, pue = (e) => {
  for (var t = e && e.parentNode; t; ) {
    if (t.toString() === "[object ShadowRoot]")
      return !0;
    t = t.parentNode;
  }
  return !1;
}, wV = (e, t, n) => {
  for (var {
    childNodes: r
  } = e, o = r[t], i = t, a = !1, s = !1; (uue(o) || Wi(o) && o.childNodes.length === 0 || Wi(o) && o.getAttribute("contenteditable") === "false") && !(a && s); ) {
    if (i >= r.length) {
      a = !0, i = t - 1, n = "backward";
      continue;
    }
    if (i < 0) {
      s = !0, i = t + 1, n = "forward";
      continue;
    }
    o = r[i], t = i, i += n === "forward" ? 1 : -1;
  }
  return [o, t];
}, due = (e, t, n) => {
  var [r] = wV(e, t, n);
  return r;
}, aT = (e) => e.getSelection != null ? e.getSelection() : document.getSelection(), CV = (e, t, n) => {
  var {
    target: r
  } = t;
  if (Wi(r) && r.matches('[contentEditable="false"]'))
    return !1;
  var {
    document: o
  } = Gt.getWindow(e);
  if (o.contains(r))
    return Gt.hasDOMNode(e, r, {
      editable: !0
    });
  var i = n.find((a) => {
    var {
      addedNodes: s,
      removedNodes: l
    } = a;
    for (var u of s)
      if (u === r || u.contains(r))
        return !0;
    for (var c of l)
      if (c === r || c.contains(r))
        return !0;
  });
  return !i || i === t ? !1 : CV(e, i, n);
}, lT = (e, t) => !!(e.compareDocumentPosition(t) & yV.DOCUMENT_POSITION_PRECEDING), fue = (e, t) => !!(e.compareDocumentPosition(t) & yV.DOCUMENT_POSITION_FOLLOWING), hue = 0;
class gue {
  constructor() {
    Bc(this, "id", void 0), this.id = "".concat(hue++);
  }
}
var Gt = {
  androidPendingDiffs: (e) => aue.get(e),
  androidScheduleFlush: (e) => {
    var t;
    (t = sue.get(e)) === null || t === void 0 || t();
  },
  blur: (e) => {
    var t = Gt.toDOMNode(e, e), n = Gt.findDocumentOrShadowRoot(e);
    Ef.set(e, !1), n.activeElement === t && t.blur();
  },
  deselect: (e) => {
    var {
      selection: t
    } = e, n = Gt.findDocumentOrShadowRoot(e), r = aT(n);
    r && r.rangeCount > 0 && r.removeAllRanges(), t && cg.deselect(e);
  },
  findDocumentOrShadowRoot: (e) => {
    var t = Gt.toDOMNode(e, e), n = t.getRootNode();
    return n instanceof Document || n instanceof ShadowRoot ? n : t.ownerDocument;
  },
  findEventRange: (e, t) => {
    "nativeEvent" in t && (t = t.nativeEvent);
    var {
      clientX: n,
      clientY: r,
      target: o
    } = t;
    if (n == null || r == null)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var i = Gt.toSlateNode(e, t.target), a = Gt.findPath(e, i);
    if (ms.isElement(i) && In.isVoid(e, i)) {
      var s = o.getBoundingClientRect(), l = e.isInline(i) ? n - s.left < s.left + s.width - n : r - s.top < s.top + s.height - r, u = In.point(e, a, {
        edge: l ? "start" : "end"
      }), c = l ? In.before(e, u) : In.after(e, u);
      if (c) {
        var p = In.range(e, c);
        return p;
      }
    }
    var d, {
      document: h
    } = Gt.getWindow(e);
    if (h.caretRangeFromPoint)
      d = h.caretRangeFromPoint(n, r);
    else {
      var f = h.caretPositionFromPoint(n, r);
      f && (d = h.createRange(), d.setStart(f.offsetNode, f.offset), d.setEnd(f.offsetNode, f.offset));
    }
    if (!d)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var m = Gt.toSlateRange(e, d, {
      exactMatch: !1,
      suppressThrow: !1
    });
    return m;
  },
  findKey: (e, t) => {
    var n = oT.get(t);
    return n || (n = new gue(), oT.set(t, n)), n;
  },
  findPath: (e, t) => {
    for (var n = [], r = t; ; ) {
      var o = eue.get(r);
      if (o == null) {
        if (In.isEditor(r))
          return n;
        break;
      }
      var i = Qle.get(r);
      if (i == null)
        break;
      n.unshift(i), r = o;
    }
    throw new Error("Unable to find the path for Slate node: ".concat(Vo.stringify(t)));
  },
  focus: function(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      retries: 5
    };
    if (!Ef.get(e)) {
      if (t.retries <= 0)
        throw new Error("Could not set focus, editor seems stuck with pending operations");
      if (e.operations.length > 0) {
        setTimeout(() => {
          Gt.focus(e, {
            retries: t.retries - 1
          });
        }, 10);
        return;
      }
      var n = Gt.toDOMNode(e, e), r = Gt.findDocumentOrShadowRoot(e);
      if (r.activeElement !== n) {
        if (e.selection && r instanceof Document) {
          var o = aT(r), i = Gt.toDOMRange(e, e.selection);
          o == null || o.removeAllRanges(), o == null || o.addRange(i);
        }
        e.selection || cg.select(e, In.start(e, [])), Ef.set(e, !0), n.focus({
          preventScroll: !0
        });
      }
    }
  },
  getWindow: (e) => {
    var t = tue.get(e);
    if (!t)
      throw new Error("Unable to find a host window element for this editor");
    return t;
  },
  hasDOMNode: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      editable: r = !1
    } = n, o = Gt.toDOMNode(e, e), i;
    try {
      i = Wi(t) ? t : t.parentElement;
    } catch (a) {
      if (a instanceof Error && !a.message.includes('Permission denied to access property "nodeType"'))
        throw a;
    }
    return i ? i.closest("[data-slate-editor]") === o && (!r || i.isContentEditable ? !0 : typeof i.isContentEditable == "boolean" && // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined
    // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable="false"(readOnly)
    i.closest('[contenteditable="false"]') === o || !!i.getAttribute("data-slate-zero-width")) : !1;
  },
  hasEditableTarget: (e, t) => Pg(t) && Gt.hasDOMNode(e, t, {
    editable: !0
  }),
  hasRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t;
    return In.hasPath(e, n.path) && In.hasPath(e, r.path);
  },
  hasSelectableTarget: (e, t) => Gt.hasEditableTarget(e, t) || Gt.isTargetInsideNonReadonlyVoid(e, t),
  hasTarget: (e, t) => Pg(t) && Gt.hasDOMNode(e, t),
  insertData: (e, t) => {
    e.insertData(t);
  },
  insertFragmentData: (e, t) => e.insertFragmentData(t),
  insertTextData: (e, t) => e.insertTextData(t),
  isComposing: (e) => !!iue.get(e),
  isFocused: (e) => !!Ef.get(e),
  isReadOnly: (e) => !!iT.get(e),
  isTargetInsideNonReadonlyVoid: (e, t) => {
    if (iT.get(e)) return !1;
    var n = Gt.hasTarget(e, t) && Gt.toSlateNode(e, t);
    return ms.isElement(n) && In.isVoid(e, n);
  },
  setFragmentData: (e, t, n) => e.setFragmentData(t, n),
  toDOMNode: (e, t) => {
    var n = oue.get(e), r = In.isEditor(t) ? nue.get(e) : n == null ? void 0 : n.get(Gt.findKey(e, t));
    if (!r)
      throw new Error("Cannot resolve a DOM node from Slate node: ".concat(Vo.stringify(t)));
    return r;
  },
  toDOMPoint: (e, t) => {
    var [n] = In.node(e, t.path), r = Gt.toDOMNode(e, n), o;
    In.void(e, {
      at: t
    }) && (t = {
      path: t.path,
      offset: 0
    });
    for (var i = "[data-slate-string], [data-slate-zero-width]", a = Array.from(r.querySelectorAll(i)), s = 0, l = 0; l < a.length; l++) {
      var u = a[l], c = u.childNodes[0];
      if (!(c == null || c.textContent == null)) {
        var {
          length: p
        } = c.textContent, d = u.getAttribute("data-slate-length"), h = d == null ? p : parseInt(d, 10), f = s + h, m = a[l + 1];
        if (t.offset === f && m !== null && m !== void 0 && m.hasAttribute("data-slate-mark-placeholder")) {
          var g, E = m.childNodes[0];
          o = [
            // COMPAT: If we don't explicity set the dom point to be on the actual
            // dom text element, chrome will put the selection behind the actual dom
            // text element, causing domRange.getBoundingClientRect() calls on a collapsed
            // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)
            // which will cause issues when scrolling to it.
            E instanceof lue ? E : m,
            (g = m.textContent) !== null && g !== void 0 && g.startsWith("\uFEFF") ? 1 : 0
          ];
          break;
        }
        if (t.offset <= f) {
          var w = Math.min(p, Math.max(0, t.offset - s));
          o = [c, w];
          break;
        }
        s = f;
      }
    }
    if (!o)
      throw new Error("Cannot resolve a DOM point from Slate point: ".concat(Vo.stringify(t)));
    return o;
  },
  toDOMRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t, o = Rt.isBackward(t), i = Gt.toDOMPoint(e, n), a = Rt.isCollapsed(t) ? i : Gt.toDOMPoint(e, r), s = Gt.getWindow(e), l = s.document.createRange(), [u, c] = o ? a : i, [p, d] = o ? i : a, h = Wi(u) ? u : u.parentElement, f = !!h.getAttribute("data-slate-zero-width"), m = Wi(p) ? p : p.parentElement, g = !!m.getAttribute("data-slate-zero-width");
    return l.setStart(u, f ? 1 : c), l.setEnd(p, g ? 1 : d), l;
  },
  toSlateNode: (e, t) => {
    var n = Wi(t) ? t : t.parentElement;
    n && !n.hasAttribute("data-slate-node") && (n = n.closest("[data-slate-node]"));
    var r = n ? rue.get(n) : null;
    if (!r)
      throw new Error("Cannot resolve a Slate node from DOM node: ".concat(n));
    return r;
  },
  toSlatePoint: (e, t, n) => {
    var {
      exactMatch: r,
      suppressThrow: o,
      searchDirection: i = "backward"
    } = n, [a, s] = r ? t : cue(t), l = a.parentNode, u = null, c = 0;
    if (l) {
      var p, d, h = Gt.toDOMNode(e, e), f = l.closest('[data-slate-void="true"]'), m = f && h.contains(f) ? f : null, g = l.closest('[contenteditable="false"]'), E = g && h.contains(g) ? g : null, w = l.closest("[data-slate-leaf]"), M = null;
      if (w) {
        if (u = w.closest('[data-slate-node="text"]'), u) {
          var x = Gt.getWindow(e), y = x.document.createRange();
          y.setStart(u, 0), y.setEnd(a, s);
          var C = y.cloneContents(), P = [...Array.prototype.slice.call(C.querySelectorAll("[data-slate-zero-width]")), ...Array.prototype.slice.call(C.querySelectorAll("[contenteditable=false]"))];
          P.forEach((S) => {
            if (Hb && !r && S.hasAttribute("data-slate-zero-width") && S.textContent.length > 0 && S.textContext !== "\uFEFF") {
              S.textContent.startsWith("\uFEFF") && (S.textContent = S.textContent.slice(1));
              return;
            }
            S.parentNode.removeChild(S);
          }), c = C.textContent.length, M = u;
        }
      } else if (m) {
        for (var F = m.querySelectorAll("[data-slate-leaf]"), L = 0; L < F.length; L++) {
          var N = F[L];
          if (Gt.hasDOMNode(e, N)) {
            w = N;
            break;
          }
        }
        w ? (u = w.closest('[data-slate-node="text"]'), M = w, c = M.textContent.length, M.querySelectorAll("[data-slate-zero-width]").forEach((S) => {
          c -= S.textContent.length;
        })) : c = 1;
      } else if (E) {
        var I = (S) => S ? S.querySelectorAll(
          // Exclude leaf nodes in nested editors
          "[data-slate-leaf]:not(:scope [data-slate-editor] [data-slate-leaf])"
        ) : [], H = E.closest('[data-slate-node="element"]');
        if (i === "forward") {
          var V, z = [...I(H), ...I(H == null ? void 0 : H.nextElementSibling)];
          w = (V = z.find((S) => fue(E, S))) !== null && V !== void 0 ? V : null;
        } else {
          var q, K = [...I(H == null ? void 0 : H.previousElementSibling), ...I(H)];
          w = (q = K.findLast((S) => lT(E, S))) !== null && q !== void 0 ? q : null;
        }
        w && (u = w.closest('[data-slate-node="text"]'), M = w, i === "forward" ? c = 0 : (c = M.textContent.length, M.querySelectorAll("[data-slate-zero-width]").forEach((S) => {
          c -= S.textContent.length;
        })));
      }
      M && c === M.textContent.length && // COMPAT: Android IMEs might remove the zero width space while composing,
      // and we don't add it for line-breaks.
      Hb && M.getAttribute("data-slate-zero-width") === "z" && (p = M.textContent) !== null && p !== void 0 && p.startsWith("\uFEFF") && // COMPAT: If the parent node is a Slate zero-width space, editor is
      // because the text node should have no characters. However, during IME
      // composition the ASCII characters will be prepended to the zero-width
      // space, so subtract 1 from the offset to account for the zero-width
      // space character.
      (l.hasAttribute("data-slate-zero-width") || // COMPAT: In Firefox, `range.cloneContents()` returns an extra trailing '\n'
      // when the document ends with a new-line character. This results in the offset
      // length being off by one, so we need to subtract one to account for this.
      Of && (d = M.textContent) !== null && d !== void 0 && d.endsWith(`

`)) && c--;
    }
    if (Hb && !u && !r) {
      var J = l.hasAttribute("data-slate-node") ? l : l.closest("[data-slate-node]");
      if (J && Gt.hasDOMNode(e, J, {
        editable: !0
      })) {
        var te = Gt.toSlateNode(e, J), {
          path: ee,
          offset: _
        } = In.start(e, Gt.findPath(e, te));
        return J.querySelector("[data-slate-leaf]") || (_ = s), {
          path: ee,
          offset: _
        };
      }
    }
    if (!u) {
      if (o)
        return null;
      throw new Error("Cannot resolve a Slate point from DOM point: ".concat(t));
    }
    var D = Gt.toSlateNode(e, u), $ = Gt.findPath(e, D);
    return {
      path: $,
      offset: c
    };
  },
  toSlateRange: (e, t, n) => {
    var r, {
      exactMatch: o,
      suppressThrow: i
    } = n, a = sT(t) ? t.anchorNode : t.startContainer, s, l, u, c, p;
    if (a)
      if (sT(t)) {
        if (Of && t.rangeCount > 1) {
          u = t.focusNode;
          var d = t.getRangeAt(0), h = t.getRangeAt(t.rangeCount - 1);
          if (u instanceof HTMLTableRowElement && d.startContainer instanceof HTMLTableRowElement && h.startContainer instanceof HTMLTableRowElement) {
            let C = function(P) {
              return P.childElementCount > 0 ? C(P.children[0]) : P;
            };
            var f = d.startContainer, m = h.startContainer, g = C(f.children[d.startOffset]), E = C(m.children[h.startOffset]);
            c = 0, E.childNodes.length > 0 ? s = E.childNodes[0] : s = E, g.childNodes.length > 0 ? u = g.childNodes[0] : u = g, E instanceof HTMLElement ? l = E.innerHTML.length : l = 0;
          } else
            d.startContainer === u ? (s = h.endContainer, l = h.endOffset, c = d.startOffset) : (s = d.startContainer, l = d.endOffset, c = h.startOffset);
        } else
          s = t.anchorNode, l = t.anchorOffset, u = t.focusNode, c = t.focusOffset;
        Jle && pue(s) || Of ? p = t.anchorNode === t.focusNode && t.anchorOffset === t.focusOffset : p = t.isCollapsed;
      } else
        s = t.startContainer, l = t.startOffset, u = t.endContainer, c = t.endOffset, p = t.collapsed;
    if (s == null || u == null || l == null || c == null)
      throw new Error("Cannot resolve a Slate range from DOM range: ".concat(t));
    Of && (r = u.textContent) !== null && r !== void 0 && r.endsWith(`

`) && c === u.textContent.length && c--;
    var w = Gt.toSlatePoint(e, [s, l], {
      exactMatch: o,
      suppressThrow: i
    });
    if (!w)
      return null;
    var M = lT(s, u) || s === u && c < l, x = p ? w : Gt.toSlatePoint(e, [u, c], {
      exactMatch: o,
      suppressThrow: i,
      searchDirection: M ? "forward" : "backward"
    });
    if (!x)
      return null;
    var y = {
      anchor: w,
      focus: x
    };
    return Rt.isExpanded(y) && Rt.isForward(y) && Wi(u) && In.void(e, {
      at: y.focus,
      mode: "highest"
    }) && (y = In.unhangRange(e, y, {
      voids: !0
    })), y;
  }
}, mue = {
  bold: "mod+b",
  compose: ["down", "left", "right", "up", "backspace", "enter"],
  moveBackward: "left",
  moveForward: "right",
  moveWordBackward: "ctrl+left",
  moveWordForward: "ctrl+right",
  deleteBackward: "shift?+backspace",
  deleteForward: "shift?+delete",
  extendBackward: "shift+left",
  extendForward: "shift+right",
  italic: "mod+i",
  insertSoftBreak: "shift+enter",
  splitBlock: "enter",
  undo: "mod+z"
}, vue = {
  moveLineBackward: "opt+up",
  moveLineForward: "opt+down",
  moveWordBackward: "opt+left",
  moveWordForward: "opt+right",
  deleteBackward: ["ctrl+backspace", "ctrl+h"],
  deleteForward: ["ctrl+delete", "ctrl+d"],
  deleteLineBackward: "cmd+shift?+backspace",
  deleteLineForward: ["cmd+shift?+delete", "ctrl+k"],
  deleteWordBackward: "opt+shift?+backspace",
  deleteWordForward: "opt+shift?+delete",
  extendLineBackward: "opt+shift+up",
  extendLineForward: "opt+shift+down",
  redo: "cmd+shift+z",
  transposeCharacter: "ctrl+t"
}, yue = {
  deleteWordBackward: "ctrl+shift?+backspace",
  deleteWordForward: "ctrl+shift?+delete",
  redo: ["ctrl+y", "ctrl+shift+z"]
}, lr = (e) => {
  var t = mue[e], n = vue[e], r = yue[e], o = t && Fb(t), i = n && Fb(n), a = r && Fb(r);
  return (s) => !!(o && o(s) || rT && i && i(s) || !rT && a && a(s));
};
lr("bold"), lr("compose"), lr("moveBackward"), lr("moveForward"), lr("deleteBackward"), lr("deleteForward"), lr("deleteLineBackward"), lr("deleteLineForward"), lr("deleteWordBackward"), lr("deleteWordForward"), lr("extendBackward"), lr("extendForward"), lr("extendLineBackward"), lr("extendLineForward"), lr("italic"), lr("moveLineBackward"), lr("moveLineForward"), lr("moveWordBackward"), lr("moveWordForward"), lr("redo"), lr("insertSoftBreak"), lr("splitBlock"), lr("transposeCharacter"), lr("undo");
var bue = (e, t) => {
  var n = [], r = () => {
    n = [];
  }, o = (a) => {
    if (t.current) {
      var s = a.filter((l) => CV(e, l, a));
      n.push(...s);
    }
  };
  function i() {
    n.length > 0 && (n.reverse().forEach((a) => {
      a.type !== "characterData" && (a.removedNodes.forEach((s) => {
        a.target.insertBefore(s, a.nextSibling);
      }), a.addedNodes.forEach((s) => {
        a.target.removeChild(s);
      }));
    }), r());
  }
  return {
    registerMutations: o,
    restoreDOM: i,
    clear: r
  };
}, wue = {
  subtree: !0,
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0
};
class Cue extends pu {
  constructor() {
    super(...arguments), Bc(this, "context", null), Bc(this, "manager", null), Bc(this, "mutationObserver", null);
  }
  observe() {
    var t, {
      node: n
    } = this.props;
    if (!n.current)
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    (t = this.mutationObserver) === null || t === void 0 || t.observe(n.current, wue);
  }
  componentDidMount() {
    var {
      receivedUserInput: t
    } = this.props, n = this.context;
    this.manager = bue(n, t), this.mutationObserver = new MutationObserver(this.manager.registerMutations), this.observe();
  }
  getSnapshotBeforeUpdate() {
    var t, n, r, o = (t = this.mutationObserver) === null || t === void 0 ? void 0 : t.takeRecords();
    if (o != null && o.length) {
      var i;
      (i = this.manager) === null || i === void 0 || i.registerMutations(o);
    }
    return (n = this.mutationObserver) === null || n === void 0 || n.disconnect(), (r = this.manager) === null || r === void 0 || r.restoreDOM(), null;
  }
  componentDidUpdate() {
    var t;
    (t = this.manager) === null || t === void 0 || t.clear(), this.observe();
  }
  componentWillUnmount() {
    var t;
    (t = this.mutationObserver) === null || t === void 0 || t.disconnect();
  }
  render() {
    return this.props.children;
  }
}
Bc(Cue, "contextType", Yle);
Ze({});
Ze({});
Ze({});
var zr = {}, sk = {}, Zp = {}, Gp = {}, xV = "Expected a function", uT = NaN, xue = "[object Symbol]", Oue = /^\s+|\s+$/g, Eue = /^[-+]0x[0-9a-f]+$/i, kue = /^0b[01]+$/i, Lue = /^0o[0-7]+$/i, _ue = parseInt, Pue = typeof $n == "object" && $n && $n.Object === Object && $n, Sue = typeof self == "object" && self && self.Object === Object && self, Mue = Pue || Sue || Function("return this")(), Due = Object.prototype, Tue = Due.toString, jue = Math.max, Aue = Math.min, Wb = function() {
  return Mue.Date.now();
};
function Bue(e, t, n) {
  var r, o, i, a, s, l, u = 0, c = !1, p = !1, d = !0;
  if (typeof e != "function")
    throw new TypeError(xV);
  t = cT(t) || 0, Sg(n) && (c = !!n.leading, p = "maxWait" in n, i = p ? jue(cT(n.maxWait) || 0, t) : i, d = "trailing" in n ? !!n.trailing : d);
  function h(C) {
    var P = r, F = o;
    return r = o = void 0, u = C, a = e.apply(F, P), a;
  }
  function f(C) {
    return u = C, s = setTimeout(E, t), c ? h(C) : a;
  }
  function m(C) {
    var P = C - l, F = C - u, L = t - P;
    return p ? Aue(L, i - F) : L;
  }
  function g(C) {
    var P = C - l, F = C - u;
    return l === void 0 || P >= t || P < 0 || p && F >= i;
  }
  function E() {
    var C = Wb();
    if (g(C))
      return w(C);
    s = setTimeout(E, m(C));
  }
  function w(C) {
    return s = void 0, d && r ? h(C) : (r = o = void 0, a);
  }
  function M() {
    s !== void 0 && clearTimeout(s), u = 0, r = l = o = s = void 0;
  }
  function x() {
    return s === void 0 ? a : w(Wb());
  }
  function y() {
    var C = Wb(), P = g(C);
    if (r = arguments, o = this, l = C, P) {
      if (s === void 0)
        return f(l);
      if (p)
        return s = setTimeout(E, t), h(l);
    }
    return s === void 0 && (s = setTimeout(E, t)), a;
  }
  return y.cancel = M, y.flush = x, y;
}
function Iue(e, t, n) {
  var r = !0, o = !0;
  if (typeof e != "function")
    throw new TypeError(xV);
  return Sg(n) && (r = "leading" in n ? !!n.leading : r, o = "trailing" in n ? !!n.trailing : o), Bue(e, t, {
    leading: r,
    maxWait: t,
    trailing: o
  });
}
function Sg(e) {
  var t = typeof e;
  return !!e && (t == "object" || t == "function");
}
function Rue(e) {
  return !!e && typeof e == "object";
}
function Nue(e) {
  return typeof e == "symbol" || Rue(e) && Tue.call(e) == xue;
}
function cT(e) {
  if (typeof e == "number")
    return e;
  if (Nue(e))
    return uT;
  if (Sg(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = Sg(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = e.replace(Oue, "");
  var n = kue.test(e);
  return n || Lue.test(e) ? _ue(e.slice(2), n ? 2 : 8) : Eue.test(e) ? uT : +e;
}
var Fue = Iue, Xp = {};
Object.defineProperty(Xp, "__esModule", {
  value: !0
});
Xp.addPassiveEventListener = function(e, t, n) {
  var r = n.name;
  r || (r = t, console.warn("Listener must be a named function.")), Sh.has(t) || Sh.set(t, /* @__PURE__ */ new Set());
  var o = Sh.get(t);
  if (!o.has(r)) {
    var i = function() {
      var a = !1;
      try {
        var s = Object.defineProperty({}, "passive", {
          get: function() {
            a = !0;
          }
        });
        window.addEventListener("test", null, s);
      } catch {
      }
      return a;
    }();
    e.addEventListener(t, n, i ? { passive: !0 } : !1), o.add(r);
  }
};
Xp.removePassiveEventListener = function(e, t, n) {
  e.removeEventListener(t, n), Sh.get(t).delete(n.name || t);
};
var Sh = /* @__PURE__ */ new Map();
Object.defineProperty(Gp, "__esModule", {
  value: !0
});
var zue = Fue, Uue = $ue(zue), pT = Xp;
function $ue(e) {
  return e && e.__esModule ? e : { default: e };
}
var Hue = function(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 66;
  return (0, Uue.default)(e, t);
}, Or = {
  spyCallbacks: [],
  spySetState: [],
  scrollSpyContainers: [],
  mount: function(e, t) {
    if (e) {
      var n = Hue(function(r) {
        Or.scrollHandler(e);
      }, t);
      return Or.scrollSpyContainers.push(e), (0, pT.addPassiveEventListener)(e, "scroll", n), function() {
        (0, pT.removePassiveEventListener)(e, "scroll", n), Or.scrollSpyContainers.splice(Or.scrollSpyContainers.indexOf(e), 1);
      };
    }
    return function() {
    };
  },
  isMounted: function(e) {
    return Or.scrollSpyContainers.indexOf(e) !== -1;
  },
  currentPositionX: function(e) {
    if (e === document) {
      var t = window.scrollY !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.scrollX : n ? document.documentElement.scrollLeft : document.body.scrollLeft;
    } else
      return e.scrollLeft;
  },
  currentPositionY: function(e) {
    if (e === document) {
      var t = window.scrollX !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.scrollY : n ? document.documentElement.scrollTop : document.body.scrollTop;
    } else
      return e.scrollTop;
  },
  scrollHandler: function(e) {
    var t = Or.scrollSpyContainers[Or.scrollSpyContainers.indexOf(e)].spyCallbacks || [];
    t.forEach(function(n) {
      return n(Or.currentPositionX(e), Or.currentPositionY(e));
    });
  },
  addStateHandler: function(e) {
    Or.spySetState.push(e);
  },
  addSpyHandler: function(e, t) {
    var n = Or.scrollSpyContainers[Or.scrollSpyContainers.indexOf(t)];
    n.spyCallbacks || (n.spyCallbacks = []), n.spyCallbacks.push(e);
  },
  updateStates: function() {
    Or.spySetState.forEach(function(e) {
      return e();
    });
  },
  unmount: function(e, t) {
    Or.scrollSpyContainers.forEach(function(n) {
      return n.spyCallbacks && n.spyCallbacks.length && n.spyCallbacks.indexOf(t) > -1 && n.spyCallbacks.splice(n.spyCallbacks.indexOf(t), 1);
    }), Or.spySetState && Or.spySetState.length && Or.spySetState.indexOf(e) > -1 && Or.spySetState.splice(Or.spySetState.indexOf(e), 1), document.removeEventListener("scroll", Or.scrollHandler);
  },
  update: function() {
    return Or.scrollSpyContainers.forEach(function(e) {
      return Or.scrollHandler(e);
    });
  }
};
Gp.default = Or;
var wu = {}, Kp = {};
Object.defineProperty(Kp, "__esModule", {
  value: !0
});
var Wue = function(e, t) {
  var n = e.indexOf("#") === 0 ? e.substring(1) : e, r = n ? "#" + n : "", o = window && window.location, i = r ? o.pathname + o.search + r : o.pathname + o.search;
  t ? history.pushState(history.state, "", i) : history.replaceState(history.state, "", i);
}, Vue = function() {
  return window.location.hash.replace(/^#/, "");
}, que = function(e) {
  return function(t) {
    return e.contains ? e != t && e.contains(t) : !!(e.compareDocumentPosition(t) & 16);
  };
}, Zue = function(e) {
  return getComputedStyle(e).position !== "static";
}, Vb = function(e, t) {
  for (var n = e.offsetTop, r = e.offsetParent; r && !t(r); )
    n += r.offsetTop, r = r.offsetParent;
  return { offsetTop: n, offsetParent: r };
}, Gue = function(e, t, n) {
  if (n)
    return e === document ? t.getBoundingClientRect().left + (window.scrollX || window.pageXOffset) : getComputedStyle(e).position !== "static" ? t.offsetLeft : t.offsetLeft - e.offsetLeft;
  if (e === document)
    return t.getBoundingClientRect().top + (window.scrollY || window.pageYOffset);
  if (Zue(e)) {
    if (t.offsetParent !== e) {
      var r = function(l) {
        return l === e || l === document;
      }, o = Vb(t, r), i = o.offsetTop, a = o.offsetParent;
      if (a !== e)
        throw new Error("Seems containerElement is not an ancestor of the Element");
      return i;
    }
    return t.offsetTop;
  }
  if (t.offsetParent === e.offsetParent)
    return t.offsetTop - e.offsetTop;
  var s = function(l) {
    return l === document;
  };
  return Vb(t, s).offsetTop - Vb(e, s).offsetTop;
};
Kp.default = {
  updateHash: Wue,
  getHash: Vue,
  filterElementInContainer: que,
  scrollOffset: Gue
};
var ey = {}, ak = {};
Object.defineProperty(ak, "__esModule", {
  value: !0
});
ak.default = {
  /*
   * https://github.com/oblador/angular-scroll (duScrollDefaultEasing)
   */
  defaultEasing: function(e) {
    return e < 0.5 ? Math.pow(e * 2, 2) / 2 : 1 - Math.pow((1 - e) * 2, 2) / 2;
  },
  /*
   * https://gist.github.com/gre/1650294
   */
  // no easing, no acceleration
  linear: function(e) {
    return e;
  },
  // accelerating from zero velocity
  easeInQuad: function(e) {
    return e * e;
  },
  // decelerating to zero velocity
  easeOutQuad: function(e) {
    return e * (2 - e);
  },
  // acceleration until halfway, then deceleration
  easeInOutQuad: function(e) {
    return e < 0.5 ? 2 * e * e : -1 + (4 - 2 * e) * e;
  },
  // accelerating from zero velocity 
  easeInCubic: function(e) {
    return e * e * e;
  },
  // decelerating to zero velocity 
  easeOutCubic: function(e) {
    return --e * e * e + 1;
  },
  // acceleration until halfway, then deceleration 
  easeInOutCubic: function(e) {
    return e < 0.5 ? 4 * e * e * e : (e - 1) * (2 * e - 2) * (2 * e - 2) + 1;
  },
  // accelerating from zero velocity 
  easeInQuart: function(e) {
    return e * e * e * e;
  },
  // decelerating to zero velocity 
  easeOutQuart: function(e) {
    return 1 - --e * e * e * e;
  },
  // acceleration until halfway, then deceleration
  easeInOutQuart: function(e) {
    return e < 0.5 ? 8 * e * e * e * e : 1 - 8 * --e * e * e * e;
  },
  // accelerating from zero velocity
  easeInQuint: function(e) {
    return e * e * e * e * e;
  },
  // decelerating to zero velocity
  easeOutQuint: function(e) {
    return 1 + --e * e * e * e * e;
  },
  // acceleration until halfway, then deceleration 
  easeInOutQuint: function(e) {
    return e < 0.5 ? 16 * e * e * e * e * e : 1 + 16 * --e * e * e * e * e;
  }
};
var lk = {};
Object.defineProperty(lk, "__esModule", {
  value: !0
});
var Xue = Xp, Kue = ["mousedown", "wheel", "touchmove", "keydown"];
lk.default = {
  subscribe: function(e) {
    return typeof document < "u" && Kue.forEach(function(t) {
      return (0, Xue.addPassiveEventListener)(document, t, e);
    });
  }
};
var Yp = {};
Object.defineProperty(Yp, "__esModule", {
  value: !0
});
var tx = {
  registered: {},
  scrollEvent: {
    register: function(e, t) {
      tx.registered[e] = t;
    },
    remove: function(e) {
      tx.registered[e] = null;
    }
  }
};
Yp.default = tx;
Object.defineProperty(ey, "__esModule", {
  value: !0
});
var Yue = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, Jue = Kp;
ty(Jue);
var Que = ak, dT = ty(Que), ece = lk, tce = ty(ece), nce = Yp, Ni = ty(nce);
function ty(e) {
  return e && e.__esModule ? e : { default: e };
}
var OV = function(e) {
  return dT.default[e.smooth] || dT.default.defaultEasing;
}, rce = function(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}, oce = function() {
  if (typeof window < "u")
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame;
}, nx = function() {
  return oce() || function(e, t, n) {
    window.setTimeout(e, n || 1e3 / 60, (/* @__PURE__ */ new Date()).getTime());
  };
}(), EV = function() {
  return {
    currentPosition: 0,
    startPosition: 0,
    targetPosition: 0,
    progress: 0,
    duration: 0,
    cancel: !1,
    target: null,
    containerElement: null,
    to: null,
    start: null,
    delta: null,
    percent: null,
    delayTimeout: null
  };
}, kV = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollLeft;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageXOffset : r ? document.documentElement.scrollLeft : document.body.scrollLeft;
}, LV = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollTop;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageYOffset : r ? document.documentElement.scrollTop : document.body.scrollTop;
}, ice = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollWidth - t.offsetWidth;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollWidth, n.offsetWidth, r.clientWidth, r.scrollWidth, r.offsetWidth);
}, sce = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollHeight - t.offsetHeight;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollHeight, n.offsetHeight, r.clientHeight, r.scrollHeight, r.offsetHeight);
}, ace = function e(t, n, r) {
  var o = n.data;
  if (!n.ignoreCancelEvents && o.cancel) {
    Ni.default.registered.end && Ni.default.registered.end(o.to, o.target, o.currentPositionY);
    return;
  }
  if (o.delta = Math.round(o.targetPosition - o.startPosition), o.start === null && (o.start = r), o.progress = r - o.start, o.percent = o.progress >= o.duration ? 1 : t(o.progress / o.duration), o.currentPosition = o.startPosition + Math.ceil(o.delta * o.percent), o.containerElement && o.containerElement !== document && o.containerElement !== document.body ? n.horizontal ? o.containerElement.scrollLeft = o.currentPosition : o.containerElement.scrollTop = o.currentPosition : n.horizontal ? window.scrollTo(o.currentPosition, 0) : window.scrollTo(0, o.currentPosition), o.percent < 1) {
    var i = e.bind(null, t, n);
    nx.call(window, i);
    return;
  }
  Ni.default.registered.end && Ni.default.registered.end(o.to, o.target, o.currentPosition);
}, uk = function(e) {
  e.data.containerElement = e ? e.containerId ? document.getElementById(e.containerId) : e.container && e.container.nodeType ? e.container : document : null;
}, Jp = function(e, t, n, r) {
  t.data = t.data || EV(), window.clearTimeout(t.data.delayTimeout);
  var o = function() {
    t.data.cancel = !0;
  };
  if (tce.default.subscribe(o), uk(t), t.data.start = null, t.data.cancel = !1, t.data.startPosition = t.horizontal ? kV(t) : LV(t), t.data.targetPosition = t.absolute ? e : e + t.data.startPosition, t.data.startPosition === t.data.targetPosition) {
    Ni.default.registered.end && Ni.default.registered.end(t.data.to, t.data.target, t.data.currentPosition);
    return;
  }
  t.data.delta = Math.round(t.data.targetPosition - t.data.startPosition), t.data.duration = rce(t.duration)(t.data.delta), t.data.duration = isNaN(parseFloat(t.data.duration)) ? 1e3 : parseFloat(t.data.duration), t.data.to = n, t.data.target = r;
  var i = OV(t), a = ace.bind(null, i, t);
  if (t && t.delay > 0) {
    t.data.delayTimeout = window.setTimeout(function() {
      Ni.default.registered.begin && Ni.default.registered.begin(t.data.to, t.data.target), nx.call(window, a);
    }, t.delay);
    return;
  }
  Ni.default.registered.begin && Ni.default.registered.begin(t.data.to, t.data.target), nx.call(window, a);
}, ny = function(e) {
  return e = Yue({}, e), e.data = e.data || EV(), e.absolute = !0, e;
}, lce = function(e) {
  Jp(0, ny(e));
}, uce = function(e, t) {
  Jp(e, ny(t));
}, cce = function(e) {
  e = ny(e), uk(e), Jp(e.horizontal ? ice(e) : sce(e), e);
}, pce = function(e, t) {
  t = ny(t), uk(t);
  var n = t.horizontal ? kV(t) : LV(t);
  Jp(e + n, t);
};
ey.default = {
  animateTopScroll: Jp,
  getAnimationType: OV,
  scrollToTop: lce,
  scrollToBottom: cce,
  scrollTo: uce,
  scrollMore: pce
};
Object.defineProperty(wu, "__esModule", {
  value: !0
});
var dce = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, fce = Kp, hce = ck(fce), gce = ey, mce = ck(gce), vce = Yp, kf = ck(vce);
function ck(e) {
  return e && e.__esModule ? e : { default: e };
}
var Lf = {}, fT = void 0;
wu.default = {
  unmount: function() {
    Lf = {};
  },
  register: function(e, t) {
    Lf[e] = t;
  },
  unregister: function(e) {
    delete Lf[e];
  },
  get: function(e) {
    return Lf[e] || document.getElementById(e) || document.getElementsByName(e)[0] || document.getElementsByClassName(e)[0];
  },
  setActiveLink: function(e) {
    return fT = e;
  },
  getActiveLink: function() {
    return fT;
  },
  scrollTo: function(e, t) {
    var n = this.get(e);
    if (!n) {
      console.warn("target Element not found");
      return;
    }
    t = dce({}, t, { absolute: !1 });
    var r = t.containerId, o = t.container, i = void 0;
    r ? i = document.getElementById(r) : o && o.nodeType ? i = o : i = document, t.absolute = !0;
    var a = t.horizontal, s = hce.default.scrollOffset(i, n, a) + (t.offset || 0);
    if (!t.smooth) {
      kf.default.registered.begin && kf.default.registered.begin(e, n), i === document ? t.horizontal ? window.scrollTo(s, 0) : window.scrollTo(0, s) : i.scrollTop = s, kf.default.registered.end && kf.default.registered.end(e, n);
      return;
    }
    mce.default.animateTopScroll(s, t, e, n);
  }
};
var rx = { exports: {} }, qb = { exports: {} }, yn = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hT;
function yce() {
  if (hT) return yn;
  hT = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, h = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, m = e ? Symbol.for("react.block") : 60121, g = e ? Symbol.for("react.fundamental") : 60117, E = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
  function M(y) {
    if (typeof y == "object" && y !== null) {
      var C = y.$$typeof;
      switch (C) {
        case t:
          switch (y = y.type, y) {
            case l:
            case u:
            case r:
            case i:
            case o:
            case p:
              return y;
            default:
              switch (y = y && y.$$typeof, y) {
                case s:
                case c:
                case f:
                case h:
                case a:
                  return y;
                default:
                  return C;
              }
          }
        case n:
          return C;
      }
    }
  }
  function x(y) {
    return M(y) === u;
  }
  return yn.AsyncMode = l, yn.ConcurrentMode = u, yn.ContextConsumer = s, yn.ContextProvider = a, yn.Element = t, yn.ForwardRef = c, yn.Fragment = r, yn.Lazy = f, yn.Memo = h, yn.Portal = n, yn.Profiler = i, yn.StrictMode = o, yn.Suspense = p, yn.isAsyncMode = function(y) {
    return x(y) || M(y) === l;
  }, yn.isConcurrentMode = x, yn.isContextConsumer = function(y) {
    return M(y) === s;
  }, yn.isContextProvider = function(y) {
    return M(y) === a;
  }, yn.isElement = function(y) {
    return typeof y == "object" && y !== null && y.$$typeof === t;
  }, yn.isForwardRef = function(y) {
    return M(y) === c;
  }, yn.isFragment = function(y) {
    return M(y) === r;
  }, yn.isLazy = function(y) {
    return M(y) === f;
  }, yn.isMemo = function(y) {
    return M(y) === h;
  }, yn.isPortal = function(y) {
    return M(y) === n;
  }, yn.isProfiler = function(y) {
    return M(y) === i;
  }, yn.isStrictMode = function(y) {
    return M(y) === o;
  }, yn.isSuspense = function(y) {
    return M(y) === p;
  }, yn.isValidElementType = function(y) {
    return typeof y == "string" || typeof y == "function" || y === r || y === u || y === i || y === o || y === p || y === d || typeof y == "object" && y !== null && (y.$$typeof === f || y.$$typeof === h || y.$$typeof === a || y.$$typeof === s || y.$$typeof === c || y.$$typeof === g || y.$$typeof === E || y.$$typeof === w || y.$$typeof === m);
  }, yn.typeOf = M, yn;
}
var Pn = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var gT;
function bce() {
  return gT || (gT = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, h = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, m = e ? Symbol.for("react.block") : 60121, g = e ? Symbol.for("react.fundamental") : 60117, E = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
    function M(R) {
      return typeof R == "string" || typeof R == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      R === r || R === u || R === i || R === o || R === p || R === d || typeof R == "object" && R !== null && (R.$$typeof === f || R.$$typeof === h || R.$$typeof === a || R.$$typeof === s || R.$$typeof === c || R.$$typeof === g || R.$$typeof === E || R.$$typeof === w || R.$$typeof === m);
    }
    function x(R) {
      if (typeof R == "object" && R !== null) {
        var ue = R.$$typeof;
        switch (ue) {
          case t:
            var fe = R.type;
            switch (fe) {
              case l:
              case u:
              case r:
              case i:
              case o:
              case p:
                return fe;
              default:
                var oe = fe && fe.$$typeof;
                switch (oe) {
                  case s:
                  case c:
                  case f:
                  case h:
                  case a:
                    return oe;
                  default:
                    return ue;
                }
            }
          case n:
            return ue;
        }
      }
    }
    var y = l, C = u, P = s, F = a, L = t, N = c, I = r, H = f, V = h, z = n, q = i, K = o, J = p, te = !1;
    function ee(R) {
      return te || (te = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), _(R) || x(R) === l;
    }
    function _(R) {
      return x(R) === u;
    }
    function D(R) {
      return x(R) === s;
    }
    function $(R) {
      return x(R) === a;
    }
    function S(R) {
      return typeof R == "object" && R !== null && R.$$typeof === t;
    }
    function W(R) {
      return x(R) === c;
    }
    function O(R) {
      return x(R) === r;
    }
    function T(R) {
      return x(R) === f;
    }
    function U(R) {
      return x(R) === h;
    }
    function j(R) {
      return x(R) === n;
    }
    function Z(R) {
      return x(R) === i;
    }
    function A(R) {
      return x(R) === o;
    }
    function Q(R) {
      return x(R) === p;
    }
    Pn.AsyncMode = y, Pn.ConcurrentMode = C, Pn.ContextConsumer = P, Pn.ContextProvider = F, Pn.Element = L, Pn.ForwardRef = N, Pn.Fragment = I, Pn.Lazy = H, Pn.Memo = V, Pn.Portal = z, Pn.Profiler = q, Pn.StrictMode = K, Pn.Suspense = J, Pn.isAsyncMode = ee, Pn.isConcurrentMode = _, Pn.isContextConsumer = D, Pn.isContextProvider = $, Pn.isElement = S, Pn.isForwardRef = W, Pn.isFragment = O, Pn.isLazy = T, Pn.isMemo = U, Pn.isPortal = j, Pn.isProfiler = Z, Pn.isStrictMode = A, Pn.isSuspense = Q, Pn.isValidElementType = M, Pn.typeOf = x;
  }()), Pn;
}
var mT;
function _V() {
  return mT || (mT = 1, process.env.NODE_ENV === "production" ? qb.exports = yce() : qb.exports = bce()), qb.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var Zb, vT;
function wce() {
  if (vT) return Zb;
  vT = 1;
  var e = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, n = Object.prototype.propertyIsEnumerable;
  function r(i) {
    if (i == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(i);
  }
  function o() {
    try {
      if (!Object.assign)
        return !1;
      var i = new String("abc");
      if (i[5] = "de", Object.getOwnPropertyNames(i)[0] === "5")
        return !1;
      for (var a = {}, s = 0; s < 10; s++)
        a["_" + String.fromCharCode(s)] = s;
      var l = Object.getOwnPropertyNames(a).map(function(c) {
        return a[c];
      });
      if (l.join("") !== "0123456789")
        return !1;
      var u = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(c) {
        u[c] = c;
      }), Object.keys(Object.assign({}, u)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return Zb = o() ? Object.assign : function(i, a) {
    for (var s, l = r(i), u, c = 1; c < arguments.length; c++) {
      s = Object(arguments[c]);
      for (var p in s)
        t.call(s, p) && (l[p] = s[p]);
      if (e) {
        u = e(s);
        for (var d = 0; d < u.length; d++)
          n.call(s, u[d]) && (l[u[d]] = s[u[d]]);
      }
    }
    return l;
  }, Zb;
}
var Gb, yT;
function pk() {
  if (yT) return Gb;
  yT = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return Gb = e, Gb;
}
var bT, wT;
function PV() {
  return wT || (wT = 1, bT = Function.call.bind(Object.prototype.hasOwnProperty)), bT;
}
var Xb, CT;
function Cce() {
  if (CT) return Xb;
  CT = 1;
  var e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = pk(), n = {}, r = PV();
    e = function(i) {
      var a = "Warning: " + i;
      typeof console < "u" && console.error(a);
      try {
        throw new Error(a);
      } catch {
      }
    };
  }
  function o(i, a, s, l, u) {
    if (process.env.NODE_ENV !== "production") {
      for (var c in i)
        if (r(i, c)) {
          var p;
          try {
            if (typeof i[c] != "function") {
              var d = Error(
                (l || "React class") + ": " + s + " type `" + c + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof i[c] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw d.name = "Invariant Violation", d;
            }
            p = i[c](a, c, l, s, null, t);
          } catch (f) {
            p = f;
          }
          if (p && !(p instanceof Error) && e(
            (l || "React class") + ": type specification of " + s + " `" + c + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof p + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), p instanceof Error && !(p.message in n)) {
            n[p.message] = !0;
            var h = u ? u() : "";
            e(
              "Failed " + s + " type: " + p.message + (h ?? "")
            );
          }
        }
    }
  }
  return o.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (n = {});
  }, Xb = o, Xb;
}
var Kb, xT;
function xce() {
  if (xT) return Kb;
  xT = 1;
  var e = _V(), t = wce(), n = pk(), r = PV(), o = Cce(), i = function() {
  };
  process.env.NODE_ENV !== "production" && (i = function(s) {
    var l = "Warning: " + s;
    typeof console < "u" && console.error(l);
    try {
      throw new Error(l);
    } catch {
    }
  });
  function a() {
    return null;
  }
  return Kb = function(s, l) {
    var u = typeof Symbol == "function" && Symbol.iterator, c = "@@iterator";
    function p(_) {
      var D = _ && (u && _[u] || _[c]);
      if (typeof D == "function")
        return D;
    }
    var d = "<<anonymous>>", h = {
      array: E("array"),
      bigint: E("bigint"),
      bool: E("boolean"),
      func: E("function"),
      number: E("number"),
      object: E("object"),
      string: E("string"),
      symbol: E("symbol"),
      any: w(),
      arrayOf: M,
      element: x(),
      elementType: y(),
      instanceOf: C,
      node: N(),
      objectOf: F,
      oneOf: P,
      oneOfType: L,
      shape: H,
      exact: V
    };
    function f(_, D) {
      return _ === D ? _ !== 0 || 1 / _ === 1 / D : _ !== _ && D !== D;
    }
    function m(_, D) {
      this.message = _, this.data = D && typeof D == "object" ? D : {}, this.stack = "";
    }
    m.prototype = Error.prototype;
    function g(_) {
      if (process.env.NODE_ENV !== "production")
        var D = {}, $ = 0;
      function S(O, T, U, j, Z, A, Q) {
        if (j = j || d, A = A || U, Q !== n) {
          if (l) {
            var R = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw R.name = "Invariant Violation", R;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var ue = j + ":" + U;
            !D[ue] && // Avoid spamming the console because they are often not actionable except for lib authors
            $ < 3 && (i(
              "You are manually calling a React.PropTypes validation function for the `" + A + "` prop on `" + j + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), D[ue] = !0, $++);
          }
        }
        return T[U] == null ? O ? T[U] === null ? new m("The " + Z + " `" + A + "` is marked as required " + ("in `" + j + "`, but its value is `null`.")) : new m("The " + Z + " `" + A + "` is marked as required in " + ("`" + j + "`, but its value is `undefined`.")) : null : _(T, U, j, Z, A);
      }
      var W = S.bind(null, !1);
      return W.isRequired = S.bind(null, !0), W;
    }
    function E(_) {
      function D($, S, W, O, T, U) {
        var j = $[S], Z = K(j);
        if (Z !== _) {
          var A = J(j);
          return new m(
            "Invalid " + O + " `" + T + "` of type " + ("`" + A + "` supplied to `" + W + "`, expected ") + ("`" + _ + "`."),
            { expectedType: _ }
          );
        }
        return null;
      }
      return g(D);
    }
    function w() {
      return g(a);
    }
    function M(_) {
      function D($, S, W, O, T) {
        if (typeof _ != "function")
          return new m("Property `" + T + "` of component `" + W + "` has invalid PropType notation inside arrayOf.");
        var U = $[S];
        if (!Array.isArray(U)) {
          var j = K(U);
          return new m("Invalid " + O + " `" + T + "` of type " + ("`" + j + "` supplied to `" + W + "`, expected an array."));
        }
        for (var Z = 0; Z < U.length; Z++) {
          var A = _(U, Z, W, O, T + "[" + Z + "]", n);
          if (A instanceof Error)
            return A;
        }
        return null;
      }
      return g(D);
    }
    function x() {
      function _(D, $, S, W, O) {
        var T = D[$];
        if (!s(T)) {
          var U = K(T);
          return new m("Invalid " + W + " `" + O + "` of type " + ("`" + U + "` supplied to `" + S + "`, expected a single ReactElement."));
        }
        return null;
      }
      return g(_);
    }
    function y() {
      function _(D, $, S, W, O) {
        var T = D[$];
        if (!e.isValidElementType(T)) {
          var U = K(T);
          return new m("Invalid " + W + " `" + O + "` of type " + ("`" + U + "` supplied to `" + S + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return g(_);
    }
    function C(_) {
      function D($, S, W, O, T) {
        if (!($[S] instanceof _)) {
          var U = _.name || d, j = ee($[S]);
          return new m("Invalid " + O + " `" + T + "` of type " + ("`" + j + "` supplied to `" + W + "`, expected ") + ("instance of `" + U + "`."));
        }
        return null;
      }
      return g(D);
    }
    function P(_) {
      if (!Array.isArray(_))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? i(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : i("Invalid argument supplied to oneOf, expected an array.")), a;
      function D($, S, W, O, T) {
        for (var U = $[S], j = 0; j < _.length; j++)
          if (f(U, _[j]))
            return null;
        var Z = JSON.stringify(_, function(A, Q) {
          var R = J(Q);
          return R === "symbol" ? String(Q) : Q;
        });
        return new m("Invalid " + O + " `" + T + "` of value `" + String(U) + "` " + ("supplied to `" + W + "`, expected one of " + Z + "."));
      }
      return g(D);
    }
    function F(_) {
      function D($, S, W, O, T) {
        if (typeof _ != "function")
          return new m("Property `" + T + "` of component `" + W + "` has invalid PropType notation inside objectOf.");
        var U = $[S], j = K(U);
        if (j !== "object")
          return new m("Invalid " + O + " `" + T + "` of type " + ("`" + j + "` supplied to `" + W + "`, expected an object."));
        for (var Z in U)
          if (r(U, Z)) {
            var A = _(U, Z, W, O, T + "." + Z, n);
            if (A instanceof Error)
              return A;
          }
        return null;
      }
      return g(D);
    }
    function L(_) {
      if (!Array.isArray(_))
        return process.env.NODE_ENV !== "production" && i("Invalid argument supplied to oneOfType, expected an instance of array."), a;
      for (var D = 0; D < _.length; D++) {
        var $ = _[D];
        if (typeof $ != "function")
          return i(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + te($) + " at index " + D + "."
          ), a;
      }
      function S(W, O, T, U, j) {
        for (var Z = [], A = 0; A < _.length; A++) {
          var Q = _[A], R = Q(W, O, T, U, j, n);
          if (R == null)
            return null;
          R.data && r(R.data, "expectedType") && Z.push(R.data.expectedType);
        }
        var ue = Z.length > 0 ? ", expected one of type [" + Z.join(", ") + "]" : "";
        return new m("Invalid " + U + " `" + j + "` supplied to " + ("`" + T + "`" + ue + "."));
      }
      return g(S);
    }
    function N() {
      function _(D, $, S, W, O) {
        return z(D[$]) ? null : new m("Invalid " + W + " `" + O + "` supplied to " + ("`" + S + "`, expected a ReactNode."));
      }
      return g(_);
    }
    function I(_, D, $, S, W) {
      return new m(
        (_ || "React class") + ": " + D + " type `" + $ + "." + S + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + W + "`."
      );
    }
    function H(_) {
      function D($, S, W, O, T) {
        var U = $[S], j = K(U);
        if (j !== "object")
          return new m("Invalid " + O + " `" + T + "` of type `" + j + "` " + ("supplied to `" + W + "`, expected `object`."));
        for (var Z in _) {
          var A = _[Z];
          if (typeof A != "function")
            return I(W, O, T, Z, J(A));
          var Q = A(U, Z, W, O, T + "." + Z, n);
          if (Q)
            return Q;
        }
        return null;
      }
      return g(D);
    }
    function V(_) {
      function D($, S, W, O, T) {
        var U = $[S], j = K(U);
        if (j !== "object")
          return new m("Invalid " + O + " `" + T + "` of type `" + j + "` " + ("supplied to `" + W + "`, expected `object`."));
        var Z = t({}, $[S], _);
        for (var A in Z) {
          var Q = _[A];
          if (r(_, A) && typeof Q != "function")
            return I(W, O, T, A, J(Q));
          if (!Q)
            return new m(
              "Invalid " + O + " `" + T + "` key `" + A + "` supplied to `" + W + "`.\nBad object: " + JSON.stringify($[S], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(_), null, "  ")
            );
          var R = Q(U, A, W, O, T + "." + A, n);
          if (R)
            return R;
        }
        return null;
      }
      return g(D);
    }
    function z(_) {
      switch (typeof _) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !_;
        case "object":
          if (Array.isArray(_))
            return _.every(z);
          if (_ === null || s(_))
            return !0;
          var D = p(_);
          if (D) {
            var $ = D.call(_), S;
            if (D !== _.entries) {
              for (; !(S = $.next()).done; )
                if (!z(S.value))
                  return !1;
            } else
              for (; !(S = $.next()).done; ) {
                var W = S.value;
                if (W && !z(W[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function q(_, D) {
      return _ === "symbol" ? !0 : D ? D["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && D instanceof Symbol : !1;
    }
    function K(_) {
      var D = typeof _;
      return Array.isArray(_) ? "array" : _ instanceof RegExp ? "object" : q(D, _) ? "symbol" : D;
    }
    function J(_) {
      if (typeof _ > "u" || _ === null)
        return "" + _;
      var D = K(_);
      if (D === "object") {
        if (_ instanceof Date)
          return "date";
        if (_ instanceof RegExp)
          return "regexp";
      }
      return D;
    }
    function te(_) {
      var D = J(_);
      switch (D) {
        case "array":
        case "object":
          return "an " + D;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + D;
        default:
          return D;
      }
    }
    function ee(_) {
      return !_.constructor || !_.constructor.name ? d : _.constructor.name;
    }
    return h.checkPropTypes = o, h.resetWarningCache = o.resetWarningCache, h.PropTypes = h, h;
  }, Kb;
}
var Yb, OT;
function Oce() {
  if (OT) return Yb;
  OT = 1;
  var e = pk();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, Yb = function() {
    function r(a, s, l, u, c, p) {
      if (p !== e) {
        var d = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw d.name = "Invariant Violation", d;
      }
    }
    r.isRequired = r;
    function o() {
      return r;
    }
    var i = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: o,
      element: r,
      elementType: r,
      instanceOf: o,
      node: r,
      objectOf: o,
      oneOf: o,
      oneOfType: o,
      shape: o,
      exact: o,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return i.PropTypes = i, i;
  }, Yb;
}
if (process.env.NODE_ENV !== "production") {
  var Ece = _V(), kce = !0;
  rx.exports = xce()(Ece.isElement, kce);
} else
  rx.exports = Oce()();
var ry = rx.exports, oy = {};
Object.defineProperty(oy, "__esModule", {
  value: !0
});
var Lce = Kp, Jb = _ce(Lce);
function _ce(e) {
  return e && e.__esModule ? e : { default: e };
}
var Pce = {
  mountFlag: !1,
  initialized: !1,
  scroller: null,
  containers: {},
  mount: function(e) {
    this.scroller = e, this.handleHashChange = this.handleHashChange.bind(this), window.addEventListener("hashchange", this.handleHashChange), this.initStateFromHash(), this.mountFlag = !0;
  },
  mapContainer: function(e, t) {
    this.containers[e] = t;
  },
  isMounted: function() {
    return this.mountFlag;
  },
  isInitialized: function() {
    return this.initialized;
  },
  initStateFromHash: function() {
    var e = this, t = this.getHash();
    t ? window.setTimeout(function() {
      e.scrollTo(t, !0), e.initialized = !0;
    }, 10) : this.initialized = !0;
  },
  scrollTo: function(e, t) {
    var n = this.scroller, r = n.get(e);
    if (r && (t || e !== n.getActiveLink())) {
      var o = this.containers[e] || document;
      n.scrollTo(e, { container: o });
    }
  },
  getHash: function() {
    return Jb.default.getHash();
  },
  changeHash: function(e, t) {
    this.isInitialized() && Jb.default.getHash() !== e && Jb.default.updateHash(e, t);
  },
  handleHashChange: function() {
    this.scrollTo(this.getHash());
  },
  unmount: function() {
    this.scroller = null, this.containers = null, window.removeEventListener("hashchange", this.handleHashChange);
  }
};
oy.default = Pce;
Object.defineProperty(Zp, "__esModule", {
  value: !0
});
var _f = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, Sce = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), Mce = ke, ET = Qp(Mce), Dce = Gp, Pf = Qp(Dce), Tce = wu, jce = Qp(Tce), Ace = ry, ur = Qp(Ace), Bce = oy, As = Qp(Bce);
function Qp(e) {
  return e && e.__esModule ? e : { default: e };
}
function Ice(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Rce(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function Nce(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var kT = {
  to: ur.default.string.isRequired,
  containerId: ur.default.string,
  container: ur.default.object,
  activeClass: ur.default.string,
  activeStyle: ur.default.object,
  spy: ur.default.bool,
  horizontal: ur.default.bool,
  smooth: ur.default.oneOfType([ur.default.bool, ur.default.string]),
  offset: ur.default.number,
  delay: ur.default.number,
  isDynamic: ur.default.bool,
  onClick: ur.default.func,
  duration: ur.default.oneOfType([ur.default.number, ur.default.func]),
  absolute: ur.default.bool,
  onSetActive: ur.default.func,
  onSetInactive: ur.default.func,
  ignoreCancelEvents: ur.default.bool,
  hashSpy: ur.default.bool,
  saveHashHistory: ur.default.bool,
  spyThrottle: ur.default.number
};
Zp.default = function(e, t) {
  var n = t || jce.default, r = function(i) {
    Nce(a, i);
    function a(s) {
      Ice(this, a);
      var l = Rce(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
      return o.call(l), l.state = {
        active: !1
      }, l.beforeUnmountCallbacks = [], l;
    }
    return Sce(a, [{
      key: "getScrollSpyContainer",
      value: function() {
        var s = this.props.containerId, l = this.props.container;
        return s && !l ? document.getElementById(s) : l && l.nodeType ? l : document;
      }
    }, {
      key: "componentDidMount",
      value: function() {
        if (this.props.spy || this.props.hashSpy) {
          var s = this.getScrollSpyContainer();
          if (!Pf.default.isMounted(s)) {
            var l = Pf.default.mount(s, this.props.spyThrottle);
            this.beforeUnmountCallbacks.push(l);
          }
          this.props.hashSpy && (As.default.isMounted() || As.default.mount(n), As.default.mapContainer(this.props.to, s)), Pf.default.addSpyHandler(this.spyHandler, s), this.setState({
            container: s
          });
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        Pf.default.unmount(this.stateHandler, this.spyHandler), this.beforeUnmountCallbacks.forEach(function(s) {
          return s();
        });
      }
    }, {
      key: "render",
      value: function() {
        var s = "";
        this.state && this.state.active ? s = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : s = this.props.className;
        var l = {};
        this.state && this.state.active ? l = _f({}, this.props.style, this.props.activeStyle) : l = _f({}, this.props.style);
        var u = _f({}, this.props);
        for (var c in kT)
          u.hasOwnProperty(c) && delete u[c];
        return u.className = s, u.style = l, u.onClick = this.handleClick, ET.default.createElement(e, u);
      }
    }]), a;
  }(ET.default.PureComponent), o = function() {
    var i = this;
    this.scrollTo = function(a, s) {
      n.scrollTo(a, _f({}, i.state, s));
    }, this.handleClick = function(a) {
      i.props.onClick && i.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), i.scrollTo(i.props.to, i.props);
    }, this.spyHandler = function(a, s) {
      var l = i.getScrollSpyContainer();
      if (!(As.default.isMounted() && !As.default.isInitialized())) {
        var u = i.props.horizontal, c = i.props.to, p = null, d = void 0, h = void 0;
        if (u) {
          var f = 0, m = 0, g = 0;
          if (l.getBoundingClientRect) {
            var E = l.getBoundingClientRect();
            g = E.left;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var w = p.getBoundingClientRect();
            f = w.left - g + a, m = f + w.width;
          }
          var M = a - i.props.offset;
          d = M >= Math.floor(f) && M < Math.floor(m), h = M < Math.floor(f) || M >= Math.floor(m);
        } else {
          var x = 0, y = 0, C = 0;
          if (l.getBoundingClientRect) {
            var P = l.getBoundingClientRect();
            C = P.top;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var F = p.getBoundingClientRect();
            x = F.top - C + s, y = x + F.height;
          }
          var L = s - i.props.offset;
          d = L >= Math.floor(x) && L < Math.floor(y), h = L < Math.floor(x) || L >= Math.floor(y);
        }
        var N = n.getActiveLink();
        if (h) {
          if (c === N && n.setActiveLink(void 0), i.props.hashSpy && As.default.getHash() === c) {
            var I = i.props.saveHashHistory, H = I === void 0 ? !1 : I;
            As.default.changeHash("", H);
          }
          i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive(c, p));
        }
        if (d && (N !== c || i.state.active === !1)) {
          n.setActiveLink(c);
          var V = i.props.saveHashHistory, z = V === void 0 ? !1 : V;
          i.props.hashSpy && As.default.changeHash(c, z), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(c, p));
        }
      }
    };
  };
  return r.propTypes = kT, r.defaultProps = { offset: 0 }, r;
};
Object.defineProperty(sk, "__esModule", {
  value: !0
});
var Fce = ke, LT = SV(Fce), zce = Zp, Uce = SV(zce);
function SV(e) {
  return e && e.__esModule ? e : { default: e };
}
function $ce(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function _T(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function Hce(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var Wce = function(e) {
  Hce(t, e);
  function t() {
    var n, r, o, i;
    $ce(this, t);
    for (var a = arguments.length, s = Array(a), l = 0; l < a; l++)
      s[l] = arguments[l];
    return i = (r = (o = _T(this, (n = t.__proto__ || Object.getPrototypeOf(t)).call.apply(n, [this].concat(s))), o), o.render = function() {
      return LT.default.createElement(
        "a",
        o.props,
        o.props.children
      );
    }, r), _T(o, i);
  }
  return t;
}(LT.default.Component);
sk.default = (0, Uce.default)(Wce);
var dk = {};
Object.defineProperty(dk, "__esModule", {
  value: !0
});
var Vce = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), qce = ke, PT = MV(qce), Zce = Zp, Gce = MV(Zce);
function MV(e) {
  return e && e.__esModule ? e : { default: e };
}
function Xce(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Kce(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function Yce(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var Jce = function(e) {
  Yce(t, e);
  function t() {
    return Xce(this, t), Kce(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return Vce(t, [{
    key: "render",
    value: function() {
      return PT.default.createElement(
        "button",
        this.props,
        this.props.children
      );
    }
  }]), t;
}(PT.default.Component);
dk.default = (0, Gce.default)(Jce);
var fk = {}, iy = {};
Object.defineProperty(iy, "__esModule", {
  value: !0
});
var Qce = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, epe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), tpe = ke, ST = sy(tpe), npe = Rl;
sy(npe);
var rpe = wu, MT = sy(rpe), ope = ry, DT = sy(ope);
function sy(e) {
  return e && e.__esModule ? e : { default: e };
}
function ipe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function spe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function ape(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
iy.default = function(e) {
  var t = function(n) {
    ape(r, n);
    function r(o) {
      ipe(this, r);
      var i = spe(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
      return i.childBindings = {
        domNode: null
      }, i;
    }
    return epe(r, [{
      key: "componentDidMount",
      value: function() {
        if (typeof window > "u")
          return !1;
        this.registerElems(this.props.name);
      }
    }, {
      key: "componentDidUpdate",
      value: function(o) {
        this.props.name !== o.name && this.registerElems(this.props.name);
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        if (typeof window > "u")
          return !1;
        MT.default.unregister(this.props.name);
      }
    }, {
      key: "registerElems",
      value: function(o) {
        MT.default.register(o, this.childBindings.domNode);
      }
    }, {
      key: "render",
      value: function() {
        return ST.default.createElement(e, Qce({}, this.props, { parentBindings: this.childBindings }));
      }
    }]), r;
  }(ST.default.Component);
  return t.propTypes = {
    name: DT.default.string,
    id: DT.default.string
  }, t;
};
Object.defineProperty(fk, "__esModule", {
  value: !0
});
var TT = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, lpe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), upe = ke, jT = hk(upe), cpe = iy, ppe = hk(cpe), dpe = ry, AT = hk(dpe);
function hk(e) {
  return e && e.__esModule ? e : { default: e };
}
function fpe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function hpe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function gpe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var DV = function(e) {
  gpe(t, e);
  function t() {
    return fpe(this, t), hpe(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return lpe(t, [{
    key: "render",
    value: function() {
      var n = this, r = TT({}, this.props);
      return delete r.name, r.parentBindings && delete r.parentBindings, jT.default.createElement(
        "div",
        TT({}, r, { ref: function(o) {
          n.props.parentBindings.domNode = o;
        } }),
        this.props.children
      );
    }
  }]), t;
}(jT.default.Component);
DV.propTypes = {
  name: AT.default.string,
  id: AT.default.string
};
fk.default = (0, ppe.default)(DV);
var Qb = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, BT = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}();
function IT(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function RT(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function NT(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var Sf = ke, Ia = Gp, e0 = wu, Sr = ry, Bs = oy, FT = {
  to: Sr.string.isRequired,
  containerId: Sr.string,
  container: Sr.object,
  activeClass: Sr.string,
  spy: Sr.bool,
  smooth: Sr.oneOfType([Sr.bool, Sr.string]),
  offset: Sr.number,
  delay: Sr.number,
  isDynamic: Sr.bool,
  onClick: Sr.func,
  duration: Sr.oneOfType([Sr.number, Sr.func]),
  absolute: Sr.bool,
  onSetActive: Sr.func,
  onSetInactive: Sr.func,
  ignoreCancelEvents: Sr.bool,
  hashSpy: Sr.bool,
  spyThrottle: Sr.number
}, mpe = {
  Scroll: function(e, t) {
    console.warn("Helpers.Scroll is deprecated since v1.7.0");
    var n = t || e0, r = function(i) {
      NT(a, i);
      function a(s) {
        IT(this, a);
        var l = RT(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
        return o.call(l), l.state = {
          active: !1
        }, l;
      }
      return BT(a, [{
        key: "getScrollSpyContainer",
        value: function() {
          var s = this.props.containerId, l = this.props.container;
          return s ? document.getElementById(s) : l && l.nodeType ? l : document;
        }
      }, {
        key: "componentDidMount",
        value: function() {
          if (this.props.spy || this.props.hashSpy) {
            var s = this.getScrollSpyContainer();
            Ia.isMounted(s) || Ia.mount(s, this.props.spyThrottle), this.props.hashSpy && (Bs.isMounted() || Bs.mount(n), Bs.mapContainer(this.props.to, s)), this.props.spy && Ia.addStateHandler(this.stateHandler), Ia.addSpyHandler(this.spyHandler, s), this.setState({
              container: s
            });
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          Ia.unmount(this.stateHandler, this.spyHandler);
        }
      }, {
        key: "render",
        value: function() {
          var s = "";
          this.state && this.state.active ? s = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : s = this.props.className;
          var l = Qb({}, this.props);
          for (var u in FT)
            l.hasOwnProperty(u) && delete l[u];
          return l.className = s, l.onClick = this.handleClick, Sf.createElement(e, l);
        }
      }]), a;
    }(Sf.Component), o = function() {
      var i = this;
      this.scrollTo = function(a, s) {
        n.scrollTo(a, Qb({}, i.state, s));
      }, this.handleClick = function(a) {
        i.props.onClick && i.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), i.scrollTo(i.props.to, i.props);
      }, this.stateHandler = function() {
        n.getActiveLink() !== i.props.to && (i.state !== null && i.state.active && i.props.onSetInactive && i.props.onSetInactive(), i.setState({ active: !1 }));
      }, this.spyHandler = function(a) {
        var s = i.getScrollSpyContainer();
        if (!(Bs.isMounted() && !Bs.isInitialized())) {
          var l = i.props.to, u = null, c = 0, p = 0, d = 0;
          if (s.getBoundingClientRect) {
            var h = s.getBoundingClientRect();
            d = h.top;
          }
          if (!u || i.props.isDynamic) {
            if (u = n.get(l), !u)
              return;
            var f = u.getBoundingClientRect();
            c = f.top - d + a, p = c + f.height;
          }
          var m = a - i.props.offset, g = m >= Math.floor(c) && m < Math.floor(p), E = m < Math.floor(c) || m >= Math.floor(p), w = n.getActiveLink();
          if (E)
            return l === w && n.setActiveLink(void 0), i.props.hashSpy && Bs.getHash() === l && Bs.changeHash(), i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive()), Ia.updateStates();
          if (g && w !== l)
            return n.setActiveLink(l), i.props.hashSpy && Bs.changeHash(l), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(l)), Ia.updateStates();
        }
      };
    };
    return r.propTypes = FT, r.defaultProps = { offset: 0 }, r;
  },
  Element: function(e) {
    console.warn("Helpers.Element is deprecated since v1.7.0");
    var t = function(n) {
      NT(r, n);
      function r(o) {
        IT(this, r);
        var i = RT(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
        return i.childBindings = {
          domNode: null
        }, i;
      }
      return BT(r, [{
        key: "componentDidMount",
        value: function() {
          if (typeof window > "u")
            return !1;
          this.registerElems(this.props.name);
        }
      }, {
        key: "componentDidUpdate",
        value: function(o) {
          this.props.name !== o.name && this.registerElems(this.props.name);
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          if (typeof window > "u")
            return !1;
          e0.unregister(this.props.name);
        }
      }, {
        key: "registerElems",
        value: function(o) {
          e0.register(o, this.childBindings.domNode);
        }
      }, {
        key: "render",
        value: function() {
          return Sf.createElement(e, Qb({}, this.props, { parentBindings: this.childBindings }));
        }
      }]), r;
    }(Sf.Component);
    return t.propTypes = {
      name: Sr.string,
      id: Sr.string
    }, t;
  }
}, vpe = mpe;
Object.defineProperty(zr, "__esModule", {
  value: !0
});
zr.Helpers = zr.ScrollElement = zr.ScrollLink = zr.animateScroll = zr.scrollSpy = zr.Events = zr.scroller = zr.Element = zr.Button = zr.Link = void 0;
var ype = sk, TV = Ki(ype), bpe = dk, jV = Ki(bpe), wpe = fk, AV = Ki(wpe), Cpe = wu, BV = Ki(Cpe), xpe = Yp, IV = Ki(xpe), Ope = Gp, RV = Ki(Ope), Epe = ey, NV = Ki(Epe), kpe = Zp, FV = Ki(kpe), Lpe = iy, zV = Ki(Lpe), _pe = vpe, UV = Ki(_pe);
function Ki(e) {
  return e && e.__esModule ? e : { default: e };
}
zr.Link = TV.default;
zr.Button = jV.default;
zr.Element = AV.default;
zr.scroller = BV.default;
zr.Events = IV.default;
zr.scrollSpy = RV.default;
zr.animateScroll = NV.default;
zr.ScrollLink = FV.default;
zr.ScrollElement = zV.default;
zr.Helpers = UV.default;
zr.default = { Link: TV.default, Button: jV.default, Element: AV.default, scroller: BV.default, Events: IV.default, scrollSpy: RV.default, animateScroll: NV.default, ScrollLink: FV.default, ScrollElement: zV.default, Helpers: UV.default };
Ze({});
Ze({});
Ze({});
function _p(e) {
  "@babel/helpers - typeof";
  return _p = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, _p(e);
}
function Ppe(e, t) {
  if (_p(e) != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (_p(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function Spe(e) {
  var t = Ppe(e, "string");
  return _p(t) == "symbol" ? t : t + "";
}
function we(e, t, n) {
  return (t = Spe(t)) in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function $V(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var t0, zT;
function Mpe() {
  if (zT) return t0;
  zT = 1;
  var e = process.env.NODE_ENV, t = function(n, r, o, i, a, s, l, u) {
    if (e !== "production" && r === void 0)
      throw new Error("invariant requires an error message argument");
    if (!n) {
      var c;
      if (r === void 0)
        c = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
      else {
        var p = [o, i, a, s, l, u], d = 0;
        c = new Error(r.replace(/%s/g, function() {
          return p[d++];
        })), c.name = "Invariant Violation";
      }
      throw c.framesToPop = 1, c;
    }
  };
  return t0 = t, t0;
}
var Dpe = Mpe(), Zr = /* @__PURE__ */ $V(Dpe), St = Ze(null);
function Tpe() {
  Zr(!!ye, "useGoogleMap is React hook and requires React version 16.8+");
  var e = ye(St);
  return Zr(!!e, "useGoogleMap needs a GoogleMap available up in the tree"), e;
}
function jpe(e, t, n) {
  return Object.keys(e).reduce(function(r, o) {
    return t(r, e[o], o);
  }, n);
}
function Ape(e, t) {
  Object.keys(e).forEach((n) => t(e[n], n));
}
function Bpe(e, t, n, r) {
  var o = {}, i = (a, s) => {
    var l = n[s];
    l !== t[s] && (o[s] = l, a(r, l));
  };
  return Ape(e, i), o;
}
function Ipe(e, t, n) {
  var r = jpe(n, function(o, i, a) {
    return typeof e[a] == "function" && o.push(google.maps.event.addListener(t, i, e[a])), o;
  }, []);
  return r;
}
function Rpe(e) {
  google.maps.event.removeListener(e);
}
function sn() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  e.forEach(Rpe);
}
function Qt(e) {
  var {
    updaterMap: t,
    eventMap: n,
    prevProps: r,
    nextProps: o,
    instance: i
  } = e, a = Ipe(o, i, n);
  return Bpe(t, r, o, i), a;
}
function Npe(e) {
  var {
    children: t,
    options: n,
    id: r,
    mapContainerStyle: o,
    mapContainerClassName: i,
    center: a,
    // clickableIcons,
    // extraMapTypes,
    // heading,
    // mapTypeId,
    onClick: s,
    onDblClick: l,
    onDrag: u,
    onDragEnd: c,
    onDragStart: p,
    onMouseMove: d,
    onMouseOut: h,
    onMouseOver: f,
    onMouseDown: m,
    onMouseUp: g,
    onRightClick: E,
    // onMapTypeIdChanged,
    // onTilesLoaded,
    // onBoundsChanged,
    onCenterChanged: w,
    // onHeadingChanged,
    // onIdle,
    // onProjectionChanged,
    // onResize,
    // onTiltChanged,
    // onZoomChanged,
    onLoad: M,
    onUnmount: x
  } = e, [y, C] = k(null), P = rt(null), [F, L] = k(null), [N, I] = k(null), [H, V] = k(null), [z, q] = k(null), [K, J] = k(null), [te, ee] = k(null), [_, D] = k(null), [$, S] = k(null), [W, O] = k(null), [T, U] = k(null), [j, Z] = k(null), [A, Q] = k(null);
  return v(() => {
    n && y !== null && y.setOptions(n);
  }, [y, n]), v(() => {
    y !== null && typeof a < "u" && y.setCenter(a);
  }, [y, a]), v(() => {
    y && l && (N !== null && google.maps.event.removeListener(N), I(google.maps.event.addListener(y, "dblclick", l)));
  }, [l]), v(() => {
    y && c && (H !== null && google.maps.event.removeListener(H), V(google.maps.event.addListener(y, "dragend", c)));
  }, [c]), v(() => {
    y && p && (z !== null && google.maps.event.removeListener(z), q(google.maps.event.addListener(y, "dragstart", p)));
  }, [p]), v(() => {
    y && m && (K !== null && google.maps.event.removeListener(K), J(google.maps.event.addListener(y, "mousedown", m)));
  }, [m]), v(() => {
    y && d && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(y, "mousemove", d)));
  }, [d]), v(() => {
    y && h && (_ !== null && google.maps.event.removeListener(_), D(google.maps.event.addListener(y, "mouseout", h)));
  }, [h]), v(() => {
    y && f && ($ !== null && google.maps.event.removeListener($), S(google.maps.event.addListener(y, "mouseover", f)));
  }, [f]), v(() => {
    y && g && (W !== null && google.maps.event.removeListener(W), O(google.maps.event.addListener(y, "mouseup", g)));
  }, [g]), v(() => {
    y && E && (T !== null && google.maps.event.removeListener(T), U(google.maps.event.addListener(y, "rightclick", E)));
  }, [E]), v(() => {
    y && s && (j !== null && google.maps.event.removeListener(j), Z(google.maps.event.addListener(y, "click", s)));
  }, [s]), v(() => {
    y && u && (A !== null && google.maps.event.removeListener(A), Q(google.maps.event.addListener(y, "drag", u)));
  }, [u]), v(() => {
    y && w && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(y, "center_changed", w)));
  }, [s]), v(() => {
    var R = P.current === null ? null : new google.maps.Map(P.current, n);
    return C(R), R !== null && M && M(R), () => {
      R !== null && x && x(R);
    };
  }, []), oo.jsx("div", {
    id: r,
    ref: P,
    style: o,
    className: i,
    children: oo.jsx(St.Provider, {
      value: y,
      children: y !== null ? t : null
    })
  });
}
Ee(Npe);
function UT(e, t, n, r, o, i, a) {
  try {
    var s = e[i](a), l = s.value;
  } catch (u) {
    return void n(u);
  }
  s.done ? t(l) : Promise.resolve(l).then(r, o);
}
function HV(e) {
  return function() {
    var t = this, n = arguments;
    return new Promise(function(r, o) {
      var i = e.apply(t, n);
      function a(l) {
        UT(i, r, o, a, s, "next", l);
      }
      function s(l) {
        UT(i, r, o, a, s, "throw", l);
      }
      a(void 0);
    });
  };
}
function WV(e) {
  var {
    googleMapsApiKey: t,
    googleMapsClientId: n,
    version: r = "weekly",
    language: o,
    region: i,
    libraries: a,
    channel: s,
    mapIds: l,
    authReferrerPolicy: u
  } = e, c = [];
  return Zr(t && n || !(t && n), "You need to specify either googleMapsApiKey or googleMapsClientId for @react-google-maps/api load script to work. You cannot use both at the same time."), t ? c.push("key=".concat(t)) : n && c.push("client=".concat(n)), r && c.push("v=".concat(r)), o && c.push("language=".concat(o)), i && c.push("region=".concat(i)), a && a.length && c.push("libraries=".concat(a.sort().join(","))), s && c.push("channel=".concat(s)), l && l.length && c.push("map_ids=".concat(l.join(","))), u && c.push("auth_referrer_policy=".concat(u)), c.push("loading=async"), c.push("callback=initMap"), "https://maps.googleapis.com/maps/api/js?".concat(c.join("&"));
}
var al = typeof document < "u";
function VV(e) {
  var {
    url: t,
    id: n,
    nonce: r
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } = e;
  return al ? new Promise(function(o, i) {
    var a = document.getElementById(n), s = window;
    if (a) {
      var l = a.getAttribute("data-state");
      if (a.src === t && l !== "error") {
        if (l === "ready")
          return o(n);
        var u = s.initMap, c = a.onerror;
        s.initMap = function() {
          u && u(), o(n);
        }, a.onerror = function(d) {
          c && c(d), i(d);
        };
        return;
      } else
        a.remove();
    }
    var p = document.createElement("script");
    p.type = "text/javascript", p.src = t, p.id = n, p.async = !0, p.nonce = r || "", p.onerror = function(d) {
      p.setAttribute("data-state", "error"), i(d);
    }, s.initMap = function() {
      p.setAttribute("data-state", "ready"), o(n);
    }, document.head.appendChild(p);
  }).catch((o) => {
    throw console.error("injectScript error: ", o), o;
  }) : Promise.reject(new Error("document is undefined"));
}
function $T(e) {
  var t = e.href;
  return t && (t.indexOf("https://fonts.googleapis.com/css?family=Roboto") === 0 || t.indexOf("https://fonts.googleapis.com/css?family=Google+Sans+Text") === 0) ? !0 : (
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.styleSheet.cssText = "", !0) : (
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.innerHTML = "", !0) : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.innerHTML
      )
    )
  );
}
function qV() {
  var e = document.getElementsByTagName("head")[0];
  if (e) {
    var t = e.insertBefore.bind(e);
    e.insertBefore = function(r, o) {
      return $T(r) || Reflect.apply(t, e, [r, o]), r;
    };
    var n = e.appendChild.bind(e);
    e.appendChild = function(r) {
      return $T(r) || Reflect.apply(n, e, [r]), r;
    };
  }
}
var qu = !1;
function ZV() {
  return oo.jsx("div", {
    children: "Loading..."
  });
}
var ox = {
  id: "script-loader",
  version: "weekly"
};
class Fpe extends pe {
  constructor() {
    super(...arguments), we(this, "check", null), we(this, "state", {
      loaded: !1
    }), we(this, "cleanupCallback", () => {
      delete window.google.maps, this.injectScript();
    }), we(this, "isCleaningUp", /* @__PURE__ */ HV(function* () {
      function t(n) {
        if (!qu)
          n();
        else if (al)
          var r = window.setInterval(function() {
            qu || (window.clearInterval(r), n());
          }, 1);
      }
      return new Promise(t);
    })), we(this, "cleanup", () => {
      qu = !0;
      var t = document.getElementById(this.props.id);
      t && t.parentNode && t.parentNode.removeChild(t), Array.prototype.slice.call(document.getElementsByTagName("script")).filter(function(n) {
        return typeof n.src == "string" && n.src.includes("maps.googleapis");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("link")).filter(function(n) {
        return n.href === "https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Google+Sans";
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("style")).filter(function(n) {
        return n.innerText !== void 0 && n.innerText.length > 0 && n.innerText.includes(".gm-");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      });
    }), we(this, "injectScript", () => {
      this.props.preventGoogleFontsLoading && qV(), Zr(!!this.props.id, 'LoadScript requires "id" prop to be a string: %s', this.props.id);
      var t = {
        id: this.props.id,
        nonce: this.props.nonce,
        url: WV(this.props)
      };
      VV(t).then(() => {
        this.props.onLoad && this.props.onLoad(), this.setState(function() {
          return {
            loaded: !0
          };
        });
      }).catch((n) => {
        this.props.onError && this.props.onError(n), console.error(`
          There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(this.props.googleMapsApiKey || "-", ") or Client ID (").concat(this.props.googleMapsClientId || "-", `) to <LoadScript />
          Otherwise it is a Network issue.
        `));
      });
    }), we(this, "getRef", (t) => {
      this.check = t;
    });
  }
  componentDidMount() {
    if (al) {
      if (window.google && window.google.maps && !qu) {
        console.error("google api is already presented");
        return;
      }
      this.isCleaningUp().then(this.injectScript).catch(function(t) {
        console.error("Error at injecting script after cleaning up: ", t);
      });
    }
  }
  componentDidUpdate(t) {
    this.props.libraries !== t.libraries && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), al && t.language !== this.props.language && (this.cleanup(), this.setState(function() {
      return {
        loaded: !1
      };
    }, this.cleanupCallback));
  }
  componentWillUnmount() {
    if (al) {
      this.cleanup();
      var t = () => {
        this.check || (delete window.google, qu = !1);
      };
      window.setTimeout(t, 1), this.props.onUnmount && this.props.onUnmount();
    }
  }
  render() {
    return oo.jsxs(oo.Fragment, {
      children: [oo.jsx("div", {
        ref: this.getRef
      }), this.state.loaded ? this.props.children : this.props.loadingElement || oo.jsx(ZV, {})]
    });
  }
}
we(Fpe, "defaultProps", ox);
function zpe(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.includes(r)) continue;
    n[r] = e[r];
  }
  return n;
}
function gk(e, t) {
  if (e == null) return {};
  var n, r, o = zpe(e, t);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (r = 0; r < i.length; r++) n = i[r], t.includes(n) || {}.propertyIsEnumerable.call(e, n) && (o[n] = e[n]);
  }
  return o;
}
var HT;
function Upe(e) {
  var {
    id: t = ox.id,
    version: n = ox.version,
    nonce: r,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    preventGoogleFontsLoading: u,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  } = e, h = rt(!1), [f, m] = k(!1), [g, E] = k(void 0);
  v(function() {
    return h.current = !0, () => {
      h.current = !1;
    };
  }, []), v(function() {
    al && u && qV();
  }, [u]), v(function() {
    f && Zr(!!window.google, "useLoadScript was marked as loaded, but window.google is not present. Something went wrong.");
  }, [f]);
  var w = WV({
    version: n,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  });
  v(function() {
    if (!al)
      return;
    function x() {
      h.current && (m(!0), HT = w);
    }
    if (window.google && window.google.maps && HT === w) {
      x();
      return;
    }
    VV({
      id: t,
      url: w,
      nonce: r
    }).then(x).catch(function(y) {
      h.current && E(y), console.warn(`
        There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(o || "-", ") or Client ID (").concat(i || "-", `)
        Otherwise it is a Network issue.
      `)), console.error(y);
    });
  }, [t, w, r]);
  var M = rt(void 0);
  return v(function() {
    M.current && l !== M.current && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), M.current = l;
  }, [l]), {
    isLoaded: f,
    loadError: g,
    url: w
  };
}
var $pe = ["loadingElement", "onLoad", "onError", "onUnmount", "children"], Hpe = oo.jsx(ZV, {});
function Wpe(e) {
  var {
    loadingElement: t,
    onLoad: n,
    onError: r,
    onUnmount: o,
    children: i
  } = e, a = gk(e, $pe), {
    isLoaded: s,
    loadError: l
  } = Upe(a);
  return v(function() {
    s && typeof n == "function" && n();
  }, [s, n]), v(function() {
    l && typeof r == "function" && r(l);
  }, [l, r]), v(function() {
    return () => {
      o && o();
    };
  }, [o]), s ? i : t || Hpe;
}
Ee(Wpe);
var WT;
(function(e) {
  e[e.INITIALIZED = 0] = "INITIALIZED", e[e.LOADING = 1] = "LOADING", e[e.SUCCESS = 2] = "SUCCESS", e[e.FAILURE = 3] = "FAILURE";
})(WT || (WT = {}));
function VT(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Mg(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? VT(Object(n), !0).forEach(function(r) {
      we(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : VT(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var qT = {}, ZT = {
  options(e, t) {
    e.setOptions(t);
  }
};
function Vpe(e) {
  var {
    options: t,
    onLoad: n,
    onUnmount: r
  } = e, o = ye(St), [i, a] = k(null);
  return v(() => {
    i !== null && i.setMap(o);
  }, [o]), v(() => {
    t && i !== null && i.setOptions(t);
  }, [i, t]), v(() => {
    var s = new google.maps.TrafficLayer(Mg(Mg({}, t), {}, {
      map: o
    }));
    return a(s), n && n(s), () => {
      i !== null && (r && r(i), i.setMap(null));
    };
  }, []), null;
}
Ee(Vpe);
class qpe extends pe {
  constructor() {
    super(...arguments), we(this, "state", {
      trafficLayer: null
    }), we(this, "setTrafficLayerCallback", () => {
      this.state.trafficLayer !== null && this.props.onLoad && this.props.onLoad(this.state.trafficLayer);
    }), we(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = new google.maps.TrafficLayer(Mg(Mg({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Qt({
      updaterMap: ZT,
      eventMap: qT,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        trafficLayer: t
      };
    }, this.setTrafficLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.trafficLayer !== null && (sn(this.registeredEvents), this.registeredEvents = Qt({
      updaterMap: ZT,
      eventMap: qT,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.trafficLayer
    }));
  }
  componentWillUnmount() {
    this.state.trafficLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.trafficLayer), sn(this.registeredEvents), this.state.trafficLayer.setMap(null));
  }
  render() {
    return null;
  }
}
we(qpe, "contextType", St);
function Zpe(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = ye(St), [o, i] = k(null);
  return v(() => {
    o !== null && o.setMap(r);
  }, [r]), v(() => {
    var a = new google.maps.BicyclingLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      a !== null && (n && n(a), a.setMap(null));
    };
  }, []), null;
}
Ee(Zpe);
class Gpe extends pe {
  constructor() {
    super(...arguments), we(this, "state", {
      bicyclingLayer: null
    }), we(this, "setBicyclingLayerCallback", () => {
      this.state.bicyclingLayer !== null && (this.state.bicyclingLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.bicyclingLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.BicyclingLayer();
    this.setState(() => ({
      bicyclingLayer: t
    }), this.setBicyclingLayerCallback);
  }
  componentWillUnmount() {
    this.state.bicyclingLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.bicyclingLayer), this.state.bicyclingLayer.setMap(null));
  }
  render() {
    return null;
  }
}
we(Gpe, "contextType", St);
function Xpe(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = ye(St), [o, i] = k(null);
  return v(() => {
    o !== null && o.setMap(r);
  }, [r]), v(() => {
    var a = new google.maps.TransitLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      o !== null && (n && n(o), o.setMap(null));
    };
  }, []), null;
}
Ee(Xpe);
class Kpe extends pe {
  constructor() {
    super(...arguments), we(this, "state", {
      transitLayer: null
    }), we(this, "setTransitLayerCallback", () => {
      this.state.transitLayer !== null && (this.state.transitLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.transitLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.TransitLayer();
    this.setState(function() {
      return {
        transitLayer: t
      };
    }, this.setTransitLayerCallback);
  }
  componentWillUnmount() {
    this.state.transitLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.transitLayer), this.state.transitLayer.setMap(null));
  }
  render() {
    return null;
  }
}
we(Kpe, "contextType", St);
function GT(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Dg(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? GT(Object(n), !0).forEach(function(r) {
      we(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : GT(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var XT = {
  onCircleComplete: "circlecomplete",
  onMarkerComplete: "markercomplete",
  onOverlayComplete: "overlaycomplete",
  onPolygonComplete: "polygoncomplete",
  onPolylineComplete: "polylinecomplete",
  onRectangleComplete: "rectanglecomplete"
}, KT = {
  drawingMode(e, t) {
    e.setDrawingMode(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function Ype(e) {
  var {
    options: t,
    drawingMode: n,
    onCircleComplete: r,
    onMarkerComplete: o,
    onOverlayComplete: i,
    onPolygonComplete: a,
    onPolylineComplete: s,
    onRectangleComplete: l,
    onLoad: u,
    onUnmount: c
  } = e, p = ye(St), [d, h] = k(null), [f, m] = k(null), [g, E] = k(null), [w, M] = k(null), [x, y] = k(null), [C, P] = k(null), [F, L] = k(null);
  return v(() => {
    d !== null && d.setMap(p);
  }, [p]), v(() => {
    t && d !== null && d.setOptions(t);
  }, [d, t]), v(() => {
    d !== null && d.setDrawingMode(n ?? null);
  }, [d, n]), v(() => {
    d && r && (f !== null && google.maps.event.removeListener(f), m(google.maps.event.addListener(d, "circlecomplete", r)));
  }, [d, r]), v(() => {
    d && o && (g !== null && google.maps.event.removeListener(g), E(google.maps.event.addListener(d, "markercomplete", o)));
  }, [d, o]), v(() => {
    d && i && (w !== null && google.maps.event.removeListener(w), M(google.maps.event.addListener(d, "overlaycomplete", i)));
  }, [d, i]), v(() => {
    d && a && (x !== null && google.maps.event.removeListener(x), y(google.maps.event.addListener(d, "polygoncomplete", a)));
  }, [d, a]), v(() => {
    d && s && (C !== null && google.maps.event.removeListener(C), P(google.maps.event.addListener(d, "polylinecomplete", s)));
  }, [d, s]), v(() => {
    d && l && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(d, "rectanglecomplete", l)));
  }, [d, l]), v(() => {
    Zr(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
    var N = new google.maps.drawing.DrawingManager(Dg(Dg({}, t), {}, {
      map: p
    }));
    return n && N.setDrawingMode(n), r && m(google.maps.event.addListener(N, "circlecomplete", r)), o && E(google.maps.event.addListener(N, "markercomplete", o)), i && M(google.maps.event.addListener(N, "overlaycomplete", i)), a && y(google.maps.event.addListener(N, "polygoncomplete", a)), s && P(google.maps.event.addListener(N, "polylinecomplete", s)), l && L(google.maps.event.addListener(N, "rectanglecomplete", l)), h(N), u && u(N), () => {
      d !== null && (f && google.maps.event.removeListener(f), g && google.maps.event.removeListener(g), w && google.maps.event.removeListener(w), x && google.maps.event.removeListener(x), C && google.maps.event.removeListener(C), F && google.maps.event.removeListener(F), c && c(d), d.setMap(null));
    };
  }, []), null;
}
Ee(Ype);
class Jpe extends pe {
  constructor(t) {
    super(t), we(this, "registeredEvents", []), we(this, "state", {
      drawingManager: null
    }), we(this, "setDrawingManagerCallback", () => {
      this.state.drawingManager !== null && this.props.onLoad && this.props.onLoad(this.state.drawingManager);
    }), Zr(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
  }
  componentDidMount() {
    var t = new google.maps.drawing.DrawingManager(Dg(Dg({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Qt({
      updaterMap: KT,
      eventMap: XT,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        drawingManager: t
      };
    }, this.setDrawingManagerCallback);
  }
  componentDidUpdate(t) {
    this.state.drawingManager !== null && (sn(this.registeredEvents), this.registeredEvents = Qt({
      updaterMap: KT,
      eventMap: XT,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.drawingManager
    }));
  }
  componentWillUnmount() {
    this.state.drawingManager !== null && (this.props.onUnmount && this.props.onUnmount(this.state.drawingManager), sn(this.registeredEvents), this.state.drawingManager.setMap(null));
  }
  render() {
    return null;
  }
}
we(Jpe, "contextType", St);
function YT(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Kl(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? YT(Object(n), !0).forEach(function(r) {
      we(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : YT(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var JT = {
  onAnimationChanged: "animation_changed",
  onClick: "click",
  onClickableChanged: "clickable_changed",
  onCursorChanged: "cursor_changed",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDraggableChanged: "draggable_changed",
  onDragStart: "dragstart",
  onFlatChanged: "flat_changed",
  onIconChanged: "icon_changed",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onPositionChanged: "position_changed",
  onRightClick: "rightclick",
  onShapeChanged: "shape_changed",
  onTitleChanged: "title_changed",
  onVisibleChanged: "visible_changed",
  onZindexChanged: "zindex_changed"
}, QT = {
  animation(e, t) {
    e.setAnimation(t);
  },
  clickable(e, t) {
    e.setClickable(t);
  },
  cursor(e, t) {
    e.setCursor(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  icon(e, t) {
    e.setIcon(t);
  },
  label(e, t) {
    e.setLabel(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  opacity(e, t) {
    e.setOpacity(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  shape(e, t) {
    e.setShape(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, Tg = {};
function Qpe(e) {
  var {
    position: t,
    options: n,
    clusterer: r,
    noClustererRedraw: o,
    children: i,
    draggable: a,
    visible: s,
    animation: l,
    clickable: u,
    cursor: c,
    icon: p,
    label: d,
    opacity: h,
    shape: f,
    title: m,
    zIndex: g,
    onClick: E,
    onDblClick: w,
    onDrag: M,
    onDragEnd: x,
    onDragStart: y,
    onMouseOut: C,
    onMouseOver: P,
    onMouseUp: F,
    onMouseDown: L,
    onRightClick: N,
    onClickableChanged: I,
    onCursorChanged: H,
    onAnimationChanged: V,
    onDraggableChanged: z,
    onFlatChanged: q,
    onIconChanged: K,
    onPositionChanged: J,
    onShapeChanged: te,
    onTitleChanged: ee,
    onVisibleChanged: _,
    onZindexChanged: D,
    onLoad: $,
    onUnmount: S
  } = e, W = ye(St), [O, T] = k(null), [U, j] = k(null), [Z, A] = k(null), [Q, R] = k(null), [ue, fe] = k(null), [oe, Re] = k(null), [He, Ve] = k(null), [ze, et] = k(null), [Ge, Pe] = k(null), [Ye, it] = k(null), [_e, Se] = k(null), [Ke, We] = k(null), [Ue, nt] = k(null), [Ie, xt] = k(null), [ot, st] = k(null), [lt, Ot] = k(null), [ut, ct] = k(null), [tt, Xe] = k(null), [Et, kt] = k(null), [pt, kn] = k(null), [dt, Ln] = k(null), [ft, rn] = k(null);
  v(() => {
    O !== null && O.setMap(W);
  }, [W]), v(() => {
    typeof n < "u" && O !== null && O.setOptions(n);
  }, [O, n]), v(() => {
    typeof a < "u" && O !== null && O.setDraggable(a);
  }, [O, a]), v(() => {
    t && O !== null && O.setPosition(t);
  }, [O, t]), v(() => {
    typeof s < "u" && O !== null && O.setVisible(s);
  }, [O, s]), v(() => {
    O == null || O.setAnimation(l);
  }, [O, l]), v(() => {
    O && u !== void 0 && O.setClickable(u);
  }, [O, u]), v(() => {
    O && c !== void 0 && O.setCursor(c);
  }, [O, c]), v(() => {
    O && p !== void 0 && O.setIcon(p);
  }, [O, p]), v(() => {
    O && d !== void 0 && O.setLabel(d);
  }, [O, d]), v(() => {
    O && h !== void 0 && O.setOpacity(h);
  }, [O, h]), v(() => {
    O && f !== void 0 && O.setShape(f);
  }, [O, f]), v(() => {
    O && m !== void 0 && O.setTitle(m);
  }, [O, m]), v(() => {
    O && g !== void 0 && O.setZIndex(g);
  }, [O, g]), v(() => {
    O && w && (U !== null && google.maps.event.removeListener(U), j(google.maps.event.addListener(O, "dblclick", w)));
  }, [w]), v(() => {
    O && x && (Z !== null && google.maps.event.removeListener(Z), A(google.maps.event.addListener(O, "dragend", x)));
  }, [x]), v(() => {
    O && y && (Q !== null && google.maps.event.removeListener(Q), R(google.maps.event.addListener(O, "dragstart", y)));
  }, [y]), v(() => {
    O && L && (ue !== null && google.maps.event.removeListener(ue), fe(google.maps.event.addListener(O, "mousedown", L)));
  }, [L]), v(() => {
    O && C && (oe !== null && google.maps.event.removeListener(oe), Re(google.maps.event.addListener(O, "mouseout", C)));
  }, [C]), v(() => {
    O && P && (He !== null && google.maps.event.removeListener(He), Ve(google.maps.event.addListener(O, "mouseover", P)));
  }, [P]), v(() => {
    O && F && (ze !== null && google.maps.event.removeListener(ze), et(google.maps.event.addListener(O, "mouseup", F)));
  }, [F]), v(() => {
    O && N && (Ge !== null && google.maps.event.removeListener(Ge), Pe(google.maps.event.addListener(O, "rightclick", N)));
  }, [N]), v(() => {
    O && E && (Ye !== null && google.maps.event.removeListener(Ye), it(google.maps.event.addListener(O, "click", E)));
  }, [E]), v(() => {
    O && M && (_e !== null && google.maps.event.removeListener(_e), Se(google.maps.event.addListener(O, "drag", M)));
  }, [M]), v(() => {
    O && I && (Ke !== null && google.maps.event.removeListener(Ke), We(google.maps.event.addListener(O, "clickable_changed", I)));
  }, [I]), v(() => {
    O && H && (Ue !== null && google.maps.event.removeListener(Ue), nt(google.maps.event.addListener(O, "cursor_changed", H)));
  }, [H]), v(() => {
    O && V && (Ie !== null && google.maps.event.removeListener(Ie), xt(google.maps.event.addListener(O, "animation_changed", V)));
  }, [V]), v(() => {
    O && z && (ot !== null && google.maps.event.removeListener(ot), st(google.maps.event.addListener(O, "draggable_changed", z)));
  }, [z]), v(() => {
    O && q && (lt !== null && google.maps.event.removeListener(lt), Ot(google.maps.event.addListener(O, "flat_changed", q)));
  }, [q]), v(() => {
    O && K && (ut !== null && google.maps.event.removeListener(ut), ct(google.maps.event.addListener(O, "icon_changed", K)));
  }, [K]), v(() => {
    O && J && (tt !== null && google.maps.event.removeListener(tt), Xe(google.maps.event.addListener(O, "position_changed", J)));
  }, [J]), v(() => {
    O && te && (Et !== null && google.maps.event.removeListener(Et), kt(google.maps.event.addListener(O, "shape_changed", te)));
  }, [te]), v(() => {
    O && ee && (pt !== null && google.maps.event.removeListener(pt), kn(google.maps.event.addListener(O, "title_changed", ee)));
  }, [ee]), v(() => {
    O && _ && (dt !== null && google.maps.event.removeListener(dt), Ln(google.maps.event.addListener(O, "visible_changed", _)));
  }, [_]), v(() => {
    O && D && (ft !== null && google.maps.event.removeListener(ft), rn(google.maps.event.addListener(O, "zindex_changed", D)));
  }, [D]), v(() => {
    var ht = Kl(Kl(Kl({}, n || Tg), r ? Tg : {
      map: W
    }), {}, {
      position: t
    }), re = new google.maps.Marker(ht);
    return r ? r.addMarker(re, !!o) : re.setMap(W), t && re.setPosition(t), typeof s < "u" && re.setVisible(s), typeof a < "u" && re.setDraggable(a), typeof u < "u" && re.setClickable(u), typeof c == "string" && re.setCursor(c), p && re.setIcon(p), typeof d < "u" && re.setLabel(d), typeof h < "u" && re.setOpacity(h), f && re.setShape(f), typeof m == "string" && re.setTitle(m), typeof g == "number" && re.setZIndex(g), w && j(google.maps.event.addListener(re, "dblclick", w)), x && A(google.maps.event.addListener(re, "dragend", x)), y && R(google.maps.event.addListener(re, "dragstart", y)), L && fe(google.maps.event.addListener(re, "mousedown", L)), C && Re(google.maps.event.addListener(re, "mouseout", C)), P && Ve(google.maps.event.addListener(re, "mouseover", P)), F && et(google.maps.event.addListener(re, "mouseup", F)), N && Pe(google.maps.event.addListener(re, "rightclick", N)), E && it(google.maps.event.addListener(re, "click", E)), M && Se(google.maps.event.addListener(re, "drag", M)), I && We(google.maps.event.addListener(re, "clickable_changed", I)), H && nt(google.maps.event.addListener(re, "cursor_changed", H)), V && xt(google.maps.event.addListener(re, "animation_changed", V)), z && st(google.maps.event.addListener(re, "draggable_changed", z)), q && Ot(google.maps.event.addListener(re, "flat_changed", q)), K && ct(google.maps.event.addListener(re, "icon_changed", K)), J && Xe(google.maps.event.addListener(re, "position_changed", J)), te && kt(google.maps.event.addListener(re, "shape_changed", te)), ee && kn(google.maps.event.addListener(re, "title_changed", ee)), _ && Ln(google.maps.event.addListener(re, "visible_changed", _)), D && rn(google.maps.event.addListener(re, "zindex_changed", D)), T(re), $ && $(re), () => {
      U !== null && google.maps.event.removeListener(U), Z !== null && google.maps.event.removeListener(Z), Q !== null && google.maps.event.removeListener(Q), ue !== null && google.maps.event.removeListener(ue), oe !== null && google.maps.event.removeListener(oe), He !== null && google.maps.event.removeListener(He), ze !== null && google.maps.event.removeListener(ze), Ge !== null && google.maps.event.removeListener(Ge), Ye !== null && google.maps.event.removeListener(Ye), Ke !== null && google.maps.event.removeListener(Ke), Ue !== null && google.maps.event.removeListener(Ue), Ie !== null && google.maps.event.removeListener(Ie), ot !== null && google.maps.event.removeListener(ot), lt !== null && google.maps.event.removeListener(lt), ut !== null && google.maps.event.removeListener(ut), tt !== null && google.maps.event.removeListener(tt), pt !== null && google.maps.event.removeListener(pt), dt !== null && google.maps.event.removeListener(dt), ft !== null && google.maps.event.removeListener(ft), S && S(re), r ? r.removeMarker(re, !!o) : re && re.setMap(null);
    };
  }, []);
  var br = Tn(() => i ? at.map(i, (ht) => {
    if (!bi(ht))
      return ht;
    var re = ht;
    return wi(re, {
      anchor: O
    });
  }) : null, [i, O]);
  return oo.jsx(oo.Fragment, {
    children: br
  }) || null;
}
Ee(Qpe);
class ede extends pe {
  constructor() {
    super(...arguments), we(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this;
    return HV(function* () {
      var n = Kl(Kl(Kl({}, t.props.options || Tg), t.props.clusterer ? Tg : {
        map: t.context
      }), {}, {
        position: t.props.position
      });
      t.marker = new google.maps.Marker(n), t.props.clusterer ? t.props.clusterer.addMarker(t.marker, !!t.props.noClustererRedraw) : t.marker.setMap(t.context), t.registeredEvents = Qt({
        updaterMap: QT,
        eventMap: JT,
        prevProps: {},
        nextProps: t.props,
        instance: t.marker
      }), t.props.onLoad && t.props.onLoad(t.marker);
    })();
  }
  componentDidUpdate(t) {
    this.marker && (sn(this.registeredEvents), this.registeredEvents = Qt({
      updaterMap: QT,
      eventMap: JT,
      prevProps: t,
      nextProps: this.props,
      instance: this.marker
    }));
  }
  componentWillUnmount() {
    this.marker && (this.props.onUnmount && this.props.onUnmount(this.marker), sn(this.registeredEvents), this.props.clusterer ? this.props.clusterer.removeMarker(this.marker, !!this.props.noClustererRedraw) : this.marker && this.marker.setMap(null));
  }
  render() {
    var t = this.props.children ? at.map(this.props.children, (n) => {
      if (!bi(n))
        return n;
      var r = n;
      return wi(r, {
        anchor: this.marker
      });
    }) : null;
    return t || null;
  }
}
we(ede, "contextType", St);
var tde = (
  /** @class */
  function() {
    function e(t, n) {
      t.getClusterer().extend(e, google.maps.OverlayView), this.cluster = t, this.clusterClassName = this.cluster.getClusterer().getClusterClass(), this.className = this.clusterClassName, this.styles = n, this.center = void 0, this.div = null, this.sums = null, this.visible = !1, this.boundsChangedListener = null, this.url = "", this.height = 0, this.width = 0, this.anchorText = [0, 0], this.anchorIcon = [0, 0], this.textColor = "black", this.textSize = 11, this.textDecoration = "none", this.fontWeight = "bold", this.fontStyle = "normal", this.fontFamily = "Arial,sans-serif", this.backgroundPosition = "0 0", this.cMouseDownInCluster = null, this.cDraggingMapByCluster = null, this.timeOut = null, this.setMap(t.getMap()), this.onBoundsChanged = this.onBoundsChanged.bind(this), this.onMouseDown = this.onMouseDown.bind(this), this.onClick = this.onClick.bind(this), this.onMouseOver = this.onMouseOver.bind(this), this.onMouseOut = this.onMouseOut.bind(this), this.onAdd = this.onAdd.bind(this), this.onRemove = this.onRemove.bind(this), this.draw = this.draw.bind(this), this.hide = this.hide.bind(this), this.show = this.show.bind(this), this.useStyle = this.useStyle.bind(this), this.setCenter = this.setCenter.bind(this), this.getPosFromLatLng = this.getPosFromLatLng.bind(this);
    }
    return e.prototype.onBoundsChanged = function() {
      this.cDraggingMapByCluster = this.cMouseDownInCluster;
    }, e.prototype.onMouseDown = function() {
      this.cMouseDownInCluster = !0, this.cDraggingMapByCluster = !1;
    }, e.prototype.onClick = function(t) {
      if (this.cMouseDownInCluster = !1, !this.cDraggingMapByCluster) {
        var n = this.cluster.getClusterer();
        if (google.maps.event.trigger(n, "click", this.cluster), google.maps.event.trigger(n, "clusterclick", this.cluster), n.getZoomOnClick()) {
          var r = n.getMaxZoom(), o = this.cluster.getBounds(), i = n.getMap();
          i !== null && "fitBounds" in i && i.fitBounds(o), this.timeOut = window.setTimeout(function() {
            var a = n.getMap();
            if (a !== null) {
              "fitBounds" in a && a.fitBounds(o);
              var s = a.getZoom() || 0;
              r !== null && s > r && a.setZoom(r + 1);
            }
          }, 100);
        }
        t.cancelBubble = !0, t.stopPropagation && t.stopPropagation();
      }
    }, e.prototype.onMouseOver = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseover", this.cluster);
    }, e.prototype.onMouseOut = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseout", this.cluster);
    }, e.prototype.onAdd = function() {
      var t;
      this.div = document.createElement("div"), this.div.className = this.className, this.visible && this.show(), (t = this.getPanes()) === null || t === void 0 || t.overlayMouseTarget.appendChild(this.div);
      var n = this.getMap();
      n !== null && (this.boundsChangedListener = google.maps.event.addListener(n, "bounds_changed", this.onBoundsChanged), this.div.addEventListener("mousedown", this.onMouseDown), this.div.addEventListener("click", this.onClick), this.div.addEventListener("mouseover", this.onMouseOver), this.div.addEventListener("mouseout", this.onMouseOut));
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.hide(), this.boundsChangedListener !== null && google.maps.event.removeListener(this.boundsChangedListener), this.div.removeEventListener("mousedown", this.onMouseDown), this.div.removeEventListener("click", this.onClick), this.div.removeEventListener("mouseover", this.onMouseOver), this.div.removeEventListener("mouseout", this.onMouseOut), this.div.parentNode.removeChild(this.div), this.timeOut !== null && (window.clearTimeout(this.timeOut), this.timeOut = null), this.div = null);
    }, e.prototype.draw = function() {
      if (this.visible && this.div !== null && this.center) {
        var t = this.getPosFromLatLng(this.center);
        this.div.style.top = t !== null ? "".concat(t.y, "px") : "0", this.div.style.left = t !== null ? "".concat(t.x, "px") : "0";
      }
    }, e.prototype.hide = function() {
      this.div && (this.div.style.display = "none"), this.visible = !1;
    }, e.prototype.show = function() {
      var t, n, r, o, i, a;
      if (this.div && this.center) {
        var s = this.sums === null || typeof this.sums.title > "u" || this.sums.title === "" ? this.cluster.getClusterer().getTitle() : this.sums.title, l = this.backgroundPosition.split(" "), u = parseInt(((t = l[0]) === null || t === void 0 ? void 0 : t.replace(/^\s+|\s+$/g, "")) || "0", 10), c = parseInt(((n = l[1]) === null || n === void 0 ? void 0 : n.replace(/^\s+|\s+$/g, "")) || "0", 10), p = this.getPosFromLatLng(this.center);
        this.div.className = this.className, this.div.setAttribute("style", "cursor: pointer; position: absolute; top: ".concat(p !== null ? "".concat(p.y, "px") : "0", "; left: ").concat(p !== null ? "".concat(p.x, "px") : "0", "; width: ").concat(this.width, "px; height: ").concat(this.height, "px; "));
        var d = document.createElement("img");
        d.alt = s, d.src = this.url, d.width = this.width, d.height = this.height, d.setAttribute("style", "position: absolute; top: ".concat(c, "px; left: ").concat(u, "px")), this.cluster.getClusterer().enableRetinaIcons || (d.style.clip = "rect(-".concat(c, "px, -").concat(u + this.width, "px, -").concat(c + this.height, ", -").concat(u, ")"));
        var h = document.createElement("div");
        h.setAttribute("style", "position: absolute; top: ".concat(this.anchorText[0], "px; left: ").concat(this.anchorText[1], "px; color: ").concat(this.textColor, "; font-size: ").concat(this.textSize, "px; font-family: ").concat(this.fontFamily, "; font-weight: ").concat(this.fontWeight, "; fontStyle: ").concat(this.fontStyle, "; text-decoration: ").concat(this.textDecoration, "; text-align: center; width: ").concat(this.width, "px; line-height: ").concat(this.height, "px")), !((r = this.sums) === null || r === void 0) && r.text && (h.innerText = "".concat((o = this.sums) === null || o === void 0 ? void 0 : o.text)), !((i = this.sums) === null || i === void 0) && i.html && (h.innerHTML = "".concat((a = this.sums) === null || a === void 0 ? void 0 : a.html)), this.div.innerHTML = "", this.div.appendChild(d), this.div.appendChild(h), this.div.title = s, this.div.style.display = "";
      }
      this.visible = !0;
    }, e.prototype.useStyle = function(t) {
      this.sums = t;
      var n = this.cluster.getClusterer().getStyles(), r = n[Math.min(n.length - 1, Math.max(0, t.index - 1))];
      r && (this.url = r.url, this.height = r.height, this.width = r.width, r.className && (this.className = "".concat(this.clusterClassName, " ").concat(r.className)), this.anchorText = r.anchorText || [0, 0], this.anchorIcon = r.anchorIcon || [this.height / 2, this.width / 2], this.textColor = r.textColor || "black", this.textSize = r.textSize || 11, this.textDecoration = r.textDecoration || "none", this.fontWeight = r.fontWeight || "bold", this.fontStyle = r.fontStyle || "normal", this.fontFamily = r.fontFamily || "Arial,sans-serif", this.backgroundPosition = r.backgroundPosition || "0 0");
    }, e.prototype.setCenter = function(t) {
      this.center = t;
    }, e.prototype.getPosFromLatLng = function(t) {
      var n = this.getProjection().fromLatLngToDivPixel(t);
      return n !== null && (n.x -= this.anchorIcon[1], n.y -= this.anchorIcon[0]), n;
    }, e;
  }()
), nde = (
  /** @class */
  function() {
    function e(t) {
      this.markerClusterer = t, this.map = this.markerClusterer.getMap(), this.gridSize = this.markerClusterer.getGridSize(), this.minClusterSize = this.markerClusterer.getMinimumClusterSize(), this.averageCenter = this.markerClusterer.getAverageCenter(), this.markers = [], this.center = void 0, this.bounds = null, this.clusterIcon = new tde(this, this.markerClusterer.getStyles()), this.getSize = this.getSize.bind(this), this.getMarkers = this.getMarkers.bind(this), this.getCenter = this.getCenter.bind(this), this.getMap = this.getMap.bind(this), this.getClusterer = this.getClusterer.bind(this), this.getBounds = this.getBounds.bind(this), this.remove = this.remove.bind(this), this.addMarker = this.addMarker.bind(this), this.isMarkerInClusterBounds = this.isMarkerInClusterBounds.bind(this), this.calculateBounds = this.calculateBounds.bind(this), this.updateIcon = this.updateIcon.bind(this), this.isMarkerAlreadyAdded = this.isMarkerAlreadyAdded.bind(this);
    }
    return e.prototype.getSize = function() {
      return this.markers.length;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getCenter = function() {
      return this.center;
    }, e.prototype.getMap = function() {
      return this.map;
    }, e.prototype.getClusterer = function() {
      return this.markerClusterer;
    }, e.prototype.getBounds = function() {
      for (var t = new google.maps.LatLngBounds(this.center, this.center), n = this.getMarkers(), r = 0, o = n; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && t.extend(a);
      }
      return t;
    }, e.prototype.remove = function() {
      this.clusterIcon.setMap(null), this.markers = [], delete this.markers;
    }, e.prototype.addMarker = function(t) {
      var n;
      if (this.isMarkerAlreadyAdded(t))
        return !1;
      if (this.center) {
        if (this.averageCenter) {
          var r = t.getPosition();
          if (r) {
            var o = this.markers.length + 1;
            this.center = new google.maps.LatLng((this.center.lat() * (o - 1) + r.lat()) / o, (this.center.lng() * (o - 1) + r.lng()) / o), this.calculateBounds();
          }
        }
      } else {
        var r = t.getPosition();
        r && (this.center = r, this.calculateBounds());
      }
      t.isAdded = !0, this.markers.push(t);
      var i = this.markers.length, a = this.markerClusterer.getMaxZoom(), s = (n = this.map) === null || n === void 0 ? void 0 : n.getZoom();
      if (a !== null && typeof s < "u" && s > a)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i < this.minClusterSize)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i === this.minClusterSize)
        for (var l = 0, u = this.markers; l < u.length; l++) {
          var c = u[l];
          c.setMap(null);
        }
      else
        t.setMap(null);
      return !0;
    }, e.prototype.isMarkerInClusterBounds = function(t) {
      if (this.bounds !== null) {
        var n = t.getPosition();
        if (n)
          return this.bounds.contains(n);
      }
      return !1;
    }, e.prototype.calculateBounds = function() {
      this.bounds = this.markerClusterer.getExtendedBounds(new google.maps.LatLngBounds(this.center, this.center));
    }, e.prototype.updateIcon = function() {
      var t, n = this.markers.length, r = this.markerClusterer.getMaxZoom(), o = (t = this.map) === null || t === void 0 ? void 0 : t.getZoom();
      if (r !== null && typeof o < "u" && o > r) {
        this.clusterIcon.hide();
        return;
      }
      if (n < this.minClusterSize) {
        this.clusterIcon.hide();
        return;
      }
      this.center && this.clusterIcon.setCenter(this.center), this.clusterIcon.useStyle(this.markerClusterer.getCalculator()(this.markers, this.markerClusterer.getStyles().length)), this.clusterIcon.show();
    }, e.prototype.isMarkerAlreadyAdded = function(t) {
      if (this.markers.includes)
        return this.markers.includes(t);
      for (var n = 0; n < this.markers.length; n++)
        if (t === this.markers[n])
          return !0;
      return !1;
    }, e;
  }()
);
function rde(e, t) {
  var n = e.length, r = n.toString().length, o = Math.min(r, t);
  return {
    text: n.toString(),
    index: o,
    title: ""
  };
}
var ode = 2e3, ide = 500, sde = "https://developers.google.com/maps/documentation/javascript/examples/markerclusterer/m", ade = "png", lde = [53, 56, 66, 78, 90], ude = "cluster", GV = (
  /** @class */
  function() {
    function e(t, n, r) {
      n === void 0 && (n = []), r === void 0 && (r = {}), this.getMinimumClusterSize = this.getMinimumClusterSize.bind(this), this.setMinimumClusterSize = this.setMinimumClusterSize.bind(this), this.getEnableRetinaIcons = this.getEnableRetinaIcons.bind(this), this.setEnableRetinaIcons = this.setEnableRetinaIcons.bind(this), this.addToClosestCluster = this.addToClosestCluster.bind(this), this.getImageExtension = this.getImageExtension.bind(this), this.setImageExtension = this.setImageExtension.bind(this), this.getExtendedBounds = this.getExtendedBounds.bind(this), this.getAverageCenter = this.getAverageCenter.bind(this), this.setAverageCenter = this.setAverageCenter.bind(this), this.getTotalClusters = this.getTotalClusters.bind(this), this.fitMapToMarkers = this.fitMapToMarkers.bind(this), this.getIgnoreHidden = this.getIgnoreHidden.bind(this), this.setIgnoreHidden = this.setIgnoreHidden.bind(this), this.getClusterClass = this.getClusterClass.bind(this), this.setClusterClass = this.setClusterClass.bind(this), this.getTotalMarkers = this.getTotalMarkers.bind(this), this.getZoomOnClick = this.getZoomOnClick.bind(this), this.setZoomOnClick = this.setZoomOnClick.bind(this), this.getBatchSizeIE = this.getBatchSizeIE.bind(this), this.setBatchSizeIE = this.setBatchSizeIE.bind(this), this.createClusters = this.createClusters.bind(this), this.onZoomChanged = this.onZoomChanged.bind(this), this.getImageSizes = this.getImageSizes.bind(this), this.setImageSizes = this.setImageSizes.bind(this), this.getCalculator = this.getCalculator.bind(this), this.setCalculator = this.setCalculator.bind(this), this.removeMarkers = this.removeMarkers.bind(this), this.resetViewport = this.resetViewport.bind(this), this.getImagePath = this.getImagePath.bind(this), this.setImagePath = this.setImagePath.bind(this), this.pushMarkerTo = this.pushMarkerTo.bind(this), this.removeMarker = this.removeMarker.bind(this), this.clearMarkers = this.clearMarkers.bind(this), this.setupStyles = this.setupStyles.bind(this), this.getGridSize = this.getGridSize.bind(this), this.setGridSize = this.setGridSize.bind(this), this.getClusters = this.getClusters.bind(this), this.getMaxZoom = this.getMaxZoom.bind(this), this.setMaxZoom = this.setMaxZoom.bind(this), this.getMarkers = this.getMarkers.bind(this), this.addMarkers = this.addMarkers.bind(this), this.getStyles = this.getStyles.bind(this), this.setStyles = this.setStyles.bind(this), this.addMarker = this.addMarker.bind(this), this.onRemove = this.onRemove.bind(this), this.getTitle = this.getTitle.bind(this), this.setTitle = this.setTitle.bind(this), this.repaint = this.repaint.bind(this), this.onIdle = this.onIdle.bind(this), this.redraw = this.redraw.bind(this), this.onAdd = this.onAdd.bind(this), this.draw = this.draw.bind(this), this.extend = this.extend.bind(this), this.extend(e, google.maps.OverlayView), this.markers = [], this.clusters = [], this.listeners = [], this.activeMap = null, this.ready = !1, this.gridSize = r.gridSize || 60, this.minClusterSize = r.minimumClusterSize || 2, this.maxZoom = r.maxZoom || null, this.styles = r.styles || [], this.title = r.title || "", this.zoomOnClick = !0, r.zoomOnClick !== void 0 && (this.zoomOnClick = r.zoomOnClick), this.averageCenter = !1, r.averageCenter !== void 0 && (this.averageCenter = r.averageCenter), this.ignoreHidden = !1, r.ignoreHidden !== void 0 && (this.ignoreHidden = r.ignoreHidden), this.enableRetinaIcons = !1, r.enableRetinaIcons !== void 0 && (this.enableRetinaIcons = r.enableRetinaIcons), this.imagePath = r.imagePath || sde, this.imageExtension = r.imageExtension || ade, this.imageSizes = r.imageSizes || lde, this.calculator = r.calculator || rde, this.batchSize = r.batchSize || ode, this.batchSizeIE = r.batchSizeIE || ide, this.clusterClass = r.clusterClass || ude, navigator.userAgent.toLowerCase().indexOf("msie") !== -1 && (this.batchSize = this.batchSizeIE), this.timerRefStatic = null, this.setupStyles(), this.addMarkers(n, !0), this.setMap(t);
    }
    return e.prototype.onZoomChanged = function() {
      var t, n;
      this.resetViewport(!1), (((t = this.getMap()) === null || t === void 0 ? void 0 : t.getZoom()) === (this.get("minZoom") || 0) || ((n = this.getMap()) === null || n === void 0 ? void 0 : n.getZoom()) === this.get("maxZoom")) && google.maps.event.trigger(this, "idle");
    }, e.prototype.onIdle = function() {
      this.redraw();
    }, e.prototype.onAdd = function() {
      var t = this.getMap();
      this.activeMap = t, this.ready = !0, this.repaint(), t !== null && (this.listeners = [google.maps.event.addListener(t, "zoom_changed", this.onZoomChanged), google.maps.event.addListener(t, "idle", this.onIdle)]);
    }, e.prototype.onRemove = function() {
      for (var t = 0, n = this.markers; t < n.length; t++) {
        var r = n[t];
        r.getMap() !== this.activeMap && r.setMap(this.activeMap);
      }
      for (var o = 0, i = this.clusters; o < i.length; o++) {
        var a = i[o];
        a.remove();
      }
      this.clusters = [];
      for (var s = 0, l = this.listeners; s < l.length; s++) {
        var u = l[s];
        google.maps.event.removeListener(u);
      }
      this.listeners = [], this.activeMap = null, this.ready = !1;
    }, e.prototype.draw = function() {
    }, e.prototype.getMap = function() {
      return null;
    }, e.prototype.getPanes = function() {
      return null;
    }, e.prototype.getProjection = function() {
      return {
        fromContainerPixelToLatLng: function() {
          return null;
        },
        fromDivPixelToLatLng: function() {
          return null;
        },
        fromLatLngToContainerPixel: function() {
          return null;
        },
        fromLatLngToDivPixel: function() {
          return null;
        },
        getVisibleRegion: function() {
          return null;
        },
        getWorldWidth: function() {
          return 0;
        }
      };
    }, e.prototype.setMap = function() {
    }, e.prototype.addListener = function() {
      return {
        remove: function() {
        }
      };
    }, e.prototype.bindTo = function() {
    }, e.prototype.get = function() {
    }, e.prototype.notify = function() {
    }, e.prototype.set = function() {
    }, e.prototype.setValues = function() {
    }, e.prototype.unbind = function() {
    }, e.prototype.unbindAll = function() {
    }, e.prototype.setupStyles = function() {
      if (!(this.styles.length > 0))
        for (var t = 0; t < this.imageSizes.length; t++)
          this.styles.push({
            url: "".concat(this.imagePath + (t + 1), ".").concat(this.imageExtension),
            height: this.imageSizes[t] || 0,
            width: this.imageSizes[t] || 0
          });
    }, e.prototype.fitMapToMarkers = function() {
      for (var t = this.getMarkers(), n = new google.maps.LatLngBounds(), r = 0, o = t; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && n.extend(a);
      }
      var s = this.getMap();
      s !== null && "fitBounds" in s && s.fitBounds(n);
    }, e.prototype.getGridSize = function() {
      return this.gridSize;
    }, e.prototype.setGridSize = function(t) {
      this.gridSize = t;
    }, e.prototype.getMinimumClusterSize = function() {
      return this.minClusterSize;
    }, e.prototype.setMinimumClusterSize = function(t) {
      this.minClusterSize = t;
    }, e.prototype.getMaxZoom = function() {
      return this.maxZoom;
    }, e.prototype.setMaxZoom = function(t) {
      this.maxZoom = t;
    }, e.prototype.getStyles = function() {
      return this.styles;
    }, e.prototype.setStyles = function(t) {
      this.styles = t;
    }, e.prototype.getTitle = function() {
      return this.title;
    }, e.prototype.setTitle = function(t) {
      this.title = t;
    }, e.prototype.getZoomOnClick = function() {
      return this.zoomOnClick;
    }, e.prototype.setZoomOnClick = function(t) {
      this.zoomOnClick = t;
    }, e.prototype.getAverageCenter = function() {
      return this.averageCenter;
    }, e.prototype.setAverageCenter = function(t) {
      this.averageCenter = t;
    }, e.prototype.getIgnoreHidden = function() {
      return this.ignoreHidden;
    }, e.prototype.setIgnoreHidden = function(t) {
      this.ignoreHidden = t;
    }, e.prototype.getEnableRetinaIcons = function() {
      return this.enableRetinaIcons;
    }, e.prototype.setEnableRetinaIcons = function(t) {
      this.enableRetinaIcons = t;
    }, e.prototype.getImageExtension = function() {
      return this.imageExtension;
    }, e.prototype.setImageExtension = function(t) {
      this.imageExtension = t;
    }, e.prototype.getImagePath = function() {
      return this.imagePath;
    }, e.prototype.setImagePath = function(t) {
      this.imagePath = t;
    }, e.prototype.getImageSizes = function() {
      return this.imageSizes;
    }, e.prototype.setImageSizes = function(t) {
      this.imageSizes = t;
    }, e.prototype.getCalculator = function() {
      return this.calculator;
    }, e.prototype.setCalculator = function(t) {
      this.calculator = t;
    }, e.prototype.getBatchSizeIE = function() {
      return this.batchSizeIE;
    }, e.prototype.setBatchSizeIE = function(t) {
      this.batchSizeIE = t;
    }, e.prototype.getClusterClass = function() {
      return this.clusterClass;
    }, e.prototype.setClusterClass = function(t) {
      this.clusterClass = t;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getTotalMarkers = function() {
      return this.markers.length;
    }, e.prototype.getClusters = function() {
      return this.clusters;
    }, e.prototype.getTotalClusters = function() {
      return this.clusters.length;
    }, e.prototype.addMarker = function(t, n) {
      this.pushMarkerTo(t), n || this.redraw();
    }, e.prototype.addMarkers = function(t, n) {
      for (var r in t)
        if (Object.prototype.hasOwnProperty.call(t, r)) {
          var o = t[r];
          o && this.pushMarkerTo(o);
        }
      n || this.redraw();
    }, e.prototype.pushMarkerTo = function(t) {
      var n = this;
      t.getDraggable() && google.maps.event.addListener(t, "dragend", function() {
        n.ready && (t.isAdded = !1, n.repaint());
      }), t.isAdded = !1, this.markers.push(t);
    }, e.prototype.removeMarker_ = function(t) {
      var n = -1;
      if (this.markers.indexOf)
        n = this.markers.indexOf(t);
      else
        for (var r = 0; r < this.markers.length; r++)
          if (t === this.markers[r]) {
            n = r;
            break;
          }
      return n === -1 ? !1 : (t.setMap(null), this.markers.splice(n, 1), !0);
    }, e.prototype.removeMarker = function(t, n) {
      var r = this.removeMarker_(t);
      return !n && r && this.repaint(), r;
    }, e.prototype.removeMarkers = function(t, n) {
      for (var r = !1, o = 0, i = t; o < i.length; o++) {
        var a = i[o];
        r = r || this.removeMarker_(a);
      }
      return !n && r && this.repaint(), r;
    }, e.prototype.clearMarkers = function() {
      this.resetViewport(!0), this.markers = [];
    }, e.prototype.repaint = function() {
      var t = this.clusters.slice();
      this.clusters = [], this.resetViewport(!1), this.redraw(), setTimeout(function() {
        for (var n = 0, r = t; n < r.length; n++) {
          var o = r[n];
          o.remove();
        }
      }, 0);
    }, e.prototype.getExtendedBounds = function(t) {
      var n = this.getProjection(), r = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getNorthEast().lat(), t.getNorthEast().lng())
      );
      r !== null && (r.x += this.gridSize, r.y -= this.gridSize);
      var o = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getSouthWest().lat(), t.getSouthWest().lng())
      );
      if (o !== null && (o.x -= this.gridSize, o.y += this.gridSize), r !== null) {
        var i = n.fromDivPixelToLatLng(r);
        i !== null && t.extend(i);
      }
      if (o !== null) {
        var a = n.fromDivPixelToLatLng(o);
        a !== null && t.extend(a);
      }
      return t;
    }, e.prototype.redraw = function() {
      this.createClusters(0);
    }, e.prototype.resetViewport = function(t) {
      for (var n = 0, r = this.clusters; n < r.length; n++) {
        var o = r[n];
        o.remove();
      }
      this.clusters = [];
      for (var i = 0, a = this.markers; i < a.length; i++) {
        var s = a[i];
        s.isAdded = !1, t && s.setMap(null);
      }
    }, e.prototype.distanceBetweenPoints = function(t, n) {
      var r = 6371, o = (n.lat() - t.lat()) * Math.PI / 180, i = (n.lng() - t.lng()) * Math.PI / 180, a = Math.sin(o / 2) * Math.sin(o / 2) + Math.cos(t.lat() * Math.PI / 180) * Math.cos(n.lat() * Math.PI / 180) * Math.sin(i / 2) * Math.sin(i / 2);
      return r * (2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)));
    }, e.prototype.isMarkerInBounds = function(t, n) {
      var r = t.getPosition();
      return r ? n.contains(r) : !1;
    }, e.prototype.addToClosestCluster = function(t) {
      for (var n, r = 4e4, o = null, i = 0, a = this.clusters; i < a.length; i++) {
        var s = a[i];
        n = s;
        var l = n.getCenter(), u = t.getPosition();
        if (l && u) {
          var c = this.distanceBetweenPoints(l, u);
          c < r && (r = c, o = n);
        }
      }
      o && o.isMarkerInClusterBounds(t) ? o.addMarker(t) : (n = new nde(this), n.addMarker(t), this.clusters.push(n));
    }, e.prototype.createClusters = function(t) {
      var n = this;
      if (this.ready) {
        t === 0 && (google.maps.event.trigger(this, "clusteringbegin", this), this.timerRefStatic !== null && (window.clearTimeout(this.timerRefStatic), delete this.timerRefStatic));
        for (var r = this.getMap(), o = r !== null && ("getBounds" in r) ? r.getBounds() : null, i = (r == null ? void 0 : r.getZoom()) || 0, a = i > 3 ? new google.maps.LatLngBounds(o == null ? void 0 : o.getSouthWest(), o == null ? void 0 : o.getNorthEast()) : new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625)), s = this.getExtendedBounds(a), l = Math.min(t + this.batchSize, this.markers.length), u = t; u < l; u++) {
          var c = this.markers[u];
          c && !c.isAdded && this.isMarkerInBounds(c, s) && (!this.ignoreHidden || this.ignoreHidden && c.getVisible()) && this.addToClosestCluster(c);
        }
        if (l < this.markers.length)
          this.timerRefStatic = window.setTimeout(function() {
            n.createClusters(l);
          }, 0);
        else {
          this.timerRefStatic = null, google.maps.event.trigger(this, "clusteringend", this);
          for (var p = 0, d = this.clusters; p < d.length; p++) {
            var h = d[p];
            h.updateIcon();
          }
        }
      }
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype) {
          var i = o;
          this.prototype[i] = r.prototype[i];
        }
        return this;
      }).apply(t, [n]);
    }, e;
  }()
);
function ej(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function cde(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? ej(Object(n), !0).forEach(function(r) {
      we(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : ej(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var di = {
  onClick: "click",
  onClusteringBegin: "clusteringbegin",
  onClusteringEnd: "clusteringend",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover"
}, pn = {
  averageCenter(e, t) {
    e.setAverageCenter(t);
  },
  batchSizeIE(e, t) {
    e.setBatchSizeIE(t);
  },
  calculator(e, t) {
    e.setCalculator(t);
  },
  clusterClass(e, t) {
    e.setClusterClass(t);
  },
  enableRetinaIcons(e, t) {
    e.setEnableRetinaIcons(t);
  },
  gridSize(e, t) {
    e.setGridSize(t);
  },
  ignoreHidden(e, t) {
    e.setIgnoreHidden(t);
  },
  imageExtension(e, t) {
    e.setImageExtension(t);
  },
  imagePath(e, t) {
    e.setImagePath(t);
  },
  imageSizes(e, t) {
    e.setImageSizes(t);
  },
  maxZoom(e, t) {
    e.setMaxZoom(t);
  },
  minimumClusterSize(e, t) {
    e.setMinimumClusterSize(t);
  },
  styles(e, t) {
    e.setStyles(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  zoomOnClick(e, t) {
    e.setZoomOnClick(t);
  }
}, pde = {};
function dde(e) {
  var {
    children: t,
    options: n,
    averageCenter: r,
    batchSizeIE: o,
    calculator: i,
    clusterClass: a,
    enableRetinaIcons: s,
    gridSize: l,
    ignoreHidden: u,
    imageExtension: c,
    imagePath: p,
    imageSizes: d,
    maxZoom: h,
    minimumClusterSize: f,
    styles: m,
    title: g,
    zoomOnClick: E,
    onClick: w,
    onClusteringBegin: M,
    onClusteringEnd: x,
    onMouseOver: y,
    onMouseOut: C,
    onLoad: P,
    onUnmount: F
  } = e, [L, N] = k(null), I = ye(St), [H, V] = k(null), [z, q] = k(null), [K, J] = k(null), [te, ee] = k(null), [_, D] = k(null);
  return v(() => {
    L && C && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(L, di.onMouseOut, C)));
  }, [C]), v(() => {
    L && y && (_ !== null && google.maps.event.removeListener(_), D(google.maps.event.addListener(L, di.onMouseOver, y)));
  }, [y]), v(() => {
    L && w && (H !== null && google.maps.event.removeListener(H), V(google.maps.event.addListener(L, di.onClick, w)));
  }, [w]), v(() => {
    L && M && (z !== null && google.maps.event.removeListener(z), q(google.maps.event.addListener(L, di.onClusteringBegin, M)));
  }, [M]), v(() => {
    L && x && (K !== null && google.maps.event.removeListener(K), q(google.maps.event.addListener(L, di.onClusteringEnd, x)));
  }, [x]), v(() => {
    typeof r < "u" && L !== null && pn.averageCenter(L, r);
  }, [L, r]), v(() => {
    typeof o < "u" && L !== null && pn.batchSizeIE(L, o);
  }, [L, o]), v(() => {
    typeof i < "u" && L !== null && pn.calculator(L, i);
  }, [L, i]), v(() => {
    typeof a < "u" && L !== null && pn.clusterClass(L, a);
  }, [L, a]), v(() => {
    typeof s < "u" && L !== null && pn.enableRetinaIcons(L, s);
  }, [L, s]), v(() => {
    typeof l < "u" && L !== null && pn.gridSize(L, l);
  }, [L, l]), v(() => {
    typeof u < "u" && L !== null && pn.ignoreHidden(L, u);
  }, [L, u]), v(() => {
    typeof c < "u" && L !== null && pn.imageExtension(L, c);
  }, [L, c]), v(() => {
    typeof p < "u" && L !== null && pn.imagePath(L, p);
  }, [L, p]), v(() => {
    typeof d < "u" && L !== null && pn.imageSizes(L, d);
  }, [L, d]), v(() => {
    typeof h < "u" && L !== null && pn.maxZoom(L, h);
  }, [L, h]), v(() => {
    typeof f < "u" && L !== null && pn.minimumClusterSize(L, f);
  }, [L, f]), v(() => {
    typeof m < "u" && L !== null && pn.styles(L, m);
  }, [L, m]), v(() => {
    typeof g < "u" && L !== null && pn.title(L, g);
  }, [L, g]), v(() => {
    typeof E < "u" && L !== null && pn.zoomOnClick(L, E);
  }, [L, E]), v(() => {
    if (I) {
      var $ = cde({}, n || pde), S = new GV(I, [], $);
      return r && pn.averageCenter(S, r), o && pn.batchSizeIE(S, o), i && pn.calculator(S, i), a && pn.clusterClass(S, a), s && pn.enableRetinaIcons(S, s), l && pn.gridSize(S, l), u && pn.ignoreHidden(S, u), c && pn.imageExtension(S, c), p && pn.imagePath(S, p), d && pn.imageSizes(S, d), h && pn.maxZoom(S, h), f && pn.minimumClusterSize(S, f), m && pn.styles(S, m), g && pn.title(S, g), E && pn.zoomOnClick(S, E), C && ee(google.maps.event.addListener(S, di.onMouseOut, C)), y && D(google.maps.event.addListener(S, di.onMouseOver, y)), w && V(google.maps.event.addListener(S, di.onClick, w)), M && q(google.maps.event.addListener(S, di.onClusteringBegin, M)), x && J(google.maps.event.addListener(S, di.onClusteringEnd, x)), N(S), P && P(S), () => {
        te !== null && google.maps.event.removeListener(te), _ !== null && google.maps.event.removeListener(_), H !== null && google.maps.event.removeListener(H), z !== null && google.maps.event.removeListener(z), K !== null && google.maps.event.removeListener(K), F && F(S);
      };
    }
  }, []), L !== null && t(L) || null;
}
Ee(dde);
class fde extends pe {
  constructor() {
    super(...arguments), we(this, "registeredEvents", []), we(this, "state", {
      markerClusterer: null
    }), we(this, "setClustererCallback", () => {
      this.state.markerClusterer !== null && this.props.onLoad && this.props.onLoad(this.state.markerClusterer);
    });
  }
  componentDidMount() {
    if (this.context) {
      var t = new GV(this.context, [], this.props.options);
      this.registeredEvents = Qt({
        updaterMap: pn,
        eventMap: di,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        markerClusterer: t
      }), this.setClustererCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.markerClusterer && (sn(this.registeredEvents), this.registeredEvents = Qt({
      updaterMap: pn,
      eventMap: di,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.markerClusterer
    }));
  }
  componentWillUnmount() {
    this.state.markerClusterer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.markerClusterer), sn(this.registeredEvents), this.state.markerClusterer.setMap(null));
  }
  render() {
    return this.state.markerClusterer !== null ? this.props.children(this.state.markerClusterer) : null;
  }
}
we(fde, "contextType", St);
function tj(e) {
  e.cancelBubble = !0, e.stopPropagation && e.stopPropagation();
}
var XV = (
  /** @class */
  function() {
    function e(t) {
      t === void 0 && (t = {}), this.getCloseClickHandler = this.getCloseClickHandler.bind(this), this.closeClickHandler = this.closeClickHandler.bind(this), this.createInfoBoxDiv = this.createInfoBoxDiv.bind(this), this.addClickHandler = this.addClickHandler.bind(this), this.getCloseBoxImg = this.getCloseBoxImg.bind(this), this.getBoxWidths = this.getBoxWidths.bind(this), this.setBoxStyle = this.setBoxStyle.bind(this), this.setPosition = this.setPosition.bind(this), this.getPosition = this.getPosition.bind(this), this.setOptions = this.setOptions.bind(this), this.setContent = this.setContent.bind(this), this.setVisible = this.setVisible.bind(this), this.getContent = this.getContent.bind(this), this.getVisible = this.getVisible.bind(this), this.setZIndex = this.setZIndex.bind(this), this.getZIndex = this.getZIndex.bind(this), this.onRemove = this.onRemove.bind(this), this.panBox = this.panBox.bind(this), this.extend = this.extend.bind(this), this.close = this.close.bind(this), this.draw = this.draw.bind(this), this.show = this.show.bind(this), this.hide = this.hide.bind(this), this.open = this.open.bind(this), this.extend(e, google.maps.OverlayView), this.content = t.content || "", this.disableAutoPan = t.disableAutoPan || !1, this.maxWidth = t.maxWidth || 0, this.pixelOffset = t.pixelOffset || new google.maps.Size(0, 0), this.position = t.position || new google.maps.LatLng(0, 0), this.zIndex = t.zIndex || null, this.boxClass = t.boxClass || "infoBox", this.boxStyle = t.boxStyle || {}, this.closeBoxMargin = t.closeBoxMargin || "2px", this.closeBoxURL = t.closeBoxURL || "http://www.google.com/intl/en_us/mapfiles/close.gif", t.closeBoxURL === "" && (this.closeBoxURL = ""), this.infoBoxClearance = t.infoBoxClearance || new google.maps.Size(1, 1), typeof t.visible > "u" && (typeof t.isHidden > "u" ? t.visible = !0 : t.visible = !t.isHidden), this.isHidden = !t.visible, this.alignBottom = t.alignBottom || !1, this.pane = t.pane || "floatPane", this.enableEventPropagation = t.enableEventPropagation || !1, this.div = null, this.closeListener = null, this.moveListener = null, this.mapListener = null, this.contextListener = null, this.eventListeners = null, this.fixedWidthSet = null;
    }
    return e.prototype.createInfoBoxDiv = function() {
      var t = this, n = function(u) {
        u.returnValue = !1, u.preventDefault && u.preventDefault(), t.enableEventPropagation || tj(u);
      };
      if (!this.div) {
        this.div = document.createElement("div"), this.setBoxStyle(), typeof this.content == "string" ? this.div.innerHTML = this.getCloseBoxImg() + this.content : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(this.content));
        var r = this.getPanes();
        if (r !== null && r[this.pane].appendChild(this.div), this.addClickHandler(), this.div.style.width)
          this.fixedWidthSet = !0;
        else if (this.maxWidth !== 0 && this.div.offsetWidth > this.maxWidth)
          this.div.style.width = this.maxWidth + "px", this.fixedWidthSet = !0;
        else {
          var o = this.getBoxWidths();
          this.div.style.width = this.div.offsetWidth - o.left - o.right + "px", this.fixedWidthSet = !1;
        }
        if (this.panBox(this.disableAutoPan), !this.enableEventPropagation) {
          this.eventListeners = [];
          for (var i = ["mousedown", "mouseover", "mouseout", "mouseup", "click", "dblclick", "touchstart", "touchend", "touchmove"], a = 0, s = i; a < s.length; a++) {
            var l = s[a];
            this.eventListeners.push(google.maps.event.addListener(this.div, l, tj));
          }
          this.eventListeners.push(google.maps.event.addListener(this.div, "mouseover", function() {
            t.div && (t.div.style.cursor = "default");
          }));
        }
        this.contextListener = google.maps.event.addListener(this.div, "contextmenu", n), google.maps.event.trigger(this, "domready");
      }
    }, e.prototype.getCloseBoxImg = function() {
      var t = "";
      return this.closeBoxURL !== "" && (t = '<img alt=""', t += ' aria-hidden="true"', t += " src='" + this.closeBoxURL + "'", t += " align=right", t += " style='", t += " position: relative;", t += " cursor: pointer;", t += " margin: " + this.closeBoxMargin + ";", t += "'>"), t;
    }, e.prototype.addClickHandler = function() {
      this.closeListener = this.div && this.div.firstChild && this.closeBoxURL !== "" ? google.maps.event.addListener(this.div.firstChild, "click", this.getCloseClickHandler()) : null;
    }, e.prototype.closeClickHandler = function(t) {
      t.cancelBubble = !0, t.stopPropagation && t.stopPropagation(), google.maps.event.trigger(this, "closeclick"), this.close();
    }, e.prototype.getCloseClickHandler = function() {
      return this.closeClickHandler;
    }, e.prototype.panBox = function(t) {
      if (this.div && !t) {
        var n = this.getMap();
        if (n instanceof google.maps.Map) {
          var r = 0, o = 0, i = n.getBounds();
          i && !i.contains(this.position) && n.setCenter(this.position);
          var a = n.getDiv(), s = a.offsetWidth, l = a.offsetHeight, u = this.pixelOffset.width, c = this.pixelOffset.height, p = this.div.offsetWidth, d = this.div.offsetHeight, h = this.infoBoxClearance.width, f = this.infoBoxClearance.height, m = this.getProjection(), g = m.fromLatLngToContainerPixel(this.position);
          g !== null && (g.x < -u + h ? r = g.x + u - h : g.x + p + u + h > s && (r = g.x + p + u + h - s), this.alignBottom ? g.y < -c + f + d ? o = g.y + c - f - d : g.y + c + f > l && (o = g.y + c + f - l) : g.y < -c + f ? o = g.y + c - f : g.y + d + c + f > l && (o = g.y + d + c + f - l)), r === 0 && o === 0 || n.panBy(r, o);
        }
      }
    }, e.prototype.setBoxStyle = function() {
      if (this.div) {
        this.div.className = this.boxClass, this.div.style.cssText = "";
        var t = this.boxStyle;
        for (var n in t)
          Object.prototype.hasOwnProperty.call(t, n) && (this.div.style[n] = t[n]);
        if (this.div.style.webkitTransform = "translateZ(0)", typeof this.div.style.opacity < "u" && this.div.style.opacity !== "") {
          var r = parseFloat(this.div.style.opacity || "");
          this.div.style.msFilter = '"progid:DXImageTransform.Microsoft.Alpha(Opacity=' + r * 100 + ')"', this.div.style.filter = "alpha(opacity=" + r * 100 + ")";
        }
        this.div.style.position = "absolute", this.div.style.visibility = "hidden", this.zIndex !== null && (this.div.style.zIndex = this.zIndex + ""), this.div.style.overflow || (this.div.style.overflow = "auto");
      }
    }, e.prototype.getBoxWidths = function() {
      var t = {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0
      };
      if (!this.div)
        return t;
      if (document.defaultView) {
        var n = this.div.ownerDocument, r = n && n.defaultView ? n.defaultView.getComputedStyle(this.div, "") : null;
        r && (t.top = parseInt(r.borderTopWidth || "", 10) || 0, t.bottom = parseInt(r.borderBottomWidth || "", 10) || 0, t.left = parseInt(r.borderLeftWidth || "", 10) || 0, t.right = parseInt(r.borderRightWidth || "", 10) || 0);
      } else if (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        document.documentElement.currentStyle
      ) {
        var o = this.div.currentStyle;
        o && (t.top = parseInt(o.borderTopWidth || "", 10) || 0, t.bottom = parseInt(o.borderBottomWidth || "", 10) || 0, t.left = parseInt(o.borderLeftWidth || "", 10) || 0, t.right = parseInt(o.borderRightWidth || "", 10) || 0);
      }
      return t;
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.div.parentNode.removeChild(this.div), this.div = null);
    }, e.prototype.draw = function() {
      if (this.createInfoBoxDiv(), this.div) {
        var t = this.getProjection(), n = t.fromLatLngToDivPixel(this.position);
        n !== null && (this.div.style.left = n.x + this.pixelOffset.width + "px", this.alignBottom ? this.div.style.bottom = -(n.y + this.pixelOffset.height) + "px" : this.div.style.top = n.y + this.pixelOffset.height + "px"), this.isHidden ? this.div.style.visibility = "hidden" : this.div.style.visibility = "visible";
      }
    }, e.prototype.setOptions = function(t) {
      t === void 0 && (t = {}), typeof t.boxClass < "u" && (this.boxClass = t.boxClass, this.setBoxStyle()), typeof t.boxStyle < "u" && (this.boxStyle = t.boxStyle, this.setBoxStyle()), typeof t.content < "u" && this.setContent(t.content), typeof t.disableAutoPan < "u" && (this.disableAutoPan = t.disableAutoPan), typeof t.maxWidth < "u" && (this.maxWidth = t.maxWidth), typeof t.pixelOffset < "u" && (this.pixelOffset = t.pixelOffset), typeof t.alignBottom < "u" && (this.alignBottom = t.alignBottom), typeof t.position < "u" && this.setPosition(t.position), typeof t.zIndex < "u" && this.setZIndex(t.zIndex), typeof t.closeBoxMargin < "u" && (this.closeBoxMargin = t.closeBoxMargin), typeof t.closeBoxURL < "u" && (this.closeBoxURL = t.closeBoxURL), typeof t.infoBoxClearance < "u" && (this.infoBoxClearance = t.infoBoxClearance), typeof t.isHidden < "u" && (this.isHidden = t.isHidden), typeof t.visible < "u" && (this.isHidden = !t.visible), typeof t.enableEventPropagation < "u" && (this.enableEventPropagation = t.enableEventPropagation), this.div && this.draw();
    }, e.prototype.setContent = function(t) {
      this.content = t, this.div && (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.fixedWidthSet || (this.div.style.width = ""), typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t)), this.fixedWidthSet || (this.div.style.width = this.div.offsetWidth + "px", typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t))), this.addClickHandler()), google.maps.event.trigger(this, "content_changed");
    }, e.prototype.setPosition = function(t) {
      this.position = t, this.div && this.draw(), google.maps.event.trigger(this, "position_changed");
    }, e.prototype.setVisible = function(t) {
      this.isHidden = !t, this.div && (this.div.style.visibility = this.isHidden ? "hidden" : "visible");
    }, e.prototype.setZIndex = function(t) {
      this.zIndex = t, this.div && (this.div.style.zIndex = t + ""), google.maps.event.trigger(this, "zindex_changed");
    }, e.prototype.getContent = function() {
      return this.content;
    }, e.prototype.getPosition = function() {
      return this.position;
    }, e.prototype.getZIndex = function() {
      return this.zIndex;
    }, e.prototype.getVisible = function() {
      var t = this.getMap();
      return typeof t > "u" || t === null ? !1 : !this.isHidden;
    }, e.prototype.show = function() {
      this.isHidden = !1, this.div && (this.div.style.visibility = "visible");
    }, e.prototype.hide = function() {
      this.isHidden = !0, this.div && (this.div.style.visibility = "hidden");
    }, e.prototype.open = function(t, n) {
      var r = this;
      n && (this.position = n.getPosition(), this.moveListener = google.maps.event.addListener(n, "position_changed", function() {
        var o = n.getPosition();
        r.setPosition(o);
      }), this.mapListener = google.maps.event.addListener(n, "map_changed", function() {
        r.setMap(n.map);
      })), this.setMap(t), this.div && this.panBox();
    }, e.prototype.close = function() {
      if (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.eventListeners) {
        for (var t = 0, n = this.eventListeners; t < n.length; t++) {
          var r = n[t];
          google.maps.event.removeListener(r);
        }
        this.eventListeners = null;
      }
      this.moveListener && (google.maps.event.removeListener(this.moveListener), this.moveListener = null), this.mapListener && (google.maps.event.removeListener(this.mapListener), this.mapListener = null), this.contextListener && (google.maps.event.removeListener(this.contextListener), this.contextListener = null), this.setMap(null);
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype)
          Object.prototype.hasOwnProperty.call(this, o) || (this.prototype[o] = r.prototype[o]);
        return this;
      }).apply(t, [n]);
    }, e;
  }()
), hde = ["position"], gde = ["position"];
function nj(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function jg(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? nj(Object(n), !0).forEach(function(r) {
      we(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : nj(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var rj = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, oj = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    t instanceof google.maps.LatLng ? e.setPosition(t) : e.setPosition(new google.maps.LatLng(t.lat, t.lng));
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, mde = {};
function vde(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, h = ye(St), [f, m] = k(null), [g, E] = k(null), [w, M] = k(null), [x, y] = k(null), [C, P] = k(null), [F, L] = k(null), N = rt(null);
  return v(() => {
    h && f !== null && (f.close(), n ? f.open(h, n) : f.getPosition() && f.open(h));
  }, [h, f, n]), v(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), v(() => {
    if (o && f !== null) {
      var I = o instanceof google.maps.LatLng ? o : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        new google.maps.LatLng(o.lat, o.lng)
      );
      f.setPosition(I);
    }
  }, [o]), v(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), v(() => {
    f && a && (g !== null && google.maps.event.removeListener(g), E(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), v(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), M(google.maps.event.addListener(f, "domready", s)));
  }, [s]), v(() => {
    f && l && (x !== null && google.maps.event.removeListener(x), y(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), v(() => {
    f && u && (C !== null && google.maps.event.removeListener(C), P(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), v(() => {
    f && c && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), v(() => {
    if (h) {
      var I = r || mde, {
        position: H
      } = I, V = gk(I, hde), z;
      H && !(H instanceof google.maps.LatLng) && (z = new google.maps.LatLng(H.lat, H.lng));
      var q = new XV(jg(jg({}, V), z ? {
        position: z
      } : {}));
      N.current = document.createElement("div"), m(q), a && E(google.maps.event.addListener(q, "closeclick", a)), s && M(google.maps.event.addListener(q, "domready", s)), l && y(google.maps.event.addListener(q, "content_changed", l)), u && P(google.maps.event.addListener(q, "position_changed", u)), c && L(google.maps.event.addListener(q, "zindex_changed", c)), q.setContent(N.current), n ? q.open(h, n) : q.getPosition() ? q.open(h) : Zr(!1, "You must provide either an anchor or a position prop for <InfoBox>."), p && p(q);
    }
    return () => {
      f !== null && (g && google.maps.event.removeListener(g), x && google.maps.event.removeListener(x), w && google.maps.event.removeListener(w), C && google.maps.event.removeListener(C), F && google.maps.event.removeListener(F), d && d(f), f.close());
    };
  }, []), N.current ? yr(at.only(t), N.current) : null;
}
Ee(vde);
class yde extends pe {
  constructor() {
    super(...arguments), we(this, "registeredEvents", []), we(this, "containerElement", null), we(this, "state", {
      infoBox: null
    }), we(this, "open", (t, n) => {
      n ? this.context !== null && t.open(this.context, n) : t.getPosition() ? this.context !== null && t.open(this.context) : Zr(!1, "You must provide either an anchor or a position prop for <InfoBox>.");
    }), we(this, "setInfoBoxCallback", () => {
      this.state.infoBox !== null && this.containerElement !== null && (this.state.infoBox.setContent(this.containerElement), this.open(this.state.infoBox, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoBox));
    });
  }
  componentDidMount() {
    var t = this.props.options || {}, {
      position: n
    } = t, r = gk(t, gde), o;
    n && !(n instanceof google.maps.LatLng) && (o = new google.maps.LatLng(n.lat, n.lng));
    var i = new XV(jg(jg({}, r), o ? {
      position: o
    } : {}));
    this.containerElement = document.createElement("div"), this.registeredEvents = Qt({
      updaterMap: oj,
      eventMap: rj,
      prevProps: {},
      nextProps: this.props,
      instance: i
    }), this.setState({
      infoBox: i
    }, this.setInfoBoxCallback);
  }
  componentDidUpdate(t) {
    var {
      infoBox: n
    } = this.state;
    n !== null && (sn(this.registeredEvents), this.registeredEvents = Qt({
      updaterMap: oj,
      eventMap: rj,
      prevProps: t,
      nextProps: this.props,
      instance: n
    }));
  }
  componentWillUnmount() {
    var {
      onUnmount: t
    } = this.props, {
      infoBox: n
    } = this.state;
    n !== null && (t && t(n), sn(this.registeredEvents), n.close());
  }
  render() {
    return this.containerElement ? yr(at.only(this.props.children), this.containerElement) : null;
  }
}
we(yde, "contextType", St);
var ij, sj;
function bde() {
  return sj || (sj = 1, ij = function e(t, n) {
    if (t === n) return !0;
    if (t && n && typeof t == "object" && typeof n == "object") {
      if (t.constructor !== n.constructor) return !1;
      var r, o, i;
      if (Array.isArray(t)) {
        if (r = t.length, r != n.length) return !1;
        for (o = r; o-- !== 0; ) if (!e(t[o], n[o])) return !1;
        return !0;
      }
      if (t.constructor === RegExp) return t.source === n.source && t.flags === n.flags;
      if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === n.valueOf();
      if (t.toString !== Object.prototype.toString) return t.toString() === n.toString();
      if (i = Object.keys(t), r = i.length, r !== Object.keys(n).length) return !1;
      for (o = r; o-- !== 0; ) if (!Object.prototype.hasOwnProperty.call(n, i[o])) return !1;
      for (o = r; o-- !== 0; ) {
        var a = i[o];
        if (!e(t[a], n[a])) return !1;
      }
      return !0;
    }
    return t !== t && n !== n;
  }), ij;
}
var wde = bde(), aj = /* @__PURE__ */ $V(wde), lj = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array], n0 = 1, Zu = 8;
class mk {
  /**
   * Creates an index from raw `ArrayBuffer` data.
   * @param {ArrayBuffer} data
   */
  static from(t) {
    if (!(t instanceof ArrayBuffer))
      throw new Error("Data must be an instance of ArrayBuffer.");
    var [n, r] = new Uint8Array(t, 0, 2);
    if (n !== 219)
      throw new Error("Data does not appear to be in a KDBush format.");
    var o = r >> 4;
    if (o !== n0)
      throw new Error("Got v".concat(o, " data when expected v").concat(n0, "."));
    var i = lj[r & 15];
    if (!i)
      throw new Error("Unrecognized array type.");
    var [a] = new Uint16Array(t, 2, 1), [s] = new Uint32Array(t, 4, 1);
    return new mk(s, a, i, t);
  }
  /**
   * Creates an index that will hold a given number of items.
   * @param {number} numItems
   * @param {number} [nodeSize=64] Size of the KD-tree node (64 by default).
   * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).
   * @param {ArrayBuffer} [data] (For internal use only)
   */
  constructor(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 64, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Float64Array, o = arguments.length > 3 ? arguments[3] : void 0;
    if (isNaN(t) || t < 0) throw new Error("Unpexpected numItems value: ".concat(t, "."));
    this.numItems = +t, this.nodeSize = Math.min(Math.max(+n, 2), 65535), this.ArrayType = r, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
    var i = lj.indexOf(this.ArrayType), a = t * 2 * this.ArrayType.BYTES_PER_ELEMENT, s = t * this.IndexArrayType.BYTES_PER_ELEMENT, l = (8 - s % 8) % 8;
    if (i < 0)
      throw new Error("Unexpected typed array class: ".concat(r, "."));
    o && o instanceof ArrayBuffer ? (this.data = o, this.ids = new this.IndexArrayType(this.data, Zu, t), this.coords = new this.ArrayType(this.data, Zu + s + l, t * 2), this._pos = t * 2, this._finished = !0) : (this.data = new ArrayBuffer(Zu + a + s + l), this.ids = new this.IndexArrayType(this.data, Zu, t), this.coords = new this.ArrayType(this.data, Zu + s + l, t * 2), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, (n0 << 4) + i]), new Uint16Array(this.data, 2, 1)[0] = n, new Uint32Array(this.data, 4, 1)[0] = t);
  }
  /**
   * Add a point to the index.
   * @param {number} x
   * @param {number} y
   * @returns {number} An incremental index associated with the added item (starting from `0`).
   */
  add(t, n) {
    var r = this._pos >> 1;
    return this.ids[r] = r, this.coords[this._pos++] = t, this.coords[this._pos++] = n, r;
  }
  /**
   * Perform indexing of the added points.
   */
  finish() {
    var t = this._pos >> 1;
    if (t !== this.numItems)
      throw new Error("Added ".concat(t, " items when expected ").concat(this.numItems, "."));
    return ix(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
  }
  /**
   * Search the index for items within a given bounding box.
   * @param {number} minX
   * @param {number} minY
   * @param {number} maxX
   * @param {number} maxY
   * @returns {number[]} An array of indices correponding to the found items.
   */
  range(t, n, r, o) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: i,
      coords: a,
      nodeSize: s
    } = this, l = [0, i.length - 1, 0], u = []; l.length; ) {
      var c = l.pop() || 0, p = l.pop() || 0, d = l.pop() || 0;
      if (p - d <= s) {
        for (var h = d; h <= p; h++) {
          var f = a[2 * h], m = a[2 * h + 1];
          f >= t && f <= r && m >= n && m <= o && u.push(i[h]);
        }
        continue;
      }
      var g = d + p >> 1, E = a[2 * g], w = a[2 * g + 1];
      E >= t && E <= r && w >= n && w <= o && u.push(i[g]), (c === 0 ? t <= E : n <= w) && (l.push(d), l.push(g - 1), l.push(1 - c)), (c === 0 ? r >= E : o >= w) && (l.push(g + 1), l.push(p), l.push(1 - c));
    }
    return u;
  }
  /**
   * Search the index for items within a given radius.
   * @param {number} qx
   * @param {number} qy
   * @param {number} r Query radius.
   * @returns {number[]} An array of indices correponding to the found items.
   */
  within(t, n, r) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: o,
      coords: i,
      nodeSize: a
    } = this, s = [0, o.length - 1, 0], l = [], u = r * r; s.length; ) {
      var c = s.pop() || 0, p = s.pop() || 0, d = s.pop() || 0;
      if (p - d <= a) {
        for (var h = d; h <= p; h++)
          uj(i[2 * h], i[2 * h + 1], t, n) <= u && l.push(o[h]);
        continue;
      }
      var f = d + p >> 1, m = i[2 * f], g = i[2 * f + 1];
      uj(m, g, t, n) <= u && l.push(o[f]), (c === 0 ? t - r <= m : n - r <= g) && (s.push(d), s.push(f - 1), s.push(1 - c)), (c === 0 ? t + r >= m : n + r >= g) && (s.push(f + 1), s.push(p), s.push(1 - c));
    }
    return l;
  }
}
function ix(e, t, n, r, o, i) {
  if (!(o - r <= n)) {
    var a = r + o >> 1;
    KV(e, t, a, r, o, i), ix(e, t, n, r, a - 1, 1 - i), ix(e, t, n, a + 1, o, 1 - i);
  }
}
function KV(e, t, n, r, o, i) {
  for (; o > r; ) {
    if (o - r > 600) {
      var a = o - r + 1, s = n - r + 1, l = Math.log(a), u = 0.5 * Math.exp(2 * l / 3), c = 0.5 * Math.sqrt(l * u * (a - u) / a) * (s - a / 2 < 0 ? -1 : 1), p = Math.max(r, Math.floor(n - s * u / a + c)), d = Math.min(o, Math.floor(n + (a - s) * u / a + c));
      KV(e, t, n, p, d, i);
    }
    var h = t[2 * n + i], f = r, m = o;
    for (Gu(e, t, r, n), t[2 * o + i] > h && Gu(e, t, r, o); f < m; ) {
      for (Gu(e, t, f, m), f++, m--; t[2 * f + i] < h; ) f++;
      for (; t[2 * m + i] > h; ) m--;
    }
    t[2 * r + i] === h ? Gu(e, t, r, m) : (m++, Gu(e, t, m, o)), m <= n && (r = m + 1), n <= m && (o = m - 1);
  }
}
function Gu(e, t, n, r) {
  r0(e, n, r), r0(t, 2 * n, 2 * r), r0(t, 2 * n + 1, 2 * r + 1);
}
function r0(e, t, n) {
  var r = e[t];
  e[t] = e[n], e[n] = r;
}
function uj(e, t, n, r) {
  var o = e - n, i = t - r;
  return o * o + i * i;
}
var Cde = {
  minZoom: 0,
  // min zoom to generate clusters on
  maxZoom: 16,
  // max zoom level to cluster the points on
  minPoints: 2,
  // minimum points to form a cluster
  radius: 40,
  // cluster radius in pixels
  extent: 512,
  // tile extent (radius is calculated relative to it)
  nodeSize: 64,
  // size of the KD-tree leaf node, affects performance
  log: !1,
  // whether to log timing info
  // whether to generate numeric ids for input features (in vector tiles)
  generateId: !1,
  // a reduce function for calculating custom cluster properties
  reduce: null,
  // (accumulated, props) => { accumulated.sum += props.sum; }
  // properties to use for individual points when running the reducer
  map: (e) => e
  // props => ({sum: props.my_value})
}, cj = Math.fround || /* @__PURE__ */ ((e) => (t) => (e[0] = +t, e[0]))(new Float32Array(1)), Ra = 2, Js = 3, o0 = 4, qs = 5, YV = 6;
class xde {
  constructor(t) {
    this.options = Object.assign(Object.create(Cde), t), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
  }
  load(t) {
    var {
      log: n,
      minZoom: r,
      maxZoom: o
    } = this.options;
    n && console.time("total time");
    var i = "prepare ".concat(t.length, " points");
    n && console.time(i), this.points = t;
    for (var a = [], s = 0; s < t.length; s++) {
      var l = t[s];
      if (l.geometry) {
        var [u, c] = l.geometry.coordinates, p = cj(Mf(u)), d = cj(Df(c));
        a.push(
          p,
          d,
          // projected point coordinates
          1 / 0,
          // the last zoom the point was processed at
          s,
          // index of the source feature in the original input array
          -1,
          // parent cluster id
          1
          // number of points in a cluster
        ), this.options.reduce && a.push(0);
      }
    }
    var h = this.trees[o + 1] = this._createTree(a);
    n && console.timeEnd(i);
    for (var f = o; f >= r; f--) {
      var m = +Date.now();
      h = this.trees[f] = this._createTree(this._cluster(h, f)), n && console.log("z%d: %d clusters in %dms", f, h.numItems, +Date.now() - m);
    }
    return n && console.timeEnd("total time"), this;
  }
  getClusters(t, n) {
    var r = ((t[0] + 180) % 360 + 360) % 360 - 180, o = Math.max(-90, Math.min(90, t[1])), i = t[2] === 180 ? 180 : ((t[2] + 180) % 360 + 360) % 360 - 180, a = Math.max(-90, Math.min(90, t[3]));
    if (t[2] - t[0] >= 360)
      r = -180, i = 180;
    else if (r > i) {
      var s = this.getClusters([r, o, 180, a], n), l = this.getClusters([-180, o, i, a], n);
      return s.concat(l);
    }
    var u = this.trees[this._limitZoom(n)], c = u.range(Mf(r), Df(a), Mf(i), Df(o)), p = u.data, d = [];
    for (var h of c) {
      var f = this.stride * h;
      d.push(p[f + qs] > 1 ? pj(p, f, this.clusterProps) : this.points[p[f + Js]]);
    }
    return d;
  }
  getChildren(t) {
    var n = this._getOriginId(t), r = this._getOriginZoom(t), o = "No cluster with the specified id.", i = this.trees[r];
    if (!i) throw new Error(o);
    var a = i.data;
    if (n * this.stride >= a.length) throw new Error(o);
    var s = this.options.radius / (this.options.extent * Math.pow(2, r - 1)), l = a[n * this.stride], u = a[n * this.stride + 1], c = i.within(l, u, s), p = [];
    for (var d of c) {
      var h = d * this.stride;
      a[h + o0] === t && p.push(a[h + qs] > 1 ? pj(a, h, this.clusterProps) : this.points[a[h + Js]]);
    }
    if (p.length === 0) throw new Error(o);
    return p;
  }
  getLeaves(t, n, r) {
    n = n || 10, r = r || 0;
    var o = [];
    return this._appendLeaves(o, t, n, r, 0), o;
  }
  getTile(t, n, r) {
    var o = this.trees[this._limitZoom(t)], i = Math.pow(2, t), {
      extent: a,
      radius: s
    } = this.options, l = s / a, u = (r - l) / i, c = (r + 1 + l) / i, p = {
      features: []
    };
    return this._addTileFeatures(o.range((n - l) / i, u, (n + 1 + l) / i, c), o.data, n, r, i, p), n === 0 && this._addTileFeatures(o.range(1 - l / i, u, 1, c), o.data, i, r, i, p), n === i - 1 && this._addTileFeatures(o.range(0, u, l / i, c), o.data, -1, r, i, p), p.features.length ? p : null;
  }
  getClusterExpansionZoom(t) {
    for (var n = this._getOriginZoom(t) - 1; n <= this.options.maxZoom; ) {
      var r = this.getChildren(t);
      if (n++, r.length !== 1) break;
      t = r[0].properties.cluster_id;
    }
    return n;
  }
  _appendLeaves(t, n, r, o, i) {
    var a = this.getChildren(n);
    for (var s of a) {
      var l = s.properties;
      if (l && l.cluster ? i + l.point_count <= o ? i += l.point_count : i = this._appendLeaves(t, l.cluster_id, r, o, i) : i < o ? i++ : t.push(s), t.length === r) break;
    }
    return i;
  }
  _createTree(t) {
    for (var n = new mk(t.length / this.stride | 0, this.options.nodeSize, Float32Array), r = 0; r < t.length; r += this.stride) n.add(t[r], t[r + 1]);
    return n.finish(), n.data = t, n;
  }
  _addTileFeatures(t, n, r, o, i, a) {
    for (var s of t) {
      var l = s * this.stride, u = n[l + qs] > 1, c = void 0, p = void 0, d = void 0;
      if (u)
        c = JV(n, l, this.clusterProps), p = n[l], d = n[l + 1];
      else {
        var h = this.points[n[l + Js]];
        c = h.properties;
        var [f, m] = h.geometry.coordinates;
        p = Mf(f), d = Df(m);
      }
      var g = {
        type: 1,
        geometry: [[Math.round(this.options.extent * (p * i - r)), Math.round(this.options.extent * (d * i - o))]],
        tags: c
      }, E = void 0;
      u || this.options.generateId ? E = n[l + Js] : E = this.points[n[l + Js]].id, E !== void 0 && (g.id = E), a.features.push(g);
    }
  }
  _limitZoom(t) {
    return Math.max(this.options.minZoom, Math.min(Math.floor(+t), this.options.maxZoom + 1));
  }
  _cluster(t, n) {
    for (var {
      radius: r,
      extent: o,
      reduce: i,
      minPoints: a
    } = this.options, s = r / (o * Math.pow(2, n)), l = t.data, u = [], c = this.stride, p = 0; p < l.length; p += c)
      if (!(l[p + Ra] <= n)) {
        l[p + Ra] = n;
        var d = l[p], h = l[p + 1], f = t.within(l[p], l[p + 1], s), m = l[p + qs], g = m;
        for (var E of f) {
          var w = E * c;
          l[w + Ra] > n && (g += l[w + qs]);
        }
        if (g > m && g >= a) {
          var M = d * m, x = h * m, y = void 0, C = -1, P = ((p / c | 0) << 5) + (n + 1) + this.points.length;
          for (var F of f) {
            var L = F * c;
            if (!(l[L + Ra] <= n)) {
              l[L + Ra] = n;
              var N = l[L + qs];
              M += l[L] * N, x += l[L + 1] * N, l[L + o0] = P, i && (y || (y = this._map(l, p, !0), C = this.clusterProps.length, this.clusterProps.push(y)), i(y, this._map(l, L)));
            }
          }
          l[p + o0] = P, u.push(M / g, x / g, 1 / 0, P, -1, g), i && u.push(C);
        } else {
          for (var I = 0; I < c; I++) u.push(l[p + I]);
          if (g > 1)
            for (var H of f) {
              var V = H * c;
              if (!(l[V + Ra] <= n)) {
                l[V + Ra] = n;
                for (var z = 0; z < c; z++) u.push(l[V + z]);
              }
            }
        }
      }
    return u;
  }
  // get index of the point from which the cluster originated
  _getOriginId(t) {
    return t - this.points.length >> 5;
  }
  // get zoom of the point from which the cluster originated
  _getOriginZoom(t) {
    return (t - this.points.length) % 32;
  }
  _map(t, n, r) {
    if (t[n + qs] > 1) {
      var o = this.clusterProps[t[n + YV]];
      return r ? Object.assign({}, o) : o;
    }
    var i = this.points[t[n + Js]].properties, a = this.options.map(i);
    return r && a === i ? Object.assign({}, a) : a;
  }
}
function pj(e, t, n) {
  return {
    type: "Feature",
    id: e[t + Js],
    properties: JV(e, t, n),
    geometry: {
      type: "Point",
      coordinates: [Ode(e[t]), Ede(e[t + 1])]
    }
  };
}
function JV(e, t, n) {
  var r = e[t + qs], o = r >= 1e4 ? "".concat(Math.round(r / 1e3), "k") : r >= 1e3 ? "".concat(Math.round(r / 100) / 10, "k") : r, i = e[t + YV], a = i === -1 ? {} : Object.assign({}, n[i]);
  return Object.assign(a, {
    cluster: !0,
    cluster_id: e[t + Js],
    point_count: r,
    point_count_abbreviated: o
  });
}
function Mf(e) {
  return e / 360 + 0.5;
}
function Df(e) {
  var t = Math.sin(e * Math.PI / 180), n = 0.5 - 0.25 * Math.log((1 + t) / (1 - t)) / Math.PI;
  return n < 0 ? 0 : n > 1 ? 1 : n;
}
function Ode(e) {
  return (e - 0.5) * 360;
}
function Ede(e) {
  var t = (180 - e * 360) * Math.PI / 180;
  return 360 * Math.atan(Math.exp(t)) / Math.PI - 90;
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function kde(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
    t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
  return n;
}
class Go {
  static isAdvancedMarkerAvailable(t) {
    return google.maps.marker && t.getMapCapabilities().isAdvancedMarkersAvailable === !0;
  }
  static isAdvancedMarker(t) {
    return google.maps.marker && t instanceof google.maps.marker.AdvancedMarkerElement;
  }
  static setMap(t, n) {
    this.isAdvancedMarker(t) ? t.map = n : t.setMap(n);
  }
  static getPosition(t) {
    if (this.isAdvancedMarker(t)) {
      if (t.position) {
        if (t.position instanceof google.maps.LatLng)
          return t.position;
        if (t.position.lat && t.position.lng)
          return new google.maps.LatLng(t.position.lat, t.position.lng);
      }
      return new google.maps.LatLng(null);
    }
    return t.getPosition();
  }
  static getVisible(t) {
    return this.isAdvancedMarker(t) ? !0 : t.getVisible();
  }
}
class sx {
  constructor(t) {
    var {
      markers: n,
      position: r
    } = t;
    this.markers = n, r && (r instanceof google.maps.LatLng ? this._position = r : this._position = new google.maps.LatLng(r));
  }
  get bounds() {
    if (!(this.markers.length === 0 && !this._position)) {
      var t = new google.maps.LatLngBounds(this._position, this._position);
      for (var n of this.markers)
        t.extend(Go.getPosition(n));
      return t;
    }
  }
  get position() {
    return this._position || this.bounds.getCenter();
  }
  /**
   * Get the count of **visible** markers.
   */
  get count() {
    return this.markers.filter((t) => Go.getVisible(t)).length;
  }
  /**
   * Add a marker to the cluster.
   */
  push(t) {
    this.markers.push(t);
  }
  /**
   * Cleanup references and remove marker from map.
   */
  delete() {
    this.marker && (Go.setMap(this.marker, null), this.marker = void 0), this.markers.length = 0;
  }
}
class Lde {
  constructor(t) {
    var {
      maxZoom: n = 16
    } = t;
    this.maxZoom = n;
  }
  /**
   * Helper function to bypass clustering based upon some map state such as
   * zoom, number of markers, etc.
   *
   * ```typescript
   *  cluster({markers, map}: AlgorithmInput): Cluster[] {
   *    if (shouldBypassClustering(map)) {
   *      return this.noop({markers})
   *    }
   * }
   * ```
   */
  noop(t) {
    var {
      markers: n
    } = t;
    return _de(n);
  }
}
var _de = (e) => {
  var t = e.map((n) => new sx({
    position: Go.getPosition(n),
    markers: [n]
  }));
  return t;
};
class Pde extends Lde {
  constructor(t) {
    var {
      maxZoom: n,
      radius: r = 60
    } = t, o = kde(t, ["maxZoom", "radius"]);
    super({
      maxZoom: n
    }), this.state = {
      zoom: -1
    }, this.superCluster = new xde(Object.assign({
      maxZoom: this.maxZoom,
      radius: r
    }, o));
  }
  calculate(t) {
    var n = !1, r = {
      zoom: t.map.getZoom()
    };
    if (!aj(t.markers, this.markers)) {
      n = !0, this.markers = [...t.markers];
      var o = this.markers.map((i) => {
        var a = Go.getPosition(i), s = [a.lng(), a.lat()];
        return {
          type: "Feature",
          geometry: {
            type: "Point",
            coordinates: s
          },
          properties: {
            marker: i
          }
        };
      });
      this.superCluster.load(o);
    }
    return n || (this.state.zoom <= this.maxZoom || r.zoom <= this.maxZoom) && (n = !aj(this.state, r)), this.state = r, n && (this.clusters = this.cluster(t)), {
      clusters: this.clusters,
      changed: n
    };
  }
  cluster(t) {
    var {
      map: n
    } = t;
    return this.superCluster.getClusters([-180, -90, 180, 90], Math.round(n.getZoom())).map((r) => this.transformCluster(r));
  }
  transformCluster(t) {
    var {
      geometry: {
        coordinates: [n, r]
      },
      properties: o
    } = t;
    if (o.cluster)
      return new sx({
        markers: this.superCluster.getLeaves(o.cluster_id, 1 / 0).map((a) => a.properties.marker),
        position: {
          lat: r,
          lng: n
        }
      });
    var i = o.marker;
    return new sx({
      markers: [i],
      position: Go.getPosition(i)
    });
  }
}
class Sde {
  constructor(t, n) {
    this.markers = {
      sum: t.length
    };
    var r = n.map((i) => i.count), o = r.reduce((i, a) => i + a, 0);
    this.clusters = {
      count: n.length,
      markers: {
        mean: o / n.length,
        sum: o,
        min: Math.min(...r),
        max: Math.max(...r)
      }
    };
  }
}
class Mde {
  /**
   * The default render function for the library used by {@link MarkerClusterer}.
   *
   * Currently set to use the following:
   *
   * ```typescript
   * // change color if this cluster has more markers than the mean cluster
   * const color =
   *   count > Math.max(10, stats.clusters.markers.mean)
   *     ? "#ff0000"
   *     : "#0000ff";
   *
   * // create svg url with fill color
   * const svg = window.btoa(`
   * <svg fill="${color}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240">
   *   <circle cx="120" cy="120" opacity=".6" r="70" />
   *   <circle cx="120" cy="120" opacity=".3" r="90" />
   *   <circle cx="120" cy="120" opacity=".2" r="110" />
   *   <circle cx="120" cy="120" opacity=".1" r="130" />
   * </svg>`);
   *
   * // create marker using svg icon
   * return new google.maps.Marker({
   *   position,
   *   icon: {
   *     url: `data:image/svg+xml;base64,${svg}`,
   *     scaledSize: new google.maps.Size(45, 45),
   *   },
   *   label: {
   *     text: String(count),
   *     color: "rgba(255,255,255,0.9)",
   *     fontSize: "12px",
   *   },
   *   // adjust zIndex to be above other markers
   *   zIndex: 1000 + count,
   * });
   * ```
   */
  render(t, n, r) {
    var {
      count: o,
      position: i
    } = t, a = o > Math.max(10, n.clusters.markers.mean) ? "#ff0000" : "#0000ff", s = '<svg fill="'.concat(a, `" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" width="50" height="50">
<circle cx="120" cy="120" opacity=".6" r="70" />
<circle cx="120" cy="120" opacity=".3" r="90" />
<circle cx="120" cy="120" opacity=".2" r="110" />
<text x="50%" y="50%" style="fill:#fff" text-anchor="middle" font-size="50" dominant-baseline="middle" font-family="roboto,arial,sans-serif">`).concat(o, `</text>
</svg>`), l = "Cluster of ".concat(o, " markers"), u = Number(google.maps.Marker.MAX_ZINDEX) + o;
    if (Go.isAdvancedMarkerAvailable(r)) {
      var c = new DOMParser(), p = c.parseFromString(s, "image/svg+xml").documentElement;
      p.setAttribute("transform", "translate(0 25)");
      var d = {
        map: r,
        position: i,
        zIndex: u,
        title: l,
        content: p
      };
      return new google.maps.marker.AdvancedMarkerElement(d);
    }
    var h = {
      position: i,
      zIndex: u,
      title: l,
      icon: {
        url: "data:image/svg+xml;base64,".concat(btoa(s)),
        anchor: new google.maps.Point(25, 25)
      }
    };
    return new google.maps.Marker(h);
  }
}
function Dde(e, t) {
  for (var n in t.prototype)
    e.prototype[n] = t.prototype[n];
}
class vk {
  constructor() {
    Dde(vk, google.maps.OverlayView);
  }
}
var Ic;
(function(e) {
  e.CLUSTERING_BEGIN = "clusteringbegin", e.CLUSTERING_END = "clusteringend", e.CLUSTER_CLICK = "click";
})(Ic || (Ic = {}));
var Tde = (e, t, n) => {
  n.fitBounds(t.bounds);
};
class jde extends vk {
  constructor(t) {
    var {
      map: n,
      markers: r = [],
      algorithmOptions: o = {},
      algorithm: i = new Pde(o),
      renderer: a = new Mde(),
      onClusterClick: s = Tde
    } = t;
    super(), this.markers = [...r], this.clusters = [], this.algorithm = i, this.renderer = a, this.onClusterClick = s, n && this.setMap(n);
  }
  addMarker(t, n) {
    this.markers.includes(t) || (this.markers.push(t), n || this.render());
  }
  addMarkers(t, n) {
    t.forEach((r) => {
      this.addMarker(r, !0);
    }), n || this.render();
  }
  removeMarker(t, n) {
    var r = this.markers.indexOf(t);
    return r === -1 ? !1 : (Go.setMap(t, null), this.markers.splice(r, 1), n || this.render(), !0);
  }
  removeMarkers(t, n) {
    var r = !1;
    return t.forEach((o) => {
      r = this.removeMarker(o, !0) || r;
    }), r && !n && this.render(), r;
  }
  clearMarkers(t) {
    this.markers.length = 0, t || this.render();
  }
  /**
   * Recalculates and draws all the marker clusters.
   */
  render() {
    var t = this.getMap();
    if (t instanceof google.maps.Map && t.getProjection()) {
      google.maps.event.trigger(this, Ic.CLUSTERING_BEGIN, this);
      var {
        clusters: n,
        changed: r
      } = this.algorithm.calculate({
        markers: this.markers,
        map: t,
        mapCanvasProjection: this.getProjection()
      });
      if (r || r == null) {
        var o = /* @__PURE__ */ new Set();
        for (var i of n)
          i.markers.length == 1 && o.add(i.markers[0]);
        var a = [];
        for (var s of this.clusters)
          s.marker != null && (s.markers.length == 1 ? o.has(s.marker) || Go.setMap(s.marker, null) : a.push(s.marker));
        this.clusters = n, this.renderClusters(), requestAnimationFrame(() => a.forEach((l) => Go.setMap(l, null)));
      }
      google.maps.event.trigger(this, Ic.CLUSTERING_END, this);
    }
  }
  onAdd() {
    this.idleListener = this.getMap().addListener("idle", this.render.bind(this)), this.render();
  }
  onRemove() {
    google.maps.event.removeListener(this.idleListener), this.reset();
  }
  reset() {
    this.markers.forEach((t) => Go.setMap(t, null)), this.clusters.forEach((t) => t.delete()), this.clusters = [];
  }
  renderClusters() {
    var t = new Sde(this.markers, this.clusters), n = this.getMap();
    this.clusters.forEach((r) => {
      r.markers.length === 1 ? r.marker = r.markers[0] : (r.marker = this.renderer.render(r, t, n), r.markers.forEach((o) => Go.setMap(o, null)), this.onClusterClick && r.marker.addListener(
        "click",
        /* istanbul ignore next */
        (o) => {
          google.maps.event.trigger(this, Ic.CLUSTER_CLICK, r), this.onClusterClick(o, r, n);
        }
      )), Go.setMap(r.marker, n);
    });
  }
}
function dj(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function fj(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? dj(Object(n), !0).forEach(function(r) {
      we(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : dj(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function Ade(e) {
  var t = Tpe(), [n, r] = k(null);
  return v(() => {
    if (t && n === null) {
      var o = new jde(fj(fj({}, e), {}, {
        map: t
      }));
      r(o);
    }
  }, [t]), n;
}
function Bde(e) {
  var {
    children: t,
    options: n
  } = e, r = Ade(n);
  return r !== null ? t(r) : null;
}
Ee(Bde);
var hj = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, gj = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
function Ide(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, h = ye(St), [f, m] = k(null), [g, E] = k(null), [w, M] = k(null), [x, y] = k(null), [C, P] = k(null), [F, L] = k(null), N = rt(null);
  return v(() => {
    f !== null && (f.close(), n ? f.open(h, n) : f.getPosition() && f.open(h));
  }, [h, f, n]), v(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), v(() => {
    o && f !== null && f.setPosition(o);
  }, [o]), v(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), v(() => {
    f && a && (g !== null && google.maps.event.removeListener(g), E(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), v(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), M(google.maps.event.addListener(f, "domready", s)));
  }, [s]), v(() => {
    f && l && (x !== null && google.maps.event.removeListener(x), y(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), v(() => {
    f && u && (C !== null && google.maps.event.removeListener(C), P(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), v(() => {
    f && c && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), v(() => {
    var I = new google.maps.InfoWindow(r);
    return m(I), N.current = document.createElement("div"), a && E(google.maps.event.addListener(I, "closeclick", a)), s && M(google.maps.event.addListener(I, "domready", s)), l && y(google.maps.event.addListener(I, "content_changed", l)), u && P(google.maps.event.addListener(I, "position_changed", u)), c && L(google.maps.event.addListener(I, "zindex_changed", c)), I.setContent(N.current), o && I.setPosition(o), i && I.setZIndex(i), n ? I.open(h, n) : I.getPosition() ? I.open(h) : Zr(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>."), p && p(I), () => {
      g && google.maps.event.removeListener(g), x && google.maps.event.removeListener(x), w && google.maps.event.removeListener(w), C && google.maps.event.removeListener(C), F && google.maps.event.removeListener(F), d && d(I), I.close();
    };
  }, []), N.current ? yr(at.only(t), N.current) : null;
}
Ee(Ide);
class Rde extends pe {
  constructor() {
    super(...arguments), we(this, "registeredEvents", []), we(this, "containerElement", null), we(this, "state", {
      infoWindow: null
    }), we(this, "open", (t, n) => {
      n ? t.open(this.context, n) : t.getPosition() ? t.open(this.context) : Zr(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>.");
    }), we(this, "setInfoWindowCallback", () => {
      this.state.infoWindow !== null && this.containerElement !== null && (this.state.infoWindow.setContent(this.containerElement), this.open(this.state.infoWindow, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoWindow));
    });
  }
  componentDidMount() {
    var t = new google.maps.InfoWindow(this.props.options);
    this.containerElement = document.createElement("div"), this.registeredEvents = Qt({
      updaterMap: gj,
      eventMap: hj,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(() => ({
      infoWindow: t
    }), this.setInfoWindowCallback);
  }
  componentDidUpdate(t) {
    this.state.infoWindow !== null && (sn(this.registeredEvents), this.registeredEvents = Qt({
      updaterMap: gj,
      eventMap: hj,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.infoWindow
    }));
  }
  componentWillUnmount() {
    this.state.infoWindow !== null && (sn(this.registeredEvents), this.props.onUnmount && this.props.onUnmount(this.state.infoWindow), this.state.infoWindow.close());
  }
  render() {
    return this.containerElement ? yr(at.only(this.props.children), this.containerElement) : null;
  }
}
we(Rde, "contextType", St);
function mj(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Ag(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? mj(Object(n), !0).forEach(function(r) {
      we(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : mj(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var vj = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, yj = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, Nde = {};
function Fde(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: h,
    onRightClick: f,
    onClick: m,
    onDrag: g,
    onLoad: E,
    onUnmount: w
  } = e, M = ye(St), [x, y] = k(null), [C, P] = k(null), [F, L] = k(null), [N, I] = k(null), [H, V] = k(null), [z, q] = k(null), [K, J] = k(null), [te, ee] = k(null), [_, D] = k(null), [$, S] = k(null), [W, O] = k(null), [T, U] = k(null);
  return v(() => {
    x !== null && x.setMap(M);
  }, [M]), v(() => {
    typeof t < "u" && x !== null && x.setOptions(t);
  }, [x, t]), v(() => {
    typeof n < "u" && x !== null && x.setDraggable(n);
  }, [x, n]), v(() => {
    typeof r < "u" && x !== null && x.setEditable(r);
  }, [x, r]), v(() => {
    typeof o < "u" && x !== null && x.setVisible(o);
  }, [x, o]), v(() => {
    typeof i < "u" && x !== null && x.setPath(i);
  }, [x, i]), v(() => {
    x && a && (C !== null && google.maps.event.removeListener(C), P(google.maps.event.addListener(x, "dblclick", a)));
  }, [a]), v(() => {
    x && s && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(x, "dragend", s)));
  }, [s]), v(() => {
    x && l && (N !== null && google.maps.event.removeListener(N), I(google.maps.event.addListener(x, "dragstart", l)));
  }, [l]), v(() => {
    x && u && (H !== null && google.maps.event.removeListener(H), V(google.maps.event.addListener(x, "mousedown", u)));
  }, [u]), v(() => {
    x && c && (z !== null && google.maps.event.removeListener(z), q(google.maps.event.addListener(x, "mousemove", c)));
  }, [c]), v(() => {
    x && p && (K !== null && google.maps.event.removeListener(K), J(google.maps.event.addListener(x, "mouseout", p)));
  }, [p]), v(() => {
    x && d && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(x, "mouseover", d)));
  }, [d]), v(() => {
    x && h && (_ !== null && google.maps.event.removeListener(_), D(google.maps.event.addListener(x, "mouseup", h)));
  }, [h]), v(() => {
    x && f && ($ !== null && google.maps.event.removeListener($), S(google.maps.event.addListener(x, "rightclick", f)));
  }, [f]), v(() => {
    x && m && (W !== null && google.maps.event.removeListener(W), O(google.maps.event.addListener(x, "click", m)));
  }, [m]), v(() => {
    x && g && (T !== null && google.maps.event.removeListener(T), U(google.maps.event.addListener(x, "drag", g)));
  }, [g]), v(() => {
    var j = new google.maps.Polyline(Ag(Ag({}, t || Nde), {}, {
      map: M
    }));
    return i && j.setPath(i), typeof o < "u" && j.setVisible(o), typeof r < "u" && j.setEditable(r), typeof n < "u" && j.setDraggable(n), a && P(google.maps.event.addListener(j, "dblclick", a)), s && L(google.maps.event.addListener(j, "dragend", s)), l && I(google.maps.event.addListener(j, "dragstart", l)), u && V(google.maps.event.addListener(j, "mousedown", u)), c && q(google.maps.event.addListener(j, "mousemove", c)), p && J(google.maps.event.addListener(j, "mouseout", p)), d && ee(google.maps.event.addListener(j, "mouseover", d)), h && D(google.maps.event.addListener(j, "mouseup", h)), f && S(google.maps.event.addListener(j, "rightclick", f)), m && O(google.maps.event.addListener(j, "click", m)), g && U(google.maps.event.addListener(j, "drag", g)), y(j), E && E(j), () => {
      C !== null && google.maps.event.removeListener(C), F !== null && google.maps.event.removeListener(F), N !== null && google.maps.event.removeListener(N), H !== null && google.maps.event.removeListener(H), z !== null && google.maps.event.removeListener(z), K !== null && google.maps.event.removeListener(K), te !== null && google.maps.event.removeListener(te), _ !== null && google.maps.event.removeListener(_), $ !== null && google.maps.event.removeListener($), W !== null && google.maps.event.removeListener(W), w && w(j), j.setMap(null);
    };
  }, []), null;
}
Ee(Fde);
class zde extends pe {
  constructor() {
    super(...arguments), we(this, "registeredEvents", []), we(this, "state", {
      polyline: null
    }), we(this, "setPolylineCallback", () => {
      this.state.polyline !== null && this.props.onLoad && this.props.onLoad(this.state.polyline);
    });
  }
  componentDidMount() {
    var t = new google.maps.Polyline(Ag(Ag({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Qt({
      updaterMap: yj,
      eventMap: vj,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        polyline: t
      };
    }, this.setPolylineCallback);
  }
  componentDidUpdate(t) {
    this.state.polyline !== null && (sn(this.registeredEvents), this.registeredEvents = Qt({
      updaterMap: yj,
      eventMap: vj,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.polyline
    }));
  }
  componentWillUnmount() {
    this.state.polyline !== null && (this.props.onUnmount && this.props.onUnmount(this.state.polyline), sn(this.registeredEvents), this.state.polyline.setMap(null));
  }
  render() {
    return null;
  }
}
we(zde, "contextType", St);
function bj(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function wj(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? bj(Object(n), !0).forEach(function(r) {
      we(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : bj(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Cj = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, xj = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  paths(e, t) {
    e.setPaths(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function Ude(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    paths: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: h,
    onMouseUp: f,
    onRightClick: m,
    onClick: g,
    onDrag: E,
    onLoad: w,
    onUnmount: M,
    onEdit: x
  } = e, y = ye(St), [C, P] = k(null), [F, L] = k(null), [N, I] = k(null), [H, V] = k(null), [z, q] = k(null), [K, J] = k(null), [te, ee] = k(null), [_, D] = k(null), [$, S] = k(null), [W, O] = k(null), [T, U] = k(null), [j, Z] = k(null);
  return v(() => {
    C !== null && C.setMap(y);
  }, [y]), v(() => {
    typeof t < "u" && C !== null && C.setOptions(t);
  }, [C, t]), v(() => {
    typeof n < "u" && C !== null && C.setDraggable(n);
  }, [C, n]), v(() => {
    typeof r < "u" && C !== null && C.setEditable(r);
  }, [C, r]), v(() => {
    typeof o < "u" && C !== null && C.setVisible(o);
  }, [C, o]), v(() => {
    typeof i < "u" && C !== null && C.setPath(i);
  }, [C, i]), v(() => {
    typeof a < "u" && C !== null && C.setPaths(a);
  }, [C, a]), v(() => {
    C && typeof s == "function" && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(C, "dblclick", s)));
  }, [s]), v(() => {
    C && (google.maps.event.addListener(C.getPath(), "insert_at", () => {
      x == null || x(C);
    }), google.maps.event.addListener(C.getPath(), "set_at", () => {
      x == null || x(C);
    }), google.maps.event.addListener(C.getPath(), "remove_at", () => {
      x == null || x(C);
    }));
  }, [C, x]), v(() => {
    C && typeof l == "function" && (N !== null && google.maps.event.removeListener(N), I(google.maps.event.addListener(C, "dragend", l)));
  }, [l]), v(() => {
    C && typeof u == "function" && (H !== null && google.maps.event.removeListener(H), V(google.maps.event.addListener(C, "dragstart", u)));
  }, [u]), v(() => {
    C && typeof c == "function" && (z !== null && google.maps.event.removeListener(z), q(google.maps.event.addListener(C, "mousedown", c)));
  }, [c]), v(() => {
    C && typeof p == "function" && (K !== null && google.maps.event.removeListener(K), J(google.maps.event.addListener(C, "mousemove", p)));
  }, [p]), v(() => {
    C && typeof d == "function" && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(C, "mouseout", d)));
  }, [d]), v(() => {
    C && typeof h == "function" && (_ !== null && google.maps.event.removeListener(_), D(google.maps.event.addListener(C, "mouseover", h)));
  }, [h]), v(() => {
    C && typeof f == "function" && ($ !== null && google.maps.event.removeListener($), S(google.maps.event.addListener(C, "mouseup", f)));
  }, [f]), v(() => {
    C && typeof m == "function" && (W !== null && google.maps.event.removeListener(W), O(google.maps.event.addListener(C, "rightclick", m)));
  }, [m]), v(() => {
    C && typeof g == "function" && (T !== null && google.maps.event.removeListener(T), U(google.maps.event.addListener(C, "click", g)));
  }, [g]), v(() => {
    C && typeof E == "function" && (j !== null && google.maps.event.removeListener(j), Z(google.maps.event.addListener(C, "drag", E)));
  }, [E]), v(() => {
    var A = new google.maps.Polygon(wj(wj({}, t), {}, {
      map: y
    }));
    return i && A.setPath(i), a && A.setPaths(a), typeof o < "u" && A.setVisible(o), typeof r < "u" && A.setEditable(r), typeof n < "u" && A.setDraggable(n), s && L(google.maps.event.addListener(A, "dblclick", s)), l && I(google.maps.event.addListener(A, "dragend", l)), u && V(google.maps.event.addListener(A, "dragstart", u)), c && q(google.maps.event.addListener(A, "mousedown", c)), p && J(google.maps.event.addListener(A, "mousemove", p)), d && ee(google.maps.event.addListener(A, "mouseout", d)), h && D(google.maps.event.addListener(A, "mouseover", h)), f && S(google.maps.event.addListener(A, "mouseup", f)), m && O(google.maps.event.addListener(A, "rightclick", m)), g && U(google.maps.event.addListener(A, "click", g)), E && Z(google.maps.event.addListener(A, "drag", E)), P(A), w && w(A), () => {
      F !== null && google.maps.event.removeListener(F), N !== null && google.maps.event.removeListener(N), H !== null && google.maps.event.removeListener(H), z !== null && google.maps.event.removeListener(z), K !== null && google.maps.event.removeListener(K), te !== null && google.maps.event.removeListener(te), _ !== null && google.maps.event.removeListener(_), $ !== null && google.maps.event.removeListener($), W !== null && google.maps.event.removeListener(W), T !== null && google.maps.event.removeListener(T), M && M(A), A.setMap(null);
    };
  }, []), null;
}
Ee(Ude);
class $de extends pe {
  constructor() {
    super(...arguments), we(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this.props.options || {};
    this.polygon = new google.maps.Polygon(t), this.polygon.setMap(this.context), this.registeredEvents = Qt({
      updaterMap: xj,
      eventMap: Cj,
      prevProps: {},
      nextProps: this.props,
      instance: this.polygon
    }), this.props.onLoad && this.props.onLoad(this.polygon);
  }
  componentDidUpdate(t) {
    this.polygon && (sn(this.registeredEvents), this.registeredEvents = Qt({
      updaterMap: xj,
      eventMap: Cj,
      prevProps: t,
      nextProps: this.props,
      instance: this.polygon
    }));
  }
  componentWillUnmount() {
    this.polygon && (this.props.onUnmount && this.props.onUnmount(this.polygon), sn(this.registeredEvents), this.polygon && this.polygon.setMap(null));
  }
  render() {
    return null;
  }
}
we($de, "contextType", St);
function Oj(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Bg(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Oj(Object(n), !0).forEach(function(r) {
      we(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Oj(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Ej = {
  onBoundsChanged: "bounds_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, kj = {
  bounds(e, t) {
    e.setBounds(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function Hde(e) {
  var {
    options: t,
    bounds: n,
    draggable: r,
    editable: o,
    visible: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: h,
    onRightClick: f,
    onClick: m,
    onDrag: g,
    onBoundsChanged: E,
    onLoad: w,
    onUnmount: M
  } = e, x = ye(St), [y, C] = k(null), [P, F] = k(null), [L, N] = k(null), [I, H] = k(null), [V, z] = k(null), [q, K] = k(null), [J, te] = k(null), [ee, _] = k(null), [D, $] = k(null), [S, W] = k(null), [O, T] = k(null), [U, j] = k(null), [Z, A] = k(null);
  return v(() => {
    y !== null && y.setMap(x);
  }, [x]), v(() => {
    typeof t < "u" && y !== null && y.setOptions(t);
  }, [y, t]), v(() => {
    typeof r < "u" && y !== null && y.setDraggable(r);
  }, [y, r]), v(() => {
    typeof o < "u" && y !== null && y.setEditable(o);
  }, [y, o]), v(() => {
    typeof i < "u" && y !== null && y.setVisible(i);
  }, [y, i]), v(() => {
    typeof n < "u" && y !== null && y.setBounds(n);
  }, [y, n]), v(() => {
    y && a && (P !== null && google.maps.event.removeListener(P), F(google.maps.event.addListener(y, "dblclick", a)));
  }, [a]), v(() => {
    y && s && (L !== null && google.maps.event.removeListener(L), N(google.maps.event.addListener(y, "dragend", s)));
  }, [s]), v(() => {
    y && l && (I !== null && google.maps.event.removeListener(I), H(google.maps.event.addListener(y, "dragstart", l)));
  }, [l]), v(() => {
    y && u && (V !== null && google.maps.event.removeListener(V), z(google.maps.event.addListener(y, "mousedown", u)));
  }, [u]), v(() => {
    y && c && (q !== null && google.maps.event.removeListener(q), K(google.maps.event.addListener(y, "mousemove", c)));
  }, [c]), v(() => {
    y && p && (J !== null && google.maps.event.removeListener(J), te(google.maps.event.addListener(y, "mouseout", p)));
  }, [p]), v(() => {
    y && d && (ee !== null && google.maps.event.removeListener(ee), _(google.maps.event.addListener(y, "mouseover", d)));
  }, [d]), v(() => {
    y && h && (D !== null && google.maps.event.removeListener(D), $(google.maps.event.addListener(y, "mouseup", h)));
  }, [h]), v(() => {
    y && f && (S !== null && google.maps.event.removeListener(S), W(google.maps.event.addListener(y, "rightclick", f)));
  }, [f]), v(() => {
    y && m && (O !== null && google.maps.event.removeListener(O), T(google.maps.event.addListener(y, "click", m)));
  }, [m]), v(() => {
    y && g && (U !== null && google.maps.event.removeListener(U), j(google.maps.event.addListener(y, "drag", g)));
  }, [g]), v(() => {
    y && E && (Z !== null && google.maps.event.removeListener(Z), A(google.maps.event.addListener(y, "bounds_changed", E)));
  }, [E]), v(() => {
    var Q = new google.maps.Rectangle(Bg(Bg({}, t), {}, {
      map: x
    }));
    return typeof i < "u" && Q.setVisible(i), typeof o < "u" && Q.setEditable(o), typeof r < "u" && Q.setDraggable(r), typeof n < "u" && Q.setBounds(n), a && F(google.maps.event.addListener(Q, "dblclick", a)), s && N(google.maps.event.addListener(Q, "dragend", s)), l && H(google.maps.event.addListener(Q, "dragstart", l)), u && z(google.maps.event.addListener(Q, "mousedown", u)), c && K(google.maps.event.addListener(Q, "mousemove", c)), p && te(google.maps.event.addListener(Q, "mouseout", p)), d && _(google.maps.event.addListener(Q, "mouseover", d)), h && $(google.maps.event.addListener(Q, "mouseup", h)), f && W(google.maps.event.addListener(Q, "rightclick", f)), m && T(google.maps.event.addListener(Q, "click", m)), g && j(google.maps.event.addListener(Q, "drag", g)), E && A(google.maps.event.addListener(Q, "bounds_changed", E)), C(Q), w && w(Q), () => {
      P !== null && google.maps.event.removeListener(P), L !== null && google.maps.event.removeListener(L), I !== null && google.maps.event.removeListener(I), V !== null && google.maps.event.removeListener(V), q !== null && google.maps.event.removeListener(q), J !== null && google.maps.event.removeListener(J), ee !== null && google.maps.event.removeListener(ee), D !== null && google.maps.event.removeListener(D), S !== null && google.maps.event.removeListener(S), O !== null && google.maps.event.removeListener(O), U !== null && google.maps.event.removeListener(U), Z !== null && google.maps.event.removeListener(Z), M && M(Q), Q.setMap(null);
    };
  }, []), null;
}
Ee(Hde);
class Wde extends pe {
  constructor() {
    super(...arguments), we(this, "registeredEvents", []), we(this, "state", {
      rectangle: null
    }), we(this, "setRectangleCallback", () => {
      this.state.rectangle !== null && this.props.onLoad && this.props.onLoad(this.state.rectangle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Rectangle(Bg(Bg({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Qt({
      updaterMap: kj,
      eventMap: Ej,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        rectangle: t
      };
    }, this.setRectangleCallback);
  }
  componentDidUpdate(t) {
    this.state.rectangle !== null && (sn(this.registeredEvents), this.registeredEvents = Qt({
      updaterMap: kj,
      eventMap: Ej,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.rectangle
    }));
  }
  componentWillUnmount() {
    this.state.rectangle !== null && (this.props.onUnmount && this.props.onUnmount(this.state.rectangle), sn(this.registeredEvents), this.state.rectangle.setMap(null));
  }
  render() {
    return null;
  }
}
we(Wde, "contextType", St);
function Lj(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Ig(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Lj(Object(n), !0).forEach(function(r) {
      we(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Lj(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var _j = {
  onCenterChanged: "center_changed",
  onRadiusChanged: "radius_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, Pj = {
  center(e, t) {
    e.setCenter(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  radius(e, t) {
    e.setRadius(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, Vde = {};
function qde(e) {
  var {
    options: t,
    center: n,
    radius: r,
    draggable: o,
    editable: i,
    visible: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: h,
    onMouseUp: f,
    onRightClick: m,
    onClick: g,
    onDrag: E,
    onCenterChanged: w,
    onRadiusChanged: M,
    onLoad: x,
    onUnmount: y
  } = e, C = ye(St), [P, F] = k(null), [L, N] = k(null), [I, H] = k(null), [V, z] = k(null), [q, K] = k(null), [J, te] = k(null), [ee, _] = k(null), [D, $] = k(null), [S, W] = k(null), [O, T] = k(null), [U, j] = k(null), [Z, A] = k(null), [Q, R] = k(null), [ue, fe] = k(null);
  return v(() => {
    P !== null && P.setMap(C);
  }, [C]), v(() => {
    typeof t < "u" && P !== null && P.setOptions(t);
  }, [P, t]), v(() => {
    typeof o < "u" && P !== null && P.setDraggable(o);
  }, [P, o]), v(() => {
    typeof i < "u" && P !== null && P.setEditable(i);
  }, [P, i]), v(() => {
    typeof a < "u" && P !== null && P.setVisible(a);
  }, [P, a]), v(() => {
    typeof r == "number" && P !== null && P.setRadius(r);
  }, [P, r]), v(() => {
    typeof n < "u" && P !== null && P.setCenter(n);
  }, [P, n]), v(() => {
    P && s && (L !== null && google.maps.event.removeListener(L), N(google.maps.event.addListener(P, "dblclick", s)));
  }, [s]), v(() => {
    P && l && (I !== null && google.maps.event.removeListener(I), H(google.maps.event.addListener(P, "dragend", l)));
  }, [l]), v(() => {
    P && u && (V !== null && google.maps.event.removeListener(V), z(google.maps.event.addListener(P, "dragstart", u)));
  }, [u]), v(() => {
    P && c && (q !== null && google.maps.event.removeListener(q), K(google.maps.event.addListener(P, "mousedown", c)));
  }, [c]), v(() => {
    P && p && (J !== null && google.maps.event.removeListener(J), te(google.maps.event.addListener(P, "mousemove", p)));
  }, [p]), v(() => {
    P && d && (ee !== null && google.maps.event.removeListener(ee), _(google.maps.event.addListener(P, "mouseout", d)));
  }, [d]), v(() => {
    P && h && (D !== null && google.maps.event.removeListener(D), $(google.maps.event.addListener(P, "mouseover", h)));
  }, [h]), v(() => {
    P && f && (S !== null && google.maps.event.removeListener(S), W(google.maps.event.addListener(P, "mouseup", f)));
  }, [f]), v(() => {
    P && m && (O !== null && google.maps.event.removeListener(O), T(google.maps.event.addListener(P, "rightclick", m)));
  }, [m]), v(() => {
    P && g && (U !== null && google.maps.event.removeListener(U), j(google.maps.event.addListener(P, "click", g)));
  }, [g]), v(() => {
    P && E && (Z !== null && google.maps.event.removeListener(Z), A(google.maps.event.addListener(P, "drag", E)));
  }, [E]), v(() => {
    P && w && (Q !== null && google.maps.event.removeListener(Q), R(google.maps.event.addListener(P, "center_changed", w)));
  }, [g]), v(() => {
    P && M && (ue !== null && google.maps.event.removeListener(ue), fe(google.maps.event.addListener(P, "radius_changed", M)));
  }, [M]), v(() => {
    var oe = new google.maps.Circle(Ig(Ig({}, t || Vde), {}, {
      map: C
    }));
    return typeof r == "number" && oe.setRadius(r), typeof n < "u" && oe.setCenter(n), typeof r == "number" && oe.setRadius(r), typeof a < "u" && oe.setVisible(a), typeof i < "u" && oe.setEditable(i), typeof o < "u" && oe.setDraggable(o), s && N(google.maps.event.addListener(oe, "dblclick", s)), l && H(google.maps.event.addListener(oe, "dragend", l)), u && z(google.maps.event.addListener(oe, "dragstart", u)), c && K(google.maps.event.addListener(oe, "mousedown", c)), p && te(google.maps.event.addListener(oe, "mousemove", p)), d && _(google.maps.event.addListener(oe, "mouseout", d)), h && $(google.maps.event.addListener(oe, "mouseover", h)), f && W(google.maps.event.addListener(oe, "mouseup", f)), m && T(google.maps.event.addListener(oe, "rightclick", m)), g && j(google.maps.event.addListener(oe, "click", g)), E && A(google.maps.event.addListener(oe, "drag", E)), w && R(google.maps.event.addListener(oe, "center_changed", w)), M && fe(google.maps.event.addListener(oe, "radius_changed", M)), F(oe), x && x(oe), () => {
      L !== null && google.maps.event.removeListener(L), I !== null && google.maps.event.removeListener(I), V !== null && google.maps.event.removeListener(V), q !== null && google.maps.event.removeListener(q), J !== null && google.maps.event.removeListener(J), ee !== null && google.maps.event.removeListener(ee), D !== null && google.maps.event.removeListener(D), S !== null && google.maps.event.removeListener(S), O !== null && google.maps.event.removeListener(O), U !== null && google.maps.event.removeListener(U), Q !== null && google.maps.event.removeListener(Q), ue !== null && google.maps.event.removeListener(ue), y && y(oe), oe.setMap(null);
    };
  }, []), null;
}
Ee(qde);
class Zde extends pe {
  constructor() {
    super(...arguments), we(this, "registeredEvents", []), we(this, "state", {
      circle: null
    }), we(this, "setCircleCallback", () => {
      this.state.circle !== null && this.props.onLoad && this.props.onLoad(this.state.circle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Circle(Ig(Ig({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Qt({
      updaterMap: Pj,
      eventMap: _j,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        circle: t
      };
    }, this.setCircleCallback);
  }
  componentDidUpdate(t) {
    this.state.circle !== null && (sn(this.registeredEvents), this.registeredEvents = Qt({
      updaterMap: Pj,
      eventMap: _j,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.circle
    }));
  }
  componentWillUnmount() {
    if (this.state.circle !== null) {
      var t;
      this.props.onUnmount && this.props.onUnmount(this.state.circle), sn(this.registeredEvents), (t = this.state.circle) === null || t === void 0 || t.setMap(null);
    }
  }
  render() {
    return null;
  }
}
we(Zde, "contextType", St);
function Sj(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Rg(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Sj(Object(n), !0).forEach(function(r) {
      we(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Sj(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Mj = {
  onClick: "click",
  onDblClick: "dblclick",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onAddFeature: "addfeature",
  onRemoveFeature: "removefeature",
  onRemoveProperty: "removeproperty",
  onSetGeometry: "setgeometry",
  onSetProperty: "setproperty"
}, Dj = {
  add(e, t) {
    e.add(t);
  },
  addgeojson(e, t, n) {
    e.addGeoJson(t, n);
  },
  contains(e, t) {
    e.contains(t);
  },
  foreach(e, t) {
    e.forEach(t);
  },
  loadgeojson(e, t, n, r) {
    e.loadGeoJson(t, n, r);
  },
  overridestyle(e, t, n) {
    e.overrideStyle(t, n);
  },
  remove(e, t) {
    e.remove(t);
  },
  revertstyle(e, t) {
    e.revertStyle(t);
  },
  controlposition(e, t) {
    e.setControlPosition(t);
  },
  controls(e, t) {
    e.setControls(t);
  },
  drawingmode(e, t) {
    e.setDrawingMode(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  style(e, t) {
    e.setStyle(t);
  },
  togeojson(e, t) {
    e.toGeoJson(t);
  }
};
function Gde(e) {
  var {
    options: t,
    onClick: n,
    onDblClick: r,
    onMouseDown: o,
    onMouseMove: i,
    onMouseOut: a,
    onMouseOver: s,
    onMouseUp: l,
    onRightClick: u,
    onAddFeature: c,
    onRemoveFeature: p,
    onRemoveProperty: d,
    onSetGeometry: h,
    onSetProperty: f,
    onLoad: m,
    onUnmount: g
  } = e, E = ye(St), [w, M] = k(null), [x, y] = k(null), [C, P] = k(null), [F, L] = k(null), [N, I] = k(null), [H, V] = k(null), [z, q] = k(null), [K, J] = k(null), [te, ee] = k(null), [_, D] = k(null), [$, S] = k(null), [W, O] = k(null), [T, U] = k(null), [j, Z] = k(null);
  return v(() => {
    w !== null && w.setMap(E);
  }, [E]), v(() => {
    w && r && (x !== null && google.maps.event.removeListener(x), y(google.maps.event.addListener(w, "dblclick", r)));
  }, [r]), v(() => {
    w && o && (C !== null && google.maps.event.removeListener(C), P(google.maps.event.addListener(w, "mousedown", o)));
  }, [o]), v(() => {
    w && i && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(w, "mousemove", i)));
  }, [i]), v(() => {
    w && a && (N !== null && google.maps.event.removeListener(N), I(google.maps.event.addListener(w, "mouseout", a)));
  }, [a]), v(() => {
    w && s && (H !== null && google.maps.event.removeListener(H), V(google.maps.event.addListener(w, "mouseover", s)));
  }, [s]), v(() => {
    w && l && (z !== null && google.maps.event.removeListener(z), q(google.maps.event.addListener(w, "mouseup", l)));
  }, [l]), v(() => {
    w && u && (K !== null && google.maps.event.removeListener(K), J(google.maps.event.addListener(w, "rightclick", u)));
  }, [u]), v(() => {
    w && n && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(w, "click", n)));
  }, [n]), v(() => {
    w && c && (_ !== null && google.maps.event.removeListener(_), D(google.maps.event.addListener(w, "addfeature", c)));
  }, [c]), v(() => {
    w && p && ($ !== null && google.maps.event.removeListener($), S(google.maps.event.addListener(w, "removefeature", p)));
  }, [p]), v(() => {
    w && d && (W !== null && google.maps.event.removeListener(W), O(google.maps.event.addListener(w, "removeproperty", d)));
  }, [d]), v(() => {
    w && h && (T !== null && google.maps.event.removeListener(T), U(google.maps.event.addListener(w, "setgeometry", h)));
  }, [h]), v(() => {
    w && f && (j !== null && google.maps.event.removeListener(j), Z(google.maps.event.addListener(w, "setproperty", f)));
  }, [f]), v(() => {
    if (E !== null) {
      var A = new google.maps.Data(Rg(Rg({}, t), {}, {
        map: E
      }));
      r && y(google.maps.event.addListener(A, "dblclick", r)), o && P(google.maps.event.addListener(A, "mousedown", o)), i && L(google.maps.event.addListener(A, "mousemove", i)), a && I(google.maps.event.addListener(A, "mouseout", a)), s && V(google.maps.event.addListener(A, "mouseover", s)), l && q(google.maps.event.addListener(A, "mouseup", l)), u && J(google.maps.event.addListener(A, "rightclick", u)), n && ee(google.maps.event.addListener(A, "click", n)), c && D(google.maps.event.addListener(A, "addfeature", c)), p && S(google.maps.event.addListener(A, "removefeature", p)), d && O(google.maps.event.addListener(A, "removeproperty", d)), h && U(google.maps.event.addListener(A, "setgeometry", h)), f && Z(google.maps.event.addListener(A, "setproperty", f)), M(A), m && m(A);
    }
    return () => {
      w && (x !== null && google.maps.event.removeListener(x), C !== null && google.maps.event.removeListener(C), F !== null && google.maps.event.removeListener(F), N !== null && google.maps.event.removeListener(N), H !== null && google.maps.event.removeListener(H), z !== null && google.maps.event.removeListener(z), K !== null && google.maps.event.removeListener(K), te !== null && google.maps.event.removeListener(te), _ !== null && google.maps.event.removeListener(_), $ !== null && google.maps.event.removeListener($), W !== null && google.maps.event.removeListener(W), T !== null && google.maps.event.removeListener(T), j !== null && google.maps.event.removeListener(j), g && g(w), w.setMap(null));
    };
  }, []), null;
}
Ee(Gde);
class Xde extends pe {
  constructor() {
    super(...arguments), we(this, "registeredEvents", []), we(this, "state", {
      data: null
    }), we(this, "setDataCallback", () => {
      this.state.data !== null && this.props.onLoad && this.props.onLoad(this.state.data);
    });
  }
  componentDidMount() {
    if (this.context !== null) {
      var t = new google.maps.Data(Rg(Rg({}, this.props.options), {}, {
        map: this.context
      }));
      this.registeredEvents = Qt({
        updaterMap: Dj,
        eventMap: Mj,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        data: t
      }), this.setDataCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.data !== null && (sn(this.registeredEvents), this.registeredEvents = Qt({
      updaterMap: Dj,
      eventMap: Mj,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.data
    }));
  }
  componentWillUnmount() {
    this.state.data !== null && (this.props.onUnmount && this.props.onUnmount(this.state.data), sn(this.registeredEvents), this.state.data && this.state.data.setMap(null));
  }
  render() {
    return null;
  }
}
we(Xde, "contextType", St);
function Tj(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function jj(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Tj(Object(n), !0).forEach(function(r) {
      we(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Tj(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Aj = {
  onClick: "click",
  onDefaultViewportChanged: "defaultviewport_changed",
  onStatusChanged: "status_changed"
}, Bj = {
  options(e, t) {
    e.setOptions(t);
  },
  url(e, t) {
    e.setUrl(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
class Kde extends pe {
  constructor() {
    super(...arguments), we(this, "registeredEvents", []), we(this, "state", {
      kmlLayer: null
    }), we(this, "setKmlLayerCallback", () => {
      this.state.kmlLayer !== null && this.props.onLoad && this.props.onLoad(this.state.kmlLayer);
    });
  }
  componentDidMount() {
    var t = new google.maps.KmlLayer(jj(jj({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Qt({
      updaterMap: Bj,
      eventMap: Aj,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        kmlLayer: t
      };
    }, this.setKmlLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.kmlLayer !== null && (sn(this.registeredEvents), this.registeredEvents = Qt({
      updaterMap: Bj,
      eventMap: Aj,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.kmlLayer
    }));
  }
  componentWillUnmount() {
    this.state.kmlLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.kmlLayer), sn(this.registeredEvents), this.state.kmlLayer.setMap(null));
  }
  render() {
    return null;
  }
}
we(Kde, "contextType", St);
function QV(e, t) {
  return typeof t == "function" ? t(e.offsetWidth, e.offsetHeight) : {
    x: 0,
    y: 0
  };
}
function Yde(e, t) {
  return new t(e.lat, e.lng);
}
function Jde(e, t) {
  return new t(new google.maps.LatLng(e.ne.lat, e.ne.lng), new google.maps.LatLng(e.sw.lat, e.sw.lng));
}
function Qde(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function efe(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function tfe(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n.getNorthEast()), o = e && e.fromLatLngToDivPixel(n.getSouthWest());
  return r && o ? {
    left: "".concat(o.x + t.x, "px"),
    top: "".concat(r.y + t.y, "px"),
    width: "".concat(r.x - o.x - t.x, "px"),
    height: "".concat(o.y - r.y - t.y, "px")
  } : {
    left: "-9999px",
    top: "-9999px"
  };
}
function nfe(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n);
  if (r) {
    var {
      x: o,
      y: i
    } = r;
    return {
      left: "".concat(o + t.x, "px"),
      top: "".concat(i + t.y, "px")
    };
  }
  return {
    left: "-9999px",
    top: "-9999px"
  };
}
function e9(e, t, n, r) {
  return n !== void 0 ? tfe(e, t, efe(n, google.maps.LatLngBounds, Jde)) : nfe(e, t, Qde(r, google.maps.LatLng, Yde));
}
function rfe(e, t) {
  return e.left === t.left && e.top === t.top && e.width === t.height && e.height === t.height;
}
function Ij(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ofe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Ij(Object(n), !0).forEach(function(r) {
      we(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Ij(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function ife(e, t, n, r, o) {
  class i extends google.maps.OverlayView {
    constructor(s, l, u, c) {
      super(), this.container = s, this.pane = l, this.position = u, this.bounds = c;
    }
    onAdd() {
      var s, l = (s = this.getPanes()) === null || s === void 0 ? void 0 : s[this.pane];
      l == null || l.appendChild(this.container);
    }
    draw() {
      var s = this.getProjection(), l = ofe({}, this.container ? QV(this.container, o) : {
        x: 0,
        y: 0
      }), u = e9(s, l, this.bounds, this.position);
      for (var [c, p] of Object.entries(u))
        this.container.style[c] = p;
    }
    onRemove() {
      this.container.parentNode !== null && this.container.parentNode.removeChild(this.container);
    }
  }
  return new i(e, t, n, r);
}
function Rj(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function sfe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Rj(Object(n), !0).forEach(function(r) {
      we(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Rj(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function Nj(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLng ? e : new google.maps.LatLng(e.lat, e.lng);
  return t + "";
}
function Fj(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLngBounds ? e : new google.maps.LatLngBounds(new google.maps.LatLng(e.south, e.east), new google.maps.LatLng(e.north, e.west));
  return t + "";
}
function afe(e) {
  var {
    position: t,
    bounds: n,
    mapPaneName: r,
    zIndex: o,
    onLoad: i,
    onUnmount: a,
    getPixelPositionOffset: s,
    children: l
  } = e, u = ye(St), c = Tn(() => {
    var d = document.createElement("div");
    return d.style.position = "absolute", d;
  }, []), p = Tn(() => ife(c, r, t, n, s), [c, r, t, n]);
  return v(() => (i == null || i(p), p == null || p.setMap(u), () => {
    a == null || a(p), p == null || p.setMap(null);
  }), [u, p]), v(() => {
    c.style.zIndex = "".concat(o);
  }, [o, c]), Ci.createPortal(l, c);
}
Ee(afe);
class Cu extends pe {
  constructor(t) {
    super(t), we(this, "state", {
      paneEl: null,
      containerStyle: {
        // set initial position
        position: "absolute"
      }
    }), we(this, "updatePane", () => {
      var r = this.props.mapPaneName, o = this.overlayView.getPanes();
      Zr(!!r, "OverlayView requires props.mapPaneName but got %s", r), o ? this.setState({
        paneEl: o[r]
      }) : this.setState({
        paneEl: null
      });
    }), we(this, "onAdd", () => {
      var r, o;
      this.updatePane(), (r = (o = this.props).onLoad) === null || r === void 0 || r.call(o, this.overlayView);
    }), we(this, "onPositionElement", () => {
      var r = this.overlayView.getProjection(), o = sfe({
        x: 0,
        y: 0
      }, this.containerRef.current ? QV(this.containerRef.current, this.props.getPixelPositionOffset) : {}), i = e9(r, o, this.props.bounds, this.props.position);
      if (!rfe(i, {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        left: this.state.containerStyle.left,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        top: this.state.containerStyle.top,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        width: this.state.containerStyle.width,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        height: this.state.containerStyle.height
      })) {
        var a, s, l, u;
        this.setState({
          containerStyle: {
            top: (a = i.top) !== null && a !== void 0 ? a : 0,
            left: (s = i.left) !== null && s !== void 0 ? s : 0,
            width: (l = i.width) !== null && l !== void 0 ? l : 0,
            height: (u = i.height) !== null && u !== void 0 ? u : 0,
            position: "absolute"
          }
        });
      }
    }), we(this, "draw", () => {
      this.onPositionElement();
    }), we(this, "onRemove", () => {
      var r, o;
      this.setState(() => ({
        paneEl: null
      })), (r = (o = this.props).onUnmount) === null || r === void 0 || r.call(o, this.overlayView);
    }), this.containerRef = Qr();
    var n = new google.maps.OverlayView();
    n.onAdd = this.onAdd, n.draw = this.draw, n.onRemove = this.onRemove, this.overlayView = n;
  }
  componentDidMount() {
    this.overlayView.setMap(this.context);
  }
  componentDidUpdate(t) {
    var n = Nj(t.position), r = Nj(this.props.position), o = Fj(t.bounds), i = Fj(this.props.bounds);
    (n !== r || o !== i) && this.overlayView.draw(), t.mapPaneName !== this.props.mapPaneName && this.updatePane();
  }
  componentWillUnmount() {
    this.overlayView.setMap(null);
  }
  render() {
    var t = this.state.paneEl;
    return t ? Ci.createPortal(oo.jsx("div", {
      ref: this.containerRef,
      style: this.state.containerStyle,
      children: at.only(this.props.children)
    }), t) : null;
  }
}
we(Cu, "FLOAT_PANE", "floatPane");
we(Cu, "MAP_PANE", "mapPane");
we(Cu, "MARKER_LAYER", "markerLayer");
we(Cu, "OVERLAY_LAYER", "overlayLayer");
we(Cu, "OVERLAY_MOUSE_TARGET", "overlayMouseTarget");
we(Cu, "contextType", St);
function lfe() {
}
function zj(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Uj(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? zj(Object(n), !0).forEach(function(r) {
      we(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : zj(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var $j = {
  onDblClick: "dblclick",
  onClick: "click"
}, Hj = {
  opacity(e, t) {
    e.setOpacity(t);
  }
};
function ufe(e) {
  var {
    url: t,
    bounds: n,
    options: r,
    visible: o
  } = e, i = ye(St), a = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east)), s = Tn(() => new google.maps.GroundOverlay(t, a, r), []);
  return v(() => {
    s !== null && s.setMap(i);
  }, [i]), v(() => {
    typeof t < "u" && s !== null && (s.set("url", t), s.setMap(i));
  }, [s, t]), v(() => {
    typeof o < "u" && s !== null && s.setOpacity(o ? 1 : 0);
  }, [s, o]), v(() => {
    var l = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east));
    typeof n < "u" && s !== null && (s.set("bounds", l), s.setMap(i));
  }, [s, n]), null;
}
Ee(ufe);
class t9 extends pe {
  constructor() {
    super(...arguments), we(this, "registeredEvents", []), we(this, "state", {
      groundOverlay: null
    }), we(this, "setGroundOverlayCallback", () => {
      this.state.groundOverlay !== null && this.props.onLoad && this.props.onLoad(this.state.groundOverlay);
    });
  }
  componentDidMount() {
    Zr(!!this.props.url || !!this.props.bounds, "For GroundOverlay, url and bounds are passed in to constructor and are immutable after instantiated. This is the behavior of Google Maps JavaScript API v3 ( See https://developers.google.com/maps/documentation/javascript/reference#GroundOverlay) Hence, use the corresponding two props provided by `react-google-maps-api`, url and bounds. In some cases, you'll need the GroundOverlay component to reflect the changes of url and bounds. You can leverage the React's key property to remount the component. Typically, just `key={url}` would serve your need. See https://github.com/tomchentw/react-google-maps/issues/655");
    var t = new google.maps.GroundOverlay(this.props.url, this.props.bounds, Uj(Uj({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Qt({
      updaterMap: Hj,
      eventMap: $j,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        groundOverlay: t
      };
    }, this.setGroundOverlayCallback);
  }
  componentDidUpdate(t) {
    this.state.groundOverlay !== null && (sn(this.registeredEvents), this.registeredEvents = Qt({
      updaterMap: Hj,
      eventMap: $j,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.groundOverlay
    }));
  }
  componentWillUnmount() {
    this.state.groundOverlay && (this.props.onUnmount && this.props.onUnmount(this.state.groundOverlay), this.state.groundOverlay.setMap(null));
  }
  render() {
    return null;
  }
}
we(t9, "defaultProps", {
  onLoad: lfe
});
we(t9, "contextType", St);
function Wj(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Ng(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Wj(Object(n), !0).forEach(function(r) {
      we(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Wj(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Vj = {}, qj = {
  data(e, t) {
    e.setData(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function cfe(e) {
  var {
    data: t,
    onLoad: n,
    onUnmount: r,
    options: o
  } = e, i = ye(St), [a, s] = k(null);
  return v(() => {
    google.maps.visualization || Zr(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} in useJsApiScript? %s', google.maps.visualization);
  }, []), v(() => {
    Zr(!!t, "data property is required in HeatmapLayer %s", t);
  }, [t]), v(() => {
    a !== null && a.setMap(i);
  }, [i]), v(() => {
    o && a !== null && a.setOptions(o);
  }, [a, o]), v(() => {
    var l = new google.maps.visualization.HeatmapLayer(Ng(Ng({}, o), {}, {
      data: t,
      map: i
    }));
    return s(l), n && n(l), () => {
      a !== null && (r && r(a), a.setMap(null));
    };
  }, []), null;
}
Ee(cfe);
class pfe extends pe {
  constructor() {
    super(...arguments), we(this, "registeredEvents", []), we(this, "state", {
      heatmapLayer: null
    }), we(this, "setHeatmapLayerCallback", () => {
      this.state.heatmapLayer !== null && this.props.onLoad && this.props.onLoad(this.state.heatmapLayer);
    });
  }
  componentDidMount() {
    Zr(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} to <LoadScript />? %s', google.maps.visualization), Zr(!!this.props.data, "data property is required in HeatmapLayer %s", this.props.data);
    var t = new google.maps.visualization.HeatmapLayer(Ng(Ng({}, this.props.options), {}, {
      data: this.props.data,
      map: this.context
    }));
    this.registeredEvents = Qt({
      updaterMap: qj,
      eventMap: Vj,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        heatmapLayer: t
      };
    }, this.setHeatmapLayerCallback);
  }
  componentDidUpdate(t) {
    sn(this.registeredEvents), this.registeredEvents = Qt({
      updaterMap: qj,
      eventMap: Vj,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.heatmapLayer
    });
  }
  componentWillUnmount() {
    this.state.heatmapLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.heatmapLayer), sn(this.registeredEvents), this.state.heatmapLayer.setMap(null));
  }
  render() {
    return null;
  }
}
we(pfe, "contextType", St);
var Zj = {
  onCloseClick: "closeclick",
  onPanoChanged: "pano_changed",
  onPositionChanged: "position_changed",
  onPovChanged: "pov_changed",
  onResize: "resize",
  onStatusChanged: "status_changed",
  onVisibleChanged: "visible_changed",
  onZoomChanged: "zoom_changed"
}, Gj = {
  register(e, t, n) {
    e.registerPanoProvider(t, n);
  },
  links(e, t) {
    e.setLinks(t);
  },
  motionTracking(e, t) {
    e.setMotionTracking(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  pano(e, t) {
    e.setPano(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  pov(e, t) {
    e.setPov(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zoom(e, t) {
    e.setZoom(t);
  }
};
class dfe extends pe {
  constructor() {
    super(...arguments), we(this, "registeredEvents", []), we(this, "state", {
      streetViewPanorama: null
    }), we(this, "setStreetViewPanoramaCallback", () => {
      this.state.streetViewPanorama !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewPanorama);
    });
  }
  componentDidMount() {
    var t, n, r = (t = (n = this.context) === null || n === void 0 ? void 0 : n.getStreetView()) !== null && t !== void 0 ? t : null;
    this.registeredEvents = Qt({
      updaterMap: Gj,
      eventMap: Zj,
      prevProps: {},
      nextProps: this.props,
      instance: r
    }), this.setState(() => ({
      streetViewPanorama: r
    }), this.setStreetViewPanoramaCallback);
  }
  componentDidUpdate(t) {
    this.state.streetViewPanorama !== null && (sn(this.registeredEvents), this.registeredEvents = Qt({
      updaterMap: Gj,
      eventMap: Zj,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.streetViewPanorama
    }));
  }
  componentWillUnmount() {
    this.state.streetViewPanorama !== null && (this.props.onUnmount && this.props.onUnmount(this.state.streetViewPanorama), sn(this.registeredEvents), this.state.streetViewPanorama.setVisible(!1));
  }
  render() {
    return null;
  }
}
we(dfe, "contextType", St);
class ffe extends pe {
  constructor() {
    super(...arguments), we(this, "state", {
      streetViewService: null
    }), we(this, "setStreetViewServiceCallback", () => {
      this.state.streetViewService !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewService);
    });
  }
  componentDidMount() {
    var t = new google.maps.StreetViewService();
    this.setState(function() {
      return {
        streetViewService: t
      };
    }, this.setStreetViewServiceCallback);
  }
  componentWillUnmount() {
    this.state.streetViewService !== null && this.props.onUnmount && this.props.onUnmount(this.state.streetViewService);
  }
  render() {
    return null;
  }
}
we(ffe, "contextType", St);
var Xj = {
  onDirectionsChanged: "directions_changed"
}, Kj = {
  directions(e, t) {
    e.setDirections(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  panel(e, t) {
    e.setPanel(t);
  },
  routeIndex(e, t) {
    e.setRouteIndex(t);
  }
};
class hfe extends pe {
  constructor() {
    super(...arguments), we(this, "registeredEvents", []), we(this, "state", {
      directionsRenderer: null
    }), we(this, "setDirectionsRendererCallback", () => {
      this.state.directionsRenderer !== null && (this.state.directionsRenderer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.directionsRenderer));
    });
  }
  componentDidMount() {
    var t = new google.maps.DirectionsRenderer(this.props.options);
    this.registeredEvents = Qt({
      updaterMap: Kj,
      eventMap: Xj,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        directionsRenderer: t
      };
    }, this.setDirectionsRendererCallback);
  }
  componentDidUpdate(t) {
    this.state.directionsRenderer !== null && (sn(this.registeredEvents), this.registeredEvents = Qt({
      updaterMap: Kj,
      eventMap: Xj,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.directionsRenderer
    }));
  }
  componentWillUnmount() {
    this.state.directionsRenderer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.directionsRenderer), sn(this.registeredEvents), this.state.directionsRenderer && this.state.directionsRenderer.setMap(null));
  }
  render() {
    return null;
  }
}
we(hfe, "contextType", St);
var Yj = {
  onPlacesChanged: "places_changed"
}, Jj = {
  bounds(e, t) {
    e.setBounds(t);
  }
};
class gfe extends pe {
  constructor() {
    super(...arguments), we(this, "registeredEvents", []), we(this, "containerElement", Qr()), we(this, "state", {
      searchBox: null
    }), we(this, "setSearchBoxCallback", () => {
      this.state.searchBox !== null && this.props.onLoad && this.props.onLoad(this.state.searchBox);
    });
  }
  componentDidMount() {
    if (Zr(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places), this.containerElement !== null && this.containerElement.current !== null) {
      var t = this.containerElement.current.querySelector("input");
      if (t !== null) {
        var n = new google.maps.places.SearchBox(t, this.props.options);
        this.registeredEvents = Qt({
          updaterMap: Jj,
          eventMap: Yj,
          prevProps: {},
          nextProps: this.props,
          instance: n
        }), this.setState(function() {
          return {
            searchBox: n
          };
        }, this.setSearchBoxCallback);
      }
    }
  }
  componentDidUpdate(t) {
    this.state.searchBox !== null && (sn(this.registeredEvents), this.registeredEvents = Qt({
      updaterMap: Jj,
      eventMap: Yj,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.searchBox
    }));
  }
  componentWillUnmount() {
    this.state.searchBox !== null && (this.props.onUnmount && this.props.onUnmount(this.state.searchBox), sn(this.registeredEvents));
  }
  render() {
    return oo.jsx("div", {
      ref: this.containerElement,
      children: at.only(this.props.children)
    });
  }
}
we(gfe, "contextType", St);
var Qj = {
  onPlaceChanged: "place_changed"
}, eA = {
  bounds(e, t) {
    e.setBounds(t);
  },
  restrictions(e, t) {
    e.setComponentRestrictions(t);
  },
  fields(e, t) {
    e.setFields(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  types(e, t) {
    e.setTypes(t);
  }
};
class n9 extends pe {
  constructor() {
    super(...arguments), we(this, "registeredEvents", []), we(this, "containerElement", Qr()), we(this, "state", {
      autocomplete: null
    }), we(this, "setAutocompleteCallback", () => {
      this.state.autocomplete !== null && this.props.onLoad && this.props.onLoad(this.state.autocomplete);
    });
  }
  componentDidMount() {
    var t;
    Zr(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places);
    var n = (t = this.containerElement.current) === null || t === void 0 ? void 0 : t.querySelector("input");
    if (n) {
      var r = new google.maps.places.Autocomplete(n, this.props.options);
      this.registeredEvents = Qt({
        updaterMap: eA,
        eventMap: Qj,
        prevProps: {},
        nextProps: this.props,
        instance: r
      }), this.setState(() => ({
        autocomplete: r
      }), this.setAutocompleteCallback);
    }
  }
  componentDidUpdate(t) {
    sn(this.registeredEvents), this.registeredEvents = Qt({
      updaterMap: eA,
      eventMap: Qj,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.autocomplete
    });
  }
  componentWillUnmount() {
    this.state.autocomplete !== null && sn(this.registeredEvents);
  }
  render() {
    return oo.jsx("div", {
      ref: this.containerElement,
      className: this.props.className,
      children: at.only(this.props.children)
    });
  }
}
we(n9, "defaultProps", {
  className: ""
});
we(n9, "contextType", St);
let mfe = { data: "" }, vfe = (e) => typeof window == "object" ? ((e ? e.querySelector("#_goober") : window._goober) || Object.assign((e || document.head).appendChild(document.createElement("style")), { innerHTML: " ", id: "_goober" })).firstChild : e || mfe, yfe = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g, bfe = /\/\*[^]*?\*\/|  +/g, tA = /\n+/g, sa = (e, t) => {
  let n = "", r = "", o = "";
  for (let i in e) {
    let a = e[i];
    i[0] == "@" ? i[1] == "i" ? n = i + " " + a + ";" : r += i[1] == "f" ? sa(a, i) : i + "{" + sa(a, i[1] == "k" ? "" : t) + "}" : typeof a == "object" ? r += sa(a, t ? t.replace(/([^,])+/g, (s) => i.replace(/([^,]*:\S+\([^)]*\))|([^,])+/g, (l) => /&/.test(l) ? l.replace(/&/g, s) : s ? s + " " + l : l)) : i) : a != null && (i = /^--/.test(i) ? i : i.replace(/[A-Z]/g, "-$&").toLowerCase(), o += sa.p ? sa.p(i, a) : i + ":" + a + ";");
  }
  return n + (t && o ? t + "{" + o + "}" : o) + r;
}, ls = {}, r9 = (e) => {
  if (typeof e == "object") {
    let t = "";
    for (let n in e) t += n + r9(e[n]);
    return t;
  }
  return e;
}, wfe = (e, t, n, r, o) => {
  let i = r9(e), a = ls[i] || (ls[i] = ((l) => {
    let u = 0, c = 11;
    for (; u < l.length; ) c = 101 * c + l.charCodeAt(u++) >>> 0;
    return "go" + c;
  })(i));
  if (!ls[a]) {
    let l = i !== e ? e : ((u) => {
      let c, p, d = [{}];
      for (; c = yfe.exec(u.replace(bfe, "")); ) c[4] ? d.shift() : c[3] ? (p = c[3].replace(tA, " ").trim(), d.unshift(d[0][p] = d[0][p] || {})) : d[0][c[1]] = c[2].replace(tA, " ").trim();
      return d[0];
    })(e);
    ls[a] = sa(o ? { ["@keyframes " + a]: l } : l, n ? "" : "." + a);
  }
  let s = n && ls.g ? ls.g : null;
  return n && (ls.g = ls[a]), ((l, u, c, p) => {
    p ? u.data = u.data.replace(p, l) : u.data.indexOf(l) === -1 && (u.data = c ? l + u.data : u.data + l);
  })(ls[a], t, r, s), a;
}, Cfe = (e, t, n) => e.reduce((r, o, i) => {
  let a = t[i];
  if (a && a.call) {
    let s = a(n), l = s && s.props && s.props.className || /^go/.test(s) && s;
    a = l ? "." + l : s && typeof s == "object" ? s.props ? "" : sa(s, "") : s === !1 ? "" : s;
  }
  return r + o + (a ?? "");
}, "");
function ay(e) {
  let t = this || {}, n = e.call ? e(t.p) : e;
  return wfe(n.unshift ? n.raw ? Cfe(n, [].slice.call(arguments, 1), t.p) : n.reduce((r, o) => Object.assign(r, o && o.call ? o(t.p) : o), {}) : n, vfe(t.target), t.g, t.o, t.k);
}
let o9, ax, lx;
ay.bind({ g: 1 });
let Cs = ay.bind({ k: 1 });
function xfe(e, t, n, r) {
  sa.p = t, o9 = e, ax = n, lx = r;
}
function Pa(e, t) {
  let n = this || {};
  return function() {
    let r = arguments;
    function o(i, a) {
      let s = Object.assign({}, i), l = s.className || o.className;
      n.p = Object.assign({ theme: ax && ax() }, s), n.o = / *go\d+/.test(l), s.className = ay.apply(n, r) + (l ? " " + l : "");
      let u = e;
      return e[0] && (u = s.as || e, delete s.as), lx && u[0] && lx(s), o9(u, s);
    }
    return o;
  };
}
var Ofe = (e) => typeof e == "function", Efe = (e, t) => Ofe(e) ? e(t) : e, kfe = /* @__PURE__ */ (() => {
  let e;
  return () => {
    if (e === void 0 && typeof window < "u") {
      let t = matchMedia("(prefers-reduced-motion: reduce)");
      e = !t || t.matches;
    }
    return e;
  };
})(), Lfe = Cs`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`, _fe = Cs`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`, Pfe = Cs`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`, Sfe = Pa("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${Lfe} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${_fe} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${(e) => e.secondary || "#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${Pfe} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`, Mfe = Cs`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, Dfe = Pa("div")`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${(e) => e.secondary || "#e0e0e0"};
  border-right-color: ${(e) => e.primary || "#616161"};
  animation: ${Mfe} 1s linear infinite;
`, Tfe = Cs`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`, jfe = Cs`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`, Afe = Pa("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${Tfe} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${jfe} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${(e) => e.secondary || "#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`, Bfe = Pa("div")`
  position: absolute;
`, Ife = Pa("div")`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`, Rfe = Cs`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`, Nfe = Pa("div")`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${Rfe} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`, Ffe = ({ toast: e }) => {
  let { icon: t, type: n, iconTheme: r } = e;
  return t !== void 0 ? typeof t == "string" ? $e.createElement(Nfe, null, t) : t : n === "blank" ? null : $e.createElement(Ife, null, $e.createElement(Dfe, { ...r }), n !== "loading" && $e.createElement(Bfe, null, n === "error" ? $e.createElement(Sfe, { ...r }) : $e.createElement(Afe, { ...r })));
}, zfe = (e) => `
0% {transform: translate3d(0,${e * -200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`, Ufe = (e) => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${e * -150}%,-1px) scale(.6); opacity:0;}
`, $fe = "0%{opacity:0;} 100%{opacity:1;}", Hfe = "0%{opacity:1;} 100%{opacity:0;}", Wfe = Pa("div")`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`, Vfe = Pa("div")`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`, qfe = (e, t) => {
  let n = e.includes("top") ? 1 : -1, [r, o] = kfe() ? [$fe, Hfe] : [zfe(n), Ufe(n)];
  return { animation: t ? `${Cs(r)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards` : `${Cs(o)} 0.4s forwards cubic-bezier(.06,.71,.55,1)` };
};
$e.memo(({ toast: e, position: t, style: n, children: r }) => {
  let o = e.height ? qfe(e.position || t || "top-center", e.visible) : { opacity: 0 }, i = $e.createElement(Ffe, { toast: e }), a = $e.createElement(Vfe, { ...e.ariaProps }, Efe(e.message, e));
  return $e.createElement(Wfe, { className: e.className, style: { ...o, ...n, ...e.style } }, typeof r == "function" ? r({ icon: i, message: a }) : $e.createElement($e.Fragment, null, i, a));
});
xfe($e.createElement);
ay`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`;
Ze({});
function Zfe(e) {
  return e && e.replace(/[^0-9]/g, "");
}
const Gfe = {
  CNPJ: "99.999.999/9999-99"
};
Zfe(Gfe.CNPJ).length;
Vr((e, t) => /* @__PURE__ */ ro.jsx("input", { ref: t, ...e }));
function i9(e) {
  return e && e.replace(/[^0-9]/g, "");
}
const s9 = {
  EIGTH: "(99) 9999-9999",
  NINE: "(99) 99999-9999"
};
function Xfe(e, t) {
  let n = "", r = 0;
  for (let o = 0; o < t.length; o++)
    if (t[o] === "9")
      if (r < e.length)
        n += e[r], r++;
      else
        break;
    else if (r < e.length)
      n += t[o];
    else
      break;
  return n;
}
function Kfe(e) {
  return e.length > 10 ? "NINE" : "EIGTH";
}
const Yfe = i9(s9.NINE).length, Jfe = Vr((e, t) => /* @__PURE__ */ ro.jsx("input", { ref: t, ...e }));
Vr(
  (e, t) => {
    const { onFocus: n, onBlur: r, size: o, onChange: i, value: a, currentCountry: s, disabled: l } = e, [u, c] = k(!1);
    v(() => {
      u ? i(s.mask) : c(!0);
    }, [s]);
    const p = `phoneInputMask ${o}`;
    function d(h) {
      let f = i9(h.target.value);
      const m = Kfe(f);
      f.length > Yfe || (f = Xfe(f, s9[m]), h.target.value = f, i(f));
    }
    return s.code === "+55" ? /* @__PURE__ */ ro.jsx(
      "input",
      {
        value: a,
        onChange: d,
        className: p,
        onFocus: n,
        onBlur: r,
        disabled: l,
        ref: t
      }
    ) : /* @__PURE__ */ ro.jsx(
      Il,
      {
        value: a,
        onChange: (h) => i(h.target.value),
        className: p,
        component: Jfe,
        onFocus: n,
        onBlur: r,
        disabled: l,
        mask: s.mask,
        showMask: !0,
        replacement: { _: /\d/ },
        ref: t
      }
    );
  }
);
Ze({});
var Ps = {};
Object.defineProperty(Ps, "__esModule", {
  value: !0
});
var Qfe = typeof window < "u" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform), i0 = {
  alt: "altKey",
  control: "ctrlKey",
  meta: "metaKey",
  shift: "shiftKey"
}, a9 = {
  add: "+",
  break: "pause",
  cmd: "meta",
  command: "meta",
  ctl: "control",
  ctrl: "control",
  del: "delete",
  down: "arrowdown",
  esc: "escape",
  ins: "insert",
  left: "arrowleft",
  mod: Qfe ? "meta" : "control",
  opt: "alt",
  option: "alt",
  return: "enter",
  right: "arrowright",
  space: " ",
  spacebar: " ",
  up: "arrowup",
  win: "meta",
  windows: "meta"
}, yk = {
  backspace: 8,
  tab: 9,
  enter: 13,
  shift: 16,
  control: 17,
  alt: 18,
  pause: 19,
  capslock: 20,
  escape: 27,
  " ": 32,
  pageup: 33,
  pagedown: 34,
  end: 35,
  home: 36,
  arrowleft: 37,
  arrowup: 38,
  arrowright: 39,
  arrowdown: 40,
  insert: 45,
  delete: 46,
  meta: 91,
  numlock: 144,
  scrolllock: 145,
  ";": 186,
  "=": 187,
  ",": 188,
  "-": 189,
  ".": 190,
  "/": 191,
  "`": 192,
  "[": 219,
  "\\": 220,
  "]": 221,
  "'": 222
};
for (var Tf = 1; Tf < 20; Tf++)
  yk["f" + Tf] = 111 + Tf;
function ly(e, t, n) {
  t && !("byKey" in t) && (n = t, t = null), Array.isArray(e) || (e = [e]);
  var r = e.map(function(a) {
    return l9(a, t);
  }), o = function(a) {
    return r.some(function(s) {
      return u9(s, a);
    });
  }, i = n == null ? o : o(n);
  return i;
}
function ehe(e, t) {
  return ly(e, t);
}
function the(e, t) {
  return ly(e, { byKey: !0 }, t);
}
function l9(e, t) {
  var n = t && t.byKey, r = {};
  e = e.replace("++", "+add");
  var o = e.split("+"), i = o.length;
  for (var a in i0)
    r[i0[a]] = !1;
  var s = !0, l = !1, u = void 0;
  try {
    for (var c = o[Symbol.iterator](), p; !(s = (p = c.next()).done); s = !0) {
      var d = p.value, h = d.endsWith("?") && d.length > 1;
      h && (d = d.slice(0, -1));
      var f = bk(d), m = i0[f];
      if (d.length > 1 && !m && !a9[d] && !yk[f])
        throw new TypeError('Unknown modifier: "' + d + '"');
      (i === 1 || !m) && (n ? r.key = f : r.which = c9(d)), m && (r[m] = h ? null : !0);
    }
  } catch (g) {
    l = !0, u = g;
  } finally {
    try {
      !s && c.return && c.return();
    } finally {
      if (l)
        throw u;
    }
  }
  return r;
}
function u9(e, t) {
  for (var n in e) {
    var r = e[n], o = void 0;
    if (r != null && (n === "key" && t.key != null ? o = t.key.toLowerCase() : n === "which" ? o = r === 91 && t.which === 93 ? 91 : t.which : o = t[n], !(o == null && r === !1) && o !== r))
      return !1;
  }
  return !0;
}
function c9(e) {
  e = bk(e);
  var t = yk[e] || e.toUpperCase().charCodeAt(0);
  return t;
}
function bk(e) {
  return e = e.toLowerCase(), e = a9[e] || e, e;
}
Ps.default = ly;
var s0 = Ps.isHotkey = ly;
Ps.isCodeHotkey = ehe;
Ps.isKeyHotkey = the;
Ps.parseHotkey = l9;
Ps.compareHotkey = u9;
Ps.toKeyCode = c9;
Ps.toKeyName = bk;
var nhe = typeof Un == "object" && Un && Un.Object === Object && Un, rhe = nhe, ohe = rhe, ihe = typeof self == "object" && self && self.Object === Object && self, she = ohe || ihe || Function("return this")(), ahe = she, lhe = ahe, uhe = lhe.Symbol, p9 = uhe, nA = p9;
nA && nA.toStringTag;
var rA = p9;
rA && rA.toStringTag;
var oA;
(function(e) {
  e.BORDER_BOX = "border-box", e.CONTENT_BOX = "content-box", e.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(oA || (oA = {}));
var wk = function(e) {
  return Object.freeze(e);
}, che = /* @__PURE__ */ function() {
  function e(t, n) {
    this.inlineSize = t, this.blockSize = n, wk(this);
  }
  return e;
}(), phe = function() {
  function e(t, n, r, o) {
    return this.x = t, this.y = n, this.width = r, this.height = o, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, wk(this);
  }
  return e.prototype.toJSON = function() {
    var t = this, n = t.x, r = t.y, o = t.top, i = t.right, a = t.bottom, s = t.left, l = t.width, u = t.height;
    return { x: n, y: r, top: o, right: i, bottom: a, left: s, width: l, height: u };
  }, e.fromRect = function(t) {
    return new e(t.x, t.y, t.width, t.height);
  }, e;
}(), iA = typeof window < "u" ? window : {};
/msie|trident/i.test(iA.navigator && iA.navigator.userAgent);
var a0 = function(e, t, n) {
  return e === void 0 && (e = 0), t === void 0 && (t = 0), n === void 0 && (n = !1), new che((n ? t : e) || 0, (n ? e : t) || 0);
};
wk({
  devicePixelContentBoxSize: a0(),
  borderBoxSize: a0(),
  contentBoxSize: a0(),
  contentRect: new phe(0, 0, 0, 0)
});
function Pp(e) {
  "@babel/helpers - typeof";
  return Pp = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Pp(e);
}
function dhe(e, t) {
  if (Pp(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (Pp(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function fhe(e) {
  var t = dhe(e, "string");
  return Pp(t) === "symbol" ? t : String(t);
}
function Rc(e, t, n) {
  return t = fhe(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
var hhe = /* @__PURE__ */ Ze(null), l0, u0;
parseInt(ke.version.split(".")[0], 10);
var sA = typeof navigator < "u" && /Mac OS X/.test(navigator.userAgent), c0 = typeof navigator < "u" && /Android/.test(navigator.userAgent), jf = typeof navigator < "u" && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent), ghe = typeof navigator < "u" && /Chrome/i.test(navigator.userAgent);
typeof navigator < "u" && /Safari/.test(navigator.userAgent) && /Version\/(\d+)/.test(navigator.userAgent) && (l0 = navigator.userAgent.match(/Version\/(\d+)/)) !== null && l0 !== void 0 && l0[1] && parseInt((u0 = navigator.userAgent.match(/Version\/(\d+)/)) === null || u0 === void 0 ? void 0 : u0[1], 10) < 17;
var mhe = /* @__PURE__ */ new WeakMap(), vhe = /* @__PURE__ */ new WeakMap(), yhe = /* @__PURE__ */ new WeakMap(), bhe = /* @__PURE__ */ new WeakMap(), whe = /* @__PURE__ */ new WeakMap(), aA = /* @__PURE__ */ new WeakMap(), Che = /* @__PURE__ */ new WeakMap(), lA = /* @__PURE__ */ new WeakMap(), Af = /* @__PURE__ */ new WeakMap(), xhe = /* @__PURE__ */ new WeakMap(), Ohe = /* @__PURE__ */ new WeakMap(), Ehe = /* @__PURE__ */ new WeakMap(), d9 = globalThis.Node, khe = globalThis.Text, f9 = (e) => e && e.ownerDocument && e.ownerDocument.defaultView || null, Lhe = (e) => Fg(e) && e.nodeType === 8, Vi = (e) => Fg(e) && e.nodeType === 1, Fg = (e) => {
  var t = f9(e);
  return !!t && e instanceof t.Node;
}, uA = (e) => {
  var t = e && e.anchorNode && f9(e.anchorNode);
  return !!t && e instanceof t.Selection;
}, _he = (e) => {
  var [t, n] = e;
  if (Vi(t) && t.childNodes.length) {
    var r = n === t.childNodes.length, o = r ? n - 1 : n;
    for ([t, o] = h9(t, o, r ? "backward" : "forward"), r = o < n; Vi(t) && t.childNodes.length; ) {
      var i = r ? t.childNodes.length - 1 : 0;
      t = She(t, i, r ? "backward" : "forward");
    }
    n = r && t.textContent != null ? t.textContent.length : 0;
  }
  return [t, n];
}, Phe = (e) => {
  for (var t = e && e.parentNode; t; ) {
    if (t.toString() === "[object ShadowRoot]")
      return !0;
    t = t.parentNode;
  }
  return !1;
}, h9 = (e, t, n) => {
  for (var {
    childNodes: r
  } = e, o = r[t], i = t, a = !1, s = !1; (Lhe(o) || Vi(o) && o.childNodes.length === 0 || Vi(o) && o.getAttribute("contenteditable") === "false") && !(a && s); ) {
    if (i >= r.length) {
      a = !0, i = t - 1, n = "backward";
      continue;
    }
    if (i < 0) {
      s = !0, i = t + 1, n = "forward";
      continue;
    }
    o = r[i], t = i, i += n === "forward" ? 1 : -1;
  }
  return [o, t];
}, She = (e, t, n) => {
  var [r] = h9(e, t, n);
  return r;
}, cA = (e) => e.getSelection != null ? e.getSelection() : document.getSelection(), g9 = (e, t, n) => {
  var {
    target: r
  } = t;
  if (Vi(r) && r.matches('[contentEditable="false"]'))
    return !1;
  var {
    document: o
  } = Xt.getWindow(e);
  if (o.contains(r))
    return Xt.hasDOMNode(e, r, {
      editable: !0
    });
  var i = n.find((a) => {
    var {
      addedNodes: s,
      removedNodes: l
    } = a;
    for (var u of s)
      if (u === r || u.contains(r))
        return !0;
    for (var c of l)
      if (c === r || c.contains(r))
        return !0;
  });
  return !i || i === t ? !1 : g9(e, i, n);
}, pA = (e, t) => !!(e.compareDocumentPosition(t) & d9.DOCUMENT_POSITION_PRECEDING), Mhe = (e, t) => !!(e.compareDocumentPosition(t) & d9.DOCUMENT_POSITION_FOLLOWING), Dhe = 0;
class The {
  constructor() {
    Rc(this, "id", void 0), this.id = "".concat(Dhe++);
  }
}
var Xt = {
  androidPendingDiffs: (e) => Ehe.get(e),
  androidScheduleFlush: (e) => {
    var t;
    (t = Ohe.get(e)) === null || t === void 0 || t();
  },
  blur: (e) => {
    var t = Xt.toDOMNode(e, e), n = Xt.findDocumentOrShadowRoot(e);
    Af.set(e, !1), n.activeElement === t && t.blur();
  },
  deselect: (e) => {
    var {
      selection: t
    } = e, n = Xt.findDocumentOrShadowRoot(e), r = cA(n);
    r && r.rangeCount > 0 && r.removeAllRanges(), t && ig.deselect(e);
  },
  findDocumentOrShadowRoot: (e) => {
    var t = Xt.toDOMNode(e, e), n = t.getRootNode();
    return n instanceof Document || n instanceof ShadowRoot ? n : t.ownerDocument;
  },
  findEventRange: (e, t) => {
    "nativeEvent" in t && (t = t.nativeEvent);
    var {
      clientX: n,
      clientY: r,
      target: o
    } = t;
    if (n == null || r == null)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var i = Xt.toSlateNode(e, t.target), a = Xt.findPath(e, i);
    if (gs.isElement(i) && Bn.isVoid(e, i)) {
      var s = o.getBoundingClientRect(), l = e.isInline(i) ? n - s.left < s.left + s.width - n : r - s.top < s.top + s.height - r, u = Bn.point(e, a, {
        edge: l ? "start" : "end"
      }), c = l ? Bn.before(e, u) : Bn.after(e, u);
      if (c) {
        var p = Bn.range(e, c);
        return p;
      }
    }
    var d, {
      document: h
    } = Xt.getWindow(e);
    if (h.caretRangeFromPoint)
      d = h.caretRangeFromPoint(n, r);
    else {
      var f = h.caretPositionFromPoint(n, r);
      f && (d = h.createRange(), d.setStart(f.offsetNode, f.offset), d.setEnd(f.offsetNode, f.offset));
    }
    if (!d)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var m = Xt.toSlateRange(e, d, {
      exactMatch: !1,
      suppressThrow: !1
    });
    return m;
  },
  findKey: (e, t) => {
    var n = aA.get(t);
    return n || (n = new The(), aA.set(t, n)), n;
  },
  findPath: (e, t) => {
    for (var n = [], r = t; ; ) {
      var o = vhe.get(r);
      if (o == null) {
        if (Bn.isEditor(r))
          return n;
        break;
      }
      var i = mhe.get(r);
      if (i == null)
        break;
      n.unshift(i), r = o;
    }
    throw new Error("Unable to find the path for Slate node: ".concat(Wo.stringify(t)));
  },
  focus: function(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      retries: 5
    };
    if (!Af.get(e)) {
      if (t.retries <= 0)
        throw new Error("Could not set focus, editor seems stuck with pending operations");
      if (e.operations.length > 0) {
        setTimeout(() => {
          Xt.focus(e, {
            retries: t.retries - 1
          });
        }, 10);
        return;
      }
      var n = Xt.toDOMNode(e, e), r = Xt.findDocumentOrShadowRoot(e);
      if (r.activeElement !== n) {
        if (e.selection && r instanceof Document) {
          var o = cA(r), i = Xt.toDOMRange(e, e.selection);
          o == null || o.removeAllRanges(), o == null || o.addRange(i);
        }
        e.selection || ig.select(e, Bn.start(e, [])), Af.set(e, !0), n.focus({
          preventScroll: !0
        });
      }
    }
  },
  getWindow: (e) => {
    var t = yhe.get(e);
    if (!t)
      throw new Error("Unable to find a host window element for this editor");
    return t;
  },
  hasDOMNode: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      editable: r = !1
    } = n, o = Xt.toDOMNode(e, e), i;
    try {
      i = Vi(t) ? t : t.parentElement;
    } catch (a) {
      if (a instanceof Error && !a.message.includes('Permission denied to access property "nodeType"'))
        throw a;
    }
    return i ? i.closest("[data-slate-editor]") === o && (!r || i.isContentEditable ? !0 : typeof i.isContentEditable == "boolean" && // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined
    // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable="false"(readOnly)
    i.closest('[contenteditable="false"]') === o || !!i.getAttribute("data-slate-zero-width")) : !1;
  },
  hasEditableTarget: (e, t) => Fg(t) && Xt.hasDOMNode(e, t, {
    editable: !0
  }),
  hasRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t;
    return Bn.hasPath(e, n.path) && Bn.hasPath(e, r.path);
  },
  hasSelectableTarget: (e, t) => Xt.hasEditableTarget(e, t) || Xt.isTargetInsideNonReadonlyVoid(e, t),
  hasTarget: (e, t) => Fg(t) && Xt.hasDOMNode(e, t),
  insertData: (e, t) => {
    e.insertData(t);
  },
  insertFragmentData: (e, t) => e.insertFragmentData(t),
  insertTextData: (e, t) => e.insertTextData(t),
  isComposing: (e) => !!xhe.get(e),
  isFocused: (e) => !!Af.get(e),
  isReadOnly: (e) => !!lA.get(e),
  isTargetInsideNonReadonlyVoid: (e, t) => {
    if (lA.get(e)) return !1;
    var n = Xt.hasTarget(e, t) && Xt.toSlateNode(e, t);
    return gs.isElement(n) && Bn.isVoid(e, n);
  },
  setFragmentData: (e, t, n) => e.setFragmentData(t, n),
  toDOMNode: (e, t) => {
    var n = Che.get(e), r = Bn.isEditor(t) ? bhe.get(e) : n == null ? void 0 : n.get(Xt.findKey(e, t));
    if (!r)
      throw new Error("Cannot resolve a DOM node from Slate node: ".concat(Wo.stringify(t)));
    return r;
  },
  toDOMPoint: (e, t) => {
    var [n] = Bn.node(e, t.path), r = Xt.toDOMNode(e, n), o;
    Bn.void(e, {
      at: t
    }) && (t = {
      path: t.path,
      offset: 0
    });
    for (var i = "[data-slate-string], [data-slate-zero-width]", a = Array.from(r.querySelectorAll(i)), s = 0, l = 0; l < a.length; l++) {
      var u = a[l], c = u.childNodes[0];
      if (!(c == null || c.textContent == null)) {
        var {
          length: p
        } = c.textContent, d = u.getAttribute("data-slate-length"), h = d == null ? p : parseInt(d, 10), f = s + h, m = a[l + 1];
        if (t.offset === f && m !== null && m !== void 0 && m.hasAttribute("data-slate-mark-placeholder")) {
          var g, E = m.childNodes[0];
          o = [
            // COMPAT: If we don't explicity set the dom point to be on the actual
            // dom text element, chrome will put the selection behind the actual dom
            // text element, causing domRange.getBoundingClientRect() calls on a collapsed
            // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)
            // which will cause issues when scrolling to it.
            E instanceof khe ? E : m,
            (g = m.textContent) !== null && g !== void 0 && g.startsWith("\uFEFF") ? 1 : 0
          ];
          break;
        }
        if (t.offset <= f) {
          var w = Math.min(p, Math.max(0, t.offset - s));
          o = [c, w];
          break;
        }
        s = f;
      }
    }
    if (!o)
      throw new Error("Cannot resolve a DOM point from Slate point: ".concat(Wo.stringify(t)));
    return o;
  },
  toDOMRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t, o = It.isBackward(t), i = Xt.toDOMPoint(e, n), a = It.isCollapsed(t) ? i : Xt.toDOMPoint(e, r), s = Xt.getWindow(e), l = s.document.createRange(), [u, c] = o ? a : i, [p, d] = o ? i : a, h = Vi(u) ? u : u.parentElement, f = !!h.getAttribute("data-slate-zero-width"), m = Vi(p) ? p : p.parentElement, g = !!m.getAttribute("data-slate-zero-width");
    return l.setStart(u, f ? 1 : c), l.setEnd(p, g ? 1 : d), l;
  },
  toSlateNode: (e, t) => {
    var n = Vi(t) ? t : t.parentElement;
    n && !n.hasAttribute("data-slate-node") && (n = n.closest("[data-slate-node]"));
    var r = n ? whe.get(n) : null;
    if (!r)
      throw new Error("Cannot resolve a Slate node from DOM node: ".concat(n));
    return r;
  },
  toSlatePoint: (e, t, n) => {
    var {
      exactMatch: r,
      suppressThrow: o,
      searchDirection: i = "backward"
    } = n, [a, s] = r ? t : _he(t), l = a.parentNode, u = null, c = 0;
    if (l) {
      var p, d, h = Xt.toDOMNode(e, e), f = l.closest('[data-slate-void="true"]'), m = f && h.contains(f) ? f : null, g = l.closest('[contenteditable="false"]'), E = g && h.contains(g) ? g : null, w = l.closest("[data-slate-leaf]"), M = null;
      if (w) {
        if (u = w.closest('[data-slate-node="text"]'), u) {
          var x = Xt.getWindow(e), y = x.document.createRange();
          y.setStart(u, 0), y.setEnd(a, s);
          var C = y.cloneContents(), P = [...Array.prototype.slice.call(C.querySelectorAll("[data-slate-zero-width]")), ...Array.prototype.slice.call(C.querySelectorAll("[contenteditable=false]"))];
          P.forEach((S) => {
            if (c0 && !r && S.hasAttribute("data-slate-zero-width") && S.textContent.length > 0 && S.textContext !== "\uFEFF") {
              S.textContent.startsWith("\uFEFF") && (S.textContent = S.textContent.slice(1));
              return;
            }
            S.parentNode.removeChild(S);
          }), c = C.textContent.length, M = u;
        }
      } else if (m) {
        for (var F = m.querySelectorAll("[data-slate-leaf]"), L = 0; L < F.length; L++) {
          var N = F[L];
          if (Xt.hasDOMNode(e, N)) {
            w = N;
            break;
          }
        }
        w ? (u = w.closest('[data-slate-node="text"]'), M = w, c = M.textContent.length, M.querySelectorAll("[data-slate-zero-width]").forEach((S) => {
          c -= S.textContent.length;
        })) : c = 1;
      } else if (E) {
        var I = (S) => S ? S.querySelectorAll(
          // Exclude leaf nodes in nested editors
          "[data-slate-leaf]:not(:scope [data-slate-editor] [data-slate-leaf])"
        ) : [], H = E.closest('[data-slate-node="element"]');
        if (i === "forward") {
          var V, z = [...I(H), ...I(H == null ? void 0 : H.nextElementSibling)];
          w = (V = z.find((S) => Mhe(E, S))) !== null && V !== void 0 ? V : null;
        } else {
          var q, K = [...I(H == null ? void 0 : H.previousElementSibling), ...I(H)];
          w = (q = K.findLast((S) => pA(E, S))) !== null && q !== void 0 ? q : null;
        }
        w && (u = w.closest('[data-slate-node="text"]'), M = w, i === "forward" ? c = 0 : (c = M.textContent.length, M.querySelectorAll("[data-slate-zero-width]").forEach((S) => {
          c -= S.textContent.length;
        })));
      }
      M && c === M.textContent.length && // COMPAT: Android IMEs might remove the zero width space while composing,
      // and we don't add it for line-breaks.
      c0 && M.getAttribute("data-slate-zero-width") === "z" && (p = M.textContent) !== null && p !== void 0 && p.startsWith("\uFEFF") && // COMPAT: If the parent node is a Slate zero-width space, editor is
      // because the text node should have no characters. However, during IME
      // composition the ASCII characters will be prepended to the zero-width
      // space, so subtract 1 from the offset to account for the zero-width
      // space character.
      (l.hasAttribute("data-slate-zero-width") || // COMPAT: In Firefox, `range.cloneContents()` returns an extra trailing '\n'
      // when the document ends with a new-line character. This results in the offset
      // length being off by one, so we need to subtract one to account for this.
      jf && (d = M.textContent) !== null && d !== void 0 && d.endsWith(`

`)) && c--;
    }
    if (c0 && !u && !r) {
      var J = l.hasAttribute("data-slate-node") ? l : l.closest("[data-slate-node]");
      if (J && Xt.hasDOMNode(e, J, {
        editable: !0
      })) {
        var te = Xt.toSlateNode(e, J), {
          path: ee,
          offset: _
        } = Bn.start(e, Xt.findPath(e, te));
        return J.querySelector("[data-slate-leaf]") || (_ = s), {
          path: ee,
          offset: _
        };
      }
    }
    if (!u) {
      if (o)
        return null;
      throw new Error("Cannot resolve a Slate point from DOM point: ".concat(t));
    }
    var D = Xt.toSlateNode(e, u), $ = Xt.findPath(e, D);
    return {
      path: $,
      offset: c
    };
  },
  toSlateRange: (e, t, n) => {
    var r, {
      exactMatch: o,
      suppressThrow: i
    } = n, a = uA(t) ? t.anchorNode : t.startContainer, s, l, u, c, p;
    if (a)
      if (uA(t)) {
        if (jf && t.rangeCount > 1) {
          u = t.focusNode;
          var d = t.getRangeAt(0), h = t.getRangeAt(t.rangeCount - 1);
          if (u instanceof HTMLTableRowElement && d.startContainer instanceof HTMLTableRowElement && h.startContainer instanceof HTMLTableRowElement) {
            let C = function(P) {
              return P.childElementCount > 0 ? C(P.children[0]) : P;
            };
            var f = d.startContainer, m = h.startContainer, g = C(f.children[d.startOffset]), E = C(m.children[h.startOffset]);
            c = 0, E.childNodes.length > 0 ? s = E.childNodes[0] : s = E, g.childNodes.length > 0 ? u = g.childNodes[0] : u = g, E instanceof HTMLElement ? l = E.innerHTML.length : l = 0;
          } else
            d.startContainer === u ? (s = h.endContainer, l = h.endOffset, c = d.startOffset) : (s = d.startContainer, l = d.endOffset, c = h.startOffset);
        } else
          s = t.anchorNode, l = t.anchorOffset, u = t.focusNode, c = t.focusOffset;
        ghe && Phe(s) || jf ? p = t.anchorNode === t.focusNode && t.anchorOffset === t.focusOffset : p = t.isCollapsed;
      } else
        s = t.startContainer, l = t.startOffset, u = t.endContainer, c = t.endOffset, p = t.collapsed;
    if (s == null || u == null || l == null || c == null)
      throw new Error("Cannot resolve a Slate range from DOM range: ".concat(t));
    jf && (r = u.textContent) !== null && r !== void 0 && r.endsWith(`

`) && c === u.textContent.length && c--;
    var w = Xt.toSlatePoint(e, [s, l], {
      exactMatch: o,
      suppressThrow: i
    });
    if (!w)
      return null;
    var M = pA(s, u) || s === u && c < l, x = p ? w : Xt.toSlatePoint(e, [u, c], {
      exactMatch: o,
      suppressThrow: i,
      searchDirection: M ? "forward" : "backward"
    });
    if (!x)
      return null;
    var y = {
      anchor: w,
      focus: x
    };
    return It.isExpanded(y) && It.isForward(y) && Vi(u) && Bn.void(e, {
      at: y.focus,
      mode: "highest"
    }) && (y = Bn.unhangRange(e, y, {
      voids: !0
    })), y;
  }
}, jhe = {
  bold: "mod+b",
  compose: ["down", "left", "right", "up", "backspace", "enter"],
  moveBackward: "left",
  moveForward: "right",
  moveWordBackward: "ctrl+left",
  moveWordForward: "ctrl+right",
  deleteBackward: "shift?+backspace",
  deleteForward: "shift?+delete",
  extendBackward: "shift+left",
  extendForward: "shift+right",
  italic: "mod+i",
  insertSoftBreak: "shift+enter",
  splitBlock: "enter",
  undo: "mod+z"
}, Ahe = {
  moveLineBackward: "opt+up",
  moveLineForward: "opt+down",
  moveWordBackward: "opt+left",
  moveWordForward: "opt+right",
  deleteBackward: ["ctrl+backspace", "ctrl+h"],
  deleteForward: ["ctrl+delete", "ctrl+d"],
  deleteLineBackward: "cmd+shift?+backspace",
  deleteLineForward: ["cmd+shift?+delete", "ctrl+k"],
  deleteWordBackward: "opt+shift?+backspace",
  deleteWordForward: "opt+shift?+delete",
  extendLineBackward: "opt+shift+up",
  extendLineForward: "opt+shift+down",
  redo: "cmd+shift+z",
  transposeCharacter: "ctrl+t"
}, Bhe = {
  deleteWordBackward: "ctrl+shift?+backspace",
  deleteWordForward: "ctrl+shift?+delete",
  redo: ["ctrl+y", "ctrl+shift+z"]
}, cr = (e) => {
  var t = jhe[e], n = Ahe[e], r = Bhe[e], o = t && s0(t), i = n && s0(n), a = r && s0(r);
  return (s) => !!(o && o(s) || sA && i && i(s) || !sA && a && a(s));
};
cr("bold"), cr("compose"), cr("moveBackward"), cr("moveForward"), cr("deleteBackward"), cr("deleteForward"), cr("deleteLineBackward"), cr("deleteLineForward"), cr("deleteWordBackward"), cr("deleteWordForward"), cr("extendBackward"), cr("extendForward"), cr("extendLineBackward"), cr("extendLineForward"), cr("italic"), cr("moveLineBackward"), cr("moveLineForward"), cr("moveWordBackward"), cr("moveWordForward"), cr("redo"), cr("insertSoftBreak"), cr("splitBlock"), cr("transposeCharacter"), cr("undo");
var Ihe = (e, t) => {
  var n = [], r = () => {
    n = [];
  }, o = (a) => {
    if (t.current) {
      var s = a.filter((l) => g9(e, l, a));
      n.push(...s);
    }
  };
  function i() {
    n.length > 0 && (n.reverse().forEach((a) => {
      a.type !== "characterData" && (a.removedNodes.forEach((s) => {
        a.target.insertBefore(s, a.nextSibling);
      }), a.addedNodes.forEach((s) => {
        a.target.removeChild(s);
      }));
    }), r());
  }
  return {
    registerMutations: o,
    restoreDOM: i,
    clear: r
  };
}, Rhe = {
  subtree: !0,
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0
};
class Nhe extends pu {
  constructor() {
    super(...arguments), Rc(this, "context", null), Rc(this, "manager", null), Rc(this, "mutationObserver", null);
  }
  observe() {
    var t, {
      node: n
    } = this.props;
    if (!n.current)
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    (t = this.mutationObserver) === null || t === void 0 || t.observe(n.current, Rhe);
  }
  componentDidMount() {
    var {
      receivedUserInput: t
    } = this.props, n = this.context;
    this.manager = Ihe(n, t), this.mutationObserver = new MutationObserver(this.manager.registerMutations), this.observe();
  }
  getSnapshotBeforeUpdate() {
    var t, n, r, o = (t = this.mutationObserver) === null || t === void 0 ? void 0 : t.takeRecords();
    if (o != null && o.length) {
      var i;
      (i = this.manager) === null || i === void 0 || i.registerMutations(o);
    }
    return (n = this.mutationObserver) === null || n === void 0 || n.disconnect(), (r = this.manager) === null || r === void 0 || r.restoreDOM(), null;
  }
  componentDidUpdate() {
    var t;
    (t = this.manager) === null || t === void 0 || t.clear(), this.observe();
  }
  componentWillUnmount() {
    var t;
    (t = this.mutationObserver) === null || t === void 0 || t.disconnect();
  }
  render() {
    return this.props.children;
  }
}
Rc(Nhe, "contextType", hhe);
Ze({});
Ze({});
Ze({});
var Ur = {}, Ck = {}, ed = {}, td = {}, m9 = "Expected a function", dA = NaN, Fhe = "[object Symbol]", zhe = /^\s+|\s+$/g, Uhe = /^[-+]0x[0-9a-f]+$/i, $he = /^0b[01]+$/i, Hhe = /^0o[0-7]+$/i, Whe = parseInt, Vhe = typeof Un == "object" && Un && Un.Object === Object && Un, qhe = typeof self == "object" && self && self.Object === Object && self, Zhe = Vhe || qhe || Function("return this")(), Ghe = Object.prototype, Xhe = Ghe.toString, Khe = Math.max, Yhe = Math.min, p0 = function() {
  return Zhe.Date.now();
};
function Jhe(e, t, n) {
  var r, o, i, a, s, l, u = 0, c = !1, p = !1, d = !0;
  if (typeof e != "function")
    throw new TypeError(m9);
  t = fA(t) || 0, zg(n) && (c = !!n.leading, p = "maxWait" in n, i = p ? Khe(fA(n.maxWait) || 0, t) : i, d = "trailing" in n ? !!n.trailing : d);
  function h(C) {
    var P = r, F = o;
    return r = o = void 0, u = C, a = e.apply(F, P), a;
  }
  function f(C) {
    return u = C, s = setTimeout(E, t), c ? h(C) : a;
  }
  function m(C) {
    var P = C - l, F = C - u, L = t - P;
    return p ? Yhe(L, i - F) : L;
  }
  function g(C) {
    var P = C - l, F = C - u;
    return l === void 0 || P >= t || P < 0 || p && F >= i;
  }
  function E() {
    var C = p0();
    if (g(C))
      return w(C);
    s = setTimeout(E, m(C));
  }
  function w(C) {
    return s = void 0, d && r ? h(C) : (r = o = void 0, a);
  }
  function M() {
    s !== void 0 && clearTimeout(s), u = 0, r = l = o = s = void 0;
  }
  function x() {
    return s === void 0 ? a : w(p0());
  }
  function y() {
    var C = p0(), P = g(C);
    if (r = arguments, o = this, l = C, P) {
      if (s === void 0)
        return f(l);
      if (p)
        return s = setTimeout(E, t), h(l);
    }
    return s === void 0 && (s = setTimeout(E, t)), a;
  }
  return y.cancel = M, y.flush = x, y;
}
function Qhe(e, t, n) {
  var r = !0, o = !0;
  if (typeof e != "function")
    throw new TypeError(m9);
  return zg(n) && (r = "leading" in n ? !!n.leading : r, o = "trailing" in n ? !!n.trailing : o), Jhe(e, t, {
    leading: r,
    maxWait: t,
    trailing: o
  });
}
function zg(e) {
  var t = typeof e;
  return !!e && (t == "object" || t == "function");
}
function ege(e) {
  return !!e && typeof e == "object";
}
function tge(e) {
  return typeof e == "symbol" || ege(e) && Xhe.call(e) == Fhe;
}
function fA(e) {
  if (typeof e == "number")
    return e;
  if (tge(e))
    return dA;
  if (zg(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = zg(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = e.replace(zhe, "");
  var n = $he.test(e);
  return n || Hhe.test(e) ? Whe(e.slice(2), n ? 2 : 8) : Uhe.test(e) ? dA : +e;
}
var nge = Qhe, nd = {};
Object.defineProperty(nd, "__esModule", {
  value: !0
});
nd.addPassiveEventListener = function(e, t, n) {
  var r = n.name;
  r || (r = t, console.warn("Listener must be a named function.")), Mh.has(t) || Mh.set(t, /* @__PURE__ */ new Set());
  var o = Mh.get(t);
  if (!o.has(r)) {
    var i = function() {
      var a = !1;
      try {
        var s = Object.defineProperty({}, "passive", {
          get: function() {
            a = !0;
          }
        });
        window.addEventListener("test", null, s);
      } catch {
      }
      return a;
    }();
    e.addEventListener(t, n, i ? { passive: !0 } : !1), o.add(r);
  }
};
nd.removePassiveEventListener = function(e, t, n) {
  e.removeEventListener(t, n), Mh.get(t).delete(n.name || t);
};
var Mh = /* @__PURE__ */ new Map();
Object.defineProperty(td, "__esModule", {
  value: !0
});
var rge = nge, oge = ige(rge), hA = nd;
function ige(e) {
  return e && e.__esModule ? e : { default: e };
}
var sge = function(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 66;
  return (0, oge.default)(e, t);
}, Er = {
  spyCallbacks: [],
  spySetState: [],
  scrollSpyContainers: [],
  mount: function(e, t) {
    if (e) {
      var n = sge(function(r) {
        Er.scrollHandler(e);
      }, t);
      return Er.scrollSpyContainers.push(e), (0, hA.addPassiveEventListener)(e, "scroll", n), function() {
        (0, hA.removePassiveEventListener)(e, "scroll", n), Er.scrollSpyContainers.splice(Er.scrollSpyContainers.indexOf(e), 1);
      };
    }
    return function() {
    };
  },
  isMounted: function(e) {
    return Er.scrollSpyContainers.indexOf(e) !== -1;
  },
  currentPositionX: function(e) {
    if (e === document) {
      var t = window.scrollY !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.scrollX : n ? document.documentElement.scrollLeft : document.body.scrollLeft;
    } else
      return e.scrollLeft;
  },
  currentPositionY: function(e) {
    if (e === document) {
      var t = window.scrollX !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.scrollY : n ? document.documentElement.scrollTop : document.body.scrollTop;
    } else
      return e.scrollTop;
  },
  scrollHandler: function(e) {
    var t = Er.scrollSpyContainers[Er.scrollSpyContainers.indexOf(e)].spyCallbacks || [];
    t.forEach(function(n) {
      return n(Er.currentPositionX(e), Er.currentPositionY(e));
    });
  },
  addStateHandler: function(e) {
    Er.spySetState.push(e);
  },
  addSpyHandler: function(e, t) {
    var n = Er.scrollSpyContainers[Er.scrollSpyContainers.indexOf(t)];
    n.spyCallbacks || (n.spyCallbacks = []), n.spyCallbacks.push(e);
  },
  updateStates: function() {
    Er.spySetState.forEach(function(e) {
      return e();
    });
  },
  unmount: function(e, t) {
    Er.scrollSpyContainers.forEach(function(n) {
      return n.spyCallbacks && n.spyCallbacks.length && n.spyCallbacks.indexOf(t) > -1 && n.spyCallbacks.splice(n.spyCallbacks.indexOf(t), 1);
    }), Er.spySetState && Er.spySetState.length && Er.spySetState.indexOf(e) > -1 && Er.spySetState.splice(Er.spySetState.indexOf(e), 1), document.removeEventListener("scroll", Er.scrollHandler);
  },
  update: function() {
    return Er.scrollSpyContainers.forEach(function(e) {
      return Er.scrollHandler(e);
    });
  }
};
td.default = Er;
var xu = {}, rd = {};
Object.defineProperty(rd, "__esModule", {
  value: !0
});
var age = function(e, t) {
  var n = e.indexOf("#") === 0 ? e.substring(1) : e, r = n ? "#" + n : "", o = window && window.location, i = r ? o.pathname + o.search + r : o.pathname + o.search;
  t ? history.pushState(history.state, "", i) : history.replaceState(history.state, "", i);
}, lge = function() {
  return window.location.hash.replace(/^#/, "");
}, uge = function(e) {
  return function(t) {
    return e.contains ? e != t && e.contains(t) : !!(e.compareDocumentPosition(t) & 16);
  };
}, cge = function(e) {
  return getComputedStyle(e).position !== "static";
}, d0 = function(e, t) {
  for (var n = e.offsetTop, r = e.offsetParent; r && !t(r); )
    n += r.offsetTop, r = r.offsetParent;
  return { offsetTop: n, offsetParent: r };
}, pge = function(e, t, n) {
  if (n)
    return e === document ? t.getBoundingClientRect().left + (window.scrollX || window.pageXOffset) : getComputedStyle(e).position !== "static" ? t.offsetLeft : t.offsetLeft - e.offsetLeft;
  if (e === document)
    return t.getBoundingClientRect().top + (window.scrollY || window.pageYOffset);
  if (cge(e)) {
    if (t.offsetParent !== e) {
      var r = function(l) {
        return l === e || l === document;
      }, o = d0(t, r), i = o.offsetTop, a = o.offsetParent;
      if (a !== e)
        throw new Error("Seems containerElement is not an ancestor of the Element");
      return i;
    }
    return t.offsetTop;
  }
  if (t.offsetParent === e.offsetParent)
    return t.offsetTop - e.offsetTop;
  var s = function(l) {
    return l === document;
  };
  return d0(t, s).offsetTop - d0(e, s).offsetTop;
};
rd.default = {
  updateHash: age,
  getHash: lge,
  filterElementInContainer: uge,
  scrollOffset: pge
};
var uy = {}, xk = {};
Object.defineProperty(xk, "__esModule", {
  value: !0
});
xk.default = {
  /*
   * https://github.com/oblador/angular-scroll (duScrollDefaultEasing)
   */
  defaultEasing: function(e) {
    return e < 0.5 ? Math.pow(e * 2, 2) / 2 : 1 - Math.pow((1 - e) * 2, 2) / 2;
  },
  /*
   * https://gist.github.com/gre/1650294
   */
  // no easing, no acceleration
  linear: function(e) {
    return e;
  },
  // accelerating from zero velocity
  easeInQuad: function(e) {
    return e * e;
  },
  // decelerating to zero velocity
  easeOutQuad: function(e) {
    return e * (2 - e);
  },
  // acceleration until halfway, then deceleration
  easeInOutQuad: function(e) {
    return e < 0.5 ? 2 * e * e : -1 + (4 - 2 * e) * e;
  },
  // accelerating from zero velocity 
  easeInCubic: function(e) {
    return e * e * e;
  },
  // decelerating to zero velocity 
  easeOutCubic: function(e) {
    return --e * e * e + 1;
  },
  // acceleration until halfway, then deceleration 
  easeInOutCubic: function(e) {
    return e < 0.5 ? 4 * e * e * e : (e - 1) * (2 * e - 2) * (2 * e - 2) + 1;
  },
  // accelerating from zero velocity 
  easeInQuart: function(e) {
    return e * e * e * e;
  },
  // decelerating to zero velocity 
  easeOutQuart: function(e) {
    return 1 - --e * e * e * e;
  },
  // acceleration until halfway, then deceleration
  easeInOutQuart: function(e) {
    return e < 0.5 ? 8 * e * e * e * e : 1 - 8 * --e * e * e * e;
  },
  // accelerating from zero velocity
  easeInQuint: function(e) {
    return e * e * e * e * e;
  },
  // decelerating to zero velocity
  easeOutQuint: function(e) {
    return 1 + --e * e * e * e * e;
  },
  // acceleration until halfway, then deceleration 
  easeInOutQuint: function(e) {
    return e < 0.5 ? 16 * e * e * e * e * e : 1 + 16 * --e * e * e * e * e;
  }
};
var Ok = {};
Object.defineProperty(Ok, "__esModule", {
  value: !0
});
var dge = nd, fge = ["mousedown", "wheel", "touchmove", "keydown"];
Ok.default = {
  subscribe: function(e) {
    return typeof document < "u" && fge.forEach(function(t) {
      return (0, dge.addPassiveEventListener)(document, t, e);
    });
  }
};
var od = {};
Object.defineProperty(od, "__esModule", {
  value: !0
});
var ux = {
  registered: {},
  scrollEvent: {
    register: function(e, t) {
      ux.registered[e] = t;
    },
    remove: function(e) {
      ux.registered[e] = null;
    }
  }
};
od.default = ux;
Object.defineProperty(uy, "__esModule", {
  value: !0
});
var hge = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, gge = rd;
cy(gge);
var mge = xk, gA = cy(mge), vge = Ok, yge = cy(vge), bge = od, Fi = cy(bge);
function cy(e) {
  return e && e.__esModule ? e : { default: e };
}
var v9 = function(e) {
  return gA.default[e.smooth] || gA.default.defaultEasing;
}, wge = function(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}, Cge = function() {
  if (typeof window < "u")
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame;
}, cx = function() {
  return Cge() || function(e, t, n) {
    window.setTimeout(e, n || 1e3 / 60, (/* @__PURE__ */ new Date()).getTime());
  };
}(), y9 = function() {
  return {
    currentPosition: 0,
    startPosition: 0,
    targetPosition: 0,
    progress: 0,
    duration: 0,
    cancel: !1,
    target: null,
    containerElement: null,
    to: null,
    start: null,
    delta: null,
    percent: null,
    delayTimeout: null
  };
}, b9 = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollLeft;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageXOffset : r ? document.documentElement.scrollLeft : document.body.scrollLeft;
}, w9 = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollTop;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageYOffset : r ? document.documentElement.scrollTop : document.body.scrollTop;
}, xge = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollWidth - t.offsetWidth;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollWidth, n.offsetWidth, r.clientWidth, r.scrollWidth, r.offsetWidth);
}, Oge = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollHeight - t.offsetHeight;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollHeight, n.offsetHeight, r.clientHeight, r.scrollHeight, r.offsetHeight);
}, Ege = function e(t, n, r) {
  var o = n.data;
  if (!n.ignoreCancelEvents && o.cancel) {
    Fi.default.registered.end && Fi.default.registered.end(o.to, o.target, o.currentPositionY);
    return;
  }
  if (o.delta = Math.round(o.targetPosition - o.startPosition), o.start === null && (o.start = r), o.progress = r - o.start, o.percent = o.progress >= o.duration ? 1 : t(o.progress / o.duration), o.currentPosition = o.startPosition + Math.ceil(o.delta * o.percent), o.containerElement && o.containerElement !== document && o.containerElement !== document.body ? n.horizontal ? o.containerElement.scrollLeft = o.currentPosition : o.containerElement.scrollTop = o.currentPosition : n.horizontal ? window.scrollTo(o.currentPosition, 0) : window.scrollTo(0, o.currentPosition), o.percent < 1) {
    var i = e.bind(null, t, n);
    cx.call(window, i);
    return;
  }
  Fi.default.registered.end && Fi.default.registered.end(o.to, o.target, o.currentPosition);
}, Ek = function(e) {
  e.data.containerElement = e ? e.containerId ? document.getElementById(e.containerId) : e.container && e.container.nodeType ? e.container : document : null;
}, id = function(e, t, n, r) {
  t.data = t.data || y9(), window.clearTimeout(t.data.delayTimeout);
  var o = function() {
    t.data.cancel = !0;
  };
  if (yge.default.subscribe(o), Ek(t), t.data.start = null, t.data.cancel = !1, t.data.startPosition = t.horizontal ? b9(t) : w9(t), t.data.targetPosition = t.absolute ? e : e + t.data.startPosition, t.data.startPosition === t.data.targetPosition) {
    Fi.default.registered.end && Fi.default.registered.end(t.data.to, t.data.target, t.data.currentPosition);
    return;
  }
  t.data.delta = Math.round(t.data.targetPosition - t.data.startPosition), t.data.duration = wge(t.duration)(t.data.delta), t.data.duration = isNaN(parseFloat(t.data.duration)) ? 1e3 : parseFloat(t.data.duration), t.data.to = n, t.data.target = r;
  var i = v9(t), a = Ege.bind(null, i, t);
  if (t && t.delay > 0) {
    t.data.delayTimeout = window.setTimeout(function() {
      Fi.default.registered.begin && Fi.default.registered.begin(t.data.to, t.data.target), cx.call(window, a);
    }, t.delay);
    return;
  }
  Fi.default.registered.begin && Fi.default.registered.begin(t.data.to, t.data.target), cx.call(window, a);
}, py = function(e) {
  return e = hge({}, e), e.data = e.data || y9(), e.absolute = !0, e;
}, kge = function(e) {
  id(0, py(e));
}, Lge = function(e, t) {
  id(e, py(t));
}, _ge = function(e) {
  e = py(e), Ek(e), id(e.horizontal ? xge(e) : Oge(e), e);
}, Pge = function(e, t) {
  t = py(t), Ek(t);
  var n = t.horizontal ? b9(t) : w9(t);
  id(e + n, t);
};
uy.default = {
  animateTopScroll: id,
  getAnimationType: v9,
  scrollToTop: kge,
  scrollToBottom: _ge,
  scrollTo: Lge,
  scrollMore: Pge
};
Object.defineProperty(xu, "__esModule", {
  value: !0
});
var Sge = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, Mge = rd, Dge = kk(Mge), Tge = uy, jge = kk(Tge), Age = od, Bf = kk(Age);
function kk(e) {
  return e && e.__esModule ? e : { default: e };
}
var If = {}, mA = void 0;
xu.default = {
  unmount: function() {
    If = {};
  },
  register: function(e, t) {
    If[e] = t;
  },
  unregister: function(e) {
    delete If[e];
  },
  get: function(e) {
    return If[e] || document.getElementById(e) || document.getElementsByName(e)[0] || document.getElementsByClassName(e)[0];
  },
  setActiveLink: function(e) {
    return mA = e;
  },
  getActiveLink: function() {
    return mA;
  },
  scrollTo: function(e, t) {
    var n = this.get(e);
    if (!n) {
      console.warn("target Element not found");
      return;
    }
    t = Sge({}, t, { absolute: !1 });
    var r = t.containerId, o = t.container, i = void 0;
    r ? i = document.getElementById(r) : o && o.nodeType ? i = o : i = document, t.absolute = !0;
    var a = t.horizontal, s = Dge.default.scrollOffset(i, n, a) + (t.offset || 0);
    if (!t.smooth) {
      Bf.default.registered.begin && Bf.default.registered.begin(e, n), i === document ? t.horizontal ? window.scrollTo(s, 0) : window.scrollTo(0, s) : i.scrollTop = s, Bf.default.registered.end && Bf.default.registered.end(e, n);
      return;
    }
    jge.default.animateTopScroll(s, t, e, n);
  }
};
var px = { exports: {} }, f0 = { exports: {} }, bn = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var vA;
function Bge() {
  if (vA) return bn;
  vA = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, h = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, m = e ? Symbol.for("react.block") : 60121, g = e ? Symbol.for("react.fundamental") : 60117, E = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
  function M(y) {
    if (typeof y == "object" && y !== null) {
      var C = y.$$typeof;
      switch (C) {
        case t:
          switch (y = y.type, y) {
            case l:
            case u:
            case r:
            case i:
            case o:
            case p:
              return y;
            default:
              switch (y = y && y.$$typeof, y) {
                case s:
                case c:
                case f:
                case h:
                case a:
                  return y;
                default:
                  return C;
              }
          }
        case n:
          return C;
      }
    }
  }
  function x(y) {
    return M(y) === u;
  }
  return bn.AsyncMode = l, bn.ConcurrentMode = u, bn.ContextConsumer = s, bn.ContextProvider = a, bn.Element = t, bn.ForwardRef = c, bn.Fragment = r, bn.Lazy = f, bn.Memo = h, bn.Portal = n, bn.Profiler = i, bn.StrictMode = o, bn.Suspense = p, bn.isAsyncMode = function(y) {
    return x(y) || M(y) === l;
  }, bn.isConcurrentMode = x, bn.isContextConsumer = function(y) {
    return M(y) === s;
  }, bn.isContextProvider = function(y) {
    return M(y) === a;
  }, bn.isElement = function(y) {
    return typeof y == "object" && y !== null && y.$$typeof === t;
  }, bn.isForwardRef = function(y) {
    return M(y) === c;
  }, bn.isFragment = function(y) {
    return M(y) === r;
  }, bn.isLazy = function(y) {
    return M(y) === f;
  }, bn.isMemo = function(y) {
    return M(y) === h;
  }, bn.isPortal = function(y) {
    return M(y) === n;
  }, bn.isProfiler = function(y) {
    return M(y) === i;
  }, bn.isStrictMode = function(y) {
    return M(y) === o;
  }, bn.isSuspense = function(y) {
    return M(y) === p;
  }, bn.isValidElementType = function(y) {
    return typeof y == "string" || typeof y == "function" || y === r || y === u || y === i || y === o || y === p || y === d || typeof y == "object" && y !== null && (y.$$typeof === f || y.$$typeof === h || y.$$typeof === a || y.$$typeof === s || y.$$typeof === c || y.$$typeof === g || y.$$typeof === E || y.$$typeof === w || y.$$typeof === m);
  }, bn.typeOf = M, bn;
}
var Sn = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var yA;
function Ige() {
  return yA || (yA = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, h = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, m = e ? Symbol.for("react.block") : 60121, g = e ? Symbol.for("react.fundamental") : 60117, E = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
    function M(R) {
      return typeof R == "string" || typeof R == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      R === r || R === u || R === i || R === o || R === p || R === d || typeof R == "object" && R !== null && (R.$$typeof === f || R.$$typeof === h || R.$$typeof === a || R.$$typeof === s || R.$$typeof === c || R.$$typeof === g || R.$$typeof === E || R.$$typeof === w || R.$$typeof === m);
    }
    function x(R) {
      if (typeof R == "object" && R !== null) {
        var ue = R.$$typeof;
        switch (ue) {
          case t:
            var fe = R.type;
            switch (fe) {
              case l:
              case u:
              case r:
              case i:
              case o:
              case p:
                return fe;
              default:
                var oe = fe && fe.$$typeof;
                switch (oe) {
                  case s:
                  case c:
                  case f:
                  case h:
                  case a:
                    return oe;
                  default:
                    return ue;
                }
            }
          case n:
            return ue;
        }
      }
    }
    var y = l, C = u, P = s, F = a, L = t, N = c, I = r, H = f, V = h, z = n, q = i, K = o, J = p, te = !1;
    function ee(R) {
      return te || (te = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), _(R) || x(R) === l;
    }
    function _(R) {
      return x(R) === u;
    }
    function D(R) {
      return x(R) === s;
    }
    function $(R) {
      return x(R) === a;
    }
    function S(R) {
      return typeof R == "object" && R !== null && R.$$typeof === t;
    }
    function W(R) {
      return x(R) === c;
    }
    function O(R) {
      return x(R) === r;
    }
    function T(R) {
      return x(R) === f;
    }
    function U(R) {
      return x(R) === h;
    }
    function j(R) {
      return x(R) === n;
    }
    function Z(R) {
      return x(R) === i;
    }
    function A(R) {
      return x(R) === o;
    }
    function Q(R) {
      return x(R) === p;
    }
    Sn.AsyncMode = y, Sn.ConcurrentMode = C, Sn.ContextConsumer = P, Sn.ContextProvider = F, Sn.Element = L, Sn.ForwardRef = N, Sn.Fragment = I, Sn.Lazy = H, Sn.Memo = V, Sn.Portal = z, Sn.Profiler = q, Sn.StrictMode = K, Sn.Suspense = J, Sn.isAsyncMode = ee, Sn.isConcurrentMode = _, Sn.isContextConsumer = D, Sn.isContextProvider = $, Sn.isElement = S, Sn.isForwardRef = W, Sn.isFragment = O, Sn.isLazy = T, Sn.isMemo = U, Sn.isPortal = j, Sn.isProfiler = Z, Sn.isStrictMode = A, Sn.isSuspense = Q, Sn.isValidElementType = M, Sn.typeOf = x;
  }()), Sn;
}
var bA;
function C9() {
  return bA || (bA = 1, process.env.NODE_ENV === "production" ? f0.exports = Bge() : f0.exports = Ige()), f0.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var h0, wA;
function Rge() {
  if (wA) return h0;
  wA = 1;
  var e = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, n = Object.prototype.propertyIsEnumerable;
  function r(i) {
    if (i == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(i);
  }
  function o() {
    try {
      if (!Object.assign)
        return !1;
      var i = new String("abc");
      if (i[5] = "de", Object.getOwnPropertyNames(i)[0] === "5")
        return !1;
      for (var a = {}, s = 0; s < 10; s++)
        a["_" + String.fromCharCode(s)] = s;
      var l = Object.getOwnPropertyNames(a).map(function(c) {
        return a[c];
      });
      if (l.join("") !== "0123456789")
        return !1;
      var u = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(c) {
        u[c] = c;
      }), Object.keys(Object.assign({}, u)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return h0 = o() ? Object.assign : function(i, a) {
    for (var s, l = r(i), u, c = 1; c < arguments.length; c++) {
      s = Object(arguments[c]);
      for (var p in s)
        t.call(s, p) && (l[p] = s[p]);
      if (e) {
        u = e(s);
        for (var d = 0; d < u.length; d++)
          n.call(s, u[d]) && (l[u[d]] = s[u[d]]);
      }
    }
    return l;
  }, h0;
}
var g0, CA;
function Lk() {
  if (CA) return g0;
  CA = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return g0 = e, g0;
}
var xA, OA;
function x9() {
  return OA || (OA = 1, xA = Function.call.bind(Object.prototype.hasOwnProperty)), xA;
}
var m0, EA;
function Nge() {
  if (EA) return m0;
  EA = 1;
  var e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = Lk(), n = {}, r = x9();
    e = function(i) {
      var a = "Warning: " + i;
      typeof console < "u" && console.error(a);
      try {
        throw new Error(a);
      } catch {
      }
    };
  }
  function o(i, a, s, l, u) {
    if (process.env.NODE_ENV !== "production") {
      for (var c in i)
        if (r(i, c)) {
          var p;
          try {
            if (typeof i[c] != "function") {
              var d = Error(
                (l || "React class") + ": " + s + " type `" + c + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof i[c] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw d.name = "Invariant Violation", d;
            }
            p = i[c](a, c, l, s, null, t);
          } catch (f) {
            p = f;
          }
          if (p && !(p instanceof Error) && e(
            (l || "React class") + ": type specification of " + s + " `" + c + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof p + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), p instanceof Error && !(p.message in n)) {
            n[p.message] = !0;
            var h = u ? u() : "";
            e(
              "Failed " + s + " type: " + p.message + (h ?? "")
            );
          }
        }
    }
  }
  return o.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (n = {});
  }, m0 = o, m0;
}
var v0, kA;
function Fge() {
  if (kA) return v0;
  kA = 1;
  var e = C9(), t = Rge(), n = Lk(), r = x9(), o = Nge(), i = function() {
  };
  process.env.NODE_ENV !== "production" && (i = function(s) {
    var l = "Warning: " + s;
    typeof console < "u" && console.error(l);
    try {
      throw new Error(l);
    } catch {
    }
  });
  function a() {
    return null;
  }
  return v0 = function(s, l) {
    var u = typeof Symbol == "function" && Symbol.iterator, c = "@@iterator";
    function p(_) {
      var D = _ && (u && _[u] || _[c]);
      if (typeof D == "function")
        return D;
    }
    var d = "<<anonymous>>", h = {
      array: E("array"),
      bigint: E("bigint"),
      bool: E("boolean"),
      func: E("function"),
      number: E("number"),
      object: E("object"),
      string: E("string"),
      symbol: E("symbol"),
      any: w(),
      arrayOf: M,
      element: x(),
      elementType: y(),
      instanceOf: C,
      node: N(),
      objectOf: F,
      oneOf: P,
      oneOfType: L,
      shape: H,
      exact: V
    };
    function f(_, D) {
      return _ === D ? _ !== 0 || 1 / _ === 1 / D : _ !== _ && D !== D;
    }
    function m(_, D) {
      this.message = _, this.data = D && typeof D == "object" ? D : {}, this.stack = "";
    }
    m.prototype = Error.prototype;
    function g(_) {
      if (process.env.NODE_ENV !== "production")
        var D = {}, $ = 0;
      function S(O, T, U, j, Z, A, Q) {
        if (j = j || d, A = A || U, Q !== n) {
          if (l) {
            var R = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw R.name = "Invariant Violation", R;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var ue = j + ":" + U;
            !D[ue] && // Avoid spamming the console because they are often not actionable except for lib authors
            $ < 3 && (i(
              "You are manually calling a React.PropTypes validation function for the `" + A + "` prop on `" + j + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), D[ue] = !0, $++);
          }
        }
        return T[U] == null ? O ? T[U] === null ? new m("The " + Z + " `" + A + "` is marked as required " + ("in `" + j + "`, but its value is `null`.")) : new m("The " + Z + " `" + A + "` is marked as required in " + ("`" + j + "`, but its value is `undefined`.")) : null : _(T, U, j, Z, A);
      }
      var W = S.bind(null, !1);
      return W.isRequired = S.bind(null, !0), W;
    }
    function E(_) {
      function D($, S, W, O, T, U) {
        var j = $[S], Z = K(j);
        if (Z !== _) {
          var A = J(j);
          return new m(
            "Invalid " + O + " `" + T + "` of type " + ("`" + A + "` supplied to `" + W + "`, expected ") + ("`" + _ + "`."),
            { expectedType: _ }
          );
        }
        return null;
      }
      return g(D);
    }
    function w() {
      return g(a);
    }
    function M(_) {
      function D($, S, W, O, T) {
        if (typeof _ != "function")
          return new m("Property `" + T + "` of component `" + W + "` has invalid PropType notation inside arrayOf.");
        var U = $[S];
        if (!Array.isArray(U)) {
          var j = K(U);
          return new m("Invalid " + O + " `" + T + "` of type " + ("`" + j + "` supplied to `" + W + "`, expected an array."));
        }
        for (var Z = 0; Z < U.length; Z++) {
          var A = _(U, Z, W, O, T + "[" + Z + "]", n);
          if (A instanceof Error)
            return A;
        }
        return null;
      }
      return g(D);
    }
    function x() {
      function _(D, $, S, W, O) {
        var T = D[$];
        if (!s(T)) {
          var U = K(T);
          return new m("Invalid " + W + " `" + O + "` of type " + ("`" + U + "` supplied to `" + S + "`, expected a single ReactElement."));
        }
        return null;
      }
      return g(_);
    }
    function y() {
      function _(D, $, S, W, O) {
        var T = D[$];
        if (!e.isValidElementType(T)) {
          var U = K(T);
          return new m("Invalid " + W + " `" + O + "` of type " + ("`" + U + "` supplied to `" + S + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return g(_);
    }
    function C(_) {
      function D($, S, W, O, T) {
        if (!($[S] instanceof _)) {
          var U = _.name || d, j = ee($[S]);
          return new m("Invalid " + O + " `" + T + "` of type " + ("`" + j + "` supplied to `" + W + "`, expected ") + ("instance of `" + U + "`."));
        }
        return null;
      }
      return g(D);
    }
    function P(_) {
      if (!Array.isArray(_))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? i(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : i("Invalid argument supplied to oneOf, expected an array.")), a;
      function D($, S, W, O, T) {
        for (var U = $[S], j = 0; j < _.length; j++)
          if (f(U, _[j]))
            return null;
        var Z = JSON.stringify(_, function(A, Q) {
          var R = J(Q);
          return R === "symbol" ? String(Q) : Q;
        });
        return new m("Invalid " + O + " `" + T + "` of value `" + String(U) + "` " + ("supplied to `" + W + "`, expected one of " + Z + "."));
      }
      return g(D);
    }
    function F(_) {
      function D($, S, W, O, T) {
        if (typeof _ != "function")
          return new m("Property `" + T + "` of component `" + W + "` has invalid PropType notation inside objectOf.");
        var U = $[S], j = K(U);
        if (j !== "object")
          return new m("Invalid " + O + " `" + T + "` of type " + ("`" + j + "` supplied to `" + W + "`, expected an object."));
        for (var Z in U)
          if (r(U, Z)) {
            var A = _(U, Z, W, O, T + "." + Z, n);
            if (A instanceof Error)
              return A;
          }
        return null;
      }
      return g(D);
    }
    function L(_) {
      if (!Array.isArray(_))
        return process.env.NODE_ENV !== "production" && i("Invalid argument supplied to oneOfType, expected an instance of array."), a;
      for (var D = 0; D < _.length; D++) {
        var $ = _[D];
        if (typeof $ != "function")
          return i(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + te($) + " at index " + D + "."
          ), a;
      }
      function S(W, O, T, U, j) {
        for (var Z = [], A = 0; A < _.length; A++) {
          var Q = _[A], R = Q(W, O, T, U, j, n);
          if (R == null)
            return null;
          R.data && r(R.data, "expectedType") && Z.push(R.data.expectedType);
        }
        var ue = Z.length > 0 ? ", expected one of type [" + Z.join(", ") + "]" : "";
        return new m("Invalid " + U + " `" + j + "` supplied to " + ("`" + T + "`" + ue + "."));
      }
      return g(S);
    }
    function N() {
      function _(D, $, S, W, O) {
        return z(D[$]) ? null : new m("Invalid " + W + " `" + O + "` supplied to " + ("`" + S + "`, expected a ReactNode."));
      }
      return g(_);
    }
    function I(_, D, $, S, W) {
      return new m(
        (_ || "React class") + ": " + D + " type `" + $ + "." + S + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + W + "`."
      );
    }
    function H(_) {
      function D($, S, W, O, T) {
        var U = $[S], j = K(U);
        if (j !== "object")
          return new m("Invalid " + O + " `" + T + "` of type `" + j + "` " + ("supplied to `" + W + "`, expected `object`."));
        for (var Z in _) {
          var A = _[Z];
          if (typeof A != "function")
            return I(W, O, T, Z, J(A));
          var Q = A(U, Z, W, O, T + "." + Z, n);
          if (Q)
            return Q;
        }
        return null;
      }
      return g(D);
    }
    function V(_) {
      function D($, S, W, O, T) {
        var U = $[S], j = K(U);
        if (j !== "object")
          return new m("Invalid " + O + " `" + T + "` of type `" + j + "` " + ("supplied to `" + W + "`, expected `object`."));
        var Z = t({}, $[S], _);
        for (var A in Z) {
          var Q = _[A];
          if (r(_, A) && typeof Q != "function")
            return I(W, O, T, A, J(Q));
          if (!Q)
            return new m(
              "Invalid " + O + " `" + T + "` key `" + A + "` supplied to `" + W + "`.\nBad object: " + JSON.stringify($[S], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(_), null, "  ")
            );
          var R = Q(U, A, W, O, T + "." + A, n);
          if (R)
            return R;
        }
        return null;
      }
      return g(D);
    }
    function z(_) {
      switch (typeof _) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !_;
        case "object":
          if (Array.isArray(_))
            return _.every(z);
          if (_ === null || s(_))
            return !0;
          var D = p(_);
          if (D) {
            var $ = D.call(_), S;
            if (D !== _.entries) {
              for (; !(S = $.next()).done; )
                if (!z(S.value))
                  return !1;
            } else
              for (; !(S = $.next()).done; ) {
                var W = S.value;
                if (W && !z(W[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function q(_, D) {
      return _ === "symbol" ? !0 : D ? D["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && D instanceof Symbol : !1;
    }
    function K(_) {
      var D = typeof _;
      return Array.isArray(_) ? "array" : _ instanceof RegExp ? "object" : q(D, _) ? "symbol" : D;
    }
    function J(_) {
      if (typeof _ > "u" || _ === null)
        return "" + _;
      var D = K(_);
      if (D === "object") {
        if (_ instanceof Date)
          return "date";
        if (_ instanceof RegExp)
          return "regexp";
      }
      return D;
    }
    function te(_) {
      var D = J(_);
      switch (D) {
        case "array":
        case "object":
          return "an " + D;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + D;
        default:
          return D;
      }
    }
    function ee(_) {
      return !_.constructor || !_.constructor.name ? d : _.constructor.name;
    }
    return h.checkPropTypes = o, h.resetWarningCache = o.resetWarningCache, h.PropTypes = h, h;
  }, v0;
}
var y0, LA;
function zge() {
  if (LA) return y0;
  LA = 1;
  var e = Lk();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, y0 = function() {
    function r(a, s, l, u, c, p) {
      if (p !== e) {
        var d = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw d.name = "Invariant Violation", d;
      }
    }
    r.isRequired = r;
    function o() {
      return r;
    }
    var i = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: o,
      element: r,
      elementType: r,
      instanceOf: o,
      node: r,
      objectOf: o,
      oneOf: o,
      oneOfType: o,
      shape: o,
      exact: o,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return i.PropTypes = i, i;
  }, y0;
}
if (process.env.NODE_ENV !== "production") {
  var Uge = C9(), $ge = !0;
  px.exports = Fge()(Uge.isElement, $ge);
} else
  px.exports = zge()();
var dy = px.exports, fy = {};
Object.defineProperty(fy, "__esModule", {
  value: !0
});
var Hge = rd, b0 = Wge(Hge);
function Wge(e) {
  return e && e.__esModule ? e : { default: e };
}
var Vge = {
  mountFlag: !1,
  initialized: !1,
  scroller: null,
  containers: {},
  mount: function(e) {
    this.scroller = e, this.handleHashChange = this.handleHashChange.bind(this), window.addEventListener("hashchange", this.handleHashChange), this.initStateFromHash(), this.mountFlag = !0;
  },
  mapContainer: function(e, t) {
    this.containers[e] = t;
  },
  isMounted: function() {
    return this.mountFlag;
  },
  isInitialized: function() {
    return this.initialized;
  },
  initStateFromHash: function() {
    var e = this, t = this.getHash();
    t ? window.setTimeout(function() {
      e.scrollTo(t, !0), e.initialized = !0;
    }, 10) : this.initialized = !0;
  },
  scrollTo: function(e, t) {
    var n = this.scroller, r = n.get(e);
    if (r && (t || e !== n.getActiveLink())) {
      var o = this.containers[e] || document;
      n.scrollTo(e, { container: o });
    }
  },
  getHash: function() {
    return b0.default.getHash();
  },
  changeHash: function(e, t) {
    this.isInitialized() && b0.default.getHash() !== e && b0.default.updateHash(e, t);
  },
  handleHashChange: function() {
    this.scrollTo(this.getHash());
  },
  unmount: function() {
    this.scroller = null, this.containers = null, window.removeEventListener("hashchange", this.handleHashChange);
  }
};
fy.default = Vge;
Object.defineProperty(ed, "__esModule", {
  value: !0
});
var Rf = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, qge = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), Zge = ke, _A = sd(Zge), Gge = td, Nf = sd(Gge), Xge = xu, Kge = sd(Xge), Yge = dy, pr = sd(Yge), Jge = fy, Is = sd(Jge);
function sd(e) {
  return e && e.__esModule ? e : { default: e };
}
function Qge(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function eme(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function tme(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var PA = {
  to: pr.default.string.isRequired,
  containerId: pr.default.string,
  container: pr.default.object,
  activeClass: pr.default.string,
  activeStyle: pr.default.object,
  spy: pr.default.bool,
  horizontal: pr.default.bool,
  smooth: pr.default.oneOfType([pr.default.bool, pr.default.string]),
  offset: pr.default.number,
  delay: pr.default.number,
  isDynamic: pr.default.bool,
  onClick: pr.default.func,
  duration: pr.default.oneOfType([pr.default.number, pr.default.func]),
  absolute: pr.default.bool,
  onSetActive: pr.default.func,
  onSetInactive: pr.default.func,
  ignoreCancelEvents: pr.default.bool,
  hashSpy: pr.default.bool,
  saveHashHistory: pr.default.bool,
  spyThrottle: pr.default.number
};
ed.default = function(e, t) {
  var n = t || Kge.default, r = function(i) {
    tme(a, i);
    function a(s) {
      Qge(this, a);
      var l = eme(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
      return o.call(l), l.state = {
        active: !1
      }, l.beforeUnmountCallbacks = [], l;
    }
    return qge(a, [{
      key: "getScrollSpyContainer",
      value: function() {
        var s = this.props.containerId, l = this.props.container;
        return s && !l ? document.getElementById(s) : l && l.nodeType ? l : document;
      }
    }, {
      key: "componentDidMount",
      value: function() {
        if (this.props.spy || this.props.hashSpy) {
          var s = this.getScrollSpyContainer();
          if (!Nf.default.isMounted(s)) {
            var l = Nf.default.mount(s, this.props.spyThrottle);
            this.beforeUnmountCallbacks.push(l);
          }
          this.props.hashSpy && (Is.default.isMounted() || Is.default.mount(n), Is.default.mapContainer(this.props.to, s)), Nf.default.addSpyHandler(this.spyHandler, s), this.setState({
            container: s
          });
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        Nf.default.unmount(this.stateHandler, this.spyHandler), this.beforeUnmountCallbacks.forEach(function(s) {
          return s();
        });
      }
    }, {
      key: "render",
      value: function() {
        var s = "";
        this.state && this.state.active ? s = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : s = this.props.className;
        var l = {};
        this.state && this.state.active ? l = Rf({}, this.props.style, this.props.activeStyle) : l = Rf({}, this.props.style);
        var u = Rf({}, this.props);
        for (var c in PA)
          u.hasOwnProperty(c) && delete u[c];
        return u.className = s, u.style = l, u.onClick = this.handleClick, _A.default.createElement(e, u);
      }
    }]), a;
  }(_A.default.PureComponent), o = function() {
    var i = this;
    this.scrollTo = function(a, s) {
      n.scrollTo(a, Rf({}, i.state, s));
    }, this.handleClick = function(a) {
      i.props.onClick && i.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), i.scrollTo(i.props.to, i.props);
    }, this.spyHandler = function(a, s) {
      var l = i.getScrollSpyContainer();
      if (!(Is.default.isMounted() && !Is.default.isInitialized())) {
        var u = i.props.horizontal, c = i.props.to, p = null, d = void 0, h = void 0;
        if (u) {
          var f = 0, m = 0, g = 0;
          if (l.getBoundingClientRect) {
            var E = l.getBoundingClientRect();
            g = E.left;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var w = p.getBoundingClientRect();
            f = w.left - g + a, m = f + w.width;
          }
          var M = a - i.props.offset;
          d = M >= Math.floor(f) && M < Math.floor(m), h = M < Math.floor(f) || M >= Math.floor(m);
        } else {
          var x = 0, y = 0, C = 0;
          if (l.getBoundingClientRect) {
            var P = l.getBoundingClientRect();
            C = P.top;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var F = p.getBoundingClientRect();
            x = F.top - C + s, y = x + F.height;
          }
          var L = s - i.props.offset;
          d = L >= Math.floor(x) && L < Math.floor(y), h = L < Math.floor(x) || L >= Math.floor(y);
        }
        var N = n.getActiveLink();
        if (h) {
          if (c === N && n.setActiveLink(void 0), i.props.hashSpy && Is.default.getHash() === c) {
            var I = i.props.saveHashHistory, H = I === void 0 ? !1 : I;
            Is.default.changeHash("", H);
          }
          i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive(c, p));
        }
        if (d && (N !== c || i.state.active === !1)) {
          n.setActiveLink(c);
          var V = i.props.saveHashHistory, z = V === void 0 ? !1 : V;
          i.props.hashSpy && Is.default.changeHash(c, z), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(c, p));
        }
      }
    };
  };
  return r.propTypes = PA, r.defaultProps = { offset: 0 }, r;
};
Object.defineProperty(Ck, "__esModule", {
  value: !0
});
var nme = ke, SA = O9(nme), rme = ed, ome = O9(rme);
function O9(e) {
  return e && e.__esModule ? e : { default: e };
}
function ime(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function MA(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function sme(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var ame = function(e) {
  sme(t, e);
  function t() {
    var n, r, o, i;
    ime(this, t);
    for (var a = arguments.length, s = Array(a), l = 0; l < a; l++)
      s[l] = arguments[l];
    return i = (r = (o = MA(this, (n = t.__proto__ || Object.getPrototypeOf(t)).call.apply(n, [this].concat(s))), o), o.render = function() {
      return SA.default.createElement(
        "a",
        o.props,
        o.props.children
      );
    }, r), MA(o, i);
  }
  return t;
}(SA.default.Component);
Ck.default = (0, ome.default)(ame);
var _k = {};
Object.defineProperty(_k, "__esModule", {
  value: !0
});
var lme = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), ume = ke, DA = E9(ume), cme = ed, pme = E9(cme);
function E9(e) {
  return e && e.__esModule ? e : { default: e };
}
function dme(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function fme(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function hme(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var gme = function(e) {
  hme(t, e);
  function t() {
    return dme(this, t), fme(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return lme(t, [{
    key: "render",
    value: function() {
      return DA.default.createElement(
        "button",
        this.props,
        this.props.children
      );
    }
  }]), t;
}(DA.default.Component);
_k.default = (0, pme.default)(gme);
var Pk = {}, hy = {};
Object.defineProperty(hy, "__esModule", {
  value: !0
});
var mme = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, vme = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), yme = ke, TA = gy(yme), bme = Rl;
gy(bme);
var wme = xu, jA = gy(wme), Cme = dy, AA = gy(Cme);
function gy(e) {
  return e && e.__esModule ? e : { default: e };
}
function xme(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Ome(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function Eme(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
hy.default = function(e) {
  var t = function(n) {
    Eme(r, n);
    function r(o) {
      xme(this, r);
      var i = Ome(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
      return i.childBindings = {
        domNode: null
      }, i;
    }
    return vme(r, [{
      key: "componentDidMount",
      value: function() {
        if (typeof window > "u")
          return !1;
        this.registerElems(this.props.name);
      }
    }, {
      key: "componentDidUpdate",
      value: function(o) {
        this.props.name !== o.name && this.registerElems(this.props.name);
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        if (typeof window > "u")
          return !1;
        jA.default.unregister(this.props.name);
      }
    }, {
      key: "registerElems",
      value: function(o) {
        jA.default.register(o, this.childBindings.domNode);
      }
    }, {
      key: "render",
      value: function() {
        return TA.default.createElement(e, mme({}, this.props, { parentBindings: this.childBindings }));
      }
    }]), r;
  }(TA.default.Component);
  return t.propTypes = {
    name: AA.default.string,
    id: AA.default.string
  }, t;
};
Object.defineProperty(Pk, "__esModule", {
  value: !0
});
var BA = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, kme = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), Lme = ke, IA = Sk(Lme), _me = hy, Pme = Sk(_me), Sme = dy, RA = Sk(Sme);
function Sk(e) {
  return e && e.__esModule ? e : { default: e };
}
function Mme(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Dme(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function Tme(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var k9 = function(e) {
  Tme(t, e);
  function t() {
    return Mme(this, t), Dme(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return kme(t, [{
    key: "render",
    value: function() {
      var n = this, r = BA({}, this.props);
      return delete r.name, r.parentBindings && delete r.parentBindings, IA.default.createElement(
        "div",
        BA({}, r, { ref: function(o) {
          n.props.parentBindings.domNode = o;
        } }),
        this.props.children
      );
    }
  }]), t;
}(IA.default.Component);
k9.propTypes = {
  name: RA.default.string,
  id: RA.default.string
};
Pk.default = (0, Pme.default)(k9);
var w0 = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, NA = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}();
function FA(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function zA(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function UA(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var Ff = ke, Na = td, C0 = xu, Mr = dy, Rs = fy, $A = {
  to: Mr.string.isRequired,
  containerId: Mr.string,
  container: Mr.object,
  activeClass: Mr.string,
  spy: Mr.bool,
  smooth: Mr.oneOfType([Mr.bool, Mr.string]),
  offset: Mr.number,
  delay: Mr.number,
  isDynamic: Mr.bool,
  onClick: Mr.func,
  duration: Mr.oneOfType([Mr.number, Mr.func]),
  absolute: Mr.bool,
  onSetActive: Mr.func,
  onSetInactive: Mr.func,
  ignoreCancelEvents: Mr.bool,
  hashSpy: Mr.bool,
  spyThrottle: Mr.number
}, jme = {
  Scroll: function(e, t) {
    console.warn("Helpers.Scroll is deprecated since v1.7.0");
    var n = t || C0, r = function(i) {
      UA(a, i);
      function a(s) {
        FA(this, a);
        var l = zA(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
        return o.call(l), l.state = {
          active: !1
        }, l;
      }
      return NA(a, [{
        key: "getScrollSpyContainer",
        value: function() {
          var s = this.props.containerId, l = this.props.container;
          return s ? document.getElementById(s) : l && l.nodeType ? l : document;
        }
      }, {
        key: "componentDidMount",
        value: function() {
          if (this.props.spy || this.props.hashSpy) {
            var s = this.getScrollSpyContainer();
            Na.isMounted(s) || Na.mount(s, this.props.spyThrottle), this.props.hashSpy && (Rs.isMounted() || Rs.mount(n), Rs.mapContainer(this.props.to, s)), this.props.spy && Na.addStateHandler(this.stateHandler), Na.addSpyHandler(this.spyHandler, s), this.setState({
              container: s
            });
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          Na.unmount(this.stateHandler, this.spyHandler);
        }
      }, {
        key: "render",
        value: function() {
          var s = "";
          this.state && this.state.active ? s = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : s = this.props.className;
          var l = w0({}, this.props);
          for (var u in $A)
            l.hasOwnProperty(u) && delete l[u];
          return l.className = s, l.onClick = this.handleClick, Ff.createElement(e, l);
        }
      }]), a;
    }(Ff.Component), o = function() {
      var i = this;
      this.scrollTo = function(a, s) {
        n.scrollTo(a, w0({}, i.state, s));
      }, this.handleClick = function(a) {
        i.props.onClick && i.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), i.scrollTo(i.props.to, i.props);
      }, this.stateHandler = function() {
        n.getActiveLink() !== i.props.to && (i.state !== null && i.state.active && i.props.onSetInactive && i.props.onSetInactive(), i.setState({ active: !1 }));
      }, this.spyHandler = function(a) {
        var s = i.getScrollSpyContainer();
        if (!(Rs.isMounted() && !Rs.isInitialized())) {
          var l = i.props.to, u = null, c = 0, p = 0, d = 0;
          if (s.getBoundingClientRect) {
            var h = s.getBoundingClientRect();
            d = h.top;
          }
          if (!u || i.props.isDynamic) {
            if (u = n.get(l), !u)
              return;
            var f = u.getBoundingClientRect();
            c = f.top - d + a, p = c + f.height;
          }
          var m = a - i.props.offset, g = m >= Math.floor(c) && m < Math.floor(p), E = m < Math.floor(c) || m >= Math.floor(p), w = n.getActiveLink();
          if (E)
            return l === w && n.setActiveLink(void 0), i.props.hashSpy && Rs.getHash() === l && Rs.changeHash(), i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive()), Na.updateStates();
          if (g && w !== l)
            return n.setActiveLink(l), i.props.hashSpy && Rs.changeHash(l), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(l)), Na.updateStates();
        }
      };
    };
    return r.propTypes = $A, r.defaultProps = { offset: 0 }, r;
  },
  Element: function(e) {
    console.warn("Helpers.Element is deprecated since v1.7.0");
    var t = function(n) {
      UA(r, n);
      function r(o) {
        FA(this, r);
        var i = zA(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
        return i.childBindings = {
          domNode: null
        }, i;
      }
      return NA(r, [{
        key: "componentDidMount",
        value: function() {
          if (typeof window > "u")
            return !1;
          this.registerElems(this.props.name);
        }
      }, {
        key: "componentDidUpdate",
        value: function(o) {
          this.props.name !== o.name && this.registerElems(this.props.name);
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          if (typeof window > "u")
            return !1;
          C0.unregister(this.props.name);
        }
      }, {
        key: "registerElems",
        value: function(o) {
          C0.register(o, this.childBindings.domNode);
        }
      }, {
        key: "render",
        value: function() {
          return Ff.createElement(e, w0({}, this.props, { parentBindings: this.childBindings }));
        }
      }]), r;
    }(Ff.Component);
    return t.propTypes = {
      name: Mr.string,
      id: Mr.string
    }, t;
  }
}, Ame = jme;
Object.defineProperty(Ur, "__esModule", {
  value: !0
});
Ur.Helpers = Ur.ScrollElement = Ur.ScrollLink = Ur.animateScroll = Ur.scrollSpy = Ur.Events = Ur.scroller = Ur.Element = Ur.Button = Ur.Link = void 0;
var Bme = Ck, L9 = Yi(Bme), Ime = _k, _9 = Yi(Ime), Rme = Pk, P9 = Yi(Rme), Nme = xu, S9 = Yi(Nme), Fme = od, M9 = Yi(Fme), zme = td, D9 = Yi(zme), Ume = uy, T9 = Yi(Ume), $me = ed, j9 = Yi($me), Hme = hy, A9 = Yi(Hme), Wme = Ame, B9 = Yi(Wme);
function Yi(e) {
  return e && e.__esModule ? e : { default: e };
}
Ur.Link = L9.default;
Ur.Button = _9.default;
Ur.Element = P9.default;
Ur.scroller = S9.default;
Ur.Events = M9.default;
Ur.scrollSpy = D9.default;
Ur.animateScroll = T9.default;
Ur.ScrollLink = j9.default;
Ur.ScrollElement = A9.default;
Ur.Helpers = B9.default;
Ur.default = { Link: L9.default, Button: _9.default, Element: P9.default, scroller: S9.default, Events: M9.default, scrollSpy: D9.default, animateScroll: T9.default, ScrollLink: j9.default, ScrollElement: A9.default, Helpers: B9.default };
Ze({});
Ze({});
Ze({});
function Sp(e) {
  "@babel/helpers - typeof";
  return Sp = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Sp(e);
}
function Vme(e, t) {
  if (Sp(e) != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (Sp(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function qme(e) {
  var t = Vme(e, "string");
  return Sp(t) == "symbol" ? t : t + "";
}
function Ce(e, t, n) {
  return (t = qme(t)) in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function I9(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var x0, HA;
function Zme() {
  if (HA) return x0;
  HA = 1;
  var e = process.env.NODE_ENV, t = function(n, r, o, i, a, s, l, u) {
    if (e !== "production" && r === void 0)
      throw new Error("invariant requires an error message argument");
    if (!n) {
      var c;
      if (r === void 0)
        c = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
      else {
        var p = [o, i, a, s, l, u], d = 0;
        c = new Error(r.replace(/%s/g, function() {
          return p[d++];
        })), c.name = "Invariant Violation";
      }
      throw c.framesToPop = 1, c;
    }
  };
  return x0 = t, x0;
}
var Gme = Zme(), Gr = /* @__PURE__ */ I9(Gme), Mt = Ze(null);
function Xme() {
  Gr(!!ye, "useGoogleMap is React hook and requires React version 16.8+");
  var e = ye(Mt);
  return Gr(!!e, "useGoogleMap needs a GoogleMap available up in the tree"), e;
}
function Kme(e, t, n) {
  return Object.keys(e).reduce(function(r, o) {
    return t(r, e[o], o);
  }, n);
}
function Yme(e, t) {
  Object.keys(e).forEach((n) => t(e[n], n));
}
function Jme(e, t, n, r) {
  var o = {}, i = (a, s) => {
    var l = n[s];
    l !== t[s] && (o[s] = l, a(r, l));
  };
  return Yme(e, i), o;
}
function Qme(e, t, n) {
  var r = Kme(n, function(o, i, a) {
    return typeof e[a] == "function" && o.push(google.maps.event.addListener(t, i, e[a])), o;
  }, []);
  return r;
}
function eve(e) {
  google.maps.event.removeListener(e);
}
function an() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  e.forEach(eve);
}
function en(e) {
  var {
    updaterMap: t,
    eventMap: n,
    prevProps: r,
    nextProps: o,
    instance: i
  } = e, a = Qme(o, i, n);
  return Jme(t, r, o, i), a;
}
function tve(e) {
  var {
    children: t,
    options: n,
    id: r,
    mapContainerStyle: o,
    mapContainerClassName: i,
    center: a,
    // clickableIcons,
    // extraMapTypes,
    // heading,
    // mapTypeId,
    onClick: s,
    onDblClick: l,
    onDrag: u,
    onDragEnd: c,
    onDragStart: p,
    onMouseMove: d,
    onMouseOut: h,
    onMouseOver: f,
    onMouseDown: m,
    onMouseUp: g,
    onRightClick: E,
    // onMapTypeIdChanged,
    // onTilesLoaded,
    // onBoundsChanged,
    onCenterChanged: w,
    // onHeadingChanged,
    // onIdle,
    // onProjectionChanged,
    // onResize,
    // onTiltChanged,
    // onZoomChanged,
    onLoad: M,
    onUnmount: x
  } = e, [y, C] = k(null), P = rt(null), [F, L] = k(null), [N, I] = k(null), [H, V] = k(null), [z, q] = k(null), [K, J] = k(null), [te, ee] = k(null), [_, D] = k(null), [$, S] = k(null), [W, O] = k(null), [T, U] = k(null), [j, Z] = k(null), [A, Q] = k(null);
  return v(() => {
    n && y !== null && y.setOptions(n);
  }, [y, n]), v(() => {
    y !== null && typeof a < "u" && y.setCenter(a);
  }, [y, a]), v(() => {
    y && l && (N !== null && google.maps.event.removeListener(N), I(google.maps.event.addListener(y, "dblclick", l)));
  }, [l]), v(() => {
    y && c && (H !== null && google.maps.event.removeListener(H), V(google.maps.event.addListener(y, "dragend", c)));
  }, [c]), v(() => {
    y && p && (z !== null && google.maps.event.removeListener(z), q(google.maps.event.addListener(y, "dragstart", p)));
  }, [p]), v(() => {
    y && m && (K !== null && google.maps.event.removeListener(K), J(google.maps.event.addListener(y, "mousedown", m)));
  }, [m]), v(() => {
    y && d && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(y, "mousemove", d)));
  }, [d]), v(() => {
    y && h && (_ !== null && google.maps.event.removeListener(_), D(google.maps.event.addListener(y, "mouseout", h)));
  }, [h]), v(() => {
    y && f && ($ !== null && google.maps.event.removeListener($), S(google.maps.event.addListener(y, "mouseover", f)));
  }, [f]), v(() => {
    y && g && (W !== null && google.maps.event.removeListener(W), O(google.maps.event.addListener(y, "mouseup", g)));
  }, [g]), v(() => {
    y && E && (T !== null && google.maps.event.removeListener(T), U(google.maps.event.addListener(y, "rightclick", E)));
  }, [E]), v(() => {
    y && s && (j !== null && google.maps.event.removeListener(j), Z(google.maps.event.addListener(y, "click", s)));
  }, [s]), v(() => {
    y && u && (A !== null && google.maps.event.removeListener(A), Q(google.maps.event.addListener(y, "drag", u)));
  }, [u]), v(() => {
    y && w && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(y, "center_changed", w)));
  }, [s]), v(() => {
    var R = P.current === null ? null : new google.maps.Map(P.current, n);
    return C(R), R !== null && M && M(R), () => {
      R !== null && x && x(R);
    };
  }, []), ro.jsx("div", {
    id: r,
    ref: P,
    style: o,
    className: i,
    children: ro.jsx(Mt.Provider, {
      value: y,
      children: y !== null ? t : null
    })
  });
}
Ee(tve);
function WA(e, t, n, r, o, i, a) {
  try {
    var s = e[i](a), l = s.value;
  } catch (u) {
    return void n(u);
  }
  s.done ? t(l) : Promise.resolve(l).then(r, o);
}
function R9(e) {
  return function() {
    var t = this, n = arguments;
    return new Promise(function(r, o) {
      var i = e.apply(t, n);
      function a(l) {
        WA(i, r, o, a, s, "next", l);
      }
      function s(l) {
        WA(i, r, o, a, s, "throw", l);
      }
      a(void 0);
    });
  };
}
function N9(e) {
  var {
    googleMapsApiKey: t,
    googleMapsClientId: n,
    version: r = "weekly",
    language: o,
    region: i,
    libraries: a,
    channel: s,
    mapIds: l,
    authReferrerPolicy: u
  } = e, c = [];
  return Gr(t && n || !(t && n), "You need to specify either googleMapsApiKey or googleMapsClientId for @react-google-maps/api load script to work. You cannot use both at the same time."), t ? c.push("key=".concat(t)) : n && c.push("client=".concat(n)), r && c.push("v=".concat(r)), o && c.push("language=".concat(o)), i && c.push("region=".concat(i)), a && a.length && c.push("libraries=".concat(a.sort().join(","))), s && c.push("channel=".concat(s)), l && l.length && c.push("map_ids=".concat(l.join(","))), u && c.push("auth_referrer_policy=".concat(u)), c.push("loading=async"), c.push("callback=initMap"), "https://maps.googleapis.com/maps/api/js?".concat(c.join("&"));
}
var ll = typeof document < "u";
function F9(e) {
  var {
    url: t,
    id: n,
    nonce: r
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } = e;
  return ll ? new Promise(function(o, i) {
    var a = document.getElementById(n), s = window;
    if (a) {
      var l = a.getAttribute("data-state");
      if (a.src === t && l !== "error") {
        if (l === "ready")
          return o(n);
        var u = s.initMap, c = a.onerror;
        s.initMap = function() {
          u && u(), o(n);
        }, a.onerror = function(d) {
          c && c(d), i(d);
        };
        return;
      } else
        a.remove();
    }
    var p = document.createElement("script");
    p.type = "text/javascript", p.src = t, p.id = n, p.async = !0, p.nonce = r || "", p.onerror = function(d) {
      p.setAttribute("data-state", "error"), i(d);
    }, s.initMap = function() {
      p.setAttribute("data-state", "ready"), o(n);
    }, document.head.appendChild(p);
  }).catch((o) => {
    throw console.error("injectScript error: ", o), o;
  }) : Promise.reject(new Error("document is undefined"));
}
function VA(e) {
  var t = e.href;
  return t && (t.indexOf("https://fonts.googleapis.com/css?family=Roboto") === 0 || t.indexOf("https://fonts.googleapis.com/css?family=Google+Sans+Text") === 0) ? !0 : (
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.styleSheet.cssText = "", !0) : (
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.innerHTML = "", !0) : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.innerHTML
      )
    )
  );
}
function z9() {
  var e = document.getElementsByTagName("head")[0];
  if (e) {
    var t = e.insertBefore.bind(e);
    e.insertBefore = function(r, o) {
      return VA(r) || Reflect.apply(t, e, [r, o]), r;
    };
    var n = e.appendChild.bind(e);
    e.appendChild = function(r) {
      return VA(r) || Reflect.apply(n, e, [r]), r;
    };
  }
}
var Xu = !1;
function U9() {
  return ro.jsx("div", {
    children: "Loading..."
  });
}
var dx = {
  id: "script-loader",
  version: "weekly"
};
class nve extends pe {
  constructor() {
    super(...arguments), Ce(this, "check", null), Ce(this, "state", {
      loaded: !1
    }), Ce(this, "cleanupCallback", () => {
      delete window.google.maps, this.injectScript();
    }), Ce(this, "isCleaningUp", /* @__PURE__ */ R9(function* () {
      function t(n) {
        if (!Xu)
          n();
        else if (ll)
          var r = window.setInterval(function() {
            Xu || (window.clearInterval(r), n());
          }, 1);
      }
      return new Promise(t);
    })), Ce(this, "cleanup", () => {
      Xu = !0;
      var t = document.getElementById(this.props.id);
      t && t.parentNode && t.parentNode.removeChild(t), Array.prototype.slice.call(document.getElementsByTagName("script")).filter(function(n) {
        return typeof n.src == "string" && n.src.includes("maps.googleapis");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("link")).filter(function(n) {
        return n.href === "https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Google+Sans";
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("style")).filter(function(n) {
        return n.innerText !== void 0 && n.innerText.length > 0 && n.innerText.includes(".gm-");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      });
    }), Ce(this, "injectScript", () => {
      this.props.preventGoogleFontsLoading && z9(), Gr(!!this.props.id, 'LoadScript requires "id" prop to be a string: %s', this.props.id);
      var t = {
        id: this.props.id,
        nonce: this.props.nonce,
        url: N9(this.props)
      };
      F9(t).then(() => {
        this.props.onLoad && this.props.onLoad(), this.setState(function() {
          return {
            loaded: !0
          };
        });
      }).catch((n) => {
        this.props.onError && this.props.onError(n), console.error(`
          There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(this.props.googleMapsApiKey || "-", ") or Client ID (").concat(this.props.googleMapsClientId || "-", `) to <LoadScript />
          Otherwise it is a Network issue.
        `));
      });
    }), Ce(this, "getRef", (t) => {
      this.check = t;
    });
  }
  componentDidMount() {
    if (ll) {
      if (window.google && window.google.maps && !Xu) {
        console.error("google api is already presented");
        return;
      }
      this.isCleaningUp().then(this.injectScript).catch(function(t) {
        console.error("Error at injecting script after cleaning up: ", t);
      });
    }
  }
  componentDidUpdate(t) {
    this.props.libraries !== t.libraries && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), ll && t.language !== this.props.language && (this.cleanup(), this.setState(function() {
      return {
        loaded: !1
      };
    }, this.cleanupCallback));
  }
  componentWillUnmount() {
    if (ll) {
      this.cleanup();
      var t = () => {
        this.check || (delete window.google, Xu = !1);
      };
      window.setTimeout(t, 1), this.props.onUnmount && this.props.onUnmount();
    }
  }
  render() {
    return ro.jsxs(ro.Fragment, {
      children: [ro.jsx("div", {
        ref: this.getRef
      }), this.state.loaded ? this.props.children : this.props.loadingElement || ro.jsx(U9, {})]
    });
  }
}
Ce(nve, "defaultProps", dx);
function rve(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.includes(r)) continue;
    n[r] = e[r];
  }
  return n;
}
function Mk(e, t) {
  if (e == null) return {};
  var n, r, o = rve(e, t);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (r = 0; r < i.length; r++) n = i[r], t.includes(n) || {}.propertyIsEnumerable.call(e, n) && (o[n] = e[n]);
  }
  return o;
}
var qA;
function ove(e) {
  var {
    id: t = dx.id,
    version: n = dx.version,
    nonce: r,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    preventGoogleFontsLoading: u,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  } = e, h = rt(!1), [f, m] = k(!1), [g, E] = k(void 0);
  v(function() {
    return h.current = !0, () => {
      h.current = !1;
    };
  }, []), v(function() {
    ll && u && z9();
  }, [u]), v(function() {
    f && Gr(!!window.google, "useLoadScript was marked as loaded, but window.google is not present. Something went wrong.");
  }, [f]);
  var w = N9({
    version: n,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  });
  v(function() {
    if (!ll)
      return;
    function x() {
      h.current && (m(!0), qA = w);
    }
    if (window.google && window.google.maps && qA === w) {
      x();
      return;
    }
    F9({
      id: t,
      url: w,
      nonce: r
    }).then(x).catch(function(y) {
      h.current && E(y), console.warn(`
        There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(o || "-", ") or Client ID (").concat(i || "-", `)
        Otherwise it is a Network issue.
      `)), console.error(y);
    });
  }, [t, w, r]);
  var M = rt(void 0);
  return v(function() {
    M.current && l !== M.current && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), M.current = l;
  }, [l]), {
    isLoaded: f,
    loadError: g,
    url: w
  };
}
var ive = ["loadingElement", "onLoad", "onError", "onUnmount", "children"], sve = ro.jsx(U9, {});
function ave(e) {
  var {
    loadingElement: t,
    onLoad: n,
    onError: r,
    onUnmount: o,
    children: i
  } = e, a = Mk(e, ive), {
    isLoaded: s,
    loadError: l
  } = ove(a);
  return v(function() {
    s && typeof n == "function" && n();
  }, [s, n]), v(function() {
    l && typeof r == "function" && r(l);
  }, [l, r]), v(function() {
    return () => {
      o && o();
    };
  }, [o]), s ? i : t || sve;
}
Ee(ave);
var ZA;
(function(e) {
  e[e.INITIALIZED = 0] = "INITIALIZED", e[e.LOADING = 1] = "LOADING", e[e.SUCCESS = 2] = "SUCCESS", e[e.FAILURE = 3] = "FAILURE";
})(ZA || (ZA = {}));
function GA(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Ug(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? GA(Object(n), !0).forEach(function(r) {
      Ce(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : GA(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var XA = {}, KA = {
  options(e, t) {
    e.setOptions(t);
  }
};
function lve(e) {
  var {
    options: t,
    onLoad: n,
    onUnmount: r
  } = e, o = ye(Mt), [i, a] = k(null);
  return v(() => {
    i !== null && i.setMap(o);
  }, [o]), v(() => {
    t && i !== null && i.setOptions(t);
  }, [i, t]), v(() => {
    var s = new google.maps.TrafficLayer(Ug(Ug({}, t), {}, {
      map: o
    }));
    return a(s), n && n(s), () => {
      i !== null && (r && r(i), i.setMap(null));
    };
  }, []), null;
}
Ee(lve);
class uve extends pe {
  constructor() {
    super(...arguments), Ce(this, "state", {
      trafficLayer: null
    }), Ce(this, "setTrafficLayerCallback", () => {
      this.state.trafficLayer !== null && this.props.onLoad && this.props.onLoad(this.state.trafficLayer);
    }), Ce(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = new google.maps.TrafficLayer(Ug(Ug({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = en({
      updaterMap: KA,
      eventMap: XA,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        trafficLayer: t
      };
    }, this.setTrafficLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.trafficLayer !== null && (an(this.registeredEvents), this.registeredEvents = en({
      updaterMap: KA,
      eventMap: XA,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.trafficLayer
    }));
  }
  componentWillUnmount() {
    this.state.trafficLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.trafficLayer), an(this.registeredEvents), this.state.trafficLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Ce(uve, "contextType", Mt);
function cve(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = ye(Mt), [o, i] = k(null);
  return v(() => {
    o !== null && o.setMap(r);
  }, [r]), v(() => {
    var a = new google.maps.BicyclingLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      a !== null && (n && n(a), a.setMap(null));
    };
  }, []), null;
}
Ee(cve);
class pve extends pe {
  constructor() {
    super(...arguments), Ce(this, "state", {
      bicyclingLayer: null
    }), Ce(this, "setBicyclingLayerCallback", () => {
      this.state.bicyclingLayer !== null && (this.state.bicyclingLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.bicyclingLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.BicyclingLayer();
    this.setState(() => ({
      bicyclingLayer: t
    }), this.setBicyclingLayerCallback);
  }
  componentWillUnmount() {
    this.state.bicyclingLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.bicyclingLayer), this.state.bicyclingLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Ce(pve, "contextType", Mt);
function dve(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = ye(Mt), [o, i] = k(null);
  return v(() => {
    o !== null && o.setMap(r);
  }, [r]), v(() => {
    var a = new google.maps.TransitLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      o !== null && (n && n(o), o.setMap(null));
    };
  }, []), null;
}
Ee(dve);
class fve extends pe {
  constructor() {
    super(...arguments), Ce(this, "state", {
      transitLayer: null
    }), Ce(this, "setTransitLayerCallback", () => {
      this.state.transitLayer !== null && (this.state.transitLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.transitLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.TransitLayer();
    this.setState(function() {
      return {
        transitLayer: t
      };
    }, this.setTransitLayerCallback);
  }
  componentWillUnmount() {
    this.state.transitLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.transitLayer), this.state.transitLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Ce(fve, "contextType", Mt);
function YA(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function $g(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? YA(Object(n), !0).forEach(function(r) {
      Ce(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : YA(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var JA = {
  onCircleComplete: "circlecomplete",
  onMarkerComplete: "markercomplete",
  onOverlayComplete: "overlaycomplete",
  onPolygonComplete: "polygoncomplete",
  onPolylineComplete: "polylinecomplete",
  onRectangleComplete: "rectanglecomplete"
}, QA = {
  drawingMode(e, t) {
    e.setDrawingMode(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function hve(e) {
  var {
    options: t,
    drawingMode: n,
    onCircleComplete: r,
    onMarkerComplete: o,
    onOverlayComplete: i,
    onPolygonComplete: a,
    onPolylineComplete: s,
    onRectangleComplete: l,
    onLoad: u,
    onUnmount: c
  } = e, p = ye(Mt), [d, h] = k(null), [f, m] = k(null), [g, E] = k(null), [w, M] = k(null), [x, y] = k(null), [C, P] = k(null), [F, L] = k(null);
  return v(() => {
    d !== null && d.setMap(p);
  }, [p]), v(() => {
    t && d !== null && d.setOptions(t);
  }, [d, t]), v(() => {
    d !== null && d.setDrawingMode(n ?? null);
  }, [d, n]), v(() => {
    d && r && (f !== null && google.maps.event.removeListener(f), m(google.maps.event.addListener(d, "circlecomplete", r)));
  }, [d, r]), v(() => {
    d && o && (g !== null && google.maps.event.removeListener(g), E(google.maps.event.addListener(d, "markercomplete", o)));
  }, [d, o]), v(() => {
    d && i && (w !== null && google.maps.event.removeListener(w), M(google.maps.event.addListener(d, "overlaycomplete", i)));
  }, [d, i]), v(() => {
    d && a && (x !== null && google.maps.event.removeListener(x), y(google.maps.event.addListener(d, "polygoncomplete", a)));
  }, [d, a]), v(() => {
    d && s && (C !== null && google.maps.event.removeListener(C), P(google.maps.event.addListener(d, "polylinecomplete", s)));
  }, [d, s]), v(() => {
    d && l && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(d, "rectanglecomplete", l)));
  }, [d, l]), v(() => {
    Gr(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
    var N = new google.maps.drawing.DrawingManager($g($g({}, t), {}, {
      map: p
    }));
    return n && N.setDrawingMode(n), r && m(google.maps.event.addListener(N, "circlecomplete", r)), o && E(google.maps.event.addListener(N, "markercomplete", o)), i && M(google.maps.event.addListener(N, "overlaycomplete", i)), a && y(google.maps.event.addListener(N, "polygoncomplete", a)), s && P(google.maps.event.addListener(N, "polylinecomplete", s)), l && L(google.maps.event.addListener(N, "rectanglecomplete", l)), h(N), u && u(N), () => {
      d !== null && (f && google.maps.event.removeListener(f), g && google.maps.event.removeListener(g), w && google.maps.event.removeListener(w), x && google.maps.event.removeListener(x), C && google.maps.event.removeListener(C), F && google.maps.event.removeListener(F), c && c(d), d.setMap(null));
    };
  }, []), null;
}
Ee(hve);
class gve extends pe {
  constructor(t) {
    super(t), Ce(this, "registeredEvents", []), Ce(this, "state", {
      drawingManager: null
    }), Ce(this, "setDrawingManagerCallback", () => {
      this.state.drawingManager !== null && this.props.onLoad && this.props.onLoad(this.state.drawingManager);
    }), Gr(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
  }
  componentDidMount() {
    var t = new google.maps.drawing.DrawingManager($g($g({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = en({
      updaterMap: QA,
      eventMap: JA,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        drawingManager: t
      };
    }, this.setDrawingManagerCallback);
  }
  componentDidUpdate(t) {
    this.state.drawingManager !== null && (an(this.registeredEvents), this.registeredEvents = en({
      updaterMap: QA,
      eventMap: JA,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.drawingManager
    }));
  }
  componentWillUnmount() {
    this.state.drawingManager !== null && (this.props.onUnmount && this.props.onUnmount(this.state.drawingManager), an(this.registeredEvents), this.state.drawingManager.setMap(null));
  }
  render() {
    return null;
  }
}
Ce(gve, "contextType", Mt);
function eB(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Yl(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? eB(Object(n), !0).forEach(function(r) {
      Ce(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : eB(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var tB = {
  onAnimationChanged: "animation_changed",
  onClick: "click",
  onClickableChanged: "clickable_changed",
  onCursorChanged: "cursor_changed",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDraggableChanged: "draggable_changed",
  onDragStart: "dragstart",
  onFlatChanged: "flat_changed",
  onIconChanged: "icon_changed",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onPositionChanged: "position_changed",
  onRightClick: "rightclick",
  onShapeChanged: "shape_changed",
  onTitleChanged: "title_changed",
  onVisibleChanged: "visible_changed",
  onZindexChanged: "zindex_changed"
}, nB = {
  animation(e, t) {
    e.setAnimation(t);
  },
  clickable(e, t) {
    e.setClickable(t);
  },
  cursor(e, t) {
    e.setCursor(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  icon(e, t) {
    e.setIcon(t);
  },
  label(e, t) {
    e.setLabel(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  opacity(e, t) {
    e.setOpacity(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  shape(e, t) {
    e.setShape(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, Hg = {};
function mve(e) {
  var {
    position: t,
    options: n,
    clusterer: r,
    noClustererRedraw: o,
    children: i,
    draggable: a,
    visible: s,
    animation: l,
    clickable: u,
    cursor: c,
    icon: p,
    label: d,
    opacity: h,
    shape: f,
    title: m,
    zIndex: g,
    onClick: E,
    onDblClick: w,
    onDrag: M,
    onDragEnd: x,
    onDragStart: y,
    onMouseOut: C,
    onMouseOver: P,
    onMouseUp: F,
    onMouseDown: L,
    onRightClick: N,
    onClickableChanged: I,
    onCursorChanged: H,
    onAnimationChanged: V,
    onDraggableChanged: z,
    onFlatChanged: q,
    onIconChanged: K,
    onPositionChanged: J,
    onShapeChanged: te,
    onTitleChanged: ee,
    onVisibleChanged: _,
    onZindexChanged: D,
    onLoad: $,
    onUnmount: S
  } = e, W = ye(Mt), [O, T] = k(null), [U, j] = k(null), [Z, A] = k(null), [Q, R] = k(null), [ue, fe] = k(null), [oe, Re] = k(null), [He, Ve] = k(null), [ze, et] = k(null), [Ge, Pe] = k(null), [Ye, it] = k(null), [_e, Se] = k(null), [Ke, We] = k(null), [Ue, nt] = k(null), [Ie, xt] = k(null), [ot, st] = k(null), [lt, Ot] = k(null), [ut, ct] = k(null), [tt, Xe] = k(null), [Et, kt] = k(null), [pt, kn] = k(null), [dt, Ln] = k(null), [ft, rn] = k(null);
  v(() => {
    O !== null && O.setMap(W);
  }, [W]), v(() => {
    typeof n < "u" && O !== null && O.setOptions(n);
  }, [O, n]), v(() => {
    typeof a < "u" && O !== null && O.setDraggable(a);
  }, [O, a]), v(() => {
    t && O !== null && O.setPosition(t);
  }, [O, t]), v(() => {
    typeof s < "u" && O !== null && O.setVisible(s);
  }, [O, s]), v(() => {
    O == null || O.setAnimation(l);
  }, [O, l]), v(() => {
    O && u !== void 0 && O.setClickable(u);
  }, [O, u]), v(() => {
    O && c !== void 0 && O.setCursor(c);
  }, [O, c]), v(() => {
    O && p !== void 0 && O.setIcon(p);
  }, [O, p]), v(() => {
    O && d !== void 0 && O.setLabel(d);
  }, [O, d]), v(() => {
    O && h !== void 0 && O.setOpacity(h);
  }, [O, h]), v(() => {
    O && f !== void 0 && O.setShape(f);
  }, [O, f]), v(() => {
    O && m !== void 0 && O.setTitle(m);
  }, [O, m]), v(() => {
    O && g !== void 0 && O.setZIndex(g);
  }, [O, g]), v(() => {
    O && w && (U !== null && google.maps.event.removeListener(U), j(google.maps.event.addListener(O, "dblclick", w)));
  }, [w]), v(() => {
    O && x && (Z !== null && google.maps.event.removeListener(Z), A(google.maps.event.addListener(O, "dragend", x)));
  }, [x]), v(() => {
    O && y && (Q !== null && google.maps.event.removeListener(Q), R(google.maps.event.addListener(O, "dragstart", y)));
  }, [y]), v(() => {
    O && L && (ue !== null && google.maps.event.removeListener(ue), fe(google.maps.event.addListener(O, "mousedown", L)));
  }, [L]), v(() => {
    O && C && (oe !== null && google.maps.event.removeListener(oe), Re(google.maps.event.addListener(O, "mouseout", C)));
  }, [C]), v(() => {
    O && P && (He !== null && google.maps.event.removeListener(He), Ve(google.maps.event.addListener(O, "mouseover", P)));
  }, [P]), v(() => {
    O && F && (ze !== null && google.maps.event.removeListener(ze), et(google.maps.event.addListener(O, "mouseup", F)));
  }, [F]), v(() => {
    O && N && (Ge !== null && google.maps.event.removeListener(Ge), Pe(google.maps.event.addListener(O, "rightclick", N)));
  }, [N]), v(() => {
    O && E && (Ye !== null && google.maps.event.removeListener(Ye), it(google.maps.event.addListener(O, "click", E)));
  }, [E]), v(() => {
    O && M && (_e !== null && google.maps.event.removeListener(_e), Se(google.maps.event.addListener(O, "drag", M)));
  }, [M]), v(() => {
    O && I && (Ke !== null && google.maps.event.removeListener(Ke), We(google.maps.event.addListener(O, "clickable_changed", I)));
  }, [I]), v(() => {
    O && H && (Ue !== null && google.maps.event.removeListener(Ue), nt(google.maps.event.addListener(O, "cursor_changed", H)));
  }, [H]), v(() => {
    O && V && (Ie !== null && google.maps.event.removeListener(Ie), xt(google.maps.event.addListener(O, "animation_changed", V)));
  }, [V]), v(() => {
    O && z && (ot !== null && google.maps.event.removeListener(ot), st(google.maps.event.addListener(O, "draggable_changed", z)));
  }, [z]), v(() => {
    O && q && (lt !== null && google.maps.event.removeListener(lt), Ot(google.maps.event.addListener(O, "flat_changed", q)));
  }, [q]), v(() => {
    O && K && (ut !== null && google.maps.event.removeListener(ut), ct(google.maps.event.addListener(O, "icon_changed", K)));
  }, [K]), v(() => {
    O && J && (tt !== null && google.maps.event.removeListener(tt), Xe(google.maps.event.addListener(O, "position_changed", J)));
  }, [J]), v(() => {
    O && te && (Et !== null && google.maps.event.removeListener(Et), kt(google.maps.event.addListener(O, "shape_changed", te)));
  }, [te]), v(() => {
    O && ee && (pt !== null && google.maps.event.removeListener(pt), kn(google.maps.event.addListener(O, "title_changed", ee)));
  }, [ee]), v(() => {
    O && _ && (dt !== null && google.maps.event.removeListener(dt), Ln(google.maps.event.addListener(O, "visible_changed", _)));
  }, [_]), v(() => {
    O && D && (ft !== null && google.maps.event.removeListener(ft), rn(google.maps.event.addListener(O, "zindex_changed", D)));
  }, [D]), v(() => {
    var ht = Yl(Yl(Yl({}, n || Hg), r ? Hg : {
      map: W
    }), {}, {
      position: t
    }), re = new google.maps.Marker(ht);
    return r ? r.addMarker(re, !!o) : re.setMap(W), t && re.setPosition(t), typeof s < "u" && re.setVisible(s), typeof a < "u" && re.setDraggable(a), typeof u < "u" && re.setClickable(u), typeof c == "string" && re.setCursor(c), p && re.setIcon(p), typeof d < "u" && re.setLabel(d), typeof h < "u" && re.setOpacity(h), f && re.setShape(f), typeof m == "string" && re.setTitle(m), typeof g == "number" && re.setZIndex(g), w && j(google.maps.event.addListener(re, "dblclick", w)), x && A(google.maps.event.addListener(re, "dragend", x)), y && R(google.maps.event.addListener(re, "dragstart", y)), L && fe(google.maps.event.addListener(re, "mousedown", L)), C && Re(google.maps.event.addListener(re, "mouseout", C)), P && Ve(google.maps.event.addListener(re, "mouseover", P)), F && et(google.maps.event.addListener(re, "mouseup", F)), N && Pe(google.maps.event.addListener(re, "rightclick", N)), E && it(google.maps.event.addListener(re, "click", E)), M && Se(google.maps.event.addListener(re, "drag", M)), I && We(google.maps.event.addListener(re, "clickable_changed", I)), H && nt(google.maps.event.addListener(re, "cursor_changed", H)), V && xt(google.maps.event.addListener(re, "animation_changed", V)), z && st(google.maps.event.addListener(re, "draggable_changed", z)), q && Ot(google.maps.event.addListener(re, "flat_changed", q)), K && ct(google.maps.event.addListener(re, "icon_changed", K)), J && Xe(google.maps.event.addListener(re, "position_changed", J)), te && kt(google.maps.event.addListener(re, "shape_changed", te)), ee && kn(google.maps.event.addListener(re, "title_changed", ee)), _ && Ln(google.maps.event.addListener(re, "visible_changed", _)), D && rn(google.maps.event.addListener(re, "zindex_changed", D)), T(re), $ && $(re), () => {
      U !== null && google.maps.event.removeListener(U), Z !== null && google.maps.event.removeListener(Z), Q !== null && google.maps.event.removeListener(Q), ue !== null && google.maps.event.removeListener(ue), oe !== null && google.maps.event.removeListener(oe), He !== null && google.maps.event.removeListener(He), ze !== null && google.maps.event.removeListener(ze), Ge !== null && google.maps.event.removeListener(Ge), Ye !== null && google.maps.event.removeListener(Ye), Ke !== null && google.maps.event.removeListener(Ke), Ue !== null && google.maps.event.removeListener(Ue), Ie !== null && google.maps.event.removeListener(Ie), ot !== null && google.maps.event.removeListener(ot), lt !== null && google.maps.event.removeListener(lt), ut !== null && google.maps.event.removeListener(ut), tt !== null && google.maps.event.removeListener(tt), pt !== null && google.maps.event.removeListener(pt), dt !== null && google.maps.event.removeListener(dt), ft !== null && google.maps.event.removeListener(ft), S && S(re), r ? r.removeMarker(re, !!o) : re && re.setMap(null);
    };
  }, []);
  var br = Tn(() => i ? at.map(i, (ht) => {
    if (!bi(ht))
      return ht;
    var re = ht;
    return wi(re, {
      anchor: O
    });
  }) : null, [i, O]);
  return ro.jsx(ro.Fragment, {
    children: br
  }) || null;
}
Ee(mve);
class vve extends pe {
  constructor() {
    super(...arguments), Ce(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this;
    return R9(function* () {
      var n = Yl(Yl(Yl({}, t.props.options || Hg), t.props.clusterer ? Hg : {
        map: t.context
      }), {}, {
        position: t.props.position
      });
      t.marker = new google.maps.Marker(n), t.props.clusterer ? t.props.clusterer.addMarker(t.marker, !!t.props.noClustererRedraw) : t.marker.setMap(t.context), t.registeredEvents = en({
        updaterMap: nB,
        eventMap: tB,
        prevProps: {},
        nextProps: t.props,
        instance: t.marker
      }), t.props.onLoad && t.props.onLoad(t.marker);
    })();
  }
  componentDidUpdate(t) {
    this.marker && (an(this.registeredEvents), this.registeredEvents = en({
      updaterMap: nB,
      eventMap: tB,
      prevProps: t,
      nextProps: this.props,
      instance: this.marker
    }));
  }
  componentWillUnmount() {
    this.marker && (this.props.onUnmount && this.props.onUnmount(this.marker), an(this.registeredEvents), this.props.clusterer ? this.props.clusterer.removeMarker(this.marker, !!this.props.noClustererRedraw) : this.marker && this.marker.setMap(null));
  }
  render() {
    var t = this.props.children ? at.map(this.props.children, (n) => {
      if (!bi(n))
        return n;
      var r = n;
      return wi(r, {
        anchor: this.marker
      });
    }) : null;
    return t || null;
  }
}
Ce(vve, "contextType", Mt);
var yve = (
  /** @class */
  function() {
    function e(t, n) {
      t.getClusterer().extend(e, google.maps.OverlayView), this.cluster = t, this.clusterClassName = this.cluster.getClusterer().getClusterClass(), this.className = this.clusterClassName, this.styles = n, this.center = void 0, this.div = null, this.sums = null, this.visible = !1, this.boundsChangedListener = null, this.url = "", this.height = 0, this.width = 0, this.anchorText = [0, 0], this.anchorIcon = [0, 0], this.textColor = "black", this.textSize = 11, this.textDecoration = "none", this.fontWeight = "bold", this.fontStyle = "normal", this.fontFamily = "Arial,sans-serif", this.backgroundPosition = "0 0", this.cMouseDownInCluster = null, this.cDraggingMapByCluster = null, this.timeOut = null, this.setMap(t.getMap()), this.onBoundsChanged = this.onBoundsChanged.bind(this), this.onMouseDown = this.onMouseDown.bind(this), this.onClick = this.onClick.bind(this), this.onMouseOver = this.onMouseOver.bind(this), this.onMouseOut = this.onMouseOut.bind(this), this.onAdd = this.onAdd.bind(this), this.onRemove = this.onRemove.bind(this), this.draw = this.draw.bind(this), this.hide = this.hide.bind(this), this.show = this.show.bind(this), this.useStyle = this.useStyle.bind(this), this.setCenter = this.setCenter.bind(this), this.getPosFromLatLng = this.getPosFromLatLng.bind(this);
    }
    return e.prototype.onBoundsChanged = function() {
      this.cDraggingMapByCluster = this.cMouseDownInCluster;
    }, e.prototype.onMouseDown = function() {
      this.cMouseDownInCluster = !0, this.cDraggingMapByCluster = !1;
    }, e.prototype.onClick = function(t) {
      if (this.cMouseDownInCluster = !1, !this.cDraggingMapByCluster) {
        var n = this.cluster.getClusterer();
        if (google.maps.event.trigger(n, "click", this.cluster), google.maps.event.trigger(n, "clusterclick", this.cluster), n.getZoomOnClick()) {
          var r = n.getMaxZoom(), o = this.cluster.getBounds(), i = n.getMap();
          i !== null && "fitBounds" in i && i.fitBounds(o), this.timeOut = window.setTimeout(function() {
            var a = n.getMap();
            if (a !== null) {
              "fitBounds" in a && a.fitBounds(o);
              var s = a.getZoom() || 0;
              r !== null && s > r && a.setZoom(r + 1);
            }
          }, 100);
        }
        t.cancelBubble = !0, t.stopPropagation && t.stopPropagation();
      }
    }, e.prototype.onMouseOver = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseover", this.cluster);
    }, e.prototype.onMouseOut = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseout", this.cluster);
    }, e.prototype.onAdd = function() {
      var t;
      this.div = document.createElement("div"), this.div.className = this.className, this.visible && this.show(), (t = this.getPanes()) === null || t === void 0 || t.overlayMouseTarget.appendChild(this.div);
      var n = this.getMap();
      n !== null && (this.boundsChangedListener = google.maps.event.addListener(n, "bounds_changed", this.onBoundsChanged), this.div.addEventListener("mousedown", this.onMouseDown), this.div.addEventListener("click", this.onClick), this.div.addEventListener("mouseover", this.onMouseOver), this.div.addEventListener("mouseout", this.onMouseOut));
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.hide(), this.boundsChangedListener !== null && google.maps.event.removeListener(this.boundsChangedListener), this.div.removeEventListener("mousedown", this.onMouseDown), this.div.removeEventListener("click", this.onClick), this.div.removeEventListener("mouseover", this.onMouseOver), this.div.removeEventListener("mouseout", this.onMouseOut), this.div.parentNode.removeChild(this.div), this.timeOut !== null && (window.clearTimeout(this.timeOut), this.timeOut = null), this.div = null);
    }, e.prototype.draw = function() {
      if (this.visible && this.div !== null && this.center) {
        var t = this.getPosFromLatLng(this.center);
        this.div.style.top = t !== null ? "".concat(t.y, "px") : "0", this.div.style.left = t !== null ? "".concat(t.x, "px") : "0";
      }
    }, e.prototype.hide = function() {
      this.div && (this.div.style.display = "none"), this.visible = !1;
    }, e.prototype.show = function() {
      var t, n, r, o, i, a;
      if (this.div && this.center) {
        var s = this.sums === null || typeof this.sums.title > "u" || this.sums.title === "" ? this.cluster.getClusterer().getTitle() : this.sums.title, l = this.backgroundPosition.split(" "), u = parseInt(((t = l[0]) === null || t === void 0 ? void 0 : t.replace(/^\s+|\s+$/g, "")) || "0", 10), c = parseInt(((n = l[1]) === null || n === void 0 ? void 0 : n.replace(/^\s+|\s+$/g, "")) || "0", 10), p = this.getPosFromLatLng(this.center);
        this.div.className = this.className, this.div.setAttribute("style", "cursor: pointer; position: absolute; top: ".concat(p !== null ? "".concat(p.y, "px") : "0", "; left: ").concat(p !== null ? "".concat(p.x, "px") : "0", "; width: ").concat(this.width, "px; height: ").concat(this.height, "px; "));
        var d = document.createElement("img");
        d.alt = s, d.src = this.url, d.width = this.width, d.height = this.height, d.setAttribute("style", "position: absolute; top: ".concat(c, "px; left: ").concat(u, "px")), this.cluster.getClusterer().enableRetinaIcons || (d.style.clip = "rect(-".concat(c, "px, -").concat(u + this.width, "px, -").concat(c + this.height, ", -").concat(u, ")"));
        var h = document.createElement("div");
        h.setAttribute("style", "position: absolute; top: ".concat(this.anchorText[0], "px; left: ").concat(this.anchorText[1], "px; color: ").concat(this.textColor, "; font-size: ").concat(this.textSize, "px; font-family: ").concat(this.fontFamily, "; font-weight: ").concat(this.fontWeight, "; fontStyle: ").concat(this.fontStyle, "; text-decoration: ").concat(this.textDecoration, "; text-align: center; width: ").concat(this.width, "px; line-height: ").concat(this.height, "px")), !((r = this.sums) === null || r === void 0) && r.text && (h.innerText = "".concat((o = this.sums) === null || o === void 0 ? void 0 : o.text)), !((i = this.sums) === null || i === void 0) && i.html && (h.innerHTML = "".concat((a = this.sums) === null || a === void 0 ? void 0 : a.html)), this.div.innerHTML = "", this.div.appendChild(d), this.div.appendChild(h), this.div.title = s, this.div.style.display = "";
      }
      this.visible = !0;
    }, e.prototype.useStyle = function(t) {
      this.sums = t;
      var n = this.cluster.getClusterer().getStyles(), r = n[Math.min(n.length - 1, Math.max(0, t.index - 1))];
      r && (this.url = r.url, this.height = r.height, this.width = r.width, r.className && (this.className = "".concat(this.clusterClassName, " ").concat(r.className)), this.anchorText = r.anchorText || [0, 0], this.anchorIcon = r.anchorIcon || [this.height / 2, this.width / 2], this.textColor = r.textColor || "black", this.textSize = r.textSize || 11, this.textDecoration = r.textDecoration || "none", this.fontWeight = r.fontWeight || "bold", this.fontStyle = r.fontStyle || "normal", this.fontFamily = r.fontFamily || "Arial,sans-serif", this.backgroundPosition = r.backgroundPosition || "0 0");
    }, e.prototype.setCenter = function(t) {
      this.center = t;
    }, e.prototype.getPosFromLatLng = function(t) {
      var n = this.getProjection().fromLatLngToDivPixel(t);
      return n !== null && (n.x -= this.anchorIcon[1], n.y -= this.anchorIcon[0]), n;
    }, e;
  }()
), bve = (
  /** @class */
  function() {
    function e(t) {
      this.markerClusterer = t, this.map = this.markerClusterer.getMap(), this.gridSize = this.markerClusterer.getGridSize(), this.minClusterSize = this.markerClusterer.getMinimumClusterSize(), this.averageCenter = this.markerClusterer.getAverageCenter(), this.markers = [], this.center = void 0, this.bounds = null, this.clusterIcon = new yve(this, this.markerClusterer.getStyles()), this.getSize = this.getSize.bind(this), this.getMarkers = this.getMarkers.bind(this), this.getCenter = this.getCenter.bind(this), this.getMap = this.getMap.bind(this), this.getClusterer = this.getClusterer.bind(this), this.getBounds = this.getBounds.bind(this), this.remove = this.remove.bind(this), this.addMarker = this.addMarker.bind(this), this.isMarkerInClusterBounds = this.isMarkerInClusterBounds.bind(this), this.calculateBounds = this.calculateBounds.bind(this), this.updateIcon = this.updateIcon.bind(this), this.isMarkerAlreadyAdded = this.isMarkerAlreadyAdded.bind(this);
    }
    return e.prototype.getSize = function() {
      return this.markers.length;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getCenter = function() {
      return this.center;
    }, e.prototype.getMap = function() {
      return this.map;
    }, e.prototype.getClusterer = function() {
      return this.markerClusterer;
    }, e.prototype.getBounds = function() {
      for (var t = new google.maps.LatLngBounds(this.center, this.center), n = this.getMarkers(), r = 0, o = n; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && t.extend(a);
      }
      return t;
    }, e.prototype.remove = function() {
      this.clusterIcon.setMap(null), this.markers = [], delete this.markers;
    }, e.prototype.addMarker = function(t) {
      var n;
      if (this.isMarkerAlreadyAdded(t))
        return !1;
      if (this.center) {
        if (this.averageCenter) {
          var r = t.getPosition();
          if (r) {
            var o = this.markers.length + 1;
            this.center = new google.maps.LatLng((this.center.lat() * (o - 1) + r.lat()) / o, (this.center.lng() * (o - 1) + r.lng()) / o), this.calculateBounds();
          }
        }
      } else {
        var r = t.getPosition();
        r && (this.center = r, this.calculateBounds());
      }
      t.isAdded = !0, this.markers.push(t);
      var i = this.markers.length, a = this.markerClusterer.getMaxZoom(), s = (n = this.map) === null || n === void 0 ? void 0 : n.getZoom();
      if (a !== null && typeof s < "u" && s > a)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i < this.minClusterSize)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i === this.minClusterSize)
        for (var l = 0, u = this.markers; l < u.length; l++) {
          var c = u[l];
          c.setMap(null);
        }
      else
        t.setMap(null);
      return !0;
    }, e.prototype.isMarkerInClusterBounds = function(t) {
      if (this.bounds !== null) {
        var n = t.getPosition();
        if (n)
          return this.bounds.contains(n);
      }
      return !1;
    }, e.prototype.calculateBounds = function() {
      this.bounds = this.markerClusterer.getExtendedBounds(new google.maps.LatLngBounds(this.center, this.center));
    }, e.prototype.updateIcon = function() {
      var t, n = this.markers.length, r = this.markerClusterer.getMaxZoom(), o = (t = this.map) === null || t === void 0 ? void 0 : t.getZoom();
      if (r !== null && typeof o < "u" && o > r) {
        this.clusterIcon.hide();
        return;
      }
      if (n < this.minClusterSize) {
        this.clusterIcon.hide();
        return;
      }
      this.center && this.clusterIcon.setCenter(this.center), this.clusterIcon.useStyle(this.markerClusterer.getCalculator()(this.markers, this.markerClusterer.getStyles().length)), this.clusterIcon.show();
    }, e.prototype.isMarkerAlreadyAdded = function(t) {
      if (this.markers.includes)
        return this.markers.includes(t);
      for (var n = 0; n < this.markers.length; n++)
        if (t === this.markers[n])
          return !0;
      return !1;
    }, e;
  }()
);
function wve(e, t) {
  var n = e.length, r = n.toString().length, o = Math.min(r, t);
  return {
    text: n.toString(),
    index: o,
    title: ""
  };
}
var Cve = 2e3, xve = 500, Ove = "https://developers.google.com/maps/documentation/javascript/examples/markerclusterer/m", Eve = "png", kve = [53, 56, 66, 78, 90], Lve = "cluster", $9 = (
  /** @class */
  function() {
    function e(t, n, r) {
      n === void 0 && (n = []), r === void 0 && (r = {}), this.getMinimumClusterSize = this.getMinimumClusterSize.bind(this), this.setMinimumClusterSize = this.setMinimumClusterSize.bind(this), this.getEnableRetinaIcons = this.getEnableRetinaIcons.bind(this), this.setEnableRetinaIcons = this.setEnableRetinaIcons.bind(this), this.addToClosestCluster = this.addToClosestCluster.bind(this), this.getImageExtension = this.getImageExtension.bind(this), this.setImageExtension = this.setImageExtension.bind(this), this.getExtendedBounds = this.getExtendedBounds.bind(this), this.getAverageCenter = this.getAverageCenter.bind(this), this.setAverageCenter = this.setAverageCenter.bind(this), this.getTotalClusters = this.getTotalClusters.bind(this), this.fitMapToMarkers = this.fitMapToMarkers.bind(this), this.getIgnoreHidden = this.getIgnoreHidden.bind(this), this.setIgnoreHidden = this.setIgnoreHidden.bind(this), this.getClusterClass = this.getClusterClass.bind(this), this.setClusterClass = this.setClusterClass.bind(this), this.getTotalMarkers = this.getTotalMarkers.bind(this), this.getZoomOnClick = this.getZoomOnClick.bind(this), this.setZoomOnClick = this.setZoomOnClick.bind(this), this.getBatchSizeIE = this.getBatchSizeIE.bind(this), this.setBatchSizeIE = this.setBatchSizeIE.bind(this), this.createClusters = this.createClusters.bind(this), this.onZoomChanged = this.onZoomChanged.bind(this), this.getImageSizes = this.getImageSizes.bind(this), this.setImageSizes = this.setImageSizes.bind(this), this.getCalculator = this.getCalculator.bind(this), this.setCalculator = this.setCalculator.bind(this), this.removeMarkers = this.removeMarkers.bind(this), this.resetViewport = this.resetViewport.bind(this), this.getImagePath = this.getImagePath.bind(this), this.setImagePath = this.setImagePath.bind(this), this.pushMarkerTo = this.pushMarkerTo.bind(this), this.removeMarker = this.removeMarker.bind(this), this.clearMarkers = this.clearMarkers.bind(this), this.setupStyles = this.setupStyles.bind(this), this.getGridSize = this.getGridSize.bind(this), this.setGridSize = this.setGridSize.bind(this), this.getClusters = this.getClusters.bind(this), this.getMaxZoom = this.getMaxZoom.bind(this), this.setMaxZoom = this.setMaxZoom.bind(this), this.getMarkers = this.getMarkers.bind(this), this.addMarkers = this.addMarkers.bind(this), this.getStyles = this.getStyles.bind(this), this.setStyles = this.setStyles.bind(this), this.addMarker = this.addMarker.bind(this), this.onRemove = this.onRemove.bind(this), this.getTitle = this.getTitle.bind(this), this.setTitle = this.setTitle.bind(this), this.repaint = this.repaint.bind(this), this.onIdle = this.onIdle.bind(this), this.redraw = this.redraw.bind(this), this.onAdd = this.onAdd.bind(this), this.draw = this.draw.bind(this), this.extend = this.extend.bind(this), this.extend(e, google.maps.OverlayView), this.markers = [], this.clusters = [], this.listeners = [], this.activeMap = null, this.ready = !1, this.gridSize = r.gridSize || 60, this.minClusterSize = r.minimumClusterSize || 2, this.maxZoom = r.maxZoom || null, this.styles = r.styles || [], this.title = r.title || "", this.zoomOnClick = !0, r.zoomOnClick !== void 0 && (this.zoomOnClick = r.zoomOnClick), this.averageCenter = !1, r.averageCenter !== void 0 && (this.averageCenter = r.averageCenter), this.ignoreHidden = !1, r.ignoreHidden !== void 0 && (this.ignoreHidden = r.ignoreHidden), this.enableRetinaIcons = !1, r.enableRetinaIcons !== void 0 && (this.enableRetinaIcons = r.enableRetinaIcons), this.imagePath = r.imagePath || Ove, this.imageExtension = r.imageExtension || Eve, this.imageSizes = r.imageSizes || kve, this.calculator = r.calculator || wve, this.batchSize = r.batchSize || Cve, this.batchSizeIE = r.batchSizeIE || xve, this.clusterClass = r.clusterClass || Lve, navigator.userAgent.toLowerCase().indexOf("msie") !== -1 && (this.batchSize = this.batchSizeIE), this.timerRefStatic = null, this.setupStyles(), this.addMarkers(n, !0), this.setMap(t);
    }
    return e.prototype.onZoomChanged = function() {
      var t, n;
      this.resetViewport(!1), (((t = this.getMap()) === null || t === void 0 ? void 0 : t.getZoom()) === (this.get("minZoom") || 0) || ((n = this.getMap()) === null || n === void 0 ? void 0 : n.getZoom()) === this.get("maxZoom")) && google.maps.event.trigger(this, "idle");
    }, e.prototype.onIdle = function() {
      this.redraw();
    }, e.prototype.onAdd = function() {
      var t = this.getMap();
      this.activeMap = t, this.ready = !0, this.repaint(), t !== null && (this.listeners = [google.maps.event.addListener(t, "zoom_changed", this.onZoomChanged), google.maps.event.addListener(t, "idle", this.onIdle)]);
    }, e.prototype.onRemove = function() {
      for (var t = 0, n = this.markers; t < n.length; t++) {
        var r = n[t];
        r.getMap() !== this.activeMap && r.setMap(this.activeMap);
      }
      for (var o = 0, i = this.clusters; o < i.length; o++) {
        var a = i[o];
        a.remove();
      }
      this.clusters = [];
      for (var s = 0, l = this.listeners; s < l.length; s++) {
        var u = l[s];
        google.maps.event.removeListener(u);
      }
      this.listeners = [], this.activeMap = null, this.ready = !1;
    }, e.prototype.draw = function() {
    }, e.prototype.getMap = function() {
      return null;
    }, e.prototype.getPanes = function() {
      return null;
    }, e.prototype.getProjection = function() {
      return {
        fromContainerPixelToLatLng: function() {
          return null;
        },
        fromDivPixelToLatLng: function() {
          return null;
        },
        fromLatLngToContainerPixel: function() {
          return null;
        },
        fromLatLngToDivPixel: function() {
          return null;
        },
        getVisibleRegion: function() {
          return null;
        },
        getWorldWidth: function() {
          return 0;
        }
      };
    }, e.prototype.setMap = function() {
    }, e.prototype.addListener = function() {
      return {
        remove: function() {
        }
      };
    }, e.prototype.bindTo = function() {
    }, e.prototype.get = function() {
    }, e.prototype.notify = function() {
    }, e.prototype.set = function() {
    }, e.prototype.setValues = function() {
    }, e.prototype.unbind = function() {
    }, e.prototype.unbindAll = function() {
    }, e.prototype.setupStyles = function() {
      if (!(this.styles.length > 0))
        for (var t = 0; t < this.imageSizes.length; t++)
          this.styles.push({
            url: "".concat(this.imagePath + (t + 1), ".").concat(this.imageExtension),
            height: this.imageSizes[t] || 0,
            width: this.imageSizes[t] || 0
          });
    }, e.prototype.fitMapToMarkers = function() {
      for (var t = this.getMarkers(), n = new google.maps.LatLngBounds(), r = 0, o = t; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && n.extend(a);
      }
      var s = this.getMap();
      s !== null && "fitBounds" in s && s.fitBounds(n);
    }, e.prototype.getGridSize = function() {
      return this.gridSize;
    }, e.prototype.setGridSize = function(t) {
      this.gridSize = t;
    }, e.prototype.getMinimumClusterSize = function() {
      return this.minClusterSize;
    }, e.prototype.setMinimumClusterSize = function(t) {
      this.minClusterSize = t;
    }, e.prototype.getMaxZoom = function() {
      return this.maxZoom;
    }, e.prototype.setMaxZoom = function(t) {
      this.maxZoom = t;
    }, e.prototype.getStyles = function() {
      return this.styles;
    }, e.prototype.setStyles = function(t) {
      this.styles = t;
    }, e.prototype.getTitle = function() {
      return this.title;
    }, e.prototype.setTitle = function(t) {
      this.title = t;
    }, e.prototype.getZoomOnClick = function() {
      return this.zoomOnClick;
    }, e.prototype.setZoomOnClick = function(t) {
      this.zoomOnClick = t;
    }, e.prototype.getAverageCenter = function() {
      return this.averageCenter;
    }, e.prototype.setAverageCenter = function(t) {
      this.averageCenter = t;
    }, e.prototype.getIgnoreHidden = function() {
      return this.ignoreHidden;
    }, e.prototype.setIgnoreHidden = function(t) {
      this.ignoreHidden = t;
    }, e.prototype.getEnableRetinaIcons = function() {
      return this.enableRetinaIcons;
    }, e.prototype.setEnableRetinaIcons = function(t) {
      this.enableRetinaIcons = t;
    }, e.prototype.getImageExtension = function() {
      return this.imageExtension;
    }, e.prototype.setImageExtension = function(t) {
      this.imageExtension = t;
    }, e.prototype.getImagePath = function() {
      return this.imagePath;
    }, e.prototype.setImagePath = function(t) {
      this.imagePath = t;
    }, e.prototype.getImageSizes = function() {
      return this.imageSizes;
    }, e.prototype.setImageSizes = function(t) {
      this.imageSizes = t;
    }, e.prototype.getCalculator = function() {
      return this.calculator;
    }, e.prototype.setCalculator = function(t) {
      this.calculator = t;
    }, e.prototype.getBatchSizeIE = function() {
      return this.batchSizeIE;
    }, e.prototype.setBatchSizeIE = function(t) {
      this.batchSizeIE = t;
    }, e.prototype.getClusterClass = function() {
      return this.clusterClass;
    }, e.prototype.setClusterClass = function(t) {
      this.clusterClass = t;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getTotalMarkers = function() {
      return this.markers.length;
    }, e.prototype.getClusters = function() {
      return this.clusters;
    }, e.prototype.getTotalClusters = function() {
      return this.clusters.length;
    }, e.prototype.addMarker = function(t, n) {
      this.pushMarkerTo(t), n || this.redraw();
    }, e.prototype.addMarkers = function(t, n) {
      for (var r in t)
        if (Object.prototype.hasOwnProperty.call(t, r)) {
          var o = t[r];
          o && this.pushMarkerTo(o);
        }
      n || this.redraw();
    }, e.prototype.pushMarkerTo = function(t) {
      var n = this;
      t.getDraggable() && google.maps.event.addListener(t, "dragend", function() {
        n.ready && (t.isAdded = !1, n.repaint());
      }), t.isAdded = !1, this.markers.push(t);
    }, e.prototype.removeMarker_ = function(t) {
      var n = -1;
      if (this.markers.indexOf)
        n = this.markers.indexOf(t);
      else
        for (var r = 0; r < this.markers.length; r++)
          if (t === this.markers[r]) {
            n = r;
            break;
          }
      return n === -1 ? !1 : (t.setMap(null), this.markers.splice(n, 1), !0);
    }, e.prototype.removeMarker = function(t, n) {
      var r = this.removeMarker_(t);
      return !n && r && this.repaint(), r;
    }, e.prototype.removeMarkers = function(t, n) {
      for (var r = !1, o = 0, i = t; o < i.length; o++) {
        var a = i[o];
        r = r || this.removeMarker_(a);
      }
      return !n && r && this.repaint(), r;
    }, e.prototype.clearMarkers = function() {
      this.resetViewport(!0), this.markers = [];
    }, e.prototype.repaint = function() {
      var t = this.clusters.slice();
      this.clusters = [], this.resetViewport(!1), this.redraw(), setTimeout(function() {
        for (var n = 0, r = t; n < r.length; n++) {
          var o = r[n];
          o.remove();
        }
      }, 0);
    }, e.prototype.getExtendedBounds = function(t) {
      var n = this.getProjection(), r = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getNorthEast().lat(), t.getNorthEast().lng())
      );
      r !== null && (r.x += this.gridSize, r.y -= this.gridSize);
      var o = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getSouthWest().lat(), t.getSouthWest().lng())
      );
      if (o !== null && (o.x -= this.gridSize, o.y += this.gridSize), r !== null) {
        var i = n.fromDivPixelToLatLng(r);
        i !== null && t.extend(i);
      }
      if (o !== null) {
        var a = n.fromDivPixelToLatLng(o);
        a !== null && t.extend(a);
      }
      return t;
    }, e.prototype.redraw = function() {
      this.createClusters(0);
    }, e.prototype.resetViewport = function(t) {
      for (var n = 0, r = this.clusters; n < r.length; n++) {
        var o = r[n];
        o.remove();
      }
      this.clusters = [];
      for (var i = 0, a = this.markers; i < a.length; i++) {
        var s = a[i];
        s.isAdded = !1, t && s.setMap(null);
      }
    }, e.prototype.distanceBetweenPoints = function(t, n) {
      var r = 6371, o = (n.lat() - t.lat()) * Math.PI / 180, i = (n.lng() - t.lng()) * Math.PI / 180, a = Math.sin(o / 2) * Math.sin(o / 2) + Math.cos(t.lat() * Math.PI / 180) * Math.cos(n.lat() * Math.PI / 180) * Math.sin(i / 2) * Math.sin(i / 2);
      return r * (2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)));
    }, e.prototype.isMarkerInBounds = function(t, n) {
      var r = t.getPosition();
      return r ? n.contains(r) : !1;
    }, e.prototype.addToClosestCluster = function(t) {
      for (var n, r = 4e4, o = null, i = 0, a = this.clusters; i < a.length; i++) {
        var s = a[i];
        n = s;
        var l = n.getCenter(), u = t.getPosition();
        if (l && u) {
          var c = this.distanceBetweenPoints(l, u);
          c < r && (r = c, o = n);
        }
      }
      o && o.isMarkerInClusterBounds(t) ? o.addMarker(t) : (n = new bve(this), n.addMarker(t), this.clusters.push(n));
    }, e.prototype.createClusters = function(t) {
      var n = this;
      if (this.ready) {
        t === 0 && (google.maps.event.trigger(this, "clusteringbegin", this), this.timerRefStatic !== null && (window.clearTimeout(this.timerRefStatic), delete this.timerRefStatic));
        for (var r = this.getMap(), o = r !== null && ("getBounds" in r) ? r.getBounds() : null, i = (r == null ? void 0 : r.getZoom()) || 0, a = i > 3 ? new google.maps.LatLngBounds(o == null ? void 0 : o.getSouthWest(), o == null ? void 0 : o.getNorthEast()) : new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625)), s = this.getExtendedBounds(a), l = Math.min(t + this.batchSize, this.markers.length), u = t; u < l; u++) {
          var c = this.markers[u];
          c && !c.isAdded && this.isMarkerInBounds(c, s) && (!this.ignoreHidden || this.ignoreHidden && c.getVisible()) && this.addToClosestCluster(c);
        }
        if (l < this.markers.length)
          this.timerRefStatic = window.setTimeout(function() {
            n.createClusters(l);
          }, 0);
        else {
          this.timerRefStatic = null, google.maps.event.trigger(this, "clusteringend", this);
          for (var p = 0, d = this.clusters; p < d.length; p++) {
            var h = d[p];
            h.updateIcon();
          }
        }
      }
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype) {
          var i = o;
          this.prototype[i] = r.prototype[i];
        }
        return this;
      }).apply(t, [n]);
    }, e;
  }()
);
function rB(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function _ve(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? rB(Object(n), !0).forEach(function(r) {
      Ce(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : rB(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var fi = {
  onClick: "click",
  onClusteringBegin: "clusteringbegin",
  onClusteringEnd: "clusteringend",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover"
}, dn = {
  averageCenter(e, t) {
    e.setAverageCenter(t);
  },
  batchSizeIE(e, t) {
    e.setBatchSizeIE(t);
  },
  calculator(e, t) {
    e.setCalculator(t);
  },
  clusterClass(e, t) {
    e.setClusterClass(t);
  },
  enableRetinaIcons(e, t) {
    e.setEnableRetinaIcons(t);
  },
  gridSize(e, t) {
    e.setGridSize(t);
  },
  ignoreHidden(e, t) {
    e.setIgnoreHidden(t);
  },
  imageExtension(e, t) {
    e.setImageExtension(t);
  },
  imagePath(e, t) {
    e.setImagePath(t);
  },
  imageSizes(e, t) {
    e.setImageSizes(t);
  },
  maxZoom(e, t) {
    e.setMaxZoom(t);
  },
  minimumClusterSize(e, t) {
    e.setMinimumClusterSize(t);
  },
  styles(e, t) {
    e.setStyles(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  zoomOnClick(e, t) {
    e.setZoomOnClick(t);
  }
}, Pve = {};
function Sve(e) {
  var {
    children: t,
    options: n,
    averageCenter: r,
    batchSizeIE: o,
    calculator: i,
    clusterClass: a,
    enableRetinaIcons: s,
    gridSize: l,
    ignoreHidden: u,
    imageExtension: c,
    imagePath: p,
    imageSizes: d,
    maxZoom: h,
    minimumClusterSize: f,
    styles: m,
    title: g,
    zoomOnClick: E,
    onClick: w,
    onClusteringBegin: M,
    onClusteringEnd: x,
    onMouseOver: y,
    onMouseOut: C,
    onLoad: P,
    onUnmount: F
  } = e, [L, N] = k(null), I = ye(Mt), [H, V] = k(null), [z, q] = k(null), [K, J] = k(null), [te, ee] = k(null), [_, D] = k(null);
  return v(() => {
    L && C && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(L, fi.onMouseOut, C)));
  }, [C]), v(() => {
    L && y && (_ !== null && google.maps.event.removeListener(_), D(google.maps.event.addListener(L, fi.onMouseOver, y)));
  }, [y]), v(() => {
    L && w && (H !== null && google.maps.event.removeListener(H), V(google.maps.event.addListener(L, fi.onClick, w)));
  }, [w]), v(() => {
    L && M && (z !== null && google.maps.event.removeListener(z), q(google.maps.event.addListener(L, fi.onClusteringBegin, M)));
  }, [M]), v(() => {
    L && x && (K !== null && google.maps.event.removeListener(K), q(google.maps.event.addListener(L, fi.onClusteringEnd, x)));
  }, [x]), v(() => {
    typeof r < "u" && L !== null && dn.averageCenter(L, r);
  }, [L, r]), v(() => {
    typeof o < "u" && L !== null && dn.batchSizeIE(L, o);
  }, [L, o]), v(() => {
    typeof i < "u" && L !== null && dn.calculator(L, i);
  }, [L, i]), v(() => {
    typeof a < "u" && L !== null && dn.clusterClass(L, a);
  }, [L, a]), v(() => {
    typeof s < "u" && L !== null && dn.enableRetinaIcons(L, s);
  }, [L, s]), v(() => {
    typeof l < "u" && L !== null && dn.gridSize(L, l);
  }, [L, l]), v(() => {
    typeof u < "u" && L !== null && dn.ignoreHidden(L, u);
  }, [L, u]), v(() => {
    typeof c < "u" && L !== null && dn.imageExtension(L, c);
  }, [L, c]), v(() => {
    typeof p < "u" && L !== null && dn.imagePath(L, p);
  }, [L, p]), v(() => {
    typeof d < "u" && L !== null && dn.imageSizes(L, d);
  }, [L, d]), v(() => {
    typeof h < "u" && L !== null && dn.maxZoom(L, h);
  }, [L, h]), v(() => {
    typeof f < "u" && L !== null && dn.minimumClusterSize(L, f);
  }, [L, f]), v(() => {
    typeof m < "u" && L !== null && dn.styles(L, m);
  }, [L, m]), v(() => {
    typeof g < "u" && L !== null && dn.title(L, g);
  }, [L, g]), v(() => {
    typeof E < "u" && L !== null && dn.zoomOnClick(L, E);
  }, [L, E]), v(() => {
    if (I) {
      var $ = _ve({}, n || Pve), S = new $9(I, [], $);
      return r && dn.averageCenter(S, r), o && dn.batchSizeIE(S, o), i && dn.calculator(S, i), a && dn.clusterClass(S, a), s && dn.enableRetinaIcons(S, s), l && dn.gridSize(S, l), u && dn.ignoreHidden(S, u), c && dn.imageExtension(S, c), p && dn.imagePath(S, p), d && dn.imageSizes(S, d), h && dn.maxZoom(S, h), f && dn.minimumClusterSize(S, f), m && dn.styles(S, m), g && dn.title(S, g), E && dn.zoomOnClick(S, E), C && ee(google.maps.event.addListener(S, fi.onMouseOut, C)), y && D(google.maps.event.addListener(S, fi.onMouseOver, y)), w && V(google.maps.event.addListener(S, fi.onClick, w)), M && q(google.maps.event.addListener(S, fi.onClusteringBegin, M)), x && J(google.maps.event.addListener(S, fi.onClusteringEnd, x)), N(S), P && P(S), () => {
        te !== null && google.maps.event.removeListener(te), _ !== null && google.maps.event.removeListener(_), H !== null && google.maps.event.removeListener(H), z !== null && google.maps.event.removeListener(z), K !== null && google.maps.event.removeListener(K), F && F(S);
      };
    }
  }, []), L !== null && t(L) || null;
}
Ee(Sve);
class Mve extends pe {
  constructor() {
    super(...arguments), Ce(this, "registeredEvents", []), Ce(this, "state", {
      markerClusterer: null
    }), Ce(this, "setClustererCallback", () => {
      this.state.markerClusterer !== null && this.props.onLoad && this.props.onLoad(this.state.markerClusterer);
    });
  }
  componentDidMount() {
    if (this.context) {
      var t = new $9(this.context, [], this.props.options);
      this.registeredEvents = en({
        updaterMap: dn,
        eventMap: fi,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        markerClusterer: t
      }), this.setClustererCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.markerClusterer && (an(this.registeredEvents), this.registeredEvents = en({
      updaterMap: dn,
      eventMap: fi,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.markerClusterer
    }));
  }
  componentWillUnmount() {
    this.state.markerClusterer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.markerClusterer), an(this.registeredEvents), this.state.markerClusterer.setMap(null));
  }
  render() {
    return this.state.markerClusterer !== null ? this.props.children(this.state.markerClusterer) : null;
  }
}
Ce(Mve, "contextType", Mt);
function oB(e) {
  e.cancelBubble = !0, e.stopPropagation && e.stopPropagation();
}
var H9 = (
  /** @class */
  function() {
    function e(t) {
      t === void 0 && (t = {}), this.getCloseClickHandler = this.getCloseClickHandler.bind(this), this.closeClickHandler = this.closeClickHandler.bind(this), this.createInfoBoxDiv = this.createInfoBoxDiv.bind(this), this.addClickHandler = this.addClickHandler.bind(this), this.getCloseBoxImg = this.getCloseBoxImg.bind(this), this.getBoxWidths = this.getBoxWidths.bind(this), this.setBoxStyle = this.setBoxStyle.bind(this), this.setPosition = this.setPosition.bind(this), this.getPosition = this.getPosition.bind(this), this.setOptions = this.setOptions.bind(this), this.setContent = this.setContent.bind(this), this.setVisible = this.setVisible.bind(this), this.getContent = this.getContent.bind(this), this.getVisible = this.getVisible.bind(this), this.setZIndex = this.setZIndex.bind(this), this.getZIndex = this.getZIndex.bind(this), this.onRemove = this.onRemove.bind(this), this.panBox = this.panBox.bind(this), this.extend = this.extend.bind(this), this.close = this.close.bind(this), this.draw = this.draw.bind(this), this.show = this.show.bind(this), this.hide = this.hide.bind(this), this.open = this.open.bind(this), this.extend(e, google.maps.OverlayView), this.content = t.content || "", this.disableAutoPan = t.disableAutoPan || !1, this.maxWidth = t.maxWidth || 0, this.pixelOffset = t.pixelOffset || new google.maps.Size(0, 0), this.position = t.position || new google.maps.LatLng(0, 0), this.zIndex = t.zIndex || null, this.boxClass = t.boxClass || "infoBox", this.boxStyle = t.boxStyle || {}, this.closeBoxMargin = t.closeBoxMargin || "2px", this.closeBoxURL = t.closeBoxURL || "http://www.google.com/intl/en_us/mapfiles/close.gif", t.closeBoxURL === "" && (this.closeBoxURL = ""), this.infoBoxClearance = t.infoBoxClearance || new google.maps.Size(1, 1), typeof t.visible > "u" && (typeof t.isHidden > "u" ? t.visible = !0 : t.visible = !t.isHidden), this.isHidden = !t.visible, this.alignBottom = t.alignBottom || !1, this.pane = t.pane || "floatPane", this.enableEventPropagation = t.enableEventPropagation || !1, this.div = null, this.closeListener = null, this.moveListener = null, this.mapListener = null, this.contextListener = null, this.eventListeners = null, this.fixedWidthSet = null;
    }
    return e.prototype.createInfoBoxDiv = function() {
      var t = this, n = function(u) {
        u.returnValue = !1, u.preventDefault && u.preventDefault(), t.enableEventPropagation || oB(u);
      };
      if (!this.div) {
        this.div = document.createElement("div"), this.setBoxStyle(), typeof this.content == "string" ? this.div.innerHTML = this.getCloseBoxImg() + this.content : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(this.content));
        var r = this.getPanes();
        if (r !== null && r[this.pane].appendChild(this.div), this.addClickHandler(), this.div.style.width)
          this.fixedWidthSet = !0;
        else if (this.maxWidth !== 0 && this.div.offsetWidth > this.maxWidth)
          this.div.style.width = this.maxWidth + "px", this.fixedWidthSet = !0;
        else {
          var o = this.getBoxWidths();
          this.div.style.width = this.div.offsetWidth - o.left - o.right + "px", this.fixedWidthSet = !1;
        }
        if (this.panBox(this.disableAutoPan), !this.enableEventPropagation) {
          this.eventListeners = [];
          for (var i = ["mousedown", "mouseover", "mouseout", "mouseup", "click", "dblclick", "touchstart", "touchend", "touchmove"], a = 0, s = i; a < s.length; a++) {
            var l = s[a];
            this.eventListeners.push(google.maps.event.addListener(this.div, l, oB));
          }
          this.eventListeners.push(google.maps.event.addListener(this.div, "mouseover", function() {
            t.div && (t.div.style.cursor = "default");
          }));
        }
        this.contextListener = google.maps.event.addListener(this.div, "contextmenu", n), google.maps.event.trigger(this, "domready");
      }
    }, e.prototype.getCloseBoxImg = function() {
      var t = "";
      return this.closeBoxURL !== "" && (t = '<img alt=""', t += ' aria-hidden="true"', t += " src='" + this.closeBoxURL + "'", t += " align=right", t += " style='", t += " position: relative;", t += " cursor: pointer;", t += " margin: " + this.closeBoxMargin + ";", t += "'>"), t;
    }, e.prototype.addClickHandler = function() {
      this.closeListener = this.div && this.div.firstChild && this.closeBoxURL !== "" ? google.maps.event.addListener(this.div.firstChild, "click", this.getCloseClickHandler()) : null;
    }, e.prototype.closeClickHandler = function(t) {
      t.cancelBubble = !0, t.stopPropagation && t.stopPropagation(), google.maps.event.trigger(this, "closeclick"), this.close();
    }, e.prototype.getCloseClickHandler = function() {
      return this.closeClickHandler;
    }, e.prototype.panBox = function(t) {
      if (this.div && !t) {
        var n = this.getMap();
        if (n instanceof google.maps.Map) {
          var r = 0, o = 0, i = n.getBounds();
          i && !i.contains(this.position) && n.setCenter(this.position);
          var a = n.getDiv(), s = a.offsetWidth, l = a.offsetHeight, u = this.pixelOffset.width, c = this.pixelOffset.height, p = this.div.offsetWidth, d = this.div.offsetHeight, h = this.infoBoxClearance.width, f = this.infoBoxClearance.height, m = this.getProjection(), g = m.fromLatLngToContainerPixel(this.position);
          g !== null && (g.x < -u + h ? r = g.x + u - h : g.x + p + u + h > s && (r = g.x + p + u + h - s), this.alignBottom ? g.y < -c + f + d ? o = g.y + c - f - d : g.y + c + f > l && (o = g.y + c + f - l) : g.y < -c + f ? o = g.y + c - f : g.y + d + c + f > l && (o = g.y + d + c + f - l)), r === 0 && o === 0 || n.panBy(r, o);
        }
      }
    }, e.prototype.setBoxStyle = function() {
      if (this.div) {
        this.div.className = this.boxClass, this.div.style.cssText = "";
        var t = this.boxStyle;
        for (var n in t)
          Object.prototype.hasOwnProperty.call(t, n) && (this.div.style[n] = t[n]);
        if (this.div.style.webkitTransform = "translateZ(0)", typeof this.div.style.opacity < "u" && this.div.style.opacity !== "") {
          var r = parseFloat(this.div.style.opacity || "");
          this.div.style.msFilter = '"progid:DXImageTransform.Microsoft.Alpha(Opacity=' + r * 100 + ')"', this.div.style.filter = "alpha(opacity=" + r * 100 + ")";
        }
        this.div.style.position = "absolute", this.div.style.visibility = "hidden", this.zIndex !== null && (this.div.style.zIndex = this.zIndex + ""), this.div.style.overflow || (this.div.style.overflow = "auto");
      }
    }, e.prototype.getBoxWidths = function() {
      var t = {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0
      };
      if (!this.div)
        return t;
      if (document.defaultView) {
        var n = this.div.ownerDocument, r = n && n.defaultView ? n.defaultView.getComputedStyle(this.div, "") : null;
        r && (t.top = parseInt(r.borderTopWidth || "", 10) || 0, t.bottom = parseInt(r.borderBottomWidth || "", 10) || 0, t.left = parseInt(r.borderLeftWidth || "", 10) || 0, t.right = parseInt(r.borderRightWidth || "", 10) || 0);
      } else if (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        document.documentElement.currentStyle
      ) {
        var o = this.div.currentStyle;
        o && (t.top = parseInt(o.borderTopWidth || "", 10) || 0, t.bottom = parseInt(o.borderBottomWidth || "", 10) || 0, t.left = parseInt(o.borderLeftWidth || "", 10) || 0, t.right = parseInt(o.borderRightWidth || "", 10) || 0);
      }
      return t;
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.div.parentNode.removeChild(this.div), this.div = null);
    }, e.prototype.draw = function() {
      if (this.createInfoBoxDiv(), this.div) {
        var t = this.getProjection(), n = t.fromLatLngToDivPixel(this.position);
        n !== null && (this.div.style.left = n.x + this.pixelOffset.width + "px", this.alignBottom ? this.div.style.bottom = -(n.y + this.pixelOffset.height) + "px" : this.div.style.top = n.y + this.pixelOffset.height + "px"), this.isHidden ? this.div.style.visibility = "hidden" : this.div.style.visibility = "visible";
      }
    }, e.prototype.setOptions = function(t) {
      t === void 0 && (t = {}), typeof t.boxClass < "u" && (this.boxClass = t.boxClass, this.setBoxStyle()), typeof t.boxStyle < "u" && (this.boxStyle = t.boxStyle, this.setBoxStyle()), typeof t.content < "u" && this.setContent(t.content), typeof t.disableAutoPan < "u" && (this.disableAutoPan = t.disableAutoPan), typeof t.maxWidth < "u" && (this.maxWidth = t.maxWidth), typeof t.pixelOffset < "u" && (this.pixelOffset = t.pixelOffset), typeof t.alignBottom < "u" && (this.alignBottom = t.alignBottom), typeof t.position < "u" && this.setPosition(t.position), typeof t.zIndex < "u" && this.setZIndex(t.zIndex), typeof t.closeBoxMargin < "u" && (this.closeBoxMargin = t.closeBoxMargin), typeof t.closeBoxURL < "u" && (this.closeBoxURL = t.closeBoxURL), typeof t.infoBoxClearance < "u" && (this.infoBoxClearance = t.infoBoxClearance), typeof t.isHidden < "u" && (this.isHidden = t.isHidden), typeof t.visible < "u" && (this.isHidden = !t.visible), typeof t.enableEventPropagation < "u" && (this.enableEventPropagation = t.enableEventPropagation), this.div && this.draw();
    }, e.prototype.setContent = function(t) {
      this.content = t, this.div && (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.fixedWidthSet || (this.div.style.width = ""), typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t)), this.fixedWidthSet || (this.div.style.width = this.div.offsetWidth + "px", typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t))), this.addClickHandler()), google.maps.event.trigger(this, "content_changed");
    }, e.prototype.setPosition = function(t) {
      this.position = t, this.div && this.draw(), google.maps.event.trigger(this, "position_changed");
    }, e.prototype.setVisible = function(t) {
      this.isHidden = !t, this.div && (this.div.style.visibility = this.isHidden ? "hidden" : "visible");
    }, e.prototype.setZIndex = function(t) {
      this.zIndex = t, this.div && (this.div.style.zIndex = t + ""), google.maps.event.trigger(this, "zindex_changed");
    }, e.prototype.getContent = function() {
      return this.content;
    }, e.prototype.getPosition = function() {
      return this.position;
    }, e.prototype.getZIndex = function() {
      return this.zIndex;
    }, e.prototype.getVisible = function() {
      var t = this.getMap();
      return typeof t > "u" || t === null ? !1 : !this.isHidden;
    }, e.prototype.show = function() {
      this.isHidden = !1, this.div && (this.div.style.visibility = "visible");
    }, e.prototype.hide = function() {
      this.isHidden = !0, this.div && (this.div.style.visibility = "hidden");
    }, e.prototype.open = function(t, n) {
      var r = this;
      n && (this.position = n.getPosition(), this.moveListener = google.maps.event.addListener(n, "position_changed", function() {
        var o = n.getPosition();
        r.setPosition(o);
      }), this.mapListener = google.maps.event.addListener(n, "map_changed", function() {
        r.setMap(n.map);
      })), this.setMap(t), this.div && this.panBox();
    }, e.prototype.close = function() {
      if (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.eventListeners) {
        for (var t = 0, n = this.eventListeners; t < n.length; t++) {
          var r = n[t];
          google.maps.event.removeListener(r);
        }
        this.eventListeners = null;
      }
      this.moveListener && (google.maps.event.removeListener(this.moveListener), this.moveListener = null), this.mapListener && (google.maps.event.removeListener(this.mapListener), this.mapListener = null), this.contextListener && (google.maps.event.removeListener(this.contextListener), this.contextListener = null), this.setMap(null);
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype)
          Object.prototype.hasOwnProperty.call(this, o) || (this.prototype[o] = r.prototype[o]);
        return this;
      }).apply(t, [n]);
    }, e;
  }()
), Dve = ["position"], Tve = ["position"];
function iB(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Wg(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? iB(Object(n), !0).forEach(function(r) {
      Ce(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : iB(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var sB = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, aB = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    t instanceof google.maps.LatLng ? e.setPosition(t) : e.setPosition(new google.maps.LatLng(t.lat, t.lng));
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, jve = {};
function Ave(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, h = ye(Mt), [f, m] = k(null), [g, E] = k(null), [w, M] = k(null), [x, y] = k(null), [C, P] = k(null), [F, L] = k(null), N = rt(null);
  return v(() => {
    h && f !== null && (f.close(), n ? f.open(h, n) : f.getPosition() && f.open(h));
  }, [h, f, n]), v(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), v(() => {
    if (o && f !== null) {
      var I = o instanceof google.maps.LatLng ? o : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        new google.maps.LatLng(o.lat, o.lng)
      );
      f.setPosition(I);
    }
  }, [o]), v(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), v(() => {
    f && a && (g !== null && google.maps.event.removeListener(g), E(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), v(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), M(google.maps.event.addListener(f, "domready", s)));
  }, [s]), v(() => {
    f && l && (x !== null && google.maps.event.removeListener(x), y(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), v(() => {
    f && u && (C !== null && google.maps.event.removeListener(C), P(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), v(() => {
    f && c && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), v(() => {
    if (h) {
      var I = r || jve, {
        position: H
      } = I, V = Mk(I, Dve), z;
      H && !(H instanceof google.maps.LatLng) && (z = new google.maps.LatLng(H.lat, H.lng));
      var q = new H9(Wg(Wg({}, V), z ? {
        position: z
      } : {}));
      N.current = document.createElement("div"), m(q), a && E(google.maps.event.addListener(q, "closeclick", a)), s && M(google.maps.event.addListener(q, "domready", s)), l && y(google.maps.event.addListener(q, "content_changed", l)), u && P(google.maps.event.addListener(q, "position_changed", u)), c && L(google.maps.event.addListener(q, "zindex_changed", c)), q.setContent(N.current), n ? q.open(h, n) : q.getPosition() ? q.open(h) : Gr(!1, "You must provide either an anchor or a position prop for <InfoBox>."), p && p(q);
    }
    return () => {
      f !== null && (g && google.maps.event.removeListener(g), x && google.maps.event.removeListener(x), w && google.maps.event.removeListener(w), C && google.maps.event.removeListener(C), F && google.maps.event.removeListener(F), d && d(f), f.close());
    };
  }, []), N.current ? yr(at.only(t), N.current) : null;
}
Ee(Ave);
class Bve extends pe {
  constructor() {
    super(...arguments), Ce(this, "registeredEvents", []), Ce(this, "containerElement", null), Ce(this, "state", {
      infoBox: null
    }), Ce(this, "open", (t, n) => {
      n ? this.context !== null && t.open(this.context, n) : t.getPosition() ? this.context !== null && t.open(this.context) : Gr(!1, "You must provide either an anchor or a position prop for <InfoBox>.");
    }), Ce(this, "setInfoBoxCallback", () => {
      this.state.infoBox !== null && this.containerElement !== null && (this.state.infoBox.setContent(this.containerElement), this.open(this.state.infoBox, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoBox));
    });
  }
  componentDidMount() {
    var t = this.props.options || {}, {
      position: n
    } = t, r = Mk(t, Tve), o;
    n && !(n instanceof google.maps.LatLng) && (o = new google.maps.LatLng(n.lat, n.lng));
    var i = new H9(Wg(Wg({}, r), o ? {
      position: o
    } : {}));
    this.containerElement = document.createElement("div"), this.registeredEvents = en({
      updaterMap: aB,
      eventMap: sB,
      prevProps: {},
      nextProps: this.props,
      instance: i
    }), this.setState({
      infoBox: i
    }, this.setInfoBoxCallback);
  }
  componentDidUpdate(t) {
    var {
      infoBox: n
    } = this.state;
    n !== null && (an(this.registeredEvents), this.registeredEvents = en({
      updaterMap: aB,
      eventMap: sB,
      prevProps: t,
      nextProps: this.props,
      instance: n
    }));
  }
  componentWillUnmount() {
    var {
      onUnmount: t
    } = this.props, {
      infoBox: n
    } = this.state;
    n !== null && (t && t(n), an(this.registeredEvents), n.close());
  }
  render() {
    return this.containerElement ? yr(at.only(this.props.children), this.containerElement) : null;
  }
}
Ce(Bve, "contextType", Mt);
var lB, uB;
function Ive() {
  return uB || (uB = 1, lB = function e(t, n) {
    if (t === n) return !0;
    if (t && n && typeof t == "object" && typeof n == "object") {
      if (t.constructor !== n.constructor) return !1;
      var r, o, i;
      if (Array.isArray(t)) {
        if (r = t.length, r != n.length) return !1;
        for (o = r; o-- !== 0; ) if (!e(t[o], n[o])) return !1;
        return !0;
      }
      if (t.constructor === RegExp) return t.source === n.source && t.flags === n.flags;
      if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === n.valueOf();
      if (t.toString !== Object.prototype.toString) return t.toString() === n.toString();
      if (i = Object.keys(t), r = i.length, r !== Object.keys(n).length) return !1;
      for (o = r; o-- !== 0; ) if (!Object.prototype.hasOwnProperty.call(n, i[o])) return !1;
      for (o = r; o-- !== 0; ) {
        var a = i[o];
        if (!e(t[a], n[a])) return !1;
      }
      return !0;
    }
    return t !== t && n !== n;
  }), lB;
}
var Rve = Ive(), cB = /* @__PURE__ */ I9(Rve), pB = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array], O0 = 1, Ku = 8;
class Dk {
  /**
   * Creates an index from raw `ArrayBuffer` data.
   * @param {ArrayBuffer} data
   */
  static from(t) {
    if (!(t instanceof ArrayBuffer))
      throw new Error("Data must be an instance of ArrayBuffer.");
    var [n, r] = new Uint8Array(t, 0, 2);
    if (n !== 219)
      throw new Error("Data does not appear to be in a KDBush format.");
    var o = r >> 4;
    if (o !== O0)
      throw new Error("Got v".concat(o, " data when expected v").concat(O0, "."));
    var i = pB[r & 15];
    if (!i)
      throw new Error("Unrecognized array type.");
    var [a] = new Uint16Array(t, 2, 1), [s] = new Uint32Array(t, 4, 1);
    return new Dk(s, a, i, t);
  }
  /**
   * Creates an index that will hold a given number of items.
   * @param {number} numItems
   * @param {number} [nodeSize=64] Size of the KD-tree node (64 by default).
   * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).
   * @param {ArrayBuffer} [data] (For internal use only)
   */
  constructor(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 64, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Float64Array, o = arguments.length > 3 ? arguments[3] : void 0;
    if (isNaN(t) || t < 0) throw new Error("Unpexpected numItems value: ".concat(t, "."));
    this.numItems = +t, this.nodeSize = Math.min(Math.max(+n, 2), 65535), this.ArrayType = r, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
    var i = pB.indexOf(this.ArrayType), a = t * 2 * this.ArrayType.BYTES_PER_ELEMENT, s = t * this.IndexArrayType.BYTES_PER_ELEMENT, l = (8 - s % 8) % 8;
    if (i < 0)
      throw new Error("Unexpected typed array class: ".concat(r, "."));
    o && o instanceof ArrayBuffer ? (this.data = o, this.ids = new this.IndexArrayType(this.data, Ku, t), this.coords = new this.ArrayType(this.data, Ku + s + l, t * 2), this._pos = t * 2, this._finished = !0) : (this.data = new ArrayBuffer(Ku + a + s + l), this.ids = new this.IndexArrayType(this.data, Ku, t), this.coords = new this.ArrayType(this.data, Ku + s + l, t * 2), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, (O0 << 4) + i]), new Uint16Array(this.data, 2, 1)[0] = n, new Uint32Array(this.data, 4, 1)[0] = t);
  }
  /**
   * Add a point to the index.
   * @param {number} x
   * @param {number} y
   * @returns {number} An incremental index associated with the added item (starting from `0`).
   */
  add(t, n) {
    var r = this._pos >> 1;
    return this.ids[r] = r, this.coords[this._pos++] = t, this.coords[this._pos++] = n, r;
  }
  /**
   * Perform indexing of the added points.
   */
  finish() {
    var t = this._pos >> 1;
    if (t !== this.numItems)
      throw new Error("Added ".concat(t, " items when expected ").concat(this.numItems, "."));
    return fx(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
  }
  /**
   * Search the index for items within a given bounding box.
   * @param {number} minX
   * @param {number} minY
   * @param {number} maxX
   * @param {number} maxY
   * @returns {number[]} An array of indices correponding to the found items.
   */
  range(t, n, r, o) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: i,
      coords: a,
      nodeSize: s
    } = this, l = [0, i.length - 1, 0], u = []; l.length; ) {
      var c = l.pop() || 0, p = l.pop() || 0, d = l.pop() || 0;
      if (p - d <= s) {
        for (var h = d; h <= p; h++) {
          var f = a[2 * h], m = a[2 * h + 1];
          f >= t && f <= r && m >= n && m <= o && u.push(i[h]);
        }
        continue;
      }
      var g = d + p >> 1, E = a[2 * g], w = a[2 * g + 1];
      E >= t && E <= r && w >= n && w <= o && u.push(i[g]), (c === 0 ? t <= E : n <= w) && (l.push(d), l.push(g - 1), l.push(1 - c)), (c === 0 ? r >= E : o >= w) && (l.push(g + 1), l.push(p), l.push(1 - c));
    }
    return u;
  }
  /**
   * Search the index for items within a given radius.
   * @param {number} qx
   * @param {number} qy
   * @param {number} r Query radius.
   * @returns {number[]} An array of indices correponding to the found items.
   */
  within(t, n, r) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: o,
      coords: i,
      nodeSize: a
    } = this, s = [0, o.length - 1, 0], l = [], u = r * r; s.length; ) {
      var c = s.pop() || 0, p = s.pop() || 0, d = s.pop() || 0;
      if (p - d <= a) {
        for (var h = d; h <= p; h++)
          dB(i[2 * h], i[2 * h + 1], t, n) <= u && l.push(o[h]);
        continue;
      }
      var f = d + p >> 1, m = i[2 * f], g = i[2 * f + 1];
      dB(m, g, t, n) <= u && l.push(o[f]), (c === 0 ? t - r <= m : n - r <= g) && (s.push(d), s.push(f - 1), s.push(1 - c)), (c === 0 ? t + r >= m : n + r >= g) && (s.push(f + 1), s.push(p), s.push(1 - c));
    }
    return l;
  }
}
function fx(e, t, n, r, o, i) {
  if (!(o - r <= n)) {
    var a = r + o >> 1;
    W9(e, t, a, r, o, i), fx(e, t, n, r, a - 1, 1 - i), fx(e, t, n, a + 1, o, 1 - i);
  }
}
function W9(e, t, n, r, o, i) {
  for (; o > r; ) {
    if (o - r > 600) {
      var a = o - r + 1, s = n - r + 1, l = Math.log(a), u = 0.5 * Math.exp(2 * l / 3), c = 0.5 * Math.sqrt(l * u * (a - u) / a) * (s - a / 2 < 0 ? -1 : 1), p = Math.max(r, Math.floor(n - s * u / a + c)), d = Math.min(o, Math.floor(n + (a - s) * u / a + c));
      W9(e, t, n, p, d, i);
    }
    var h = t[2 * n + i], f = r, m = o;
    for (Yu(e, t, r, n), t[2 * o + i] > h && Yu(e, t, r, o); f < m; ) {
      for (Yu(e, t, f, m), f++, m--; t[2 * f + i] < h; ) f++;
      for (; t[2 * m + i] > h; ) m--;
    }
    t[2 * r + i] === h ? Yu(e, t, r, m) : (m++, Yu(e, t, m, o)), m <= n && (r = m + 1), n <= m && (o = m - 1);
  }
}
function Yu(e, t, n, r) {
  E0(e, n, r), E0(t, 2 * n, 2 * r), E0(t, 2 * n + 1, 2 * r + 1);
}
function E0(e, t, n) {
  var r = e[t];
  e[t] = e[n], e[n] = r;
}
function dB(e, t, n, r) {
  var o = e - n, i = t - r;
  return o * o + i * i;
}
var Nve = {
  minZoom: 0,
  // min zoom to generate clusters on
  maxZoom: 16,
  // max zoom level to cluster the points on
  minPoints: 2,
  // minimum points to form a cluster
  radius: 40,
  // cluster radius in pixels
  extent: 512,
  // tile extent (radius is calculated relative to it)
  nodeSize: 64,
  // size of the KD-tree leaf node, affects performance
  log: !1,
  // whether to log timing info
  // whether to generate numeric ids for input features (in vector tiles)
  generateId: !1,
  // a reduce function for calculating custom cluster properties
  reduce: null,
  // (accumulated, props) => { accumulated.sum += props.sum; }
  // properties to use for individual points when running the reducer
  map: (e) => e
  // props => ({sum: props.my_value})
}, fB = Math.fround || /* @__PURE__ */ ((e) => (t) => (e[0] = +t, e[0]))(new Float32Array(1)), Fa = 2, Qs = 3, k0 = 4, Zs = 5, V9 = 6;
class Fve {
  constructor(t) {
    this.options = Object.assign(Object.create(Nve), t), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
  }
  load(t) {
    var {
      log: n,
      minZoom: r,
      maxZoom: o
    } = this.options;
    n && console.time("total time");
    var i = "prepare ".concat(t.length, " points");
    n && console.time(i), this.points = t;
    for (var a = [], s = 0; s < t.length; s++) {
      var l = t[s];
      if (l.geometry) {
        var [u, c] = l.geometry.coordinates, p = fB(zf(u)), d = fB(Uf(c));
        a.push(
          p,
          d,
          // projected point coordinates
          1 / 0,
          // the last zoom the point was processed at
          s,
          // index of the source feature in the original input array
          -1,
          // parent cluster id
          1
          // number of points in a cluster
        ), this.options.reduce && a.push(0);
      }
    }
    var h = this.trees[o + 1] = this._createTree(a);
    n && console.timeEnd(i);
    for (var f = o; f >= r; f--) {
      var m = +Date.now();
      h = this.trees[f] = this._createTree(this._cluster(h, f)), n && console.log("z%d: %d clusters in %dms", f, h.numItems, +Date.now() - m);
    }
    return n && console.timeEnd("total time"), this;
  }
  getClusters(t, n) {
    var r = ((t[0] + 180) % 360 + 360) % 360 - 180, o = Math.max(-90, Math.min(90, t[1])), i = t[2] === 180 ? 180 : ((t[2] + 180) % 360 + 360) % 360 - 180, a = Math.max(-90, Math.min(90, t[3]));
    if (t[2] - t[0] >= 360)
      r = -180, i = 180;
    else if (r > i) {
      var s = this.getClusters([r, o, 180, a], n), l = this.getClusters([-180, o, i, a], n);
      return s.concat(l);
    }
    var u = this.trees[this._limitZoom(n)], c = u.range(zf(r), Uf(a), zf(i), Uf(o)), p = u.data, d = [];
    for (var h of c) {
      var f = this.stride * h;
      d.push(p[f + Zs] > 1 ? hB(p, f, this.clusterProps) : this.points[p[f + Qs]]);
    }
    return d;
  }
  getChildren(t) {
    var n = this._getOriginId(t), r = this._getOriginZoom(t), o = "No cluster with the specified id.", i = this.trees[r];
    if (!i) throw new Error(o);
    var a = i.data;
    if (n * this.stride >= a.length) throw new Error(o);
    var s = this.options.radius / (this.options.extent * Math.pow(2, r - 1)), l = a[n * this.stride], u = a[n * this.stride + 1], c = i.within(l, u, s), p = [];
    for (var d of c) {
      var h = d * this.stride;
      a[h + k0] === t && p.push(a[h + Zs] > 1 ? hB(a, h, this.clusterProps) : this.points[a[h + Qs]]);
    }
    if (p.length === 0) throw new Error(o);
    return p;
  }
  getLeaves(t, n, r) {
    n = n || 10, r = r || 0;
    var o = [];
    return this._appendLeaves(o, t, n, r, 0), o;
  }
  getTile(t, n, r) {
    var o = this.trees[this._limitZoom(t)], i = Math.pow(2, t), {
      extent: a,
      radius: s
    } = this.options, l = s / a, u = (r - l) / i, c = (r + 1 + l) / i, p = {
      features: []
    };
    return this._addTileFeatures(o.range((n - l) / i, u, (n + 1 + l) / i, c), o.data, n, r, i, p), n === 0 && this._addTileFeatures(o.range(1 - l / i, u, 1, c), o.data, i, r, i, p), n === i - 1 && this._addTileFeatures(o.range(0, u, l / i, c), o.data, -1, r, i, p), p.features.length ? p : null;
  }
  getClusterExpansionZoom(t) {
    for (var n = this._getOriginZoom(t) - 1; n <= this.options.maxZoom; ) {
      var r = this.getChildren(t);
      if (n++, r.length !== 1) break;
      t = r[0].properties.cluster_id;
    }
    return n;
  }
  _appendLeaves(t, n, r, o, i) {
    var a = this.getChildren(n);
    for (var s of a) {
      var l = s.properties;
      if (l && l.cluster ? i + l.point_count <= o ? i += l.point_count : i = this._appendLeaves(t, l.cluster_id, r, o, i) : i < o ? i++ : t.push(s), t.length === r) break;
    }
    return i;
  }
  _createTree(t) {
    for (var n = new Dk(t.length / this.stride | 0, this.options.nodeSize, Float32Array), r = 0; r < t.length; r += this.stride) n.add(t[r], t[r + 1]);
    return n.finish(), n.data = t, n;
  }
  _addTileFeatures(t, n, r, o, i, a) {
    for (var s of t) {
      var l = s * this.stride, u = n[l + Zs] > 1, c = void 0, p = void 0, d = void 0;
      if (u)
        c = q9(n, l, this.clusterProps), p = n[l], d = n[l + 1];
      else {
        var h = this.points[n[l + Qs]];
        c = h.properties;
        var [f, m] = h.geometry.coordinates;
        p = zf(f), d = Uf(m);
      }
      var g = {
        type: 1,
        geometry: [[Math.round(this.options.extent * (p * i - r)), Math.round(this.options.extent * (d * i - o))]],
        tags: c
      }, E = void 0;
      u || this.options.generateId ? E = n[l + Qs] : E = this.points[n[l + Qs]].id, E !== void 0 && (g.id = E), a.features.push(g);
    }
  }
  _limitZoom(t) {
    return Math.max(this.options.minZoom, Math.min(Math.floor(+t), this.options.maxZoom + 1));
  }
  _cluster(t, n) {
    for (var {
      radius: r,
      extent: o,
      reduce: i,
      minPoints: a
    } = this.options, s = r / (o * Math.pow(2, n)), l = t.data, u = [], c = this.stride, p = 0; p < l.length; p += c)
      if (!(l[p + Fa] <= n)) {
        l[p + Fa] = n;
        var d = l[p], h = l[p + 1], f = t.within(l[p], l[p + 1], s), m = l[p + Zs], g = m;
        for (var E of f) {
          var w = E * c;
          l[w + Fa] > n && (g += l[w + Zs]);
        }
        if (g > m && g >= a) {
          var M = d * m, x = h * m, y = void 0, C = -1, P = ((p / c | 0) << 5) + (n + 1) + this.points.length;
          for (var F of f) {
            var L = F * c;
            if (!(l[L + Fa] <= n)) {
              l[L + Fa] = n;
              var N = l[L + Zs];
              M += l[L] * N, x += l[L + 1] * N, l[L + k0] = P, i && (y || (y = this._map(l, p, !0), C = this.clusterProps.length, this.clusterProps.push(y)), i(y, this._map(l, L)));
            }
          }
          l[p + k0] = P, u.push(M / g, x / g, 1 / 0, P, -1, g), i && u.push(C);
        } else {
          for (var I = 0; I < c; I++) u.push(l[p + I]);
          if (g > 1)
            for (var H of f) {
              var V = H * c;
              if (!(l[V + Fa] <= n)) {
                l[V + Fa] = n;
                for (var z = 0; z < c; z++) u.push(l[V + z]);
              }
            }
        }
      }
    return u;
  }
  // get index of the point from which the cluster originated
  _getOriginId(t) {
    return t - this.points.length >> 5;
  }
  // get zoom of the point from which the cluster originated
  _getOriginZoom(t) {
    return (t - this.points.length) % 32;
  }
  _map(t, n, r) {
    if (t[n + Zs] > 1) {
      var o = this.clusterProps[t[n + V9]];
      return r ? Object.assign({}, o) : o;
    }
    var i = this.points[t[n + Qs]].properties, a = this.options.map(i);
    return r && a === i ? Object.assign({}, a) : a;
  }
}
function hB(e, t, n) {
  return {
    type: "Feature",
    id: e[t + Qs],
    properties: q9(e, t, n),
    geometry: {
      type: "Point",
      coordinates: [zve(e[t]), Uve(e[t + 1])]
    }
  };
}
function q9(e, t, n) {
  var r = e[t + Zs], o = r >= 1e4 ? "".concat(Math.round(r / 1e3), "k") : r >= 1e3 ? "".concat(Math.round(r / 100) / 10, "k") : r, i = e[t + V9], a = i === -1 ? {} : Object.assign({}, n[i]);
  return Object.assign(a, {
    cluster: !0,
    cluster_id: e[t + Qs],
    point_count: r,
    point_count_abbreviated: o
  });
}
function zf(e) {
  return e / 360 + 0.5;
}
function Uf(e) {
  var t = Math.sin(e * Math.PI / 180), n = 0.5 - 0.25 * Math.log((1 + t) / (1 - t)) / Math.PI;
  return n < 0 ? 0 : n > 1 ? 1 : n;
}
function zve(e) {
  return (e - 0.5) * 360;
}
function Uve(e) {
  var t = (180 - e * 360) * Math.PI / 180;
  return 360 * Math.atan(Math.exp(t)) / Math.PI - 90;
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function $ve(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
    t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
  return n;
}
class Xo {
  static isAdvancedMarkerAvailable(t) {
    return google.maps.marker && t.getMapCapabilities().isAdvancedMarkersAvailable === !0;
  }
  static isAdvancedMarker(t) {
    return google.maps.marker && t instanceof google.maps.marker.AdvancedMarkerElement;
  }
  static setMap(t, n) {
    this.isAdvancedMarker(t) ? t.map = n : t.setMap(n);
  }
  static getPosition(t) {
    if (this.isAdvancedMarker(t)) {
      if (t.position) {
        if (t.position instanceof google.maps.LatLng)
          return t.position;
        if (t.position.lat && t.position.lng)
          return new google.maps.LatLng(t.position.lat, t.position.lng);
      }
      return new google.maps.LatLng(null);
    }
    return t.getPosition();
  }
  static getVisible(t) {
    return this.isAdvancedMarker(t) ? !0 : t.getVisible();
  }
}
class hx {
  constructor(t) {
    var {
      markers: n,
      position: r
    } = t;
    this.markers = n, r && (r instanceof google.maps.LatLng ? this._position = r : this._position = new google.maps.LatLng(r));
  }
  get bounds() {
    if (!(this.markers.length === 0 && !this._position)) {
      var t = new google.maps.LatLngBounds(this._position, this._position);
      for (var n of this.markers)
        t.extend(Xo.getPosition(n));
      return t;
    }
  }
  get position() {
    return this._position || this.bounds.getCenter();
  }
  /**
   * Get the count of **visible** markers.
   */
  get count() {
    return this.markers.filter((t) => Xo.getVisible(t)).length;
  }
  /**
   * Add a marker to the cluster.
   */
  push(t) {
    this.markers.push(t);
  }
  /**
   * Cleanup references and remove marker from map.
   */
  delete() {
    this.marker && (Xo.setMap(this.marker, null), this.marker = void 0), this.markers.length = 0;
  }
}
class Hve {
  constructor(t) {
    var {
      maxZoom: n = 16
    } = t;
    this.maxZoom = n;
  }
  /**
   * Helper function to bypass clustering based upon some map state such as
   * zoom, number of markers, etc.
   *
   * ```typescript
   *  cluster({markers, map}: AlgorithmInput): Cluster[] {
   *    if (shouldBypassClustering(map)) {
   *      return this.noop({markers})
   *    }
   * }
   * ```
   */
  noop(t) {
    var {
      markers: n
    } = t;
    return Wve(n);
  }
}
var Wve = (e) => {
  var t = e.map((n) => new hx({
    position: Xo.getPosition(n),
    markers: [n]
  }));
  return t;
};
class Vve extends Hve {
  constructor(t) {
    var {
      maxZoom: n,
      radius: r = 60
    } = t, o = $ve(t, ["maxZoom", "radius"]);
    super({
      maxZoom: n
    }), this.state = {
      zoom: -1
    }, this.superCluster = new Fve(Object.assign({
      maxZoom: this.maxZoom,
      radius: r
    }, o));
  }
  calculate(t) {
    var n = !1, r = {
      zoom: t.map.getZoom()
    };
    if (!cB(t.markers, this.markers)) {
      n = !0, this.markers = [...t.markers];
      var o = this.markers.map((i) => {
        var a = Xo.getPosition(i), s = [a.lng(), a.lat()];
        return {
          type: "Feature",
          geometry: {
            type: "Point",
            coordinates: s
          },
          properties: {
            marker: i
          }
        };
      });
      this.superCluster.load(o);
    }
    return n || (this.state.zoom <= this.maxZoom || r.zoom <= this.maxZoom) && (n = !cB(this.state, r)), this.state = r, n && (this.clusters = this.cluster(t)), {
      clusters: this.clusters,
      changed: n
    };
  }
  cluster(t) {
    var {
      map: n
    } = t;
    return this.superCluster.getClusters([-180, -90, 180, 90], Math.round(n.getZoom())).map((r) => this.transformCluster(r));
  }
  transformCluster(t) {
    var {
      geometry: {
        coordinates: [n, r]
      },
      properties: o
    } = t;
    if (o.cluster)
      return new hx({
        markers: this.superCluster.getLeaves(o.cluster_id, 1 / 0).map((a) => a.properties.marker),
        position: {
          lat: r,
          lng: n
        }
      });
    var i = o.marker;
    return new hx({
      markers: [i],
      position: Xo.getPosition(i)
    });
  }
}
class qve {
  constructor(t, n) {
    this.markers = {
      sum: t.length
    };
    var r = n.map((i) => i.count), o = r.reduce((i, a) => i + a, 0);
    this.clusters = {
      count: n.length,
      markers: {
        mean: o / n.length,
        sum: o,
        min: Math.min(...r),
        max: Math.max(...r)
      }
    };
  }
}
class Zve {
  /**
   * The default render function for the library used by {@link MarkerClusterer}.
   *
   * Currently set to use the following:
   *
   * ```typescript
   * // change color if this cluster has more markers than the mean cluster
   * const color =
   *   count > Math.max(10, stats.clusters.markers.mean)
   *     ? "#ff0000"
   *     : "#0000ff";
   *
   * // create svg url with fill color
   * const svg = window.btoa(`
   * <svg fill="${color}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240">
   *   <circle cx="120" cy="120" opacity=".6" r="70" />
   *   <circle cx="120" cy="120" opacity=".3" r="90" />
   *   <circle cx="120" cy="120" opacity=".2" r="110" />
   *   <circle cx="120" cy="120" opacity=".1" r="130" />
   * </svg>`);
   *
   * // create marker using svg icon
   * return new google.maps.Marker({
   *   position,
   *   icon: {
   *     url: `data:image/svg+xml;base64,${svg}`,
   *     scaledSize: new google.maps.Size(45, 45),
   *   },
   *   label: {
   *     text: String(count),
   *     color: "rgba(255,255,255,0.9)",
   *     fontSize: "12px",
   *   },
   *   // adjust zIndex to be above other markers
   *   zIndex: 1000 + count,
   * });
   * ```
   */
  render(t, n, r) {
    var {
      count: o,
      position: i
    } = t, a = o > Math.max(10, n.clusters.markers.mean) ? "#ff0000" : "#0000ff", s = '<svg fill="'.concat(a, `" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" width="50" height="50">
<circle cx="120" cy="120" opacity=".6" r="70" />
<circle cx="120" cy="120" opacity=".3" r="90" />
<circle cx="120" cy="120" opacity=".2" r="110" />
<text x="50%" y="50%" style="fill:#fff" text-anchor="middle" font-size="50" dominant-baseline="middle" font-family="roboto,arial,sans-serif">`).concat(o, `</text>
</svg>`), l = "Cluster of ".concat(o, " markers"), u = Number(google.maps.Marker.MAX_ZINDEX) + o;
    if (Xo.isAdvancedMarkerAvailable(r)) {
      var c = new DOMParser(), p = c.parseFromString(s, "image/svg+xml").documentElement;
      p.setAttribute("transform", "translate(0 25)");
      var d = {
        map: r,
        position: i,
        zIndex: u,
        title: l,
        content: p
      };
      return new google.maps.marker.AdvancedMarkerElement(d);
    }
    var h = {
      position: i,
      zIndex: u,
      title: l,
      icon: {
        url: "data:image/svg+xml;base64,".concat(btoa(s)),
        anchor: new google.maps.Point(25, 25)
      }
    };
    return new google.maps.Marker(h);
  }
}
function Gve(e, t) {
  for (var n in t.prototype)
    e.prototype[n] = t.prototype[n];
}
class Tk {
  constructor() {
    Gve(Tk, google.maps.OverlayView);
  }
}
var Nc;
(function(e) {
  e.CLUSTERING_BEGIN = "clusteringbegin", e.CLUSTERING_END = "clusteringend", e.CLUSTER_CLICK = "click";
})(Nc || (Nc = {}));
var Xve = (e, t, n) => {
  n.fitBounds(t.bounds);
};
class Kve extends Tk {
  constructor(t) {
    var {
      map: n,
      markers: r = [],
      algorithmOptions: o = {},
      algorithm: i = new Vve(o),
      renderer: a = new Zve(),
      onClusterClick: s = Xve
    } = t;
    super(), this.markers = [...r], this.clusters = [], this.algorithm = i, this.renderer = a, this.onClusterClick = s, n && this.setMap(n);
  }
  addMarker(t, n) {
    this.markers.includes(t) || (this.markers.push(t), n || this.render());
  }
  addMarkers(t, n) {
    t.forEach((r) => {
      this.addMarker(r, !0);
    }), n || this.render();
  }
  removeMarker(t, n) {
    var r = this.markers.indexOf(t);
    return r === -1 ? !1 : (Xo.setMap(t, null), this.markers.splice(r, 1), n || this.render(), !0);
  }
  removeMarkers(t, n) {
    var r = !1;
    return t.forEach((o) => {
      r = this.removeMarker(o, !0) || r;
    }), r && !n && this.render(), r;
  }
  clearMarkers(t) {
    this.markers.length = 0, t || this.render();
  }
  /**
   * Recalculates and draws all the marker clusters.
   */
  render() {
    var t = this.getMap();
    if (t instanceof google.maps.Map && t.getProjection()) {
      google.maps.event.trigger(this, Nc.CLUSTERING_BEGIN, this);
      var {
        clusters: n,
        changed: r
      } = this.algorithm.calculate({
        markers: this.markers,
        map: t,
        mapCanvasProjection: this.getProjection()
      });
      if (r || r == null) {
        var o = /* @__PURE__ */ new Set();
        for (var i of n)
          i.markers.length == 1 && o.add(i.markers[0]);
        var a = [];
        for (var s of this.clusters)
          s.marker != null && (s.markers.length == 1 ? o.has(s.marker) || Xo.setMap(s.marker, null) : a.push(s.marker));
        this.clusters = n, this.renderClusters(), requestAnimationFrame(() => a.forEach((l) => Xo.setMap(l, null)));
      }
      google.maps.event.trigger(this, Nc.CLUSTERING_END, this);
    }
  }
  onAdd() {
    this.idleListener = this.getMap().addListener("idle", this.render.bind(this)), this.render();
  }
  onRemove() {
    google.maps.event.removeListener(this.idleListener), this.reset();
  }
  reset() {
    this.markers.forEach((t) => Xo.setMap(t, null)), this.clusters.forEach((t) => t.delete()), this.clusters = [];
  }
  renderClusters() {
    var t = new qve(this.markers, this.clusters), n = this.getMap();
    this.clusters.forEach((r) => {
      r.markers.length === 1 ? r.marker = r.markers[0] : (r.marker = this.renderer.render(r, t, n), r.markers.forEach((o) => Xo.setMap(o, null)), this.onClusterClick && r.marker.addListener(
        "click",
        /* istanbul ignore next */
        (o) => {
          google.maps.event.trigger(this, Nc.CLUSTER_CLICK, r), this.onClusterClick(o, r, n);
        }
      )), Xo.setMap(r.marker, n);
    });
  }
}
function gB(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function mB(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? gB(Object(n), !0).forEach(function(r) {
      Ce(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : gB(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function Yve(e) {
  var t = Xme(), [n, r] = k(null);
  return v(() => {
    if (t && n === null) {
      var o = new Kve(mB(mB({}, e), {}, {
        map: t
      }));
      r(o);
    }
  }, [t]), n;
}
function Jve(e) {
  var {
    children: t,
    options: n
  } = e, r = Yve(n);
  return r !== null ? t(r) : null;
}
Ee(Jve);
var vB = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, yB = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
function Qve(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, h = ye(Mt), [f, m] = k(null), [g, E] = k(null), [w, M] = k(null), [x, y] = k(null), [C, P] = k(null), [F, L] = k(null), N = rt(null);
  return v(() => {
    f !== null && (f.close(), n ? f.open(h, n) : f.getPosition() && f.open(h));
  }, [h, f, n]), v(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), v(() => {
    o && f !== null && f.setPosition(o);
  }, [o]), v(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), v(() => {
    f && a && (g !== null && google.maps.event.removeListener(g), E(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), v(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), M(google.maps.event.addListener(f, "domready", s)));
  }, [s]), v(() => {
    f && l && (x !== null && google.maps.event.removeListener(x), y(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), v(() => {
    f && u && (C !== null && google.maps.event.removeListener(C), P(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), v(() => {
    f && c && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), v(() => {
    var I = new google.maps.InfoWindow(r);
    return m(I), N.current = document.createElement("div"), a && E(google.maps.event.addListener(I, "closeclick", a)), s && M(google.maps.event.addListener(I, "domready", s)), l && y(google.maps.event.addListener(I, "content_changed", l)), u && P(google.maps.event.addListener(I, "position_changed", u)), c && L(google.maps.event.addListener(I, "zindex_changed", c)), I.setContent(N.current), o && I.setPosition(o), i && I.setZIndex(i), n ? I.open(h, n) : I.getPosition() ? I.open(h) : Gr(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>."), p && p(I), () => {
      g && google.maps.event.removeListener(g), x && google.maps.event.removeListener(x), w && google.maps.event.removeListener(w), C && google.maps.event.removeListener(C), F && google.maps.event.removeListener(F), d && d(I), I.close();
    };
  }, []), N.current ? yr(at.only(t), N.current) : null;
}
Ee(Qve);
class eye extends pe {
  constructor() {
    super(...arguments), Ce(this, "registeredEvents", []), Ce(this, "containerElement", null), Ce(this, "state", {
      infoWindow: null
    }), Ce(this, "open", (t, n) => {
      n ? t.open(this.context, n) : t.getPosition() ? t.open(this.context) : Gr(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>.");
    }), Ce(this, "setInfoWindowCallback", () => {
      this.state.infoWindow !== null && this.containerElement !== null && (this.state.infoWindow.setContent(this.containerElement), this.open(this.state.infoWindow, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoWindow));
    });
  }
  componentDidMount() {
    var t = new google.maps.InfoWindow(this.props.options);
    this.containerElement = document.createElement("div"), this.registeredEvents = en({
      updaterMap: yB,
      eventMap: vB,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(() => ({
      infoWindow: t
    }), this.setInfoWindowCallback);
  }
  componentDidUpdate(t) {
    this.state.infoWindow !== null && (an(this.registeredEvents), this.registeredEvents = en({
      updaterMap: yB,
      eventMap: vB,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.infoWindow
    }));
  }
  componentWillUnmount() {
    this.state.infoWindow !== null && (an(this.registeredEvents), this.props.onUnmount && this.props.onUnmount(this.state.infoWindow), this.state.infoWindow.close());
  }
  render() {
    return this.containerElement ? yr(at.only(this.props.children), this.containerElement) : null;
  }
}
Ce(eye, "contextType", Mt);
function bB(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Vg(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? bB(Object(n), !0).forEach(function(r) {
      Ce(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : bB(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var wB = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, CB = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, tye = {};
function nye(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: h,
    onRightClick: f,
    onClick: m,
    onDrag: g,
    onLoad: E,
    onUnmount: w
  } = e, M = ye(Mt), [x, y] = k(null), [C, P] = k(null), [F, L] = k(null), [N, I] = k(null), [H, V] = k(null), [z, q] = k(null), [K, J] = k(null), [te, ee] = k(null), [_, D] = k(null), [$, S] = k(null), [W, O] = k(null), [T, U] = k(null);
  return v(() => {
    x !== null && x.setMap(M);
  }, [M]), v(() => {
    typeof t < "u" && x !== null && x.setOptions(t);
  }, [x, t]), v(() => {
    typeof n < "u" && x !== null && x.setDraggable(n);
  }, [x, n]), v(() => {
    typeof r < "u" && x !== null && x.setEditable(r);
  }, [x, r]), v(() => {
    typeof o < "u" && x !== null && x.setVisible(o);
  }, [x, o]), v(() => {
    typeof i < "u" && x !== null && x.setPath(i);
  }, [x, i]), v(() => {
    x && a && (C !== null && google.maps.event.removeListener(C), P(google.maps.event.addListener(x, "dblclick", a)));
  }, [a]), v(() => {
    x && s && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(x, "dragend", s)));
  }, [s]), v(() => {
    x && l && (N !== null && google.maps.event.removeListener(N), I(google.maps.event.addListener(x, "dragstart", l)));
  }, [l]), v(() => {
    x && u && (H !== null && google.maps.event.removeListener(H), V(google.maps.event.addListener(x, "mousedown", u)));
  }, [u]), v(() => {
    x && c && (z !== null && google.maps.event.removeListener(z), q(google.maps.event.addListener(x, "mousemove", c)));
  }, [c]), v(() => {
    x && p && (K !== null && google.maps.event.removeListener(K), J(google.maps.event.addListener(x, "mouseout", p)));
  }, [p]), v(() => {
    x && d && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(x, "mouseover", d)));
  }, [d]), v(() => {
    x && h && (_ !== null && google.maps.event.removeListener(_), D(google.maps.event.addListener(x, "mouseup", h)));
  }, [h]), v(() => {
    x && f && ($ !== null && google.maps.event.removeListener($), S(google.maps.event.addListener(x, "rightclick", f)));
  }, [f]), v(() => {
    x && m && (W !== null && google.maps.event.removeListener(W), O(google.maps.event.addListener(x, "click", m)));
  }, [m]), v(() => {
    x && g && (T !== null && google.maps.event.removeListener(T), U(google.maps.event.addListener(x, "drag", g)));
  }, [g]), v(() => {
    var j = new google.maps.Polyline(Vg(Vg({}, t || tye), {}, {
      map: M
    }));
    return i && j.setPath(i), typeof o < "u" && j.setVisible(o), typeof r < "u" && j.setEditable(r), typeof n < "u" && j.setDraggable(n), a && P(google.maps.event.addListener(j, "dblclick", a)), s && L(google.maps.event.addListener(j, "dragend", s)), l && I(google.maps.event.addListener(j, "dragstart", l)), u && V(google.maps.event.addListener(j, "mousedown", u)), c && q(google.maps.event.addListener(j, "mousemove", c)), p && J(google.maps.event.addListener(j, "mouseout", p)), d && ee(google.maps.event.addListener(j, "mouseover", d)), h && D(google.maps.event.addListener(j, "mouseup", h)), f && S(google.maps.event.addListener(j, "rightclick", f)), m && O(google.maps.event.addListener(j, "click", m)), g && U(google.maps.event.addListener(j, "drag", g)), y(j), E && E(j), () => {
      C !== null && google.maps.event.removeListener(C), F !== null && google.maps.event.removeListener(F), N !== null && google.maps.event.removeListener(N), H !== null && google.maps.event.removeListener(H), z !== null && google.maps.event.removeListener(z), K !== null && google.maps.event.removeListener(K), te !== null && google.maps.event.removeListener(te), _ !== null && google.maps.event.removeListener(_), $ !== null && google.maps.event.removeListener($), W !== null && google.maps.event.removeListener(W), w && w(j), j.setMap(null);
    };
  }, []), null;
}
Ee(nye);
class rye extends pe {
  constructor() {
    super(...arguments), Ce(this, "registeredEvents", []), Ce(this, "state", {
      polyline: null
    }), Ce(this, "setPolylineCallback", () => {
      this.state.polyline !== null && this.props.onLoad && this.props.onLoad(this.state.polyline);
    });
  }
  componentDidMount() {
    var t = new google.maps.Polyline(Vg(Vg({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = en({
      updaterMap: CB,
      eventMap: wB,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        polyline: t
      };
    }, this.setPolylineCallback);
  }
  componentDidUpdate(t) {
    this.state.polyline !== null && (an(this.registeredEvents), this.registeredEvents = en({
      updaterMap: CB,
      eventMap: wB,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.polyline
    }));
  }
  componentWillUnmount() {
    this.state.polyline !== null && (this.props.onUnmount && this.props.onUnmount(this.state.polyline), an(this.registeredEvents), this.state.polyline.setMap(null));
  }
  render() {
    return null;
  }
}
Ce(rye, "contextType", Mt);
function xB(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function OB(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? xB(Object(n), !0).forEach(function(r) {
      Ce(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : xB(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var EB = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, kB = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  paths(e, t) {
    e.setPaths(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function oye(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    paths: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: h,
    onMouseUp: f,
    onRightClick: m,
    onClick: g,
    onDrag: E,
    onLoad: w,
    onUnmount: M,
    onEdit: x
  } = e, y = ye(Mt), [C, P] = k(null), [F, L] = k(null), [N, I] = k(null), [H, V] = k(null), [z, q] = k(null), [K, J] = k(null), [te, ee] = k(null), [_, D] = k(null), [$, S] = k(null), [W, O] = k(null), [T, U] = k(null), [j, Z] = k(null);
  return v(() => {
    C !== null && C.setMap(y);
  }, [y]), v(() => {
    typeof t < "u" && C !== null && C.setOptions(t);
  }, [C, t]), v(() => {
    typeof n < "u" && C !== null && C.setDraggable(n);
  }, [C, n]), v(() => {
    typeof r < "u" && C !== null && C.setEditable(r);
  }, [C, r]), v(() => {
    typeof o < "u" && C !== null && C.setVisible(o);
  }, [C, o]), v(() => {
    typeof i < "u" && C !== null && C.setPath(i);
  }, [C, i]), v(() => {
    typeof a < "u" && C !== null && C.setPaths(a);
  }, [C, a]), v(() => {
    C && typeof s == "function" && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(C, "dblclick", s)));
  }, [s]), v(() => {
    C && (google.maps.event.addListener(C.getPath(), "insert_at", () => {
      x == null || x(C);
    }), google.maps.event.addListener(C.getPath(), "set_at", () => {
      x == null || x(C);
    }), google.maps.event.addListener(C.getPath(), "remove_at", () => {
      x == null || x(C);
    }));
  }, [C, x]), v(() => {
    C && typeof l == "function" && (N !== null && google.maps.event.removeListener(N), I(google.maps.event.addListener(C, "dragend", l)));
  }, [l]), v(() => {
    C && typeof u == "function" && (H !== null && google.maps.event.removeListener(H), V(google.maps.event.addListener(C, "dragstart", u)));
  }, [u]), v(() => {
    C && typeof c == "function" && (z !== null && google.maps.event.removeListener(z), q(google.maps.event.addListener(C, "mousedown", c)));
  }, [c]), v(() => {
    C && typeof p == "function" && (K !== null && google.maps.event.removeListener(K), J(google.maps.event.addListener(C, "mousemove", p)));
  }, [p]), v(() => {
    C && typeof d == "function" && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(C, "mouseout", d)));
  }, [d]), v(() => {
    C && typeof h == "function" && (_ !== null && google.maps.event.removeListener(_), D(google.maps.event.addListener(C, "mouseover", h)));
  }, [h]), v(() => {
    C && typeof f == "function" && ($ !== null && google.maps.event.removeListener($), S(google.maps.event.addListener(C, "mouseup", f)));
  }, [f]), v(() => {
    C && typeof m == "function" && (W !== null && google.maps.event.removeListener(W), O(google.maps.event.addListener(C, "rightclick", m)));
  }, [m]), v(() => {
    C && typeof g == "function" && (T !== null && google.maps.event.removeListener(T), U(google.maps.event.addListener(C, "click", g)));
  }, [g]), v(() => {
    C && typeof E == "function" && (j !== null && google.maps.event.removeListener(j), Z(google.maps.event.addListener(C, "drag", E)));
  }, [E]), v(() => {
    var A = new google.maps.Polygon(OB(OB({}, t), {}, {
      map: y
    }));
    return i && A.setPath(i), a && A.setPaths(a), typeof o < "u" && A.setVisible(o), typeof r < "u" && A.setEditable(r), typeof n < "u" && A.setDraggable(n), s && L(google.maps.event.addListener(A, "dblclick", s)), l && I(google.maps.event.addListener(A, "dragend", l)), u && V(google.maps.event.addListener(A, "dragstart", u)), c && q(google.maps.event.addListener(A, "mousedown", c)), p && J(google.maps.event.addListener(A, "mousemove", p)), d && ee(google.maps.event.addListener(A, "mouseout", d)), h && D(google.maps.event.addListener(A, "mouseover", h)), f && S(google.maps.event.addListener(A, "mouseup", f)), m && O(google.maps.event.addListener(A, "rightclick", m)), g && U(google.maps.event.addListener(A, "click", g)), E && Z(google.maps.event.addListener(A, "drag", E)), P(A), w && w(A), () => {
      F !== null && google.maps.event.removeListener(F), N !== null && google.maps.event.removeListener(N), H !== null && google.maps.event.removeListener(H), z !== null && google.maps.event.removeListener(z), K !== null && google.maps.event.removeListener(K), te !== null && google.maps.event.removeListener(te), _ !== null && google.maps.event.removeListener(_), $ !== null && google.maps.event.removeListener($), W !== null && google.maps.event.removeListener(W), T !== null && google.maps.event.removeListener(T), M && M(A), A.setMap(null);
    };
  }, []), null;
}
Ee(oye);
class iye extends pe {
  constructor() {
    super(...arguments), Ce(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this.props.options || {};
    this.polygon = new google.maps.Polygon(t), this.polygon.setMap(this.context), this.registeredEvents = en({
      updaterMap: kB,
      eventMap: EB,
      prevProps: {},
      nextProps: this.props,
      instance: this.polygon
    }), this.props.onLoad && this.props.onLoad(this.polygon);
  }
  componentDidUpdate(t) {
    this.polygon && (an(this.registeredEvents), this.registeredEvents = en({
      updaterMap: kB,
      eventMap: EB,
      prevProps: t,
      nextProps: this.props,
      instance: this.polygon
    }));
  }
  componentWillUnmount() {
    this.polygon && (this.props.onUnmount && this.props.onUnmount(this.polygon), an(this.registeredEvents), this.polygon && this.polygon.setMap(null));
  }
  render() {
    return null;
  }
}
Ce(iye, "contextType", Mt);
function LB(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function qg(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? LB(Object(n), !0).forEach(function(r) {
      Ce(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : LB(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var _B = {
  onBoundsChanged: "bounds_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, PB = {
  bounds(e, t) {
    e.setBounds(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function sye(e) {
  var {
    options: t,
    bounds: n,
    draggable: r,
    editable: o,
    visible: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: h,
    onRightClick: f,
    onClick: m,
    onDrag: g,
    onBoundsChanged: E,
    onLoad: w,
    onUnmount: M
  } = e, x = ye(Mt), [y, C] = k(null), [P, F] = k(null), [L, N] = k(null), [I, H] = k(null), [V, z] = k(null), [q, K] = k(null), [J, te] = k(null), [ee, _] = k(null), [D, $] = k(null), [S, W] = k(null), [O, T] = k(null), [U, j] = k(null), [Z, A] = k(null);
  return v(() => {
    y !== null && y.setMap(x);
  }, [x]), v(() => {
    typeof t < "u" && y !== null && y.setOptions(t);
  }, [y, t]), v(() => {
    typeof r < "u" && y !== null && y.setDraggable(r);
  }, [y, r]), v(() => {
    typeof o < "u" && y !== null && y.setEditable(o);
  }, [y, o]), v(() => {
    typeof i < "u" && y !== null && y.setVisible(i);
  }, [y, i]), v(() => {
    typeof n < "u" && y !== null && y.setBounds(n);
  }, [y, n]), v(() => {
    y && a && (P !== null && google.maps.event.removeListener(P), F(google.maps.event.addListener(y, "dblclick", a)));
  }, [a]), v(() => {
    y && s && (L !== null && google.maps.event.removeListener(L), N(google.maps.event.addListener(y, "dragend", s)));
  }, [s]), v(() => {
    y && l && (I !== null && google.maps.event.removeListener(I), H(google.maps.event.addListener(y, "dragstart", l)));
  }, [l]), v(() => {
    y && u && (V !== null && google.maps.event.removeListener(V), z(google.maps.event.addListener(y, "mousedown", u)));
  }, [u]), v(() => {
    y && c && (q !== null && google.maps.event.removeListener(q), K(google.maps.event.addListener(y, "mousemove", c)));
  }, [c]), v(() => {
    y && p && (J !== null && google.maps.event.removeListener(J), te(google.maps.event.addListener(y, "mouseout", p)));
  }, [p]), v(() => {
    y && d && (ee !== null && google.maps.event.removeListener(ee), _(google.maps.event.addListener(y, "mouseover", d)));
  }, [d]), v(() => {
    y && h && (D !== null && google.maps.event.removeListener(D), $(google.maps.event.addListener(y, "mouseup", h)));
  }, [h]), v(() => {
    y && f && (S !== null && google.maps.event.removeListener(S), W(google.maps.event.addListener(y, "rightclick", f)));
  }, [f]), v(() => {
    y && m && (O !== null && google.maps.event.removeListener(O), T(google.maps.event.addListener(y, "click", m)));
  }, [m]), v(() => {
    y && g && (U !== null && google.maps.event.removeListener(U), j(google.maps.event.addListener(y, "drag", g)));
  }, [g]), v(() => {
    y && E && (Z !== null && google.maps.event.removeListener(Z), A(google.maps.event.addListener(y, "bounds_changed", E)));
  }, [E]), v(() => {
    var Q = new google.maps.Rectangle(qg(qg({}, t), {}, {
      map: x
    }));
    return typeof i < "u" && Q.setVisible(i), typeof o < "u" && Q.setEditable(o), typeof r < "u" && Q.setDraggable(r), typeof n < "u" && Q.setBounds(n), a && F(google.maps.event.addListener(Q, "dblclick", a)), s && N(google.maps.event.addListener(Q, "dragend", s)), l && H(google.maps.event.addListener(Q, "dragstart", l)), u && z(google.maps.event.addListener(Q, "mousedown", u)), c && K(google.maps.event.addListener(Q, "mousemove", c)), p && te(google.maps.event.addListener(Q, "mouseout", p)), d && _(google.maps.event.addListener(Q, "mouseover", d)), h && $(google.maps.event.addListener(Q, "mouseup", h)), f && W(google.maps.event.addListener(Q, "rightclick", f)), m && T(google.maps.event.addListener(Q, "click", m)), g && j(google.maps.event.addListener(Q, "drag", g)), E && A(google.maps.event.addListener(Q, "bounds_changed", E)), C(Q), w && w(Q), () => {
      P !== null && google.maps.event.removeListener(P), L !== null && google.maps.event.removeListener(L), I !== null && google.maps.event.removeListener(I), V !== null && google.maps.event.removeListener(V), q !== null && google.maps.event.removeListener(q), J !== null && google.maps.event.removeListener(J), ee !== null && google.maps.event.removeListener(ee), D !== null && google.maps.event.removeListener(D), S !== null && google.maps.event.removeListener(S), O !== null && google.maps.event.removeListener(O), U !== null && google.maps.event.removeListener(U), Z !== null && google.maps.event.removeListener(Z), M && M(Q), Q.setMap(null);
    };
  }, []), null;
}
Ee(sye);
class aye extends pe {
  constructor() {
    super(...arguments), Ce(this, "registeredEvents", []), Ce(this, "state", {
      rectangle: null
    }), Ce(this, "setRectangleCallback", () => {
      this.state.rectangle !== null && this.props.onLoad && this.props.onLoad(this.state.rectangle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Rectangle(qg(qg({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = en({
      updaterMap: PB,
      eventMap: _B,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        rectangle: t
      };
    }, this.setRectangleCallback);
  }
  componentDidUpdate(t) {
    this.state.rectangle !== null && (an(this.registeredEvents), this.registeredEvents = en({
      updaterMap: PB,
      eventMap: _B,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.rectangle
    }));
  }
  componentWillUnmount() {
    this.state.rectangle !== null && (this.props.onUnmount && this.props.onUnmount(this.state.rectangle), an(this.registeredEvents), this.state.rectangle.setMap(null));
  }
  render() {
    return null;
  }
}
Ce(aye, "contextType", Mt);
function SB(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Zg(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? SB(Object(n), !0).forEach(function(r) {
      Ce(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : SB(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var MB = {
  onCenterChanged: "center_changed",
  onRadiusChanged: "radius_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, DB = {
  center(e, t) {
    e.setCenter(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  radius(e, t) {
    e.setRadius(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, lye = {};
function uye(e) {
  var {
    options: t,
    center: n,
    radius: r,
    draggable: o,
    editable: i,
    visible: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: h,
    onMouseUp: f,
    onRightClick: m,
    onClick: g,
    onDrag: E,
    onCenterChanged: w,
    onRadiusChanged: M,
    onLoad: x,
    onUnmount: y
  } = e, C = ye(Mt), [P, F] = k(null), [L, N] = k(null), [I, H] = k(null), [V, z] = k(null), [q, K] = k(null), [J, te] = k(null), [ee, _] = k(null), [D, $] = k(null), [S, W] = k(null), [O, T] = k(null), [U, j] = k(null), [Z, A] = k(null), [Q, R] = k(null), [ue, fe] = k(null);
  return v(() => {
    P !== null && P.setMap(C);
  }, [C]), v(() => {
    typeof t < "u" && P !== null && P.setOptions(t);
  }, [P, t]), v(() => {
    typeof o < "u" && P !== null && P.setDraggable(o);
  }, [P, o]), v(() => {
    typeof i < "u" && P !== null && P.setEditable(i);
  }, [P, i]), v(() => {
    typeof a < "u" && P !== null && P.setVisible(a);
  }, [P, a]), v(() => {
    typeof r == "number" && P !== null && P.setRadius(r);
  }, [P, r]), v(() => {
    typeof n < "u" && P !== null && P.setCenter(n);
  }, [P, n]), v(() => {
    P && s && (L !== null && google.maps.event.removeListener(L), N(google.maps.event.addListener(P, "dblclick", s)));
  }, [s]), v(() => {
    P && l && (I !== null && google.maps.event.removeListener(I), H(google.maps.event.addListener(P, "dragend", l)));
  }, [l]), v(() => {
    P && u && (V !== null && google.maps.event.removeListener(V), z(google.maps.event.addListener(P, "dragstart", u)));
  }, [u]), v(() => {
    P && c && (q !== null && google.maps.event.removeListener(q), K(google.maps.event.addListener(P, "mousedown", c)));
  }, [c]), v(() => {
    P && p && (J !== null && google.maps.event.removeListener(J), te(google.maps.event.addListener(P, "mousemove", p)));
  }, [p]), v(() => {
    P && d && (ee !== null && google.maps.event.removeListener(ee), _(google.maps.event.addListener(P, "mouseout", d)));
  }, [d]), v(() => {
    P && h && (D !== null && google.maps.event.removeListener(D), $(google.maps.event.addListener(P, "mouseover", h)));
  }, [h]), v(() => {
    P && f && (S !== null && google.maps.event.removeListener(S), W(google.maps.event.addListener(P, "mouseup", f)));
  }, [f]), v(() => {
    P && m && (O !== null && google.maps.event.removeListener(O), T(google.maps.event.addListener(P, "rightclick", m)));
  }, [m]), v(() => {
    P && g && (U !== null && google.maps.event.removeListener(U), j(google.maps.event.addListener(P, "click", g)));
  }, [g]), v(() => {
    P && E && (Z !== null && google.maps.event.removeListener(Z), A(google.maps.event.addListener(P, "drag", E)));
  }, [E]), v(() => {
    P && w && (Q !== null && google.maps.event.removeListener(Q), R(google.maps.event.addListener(P, "center_changed", w)));
  }, [g]), v(() => {
    P && M && (ue !== null && google.maps.event.removeListener(ue), fe(google.maps.event.addListener(P, "radius_changed", M)));
  }, [M]), v(() => {
    var oe = new google.maps.Circle(Zg(Zg({}, t || lye), {}, {
      map: C
    }));
    return typeof r == "number" && oe.setRadius(r), typeof n < "u" && oe.setCenter(n), typeof r == "number" && oe.setRadius(r), typeof a < "u" && oe.setVisible(a), typeof i < "u" && oe.setEditable(i), typeof o < "u" && oe.setDraggable(o), s && N(google.maps.event.addListener(oe, "dblclick", s)), l && H(google.maps.event.addListener(oe, "dragend", l)), u && z(google.maps.event.addListener(oe, "dragstart", u)), c && K(google.maps.event.addListener(oe, "mousedown", c)), p && te(google.maps.event.addListener(oe, "mousemove", p)), d && _(google.maps.event.addListener(oe, "mouseout", d)), h && $(google.maps.event.addListener(oe, "mouseover", h)), f && W(google.maps.event.addListener(oe, "mouseup", f)), m && T(google.maps.event.addListener(oe, "rightclick", m)), g && j(google.maps.event.addListener(oe, "click", g)), E && A(google.maps.event.addListener(oe, "drag", E)), w && R(google.maps.event.addListener(oe, "center_changed", w)), M && fe(google.maps.event.addListener(oe, "radius_changed", M)), F(oe), x && x(oe), () => {
      L !== null && google.maps.event.removeListener(L), I !== null && google.maps.event.removeListener(I), V !== null && google.maps.event.removeListener(V), q !== null && google.maps.event.removeListener(q), J !== null && google.maps.event.removeListener(J), ee !== null && google.maps.event.removeListener(ee), D !== null && google.maps.event.removeListener(D), S !== null && google.maps.event.removeListener(S), O !== null && google.maps.event.removeListener(O), U !== null && google.maps.event.removeListener(U), Q !== null && google.maps.event.removeListener(Q), ue !== null && google.maps.event.removeListener(ue), y && y(oe), oe.setMap(null);
    };
  }, []), null;
}
Ee(uye);
class cye extends pe {
  constructor() {
    super(...arguments), Ce(this, "registeredEvents", []), Ce(this, "state", {
      circle: null
    }), Ce(this, "setCircleCallback", () => {
      this.state.circle !== null && this.props.onLoad && this.props.onLoad(this.state.circle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Circle(Zg(Zg({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = en({
      updaterMap: DB,
      eventMap: MB,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        circle: t
      };
    }, this.setCircleCallback);
  }
  componentDidUpdate(t) {
    this.state.circle !== null && (an(this.registeredEvents), this.registeredEvents = en({
      updaterMap: DB,
      eventMap: MB,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.circle
    }));
  }
  componentWillUnmount() {
    if (this.state.circle !== null) {
      var t;
      this.props.onUnmount && this.props.onUnmount(this.state.circle), an(this.registeredEvents), (t = this.state.circle) === null || t === void 0 || t.setMap(null);
    }
  }
  render() {
    return null;
  }
}
Ce(cye, "contextType", Mt);
function TB(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Gg(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? TB(Object(n), !0).forEach(function(r) {
      Ce(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : TB(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var jB = {
  onClick: "click",
  onDblClick: "dblclick",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onAddFeature: "addfeature",
  onRemoveFeature: "removefeature",
  onRemoveProperty: "removeproperty",
  onSetGeometry: "setgeometry",
  onSetProperty: "setproperty"
}, AB = {
  add(e, t) {
    e.add(t);
  },
  addgeojson(e, t, n) {
    e.addGeoJson(t, n);
  },
  contains(e, t) {
    e.contains(t);
  },
  foreach(e, t) {
    e.forEach(t);
  },
  loadgeojson(e, t, n, r) {
    e.loadGeoJson(t, n, r);
  },
  overridestyle(e, t, n) {
    e.overrideStyle(t, n);
  },
  remove(e, t) {
    e.remove(t);
  },
  revertstyle(e, t) {
    e.revertStyle(t);
  },
  controlposition(e, t) {
    e.setControlPosition(t);
  },
  controls(e, t) {
    e.setControls(t);
  },
  drawingmode(e, t) {
    e.setDrawingMode(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  style(e, t) {
    e.setStyle(t);
  },
  togeojson(e, t) {
    e.toGeoJson(t);
  }
};
function pye(e) {
  var {
    options: t,
    onClick: n,
    onDblClick: r,
    onMouseDown: o,
    onMouseMove: i,
    onMouseOut: a,
    onMouseOver: s,
    onMouseUp: l,
    onRightClick: u,
    onAddFeature: c,
    onRemoveFeature: p,
    onRemoveProperty: d,
    onSetGeometry: h,
    onSetProperty: f,
    onLoad: m,
    onUnmount: g
  } = e, E = ye(Mt), [w, M] = k(null), [x, y] = k(null), [C, P] = k(null), [F, L] = k(null), [N, I] = k(null), [H, V] = k(null), [z, q] = k(null), [K, J] = k(null), [te, ee] = k(null), [_, D] = k(null), [$, S] = k(null), [W, O] = k(null), [T, U] = k(null), [j, Z] = k(null);
  return v(() => {
    w !== null && w.setMap(E);
  }, [E]), v(() => {
    w && r && (x !== null && google.maps.event.removeListener(x), y(google.maps.event.addListener(w, "dblclick", r)));
  }, [r]), v(() => {
    w && o && (C !== null && google.maps.event.removeListener(C), P(google.maps.event.addListener(w, "mousedown", o)));
  }, [o]), v(() => {
    w && i && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(w, "mousemove", i)));
  }, [i]), v(() => {
    w && a && (N !== null && google.maps.event.removeListener(N), I(google.maps.event.addListener(w, "mouseout", a)));
  }, [a]), v(() => {
    w && s && (H !== null && google.maps.event.removeListener(H), V(google.maps.event.addListener(w, "mouseover", s)));
  }, [s]), v(() => {
    w && l && (z !== null && google.maps.event.removeListener(z), q(google.maps.event.addListener(w, "mouseup", l)));
  }, [l]), v(() => {
    w && u && (K !== null && google.maps.event.removeListener(K), J(google.maps.event.addListener(w, "rightclick", u)));
  }, [u]), v(() => {
    w && n && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(w, "click", n)));
  }, [n]), v(() => {
    w && c && (_ !== null && google.maps.event.removeListener(_), D(google.maps.event.addListener(w, "addfeature", c)));
  }, [c]), v(() => {
    w && p && ($ !== null && google.maps.event.removeListener($), S(google.maps.event.addListener(w, "removefeature", p)));
  }, [p]), v(() => {
    w && d && (W !== null && google.maps.event.removeListener(W), O(google.maps.event.addListener(w, "removeproperty", d)));
  }, [d]), v(() => {
    w && h && (T !== null && google.maps.event.removeListener(T), U(google.maps.event.addListener(w, "setgeometry", h)));
  }, [h]), v(() => {
    w && f && (j !== null && google.maps.event.removeListener(j), Z(google.maps.event.addListener(w, "setproperty", f)));
  }, [f]), v(() => {
    if (E !== null) {
      var A = new google.maps.Data(Gg(Gg({}, t), {}, {
        map: E
      }));
      r && y(google.maps.event.addListener(A, "dblclick", r)), o && P(google.maps.event.addListener(A, "mousedown", o)), i && L(google.maps.event.addListener(A, "mousemove", i)), a && I(google.maps.event.addListener(A, "mouseout", a)), s && V(google.maps.event.addListener(A, "mouseover", s)), l && q(google.maps.event.addListener(A, "mouseup", l)), u && J(google.maps.event.addListener(A, "rightclick", u)), n && ee(google.maps.event.addListener(A, "click", n)), c && D(google.maps.event.addListener(A, "addfeature", c)), p && S(google.maps.event.addListener(A, "removefeature", p)), d && O(google.maps.event.addListener(A, "removeproperty", d)), h && U(google.maps.event.addListener(A, "setgeometry", h)), f && Z(google.maps.event.addListener(A, "setproperty", f)), M(A), m && m(A);
    }
    return () => {
      w && (x !== null && google.maps.event.removeListener(x), C !== null && google.maps.event.removeListener(C), F !== null && google.maps.event.removeListener(F), N !== null && google.maps.event.removeListener(N), H !== null && google.maps.event.removeListener(H), z !== null && google.maps.event.removeListener(z), K !== null && google.maps.event.removeListener(K), te !== null && google.maps.event.removeListener(te), _ !== null && google.maps.event.removeListener(_), $ !== null && google.maps.event.removeListener($), W !== null && google.maps.event.removeListener(W), T !== null && google.maps.event.removeListener(T), j !== null && google.maps.event.removeListener(j), g && g(w), w.setMap(null));
    };
  }, []), null;
}
Ee(pye);
class dye extends pe {
  constructor() {
    super(...arguments), Ce(this, "registeredEvents", []), Ce(this, "state", {
      data: null
    }), Ce(this, "setDataCallback", () => {
      this.state.data !== null && this.props.onLoad && this.props.onLoad(this.state.data);
    });
  }
  componentDidMount() {
    if (this.context !== null) {
      var t = new google.maps.Data(Gg(Gg({}, this.props.options), {}, {
        map: this.context
      }));
      this.registeredEvents = en({
        updaterMap: AB,
        eventMap: jB,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        data: t
      }), this.setDataCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.data !== null && (an(this.registeredEvents), this.registeredEvents = en({
      updaterMap: AB,
      eventMap: jB,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.data
    }));
  }
  componentWillUnmount() {
    this.state.data !== null && (this.props.onUnmount && this.props.onUnmount(this.state.data), an(this.registeredEvents), this.state.data && this.state.data.setMap(null));
  }
  render() {
    return null;
  }
}
Ce(dye, "contextType", Mt);
function BB(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function IB(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? BB(Object(n), !0).forEach(function(r) {
      Ce(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : BB(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var RB = {
  onClick: "click",
  onDefaultViewportChanged: "defaultviewport_changed",
  onStatusChanged: "status_changed"
}, NB = {
  options(e, t) {
    e.setOptions(t);
  },
  url(e, t) {
    e.setUrl(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
class fye extends pe {
  constructor() {
    super(...arguments), Ce(this, "registeredEvents", []), Ce(this, "state", {
      kmlLayer: null
    }), Ce(this, "setKmlLayerCallback", () => {
      this.state.kmlLayer !== null && this.props.onLoad && this.props.onLoad(this.state.kmlLayer);
    });
  }
  componentDidMount() {
    var t = new google.maps.KmlLayer(IB(IB({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = en({
      updaterMap: NB,
      eventMap: RB,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        kmlLayer: t
      };
    }, this.setKmlLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.kmlLayer !== null && (an(this.registeredEvents), this.registeredEvents = en({
      updaterMap: NB,
      eventMap: RB,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.kmlLayer
    }));
  }
  componentWillUnmount() {
    this.state.kmlLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.kmlLayer), an(this.registeredEvents), this.state.kmlLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Ce(fye, "contextType", Mt);
function Z9(e, t) {
  return typeof t == "function" ? t(e.offsetWidth, e.offsetHeight) : {
    x: 0,
    y: 0
  };
}
function hye(e, t) {
  return new t(e.lat, e.lng);
}
function gye(e, t) {
  return new t(new google.maps.LatLng(e.ne.lat, e.ne.lng), new google.maps.LatLng(e.sw.lat, e.sw.lng));
}
function mye(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function vye(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function yye(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n.getNorthEast()), o = e && e.fromLatLngToDivPixel(n.getSouthWest());
  return r && o ? {
    left: "".concat(o.x + t.x, "px"),
    top: "".concat(r.y + t.y, "px"),
    width: "".concat(r.x - o.x - t.x, "px"),
    height: "".concat(o.y - r.y - t.y, "px")
  } : {
    left: "-9999px",
    top: "-9999px"
  };
}
function bye(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n);
  if (r) {
    var {
      x: o,
      y: i
    } = r;
    return {
      left: "".concat(o + t.x, "px"),
      top: "".concat(i + t.y, "px")
    };
  }
  return {
    left: "-9999px",
    top: "-9999px"
  };
}
function G9(e, t, n, r) {
  return n !== void 0 ? yye(e, t, vye(n, google.maps.LatLngBounds, gye)) : bye(e, t, mye(r, google.maps.LatLng, hye));
}
function wye(e, t) {
  return e.left === t.left && e.top === t.top && e.width === t.height && e.height === t.height;
}
function FB(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Cye(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? FB(Object(n), !0).forEach(function(r) {
      Ce(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : FB(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function xye(e, t, n, r, o) {
  class i extends google.maps.OverlayView {
    constructor(s, l, u, c) {
      super(), this.container = s, this.pane = l, this.position = u, this.bounds = c;
    }
    onAdd() {
      var s, l = (s = this.getPanes()) === null || s === void 0 ? void 0 : s[this.pane];
      l == null || l.appendChild(this.container);
    }
    draw() {
      var s = this.getProjection(), l = Cye({}, this.container ? Z9(this.container, o) : {
        x: 0,
        y: 0
      }), u = G9(s, l, this.bounds, this.position);
      for (var [c, p] of Object.entries(u))
        this.container.style[c] = p;
    }
    onRemove() {
      this.container.parentNode !== null && this.container.parentNode.removeChild(this.container);
    }
  }
  return new i(e, t, n, r);
}
function zB(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Oye(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? zB(Object(n), !0).forEach(function(r) {
      Ce(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : zB(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function UB(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLng ? e : new google.maps.LatLng(e.lat, e.lng);
  return t + "";
}
function $B(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLngBounds ? e : new google.maps.LatLngBounds(new google.maps.LatLng(e.south, e.east), new google.maps.LatLng(e.north, e.west));
  return t + "";
}
function Eye(e) {
  var {
    position: t,
    bounds: n,
    mapPaneName: r,
    zIndex: o,
    onLoad: i,
    onUnmount: a,
    getPixelPositionOffset: s,
    children: l
  } = e, u = ye(Mt), c = Tn(() => {
    var d = document.createElement("div");
    return d.style.position = "absolute", d;
  }, []), p = Tn(() => xye(c, r, t, n, s), [c, r, t, n]);
  return v(() => (i == null || i(p), p == null || p.setMap(u), () => {
    a == null || a(p), p == null || p.setMap(null);
  }), [u, p]), v(() => {
    c.style.zIndex = "".concat(o);
  }, [o, c]), Ci.createPortal(l, c);
}
Ee(Eye);
class Ou extends pe {
  constructor(t) {
    super(t), Ce(this, "state", {
      paneEl: null,
      containerStyle: {
        // set initial position
        position: "absolute"
      }
    }), Ce(this, "updatePane", () => {
      var r = this.props.mapPaneName, o = this.overlayView.getPanes();
      Gr(!!r, "OverlayView requires props.mapPaneName but got %s", r), o ? this.setState({
        paneEl: o[r]
      }) : this.setState({
        paneEl: null
      });
    }), Ce(this, "onAdd", () => {
      var r, o;
      this.updatePane(), (r = (o = this.props).onLoad) === null || r === void 0 || r.call(o, this.overlayView);
    }), Ce(this, "onPositionElement", () => {
      var r = this.overlayView.getProjection(), o = Oye({
        x: 0,
        y: 0
      }, this.containerRef.current ? Z9(this.containerRef.current, this.props.getPixelPositionOffset) : {}), i = G9(r, o, this.props.bounds, this.props.position);
      if (!wye(i, {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        left: this.state.containerStyle.left,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        top: this.state.containerStyle.top,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        width: this.state.containerStyle.width,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        height: this.state.containerStyle.height
      })) {
        var a, s, l, u;
        this.setState({
          containerStyle: {
            top: (a = i.top) !== null && a !== void 0 ? a : 0,
            left: (s = i.left) !== null && s !== void 0 ? s : 0,
            width: (l = i.width) !== null && l !== void 0 ? l : 0,
            height: (u = i.height) !== null && u !== void 0 ? u : 0,
            position: "absolute"
          }
        });
      }
    }), Ce(this, "draw", () => {
      this.onPositionElement();
    }), Ce(this, "onRemove", () => {
      var r, o;
      this.setState(() => ({
        paneEl: null
      })), (r = (o = this.props).onUnmount) === null || r === void 0 || r.call(o, this.overlayView);
    }), this.containerRef = Qr();
    var n = new google.maps.OverlayView();
    n.onAdd = this.onAdd, n.draw = this.draw, n.onRemove = this.onRemove, this.overlayView = n;
  }
  componentDidMount() {
    this.overlayView.setMap(this.context);
  }
  componentDidUpdate(t) {
    var n = UB(t.position), r = UB(this.props.position), o = $B(t.bounds), i = $B(this.props.bounds);
    (n !== r || o !== i) && this.overlayView.draw(), t.mapPaneName !== this.props.mapPaneName && this.updatePane();
  }
  componentWillUnmount() {
    this.overlayView.setMap(null);
  }
  render() {
    var t = this.state.paneEl;
    return t ? Ci.createPortal(ro.jsx("div", {
      ref: this.containerRef,
      style: this.state.containerStyle,
      children: at.only(this.props.children)
    }), t) : null;
  }
}
Ce(Ou, "FLOAT_PANE", "floatPane");
Ce(Ou, "MAP_PANE", "mapPane");
Ce(Ou, "MARKER_LAYER", "markerLayer");
Ce(Ou, "OVERLAY_LAYER", "overlayLayer");
Ce(Ou, "OVERLAY_MOUSE_TARGET", "overlayMouseTarget");
Ce(Ou, "contextType", Mt);
function kye() {
}
function HB(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function WB(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? HB(Object(n), !0).forEach(function(r) {
      Ce(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : HB(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var VB = {
  onDblClick: "dblclick",
  onClick: "click"
}, qB = {
  opacity(e, t) {
    e.setOpacity(t);
  }
};
function Lye(e) {
  var {
    url: t,
    bounds: n,
    options: r,
    visible: o
  } = e, i = ye(Mt), a = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east)), s = Tn(() => new google.maps.GroundOverlay(t, a, r), []);
  return v(() => {
    s !== null && s.setMap(i);
  }, [i]), v(() => {
    typeof t < "u" && s !== null && (s.set("url", t), s.setMap(i));
  }, [s, t]), v(() => {
    typeof o < "u" && s !== null && s.setOpacity(o ? 1 : 0);
  }, [s, o]), v(() => {
    var l = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east));
    typeof n < "u" && s !== null && (s.set("bounds", l), s.setMap(i));
  }, [s, n]), null;
}
Ee(Lye);
class X9 extends pe {
  constructor() {
    super(...arguments), Ce(this, "registeredEvents", []), Ce(this, "state", {
      groundOverlay: null
    }), Ce(this, "setGroundOverlayCallback", () => {
      this.state.groundOverlay !== null && this.props.onLoad && this.props.onLoad(this.state.groundOverlay);
    });
  }
  componentDidMount() {
    Gr(!!this.props.url || !!this.props.bounds, "For GroundOverlay, url and bounds are passed in to constructor and are immutable after instantiated. This is the behavior of Google Maps JavaScript API v3 ( See https://developers.google.com/maps/documentation/javascript/reference#GroundOverlay) Hence, use the corresponding two props provided by `react-google-maps-api`, url and bounds. In some cases, you'll need the GroundOverlay component to reflect the changes of url and bounds. You can leverage the React's key property to remount the component. Typically, just `key={url}` would serve your need. See https://github.com/tomchentw/react-google-maps/issues/655");
    var t = new google.maps.GroundOverlay(this.props.url, this.props.bounds, WB(WB({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = en({
      updaterMap: qB,
      eventMap: VB,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        groundOverlay: t
      };
    }, this.setGroundOverlayCallback);
  }
  componentDidUpdate(t) {
    this.state.groundOverlay !== null && (an(this.registeredEvents), this.registeredEvents = en({
      updaterMap: qB,
      eventMap: VB,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.groundOverlay
    }));
  }
  componentWillUnmount() {
    this.state.groundOverlay && (this.props.onUnmount && this.props.onUnmount(this.state.groundOverlay), this.state.groundOverlay.setMap(null));
  }
  render() {
    return null;
  }
}
Ce(X9, "defaultProps", {
  onLoad: kye
});
Ce(X9, "contextType", Mt);
function ZB(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Xg(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? ZB(Object(n), !0).forEach(function(r) {
      Ce(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : ZB(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var GB = {}, XB = {
  data(e, t) {
    e.setData(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function _ye(e) {
  var {
    data: t,
    onLoad: n,
    onUnmount: r,
    options: o
  } = e, i = ye(Mt), [a, s] = k(null);
  return v(() => {
    google.maps.visualization || Gr(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} in useJsApiScript? %s', google.maps.visualization);
  }, []), v(() => {
    Gr(!!t, "data property is required in HeatmapLayer %s", t);
  }, [t]), v(() => {
    a !== null && a.setMap(i);
  }, [i]), v(() => {
    o && a !== null && a.setOptions(o);
  }, [a, o]), v(() => {
    var l = new google.maps.visualization.HeatmapLayer(Xg(Xg({}, o), {}, {
      data: t,
      map: i
    }));
    return s(l), n && n(l), () => {
      a !== null && (r && r(a), a.setMap(null));
    };
  }, []), null;
}
Ee(_ye);
class Pye extends pe {
  constructor() {
    super(...arguments), Ce(this, "registeredEvents", []), Ce(this, "state", {
      heatmapLayer: null
    }), Ce(this, "setHeatmapLayerCallback", () => {
      this.state.heatmapLayer !== null && this.props.onLoad && this.props.onLoad(this.state.heatmapLayer);
    });
  }
  componentDidMount() {
    Gr(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} to <LoadScript />? %s', google.maps.visualization), Gr(!!this.props.data, "data property is required in HeatmapLayer %s", this.props.data);
    var t = new google.maps.visualization.HeatmapLayer(Xg(Xg({}, this.props.options), {}, {
      data: this.props.data,
      map: this.context
    }));
    this.registeredEvents = en({
      updaterMap: XB,
      eventMap: GB,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        heatmapLayer: t
      };
    }, this.setHeatmapLayerCallback);
  }
  componentDidUpdate(t) {
    an(this.registeredEvents), this.registeredEvents = en({
      updaterMap: XB,
      eventMap: GB,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.heatmapLayer
    });
  }
  componentWillUnmount() {
    this.state.heatmapLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.heatmapLayer), an(this.registeredEvents), this.state.heatmapLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Ce(Pye, "contextType", Mt);
var KB = {
  onCloseClick: "closeclick",
  onPanoChanged: "pano_changed",
  onPositionChanged: "position_changed",
  onPovChanged: "pov_changed",
  onResize: "resize",
  onStatusChanged: "status_changed",
  onVisibleChanged: "visible_changed",
  onZoomChanged: "zoom_changed"
}, YB = {
  register(e, t, n) {
    e.registerPanoProvider(t, n);
  },
  links(e, t) {
    e.setLinks(t);
  },
  motionTracking(e, t) {
    e.setMotionTracking(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  pano(e, t) {
    e.setPano(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  pov(e, t) {
    e.setPov(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zoom(e, t) {
    e.setZoom(t);
  }
};
class Sye extends pe {
  constructor() {
    super(...arguments), Ce(this, "registeredEvents", []), Ce(this, "state", {
      streetViewPanorama: null
    }), Ce(this, "setStreetViewPanoramaCallback", () => {
      this.state.streetViewPanorama !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewPanorama);
    });
  }
  componentDidMount() {
    var t, n, r = (t = (n = this.context) === null || n === void 0 ? void 0 : n.getStreetView()) !== null && t !== void 0 ? t : null;
    this.registeredEvents = en({
      updaterMap: YB,
      eventMap: KB,
      prevProps: {},
      nextProps: this.props,
      instance: r
    }), this.setState(() => ({
      streetViewPanorama: r
    }), this.setStreetViewPanoramaCallback);
  }
  componentDidUpdate(t) {
    this.state.streetViewPanorama !== null && (an(this.registeredEvents), this.registeredEvents = en({
      updaterMap: YB,
      eventMap: KB,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.streetViewPanorama
    }));
  }
  componentWillUnmount() {
    this.state.streetViewPanorama !== null && (this.props.onUnmount && this.props.onUnmount(this.state.streetViewPanorama), an(this.registeredEvents), this.state.streetViewPanorama.setVisible(!1));
  }
  render() {
    return null;
  }
}
Ce(Sye, "contextType", Mt);
class Mye extends pe {
  constructor() {
    super(...arguments), Ce(this, "state", {
      streetViewService: null
    }), Ce(this, "setStreetViewServiceCallback", () => {
      this.state.streetViewService !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewService);
    });
  }
  componentDidMount() {
    var t = new google.maps.StreetViewService();
    this.setState(function() {
      return {
        streetViewService: t
      };
    }, this.setStreetViewServiceCallback);
  }
  componentWillUnmount() {
    this.state.streetViewService !== null && this.props.onUnmount && this.props.onUnmount(this.state.streetViewService);
  }
  render() {
    return null;
  }
}
Ce(Mye, "contextType", Mt);
var JB = {
  onDirectionsChanged: "directions_changed"
}, QB = {
  directions(e, t) {
    e.setDirections(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  panel(e, t) {
    e.setPanel(t);
  },
  routeIndex(e, t) {
    e.setRouteIndex(t);
  }
};
class Dye extends pe {
  constructor() {
    super(...arguments), Ce(this, "registeredEvents", []), Ce(this, "state", {
      directionsRenderer: null
    }), Ce(this, "setDirectionsRendererCallback", () => {
      this.state.directionsRenderer !== null && (this.state.directionsRenderer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.directionsRenderer));
    });
  }
  componentDidMount() {
    var t = new google.maps.DirectionsRenderer(this.props.options);
    this.registeredEvents = en({
      updaterMap: QB,
      eventMap: JB,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        directionsRenderer: t
      };
    }, this.setDirectionsRendererCallback);
  }
  componentDidUpdate(t) {
    this.state.directionsRenderer !== null && (an(this.registeredEvents), this.registeredEvents = en({
      updaterMap: QB,
      eventMap: JB,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.directionsRenderer
    }));
  }
  componentWillUnmount() {
    this.state.directionsRenderer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.directionsRenderer), an(this.registeredEvents), this.state.directionsRenderer && this.state.directionsRenderer.setMap(null));
  }
  render() {
    return null;
  }
}
Ce(Dye, "contextType", Mt);
var eI = {
  onPlacesChanged: "places_changed"
}, tI = {
  bounds(e, t) {
    e.setBounds(t);
  }
};
class Tye extends pe {
  constructor() {
    super(...arguments), Ce(this, "registeredEvents", []), Ce(this, "containerElement", Qr()), Ce(this, "state", {
      searchBox: null
    }), Ce(this, "setSearchBoxCallback", () => {
      this.state.searchBox !== null && this.props.onLoad && this.props.onLoad(this.state.searchBox);
    });
  }
  componentDidMount() {
    if (Gr(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places), this.containerElement !== null && this.containerElement.current !== null) {
      var t = this.containerElement.current.querySelector("input");
      if (t !== null) {
        var n = new google.maps.places.SearchBox(t, this.props.options);
        this.registeredEvents = en({
          updaterMap: tI,
          eventMap: eI,
          prevProps: {},
          nextProps: this.props,
          instance: n
        }), this.setState(function() {
          return {
            searchBox: n
          };
        }, this.setSearchBoxCallback);
      }
    }
  }
  componentDidUpdate(t) {
    this.state.searchBox !== null && (an(this.registeredEvents), this.registeredEvents = en({
      updaterMap: tI,
      eventMap: eI,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.searchBox
    }));
  }
  componentWillUnmount() {
    this.state.searchBox !== null && (this.props.onUnmount && this.props.onUnmount(this.state.searchBox), an(this.registeredEvents));
  }
  render() {
    return ro.jsx("div", {
      ref: this.containerElement,
      children: at.only(this.props.children)
    });
  }
}
Ce(Tye, "contextType", Mt);
var nI = {
  onPlaceChanged: "place_changed"
}, rI = {
  bounds(e, t) {
    e.setBounds(t);
  },
  restrictions(e, t) {
    e.setComponentRestrictions(t);
  },
  fields(e, t) {
    e.setFields(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  types(e, t) {
    e.setTypes(t);
  }
};
class K9 extends pe {
  constructor() {
    super(...arguments), Ce(this, "registeredEvents", []), Ce(this, "containerElement", Qr()), Ce(this, "state", {
      autocomplete: null
    }), Ce(this, "setAutocompleteCallback", () => {
      this.state.autocomplete !== null && this.props.onLoad && this.props.onLoad(this.state.autocomplete);
    });
  }
  componentDidMount() {
    var t;
    Gr(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places);
    var n = (t = this.containerElement.current) === null || t === void 0 ? void 0 : t.querySelector("input");
    if (n) {
      var r = new google.maps.places.Autocomplete(n, this.props.options);
      this.registeredEvents = en({
        updaterMap: rI,
        eventMap: nI,
        prevProps: {},
        nextProps: this.props,
        instance: r
      }), this.setState(() => ({
        autocomplete: r
      }), this.setAutocompleteCallback);
    }
  }
  componentDidUpdate(t) {
    an(this.registeredEvents), this.registeredEvents = en({
      updaterMap: rI,
      eventMap: nI,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.autocomplete
    });
  }
  componentWillUnmount() {
    this.state.autocomplete !== null && an(this.registeredEvents);
  }
  render() {
    return ro.jsx("div", {
      ref: this.containerElement,
      className: this.props.className,
      children: at.only(this.props.children)
    });
  }
}
Ce(K9, "defaultProps", {
  className: ""
});
Ce(K9, "contextType", Mt);
let jye = { data: "" }, Aye = (e) => typeof window == "object" ? ((e ? e.querySelector("#_goober") : window._goober) || Object.assign((e || document.head).appendChild(document.createElement("style")), { innerHTML: " ", id: "_goober" })).firstChild : e || jye, Bye = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g, Iye = /\/\*[^]*?\*\/|  +/g, oI = /\n+/g, aa = (e, t) => {
  let n = "", r = "", o = "";
  for (let i in e) {
    let a = e[i];
    i[0] == "@" ? i[1] == "i" ? n = i + " " + a + ";" : r += i[1] == "f" ? aa(a, i) : i + "{" + aa(a, i[1] == "k" ? "" : t) + "}" : typeof a == "object" ? r += aa(a, t ? t.replace(/([^,])+/g, (s) => i.replace(/([^,]*:\S+\([^)]*\))|([^,])+/g, (l) => /&/.test(l) ? l.replace(/&/g, s) : s ? s + " " + l : l)) : i) : a != null && (i = /^--/.test(i) ? i : i.replace(/[A-Z]/g, "-$&").toLowerCase(), o += aa.p ? aa.p(i, a) : i + ":" + a + ";");
  }
  return n + (t && o ? t + "{" + o + "}" : o) + r;
}, us = {}, Y9 = (e) => {
  if (typeof e == "object") {
    let t = "";
    for (let n in e) t += n + Y9(e[n]);
    return t;
  }
  return e;
}, Rye = (e, t, n, r, o) => {
  let i = Y9(e), a = us[i] || (us[i] = ((l) => {
    let u = 0, c = 11;
    for (; u < l.length; ) c = 101 * c + l.charCodeAt(u++) >>> 0;
    return "go" + c;
  })(i));
  if (!us[a]) {
    let l = i !== e ? e : ((u) => {
      let c, p, d = [{}];
      for (; c = Bye.exec(u.replace(Iye, "")); ) c[4] ? d.shift() : c[3] ? (p = c[3].replace(oI, " ").trim(), d.unshift(d[0][p] = d[0][p] || {})) : d[0][c[1]] = c[2].replace(oI, " ").trim();
      return d[0];
    })(e);
    us[a] = aa(o ? { ["@keyframes " + a]: l } : l, n ? "" : "." + a);
  }
  let s = n && us.g ? us.g : null;
  return n && (us.g = us[a]), ((l, u, c, p) => {
    p ? u.data = u.data.replace(p, l) : u.data.indexOf(l) === -1 && (u.data = c ? l + u.data : u.data + l);
  })(us[a], t, r, s), a;
}, Nye = (e, t, n) => e.reduce((r, o, i) => {
  let a = t[i];
  if (a && a.call) {
    let s = a(n), l = s && s.props && s.props.className || /^go/.test(s) && s;
    a = l ? "." + l : s && typeof s == "object" ? s.props ? "" : aa(s, "") : s === !1 ? "" : s;
  }
  return r + o + (a ?? "");
}, "");
function my(e) {
  let t = this || {}, n = e.call ? e(t.p) : e;
  return Rye(n.unshift ? n.raw ? Nye(n, [].slice.call(arguments, 1), t.p) : n.reduce((r, o) => Object.assign(r, o && o.call ? o(t.p) : o), {}) : n, Aye(t.target), t.g, t.o, t.k);
}
let J9, gx, mx;
my.bind({ g: 1 });
let xs = my.bind({ k: 1 });
function Fye(e, t, n, r) {
  aa.p = t, J9 = e, gx = n, mx = r;
}
function Sa(e, t) {
  let n = this || {};
  return function() {
    let r = arguments;
    function o(i, a) {
      let s = Object.assign({}, i), l = s.className || o.className;
      n.p = Object.assign({ theme: gx && gx() }, s), n.o = / *go\d+/.test(l), s.className = my.apply(n, r) + (l ? " " + l : "");
      let u = e;
      return e[0] && (u = s.as || e, delete s.as), mx && u[0] && mx(s), J9(u, s);
    }
    return o;
  };
}
var zye = (e) => typeof e == "function", Uye = (e, t) => zye(e) ? e(t) : e, $ye = /* @__PURE__ */ (() => {
  let e;
  return () => {
    if (e === void 0 && typeof window < "u") {
      let t = matchMedia("(prefers-reduced-motion: reduce)");
      e = !t || t.matches;
    }
    return e;
  };
})(), Hye = xs`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`, Wye = xs`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`, Vye = xs`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`, qye = Sa("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${Hye} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${Wye} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${(e) => e.secondary || "#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${Vye} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`, Zye = xs`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, Gye = Sa("div")`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${(e) => e.secondary || "#e0e0e0"};
  border-right-color: ${(e) => e.primary || "#616161"};
  animation: ${Zye} 1s linear infinite;
`, Xye = xs`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`, Kye = xs`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`, Yye = Sa("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${Xye} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${Kye} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${(e) => e.secondary || "#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`, Jye = Sa("div")`
  position: absolute;
`, Qye = Sa("div")`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`, ebe = xs`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`, tbe = Sa("div")`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${ebe} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`, nbe = ({ toast: e }) => {
  let { icon: t, type: n, iconTheme: r } = e;
  return t !== void 0 ? typeof t == "string" ? $e.createElement(tbe, null, t) : t : n === "blank" ? null : $e.createElement(Qye, null, $e.createElement(Gye, { ...r }), n !== "loading" && $e.createElement(Jye, null, n === "error" ? $e.createElement(qye, { ...r }) : $e.createElement(Yye, { ...r })));
}, rbe = (e) => `
0% {transform: translate3d(0,${e * -200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`, obe = (e) => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${e * -150}%,-1px) scale(.6); opacity:0;}
`, ibe = "0%{opacity:0;} 100%{opacity:1;}", sbe = "0%{opacity:1;} 100%{opacity:0;}", abe = Sa("div")`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`, lbe = Sa("div")`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`, ube = (e, t) => {
  let n = e.includes("top") ? 1 : -1, [r, o] = $ye() ? [ibe, sbe] : [rbe(n), obe(n)];
  return { animation: t ? `${xs(r)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards` : `${xs(o)} 0.4s forwards cubic-bezier(.06,.71,.55,1)` };
};
$e.memo(({ toast: e, position: t, style: n, children: r }) => {
  let o = e.height ? ube(e.position || t || "top-center", e.visible) : { opacity: 0 }, i = $e.createElement(nbe, { toast: e }), a = $e.createElement(lbe, { ...e.ariaProps }, Uye(e.message, e));
  return $e.createElement(abe, { className: e.className, style: { ...o, ...n, ...e.style } }, typeof r == "function" ? r({ icon: i, message: a }) : $e.createElement($e.Fragment, null, i, a));
});
Fye($e.createElement);
my`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`;
Ze({});
function cbe(e) {
  return e && e.replace(/[^0-9]/g, "");
}
const pbe = {
  CNPJ: "99.999.999/9999-99"
};
cbe(pbe.CNPJ).length;
Vr((e, t) => /* @__PURE__ */ no.jsx("input", { ref: t, ...e }));
function Q9(e) {
  return e && e.replace(/[^0-9]/g, "");
}
const e6 = {
  EIGTH: "(99) 9999-9999",
  NINE: "(99) 99999-9999"
};
function dbe(e, t) {
  let n = "", r = 0;
  for (let o = 0; o < t.length; o++)
    if (t[o] === "9")
      if (r < e.length)
        n += e[r], r++;
      else
        break;
    else if (r < e.length)
      n += t[o];
    else
      break;
  return n;
}
function fbe(e) {
  return e.length > 10 ? "NINE" : "EIGTH";
}
const hbe = Q9(e6.NINE).length, gbe = Vr((e, t) => /* @__PURE__ */ no.jsx("input", { ref: t, ...e }));
Vr(
  (e, t) => {
    const { onFocus: n, onBlur: r, size: o, onChange: i, value: a, currentCountry: s, disabled: l } = e, [u, c] = k(!1);
    v(() => {
      u ? i(s.mask) : c(!0);
    }, [s]);
    const p = `phoneInputMask ${o}`;
    function d(h) {
      let f = Q9(h.target.value);
      const m = fbe(f);
      f.length > hbe || (f = dbe(f, e6[m]), h.target.value = f, i(f));
    }
    return s.code === "+55" ? /* @__PURE__ */ no.jsx(
      "input",
      {
        value: a,
        onChange: d,
        className: p,
        onFocus: n,
        onBlur: r,
        disabled: l,
        ref: t
      }
    ) : /* @__PURE__ */ no.jsx(
      Il,
      {
        value: a,
        onChange: (h) => i(h.target.value),
        className: p,
        component: gbe,
        onFocus: n,
        onBlur: r,
        disabled: l,
        mask: s.mask,
        showMask: !0,
        replacement: { _: /\d/ },
        ref: t
      }
    );
  }
);
Ze({});
var Ss = {};
Object.defineProperty(Ss, "__esModule", {
  value: !0
});
var mbe = typeof window < "u" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform), L0 = {
  alt: "altKey",
  control: "ctrlKey",
  meta: "metaKey",
  shift: "shiftKey"
}, t6 = {
  add: "+",
  break: "pause",
  cmd: "meta",
  command: "meta",
  ctl: "control",
  ctrl: "control",
  del: "delete",
  down: "arrowdown",
  esc: "escape",
  ins: "insert",
  left: "arrowleft",
  mod: mbe ? "meta" : "control",
  opt: "alt",
  option: "alt",
  return: "enter",
  right: "arrowright",
  space: " ",
  spacebar: " ",
  up: "arrowup",
  win: "meta",
  windows: "meta"
}, jk = {
  backspace: 8,
  tab: 9,
  enter: 13,
  shift: 16,
  control: 17,
  alt: 18,
  pause: 19,
  capslock: 20,
  escape: 27,
  " ": 32,
  pageup: 33,
  pagedown: 34,
  end: 35,
  home: 36,
  arrowleft: 37,
  arrowup: 38,
  arrowright: 39,
  arrowdown: 40,
  insert: 45,
  delete: 46,
  meta: 91,
  numlock: 144,
  scrolllock: 145,
  ";": 186,
  "=": 187,
  ",": 188,
  "-": 189,
  ".": 190,
  "/": 191,
  "`": 192,
  "[": 219,
  "\\": 220,
  "]": 221,
  "'": 222
};
for (var $f = 1; $f < 20; $f++)
  jk["f" + $f] = 111 + $f;
function vy(e, t, n) {
  t && !("byKey" in t) && (n = t, t = null), Array.isArray(e) || (e = [e]);
  var r = e.map(function(a) {
    return n6(a, t);
  }), o = function(a) {
    return r.some(function(s) {
      return r6(s, a);
    });
  }, i = n == null ? o : o(n);
  return i;
}
function vbe(e, t) {
  return vy(e, t);
}
function ybe(e, t) {
  return vy(e, { byKey: !0 }, t);
}
function n6(e, t) {
  var n = t && t.byKey, r = {};
  e = e.replace("++", "+add");
  var o = e.split("+"), i = o.length;
  for (var a in L0)
    r[L0[a]] = !1;
  var s = !0, l = !1, u = void 0;
  try {
    for (var c = o[Symbol.iterator](), p; !(s = (p = c.next()).done); s = !0) {
      var d = p.value, h = d.endsWith("?") && d.length > 1;
      h && (d = d.slice(0, -1));
      var f = Ak(d), m = L0[f];
      if (d.length > 1 && !m && !t6[d] && !jk[f])
        throw new TypeError('Unknown modifier: "' + d + '"');
      (i === 1 || !m) && (n ? r.key = f : r.which = o6(d)), m && (r[m] = h ? null : !0);
    }
  } catch (g) {
    l = !0, u = g;
  } finally {
    try {
      !s && c.return && c.return();
    } finally {
      if (l)
        throw u;
    }
  }
  return r;
}
function r6(e, t) {
  for (var n in e) {
    var r = e[n], o = void 0;
    if (r != null && (n === "key" && t.key != null ? o = t.key.toLowerCase() : n === "which" ? o = r === 91 && t.which === 93 ? 91 : t.which : o = t[n], !(o == null && r === !1) && o !== r))
      return !1;
  }
  return !0;
}
function o6(e) {
  e = Ak(e);
  var t = jk[e] || e.toUpperCase().charCodeAt(0);
  return t;
}
function Ak(e) {
  return e = e.toLowerCase(), e = t6[e] || e, e;
}
Ss.default = vy;
var _0 = Ss.isHotkey = vy;
Ss.isCodeHotkey = vbe;
Ss.isKeyHotkey = ybe;
Ss.parseHotkey = n6;
Ss.compareHotkey = r6;
Ss.toKeyCode = o6;
Ss.toKeyName = Ak;
var bbe = typeof zn == "object" && zn && zn.Object === Object && zn, wbe = bbe, Cbe = wbe, xbe = typeof self == "object" && self && self.Object === Object && self, Obe = Cbe || xbe || Function("return this")(), Ebe = Obe, kbe = Ebe, Lbe = kbe.Symbol, i6 = Lbe, iI = i6;
iI && iI.toStringTag;
var sI = i6;
sI && sI.toStringTag;
var aI;
(function(e) {
  e.BORDER_BOX = "border-box", e.CONTENT_BOX = "content-box", e.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(aI || (aI = {}));
var Bk = function(e) {
  return Object.freeze(e);
}, _be = /* @__PURE__ */ function() {
  function e(t, n) {
    this.inlineSize = t, this.blockSize = n, Bk(this);
  }
  return e;
}(), Pbe = function() {
  function e(t, n, r, o) {
    return this.x = t, this.y = n, this.width = r, this.height = o, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, Bk(this);
  }
  return e.prototype.toJSON = function() {
    var t = this, n = t.x, r = t.y, o = t.top, i = t.right, a = t.bottom, s = t.left, l = t.width, u = t.height;
    return { x: n, y: r, top: o, right: i, bottom: a, left: s, width: l, height: u };
  }, e.fromRect = function(t) {
    return new e(t.x, t.y, t.width, t.height);
  }, e;
}(), lI = typeof window < "u" ? window : {};
/msie|trident/i.test(lI.navigator && lI.navigator.userAgent);
var P0 = function(e, t, n) {
  return e === void 0 && (e = 0), t === void 0 && (t = 0), n === void 0 && (n = !1), new _be((n ? t : e) || 0, (n ? e : t) || 0);
};
Bk({
  devicePixelContentBoxSize: P0(),
  borderBoxSize: P0(),
  contentBoxSize: P0(),
  contentRect: new Pbe(0, 0, 0, 0)
});
function Mp(e) {
  "@babel/helpers - typeof";
  return Mp = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Mp(e);
}
function Sbe(e, t) {
  if (Mp(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (Mp(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function Mbe(e) {
  var t = Sbe(e, "string");
  return Mp(t) === "symbol" ? t : String(t);
}
function Fc(e, t, n) {
  return t = Mbe(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
var Dbe = /* @__PURE__ */ Ze(null), S0, M0;
parseInt(ke.version.split(".")[0], 10);
var uI = typeof navigator < "u" && /Mac OS X/.test(navigator.userAgent), D0 = typeof navigator < "u" && /Android/.test(navigator.userAgent), Hf = typeof navigator < "u" && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent), Tbe = typeof navigator < "u" && /Chrome/i.test(navigator.userAgent);
typeof navigator < "u" && /Safari/.test(navigator.userAgent) && /Version\/(\d+)/.test(navigator.userAgent) && (S0 = navigator.userAgent.match(/Version\/(\d+)/)) !== null && S0 !== void 0 && S0[1] && parseInt((M0 = navigator.userAgent.match(/Version\/(\d+)/)) === null || M0 === void 0 ? void 0 : M0[1], 10) < 17;
var jbe = /* @__PURE__ */ new WeakMap(), Abe = /* @__PURE__ */ new WeakMap(), Bbe = /* @__PURE__ */ new WeakMap(), Ibe = /* @__PURE__ */ new WeakMap(), Rbe = /* @__PURE__ */ new WeakMap(), cI = /* @__PURE__ */ new WeakMap(), Nbe = /* @__PURE__ */ new WeakMap(), pI = /* @__PURE__ */ new WeakMap(), Wf = /* @__PURE__ */ new WeakMap(), Fbe = /* @__PURE__ */ new WeakMap(), zbe = /* @__PURE__ */ new WeakMap(), Ube = /* @__PURE__ */ new WeakMap(), s6 = globalThis.Node, $be = globalThis.Text, a6 = (e) => e && e.ownerDocument && e.ownerDocument.defaultView || null, Hbe = (e) => Kg(e) && e.nodeType === 8, qi = (e) => Kg(e) && e.nodeType === 1, Kg = (e) => {
  var t = a6(e);
  return !!t && e instanceof t.Node;
}, dI = (e) => {
  var t = e && e.anchorNode && a6(e.anchorNode);
  return !!t && e instanceof t.Selection;
}, Wbe = (e) => {
  var [t, n] = e;
  if (qi(t) && t.childNodes.length) {
    var r = n === t.childNodes.length, o = r ? n - 1 : n;
    for ([t, o] = l6(t, o, r ? "backward" : "forward"), r = o < n; qi(t) && t.childNodes.length; ) {
      var i = r ? t.childNodes.length - 1 : 0;
      t = qbe(t, i, r ? "backward" : "forward");
    }
    n = r && t.textContent != null ? t.textContent.length : 0;
  }
  return [t, n];
}, Vbe = (e) => {
  for (var t = e && e.parentNode; t; ) {
    if (t.toString() === "[object ShadowRoot]")
      return !0;
    t = t.parentNode;
  }
  return !1;
}, l6 = (e, t, n) => {
  for (var {
    childNodes: r
  } = e, o = r[t], i = t, a = !1, s = !1; (Hbe(o) || qi(o) && o.childNodes.length === 0 || qi(o) && o.getAttribute("contenteditable") === "false") && !(a && s); ) {
    if (i >= r.length) {
      a = !0, i = t - 1, n = "backward";
      continue;
    }
    if (i < 0) {
      s = !0, i = t + 1, n = "forward";
      continue;
    }
    o = r[i], t = i, i += n === "forward" ? 1 : -1;
  }
  return [o, t];
}, qbe = (e, t, n) => {
  var [r] = l6(e, t, n);
  return r;
}, fI = (e) => e.getSelection != null ? e.getSelection() : document.getSelection(), u6 = (e, t, n) => {
  var {
    target: r
  } = t;
  if (qi(r) && r.matches('[contentEditable="false"]'))
    return !1;
  var {
    document: o
  } = Kt.getWindow(e);
  if (o.contains(r))
    return Kt.hasDOMNode(e, r, {
      editable: !0
    });
  var i = n.find((a) => {
    var {
      addedNodes: s,
      removedNodes: l
    } = a;
    for (var u of s)
      if (u === r || u.contains(r))
        return !0;
    for (var c of l)
      if (c === r || c.contains(r))
        return !0;
  });
  return !i || i === t ? !1 : u6(e, i, n);
}, hI = (e, t) => !!(e.compareDocumentPosition(t) & s6.DOCUMENT_POSITION_PRECEDING), Zbe = (e, t) => !!(e.compareDocumentPosition(t) & s6.DOCUMENT_POSITION_FOLLOWING), Gbe = 0;
class Xbe {
  constructor() {
    Fc(this, "id", void 0), this.id = "".concat(Gbe++);
  }
}
var Kt = {
  androidPendingDiffs: (e) => Ube.get(e),
  androidScheduleFlush: (e) => {
    var t;
    (t = zbe.get(e)) === null || t === void 0 || t();
  },
  blur: (e) => {
    var t = Kt.toDOMNode(e, e), n = Kt.findDocumentOrShadowRoot(e);
    Wf.set(e, !1), n.activeElement === t && t.blur();
  },
  deselect: (e) => {
    var {
      selection: t
    } = e, n = Kt.findDocumentOrShadowRoot(e), r = fI(n);
    r && r.rangeCount > 0 && r.removeAllRanges(), t && eg.deselect(e);
  },
  findDocumentOrShadowRoot: (e) => {
    var t = Kt.toDOMNode(e, e), n = t.getRootNode();
    return n instanceof Document || n instanceof ShadowRoot ? n : t.ownerDocument;
  },
  findEventRange: (e, t) => {
    "nativeEvent" in t && (t = t.nativeEvent);
    var {
      clientX: n,
      clientY: r,
      target: o
    } = t;
    if (n == null || r == null)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var i = Kt.toSlateNode(e, t.target), a = Kt.findPath(e, i);
    if (hs.isElement(i) && An.isVoid(e, i)) {
      var s = o.getBoundingClientRect(), l = e.isInline(i) ? n - s.left < s.left + s.width - n : r - s.top < s.top + s.height - r, u = An.point(e, a, {
        edge: l ? "start" : "end"
      }), c = l ? An.before(e, u) : An.after(e, u);
      if (c) {
        var p = An.range(e, c);
        return p;
      }
    }
    var d, {
      document: h
    } = Kt.getWindow(e);
    if (h.caretRangeFromPoint)
      d = h.caretRangeFromPoint(n, r);
    else {
      var f = h.caretPositionFromPoint(n, r);
      f && (d = h.createRange(), d.setStart(f.offsetNode, f.offset), d.setEnd(f.offsetNode, f.offset));
    }
    if (!d)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var m = Kt.toSlateRange(e, d, {
      exactMatch: !1,
      suppressThrow: !1
    });
    return m;
  },
  findKey: (e, t) => {
    var n = cI.get(t);
    return n || (n = new Xbe(), cI.set(t, n)), n;
  },
  findPath: (e, t) => {
    for (var n = [], r = t; ; ) {
      var o = Abe.get(r);
      if (o == null) {
        if (An.isEditor(r))
          return n;
        break;
      }
      var i = jbe.get(r);
      if (i == null)
        break;
      n.unshift(i), r = o;
    }
    throw new Error("Unable to find the path for Slate node: ".concat(Ho.stringify(t)));
  },
  focus: function(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      retries: 5
    };
    if (!Wf.get(e)) {
      if (t.retries <= 0)
        throw new Error("Could not set focus, editor seems stuck with pending operations");
      if (e.operations.length > 0) {
        setTimeout(() => {
          Kt.focus(e, {
            retries: t.retries - 1
          });
        }, 10);
        return;
      }
      var n = Kt.toDOMNode(e, e), r = Kt.findDocumentOrShadowRoot(e);
      if (r.activeElement !== n) {
        if (e.selection && r instanceof Document) {
          var o = fI(r), i = Kt.toDOMRange(e, e.selection);
          o == null || o.removeAllRanges(), o == null || o.addRange(i);
        }
        e.selection || eg.select(e, An.start(e, [])), Wf.set(e, !0), n.focus({
          preventScroll: !0
        });
      }
    }
  },
  getWindow: (e) => {
    var t = Bbe.get(e);
    if (!t)
      throw new Error("Unable to find a host window element for this editor");
    return t;
  },
  hasDOMNode: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      editable: r = !1
    } = n, o = Kt.toDOMNode(e, e), i;
    try {
      i = qi(t) ? t : t.parentElement;
    } catch (a) {
      if (a instanceof Error && !a.message.includes('Permission denied to access property "nodeType"'))
        throw a;
    }
    return i ? i.closest("[data-slate-editor]") === o && (!r || i.isContentEditable ? !0 : typeof i.isContentEditable == "boolean" && // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined
    // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable="false"(readOnly)
    i.closest('[contenteditable="false"]') === o || !!i.getAttribute("data-slate-zero-width")) : !1;
  },
  hasEditableTarget: (e, t) => Kg(t) && Kt.hasDOMNode(e, t, {
    editable: !0
  }),
  hasRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t;
    return An.hasPath(e, n.path) && An.hasPath(e, r.path);
  },
  hasSelectableTarget: (e, t) => Kt.hasEditableTarget(e, t) || Kt.isTargetInsideNonReadonlyVoid(e, t),
  hasTarget: (e, t) => Kg(t) && Kt.hasDOMNode(e, t),
  insertData: (e, t) => {
    e.insertData(t);
  },
  insertFragmentData: (e, t) => e.insertFragmentData(t),
  insertTextData: (e, t) => e.insertTextData(t),
  isComposing: (e) => !!Fbe.get(e),
  isFocused: (e) => !!Wf.get(e),
  isReadOnly: (e) => !!pI.get(e),
  isTargetInsideNonReadonlyVoid: (e, t) => {
    if (pI.get(e)) return !1;
    var n = Kt.hasTarget(e, t) && Kt.toSlateNode(e, t);
    return hs.isElement(n) && An.isVoid(e, n);
  },
  setFragmentData: (e, t, n) => e.setFragmentData(t, n),
  toDOMNode: (e, t) => {
    var n = Nbe.get(e), r = An.isEditor(t) ? Ibe.get(e) : n == null ? void 0 : n.get(Kt.findKey(e, t));
    if (!r)
      throw new Error("Cannot resolve a DOM node from Slate node: ".concat(Ho.stringify(t)));
    return r;
  },
  toDOMPoint: (e, t) => {
    var [n] = An.node(e, t.path), r = Kt.toDOMNode(e, n), o;
    An.void(e, {
      at: t
    }) && (t = {
      path: t.path,
      offset: 0
    });
    for (var i = "[data-slate-string], [data-slate-zero-width]", a = Array.from(r.querySelectorAll(i)), s = 0, l = 0; l < a.length; l++) {
      var u = a[l], c = u.childNodes[0];
      if (!(c == null || c.textContent == null)) {
        var {
          length: p
        } = c.textContent, d = u.getAttribute("data-slate-length"), h = d == null ? p : parseInt(d, 10), f = s + h, m = a[l + 1];
        if (t.offset === f && m !== null && m !== void 0 && m.hasAttribute("data-slate-mark-placeholder")) {
          var g, E = m.childNodes[0];
          o = [
            // COMPAT: If we don't explicity set the dom point to be on the actual
            // dom text element, chrome will put the selection behind the actual dom
            // text element, causing domRange.getBoundingClientRect() calls on a collapsed
            // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)
            // which will cause issues when scrolling to it.
            E instanceof $be ? E : m,
            (g = m.textContent) !== null && g !== void 0 && g.startsWith("\uFEFF") ? 1 : 0
          ];
          break;
        }
        if (t.offset <= f) {
          var w = Math.min(p, Math.max(0, t.offset - s));
          o = [c, w];
          break;
        }
        s = f;
      }
    }
    if (!o)
      throw new Error("Cannot resolve a DOM point from Slate point: ".concat(Ho.stringify(t)));
    return o;
  },
  toDOMRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t, o = Bt.isBackward(t), i = Kt.toDOMPoint(e, n), a = Bt.isCollapsed(t) ? i : Kt.toDOMPoint(e, r), s = Kt.getWindow(e), l = s.document.createRange(), [u, c] = o ? a : i, [p, d] = o ? i : a, h = qi(u) ? u : u.parentElement, f = !!h.getAttribute("data-slate-zero-width"), m = qi(p) ? p : p.parentElement, g = !!m.getAttribute("data-slate-zero-width");
    return l.setStart(u, f ? 1 : c), l.setEnd(p, g ? 1 : d), l;
  },
  toSlateNode: (e, t) => {
    var n = qi(t) ? t : t.parentElement;
    n && !n.hasAttribute("data-slate-node") && (n = n.closest("[data-slate-node]"));
    var r = n ? Rbe.get(n) : null;
    if (!r)
      throw new Error("Cannot resolve a Slate node from DOM node: ".concat(n));
    return r;
  },
  toSlatePoint: (e, t, n) => {
    var {
      exactMatch: r,
      suppressThrow: o,
      searchDirection: i = "backward"
    } = n, [a, s] = r ? t : Wbe(t), l = a.parentNode, u = null, c = 0;
    if (l) {
      var p, d, h = Kt.toDOMNode(e, e), f = l.closest('[data-slate-void="true"]'), m = f && h.contains(f) ? f : null, g = l.closest('[contenteditable="false"]'), E = g && h.contains(g) ? g : null, w = l.closest("[data-slate-leaf]"), M = null;
      if (w) {
        if (u = w.closest('[data-slate-node="text"]'), u) {
          var x = Kt.getWindow(e), y = x.document.createRange();
          y.setStart(u, 0), y.setEnd(a, s);
          var C = y.cloneContents(), P = [...Array.prototype.slice.call(C.querySelectorAll("[data-slate-zero-width]")), ...Array.prototype.slice.call(C.querySelectorAll("[contenteditable=false]"))];
          P.forEach((S) => {
            if (D0 && !r && S.hasAttribute("data-slate-zero-width") && S.textContent.length > 0 && S.textContext !== "\uFEFF") {
              S.textContent.startsWith("\uFEFF") && (S.textContent = S.textContent.slice(1));
              return;
            }
            S.parentNode.removeChild(S);
          }), c = C.textContent.length, M = u;
        }
      } else if (m) {
        for (var F = m.querySelectorAll("[data-slate-leaf]"), L = 0; L < F.length; L++) {
          var N = F[L];
          if (Kt.hasDOMNode(e, N)) {
            w = N;
            break;
          }
        }
        w ? (u = w.closest('[data-slate-node="text"]'), M = w, c = M.textContent.length, M.querySelectorAll("[data-slate-zero-width]").forEach((S) => {
          c -= S.textContent.length;
        })) : c = 1;
      } else if (E) {
        var I = (S) => S ? S.querySelectorAll(
          // Exclude leaf nodes in nested editors
          "[data-slate-leaf]:not(:scope [data-slate-editor] [data-slate-leaf])"
        ) : [], H = E.closest('[data-slate-node="element"]');
        if (i === "forward") {
          var V, z = [...I(H), ...I(H == null ? void 0 : H.nextElementSibling)];
          w = (V = z.find((S) => Zbe(E, S))) !== null && V !== void 0 ? V : null;
        } else {
          var q, K = [...I(H == null ? void 0 : H.previousElementSibling), ...I(H)];
          w = (q = K.findLast((S) => hI(E, S))) !== null && q !== void 0 ? q : null;
        }
        w && (u = w.closest('[data-slate-node="text"]'), M = w, i === "forward" ? c = 0 : (c = M.textContent.length, M.querySelectorAll("[data-slate-zero-width]").forEach((S) => {
          c -= S.textContent.length;
        })));
      }
      M && c === M.textContent.length && // COMPAT: Android IMEs might remove the zero width space while composing,
      // and we don't add it for line-breaks.
      D0 && M.getAttribute("data-slate-zero-width") === "z" && (p = M.textContent) !== null && p !== void 0 && p.startsWith("\uFEFF") && // COMPAT: If the parent node is a Slate zero-width space, editor is
      // because the text node should have no characters. However, during IME
      // composition the ASCII characters will be prepended to the zero-width
      // space, so subtract 1 from the offset to account for the zero-width
      // space character.
      (l.hasAttribute("data-slate-zero-width") || // COMPAT: In Firefox, `range.cloneContents()` returns an extra trailing '\n'
      // when the document ends with a new-line character. This results in the offset
      // length being off by one, so we need to subtract one to account for this.
      Hf && (d = M.textContent) !== null && d !== void 0 && d.endsWith(`

`)) && c--;
    }
    if (D0 && !u && !r) {
      var J = l.hasAttribute("data-slate-node") ? l : l.closest("[data-slate-node]");
      if (J && Kt.hasDOMNode(e, J, {
        editable: !0
      })) {
        var te = Kt.toSlateNode(e, J), {
          path: ee,
          offset: _
        } = An.start(e, Kt.findPath(e, te));
        return J.querySelector("[data-slate-leaf]") || (_ = s), {
          path: ee,
          offset: _
        };
      }
    }
    if (!u) {
      if (o)
        return null;
      throw new Error("Cannot resolve a Slate point from DOM point: ".concat(t));
    }
    var D = Kt.toSlateNode(e, u), $ = Kt.findPath(e, D);
    return {
      path: $,
      offset: c
    };
  },
  toSlateRange: (e, t, n) => {
    var r, {
      exactMatch: o,
      suppressThrow: i
    } = n, a = dI(t) ? t.anchorNode : t.startContainer, s, l, u, c, p;
    if (a)
      if (dI(t)) {
        if (Hf && t.rangeCount > 1) {
          u = t.focusNode;
          var d = t.getRangeAt(0), h = t.getRangeAt(t.rangeCount - 1);
          if (u instanceof HTMLTableRowElement && d.startContainer instanceof HTMLTableRowElement && h.startContainer instanceof HTMLTableRowElement) {
            let C = function(P) {
              return P.childElementCount > 0 ? C(P.children[0]) : P;
            };
            var f = d.startContainer, m = h.startContainer, g = C(f.children[d.startOffset]), E = C(m.children[h.startOffset]);
            c = 0, E.childNodes.length > 0 ? s = E.childNodes[0] : s = E, g.childNodes.length > 0 ? u = g.childNodes[0] : u = g, E instanceof HTMLElement ? l = E.innerHTML.length : l = 0;
          } else
            d.startContainer === u ? (s = h.endContainer, l = h.endOffset, c = d.startOffset) : (s = d.startContainer, l = d.endOffset, c = h.startOffset);
        } else
          s = t.anchorNode, l = t.anchorOffset, u = t.focusNode, c = t.focusOffset;
        Tbe && Vbe(s) || Hf ? p = t.anchorNode === t.focusNode && t.anchorOffset === t.focusOffset : p = t.isCollapsed;
      } else
        s = t.startContainer, l = t.startOffset, u = t.endContainer, c = t.endOffset, p = t.collapsed;
    if (s == null || u == null || l == null || c == null)
      throw new Error("Cannot resolve a Slate range from DOM range: ".concat(t));
    Hf && (r = u.textContent) !== null && r !== void 0 && r.endsWith(`

`) && c === u.textContent.length && c--;
    var w = Kt.toSlatePoint(e, [s, l], {
      exactMatch: o,
      suppressThrow: i
    });
    if (!w)
      return null;
    var M = hI(s, u) || s === u && c < l, x = p ? w : Kt.toSlatePoint(e, [u, c], {
      exactMatch: o,
      suppressThrow: i,
      searchDirection: M ? "forward" : "backward"
    });
    if (!x)
      return null;
    var y = {
      anchor: w,
      focus: x
    };
    return Bt.isExpanded(y) && Bt.isForward(y) && qi(u) && An.void(e, {
      at: y.focus,
      mode: "highest"
    }) && (y = An.unhangRange(e, y, {
      voids: !0
    })), y;
  }
}, Kbe = {
  bold: "mod+b",
  compose: ["down", "left", "right", "up", "backspace", "enter"],
  moveBackward: "left",
  moveForward: "right",
  moveWordBackward: "ctrl+left",
  moveWordForward: "ctrl+right",
  deleteBackward: "shift?+backspace",
  deleteForward: "shift?+delete",
  extendBackward: "shift+left",
  extendForward: "shift+right",
  italic: "mod+i",
  insertSoftBreak: "shift+enter",
  splitBlock: "enter",
  undo: "mod+z"
}, Ybe = {
  moveLineBackward: "opt+up",
  moveLineForward: "opt+down",
  moveWordBackward: "opt+left",
  moveWordForward: "opt+right",
  deleteBackward: ["ctrl+backspace", "ctrl+h"],
  deleteForward: ["ctrl+delete", "ctrl+d"],
  deleteLineBackward: "cmd+shift?+backspace",
  deleteLineForward: ["cmd+shift?+delete", "ctrl+k"],
  deleteWordBackward: "opt+shift?+backspace",
  deleteWordForward: "opt+shift?+delete",
  extendLineBackward: "opt+shift+up",
  extendLineForward: "opt+shift+down",
  redo: "cmd+shift+z",
  transposeCharacter: "ctrl+t"
}, Jbe = {
  deleteWordBackward: "ctrl+shift?+backspace",
  deleteWordForward: "ctrl+shift?+delete",
  redo: ["ctrl+y", "ctrl+shift+z"]
}, dr = (e) => {
  var t = Kbe[e], n = Ybe[e], r = Jbe[e], o = t && _0(t), i = n && _0(n), a = r && _0(r);
  return (s) => !!(o && o(s) || uI && i && i(s) || !uI && a && a(s));
};
dr("bold"), dr("compose"), dr("moveBackward"), dr("moveForward"), dr("deleteBackward"), dr("deleteForward"), dr("deleteLineBackward"), dr("deleteLineForward"), dr("deleteWordBackward"), dr("deleteWordForward"), dr("extendBackward"), dr("extendForward"), dr("extendLineBackward"), dr("extendLineForward"), dr("italic"), dr("moveLineBackward"), dr("moveLineForward"), dr("moveWordBackward"), dr("moveWordForward"), dr("redo"), dr("insertSoftBreak"), dr("splitBlock"), dr("transposeCharacter"), dr("undo");
var Qbe = (e, t) => {
  var n = [], r = () => {
    n = [];
  }, o = (a) => {
    if (t.current) {
      var s = a.filter((l) => u6(e, l, a));
      n.push(...s);
    }
  };
  function i() {
    n.length > 0 && (n.reverse().forEach((a) => {
      a.type !== "characterData" && (a.removedNodes.forEach((s) => {
        a.target.insertBefore(s, a.nextSibling);
      }), a.addedNodes.forEach((s) => {
        a.target.removeChild(s);
      }));
    }), r());
  }
  return {
    registerMutations: o,
    restoreDOM: i,
    clear: r
  };
}, e0e = {
  subtree: !0,
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0
};
class t0e extends pu {
  constructor() {
    super(...arguments), Fc(this, "context", null), Fc(this, "manager", null), Fc(this, "mutationObserver", null);
  }
  observe() {
    var t, {
      node: n
    } = this.props;
    if (!n.current)
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    (t = this.mutationObserver) === null || t === void 0 || t.observe(n.current, e0e);
  }
  componentDidMount() {
    var {
      receivedUserInput: t
    } = this.props, n = this.context;
    this.manager = Qbe(n, t), this.mutationObserver = new MutationObserver(this.manager.registerMutations), this.observe();
  }
  getSnapshotBeforeUpdate() {
    var t, n, r, o = (t = this.mutationObserver) === null || t === void 0 ? void 0 : t.takeRecords();
    if (o != null && o.length) {
      var i;
      (i = this.manager) === null || i === void 0 || i.registerMutations(o);
    }
    return (n = this.mutationObserver) === null || n === void 0 || n.disconnect(), (r = this.manager) === null || r === void 0 || r.restoreDOM(), null;
  }
  componentDidUpdate() {
    var t;
    (t = this.manager) === null || t === void 0 || t.clear(), this.observe();
  }
  componentWillUnmount() {
    var t;
    (t = this.mutationObserver) === null || t === void 0 || t.disconnect();
  }
  render() {
    return this.props.children;
  }
}
Fc(t0e, "contextType", Dbe);
Ze({});
Ze({});
Ze({});
var $r = {}, Ik = {}, ad = {}, ld = {}, c6 = "Expected a function", gI = NaN, n0e = "[object Symbol]", r0e = /^\s+|\s+$/g, o0e = /^[-+]0x[0-9a-f]+$/i, i0e = /^0b[01]+$/i, s0e = /^0o[0-7]+$/i, a0e = parseInt, l0e = typeof zn == "object" && zn && zn.Object === Object && zn, u0e = typeof self == "object" && self && self.Object === Object && self, c0e = l0e || u0e || Function("return this")(), p0e = Object.prototype, d0e = p0e.toString, f0e = Math.max, h0e = Math.min, T0 = function() {
  return c0e.Date.now();
};
function g0e(e, t, n) {
  var r, o, i, a, s, l, u = 0, c = !1, p = !1, d = !0;
  if (typeof e != "function")
    throw new TypeError(c6);
  t = mI(t) || 0, Yg(n) && (c = !!n.leading, p = "maxWait" in n, i = p ? f0e(mI(n.maxWait) || 0, t) : i, d = "trailing" in n ? !!n.trailing : d);
  function h(C) {
    var P = r, F = o;
    return r = o = void 0, u = C, a = e.apply(F, P), a;
  }
  function f(C) {
    return u = C, s = setTimeout(E, t), c ? h(C) : a;
  }
  function m(C) {
    var P = C - l, F = C - u, L = t - P;
    return p ? h0e(L, i - F) : L;
  }
  function g(C) {
    var P = C - l, F = C - u;
    return l === void 0 || P >= t || P < 0 || p && F >= i;
  }
  function E() {
    var C = T0();
    if (g(C))
      return w(C);
    s = setTimeout(E, m(C));
  }
  function w(C) {
    return s = void 0, d && r ? h(C) : (r = o = void 0, a);
  }
  function M() {
    s !== void 0 && clearTimeout(s), u = 0, r = l = o = s = void 0;
  }
  function x() {
    return s === void 0 ? a : w(T0());
  }
  function y() {
    var C = T0(), P = g(C);
    if (r = arguments, o = this, l = C, P) {
      if (s === void 0)
        return f(l);
      if (p)
        return s = setTimeout(E, t), h(l);
    }
    return s === void 0 && (s = setTimeout(E, t)), a;
  }
  return y.cancel = M, y.flush = x, y;
}
function m0e(e, t, n) {
  var r = !0, o = !0;
  if (typeof e != "function")
    throw new TypeError(c6);
  return Yg(n) && (r = "leading" in n ? !!n.leading : r, o = "trailing" in n ? !!n.trailing : o), g0e(e, t, {
    leading: r,
    maxWait: t,
    trailing: o
  });
}
function Yg(e) {
  var t = typeof e;
  return !!e && (t == "object" || t == "function");
}
function v0e(e) {
  return !!e && typeof e == "object";
}
function y0e(e) {
  return typeof e == "symbol" || v0e(e) && d0e.call(e) == n0e;
}
function mI(e) {
  if (typeof e == "number")
    return e;
  if (y0e(e))
    return gI;
  if (Yg(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = Yg(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = e.replace(r0e, "");
  var n = i0e.test(e);
  return n || s0e.test(e) ? a0e(e.slice(2), n ? 2 : 8) : o0e.test(e) ? gI : +e;
}
var b0e = m0e, ud = {};
Object.defineProperty(ud, "__esModule", {
  value: !0
});
ud.addPassiveEventListener = function(e, t, n) {
  var r = n.name;
  r || (r = t, console.warn("Listener must be a named function.")), Dh.has(t) || Dh.set(t, /* @__PURE__ */ new Set());
  var o = Dh.get(t);
  if (!o.has(r)) {
    var i = function() {
      var a = !1;
      try {
        var s = Object.defineProperty({}, "passive", {
          get: function() {
            a = !0;
          }
        });
        window.addEventListener("test", null, s);
      } catch {
      }
      return a;
    }();
    e.addEventListener(t, n, i ? { passive: !0 } : !1), o.add(r);
  }
};
ud.removePassiveEventListener = function(e, t, n) {
  e.removeEventListener(t, n), Dh.get(t).delete(n.name || t);
};
var Dh = /* @__PURE__ */ new Map();
Object.defineProperty(ld, "__esModule", {
  value: !0
});
var w0e = b0e, C0e = x0e(w0e), vI = ud;
function x0e(e) {
  return e && e.__esModule ? e : { default: e };
}
var O0e = function(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 66;
  return (0, C0e.default)(e, t);
}, kr = {
  spyCallbacks: [],
  spySetState: [],
  scrollSpyContainers: [],
  mount: function(e, t) {
    if (e) {
      var n = O0e(function(r) {
        kr.scrollHandler(e);
      }, t);
      return kr.scrollSpyContainers.push(e), (0, vI.addPassiveEventListener)(e, "scroll", n), function() {
        (0, vI.removePassiveEventListener)(e, "scroll", n), kr.scrollSpyContainers.splice(kr.scrollSpyContainers.indexOf(e), 1);
      };
    }
    return function() {
    };
  },
  isMounted: function(e) {
    return kr.scrollSpyContainers.indexOf(e) !== -1;
  },
  currentPositionX: function(e) {
    if (e === document) {
      var t = window.scrollY !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.scrollX : n ? document.documentElement.scrollLeft : document.body.scrollLeft;
    } else
      return e.scrollLeft;
  },
  currentPositionY: function(e) {
    if (e === document) {
      var t = window.scrollX !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.scrollY : n ? document.documentElement.scrollTop : document.body.scrollTop;
    } else
      return e.scrollTop;
  },
  scrollHandler: function(e) {
    var t = kr.scrollSpyContainers[kr.scrollSpyContainers.indexOf(e)].spyCallbacks || [];
    t.forEach(function(n) {
      return n(kr.currentPositionX(e), kr.currentPositionY(e));
    });
  },
  addStateHandler: function(e) {
    kr.spySetState.push(e);
  },
  addSpyHandler: function(e, t) {
    var n = kr.scrollSpyContainers[kr.scrollSpyContainers.indexOf(t)];
    n.spyCallbacks || (n.spyCallbacks = []), n.spyCallbacks.push(e);
  },
  updateStates: function() {
    kr.spySetState.forEach(function(e) {
      return e();
    });
  },
  unmount: function(e, t) {
    kr.scrollSpyContainers.forEach(function(n) {
      return n.spyCallbacks && n.spyCallbacks.length && n.spyCallbacks.indexOf(t) > -1 && n.spyCallbacks.splice(n.spyCallbacks.indexOf(t), 1);
    }), kr.spySetState && kr.spySetState.length && kr.spySetState.indexOf(e) > -1 && kr.spySetState.splice(kr.spySetState.indexOf(e), 1), document.removeEventListener("scroll", kr.scrollHandler);
  },
  update: function() {
    return kr.scrollSpyContainers.forEach(function(e) {
      return kr.scrollHandler(e);
    });
  }
};
ld.default = kr;
var Eu = {}, cd = {};
Object.defineProperty(cd, "__esModule", {
  value: !0
});
var E0e = function(e, t) {
  var n = e.indexOf("#") === 0 ? e.substring(1) : e, r = n ? "#" + n : "", o = window && window.location, i = r ? o.pathname + o.search + r : o.pathname + o.search;
  t ? history.pushState(history.state, "", i) : history.replaceState(history.state, "", i);
}, k0e = function() {
  return window.location.hash.replace(/^#/, "");
}, L0e = function(e) {
  return function(t) {
    return e.contains ? e != t && e.contains(t) : !!(e.compareDocumentPosition(t) & 16);
  };
}, _0e = function(e) {
  return getComputedStyle(e).position !== "static";
}, j0 = function(e, t) {
  for (var n = e.offsetTop, r = e.offsetParent; r && !t(r); )
    n += r.offsetTop, r = r.offsetParent;
  return { offsetTop: n, offsetParent: r };
}, P0e = function(e, t, n) {
  if (n)
    return e === document ? t.getBoundingClientRect().left + (window.scrollX || window.pageXOffset) : getComputedStyle(e).position !== "static" ? t.offsetLeft : t.offsetLeft - e.offsetLeft;
  if (e === document)
    return t.getBoundingClientRect().top + (window.scrollY || window.pageYOffset);
  if (_0e(e)) {
    if (t.offsetParent !== e) {
      var r = function(l) {
        return l === e || l === document;
      }, o = j0(t, r), i = o.offsetTop, a = o.offsetParent;
      if (a !== e)
        throw new Error("Seems containerElement is not an ancestor of the Element");
      return i;
    }
    return t.offsetTop;
  }
  if (t.offsetParent === e.offsetParent)
    return t.offsetTop - e.offsetTop;
  var s = function(l) {
    return l === document;
  };
  return j0(t, s).offsetTop - j0(e, s).offsetTop;
};
cd.default = {
  updateHash: E0e,
  getHash: k0e,
  filterElementInContainer: L0e,
  scrollOffset: P0e
};
var yy = {}, Rk = {};
Object.defineProperty(Rk, "__esModule", {
  value: !0
});
Rk.default = {
  /*
   * https://github.com/oblador/angular-scroll (duScrollDefaultEasing)
   */
  defaultEasing: function(e) {
    return e < 0.5 ? Math.pow(e * 2, 2) / 2 : 1 - Math.pow((1 - e) * 2, 2) / 2;
  },
  /*
   * https://gist.github.com/gre/1650294
   */
  // no easing, no acceleration
  linear: function(e) {
    return e;
  },
  // accelerating from zero velocity
  easeInQuad: function(e) {
    return e * e;
  },
  // decelerating to zero velocity
  easeOutQuad: function(e) {
    return e * (2 - e);
  },
  // acceleration until halfway, then deceleration
  easeInOutQuad: function(e) {
    return e < 0.5 ? 2 * e * e : -1 + (4 - 2 * e) * e;
  },
  // accelerating from zero velocity 
  easeInCubic: function(e) {
    return e * e * e;
  },
  // decelerating to zero velocity 
  easeOutCubic: function(e) {
    return --e * e * e + 1;
  },
  // acceleration until halfway, then deceleration 
  easeInOutCubic: function(e) {
    return e < 0.5 ? 4 * e * e * e : (e - 1) * (2 * e - 2) * (2 * e - 2) + 1;
  },
  // accelerating from zero velocity 
  easeInQuart: function(e) {
    return e * e * e * e;
  },
  // decelerating to zero velocity 
  easeOutQuart: function(e) {
    return 1 - --e * e * e * e;
  },
  // acceleration until halfway, then deceleration
  easeInOutQuart: function(e) {
    return e < 0.5 ? 8 * e * e * e * e : 1 - 8 * --e * e * e * e;
  },
  // accelerating from zero velocity
  easeInQuint: function(e) {
    return e * e * e * e * e;
  },
  // decelerating to zero velocity
  easeOutQuint: function(e) {
    return 1 + --e * e * e * e * e;
  },
  // acceleration until halfway, then deceleration 
  easeInOutQuint: function(e) {
    return e < 0.5 ? 16 * e * e * e * e * e : 1 + 16 * --e * e * e * e * e;
  }
};
var Nk = {};
Object.defineProperty(Nk, "__esModule", {
  value: !0
});
var S0e = ud, M0e = ["mousedown", "wheel", "touchmove", "keydown"];
Nk.default = {
  subscribe: function(e) {
    return typeof document < "u" && M0e.forEach(function(t) {
      return (0, S0e.addPassiveEventListener)(document, t, e);
    });
  }
};
var pd = {};
Object.defineProperty(pd, "__esModule", {
  value: !0
});
var vx = {
  registered: {},
  scrollEvent: {
    register: function(e, t) {
      vx.registered[e] = t;
    },
    remove: function(e) {
      vx.registered[e] = null;
    }
  }
};
pd.default = vx;
Object.defineProperty(yy, "__esModule", {
  value: !0
});
var D0e = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, T0e = cd;
by(T0e);
var j0e = Rk, yI = by(j0e), A0e = Nk, B0e = by(A0e), I0e = pd, zi = by(I0e);
function by(e) {
  return e && e.__esModule ? e : { default: e };
}
var p6 = function(e) {
  return yI.default[e.smooth] || yI.default.defaultEasing;
}, R0e = function(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}, N0e = function() {
  if (typeof window < "u")
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame;
}, yx = function() {
  return N0e() || function(e, t, n) {
    window.setTimeout(e, n || 1e3 / 60, (/* @__PURE__ */ new Date()).getTime());
  };
}(), d6 = function() {
  return {
    currentPosition: 0,
    startPosition: 0,
    targetPosition: 0,
    progress: 0,
    duration: 0,
    cancel: !1,
    target: null,
    containerElement: null,
    to: null,
    start: null,
    delta: null,
    percent: null,
    delayTimeout: null
  };
}, f6 = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollLeft;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageXOffset : r ? document.documentElement.scrollLeft : document.body.scrollLeft;
}, h6 = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollTop;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageYOffset : r ? document.documentElement.scrollTop : document.body.scrollTop;
}, F0e = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollWidth - t.offsetWidth;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollWidth, n.offsetWidth, r.clientWidth, r.scrollWidth, r.offsetWidth);
}, z0e = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollHeight - t.offsetHeight;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollHeight, n.offsetHeight, r.clientHeight, r.scrollHeight, r.offsetHeight);
}, U0e = function e(t, n, r) {
  var o = n.data;
  if (!n.ignoreCancelEvents && o.cancel) {
    zi.default.registered.end && zi.default.registered.end(o.to, o.target, o.currentPositionY);
    return;
  }
  if (o.delta = Math.round(o.targetPosition - o.startPosition), o.start === null && (o.start = r), o.progress = r - o.start, o.percent = o.progress >= o.duration ? 1 : t(o.progress / o.duration), o.currentPosition = o.startPosition + Math.ceil(o.delta * o.percent), o.containerElement && o.containerElement !== document && o.containerElement !== document.body ? n.horizontal ? o.containerElement.scrollLeft = o.currentPosition : o.containerElement.scrollTop = o.currentPosition : n.horizontal ? window.scrollTo(o.currentPosition, 0) : window.scrollTo(0, o.currentPosition), o.percent < 1) {
    var i = e.bind(null, t, n);
    yx.call(window, i);
    return;
  }
  zi.default.registered.end && zi.default.registered.end(o.to, o.target, o.currentPosition);
}, Fk = function(e) {
  e.data.containerElement = e ? e.containerId ? document.getElementById(e.containerId) : e.container && e.container.nodeType ? e.container : document : null;
}, dd = function(e, t, n, r) {
  t.data = t.data || d6(), window.clearTimeout(t.data.delayTimeout);
  var o = function() {
    t.data.cancel = !0;
  };
  if (B0e.default.subscribe(o), Fk(t), t.data.start = null, t.data.cancel = !1, t.data.startPosition = t.horizontal ? f6(t) : h6(t), t.data.targetPosition = t.absolute ? e : e + t.data.startPosition, t.data.startPosition === t.data.targetPosition) {
    zi.default.registered.end && zi.default.registered.end(t.data.to, t.data.target, t.data.currentPosition);
    return;
  }
  t.data.delta = Math.round(t.data.targetPosition - t.data.startPosition), t.data.duration = R0e(t.duration)(t.data.delta), t.data.duration = isNaN(parseFloat(t.data.duration)) ? 1e3 : parseFloat(t.data.duration), t.data.to = n, t.data.target = r;
  var i = p6(t), a = U0e.bind(null, i, t);
  if (t && t.delay > 0) {
    t.data.delayTimeout = window.setTimeout(function() {
      zi.default.registered.begin && zi.default.registered.begin(t.data.to, t.data.target), yx.call(window, a);
    }, t.delay);
    return;
  }
  zi.default.registered.begin && zi.default.registered.begin(t.data.to, t.data.target), yx.call(window, a);
}, wy = function(e) {
  return e = D0e({}, e), e.data = e.data || d6(), e.absolute = !0, e;
}, $0e = function(e) {
  dd(0, wy(e));
}, H0e = function(e, t) {
  dd(e, wy(t));
}, W0e = function(e) {
  e = wy(e), Fk(e), dd(e.horizontal ? F0e(e) : z0e(e), e);
}, V0e = function(e, t) {
  t = wy(t), Fk(t);
  var n = t.horizontal ? f6(t) : h6(t);
  dd(e + n, t);
};
yy.default = {
  animateTopScroll: dd,
  getAnimationType: p6,
  scrollToTop: $0e,
  scrollToBottom: W0e,
  scrollTo: H0e,
  scrollMore: V0e
};
Object.defineProperty(Eu, "__esModule", {
  value: !0
});
var q0e = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, Z0e = cd, G0e = zk(Z0e), X0e = yy, K0e = zk(X0e), Y0e = pd, Vf = zk(Y0e);
function zk(e) {
  return e && e.__esModule ? e : { default: e };
}
var qf = {}, bI = void 0;
Eu.default = {
  unmount: function() {
    qf = {};
  },
  register: function(e, t) {
    qf[e] = t;
  },
  unregister: function(e) {
    delete qf[e];
  },
  get: function(e) {
    return qf[e] || document.getElementById(e) || document.getElementsByName(e)[0] || document.getElementsByClassName(e)[0];
  },
  setActiveLink: function(e) {
    return bI = e;
  },
  getActiveLink: function() {
    return bI;
  },
  scrollTo: function(e, t) {
    var n = this.get(e);
    if (!n) {
      console.warn("target Element not found");
      return;
    }
    t = q0e({}, t, { absolute: !1 });
    var r = t.containerId, o = t.container, i = void 0;
    r ? i = document.getElementById(r) : o && o.nodeType ? i = o : i = document, t.absolute = !0;
    var a = t.horizontal, s = G0e.default.scrollOffset(i, n, a) + (t.offset || 0);
    if (!t.smooth) {
      Vf.default.registered.begin && Vf.default.registered.begin(e, n), i === document ? t.horizontal ? window.scrollTo(s, 0) : window.scrollTo(0, s) : i.scrollTop = s, Vf.default.registered.end && Vf.default.registered.end(e, n);
      return;
    }
    K0e.default.animateTopScroll(s, t, e, n);
  }
};
var bx = { exports: {} }, A0 = { exports: {} }, wn = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var wI;
function J0e() {
  if (wI) return wn;
  wI = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, h = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, m = e ? Symbol.for("react.block") : 60121, g = e ? Symbol.for("react.fundamental") : 60117, E = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
  function M(y) {
    if (typeof y == "object" && y !== null) {
      var C = y.$$typeof;
      switch (C) {
        case t:
          switch (y = y.type, y) {
            case l:
            case u:
            case r:
            case i:
            case o:
            case p:
              return y;
            default:
              switch (y = y && y.$$typeof, y) {
                case s:
                case c:
                case f:
                case h:
                case a:
                  return y;
                default:
                  return C;
              }
          }
        case n:
          return C;
      }
    }
  }
  function x(y) {
    return M(y) === u;
  }
  return wn.AsyncMode = l, wn.ConcurrentMode = u, wn.ContextConsumer = s, wn.ContextProvider = a, wn.Element = t, wn.ForwardRef = c, wn.Fragment = r, wn.Lazy = f, wn.Memo = h, wn.Portal = n, wn.Profiler = i, wn.StrictMode = o, wn.Suspense = p, wn.isAsyncMode = function(y) {
    return x(y) || M(y) === l;
  }, wn.isConcurrentMode = x, wn.isContextConsumer = function(y) {
    return M(y) === s;
  }, wn.isContextProvider = function(y) {
    return M(y) === a;
  }, wn.isElement = function(y) {
    return typeof y == "object" && y !== null && y.$$typeof === t;
  }, wn.isForwardRef = function(y) {
    return M(y) === c;
  }, wn.isFragment = function(y) {
    return M(y) === r;
  }, wn.isLazy = function(y) {
    return M(y) === f;
  }, wn.isMemo = function(y) {
    return M(y) === h;
  }, wn.isPortal = function(y) {
    return M(y) === n;
  }, wn.isProfiler = function(y) {
    return M(y) === i;
  }, wn.isStrictMode = function(y) {
    return M(y) === o;
  }, wn.isSuspense = function(y) {
    return M(y) === p;
  }, wn.isValidElementType = function(y) {
    return typeof y == "string" || typeof y == "function" || y === r || y === u || y === i || y === o || y === p || y === d || typeof y == "object" && y !== null && (y.$$typeof === f || y.$$typeof === h || y.$$typeof === a || y.$$typeof === s || y.$$typeof === c || y.$$typeof === g || y.$$typeof === E || y.$$typeof === w || y.$$typeof === m);
  }, wn.typeOf = M, wn;
}
var Mn = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var CI;
function Q0e() {
  return CI || (CI = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, h = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, m = e ? Symbol.for("react.block") : 60121, g = e ? Symbol.for("react.fundamental") : 60117, E = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
    function M(R) {
      return typeof R == "string" || typeof R == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      R === r || R === u || R === i || R === o || R === p || R === d || typeof R == "object" && R !== null && (R.$$typeof === f || R.$$typeof === h || R.$$typeof === a || R.$$typeof === s || R.$$typeof === c || R.$$typeof === g || R.$$typeof === E || R.$$typeof === w || R.$$typeof === m);
    }
    function x(R) {
      if (typeof R == "object" && R !== null) {
        var ue = R.$$typeof;
        switch (ue) {
          case t:
            var fe = R.type;
            switch (fe) {
              case l:
              case u:
              case r:
              case i:
              case o:
              case p:
                return fe;
              default:
                var oe = fe && fe.$$typeof;
                switch (oe) {
                  case s:
                  case c:
                  case f:
                  case h:
                  case a:
                    return oe;
                  default:
                    return ue;
                }
            }
          case n:
            return ue;
        }
      }
    }
    var y = l, C = u, P = s, F = a, L = t, N = c, I = r, H = f, V = h, z = n, q = i, K = o, J = p, te = !1;
    function ee(R) {
      return te || (te = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), _(R) || x(R) === l;
    }
    function _(R) {
      return x(R) === u;
    }
    function D(R) {
      return x(R) === s;
    }
    function $(R) {
      return x(R) === a;
    }
    function S(R) {
      return typeof R == "object" && R !== null && R.$$typeof === t;
    }
    function W(R) {
      return x(R) === c;
    }
    function O(R) {
      return x(R) === r;
    }
    function T(R) {
      return x(R) === f;
    }
    function U(R) {
      return x(R) === h;
    }
    function j(R) {
      return x(R) === n;
    }
    function Z(R) {
      return x(R) === i;
    }
    function A(R) {
      return x(R) === o;
    }
    function Q(R) {
      return x(R) === p;
    }
    Mn.AsyncMode = y, Mn.ConcurrentMode = C, Mn.ContextConsumer = P, Mn.ContextProvider = F, Mn.Element = L, Mn.ForwardRef = N, Mn.Fragment = I, Mn.Lazy = H, Mn.Memo = V, Mn.Portal = z, Mn.Profiler = q, Mn.StrictMode = K, Mn.Suspense = J, Mn.isAsyncMode = ee, Mn.isConcurrentMode = _, Mn.isContextConsumer = D, Mn.isContextProvider = $, Mn.isElement = S, Mn.isForwardRef = W, Mn.isFragment = O, Mn.isLazy = T, Mn.isMemo = U, Mn.isPortal = j, Mn.isProfiler = Z, Mn.isStrictMode = A, Mn.isSuspense = Q, Mn.isValidElementType = M, Mn.typeOf = x;
  }()), Mn;
}
var xI;
function g6() {
  return xI || (xI = 1, process.env.NODE_ENV === "production" ? A0.exports = J0e() : A0.exports = Q0e()), A0.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var B0, OI;
function ewe() {
  if (OI) return B0;
  OI = 1;
  var e = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, n = Object.prototype.propertyIsEnumerable;
  function r(i) {
    if (i == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(i);
  }
  function o() {
    try {
      if (!Object.assign)
        return !1;
      var i = new String("abc");
      if (i[5] = "de", Object.getOwnPropertyNames(i)[0] === "5")
        return !1;
      for (var a = {}, s = 0; s < 10; s++)
        a["_" + String.fromCharCode(s)] = s;
      var l = Object.getOwnPropertyNames(a).map(function(c) {
        return a[c];
      });
      if (l.join("") !== "0123456789")
        return !1;
      var u = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(c) {
        u[c] = c;
      }), Object.keys(Object.assign({}, u)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return B0 = o() ? Object.assign : function(i, a) {
    for (var s, l = r(i), u, c = 1; c < arguments.length; c++) {
      s = Object(arguments[c]);
      for (var p in s)
        t.call(s, p) && (l[p] = s[p]);
      if (e) {
        u = e(s);
        for (var d = 0; d < u.length; d++)
          n.call(s, u[d]) && (l[u[d]] = s[u[d]]);
      }
    }
    return l;
  }, B0;
}
var I0, EI;
function Uk() {
  if (EI) return I0;
  EI = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return I0 = e, I0;
}
var kI, LI;
function m6() {
  return LI || (LI = 1, kI = Function.call.bind(Object.prototype.hasOwnProperty)), kI;
}
var R0, _I;
function twe() {
  if (_I) return R0;
  _I = 1;
  var e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = Uk(), n = {}, r = m6();
    e = function(i) {
      var a = "Warning: " + i;
      typeof console < "u" && console.error(a);
      try {
        throw new Error(a);
      } catch {
      }
    };
  }
  function o(i, a, s, l, u) {
    if (process.env.NODE_ENV !== "production") {
      for (var c in i)
        if (r(i, c)) {
          var p;
          try {
            if (typeof i[c] != "function") {
              var d = Error(
                (l || "React class") + ": " + s + " type `" + c + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof i[c] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw d.name = "Invariant Violation", d;
            }
            p = i[c](a, c, l, s, null, t);
          } catch (f) {
            p = f;
          }
          if (p && !(p instanceof Error) && e(
            (l || "React class") + ": type specification of " + s + " `" + c + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof p + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), p instanceof Error && !(p.message in n)) {
            n[p.message] = !0;
            var h = u ? u() : "";
            e(
              "Failed " + s + " type: " + p.message + (h ?? "")
            );
          }
        }
    }
  }
  return o.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (n = {});
  }, R0 = o, R0;
}
var N0, PI;
function nwe() {
  if (PI) return N0;
  PI = 1;
  var e = g6(), t = ewe(), n = Uk(), r = m6(), o = twe(), i = function() {
  };
  process.env.NODE_ENV !== "production" && (i = function(s) {
    var l = "Warning: " + s;
    typeof console < "u" && console.error(l);
    try {
      throw new Error(l);
    } catch {
    }
  });
  function a() {
    return null;
  }
  return N0 = function(s, l) {
    var u = typeof Symbol == "function" && Symbol.iterator, c = "@@iterator";
    function p(_) {
      var D = _ && (u && _[u] || _[c]);
      if (typeof D == "function")
        return D;
    }
    var d = "<<anonymous>>", h = {
      array: E("array"),
      bigint: E("bigint"),
      bool: E("boolean"),
      func: E("function"),
      number: E("number"),
      object: E("object"),
      string: E("string"),
      symbol: E("symbol"),
      any: w(),
      arrayOf: M,
      element: x(),
      elementType: y(),
      instanceOf: C,
      node: N(),
      objectOf: F,
      oneOf: P,
      oneOfType: L,
      shape: H,
      exact: V
    };
    function f(_, D) {
      return _ === D ? _ !== 0 || 1 / _ === 1 / D : _ !== _ && D !== D;
    }
    function m(_, D) {
      this.message = _, this.data = D && typeof D == "object" ? D : {}, this.stack = "";
    }
    m.prototype = Error.prototype;
    function g(_) {
      if (process.env.NODE_ENV !== "production")
        var D = {}, $ = 0;
      function S(O, T, U, j, Z, A, Q) {
        if (j = j || d, A = A || U, Q !== n) {
          if (l) {
            var R = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw R.name = "Invariant Violation", R;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var ue = j + ":" + U;
            !D[ue] && // Avoid spamming the console because they are often not actionable except for lib authors
            $ < 3 && (i(
              "You are manually calling a React.PropTypes validation function for the `" + A + "` prop on `" + j + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), D[ue] = !0, $++);
          }
        }
        return T[U] == null ? O ? T[U] === null ? new m("The " + Z + " `" + A + "` is marked as required " + ("in `" + j + "`, but its value is `null`.")) : new m("The " + Z + " `" + A + "` is marked as required in " + ("`" + j + "`, but its value is `undefined`.")) : null : _(T, U, j, Z, A);
      }
      var W = S.bind(null, !1);
      return W.isRequired = S.bind(null, !0), W;
    }
    function E(_) {
      function D($, S, W, O, T, U) {
        var j = $[S], Z = K(j);
        if (Z !== _) {
          var A = J(j);
          return new m(
            "Invalid " + O + " `" + T + "` of type " + ("`" + A + "` supplied to `" + W + "`, expected ") + ("`" + _ + "`."),
            { expectedType: _ }
          );
        }
        return null;
      }
      return g(D);
    }
    function w() {
      return g(a);
    }
    function M(_) {
      function D($, S, W, O, T) {
        if (typeof _ != "function")
          return new m("Property `" + T + "` of component `" + W + "` has invalid PropType notation inside arrayOf.");
        var U = $[S];
        if (!Array.isArray(U)) {
          var j = K(U);
          return new m("Invalid " + O + " `" + T + "` of type " + ("`" + j + "` supplied to `" + W + "`, expected an array."));
        }
        for (var Z = 0; Z < U.length; Z++) {
          var A = _(U, Z, W, O, T + "[" + Z + "]", n);
          if (A instanceof Error)
            return A;
        }
        return null;
      }
      return g(D);
    }
    function x() {
      function _(D, $, S, W, O) {
        var T = D[$];
        if (!s(T)) {
          var U = K(T);
          return new m("Invalid " + W + " `" + O + "` of type " + ("`" + U + "` supplied to `" + S + "`, expected a single ReactElement."));
        }
        return null;
      }
      return g(_);
    }
    function y() {
      function _(D, $, S, W, O) {
        var T = D[$];
        if (!e.isValidElementType(T)) {
          var U = K(T);
          return new m("Invalid " + W + " `" + O + "` of type " + ("`" + U + "` supplied to `" + S + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return g(_);
    }
    function C(_) {
      function D($, S, W, O, T) {
        if (!($[S] instanceof _)) {
          var U = _.name || d, j = ee($[S]);
          return new m("Invalid " + O + " `" + T + "` of type " + ("`" + j + "` supplied to `" + W + "`, expected ") + ("instance of `" + U + "`."));
        }
        return null;
      }
      return g(D);
    }
    function P(_) {
      if (!Array.isArray(_))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? i(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : i("Invalid argument supplied to oneOf, expected an array.")), a;
      function D($, S, W, O, T) {
        for (var U = $[S], j = 0; j < _.length; j++)
          if (f(U, _[j]))
            return null;
        var Z = JSON.stringify(_, function(A, Q) {
          var R = J(Q);
          return R === "symbol" ? String(Q) : Q;
        });
        return new m("Invalid " + O + " `" + T + "` of value `" + String(U) + "` " + ("supplied to `" + W + "`, expected one of " + Z + "."));
      }
      return g(D);
    }
    function F(_) {
      function D($, S, W, O, T) {
        if (typeof _ != "function")
          return new m("Property `" + T + "` of component `" + W + "` has invalid PropType notation inside objectOf.");
        var U = $[S], j = K(U);
        if (j !== "object")
          return new m("Invalid " + O + " `" + T + "` of type " + ("`" + j + "` supplied to `" + W + "`, expected an object."));
        for (var Z in U)
          if (r(U, Z)) {
            var A = _(U, Z, W, O, T + "." + Z, n);
            if (A instanceof Error)
              return A;
          }
        return null;
      }
      return g(D);
    }
    function L(_) {
      if (!Array.isArray(_))
        return process.env.NODE_ENV !== "production" && i("Invalid argument supplied to oneOfType, expected an instance of array."), a;
      for (var D = 0; D < _.length; D++) {
        var $ = _[D];
        if (typeof $ != "function")
          return i(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + te($) + " at index " + D + "."
          ), a;
      }
      function S(W, O, T, U, j) {
        for (var Z = [], A = 0; A < _.length; A++) {
          var Q = _[A], R = Q(W, O, T, U, j, n);
          if (R == null)
            return null;
          R.data && r(R.data, "expectedType") && Z.push(R.data.expectedType);
        }
        var ue = Z.length > 0 ? ", expected one of type [" + Z.join(", ") + "]" : "";
        return new m("Invalid " + U + " `" + j + "` supplied to " + ("`" + T + "`" + ue + "."));
      }
      return g(S);
    }
    function N() {
      function _(D, $, S, W, O) {
        return z(D[$]) ? null : new m("Invalid " + W + " `" + O + "` supplied to " + ("`" + S + "`, expected a ReactNode."));
      }
      return g(_);
    }
    function I(_, D, $, S, W) {
      return new m(
        (_ || "React class") + ": " + D + " type `" + $ + "." + S + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + W + "`."
      );
    }
    function H(_) {
      function D($, S, W, O, T) {
        var U = $[S], j = K(U);
        if (j !== "object")
          return new m("Invalid " + O + " `" + T + "` of type `" + j + "` " + ("supplied to `" + W + "`, expected `object`."));
        for (var Z in _) {
          var A = _[Z];
          if (typeof A != "function")
            return I(W, O, T, Z, J(A));
          var Q = A(U, Z, W, O, T + "." + Z, n);
          if (Q)
            return Q;
        }
        return null;
      }
      return g(D);
    }
    function V(_) {
      function D($, S, W, O, T) {
        var U = $[S], j = K(U);
        if (j !== "object")
          return new m("Invalid " + O + " `" + T + "` of type `" + j + "` " + ("supplied to `" + W + "`, expected `object`."));
        var Z = t({}, $[S], _);
        for (var A in Z) {
          var Q = _[A];
          if (r(_, A) && typeof Q != "function")
            return I(W, O, T, A, J(Q));
          if (!Q)
            return new m(
              "Invalid " + O + " `" + T + "` key `" + A + "` supplied to `" + W + "`.\nBad object: " + JSON.stringify($[S], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(_), null, "  ")
            );
          var R = Q(U, A, W, O, T + "." + A, n);
          if (R)
            return R;
        }
        return null;
      }
      return g(D);
    }
    function z(_) {
      switch (typeof _) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !_;
        case "object":
          if (Array.isArray(_))
            return _.every(z);
          if (_ === null || s(_))
            return !0;
          var D = p(_);
          if (D) {
            var $ = D.call(_), S;
            if (D !== _.entries) {
              for (; !(S = $.next()).done; )
                if (!z(S.value))
                  return !1;
            } else
              for (; !(S = $.next()).done; ) {
                var W = S.value;
                if (W && !z(W[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function q(_, D) {
      return _ === "symbol" ? !0 : D ? D["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && D instanceof Symbol : !1;
    }
    function K(_) {
      var D = typeof _;
      return Array.isArray(_) ? "array" : _ instanceof RegExp ? "object" : q(D, _) ? "symbol" : D;
    }
    function J(_) {
      if (typeof _ > "u" || _ === null)
        return "" + _;
      var D = K(_);
      if (D === "object") {
        if (_ instanceof Date)
          return "date";
        if (_ instanceof RegExp)
          return "regexp";
      }
      return D;
    }
    function te(_) {
      var D = J(_);
      switch (D) {
        case "array":
        case "object":
          return "an " + D;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + D;
        default:
          return D;
      }
    }
    function ee(_) {
      return !_.constructor || !_.constructor.name ? d : _.constructor.name;
    }
    return h.checkPropTypes = o, h.resetWarningCache = o.resetWarningCache, h.PropTypes = h, h;
  }, N0;
}
var F0, SI;
function rwe() {
  if (SI) return F0;
  SI = 1;
  var e = Uk();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, F0 = function() {
    function r(a, s, l, u, c, p) {
      if (p !== e) {
        var d = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw d.name = "Invariant Violation", d;
      }
    }
    r.isRequired = r;
    function o() {
      return r;
    }
    var i = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: o,
      element: r,
      elementType: r,
      instanceOf: o,
      node: r,
      objectOf: o,
      oneOf: o,
      oneOfType: o,
      shape: o,
      exact: o,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return i.PropTypes = i, i;
  }, F0;
}
if (process.env.NODE_ENV !== "production") {
  var owe = g6(), iwe = !0;
  bx.exports = nwe()(owe.isElement, iwe);
} else
  bx.exports = rwe()();
var Cy = bx.exports, xy = {};
Object.defineProperty(xy, "__esModule", {
  value: !0
});
var swe = cd, z0 = awe(swe);
function awe(e) {
  return e && e.__esModule ? e : { default: e };
}
var lwe = {
  mountFlag: !1,
  initialized: !1,
  scroller: null,
  containers: {},
  mount: function(e) {
    this.scroller = e, this.handleHashChange = this.handleHashChange.bind(this), window.addEventListener("hashchange", this.handleHashChange), this.initStateFromHash(), this.mountFlag = !0;
  },
  mapContainer: function(e, t) {
    this.containers[e] = t;
  },
  isMounted: function() {
    return this.mountFlag;
  },
  isInitialized: function() {
    return this.initialized;
  },
  initStateFromHash: function() {
    var e = this, t = this.getHash();
    t ? window.setTimeout(function() {
      e.scrollTo(t, !0), e.initialized = !0;
    }, 10) : this.initialized = !0;
  },
  scrollTo: function(e, t) {
    var n = this.scroller, r = n.get(e);
    if (r && (t || e !== n.getActiveLink())) {
      var o = this.containers[e] || document;
      n.scrollTo(e, { container: o });
    }
  },
  getHash: function() {
    return z0.default.getHash();
  },
  changeHash: function(e, t) {
    this.isInitialized() && z0.default.getHash() !== e && z0.default.updateHash(e, t);
  },
  handleHashChange: function() {
    this.scrollTo(this.getHash());
  },
  unmount: function() {
    this.scroller = null, this.containers = null, window.removeEventListener("hashchange", this.handleHashChange);
  }
};
xy.default = lwe;
Object.defineProperty(ad, "__esModule", {
  value: !0
});
var Zf = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, uwe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), cwe = ke, MI = fd(cwe), pwe = ld, Gf = fd(pwe), dwe = Eu, fwe = fd(dwe), hwe = Cy, fr = fd(hwe), gwe = xy, Ns = fd(gwe);
function fd(e) {
  return e && e.__esModule ? e : { default: e };
}
function mwe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function vwe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function ywe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var DI = {
  to: fr.default.string.isRequired,
  containerId: fr.default.string,
  container: fr.default.object,
  activeClass: fr.default.string,
  activeStyle: fr.default.object,
  spy: fr.default.bool,
  horizontal: fr.default.bool,
  smooth: fr.default.oneOfType([fr.default.bool, fr.default.string]),
  offset: fr.default.number,
  delay: fr.default.number,
  isDynamic: fr.default.bool,
  onClick: fr.default.func,
  duration: fr.default.oneOfType([fr.default.number, fr.default.func]),
  absolute: fr.default.bool,
  onSetActive: fr.default.func,
  onSetInactive: fr.default.func,
  ignoreCancelEvents: fr.default.bool,
  hashSpy: fr.default.bool,
  saveHashHistory: fr.default.bool,
  spyThrottle: fr.default.number
};
ad.default = function(e, t) {
  var n = t || fwe.default, r = function(i) {
    ywe(a, i);
    function a(s) {
      mwe(this, a);
      var l = vwe(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
      return o.call(l), l.state = {
        active: !1
      }, l.beforeUnmountCallbacks = [], l;
    }
    return uwe(a, [{
      key: "getScrollSpyContainer",
      value: function() {
        var s = this.props.containerId, l = this.props.container;
        return s && !l ? document.getElementById(s) : l && l.nodeType ? l : document;
      }
    }, {
      key: "componentDidMount",
      value: function() {
        if (this.props.spy || this.props.hashSpy) {
          var s = this.getScrollSpyContainer();
          if (!Gf.default.isMounted(s)) {
            var l = Gf.default.mount(s, this.props.spyThrottle);
            this.beforeUnmountCallbacks.push(l);
          }
          this.props.hashSpy && (Ns.default.isMounted() || Ns.default.mount(n), Ns.default.mapContainer(this.props.to, s)), Gf.default.addSpyHandler(this.spyHandler, s), this.setState({
            container: s
          });
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        Gf.default.unmount(this.stateHandler, this.spyHandler), this.beforeUnmountCallbacks.forEach(function(s) {
          return s();
        });
      }
    }, {
      key: "render",
      value: function() {
        var s = "";
        this.state && this.state.active ? s = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : s = this.props.className;
        var l = {};
        this.state && this.state.active ? l = Zf({}, this.props.style, this.props.activeStyle) : l = Zf({}, this.props.style);
        var u = Zf({}, this.props);
        for (var c in DI)
          u.hasOwnProperty(c) && delete u[c];
        return u.className = s, u.style = l, u.onClick = this.handleClick, MI.default.createElement(e, u);
      }
    }]), a;
  }(MI.default.PureComponent), o = function() {
    var i = this;
    this.scrollTo = function(a, s) {
      n.scrollTo(a, Zf({}, i.state, s));
    }, this.handleClick = function(a) {
      i.props.onClick && i.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), i.scrollTo(i.props.to, i.props);
    }, this.spyHandler = function(a, s) {
      var l = i.getScrollSpyContainer();
      if (!(Ns.default.isMounted() && !Ns.default.isInitialized())) {
        var u = i.props.horizontal, c = i.props.to, p = null, d = void 0, h = void 0;
        if (u) {
          var f = 0, m = 0, g = 0;
          if (l.getBoundingClientRect) {
            var E = l.getBoundingClientRect();
            g = E.left;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var w = p.getBoundingClientRect();
            f = w.left - g + a, m = f + w.width;
          }
          var M = a - i.props.offset;
          d = M >= Math.floor(f) && M < Math.floor(m), h = M < Math.floor(f) || M >= Math.floor(m);
        } else {
          var x = 0, y = 0, C = 0;
          if (l.getBoundingClientRect) {
            var P = l.getBoundingClientRect();
            C = P.top;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var F = p.getBoundingClientRect();
            x = F.top - C + s, y = x + F.height;
          }
          var L = s - i.props.offset;
          d = L >= Math.floor(x) && L < Math.floor(y), h = L < Math.floor(x) || L >= Math.floor(y);
        }
        var N = n.getActiveLink();
        if (h) {
          if (c === N && n.setActiveLink(void 0), i.props.hashSpy && Ns.default.getHash() === c) {
            var I = i.props.saveHashHistory, H = I === void 0 ? !1 : I;
            Ns.default.changeHash("", H);
          }
          i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive(c, p));
        }
        if (d && (N !== c || i.state.active === !1)) {
          n.setActiveLink(c);
          var V = i.props.saveHashHistory, z = V === void 0 ? !1 : V;
          i.props.hashSpy && Ns.default.changeHash(c, z), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(c, p));
        }
      }
    };
  };
  return r.propTypes = DI, r.defaultProps = { offset: 0 }, r;
};
Object.defineProperty(Ik, "__esModule", {
  value: !0
});
var bwe = ke, TI = v6(bwe), wwe = ad, Cwe = v6(wwe);
function v6(e) {
  return e && e.__esModule ? e : { default: e };
}
function xwe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function jI(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function Owe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var Ewe = function(e) {
  Owe(t, e);
  function t() {
    var n, r, o, i;
    xwe(this, t);
    for (var a = arguments.length, s = Array(a), l = 0; l < a; l++)
      s[l] = arguments[l];
    return i = (r = (o = jI(this, (n = t.__proto__ || Object.getPrototypeOf(t)).call.apply(n, [this].concat(s))), o), o.render = function() {
      return TI.default.createElement(
        "a",
        o.props,
        o.props.children
      );
    }, r), jI(o, i);
  }
  return t;
}(TI.default.Component);
Ik.default = (0, Cwe.default)(Ewe);
var $k = {};
Object.defineProperty($k, "__esModule", {
  value: !0
});
var kwe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), Lwe = ke, AI = y6(Lwe), _we = ad, Pwe = y6(_we);
function y6(e) {
  return e && e.__esModule ? e : { default: e };
}
function Swe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Mwe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function Dwe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var Twe = function(e) {
  Dwe(t, e);
  function t() {
    return Swe(this, t), Mwe(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return kwe(t, [{
    key: "render",
    value: function() {
      return AI.default.createElement(
        "button",
        this.props,
        this.props.children
      );
    }
  }]), t;
}(AI.default.Component);
$k.default = (0, Pwe.default)(Twe);
var Hk = {}, Oy = {};
Object.defineProperty(Oy, "__esModule", {
  value: !0
});
var jwe = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, Awe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), Bwe = ke, BI = Ey(Bwe), Iwe = Rl;
Ey(Iwe);
var Rwe = Eu, II = Ey(Rwe), Nwe = Cy, RI = Ey(Nwe);
function Ey(e) {
  return e && e.__esModule ? e : { default: e };
}
function Fwe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function zwe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function Uwe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
Oy.default = function(e) {
  var t = function(n) {
    Uwe(r, n);
    function r(o) {
      Fwe(this, r);
      var i = zwe(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
      return i.childBindings = {
        domNode: null
      }, i;
    }
    return Awe(r, [{
      key: "componentDidMount",
      value: function() {
        if (typeof window > "u")
          return !1;
        this.registerElems(this.props.name);
      }
    }, {
      key: "componentDidUpdate",
      value: function(o) {
        this.props.name !== o.name && this.registerElems(this.props.name);
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        if (typeof window > "u")
          return !1;
        II.default.unregister(this.props.name);
      }
    }, {
      key: "registerElems",
      value: function(o) {
        II.default.register(o, this.childBindings.domNode);
      }
    }, {
      key: "render",
      value: function() {
        return BI.default.createElement(e, jwe({}, this.props, { parentBindings: this.childBindings }));
      }
    }]), r;
  }(BI.default.Component);
  return t.propTypes = {
    name: RI.default.string,
    id: RI.default.string
  }, t;
};
Object.defineProperty(Hk, "__esModule", {
  value: !0
});
var NI = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, $we = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), Hwe = ke, FI = Wk(Hwe), Wwe = Oy, Vwe = Wk(Wwe), qwe = Cy, zI = Wk(qwe);
function Wk(e) {
  return e && e.__esModule ? e : { default: e };
}
function Zwe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Gwe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function Xwe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var b6 = function(e) {
  Xwe(t, e);
  function t() {
    return Zwe(this, t), Gwe(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return $we(t, [{
    key: "render",
    value: function() {
      var n = this, r = NI({}, this.props);
      return delete r.name, r.parentBindings && delete r.parentBindings, FI.default.createElement(
        "div",
        NI({}, r, { ref: function(o) {
          n.props.parentBindings.domNode = o;
        } }),
        this.props.children
      );
    }
  }]), t;
}(FI.default.Component);
b6.propTypes = {
  name: zI.default.string,
  id: zI.default.string
};
Hk.default = (0, Vwe.default)(b6);
var U0 = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, UI = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}();
function $I(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function HI(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function WI(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var Xf = ke, za = ld, $0 = Eu, Dr = Cy, Fs = xy, VI = {
  to: Dr.string.isRequired,
  containerId: Dr.string,
  container: Dr.object,
  activeClass: Dr.string,
  spy: Dr.bool,
  smooth: Dr.oneOfType([Dr.bool, Dr.string]),
  offset: Dr.number,
  delay: Dr.number,
  isDynamic: Dr.bool,
  onClick: Dr.func,
  duration: Dr.oneOfType([Dr.number, Dr.func]),
  absolute: Dr.bool,
  onSetActive: Dr.func,
  onSetInactive: Dr.func,
  ignoreCancelEvents: Dr.bool,
  hashSpy: Dr.bool,
  spyThrottle: Dr.number
}, Kwe = {
  Scroll: function(e, t) {
    console.warn("Helpers.Scroll is deprecated since v1.7.0");
    var n = t || $0, r = function(i) {
      WI(a, i);
      function a(s) {
        $I(this, a);
        var l = HI(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
        return o.call(l), l.state = {
          active: !1
        }, l;
      }
      return UI(a, [{
        key: "getScrollSpyContainer",
        value: function() {
          var s = this.props.containerId, l = this.props.container;
          return s ? document.getElementById(s) : l && l.nodeType ? l : document;
        }
      }, {
        key: "componentDidMount",
        value: function() {
          if (this.props.spy || this.props.hashSpy) {
            var s = this.getScrollSpyContainer();
            za.isMounted(s) || za.mount(s, this.props.spyThrottle), this.props.hashSpy && (Fs.isMounted() || Fs.mount(n), Fs.mapContainer(this.props.to, s)), this.props.spy && za.addStateHandler(this.stateHandler), za.addSpyHandler(this.spyHandler, s), this.setState({
              container: s
            });
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          za.unmount(this.stateHandler, this.spyHandler);
        }
      }, {
        key: "render",
        value: function() {
          var s = "";
          this.state && this.state.active ? s = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : s = this.props.className;
          var l = U0({}, this.props);
          for (var u in VI)
            l.hasOwnProperty(u) && delete l[u];
          return l.className = s, l.onClick = this.handleClick, Xf.createElement(e, l);
        }
      }]), a;
    }(Xf.Component), o = function() {
      var i = this;
      this.scrollTo = function(a, s) {
        n.scrollTo(a, U0({}, i.state, s));
      }, this.handleClick = function(a) {
        i.props.onClick && i.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), i.scrollTo(i.props.to, i.props);
      }, this.stateHandler = function() {
        n.getActiveLink() !== i.props.to && (i.state !== null && i.state.active && i.props.onSetInactive && i.props.onSetInactive(), i.setState({ active: !1 }));
      }, this.spyHandler = function(a) {
        var s = i.getScrollSpyContainer();
        if (!(Fs.isMounted() && !Fs.isInitialized())) {
          var l = i.props.to, u = null, c = 0, p = 0, d = 0;
          if (s.getBoundingClientRect) {
            var h = s.getBoundingClientRect();
            d = h.top;
          }
          if (!u || i.props.isDynamic) {
            if (u = n.get(l), !u)
              return;
            var f = u.getBoundingClientRect();
            c = f.top - d + a, p = c + f.height;
          }
          var m = a - i.props.offset, g = m >= Math.floor(c) && m < Math.floor(p), E = m < Math.floor(c) || m >= Math.floor(p), w = n.getActiveLink();
          if (E)
            return l === w && n.setActiveLink(void 0), i.props.hashSpy && Fs.getHash() === l && Fs.changeHash(), i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive()), za.updateStates();
          if (g && w !== l)
            return n.setActiveLink(l), i.props.hashSpy && Fs.changeHash(l), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(l)), za.updateStates();
        }
      };
    };
    return r.propTypes = VI, r.defaultProps = { offset: 0 }, r;
  },
  Element: function(e) {
    console.warn("Helpers.Element is deprecated since v1.7.0");
    var t = function(n) {
      WI(r, n);
      function r(o) {
        $I(this, r);
        var i = HI(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
        return i.childBindings = {
          domNode: null
        }, i;
      }
      return UI(r, [{
        key: "componentDidMount",
        value: function() {
          if (typeof window > "u")
            return !1;
          this.registerElems(this.props.name);
        }
      }, {
        key: "componentDidUpdate",
        value: function(o) {
          this.props.name !== o.name && this.registerElems(this.props.name);
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          if (typeof window > "u")
            return !1;
          $0.unregister(this.props.name);
        }
      }, {
        key: "registerElems",
        value: function(o) {
          $0.register(o, this.childBindings.domNode);
        }
      }, {
        key: "render",
        value: function() {
          return Xf.createElement(e, U0({}, this.props, { parentBindings: this.childBindings }));
        }
      }]), r;
    }(Xf.Component);
    return t.propTypes = {
      name: Dr.string,
      id: Dr.string
    }, t;
  }
}, Ywe = Kwe;
Object.defineProperty($r, "__esModule", {
  value: !0
});
$r.Helpers = $r.ScrollElement = $r.ScrollLink = $r.animateScroll = $r.scrollSpy = $r.Events = $r.scroller = $r.Element = $r.Button = $r.Link = void 0;
var Jwe = Ik, w6 = Ji(Jwe), Qwe = $k, C6 = Ji(Qwe), eCe = Hk, x6 = Ji(eCe), tCe = Eu, O6 = Ji(tCe), nCe = pd, E6 = Ji(nCe), rCe = ld, k6 = Ji(rCe), oCe = yy, L6 = Ji(oCe), iCe = ad, _6 = Ji(iCe), sCe = Oy, P6 = Ji(sCe), aCe = Ywe, S6 = Ji(aCe);
function Ji(e) {
  return e && e.__esModule ? e : { default: e };
}
$r.Link = w6.default;
$r.Button = C6.default;
$r.Element = x6.default;
$r.scroller = O6.default;
$r.Events = E6.default;
$r.scrollSpy = k6.default;
$r.animateScroll = L6.default;
$r.ScrollLink = _6.default;
$r.ScrollElement = P6.default;
$r.Helpers = S6.default;
$r.default = { Link: w6.default, Button: C6.default, Element: x6.default, scroller: O6.default, Events: E6.default, scrollSpy: k6.default, animateScroll: L6.default, ScrollLink: _6.default, ScrollElement: P6.default, Helpers: S6.default };
Ze({});
Ze({});
Ze({});
function Dp(e) {
  "@babel/helpers - typeof";
  return Dp = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Dp(e);
}
function lCe(e, t) {
  if (Dp(e) != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (Dp(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function uCe(e) {
  var t = lCe(e, "string");
  return Dp(t) == "symbol" ? t : t + "";
}
function xe(e, t, n) {
  return (t = uCe(t)) in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function M6(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var H0, qI;
function cCe() {
  if (qI) return H0;
  qI = 1;
  var e = process.env.NODE_ENV, t = function(n, r, o, i, a, s, l, u) {
    if (e !== "production" && r === void 0)
      throw new Error("invariant requires an error message argument");
    if (!n) {
      var c;
      if (r === void 0)
        c = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
      else {
        var p = [o, i, a, s, l, u], d = 0;
        c = new Error(r.replace(/%s/g, function() {
          return p[d++];
        })), c.name = "Invariant Violation";
      }
      throw c.framesToPop = 1, c;
    }
  };
  return H0 = t, H0;
}
var pCe = cCe(), Xr = /* @__PURE__ */ M6(pCe), Dt = Ze(null);
function dCe() {
  Xr(!!ye, "useGoogleMap is React hook and requires React version 16.8+");
  var e = ye(Dt);
  return Xr(!!e, "useGoogleMap needs a GoogleMap available up in the tree"), e;
}
function fCe(e, t, n) {
  return Object.keys(e).reduce(function(r, o) {
    return t(r, e[o], o);
  }, n);
}
function hCe(e, t) {
  Object.keys(e).forEach((n) => t(e[n], n));
}
function gCe(e, t, n, r) {
  var o = {}, i = (a, s) => {
    var l = n[s];
    l !== t[s] && (o[s] = l, a(r, l));
  };
  return hCe(e, i), o;
}
function mCe(e, t, n) {
  var r = fCe(n, function(o, i, a) {
    return typeof e[a] == "function" && o.push(google.maps.event.addListener(t, i, e[a])), o;
  }, []);
  return r;
}
function vCe(e) {
  google.maps.event.removeListener(e);
}
function ln() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  e.forEach(vCe);
}
function tn(e) {
  var {
    updaterMap: t,
    eventMap: n,
    prevProps: r,
    nextProps: o,
    instance: i
  } = e, a = mCe(o, i, n);
  return gCe(t, r, o, i), a;
}
function yCe(e) {
  var {
    children: t,
    options: n,
    id: r,
    mapContainerStyle: o,
    mapContainerClassName: i,
    center: a,
    // clickableIcons,
    // extraMapTypes,
    // heading,
    // mapTypeId,
    onClick: s,
    onDblClick: l,
    onDrag: u,
    onDragEnd: c,
    onDragStart: p,
    onMouseMove: d,
    onMouseOut: h,
    onMouseOver: f,
    onMouseDown: m,
    onMouseUp: g,
    onRightClick: E,
    // onMapTypeIdChanged,
    // onTilesLoaded,
    // onBoundsChanged,
    onCenterChanged: w,
    // onHeadingChanged,
    // onIdle,
    // onProjectionChanged,
    // onResize,
    // onTiltChanged,
    // onZoomChanged,
    onLoad: M,
    onUnmount: x
  } = e, [y, C] = k(null), P = rt(null), [F, L] = k(null), [N, I] = k(null), [H, V] = k(null), [z, q] = k(null), [K, J] = k(null), [te, ee] = k(null), [_, D] = k(null), [$, S] = k(null), [W, O] = k(null), [T, U] = k(null), [j, Z] = k(null), [A, Q] = k(null);
  return v(() => {
    n && y !== null && y.setOptions(n);
  }, [y, n]), v(() => {
    y !== null && typeof a < "u" && y.setCenter(a);
  }, [y, a]), v(() => {
    y && l && (N !== null && google.maps.event.removeListener(N), I(google.maps.event.addListener(y, "dblclick", l)));
  }, [l]), v(() => {
    y && c && (H !== null && google.maps.event.removeListener(H), V(google.maps.event.addListener(y, "dragend", c)));
  }, [c]), v(() => {
    y && p && (z !== null && google.maps.event.removeListener(z), q(google.maps.event.addListener(y, "dragstart", p)));
  }, [p]), v(() => {
    y && m && (K !== null && google.maps.event.removeListener(K), J(google.maps.event.addListener(y, "mousedown", m)));
  }, [m]), v(() => {
    y && d && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(y, "mousemove", d)));
  }, [d]), v(() => {
    y && h && (_ !== null && google.maps.event.removeListener(_), D(google.maps.event.addListener(y, "mouseout", h)));
  }, [h]), v(() => {
    y && f && ($ !== null && google.maps.event.removeListener($), S(google.maps.event.addListener(y, "mouseover", f)));
  }, [f]), v(() => {
    y && g && (W !== null && google.maps.event.removeListener(W), O(google.maps.event.addListener(y, "mouseup", g)));
  }, [g]), v(() => {
    y && E && (T !== null && google.maps.event.removeListener(T), U(google.maps.event.addListener(y, "rightclick", E)));
  }, [E]), v(() => {
    y && s && (j !== null && google.maps.event.removeListener(j), Z(google.maps.event.addListener(y, "click", s)));
  }, [s]), v(() => {
    y && u && (A !== null && google.maps.event.removeListener(A), Q(google.maps.event.addListener(y, "drag", u)));
  }, [u]), v(() => {
    y && w && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(y, "center_changed", w)));
  }, [s]), v(() => {
    var R = P.current === null ? null : new google.maps.Map(P.current, n);
    return C(R), R !== null && M && M(R), () => {
      R !== null && x && x(R);
    };
  }, []), no.jsx("div", {
    id: r,
    ref: P,
    style: o,
    className: i,
    children: no.jsx(Dt.Provider, {
      value: y,
      children: y !== null ? t : null
    })
  });
}
Ee(yCe);
function ZI(e, t, n, r, o, i, a) {
  try {
    var s = e[i](a), l = s.value;
  } catch (u) {
    return void n(u);
  }
  s.done ? t(l) : Promise.resolve(l).then(r, o);
}
function D6(e) {
  return function() {
    var t = this, n = arguments;
    return new Promise(function(r, o) {
      var i = e.apply(t, n);
      function a(l) {
        ZI(i, r, o, a, s, "next", l);
      }
      function s(l) {
        ZI(i, r, o, a, s, "throw", l);
      }
      a(void 0);
    });
  };
}
function T6(e) {
  var {
    googleMapsApiKey: t,
    googleMapsClientId: n,
    version: r = "weekly",
    language: o,
    region: i,
    libraries: a,
    channel: s,
    mapIds: l,
    authReferrerPolicy: u
  } = e, c = [];
  return Xr(t && n || !(t && n), "You need to specify either googleMapsApiKey or googleMapsClientId for @react-google-maps/api load script to work. You cannot use both at the same time."), t ? c.push("key=".concat(t)) : n && c.push("client=".concat(n)), r && c.push("v=".concat(r)), o && c.push("language=".concat(o)), i && c.push("region=".concat(i)), a && a.length && c.push("libraries=".concat(a.sort().join(","))), s && c.push("channel=".concat(s)), l && l.length && c.push("map_ids=".concat(l.join(","))), u && c.push("auth_referrer_policy=".concat(u)), c.push("loading=async"), c.push("callback=initMap"), "https://maps.googleapis.com/maps/api/js?".concat(c.join("&"));
}
var ul = typeof document < "u";
function j6(e) {
  var {
    url: t,
    id: n,
    nonce: r
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } = e;
  return ul ? new Promise(function(o, i) {
    var a = document.getElementById(n), s = window;
    if (a) {
      var l = a.getAttribute("data-state");
      if (a.src === t && l !== "error") {
        if (l === "ready")
          return o(n);
        var u = s.initMap, c = a.onerror;
        s.initMap = function() {
          u && u(), o(n);
        }, a.onerror = function(d) {
          c && c(d), i(d);
        };
        return;
      } else
        a.remove();
    }
    var p = document.createElement("script");
    p.type = "text/javascript", p.src = t, p.id = n, p.async = !0, p.nonce = r || "", p.onerror = function(d) {
      p.setAttribute("data-state", "error"), i(d);
    }, s.initMap = function() {
      p.setAttribute("data-state", "ready"), o(n);
    }, document.head.appendChild(p);
  }).catch((o) => {
    throw console.error("injectScript error: ", o), o;
  }) : Promise.reject(new Error("document is undefined"));
}
function GI(e) {
  var t = e.href;
  return t && (t.indexOf("https://fonts.googleapis.com/css?family=Roboto") === 0 || t.indexOf("https://fonts.googleapis.com/css?family=Google+Sans+Text") === 0) ? !0 : (
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.styleSheet.cssText = "", !0) : (
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.innerHTML = "", !0) : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.innerHTML
      )
    )
  );
}
function A6() {
  var e = document.getElementsByTagName("head")[0];
  if (e) {
    var t = e.insertBefore.bind(e);
    e.insertBefore = function(r, o) {
      return GI(r) || Reflect.apply(t, e, [r, o]), r;
    };
    var n = e.appendChild.bind(e);
    e.appendChild = function(r) {
      return GI(r) || Reflect.apply(n, e, [r]), r;
    };
  }
}
var Ju = !1;
function B6() {
  return no.jsx("div", {
    children: "Loading..."
  });
}
var wx = {
  id: "script-loader",
  version: "weekly"
};
class bCe extends pe {
  constructor() {
    super(...arguments), xe(this, "check", null), xe(this, "state", {
      loaded: !1
    }), xe(this, "cleanupCallback", () => {
      delete window.google.maps, this.injectScript();
    }), xe(this, "isCleaningUp", /* @__PURE__ */ D6(function* () {
      function t(n) {
        if (!Ju)
          n();
        else if (ul)
          var r = window.setInterval(function() {
            Ju || (window.clearInterval(r), n());
          }, 1);
      }
      return new Promise(t);
    })), xe(this, "cleanup", () => {
      Ju = !0;
      var t = document.getElementById(this.props.id);
      t && t.parentNode && t.parentNode.removeChild(t), Array.prototype.slice.call(document.getElementsByTagName("script")).filter(function(n) {
        return typeof n.src == "string" && n.src.includes("maps.googleapis");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("link")).filter(function(n) {
        return n.href === "https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Google+Sans";
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("style")).filter(function(n) {
        return n.innerText !== void 0 && n.innerText.length > 0 && n.innerText.includes(".gm-");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      });
    }), xe(this, "injectScript", () => {
      this.props.preventGoogleFontsLoading && A6(), Xr(!!this.props.id, 'LoadScript requires "id" prop to be a string: %s', this.props.id);
      var t = {
        id: this.props.id,
        nonce: this.props.nonce,
        url: T6(this.props)
      };
      j6(t).then(() => {
        this.props.onLoad && this.props.onLoad(), this.setState(function() {
          return {
            loaded: !0
          };
        });
      }).catch((n) => {
        this.props.onError && this.props.onError(n), console.error(`
          There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(this.props.googleMapsApiKey || "-", ") or Client ID (").concat(this.props.googleMapsClientId || "-", `) to <LoadScript />
          Otherwise it is a Network issue.
        `));
      });
    }), xe(this, "getRef", (t) => {
      this.check = t;
    });
  }
  componentDidMount() {
    if (ul) {
      if (window.google && window.google.maps && !Ju) {
        console.error("google api is already presented");
        return;
      }
      this.isCleaningUp().then(this.injectScript).catch(function(t) {
        console.error("Error at injecting script after cleaning up: ", t);
      });
    }
  }
  componentDidUpdate(t) {
    this.props.libraries !== t.libraries && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), ul && t.language !== this.props.language && (this.cleanup(), this.setState(function() {
      return {
        loaded: !1
      };
    }, this.cleanupCallback));
  }
  componentWillUnmount() {
    if (ul) {
      this.cleanup();
      var t = () => {
        this.check || (delete window.google, Ju = !1);
      };
      window.setTimeout(t, 1), this.props.onUnmount && this.props.onUnmount();
    }
  }
  render() {
    return no.jsxs(no.Fragment, {
      children: [no.jsx("div", {
        ref: this.getRef
      }), this.state.loaded ? this.props.children : this.props.loadingElement || no.jsx(B6, {})]
    });
  }
}
xe(bCe, "defaultProps", wx);
function wCe(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.includes(r)) continue;
    n[r] = e[r];
  }
  return n;
}
function Vk(e, t) {
  if (e == null) return {};
  var n, r, o = wCe(e, t);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (r = 0; r < i.length; r++) n = i[r], t.includes(n) || {}.propertyIsEnumerable.call(e, n) && (o[n] = e[n]);
  }
  return o;
}
var XI;
function CCe(e) {
  var {
    id: t = wx.id,
    version: n = wx.version,
    nonce: r,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    preventGoogleFontsLoading: u,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  } = e, h = rt(!1), [f, m] = k(!1), [g, E] = k(void 0);
  v(function() {
    return h.current = !0, () => {
      h.current = !1;
    };
  }, []), v(function() {
    ul && u && A6();
  }, [u]), v(function() {
    f && Xr(!!window.google, "useLoadScript was marked as loaded, but window.google is not present. Something went wrong.");
  }, [f]);
  var w = T6({
    version: n,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  });
  v(function() {
    if (!ul)
      return;
    function x() {
      h.current && (m(!0), XI = w);
    }
    if (window.google && window.google.maps && XI === w) {
      x();
      return;
    }
    j6({
      id: t,
      url: w,
      nonce: r
    }).then(x).catch(function(y) {
      h.current && E(y), console.warn(`
        There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(o || "-", ") or Client ID (").concat(i || "-", `)
        Otherwise it is a Network issue.
      `)), console.error(y);
    });
  }, [t, w, r]);
  var M = rt(void 0);
  return v(function() {
    M.current && l !== M.current && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), M.current = l;
  }, [l]), {
    isLoaded: f,
    loadError: g,
    url: w
  };
}
var xCe = ["loadingElement", "onLoad", "onError", "onUnmount", "children"], OCe = no.jsx(B6, {});
function ECe(e) {
  var {
    loadingElement: t,
    onLoad: n,
    onError: r,
    onUnmount: o,
    children: i
  } = e, a = Vk(e, xCe), {
    isLoaded: s,
    loadError: l
  } = CCe(a);
  return v(function() {
    s && typeof n == "function" && n();
  }, [s, n]), v(function() {
    l && typeof r == "function" && r(l);
  }, [l, r]), v(function() {
    return () => {
      o && o();
    };
  }, [o]), s ? i : t || OCe;
}
Ee(ECe);
var KI;
(function(e) {
  e[e.INITIALIZED = 0] = "INITIALIZED", e[e.LOADING = 1] = "LOADING", e[e.SUCCESS = 2] = "SUCCESS", e[e.FAILURE = 3] = "FAILURE";
})(KI || (KI = {}));
function YI(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Jg(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? YI(Object(n), !0).forEach(function(r) {
      xe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : YI(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var JI = {}, QI = {
  options(e, t) {
    e.setOptions(t);
  }
};
function kCe(e) {
  var {
    options: t,
    onLoad: n,
    onUnmount: r
  } = e, o = ye(Dt), [i, a] = k(null);
  return v(() => {
    i !== null && i.setMap(o);
  }, [o]), v(() => {
    t && i !== null && i.setOptions(t);
  }, [i, t]), v(() => {
    var s = new google.maps.TrafficLayer(Jg(Jg({}, t), {}, {
      map: o
    }));
    return a(s), n && n(s), () => {
      i !== null && (r && r(i), i.setMap(null));
    };
  }, []), null;
}
Ee(kCe);
class LCe extends pe {
  constructor() {
    super(...arguments), xe(this, "state", {
      trafficLayer: null
    }), xe(this, "setTrafficLayerCallback", () => {
      this.state.trafficLayer !== null && this.props.onLoad && this.props.onLoad(this.state.trafficLayer);
    }), xe(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = new google.maps.TrafficLayer(Jg(Jg({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = tn({
      updaterMap: QI,
      eventMap: JI,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        trafficLayer: t
      };
    }, this.setTrafficLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.trafficLayer !== null && (ln(this.registeredEvents), this.registeredEvents = tn({
      updaterMap: QI,
      eventMap: JI,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.trafficLayer
    }));
  }
  componentWillUnmount() {
    this.state.trafficLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.trafficLayer), ln(this.registeredEvents), this.state.trafficLayer.setMap(null));
  }
  render() {
    return null;
  }
}
xe(LCe, "contextType", Dt);
function _Ce(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = ye(Dt), [o, i] = k(null);
  return v(() => {
    o !== null && o.setMap(r);
  }, [r]), v(() => {
    var a = new google.maps.BicyclingLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      a !== null && (n && n(a), a.setMap(null));
    };
  }, []), null;
}
Ee(_Ce);
class PCe extends pe {
  constructor() {
    super(...arguments), xe(this, "state", {
      bicyclingLayer: null
    }), xe(this, "setBicyclingLayerCallback", () => {
      this.state.bicyclingLayer !== null && (this.state.bicyclingLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.bicyclingLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.BicyclingLayer();
    this.setState(() => ({
      bicyclingLayer: t
    }), this.setBicyclingLayerCallback);
  }
  componentWillUnmount() {
    this.state.bicyclingLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.bicyclingLayer), this.state.bicyclingLayer.setMap(null));
  }
  render() {
    return null;
  }
}
xe(PCe, "contextType", Dt);
function SCe(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = ye(Dt), [o, i] = k(null);
  return v(() => {
    o !== null && o.setMap(r);
  }, [r]), v(() => {
    var a = new google.maps.TransitLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      o !== null && (n && n(o), o.setMap(null));
    };
  }, []), null;
}
Ee(SCe);
class MCe extends pe {
  constructor() {
    super(...arguments), xe(this, "state", {
      transitLayer: null
    }), xe(this, "setTransitLayerCallback", () => {
      this.state.transitLayer !== null && (this.state.transitLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.transitLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.TransitLayer();
    this.setState(function() {
      return {
        transitLayer: t
      };
    }, this.setTransitLayerCallback);
  }
  componentWillUnmount() {
    this.state.transitLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.transitLayer), this.state.transitLayer.setMap(null));
  }
  render() {
    return null;
  }
}
xe(MCe, "contextType", Dt);
function eR(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Qg(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? eR(Object(n), !0).forEach(function(r) {
      xe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : eR(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var tR = {
  onCircleComplete: "circlecomplete",
  onMarkerComplete: "markercomplete",
  onOverlayComplete: "overlaycomplete",
  onPolygonComplete: "polygoncomplete",
  onPolylineComplete: "polylinecomplete",
  onRectangleComplete: "rectanglecomplete"
}, nR = {
  drawingMode(e, t) {
    e.setDrawingMode(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function DCe(e) {
  var {
    options: t,
    drawingMode: n,
    onCircleComplete: r,
    onMarkerComplete: o,
    onOverlayComplete: i,
    onPolygonComplete: a,
    onPolylineComplete: s,
    onRectangleComplete: l,
    onLoad: u,
    onUnmount: c
  } = e, p = ye(Dt), [d, h] = k(null), [f, m] = k(null), [g, E] = k(null), [w, M] = k(null), [x, y] = k(null), [C, P] = k(null), [F, L] = k(null);
  return v(() => {
    d !== null && d.setMap(p);
  }, [p]), v(() => {
    t && d !== null && d.setOptions(t);
  }, [d, t]), v(() => {
    d !== null && d.setDrawingMode(n ?? null);
  }, [d, n]), v(() => {
    d && r && (f !== null && google.maps.event.removeListener(f), m(google.maps.event.addListener(d, "circlecomplete", r)));
  }, [d, r]), v(() => {
    d && o && (g !== null && google.maps.event.removeListener(g), E(google.maps.event.addListener(d, "markercomplete", o)));
  }, [d, o]), v(() => {
    d && i && (w !== null && google.maps.event.removeListener(w), M(google.maps.event.addListener(d, "overlaycomplete", i)));
  }, [d, i]), v(() => {
    d && a && (x !== null && google.maps.event.removeListener(x), y(google.maps.event.addListener(d, "polygoncomplete", a)));
  }, [d, a]), v(() => {
    d && s && (C !== null && google.maps.event.removeListener(C), P(google.maps.event.addListener(d, "polylinecomplete", s)));
  }, [d, s]), v(() => {
    d && l && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(d, "rectanglecomplete", l)));
  }, [d, l]), v(() => {
    Xr(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
    var N = new google.maps.drawing.DrawingManager(Qg(Qg({}, t), {}, {
      map: p
    }));
    return n && N.setDrawingMode(n), r && m(google.maps.event.addListener(N, "circlecomplete", r)), o && E(google.maps.event.addListener(N, "markercomplete", o)), i && M(google.maps.event.addListener(N, "overlaycomplete", i)), a && y(google.maps.event.addListener(N, "polygoncomplete", a)), s && P(google.maps.event.addListener(N, "polylinecomplete", s)), l && L(google.maps.event.addListener(N, "rectanglecomplete", l)), h(N), u && u(N), () => {
      d !== null && (f && google.maps.event.removeListener(f), g && google.maps.event.removeListener(g), w && google.maps.event.removeListener(w), x && google.maps.event.removeListener(x), C && google.maps.event.removeListener(C), F && google.maps.event.removeListener(F), c && c(d), d.setMap(null));
    };
  }, []), null;
}
Ee(DCe);
class TCe extends pe {
  constructor(t) {
    super(t), xe(this, "registeredEvents", []), xe(this, "state", {
      drawingManager: null
    }), xe(this, "setDrawingManagerCallback", () => {
      this.state.drawingManager !== null && this.props.onLoad && this.props.onLoad(this.state.drawingManager);
    }), Xr(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
  }
  componentDidMount() {
    var t = new google.maps.drawing.DrawingManager(Qg(Qg({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = tn({
      updaterMap: nR,
      eventMap: tR,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        drawingManager: t
      };
    }, this.setDrawingManagerCallback);
  }
  componentDidUpdate(t) {
    this.state.drawingManager !== null && (ln(this.registeredEvents), this.registeredEvents = tn({
      updaterMap: nR,
      eventMap: tR,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.drawingManager
    }));
  }
  componentWillUnmount() {
    this.state.drawingManager !== null && (this.props.onUnmount && this.props.onUnmount(this.state.drawingManager), ln(this.registeredEvents), this.state.drawingManager.setMap(null));
  }
  render() {
    return null;
  }
}
xe(TCe, "contextType", Dt);
function rR(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Jl(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? rR(Object(n), !0).forEach(function(r) {
      xe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : rR(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var oR = {
  onAnimationChanged: "animation_changed",
  onClick: "click",
  onClickableChanged: "clickable_changed",
  onCursorChanged: "cursor_changed",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDraggableChanged: "draggable_changed",
  onDragStart: "dragstart",
  onFlatChanged: "flat_changed",
  onIconChanged: "icon_changed",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onPositionChanged: "position_changed",
  onRightClick: "rightclick",
  onShapeChanged: "shape_changed",
  onTitleChanged: "title_changed",
  onVisibleChanged: "visible_changed",
  onZindexChanged: "zindex_changed"
}, iR = {
  animation(e, t) {
    e.setAnimation(t);
  },
  clickable(e, t) {
    e.setClickable(t);
  },
  cursor(e, t) {
    e.setCursor(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  icon(e, t) {
    e.setIcon(t);
  },
  label(e, t) {
    e.setLabel(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  opacity(e, t) {
    e.setOpacity(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  shape(e, t) {
    e.setShape(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, em = {};
function jCe(e) {
  var {
    position: t,
    options: n,
    clusterer: r,
    noClustererRedraw: o,
    children: i,
    draggable: a,
    visible: s,
    animation: l,
    clickable: u,
    cursor: c,
    icon: p,
    label: d,
    opacity: h,
    shape: f,
    title: m,
    zIndex: g,
    onClick: E,
    onDblClick: w,
    onDrag: M,
    onDragEnd: x,
    onDragStart: y,
    onMouseOut: C,
    onMouseOver: P,
    onMouseUp: F,
    onMouseDown: L,
    onRightClick: N,
    onClickableChanged: I,
    onCursorChanged: H,
    onAnimationChanged: V,
    onDraggableChanged: z,
    onFlatChanged: q,
    onIconChanged: K,
    onPositionChanged: J,
    onShapeChanged: te,
    onTitleChanged: ee,
    onVisibleChanged: _,
    onZindexChanged: D,
    onLoad: $,
    onUnmount: S
  } = e, W = ye(Dt), [O, T] = k(null), [U, j] = k(null), [Z, A] = k(null), [Q, R] = k(null), [ue, fe] = k(null), [oe, Re] = k(null), [He, Ve] = k(null), [ze, et] = k(null), [Ge, Pe] = k(null), [Ye, it] = k(null), [_e, Se] = k(null), [Ke, We] = k(null), [Ue, nt] = k(null), [Ie, xt] = k(null), [ot, st] = k(null), [lt, Ot] = k(null), [ut, ct] = k(null), [tt, Xe] = k(null), [Et, kt] = k(null), [pt, kn] = k(null), [dt, Ln] = k(null), [ft, rn] = k(null);
  v(() => {
    O !== null && O.setMap(W);
  }, [W]), v(() => {
    typeof n < "u" && O !== null && O.setOptions(n);
  }, [O, n]), v(() => {
    typeof a < "u" && O !== null && O.setDraggable(a);
  }, [O, a]), v(() => {
    t && O !== null && O.setPosition(t);
  }, [O, t]), v(() => {
    typeof s < "u" && O !== null && O.setVisible(s);
  }, [O, s]), v(() => {
    O == null || O.setAnimation(l);
  }, [O, l]), v(() => {
    O && u !== void 0 && O.setClickable(u);
  }, [O, u]), v(() => {
    O && c !== void 0 && O.setCursor(c);
  }, [O, c]), v(() => {
    O && p !== void 0 && O.setIcon(p);
  }, [O, p]), v(() => {
    O && d !== void 0 && O.setLabel(d);
  }, [O, d]), v(() => {
    O && h !== void 0 && O.setOpacity(h);
  }, [O, h]), v(() => {
    O && f !== void 0 && O.setShape(f);
  }, [O, f]), v(() => {
    O && m !== void 0 && O.setTitle(m);
  }, [O, m]), v(() => {
    O && g !== void 0 && O.setZIndex(g);
  }, [O, g]), v(() => {
    O && w && (U !== null && google.maps.event.removeListener(U), j(google.maps.event.addListener(O, "dblclick", w)));
  }, [w]), v(() => {
    O && x && (Z !== null && google.maps.event.removeListener(Z), A(google.maps.event.addListener(O, "dragend", x)));
  }, [x]), v(() => {
    O && y && (Q !== null && google.maps.event.removeListener(Q), R(google.maps.event.addListener(O, "dragstart", y)));
  }, [y]), v(() => {
    O && L && (ue !== null && google.maps.event.removeListener(ue), fe(google.maps.event.addListener(O, "mousedown", L)));
  }, [L]), v(() => {
    O && C && (oe !== null && google.maps.event.removeListener(oe), Re(google.maps.event.addListener(O, "mouseout", C)));
  }, [C]), v(() => {
    O && P && (He !== null && google.maps.event.removeListener(He), Ve(google.maps.event.addListener(O, "mouseover", P)));
  }, [P]), v(() => {
    O && F && (ze !== null && google.maps.event.removeListener(ze), et(google.maps.event.addListener(O, "mouseup", F)));
  }, [F]), v(() => {
    O && N && (Ge !== null && google.maps.event.removeListener(Ge), Pe(google.maps.event.addListener(O, "rightclick", N)));
  }, [N]), v(() => {
    O && E && (Ye !== null && google.maps.event.removeListener(Ye), it(google.maps.event.addListener(O, "click", E)));
  }, [E]), v(() => {
    O && M && (_e !== null && google.maps.event.removeListener(_e), Se(google.maps.event.addListener(O, "drag", M)));
  }, [M]), v(() => {
    O && I && (Ke !== null && google.maps.event.removeListener(Ke), We(google.maps.event.addListener(O, "clickable_changed", I)));
  }, [I]), v(() => {
    O && H && (Ue !== null && google.maps.event.removeListener(Ue), nt(google.maps.event.addListener(O, "cursor_changed", H)));
  }, [H]), v(() => {
    O && V && (Ie !== null && google.maps.event.removeListener(Ie), xt(google.maps.event.addListener(O, "animation_changed", V)));
  }, [V]), v(() => {
    O && z && (ot !== null && google.maps.event.removeListener(ot), st(google.maps.event.addListener(O, "draggable_changed", z)));
  }, [z]), v(() => {
    O && q && (lt !== null && google.maps.event.removeListener(lt), Ot(google.maps.event.addListener(O, "flat_changed", q)));
  }, [q]), v(() => {
    O && K && (ut !== null && google.maps.event.removeListener(ut), ct(google.maps.event.addListener(O, "icon_changed", K)));
  }, [K]), v(() => {
    O && J && (tt !== null && google.maps.event.removeListener(tt), Xe(google.maps.event.addListener(O, "position_changed", J)));
  }, [J]), v(() => {
    O && te && (Et !== null && google.maps.event.removeListener(Et), kt(google.maps.event.addListener(O, "shape_changed", te)));
  }, [te]), v(() => {
    O && ee && (pt !== null && google.maps.event.removeListener(pt), kn(google.maps.event.addListener(O, "title_changed", ee)));
  }, [ee]), v(() => {
    O && _ && (dt !== null && google.maps.event.removeListener(dt), Ln(google.maps.event.addListener(O, "visible_changed", _)));
  }, [_]), v(() => {
    O && D && (ft !== null && google.maps.event.removeListener(ft), rn(google.maps.event.addListener(O, "zindex_changed", D)));
  }, [D]), v(() => {
    var ht = Jl(Jl(Jl({}, n || em), r ? em : {
      map: W
    }), {}, {
      position: t
    }), re = new google.maps.Marker(ht);
    return r ? r.addMarker(re, !!o) : re.setMap(W), t && re.setPosition(t), typeof s < "u" && re.setVisible(s), typeof a < "u" && re.setDraggable(a), typeof u < "u" && re.setClickable(u), typeof c == "string" && re.setCursor(c), p && re.setIcon(p), typeof d < "u" && re.setLabel(d), typeof h < "u" && re.setOpacity(h), f && re.setShape(f), typeof m == "string" && re.setTitle(m), typeof g == "number" && re.setZIndex(g), w && j(google.maps.event.addListener(re, "dblclick", w)), x && A(google.maps.event.addListener(re, "dragend", x)), y && R(google.maps.event.addListener(re, "dragstart", y)), L && fe(google.maps.event.addListener(re, "mousedown", L)), C && Re(google.maps.event.addListener(re, "mouseout", C)), P && Ve(google.maps.event.addListener(re, "mouseover", P)), F && et(google.maps.event.addListener(re, "mouseup", F)), N && Pe(google.maps.event.addListener(re, "rightclick", N)), E && it(google.maps.event.addListener(re, "click", E)), M && Se(google.maps.event.addListener(re, "drag", M)), I && We(google.maps.event.addListener(re, "clickable_changed", I)), H && nt(google.maps.event.addListener(re, "cursor_changed", H)), V && xt(google.maps.event.addListener(re, "animation_changed", V)), z && st(google.maps.event.addListener(re, "draggable_changed", z)), q && Ot(google.maps.event.addListener(re, "flat_changed", q)), K && ct(google.maps.event.addListener(re, "icon_changed", K)), J && Xe(google.maps.event.addListener(re, "position_changed", J)), te && kt(google.maps.event.addListener(re, "shape_changed", te)), ee && kn(google.maps.event.addListener(re, "title_changed", ee)), _ && Ln(google.maps.event.addListener(re, "visible_changed", _)), D && rn(google.maps.event.addListener(re, "zindex_changed", D)), T(re), $ && $(re), () => {
      U !== null && google.maps.event.removeListener(U), Z !== null && google.maps.event.removeListener(Z), Q !== null && google.maps.event.removeListener(Q), ue !== null && google.maps.event.removeListener(ue), oe !== null && google.maps.event.removeListener(oe), He !== null && google.maps.event.removeListener(He), ze !== null && google.maps.event.removeListener(ze), Ge !== null && google.maps.event.removeListener(Ge), Ye !== null && google.maps.event.removeListener(Ye), Ke !== null && google.maps.event.removeListener(Ke), Ue !== null && google.maps.event.removeListener(Ue), Ie !== null && google.maps.event.removeListener(Ie), ot !== null && google.maps.event.removeListener(ot), lt !== null && google.maps.event.removeListener(lt), ut !== null && google.maps.event.removeListener(ut), tt !== null && google.maps.event.removeListener(tt), pt !== null && google.maps.event.removeListener(pt), dt !== null && google.maps.event.removeListener(dt), ft !== null && google.maps.event.removeListener(ft), S && S(re), r ? r.removeMarker(re, !!o) : re && re.setMap(null);
    };
  }, []);
  var br = Tn(() => i ? at.map(i, (ht) => {
    if (!bi(ht))
      return ht;
    var re = ht;
    return wi(re, {
      anchor: O
    });
  }) : null, [i, O]);
  return no.jsx(no.Fragment, {
    children: br
  }) || null;
}
Ee(jCe);
class ACe extends pe {
  constructor() {
    super(...arguments), xe(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this;
    return D6(function* () {
      var n = Jl(Jl(Jl({}, t.props.options || em), t.props.clusterer ? em : {
        map: t.context
      }), {}, {
        position: t.props.position
      });
      t.marker = new google.maps.Marker(n), t.props.clusterer ? t.props.clusterer.addMarker(t.marker, !!t.props.noClustererRedraw) : t.marker.setMap(t.context), t.registeredEvents = tn({
        updaterMap: iR,
        eventMap: oR,
        prevProps: {},
        nextProps: t.props,
        instance: t.marker
      }), t.props.onLoad && t.props.onLoad(t.marker);
    })();
  }
  componentDidUpdate(t) {
    this.marker && (ln(this.registeredEvents), this.registeredEvents = tn({
      updaterMap: iR,
      eventMap: oR,
      prevProps: t,
      nextProps: this.props,
      instance: this.marker
    }));
  }
  componentWillUnmount() {
    this.marker && (this.props.onUnmount && this.props.onUnmount(this.marker), ln(this.registeredEvents), this.props.clusterer ? this.props.clusterer.removeMarker(this.marker, !!this.props.noClustererRedraw) : this.marker && this.marker.setMap(null));
  }
  render() {
    var t = this.props.children ? at.map(this.props.children, (n) => {
      if (!bi(n))
        return n;
      var r = n;
      return wi(r, {
        anchor: this.marker
      });
    }) : null;
    return t || null;
  }
}
xe(ACe, "contextType", Dt);
var BCe = (
  /** @class */
  function() {
    function e(t, n) {
      t.getClusterer().extend(e, google.maps.OverlayView), this.cluster = t, this.clusterClassName = this.cluster.getClusterer().getClusterClass(), this.className = this.clusterClassName, this.styles = n, this.center = void 0, this.div = null, this.sums = null, this.visible = !1, this.boundsChangedListener = null, this.url = "", this.height = 0, this.width = 0, this.anchorText = [0, 0], this.anchorIcon = [0, 0], this.textColor = "black", this.textSize = 11, this.textDecoration = "none", this.fontWeight = "bold", this.fontStyle = "normal", this.fontFamily = "Arial,sans-serif", this.backgroundPosition = "0 0", this.cMouseDownInCluster = null, this.cDraggingMapByCluster = null, this.timeOut = null, this.setMap(t.getMap()), this.onBoundsChanged = this.onBoundsChanged.bind(this), this.onMouseDown = this.onMouseDown.bind(this), this.onClick = this.onClick.bind(this), this.onMouseOver = this.onMouseOver.bind(this), this.onMouseOut = this.onMouseOut.bind(this), this.onAdd = this.onAdd.bind(this), this.onRemove = this.onRemove.bind(this), this.draw = this.draw.bind(this), this.hide = this.hide.bind(this), this.show = this.show.bind(this), this.useStyle = this.useStyle.bind(this), this.setCenter = this.setCenter.bind(this), this.getPosFromLatLng = this.getPosFromLatLng.bind(this);
    }
    return e.prototype.onBoundsChanged = function() {
      this.cDraggingMapByCluster = this.cMouseDownInCluster;
    }, e.prototype.onMouseDown = function() {
      this.cMouseDownInCluster = !0, this.cDraggingMapByCluster = !1;
    }, e.prototype.onClick = function(t) {
      if (this.cMouseDownInCluster = !1, !this.cDraggingMapByCluster) {
        var n = this.cluster.getClusterer();
        if (google.maps.event.trigger(n, "click", this.cluster), google.maps.event.trigger(n, "clusterclick", this.cluster), n.getZoomOnClick()) {
          var r = n.getMaxZoom(), o = this.cluster.getBounds(), i = n.getMap();
          i !== null && "fitBounds" in i && i.fitBounds(o), this.timeOut = window.setTimeout(function() {
            var a = n.getMap();
            if (a !== null) {
              "fitBounds" in a && a.fitBounds(o);
              var s = a.getZoom() || 0;
              r !== null && s > r && a.setZoom(r + 1);
            }
          }, 100);
        }
        t.cancelBubble = !0, t.stopPropagation && t.stopPropagation();
      }
    }, e.prototype.onMouseOver = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseover", this.cluster);
    }, e.prototype.onMouseOut = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseout", this.cluster);
    }, e.prototype.onAdd = function() {
      var t;
      this.div = document.createElement("div"), this.div.className = this.className, this.visible && this.show(), (t = this.getPanes()) === null || t === void 0 || t.overlayMouseTarget.appendChild(this.div);
      var n = this.getMap();
      n !== null && (this.boundsChangedListener = google.maps.event.addListener(n, "bounds_changed", this.onBoundsChanged), this.div.addEventListener("mousedown", this.onMouseDown), this.div.addEventListener("click", this.onClick), this.div.addEventListener("mouseover", this.onMouseOver), this.div.addEventListener("mouseout", this.onMouseOut));
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.hide(), this.boundsChangedListener !== null && google.maps.event.removeListener(this.boundsChangedListener), this.div.removeEventListener("mousedown", this.onMouseDown), this.div.removeEventListener("click", this.onClick), this.div.removeEventListener("mouseover", this.onMouseOver), this.div.removeEventListener("mouseout", this.onMouseOut), this.div.parentNode.removeChild(this.div), this.timeOut !== null && (window.clearTimeout(this.timeOut), this.timeOut = null), this.div = null);
    }, e.prototype.draw = function() {
      if (this.visible && this.div !== null && this.center) {
        var t = this.getPosFromLatLng(this.center);
        this.div.style.top = t !== null ? "".concat(t.y, "px") : "0", this.div.style.left = t !== null ? "".concat(t.x, "px") : "0";
      }
    }, e.prototype.hide = function() {
      this.div && (this.div.style.display = "none"), this.visible = !1;
    }, e.prototype.show = function() {
      var t, n, r, o, i, a;
      if (this.div && this.center) {
        var s = this.sums === null || typeof this.sums.title > "u" || this.sums.title === "" ? this.cluster.getClusterer().getTitle() : this.sums.title, l = this.backgroundPosition.split(" "), u = parseInt(((t = l[0]) === null || t === void 0 ? void 0 : t.replace(/^\s+|\s+$/g, "")) || "0", 10), c = parseInt(((n = l[1]) === null || n === void 0 ? void 0 : n.replace(/^\s+|\s+$/g, "")) || "0", 10), p = this.getPosFromLatLng(this.center);
        this.div.className = this.className, this.div.setAttribute("style", "cursor: pointer; position: absolute; top: ".concat(p !== null ? "".concat(p.y, "px") : "0", "; left: ").concat(p !== null ? "".concat(p.x, "px") : "0", "; width: ").concat(this.width, "px; height: ").concat(this.height, "px; "));
        var d = document.createElement("img");
        d.alt = s, d.src = this.url, d.width = this.width, d.height = this.height, d.setAttribute("style", "position: absolute; top: ".concat(c, "px; left: ").concat(u, "px")), this.cluster.getClusterer().enableRetinaIcons || (d.style.clip = "rect(-".concat(c, "px, -").concat(u + this.width, "px, -").concat(c + this.height, ", -").concat(u, ")"));
        var h = document.createElement("div");
        h.setAttribute("style", "position: absolute; top: ".concat(this.anchorText[0], "px; left: ").concat(this.anchorText[1], "px; color: ").concat(this.textColor, "; font-size: ").concat(this.textSize, "px; font-family: ").concat(this.fontFamily, "; font-weight: ").concat(this.fontWeight, "; fontStyle: ").concat(this.fontStyle, "; text-decoration: ").concat(this.textDecoration, "; text-align: center; width: ").concat(this.width, "px; line-height: ").concat(this.height, "px")), !((r = this.sums) === null || r === void 0) && r.text && (h.innerText = "".concat((o = this.sums) === null || o === void 0 ? void 0 : o.text)), !((i = this.sums) === null || i === void 0) && i.html && (h.innerHTML = "".concat((a = this.sums) === null || a === void 0 ? void 0 : a.html)), this.div.innerHTML = "", this.div.appendChild(d), this.div.appendChild(h), this.div.title = s, this.div.style.display = "";
      }
      this.visible = !0;
    }, e.prototype.useStyle = function(t) {
      this.sums = t;
      var n = this.cluster.getClusterer().getStyles(), r = n[Math.min(n.length - 1, Math.max(0, t.index - 1))];
      r && (this.url = r.url, this.height = r.height, this.width = r.width, r.className && (this.className = "".concat(this.clusterClassName, " ").concat(r.className)), this.anchorText = r.anchorText || [0, 0], this.anchorIcon = r.anchorIcon || [this.height / 2, this.width / 2], this.textColor = r.textColor || "black", this.textSize = r.textSize || 11, this.textDecoration = r.textDecoration || "none", this.fontWeight = r.fontWeight || "bold", this.fontStyle = r.fontStyle || "normal", this.fontFamily = r.fontFamily || "Arial,sans-serif", this.backgroundPosition = r.backgroundPosition || "0 0");
    }, e.prototype.setCenter = function(t) {
      this.center = t;
    }, e.prototype.getPosFromLatLng = function(t) {
      var n = this.getProjection().fromLatLngToDivPixel(t);
      return n !== null && (n.x -= this.anchorIcon[1], n.y -= this.anchorIcon[0]), n;
    }, e;
  }()
), ICe = (
  /** @class */
  function() {
    function e(t) {
      this.markerClusterer = t, this.map = this.markerClusterer.getMap(), this.gridSize = this.markerClusterer.getGridSize(), this.minClusterSize = this.markerClusterer.getMinimumClusterSize(), this.averageCenter = this.markerClusterer.getAverageCenter(), this.markers = [], this.center = void 0, this.bounds = null, this.clusterIcon = new BCe(this, this.markerClusterer.getStyles()), this.getSize = this.getSize.bind(this), this.getMarkers = this.getMarkers.bind(this), this.getCenter = this.getCenter.bind(this), this.getMap = this.getMap.bind(this), this.getClusterer = this.getClusterer.bind(this), this.getBounds = this.getBounds.bind(this), this.remove = this.remove.bind(this), this.addMarker = this.addMarker.bind(this), this.isMarkerInClusterBounds = this.isMarkerInClusterBounds.bind(this), this.calculateBounds = this.calculateBounds.bind(this), this.updateIcon = this.updateIcon.bind(this), this.isMarkerAlreadyAdded = this.isMarkerAlreadyAdded.bind(this);
    }
    return e.prototype.getSize = function() {
      return this.markers.length;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getCenter = function() {
      return this.center;
    }, e.prototype.getMap = function() {
      return this.map;
    }, e.prototype.getClusterer = function() {
      return this.markerClusterer;
    }, e.prototype.getBounds = function() {
      for (var t = new google.maps.LatLngBounds(this.center, this.center), n = this.getMarkers(), r = 0, o = n; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && t.extend(a);
      }
      return t;
    }, e.prototype.remove = function() {
      this.clusterIcon.setMap(null), this.markers = [], delete this.markers;
    }, e.prototype.addMarker = function(t) {
      var n;
      if (this.isMarkerAlreadyAdded(t))
        return !1;
      if (this.center) {
        if (this.averageCenter) {
          var r = t.getPosition();
          if (r) {
            var o = this.markers.length + 1;
            this.center = new google.maps.LatLng((this.center.lat() * (o - 1) + r.lat()) / o, (this.center.lng() * (o - 1) + r.lng()) / o), this.calculateBounds();
          }
        }
      } else {
        var r = t.getPosition();
        r && (this.center = r, this.calculateBounds());
      }
      t.isAdded = !0, this.markers.push(t);
      var i = this.markers.length, a = this.markerClusterer.getMaxZoom(), s = (n = this.map) === null || n === void 0 ? void 0 : n.getZoom();
      if (a !== null && typeof s < "u" && s > a)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i < this.minClusterSize)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i === this.minClusterSize)
        for (var l = 0, u = this.markers; l < u.length; l++) {
          var c = u[l];
          c.setMap(null);
        }
      else
        t.setMap(null);
      return !0;
    }, e.prototype.isMarkerInClusterBounds = function(t) {
      if (this.bounds !== null) {
        var n = t.getPosition();
        if (n)
          return this.bounds.contains(n);
      }
      return !1;
    }, e.prototype.calculateBounds = function() {
      this.bounds = this.markerClusterer.getExtendedBounds(new google.maps.LatLngBounds(this.center, this.center));
    }, e.prototype.updateIcon = function() {
      var t, n = this.markers.length, r = this.markerClusterer.getMaxZoom(), o = (t = this.map) === null || t === void 0 ? void 0 : t.getZoom();
      if (r !== null && typeof o < "u" && o > r) {
        this.clusterIcon.hide();
        return;
      }
      if (n < this.minClusterSize) {
        this.clusterIcon.hide();
        return;
      }
      this.center && this.clusterIcon.setCenter(this.center), this.clusterIcon.useStyle(this.markerClusterer.getCalculator()(this.markers, this.markerClusterer.getStyles().length)), this.clusterIcon.show();
    }, e.prototype.isMarkerAlreadyAdded = function(t) {
      if (this.markers.includes)
        return this.markers.includes(t);
      for (var n = 0; n < this.markers.length; n++)
        if (t === this.markers[n])
          return !0;
      return !1;
    }, e;
  }()
);
function RCe(e, t) {
  var n = e.length, r = n.toString().length, o = Math.min(r, t);
  return {
    text: n.toString(),
    index: o,
    title: ""
  };
}
var NCe = 2e3, FCe = 500, zCe = "https://developers.google.com/maps/documentation/javascript/examples/markerclusterer/m", UCe = "png", $Ce = [53, 56, 66, 78, 90], HCe = "cluster", I6 = (
  /** @class */
  function() {
    function e(t, n, r) {
      n === void 0 && (n = []), r === void 0 && (r = {}), this.getMinimumClusterSize = this.getMinimumClusterSize.bind(this), this.setMinimumClusterSize = this.setMinimumClusterSize.bind(this), this.getEnableRetinaIcons = this.getEnableRetinaIcons.bind(this), this.setEnableRetinaIcons = this.setEnableRetinaIcons.bind(this), this.addToClosestCluster = this.addToClosestCluster.bind(this), this.getImageExtension = this.getImageExtension.bind(this), this.setImageExtension = this.setImageExtension.bind(this), this.getExtendedBounds = this.getExtendedBounds.bind(this), this.getAverageCenter = this.getAverageCenter.bind(this), this.setAverageCenter = this.setAverageCenter.bind(this), this.getTotalClusters = this.getTotalClusters.bind(this), this.fitMapToMarkers = this.fitMapToMarkers.bind(this), this.getIgnoreHidden = this.getIgnoreHidden.bind(this), this.setIgnoreHidden = this.setIgnoreHidden.bind(this), this.getClusterClass = this.getClusterClass.bind(this), this.setClusterClass = this.setClusterClass.bind(this), this.getTotalMarkers = this.getTotalMarkers.bind(this), this.getZoomOnClick = this.getZoomOnClick.bind(this), this.setZoomOnClick = this.setZoomOnClick.bind(this), this.getBatchSizeIE = this.getBatchSizeIE.bind(this), this.setBatchSizeIE = this.setBatchSizeIE.bind(this), this.createClusters = this.createClusters.bind(this), this.onZoomChanged = this.onZoomChanged.bind(this), this.getImageSizes = this.getImageSizes.bind(this), this.setImageSizes = this.setImageSizes.bind(this), this.getCalculator = this.getCalculator.bind(this), this.setCalculator = this.setCalculator.bind(this), this.removeMarkers = this.removeMarkers.bind(this), this.resetViewport = this.resetViewport.bind(this), this.getImagePath = this.getImagePath.bind(this), this.setImagePath = this.setImagePath.bind(this), this.pushMarkerTo = this.pushMarkerTo.bind(this), this.removeMarker = this.removeMarker.bind(this), this.clearMarkers = this.clearMarkers.bind(this), this.setupStyles = this.setupStyles.bind(this), this.getGridSize = this.getGridSize.bind(this), this.setGridSize = this.setGridSize.bind(this), this.getClusters = this.getClusters.bind(this), this.getMaxZoom = this.getMaxZoom.bind(this), this.setMaxZoom = this.setMaxZoom.bind(this), this.getMarkers = this.getMarkers.bind(this), this.addMarkers = this.addMarkers.bind(this), this.getStyles = this.getStyles.bind(this), this.setStyles = this.setStyles.bind(this), this.addMarker = this.addMarker.bind(this), this.onRemove = this.onRemove.bind(this), this.getTitle = this.getTitle.bind(this), this.setTitle = this.setTitle.bind(this), this.repaint = this.repaint.bind(this), this.onIdle = this.onIdle.bind(this), this.redraw = this.redraw.bind(this), this.onAdd = this.onAdd.bind(this), this.draw = this.draw.bind(this), this.extend = this.extend.bind(this), this.extend(e, google.maps.OverlayView), this.markers = [], this.clusters = [], this.listeners = [], this.activeMap = null, this.ready = !1, this.gridSize = r.gridSize || 60, this.minClusterSize = r.minimumClusterSize || 2, this.maxZoom = r.maxZoom || null, this.styles = r.styles || [], this.title = r.title || "", this.zoomOnClick = !0, r.zoomOnClick !== void 0 && (this.zoomOnClick = r.zoomOnClick), this.averageCenter = !1, r.averageCenter !== void 0 && (this.averageCenter = r.averageCenter), this.ignoreHidden = !1, r.ignoreHidden !== void 0 && (this.ignoreHidden = r.ignoreHidden), this.enableRetinaIcons = !1, r.enableRetinaIcons !== void 0 && (this.enableRetinaIcons = r.enableRetinaIcons), this.imagePath = r.imagePath || zCe, this.imageExtension = r.imageExtension || UCe, this.imageSizes = r.imageSizes || $Ce, this.calculator = r.calculator || RCe, this.batchSize = r.batchSize || NCe, this.batchSizeIE = r.batchSizeIE || FCe, this.clusterClass = r.clusterClass || HCe, navigator.userAgent.toLowerCase().indexOf("msie") !== -1 && (this.batchSize = this.batchSizeIE), this.timerRefStatic = null, this.setupStyles(), this.addMarkers(n, !0), this.setMap(t);
    }
    return e.prototype.onZoomChanged = function() {
      var t, n;
      this.resetViewport(!1), (((t = this.getMap()) === null || t === void 0 ? void 0 : t.getZoom()) === (this.get("minZoom") || 0) || ((n = this.getMap()) === null || n === void 0 ? void 0 : n.getZoom()) === this.get("maxZoom")) && google.maps.event.trigger(this, "idle");
    }, e.prototype.onIdle = function() {
      this.redraw();
    }, e.prototype.onAdd = function() {
      var t = this.getMap();
      this.activeMap = t, this.ready = !0, this.repaint(), t !== null && (this.listeners = [google.maps.event.addListener(t, "zoom_changed", this.onZoomChanged), google.maps.event.addListener(t, "idle", this.onIdle)]);
    }, e.prototype.onRemove = function() {
      for (var t = 0, n = this.markers; t < n.length; t++) {
        var r = n[t];
        r.getMap() !== this.activeMap && r.setMap(this.activeMap);
      }
      for (var o = 0, i = this.clusters; o < i.length; o++) {
        var a = i[o];
        a.remove();
      }
      this.clusters = [];
      for (var s = 0, l = this.listeners; s < l.length; s++) {
        var u = l[s];
        google.maps.event.removeListener(u);
      }
      this.listeners = [], this.activeMap = null, this.ready = !1;
    }, e.prototype.draw = function() {
    }, e.prototype.getMap = function() {
      return null;
    }, e.prototype.getPanes = function() {
      return null;
    }, e.prototype.getProjection = function() {
      return {
        fromContainerPixelToLatLng: function() {
          return null;
        },
        fromDivPixelToLatLng: function() {
          return null;
        },
        fromLatLngToContainerPixel: function() {
          return null;
        },
        fromLatLngToDivPixel: function() {
          return null;
        },
        getVisibleRegion: function() {
          return null;
        },
        getWorldWidth: function() {
          return 0;
        }
      };
    }, e.prototype.setMap = function() {
    }, e.prototype.addListener = function() {
      return {
        remove: function() {
        }
      };
    }, e.prototype.bindTo = function() {
    }, e.prototype.get = function() {
    }, e.prototype.notify = function() {
    }, e.prototype.set = function() {
    }, e.prototype.setValues = function() {
    }, e.prototype.unbind = function() {
    }, e.prototype.unbindAll = function() {
    }, e.prototype.setupStyles = function() {
      if (!(this.styles.length > 0))
        for (var t = 0; t < this.imageSizes.length; t++)
          this.styles.push({
            url: "".concat(this.imagePath + (t + 1), ".").concat(this.imageExtension),
            height: this.imageSizes[t] || 0,
            width: this.imageSizes[t] || 0
          });
    }, e.prototype.fitMapToMarkers = function() {
      for (var t = this.getMarkers(), n = new google.maps.LatLngBounds(), r = 0, o = t; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && n.extend(a);
      }
      var s = this.getMap();
      s !== null && "fitBounds" in s && s.fitBounds(n);
    }, e.prototype.getGridSize = function() {
      return this.gridSize;
    }, e.prototype.setGridSize = function(t) {
      this.gridSize = t;
    }, e.prototype.getMinimumClusterSize = function() {
      return this.minClusterSize;
    }, e.prototype.setMinimumClusterSize = function(t) {
      this.minClusterSize = t;
    }, e.prototype.getMaxZoom = function() {
      return this.maxZoom;
    }, e.prototype.setMaxZoom = function(t) {
      this.maxZoom = t;
    }, e.prototype.getStyles = function() {
      return this.styles;
    }, e.prototype.setStyles = function(t) {
      this.styles = t;
    }, e.prototype.getTitle = function() {
      return this.title;
    }, e.prototype.setTitle = function(t) {
      this.title = t;
    }, e.prototype.getZoomOnClick = function() {
      return this.zoomOnClick;
    }, e.prototype.setZoomOnClick = function(t) {
      this.zoomOnClick = t;
    }, e.prototype.getAverageCenter = function() {
      return this.averageCenter;
    }, e.prototype.setAverageCenter = function(t) {
      this.averageCenter = t;
    }, e.prototype.getIgnoreHidden = function() {
      return this.ignoreHidden;
    }, e.prototype.setIgnoreHidden = function(t) {
      this.ignoreHidden = t;
    }, e.prototype.getEnableRetinaIcons = function() {
      return this.enableRetinaIcons;
    }, e.prototype.setEnableRetinaIcons = function(t) {
      this.enableRetinaIcons = t;
    }, e.prototype.getImageExtension = function() {
      return this.imageExtension;
    }, e.prototype.setImageExtension = function(t) {
      this.imageExtension = t;
    }, e.prototype.getImagePath = function() {
      return this.imagePath;
    }, e.prototype.setImagePath = function(t) {
      this.imagePath = t;
    }, e.prototype.getImageSizes = function() {
      return this.imageSizes;
    }, e.prototype.setImageSizes = function(t) {
      this.imageSizes = t;
    }, e.prototype.getCalculator = function() {
      return this.calculator;
    }, e.prototype.setCalculator = function(t) {
      this.calculator = t;
    }, e.prototype.getBatchSizeIE = function() {
      return this.batchSizeIE;
    }, e.prototype.setBatchSizeIE = function(t) {
      this.batchSizeIE = t;
    }, e.prototype.getClusterClass = function() {
      return this.clusterClass;
    }, e.prototype.setClusterClass = function(t) {
      this.clusterClass = t;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getTotalMarkers = function() {
      return this.markers.length;
    }, e.prototype.getClusters = function() {
      return this.clusters;
    }, e.prototype.getTotalClusters = function() {
      return this.clusters.length;
    }, e.prototype.addMarker = function(t, n) {
      this.pushMarkerTo(t), n || this.redraw();
    }, e.prototype.addMarkers = function(t, n) {
      for (var r in t)
        if (Object.prototype.hasOwnProperty.call(t, r)) {
          var o = t[r];
          o && this.pushMarkerTo(o);
        }
      n || this.redraw();
    }, e.prototype.pushMarkerTo = function(t) {
      var n = this;
      t.getDraggable() && google.maps.event.addListener(t, "dragend", function() {
        n.ready && (t.isAdded = !1, n.repaint());
      }), t.isAdded = !1, this.markers.push(t);
    }, e.prototype.removeMarker_ = function(t) {
      var n = -1;
      if (this.markers.indexOf)
        n = this.markers.indexOf(t);
      else
        for (var r = 0; r < this.markers.length; r++)
          if (t === this.markers[r]) {
            n = r;
            break;
          }
      return n === -1 ? !1 : (t.setMap(null), this.markers.splice(n, 1), !0);
    }, e.prototype.removeMarker = function(t, n) {
      var r = this.removeMarker_(t);
      return !n && r && this.repaint(), r;
    }, e.prototype.removeMarkers = function(t, n) {
      for (var r = !1, o = 0, i = t; o < i.length; o++) {
        var a = i[o];
        r = r || this.removeMarker_(a);
      }
      return !n && r && this.repaint(), r;
    }, e.prototype.clearMarkers = function() {
      this.resetViewport(!0), this.markers = [];
    }, e.prototype.repaint = function() {
      var t = this.clusters.slice();
      this.clusters = [], this.resetViewport(!1), this.redraw(), setTimeout(function() {
        for (var n = 0, r = t; n < r.length; n++) {
          var o = r[n];
          o.remove();
        }
      }, 0);
    }, e.prototype.getExtendedBounds = function(t) {
      var n = this.getProjection(), r = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getNorthEast().lat(), t.getNorthEast().lng())
      );
      r !== null && (r.x += this.gridSize, r.y -= this.gridSize);
      var o = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getSouthWest().lat(), t.getSouthWest().lng())
      );
      if (o !== null && (o.x -= this.gridSize, o.y += this.gridSize), r !== null) {
        var i = n.fromDivPixelToLatLng(r);
        i !== null && t.extend(i);
      }
      if (o !== null) {
        var a = n.fromDivPixelToLatLng(o);
        a !== null && t.extend(a);
      }
      return t;
    }, e.prototype.redraw = function() {
      this.createClusters(0);
    }, e.prototype.resetViewport = function(t) {
      for (var n = 0, r = this.clusters; n < r.length; n++) {
        var o = r[n];
        o.remove();
      }
      this.clusters = [];
      for (var i = 0, a = this.markers; i < a.length; i++) {
        var s = a[i];
        s.isAdded = !1, t && s.setMap(null);
      }
    }, e.prototype.distanceBetweenPoints = function(t, n) {
      var r = 6371, o = (n.lat() - t.lat()) * Math.PI / 180, i = (n.lng() - t.lng()) * Math.PI / 180, a = Math.sin(o / 2) * Math.sin(o / 2) + Math.cos(t.lat() * Math.PI / 180) * Math.cos(n.lat() * Math.PI / 180) * Math.sin(i / 2) * Math.sin(i / 2);
      return r * (2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)));
    }, e.prototype.isMarkerInBounds = function(t, n) {
      var r = t.getPosition();
      return r ? n.contains(r) : !1;
    }, e.prototype.addToClosestCluster = function(t) {
      for (var n, r = 4e4, o = null, i = 0, a = this.clusters; i < a.length; i++) {
        var s = a[i];
        n = s;
        var l = n.getCenter(), u = t.getPosition();
        if (l && u) {
          var c = this.distanceBetweenPoints(l, u);
          c < r && (r = c, o = n);
        }
      }
      o && o.isMarkerInClusterBounds(t) ? o.addMarker(t) : (n = new ICe(this), n.addMarker(t), this.clusters.push(n));
    }, e.prototype.createClusters = function(t) {
      var n = this;
      if (this.ready) {
        t === 0 && (google.maps.event.trigger(this, "clusteringbegin", this), this.timerRefStatic !== null && (window.clearTimeout(this.timerRefStatic), delete this.timerRefStatic));
        for (var r = this.getMap(), o = r !== null && ("getBounds" in r) ? r.getBounds() : null, i = (r == null ? void 0 : r.getZoom()) || 0, a = i > 3 ? new google.maps.LatLngBounds(o == null ? void 0 : o.getSouthWest(), o == null ? void 0 : o.getNorthEast()) : new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625)), s = this.getExtendedBounds(a), l = Math.min(t + this.batchSize, this.markers.length), u = t; u < l; u++) {
          var c = this.markers[u];
          c && !c.isAdded && this.isMarkerInBounds(c, s) && (!this.ignoreHidden || this.ignoreHidden && c.getVisible()) && this.addToClosestCluster(c);
        }
        if (l < this.markers.length)
          this.timerRefStatic = window.setTimeout(function() {
            n.createClusters(l);
          }, 0);
        else {
          this.timerRefStatic = null, google.maps.event.trigger(this, "clusteringend", this);
          for (var p = 0, d = this.clusters; p < d.length; p++) {
            var h = d[p];
            h.updateIcon();
          }
        }
      }
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype) {
          var i = o;
          this.prototype[i] = r.prototype[i];
        }
        return this;
      }).apply(t, [n]);
    }, e;
  }()
);
function sR(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function WCe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? sR(Object(n), !0).forEach(function(r) {
      xe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : sR(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var hi = {
  onClick: "click",
  onClusteringBegin: "clusteringbegin",
  onClusteringEnd: "clusteringend",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover"
}, fn = {
  averageCenter(e, t) {
    e.setAverageCenter(t);
  },
  batchSizeIE(e, t) {
    e.setBatchSizeIE(t);
  },
  calculator(e, t) {
    e.setCalculator(t);
  },
  clusterClass(e, t) {
    e.setClusterClass(t);
  },
  enableRetinaIcons(e, t) {
    e.setEnableRetinaIcons(t);
  },
  gridSize(e, t) {
    e.setGridSize(t);
  },
  ignoreHidden(e, t) {
    e.setIgnoreHidden(t);
  },
  imageExtension(e, t) {
    e.setImageExtension(t);
  },
  imagePath(e, t) {
    e.setImagePath(t);
  },
  imageSizes(e, t) {
    e.setImageSizes(t);
  },
  maxZoom(e, t) {
    e.setMaxZoom(t);
  },
  minimumClusterSize(e, t) {
    e.setMinimumClusterSize(t);
  },
  styles(e, t) {
    e.setStyles(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  zoomOnClick(e, t) {
    e.setZoomOnClick(t);
  }
}, VCe = {};
function qCe(e) {
  var {
    children: t,
    options: n,
    averageCenter: r,
    batchSizeIE: o,
    calculator: i,
    clusterClass: a,
    enableRetinaIcons: s,
    gridSize: l,
    ignoreHidden: u,
    imageExtension: c,
    imagePath: p,
    imageSizes: d,
    maxZoom: h,
    minimumClusterSize: f,
    styles: m,
    title: g,
    zoomOnClick: E,
    onClick: w,
    onClusteringBegin: M,
    onClusteringEnd: x,
    onMouseOver: y,
    onMouseOut: C,
    onLoad: P,
    onUnmount: F
  } = e, [L, N] = k(null), I = ye(Dt), [H, V] = k(null), [z, q] = k(null), [K, J] = k(null), [te, ee] = k(null), [_, D] = k(null);
  return v(() => {
    L && C && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(L, hi.onMouseOut, C)));
  }, [C]), v(() => {
    L && y && (_ !== null && google.maps.event.removeListener(_), D(google.maps.event.addListener(L, hi.onMouseOver, y)));
  }, [y]), v(() => {
    L && w && (H !== null && google.maps.event.removeListener(H), V(google.maps.event.addListener(L, hi.onClick, w)));
  }, [w]), v(() => {
    L && M && (z !== null && google.maps.event.removeListener(z), q(google.maps.event.addListener(L, hi.onClusteringBegin, M)));
  }, [M]), v(() => {
    L && x && (K !== null && google.maps.event.removeListener(K), q(google.maps.event.addListener(L, hi.onClusteringEnd, x)));
  }, [x]), v(() => {
    typeof r < "u" && L !== null && fn.averageCenter(L, r);
  }, [L, r]), v(() => {
    typeof o < "u" && L !== null && fn.batchSizeIE(L, o);
  }, [L, o]), v(() => {
    typeof i < "u" && L !== null && fn.calculator(L, i);
  }, [L, i]), v(() => {
    typeof a < "u" && L !== null && fn.clusterClass(L, a);
  }, [L, a]), v(() => {
    typeof s < "u" && L !== null && fn.enableRetinaIcons(L, s);
  }, [L, s]), v(() => {
    typeof l < "u" && L !== null && fn.gridSize(L, l);
  }, [L, l]), v(() => {
    typeof u < "u" && L !== null && fn.ignoreHidden(L, u);
  }, [L, u]), v(() => {
    typeof c < "u" && L !== null && fn.imageExtension(L, c);
  }, [L, c]), v(() => {
    typeof p < "u" && L !== null && fn.imagePath(L, p);
  }, [L, p]), v(() => {
    typeof d < "u" && L !== null && fn.imageSizes(L, d);
  }, [L, d]), v(() => {
    typeof h < "u" && L !== null && fn.maxZoom(L, h);
  }, [L, h]), v(() => {
    typeof f < "u" && L !== null && fn.minimumClusterSize(L, f);
  }, [L, f]), v(() => {
    typeof m < "u" && L !== null && fn.styles(L, m);
  }, [L, m]), v(() => {
    typeof g < "u" && L !== null && fn.title(L, g);
  }, [L, g]), v(() => {
    typeof E < "u" && L !== null && fn.zoomOnClick(L, E);
  }, [L, E]), v(() => {
    if (I) {
      var $ = WCe({}, n || VCe), S = new I6(I, [], $);
      return r && fn.averageCenter(S, r), o && fn.batchSizeIE(S, o), i && fn.calculator(S, i), a && fn.clusterClass(S, a), s && fn.enableRetinaIcons(S, s), l && fn.gridSize(S, l), u && fn.ignoreHidden(S, u), c && fn.imageExtension(S, c), p && fn.imagePath(S, p), d && fn.imageSizes(S, d), h && fn.maxZoom(S, h), f && fn.minimumClusterSize(S, f), m && fn.styles(S, m), g && fn.title(S, g), E && fn.zoomOnClick(S, E), C && ee(google.maps.event.addListener(S, hi.onMouseOut, C)), y && D(google.maps.event.addListener(S, hi.onMouseOver, y)), w && V(google.maps.event.addListener(S, hi.onClick, w)), M && q(google.maps.event.addListener(S, hi.onClusteringBegin, M)), x && J(google.maps.event.addListener(S, hi.onClusteringEnd, x)), N(S), P && P(S), () => {
        te !== null && google.maps.event.removeListener(te), _ !== null && google.maps.event.removeListener(_), H !== null && google.maps.event.removeListener(H), z !== null && google.maps.event.removeListener(z), K !== null && google.maps.event.removeListener(K), F && F(S);
      };
    }
  }, []), L !== null && t(L) || null;
}
Ee(qCe);
class ZCe extends pe {
  constructor() {
    super(...arguments), xe(this, "registeredEvents", []), xe(this, "state", {
      markerClusterer: null
    }), xe(this, "setClustererCallback", () => {
      this.state.markerClusterer !== null && this.props.onLoad && this.props.onLoad(this.state.markerClusterer);
    });
  }
  componentDidMount() {
    if (this.context) {
      var t = new I6(this.context, [], this.props.options);
      this.registeredEvents = tn({
        updaterMap: fn,
        eventMap: hi,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        markerClusterer: t
      }), this.setClustererCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.markerClusterer && (ln(this.registeredEvents), this.registeredEvents = tn({
      updaterMap: fn,
      eventMap: hi,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.markerClusterer
    }));
  }
  componentWillUnmount() {
    this.state.markerClusterer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.markerClusterer), ln(this.registeredEvents), this.state.markerClusterer.setMap(null));
  }
  render() {
    return this.state.markerClusterer !== null ? this.props.children(this.state.markerClusterer) : null;
  }
}
xe(ZCe, "contextType", Dt);
function aR(e) {
  e.cancelBubble = !0, e.stopPropagation && e.stopPropagation();
}
var R6 = (
  /** @class */
  function() {
    function e(t) {
      t === void 0 && (t = {}), this.getCloseClickHandler = this.getCloseClickHandler.bind(this), this.closeClickHandler = this.closeClickHandler.bind(this), this.createInfoBoxDiv = this.createInfoBoxDiv.bind(this), this.addClickHandler = this.addClickHandler.bind(this), this.getCloseBoxImg = this.getCloseBoxImg.bind(this), this.getBoxWidths = this.getBoxWidths.bind(this), this.setBoxStyle = this.setBoxStyle.bind(this), this.setPosition = this.setPosition.bind(this), this.getPosition = this.getPosition.bind(this), this.setOptions = this.setOptions.bind(this), this.setContent = this.setContent.bind(this), this.setVisible = this.setVisible.bind(this), this.getContent = this.getContent.bind(this), this.getVisible = this.getVisible.bind(this), this.setZIndex = this.setZIndex.bind(this), this.getZIndex = this.getZIndex.bind(this), this.onRemove = this.onRemove.bind(this), this.panBox = this.panBox.bind(this), this.extend = this.extend.bind(this), this.close = this.close.bind(this), this.draw = this.draw.bind(this), this.show = this.show.bind(this), this.hide = this.hide.bind(this), this.open = this.open.bind(this), this.extend(e, google.maps.OverlayView), this.content = t.content || "", this.disableAutoPan = t.disableAutoPan || !1, this.maxWidth = t.maxWidth || 0, this.pixelOffset = t.pixelOffset || new google.maps.Size(0, 0), this.position = t.position || new google.maps.LatLng(0, 0), this.zIndex = t.zIndex || null, this.boxClass = t.boxClass || "infoBox", this.boxStyle = t.boxStyle || {}, this.closeBoxMargin = t.closeBoxMargin || "2px", this.closeBoxURL = t.closeBoxURL || "http://www.google.com/intl/en_us/mapfiles/close.gif", t.closeBoxURL === "" && (this.closeBoxURL = ""), this.infoBoxClearance = t.infoBoxClearance || new google.maps.Size(1, 1), typeof t.visible > "u" && (typeof t.isHidden > "u" ? t.visible = !0 : t.visible = !t.isHidden), this.isHidden = !t.visible, this.alignBottom = t.alignBottom || !1, this.pane = t.pane || "floatPane", this.enableEventPropagation = t.enableEventPropagation || !1, this.div = null, this.closeListener = null, this.moveListener = null, this.mapListener = null, this.contextListener = null, this.eventListeners = null, this.fixedWidthSet = null;
    }
    return e.prototype.createInfoBoxDiv = function() {
      var t = this, n = function(u) {
        u.returnValue = !1, u.preventDefault && u.preventDefault(), t.enableEventPropagation || aR(u);
      };
      if (!this.div) {
        this.div = document.createElement("div"), this.setBoxStyle(), typeof this.content == "string" ? this.div.innerHTML = this.getCloseBoxImg() + this.content : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(this.content));
        var r = this.getPanes();
        if (r !== null && r[this.pane].appendChild(this.div), this.addClickHandler(), this.div.style.width)
          this.fixedWidthSet = !0;
        else if (this.maxWidth !== 0 && this.div.offsetWidth > this.maxWidth)
          this.div.style.width = this.maxWidth + "px", this.fixedWidthSet = !0;
        else {
          var o = this.getBoxWidths();
          this.div.style.width = this.div.offsetWidth - o.left - o.right + "px", this.fixedWidthSet = !1;
        }
        if (this.panBox(this.disableAutoPan), !this.enableEventPropagation) {
          this.eventListeners = [];
          for (var i = ["mousedown", "mouseover", "mouseout", "mouseup", "click", "dblclick", "touchstart", "touchend", "touchmove"], a = 0, s = i; a < s.length; a++) {
            var l = s[a];
            this.eventListeners.push(google.maps.event.addListener(this.div, l, aR));
          }
          this.eventListeners.push(google.maps.event.addListener(this.div, "mouseover", function() {
            t.div && (t.div.style.cursor = "default");
          }));
        }
        this.contextListener = google.maps.event.addListener(this.div, "contextmenu", n), google.maps.event.trigger(this, "domready");
      }
    }, e.prototype.getCloseBoxImg = function() {
      var t = "";
      return this.closeBoxURL !== "" && (t = '<img alt=""', t += ' aria-hidden="true"', t += " src='" + this.closeBoxURL + "'", t += " align=right", t += " style='", t += " position: relative;", t += " cursor: pointer;", t += " margin: " + this.closeBoxMargin + ";", t += "'>"), t;
    }, e.prototype.addClickHandler = function() {
      this.closeListener = this.div && this.div.firstChild && this.closeBoxURL !== "" ? google.maps.event.addListener(this.div.firstChild, "click", this.getCloseClickHandler()) : null;
    }, e.prototype.closeClickHandler = function(t) {
      t.cancelBubble = !0, t.stopPropagation && t.stopPropagation(), google.maps.event.trigger(this, "closeclick"), this.close();
    }, e.prototype.getCloseClickHandler = function() {
      return this.closeClickHandler;
    }, e.prototype.panBox = function(t) {
      if (this.div && !t) {
        var n = this.getMap();
        if (n instanceof google.maps.Map) {
          var r = 0, o = 0, i = n.getBounds();
          i && !i.contains(this.position) && n.setCenter(this.position);
          var a = n.getDiv(), s = a.offsetWidth, l = a.offsetHeight, u = this.pixelOffset.width, c = this.pixelOffset.height, p = this.div.offsetWidth, d = this.div.offsetHeight, h = this.infoBoxClearance.width, f = this.infoBoxClearance.height, m = this.getProjection(), g = m.fromLatLngToContainerPixel(this.position);
          g !== null && (g.x < -u + h ? r = g.x + u - h : g.x + p + u + h > s && (r = g.x + p + u + h - s), this.alignBottom ? g.y < -c + f + d ? o = g.y + c - f - d : g.y + c + f > l && (o = g.y + c + f - l) : g.y < -c + f ? o = g.y + c - f : g.y + d + c + f > l && (o = g.y + d + c + f - l)), r === 0 && o === 0 || n.panBy(r, o);
        }
      }
    }, e.prototype.setBoxStyle = function() {
      if (this.div) {
        this.div.className = this.boxClass, this.div.style.cssText = "";
        var t = this.boxStyle;
        for (var n in t)
          Object.prototype.hasOwnProperty.call(t, n) && (this.div.style[n] = t[n]);
        if (this.div.style.webkitTransform = "translateZ(0)", typeof this.div.style.opacity < "u" && this.div.style.opacity !== "") {
          var r = parseFloat(this.div.style.opacity || "");
          this.div.style.msFilter = '"progid:DXImageTransform.Microsoft.Alpha(Opacity=' + r * 100 + ')"', this.div.style.filter = "alpha(opacity=" + r * 100 + ")";
        }
        this.div.style.position = "absolute", this.div.style.visibility = "hidden", this.zIndex !== null && (this.div.style.zIndex = this.zIndex + ""), this.div.style.overflow || (this.div.style.overflow = "auto");
      }
    }, e.prototype.getBoxWidths = function() {
      var t = {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0
      };
      if (!this.div)
        return t;
      if (document.defaultView) {
        var n = this.div.ownerDocument, r = n && n.defaultView ? n.defaultView.getComputedStyle(this.div, "") : null;
        r && (t.top = parseInt(r.borderTopWidth || "", 10) || 0, t.bottom = parseInt(r.borderBottomWidth || "", 10) || 0, t.left = parseInt(r.borderLeftWidth || "", 10) || 0, t.right = parseInt(r.borderRightWidth || "", 10) || 0);
      } else if (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        document.documentElement.currentStyle
      ) {
        var o = this.div.currentStyle;
        o && (t.top = parseInt(o.borderTopWidth || "", 10) || 0, t.bottom = parseInt(o.borderBottomWidth || "", 10) || 0, t.left = parseInt(o.borderLeftWidth || "", 10) || 0, t.right = parseInt(o.borderRightWidth || "", 10) || 0);
      }
      return t;
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.div.parentNode.removeChild(this.div), this.div = null);
    }, e.prototype.draw = function() {
      if (this.createInfoBoxDiv(), this.div) {
        var t = this.getProjection(), n = t.fromLatLngToDivPixel(this.position);
        n !== null && (this.div.style.left = n.x + this.pixelOffset.width + "px", this.alignBottom ? this.div.style.bottom = -(n.y + this.pixelOffset.height) + "px" : this.div.style.top = n.y + this.pixelOffset.height + "px"), this.isHidden ? this.div.style.visibility = "hidden" : this.div.style.visibility = "visible";
      }
    }, e.prototype.setOptions = function(t) {
      t === void 0 && (t = {}), typeof t.boxClass < "u" && (this.boxClass = t.boxClass, this.setBoxStyle()), typeof t.boxStyle < "u" && (this.boxStyle = t.boxStyle, this.setBoxStyle()), typeof t.content < "u" && this.setContent(t.content), typeof t.disableAutoPan < "u" && (this.disableAutoPan = t.disableAutoPan), typeof t.maxWidth < "u" && (this.maxWidth = t.maxWidth), typeof t.pixelOffset < "u" && (this.pixelOffset = t.pixelOffset), typeof t.alignBottom < "u" && (this.alignBottom = t.alignBottom), typeof t.position < "u" && this.setPosition(t.position), typeof t.zIndex < "u" && this.setZIndex(t.zIndex), typeof t.closeBoxMargin < "u" && (this.closeBoxMargin = t.closeBoxMargin), typeof t.closeBoxURL < "u" && (this.closeBoxURL = t.closeBoxURL), typeof t.infoBoxClearance < "u" && (this.infoBoxClearance = t.infoBoxClearance), typeof t.isHidden < "u" && (this.isHidden = t.isHidden), typeof t.visible < "u" && (this.isHidden = !t.visible), typeof t.enableEventPropagation < "u" && (this.enableEventPropagation = t.enableEventPropagation), this.div && this.draw();
    }, e.prototype.setContent = function(t) {
      this.content = t, this.div && (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.fixedWidthSet || (this.div.style.width = ""), typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t)), this.fixedWidthSet || (this.div.style.width = this.div.offsetWidth + "px", typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t))), this.addClickHandler()), google.maps.event.trigger(this, "content_changed");
    }, e.prototype.setPosition = function(t) {
      this.position = t, this.div && this.draw(), google.maps.event.trigger(this, "position_changed");
    }, e.prototype.setVisible = function(t) {
      this.isHidden = !t, this.div && (this.div.style.visibility = this.isHidden ? "hidden" : "visible");
    }, e.prototype.setZIndex = function(t) {
      this.zIndex = t, this.div && (this.div.style.zIndex = t + ""), google.maps.event.trigger(this, "zindex_changed");
    }, e.prototype.getContent = function() {
      return this.content;
    }, e.prototype.getPosition = function() {
      return this.position;
    }, e.prototype.getZIndex = function() {
      return this.zIndex;
    }, e.prototype.getVisible = function() {
      var t = this.getMap();
      return typeof t > "u" || t === null ? !1 : !this.isHidden;
    }, e.prototype.show = function() {
      this.isHidden = !1, this.div && (this.div.style.visibility = "visible");
    }, e.prototype.hide = function() {
      this.isHidden = !0, this.div && (this.div.style.visibility = "hidden");
    }, e.prototype.open = function(t, n) {
      var r = this;
      n && (this.position = n.getPosition(), this.moveListener = google.maps.event.addListener(n, "position_changed", function() {
        var o = n.getPosition();
        r.setPosition(o);
      }), this.mapListener = google.maps.event.addListener(n, "map_changed", function() {
        r.setMap(n.map);
      })), this.setMap(t), this.div && this.panBox();
    }, e.prototype.close = function() {
      if (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.eventListeners) {
        for (var t = 0, n = this.eventListeners; t < n.length; t++) {
          var r = n[t];
          google.maps.event.removeListener(r);
        }
        this.eventListeners = null;
      }
      this.moveListener && (google.maps.event.removeListener(this.moveListener), this.moveListener = null), this.mapListener && (google.maps.event.removeListener(this.mapListener), this.mapListener = null), this.contextListener && (google.maps.event.removeListener(this.contextListener), this.contextListener = null), this.setMap(null);
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype)
          Object.prototype.hasOwnProperty.call(this, o) || (this.prototype[o] = r.prototype[o]);
        return this;
      }).apply(t, [n]);
    }, e;
  }()
), GCe = ["position"], XCe = ["position"];
function lR(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function tm(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? lR(Object(n), !0).forEach(function(r) {
      xe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : lR(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var uR = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, cR = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    t instanceof google.maps.LatLng ? e.setPosition(t) : e.setPosition(new google.maps.LatLng(t.lat, t.lng));
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, KCe = {};
function YCe(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, h = ye(Dt), [f, m] = k(null), [g, E] = k(null), [w, M] = k(null), [x, y] = k(null), [C, P] = k(null), [F, L] = k(null), N = rt(null);
  return v(() => {
    h && f !== null && (f.close(), n ? f.open(h, n) : f.getPosition() && f.open(h));
  }, [h, f, n]), v(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), v(() => {
    if (o && f !== null) {
      var I = o instanceof google.maps.LatLng ? o : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        new google.maps.LatLng(o.lat, o.lng)
      );
      f.setPosition(I);
    }
  }, [o]), v(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), v(() => {
    f && a && (g !== null && google.maps.event.removeListener(g), E(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), v(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), M(google.maps.event.addListener(f, "domready", s)));
  }, [s]), v(() => {
    f && l && (x !== null && google.maps.event.removeListener(x), y(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), v(() => {
    f && u && (C !== null && google.maps.event.removeListener(C), P(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), v(() => {
    f && c && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), v(() => {
    if (h) {
      var I = r || KCe, {
        position: H
      } = I, V = Vk(I, GCe), z;
      H && !(H instanceof google.maps.LatLng) && (z = new google.maps.LatLng(H.lat, H.lng));
      var q = new R6(tm(tm({}, V), z ? {
        position: z
      } : {}));
      N.current = document.createElement("div"), m(q), a && E(google.maps.event.addListener(q, "closeclick", a)), s && M(google.maps.event.addListener(q, "domready", s)), l && y(google.maps.event.addListener(q, "content_changed", l)), u && P(google.maps.event.addListener(q, "position_changed", u)), c && L(google.maps.event.addListener(q, "zindex_changed", c)), q.setContent(N.current), n ? q.open(h, n) : q.getPosition() ? q.open(h) : Xr(!1, "You must provide either an anchor or a position prop for <InfoBox>."), p && p(q);
    }
    return () => {
      f !== null && (g && google.maps.event.removeListener(g), x && google.maps.event.removeListener(x), w && google.maps.event.removeListener(w), C && google.maps.event.removeListener(C), F && google.maps.event.removeListener(F), d && d(f), f.close());
    };
  }, []), N.current ? yr(at.only(t), N.current) : null;
}
Ee(YCe);
class JCe extends pe {
  constructor() {
    super(...arguments), xe(this, "registeredEvents", []), xe(this, "containerElement", null), xe(this, "state", {
      infoBox: null
    }), xe(this, "open", (t, n) => {
      n ? this.context !== null && t.open(this.context, n) : t.getPosition() ? this.context !== null && t.open(this.context) : Xr(!1, "You must provide either an anchor or a position prop for <InfoBox>.");
    }), xe(this, "setInfoBoxCallback", () => {
      this.state.infoBox !== null && this.containerElement !== null && (this.state.infoBox.setContent(this.containerElement), this.open(this.state.infoBox, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoBox));
    });
  }
  componentDidMount() {
    var t = this.props.options || {}, {
      position: n
    } = t, r = Vk(t, XCe), o;
    n && !(n instanceof google.maps.LatLng) && (o = new google.maps.LatLng(n.lat, n.lng));
    var i = new R6(tm(tm({}, r), o ? {
      position: o
    } : {}));
    this.containerElement = document.createElement("div"), this.registeredEvents = tn({
      updaterMap: cR,
      eventMap: uR,
      prevProps: {},
      nextProps: this.props,
      instance: i
    }), this.setState({
      infoBox: i
    }, this.setInfoBoxCallback);
  }
  componentDidUpdate(t) {
    var {
      infoBox: n
    } = this.state;
    n !== null && (ln(this.registeredEvents), this.registeredEvents = tn({
      updaterMap: cR,
      eventMap: uR,
      prevProps: t,
      nextProps: this.props,
      instance: n
    }));
  }
  componentWillUnmount() {
    var {
      onUnmount: t
    } = this.props, {
      infoBox: n
    } = this.state;
    n !== null && (t && t(n), ln(this.registeredEvents), n.close());
  }
  render() {
    return this.containerElement ? yr(at.only(this.props.children), this.containerElement) : null;
  }
}
xe(JCe, "contextType", Dt);
var pR, dR;
function QCe() {
  return dR || (dR = 1, pR = function e(t, n) {
    if (t === n) return !0;
    if (t && n && typeof t == "object" && typeof n == "object") {
      if (t.constructor !== n.constructor) return !1;
      var r, o, i;
      if (Array.isArray(t)) {
        if (r = t.length, r != n.length) return !1;
        for (o = r; o-- !== 0; ) if (!e(t[o], n[o])) return !1;
        return !0;
      }
      if (t.constructor === RegExp) return t.source === n.source && t.flags === n.flags;
      if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === n.valueOf();
      if (t.toString !== Object.prototype.toString) return t.toString() === n.toString();
      if (i = Object.keys(t), r = i.length, r !== Object.keys(n).length) return !1;
      for (o = r; o-- !== 0; ) if (!Object.prototype.hasOwnProperty.call(n, i[o])) return !1;
      for (o = r; o-- !== 0; ) {
        var a = i[o];
        if (!e(t[a], n[a])) return !1;
      }
      return !0;
    }
    return t !== t && n !== n;
  }), pR;
}
var exe = QCe(), fR = /* @__PURE__ */ M6(exe), hR = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array], W0 = 1, Qu = 8;
class qk {
  /**
   * Creates an index from raw `ArrayBuffer` data.
   * @param {ArrayBuffer} data
   */
  static from(t) {
    if (!(t instanceof ArrayBuffer))
      throw new Error("Data must be an instance of ArrayBuffer.");
    var [n, r] = new Uint8Array(t, 0, 2);
    if (n !== 219)
      throw new Error("Data does not appear to be in a KDBush format.");
    var o = r >> 4;
    if (o !== W0)
      throw new Error("Got v".concat(o, " data when expected v").concat(W0, "."));
    var i = hR[r & 15];
    if (!i)
      throw new Error("Unrecognized array type.");
    var [a] = new Uint16Array(t, 2, 1), [s] = new Uint32Array(t, 4, 1);
    return new qk(s, a, i, t);
  }
  /**
   * Creates an index that will hold a given number of items.
   * @param {number} numItems
   * @param {number} [nodeSize=64] Size of the KD-tree node (64 by default).
   * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).
   * @param {ArrayBuffer} [data] (For internal use only)
   */
  constructor(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 64, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Float64Array, o = arguments.length > 3 ? arguments[3] : void 0;
    if (isNaN(t) || t < 0) throw new Error("Unpexpected numItems value: ".concat(t, "."));
    this.numItems = +t, this.nodeSize = Math.min(Math.max(+n, 2), 65535), this.ArrayType = r, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
    var i = hR.indexOf(this.ArrayType), a = t * 2 * this.ArrayType.BYTES_PER_ELEMENT, s = t * this.IndexArrayType.BYTES_PER_ELEMENT, l = (8 - s % 8) % 8;
    if (i < 0)
      throw new Error("Unexpected typed array class: ".concat(r, "."));
    o && o instanceof ArrayBuffer ? (this.data = o, this.ids = new this.IndexArrayType(this.data, Qu, t), this.coords = new this.ArrayType(this.data, Qu + s + l, t * 2), this._pos = t * 2, this._finished = !0) : (this.data = new ArrayBuffer(Qu + a + s + l), this.ids = new this.IndexArrayType(this.data, Qu, t), this.coords = new this.ArrayType(this.data, Qu + s + l, t * 2), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, (W0 << 4) + i]), new Uint16Array(this.data, 2, 1)[0] = n, new Uint32Array(this.data, 4, 1)[0] = t);
  }
  /**
   * Add a point to the index.
   * @param {number} x
   * @param {number} y
   * @returns {number} An incremental index associated with the added item (starting from `0`).
   */
  add(t, n) {
    var r = this._pos >> 1;
    return this.ids[r] = r, this.coords[this._pos++] = t, this.coords[this._pos++] = n, r;
  }
  /**
   * Perform indexing of the added points.
   */
  finish() {
    var t = this._pos >> 1;
    if (t !== this.numItems)
      throw new Error("Added ".concat(t, " items when expected ").concat(this.numItems, "."));
    return Cx(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
  }
  /**
   * Search the index for items within a given bounding box.
   * @param {number} minX
   * @param {number} minY
   * @param {number} maxX
   * @param {number} maxY
   * @returns {number[]} An array of indices correponding to the found items.
   */
  range(t, n, r, o) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: i,
      coords: a,
      nodeSize: s
    } = this, l = [0, i.length - 1, 0], u = []; l.length; ) {
      var c = l.pop() || 0, p = l.pop() || 0, d = l.pop() || 0;
      if (p - d <= s) {
        for (var h = d; h <= p; h++) {
          var f = a[2 * h], m = a[2 * h + 1];
          f >= t && f <= r && m >= n && m <= o && u.push(i[h]);
        }
        continue;
      }
      var g = d + p >> 1, E = a[2 * g], w = a[2 * g + 1];
      E >= t && E <= r && w >= n && w <= o && u.push(i[g]), (c === 0 ? t <= E : n <= w) && (l.push(d), l.push(g - 1), l.push(1 - c)), (c === 0 ? r >= E : o >= w) && (l.push(g + 1), l.push(p), l.push(1 - c));
    }
    return u;
  }
  /**
   * Search the index for items within a given radius.
   * @param {number} qx
   * @param {number} qy
   * @param {number} r Query radius.
   * @returns {number[]} An array of indices correponding to the found items.
   */
  within(t, n, r) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: o,
      coords: i,
      nodeSize: a
    } = this, s = [0, o.length - 1, 0], l = [], u = r * r; s.length; ) {
      var c = s.pop() || 0, p = s.pop() || 0, d = s.pop() || 0;
      if (p - d <= a) {
        for (var h = d; h <= p; h++)
          gR(i[2 * h], i[2 * h + 1], t, n) <= u && l.push(o[h]);
        continue;
      }
      var f = d + p >> 1, m = i[2 * f], g = i[2 * f + 1];
      gR(m, g, t, n) <= u && l.push(o[f]), (c === 0 ? t - r <= m : n - r <= g) && (s.push(d), s.push(f - 1), s.push(1 - c)), (c === 0 ? t + r >= m : n + r >= g) && (s.push(f + 1), s.push(p), s.push(1 - c));
    }
    return l;
  }
}
function Cx(e, t, n, r, o, i) {
  if (!(o - r <= n)) {
    var a = r + o >> 1;
    N6(e, t, a, r, o, i), Cx(e, t, n, r, a - 1, 1 - i), Cx(e, t, n, a + 1, o, 1 - i);
  }
}
function N6(e, t, n, r, o, i) {
  for (; o > r; ) {
    if (o - r > 600) {
      var a = o - r + 1, s = n - r + 1, l = Math.log(a), u = 0.5 * Math.exp(2 * l / 3), c = 0.5 * Math.sqrt(l * u * (a - u) / a) * (s - a / 2 < 0 ? -1 : 1), p = Math.max(r, Math.floor(n - s * u / a + c)), d = Math.min(o, Math.floor(n + (a - s) * u / a + c));
      N6(e, t, n, p, d, i);
    }
    var h = t[2 * n + i], f = r, m = o;
    for (ec(e, t, r, n), t[2 * o + i] > h && ec(e, t, r, o); f < m; ) {
      for (ec(e, t, f, m), f++, m--; t[2 * f + i] < h; ) f++;
      for (; t[2 * m + i] > h; ) m--;
    }
    t[2 * r + i] === h ? ec(e, t, r, m) : (m++, ec(e, t, m, o)), m <= n && (r = m + 1), n <= m && (o = m - 1);
  }
}
function ec(e, t, n, r) {
  V0(e, n, r), V0(t, 2 * n, 2 * r), V0(t, 2 * n + 1, 2 * r + 1);
}
function V0(e, t, n) {
  var r = e[t];
  e[t] = e[n], e[n] = r;
}
function gR(e, t, n, r) {
  var o = e - n, i = t - r;
  return o * o + i * i;
}
var txe = {
  minZoom: 0,
  // min zoom to generate clusters on
  maxZoom: 16,
  // max zoom level to cluster the points on
  minPoints: 2,
  // minimum points to form a cluster
  radius: 40,
  // cluster radius in pixels
  extent: 512,
  // tile extent (radius is calculated relative to it)
  nodeSize: 64,
  // size of the KD-tree leaf node, affects performance
  log: !1,
  // whether to log timing info
  // whether to generate numeric ids for input features (in vector tiles)
  generateId: !1,
  // a reduce function for calculating custom cluster properties
  reduce: null,
  // (accumulated, props) => { accumulated.sum += props.sum; }
  // properties to use for individual points when running the reducer
  map: (e) => e
  // props => ({sum: props.my_value})
}, mR = Math.fround || /* @__PURE__ */ ((e) => (t) => (e[0] = +t, e[0]))(new Float32Array(1)), Ua = 2, ea = 3, q0 = 4, Gs = 5, F6 = 6;
class nxe {
  constructor(t) {
    this.options = Object.assign(Object.create(txe), t), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
  }
  load(t) {
    var {
      log: n,
      minZoom: r,
      maxZoom: o
    } = this.options;
    n && console.time("total time");
    var i = "prepare ".concat(t.length, " points");
    n && console.time(i), this.points = t;
    for (var a = [], s = 0; s < t.length; s++) {
      var l = t[s];
      if (l.geometry) {
        var [u, c] = l.geometry.coordinates, p = mR(Kf(u)), d = mR(Yf(c));
        a.push(
          p,
          d,
          // projected point coordinates
          1 / 0,
          // the last zoom the point was processed at
          s,
          // index of the source feature in the original input array
          -1,
          // parent cluster id
          1
          // number of points in a cluster
        ), this.options.reduce && a.push(0);
      }
    }
    var h = this.trees[o + 1] = this._createTree(a);
    n && console.timeEnd(i);
    for (var f = o; f >= r; f--) {
      var m = +Date.now();
      h = this.trees[f] = this._createTree(this._cluster(h, f)), n && console.log("z%d: %d clusters in %dms", f, h.numItems, +Date.now() - m);
    }
    return n && console.timeEnd("total time"), this;
  }
  getClusters(t, n) {
    var r = ((t[0] + 180) % 360 + 360) % 360 - 180, o = Math.max(-90, Math.min(90, t[1])), i = t[2] === 180 ? 180 : ((t[2] + 180) % 360 + 360) % 360 - 180, a = Math.max(-90, Math.min(90, t[3]));
    if (t[2] - t[0] >= 360)
      r = -180, i = 180;
    else if (r > i) {
      var s = this.getClusters([r, o, 180, a], n), l = this.getClusters([-180, o, i, a], n);
      return s.concat(l);
    }
    var u = this.trees[this._limitZoom(n)], c = u.range(Kf(r), Yf(a), Kf(i), Yf(o)), p = u.data, d = [];
    for (var h of c) {
      var f = this.stride * h;
      d.push(p[f + Gs] > 1 ? vR(p, f, this.clusterProps) : this.points[p[f + ea]]);
    }
    return d;
  }
  getChildren(t) {
    var n = this._getOriginId(t), r = this._getOriginZoom(t), o = "No cluster with the specified id.", i = this.trees[r];
    if (!i) throw new Error(o);
    var a = i.data;
    if (n * this.stride >= a.length) throw new Error(o);
    var s = this.options.radius / (this.options.extent * Math.pow(2, r - 1)), l = a[n * this.stride], u = a[n * this.stride + 1], c = i.within(l, u, s), p = [];
    for (var d of c) {
      var h = d * this.stride;
      a[h + q0] === t && p.push(a[h + Gs] > 1 ? vR(a, h, this.clusterProps) : this.points[a[h + ea]]);
    }
    if (p.length === 0) throw new Error(o);
    return p;
  }
  getLeaves(t, n, r) {
    n = n || 10, r = r || 0;
    var o = [];
    return this._appendLeaves(o, t, n, r, 0), o;
  }
  getTile(t, n, r) {
    var o = this.trees[this._limitZoom(t)], i = Math.pow(2, t), {
      extent: a,
      radius: s
    } = this.options, l = s / a, u = (r - l) / i, c = (r + 1 + l) / i, p = {
      features: []
    };
    return this._addTileFeatures(o.range((n - l) / i, u, (n + 1 + l) / i, c), o.data, n, r, i, p), n === 0 && this._addTileFeatures(o.range(1 - l / i, u, 1, c), o.data, i, r, i, p), n === i - 1 && this._addTileFeatures(o.range(0, u, l / i, c), o.data, -1, r, i, p), p.features.length ? p : null;
  }
  getClusterExpansionZoom(t) {
    for (var n = this._getOriginZoom(t) - 1; n <= this.options.maxZoom; ) {
      var r = this.getChildren(t);
      if (n++, r.length !== 1) break;
      t = r[0].properties.cluster_id;
    }
    return n;
  }
  _appendLeaves(t, n, r, o, i) {
    var a = this.getChildren(n);
    for (var s of a) {
      var l = s.properties;
      if (l && l.cluster ? i + l.point_count <= o ? i += l.point_count : i = this._appendLeaves(t, l.cluster_id, r, o, i) : i < o ? i++ : t.push(s), t.length === r) break;
    }
    return i;
  }
  _createTree(t) {
    for (var n = new qk(t.length / this.stride | 0, this.options.nodeSize, Float32Array), r = 0; r < t.length; r += this.stride) n.add(t[r], t[r + 1]);
    return n.finish(), n.data = t, n;
  }
  _addTileFeatures(t, n, r, o, i, a) {
    for (var s of t) {
      var l = s * this.stride, u = n[l + Gs] > 1, c = void 0, p = void 0, d = void 0;
      if (u)
        c = z6(n, l, this.clusterProps), p = n[l], d = n[l + 1];
      else {
        var h = this.points[n[l + ea]];
        c = h.properties;
        var [f, m] = h.geometry.coordinates;
        p = Kf(f), d = Yf(m);
      }
      var g = {
        type: 1,
        geometry: [[Math.round(this.options.extent * (p * i - r)), Math.round(this.options.extent * (d * i - o))]],
        tags: c
      }, E = void 0;
      u || this.options.generateId ? E = n[l + ea] : E = this.points[n[l + ea]].id, E !== void 0 && (g.id = E), a.features.push(g);
    }
  }
  _limitZoom(t) {
    return Math.max(this.options.minZoom, Math.min(Math.floor(+t), this.options.maxZoom + 1));
  }
  _cluster(t, n) {
    for (var {
      radius: r,
      extent: o,
      reduce: i,
      minPoints: a
    } = this.options, s = r / (o * Math.pow(2, n)), l = t.data, u = [], c = this.stride, p = 0; p < l.length; p += c)
      if (!(l[p + Ua] <= n)) {
        l[p + Ua] = n;
        var d = l[p], h = l[p + 1], f = t.within(l[p], l[p + 1], s), m = l[p + Gs], g = m;
        for (var E of f) {
          var w = E * c;
          l[w + Ua] > n && (g += l[w + Gs]);
        }
        if (g > m && g >= a) {
          var M = d * m, x = h * m, y = void 0, C = -1, P = ((p / c | 0) << 5) + (n + 1) + this.points.length;
          for (var F of f) {
            var L = F * c;
            if (!(l[L + Ua] <= n)) {
              l[L + Ua] = n;
              var N = l[L + Gs];
              M += l[L] * N, x += l[L + 1] * N, l[L + q0] = P, i && (y || (y = this._map(l, p, !0), C = this.clusterProps.length, this.clusterProps.push(y)), i(y, this._map(l, L)));
            }
          }
          l[p + q0] = P, u.push(M / g, x / g, 1 / 0, P, -1, g), i && u.push(C);
        } else {
          for (var I = 0; I < c; I++) u.push(l[p + I]);
          if (g > 1)
            for (var H of f) {
              var V = H * c;
              if (!(l[V + Ua] <= n)) {
                l[V + Ua] = n;
                for (var z = 0; z < c; z++) u.push(l[V + z]);
              }
            }
        }
      }
    return u;
  }
  // get index of the point from which the cluster originated
  _getOriginId(t) {
    return t - this.points.length >> 5;
  }
  // get zoom of the point from which the cluster originated
  _getOriginZoom(t) {
    return (t - this.points.length) % 32;
  }
  _map(t, n, r) {
    if (t[n + Gs] > 1) {
      var o = this.clusterProps[t[n + F6]];
      return r ? Object.assign({}, o) : o;
    }
    var i = this.points[t[n + ea]].properties, a = this.options.map(i);
    return r && a === i ? Object.assign({}, a) : a;
  }
}
function vR(e, t, n) {
  return {
    type: "Feature",
    id: e[t + ea],
    properties: z6(e, t, n),
    geometry: {
      type: "Point",
      coordinates: [rxe(e[t]), oxe(e[t + 1])]
    }
  };
}
function z6(e, t, n) {
  var r = e[t + Gs], o = r >= 1e4 ? "".concat(Math.round(r / 1e3), "k") : r >= 1e3 ? "".concat(Math.round(r / 100) / 10, "k") : r, i = e[t + F6], a = i === -1 ? {} : Object.assign({}, n[i]);
  return Object.assign(a, {
    cluster: !0,
    cluster_id: e[t + ea],
    point_count: r,
    point_count_abbreviated: o
  });
}
function Kf(e) {
  return e / 360 + 0.5;
}
function Yf(e) {
  var t = Math.sin(e * Math.PI / 180), n = 0.5 - 0.25 * Math.log((1 + t) / (1 - t)) / Math.PI;
  return n < 0 ? 0 : n > 1 ? 1 : n;
}
function rxe(e) {
  return (e - 0.5) * 360;
}
function oxe(e) {
  var t = (180 - e * 360) * Math.PI / 180;
  return 360 * Math.atan(Math.exp(t)) / Math.PI - 90;
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function ixe(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
    t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
  return n;
}
class Ko {
  static isAdvancedMarkerAvailable(t) {
    return google.maps.marker && t.getMapCapabilities().isAdvancedMarkersAvailable === !0;
  }
  static isAdvancedMarker(t) {
    return google.maps.marker && t instanceof google.maps.marker.AdvancedMarkerElement;
  }
  static setMap(t, n) {
    this.isAdvancedMarker(t) ? t.map = n : t.setMap(n);
  }
  static getPosition(t) {
    if (this.isAdvancedMarker(t)) {
      if (t.position) {
        if (t.position instanceof google.maps.LatLng)
          return t.position;
        if (t.position.lat && t.position.lng)
          return new google.maps.LatLng(t.position.lat, t.position.lng);
      }
      return new google.maps.LatLng(null);
    }
    return t.getPosition();
  }
  static getVisible(t) {
    return this.isAdvancedMarker(t) ? !0 : t.getVisible();
  }
}
class xx {
  constructor(t) {
    var {
      markers: n,
      position: r
    } = t;
    this.markers = n, r && (r instanceof google.maps.LatLng ? this._position = r : this._position = new google.maps.LatLng(r));
  }
  get bounds() {
    if (!(this.markers.length === 0 && !this._position)) {
      var t = new google.maps.LatLngBounds(this._position, this._position);
      for (var n of this.markers)
        t.extend(Ko.getPosition(n));
      return t;
    }
  }
  get position() {
    return this._position || this.bounds.getCenter();
  }
  /**
   * Get the count of **visible** markers.
   */
  get count() {
    return this.markers.filter((t) => Ko.getVisible(t)).length;
  }
  /**
   * Add a marker to the cluster.
   */
  push(t) {
    this.markers.push(t);
  }
  /**
   * Cleanup references and remove marker from map.
   */
  delete() {
    this.marker && (Ko.setMap(this.marker, null), this.marker = void 0), this.markers.length = 0;
  }
}
class sxe {
  constructor(t) {
    var {
      maxZoom: n = 16
    } = t;
    this.maxZoom = n;
  }
  /**
   * Helper function to bypass clustering based upon some map state such as
   * zoom, number of markers, etc.
   *
   * ```typescript
   *  cluster({markers, map}: AlgorithmInput): Cluster[] {
   *    if (shouldBypassClustering(map)) {
   *      return this.noop({markers})
   *    }
   * }
   * ```
   */
  noop(t) {
    var {
      markers: n
    } = t;
    return axe(n);
  }
}
var axe = (e) => {
  var t = e.map((n) => new xx({
    position: Ko.getPosition(n),
    markers: [n]
  }));
  return t;
};
class lxe extends sxe {
  constructor(t) {
    var {
      maxZoom: n,
      radius: r = 60
    } = t, o = ixe(t, ["maxZoom", "radius"]);
    super({
      maxZoom: n
    }), this.state = {
      zoom: -1
    }, this.superCluster = new nxe(Object.assign({
      maxZoom: this.maxZoom,
      radius: r
    }, o));
  }
  calculate(t) {
    var n = !1, r = {
      zoom: t.map.getZoom()
    };
    if (!fR(t.markers, this.markers)) {
      n = !0, this.markers = [...t.markers];
      var o = this.markers.map((i) => {
        var a = Ko.getPosition(i), s = [a.lng(), a.lat()];
        return {
          type: "Feature",
          geometry: {
            type: "Point",
            coordinates: s
          },
          properties: {
            marker: i
          }
        };
      });
      this.superCluster.load(o);
    }
    return n || (this.state.zoom <= this.maxZoom || r.zoom <= this.maxZoom) && (n = !fR(this.state, r)), this.state = r, n && (this.clusters = this.cluster(t)), {
      clusters: this.clusters,
      changed: n
    };
  }
  cluster(t) {
    var {
      map: n
    } = t;
    return this.superCluster.getClusters([-180, -90, 180, 90], Math.round(n.getZoom())).map((r) => this.transformCluster(r));
  }
  transformCluster(t) {
    var {
      geometry: {
        coordinates: [n, r]
      },
      properties: o
    } = t;
    if (o.cluster)
      return new xx({
        markers: this.superCluster.getLeaves(o.cluster_id, 1 / 0).map((a) => a.properties.marker),
        position: {
          lat: r,
          lng: n
        }
      });
    var i = o.marker;
    return new xx({
      markers: [i],
      position: Ko.getPosition(i)
    });
  }
}
class uxe {
  constructor(t, n) {
    this.markers = {
      sum: t.length
    };
    var r = n.map((i) => i.count), o = r.reduce((i, a) => i + a, 0);
    this.clusters = {
      count: n.length,
      markers: {
        mean: o / n.length,
        sum: o,
        min: Math.min(...r),
        max: Math.max(...r)
      }
    };
  }
}
class cxe {
  /**
   * The default render function for the library used by {@link MarkerClusterer}.
   *
   * Currently set to use the following:
   *
   * ```typescript
   * // change color if this cluster has more markers than the mean cluster
   * const color =
   *   count > Math.max(10, stats.clusters.markers.mean)
   *     ? "#ff0000"
   *     : "#0000ff";
   *
   * // create svg url with fill color
   * const svg = window.btoa(`
   * <svg fill="${color}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240">
   *   <circle cx="120" cy="120" opacity=".6" r="70" />
   *   <circle cx="120" cy="120" opacity=".3" r="90" />
   *   <circle cx="120" cy="120" opacity=".2" r="110" />
   *   <circle cx="120" cy="120" opacity=".1" r="130" />
   * </svg>`);
   *
   * // create marker using svg icon
   * return new google.maps.Marker({
   *   position,
   *   icon: {
   *     url: `data:image/svg+xml;base64,${svg}`,
   *     scaledSize: new google.maps.Size(45, 45),
   *   },
   *   label: {
   *     text: String(count),
   *     color: "rgba(255,255,255,0.9)",
   *     fontSize: "12px",
   *   },
   *   // adjust zIndex to be above other markers
   *   zIndex: 1000 + count,
   * });
   * ```
   */
  render(t, n, r) {
    var {
      count: o,
      position: i
    } = t, a = o > Math.max(10, n.clusters.markers.mean) ? "#ff0000" : "#0000ff", s = '<svg fill="'.concat(a, `" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" width="50" height="50">
<circle cx="120" cy="120" opacity=".6" r="70" />
<circle cx="120" cy="120" opacity=".3" r="90" />
<circle cx="120" cy="120" opacity=".2" r="110" />
<text x="50%" y="50%" style="fill:#fff" text-anchor="middle" font-size="50" dominant-baseline="middle" font-family="roboto,arial,sans-serif">`).concat(o, `</text>
</svg>`), l = "Cluster of ".concat(o, " markers"), u = Number(google.maps.Marker.MAX_ZINDEX) + o;
    if (Ko.isAdvancedMarkerAvailable(r)) {
      var c = new DOMParser(), p = c.parseFromString(s, "image/svg+xml").documentElement;
      p.setAttribute("transform", "translate(0 25)");
      var d = {
        map: r,
        position: i,
        zIndex: u,
        title: l,
        content: p
      };
      return new google.maps.marker.AdvancedMarkerElement(d);
    }
    var h = {
      position: i,
      zIndex: u,
      title: l,
      icon: {
        url: "data:image/svg+xml;base64,".concat(btoa(s)),
        anchor: new google.maps.Point(25, 25)
      }
    };
    return new google.maps.Marker(h);
  }
}
function pxe(e, t) {
  for (var n in t.prototype)
    e.prototype[n] = t.prototype[n];
}
class Zk {
  constructor() {
    pxe(Zk, google.maps.OverlayView);
  }
}
var zc;
(function(e) {
  e.CLUSTERING_BEGIN = "clusteringbegin", e.CLUSTERING_END = "clusteringend", e.CLUSTER_CLICK = "click";
})(zc || (zc = {}));
var dxe = (e, t, n) => {
  n.fitBounds(t.bounds);
};
class fxe extends Zk {
  constructor(t) {
    var {
      map: n,
      markers: r = [],
      algorithmOptions: o = {},
      algorithm: i = new lxe(o),
      renderer: a = new cxe(),
      onClusterClick: s = dxe
    } = t;
    super(), this.markers = [...r], this.clusters = [], this.algorithm = i, this.renderer = a, this.onClusterClick = s, n && this.setMap(n);
  }
  addMarker(t, n) {
    this.markers.includes(t) || (this.markers.push(t), n || this.render());
  }
  addMarkers(t, n) {
    t.forEach((r) => {
      this.addMarker(r, !0);
    }), n || this.render();
  }
  removeMarker(t, n) {
    var r = this.markers.indexOf(t);
    return r === -1 ? !1 : (Ko.setMap(t, null), this.markers.splice(r, 1), n || this.render(), !0);
  }
  removeMarkers(t, n) {
    var r = !1;
    return t.forEach((o) => {
      r = this.removeMarker(o, !0) || r;
    }), r && !n && this.render(), r;
  }
  clearMarkers(t) {
    this.markers.length = 0, t || this.render();
  }
  /**
   * Recalculates and draws all the marker clusters.
   */
  render() {
    var t = this.getMap();
    if (t instanceof google.maps.Map && t.getProjection()) {
      google.maps.event.trigger(this, zc.CLUSTERING_BEGIN, this);
      var {
        clusters: n,
        changed: r
      } = this.algorithm.calculate({
        markers: this.markers,
        map: t,
        mapCanvasProjection: this.getProjection()
      });
      if (r || r == null) {
        var o = /* @__PURE__ */ new Set();
        for (var i of n)
          i.markers.length == 1 && o.add(i.markers[0]);
        var a = [];
        for (var s of this.clusters)
          s.marker != null && (s.markers.length == 1 ? o.has(s.marker) || Ko.setMap(s.marker, null) : a.push(s.marker));
        this.clusters = n, this.renderClusters(), requestAnimationFrame(() => a.forEach((l) => Ko.setMap(l, null)));
      }
      google.maps.event.trigger(this, zc.CLUSTERING_END, this);
    }
  }
  onAdd() {
    this.idleListener = this.getMap().addListener("idle", this.render.bind(this)), this.render();
  }
  onRemove() {
    google.maps.event.removeListener(this.idleListener), this.reset();
  }
  reset() {
    this.markers.forEach((t) => Ko.setMap(t, null)), this.clusters.forEach((t) => t.delete()), this.clusters = [];
  }
  renderClusters() {
    var t = new uxe(this.markers, this.clusters), n = this.getMap();
    this.clusters.forEach((r) => {
      r.markers.length === 1 ? r.marker = r.markers[0] : (r.marker = this.renderer.render(r, t, n), r.markers.forEach((o) => Ko.setMap(o, null)), this.onClusterClick && r.marker.addListener(
        "click",
        /* istanbul ignore next */
        (o) => {
          google.maps.event.trigger(this, zc.CLUSTER_CLICK, r), this.onClusterClick(o, r, n);
        }
      )), Ko.setMap(r.marker, n);
    });
  }
}
function yR(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function bR(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? yR(Object(n), !0).forEach(function(r) {
      xe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : yR(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function hxe(e) {
  var t = dCe(), [n, r] = k(null);
  return v(() => {
    if (t && n === null) {
      var o = new fxe(bR(bR({}, e), {}, {
        map: t
      }));
      r(o);
    }
  }, [t]), n;
}
function gxe(e) {
  var {
    children: t,
    options: n
  } = e, r = hxe(n);
  return r !== null ? t(r) : null;
}
Ee(gxe);
var wR = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, CR = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
function mxe(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, h = ye(Dt), [f, m] = k(null), [g, E] = k(null), [w, M] = k(null), [x, y] = k(null), [C, P] = k(null), [F, L] = k(null), N = rt(null);
  return v(() => {
    f !== null && (f.close(), n ? f.open(h, n) : f.getPosition() && f.open(h));
  }, [h, f, n]), v(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), v(() => {
    o && f !== null && f.setPosition(o);
  }, [o]), v(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), v(() => {
    f && a && (g !== null && google.maps.event.removeListener(g), E(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), v(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), M(google.maps.event.addListener(f, "domready", s)));
  }, [s]), v(() => {
    f && l && (x !== null && google.maps.event.removeListener(x), y(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), v(() => {
    f && u && (C !== null && google.maps.event.removeListener(C), P(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), v(() => {
    f && c && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), v(() => {
    var I = new google.maps.InfoWindow(r);
    return m(I), N.current = document.createElement("div"), a && E(google.maps.event.addListener(I, "closeclick", a)), s && M(google.maps.event.addListener(I, "domready", s)), l && y(google.maps.event.addListener(I, "content_changed", l)), u && P(google.maps.event.addListener(I, "position_changed", u)), c && L(google.maps.event.addListener(I, "zindex_changed", c)), I.setContent(N.current), o && I.setPosition(o), i && I.setZIndex(i), n ? I.open(h, n) : I.getPosition() ? I.open(h) : Xr(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>."), p && p(I), () => {
      g && google.maps.event.removeListener(g), x && google.maps.event.removeListener(x), w && google.maps.event.removeListener(w), C && google.maps.event.removeListener(C), F && google.maps.event.removeListener(F), d && d(I), I.close();
    };
  }, []), N.current ? yr(at.only(t), N.current) : null;
}
Ee(mxe);
class vxe extends pe {
  constructor() {
    super(...arguments), xe(this, "registeredEvents", []), xe(this, "containerElement", null), xe(this, "state", {
      infoWindow: null
    }), xe(this, "open", (t, n) => {
      n ? t.open(this.context, n) : t.getPosition() ? t.open(this.context) : Xr(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>.");
    }), xe(this, "setInfoWindowCallback", () => {
      this.state.infoWindow !== null && this.containerElement !== null && (this.state.infoWindow.setContent(this.containerElement), this.open(this.state.infoWindow, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoWindow));
    });
  }
  componentDidMount() {
    var t = new google.maps.InfoWindow(this.props.options);
    this.containerElement = document.createElement("div"), this.registeredEvents = tn({
      updaterMap: CR,
      eventMap: wR,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(() => ({
      infoWindow: t
    }), this.setInfoWindowCallback);
  }
  componentDidUpdate(t) {
    this.state.infoWindow !== null && (ln(this.registeredEvents), this.registeredEvents = tn({
      updaterMap: CR,
      eventMap: wR,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.infoWindow
    }));
  }
  componentWillUnmount() {
    this.state.infoWindow !== null && (ln(this.registeredEvents), this.props.onUnmount && this.props.onUnmount(this.state.infoWindow), this.state.infoWindow.close());
  }
  render() {
    return this.containerElement ? yr(at.only(this.props.children), this.containerElement) : null;
  }
}
xe(vxe, "contextType", Dt);
function xR(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function nm(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? xR(Object(n), !0).forEach(function(r) {
      xe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : xR(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var OR = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, ER = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, yxe = {};
function bxe(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: h,
    onRightClick: f,
    onClick: m,
    onDrag: g,
    onLoad: E,
    onUnmount: w
  } = e, M = ye(Dt), [x, y] = k(null), [C, P] = k(null), [F, L] = k(null), [N, I] = k(null), [H, V] = k(null), [z, q] = k(null), [K, J] = k(null), [te, ee] = k(null), [_, D] = k(null), [$, S] = k(null), [W, O] = k(null), [T, U] = k(null);
  return v(() => {
    x !== null && x.setMap(M);
  }, [M]), v(() => {
    typeof t < "u" && x !== null && x.setOptions(t);
  }, [x, t]), v(() => {
    typeof n < "u" && x !== null && x.setDraggable(n);
  }, [x, n]), v(() => {
    typeof r < "u" && x !== null && x.setEditable(r);
  }, [x, r]), v(() => {
    typeof o < "u" && x !== null && x.setVisible(o);
  }, [x, o]), v(() => {
    typeof i < "u" && x !== null && x.setPath(i);
  }, [x, i]), v(() => {
    x && a && (C !== null && google.maps.event.removeListener(C), P(google.maps.event.addListener(x, "dblclick", a)));
  }, [a]), v(() => {
    x && s && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(x, "dragend", s)));
  }, [s]), v(() => {
    x && l && (N !== null && google.maps.event.removeListener(N), I(google.maps.event.addListener(x, "dragstart", l)));
  }, [l]), v(() => {
    x && u && (H !== null && google.maps.event.removeListener(H), V(google.maps.event.addListener(x, "mousedown", u)));
  }, [u]), v(() => {
    x && c && (z !== null && google.maps.event.removeListener(z), q(google.maps.event.addListener(x, "mousemove", c)));
  }, [c]), v(() => {
    x && p && (K !== null && google.maps.event.removeListener(K), J(google.maps.event.addListener(x, "mouseout", p)));
  }, [p]), v(() => {
    x && d && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(x, "mouseover", d)));
  }, [d]), v(() => {
    x && h && (_ !== null && google.maps.event.removeListener(_), D(google.maps.event.addListener(x, "mouseup", h)));
  }, [h]), v(() => {
    x && f && ($ !== null && google.maps.event.removeListener($), S(google.maps.event.addListener(x, "rightclick", f)));
  }, [f]), v(() => {
    x && m && (W !== null && google.maps.event.removeListener(W), O(google.maps.event.addListener(x, "click", m)));
  }, [m]), v(() => {
    x && g && (T !== null && google.maps.event.removeListener(T), U(google.maps.event.addListener(x, "drag", g)));
  }, [g]), v(() => {
    var j = new google.maps.Polyline(nm(nm({}, t || yxe), {}, {
      map: M
    }));
    return i && j.setPath(i), typeof o < "u" && j.setVisible(o), typeof r < "u" && j.setEditable(r), typeof n < "u" && j.setDraggable(n), a && P(google.maps.event.addListener(j, "dblclick", a)), s && L(google.maps.event.addListener(j, "dragend", s)), l && I(google.maps.event.addListener(j, "dragstart", l)), u && V(google.maps.event.addListener(j, "mousedown", u)), c && q(google.maps.event.addListener(j, "mousemove", c)), p && J(google.maps.event.addListener(j, "mouseout", p)), d && ee(google.maps.event.addListener(j, "mouseover", d)), h && D(google.maps.event.addListener(j, "mouseup", h)), f && S(google.maps.event.addListener(j, "rightclick", f)), m && O(google.maps.event.addListener(j, "click", m)), g && U(google.maps.event.addListener(j, "drag", g)), y(j), E && E(j), () => {
      C !== null && google.maps.event.removeListener(C), F !== null && google.maps.event.removeListener(F), N !== null && google.maps.event.removeListener(N), H !== null && google.maps.event.removeListener(H), z !== null && google.maps.event.removeListener(z), K !== null && google.maps.event.removeListener(K), te !== null && google.maps.event.removeListener(te), _ !== null && google.maps.event.removeListener(_), $ !== null && google.maps.event.removeListener($), W !== null && google.maps.event.removeListener(W), w && w(j), j.setMap(null);
    };
  }, []), null;
}
Ee(bxe);
class wxe extends pe {
  constructor() {
    super(...arguments), xe(this, "registeredEvents", []), xe(this, "state", {
      polyline: null
    }), xe(this, "setPolylineCallback", () => {
      this.state.polyline !== null && this.props.onLoad && this.props.onLoad(this.state.polyline);
    });
  }
  componentDidMount() {
    var t = new google.maps.Polyline(nm(nm({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = tn({
      updaterMap: ER,
      eventMap: OR,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        polyline: t
      };
    }, this.setPolylineCallback);
  }
  componentDidUpdate(t) {
    this.state.polyline !== null && (ln(this.registeredEvents), this.registeredEvents = tn({
      updaterMap: ER,
      eventMap: OR,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.polyline
    }));
  }
  componentWillUnmount() {
    this.state.polyline !== null && (this.props.onUnmount && this.props.onUnmount(this.state.polyline), ln(this.registeredEvents), this.state.polyline.setMap(null));
  }
  render() {
    return null;
  }
}
xe(wxe, "contextType", Dt);
function kR(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function LR(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? kR(Object(n), !0).forEach(function(r) {
      xe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : kR(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var _R = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, PR = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  paths(e, t) {
    e.setPaths(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function Cxe(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    paths: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: h,
    onMouseUp: f,
    onRightClick: m,
    onClick: g,
    onDrag: E,
    onLoad: w,
    onUnmount: M,
    onEdit: x
  } = e, y = ye(Dt), [C, P] = k(null), [F, L] = k(null), [N, I] = k(null), [H, V] = k(null), [z, q] = k(null), [K, J] = k(null), [te, ee] = k(null), [_, D] = k(null), [$, S] = k(null), [W, O] = k(null), [T, U] = k(null), [j, Z] = k(null);
  return v(() => {
    C !== null && C.setMap(y);
  }, [y]), v(() => {
    typeof t < "u" && C !== null && C.setOptions(t);
  }, [C, t]), v(() => {
    typeof n < "u" && C !== null && C.setDraggable(n);
  }, [C, n]), v(() => {
    typeof r < "u" && C !== null && C.setEditable(r);
  }, [C, r]), v(() => {
    typeof o < "u" && C !== null && C.setVisible(o);
  }, [C, o]), v(() => {
    typeof i < "u" && C !== null && C.setPath(i);
  }, [C, i]), v(() => {
    typeof a < "u" && C !== null && C.setPaths(a);
  }, [C, a]), v(() => {
    C && typeof s == "function" && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(C, "dblclick", s)));
  }, [s]), v(() => {
    C && (google.maps.event.addListener(C.getPath(), "insert_at", () => {
      x == null || x(C);
    }), google.maps.event.addListener(C.getPath(), "set_at", () => {
      x == null || x(C);
    }), google.maps.event.addListener(C.getPath(), "remove_at", () => {
      x == null || x(C);
    }));
  }, [C, x]), v(() => {
    C && typeof l == "function" && (N !== null && google.maps.event.removeListener(N), I(google.maps.event.addListener(C, "dragend", l)));
  }, [l]), v(() => {
    C && typeof u == "function" && (H !== null && google.maps.event.removeListener(H), V(google.maps.event.addListener(C, "dragstart", u)));
  }, [u]), v(() => {
    C && typeof c == "function" && (z !== null && google.maps.event.removeListener(z), q(google.maps.event.addListener(C, "mousedown", c)));
  }, [c]), v(() => {
    C && typeof p == "function" && (K !== null && google.maps.event.removeListener(K), J(google.maps.event.addListener(C, "mousemove", p)));
  }, [p]), v(() => {
    C && typeof d == "function" && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(C, "mouseout", d)));
  }, [d]), v(() => {
    C && typeof h == "function" && (_ !== null && google.maps.event.removeListener(_), D(google.maps.event.addListener(C, "mouseover", h)));
  }, [h]), v(() => {
    C && typeof f == "function" && ($ !== null && google.maps.event.removeListener($), S(google.maps.event.addListener(C, "mouseup", f)));
  }, [f]), v(() => {
    C && typeof m == "function" && (W !== null && google.maps.event.removeListener(W), O(google.maps.event.addListener(C, "rightclick", m)));
  }, [m]), v(() => {
    C && typeof g == "function" && (T !== null && google.maps.event.removeListener(T), U(google.maps.event.addListener(C, "click", g)));
  }, [g]), v(() => {
    C && typeof E == "function" && (j !== null && google.maps.event.removeListener(j), Z(google.maps.event.addListener(C, "drag", E)));
  }, [E]), v(() => {
    var A = new google.maps.Polygon(LR(LR({}, t), {}, {
      map: y
    }));
    return i && A.setPath(i), a && A.setPaths(a), typeof o < "u" && A.setVisible(o), typeof r < "u" && A.setEditable(r), typeof n < "u" && A.setDraggable(n), s && L(google.maps.event.addListener(A, "dblclick", s)), l && I(google.maps.event.addListener(A, "dragend", l)), u && V(google.maps.event.addListener(A, "dragstart", u)), c && q(google.maps.event.addListener(A, "mousedown", c)), p && J(google.maps.event.addListener(A, "mousemove", p)), d && ee(google.maps.event.addListener(A, "mouseout", d)), h && D(google.maps.event.addListener(A, "mouseover", h)), f && S(google.maps.event.addListener(A, "mouseup", f)), m && O(google.maps.event.addListener(A, "rightclick", m)), g && U(google.maps.event.addListener(A, "click", g)), E && Z(google.maps.event.addListener(A, "drag", E)), P(A), w && w(A), () => {
      F !== null && google.maps.event.removeListener(F), N !== null && google.maps.event.removeListener(N), H !== null && google.maps.event.removeListener(H), z !== null && google.maps.event.removeListener(z), K !== null && google.maps.event.removeListener(K), te !== null && google.maps.event.removeListener(te), _ !== null && google.maps.event.removeListener(_), $ !== null && google.maps.event.removeListener($), W !== null && google.maps.event.removeListener(W), T !== null && google.maps.event.removeListener(T), M && M(A), A.setMap(null);
    };
  }, []), null;
}
Ee(Cxe);
class xxe extends pe {
  constructor() {
    super(...arguments), xe(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this.props.options || {};
    this.polygon = new google.maps.Polygon(t), this.polygon.setMap(this.context), this.registeredEvents = tn({
      updaterMap: PR,
      eventMap: _R,
      prevProps: {},
      nextProps: this.props,
      instance: this.polygon
    }), this.props.onLoad && this.props.onLoad(this.polygon);
  }
  componentDidUpdate(t) {
    this.polygon && (ln(this.registeredEvents), this.registeredEvents = tn({
      updaterMap: PR,
      eventMap: _R,
      prevProps: t,
      nextProps: this.props,
      instance: this.polygon
    }));
  }
  componentWillUnmount() {
    this.polygon && (this.props.onUnmount && this.props.onUnmount(this.polygon), ln(this.registeredEvents), this.polygon && this.polygon.setMap(null));
  }
  render() {
    return null;
  }
}
xe(xxe, "contextType", Dt);
function SR(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function rm(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? SR(Object(n), !0).forEach(function(r) {
      xe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : SR(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var MR = {
  onBoundsChanged: "bounds_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, DR = {
  bounds(e, t) {
    e.setBounds(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function Oxe(e) {
  var {
    options: t,
    bounds: n,
    draggable: r,
    editable: o,
    visible: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: h,
    onRightClick: f,
    onClick: m,
    onDrag: g,
    onBoundsChanged: E,
    onLoad: w,
    onUnmount: M
  } = e, x = ye(Dt), [y, C] = k(null), [P, F] = k(null), [L, N] = k(null), [I, H] = k(null), [V, z] = k(null), [q, K] = k(null), [J, te] = k(null), [ee, _] = k(null), [D, $] = k(null), [S, W] = k(null), [O, T] = k(null), [U, j] = k(null), [Z, A] = k(null);
  return v(() => {
    y !== null && y.setMap(x);
  }, [x]), v(() => {
    typeof t < "u" && y !== null && y.setOptions(t);
  }, [y, t]), v(() => {
    typeof r < "u" && y !== null && y.setDraggable(r);
  }, [y, r]), v(() => {
    typeof o < "u" && y !== null && y.setEditable(o);
  }, [y, o]), v(() => {
    typeof i < "u" && y !== null && y.setVisible(i);
  }, [y, i]), v(() => {
    typeof n < "u" && y !== null && y.setBounds(n);
  }, [y, n]), v(() => {
    y && a && (P !== null && google.maps.event.removeListener(P), F(google.maps.event.addListener(y, "dblclick", a)));
  }, [a]), v(() => {
    y && s && (L !== null && google.maps.event.removeListener(L), N(google.maps.event.addListener(y, "dragend", s)));
  }, [s]), v(() => {
    y && l && (I !== null && google.maps.event.removeListener(I), H(google.maps.event.addListener(y, "dragstart", l)));
  }, [l]), v(() => {
    y && u && (V !== null && google.maps.event.removeListener(V), z(google.maps.event.addListener(y, "mousedown", u)));
  }, [u]), v(() => {
    y && c && (q !== null && google.maps.event.removeListener(q), K(google.maps.event.addListener(y, "mousemove", c)));
  }, [c]), v(() => {
    y && p && (J !== null && google.maps.event.removeListener(J), te(google.maps.event.addListener(y, "mouseout", p)));
  }, [p]), v(() => {
    y && d && (ee !== null && google.maps.event.removeListener(ee), _(google.maps.event.addListener(y, "mouseover", d)));
  }, [d]), v(() => {
    y && h && (D !== null && google.maps.event.removeListener(D), $(google.maps.event.addListener(y, "mouseup", h)));
  }, [h]), v(() => {
    y && f && (S !== null && google.maps.event.removeListener(S), W(google.maps.event.addListener(y, "rightclick", f)));
  }, [f]), v(() => {
    y && m && (O !== null && google.maps.event.removeListener(O), T(google.maps.event.addListener(y, "click", m)));
  }, [m]), v(() => {
    y && g && (U !== null && google.maps.event.removeListener(U), j(google.maps.event.addListener(y, "drag", g)));
  }, [g]), v(() => {
    y && E && (Z !== null && google.maps.event.removeListener(Z), A(google.maps.event.addListener(y, "bounds_changed", E)));
  }, [E]), v(() => {
    var Q = new google.maps.Rectangle(rm(rm({}, t), {}, {
      map: x
    }));
    return typeof i < "u" && Q.setVisible(i), typeof o < "u" && Q.setEditable(o), typeof r < "u" && Q.setDraggable(r), typeof n < "u" && Q.setBounds(n), a && F(google.maps.event.addListener(Q, "dblclick", a)), s && N(google.maps.event.addListener(Q, "dragend", s)), l && H(google.maps.event.addListener(Q, "dragstart", l)), u && z(google.maps.event.addListener(Q, "mousedown", u)), c && K(google.maps.event.addListener(Q, "mousemove", c)), p && te(google.maps.event.addListener(Q, "mouseout", p)), d && _(google.maps.event.addListener(Q, "mouseover", d)), h && $(google.maps.event.addListener(Q, "mouseup", h)), f && W(google.maps.event.addListener(Q, "rightclick", f)), m && T(google.maps.event.addListener(Q, "click", m)), g && j(google.maps.event.addListener(Q, "drag", g)), E && A(google.maps.event.addListener(Q, "bounds_changed", E)), C(Q), w && w(Q), () => {
      P !== null && google.maps.event.removeListener(P), L !== null && google.maps.event.removeListener(L), I !== null && google.maps.event.removeListener(I), V !== null && google.maps.event.removeListener(V), q !== null && google.maps.event.removeListener(q), J !== null && google.maps.event.removeListener(J), ee !== null && google.maps.event.removeListener(ee), D !== null && google.maps.event.removeListener(D), S !== null && google.maps.event.removeListener(S), O !== null && google.maps.event.removeListener(O), U !== null && google.maps.event.removeListener(U), Z !== null && google.maps.event.removeListener(Z), M && M(Q), Q.setMap(null);
    };
  }, []), null;
}
Ee(Oxe);
class Exe extends pe {
  constructor() {
    super(...arguments), xe(this, "registeredEvents", []), xe(this, "state", {
      rectangle: null
    }), xe(this, "setRectangleCallback", () => {
      this.state.rectangle !== null && this.props.onLoad && this.props.onLoad(this.state.rectangle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Rectangle(rm(rm({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = tn({
      updaterMap: DR,
      eventMap: MR,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        rectangle: t
      };
    }, this.setRectangleCallback);
  }
  componentDidUpdate(t) {
    this.state.rectangle !== null && (ln(this.registeredEvents), this.registeredEvents = tn({
      updaterMap: DR,
      eventMap: MR,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.rectangle
    }));
  }
  componentWillUnmount() {
    this.state.rectangle !== null && (this.props.onUnmount && this.props.onUnmount(this.state.rectangle), ln(this.registeredEvents), this.state.rectangle.setMap(null));
  }
  render() {
    return null;
  }
}
xe(Exe, "contextType", Dt);
function TR(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function om(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? TR(Object(n), !0).forEach(function(r) {
      xe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : TR(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var jR = {
  onCenterChanged: "center_changed",
  onRadiusChanged: "radius_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, AR = {
  center(e, t) {
    e.setCenter(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  radius(e, t) {
    e.setRadius(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, kxe = {};
function Lxe(e) {
  var {
    options: t,
    center: n,
    radius: r,
    draggable: o,
    editable: i,
    visible: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: h,
    onMouseUp: f,
    onRightClick: m,
    onClick: g,
    onDrag: E,
    onCenterChanged: w,
    onRadiusChanged: M,
    onLoad: x,
    onUnmount: y
  } = e, C = ye(Dt), [P, F] = k(null), [L, N] = k(null), [I, H] = k(null), [V, z] = k(null), [q, K] = k(null), [J, te] = k(null), [ee, _] = k(null), [D, $] = k(null), [S, W] = k(null), [O, T] = k(null), [U, j] = k(null), [Z, A] = k(null), [Q, R] = k(null), [ue, fe] = k(null);
  return v(() => {
    P !== null && P.setMap(C);
  }, [C]), v(() => {
    typeof t < "u" && P !== null && P.setOptions(t);
  }, [P, t]), v(() => {
    typeof o < "u" && P !== null && P.setDraggable(o);
  }, [P, o]), v(() => {
    typeof i < "u" && P !== null && P.setEditable(i);
  }, [P, i]), v(() => {
    typeof a < "u" && P !== null && P.setVisible(a);
  }, [P, a]), v(() => {
    typeof r == "number" && P !== null && P.setRadius(r);
  }, [P, r]), v(() => {
    typeof n < "u" && P !== null && P.setCenter(n);
  }, [P, n]), v(() => {
    P && s && (L !== null && google.maps.event.removeListener(L), N(google.maps.event.addListener(P, "dblclick", s)));
  }, [s]), v(() => {
    P && l && (I !== null && google.maps.event.removeListener(I), H(google.maps.event.addListener(P, "dragend", l)));
  }, [l]), v(() => {
    P && u && (V !== null && google.maps.event.removeListener(V), z(google.maps.event.addListener(P, "dragstart", u)));
  }, [u]), v(() => {
    P && c && (q !== null && google.maps.event.removeListener(q), K(google.maps.event.addListener(P, "mousedown", c)));
  }, [c]), v(() => {
    P && p && (J !== null && google.maps.event.removeListener(J), te(google.maps.event.addListener(P, "mousemove", p)));
  }, [p]), v(() => {
    P && d && (ee !== null && google.maps.event.removeListener(ee), _(google.maps.event.addListener(P, "mouseout", d)));
  }, [d]), v(() => {
    P && h && (D !== null && google.maps.event.removeListener(D), $(google.maps.event.addListener(P, "mouseover", h)));
  }, [h]), v(() => {
    P && f && (S !== null && google.maps.event.removeListener(S), W(google.maps.event.addListener(P, "mouseup", f)));
  }, [f]), v(() => {
    P && m && (O !== null && google.maps.event.removeListener(O), T(google.maps.event.addListener(P, "rightclick", m)));
  }, [m]), v(() => {
    P && g && (U !== null && google.maps.event.removeListener(U), j(google.maps.event.addListener(P, "click", g)));
  }, [g]), v(() => {
    P && E && (Z !== null && google.maps.event.removeListener(Z), A(google.maps.event.addListener(P, "drag", E)));
  }, [E]), v(() => {
    P && w && (Q !== null && google.maps.event.removeListener(Q), R(google.maps.event.addListener(P, "center_changed", w)));
  }, [g]), v(() => {
    P && M && (ue !== null && google.maps.event.removeListener(ue), fe(google.maps.event.addListener(P, "radius_changed", M)));
  }, [M]), v(() => {
    var oe = new google.maps.Circle(om(om({}, t || kxe), {}, {
      map: C
    }));
    return typeof r == "number" && oe.setRadius(r), typeof n < "u" && oe.setCenter(n), typeof r == "number" && oe.setRadius(r), typeof a < "u" && oe.setVisible(a), typeof i < "u" && oe.setEditable(i), typeof o < "u" && oe.setDraggable(o), s && N(google.maps.event.addListener(oe, "dblclick", s)), l && H(google.maps.event.addListener(oe, "dragend", l)), u && z(google.maps.event.addListener(oe, "dragstart", u)), c && K(google.maps.event.addListener(oe, "mousedown", c)), p && te(google.maps.event.addListener(oe, "mousemove", p)), d && _(google.maps.event.addListener(oe, "mouseout", d)), h && $(google.maps.event.addListener(oe, "mouseover", h)), f && W(google.maps.event.addListener(oe, "mouseup", f)), m && T(google.maps.event.addListener(oe, "rightclick", m)), g && j(google.maps.event.addListener(oe, "click", g)), E && A(google.maps.event.addListener(oe, "drag", E)), w && R(google.maps.event.addListener(oe, "center_changed", w)), M && fe(google.maps.event.addListener(oe, "radius_changed", M)), F(oe), x && x(oe), () => {
      L !== null && google.maps.event.removeListener(L), I !== null && google.maps.event.removeListener(I), V !== null && google.maps.event.removeListener(V), q !== null && google.maps.event.removeListener(q), J !== null && google.maps.event.removeListener(J), ee !== null && google.maps.event.removeListener(ee), D !== null && google.maps.event.removeListener(D), S !== null && google.maps.event.removeListener(S), O !== null && google.maps.event.removeListener(O), U !== null && google.maps.event.removeListener(U), Q !== null && google.maps.event.removeListener(Q), ue !== null && google.maps.event.removeListener(ue), y && y(oe), oe.setMap(null);
    };
  }, []), null;
}
Ee(Lxe);
class _xe extends pe {
  constructor() {
    super(...arguments), xe(this, "registeredEvents", []), xe(this, "state", {
      circle: null
    }), xe(this, "setCircleCallback", () => {
      this.state.circle !== null && this.props.onLoad && this.props.onLoad(this.state.circle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Circle(om(om({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = tn({
      updaterMap: AR,
      eventMap: jR,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        circle: t
      };
    }, this.setCircleCallback);
  }
  componentDidUpdate(t) {
    this.state.circle !== null && (ln(this.registeredEvents), this.registeredEvents = tn({
      updaterMap: AR,
      eventMap: jR,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.circle
    }));
  }
  componentWillUnmount() {
    if (this.state.circle !== null) {
      var t;
      this.props.onUnmount && this.props.onUnmount(this.state.circle), ln(this.registeredEvents), (t = this.state.circle) === null || t === void 0 || t.setMap(null);
    }
  }
  render() {
    return null;
  }
}
xe(_xe, "contextType", Dt);
function BR(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function im(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? BR(Object(n), !0).forEach(function(r) {
      xe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : BR(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var IR = {
  onClick: "click",
  onDblClick: "dblclick",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onAddFeature: "addfeature",
  onRemoveFeature: "removefeature",
  onRemoveProperty: "removeproperty",
  onSetGeometry: "setgeometry",
  onSetProperty: "setproperty"
}, RR = {
  add(e, t) {
    e.add(t);
  },
  addgeojson(e, t, n) {
    e.addGeoJson(t, n);
  },
  contains(e, t) {
    e.contains(t);
  },
  foreach(e, t) {
    e.forEach(t);
  },
  loadgeojson(e, t, n, r) {
    e.loadGeoJson(t, n, r);
  },
  overridestyle(e, t, n) {
    e.overrideStyle(t, n);
  },
  remove(e, t) {
    e.remove(t);
  },
  revertstyle(e, t) {
    e.revertStyle(t);
  },
  controlposition(e, t) {
    e.setControlPosition(t);
  },
  controls(e, t) {
    e.setControls(t);
  },
  drawingmode(e, t) {
    e.setDrawingMode(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  style(e, t) {
    e.setStyle(t);
  },
  togeojson(e, t) {
    e.toGeoJson(t);
  }
};
function Pxe(e) {
  var {
    options: t,
    onClick: n,
    onDblClick: r,
    onMouseDown: o,
    onMouseMove: i,
    onMouseOut: a,
    onMouseOver: s,
    onMouseUp: l,
    onRightClick: u,
    onAddFeature: c,
    onRemoveFeature: p,
    onRemoveProperty: d,
    onSetGeometry: h,
    onSetProperty: f,
    onLoad: m,
    onUnmount: g
  } = e, E = ye(Dt), [w, M] = k(null), [x, y] = k(null), [C, P] = k(null), [F, L] = k(null), [N, I] = k(null), [H, V] = k(null), [z, q] = k(null), [K, J] = k(null), [te, ee] = k(null), [_, D] = k(null), [$, S] = k(null), [W, O] = k(null), [T, U] = k(null), [j, Z] = k(null);
  return v(() => {
    w !== null && w.setMap(E);
  }, [E]), v(() => {
    w && r && (x !== null && google.maps.event.removeListener(x), y(google.maps.event.addListener(w, "dblclick", r)));
  }, [r]), v(() => {
    w && o && (C !== null && google.maps.event.removeListener(C), P(google.maps.event.addListener(w, "mousedown", o)));
  }, [o]), v(() => {
    w && i && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(w, "mousemove", i)));
  }, [i]), v(() => {
    w && a && (N !== null && google.maps.event.removeListener(N), I(google.maps.event.addListener(w, "mouseout", a)));
  }, [a]), v(() => {
    w && s && (H !== null && google.maps.event.removeListener(H), V(google.maps.event.addListener(w, "mouseover", s)));
  }, [s]), v(() => {
    w && l && (z !== null && google.maps.event.removeListener(z), q(google.maps.event.addListener(w, "mouseup", l)));
  }, [l]), v(() => {
    w && u && (K !== null && google.maps.event.removeListener(K), J(google.maps.event.addListener(w, "rightclick", u)));
  }, [u]), v(() => {
    w && n && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(w, "click", n)));
  }, [n]), v(() => {
    w && c && (_ !== null && google.maps.event.removeListener(_), D(google.maps.event.addListener(w, "addfeature", c)));
  }, [c]), v(() => {
    w && p && ($ !== null && google.maps.event.removeListener($), S(google.maps.event.addListener(w, "removefeature", p)));
  }, [p]), v(() => {
    w && d && (W !== null && google.maps.event.removeListener(W), O(google.maps.event.addListener(w, "removeproperty", d)));
  }, [d]), v(() => {
    w && h && (T !== null && google.maps.event.removeListener(T), U(google.maps.event.addListener(w, "setgeometry", h)));
  }, [h]), v(() => {
    w && f && (j !== null && google.maps.event.removeListener(j), Z(google.maps.event.addListener(w, "setproperty", f)));
  }, [f]), v(() => {
    if (E !== null) {
      var A = new google.maps.Data(im(im({}, t), {}, {
        map: E
      }));
      r && y(google.maps.event.addListener(A, "dblclick", r)), o && P(google.maps.event.addListener(A, "mousedown", o)), i && L(google.maps.event.addListener(A, "mousemove", i)), a && I(google.maps.event.addListener(A, "mouseout", a)), s && V(google.maps.event.addListener(A, "mouseover", s)), l && q(google.maps.event.addListener(A, "mouseup", l)), u && J(google.maps.event.addListener(A, "rightclick", u)), n && ee(google.maps.event.addListener(A, "click", n)), c && D(google.maps.event.addListener(A, "addfeature", c)), p && S(google.maps.event.addListener(A, "removefeature", p)), d && O(google.maps.event.addListener(A, "removeproperty", d)), h && U(google.maps.event.addListener(A, "setgeometry", h)), f && Z(google.maps.event.addListener(A, "setproperty", f)), M(A), m && m(A);
    }
    return () => {
      w && (x !== null && google.maps.event.removeListener(x), C !== null && google.maps.event.removeListener(C), F !== null && google.maps.event.removeListener(F), N !== null && google.maps.event.removeListener(N), H !== null && google.maps.event.removeListener(H), z !== null && google.maps.event.removeListener(z), K !== null && google.maps.event.removeListener(K), te !== null && google.maps.event.removeListener(te), _ !== null && google.maps.event.removeListener(_), $ !== null && google.maps.event.removeListener($), W !== null && google.maps.event.removeListener(W), T !== null && google.maps.event.removeListener(T), j !== null && google.maps.event.removeListener(j), g && g(w), w.setMap(null));
    };
  }, []), null;
}
Ee(Pxe);
class Sxe extends pe {
  constructor() {
    super(...arguments), xe(this, "registeredEvents", []), xe(this, "state", {
      data: null
    }), xe(this, "setDataCallback", () => {
      this.state.data !== null && this.props.onLoad && this.props.onLoad(this.state.data);
    });
  }
  componentDidMount() {
    if (this.context !== null) {
      var t = new google.maps.Data(im(im({}, this.props.options), {}, {
        map: this.context
      }));
      this.registeredEvents = tn({
        updaterMap: RR,
        eventMap: IR,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        data: t
      }), this.setDataCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.data !== null && (ln(this.registeredEvents), this.registeredEvents = tn({
      updaterMap: RR,
      eventMap: IR,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.data
    }));
  }
  componentWillUnmount() {
    this.state.data !== null && (this.props.onUnmount && this.props.onUnmount(this.state.data), ln(this.registeredEvents), this.state.data && this.state.data.setMap(null));
  }
  render() {
    return null;
  }
}
xe(Sxe, "contextType", Dt);
function NR(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function FR(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? NR(Object(n), !0).forEach(function(r) {
      xe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : NR(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var zR = {
  onClick: "click",
  onDefaultViewportChanged: "defaultviewport_changed",
  onStatusChanged: "status_changed"
}, UR = {
  options(e, t) {
    e.setOptions(t);
  },
  url(e, t) {
    e.setUrl(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
class Mxe extends pe {
  constructor() {
    super(...arguments), xe(this, "registeredEvents", []), xe(this, "state", {
      kmlLayer: null
    }), xe(this, "setKmlLayerCallback", () => {
      this.state.kmlLayer !== null && this.props.onLoad && this.props.onLoad(this.state.kmlLayer);
    });
  }
  componentDidMount() {
    var t = new google.maps.KmlLayer(FR(FR({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = tn({
      updaterMap: UR,
      eventMap: zR,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        kmlLayer: t
      };
    }, this.setKmlLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.kmlLayer !== null && (ln(this.registeredEvents), this.registeredEvents = tn({
      updaterMap: UR,
      eventMap: zR,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.kmlLayer
    }));
  }
  componentWillUnmount() {
    this.state.kmlLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.kmlLayer), ln(this.registeredEvents), this.state.kmlLayer.setMap(null));
  }
  render() {
    return null;
  }
}
xe(Mxe, "contextType", Dt);
function U6(e, t) {
  return typeof t == "function" ? t(e.offsetWidth, e.offsetHeight) : {
    x: 0,
    y: 0
  };
}
function Dxe(e, t) {
  return new t(e.lat, e.lng);
}
function Txe(e, t) {
  return new t(new google.maps.LatLng(e.ne.lat, e.ne.lng), new google.maps.LatLng(e.sw.lat, e.sw.lng));
}
function jxe(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function Axe(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function Bxe(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n.getNorthEast()), o = e && e.fromLatLngToDivPixel(n.getSouthWest());
  return r && o ? {
    left: "".concat(o.x + t.x, "px"),
    top: "".concat(r.y + t.y, "px"),
    width: "".concat(r.x - o.x - t.x, "px"),
    height: "".concat(o.y - r.y - t.y, "px")
  } : {
    left: "-9999px",
    top: "-9999px"
  };
}
function Ixe(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n);
  if (r) {
    var {
      x: o,
      y: i
    } = r;
    return {
      left: "".concat(o + t.x, "px"),
      top: "".concat(i + t.y, "px")
    };
  }
  return {
    left: "-9999px",
    top: "-9999px"
  };
}
function $6(e, t, n, r) {
  return n !== void 0 ? Bxe(e, t, Axe(n, google.maps.LatLngBounds, Txe)) : Ixe(e, t, jxe(r, google.maps.LatLng, Dxe));
}
function Rxe(e, t) {
  return e.left === t.left && e.top === t.top && e.width === t.height && e.height === t.height;
}
function $R(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Nxe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? $R(Object(n), !0).forEach(function(r) {
      xe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : $R(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function Fxe(e, t, n, r, o) {
  class i extends google.maps.OverlayView {
    constructor(s, l, u, c) {
      super(), this.container = s, this.pane = l, this.position = u, this.bounds = c;
    }
    onAdd() {
      var s, l = (s = this.getPanes()) === null || s === void 0 ? void 0 : s[this.pane];
      l == null || l.appendChild(this.container);
    }
    draw() {
      var s = this.getProjection(), l = Nxe({}, this.container ? U6(this.container, o) : {
        x: 0,
        y: 0
      }), u = $6(s, l, this.bounds, this.position);
      for (var [c, p] of Object.entries(u))
        this.container.style[c] = p;
    }
    onRemove() {
      this.container.parentNode !== null && this.container.parentNode.removeChild(this.container);
    }
  }
  return new i(e, t, n, r);
}
function HR(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function zxe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? HR(Object(n), !0).forEach(function(r) {
      xe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : HR(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function WR(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLng ? e : new google.maps.LatLng(e.lat, e.lng);
  return t + "";
}
function VR(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLngBounds ? e : new google.maps.LatLngBounds(new google.maps.LatLng(e.south, e.east), new google.maps.LatLng(e.north, e.west));
  return t + "";
}
function Uxe(e) {
  var {
    position: t,
    bounds: n,
    mapPaneName: r,
    zIndex: o,
    onLoad: i,
    onUnmount: a,
    getPixelPositionOffset: s,
    children: l
  } = e, u = ye(Dt), c = Tn(() => {
    var d = document.createElement("div");
    return d.style.position = "absolute", d;
  }, []), p = Tn(() => Fxe(c, r, t, n, s), [c, r, t, n]);
  return v(() => (i == null || i(p), p == null || p.setMap(u), () => {
    a == null || a(p), p == null || p.setMap(null);
  }), [u, p]), v(() => {
    c.style.zIndex = "".concat(o);
  }, [o, c]), Ci.createPortal(l, c);
}
Ee(Uxe);
class ku extends pe {
  constructor(t) {
    super(t), xe(this, "state", {
      paneEl: null,
      containerStyle: {
        // set initial position
        position: "absolute"
      }
    }), xe(this, "updatePane", () => {
      var r = this.props.mapPaneName, o = this.overlayView.getPanes();
      Xr(!!r, "OverlayView requires props.mapPaneName but got %s", r), o ? this.setState({
        paneEl: o[r]
      }) : this.setState({
        paneEl: null
      });
    }), xe(this, "onAdd", () => {
      var r, o;
      this.updatePane(), (r = (o = this.props).onLoad) === null || r === void 0 || r.call(o, this.overlayView);
    }), xe(this, "onPositionElement", () => {
      var r = this.overlayView.getProjection(), o = zxe({
        x: 0,
        y: 0
      }, this.containerRef.current ? U6(this.containerRef.current, this.props.getPixelPositionOffset) : {}), i = $6(r, o, this.props.bounds, this.props.position);
      if (!Rxe(i, {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        left: this.state.containerStyle.left,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        top: this.state.containerStyle.top,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        width: this.state.containerStyle.width,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        height: this.state.containerStyle.height
      })) {
        var a, s, l, u;
        this.setState({
          containerStyle: {
            top: (a = i.top) !== null && a !== void 0 ? a : 0,
            left: (s = i.left) !== null && s !== void 0 ? s : 0,
            width: (l = i.width) !== null && l !== void 0 ? l : 0,
            height: (u = i.height) !== null && u !== void 0 ? u : 0,
            position: "absolute"
          }
        });
      }
    }), xe(this, "draw", () => {
      this.onPositionElement();
    }), xe(this, "onRemove", () => {
      var r, o;
      this.setState(() => ({
        paneEl: null
      })), (r = (o = this.props).onUnmount) === null || r === void 0 || r.call(o, this.overlayView);
    }), this.containerRef = Qr();
    var n = new google.maps.OverlayView();
    n.onAdd = this.onAdd, n.draw = this.draw, n.onRemove = this.onRemove, this.overlayView = n;
  }
  componentDidMount() {
    this.overlayView.setMap(this.context);
  }
  componentDidUpdate(t) {
    var n = WR(t.position), r = WR(this.props.position), o = VR(t.bounds), i = VR(this.props.bounds);
    (n !== r || o !== i) && this.overlayView.draw(), t.mapPaneName !== this.props.mapPaneName && this.updatePane();
  }
  componentWillUnmount() {
    this.overlayView.setMap(null);
  }
  render() {
    var t = this.state.paneEl;
    return t ? Ci.createPortal(no.jsx("div", {
      ref: this.containerRef,
      style: this.state.containerStyle,
      children: at.only(this.props.children)
    }), t) : null;
  }
}
xe(ku, "FLOAT_PANE", "floatPane");
xe(ku, "MAP_PANE", "mapPane");
xe(ku, "MARKER_LAYER", "markerLayer");
xe(ku, "OVERLAY_LAYER", "overlayLayer");
xe(ku, "OVERLAY_MOUSE_TARGET", "overlayMouseTarget");
xe(ku, "contextType", Dt);
function $xe() {
}
function qR(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ZR(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? qR(Object(n), !0).forEach(function(r) {
      xe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : qR(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var GR = {
  onDblClick: "dblclick",
  onClick: "click"
}, XR = {
  opacity(e, t) {
    e.setOpacity(t);
  }
};
function Hxe(e) {
  var {
    url: t,
    bounds: n,
    options: r,
    visible: o
  } = e, i = ye(Dt), a = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east)), s = Tn(() => new google.maps.GroundOverlay(t, a, r), []);
  return v(() => {
    s !== null && s.setMap(i);
  }, [i]), v(() => {
    typeof t < "u" && s !== null && (s.set("url", t), s.setMap(i));
  }, [s, t]), v(() => {
    typeof o < "u" && s !== null && s.setOpacity(o ? 1 : 0);
  }, [s, o]), v(() => {
    var l = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east));
    typeof n < "u" && s !== null && (s.set("bounds", l), s.setMap(i));
  }, [s, n]), null;
}
Ee(Hxe);
class H6 extends pe {
  constructor() {
    super(...arguments), xe(this, "registeredEvents", []), xe(this, "state", {
      groundOverlay: null
    }), xe(this, "setGroundOverlayCallback", () => {
      this.state.groundOverlay !== null && this.props.onLoad && this.props.onLoad(this.state.groundOverlay);
    });
  }
  componentDidMount() {
    Xr(!!this.props.url || !!this.props.bounds, "For GroundOverlay, url and bounds are passed in to constructor and are immutable after instantiated. This is the behavior of Google Maps JavaScript API v3 ( See https://developers.google.com/maps/documentation/javascript/reference#GroundOverlay) Hence, use the corresponding two props provided by `react-google-maps-api`, url and bounds. In some cases, you'll need the GroundOverlay component to reflect the changes of url and bounds. You can leverage the React's key property to remount the component. Typically, just `key={url}` would serve your need. See https://github.com/tomchentw/react-google-maps/issues/655");
    var t = new google.maps.GroundOverlay(this.props.url, this.props.bounds, ZR(ZR({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = tn({
      updaterMap: XR,
      eventMap: GR,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        groundOverlay: t
      };
    }, this.setGroundOverlayCallback);
  }
  componentDidUpdate(t) {
    this.state.groundOverlay !== null && (ln(this.registeredEvents), this.registeredEvents = tn({
      updaterMap: XR,
      eventMap: GR,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.groundOverlay
    }));
  }
  componentWillUnmount() {
    this.state.groundOverlay && (this.props.onUnmount && this.props.onUnmount(this.state.groundOverlay), this.state.groundOverlay.setMap(null));
  }
  render() {
    return null;
  }
}
xe(H6, "defaultProps", {
  onLoad: $xe
});
xe(H6, "contextType", Dt);
function KR(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function sm(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? KR(Object(n), !0).forEach(function(r) {
      xe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : KR(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var YR = {}, JR = {
  data(e, t) {
    e.setData(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function Wxe(e) {
  var {
    data: t,
    onLoad: n,
    onUnmount: r,
    options: o
  } = e, i = ye(Dt), [a, s] = k(null);
  return v(() => {
    google.maps.visualization || Xr(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} in useJsApiScript? %s', google.maps.visualization);
  }, []), v(() => {
    Xr(!!t, "data property is required in HeatmapLayer %s", t);
  }, [t]), v(() => {
    a !== null && a.setMap(i);
  }, [i]), v(() => {
    o && a !== null && a.setOptions(o);
  }, [a, o]), v(() => {
    var l = new google.maps.visualization.HeatmapLayer(sm(sm({}, o), {}, {
      data: t,
      map: i
    }));
    return s(l), n && n(l), () => {
      a !== null && (r && r(a), a.setMap(null));
    };
  }, []), null;
}
Ee(Wxe);
class Vxe extends pe {
  constructor() {
    super(...arguments), xe(this, "registeredEvents", []), xe(this, "state", {
      heatmapLayer: null
    }), xe(this, "setHeatmapLayerCallback", () => {
      this.state.heatmapLayer !== null && this.props.onLoad && this.props.onLoad(this.state.heatmapLayer);
    });
  }
  componentDidMount() {
    Xr(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} to <LoadScript />? %s', google.maps.visualization), Xr(!!this.props.data, "data property is required in HeatmapLayer %s", this.props.data);
    var t = new google.maps.visualization.HeatmapLayer(sm(sm({}, this.props.options), {}, {
      data: this.props.data,
      map: this.context
    }));
    this.registeredEvents = tn({
      updaterMap: JR,
      eventMap: YR,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        heatmapLayer: t
      };
    }, this.setHeatmapLayerCallback);
  }
  componentDidUpdate(t) {
    ln(this.registeredEvents), this.registeredEvents = tn({
      updaterMap: JR,
      eventMap: YR,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.heatmapLayer
    });
  }
  componentWillUnmount() {
    this.state.heatmapLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.heatmapLayer), ln(this.registeredEvents), this.state.heatmapLayer.setMap(null));
  }
  render() {
    return null;
  }
}
xe(Vxe, "contextType", Dt);
var QR = {
  onCloseClick: "closeclick",
  onPanoChanged: "pano_changed",
  onPositionChanged: "position_changed",
  onPovChanged: "pov_changed",
  onResize: "resize",
  onStatusChanged: "status_changed",
  onVisibleChanged: "visible_changed",
  onZoomChanged: "zoom_changed"
}, eN = {
  register(e, t, n) {
    e.registerPanoProvider(t, n);
  },
  links(e, t) {
    e.setLinks(t);
  },
  motionTracking(e, t) {
    e.setMotionTracking(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  pano(e, t) {
    e.setPano(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  pov(e, t) {
    e.setPov(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zoom(e, t) {
    e.setZoom(t);
  }
};
class qxe extends pe {
  constructor() {
    super(...arguments), xe(this, "registeredEvents", []), xe(this, "state", {
      streetViewPanorama: null
    }), xe(this, "setStreetViewPanoramaCallback", () => {
      this.state.streetViewPanorama !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewPanorama);
    });
  }
  componentDidMount() {
    var t, n, r = (t = (n = this.context) === null || n === void 0 ? void 0 : n.getStreetView()) !== null && t !== void 0 ? t : null;
    this.registeredEvents = tn({
      updaterMap: eN,
      eventMap: QR,
      prevProps: {},
      nextProps: this.props,
      instance: r
    }), this.setState(() => ({
      streetViewPanorama: r
    }), this.setStreetViewPanoramaCallback);
  }
  componentDidUpdate(t) {
    this.state.streetViewPanorama !== null && (ln(this.registeredEvents), this.registeredEvents = tn({
      updaterMap: eN,
      eventMap: QR,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.streetViewPanorama
    }));
  }
  componentWillUnmount() {
    this.state.streetViewPanorama !== null && (this.props.onUnmount && this.props.onUnmount(this.state.streetViewPanorama), ln(this.registeredEvents), this.state.streetViewPanorama.setVisible(!1));
  }
  render() {
    return null;
  }
}
xe(qxe, "contextType", Dt);
class Zxe extends pe {
  constructor() {
    super(...arguments), xe(this, "state", {
      streetViewService: null
    }), xe(this, "setStreetViewServiceCallback", () => {
      this.state.streetViewService !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewService);
    });
  }
  componentDidMount() {
    var t = new google.maps.StreetViewService();
    this.setState(function() {
      return {
        streetViewService: t
      };
    }, this.setStreetViewServiceCallback);
  }
  componentWillUnmount() {
    this.state.streetViewService !== null && this.props.onUnmount && this.props.onUnmount(this.state.streetViewService);
  }
  render() {
    return null;
  }
}
xe(Zxe, "contextType", Dt);
var tN = {
  onDirectionsChanged: "directions_changed"
}, nN = {
  directions(e, t) {
    e.setDirections(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  panel(e, t) {
    e.setPanel(t);
  },
  routeIndex(e, t) {
    e.setRouteIndex(t);
  }
};
class Gxe extends pe {
  constructor() {
    super(...arguments), xe(this, "registeredEvents", []), xe(this, "state", {
      directionsRenderer: null
    }), xe(this, "setDirectionsRendererCallback", () => {
      this.state.directionsRenderer !== null && (this.state.directionsRenderer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.directionsRenderer));
    });
  }
  componentDidMount() {
    var t = new google.maps.DirectionsRenderer(this.props.options);
    this.registeredEvents = tn({
      updaterMap: nN,
      eventMap: tN,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        directionsRenderer: t
      };
    }, this.setDirectionsRendererCallback);
  }
  componentDidUpdate(t) {
    this.state.directionsRenderer !== null && (ln(this.registeredEvents), this.registeredEvents = tn({
      updaterMap: nN,
      eventMap: tN,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.directionsRenderer
    }));
  }
  componentWillUnmount() {
    this.state.directionsRenderer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.directionsRenderer), ln(this.registeredEvents), this.state.directionsRenderer && this.state.directionsRenderer.setMap(null));
  }
  render() {
    return null;
  }
}
xe(Gxe, "contextType", Dt);
var rN = {
  onPlacesChanged: "places_changed"
}, oN = {
  bounds(e, t) {
    e.setBounds(t);
  }
};
class Xxe extends pe {
  constructor() {
    super(...arguments), xe(this, "registeredEvents", []), xe(this, "containerElement", Qr()), xe(this, "state", {
      searchBox: null
    }), xe(this, "setSearchBoxCallback", () => {
      this.state.searchBox !== null && this.props.onLoad && this.props.onLoad(this.state.searchBox);
    });
  }
  componentDidMount() {
    if (Xr(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places), this.containerElement !== null && this.containerElement.current !== null) {
      var t = this.containerElement.current.querySelector("input");
      if (t !== null) {
        var n = new google.maps.places.SearchBox(t, this.props.options);
        this.registeredEvents = tn({
          updaterMap: oN,
          eventMap: rN,
          prevProps: {},
          nextProps: this.props,
          instance: n
        }), this.setState(function() {
          return {
            searchBox: n
          };
        }, this.setSearchBoxCallback);
      }
    }
  }
  componentDidUpdate(t) {
    this.state.searchBox !== null && (ln(this.registeredEvents), this.registeredEvents = tn({
      updaterMap: oN,
      eventMap: rN,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.searchBox
    }));
  }
  componentWillUnmount() {
    this.state.searchBox !== null && (this.props.onUnmount && this.props.onUnmount(this.state.searchBox), ln(this.registeredEvents));
  }
  render() {
    return no.jsx("div", {
      ref: this.containerElement,
      children: at.only(this.props.children)
    });
  }
}
xe(Xxe, "contextType", Dt);
var iN = {
  onPlaceChanged: "place_changed"
}, sN = {
  bounds(e, t) {
    e.setBounds(t);
  },
  restrictions(e, t) {
    e.setComponentRestrictions(t);
  },
  fields(e, t) {
    e.setFields(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  types(e, t) {
    e.setTypes(t);
  }
};
class W6 extends pe {
  constructor() {
    super(...arguments), xe(this, "registeredEvents", []), xe(this, "containerElement", Qr()), xe(this, "state", {
      autocomplete: null
    }), xe(this, "setAutocompleteCallback", () => {
      this.state.autocomplete !== null && this.props.onLoad && this.props.onLoad(this.state.autocomplete);
    });
  }
  componentDidMount() {
    var t;
    Xr(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places);
    var n = (t = this.containerElement.current) === null || t === void 0 ? void 0 : t.querySelector("input");
    if (n) {
      var r = new google.maps.places.Autocomplete(n, this.props.options);
      this.registeredEvents = tn({
        updaterMap: sN,
        eventMap: iN,
        prevProps: {},
        nextProps: this.props,
        instance: r
      }), this.setState(() => ({
        autocomplete: r
      }), this.setAutocompleteCallback);
    }
  }
  componentDidUpdate(t) {
    ln(this.registeredEvents), this.registeredEvents = tn({
      updaterMap: sN,
      eventMap: iN,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.autocomplete
    });
  }
  componentWillUnmount() {
    this.state.autocomplete !== null && ln(this.registeredEvents);
  }
  render() {
    return no.jsx("div", {
      ref: this.containerElement,
      className: this.props.className,
      children: at.only(this.props.children)
    });
  }
}
xe(W6, "defaultProps", {
  className: ""
});
xe(W6, "contextType", Dt);
let Kxe = { data: "" }, Yxe = (e) => typeof window == "object" ? ((e ? e.querySelector("#_goober") : window._goober) || Object.assign((e || document.head).appendChild(document.createElement("style")), { innerHTML: " ", id: "_goober" })).firstChild : e || Kxe, Jxe = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g, Qxe = /\/\*[^]*?\*\/|  +/g, aN = /\n+/g, la = (e, t) => {
  let n = "", r = "", o = "";
  for (let i in e) {
    let a = e[i];
    i[0] == "@" ? i[1] == "i" ? n = i + " " + a + ";" : r += i[1] == "f" ? la(a, i) : i + "{" + la(a, i[1] == "k" ? "" : t) + "}" : typeof a == "object" ? r += la(a, t ? t.replace(/([^,])+/g, (s) => i.replace(/([^,]*:\S+\([^)]*\))|([^,])+/g, (l) => /&/.test(l) ? l.replace(/&/g, s) : s ? s + " " + l : l)) : i) : a != null && (i = /^--/.test(i) ? i : i.replace(/[A-Z]/g, "-$&").toLowerCase(), o += la.p ? la.p(i, a) : i + ":" + a + ";");
  }
  return n + (t && o ? t + "{" + o + "}" : o) + r;
}, cs = {}, V6 = (e) => {
  if (typeof e == "object") {
    let t = "";
    for (let n in e) t += n + V6(e[n]);
    return t;
  }
  return e;
}, eOe = (e, t, n, r, o) => {
  let i = V6(e), a = cs[i] || (cs[i] = ((l) => {
    let u = 0, c = 11;
    for (; u < l.length; ) c = 101 * c + l.charCodeAt(u++) >>> 0;
    return "go" + c;
  })(i));
  if (!cs[a]) {
    let l = i !== e ? e : ((u) => {
      let c, p, d = [{}];
      for (; c = Jxe.exec(u.replace(Qxe, "")); ) c[4] ? d.shift() : c[3] ? (p = c[3].replace(aN, " ").trim(), d.unshift(d[0][p] = d[0][p] || {})) : d[0][c[1]] = c[2].replace(aN, " ").trim();
      return d[0];
    })(e);
    cs[a] = la(o ? { ["@keyframes " + a]: l } : l, n ? "" : "." + a);
  }
  let s = n && cs.g ? cs.g : null;
  return n && (cs.g = cs[a]), ((l, u, c, p) => {
    p ? u.data = u.data.replace(p, l) : u.data.indexOf(l) === -1 && (u.data = c ? l + u.data : u.data + l);
  })(cs[a], t, r, s), a;
}, tOe = (e, t, n) => e.reduce((r, o, i) => {
  let a = t[i];
  if (a && a.call) {
    let s = a(n), l = s && s.props && s.props.className || /^go/.test(s) && s;
    a = l ? "." + l : s && typeof s == "object" ? s.props ? "" : la(s, "") : s === !1 ? "" : s;
  }
  return r + o + (a ?? "");
}, "");
function ky(e) {
  let t = this || {}, n = e.call ? e(t.p) : e;
  return eOe(n.unshift ? n.raw ? tOe(n, [].slice.call(arguments, 1), t.p) : n.reduce((r, o) => Object.assign(r, o && o.call ? o(t.p) : o), {}) : n, Yxe(t.target), t.g, t.o, t.k);
}
let q6, Ox, Ex;
ky.bind({ g: 1 });
let Os = ky.bind({ k: 1 });
function nOe(e, t, n, r) {
  la.p = t, q6 = e, Ox = n, Ex = r;
}
function Ma(e, t) {
  let n = this || {};
  return function() {
    let r = arguments;
    function o(i, a) {
      let s = Object.assign({}, i), l = s.className || o.className;
      n.p = Object.assign({ theme: Ox && Ox() }, s), n.o = / *go\d+/.test(l), s.className = ky.apply(n, r) + (l ? " " + l : "");
      let u = e;
      return e[0] && (u = s.as || e, delete s.as), Ex && u[0] && Ex(s), q6(u, s);
    }
    return o;
  };
}
var rOe = (e) => typeof e == "function", oOe = (e, t) => rOe(e) ? e(t) : e, iOe = /* @__PURE__ */ (() => {
  let e;
  return () => {
    if (e === void 0 && typeof window < "u") {
      let t = matchMedia("(prefers-reduced-motion: reduce)");
      e = !t || t.matches;
    }
    return e;
  };
})(), sOe = Os`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`, aOe = Os`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`, lOe = Os`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`, uOe = Ma("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${sOe} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${aOe} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${(e) => e.secondary || "#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${lOe} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`, cOe = Os`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, pOe = Ma("div")`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${(e) => e.secondary || "#e0e0e0"};
  border-right-color: ${(e) => e.primary || "#616161"};
  animation: ${cOe} 1s linear infinite;
`, dOe = Os`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`, fOe = Os`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`, hOe = Ma("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${dOe} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${fOe} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${(e) => e.secondary || "#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`, gOe = Ma("div")`
  position: absolute;
`, mOe = Ma("div")`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`, vOe = Os`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`, yOe = Ma("div")`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${vOe} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`, bOe = ({ toast: e }) => {
  let { icon: t, type: n, iconTheme: r } = e;
  return t !== void 0 ? typeof t == "string" ? $e.createElement(yOe, null, t) : t : n === "blank" ? null : $e.createElement(mOe, null, $e.createElement(pOe, { ...r }), n !== "loading" && $e.createElement(gOe, null, n === "error" ? $e.createElement(uOe, { ...r }) : $e.createElement(hOe, { ...r })));
}, wOe = (e) => `
0% {transform: translate3d(0,${e * -200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`, COe = (e) => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${e * -150}%,-1px) scale(.6); opacity:0;}
`, xOe = "0%{opacity:0;} 100%{opacity:1;}", OOe = "0%{opacity:1;} 100%{opacity:0;}", EOe = Ma("div")`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`, kOe = Ma("div")`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`, LOe = (e, t) => {
  let n = e.includes("top") ? 1 : -1, [r, o] = iOe() ? [xOe, OOe] : [wOe(n), COe(n)];
  return { animation: t ? `${Os(r)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards` : `${Os(o)} 0.4s forwards cubic-bezier(.06,.71,.55,1)` };
};
$e.memo(({ toast: e, position: t, style: n, children: r }) => {
  let o = e.height ? LOe(e.position || t || "top-center", e.visible) : { opacity: 0 }, i = $e.createElement(bOe, { toast: e }), a = $e.createElement(kOe, { ...e.ariaProps }, oOe(e.message, e));
  return $e.createElement(EOe, { className: e.className, style: { ...o, ...n, ...e.style } }, typeof r == "function" ? r({ icon: i, message: a }) : $e.createElement($e.Fragment, null, i, a));
});
nOe($e.createElement);
ky`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`;
function Gk(e) {
  const {
    isLoading: t = !1,
    scheme: n = "primary",
    variant: r = "solid",
    loadingText: o,
    size: i = "md",
    leftIcon: a,
    rightIcon: s,
    disabled: l,
    className: u = "",
    children: c,
    ...p
  } = e, d = { xs: 12, sm: 16, md: 20, lg: 24 }[i], h = `arkynButton ${t ? "loadingTrue" : "loadingFalse"} ${r} ${n} ${i} ${o ? "loadingTextTrue" : "loadingTextFalse"} ${u}`;
  return /* @__PURE__ */ mn.jsxs("button", { className: h, disabled: l || t, ...p, children: [
    /* @__PURE__ */ mn.jsxs("div", { className: "arkynButtonSpinner", children: [
      /* @__PURE__ */ mn.jsx(Gi, { size: d, strokeWidth: 2.5 }),
      o && o
    ] }),
    /* @__PURE__ */ mn.jsxs("div", { className: "arkynButtonContent", children: [
      $L(d, a),
      c,
      $L(d, s)
    ] })
  ] });
}
function _Oe() {
  const e = eO(), t = t$(), n = tO(), [r, o] = k(null);
  function i(u, c) {
    return JSON.stringify(u) === JSON.stringify(c);
  }
  function a() {
    r && o(null);
  }
  v(() => {
    var u, c;
    let p = ((c = (u = n[0]) == null ? void 0 : u.data) == null ? void 0 : c.fieldErrors) || {};
    i(r, p) || Object.entries(p).length !== 0 && o(p);
  }, [n, e]), v(() => {
    var u;
    ((u = n[0]) == null ? void 0 : u.state) === "submitting" && a();
  }, [n, t]);
  const s = (e == null ? void 0 : e.fieldErrors) || r;
  let l = {};
  return Object.entries(s || {}).forEach(([u, c]) => {
    typeof c == "string" && typeof u == "string" && (l[u] = c);
  }), l;
}
Ze({});
function POe(e) {
  const {
    isLoading: t = !1,
    scheme: n = "primary",
    variant: r = "solid",
    size: o = "md",
    icon: i,
    disabled: a,
    className: s = "",
    ...l
  } = e, u = { xs: 12, sm: 16, md: 20, lg: 24 }, c = `arkynIconButton ${r} ${n} ${o} ${t ? "loadingTrue" : "loadingFalse"} ${s}`;
  return /* @__PURE__ */ mn.jsxs(
    "button",
    {
      disabled: a || t,
      className: c.trim(),
      ...l,
      children: [
        /* @__PURE__ */ mn.jsx("div", { className: "arkynIconButtonSpinner", children: /* @__PURE__ */ mn.jsx(Gi, { size: u[o], strokeWidth: 2.5 }) }),
        /* @__PURE__ */ mn.jsx("div", { className: "arkynIconButtonContent", children: /* @__PURE__ */ mn.jsx(i, { size: u[o], strokeWidth: 2.5 }) })
      ]
    }
  );
}
function SOe(e) {
  const {
    text: t,
    size: n = "lg",
    children: r,
    orientation: o = "top",
    className: i = "",
    ...a
  } = e, s = `arkynTooltip ${n} ${o} ${i}`;
  return /* @__PURE__ */ mn.jsxs("div", { className: s.trim(), ...a, children: [
    r,
    /* @__PURE__ */ mn.jsx("div", { className: "arkynTooltipText", children: t })
  ] });
}
function MOe(e) {
  return e && e.replace(/[^0-9]/g, "");
}
const DOe = {
  CNPJ: "99.999.999/9999-99"
};
MOe(DOe.CNPJ).length;
Vr((e, t) => /* @__PURE__ */ mn.jsx("input", { ref: t, ...e }));
function Z6(e) {
  return e && e.replace(/[^0-9]/g, "");
}
const G6 = {
  EIGTH: "(99) 9999-9999",
  NINE: "(99) 99999-9999"
};
function TOe(e, t) {
  let n = "", r = 0;
  for (let o = 0; o < t.length; o++)
    if (t[o] === "9")
      if (r < e.length)
        n += e[r], r++;
      else
        break;
    else if (r < e.length)
      n += t[o];
    else
      break;
  return n;
}
function jOe(e) {
  return e.length > 10 ? "NINE" : "EIGTH";
}
const AOe = Z6(G6.NINE).length, BOe = Vr((e, t) => /* @__PURE__ */ mn.jsx("input", { ref: t, ...e }));
Vr(
  (e, t) => {
    const { onFocus: n, onBlur: r, size: o, onChange: i, value: a, currentCountry: s, disabled: l } = e, [u, c] = k(!1);
    v(() => {
      u ? i(s.mask) : c(!0);
    }, [s]);
    const p = `phoneInputMask ${o}`;
    function d(h) {
      let f = Z6(h.target.value);
      const m = jOe(f);
      f.length > AOe || (f = TOe(f, G6[m]), h.target.value = f, i(f));
    }
    return s.code === "+55" ? /* @__PURE__ */ mn.jsx(
      "input",
      {
        value: a,
        onChange: d,
        className: p,
        onFocus: n,
        onBlur: r,
        disabled: l,
        ref: t
      }
    ) : /* @__PURE__ */ mn.jsx(
      Il,
      {
        value: a,
        onChange: (h) => i(h.target.value),
        className: p,
        component: BOe,
        onFocus: n,
        onBlur: r,
        disabled: l,
        mask: s.mask,
        showMask: !0,
        replacement: { _: /\d/ },
        ref: t
      }
    );
  }
);
Ze({});
var Ms = {};
Object.defineProperty(Ms, "__esModule", {
  value: !0
});
var IOe = typeof window < "u" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform), Z0 = {
  alt: "altKey",
  control: "ctrlKey",
  meta: "metaKey",
  shift: "shiftKey"
}, X6 = {
  add: "+",
  break: "pause",
  cmd: "meta",
  command: "meta",
  ctl: "control",
  ctrl: "control",
  del: "delete",
  down: "arrowdown",
  esc: "escape",
  ins: "insert",
  left: "arrowleft",
  mod: IOe ? "meta" : "control",
  opt: "alt",
  option: "alt",
  return: "enter",
  right: "arrowright",
  space: " ",
  spacebar: " ",
  up: "arrowup",
  win: "meta",
  windows: "meta"
}, Xk = {
  backspace: 8,
  tab: 9,
  enter: 13,
  shift: 16,
  control: 17,
  alt: 18,
  pause: 19,
  capslock: 20,
  escape: 27,
  " ": 32,
  pageup: 33,
  pagedown: 34,
  end: 35,
  home: 36,
  arrowleft: 37,
  arrowup: 38,
  arrowright: 39,
  arrowdown: 40,
  insert: 45,
  delete: 46,
  meta: 91,
  numlock: 144,
  scrolllock: 145,
  ";": 186,
  "=": 187,
  ",": 188,
  "-": 189,
  ".": 190,
  "/": 191,
  "`": 192,
  "[": 219,
  "\\": 220,
  "]": 221,
  "'": 222
};
for (var Jf = 1; Jf < 20; Jf++)
  Xk["f" + Jf] = 111 + Jf;
function Ly(e, t, n) {
  t && !("byKey" in t) && (n = t, t = null), Array.isArray(e) || (e = [e]);
  var r = e.map(function(a) {
    return K6(a, t);
  }), o = function(a) {
    return r.some(function(s) {
      return Y6(s, a);
    });
  }, i = n == null ? o : o(n);
  return i;
}
function ROe(e, t) {
  return Ly(e, t);
}
function NOe(e, t) {
  return Ly(e, { byKey: !0 }, t);
}
function K6(e, t) {
  var n = t && t.byKey, r = {};
  e = e.replace("++", "+add");
  var o = e.split("+"), i = o.length;
  for (var a in Z0)
    r[Z0[a]] = !1;
  var s = !0, l = !1, u = void 0;
  try {
    for (var c = o[Symbol.iterator](), p; !(s = (p = c.next()).done); s = !0) {
      var d = p.value, h = d.endsWith("?") && d.length > 1;
      h && (d = d.slice(0, -1));
      var f = Kk(d), m = Z0[f];
      if (d.length > 1 && !m && !X6[d] && !Xk[f])
        throw new TypeError('Unknown modifier: "' + d + '"');
      (i === 1 || !m) && (n ? r.key = f : r.which = J6(d)), m && (r[m] = h ? null : !0);
    }
  } catch (g) {
    l = !0, u = g;
  } finally {
    try {
      !s && c.return && c.return();
    } finally {
      if (l)
        throw u;
    }
  }
  return r;
}
function Y6(e, t) {
  for (var n in e) {
    var r = e[n], o = void 0;
    if (r != null && (n === "key" && t.key != null ? o = t.key.toLowerCase() : n === "which" ? o = r === 91 && t.which === 93 ? 91 : t.which : o = t[n], !(o == null && r === !1) && o !== r))
      return !1;
  }
  return !0;
}
function J6(e) {
  e = Kk(e);
  var t = Xk[e] || e.toUpperCase().charCodeAt(0);
  return t;
}
function Kk(e) {
  return e = e.toLowerCase(), e = X6[e] || e, e;
}
Ms.default = Ly;
var G0 = Ms.isHotkey = Ly;
Ms.isCodeHotkey = ROe;
Ms.isKeyHotkey = NOe;
Ms.parseHotkey = K6;
Ms.compareHotkey = Y6;
Ms.toKeyCode = J6;
Ms.toKeyName = Kk;
var FOe = typeof Fn == "object" && Fn && Fn.Object === Object && Fn, zOe = FOe, UOe = zOe, $Oe = typeof self == "object" && self && self.Object === Object && self, HOe = UOe || $Oe || Function("return this")(), WOe = HOe, VOe = WOe, qOe = VOe.Symbol, Q6 = qOe, lN = Q6;
lN && lN.toStringTag;
var uN = Q6;
uN && uN.toStringTag;
var cN;
(function(e) {
  e.BORDER_BOX = "border-box", e.CONTENT_BOX = "content-box", e.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(cN || (cN = {}));
var Yk = function(e) {
  return Object.freeze(e);
}, ZOe = /* @__PURE__ */ function() {
  function e(t, n) {
    this.inlineSize = t, this.blockSize = n, Yk(this);
  }
  return e;
}(), GOe = function() {
  function e(t, n, r, o) {
    return this.x = t, this.y = n, this.width = r, this.height = o, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, Yk(this);
  }
  return e.prototype.toJSON = function() {
    var t = this, n = t.x, r = t.y, o = t.top, i = t.right, a = t.bottom, s = t.left, l = t.width, u = t.height;
    return { x: n, y: r, top: o, right: i, bottom: a, left: s, width: l, height: u };
  }, e.fromRect = function(t) {
    return new e(t.x, t.y, t.width, t.height);
  }, e;
}(), pN = typeof window < "u" ? window : {};
/msie|trident/i.test(pN.navigator && pN.navigator.userAgent);
var X0 = function(e, t, n) {
  return e === void 0 && (e = 0), t === void 0 && (t = 0), n === void 0 && (n = !1), new ZOe((n ? t : e) || 0, (n ? e : t) || 0);
};
Yk({
  devicePixelContentBoxSize: X0(),
  borderBoxSize: X0(),
  contentBoxSize: X0(),
  contentRect: new GOe(0, 0, 0, 0)
});
function Tp(e) {
  "@babel/helpers - typeof";
  return Tp = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Tp(e);
}
function XOe(e, t) {
  if (Tp(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (Tp(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function KOe(e) {
  var t = XOe(e, "string");
  return Tp(t) === "symbol" ? t : String(t);
}
function Uc(e, t, n) {
  return t = KOe(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
var YOe = /* @__PURE__ */ Ze(null), K0, Y0;
parseInt(ke.version.split(".")[0], 10);
var dN = typeof navigator < "u" && /Mac OS X/.test(navigator.userAgent), J0 = typeof navigator < "u" && /Android/.test(navigator.userAgent), Qf = typeof navigator < "u" && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent), JOe = typeof navigator < "u" && /Chrome/i.test(navigator.userAgent);
typeof navigator < "u" && /Safari/.test(navigator.userAgent) && /Version\/(\d+)/.test(navigator.userAgent) && (K0 = navigator.userAgent.match(/Version\/(\d+)/)) !== null && K0 !== void 0 && K0[1] && parseInt((Y0 = navigator.userAgent.match(/Version\/(\d+)/)) === null || Y0 === void 0 ? void 0 : Y0[1], 10) < 17;
var QOe = /* @__PURE__ */ new WeakMap(), eEe = /* @__PURE__ */ new WeakMap(), tEe = /* @__PURE__ */ new WeakMap(), nEe = /* @__PURE__ */ new WeakMap(), rEe = /* @__PURE__ */ new WeakMap(), fN = /* @__PURE__ */ new WeakMap(), oEe = /* @__PURE__ */ new WeakMap(), hN = /* @__PURE__ */ new WeakMap(), eh = /* @__PURE__ */ new WeakMap(), iEe = /* @__PURE__ */ new WeakMap(), sEe = /* @__PURE__ */ new WeakMap(), aEe = /* @__PURE__ */ new WeakMap(), e8 = globalThis.Node, lEe = globalThis.Text, t8 = (e) => e && e.ownerDocument && e.ownerDocument.defaultView || null, uEe = (e) => am(e) && e.nodeType === 8, Zi = (e) => am(e) && e.nodeType === 1, am = (e) => {
  var t = t8(e);
  return !!t && e instanceof t.Node;
}, gN = (e) => {
  var t = e && e.anchorNode && t8(e.anchorNode);
  return !!t && e instanceof t.Selection;
}, cEe = (e) => {
  var [t, n] = e;
  if (Zi(t) && t.childNodes.length) {
    var r = n === t.childNodes.length, o = r ? n - 1 : n;
    for ([t, o] = n8(t, o, r ? "backward" : "forward"), r = o < n; Zi(t) && t.childNodes.length; ) {
      var i = r ? t.childNodes.length - 1 : 0;
      t = dEe(t, i, r ? "backward" : "forward");
    }
    n = r && t.textContent != null ? t.textContent.length : 0;
  }
  return [t, n];
}, pEe = (e) => {
  for (var t = e && e.parentNode; t; ) {
    if (t.toString() === "[object ShadowRoot]")
      return !0;
    t = t.parentNode;
  }
  return !1;
}, n8 = (e, t, n) => {
  for (var {
    childNodes: r
  } = e, o = r[t], i = t, a = !1, s = !1; (uEe(o) || Zi(o) && o.childNodes.length === 0 || Zi(o) && o.getAttribute("contenteditable") === "false") && !(a && s); ) {
    if (i >= r.length) {
      a = !0, i = t - 1, n = "backward";
      continue;
    }
    if (i < 0) {
      s = !0, i = t + 1, n = "forward";
      continue;
    }
    o = r[i], t = i, i += n === "forward" ? 1 : -1;
  }
  return [o, t];
}, dEe = (e, t, n) => {
  var [r] = n8(e, t, n);
  return r;
}, mN = (e) => e.getSelection != null ? e.getSelection() : document.getSelection(), r8 = (e, t, n) => {
  var {
    target: r
  } = t;
  if (Zi(r) && r.matches('[contentEditable="false"]'))
    return !1;
  var {
    document: o
  } = Yt.getWindow(e);
  if (o.contains(r))
    return Yt.hasDOMNode(e, r, {
      editable: !0
    });
  var i = n.find((a) => {
    var {
      addedNodes: s,
      removedNodes: l
    } = a;
    for (var u of s)
      if (u === r || u.contains(r))
        return !0;
    for (var c of l)
      if (c === r || c.contains(r))
        return !0;
  });
  return !i || i === t ? !1 : r8(e, i, n);
}, vN = (e, t) => !!(e.compareDocumentPosition(t) & e8.DOCUMENT_POSITION_PRECEDING), fEe = (e, t) => !!(e.compareDocumentPosition(t) & e8.DOCUMENT_POSITION_FOLLOWING), hEe = 0;
class gEe {
  constructor() {
    Uc(this, "id", void 0), this.id = "".concat(hEe++);
  }
}
var Yt = {
  androidPendingDiffs: (e) => aEe.get(e),
  androidScheduleFlush: (e) => {
    var t;
    (t = sEe.get(e)) === null || t === void 0 || t();
  },
  blur: (e) => {
    var t = Yt.toDOMNode(e, e), n = Yt.findDocumentOrShadowRoot(e);
    eh.set(e, !1), n.activeElement === t && t.blur();
  },
  deselect: (e) => {
    var {
      selection: t
    } = e, n = Yt.findDocumentOrShadowRoot(e), r = mN(n);
    r && r.rangeCount > 0 && r.removeAllRanges(), t && Xh.deselect(e);
  },
  findDocumentOrShadowRoot: (e) => {
    var t = Yt.toDOMNode(e, e), n = t.getRootNode();
    return n instanceof Document || n instanceof ShadowRoot ? n : t.ownerDocument;
  },
  findEventRange: (e, t) => {
    "nativeEvent" in t && (t = t.nativeEvent);
    var {
      clientX: n,
      clientY: r,
      target: o
    } = t;
    if (n == null || r == null)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var i = Yt.toSlateNode(e, t.target), a = Yt.findPath(e, i);
    if (fs.isElement(i) && jn.isVoid(e, i)) {
      var s = o.getBoundingClientRect(), l = e.isInline(i) ? n - s.left < s.left + s.width - n : r - s.top < s.top + s.height - r, u = jn.point(e, a, {
        edge: l ? "start" : "end"
      }), c = l ? jn.before(e, u) : jn.after(e, u);
      if (c) {
        var p = jn.range(e, c);
        return p;
      }
    }
    var d, {
      document: h
    } = Yt.getWindow(e);
    if (h.caretRangeFromPoint)
      d = h.caretRangeFromPoint(n, r);
    else {
      var f = h.caretPositionFromPoint(n, r);
      f && (d = h.createRange(), d.setStart(f.offsetNode, f.offset), d.setEnd(f.offsetNode, f.offset));
    }
    if (!d)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var m = Yt.toSlateRange(e, d, {
      exactMatch: !1,
      suppressThrow: !1
    });
    return m;
  },
  findKey: (e, t) => {
    var n = fN.get(t);
    return n || (n = new gEe(), fN.set(t, n)), n;
  },
  findPath: (e, t) => {
    for (var n = [], r = t; ; ) {
      var o = eEe.get(r);
      if (o == null) {
        if (jn.isEditor(r))
          return n;
        break;
      }
      var i = QOe.get(r);
      if (i == null)
        break;
      n.unshift(i), r = o;
    }
    throw new Error("Unable to find the path for Slate node: ".concat($o.stringify(t)));
  },
  focus: function(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      retries: 5
    };
    if (!eh.get(e)) {
      if (t.retries <= 0)
        throw new Error("Could not set focus, editor seems stuck with pending operations");
      if (e.operations.length > 0) {
        setTimeout(() => {
          Yt.focus(e, {
            retries: t.retries - 1
          });
        }, 10);
        return;
      }
      var n = Yt.toDOMNode(e, e), r = Yt.findDocumentOrShadowRoot(e);
      if (r.activeElement !== n) {
        if (e.selection && r instanceof Document) {
          var o = mN(r), i = Yt.toDOMRange(e, e.selection);
          o == null || o.removeAllRanges(), o == null || o.addRange(i);
        }
        e.selection || Xh.select(e, jn.start(e, [])), eh.set(e, !0), n.focus({
          preventScroll: !0
        });
      }
    }
  },
  getWindow: (e) => {
    var t = tEe.get(e);
    if (!t)
      throw new Error("Unable to find a host window element for this editor");
    return t;
  },
  hasDOMNode: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      editable: r = !1
    } = n, o = Yt.toDOMNode(e, e), i;
    try {
      i = Zi(t) ? t : t.parentElement;
    } catch (a) {
      if (a instanceof Error && !a.message.includes('Permission denied to access property "nodeType"'))
        throw a;
    }
    return i ? i.closest("[data-slate-editor]") === o && (!r || i.isContentEditable ? !0 : typeof i.isContentEditable == "boolean" && // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined
    // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable="false"(readOnly)
    i.closest('[contenteditable="false"]') === o || !!i.getAttribute("data-slate-zero-width")) : !1;
  },
  hasEditableTarget: (e, t) => am(t) && Yt.hasDOMNode(e, t, {
    editable: !0
  }),
  hasRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t;
    return jn.hasPath(e, n.path) && jn.hasPath(e, r.path);
  },
  hasSelectableTarget: (e, t) => Yt.hasEditableTarget(e, t) || Yt.isTargetInsideNonReadonlyVoid(e, t),
  hasTarget: (e, t) => am(t) && Yt.hasDOMNode(e, t),
  insertData: (e, t) => {
    e.insertData(t);
  },
  insertFragmentData: (e, t) => e.insertFragmentData(t),
  insertTextData: (e, t) => e.insertTextData(t),
  isComposing: (e) => !!iEe.get(e),
  isFocused: (e) => !!eh.get(e),
  isReadOnly: (e) => !!hN.get(e),
  isTargetInsideNonReadonlyVoid: (e, t) => {
    if (hN.get(e)) return !1;
    var n = Yt.hasTarget(e, t) && Yt.toSlateNode(e, t);
    return fs.isElement(n) && jn.isVoid(e, n);
  },
  setFragmentData: (e, t, n) => e.setFragmentData(t, n),
  toDOMNode: (e, t) => {
    var n = oEe.get(e), r = jn.isEditor(t) ? nEe.get(e) : n == null ? void 0 : n.get(Yt.findKey(e, t));
    if (!r)
      throw new Error("Cannot resolve a DOM node from Slate node: ".concat($o.stringify(t)));
    return r;
  },
  toDOMPoint: (e, t) => {
    var [n] = jn.node(e, t.path), r = Yt.toDOMNode(e, n), o;
    jn.void(e, {
      at: t
    }) && (t = {
      path: t.path,
      offset: 0
    });
    for (var i = "[data-slate-string], [data-slate-zero-width]", a = Array.from(r.querySelectorAll(i)), s = 0, l = 0; l < a.length; l++) {
      var u = a[l], c = u.childNodes[0];
      if (!(c == null || c.textContent == null)) {
        var {
          length: p
        } = c.textContent, d = u.getAttribute("data-slate-length"), h = d == null ? p : parseInt(d, 10), f = s + h, m = a[l + 1];
        if (t.offset === f && m !== null && m !== void 0 && m.hasAttribute("data-slate-mark-placeholder")) {
          var g, E = m.childNodes[0];
          o = [
            // COMPAT: If we don't explicity set the dom point to be on the actual
            // dom text element, chrome will put the selection behind the actual dom
            // text element, causing domRange.getBoundingClientRect() calls on a collapsed
            // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)
            // which will cause issues when scrolling to it.
            E instanceof lEe ? E : m,
            (g = m.textContent) !== null && g !== void 0 && g.startsWith("\uFEFF") ? 1 : 0
          ];
          break;
        }
        if (t.offset <= f) {
          var w = Math.min(p, Math.max(0, t.offset - s));
          o = [c, w];
          break;
        }
        s = f;
      }
    }
    if (!o)
      throw new Error("Cannot resolve a DOM point from Slate point: ".concat($o.stringify(t)));
    return o;
  },
  toDOMRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t, o = At.isBackward(t), i = Yt.toDOMPoint(e, n), a = At.isCollapsed(t) ? i : Yt.toDOMPoint(e, r), s = Yt.getWindow(e), l = s.document.createRange(), [u, c] = o ? a : i, [p, d] = o ? i : a, h = Zi(u) ? u : u.parentElement, f = !!h.getAttribute("data-slate-zero-width"), m = Zi(p) ? p : p.parentElement, g = !!m.getAttribute("data-slate-zero-width");
    return l.setStart(u, f ? 1 : c), l.setEnd(p, g ? 1 : d), l;
  },
  toSlateNode: (e, t) => {
    var n = Zi(t) ? t : t.parentElement;
    n && !n.hasAttribute("data-slate-node") && (n = n.closest("[data-slate-node]"));
    var r = n ? rEe.get(n) : null;
    if (!r)
      throw new Error("Cannot resolve a Slate node from DOM node: ".concat(n));
    return r;
  },
  toSlatePoint: (e, t, n) => {
    var {
      exactMatch: r,
      suppressThrow: o,
      searchDirection: i = "backward"
    } = n, [a, s] = r ? t : cEe(t), l = a.parentNode, u = null, c = 0;
    if (l) {
      var p, d, h = Yt.toDOMNode(e, e), f = l.closest('[data-slate-void="true"]'), m = f && h.contains(f) ? f : null, g = l.closest('[contenteditable="false"]'), E = g && h.contains(g) ? g : null, w = l.closest("[data-slate-leaf]"), M = null;
      if (w) {
        if (u = w.closest('[data-slate-node="text"]'), u) {
          var x = Yt.getWindow(e), y = x.document.createRange();
          y.setStart(u, 0), y.setEnd(a, s);
          var C = y.cloneContents(), P = [...Array.prototype.slice.call(C.querySelectorAll("[data-slate-zero-width]")), ...Array.prototype.slice.call(C.querySelectorAll("[contenteditable=false]"))];
          P.forEach((S) => {
            if (J0 && !r && S.hasAttribute("data-slate-zero-width") && S.textContent.length > 0 && S.textContext !== "\uFEFF") {
              S.textContent.startsWith("\uFEFF") && (S.textContent = S.textContent.slice(1));
              return;
            }
            S.parentNode.removeChild(S);
          }), c = C.textContent.length, M = u;
        }
      } else if (m) {
        for (var F = m.querySelectorAll("[data-slate-leaf]"), L = 0; L < F.length; L++) {
          var N = F[L];
          if (Yt.hasDOMNode(e, N)) {
            w = N;
            break;
          }
        }
        w ? (u = w.closest('[data-slate-node="text"]'), M = w, c = M.textContent.length, M.querySelectorAll("[data-slate-zero-width]").forEach((S) => {
          c -= S.textContent.length;
        })) : c = 1;
      } else if (E) {
        var I = (S) => S ? S.querySelectorAll(
          // Exclude leaf nodes in nested editors
          "[data-slate-leaf]:not(:scope [data-slate-editor] [data-slate-leaf])"
        ) : [], H = E.closest('[data-slate-node="element"]');
        if (i === "forward") {
          var V, z = [...I(H), ...I(H == null ? void 0 : H.nextElementSibling)];
          w = (V = z.find((S) => fEe(E, S))) !== null && V !== void 0 ? V : null;
        } else {
          var q, K = [...I(H == null ? void 0 : H.previousElementSibling), ...I(H)];
          w = (q = K.findLast((S) => vN(E, S))) !== null && q !== void 0 ? q : null;
        }
        w && (u = w.closest('[data-slate-node="text"]'), M = w, i === "forward" ? c = 0 : (c = M.textContent.length, M.querySelectorAll("[data-slate-zero-width]").forEach((S) => {
          c -= S.textContent.length;
        })));
      }
      M && c === M.textContent.length && // COMPAT: Android IMEs might remove the zero width space while composing,
      // and we don't add it for line-breaks.
      J0 && M.getAttribute("data-slate-zero-width") === "z" && (p = M.textContent) !== null && p !== void 0 && p.startsWith("\uFEFF") && // COMPAT: If the parent node is a Slate zero-width space, editor is
      // because the text node should have no characters. However, during IME
      // composition the ASCII characters will be prepended to the zero-width
      // space, so subtract 1 from the offset to account for the zero-width
      // space character.
      (l.hasAttribute("data-slate-zero-width") || // COMPAT: In Firefox, `range.cloneContents()` returns an extra trailing '\n'
      // when the document ends with a new-line character. This results in the offset
      // length being off by one, so we need to subtract one to account for this.
      Qf && (d = M.textContent) !== null && d !== void 0 && d.endsWith(`

`)) && c--;
    }
    if (J0 && !u && !r) {
      var J = l.hasAttribute("data-slate-node") ? l : l.closest("[data-slate-node]");
      if (J && Yt.hasDOMNode(e, J, {
        editable: !0
      })) {
        var te = Yt.toSlateNode(e, J), {
          path: ee,
          offset: _
        } = jn.start(e, Yt.findPath(e, te));
        return J.querySelector("[data-slate-leaf]") || (_ = s), {
          path: ee,
          offset: _
        };
      }
    }
    if (!u) {
      if (o)
        return null;
      throw new Error("Cannot resolve a Slate point from DOM point: ".concat(t));
    }
    var D = Yt.toSlateNode(e, u), $ = Yt.findPath(e, D);
    return {
      path: $,
      offset: c
    };
  },
  toSlateRange: (e, t, n) => {
    var r, {
      exactMatch: o,
      suppressThrow: i
    } = n, a = gN(t) ? t.anchorNode : t.startContainer, s, l, u, c, p;
    if (a)
      if (gN(t)) {
        if (Qf && t.rangeCount > 1) {
          u = t.focusNode;
          var d = t.getRangeAt(0), h = t.getRangeAt(t.rangeCount - 1);
          if (u instanceof HTMLTableRowElement && d.startContainer instanceof HTMLTableRowElement && h.startContainer instanceof HTMLTableRowElement) {
            let C = function(P) {
              return P.childElementCount > 0 ? C(P.children[0]) : P;
            };
            var f = d.startContainer, m = h.startContainer, g = C(f.children[d.startOffset]), E = C(m.children[h.startOffset]);
            c = 0, E.childNodes.length > 0 ? s = E.childNodes[0] : s = E, g.childNodes.length > 0 ? u = g.childNodes[0] : u = g, E instanceof HTMLElement ? l = E.innerHTML.length : l = 0;
          } else
            d.startContainer === u ? (s = h.endContainer, l = h.endOffset, c = d.startOffset) : (s = d.startContainer, l = d.endOffset, c = h.startOffset);
        } else
          s = t.anchorNode, l = t.anchorOffset, u = t.focusNode, c = t.focusOffset;
        JOe && pEe(s) || Qf ? p = t.anchorNode === t.focusNode && t.anchorOffset === t.focusOffset : p = t.isCollapsed;
      } else
        s = t.startContainer, l = t.startOffset, u = t.endContainer, c = t.endOffset, p = t.collapsed;
    if (s == null || u == null || l == null || c == null)
      throw new Error("Cannot resolve a Slate range from DOM range: ".concat(t));
    Qf && (r = u.textContent) !== null && r !== void 0 && r.endsWith(`

`) && c === u.textContent.length && c--;
    var w = Yt.toSlatePoint(e, [s, l], {
      exactMatch: o,
      suppressThrow: i
    });
    if (!w)
      return null;
    var M = vN(s, u) || s === u && c < l, x = p ? w : Yt.toSlatePoint(e, [u, c], {
      exactMatch: o,
      suppressThrow: i,
      searchDirection: M ? "forward" : "backward"
    });
    if (!x)
      return null;
    var y = {
      anchor: w,
      focus: x
    };
    return At.isExpanded(y) && At.isForward(y) && Zi(u) && jn.void(e, {
      at: y.focus,
      mode: "highest"
    }) && (y = jn.unhangRange(e, y, {
      voids: !0
    })), y;
  }
}, mEe = {
  bold: "mod+b",
  compose: ["down", "left", "right", "up", "backspace", "enter"],
  moveBackward: "left",
  moveForward: "right",
  moveWordBackward: "ctrl+left",
  moveWordForward: "ctrl+right",
  deleteBackward: "shift?+backspace",
  deleteForward: "shift?+delete",
  extendBackward: "shift+left",
  extendForward: "shift+right",
  italic: "mod+i",
  insertSoftBreak: "shift+enter",
  splitBlock: "enter",
  undo: "mod+z"
}, vEe = {
  moveLineBackward: "opt+up",
  moveLineForward: "opt+down",
  moveWordBackward: "opt+left",
  moveWordForward: "opt+right",
  deleteBackward: ["ctrl+backspace", "ctrl+h"],
  deleteForward: ["ctrl+delete", "ctrl+d"],
  deleteLineBackward: "cmd+shift?+backspace",
  deleteLineForward: ["cmd+shift?+delete", "ctrl+k"],
  deleteWordBackward: "opt+shift?+backspace",
  deleteWordForward: "opt+shift?+delete",
  extendLineBackward: "opt+shift+up",
  extendLineForward: "opt+shift+down",
  redo: "cmd+shift+z",
  transposeCharacter: "ctrl+t"
}, yEe = {
  deleteWordBackward: "ctrl+shift?+backspace",
  deleteWordForward: "ctrl+shift?+delete",
  redo: ["ctrl+y", "ctrl+shift+z"]
}, hr = (e) => {
  var t = mEe[e], n = vEe[e], r = yEe[e], o = t && G0(t), i = n && G0(n), a = r && G0(r);
  return (s) => !!(o && o(s) || dN && i && i(s) || !dN && a && a(s));
};
hr("bold"), hr("compose"), hr("moveBackward"), hr("moveForward"), hr("deleteBackward"), hr("deleteForward"), hr("deleteLineBackward"), hr("deleteLineForward"), hr("deleteWordBackward"), hr("deleteWordForward"), hr("extendBackward"), hr("extendForward"), hr("extendLineBackward"), hr("extendLineForward"), hr("italic"), hr("moveLineBackward"), hr("moveLineForward"), hr("moveWordBackward"), hr("moveWordForward"), hr("redo"), hr("insertSoftBreak"), hr("splitBlock"), hr("transposeCharacter"), hr("undo");
var bEe = (e, t) => {
  var n = [], r = () => {
    n = [];
  }, o = (a) => {
    if (t.current) {
      var s = a.filter((l) => r8(e, l, a));
      n.push(...s);
    }
  };
  function i() {
    n.length > 0 && (n.reverse().forEach((a) => {
      a.type !== "characterData" && (a.removedNodes.forEach((s) => {
        a.target.insertBefore(s, a.nextSibling);
      }), a.addedNodes.forEach((s) => {
        a.target.removeChild(s);
      }));
    }), r());
  }
  return {
    registerMutations: o,
    restoreDOM: i,
    clear: r
  };
}, wEe = {
  subtree: !0,
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0
};
class CEe extends pu {
  constructor() {
    super(...arguments), Uc(this, "context", null), Uc(this, "manager", null), Uc(this, "mutationObserver", null);
  }
  observe() {
    var t, {
      node: n
    } = this.props;
    if (!n.current)
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    (t = this.mutationObserver) === null || t === void 0 || t.observe(n.current, wEe);
  }
  componentDidMount() {
    var {
      receivedUserInput: t
    } = this.props, n = this.context;
    this.manager = bEe(n, t), this.mutationObserver = new MutationObserver(this.manager.registerMutations), this.observe();
  }
  getSnapshotBeforeUpdate() {
    var t, n, r, o = (t = this.mutationObserver) === null || t === void 0 ? void 0 : t.takeRecords();
    if (o != null && o.length) {
      var i;
      (i = this.manager) === null || i === void 0 || i.registerMutations(o);
    }
    return (n = this.mutationObserver) === null || n === void 0 || n.disconnect(), (r = this.manager) === null || r === void 0 || r.restoreDOM(), null;
  }
  componentDidUpdate() {
    var t;
    (t = this.manager) === null || t === void 0 || t.clear(), this.observe();
  }
  componentWillUnmount() {
    var t;
    (t = this.mutationObserver) === null || t === void 0 || t.disconnect();
  }
  render() {
    return this.props.children;
  }
}
Uc(CEe, "contextType", YOe);
Ze({});
Ze({});
Ze({});
var Hr = {}, Jk = {}, hd = {}, gd = {}, o8 = "Expected a function", yN = NaN, xEe = "[object Symbol]", OEe = /^\s+|\s+$/g, EEe = /^[-+]0x[0-9a-f]+$/i, kEe = /^0b[01]+$/i, LEe = /^0o[0-7]+$/i, _Ee = parseInt, PEe = typeof Fn == "object" && Fn && Fn.Object === Object && Fn, SEe = typeof self == "object" && self && self.Object === Object && self, MEe = PEe || SEe || Function("return this")(), DEe = Object.prototype, TEe = DEe.toString, jEe = Math.max, AEe = Math.min, Q0 = function() {
  return MEe.Date.now();
};
function BEe(e, t, n) {
  var r, o, i, a, s, l, u = 0, c = !1, p = !1, d = !0;
  if (typeof e != "function")
    throw new TypeError(o8);
  t = bN(t) || 0, lm(n) && (c = !!n.leading, p = "maxWait" in n, i = p ? jEe(bN(n.maxWait) || 0, t) : i, d = "trailing" in n ? !!n.trailing : d);
  function h(C) {
    var P = r, F = o;
    return r = o = void 0, u = C, a = e.apply(F, P), a;
  }
  function f(C) {
    return u = C, s = setTimeout(E, t), c ? h(C) : a;
  }
  function m(C) {
    var P = C - l, F = C - u, L = t - P;
    return p ? AEe(L, i - F) : L;
  }
  function g(C) {
    var P = C - l, F = C - u;
    return l === void 0 || P >= t || P < 0 || p && F >= i;
  }
  function E() {
    var C = Q0();
    if (g(C))
      return w(C);
    s = setTimeout(E, m(C));
  }
  function w(C) {
    return s = void 0, d && r ? h(C) : (r = o = void 0, a);
  }
  function M() {
    s !== void 0 && clearTimeout(s), u = 0, r = l = o = s = void 0;
  }
  function x() {
    return s === void 0 ? a : w(Q0());
  }
  function y() {
    var C = Q0(), P = g(C);
    if (r = arguments, o = this, l = C, P) {
      if (s === void 0)
        return f(l);
      if (p)
        return s = setTimeout(E, t), h(l);
    }
    return s === void 0 && (s = setTimeout(E, t)), a;
  }
  return y.cancel = M, y.flush = x, y;
}
function IEe(e, t, n) {
  var r = !0, o = !0;
  if (typeof e != "function")
    throw new TypeError(o8);
  return lm(n) && (r = "leading" in n ? !!n.leading : r, o = "trailing" in n ? !!n.trailing : o), BEe(e, t, {
    leading: r,
    maxWait: t,
    trailing: o
  });
}
function lm(e) {
  var t = typeof e;
  return !!e && (t == "object" || t == "function");
}
function REe(e) {
  return !!e && typeof e == "object";
}
function NEe(e) {
  return typeof e == "symbol" || REe(e) && TEe.call(e) == xEe;
}
function bN(e) {
  if (typeof e == "number")
    return e;
  if (NEe(e))
    return yN;
  if (lm(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = lm(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = e.replace(OEe, "");
  var n = kEe.test(e);
  return n || LEe.test(e) ? _Ee(e.slice(2), n ? 2 : 8) : EEe.test(e) ? yN : +e;
}
var FEe = IEe, md = {};
Object.defineProperty(md, "__esModule", {
  value: !0
});
md.addPassiveEventListener = function(e, t, n) {
  var r = n.name;
  r || (r = t, console.warn("Listener must be a named function.")), Th.has(t) || Th.set(t, /* @__PURE__ */ new Set());
  var o = Th.get(t);
  if (!o.has(r)) {
    var i = function() {
      var a = !1;
      try {
        var s = Object.defineProperty({}, "passive", {
          get: function() {
            a = !0;
          }
        });
        window.addEventListener("test", null, s);
      } catch {
      }
      return a;
    }();
    e.addEventListener(t, n, i ? { passive: !0 } : !1), o.add(r);
  }
};
md.removePassiveEventListener = function(e, t, n) {
  e.removeEventListener(t, n), Th.get(t).delete(n.name || t);
};
var Th = /* @__PURE__ */ new Map();
Object.defineProperty(gd, "__esModule", {
  value: !0
});
var zEe = FEe, UEe = $Ee(zEe), wN = md;
function $Ee(e) {
  return e && e.__esModule ? e : { default: e };
}
var HEe = function(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 66;
  return (0, UEe.default)(e, t);
}, Lr = {
  spyCallbacks: [],
  spySetState: [],
  scrollSpyContainers: [],
  mount: function(e, t) {
    if (e) {
      var n = HEe(function(r) {
        Lr.scrollHandler(e);
      }, t);
      return Lr.scrollSpyContainers.push(e), (0, wN.addPassiveEventListener)(e, "scroll", n), function() {
        (0, wN.removePassiveEventListener)(e, "scroll", n), Lr.scrollSpyContainers.splice(Lr.scrollSpyContainers.indexOf(e), 1);
      };
    }
    return function() {
    };
  },
  isMounted: function(e) {
    return Lr.scrollSpyContainers.indexOf(e) !== -1;
  },
  currentPositionX: function(e) {
    if (e === document) {
      var t = window.scrollY !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.scrollX : n ? document.documentElement.scrollLeft : document.body.scrollLeft;
    } else
      return e.scrollLeft;
  },
  currentPositionY: function(e) {
    if (e === document) {
      var t = window.scrollX !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.scrollY : n ? document.documentElement.scrollTop : document.body.scrollTop;
    } else
      return e.scrollTop;
  },
  scrollHandler: function(e) {
    var t = Lr.scrollSpyContainers[Lr.scrollSpyContainers.indexOf(e)].spyCallbacks || [];
    t.forEach(function(n) {
      return n(Lr.currentPositionX(e), Lr.currentPositionY(e));
    });
  },
  addStateHandler: function(e) {
    Lr.spySetState.push(e);
  },
  addSpyHandler: function(e, t) {
    var n = Lr.scrollSpyContainers[Lr.scrollSpyContainers.indexOf(t)];
    n.spyCallbacks || (n.spyCallbacks = []), n.spyCallbacks.push(e);
  },
  updateStates: function() {
    Lr.spySetState.forEach(function(e) {
      return e();
    });
  },
  unmount: function(e, t) {
    Lr.scrollSpyContainers.forEach(function(n) {
      return n.spyCallbacks && n.spyCallbacks.length && n.spyCallbacks.indexOf(t) > -1 && n.spyCallbacks.splice(n.spyCallbacks.indexOf(t), 1);
    }), Lr.spySetState && Lr.spySetState.length && Lr.spySetState.indexOf(e) > -1 && Lr.spySetState.splice(Lr.spySetState.indexOf(e), 1), document.removeEventListener("scroll", Lr.scrollHandler);
  },
  update: function() {
    return Lr.scrollSpyContainers.forEach(function(e) {
      return Lr.scrollHandler(e);
    });
  }
};
gd.default = Lr;
var Lu = {}, vd = {};
Object.defineProperty(vd, "__esModule", {
  value: !0
});
var WEe = function(e, t) {
  var n = e.indexOf("#") === 0 ? e.substring(1) : e, r = n ? "#" + n : "", o = window && window.location, i = r ? o.pathname + o.search + r : o.pathname + o.search;
  t ? history.pushState(history.state, "", i) : history.replaceState(history.state, "", i);
}, VEe = function() {
  return window.location.hash.replace(/^#/, "");
}, qEe = function(e) {
  return function(t) {
    return e.contains ? e != t && e.contains(t) : !!(e.compareDocumentPosition(t) & 16);
  };
}, ZEe = function(e) {
  return getComputedStyle(e).position !== "static";
}, ew = function(e, t) {
  for (var n = e.offsetTop, r = e.offsetParent; r && !t(r); )
    n += r.offsetTop, r = r.offsetParent;
  return { offsetTop: n, offsetParent: r };
}, GEe = function(e, t, n) {
  if (n)
    return e === document ? t.getBoundingClientRect().left + (window.scrollX || window.pageXOffset) : getComputedStyle(e).position !== "static" ? t.offsetLeft : t.offsetLeft - e.offsetLeft;
  if (e === document)
    return t.getBoundingClientRect().top + (window.scrollY || window.pageYOffset);
  if (ZEe(e)) {
    if (t.offsetParent !== e) {
      var r = function(l) {
        return l === e || l === document;
      }, o = ew(t, r), i = o.offsetTop, a = o.offsetParent;
      if (a !== e)
        throw new Error("Seems containerElement is not an ancestor of the Element");
      return i;
    }
    return t.offsetTop;
  }
  if (t.offsetParent === e.offsetParent)
    return t.offsetTop - e.offsetTop;
  var s = function(l) {
    return l === document;
  };
  return ew(t, s).offsetTop - ew(e, s).offsetTop;
};
vd.default = {
  updateHash: WEe,
  getHash: VEe,
  filterElementInContainer: qEe,
  scrollOffset: GEe
};
var _y = {}, Qk = {};
Object.defineProperty(Qk, "__esModule", {
  value: !0
});
Qk.default = {
  /*
   * https://github.com/oblador/angular-scroll (duScrollDefaultEasing)
   */
  defaultEasing: function(e) {
    return e < 0.5 ? Math.pow(e * 2, 2) / 2 : 1 - Math.pow((1 - e) * 2, 2) / 2;
  },
  /*
   * https://gist.github.com/gre/1650294
   */
  // no easing, no acceleration
  linear: function(e) {
    return e;
  },
  // accelerating from zero velocity
  easeInQuad: function(e) {
    return e * e;
  },
  // decelerating to zero velocity
  easeOutQuad: function(e) {
    return e * (2 - e);
  },
  // acceleration until halfway, then deceleration
  easeInOutQuad: function(e) {
    return e < 0.5 ? 2 * e * e : -1 + (4 - 2 * e) * e;
  },
  // accelerating from zero velocity 
  easeInCubic: function(e) {
    return e * e * e;
  },
  // decelerating to zero velocity 
  easeOutCubic: function(e) {
    return --e * e * e + 1;
  },
  // acceleration until halfway, then deceleration 
  easeInOutCubic: function(e) {
    return e < 0.5 ? 4 * e * e * e : (e - 1) * (2 * e - 2) * (2 * e - 2) + 1;
  },
  // accelerating from zero velocity 
  easeInQuart: function(e) {
    return e * e * e * e;
  },
  // decelerating to zero velocity 
  easeOutQuart: function(e) {
    return 1 - --e * e * e * e;
  },
  // acceleration until halfway, then deceleration
  easeInOutQuart: function(e) {
    return e < 0.5 ? 8 * e * e * e * e : 1 - 8 * --e * e * e * e;
  },
  // accelerating from zero velocity
  easeInQuint: function(e) {
    return e * e * e * e * e;
  },
  // decelerating to zero velocity
  easeOutQuint: function(e) {
    return 1 + --e * e * e * e * e;
  },
  // acceleration until halfway, then deceleration 
  easeInOutQuint: function(e) {
    return e < 0.5 ? 16 * e * e * e * e * e : 1 + 16 * --e * e * e * e * e;
  }
};
var e1 = {};
Object.defineProperty(e1, "__esModule", {
  value: !0
});
var XEe = md, KEe = ["mousedown", "wheel", "touchmove", "keydown"];
e1.default = {
  subscribe: function(e) {
    return typeof document < "u" && KEe.forEach(function(t) {
      return (0, XEe.addPassiveEventListener)(document, t, e);
    });
  }
};
var yd = {};
Object.defineProperty(yd, "__esModule", {
  value: !0
});
var kx = {
  registered: {},
  scrollEvent: {
    register: function(e, t) {
      kx.registered[e] = t;
    },
    remove: function(e) {
      kx.registered[e] = null;
    }
  }
};
yd.default = kx;
Object.defineProperty(_y, "__esModule", {
  value: !0
});
var YEe = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, JEe = vd;
Py(JEe);
var QEe = Qk, CN = Py(QEe), eke = e1, tke = Py(eke), nke = yd, Ui = Py(nke);
function Py(e) {
  return e && e.__esModule ? e : { default: e };
}
var i8 = function(e) {
  return CN.default[e.smooth] || CN.default.defaultEasing;
}, rke = function(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}, oke = function() {
  if (typeof window < "u")
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame;
}, Lx = function() {
  return oke() || function(e, t, n) {
    window.setTimeout(e, n || 1e3 / 60, (/* @__PURE__ */ new Date()).getTime());
  };
}(), s8 = function() {
  return {
    currentPosition: 0,
    startPosition: 0,
    targetPosition: 0,
    progress: 0,
    duration: 0,
    cancel: !1,
    target: null,
    containerElement: null,
    to: null,
    start: null,
    delta: null,
    percent: null,
    delayTimeout: null
  };
}, a8 = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollLeft;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageXOffset : r ? document.documentElement.scrollLeft : document.body.scrollLeft;
}, l8 = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollTop;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageYOffset : r ? document.documentElement.scrollTop : document.body.scrollTop;
}, ike = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollWidth - t.offsetWidth;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollWidth, n.offsetWidth, r.clientWidth, r.scrollWidth, r.offsetWidth);
}, ske = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollHeight - t.offsetHeight;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollHeight, n.offsetHeight, r.clientHeight, r.scrollHeight, r.offsetHeight);
}, ake = function e(t, n, r) {
  var o = n.data;
  if (!n.ignoreCancelEvents && o.cancel) {
    Ui.default.registered.end && Ui.default.registered.end(o.to, o.target, o.currentPositionY);
    return;
  }
  if (o.delta = Math.round(o.targetPosition - o.startPosition), o.start === null && (o.start = r), o.progress = r - o.start, o.percent = o.progress >= o.duration ? 1 : t(o.progress / o.duration), o.currentPosition = o.startPosition + Math.ceil(o.delta * o.percent), o.containerElement && o.containerElement !== document && o.containerElement !== document.body ? n.horizontal ? o.containerElement.scrollLeft = o.currentPosition : o.containerElement.scrollTop = o.currentPosition : n.horizontal ? window.scrollTo(o.currentPosition, 0) : window.scrollTo(0, o.currentPosition), o.percent < 1) {
    var i = e.bind(null, t, n);
    Lx.call(window, i);
    return;
  }
  Ui.default.registered.end && Ui.default.registered.end(o.to, o.target, o.currentPosition);
}, t1 = function(e) {
  e.data.containerElement = e ? e.containerId ? document.getElementById(e.containerId) : e.container && e.container.nodeType ? e.container : document : null;
}, bd = function(e, t, n, r) {
  t.data = t.data || s8(), window.clearTimeout(t.data.delayTimeout);
  var o = function() {
    t.data.cancel = !0;
  };
  if (tke.default.subscribe(o), t1(t), t.data.start = null, t.data.cancel = !1, t.data.startPosition = t.horizontal ? a8(t) : l8(t), t.data.targetPosition = t.absolute ? e : e + t.data.startPosition, t.data.startPosition === t.data.targetPosition) {
    Ui.default.registered.end && Ui.default.registered.end(t.data.to, t.data.target, t.data.currentPosition);
    return;
  }
  t.data.delta = Math.round(t.data.targetPosition - t.data.startPosition), t.data.duration = rke(t.duration)(t.data.delta), t.data.duration = isNaN(parseFloat(t.data.duration)) ? 1e3 : parseFloat(t.data.duration), t.data.to = n, t.data.target = r;
  var i = i8(t), a = ake.bind(null, i, t);
  if (t && t.delay > 0) {
    t.data.delayTimeout = window.setTimeout(function() {
      Ui.default.registered.begin && Ui.default.registered.begin(t.data.to, t.data.target), Lx.call(window, a);
    }, t.delay);
    return;
  }
  Ui.default.registered.begin && Ui.default.registered.begin(t.data.to, t.data.target), Lx.call(window, a);
}, Sy = function(e) {
  return e = YEe({}, e), e.data = e.data || s8(), e.absolute = !0, e;
}, lke = function(e) {
  bd(0, Sy(e));
}, uke = function(e, t) {
  bd(e, Sy(t));
}, cke = function(e) {
  e = Sy(e), t1(e), bd(e.horizontal ? ike(e) : ske(e), e);
}, pke = function(e, t) {
  t = Sy(t), t1(t);
  var n = t.horizontal ? a8(t) : l8(t);
  bd(e + n, t);
};
_y.default = {
  animateTopScroll: bd,
  getAnimationType: i8,
  scrollToTop: lke,
  scrollToBottom: cke,
  scrollTo: uke,
  scrollMore: pke
};
Object.defineProperty(Lu, "__esModule", {
  value: !0
});
var dke = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, fke = vd, hke = n1(fke), gke = _y, mke = n1(gke), vke = yd, th = n1(vke);
function n1(e) {
  return e && e.__esModule ? e : { default: e };
}
var nh = {}, xN = void 0;
Lu.default = {
  unmount: function() {
    nh = {};
  },
  register: function(e, t) {
    nh[e] = t;
  },
  unregister: function(e) {
    delete nh[e];
  },
  get: function(e) {
    return nh[e] || document.getElementById(e) || document.getElementsByName(e)[0] || document.getElementsByClassName(e)[0];
  },
  setActiveLink: function(e) {
    return xN = e;
  },
  getActiveLink: function() {
    return xN;
  },
  scrollTo: function(e, t) {
    var n = this.get(e);
    if (!n) {
      console.warn("target Element not found");
      return;
    }
    t = dke({}, t, { absolute: !1 });
    var r = t.containerId, o = t.container, i = void 0;
    r ? i = document.getElementById(r) : o && o.nodeType ? i = o : i = document, t.absolute = !0;
    var a = t.horizontal, s = hke.default.scrollOffset(i, n, a) + (t.offset || 0);
    if (!t.smooth) {
      th.default.registered.begin && th.default.registered.begin(e, n), i === document ? t.horizontal ? window.scrollTo(s, 0) : window.scrollTo(0, s) : i.scrollTop = s, th.default.registered.end && th.default.registered.end(e, n);
      return;
    }
    mke.default.animateTopScroll(s, t, e, n);
  }
};
var _x = { exports: {} }, tw = { exports: {} }, Cn = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var ON;
function yke() {
  if (ON) return Cn;
  ON = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, h = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, m = e ? Symbol.for("react.block") : 60121, g = e ? Symbol.for("react.fundamental") : 60117, E = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
  function M(y) {
    if (typeof y == "object" && y !== null) {
      var C = y.$$typeof;
      switch (C) {
        case t:
          switch (y = y.type, y) {
            case l:
            case u:
            case r:
            case i:
            case o:
            case p:
              return y;
            default:
              switch (y = y && y.$$typeof, y) {
                case s:
                case c:
                case f:
                case h:
                case a:
                  return y;
                default:
                  return C;
              }
          }
        case n:
          return C;
      }
    }
  }
  function x(y) {
    return M(y) === u;
  }
  return Cn.AsyncMode = l, Cn.ConcurrentMode = u, Cn.ContextConsumer = s, Cn.ContextProvider = a, Cn.Element = t, Cn.ForwardRef = c, Cn.Fragment = r, Cn.Lazy = f, Cn.Memo = h, Cn.Portal = n, Cn.Profiler = i, Cn.StrictMode = o, Cn.Suspense = p, Cn.isAsyncMode = function(y) {
    return x(y) || M(y) === l;
  }, Cn.isConcurrentMode = x, Cn.isContextConsumer = function(y) {
    return M(y) === s;
  }, Cn.isContextProvider = function(y) {
    return M(y) === a;
  }, Cn.isElement = function(y) {
    return typeof y == "object" && y !== null && y.$$typeof === t;
  }, Cn.isForwardRef = function(y) {
    return M(y) === c;
  }, Cn.isFragment = function(y) {
    return M(y) === r;
  }, Cn.isLazy = function(y) {
    return M(y) === f;
  }, Cn.isMemo = function(y) {
    return M(y) === h;
  }, Cn.isPortal = function(y) {
    return M(y) === n;
  }, Cn.isProfiler = function(y) {
    return M(y) === i;
  }, Cn.isStrictMode = function(y) {
    return M(y) === o;
  }, Cn.isSuspense = function(y) {
    return M(y) === p;
  }, Cn.isValidElementType = function(y) {
    return typeof y == "string" || typeof y == "function" || y === r || y === u || y === i || y === o || y === p || y === d || typeof y == "object" && y !== null && (y.$$typeof === f || y.$$typeof === h || y.$$typeof === a || y.$$typeof === s || y.$$typeof === c || y.$$typeof === g || y.$$typeof === E || y.$$typeof === w || y.$$typeof === m);
  }, Cn.typeOf = M, Cn;
}
var Dn = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var EN;
function bke() {
  return EN || (EN = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, h = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, m = e ? Symbol.for("react.block") : 60121, g = e ? Symbol.for("react.fundamental") : 60117, E = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
    function M(R) {
      return typeof R == "string" || typeof R == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      R === r || R === u || R === i || R === o || R === p || R === d || typeof R == "object" && R !== null && (R.$$typeof === f || R.$$typeof === h || R.$$typeof === a || R.$$typeof === s || R.$$typeof === c || R.$$typeof === g || R.$$typeof === E || R.$$typeof === w || R.$$typeof === m);
    }
    function x(R) {
      if (typeof R == "object" && R !== null) {
        var ue = R.$$typeof;
        switch (ue) {
          case t:
            var fe = R.type;
            switch (fe) {
              case l:
              case u:
              case r:
              case i:
              case o:
              case p:
                return fe;
              default:
                var oe = fe && fe.$$typeof;
                switch (oe) {
                  case s:
                  case c:
                  case f:
                  case h:
                  case a:
                    return oe;
                  default:
                    return ue;
                }
            }
          case n:
            return ue;
        }
      }
    }
    var y = l, C = u, P = s, F = a, L = t, N = c, I = r, H = f, V = h, z = n, q = i, K = o, J = p, te = !1;
    function ee(R) {
      return te || (te = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), _(R) || x(R) === l;
    }
    function _(R) {
      return x(R) === u;
    }
    function D(R) {
      return x(R) === s;
    }
    function $(R) {
      return x(R) === a;
    }
    function S(R) {
      return typeof R == "object" && R !== null && R.$$typeof === t;
    }
    function W(R) {
      return x(R) === c;
    }
    function O(R) {
      return x(R) === r;
    }
    function T(R) {
      return x(R) === f;
    }
    function U(R) {
      return x(R) === h;
    }
    function j(R) {
      return x(R) === n;
    }
    function Z(R) {
      return x(R) === i;
    }
    function A(R) {
      return x(R) === o;
    }
    function Q(R) {
      return x(R) === p;
    }
    Dn.AsyncMode = y, Dn.ConcurrentMode = C, Dn.ContextConsumer = P, Dn.ContextProvider = F, Dn.Element = L, Dn.ForwardRef = N, Dn.Fragment = I, Dn.Lazy = H, Dn.Memo = V, Dn.Portal = z, Dn.Profiler = q, Dn.StrictMode = K, Dn.Suspense = J, Dn.isAsyncMode = ee, Dn.isConcurrentMode = _, Dn.isContextConsumer = D, Dn.isContextProvider = $, Dn.isElement = S, Dn.isForwardRef = W, Dn.isFragment = O, Dn.isLazy = T, Dn.isMemo = U, Dn.isPortal = j, Dn.isProfiler = Z, Dn.isStrictMode = A, Dn.isSuspense = Q, Dn.isValidElementType = M, Dn.typeOf = x;
  }()), Dn;
}
var kN;
function u8() {
  return kN || (kN = 1, process.env.NODE_ENV === "production" ? tw.exports = yke() : tw.exports = bke()), tw.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var nw, LN;
function wke() {
  if (LN) return nw;
  LN = 1;
  var e = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, n = Object.prototype.propertyIsEnumerable;
  function r(i) {
    if (i == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(i);
  }
  function o() {
    try {
      if (!Object.assign)
        return !1;
      var i = new String("abc");
      if (i[5] = "de", Object.getOwnPropertyNames(i)[0] === "5")
        return !1;
      for (var a = {}, s = 0; s < 10; s++)
        a["_" + String.fromCharCode(s)] = s;
      var l = Object.getOwnPropertyNames(a).map(function(c) {
        return a[c];
      });
      if (l.join("") !== "0123456789")
        return !1;
      var u = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(c) {
        u[c] = c;
      }), Object.keys(Object.assign({}, u)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return nw = o() ? Object.assign : function(i, a) {
    for (var s, l = r(i), u, c = 1; c < arguments.length; c++) {
      s = Object(arguments[c]);
      for (var p in s)
        t.call(s, p) && (l[p] = s[p]);
      if (e) {
        u = e(s);
        for (var d = 0; d < u.length; d++)
          n.call(s, u[d]) && (l[u[d]] = s[u[d]]);
      }
    }
    return l;
  }, nw;
}
var rw, _N;
function r1() {
  if (_N) return rw;
  _N = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return rw = e, rw;
}
var PN, SN;
function c8() {
  return SN || (SN = 1, PN = Function.call.bind(Object.prototype.hasOwnProperty)), PN;
}
var ow, MN;
function Cke() {
  if (MN) return ow;
  MN = 1;
  var e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = r1(), n = {}, r = c8();
    e = function(i) {
      var a = "Warning: " + i;
      typeof console < "u" && console.error(a);
      try {
        throw new Error(a);
      } catch {
      }
    };
  }
  function o(i, a, s, l, u) {
    if (process.env.NODE_ENV !== "production") {
      for (var c in i)
        if (r(i, c)) {
          var p;
          try {
            if (typeof i[c] != "function") {
              var d = Error(
                (l || "React class") + ": " + s + " type `" + c + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof i[c] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw d.name = "Invariant Violation", d;
            }
            p = i[c](a, c, l, s, null, t);
          } catch (f) {
            p = f;
          }
          if (p && !(p instanceof Error) && e(
            (l || "React class") + ": type specification of " + s + " `" + c + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof p + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), p instanceof Error && !(p.message in n)) {
            n[p.message] = !0;
            var h = u ? u() : "";
            e(
              "Failed " + s + " type: " + p.message + (h ?? "")
            );
          }
        }
    }
  }
  return o.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (n = {});
  }, ow = o, ow;
}
var iw, DN;
function xke() {
  if (DN) return iw;
  DN = 1;
  var e = u8(), t = wke(), n = r1(), r = c8(), o = Cke(), i = function() {
  };
  process.env.NODE_ENV !== "production" && (i = function(s) {
    var l = "Warning: " + s;
    typeof console < "u" && console.error(l);
    try {
      throw new Error(l);
    } catch {
    }
  });
  function a() {
    return null;
  }
  return iw = function(s, l) {
    var u = typeof Symbol == "function" && Symbol.iterator, c = "@@iterator";
    function p(_) {
      var D = _ && (u && _[u] || _[c]);
      if (typeof D == "function")
        return D;
    }
    var d = "<<anonymous>>", h = {
      array: E("array"),
      bigint: E("bigint"),
      bool: E("boolean"),
      func: E("function"),
      number: E("number"),
      object: E("object"),
      string: E("string"),
      symbol: E("symbol"),
      any: w(),
      arrayOf: M,
      element: x(),
      elementType: y(),
      instanceOf: C,
      node: N(),
      objectOf: F,
      oneOf: P,
      oneOfType: L,
      shape: H,
      exact: V
    };
    function f(_, D) {
      return _ === D ? _ !== 0 || 1 / _ === 1 / D : _ !== _ && D !== D;
    }
    function m(_, D) {
      this.message = _, this.data = D && typeof D == "object" ? D : {}, this.stack = "";
    }
    m.prototype = Error.prototype;
    function g(_) {
      if (process.env.NODE_ENV !== "production")
        var D = {}, $ = 0;
      function S(O, T, U, j, Z, A, Q) {
        if (j = j || d, A = A || U, Q !== n) {
          if (l) {
            var R = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw R.name = "Invariant Violation", R;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var ue = j + ":" + U;
            !D[ue] && // Avoid spamming the console because they are often not actionable except for lib authors
            $ < 3 && (i(
              "You are manually calling a React.PropTypes validation function for the `" + A + "` prop on `" + j + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), D[ue] = !0, $++);
          }
        }
        return T[U] == null ? O ? T[U] === null ? new m("The " + Z + " `" + A + "` is marked as required " + ("in `" + j + "`, but its value is `null`.")) : new m("The " + Z + " `" + A + "` is marked as required in " + ("`" + j + "`, but its value is `undefined`.")) : null : _(T, U, j, Z, A);
      }
      var W = S.bind(null, !1);
      return W.isRequired = S.bind(null, !0), W;
    }
    function E(_) {
      function D($, S, W, O, T, U) {
        var j = $[S], Z = K(j);
        if (Z !== _) {
          var A = J(j);
          return new m(
            "Invalid " + O + " `" + T + "` of type " + ("`" + A + "` supplied to `" + W + "`, expected ") + ("`" + _ + "`."),
            { expectedType: _ }
          );
        }
        return null;
      }
      return g(D);
    }
    function w() {
      return g(a);
    }
    function M(_) {
      function D($, S, W, O, T) {
        if (typeof _ != "function")
          return new m("Property `" + T + "` of component `" + W + "` has invalid PropType notation inside arrayOf.");
        var U = $[S];
        if (!Array.isArray(U)) {
          var j = K(U);
          return new m("Invalid " + O + " `" + T + "` of type " + ("`" + j + "` supplied to `" + W + "`, expected an array."));
        }
        for (var Z = 0; Z < U.length; Z++) {
          var A = _(U, Z, W, O, T + "[" + Z + "]", n);
          if (A instanceof Error)
            return A;
        }
        return null;
      }
      return g(D);
    }
    function x() {
      function _(D, $, S, W, O) {
        var T = D[$];
        if (!s(T)) {
          var U = K(T);
          return new m("Invalid " + W + " `" + O + "` of type " + ("`" + U + "` supplied to `" + S + "`, expected a single ReactElement."));
        }
        return null;
      }
      return g(_);
    }
    function y() {
      function _(D, $, S, W, O) {
        var T = D[$];
        if (!e.isValidElementType(T)) {
          var U = K(T);
          return new m("Invalid " + W + " `" + O + "` of type " + ("`" + U + "` supplied to `" + S + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return g(_);
    }
    function C(_) {
      function D($, S, W, O, T) {
        if (!($[S] instanceof _)) {
          var U = _.name || d, j = ee($[S]);
          return new m("Invalid " + O + " `" + T + "` of type " + ("`" + j + "` supplied to `" + W + "`, expected ") + ("instance of `" + U + "`."));
        }
        return null;
      }
      return g(D);
    }
    function P(_) {
      if (!Array.isArray(_))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? i(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : i("Invalid argument supplied to oneOf, expected an array.")), a;
      function D($, S, W, O, T) {
        for (var U = $[S], j = 0; j < _.length; j++)
          if (f(U, _[j]))
            return null;
        var Z = JSON.stringify(_, function(A, Q) {
          var R = J(Q);
          return R === "symbol" ? String(Q) : Q;
        });
        return new m("Invalid " + O + " `" + T + "` of value `" + String(U) + "` " + ("supplied to `" + W + "`, expected one of " + Z + "."));
      }
      return g(D);
    }
    function F(_) {
      function D($, S, W, O, T) {
        if (typeof _ != "function")
          return new m("Property `" + T + "` of component `" + W + "` has invalid PropType notation inside objectOf.");
        var U = $[S], j = K(U);
        if (j !== "object")
          return new m("Invalid " + O + " `" + T + "` of type " + ("`" + j + "` supplied to `" + W + "`, expected an object."));
        for (var Z in U)
          if (r(U, Z)) {
            var A = _(U, Z, W, O, T + "." + Z, n);
            if (A instanceof Error)
              return A;
          }
        return null;
      }
      return g(D);
    }
    function L(_) {
      if (!Array.isArray(_))
        return process.env.NODE_ENV !== "production" && i("Invalid argument supplied to oneOfType, expected an instance of array."), a;
      for (var D = 0; D < _.length; D++) {
        var $ = _[D];
        if (typeof $ != "function")
          return i(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + te($) + " at index " + D + "."
          ), a;
      }
      function S(W, O, T, U, j) {
        for (var Z = [], A = 0; A < _.length; A++) {
          var Q = _[A], R = Q(W, O, T, U, j, n);
          if (R == null)
            return null;
          R.data && r(R.data, "expectedType") && Z.push(R.data.expectedType);
        }
        var ue = Z.length > 0 ? ", expected one of type [" + Z.join(", ") + "]" : "";
        return new m("Invalid " + U + " `" + j + "` supplied to " + ("`" + T + "`" + ue + "."));
      }
      return g(S);
    }
    function N() {
      function _(D, $, S, W, O) {
        return z(D[$]) ? null : new m("Invalid " + W + " `" + O + "` supplied to " + ("`" + S + "`, expected a ReactNode."));
      }
      return g(_);
    }
    function I(_, D, $, S, W) {
      return new m(
        (_ || "React class") + ": " + D + " type `" + $ + "." + S + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + W + "`."
      );
    }
    function H(_) {
      function D($, S, W, O, T) {
        var U = $[S], j = K(U);
        if (j !== "object")
          return new m("Invalid " + O + " `" + T + "` of type `" + j + "` " + ("supplied to `" + W + "`, expected `object`."));
        for (var Z in _) {
          var A = _[Z];
          if (typeof A != "function")
            return I(W, O, T, Z, J(A));
          var Q = A(U, Z, W, O, T + "." + Z, n);
          if (Q)
            return Q;
        }
        return null;
      }
      return g(D);
    }
    function V(_) {
      function D($, S, W, O, T) {
        var U = $[S], j = K(U);
        if (j !== "object")
          return new m("Invalid " + O + " `" + T + "` of type `" + j + "` " + ("supplied to `" + W + "`, expected `object`."));
        var Z = t({}, $[S], _);
        for (var A in Z) {
          var Q = _[A];
          if (r(_, A) && typeof Q != "function")
            return I(W, O, T, A, J(Q));
          if (!Q)
            return new m(
              "Invalid " + O + " `" + T + "` key `" + A + "` supplied to `" + W + "`.\nBad object: " + JSON.stringify($[S], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(_), null, "  ")
            );
          var R = Q(U, A, W, O, T + "." + A, n);
          if (R)
            return R;
        }
        return null;
      }
      return g(D);
    }
    function z(_) {
      switch (typeof _) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !_;
        case "object":
          if (Array.isArray(_))
            return _.every(z);
          if (_ === null || s(_))
            return !0;
          var D = p(_);
          if (D) {
            var $ = D.call(_), S;
            if (D !== _.entries) {
              for (; !(S = $.next()).done; )
                if (!z(S.value))
                  return !1;
            } else
              for (; !(S = $.next()).done; ) {
                var W = S.value;
                if (W && !z(W[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function q(_, D) {
      return _ === "symbol" ? !0 : D ? D["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && D instanceof Symbol : !1;
    }
    function K(_) {
      var D = typeof _;
      return Array.isArray(_) ? "array" : _ instanceof RegExp ? "object" : q(D, _) ? "symbol" : D;
    }
    function J(_) {
      if (typeof _ > "u" || _ === null)
        return "" + _;
      var D = K(_);
      if (D === "object") {
        if (_ instanceof Date)
          return "date";
        if (_ instanceof RegExp)
          return "regexp";
      }
      return D;
    }
    function te(_) {
      var D = J(_);
      switch (D) {
        case "array":
        case "object":
          return "an " + D;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + D;
        default:
          return D;
      }
    }
    function ee(_) {
      return !_.constructor || !_.constructor.name ? d : _.constructor.name;
    }
    return h.checkPropTypes = o, h.resetWarningCache = o.resetWarningCache, h.PropTypes = h, h;
  }, iw;
}
var sw, TN;
function Oke() {
  if (TN) return sw;
  TN = 1;
  var e = r1();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, sw = function() {
    function r(a, s, l, u, c, p) {
      if (p !== e) {
        var d = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw d.name = "Invariant Violation", d;
      }
    }
    r.isRequired = r;
    function o() {
      return r;
    }
    var i = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: o,
      element: r,
      elementType: r,
      instanceOf: o,
      node: r,
      objectOf: o,
      oneOf: o,
      oneOfType: o,
      shape: o,
      exact: o,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return i.PropTypes = i, i;
  }, sw;
}
if (process.env.NODE_ENV !== "production") {
  var Eke = u8(), kke = !0;
  _x.exports = xke()(Eke.isElement, kke);
} else
  _x.exports = Oke()();
var My = _x.exports, Dy = {};
Object.defineProperty(Dy, "__esModule", {
  value: !0
});
var Lke = vd, aw = _ke(Lke);
function _ke(e) {
  return e && e.__esModule ? e : { default: e };
}
var Pke = {
  mountFlag: !1,
  initialized: !1,
  scroller: null,
  containers: {},
  mount: function(e) {
    this.scroller = e, this.handleHashChange = this.handleHashChange.bind(this), window.addEventListener("hashchange", this.handleHashChange), this.initStateFromHash(), this.mountFlag = !0;
  },
  mapContainer: function(e, t) {
    this.containers[e] = t;
  },
  isMounted: function() {
    return this.mountFlag;
  },
  isInitialized: function() {
    return this.initialized;
  },
  initStateFromHash: function() {
    var e = this, t = this.getHash();
    t ? window.setTimeout(function() {
      e.scrollTo(t, !0), e.initialized = !0;
    }, 10) : this.initialized = !0;
  },
  scrollTo: function(e, t) {
    var n = this.scroller, r = n.get(e);
    if (r && (t || e !== n.getActiveLink())) {
      var o = this.containers[e] || document;
      n.scrollTo(e, { container: o });
    }
  },
  getHash: function() {
    return aw.default.getHash();
  },
  changeHash: function(e, t) {
    this.isInitialized() && aw.default.getHash() !== e && aw.default.updateHash(e, t);
  },
  handleHashChange: function() {
    this.scrollTo(this.getHash());
  },
  unmount: function() {
    this.scroller = null, this.containers = null, window.removeEventListener("hashchange", this.handleHashChange);
  }
};
Dy.default = Pke;
Object.defineProperty(hd, "__esModule", {
  value: !0
});
var rh = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, Ske = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), Mke = ke, jN = wd(Mke), Dke = gd, oh = wd(Dke), Tke = Lu, jke = wd(Tke), Ake = My, gr = wd(Ake), Bke = Dy, zs = wd(Bke);
function wd(e) {
  return e && e.__esModule ? e : { default: e };
}
function Ike(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Rke(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function Nke(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var AN = {
  to: gr.default.string.isRequired,
  containerId: gr.default.string,
  container: gr.default.object,
  activeClass: gr.default.string,
  activeStyle: gr.default.object,
  spy: gr.default.bool,
  horizontal: gr.default.bool,
  smooth: gr.default.oneOfType([gr.default.bool, gr.default.string]),
  offset: gr.default.number,
  delay: gr.default.number,
  isDynamic: gr.default.bool,
  onClick: gr.default.func,
  duration: gr.default.oneOfType([gr.default.number, gr.default.func]),
  absolute: gr.default.bool,
  onSetActive: gr.default.func,
  onSetInactive: gr.default.func,
  ignoreCancelEvents: gr.default.bool,
  hashSpy: gr.default.bool,
  saveHashHistory: gr.default.bool,
  spyThrottle: gr.default.number
};
hd.default = function(e, t) {
  var n = t || jke.default, r = function(i) {
    Nke(a, i);
    function a(s) {
      Ike(this, a);
      var l = Rke(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
      return o.call(l), l.state = {
        active: !1
      }, l.beforeUnmountCallbacks = [], l;
    }
    return Ske(a, [{
      key: "getScrollSpyContainer",
      value: function() {
        var s = this.props.containerId, l = this.props.container;
        return s && !l ? document.getElementById(s) : l && l.nodeType ? l : document;
      }
    }, {
      key: "componentDidMount",
      value: function() {
        if (this.props.spy || this.props.hashSpy) {
          var s = this.getScrollSpyContainer();
          if (!oh.default.isMounted(s)) {
            var l = oh.default.mount(s, this.props.spyThrottle);
            this.beforeUnmountCallbacks.push(l);
          }
          this.props.hashSpy && (zs.default.isMounted() || zs.default.mount(n), zs.default.mapContainer(this.props.to, s)), oh.default.addSpyHandler(this.spyHandler, s), this.setState({
            container: s
          });
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        oh.default.unmount(this.stateHandler, this.spyHandler), this.beforeUnmountCallbacks.forEach(function(s) {
          return s();
        });
      }
    }, {
      key: "render",
      value: function() {
        var s = "";
        this.state && this.state.active ? s = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : s = this.props.className;
        var l = {};
        this.state && this.state.active ? l = rh({}, this.props.style, this.props.activeStyle) : l = rh({}, this.props.style);
        var u = rh({}, this.props);
        for (var c in AN)
          u.hasOwnProperty(c) && delete u[c];
        return u.className = s, u.style = l, u.onClick = this.handleClick, jN.default.createElement(e, u);
      }
    }]), a;
  }(jN.default.PureComponent), o = function() {
    var i = this;
    this.scrollTo = function(a, s) {
      n.scrollTo(a, rh({}, i.state, s));
    }, this.handleClick = function(a) {
      i.props.onClick && i.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), i.scrollTo(i.props.to, i.props);
    }, this.spyHandler = function(a, s) {
      var l = i.getScrollSpyContainer();
      if (!(zs.default.isMounted() && !zs.default.isInitialized())) {
        var u = i.props.horizontal, c = i.props.to, p = null, d = void 0, h = void 0;
        if (u) {
          var f = 0, m = 0, g = 0;
          if (l.getBoundingClientRect) {
            var E = l.getBoundingClientRect();
            g = E.left;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var w = p.getBoundingClientRect();
            f = w.left - g + a, m = f + w.width;
          }
          var M = a - i.props.offset;
          d = M >= Math.floor(f) && M < Math.floor(m), h = M < Math.floor(f) || M >= Math.floor(m);
        } else {
          var x = 0, y = 0, C = 0;
          if (l.getBoundingClientRect) {
            var P = l.getBoundingClientRect();
            C = P.top;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var F = p.getBoundingClientRect();
            x = F.top - C + s, y = x + F.height;
          }
          var L = s - i.props.offset;
          d = L >= Math.floor(x) && L < Math.floor(y), h = L < Math.floor(x) || L >= Math.floor(y);
        }
        var N = n.getActiveLink();
        if (h) {
          if (c === N && n.setActiveLink(void 0), i.props.hashSpy && zs.default.getHash() === c) {
            var I = i.props.saveHashHistory, H = I === void 0 ? !1 : I;
            zs.default.changeHash("", H);
          }
          i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive(c, p));
        }
        if (d && (N !== c || i.state.active === !1)) {
          n.setActiveLink(c);
          var V = i.props.saveHashHistory, z = V === void 0 ? !1 : V;
          i.props.hashSpy && zs.default.changeHash(c, z), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(c, p));
        }
      }
    };
  };
  return r.propTypes = AN, r.defaultProps = { offset: 0 }, r;
};
Object.defineProperty(Jk, "__esModule", {
  value: !0
});
var Fke = ke, BN = p8(Fke), zke = hd, Uke = p8(zke);
function p8(e) {
  return e && e.__esModule ? e : { default: e };
}
function $ke(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function IN(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function Hke(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var Wke = function(e) {
  Hke(t, e);
  function t() {
    var n, r, o, i;
    $ke(this, t);
    for (var a = arguments.length, s = Array(a), l = 0; l < a; l++)
      s[l] = arguments[l];
    return i = (r = (o = IN(this, (n = t.__proto__ || Object.getPrototypeOf(t)).call.apply(n, [this].concat(s))), o), o.render = function() {
      return BN.default.createElement(
        "a",
        o.props,
        o.props.children
      );
    }, r), IN(o, i);
  }
  return t;
}(BN.default.Component);
Jk.default = (0, Uke.default)(Wke);
var o1 = {};
Object.defineProperty(o1, "__esModule", {
  value: !0
});
var Vke = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), qke = ke, RN = d8(qke), Zke = hd, Gke = d8(Zke);
function d8(e) {
  return e && e.__esModule ? e : { default: e };
}
function Xke(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Kke(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function Yke(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var Jke = function(e) {
  Yke(t, e);
  function t() {
    return Xke(this, t), Kke(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return Vke(t, [{
    key: "render",
    value: function() {
      return RN.default.createElement(
        "button",
        this.props,
        this.props.children
      );
    }
  }]), t;
}(RN.default.Component);
o1.default = (0, Gke.default)(Jke);
var i1 = {}, Ty = {};
Object.defineProperty(Ty, "__esModule", {
  value: !0
});
var Qke = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, e1e = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), t1e = ke, NN = jy(t1e), n1e = Rl;
jy(n1e);
var r1e = Lu, FN = jy(r1e), o1e = My, zN = jy(o1e);
function jy(e) {
  return e && e.__esModule ? e : { default: e };
}
function i1e(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function s1e(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function a1e(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
Ty.default = function(e) {
  var t = function(n) {
    a1e(r, n);
    function r(o) {
      i1e(this, r);
      var i = s1e(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
      return i.childBindings = {
        domNode: null
      }, i;
    }
    return e1e(r, [{
      key: "componentDidMount",
      value: function() {
        if (typeof window > "u")
          return !1;
        this.registerElems(this.props.name);
      }
    }, {
      key: "componentDidUpdate",
      value: function(o) {
        this.props.name !== o.name && this.registerElems(this.props.name);
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        if (typeof window > "u")
          return !1;
        FN.default.unregister(this.props.name);
      }
    }, {
      key: "registerElems",
      value: function(o) {
        FN.default.register(o, this.childBindings.domNode);
      }
    }, {
      key: "render",
      value: function() {
        return NN.default.createElement(e, Qke({}, this.props, { parentBindings: this.childBindings }));
      }
    }]), r;
  }(NN.default.Component);
  return t.propTypes = {
    name: zN.default.string,
    id: zN.default.string
  }, t;
};
Object.defineProperty(i1, "__esModule", {
  value: !0
});
var UN = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, l1e = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), u1e = ke, $N = s1(u1e), c1e = Ty, p1e = s1(c1e), d1e = My, HN = s1(d1e);
function s1(e) {
  return e && e.__esModule ? e : { default: e };
}
function f1e(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function h1e(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function g1e(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var f8 = function(e) {
  g1e(t, e);
  function t() {
    return f1e(this, t), h1e(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return l1e(t, [{
    key: "render",
    value: function() {
      var n = this, r = UN({}, this.props);
      return delete r.name, r.parentBindings && delete r.parentBindings, $N.default.createElement(
        "div",
        UN({}, r, { ref: function(o) {
          n.props.parentBindings.domNode = o;
        } }),
        this.props.children
      );
    }
  }]), t;
}($N.default.Component);
f8.propTypes = {
  name: HN.default.string,
  id: HN.default.string
};
i1.default = (0, p1e.default)(f8);
var lw = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, WN = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}();
function VN(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function qN(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function ZN(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var ih = ke, $a = gd, uw = Lu, Tr = My, Us = Dy, GN = {
  to: Tr.string.isRequired,
  containerId: Tr.string,
  container: Tr.object,
  activeClass: Tr.string,
  spy: Tr.bool,
  smooth: Tr.oneOfType([Tr.bool, Tr.string]),
  offset: Tr.number,
  delay: Tr.number,
  isDynamic: Tr.bool,
  onClick: Tr.func,
  duration: Tr.oneOfType([Tr.number, Tr.func]),
  absolute: Tr.bool,
  onSetActive: Tr.func,
  onSetInactive: Tr.func,
  ignoreCancelEvents: Tr.bool,
  hashSpy: Tr.bool,
  spyThrottle: Tr.number
}, m1e = {
  Scroll: function(e, t) {
    console.warn("Helpers.Scroll is deprecated since v1.7.0");
    var n = t || uw, r = function(i) {
      ZN(a, i);
      function a(s) {
        VN(this, a);
        var l = qN(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
        return o.call(l), l.state = {
          active: !1
        }, l;
      }
      return WN(a, [{
        key: "getScrollSpyContainer",
        value: function() {
          var s = this.props.containerId, l = this.props.container;
          return s ? document.getElementById(s) : l && l.nodeType ? l : document;
        }
      }, {
        key: "componentDidMount",
        value: function() {
          if (this.props.spy || this.props.hashSpy) {
            var s = this.getScrollSpyContainer();
            $a.isMounted(s) || $a.mount(s, this.props.spyThrottle), this.props.hashSpy && (Us.isMounted() || Us.mount(n), Us.mapContainer(this.props.to, s)), this.props.spy && $a.addStateHandler(this.stateHandler), $a.addSpyHandler(this.spyHandler, s), this.setState({
              container: s
            });
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          $a.unmount(this.stateHandler, this.spyHandler);
        }
      }, {
        key: "render",
        value: function() {
          var s = "";
          this.state && this.state.active ? s = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : s = this.props.className;
          var l = lw({}, this.props);
          for (var u in GN)
            l.hasOwnProperty(u) && delete l[u];
          return l.className = s, l.onClick = this.handleClick, ih.createElement(e, l);
        }
      }]), a;
    }(ih.Component), o = function() {
      var i = this;
      this.scrollTo = function(a, s) {
        n.scrollTo(a, lw({}, i.state, s));
      }, this.handleClick = function(a) {
        i.props.onClick && i.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), i.scrollTo(i.props.to, i.props);
      }, this.stateHandler = function() {
        n.getActiveLink() !== i.props.to && (i.state !== null && i.state.active && i.props.onSetInactive && i.props.onSetInactive(), i.setState({ active: !1 }));
      }, this.spyHandler = function(a) {
        var s = i.getScrollSpyContainer();
        if (!(Us.isMounted() && !Us.isInitialized())) {
          var l = i.props.to, u = null, c = 0, p = 0, d = 0;
          if (s.getBoundingClientRect) {
            var h = s.getBoundingClientRect();
            d = h.top;
          }
          if (!u || i.props.isDynamic) {
            if (u = n.get(l), !u)
              return;
            var f = u.getBoundingClientRect();
            c = f.top - d + a, p = c + f.height;
          }
          var m = a - i.props.offset, g = m >= Math.floor(c) && m < Math.floor(p), E = m < Math.floor(c) || m >= Math.floor(p), w = n.getActiveLink();
          if (E)
            return l === w && n.setActiveLink(void 0), i.props.hashSpy && Us.getHash() === l && Us.changeHash(), i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive()), $a.updateStates();
          if (g && w !== l)
            return n.setActiveLink(l), i.props.hashSpy && Us.changeHash(l), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(l)), $a.updateStates();
        }
      };
    };
    return r.propTypes = GN, r.defaultProps = { offset: 0 }, r;
  },
  Element: function(e) {
    console.warn("Helpers.Element is deprecated since v1.7.0");
    var t = function(n) {
      ZN(r, n);
      function r(o) {
        VN(this, r);
        var i = qN(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
        return i.childBindings = {
          domNode: null
        }, i;
      }
      return WN(r, [{
        key: "componentDidMount",
        value: function() {
          if (typeof window > "u")
            return !1;
          this.registerElems(this.props.name);
        }
      }, {
        key: "componentDidUpdate",
        value: function(o) {
          this.props.name !== o.name && this.registerElems(this.props.name);
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          if (typeof window > "u")
            return !1;
          uw.unregister(this.props.name);
        }
      }, {
        key: "registerElems",
        value: function(o) {
          uw.register(o, this.childBindings.domNode);
        }
      }, {
        key: "render",
        value: function() {
          return ih.createElement(e, lw({}, this.props, { parentBindings: this.childBindings }));
        }
      }]), r;
    }(ih.Component);
    return t.propTypes = {
      name: Tr.string,
      id: Tr.string
    }, t;
  }
}, v1e = m1e;
Object.defineProperty(Hr, "__esModule", {
  value: !0
});
Hr.Helpers = Hr.ScrollElement = Hr.ScrollLink = Hr.animateScroll = Hr.scrollSpy = Hr.Events = Hr.scroller = Hr.Element = Hr.Button = Hr.Link = void 0;
var y1e = Jk, h8 = Qi(y1e), b1e = o1, g8 = Qi(b1e), w1e = i1, m8 = Qi(w1e), C1e = Lu, v8 = Qi(C1e), x1e = yd, y8 = Qi(x1e), O1e = gd, b8 = Qi(O1e), E1e = _y, w8 = Qi(E1e), k1e = hd, C8 = Qi(k1e), L1e = Ty, x8 = Qi(L1e), _1e = v1e, O8 = Qi(_1e);
function Qi(e) {
  return e && e.__esModule ? e : { default: e };
}
Hr.Link = h8.default;
Hr.Button = g8.default;
Hr.Element = m8.default;
Hr.scroller = v8.default;
Hr.Events = y8.default;
Hr.scrollSpy = b8.default;
Hr.animateScroll = w8.default;
Hr.ScrollLink = C8.default;
Hr.ScrollElement = x8.default;
Hr.Helpers = O8.default;
Hr.default = { Link: h8.default, Button: g8.default, Element: m8.default, scroller: v8.default, Events: y8.default, scrollSpy: b8.default, animateScroll: w8.default, ScrollLink: C8.default, ScrollElement: x8.default, Helpers: O8.default };
Ze({});
Ze({});
Ze({});
function jp(e) {
  "@babel/helpers - typeof";
  return jp = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, jp(e);
}
function P1e(e, t) {
  if (jp(e) != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (jp(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function S1e(e) {
  var t = P1e(e, "string");
  return jp(t) == "symbol" ? t : t + "";
}
function Oe(e, t, n) {
  return (t = S1e(t)) in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function E8(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var cw, XN;
function M1e() {
  if (XN) return cw;
  XN = 1;
  var e = process.env.NODE_ENV, t = function(n, r, o, i, a, s, l, u) {
    if (e !== "production" && r === void 0)
      throw new Error("invariant requires an error message argument");
    if (!n) {
      var c;
      if (r === void 0)
        c = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
      else {
        var p = [o, i, a, s, l, u], d = 0;
        c = new Error(r.replace(/%s/g, function() {
          return p[d++];
        })), c.name = "Invariant Violation";
      }
      throw c.framesToPop = 1, c;
    }
  };
  return cw = t, cw;
}
var D1e = M1e(), Kr = /* @__PURE__ */ E8(D1e), Tt = Ze(null);
function T1e() {
  Kr(!!ye, "useGoogleMap is React hook and requires React version 16.8+");
  var e = ye(Tt);
  return Kr(!!e, "useGoogleMap needs a GoogleMap available up in the tree"), e;
}
function j1e(e, t, n) {
  return Object.keys(e).reduce(function(r, o) {
    return t(r, e[o], o);
  }, n);
}
function A1e(e, t) {
  Object.keys(e).forEach((n) => t(e[n], n));
}
function B1e(e, t, n, r) {
  var o = {}, i = (a, s) => {
    var l = n[s];
    l !== t[s] && (o[s] = l, a(r, l));
  };
  return A1e(e, i), o;
}
function I1e(e, t, n) {
  var r = j1e(n, function(o, i, a) {
    return typeof e[a] == "function" && o.push(google.maps.event.addListener(t, i, e[a])), o;
  }, []);
  return r;
}
function R1e(e) {
  google.maps.event.removeListener(e);
}
function un() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  e.forEach(R1e);
}
function nn(e) {
  var {
    updaterMap: t,
    eventMap: n,
    prevProps: r,
    nextProps: o,
    instance: i
  } = e, a = I1e(o, i, n);
  return B1e(t, r, o, i), a;
}
function N1e(e) {
  var {
    children: t,
    options: n,
    id: r,
    mapContainerStyle: o,
    mapContainerClassName: i,
    center: a,
    // clickableIcons,
    // extraMapTypes,
    // heading,
    // mapTypeId,
    onClick: s,
    onDblClick: l,
    onDrag: u,
    onDragEnd: c,
    onDragStart: p,
    onMouseMove: d,
    onMouseOut: h,
    onMouseOver: f,
    onMouseDown: m,
    onMouseUp: g,
    onRightClick: E,
    // onMapTypeIdChanged,
    // onTilesLoaded,
    // onBoundsChanged,
    onCenterChanged: w,
    // onHeadingChanged,
    // onIdle,
    // onProjectionChanged,
    // onResize,
    // onTiltChanged,
    // onZoomChanged,
    onLoad: M,
    onUnmount: x
  } = e, [y, C] = k(null), P = rt(null), [F, L] = k(null), [N, I] = k(null), [H, V] = k(null), [z, q] = k(null), [K, J] = k(null), [te, ee] = k(null), [_, D] = k(null), [$, S] = k(null), [W, O] = k(null), [T, U] = k(null), [j, Z] = k(null), [A, Q] = k(null);
  return v(() => {
    n && y !== null && y.setOptions(n);
  }, [y, n]), v(() => {
    y !== null && typeof a < "u" && y.setCenter(a);
  }, [y, a]), v(() => {
    y && l && (N !== null && google.maps.event.removeListener(N), I(google.maps.event.addListener(y, "dblclick", l)));
  }, [l]), v(() => {
    y && c && (H !== null && google.maps.event.removeListener(H), V(google.maps.event.addListener(y, "dragend", c)));
  }, [c]), v(() => {
    y && p && (z !== null && google.maps.event.removeListener(z), q(google.maps.event.addListener(y, "dragstart", p)));
  }, [p]), v(() => {
    y && m && (K !== null && google.maps.event.removeListener(K), J(google.maps.event.addListener(y, "mousedown", m)));
  }, [m]), v(() => {
    y && d && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(y, "mousemove", d)));
  }, [d]), v(() => {
    y && h && (_ !== null && google.maps.event.removeListener(_), D(google.maps.event.addListener(y, "mouseout", h)));
  }, [h]), v(() => {
    y && f && ($ !== null && google.maps.event.removeListener($), S(google.maps.event.addListener(y, "mouseover", f)));
  }, [f]), v(() => {
    y && g && (W !== null && google.maps.event.removeListener(W), O(google.maps.event.addListener(y, "mouseup", g)));
  }, [g]), v(() => {
    y && E && (T !== null && google.maps.event.removeListener(T), U(google.maps.event.addListener(y, "rightclick", E)));
  }, [E]), v(() => {
    y && s && (j !== null && google.maps.event.removeListener(j), Z(google.maps.event.addListener(y, "click", s)));
  }, [s]), v(() => {
    y && u && (A !== null && google.maps.event.removeListener(A), Q(google.maps.event.addListener(y, "drag", u)));
  }, [u]), v(() => {
    y && w && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(y, "center_changed", w)));
  }, [s]), v(() => {
    var R = P.current === null ? null : new google.maps.Map(P.current, n);
    return C(R), R !== null && M && M(R), () => {
      R !== null && x && x(R);
    };
  }, []), mn.jsx("div", {
    id: r,
    ref: P,
    style: o,
    className: i,
    children: mn.jsx(Tt.Provider, {
      value: y,
      children: y !== null ? t : null
    })
  });
}
Ee(N1e);
function KN(e, t, n, r, o, i, a) {
  try {
    var s = e[i](a), l = s.value;
  } catch (u) {
    return void n(u);
  }
  s.done ? t(l) : Promise.resolve(l).then(r, o);
}
function k8(e) {
  return function() {
    var t = this, n = arguments;
    return new Promise(function(r, o) {
      var i = e.apply(t, n);
      function a(l) {
        KN(i, r, o, a, s, "next", l);
      }
      function s(l) {
        KN(i, r, o, a, s, "throw", l);
      }
      a(void 0);
    });
  };
}
function L8(e) {
  var {
    googleMapsApiKey: t,
    googleMapsClientId: n,
    version: r = "weekly",
    language: o,
    region: i,
    libraries: a,
    channel: s,
    mapIds: l,
    authReferrerPolicy: u
  } = e, c = [];
  return Kr(t && n || !(t && n), "You need to specify either googleMapsApiKey or googleMapsClientId for @react-google-maps/api load script to work. You cannot use both at the same time."), t ? c.push("key=".concat(t)) : n && c.push("client=".concat(n)), r && c.push("v=".concat(r)), o && c.push("language=".concat(o)), i && c.push("region=".concat(i)), a && a.length && c.push("libraries=".concat(a.sort().join(","))), s && c.push("channel=".concat(s)), l && l.length && c.push("map_ids=".concat(l.join(","))), u && c.push("auth_referrer_policy=".concat(u)), c.push("loading=async"), c.push("callback=initMap"), "https://maps.googleapis.com/maps/api/js?".concat(c.join("&"));
}
var cl = typeof document < "u";
function _8(e) {
  var {
    url: t,
    id: n,
    nonce: r
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } = e;
  return cl ? new Promise(function(o, i) {
    var a = document.getElementById(n), s = window;
    if (a) {
      var l = a.getAttribute("data-state");
      if (a.src === t && l !== "error") {
        if (l === "ready")
          return o(n);
        var u = s.initMap, c = a.onerror;
        s.initMap = function() {
          u && u(), o(n);
        }, a.onerror = function(d) {
          c && c(d), i(d);
        };
        return;
      } else
        a.remove();
    }
    var p = document.createElement("script");
    p.type = "text/javascript", p.src = t, p.id = n, p.async = !0, p.nonce = r || "", p.onerror = function(d) {
      p.setAttribute("data-state", "error"), i(d);
    }, s.initMap = function() {
      p.setAttribute("data-state", "ready"), o(n);
    }, document.head.appendChild(p);
  }).catch((o) => {
    throw console.error("injectScript error: ", o), o;
  }) : Promise.reject(new Error("document is undefined"));
}
function YN(e) {
  var t = e.href;
  return t && (t.indexOf("https://fonts.googleapis.com/css?family=Roboto") === 0 || t.indexOf("https://fonts.googleapis.com/css?family=Google+Sans+Text") === 0) ? !0 : (
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.styleSheet.cssText = "", !0) : (
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.innerHTML = "", !0) : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.innerHTML
      )
    )
  );
}
function P8() {
  var e = document.getElementsByTagName("head")[0];
  if (e) {
    var t = e.insertBefore.bind(e);
    e.insertBefore = function(r, o) {
      return YN(r) || Reflect.apply(t, e, [r, o]), r;
    };
    var n = e.appendChild.bind(e);
    e.appendChild = function(r) {
      return YN(r) || Reflect.apply(n, e, [r]), r;
    };
  }
}
var tc = !1;
function S8() {
  return mn.jsx("div", {
    children: "Loading..."
  });
}
var Px = {
  id: "script-loader",
  version: "weekly"
};
class F1e extends pe {
  constructor() {
    super(...arguments), Oe(this, "check", null), Oe(this, "state", {
      loaded: !1
    }), Oe(this, "cleanupCallback", () => {
      delete window.google.maps, this.injectScript();
    }), Oe(this, "isCleaningUp", /* @__PURE__ */ k8(function* () {
      function t(n) {
        if (!tc)
          n();
        else if (cl)
          var r = window.setInterval(function() {
            tc || (window.clearInterval(r), n());
          }, 1);
      }
      return new Promise(t);
    })), Oe(this, "cleanup", () => {
      tc = !0;
      var t = document.getElementById(this.props.id);
      t && t.parentNode && t.parentNode.removeChild(t), Array.prototype.slice.call(document.getElementsByTagName("script")).filter(function(n) {
        return typeof n.src == "string" && n.src.includes("maps.googleapis");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("link")).filter(function(n) {
        return n.href === "https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Google+Sans";
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("style")).filter(function(n) {
        return n.innerText !== void 0 && n.innerText.length > 0 && n.innerText.includes(".gm-");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      });
    }), Oe(this, "injectScript", () => {
      this.props.preventGoogleFontsLoading && P8(), Kr(!!this.props.id, 'LoadScript requires "id" prop to be a string: %s', this.props.id);
      var t = {
        id: this.props.id,
        nonce: this.props.nonce,
        url: L8(this.props)
      };
      _8(t).then(() => {
        this.props.onLoad && this.props.onLoad(), this.setState(function() {
          return {
            loaded: !0
          };
        });
      }).catch((n) => {
        this.props.onError && this.props.onError(n), console.error(`
          There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(this.props.googleMapsApiKey || "-", ") or Client ID (").concat(this.props.googleMapsClientId || "-", `) to <LoadScript />
          Otherwise it is a Network issue.
        `));
      });
    }), Oe(this, "getRef", (t) => {
      this.check = t;
    });
  }
  componentDidMount() {
    if (cl) {
      if (window.google && window.google.maps && !tc) {
        console.error("google api is already presented");
        return;
      }
      this.isCleaningUp().then(this.injectScript).catch(function(t) {
        console.error("Error at injecting script after cleaning up: ", t);
      });
    }
  }
  componentDidUpdate(t) {
    this.props.libraries !== t.libraries && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), cl && t.language !== this.props.language && (this.cleanup(), this.setState(function() {
      return {
        loaded: !1
      };
    }, this.cleanupCallback));
  }
  componentWillUnmount() {
    if (cl) {
      this.cleanup();
      var t = () => {
        this.check || (delete window.google, tc = !1);
      };
      window.setTimeout(t, 1), this.props.onUnmount && this.props.onUnmount();
    }
  }
  render() {
    return mn.jsxs(mn.Fragment, {
      children: [mn.jsx("div", {
        ref: this.getRef
      }), this.state.loaded ? this.props.children : this.props.loadingElement || mn.jsx(S8, {})]
    });
  }
}
Oe(F1e, "defaultProps", Px);
function z1e(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.includes(r)) continue;
    n[r] = e[r];
  }
  return n;
}
function a1(e, t) {
  if (e == null) return {};
  var n, r, o = z1e(e, t);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (r = 0; r < i.length; r++) n = i[r], t.includes(n) || {}.propertyIsEnumerable.call(e, n) && (o[n] = e[n]);
  }
  return o;
}
var JN;
function U1e(e) {
  var {
    id: t = Px.id,
    version: n = Px.version,
    nonce: r,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    preventGoogleFontsLoading: u,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  } = e, h = rt(!1), [f, m] = k(!1), [g, E] = k(void 0);
  v(function() {
    return h.current = !0, () => {
      h.current = !1;
    };
  }, []), v(function() {
    cl && u && P8();
  }, [u]), v(function() {
    f && Kr(!!window.google, "useLoadScript was marked as loaded, but window.google is not present. Something went wrong.");
  }, [f]);
  var w = L8({
    version: n,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  });
  v(function() {
    if (!cl)
      return;
    function x() {
      h.current && (m(!0), JN = w);
    }
    if (window.google && window.google.maps && JN === w) {
      x();
      return;
    }
    _8({
      id: t,
      url: w,
      nonce: r
    }).then(x).catch(function(y) {
      h.current && E(y), console.warn(`
        There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(o || "-", ") or Client ID (").concat(i || "-", `)
        Otherwise it is a Network issue.
      `)), console.error(y);
    });
  }, [t, w, r]);
  var M = rt(void 0);
  return v(function() {
    M.current && l !== M.current && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), M.current = l;
  }, [l]), {
    isLoaded: f,
    loadError: g,
    url: w
  };
}
var $1e = ["loadingElement", "onLoad", "onError", "onUnmount", "children"], H1e = mn.jsx(S8, {});
function W1e(e) {
  var {
    loadingElement: t,
    onLoad: n,
    onError: r,
    onUnmount: o,
    children: i
  } = e, a = a1(e, $1e), {
    isLoaded: s,
    loadError: l
  } = U1e(a);
  return v(function() {
    s && typeof n == "function" && n();
  }, [s, n]), v(function() {
    l && typeof r == "function" && r(l);
  }, [l, r]), v(function() {
    return () => {
      o && o();
    };
  }, [o]), s ? i : t || H1e;
}
Ee(W1e);
var QN;
(function(e) {
  e[e.INITIALIZED = 0] = "INITIALIZED", e[e.LOADING = 1] = "LOADING", e[e.SUCCESS = 2] = "SUCCESS", e[e.FAILURE = 3] = "FAILURE";
})(QN || (QN = {}));
function eF(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function um(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? eF(Object(n), !0).forEach(function(r) {
      Oe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : eF(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var tF = {}, nF = {
  options(e, t) {
    e.setOptions(t);
  }
};
function V1e(e) {
  var {
    options: t,
    onLoad: n,
    onUnmount: r
  } = e, o = ye(Tt), [i, a] = k(null);
  return v(() => {
    i !== null && i.setMap(o);
  }, [o]), v(() => {
    t && i !== null && i.setOptions(t);
  }, [i, t]), v(() => {
    var s = new google.maps.TrafficLayer(um(um({}, t), {}, {
      map: o
    }));
    return a(s), n && n(s), () => {
      i !== null && (r && r(i), i.setMap(null));
    };
  }, []), null;
}
Ee(V1e);
class q1e extends pe {
  constructor() {
    super(...arguments), Oe(this, "state", {
      trafficLayer: null
    }), Oe(this, "setTrafficLayerCallback", () => {
      this.state.trafficLayer !== null && this.props.onLoad && this.props.onLoad(this.state.trafficLayer);
    }), Oe(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = new google.maps.TrafficLayer(um(um({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = nn({
      updaterMap: nF,
      eventMap: tF,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        trafficLayer: t
      };
    }, this.setTrafficLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.trafficLayer !== null && (un(this.registeredEvents), this.registeredEvents = nn({
      updaterMap: nF,
      eventMap: tF,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.trafficLayer
    }));
  }
  componentWillUnmount() {
    this.state.trafficLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.trafficLayer), un(this.registeredEvents), this.state.trafficLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Oe(q1e, "contextType", Tt);
function Z1e(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = ye(Tt), [o, i] = k(null);
  return v(() => {
    o !== null && o.setMap(r);
  }, [r]), v(() => {
    var a = new google.maps.BicyclingLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      a !== null && (n && n(a), a.setMap(null));
    };
  }, []), null;
}
Ee(Z1e);
class G1e extends pe {
  constructor() {
    super(...arguments), Oe(this, "state", {
      bicyclingLayer: null
    }), Oe(this, "setBicyclingLayerCallback", () => {
      this.state.bicyclingLayer !== null && (this.state.bicyclingLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.bicyclingLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.BicyclingLayer();
    this.setState(() => ({
      bicyclingLayer: t
    }), this.setBicyclingLayerCallback);
  }
  componentWillUnmount() {
    this.state.bicyclingLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.bicyclingLayer), this.state.bicyclingLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Oe(G1e, "contextType", Tt);
function X1e(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = ye(Tt), [o, i] = k(null);
  return v(() => {
    o !== null && o.setMap(r);
  }, [r]), v(() => {
    var a = new google.maps.TransitLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      o !== null && (n && n(o), o.setMap(null));
    };
  }, []), null;
}
Ee(X1e);
class K1e extends pe {
  constructor() {
    super(...arguments), Oe(this, "state", {
      transitLayer: null
    }), Oe(this, "setTransitLayerCallback", () => {
      this.state.transitLayer !== null && (this.state.transitLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.transitLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.TransitLayer();
    this.setState(function() {
      return {
        transitLayer: t
      };
    }, this.setTransitLayerCallback);
  }
  componentWillUnmount() {
    this.state.transitLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.transitLayer), this.state.transitLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Oe(K1e, "contextType", Tt);
function rF(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function cm(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? rF(Object(n), !0).forEach(function(r) {
      Oe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : rF(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var oF = {
  onCircleComplete: "circlecomplete",
  onMarkerComplete: "markercomplete",
  onOverlayComplete: "overlaycomplete",
  onPolygonComplete: "polygoncomplete",
  onPolylineComplete: "polylinecomplete",
  onRectangleComplete: "rectanglecomplete"
}, iF = {
  drawingMode(e, t) {
    e.setDrawingMode(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function Y1e(e) {
  var {
    options: t,
    drawingMode: n,
    onCircleComplete: r,
    onMarkerComplete: o,
    onOverlayComplete: i,
    onPolygonComplete: a,
    onPolylineComplete: s,
    onRectangleComplete: l,
    onLoad: u,
    onUnmount: c
  } = e, p = ye(Tt), [d, h] = k(null), [f, m] = k(null), [g, E] = k(null), [w, M] = k(null), [x, y] = k(null), [C, P] = k(null), [F, L] = k(null);
  return v(() => {
    d !== null && d.setMap(p);
  }, [p]), v(() => {
    t && d !== null && d.setOptions(t);
  }, [d, t]), v(() => {
    d !== null && d.setDrawingMode(n ?? null);
  }, [d, n]), v(() => {
    d && r && (f !== null && google.maps.event.removeListener(f), m(google.maps.event.addListener(d, "circlecomplete", r)));
  }, [d, r]), v(() => {
    d && o && (g !== null && google.maps.event.removeListener(g), E(google.maps.event.addListener(d, "markercomplete", o)));
  }, [d, o]), v(() => {
    d && i && (w !== null && google.maps.event.removeListener(w), M(google.maps.event.addListener(d, "overlaycomplete", i)));
  }, [d, i]), v(() => {
    d && a && (x !== null && google.maps.event.removeListener(x), y(google.maps.event.addListener(d, "polygoncomplete", a)));
  }, [d, a]), v(() => {
    d && s && (C !== null && google.maps.event.removeListener(C), P(google.maps.event.addListener(d, "polylinecomplete", s)));
  }, [d, s]), v(() => {
    d && l && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(d, "rectanglecomplete", l)));
  }, [d, l]), v(() => {
    Kr(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
    var N = new google.maps.drawing.DrawingManager(cm(cm({}, t), {}, {
      map: p
    }));
    return n && N.setDrawingMode(n), r && m(google.maps.event.addListener(N, "circlecomplete", r)), o && E(google.maps.event.addListener(N, "markercomplete", o)), i && M(google.maps.event.addListener(N, "overlaycomplete", i)), a && y(google.maps.event.addListener(N, "polygoncomplete", a)), s && P(google.maps.event.addListener(N, "polylinecomplete", s)), l && L(google.maps.event.addListener(N, "rectanglecomplete", l)), h(N), u && u(N), () => {
      d !== null && (f && google.maps.event.removeListener(f), g && google.maps.event.removeListener(g), w && google.maps.event.removeListener(w), x && google.maps.event.removeListener(x), C && google.maps.event.removeListener(C), F && google.maps.event.removeListener(F), c && c(d), d.setMap(null));
    };
  }, []), null;
}
Ee(Y1e);
class J1e extends pe {
  constructor(t) {
    super(t), Oe(this, "registeredEvents", []), Oe(this, "state", {
      drawingManager: null
    }), Oe(this, "setDrawingManagerCallback", () => {
      this.state.drawingManager !== null && this.props.onLoad && this.props.onLoad(this.state.drawingManager);
    }), Kr(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
  }
  componentDidMount() {
    var t = new google.maps.drawing.DrawingManager(cm(cm({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = nn({
      updaterMap: iF,
      eventMap: oF,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        drawingManager: t
      };
    }, this.setDrawingManagerCallback);
  }
  componentDidUpdate(t) {
    this.state.drawingManager !== null && (un(this.registeredEvents), this.registeredEvents = nn({
      updaterMap: iF,
      eventMap: oF,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.drawingManager
    }));
  }
  componentWillUnmount() {
    this.state.drawingManager !== null && (this.props.onUnmount && this.props.onUnmount(this.state.drawingManager), un(this.registeredEvents), this.state.drawingManager.setMap(null));
  }
  render() {
    return null;
  }
}
Oe(J1e, "contextType", Tt);
function sF(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Ql(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? sF(Object(n), !0).forEach(function(r) {
      Oe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : sF(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var aF = {
  onAnimationChanged: "animation_changed",
  onClick: "click",
  onClickableChanged: "clickable_changed",
  onCursorChanged: "cursor_changed",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDraggableChanged: "draggable_changed",
  onDragStart: "dragstart",
  onFlatChanged: "flat_changed",
  onIconChanged: "icon_changed",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onPositionChanged: "position_changed",
  onRightClick: "rightclick",
  onShapeChanged: "shape_changed",
  onTitleChanged: "title_changed",
  onVisibleChanged: "visible_changed",
  onZindexChanged: "zindex_changed"
}, lF = {
  animation(e, t) {
    e.setAnimation(t);
  },
  clickable(e, t) {
    e.setClickable(t);
  },
  cursor(e, t) {
    e.setCursor(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  icon(e, t) {
    e.setIcon(t);
  },
  label(e, t) {
    e.setLabel(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  opacity(e, t) {
    e.setOpacity(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  shape(e, t) {
    e.setShape(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, pm = {};
function Q1e(e) {
  var {
    position: t,
    options: n,
    clusterer: r,
    noClustererRedraw: o,
    children: i,
    draggable: a,
    visible: s,
    animation: l,
    clickable: u,
    cursor: c,
    icon: p,
    label: d,
    opacity: h,
    shape: f,
    title: m,
    zIndex: g,
    onClick: E,
    onDblClick: w,
    onDrag: M,
    onDragEnd: x,
    onDragStart: y,
    onMouseOut: C,
    onMouseOver: P,
    onMouseUp: F,
    onMouseDown: L,
    onRightClick: N,
    onClickableChanged: I,
    onCursorChanged: H,
    onAnimationChanged: V,
    onDraggableChanged: z,
    onFlatChanged: q,
    onIconChanged: K,
    onPositionChanged: J,
    onShapeChanged: te,
    onTitleChanged: ee,
    onVisibleChanged: _,
    onZindexChanged: D,
    onLoad: $,
    onUnmount: S
  } = e, W = ye(Tt), [O, T] = k(null), [U, j] = k(null), [Z, A] = k(null), [Q, R] = k(null), [ue, fe] = k(null), [oe, Re] = k(null), [He, Ve] = k(null), [ze, et] = k(null), [Ge, Pe] = k(null), [Ye, it] = k(null), [_e, Se] = k(null), [Ke, We] = k(null), [Ue, nt] = k(null), [Ie, xt] = k(null), [ot, st] = k(null), [lt, Ot] = k(null), [ut, ct] = k(null), [tt, Xe] = k(null), [Et, kt] = k(null), [pt, kn] = k(null), [dt, Ln] = k(null), [ft, rn] = k(null);
  v(() => {
    O !== null && O.setMap(W);
  }, [W]), v(() => {
    typeof n < "u" && O !== null && O.setOptions(n);
  }, [O, n]), v(() => {
    typeof a < "u" && O !== null && O.setDraggable(a);
  }, [O, a]), v(() => {
    t && O !== null && O.setPosition(t);
  }, [O, t]), v(() => {
    typeof s < "u" && O !== null && O.setVisible(s);
  }, [O, s]), v(() => {
    O == null || O.setAnimation(l);
  }, [O, l]), v(() => {
    O && u !== void 0 && O.setClickable(u);
  }, [O, u]), v(() => {
    O && c !== void 0 && O.setCursor(c);
  }, [O, c]), v(() => {
    O && p !== void 0 && O.setIcon(p);
  }, [O, p]), v(() => {
    O && d !== void 0 && O.setLabel(d);
  }, [O, d]), v(() => {
    O && h !== void 0 && O.setOpacity(h);
  }, [O, h]), v(() => {
    O && f !== void 0 && O.setShape(f);
  }, [O, f]), v(() => {
    O && m !== void 0 && O.setTitle(m);
  }, [O, m]), v(() => {
    O && g !== void 0 && O.setZIndex(g);
  }, [O, g]), v(() => {
    O && w && (U !== null && google.maps.event.removeListener(U), j(google.maps.event.addListener(O, "dblclick", w)));
  }, [w]), v(() => {
    O && x && (Z !== null && google.maps.event.removeListener(Z), A(google.maps.event.addListener(O, "dragend", x)));
  }, [x]), v(() => {
    O && y && (Q !== null && google.maps.event.removeListener(Q), R(google.maps.event.addListener(O, "dragstart", y)));
  }, [y]), v(() => {
    O && L && (ue !== null && google.maps.event.removeListener(ue), fe(google.maps.event.addListener(O, "mousedown", L)));
  }, [L]), v(() => {
    O && C && (oe !== null && google.maps.event.removeListener(oe), Re(google.maps.event.addListener(O, "mouseout", C)));
  }, [C]), v(() => {
    O && P && (He !== null && google.maps.event.removeListener(He), Ve(google.maps.event.addListener(O, "mouseover", P)));
  }, [P]), v(() => {
    O && F && (ze !== null && google.maps.event.removeListener(ze), et(google.maps.event.addListener(O, "mouseup", F)));
  }, [F]), v(() => {
    O && N && (Ge !== null && google.maps.event.removeListener(Ge), Pe(google.maps.event.addListener(O, "rightclick", N)));
  }, [N]), v(() => {
    O && E && (Ye !== null && google.maps.event.removeListener(Ye), it(google.maps.event.addListener(O, "click", E)));
  }, [E]), v(() => {
    O && M && (_e !== null && google.maps.event.removeListener(_e), Se(google.maps.event.addListener(O, "drag", M)));
  }, [M]), v(() => {
    O && I && (Ke !== null && google.maps.event.removeListener(Ke), We(google.maps.event.addListener(O, "clickable_changed", I)));
  }, [I]), v(() => {
    O && H && (Ue !== null && google.maps.event.removeListener(Ue), nt(google.maps.event.addListener(O, "cursor_changed", H)));
  }, [H]), v(() => {
    O && V && (Ie !== null && google.maps.event.removeListener(Ie), xt(google.maps.event.addListener(O, "animation_changed", V)));
  }, [V]), v(() => {
    O && z && (ot !== null && google.maps.event.removeListener(ot), st(google.maps.event.addListener(O, "draggable_changed", z)));
  }, [z]), v(() => {
    O && q && (lt !== null && google.maps.event.removeListener(lt), Ot(google.maps.event.addListener(O, "flat_changed", q)));
  }, [q]), v(() => {
    O && K && (ut !== null && google.maps.event.removeListener(ut), ct(google.maps.event.addListener(O, "icon_changed", K)));
  }, [K]), v(() => {
    O && J && (tt !== null && google.maps.event.removeListener(tt), Xe(google.maps.event.addListener(O, "position_changed", J)));
  }, [J]), v(() => {
    O && te && (Et !== null && google.maps.event.removeListener(Et), kt(google.maps.event.addListener(O, "shape_changed", te)));
  }, [te]), v(() => {
    O && ee && (pt !== null && google.maps.event.removeListener(pt), kn(google.maps.event.addListener(O, "title_changed", ee)));
  }, [ee]), v(() => {
    O && _ && (dt !== null && google.maps.event.removeListener(dt), Ln(google.maps.event.addListener(O, "visible_changed", _)));
  }, [_]), v(() => {
    O && D && (ft !== null && google.maps.event.removeListener(ft), rn(google.maps.event.addListener(O, "zindex_changed", D)));
  }, [D]), v(() => {
    var ht = Ql(Ql(Ql({}, n || pm), r ? pm : {
      map: W
    }), {}, {
      position: t
    }), re = new google.maps.Marker(ht);
    return r ? r.addMarker(re, !!o) : re.setMap(W), t && re.setPosition(t), typeof s < "u" && re.setVisible(s), typeof a < "u" && re.setDraggable(a), typeof u < "u" && re.setClickable(u), typeof c == "string" && re.setCursor(c), p && re.setIcon(p), typeof d < "u" && re.setLabel(d), typeof h < "u" && re.setOpacity(h), f && re.setShape(f), typeof m == "string" && re.setTitle(m), typeof g == "number" && re.setZIndex(g), w && j(google.maps.event.addListener(re, "dblclick", w)), x && A(google.maps.event.addListener(re, "dragend", x)), y && R(google.maps.event.addListener(re, "dragstart", y)), L && fe(google.maps.event.addListener(re, "mousedown", L)), C && Re(google.maps.event.addListener(re, "mouseout", C)), P && Ve(google.maps.event.addListener(re, "mouseover", P)), F && et(google.maps.event.addListener(re, "mouseup", F)), N && Pe(google.maps.event.addListener(re, "rightclick", N)), E && it(google.maps.event.addListener(re, "click", E)), M && Se(google.maps.event.addListener(re, "drag", M)), I && We(google.maps.event.addListener(re, "clickable_changed", I)), H && nt(google.maps.event.addListener(re, "cursor_changed", H)), V && xt(google.maps.event.addListener(re, "animation_changed", V)), z && st(google.maps.event.addListener(re, "draggable_changed", z)), q && Ot(google.maps.event.addListener(re, "flat_changed", q)), K && ct(google.maps.event.addListener(re, "icon_changed", K)), J && Xe(google.maps.event.addListener(re, "position_changed", J)), te && kt(google.maps.event.addListener(re, "shape_changed", te)), ee && kn(google.maps.event.addListener(re, "title_changed", ee)), _ && Ln(google.maps.event.addListener(re, "visible_changed", _)), D && rn(google.maps.event.addListener(re, "zindex_changed", D)), T(re), $ && $(re), () => {
      U !== null && google.maps.event.removeListener(U), Z !== null && google.maps.event.removeListener(Z), Q !== null && google.maps.event.removeListener(Q), ue !== null && google.maps.event.removeListener(ue), oe !== null && google.maps.event.removeListener(oe), He !== null && google.maps.event.removeListener(He), ze !== null && google.maps.event.removeListener(ze), Ge !== null && google.maps.event.removeListener(Ge), Ye !== null && google.maps.event.removeListener(Ye), Ke !== null && google.maps.event.removeListener(Ke), Ue !== null && google.maps.event.removeListener(Ue), Ie !== null && google.maps.event.removeListener(Ie), ot !== null && google.maps.event.removeListener(ot), lt !== null && google.maps.event.removeListener(lt), ut !== null && google.maps.event.removeListener(ut), tt !== null && google.maps.event.removeListener(tt), pt !== null && google.maps.event.removeListener(pt), dt !== null && google.maps.event.removeListener(dt), ft !== null && google.maps.event.removeListener(ft), S && S(re), r ? r.removeMarker(re, !!o) : re && re.setMap(null);
    };
  }, []);
  var br = Tn(() => i ? at.map(i, (ht) => {
    if (!bi(ht))
      return ht;
    var re = ht;
    return wi(re, {
      anchor: O
    });
  }) : null, [i, O]);
  return mn.jsx(mn.Fragment, {
    children: br
  }) || null;
}
Ee(Q1e);
class eLe extends pe {
  constructor() {
    super(...arguments), Oe(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this;
    return k8(function* () {
      var n = Ql(Ql(Ql({}, t.props.options || pm), t.props.clusterer ? pm : {
        map: t.context
      }), {}, {
        position: t.props.position
      });
      t.marker = new google.maps.Marker(n), t.props.clusterer ? t.props.clusterer.addMarker(t.marker, !!t.props.noClustererRedraw) : t.marker.setMap(t.context), t.registeredEvents = nn({
        updaterMap: lF,
        eventMap: aF,
        prevProps: {},
        nextProps: t.props,
        instance: t.marker
      }), t.props.onLoad && t.props.onLoad(t.marker);
    })();
  }
  componentDidUpdate(t) {
    this.marker && (un(this.registeredEvents), this.registeredEvents = nn({
      updaterMap: lF,
      eventMap: aF,
      prevProps: t,
      nextProps: this.props,
      instance: this.marker
    }));
  }
  componentWillUnmount() {
    this.marker && (this.props.onUnmount && this.props.onUnmount(this.marker), un(this.registeredEvents), this.props.clusterer ? this.props.clusterer.removeMarker(this.marker, !!this.props.noClustererRedraw) : this.marker && this.marker.setMap(null));
  }
  render() {
    var t = this.props.children ? at.map(this.props.children, (n) => {
      if (!bi(n))
        return n;
      var r = n;
      return wi(r, {
        anchor: this.marker
      });
    }) : null;
    return t || null;
  }
}
Oe(eLe, "contextType", Tt);
var tLe = (
  /** @class */
  function() {
    function e(t, n) {
      t.getClusterer().extend(e, google.maps.OverlayView), this.cluster = t, this.clusterClassName = this.cluster.getClusterer().getClusterClass(), this.className = this.clusterClassName, this.styles = n, this.center = void 0, this.div = null, this.sums = null, this.visible = !1, this.boundsChangedListener = null, this.url = "", this.height = 0, this.width = 0, this.anchorText = [0, 0], this.anchorIcon = [0, 0], this.textColor = "black", this.textSize = 11, this.textDecoration = "none", this.fontWeight = "bold", this.fontStyle = "normal", this.fontFamily = "Arial,sans-serif", this.backgroundPosition = "0 0", this.cMouseDownInCluster = null, this.cDraggingMapByCluster = null, this.timeOut = null, this.setMap(t.getMap()), this.onBoundsChanged = this.onBoundsChanged.bind(this), this.onMouseDown = this.onMouseDown.bind(this), this.onClick = this.onClick.bind(this), this.onMouseOver = this.onMouseOver.bind(this), this.onMouseOut = this.onMouseOut.bind(this), this.onAdd = this.onAdd.bind(this), this.onRemove = this.onRemove.bind(this), this.draw = this.draw.bind(this), this.hide = this.hide.bind(this), this.show = this.show.bind(this), this.useStyle = this.useStyle.bind(this), this.setCenter = this.setCenter.bind(this), this.getPosFromLatLng = this.getPosFromLatLng.bind(this);
    }
    return e.prototype.onBoundsChanged = function() {
      this.cDraggingMapByCluster = this.cMouseDownInCluster;
    }, e.prototype.onMouseDown = function() {
      this.cMouseDownInCluster = !0, this.cDraggingMapByCluster = !1;
    }, e.prototype.onClick = function(t) {
      if (this.cMouseDownInCluster = !1, !this.cDraggingMapByCluster) {
        var n = this.cluster.getClusterer();
        if (google.maps.event.trigger(n, "click", this.cluster), google.maps.event.trigger(n, "clusterclick", this.cluster), n.getZoomOnClick()) {
          var r = n.getMaxZoom(), o = this.cluster.getBounds(), i = n.getMap();
          i !== null && "fitBounds" in i && i.fitBounds(o), this.timeOut = window.setTimeout(function() {
            var a = n.getMap();
            if (a !== null) {
              "fitBounds" in a && a.fitBounds(o);
              var s = a.getZoom() || 0;
              r !== null && s > r && a.setZoom(r + 1);
            }
          }, 100);
        }
        t.cancelBubble = !0, t.stopPropagation && t.stopPropagation();
      }
    }, e.prototype.onMouseOver = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseover", this.cluster);
    }, e.prototype.onMouseOut = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseout", this.cluster);
    }, e.prototype.onAdd = function() {
      var t;
      this.div = document.createElement("div"), this.div.className = this.className, this.visible && this.show(), (t = this.getPanes()) === null || t === void 0 || t.overlayMouseTarget.appendChild(this.div);
      var n = this.getMap();
      n !== null && (this.boundsChangedListener = google.maps.event.addListener(n, "bounds_changed", this.onBoundsChanged), this.div.addEventListener("mousedown", this.onMouseDown), this.div.addEventListener("click", this.onClick), this.div.addEventListener("mouseover", this.onMouseOver), this.div.addEventListener("mouseout", this.onMouseOut));
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.hide(), this.boundsChangedListener !== null && google.maps.event.removeListener(this.boundsChangedListener), this.div.removeEventListener("mousedown", this.onMouseDown), this.div.removeEventListener("click", this.onClick), this.div.removeEventListener("mouseover", this.onMouseOver), this.div.removeEventListener("mouseout", this.onMouseOut), this.div.parentNode.removeChild(this.div), this.timeOut !== null && (window.clearTimeout(this.timeOut), this.timeOut = null), this.div = null);
    }, e.prototype.draw = function() {
      if (this.visible && this.div !== null && this.center) {
        var t = this.getPosFromLatLng(this.center);
        this.div.style.top = t !== null ? "".concat(t.y, "px") : "0", this.div.style.left = t !== null ? "".concat(t.x, "px") : "0";
      }
    }, e.prototype.hide = function() {
      this.div && (this.div.style.display = "none"), this.visible = !1;
    }, e.prototype.show = function() {
      var t, n, r, o, i, a;
      if (this.div && this.center) {
        var s = this.sums === null || typeof this.sums.title > "u" || this.sums.title === "" ? this.cluster.getClusterer().getTitle() : this.sums.title, l = this.backgroundPosition.split(" "), u = parseInt(((t = l[0]) === null || t === void 0 ? void 0 : t.replace(/^\s+|\s+$/g, "")) || "0", 10), c = parseInt(((n = l[1]) === null || n === void 0 ? void 0 : n.replace(/^\s+|\s+$/g, "")) || "0", 10), p = this.getPosFromLatLng(this.center);
        this.div.className = this.className, this.div.setAttribute("style", "cursor: pointer; position: absolute; top: ".concat(p !== null ? "".concat(p.y, "px") : "0", "; left: ").concat(p !== null ? "".concat(p.x, "px") : "0", "; width: ").concat(this.width, "px; height: ").concat(this.height, "px; "));
        var d = document.createElement("img");
        d.alt = s, d.src = this.url, d.width = this.width, d.height = this.height, d.setAttribute("style", "position: absolute; top: ".concat(c, "px; left: ").concat(u, "px")), this.cluster.getClusterer().enableRetinaIcons || (d.style.clip = "rect(-".concat(c, "px, -").concat(u + this.width, "px, -").concat(c + this.height, ", -").concat(u, ")"));
        var h = document.createElement("div");
        h.setAttribute("style", "position: absolute; top: ".concat(this.anchorText[0], "px; left: ").concat(this.anchorText[1], "px; color: ").concat(this.textColor, "; font-size: ").concat(this.textSize, "px; font-family: ").concat(this.fontFamily, "; font-weight: ").concat(this.fontWeight, "; fontStyle: ").concat(this.fontStyle, "; text-decoration: ").concat(this.textDecoration, "; text-align: center; width: ").concat(this.width, "px; line-height: ").concat(this.height, "px")), !((r = this.sums) === null || r === void 0) && r.text && (h.innerText = "".concat((o = this.sums) === null || o === void 0 ? void 0 : o.text)), !((i = this.sums) === null || i === void 0) && i.html && (h.innerHTML = "".concat((a = this.sums) === null || a === void 0 ? void 0 : a.html)), this.div.innerHTML = "", this.div.appendChild(d), this.div.appendChild(h), this.div.title = s, this.div.style.display = "";
      }
      this.visible = !0;
    }, e.prototype.useStyle = function(t) {
      this.sums = t;
      var n = this.cluster.getClusterer().getStyles(), r = n[Math.min(n.length - 1, Math.max(0, t.index - 1))];
      r && (this.url = r.url, this.height = r.height, this.width = r.width, r.className && (this.className = "".concat(this.clusterClassName, " ").concat(r.className)), this.anchorText = r.anchorText || [0, 0], this.anchorIcon = r.anchorIcon || [this.height / 2, this.width / 2], this.textColor = r.textColor || "black", this.textSize = r.textSize || 11, this.textDecoration = r.textDecoration || "none", this.fontWeight = r.fontWeight || "bold", this.fontStyle = r.fontStyle || "normal", this.fontFamily = r.fontFamily || "Arial,sans-serif", this.backgroundPosition = r.backgroundPosition || "0 0");
    }, e.prototype.setCenter = function(t) {
      this.center = t;
    }, e.prototype.getPosFromLatLng = function(t) {
      var n = this.getProjection().fromLatLngToDivPixel(t);
      return n !== null && (n.x -= this.anchorIcon[1], n.y -= this.anchorIcon[0]), n;
    }, e;
  }()
), nLe = (
  /** @class */
  function() {
    function e(t) {
      this.markerClusterer = t, this.map = this.markerClusterer.getMap(), this.gridSize = this.markerClusterer.getGridSize(), this.minClusterSize = this.markerClusterer.getMinimumClusterSize(), this.averageCenter = this.markerClusterer.getAverageCenter(), this.markers = [], this.center = void 0, this.bounds = null, this.clusterIcon = new tLe(this, this.markerClusterer.getStyles()), this.getSize = this.getSize.bind(this), this.getMarkers = this.getMarkers.bind(this), this.getCenter = this.getCenter.bind(this), this.getMap = this.getMap.bind(this), this.getClusterer = this.getClusterer.bind(this), this.getBounds = this.getBounds.bind(this), this.remove = this.remove.bind(this), this.addMarker = this.addMarker.bind(this), this.isMarkerInClusterBounds = this.isMarkerInClusterBounds.bind(this), this.calculateBounds = this.calculateBounds.bind(this), this.updateIcon = this.updateIcon.bind(this), this.isMarkerAlreadyAdded = this.isMarkerAlreadyAdded.bind(this);
    }
    return e.prototype.getSize = function() {
      return this.markers.length;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getCenter = function() {
      return this.center;
    }, e.prototype.getMap = function() {
      return this.map;
    }, e.prototype.getClusterer = function() {
      return this.markerClusterer;
    }, e.prototype.getBounds = function() {
      for (var t = new google.maps.LatLngBounds(this.center, this.center), n = this.getMarkers(), r = 0, o = n; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && t.extend(a);
      }
      return t;
    }, e.prototype.remove = function() {
      this.clusterIcon.setMap(null), this.markers = [], delete this.markers;
    }, e.prototype.addMarker = function(t) {
      var n;
      if (this.isMarkerAlreadyAdded(t))
        return !1;
      if (this.center) {
        if (this.averageCenter) {
          var r = t.getPosition();
          if (r) {
            var o = this.markers.length + 1;
            this.center = new google.maps.LatLng((this.center.lat() * (o - 1) + r.lat()) / o, (this.center.lng() * (o - 1) + r.lng()) / o), this.calculateBounds();
          }
        }
      } else {
        var r = t.getPosition();
        r && (this.center = r, this.calculateBounds());
      }
      t.isAdded = !0, this.markers.push(t);
      var i = this.markers.length, a = this.markerClusterer.getMaxZoom(), s = (n = this.map) === null || n === void 0 ? void 0 : n.getZoom();
      if (a !== null && typeof s < "u" && s > a)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i < this.minClusterSize)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i === this.minClusterSize)
        for (var l = 0, u = this.markers; l < u.length; l++) {
          var c = u[l];
          c.setMap(null);
        }
      else
        t.setMap(null);
      return !0;
    }, e.prototype.isMarkerInClusterBounds = function(t) {
      if (this.bounds !== null) {
        var n = t.getPosition();
        if (n)
          return this.bounds.contains(n);
      }
      return !1;
    }, e.prototype.calculateBounds = function() {
      this.bounds = this.markerClusterer.getExtendedBounds(new google.maps.LatLngBounds(this.center, this.center));
    }, e.prototype.updateIcon = function() {
      var t, n = this.markers.length, r = this.markerClusterer.getMaxZoom(), o = (t = this.map) === null || t === void 0 ? void 0 : t.getZoom();
      if (r !== null && typeof o < "u" && o > r) {
        this.clusterIcon.hide();
        return;
      }
      if (n < this.minClusterSize) {
        this.clusterIcon.hide();
        return;
      }
      this.center && this.clusterIcon.setCenter(this.center), this.clusterIcon.useStyle(this.markerClusterer.getCalculator()(this.markers, this.markerClusterer.getStyles().length)), this.clusterIcon.show();
    }, e.prototype.isMarkerAlreadyAdded = function(t) {
      if (this.markers.includes)
        return this.markers.includes(t);
      for (var n = 0; n < this.markers.length; n++)
        if (t === this.markers[n])
          return !0;
      return !1;
    }, e;
  }()
);
function rLe(e, t) {
  var n = e.length, r = n.toString().length, o = Math.min(r, t);
  return {
    text: n.toString(),
    index: o,
    title: ""
  };
}
var oLe = 2e3, iLe = 500, sLe = "https://developers.google.com/maps/documentation/javascript/examples/markerclusterer/m", aLe = "png", lLe = [53, 56, 66, 78, 90], uLe = "cluster", M8 = (
  /** @class */
  function() {
    function e(t, n, r) {
      n === void 0 && (n = []), r === void 0 && (r = {}), this.getMinimumClusterSize = this.getMinimumClusterSize.bind(this), this.setMinimumClusterSize = this.setMinimumClusterSize.bind(this), this.getEnableRetinaIcons = this.getEnableRetinaIcons.bind(this), this.setEnableRetinaIcons = this.setEnableRetinaIcons.bind(this), this.addToClosestCluster = this.addToClosestCluster.bind(this), this.getImageExtension = this.getImageExtension.bind(this), this.setImageExtension = this.setImageExtension.bind(this), this.getExtendedBounds = this.getExtendedBounds.bind(this), this.getAverageCenter = this.getAverageCenter.bind(this), this.setAverageCenter = this.setAverageCenter.bind(this), this.getTotalClusters = this.getTotalClusters.bind(this), this.fitMapToMarkers = this.fitMapToMarkers.bind(this), this.getIgnoreHidden = this.getIgnoreHidden.bind(this), this.setIgnoreHidden = this.setIgnoreHidden.bind(this), this.getClusterClass = this.getClusterClass.bind(this), this.setClusterClass = this.setClusterClass.bind(this), this.getTotalMarkers = this.getTotalMarkers.bind(this), this.getZoomOnClick = this.getZoomOnClick.bind(this), this.setZoomOnClick = this.setZoomOnClick.bind(this), this.getBatchSizeIE = this.getBatchSizeIE.bind(this), this.setBatchSizeIE = this.setBatchSizeIE.bind(this), this.createClusters = this.createClusters.bind(this), this.onZoomChanged = this.onZoomChanged.bind(this), this.getImageSizes = this.getImageSizes.bind(this), this.setImageSizes = this.setImageSizes.bind(this), this.getCalculator = this.getCalculator.bind(this), this.setCalculator = this.setCalculator.bind(this), this.removeMarkers = this.removeMarkers.bind(this), this.resetViewport = this.resetViewport.bind(this), this.getImagePath = this.getImagePath.bind(this), this.setImagePath = this.setImagePath.bind(this), this.pushMarkerTo = this.pushMarkerTo.bind(this), this.removeMarker = this.removeMarker.bind(this), this.clearMarkers = this.clearMarkers.bind(this), this.setupStyles = this.setupStyles.bind(this), this.getGridSize = this.getGridSize.bind(this), this.setGridSize = this.setGridSize.bind(this), this.getClusters = this.getClusters.bind(this), this.getMaxZoom = this.getMaxZoom.bind(this), this.setMaxZoom = this.setMaxZoom.bind(this), this.getMarkers = this.getMarkers.bind(this), this.addMarkers = this.addMarkers.bind(this), this.getStyles = this.getStyles.bind(this), this.setStyles = this.setStyles.bind(this), this.addMarker = this.addMarker.bind(this), this.onRemove = this.onRemove.bind(this), this.getTitle = this.getTitle.bind(this), this.setTitle = this.setTitle.bind(this), this.repaint = this.repaint.bind(this), this.onIdle = this.onIdle.bind(this), this.redraw = this.redraw.bind(this), this.onAdd = this.onAdd.bind(this), this.draw = this.draw.bind(this), this.extend = this.extend.bind(this), this.extend(e, google.maps.OverlayView), this.markers = [], this.clusters = [], this.listeners = [], this.activeMap = null, this.ready = !1, this.gridSize = r.gridSize || 60, this.minClusterSize = r.minimumClusterSize || 2, this.maxZoom = r.maxZoom || null, this.styles = r.styles || [], this.title = r.title || "", this.zoomOnClick = !0, r.zoomOnClick !== void 0 && (this.zoomOnClick = r.zoomOnClick), this.averageCenter = !1, r.averageCenter !== void 0 && (this.averageCenter = r.averageCenter), this.ignoreHidden = !1, r.ignoreHidden !== void 0 && (this.ignoreHidden = r.ignoreHidden), this.enableRetinaIcons = !1, r.enableRetinaIcons !== void 0 && (this.enableRetinaIcons = r.enableRetinaIcons), this.imagePath = r.imagePath || sLe, this.imageExtension = r.imageExtension || aLe, this.imageSizes = r.imageSizes || lLe, this.calculator = r.calculator || rLe, this.batchSize = r.batchSize || oLe, this.batchSizeIE = r.batchSizeIE || iLe, this.clusterClass = r.clusterClass || uLe, navigator.userAgent.toLowerCase().indexOf("msie") !== -1 && (this.batchSize = this.batchSizeIE), this.timerRefStatic = null, this.setupStyles(), this.addMarkers(n, !0), this.setMap(t);
    }
    return e.prototype.onZoomChanged = function() {
      var t, n;
      this.resetViewport(!1), (((t = this.getMap()) === null || t === void 0 ? void 0 : t.getZoom()) === (this.get("minZoom") || 0) || ((n = this.getMap()) === null || n === void 0 ? void 0 : n.getZoom()) === this.get("maxZoom")) && google.maps.event.trigger(this, "idle");
    }, e.prototype.onIdle = function() {
      this.redraw();
    }, e.prototype.onAdd = function() {
      var t = this.getMap();
      this.activeMap = t, this.ready = !0, this.repaint(), t !== null && (this.listeners = [google.maps.event.addListener(t, "zoom_changed", this.onZoomChanged), google.maps.event.addListener(t, "idle", this.onIdle)]);
    }, e.prototype.onRemove = function() {
      for (var t = 0, n = this.markers; t < n.length; t++) {
        var r = n[t];
        r.getMap() !== this.activeMap && r.setMap(this.activeMap);
      }
      for (var o = 0, i = this.clusters; o < i.length; o++) {
        var a = i[o];
        a.remove();
      }
      this.clusters = [];
      for (var s = 0, l = this.listeners; s < l.length; s++) {
        var u = l[s];
        google.maps.event.removeListener(u);
      }
      this.listeners = [], this.activeMap = null, this.ready = !1;
    }, e.prototype.draw = function() {
    }, e.prototype.getMap = function() {
      return null;
    }, e.prototype.getPanes = function() {
      return null;
    }, e.prototype.getProjection = function() {
      return {
        fromContainerPixelToLatLng: function() {
          return null;
        },
        fromDivPixelToLatLng: function() {
          return null;
        },
        fromLatLngToContainerPixel: function() {
          return null;
        },
        fromLatLngToDivPixel: function() {
          return null;
        },
        getVisibleRegion: function() {
          return null;
        },
        getWorldWidth: function() {
          return 0;
        }
      };
    }, e.prototype.setMap = function() {
    }, e.prototype.addListener = function() {
      return {
        remove: function() {
        }
      };
    }, e.prototype.bindTo = function() {
    }, e.prototype.get = function() {
    }, e.prototype.notify = function() {
    }, e.prototype.set = function() {
    }, e.prototype.setValues = function() {
    }, e.prototype.unbind = function() {
    }, e.prototype.unbindAll = function() {
    }, e.prototype.setupStyles = function() {
      if (!(this.styles.length > 0))
        for (var t = 0; t < this.imageSizes.length; t++)
          this.styles.push({
            url: "".concat(this.imagePath + (t + 1), ".").concat(this.imageExtension),
            height: this.imageSizes[t] || 0,
            width: this.imageSizes[t] || 0
          });
    }, e.prototype.fitMapToMarkers = function() {
      for (var t = this.getMarkers(), n = new google.maps.LatLngBounds(), r = 0, o = t; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && n.extend(a);
      }
      var s = this.getMap();
      s !== null && "fitBounds" in s && s.fitBounds(n);
    }, e.prototype.getGridSize = function() {
      return this.gridSize;
    }, e.prototype.setGridSize = function(t) {
      this.gridSize = t;
    }, e.prototype.getMinimumClusterSize = function() {
      return this.minClusterSize;
    }, e.prototype.setMinimumClusterSize = function(t) {
      this.minClusterSize = t;
    }, e.prototype.getMaxZoom = function() {
      return this.maxZoom;
    }, e.prototype.setMaxZoom = function(t) {
      this.maxZoom = t;
    }, e.prototype.getStyles = function() {
      return this.styles;
    }, e.prototype.setStyles = function(t) {
      this.styles = t;
    }, e.prototype.getTitle = function() {
      return this.title;
    }, e.prototype.setTitle = function(t) {
      this.title = t;
    }, e.prototype.getZoomOnClick = function() {
      return this.zoomOnClick;
    }, e.prototype.setZoomOnClick = function(t) {
      this.zoomOnClick = t;
    }, e.prototype.getAverageCenter = function() {
      return this.averageCenter;
    }, e.prototype.setAverageCenter = function(t) {
      this.averageCenter = t;
    }, e.prototype.getIgnoreHidden = function() {
      return this.ignoreHidden;
    }, e.prototype.setIgnoreHidden = function(t) {
      this.ignoreHidden = t;
    }, e.prototype.getEnableRetinaIcons = function() {
      return this.enableRetinaIcons;
    }, e.prototype.setEnableRetinaIcons = function(t) {
      this.enableRetinaIcons = t;
    }, e.prototype.getImageExtension = function() {
      return this.imageExtension;
    }, e.prototype.setImageExtension = function(t) {
      this.imageExtension = t;
    }, e.prototype.getImagePath = function() {
      return this.imagePath;
    }, e.prototype.setImagePath = function(t) {
      this.imagePath = t;
    }, e.prototype.getImageSizes = function() {
      return this.imageSizes;
    }, e.prototype.setImageSizes = function(t) {
      this.imageSizes = t;
    }, e.prototype.getCalculator = function() {
      return this.calculator;
    }, e.prototype.setCalculator = function(t) {
      this.calculator = t;
    }, e.prototype.getBatchSizeIE = function() {
      return this.batchSizeIE;
    }, e.prototype.setBatchSizeIE = function(t) {
      this.batchSizeIE = t;
    }, e.prototype.getClusterClass = function() {
      return this.clusterClass;
    }, e.prototype.setClusterClass = function(t) {
      this.clusterClass = t;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getTotalMarkers = function() {
      return this.markers.length;
    }, e.prototype.getClusters = function() {
      return this.clusters;
    }, e.prototype.getTotalClusters = function() {
      return this.clusters.length;
    }, e.prototype.addMarker = function(t, n) {
      this.pushMarkerTo(t), n || this.redraw();
    }, e.prototype.addMarkers = function(t, n) {
      for (var r in t)
        if (Object.prototype.hasOwnProperty.call(t, r)) {
          var o = t[r];
          o && this.pushMarkerTo(o);
        }
      n || this.redraw();
    }, e.prototype.pushMarkerTo = function(t) {
      var n = this;
      t.getDraggable() && google.maps.event.addListener(t, "dragend", function() {
        n.ready && (t.isAdded = !1, n.repaint());
      }), t.isAdded = !1, this.markers.push(t);
    }, e.prototype.removeMarker_ = function(t) {
      var n = -1;
      if (this.markers.indexOf)
        n = this.markers.indexOf(t);
      else
        for (var r = 0; r < this.markers.length; r++)
          if (t === this.markers[r]) {
            n = r;
            break;
          }
      return n === -1 ? !1 : (t.setMap(null), this.markers.splice(n, 1), !0);
    }, e.prototype.removeMarker = function(t, n) {
      var r = this.removeMarker_(t);
      return !n && r && this.repaint(), r;
    }, e.prototype.removeMarkers = function(t, n) {
      for (var r = !1, o = 0, i = t; o < i.length; o++) {
        var a = i[o];
        r = r || this.removeMarker_(a);
      }
      return !n && r && this.repaint(), r;
    }, e.prototype.clearMarkers = function() {
      this.resetViewport(!0), this.markers = [];
    }, e.prototype.repaint = function() {
      var t = this.clusters.slice();
      this.clusters = [], this.resetViewport(!1), this.redraw(), setTimeout(function() {
        for (var n = 0, r = t; n < r.length; n++) {
          var o = r[n];
          o.remove();
        }
      }, 0);
    }, e.prototype.getExtendedBounds = function(t) {
      var n = this.getProjection(), r = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getNorthEast().lat(), t.getNorthEast().lng())
      );
      r !== null && (r.x += this.gridSize, r.y -= this.gridSize);
      var o = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getSouthWest().lat(), t.getSouthWest().lng())
      );
      if (o !== null && (o.x -= this.gridSize, o.y += this.gridSize), r !== null) {
        var i = n.fromDivPixelToLatLng(r);
        i !== null && t.extend(i);
      }
      if (o !== null) {
        var a = n.fromDivPixelToLatLng(o);
        a !== null && t.extend(a);
      }
      return t;
    }, e.prototype.redraw = function() {
      this.createClusters(0);
    }, e.prototype.resetViewport = function(t) {
      for (var n = 0, r = this.clusters; n < r.length; n++) {
        var o = r[n];
        o.remove();
      }
      this.clusters = [];
      for (var i = 0, a = this.markers; i < a.length; i++) {
        var s = a[i];
        s.isAdded = !1, t && s.setMap(null);
      }
    }, e.prototype.distanceBetweenPoints = function(t, n) {
      var r = 6371, o = (n.lat() - t.lat()) * Math.PI / 180, i = (n.lng() - t.lng()) * Math.PI / 180, a = Math.sin(o / 2) * Math.sin(o / 2) + Math.cos(t.lat() * Math.PI / 180) * Math.cos(n.lat() * Math.PI / 180) * Math.sin(i / 2) * Math.sin(i / 2);
      return r * (2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)));
    }, e.prototype.isMarkerInBounds = function(t, n) {
      var r = t.getPosition();
      return r ? n.contains(r) : !1;
    }, e.prototype.addToClosestCluster = function(t) {
      for (var n, r = 4e4, o = null, i = 0, a = this.clusters; i < a.length; i++) {
        var s = a[i];
        n = s;
        var l = n.getCenter(), u = t.getPosition();
        if (l && u) {
          var c = this.distanceBetweenPoints(l, u);
          c < r && (r = c, o = n);
        }
      }
      o && o.isMarkerInClusterBounds(t) ? o.addMarker(t) : (n = new nLe(this), n.addMarker(t), this.clusters.push(n));
    }, e.prototype.createClusters = function(t) {
      var n = this;
      if (this.ready) {
        t === 0 && (google.maps.event.trigger(this, "clusteringbegin", this), this.timerRefStatic !== null && (window.clearTimeout(this.timerRefStatic), delete this.timerRefStatic));
        for (var r = this.getMap(), o = r !== null && ("getBounds" in r) ? r.getBounds() : null, i = (r == null ? void 0 : r.getZoom()) || 0, a = i > 3 ? new google.maps.LatLngBounds(o == null ? void 0 : o.getSouthWest(), o == null ? void 0 : o.getNorthEast()) : new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625)), s = this.getExtendedBounds(a), l = Math.min(t + this.batchSize, this.markers.length), u = t; u < l; u++) {
          var c = this.markers[u];
          c && !c.isAdded && this.isMarkerInBounds(c, s) && (!this.ignoreHidden || this.ignoreHidden && c.getVisible()) && this.addToClosestCluster(c);
        }
        if (l < this.markers.length)
          this.timerRefStatic = window.setTimeout(function() {
            n.createClusters(l);
          }, 0);
        else {
          this.timerRefStatic = null, google.maps.event.trigger(this, "clusteringend", this);
          for (var p = 0, d = this.clusters; p < d.length; p++) {
            var h = d[p];
            h.updateIcon();
          }
        }
      }
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype) {
          var i = o;
          this.prototype[i] = r.prototype[i];
        }
        return this;
      }).apply(t, [n]);
    }, e;
  }()
);
function uF(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function cLe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? uF(Object(n), !0).forEach(function(r) {
      Oe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : uF(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var gi = {
  onClick: "click",
  onClusteringBegin: "clusteringbegin",
  onClusteringEnd: "clusteringend",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover"
}, hn = {
  averageCenter(e, t) {
    e.setAverageCenter(t);
  },
  batchSizeIE(e, t) {
    e.setBatchSizeIE(t);
  },
  calculator(e, t) {
    e.setCalculator(t);
  },
  clusterClass(e, t) {
    e.setClusterClass(t);
  },
  enableRetinaIcons(e, t) {
    e.setEnableRetinaIcons(t);
  },
  gridSize(e, t) {
    e.setGridSize(t);
  },
  ignoreHidden(e, t) {
    e.setIgnoreHidden(t);
  },
  imageExtension(e, t) {
    e.setImageExtension(t);
  },
  imagePath(e, t) {
    e.setImagePath(t);
  },
  imageSizes(e, t) {
    e.setImageSizes(t);
  },
  maxZoom(e, t) {
    e.setMaxZoom(t);
  },
  minimumClusterSize(e, t) {
    e.setMinimumClusterSize(t);
  },
  styles(e, t) {
    e.setStyles(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  zoomOnClick(e, t) {
    e.setZoomOnClick(t);
  }
}, pLe = {};
function dLe(e) {
  var {
    children: t,
    options: n,
    averageCenter: r,
    batchSizeIE: o,
    calculator: i,
    clusterClass: a,
    enableRetinaIcons: s,
    gridSize: l,
    ignoreHidden: u,
    imageExtension: c,
    imagePath: p,
    imageSizes: d,
    maxZoom: h,
    minimumClusterSize: f,
    styles: m,
    title: g,
    zoomOnClick: E,
    onClick: w,
    onClusteringBegin: M,
    onClusteringEnd: x,
    onMouseOver: y,
    onMouseOut: C,
    onLoad: P,
    onUnmount: F
  } = e, [L, N] = k(null), I = ye(Tt), [H, V] = k(null), [z, q] = k(null), [K, J] = k(null), [te, ee] = k(null), [_, D] = k(null);
  return v(() => {
    L && C && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(L, gi.onMouseOut, C)));
  }, [C]), v(() => {
    L && y && (_ !== null && google.maps.event.removeListener(_), D(google.maps.event.addListener(L, gi.onMouseOver, y)));
  }, [y]), v(() => {
    L && w && (H !== null && google.maps.event.removeListener(H), V(google.maps.event.addListener(L, gi.onClick, w)));
  }, [w]), v(() => {
    L && M && (z !== null && google.maps.event.removeListener(z), q(google.maps.event.addListener(L, gi.onClusteringBegin, M)));
  }, [M]), v(() => {
    L && x && (K !== null && google.maps.event.removeListener(K), q(google.maps.event.addListener(L, gi.onClusteringEnd, x)));
  }, [x]), v(() => {
    typeof r < "u" && L !== null && hn.averageCenter(L, r);
  }, [L, r]), v(() => {
    typeof o < "u" && L !== null && hn.batchSizeIE(L, o);
  }, [L, o]), v(() => {
    typeof i < "u" && L !== null && hn.calculator(L, i);
  }, [L, i]), v(() => {
    typeof a < "u" && L !== null && hn.clusterClass(L, a);
  }, [L, a]), v(() => {
    typeof s < "u" && L !== null && hn.enableRetinaIcons(L, s);
  }, [L, s]), v(() => {
    typeof l < "u" && L !== null && hn.gridSize(L, l);
  }, [L, l]), v(() => {
    typeof u < "u" && L !== null && hn.ignoreHidden(L, u);
  }, [L, u]), v(() => {
    typeof c < "u" && L !== null && hn.imageExtension(L, c);
  }, [L, c]), v(() => {
    typeof p < "u" && L !== null && hn.imagePath(L, p);
  }, [L, p]), v(() => {
    typeof d < "u" && L !== null && hn.imageSizes(L, d);
  }, [L, d]), v(() => {
    typeof h < "u" && L !== null && hn.maxZoom(L, h);
  }, [L, h]), v(() => {
    typeof f < "u" && L !== null && hn.minimumClusterSize(L, f);
  }, [L, f]), v(() => {
    typeof m < "u" && L !== null && hn.styles(L, m);
  }, [L, m]), v(() => {
    typeof g < "u" && L !== null && hn.title(L, g);
  }, [L, g]), v(() => {
    typeof E < "u" && L !== null && hn.zoomOnClick(L, E);
  }, [L, E]), v(() => {
    if (I) {
      var $ = cLe({}, n || pLe), S = new M8(I, [], $);
      return r && hn.averageCenter(S, r), o && hn.batchSizeIE(S, o), i && hn.calculator(S, i), a && hn.clusterClass(S, a), s && hn.enableRetinaIcons(S, s), l && hn.gridSize(S, l), u && hn.ignoreHidden(S, u), c && hn.imageExtension(S, c), p && hn.imagePath(S, p), d && hn.imageSizes(S, d), h && hn.maxZoom(S, h), f && hn.minimumClusterSize(S, f), m && hn.styles(S, m), g && hn.title(S, g), E && hn.zoomOnClick(S, E), C && ee(google.maps.event.addListener(S, gi.onMouseOut, C)), y && D(google.maps.event.addListener(S, gi.onMouseOver, y)), w && V(google.maps.event.addListener(S, gi.onClick, w)), M && q(google.maps.event.addListener(S, gi.onClusteringBegin, M)), x && J(google.maps.event.addListener(S, gi.onClusteringEnd, x)), N(S), P && P(S), () => {
        te !== null && google.maps.event.removeListener(te), _ !== null && google.maps.event.removeListener(_), H !== null && google.maps.event.removeListener(H), z !== null && google.maps.event.removeListener(z), K !== null && google.maps.event.removeListener(K), F && F(S);
      };
    }
  }, []), L !== null && t(L) || null;
}
Ee(dLe);
class fLe extends pe {
  constructor() {
    super(...arguments), Oe(this, "registeredEvents", []), Oe(this, "state", {
      markerClusterer: null
    }), Oe(this, "setClustererCallback", () => {
      this.state.markerClusterer !== null && this.props.onLoad && this.props.onLoad(this.state.markerClusterer);
    });
  }
  componentDidMount() {
    if (this.context) {
      var t = new M8(this.context, [], this.props.options);
      this.registeredEvents = nn({
        updaterMap: hn,
        eventMap: gi,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        markerClusterer: t
      }), this.setClustererCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.markerClusterer && (un(this.registeredEvents), this.registeredEvents = nn({
      updaterMap: hn,
      eventMap: gi,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.markerClusterer
    }));
  }
  componentWillUnmount() {
    this.state.markerClusterer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.markerClusterer), un(this.registeredEvents), this.state.markerClusterer.setMap(null));
  }
  render() {
    return this.state.markerClusterer !== null ? this.props.children(this.state.markerClusterer) : null;
  }
}
Oe(fLe, "contextType", Tt);
function cF(e) {
  e.cancelBubble = !0, e.stopPropagation && e.stopPropagation();
}
var D8 = (
  /** @class */
  function() {
    function e(t) {
      t === void 0 && (t = {}), this.getCloseClickHandler = this.getCloseClickHandler.bind(this), this.closeClickHandler = this.closeClickHandler.bind(this), this.createInfoBoxDiv = this.createInfoBoxDiv.bind(this), this.addClickHandler = this.addClickHandler.bind(this), this.getCloseBoxImg = this.getCloseBoxImg.bind(this), this.getBoxWidths = this.getBoxWidths.bind(this), this.setBoxStyle = this.setBoxStyle.bind(this), this.setPosition = this.setPosition.bind(this), this.getPosition = this.getPosition.bind(this), this.setOptions = this.setOptions.bind(this), this.setContent = this.setContent.bind(this), this.setVisible = this.setVisible.bind(this), this.getContent = this.getContent.bind(this), this.getVisible = this.getVisible.bind(this), this.setZIndex = this.setZIndex.bind(this), this.getZIndex = this.getZIndex.bind(this), this.onRemove = this.onRemove.bind(this), this.panBox = this.panBox.bind(this), this.extend = this.extend.bind(this), this.close = this.close.bind(this), this.draw = this.draw.bind(this), this.show = this.show.bind(this), this.hide = this.hide.bind(this), this.open = this.open.bind(this), this.extend(e, google.maps.OverlayView), this.content = t.content || "", this.disableAutoPan = t.disableAutoPan || !1, this.maxWidth = t.maxWidth || 0, this.pixelOffset = t.pixelOffset || new google.maps.Size(0, 0), this.position = t.position || new google.maps.LatLng(0, 0), this.zIndex = t.zIndex || null, this.boxClass = t.boxClass || "infoBox", this.boxStyle = t.boxStyle || {}, this.closeBoxMargin = t.closeBoxMargin || "2px", this.closeBoxURL = t.closeBoxURL || "http://www.google.com/intl/en_us/mapfiles/close.gif", t.closeBoxURL === "" && (this.closeBoxURL = ""), this.infoBoxClearance = t.infoBoxClearance || new google.maps.Size(1, 1), typeof t.visible > "u" && (typeof t.isHidden > "u" ? t.visible = !0 : t.visible = !t.isHidden), this.isHidden = !t.visible, this.alignBottom = t.alignBottom || !1, this.pane = t.pane || "floatPane", this.enableEventPropagation = t.enableEventPropagation || !1, this.div = null, this.closeListener = null, this.moveListener = null, this.mapListener = null, this.contextListener = null, this.eventListeners = null, this.fixedWidthSet = null;
    }
    return e.prototype.createInfoBoxDiv = function() {
      var t = this, n = function(u) {
        u.returnValue = !1, u.preventDefault && u.preventDefault(), t.enableEventPropagation || cF(u);
      };
      if (!this.div) {
        this.div = document.createElement("div"), this.setBoxStyle(), typeof this.content == "string" ? this.div.innerHTML = this.getCloseBoxImg() + this.content : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(this.content));
        var r = this.getPanes();
        if (r !== null && r[this.pane].appendChild(this.div), this.addClickHandler(), this.div.style.width)
          this.fixedWidthSet = !0;
        else if (this.maxWidth !== 0 && this.div.offsetWidth > this.maxWidth)
          this.div.style.width = this.maxWidth + "px", this.fixedWidthSet = !0;
        else {
          var o = this.getBoxWidths();
          this.div.style.width = this.div.offsetWidth - o.left - o.right + "px", this.fixedWidthSet = !1;
        }
        if (this.panBox(this.disableAutoPan), !this.enableEventPropagation) {
          this.eventListeners = [];
          for (var i = ["mousedown", "mouseover", "mouseout", "mouseup", "click", "dblclick", "touchstart", "touchend", "touchmove"], a = 0, s = i; a < s.length; a++) {
            var l = s[a];
            this.eventListeners.push(google.maps.event.addListener(this.div, l, cF));
          }
          this.eventListeners.push(google.maps.event.addListener(this.div, "mouseover", function() {
            t.div && (t.div.style.cursor = "default");
          }));
        }
        this.contextListener = google.maps.event.addListener(this.div, "contextmenu", n), google.maps.event.trigger(this, "domready");
      }
    }, e.prototype.getCloseBoxImg = function() {
      var t = "";
      return this.closeBoxURL !== "" && (t = '<img alt=""', t += ' aria-hidden="true"', t += " src='" + this.closeBoxURL + "'", t += " align=right", t += " style='", t += " position: relative;", t += " cursor: pointer;", t += " margin: " + this.closeBoxMargin + ";", t += "'>"), t;
    }, e.prototype.addClickHandler = function() {
      this.closeListener = this.div && this.div.firstChild && this.closeBoxURL !== "" ? google.maps.event.addListener(this.div.firstChild, "click", this.getCloseClickHandler()) : null;
    }, e.prototype.closeClickHandler = function(t) {
      t.cancelBubble = !0, t.stopPropagation && t.stopPropagation(), google.maps.event.trigger(this, "closeclick"), this.close();
    }, e.prototype.getCloseClickHandler = function() {
      return this.closeClickHandler;
    }, e.prototype.panBox = function(t) {
      if (this.div && !t) {
        var n = this.getMap();
        if (n instanceof google.maps.Map) {
          var r = 0, o = 0, i = n.getBounds();
          i && !i.contains(this.position) && n.setCenter(this.position);
          var a = n.getDiv(), s = a.offsetWidth, l = a.offsetHeight, u = this.pixelOffset.width, c = this.pixelOffset.height, p = this.div.offsetWidth, d = this.div.offsetHeight, h = this.infoBoxClearance.width, f = this.infoBoxClearance.height, m = this.getProjection(), g = m.fromLatLngToContainerPixel(this.position);
          g !== null && (g.x < -u + h ? r = g.x + u - h : g.x + p + u + h > s && (r = g.x + p + u + h - s), this.alignBottom ? g.y < -c + f + d ? o = g.y + c - f - d : g.y + c + f > l && (o = g.y + c + f - l) : g.y < -c + f ? o = g.y + c - f : g.y + d + c + f > l && (o = g.y + d + c + f - l)), r === 0 && o === 0 || n.panBy(r, o);
        }
      }
    }, e.prototype.setBoxStyle = function() {
      if (this.div) {
        this.div.className = this.boxClass, this.div.style.cssText = "";
        var t = this.boxStyle;
        for (var n in t)
          Object.prototype.hasOwnProperty.call(t, n) && (this.div.style[n] = t[n]);
        if (this.div.style.webkitTransform = "translateZ(0)", typeof this.div.style.opacity < "u" && this.div.style.opacity !== "") {
          var r = parseFloat(this.div.style.opacity || "");
          this.div.style.msFilter = '"progid:DXImageTransform.Microsoft.Alpha(Opacity=' + r * 100 + ')"', this.div.style.filter = "alpha(opacity=" + r * 100 + ")";
        }
        this.div.style.position = "absolute", this.div.style.visibility = "hidden", this.zIndex !== null && (this.div.style.zIndex = this.zIndex + ""), this.div.style.overflow || (this.div.style.overflow = "auto");
      }
    }, e.prototype.getBoxWidths = function() {
      var t = {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0
      };
      if (!this.div)
        return t;
      if (document.defaultView) {
        var n = this.div.ownerDocument, r = n && n.defaultView ? n.defaultView.getComputedStyle(this.div, "") : null;
        r && (t.top = parseInt(r.borderTopWidth || "", 10) || 0, t.bottom = parseInt(r.borderBottomWidth || "", 10) || 0, t.left = parseInt(r.borderLeftWidth || "", 10) || 0, t.right = parseInt(r.borderRightWidth || "", 10) || 0);
      } else if (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        document.documentElement.currentStyle
      ) {
        var o = this.div.currentStyle;
        o && (t.top = parseInt(o.borderTopWidth || "", 10) || 0, t.bottom = parseInt(o.borderBottomWidth || "", 10) || 0, t.left = parseInt(o.borderLeftWidth || "", 10) || 0, t.right = parseInt(o.borderRightWidth || "", 10) || 0);
      }
      return t;
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.div.parentNode.removeChild(this.div), this.div = null);
    }, e.prototype.draw = function() {
      if (this.createInfoBoxDiv(), this.div) {
        var t = this.getProjection(), n = t.fromLatLngToDivPixel(this.position);
        n !== null && (this.div.style.left = n.x + this.pixelOffset.width + "px", this.alignBottom ? this.div.style.bottom = -(n.y + this.pixelOffset.height) + "px" : this.div.style.top = n.y + this.pixelOffset.height + "px"), this.isHidden ? this.div.style.visibility = "hidden" : this.div.style.visibility = "visible";
      }
    }, e.prototype.setOptions = function(t) {
      t === void 0 && (t = {}), typeof t.boxClass < "u" && (this.boxClass = t.boxClass, this.setBoxStyle()), typeof t.boxStyle < "u" && (this.boxStyle = t.boxStyle, this.setBoxStyle()), typeof t.content < "u" && this.setContent(t.content), typeof t.disableAutoPan < "u" && (this.disableAutoPan = t.disableAutoPan), typeof t.maxWidth < "u" && (this.maxWidth = t.maxWidth), typeof t.pixelOffset < "u" && (this.pixelOffset = t.pixelOffset), typeof t.alignBottom < "u" && (this.alignBottom = t.alignBottom), typeof t.position < "u" && this.setPosition(t.position), typeof t.zIndex < "u" && this.setZIndex(t.zIndex), typeof t.closeBoxMargin < "u" && (this.closeBoxMargin = t.closeBoxMargin), typeof t.closeBoxURL < "u" && (this.closeBoxURL = t.closeBoxURL), typeof t.infoBoxClearance < "u" && (this.infoBoxClearance = t.infoBoxClearance), typeof t.isHidden < "u" && (this.isHidden = t.isHidden), typeof t.visible < "u" && (this.isHidden = !t.visible), typeof t.enableEventPropagation < "u" && (this.enableEventPropagation = t.enableEventPropagation), this.div && this.draw();
    }, e.prototype.setContent = function(t) {
      this.content = t, this.div && (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.fixedWidthSet || (this.div.style.width = ""), typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t)), this.fixedWidthSet || (this.div.style.width = this.div.offsetWidth + "px", typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t))), this.addClickHandler()), google.maps.event.trigger(this, "content_changed");
    }, e.prototype.setPosition = function(t) {
      this.position = t, this.div && this.draw(), google.maps.event.trigger(this, "position_changed");
    }, e.prototype.setVisible = function(t) {
      this.isHidden = !t, this.div && (this.div.style.visibility = this.isHidden ? "hidden" : "visible");
    }, e.prototype.setZIndex = function(t) {
      this.zIndex = t, this.div && (this.div.style.zIndex = t + ""), google.maps.event.trigger(this, "zindex_changed");
    }, e.prototype.getContent = function() {
      return this.content;
    }, e.prototype.getPosition = function() {
      return this.position;
    }, e.prototype.getZIndex = function() {
      return this.zIndex;
    }, e.prototype.getVisible = function() {
      var t = this.getMap();
      return typeof t > "u" || t === null ? !1 : !this.isHidden;
    }, e.prototype.show = function() {
      this.isHidden = !1, this.div && (this.div.style.visibility = "visible");
    }, e.prototype.hide = function() {
      this.isHidden = !0, this.div && (this.div.style.visibility = "hidden");
    }, e.prototype.open = function(t, n) {
      var r = this;
      n && (this.position = n.getPosition(), this.moveListener = google.maps.event.addListener(n, "position_changed", function() {
        var o = n.getPosition();
        r.setPosition(o);
      }), this.mapListener = google.maps.event.addListener(n, "map_changed", function() {
        r.setMap(n.map);
      })), this.setMap(t), this.div && this.panBox();
    }, e.prototype.close = function() {
      if (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.eventListeners) {
        for (var t = 0, n = this.eventListeners; t < n.length; t++) {
          var r = n[t];
          google.maps.event.removeListener(r);
        }
        this.eventListeners = null;
      }
      this.moveListener && (google.maps.event.removeListener(this.moveListener), this.moveListener = null), this.mapListener && (google.maps.event.removeListener(this.mapListener), this.mapListener = null), this.contextListener && (google.maps.event.removeListener(this.contextListener), this.contextListener = null), this.setMap(null);
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype)
          Object.prototype.hasOwnProperty.call(this, o) || (this.prototype[o] = r.prototype[o]);
        return this;
      }).apply(t, [n]);
    }, e;
  }()
), hLe = ["position"], gLe = ["position"];
function pF(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function dm(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? pF(Object(n), !0).forEach(function(r) {
      Oe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : pF(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var dF = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, fF = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    t instanceof google.maps.LatLng ? e.setPosition(t) : e.setPosition(new google.maps.LatLng(t.lat, t.lng));
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, mLe = {};
function vLe(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, h = ye(Tt), [f, m] = k(null), [g, E] = k(null), [w, M] = k(null), [x, y] = k(null), [C, P] = k(null), [F, L] = k(null), N = rt(null);
  return v(() => {
    h && f !== null && (f.close(), n ? f.open(h, n) : f.getPosition() && f.open(h));
  }, [h, f, n]), v(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), v(() => {
    if (o && f !== null) {
      var I = o instanceof google.maps.LatLng ? o : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        new google.maps.LatLng(o.lat, o.lng)
      );
      f.setPosition(I);
    }
  }, [o]), v(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), v(() => {
    f && a && (g !== null && google.maps.event.removeListener(g), E(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), v(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), M(google.maps.event.addListener(f, "domready", s)));
  }, [s]), v(() => {
    f && l && (x !== null && google.maps.event.removeListener(x), y(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), v(() => {
    f && u && (C !== null && google.maps.event.removeListener(C), P(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), v(() => {
    f && c && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), v(() => {
    if (h) {
      var I = r || mLe, {
        position: H
      } = I, V = a1(I, hLe), z;
      H && !(H instanceof google.maps.LatLng) && (z = new google.maps.LatLng(H.lat, H.lng));
      var q = new D8(dm(dm({}, V), z ? {
        position: z
      } : {}));
      N.current = document.createElement("div"), m(q), a && E(google.maps.event.addListener(q, "closeclick", a)), s && M(google.maps.event.addListener(q, "domready", s)), l && y(google.maps.event.addListener(q, "content_changed", l)), u && P(google.maps.event.addListener(q, "position_changed", u)), c && L(google.maps.event.addListener(q, "zindex_changed", c)), q.setContent(N.current), n ? q.open(h, n) : q.getPosition() ? q.open(h) : Kr(!1, "You must provide either an anchor or a position prop for <InfoBox>."), p && p(q);
    }
    return () => {
      f !== null && (g && google.maps.event.removeListener(g), x && google.maps.event.removeListener(x), w && google.maps.event.removeListener(w), C && google.maps.event.removeListener(C), F && google.maps.event.removeListener(F), d && d(f), f.close());
    };
  }, []), N.current ? yr(at.only(t), N.current) : null;
}
Ee(vLe);
class yLe extends pe {
  constructor() {
    super(...arguments), Oe(this, "registeredEvents", []), Oe(this, "containerElement", null), Oe(this, "state", {
      infoBox: null
    }), Oe(this, "open", (t, n) => {
      n ? this.context !== null && t.open(this.context, n) : t.getPosition() ? this.context !== null && t.open(this.context) : Kr(!1, "You must provide either an anchor or a position prop for <InfoBox>.");
    }), Oe(this, "setInfoBoxCallback", () => {
      this.state.infoBox !== null && this.containerElement !== null && (this.state.infoBox.setContent(this.containerElement), this.open(this.state.infoBox, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoBox));
    });
  }
  componentDidMount() {
    var t = this.props.options || {}, {
      position: n
    } = t, r = a1(t, gLe), o;
    n && !(n instanceof google.maps.LatLng) && (o = new google.maps.LatLng(n.lat, n.lng));
    var i = new D8(dm(dm({}, r), o ? {
      position: o
    } : {}));
    this.containerElement = document.createElement("div"), this.registeredEvents = nn({
      updaterMap: fF,
      eventMap: dF,
      prevProps: {},
      nextProps: this.props,
      instance: i
    }), this.setState({
      infoBox: i
    }, this.setInfoBoxCallback);
  }
  componentDidUpdate(t) {
    var {
      infoBox: n
    } = this.state;
    n !== null && (un(this.registeredEvents), this.registeredEvents = nn({
      updaterMap: fF,
      eventMap: dF,
      prevProps: t,
      nextProps: this.props,
      instance: n
    }));
  }
  componentWillUnmount() {
    var {
      onUnmount: t
    } = this.props, {
      infoBox: n
    } = this.state;
    n !== null && (t && t(n), un(this.registeredEvents), n.close());
  }
  render() {
    return this.containerElement ? yr(at.only(this.props.children), this.containerElement) : null;
  }
}
Oe(yLe, "contextType", Tt);
var hF, gF;
function bLe() {
  return gF || (gF = 1, hF = function e(t, n) {
    if (t === n) return !0;
    if (t && n && typeof t == "object" && typeof n == "object") {
      if (t.constructor !== n.constructor) return !1;
      var r, o, i;
      if (Array.isArray(t)) {
        if (r = t.length, r != n.length) return !1;
        for (o = r; o-- !== 0; ) if (!e(t[o], n[o])) return !1;
        return !0;
      }
      if (t.constructor === RegExp) return t.source === n.source && t.flags === n.flags;
      if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === n.valueOf();
      if (t.toString !== Object.prototype.toString) return t.toString() === n.toString();
      if (i = Object.keys(t), r = i.length, r !== Object.keys(n).length) return !1;
      for (o = r; o-- !== 0; ) if (!Object.prototype.hasOwnProperty.call(n, i[o])) return !1;
      for (o = r; o-- !== 0; ) {
        var a = i[o];
        if (!e(t[a], n[a])) return !1;
      }
      return !0;
    }
    return t !== t && n !== n;
  }), hF;
}
var wLe = bLe(), mF = /* @__PURE__ */ E8(wLe), vF = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array], pw = 1, nc = 8;
class l1 {
  /**
   * Creates an index from raw `ArrayBuffer` data.
   * @param {ArrayBuffer} data
   */
  static from(t) {
    if (!(t instanceof ArrayBuffer))
      throw new Error("Data must be an instance of ArrayBuffer.");
    var [n, r] = new Uint8Array(t, 0, 2);
    if (n !== 219)
      throw new Error("Data does not appear to be in a KDBush format.");
    var o = r >> 4;
    if (o !== pw)
      throw new Error("Got v".concat(o, " data when expected v").concat(pw, "."));
    var i = vF[r & 15];
    if (!i)
      throw new Error("Unrecognized array type.");
    var [a] = new Uint16Array(t, 2, 1), [s] = new Uint32Array(t, 4, 1);
    return new l1(s, a, i, t);
  }
  /**
   * Creates an index that will hold a given number of items.
   * @param {number} numItems
   * @param {number} [nodeSize=64] Size of the KD-tree node (64 by default).
   * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).
   * @param {ArrayBuffer} [data] (For internal use only)
   */
  constructor(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 64, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Float64Array, o = arguments.length > 3 ? arguments[3] : void 0;
    if (isNaN(t) || t < 0) throw new Error("Unpexpected numItems value: ".concat(t, "."));
    this.numItems = +t, this.nodeSize = Math.min(Math.max(+n, 2), 65535), this.ArrayType = r, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
    var i = vF.indexOf(this.ArrayType), a = t * 2 * this.ArrayType.BYTES_PER_ELEMENT, s = t * this.IndexArrayType.BYTES_PER_ELEMENT, l = (8 - s % 8) % 8;
    if (i < 0)
      throw new Error("Unexpected typed array class: ".concat(r, "."));
    o && o instanceof ArrayBuffer ? (this.data = o, this.ids = new this.IndexArrayType(this.data, nc, t), this.coords = new this.ArrayType(this.data, nc + s + l, t * 2), this._pos = t * 2, this._finished = !0) : (this.data = new ArrayBuffer(nc + a + s + l), this.ids = new this.IndexArrayType(this.data, nc, t), this.coords = new this.ArrayType(this.data, nc + s + l, t * 2), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, (pw << 4) + i]), new Uint16Array(this.data, 2, 1)[0] = n, new Uint32Array(this.data, 4, 1)[0] = t);
  }
  /**
   * Add a point to the index.
   * @param {number} x
   * @param {number} y
   * @returns {number} An incremental index associated with the added item (starting from `0`).
   */
  add(t, n) {
    var r = this._pos >> 1;
    return this.ids[r] = r, this.coords[this._pos++] = t, this.coords[this._pos++] = n, r;
  }
  /**
   * Perform indexing of the added points.
   */
  finish() {
    var t = this._pos >> 1;
    if (t !== this.numItems)
      throw new Error("Added ".concat(t, " items when expected ").concat(this.numItems, "."));
    return Sx(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
  }
  /**
   * Search the index for items within a given bounding box.
   * @param {number} minX
   * @param {number} minY
   * @param {number} maxX
   * @param {number} maxY
   * @returns {number[]} An array of indices correponding to the found items.
   */
  range(t, n, r, o) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: i,
      coords: a,
      nodeSize: s
    } = this, l = [0, i.length - 1, 0], u = []; l.length; ) {
      var c = l.pop() || 0, p = l.pop() || 0, d = l.pop() || 0;
      if (p - d <= s) {
        for (var h = d; h <= p; h++) {
          var f = a[2 * h], m = a[2 * h + 1];
          f >= t && f <= r && m >= n && m <= o && u.push(i[h]);
        }
        continue;
      }
      var g = d + p >> 1, E = a[2 * g], w = a[2 * g + 1];
      E >= t && E <= r && w >= n && w <= o && u.push(i[g]), (c === 0 ? t <= E : n <= w) && (l.push(d), l.push(g - 1), l.push(1 - c)), (c === 0 ? r >= E : o >= w) && (l.push(g + 1), l.push(p), l.push(1 - c));
    }
    return u;
  }
  /**
   * Search the index for items within a given radius.
   * @param {number} qx
   * @param {number} qy
   * @param {number} r Query radius.
   * @returns {number[]} An array of indices correponding to the found items.
   */
  within(t, n, r) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: o,
      coords: i,
      nodeSize: a
    } = this, s = [0, o.length - 1, 0], l = [], u = r * r; s.length; ) {
      var c = s.pop() || 0, p = s.pop() || 0, d = s.pop() || 0;
      if (p - d <= a) {
        for (var h = d; h <= p; h++)
          yF(i[2 * h], i[2 * h + 1], t, n) <= u && l.push(o[h]);
        continue;
      }
      var f = d + p >> 1, m = i[2 * f], g = i[2 * f + 1];
      yF(m, g, t, n) <= u && l.push(o[f]), (c === 0 ? t - r <= m : n - r <= g) && (s.push(d), s.push(f - 1), s.push(1 - c)), (c === 0 ? t + r >= m : n + r >= g) && (s.push(f + 1), s.push(p), s.push(1 - c));
    }
    return l;
  }
}
function Sx(e, t, n, r, o, i) {
  if (!(o - r <= n)) {
    var a = r + o >> 1;
    T8(e, t, a, r, o, i), Sx(e, t, n, r, a - 1, 1 - i), Sx(e, t, n, a + 1, o, 1 - i);
  }
}
function T8(e, t, n, r, o, i) {
  for (; o > r; ) {
    if (o - r > 600) {
      var a = o - r + 1, s = n - r + 1, l = Math.log(a), u = 0.5 * Math.exp(2 * l / 3), c = 0.5 * Math.sqrt(l * u * (a - u) / a) * (s - a / 2 < 0 ? -1 : 1), p = Math.max(r, Math.floor(n - s * u / a + c)), d = Math.min(o, Math.floor(n + (a - s) * u / a + c));
      T8(e, t, n, p, d, i);
    }
    var h = t[2 * n + i], f = r, m = o;
    for (rc(e, t, r, n), t[2 * o + i] > h && rc(e, t, r, o); f < m; ) {
      for (rc(e, t, f, m), f++, m--; t[2 * f + i] < h; ) f++;
      for (; t[2 * m + i] > h; ) m--;
    }
    t[2 * r + i] === h ? rc(e, t, r, m) : (m++, rc(e, t, m, o)), m <= n && (r = m + 1), n <= m && (o = m - 1);
  }
}
function rc(e, t, n, r) {
  dw(e, n, r), dw(t, 2 * n, 2 * r), dw(t, 2 * n + 1, 2 * r + 1);
}
function dw(e, t, n) {
  var r = e[t];
  e[t] = e[n], e[n] = r;
}
function yF(e, t, n, r) {
  var o = e - n, i = t - r;
  return o * o + i * i;
}
var CLe = {
  minZoom: 0,
  // min zoom to generate clusters on
  maxZoom: 16,
  // max zoom level to cluster the points on
  minPoints: 2,
  // minimum points to form a cluster
  radius: 40,
  // cluster radius in pixels
  extent: 512,
  // tile extent (radius is calculated relative to it)
  nodeSize: 64,
  // size of the KD-tree leaf node, affects performance
  log: !1,
  // whether to log timing info
  // whether to generate numeric ids for input features (in vector tiles)
  generateId: !1,
  // a reduce function for calculating custom cluster properties
  reduce: null,
  // (accumulated, props) => { accumulated.sum += props.sum; }
  // properties to use for individual points when running the reducer
  map: (e) => e
  // props => ({sum: props.my_value})
}, bF = Math.fround || /* @__PURE__ */ ((e) => (t) => (e[0] = +t, e[0]))(new Float32Array(1)), Ha = 2, ta = 3, fw = 4, Xs = 5, j8 = 6;
class xLe {
  constructor(t) {
    this.options = Object.assign(Object.create(CLe), t), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
  }
  load(t) {
    var {
      log: n,
      minZoom: r,
      maxZoom: o
    } = this.options;
    n && console.time("total time");
    var i = "prepare ".concat(t.length, " points");
    n && console.time(i), this.points = t;
    for (var a = [], s = 0; s < t.length; s++) {
      var l = t[s];
      if (l.geometry) {
        var [u, c] = l.geometry.coordinates, p = bF(sh(u)), d = bF(ah(c));
        a.push(
          p,
          d,
          // projected point coordinates
          1 / 0,
          // the last zoom the point was processed at
          s,
          // index of the source feature in the original input array
          -1,
          // parent cluster id
          1
          // number of points in a cluster
        ), this.options.reduce && a.push(0);
      }
    }
    var h = this.trees[o + 1] = this._createTree(a);
    n && console.timeEnd(i);
    for (var f = o; f >= r; f--) {
      var m = +Date.now();
      h = this.trees[f] = this._createTree(this._cluster(h, f)), n && console.log("z%d: %d clusters in %dms", f, h.numItems, +Date.now() - m);
    }
    return n && console.timeEnd("total time"), this;
  }
  getClusters(t, n) {
    var r = ((t[0] + 180) % 360 + 360) % 360 - 180, o = Math.max(-90, Math.min(90, t[1])), i = t[2] === 180 ? 180 : ((t[2] + 180) % 360 + 360) % 360 - 180, a = Math.max(-90, Math.min(90, t[3]));
    if (t[2] - t[0] >= 360)
      r = -180, i = 180;
    else if (r > i) {
      var s = this.getClusters([r, o, 180, a], n), l = this.getClusters([-180, o, i, a], n);
      return s.concat(l);
    }
    var u = this.trees[this._limitZoom(n)], c = u.range(sh(r), ah(a), sh(i), ah(o)), p = u.data, d = [];
    for (var h of c) {
      var f = this.stride * h;
      d.push(p[f + Xs] > 1 ? wF(p, f, this.clusterProps) : this.points[p[f + ta]]);
    }
    return d;
  }
  getChildren(t) {
    var n = this._getOriginId(t), r = this._getOriginZoom(t), o = "No cluster with the specified id.", i = this.trees[r];
    if (!i) throw new Error(o);
    var a = i.data;
    if (n * this.stride >= a.length) throw new Error(o);
    var s = this.options.radius / (this.options.extent * Math.pow(2, r - 1)), l = a[n * this.stride], u = a[n * this.stride + 1], c = i.within(l, u, s), p = [];
    for (var d of c) {
      var h = d * this.stride;
      a[h + fw] === t && p.push(a[h + Xs] > 1 ? wF(a, h, this.clusterProps) : this.points[a[h + ta]]);
    }
    if (p.length === 0) throw new Error(o);
    return p;
  }
  getLeaves(t, n, r) {
    n = n || 10, r = r || 0;
    var o = [];
    return this._appendLeaves(o, t, n, r, 0), o;
  }
  getTile(t, n, r) {
    var o = this.trees[this._limitZoom(t)], i = Math.pow(2, t), {
      extent: a,
      radius: s
    } = this.options, l = s / a, u = (r - l) / i, c = (r + 1 + l) / i, p = {
      features: []
    };
    return this._addTileFeatures(o.range((n - l) / i, u, (n + 1 + l) / i, c), o.data, n, r, i, p), n === 0 && this._addTileFeatures(o.range(1 - l / i, u, 1, c), o.data, i, r, i, p), n === i - 1 && this._addTileFeatures(o.range(0, u, l / i, c), o.data, -1, r, i, p), p.features.length ? p : null;
  }
  getClusterExpansionZoom(t) {
    for (var n = this._getOriginZoom(t) - 1; n <= this.options.maxZoom; ) {
      var r = this.getChildren(t);
      if (n++, r.length !== 1) break;
      t = r[0].properties.cluster_id;
    }
    return n;
  }
  _appendLeaves(t, n, r, o, i) {
    var a = this.getChildren(n);
    for (var s of a) {
      var l = s.properties;
      if (l && l.cluster ? i + l.point_count <= o ? i += l.point_count : i = this._appendLeaves(t, l.cluster_id, r, o, i) : i < o ? i++ : t.push(s), t.length === r) break;
    }
    return i;
  }
  _createTree(t) {
    for (var n = new l1(t.length / this.stride | 0, this.options.nodeSize, Float32Array), r = 0; r < t.length; r += this.stride) n.add(t[r], t[r + 1]);
    return n.finish(), n.data = t, n;
  }
  _addTileFeatures(t, n, r, o, i, a) {
    for (var s of t) {
      var l = s * this.stride, u = n[l + Xs] > 1, c = void 0, p = void 0, d = void 0;
      if (u)
        c = A8(n, l, this.clusterProps), p = n[l], d = n[l + 1];
      else {
        var h = this.points[n[l + ta]];
        c = h.properties;
        var [f, m] = h.geometry.coordinates;
        p = sh(f), d = ah(m);
      }
      var g = {
        type: 1,
        geometry: [[Math.round(this.options.extent * (p * i - r)), Math.round(this.options.extent * (d * i - o))]],
        tags: c
      }, E = void 0;
      u || this.options.generateId ? E = n[l + ta] : E = this.points[n[l + ta]].id, E !== void 0 && (g.id = E), a.features.push(g);
    }
  }
  _limitZoom(t) {
    return Math.max(this.options.minZoom, Math.min(Math.floor(+t), this.options.maxZoom + 1));
  }
  _cluster(t, n) {
    for (var {
      radius: r,
      extent: o,
      reduce: i,
      minPoints: a
    } = this.options, s = r / (o * Math.pow(2, n)), l = t.data, u = [], c = this.stride, p = 0; p < l.length; p += c)
      if (!(l[p + Ha] <= n)) {
        l[p + Ha] = n;
        var d = l[p], h = l[p + 1], f = t.within(l[p], l[p + 1], s), m = l[p + Xs], g = m;
        for (var E of f) {
          var w = E * c;
          l[w + Ha] > n && (g += l[w + Xs]);
        }
        if (g > m && g >= a) {
          var M = d * m, x = h * m, y = void 0, C = -1, P = ((p / c | 0) << 5) + (n + 1) + this.points.length;
          for (var F of f) {
            var L = F * c;
            if (!(l[L + Ha] <= n)) {
              l[L + Ha] = n;
              var N = l[L + Xs];
              M += l[L] * N, x += l[L + 1] * N, l[L + fw] = P, i && (y || (y = this._map(l, p, !0), C = this.clusterProps.length, this.clusterProps.push(y)), i(y, this._map(l, L)));
            }
          }
          l[p + fw] = P, u.push(M / g, x / g, 1 / 0, P, -1, g), i && u.push(C);
        } else {
          for (var I = 0; I < c; I++) u.push(l[p + I]);
          if (g > 1)
            for (var H of f) {
              var V = H * c;
              if (!(l[V + Ha] <= n)) {
                l[V + Ha] = n;
                for (var z = 0; z < c; z++) u.push(l[V + z]);
              }
            }
        }
      }
    return u;
  }
  // get index of the point from which the cluster originated
  _getOriginId(t) {
    return t - this.points.length >> 5;
  }
  // get zoom of the point from which the cluster originated
  _getOriginZoom(t) {
    return (t - this.points.length) % 32;
  }
  _map(t, n, r) {
    if (t[n + Xs] > 1) {
      var o = this.clusterProps[t[n + j8]];
      return r ? Object.assign({}, o) : o;
    }
    var i = this.points[t[n + ta]].properties, a = this.options.map(i);
    return r && a === i ? Object.assign({}, a) : a;
  }
}
function wF(e, t, n) {
  return {
    type: "Feature",
    id: e[t + ta],
    properties: A8(e, t, n),
    geometry: {
      type: "Point",
      coordinates: [OLe(e[t]), ELe(e[t + 1])]
    }
  };
}
function A8(e, t, n) {
  var r = e[t + Xs], o = r >= 1e4 ? "".concat(Math.round(r / 1e3), "k") : r >= 1e3 ? "".concat(Math.round(r / 100) / 10, "k") : r, i = e[t + j8], a = i === -1 ? {} : Object.assign({}, n[i]);
  return Object.assign(a, {
    cluster: !0,
    cluster_id: e[t + ta],
    point_count: r,
    point_count_abbreviated: o
  });
}
function sh(e) {
  return e / 360 + 0.5;
}
function ah(e) {
  var t = Math.sin(e * Math.PI / 180), n = 0.5 - 0.25 * Math.log((1 + t) / (1 - t)) / Math.PI;
  return n < 0 ? 0 : n > 1 ? 1 : n;
}
function OLe(e) {
  return (e - 0.5) * 360;
}
function ELe(e) {
  var t = (180 - e * 360) * Math.PI / 180;
  return 360 * Math.atan(Math.exp(t)) / Math.PI - 90;
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function kLe(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
    t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
  return n;
}
class Yo {
  static isAdvancedMarkerAvailable(t) {
    return google.maps.marker && t.getMapCapabilities().isAdvancedMarkersAvailable === !0;
  }
  static isAdvancedMarker(t) {
    return google.maps.marker && t instanceof google.maps.marker.AdvancedMarkerElement;
  }
  static setMap(t, n) {
    this.isAdvancedMarker(t) ? t.map = n : t.setMap(n);
  }
  static getPosition(t) {
    if (this.isAdvancedMarker(t)) {
      if (t.position) {
        if (t.position instanceof google.maps.LatLng)
          return t.position;
        if (t.position.lat && t.position.lng)
          return new google.maps.LatLng(t.position.lat, t.position.lng);
      }
      return new google.maps.LatLng(null);
    }
    return t.getPosition();
  }
  static getVisible(t) {
    return this.isAdvancedMarker(t) ? !0 : t.getVisible();
  }
}
class Mx {
  constructor(t) {
    var {
      markers: n,
      position: r
    } = t;
    this.markers = n, r && (r instanceof google.maps.LatLng ? this._position = r : this._position = new google.maps.LatLng(r));
  }
  get bounds() {
    if (!(this.markers.length === 0 && !this._position)) {
      var t = new google.maps.LatLngBounds(this._position, this._position);
      for (var n of this.markers)
        t.extend(Yo.getPosition(n));
      return t;
    }
  }
  get position() {
    return this._position || this.bounds.getCenter();
  }
  /**
   * Get the count of **visible** markers.
   */
  get count() {
    return this.markers.filter((t) => Yo.getVisible(t)).length;
  }
  /**
   * Add a marker to the cluster.
   */
  push(t) {
    this.markers.push(t);
  }
  /**
   * Cleanup references and remove marker from map.
   */
  delete() {
    this.marker && (Yo.setMap(this.marker, null), this.marker = void 0), this.markers.length = 0;
  }
}
class LLe {
  constructor(t) {
    var {
      maxZoom: n = 16
    } = t;
    this.maxZoom = n;
  }
  /**
   * Helper function to bypass clustering based upon some map state such as
   * zoom, number of markers, etc.
   *
   * ```typescript
   *  cluster({markers, map}: AlgorithmInput): Cluster[] {
   *    if (shouldBypassClustering(map)) {
   *      return this.noop({markers})
   *    }
   * }
   * ```
   */
  noop(t) {
    var {
      markers: n
    } = t;
    return _Le(n);
  }
}
var _Le = (e) => {
  var t = e.map((n) => new Mx({
    position: Yo.getPosition(n),
    markers: [n]
  }));
  return t;
};
class PLe extends LLe {
  constructor(t) {
    var {
      maxZoom: n,
      radius: r = 60
    } = t, o = kLe(t, ["maxZoom", "radius"]);
    super({
      maxZoom: n
    }), this.state = {
      zoom: -1
    }, this.superCluster = new xLe(Object.assign({
      maxZoom: this.maxZoom,
      radius: r
    }, o));
  }
  calculate(t) {
    var n = !1, r = {
      zoom: t.map.getZoom()
    };
    if (!mF(t.markers, this.markers)) {
      n = !0, this.markers = [...t.markers];
      var o = this.markers.map((i) => {
        var a = Yo.getPosition(i), s = [a.lng(), a.lat()];
        return {
          type: "Feature",
          geometry: {
            type: "Point",
            coordinates: s
          },
          properties: {
            marker: i
          }
        };
      });
      this.superCluster.load(o);
    }
    return n || (this.state.zoom <= this.maxZoom || r.zoom <= this.maxZoom) && (n = !mF(this.state, r)), this.state = r, n && (this.clusters = this.cluster(t)), {
      clusters: this.clusters,
      changed: n
    };
  }
  cluster(t) {
    var {
      map: n
    } = t;
    return this.superCluster.getClusters([-180, -90, 180, 90], Math.round(n.getZoom())).map((r) => this.transformCluster(r));
  }
  transformCluster(t) {
    var {
      geometry: {
        coordinates: [n, r]
      },
      properties: o
    } = t;
    if (o.cluster)
      return new Mx({
        markers: this.superCluster.getLeaves(o.cluster_id, 1 / 0).map((a) => a.properties.marker),
        position: {
          lat: r,
          lng: n
        }
      });
    var i = o.marker;
    return new Mx({
      markers: [i],
      position: Yo.getPosition(i)
    });
  }
}
class SLe {
  constructor(t, n) {
    this.markers = {
      sum: t.length
    };
    var r = n.map((i) => i.count), o = r.reduce((i, a) => i + a, 0);
    this.clusters = {
      count: n.length,
      markers: {
        mean: o / n.length,
        sum: o,
        min: Math.min(...r),
        max: Math.max(...r)
      }
    };
  }
}
class MLe {
  /**
   * The default render function for the library used by {@link MarkerClusterer}.
   *
   * Currently set to use the following:
   *
   * ```typescript
   * // change color if this cluster has more markers than the mean cluster
   * const color =
   *   count > Math.max(10, stats.clusters.markers.mean)
   *     ? "#ff0000"
   *     : "#0000ff";
   *
   * // create svg url with fill color
   * const svg = window.btoa(`
   * <svg fill="${color}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240">
   *   <circle cx="120" cy="120" opacity=".6" r="70" />
   *   <circle cx="120" cy="120" opacity=".3" r="90" />
   *   <circle cx="120" cy="120" opacity=".2" r="110" />
   *   <circle cx="120" cy="120" opacity=".1" r="130" />
   * </svg>`);
   *
   * // create marker using svg icon
   * return new google.maps.Marker({
   *   position,
   *   icon: {
   *     url: `data:image/svg+xml;base64,${svg}`,
   *     scaledSize: new google.maps.Size(45, 45),
   *   },
   *   label: {
   *     text: String(count),
   *     color: "rgba(255,255,255,0.9)",
   *     fontSize: "12px",
   *   },
   *   // adjust zIndex to be above other markers
   *   zIndex: 1000 + count,
   * });
   * ```
   */
  render(t, n, r) {
    var {
      count: o,
      position: i
    } = t, a = o > Math.max(10, n.clusters.markers.mean) ? "#ff0000" : "#0000ff", s = '<svg fill="'.concat(a, `" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" width="50" height="50">
<circle cx="120" cy="120" opacity=".6" r="70" />
<circle cx="120" cy="120" opacity=".3" r="90" />
<circle cx="120" cy="120" opacity=".2" r="110" />
<text x="50%" y="50%" style="fill:#fff" text-anchor="middle" font-size="50" dominant-baseline="middle" font-family="roboto,arial,sans-serif">`).concat(o, `</text>
</svg>`), l = "Cluster of ".concat(o, " markers"), u = Number(google.maps.Marker.MAX_ZINDEX) + o;
    if (Yo.isAdvancedMarkerAvailable(r)) {
      var c = new DOMParser(), p = c.parseFromString(s, "image/svg+xml").documentElement;
      p.setAttribute("transform", "translate(0 25)");
      var d = {
        map: r,
        position: i,
        zIndex: u,
        title: l,
        content: p
      };
      return new google.maps.marker.AdvancedMarkerElement(d);
    }
    var h = {
      position: i,
      zIndex: u,
      title: l,
      icon: {
        url: "data:image/svg+xml;base64,".concat(btoa(s)),
        anchor: new google.maps.Point(25, 25)
      }
    };
    return new google.maps.Marker(h);
  }
}
function DLe(e, t) {
  for (var n in t.prototype)
    e.prototype[n] = t.prototype[n];
}
class u1 {
  constructor() {
    DLe(u1, google.maps.OverlayView);
  }
}
var $c;
(function(e) {
  e.CLUSTERING_BEGIN = "clusteringbegin", e.CLUSTERING_END = "clusteringend", e.CLUSTER_CLICK = "click";
})($c || ($c = {}));
var TLe = (e, t, n) => {
  n.fitBounds(t.bounds);
};
class jLe extends u1 {
  constructor(t) {
    var {
      map: n,
      markers: r = [],
      algorithmOptions: o = {},
      algorithm: i = new PLe(o),
      renderer: a = new MLe(),
      onClusterClick: s = TLe
    } = t;
    super(), this.markers = [...r], this.clusters = [], this.algorithm = i, this.renderer = a, this.onClusterClick = s, n && this.setMap(n);
  }
  addMarker(t, n) {
    this.markers.includes(t) || (this.markers.push(t), n || this.render());
  }
  addMarkers(t, n) {
    t.forEach((r) => {
      this.addMarker(r, !0);
    }), n || this.render();
  }
  removeMarker(t, n) {
    var r = this.markers.indexOf(t);
    return r === -1 ? !1 : (Yo.setMap(t, null), this.markers.splice(r, 1), n || this.render(), !0);
  }
  removeMarkers(t, n) {
    var r = !1;
    return t.forEach((o) => {
      r = this.removeMarker(o, !0) || r;
    }), r && !n && this.render(), r;
  }
  clearMarkers(t) {
    this.markers.length = 0, t || this.render();
  }
  /**
   * Recalculates and draws all the marker clusters.
   */
  render() {
    var t = this.getMap();
    if (t instanceof google.maps.Map && t.getProjection()) {
      google.maps.event.trigger(this, $c.CLUSTERING_BEGIN, this);
      var {
        clusters: n,
        changed: r
      } = this.algorithm.calculate({
        markers: this.markers,
        map: t,
        mapCanvasProjection: this.getProjection()
      });
      if (r || r == null) {
        var o = /* @__PURE__ */ new Set();
        for (var i of n)
          i.markers.length == 1 && o.add(i.markers[0]);
        var a = [];
        for (var s of this.clusters)
          s.marker != null && (s.markers.length == 1 ? o.has(s.marker) || Yo.setMap(s.marker, null) : a.push(s.marker));
        this.clusters = n, this.renderClusters(), requestAnimationFrame(() => a.forEach((l) => Yo.setMap(l, null)));
      }
      google.maps.event.trigger(this, $c.CLUSTERING_END, this);
    }
  }
  onAdd() {
    this.idleListener = this.getMap().addListener("idle", this.render.bind(this)), this.render();
  }
  onRemove() {
    google.maps.event.removeListener(this.idleListener), this.reset();
  }
  reset() {
    this.markers.forEach((t) => Yo.setMap(t, null)), this.clusters.forEach((t) => t.delete()), this.clusters = [];
  }
  renderClusters() {
    var t = new SLe(this.markers, this.clusters), n = this.getMap();
    this.clusters.forEach((r) => {
      r.markers.length === 1 ? r.marker = r.markers[0] : (r.marker = this.renderer.render(r, t, n), r.markers.forEach((o) => Yo.setMap(o, null)), this.onClusterClick && r.marker.addListener(
        "click",
        /* istanbul ignore next */
        (o) => {
          google.maps.event.trigger(this, $c.CLUSTER_CLICK, r), this.onClusterClick(o, r, n);
        }
      )), Yo.setMap(r.marker, n);
    });
  }
}
function CF(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function xF(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? CF(Object(n), !0).forEach(function(r) {
      Oe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : CF(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function ALe(e) {
  var t = T1e(), [n, r] = k(null);
  return v(() => {
    if (t && n === null) {
      var o = new jLe(xF(xF({}, e), {}, {
        map: t
      }));
      r(o);
    }
  }, [t]), n;
}
function BLe(e) {
  var {
    children: t,
    options: n
  } = e, r = ALe(n);
  return r !== null ? t(r) : null;
}
Ee(BLe);
var OF = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, EF = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
function ILe(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, h = ye(Tt), [f, m] = k(null), [g, E] = k(null), [w, M] = k(null), [x, y] = k(null), [C, P] = k(null), [F, L] = k(null), N = rt(null);
  return v(() => {
    f !== null && (f.close(), n ? f.open(h, n) : f.getPosition() && f.open(h));
  }, [h, f, n]), v(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), v(() => {
    o && f !== null && f.setPosition(o);
  }, [o]), v(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), v(() => {
    f && a && (g !== null && google.maps.event.removeListener(g), E(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), v(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), M(google.maps.event.addListener(f, "domready", s)));
  }, [s]), v(() => {
    f && l && (x !== null && google.maps.event.removeListener(x), y(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), v(() => {
    f && u && (C !== null && google.maps.event.removeListener(C), P(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), v(() => {
    f && c && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), v(() => {
    var I = new google.maps.InfoWindow(r);
    return m(I), N.current = document.createElement("div"), a && E(google.maps.event.addListener(I, "closeclick", a)), s && M(google.maps.event.addListener(I, "domready", s)), l && y(google.maps.event.addListener(I, "content_changed", l)), u && P(google.maps.event.addListener(I, "position_changed", u)), c && L(google.maps.event.addListener(I, "zindex_changed", c)), I.setContent(N.current), o && I.setPosition(o), i && I.setZIndex(i), n ? I.open(h, n) : I.getPosition() ? I.open(h) : Kr(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>."), p && p(I), () => {
      g && google.maps.event.removeListener(g), x && google.maps.event.removeListener(x), w && google.maps.event.removeListener(w), C && google.maps.event.removeListener(C), F && google.maps.event.removeListener(F), d && d(I), I.close();
    };
  }, []), N.current ? yr(at.only(t), N.current) : null;
}
Ee(ILe);
class RLe extends pe {
  constructor() {
    super(...arguments), Oe(this, "registeredEvents", []), Oe(this, "containerElement", null), Oe(this, "state", {
      infoWindow: null
    }), Oe(this, "open", (t, n) => {
      n ? t.open(this.context, n) : t.getPosition() ? t.open(this.context) : Kr(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>.");
    }), Oe(this, "setInfoWindowCallback", () => {
      this.state.infoWindow !== null && this.containerElement !== null && (this.state.infoWindow.setContent(this.containerElement), this.open(this.state.infoWindow, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoWindow));
    });
  }
  componentDidMount() {
    var t = new google.maps.InfoWindow(this.props.options);
    this.containerElement = document.createElement("div"), this.registeredEvents = nn({
      updaterMap: EF,
      eventMap: OF,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(() => ({
      infoWindow: t
    }), this.setInfoWindowCallback);
  }
  componentDidUpdate(t) {
    this.state.infoWindow !== null && (un(this.registeredEvents), this.registeredEvents = nn({
      updaterMap: EF,
      eventMap: OF,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.infoWindow
    }));
  }
  componentWillUnmount() {
    this.state.infoWindow !== null && (un(this.registeredEvents), this.props.onUnmount && this.props.onUnmount(this.state.infoWindow), this.state.infoWindow.close());
  }
  render() {
    return this.containerElement ? yr(at.only(this.props.children), this.containerElement) : null;
  }
}
Oe(RLe, "contextType", Tt);
function kF(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function fm(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? kF(Object(n), !0).forEach(function(r) {
      Oe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : kF(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var LF = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, _F = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, NLe = {};
function FLe(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: h,
    onRightClick: f,
    onClick: m,
    onDrag: g,
    onLoad: E,
    onUnmount: w
  } = e, M = ye(Tt), [x, y] = k(null), [C, P] = k(null), [F, L] = k(null), [N, I] = k(null), [H, V] = k(null), [z, q] = k(null), [K, J] = k(null), [te, ee] = k(null), [_, D] = k(null), [$, S] = k(null), [W, O] = k(null), [T, U] = k(null);
  return v(() => {
    x !== null && x.setMap(M);
  }, [M]), v(() => {
    typeof t < "u" && x !== null && x.setOptions(t);
  }, [x, t]), v(() => {
    typeof n < "u" && x !== null && x.setDraggable(n);
  }, [x, n]), v(() => {
    typeof r < "u" && x !== null && x.setEditable(r);
  }, [x, r]), v(() => {
    typeof o < "u" && x !== null && x.setVisible(o);
  }, [x, o]), v(() => {
    typeof i < "u" && x !== null && x.setPath(i);
  }, [x, i]), v(() => {
    x && a && (C !== null && google.maps.event.removeListener(C), P(google.maps.event.addListener(x, "dblclick", a)));
  }, [a]), v(() => {
    x && s && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(x, "dragend", s)));
  }, [s]), v(() => {
    x && l && (N !== null && google.maps.event.removeListener(N), I(google.maps.event.addListener(x, "dragstart", l)));
  }, [l]), v(() => {
    x && u && (H !== null && google.maps.event.removeListener(H), V(google.maps.event.addListener(x, "mousedown", u)));
  }, [u]), v(() => {
    x && c && (z !== null && google.maps.event.removeListener(z), q(google.maps.event.addListener(x, "mousemove", c)));
  }, [c]), v(() => {
    x && p && (K !== null && google.maps.event.removeListener(K), J(google.maps.event.addListener(x, "mouseout", p)));
  }, [p]), v(() => {
    x && d && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(x, "mouseover", d)));
  }, [d]), v(() => {
    x && h && (_ !== null && google.maps.event.removeListener(_), D(google.maps.event.addListener(x, "mouseup", h)));
  }, [h]), v(() => {
    x && f && ($ !== null && google.maps.event.removeListener($), S(google.maps.event.addListener(x, "rightclick", f)));
  }, [f]), v(() => {
    x && m && (W !== null && google.maps.event.removeListener(W), O(google.maps.event.addListener(x, "click", m)));
  }, [m]), v(() => {
    x && g && (T !== null && google.maps.event.removeListener(T), U(google.maps.event.addListener(x, "drag", g)));
  }, [g]), v(() => {
    var j = new google.maps.Polyline(fm(fm({}, t || NLe), {}, {
      map: M
    }));
    return i && j.setPath(i), typeof o < "u" && j.setVisible(o), typeof r < "u" && j.setEditable(r), typeof n < "u" && j.setDraggable(n), a && P(google.maps.event.addListener(j, "dblclick", a)), s && L(google.maps.event.addListener(j, "dragend", s)), l && I(google.maps.event.addListener(j, "dragstart", l)), u && V(google.maps.event.addListener(j, "mousedown", u)), c && q(google.maps.event.addListener(j, "mousemove", c)), p && J(google.maps.event.addListener(j, "mouseout", p)), d && ee(google.maps.event.addListener(j, "mouseover", d)), h && D(google.maps.event.addListener(j, "mouseup", h)), f && S(google.maps.event.addListener(j, "rightclick", f)), m && O(google.maps.event.addListener(j, "click", m)), g && U(google.maps.event.addListener(j, "drag", g)), y(j), E && E(j), () => {
      C !== null && google.maps.event.removeListener(C), F !== null && google.maps.event.removeListener(F), N !== null && google.maps.event.removeListener(N), H !== null && google.maps.event.removeListener(H), z !== null && google.maps.event.removeListener(z), K !== null && google.maps.event.removeListener(K), te !== null && google.maps.event.removeListener(te), _ !== null && google.maps.event.removeListener(_), $ !== null && google.maps.event.removeListener($), W !== null && google.maps.event.removeListener(W), w && w(j), j.setMap(null);
    };
  }, []), null;
}
Ee(FLe);
class zLe extends pe {
  constructor() {
    super(...arguments), Oe(this, "registeredEvents", []), Oe(this, "state", {
      polyline: null
    }), Oe(this, "setPolylineCallback", () => {
      this.state.polyline !== null && this.props.onLoad && this.props.onLoad(this.state.polyline);
    });
  }
  componentDidMount() {
    var t = new google.maps.Polyline(fm(fm({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = nn({
      updaterMap: _F,
      eventMap: LF,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        polyline: t
      };
    }, this.setPolylineCallback);
  }
  componentDidUpdate(t) {
    this.state.polyline !== null && (un(this.registeredEvents), this.registeredEvents = nn({
      updaterMap: _F,
      eventMap: LF,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.polyline
    }));
  }
  componentWillUnmount() {
    this.state.polyline !== null && (this.props.onUnmount && this.props.onUnmount(this.state.polyline), un(this.registeredEvents), this.state.polyline.setMap(null));
  }
  render() {
    return null;
  }
}
Oe(zLe, "contextType", Tt);
function PF(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function SF(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? PF(Object(n), !0).forEach(function(r) {
      Oe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : PF(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var MF = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, DF = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  paths(e, t) {
    e.setPaths(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function ULe(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    paths: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: h,
    onMouseUp: f,
    onRightClick: m,
    onClick: g,
    onDrag: E,
    onLoad: w,
    onUnmount: M,
    onEdit: x
  } = e, y = ye(Tt), [C, P] = k(null), [F, L] = k(null), [N, I] = k(null), [H, V] = k(null), [z, q] = k(null), [K, J] = k(null), [te, ee] = k(null), [_, D] = k(null), [$, S] = k(null), [W, O] = k(null), [T, U] = k(null), [j, Z] = k(null);
  return v(() => {
    C !== null && C.setMap(y);
  }, [y]), v(() => {
    typeof t < "u" && C !== null && C.setOptions(t);
  }, [C, t]), v(() => {
    typeof n < "u" && C !== null && C.setDraggable(n);
  }, [C, n]), v(() => {
    typeof r < "u" && C !== null && C.setEditable(r);
  }, [C, r]), v(() => {
    typeof o < "u" && C !== null && C.setVisible(o);
  }, [C, o]), v(() => {
    typeof i < "u" && C !== null && C.setPath(i);
  }, [C, i]), v(() => {
    typeof a < "u" && C !== null && C.setPaths(a);
  }, [C, a]), v(() => {
    C && typeof s == "function" && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(C, "dblclick", s)));
  }, [s]), v(() => {
    C && (google.maps.event.addListener(C.getPath(), "insert_at", () => {
      x == null || x(C);
    }), google.maps.event.addListener(C.getPath(), "set_at", () => {
      x == null || x(C);
    }), google.maps.event.addListener(C.getPath(), "remove_at", () => {
      x == null || x(C);
    }));
  }, [C, x]), v(() => {
    C && typeof l == "function" && (N !== null && google.maps.event.removeListener(N), I(google.maps.event.addListener(C, "dragend", l)));
  }, [l]), v(() => {
    C && typeof u == "function" && (H !== null && google.maps.event.removeListener(H), V(google.maps.event.addListener(C, "dragstart", u)));
  }, [u]), v(() => {
    C && typeof c == "function" && (z !== null && google.maps.event.removeListener(z), q(google.maps.event.addListener(C, "mousedown", c)));
  }, [c]), v(() => {
    C && typeof p == "function" && (K !== null && google.maps.event.removeListener(K), J(google.maps.event.addListener(C, "mousemove", p)));
  }, [p]), v(() => {
    C && typeof d == "function" && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(C, "mouseout", d)));
  }, [d]), v(() => {
    C && typeof h == "function" && (_ !== null && google.maps.event.removeListener(_), D(google.maps.event.addListener(C, "mouseover", h)));
  }, [h]), v(() => {
    C && typeof f == "function" && ($ !== null && google.maps.event.removeListener($), S(google.maps.event.addListener(C, "mouseup", f)));
  }, [f]), v(() => {
    C && typeof m == "function" && (W !== null && google.maps.event.removeListener(W), O(google.maps.event.addListener(C, "rightclick", m)));
  }, [m]), v(() => {
    C && typeof g == "function" && (T !== null && google.maps.event.removeListener(T), U(google.maps.event.addListener(C, "click", g)));
  }, [g]), v(() => {
    C && typeof E == "function" && (j !== null && google.maps.event.removeListener(j), Z(google.maps.event.addListener(C, "drag", E)));
  }, [E]), v(() => {
    var A = new google.maps.Polygon(SF(SF({}, t), {}, {
      map: y
    }));
    return i && A.setPath(i), a && A.setPaths(a), typeof o < "u" && A.setVisible(o), typeof r < "u" && A.setEditable(r), typeof n < "u" && A.setDraggable(n), s && L(google.maps.event.addListener(A, "dblclick", s)), l && I(google.maps.event.addListener(A, "dragend", l)), u && V(google.maps.event.addListener(A, "dragstart", u)), c && q(google.maps.event.addListener(A, "mousedown", c)), p && J(google.maps.event.addListener(A, "mousemove", p)), d && ee(google.maps.event.addListener(A, "mouseout", d)), h && D(google.maps.event.addListener(A, "mouseover", h)), f && S(google.maps.event.addListener(A, "mouseup", f)), m && O(google.maps.event.addListener(A, "rightclick", m)), g && U(google.maps.event.addListener(A, "click", g)), E && Z(google.maps.event.addListener(A, "drag", E)), P(A), w && w(A), () => {
      F !== null && google.maps.event.removeListener(F), N !== null && google.maps.event.removeListener(N), H !== null && google.maps.event.removeListener(H), z !== null && google.maps.event.removeListener(z), K !== null && google.maps.event.removeListener(K), te !== null && google.maps.event.removeListener(te), _ !== null && google.maps.event.removeListener(_), $ !== null && google.maps.event.removeListener($), W !== null && google.maps.event.removeListener(W), T !== null && google.maps.event.removeListener(T), M && M(A), A.setMap(null);
    };
  }, []), null;
}
Ee(ULe);
class $Le extends pe {
  constructor() {
    super(...arguments), Oe(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this.props.options || {};
    this.polygon = new google.maps.Polygon(t), this.polygon.setMap(this.context), this.registeredEvents = nn({
      updaterMap: DF,
      eventMap: MF,
      prevProps: {},
      nextProps: this.props,
      instance: this.polygon
    }), this.props.onLoad && this.props.onLoad(this.polygon);
  }
  componentDidUpdate(t) {
    this.polygon && (un(this.registeredEvents), this.registeredEvents = nn({
      updaterMap: DF,
      eventMap: MF,
      prevProps: t,
      nextProps: this.props,
      instance: this.polygon
    }));
  }
  componentWillUnmount() {
    this.polygon && (this.props.onUnmount && this.props.onUnmount(this.polygon), un(this.registeredEvents), this.polygon && this.polygon.setMap(null));
  }
  render() {
    return null;
  }
}
Oe($Le, "contextType", Tt);
function TF(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function hm(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? TF(Object(n), !0).forEach(function(r) {
      Oe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : TF(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var jF = {
  onBoundsChanged: "bounds_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, AF = {
  bounds(e, t) {
    e.setBounds(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function HLe(e) {
  var {
    options: t,
    bounds: n,
    draggable: r,
    editable: o,
    visible: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: h,
    onRightClick: f,
    onClick: m,
    onDrag: g,
    onBoundsChanged: E,
    onLoad: w,
    onUnmount: M
  } = e, x = ye(Tt), [y, C] = k(null), [P, F] = k(null), [L, N] = k(null), [I, H] = k(null), [V, z] = k(null), [q, K] = k(null), [J, te] = k(null), [ee, _] = k(null), [D, $] = k(null), [S, W] = k(null), [O, T] = k(null), [U, j] = k(null), [Z, A] = k(null);
  return v(() => {
    y !== null && y.setMap(x);
  }, [x]), v(() => {
    typeof t < "u" && y !== null && y.setOptions(t);
  }, [y, t]), v(() => {
    typeof r < "u" && y !== null && y.setDraggable(r);
  }, [y, r]), v(() => {
    typeof o < "u" && y !== null && y.setEditable(o);
  }, [y, o]), v(() => {
    typeof i < "u" && y !== null && y.setVisible(i);
  }, [y, i]), v(() => {
    typeof n < "u" && y !== null && y.setBounds(n);
  }, [y, n]), v(() => {
    y && a && (P !== null && google.maps.event.removeListener(P), F(google.maps.event.addListener(y, "dblclick", a)));
  }, [a]), v(() => {
    y && s && (L !== null && google.maps.event.removeListener(L), N(google.maps.event.addListener(y, "dragend", s)));
  }, [s]), v(() => {
    y && l && (I !== null && google.maps.event.removeListener(I), H(google.maps.event.addListener(y, "dragstart", l)));
  }, [l]), v(() => {
    y && u && (V !== null && google.maps.event.removeListener(V), z(google.maps.event.addListener(y, "mousedown", u)));
  }, [u]), v(() => {
    y && c && (q !== null && google.maps.event.removeListener(q), K(google.maps.event.addListener(y, "mousemove", c)));
  }, [c]), v(() => {
    y && p && (J !== null && google.maps.event.removeListener(J), te(google.maps.event.addListener(y, "mouseout", p)));
  }, [p]), v(() => {
    y && d && (ee !== null && google.maps.event.removeListener(ee), _(google.maps.event.addListener(y, "mouseover", d)));
  }, [d]), v(() => {
    y && h && (D !== null && google.maps.event.removeListener(D), $(google.maps.event.addListener(y, "mouseup", h)));
  }, [h]), v(() => {
    y && f && (S !== null && google.maps.event.removeListener(S), W(google.maps.event.addListener(y, "rightclick", f)));
  }, [f]), v(() => {
    y && m && (O !== null && google.maps.event.removeListener(O), T(google.maps.event.addListener(y, "click", m)));
  }, [m]), v(() => {
    y && g && (U !== null && google.maps.event.removeListener(U), j(google.maps.event.addListener(y, "drag", g)));
  }, [g]), v(() => {
    y && E && (Z !== null && google.maps.event.removeListener(Z), A(google.maps.event.addListener(y, "bounds_changed", E)));
  }, [E]), v(() => {
    var Q = new google.maps.Rectangle(hm(hm({}, t), {}, {
      map: x
    }));
    return typeof i < "u" && Q.setVisible(i), typeof o < "u" && Q.setEditable(o), typeof r < "u" && Q.setDraggable(r), typeof n < "u" && Q.setBounds(n), a && F(google.maps.event.addListener(Q, "dblclick", a)), s && N(google.maps.event.addListener(Q, "dragend", s)), l && H(google.maps.event.addListener(Q, "dragstart", l)), u && z(google.maps.event.addListener(Q, "mousedown", u)), c && K(google.maps.event.addListener(Q, "mousemove", c)), p && te(google.maps.event.addListener(Q, "mouseout", p)), d && _(google.maps.event.addListener(Q, "mouseover", d)), h && $(google.maps.event.addListener(Q, "mouseup", h)), f && W(google.maps.event.addListener(Q, "rightclick", f)), m && T(google.maps.event.addListener(Q, "click", m)), g && j(google.maps.event.addListener(Q, "drag", g)), E && A(google.maps.event.addListener(Q, "bounds_changed", E)), C(Q), w && w(Q), () => {
      P !== null && google.maps.event.removeListener(P), L !== null && google.maps.event.removeListener(L), I !== null && google.maps.event.removeListener(I), V !== null && google.maps.event.removeListener(V), q !== null && google.maps.event.removeListener(q), J !== null && google.maps.event.removeListener(J), ee !== null && google.maps.event.removeListener(ee), D !== null && google.maps.event.removeListener(D), S !== null && google.maps.event.removeListener(S), O !== null && google.maps.event.removeListener(O), U !== null && google.maps.event.removeListener(U), Z !== null && google.maps.event.removeListener(Z), M && M(Q), Q.setMap(null);
    };
  }, []), null;
}
Ee(HLe);
class WLe extends pe {
  constructor() {
    super(...arguments), Oe(this, "registeredEvents", []), Oe(this, "state", {
      rectangle: null
    }), Oe(this, "setRectangleCallback", () => {
      this.state.rectangle !== null && this.props.onLoad && this.props.onLoad(this.state.rectangle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Rectangle(hm(hm({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = nn({
      updaterMap: AF,
      eventMap: jF,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        rectangle: t
      };
    }, this.setRectangleCallback);
  }
  componentDidUpdate(t) {
    this.state.rectangle !== null && (un(this.registeredEvents), this.registeredEvents = nn({
      updaterMap: AF,
      eventMap: jF,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.rectangle
    }));
  }
  componentWillUnmount() {
    this.state.rectangle !== null && (this.props.onUnmount && this.props.onUnmount(this.state.rectangle), un(this.registeredEvents), this.state.rectangle.setMap(null));
  }
  render() {
    return null;
  }
}
Oe(WLe, "contextType", Tt);
function BF(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function gm(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? BF(Object(n), !0).forEach(function(r) {
      Oe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : BF(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var IF = {
  onCenterChanged: "center_changed",
  onRadiusChanged: "radius_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, RF = {
  center(e, t) {
    e.setCenter(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  radius(e, t) {
    e.setRadius(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, VLe = {};
function qLe(e) {
  var {
    options: t,
    center: n,
    radius: r,
    draggable: o,
    editable: i,
    visible: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: h,
    onMouseUp: f,
    onRightClick: m,
    onClick: g,
    onDrag: E,
    onCenterChanged: w,
    onRadiusChanged: M,
    onLoad: x,
    onUnmount: y
  } = e, C = ye(Tt), [P, F] = k(null), [L, N] = k(null), [I, H] = k(null), [V, z] = k(null), [q, K] = k(null), [J, te] = k(null), [ee, _] = k(null), [D, $] = k(null), [S, W] = k(null), [O, T] = k(null), [U, j] = k(null), [Z, A] = k(null), [Q, R] = k(null), [ue, fe] = k(null);
  return v(() => {
    P !== null && P.setMap(C);
  }, [C]), v(() => {
    typeof t < "u" && P !== null && P.setOptions(t);
  }, [P, t]), v(() => {
    typeof o < "u" && P !== null && P.setDraggable(o);
  }, [P, o]), v(() => {
    typeof i < "u" && P !== null && P.setEditable(i);
  }, [P, i]), v(() => {
    typeof a < "u" && P !== null && P.setVisible(a);
  }, [P, a]), v(() => {
    typeof r == "number" && P !== null && P.setRadius(r);
  }, [P, r]), v(() => {
    typeof n < "u" && P !== null && P.setCenter(n);
  }, [P, n]), v(() => {
    P && s && (L !== null && google.maps.event.removeListener(L), N(google.maps.event.addListener(P, "dblclick", s)));
  }, [s]), v(() => {
    P && l && (I !== null && google.maps.event.removeListener(I), H(google.maps.event.addListener(P, "dragend", l)));
  }, [l]), v(() => {
    P && u && (V !== null && google.maps.event.removeListener(V), z(google.maps.event.addListener(P, "dragstart", u)));
  }, [u]), v(() => {
    P && c && (q !== null && google.maps.event.removeListener(q), K(google.maps.event.addListener(P, "mousedown", c)));
  }, [c]), v(() => {
    P && p && (J !== null && google.maps.event.removeListener(J), te(google.maps.event.addListener(P, "mousemove", p)));
  }, [p]), v(() => {
    P && d && (ee !== null && google.maps.event.removeListener(ee), _(google.maps.event.addListener(P, "mouseout", d)));
  }, [d]), v(() => {
    P && h && (D !== null && google.maps.event.removeListener(D), $(google.maps.event.addListener(P, "mouseover", h)));
  }, [h]), v(() => {
    P && f && (S !== null && google.maps.event.removeListener(S), W(google.maps.event.addListener(P, "mouseup", f)));
  }, [f]), v(() => {
    P && m && (O !== null && google.maps.event.removeListener(O), T(google.maps.event.addListener(P, "rightclick", m)));
  }, [m]), v(() => {
    P && g && (U !== null && google.maps.event.removeListener(U), j(google.maps.event.addListener(P, "click", g)));
  }, [g]), v(() => {
    P && E && (Z !== null && google.maps.event.removeListener(Z), A(google.maps.event.addListener(P, "drag", E)));
  }, [E]), v(() => {
    P && w && (Q !== null && google.maps.event.removeListener(Q), R(google.maps.event.addListener(P, "center_changed", w)));
  }, [g]), v(() => {
    P && M && (ue !== null && google.maps.event.removeListener(ue), fe(google.maps.event.addListener(P, "radius_changed", M)));
  }, [M]), v(() => {
    var oe = new google.maps.Circle(gm(gm({}, t || VLe), {}, {
      map: C
    }));
    return typeof r == "number" && oe.setRadius(r), typeof n < "u" && oe.setCenter(n), typeof r == "number" && oe.setRadius(r), typeof a < "u" && oe.setVisible(a), typeof i < "u" && oe.setEditable(i), typeof o < "u" && oe.setDraggable(o), s && N(google.maps.event.addListener(oe, "dblclick", s)), l && H(google.maps.event.addListener(oe, "dragend", l)), u && z(google.maps.event.addListener(oe, "dragstart", u)), c && K(google.maps.event.addListener(oe, "mousedown", c)), p && te(google.maps.event.addListener(oe, "mousemove", p)), d && _(google.maps.event.addListener(oe, "mouseout", d)), h && $(google.maps.event.addListener(oe, "mouseover", h)), f && W(google.maps.event.addListener(oe, "mouseup", f)), m && T(google.maps.event.addListener(oe, "rightclick", m)), g && j(google.maps.event.addListener(oe, "click", g)), E && A(google.maps.event.addListener(oe, "drag", E)), w && R(google.maps.event.addListener(oe, "center_changed", w)), M && fe(google.maps.event.addListener(oe, "radius_changed", M)), F(oe), x && x(oe), () => {
      L !== null && google.maps.event.removeListener(L), I !== null && google.maps.event.removeListener(I), V !== null && google.maps.event.removeListener(V), q !== null && google.maps.event.removeListener(q), J !== null && google.maps.event.removeListener(J), ee !== null && google.maps.event.removeListener(ee), D !== null && google.maps.event.removeListener(D), S !== null && google.maps.event.removeListener(S), O !== null && google.maps.event.removeListener(O), U !== null && google.maps.event.removeListener(U), Q !== null && google.maps.event.removeListener(Q), ue !== null && google.maps.event.removeListener(ue), y && y(oe), oe.setMap(null);
    };
  }, []), null;
}
Ee(qLe);
class ZLe extends pe {
  constructor() {
    super(...arguments), Oe(this, "registeredEvents", []), Oe(this, "state", {
      circle: null
    }), Oe(this, "setCircleCallback", () => {
      this.state.circle !== null && this.props.onLoad && this.props.onLoad(this.state.circle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Circle(gm(gm({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = nn({
      updaterMap: RF,
      eventMap: IF,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        circle: t
      };
    }, this.setCircleCallback);
  }
  componentDidUpdate(t) {
    this.state.circle !== null && (un(this.registeredEvents), this.registeredEvents = nn({
      updaterMap: RF,
      eventMap: IF,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.circle
    }));
  }
  componentWillUnmount() {
    if (this.state.circle !== null) {
      var t;
      this.props.onUnmount && this.props.onUnmount(this.state.circle), un(this.registeredEvents), (t = this.state.circle) === null || t === void 0 || t.setMap(null);
    }
  }
  render() {
    return null;
  }
}
Oe(ZLe, "contextType", Tt);
function NF(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function mm(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? NF(Object(n), !0).forEach(function(r) {
      Oe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : NF(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var FF = {
  onClick: "click",
  onDblClick: "dblclick",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onAddFeature: "addfeature",
  onRemoveFeature: "removefeature",
  onRemoveProperty: "removeproperty",
  onSetGeometry: "setgeometry",
  onSetProperty: "setproperty"
}, zF = {
  add(e, t) {
    e.add(t);
  },
  addgeojson(e, t, n) {
    e.addGeoJson(t, n);
  },
  contains(e, t) {
    e.contains(t);
  },
  foreach(e, t) {
    e.forEach(t);
  },
  loadgeojson(e, t, n, r) {
    e.loadGeoJson(t, n, r);
  },
  overridestyle(e, t, n) {
    e.overrideStyle(t, n);
  },
  remove(e, t) {
    e.remove(t);
  },
  revertstyle(e, t) {
    e.revertStyle(t);
  },
  controlposition(e, t) {
    e.setControlPosition(t);
  },
  controls(e, t) {
    e.setControls(t);
  },
  drawingmode(e, t) {
    e.setDrawingMode(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  style(e, t) {
    e.setStyle(t);
  },
  togeojson(e, t) {
    e.toGeoJson(t);
  }
};
function GLe(e) {
  var {
    options: t,
    onClick: n,
    onDblClick: r,
    onMouseDown: o,
    onMouseMove: i,
    onMouseOut: a,
    onMouseOver: s,
    onMouseUp: l,
    onRightClick: u,
    onAddFeature: c,
    onRemoveFeature: p,
    onRemoveProperty: d,
    onSetGeometry: h,
    onSetProperty: f,
    onLoad: m,
    onUnmount: g
  } = e, E = ye(Tt), [w, M] = k(null), [x, y] = k(null), [C, P] = k(null), [F, L] = k(null), [N, I] = k(null), [H, V] = k(null), [z, q] = k(null), [K, J] = k(null), [te, ee] = k(null), [_, D] = k(null), [$, S] = k(null), [W, O] = k(null), [T, U] = k(null), [j, Z] = k(null);
  return v(() => {
    w !== null && w.setMap(E);
  }, [E]), v(() => {
    w && r && (x !== null && google.maps.event.removeListener(x), y(google.maps.event.addListener(w, "dblclick", r)));
  }, [r]), v(() => {
    w && o && (C !== null && google.maps.event.removeListener(C), P(google.maps.event.addListener(w, "mousedown", o)));
  }, [o]), v(() => {
    w && i && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(w, "mousemove", i)));
  }, [i]), v(() => {
    w && a && (N !== null && google.maps.event.removeListener(N), I(google.maps.event.addListener(w, "mouseout", a)));
  }, [a]), v(() => {
    w && s && (H !== null && google.maps.event.removeListener(H), V(google.maps.event.addListener(w, "mouseover", s)));
  }, [s]), v(() => {
    w && l && (z !== null && google.maps.event.removeListener(z), q(google.maps.event.addListener(w, "mouseup", l)));
  }, [l]), v(() => {
    w && u && (K !== null && google.maps.event.removeListener(K), J(google.maps.event.addListener(w, "rightclick", u)));
  }, [u]), v(() => {
    w && n && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(w, "click", n)));
  }, [n]), v(() => {
    w && c && (_ !== null && google.maps.event.removeListener(_), D(google.maps.event.addListener(w, "addfeature", c)));
  }, [c]), v(() => {
    w && p && ($ !== null && google.maps.event.removeListener($), S(google.maps.event.addListener(w, "removefeature", p)));
  }, [p]), v(() => {
    w && d && (W !== null && google.maps.event.removeListener(W), O(google.maps.event.addListener(w, "removeproperty", d)));
  }, [d]), v(() => {
    w && h && (T !== null && google.maps.event.removeListener(T), U(google.maps.event.addListener(w, "setgeometry", h)));
  }, [h]), v(() => {
    w && f && (j !== null && google.maps.event.removeListener(j), Z(google.maps.event.addListener(w, "setproperty", f)));
  }, [f]), v(() => {
    if (E !== null) {
      var A = new google.maps.Data(mm(mm({}, t), {}, {
        map: E
      }));
      r && y(google.maps.event.addListener(A, "dblclick", r)), o && P(google.maps.event.addListener(A, "mousedown", o)), i && L(google.maps.event.addListener(A, "mousemove", i)), a && I(google.maps.event.addListener(A, "mouseout", a)), s && V(google.maps.event.addListener(A, "mouseover", s)), l && q(google.maps.event.addListener(A, "mouseup", l)), u && J(google.maps.event.addListener(A, "rightclick", u)), n && ee(google.maps.event.addListener(A, "click", n)), c && D(google.maps.event.addListener(A, "addfeature", c)), p && S(google.maps.event.addListener(A, "removefeature", p)), d && O(google.maps.event.addListener(A, "removeproperty", d)), h && U(google.maps.event.addListener(A, "setgeometry", h)), f && Z(google.maps.event.addListener(A, "setproperty", f)), M(A), m && m(A);
    }
    return () => {
      w && (x !== null && google.maps.event.removeListener(x), C !== null && google.maps.event.removeListener(C), F !== null && google.maps.event.removeListener(F), N !== null && google.maps.event.removeListener(N), H !== null && google.maps.event.removeListener(H), z !== null && google.maps.event.removeListener(z), K !== null && google.maps.event.removeListener(K), te !== null && google.maps.event.removeListener(te), _ !== null && google.maps.event.removeListener(_), $ !== null && google.maps.event.removeListener($), W !== null && google.maps.event.removeListener(W), T !== null && google.maps.event.removeListener(T), j !== null && google.maps.event.removeListener(j), g && g(w), w.setMap(null));
    };
  }, []), null;
}
Ee(GLe);
class XLe extends pe {
  constructor() {
    super(...arguments), Oe(this, "registeredEvents", []), Oe(this, "state", {
      data: null
    }), Oe(this, "setDataCallback", () => {
      this.state.data !== null && this.props.onLoad && this.props.onLoad(this.state.data);
    });
  }
  componentDidMount() {
    if (this.context !== null) {
      var t = new google.maps.Data(mm(mm({}, this.props.options), {}, {
        map: this.context
      }));
      this.registeredEvents = nn({
        updaterMap: zF,
        eventMap: FF,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        data: t
      }), this.setDataCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.data !== null && (un(this.registeredEvents), this.registeredEvents = nn({
      updaterMap: zF,
      eventMap: FF,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.data
    }));
  }
  componentWillUnmount() {
    this.state.data !== null && (this.props.onUnmount && this.props.onUnmount(this.state.data), un(this.registeredEvents), this.state.data && this.state.data.setMap(null));
  }
  render() {
    return null;
  }
}
Oe(XLe, "contextType", Tt);
function UF(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function $F(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? UF(Object(n), !0).forEach(function(r) {
      Oe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : UF(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var HF = {
  onClick: "click",
  onDefaultViewportChanged: "defaultviewport_changed",
  onStatusChanged: "status_changed"
}, WF = {
  options(e, t) {
    e.setOptions(t);
  },
  url(e, t) {
    e.setUrl(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
class KLe extends pe {
  constructor() {
    super(...arguments), Oe(this, "registeredEvents", []), Oe(this, "state", {
      kmlLayer: null
    }), Oe(this, "setKmlLayerCallback", () => {
      this.state.kmlLayer !== null && this.props.onLoad && this.props.onLoad(this.state.kmlLayer);
    });
  }
  componentDidMount() {
    var t = new google.maps.KmlLayer($F($F({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = nn({
      updaterMap: WF,
      eventMap: HF,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        kmlLayer: t
      };
    }, this.setKmlLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.kmlLayer !== null && (un(this.registeredEvents), this.registeredEvents = nn({
      updaterMap: WF,
      eventMap: HF,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.kmlLayer
    }));
  }
  componentWillUnmount() {
    this.state.kmlLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.kmlLayer), un(this.registeredEvents), this.state.kmlLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Oe(KLe, "contextType", Tt);
function B8(e, t) {
  return typeof t == "function" ? t(e.offsetWidth, e.offsetHeight) : {
    x: 0,
    y: 0
  };
}
function YLe(e, t) {
  return new t(e.lat, e.lng);
}
function JLe(e, t) {
  return new t(new google.maps.LatLng(e.ne.lat, e.ne.lng), new google.maps.LatLng(e.sw.lat, e.sw.lng));
}
function QLe(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function e_e(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function t_e(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n.getNorthEast()), o = e && e.fromLatLngToDivPixel(n.getSouthWest());
  return r && o ? {
    left: "".concat(o.x + t.x, "px"),
    top: "".concat(r.y + t.y, "px"),
    width: "".concat(r.x - o.x - t.x, "px"),
    height: "".concat(o.y - r.y - t.y, "px")
  } : {
    left: "-9999px",
    top: "-9999px"
  };
}
function n_e(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n);
  if (r) {
    var {
      x: o,
      y: i
    } = r;
    return {
      left: "".concat(o + t.x, "px"),
      top: "".concat(i + t.y, "px")
    };
  }
  return {
    left: "-9999px",
    top: "-9999px"
  };
}
function I8(e, t, n, r) {
  return n !== void 0 ? t_e(e, t, e_e(n, google.maps.LatLngBounds, JLe)) : n_e(e, t, QLe(r, google.maps.LatLng, YLe));
}
function r_e(e, t) {
  return e.left === t.left && e.top === t.top && e.width === t.height && e.height === t.height;
}
function VF(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function o_e(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? VF(Object(n), !0).forEach(function(r) {
      Oe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : VF(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function i_e(e, t, n, r, o) {
  class i extends google.maps.OverlayView {
    constructor(s, l, u, c) {
      super(), this.container = s, this.pane = l, this.position = u, this.bounds = c;
    }
    onAdd() {
      var s, l = (s = this.getPanes()) === null || s === void 0 ? void 0 : s[this.pane];
      l == null || l.appendChild(this.container);
    }
    draw() {
      var s = this.getProjection(), l = o_e({}, this.container ? B8(this.container, o) : {
        x: 0,
        y: 0
      }), u = I8(s, l, this.bounds, this.position);
      for (var [c, p] of Object.entries(u))
        this.container.style[c] = p;
    }
    onRemove() {
      this.container.parentNode !== null && this.container.parentNode.removeChild(this.container);
    }
  }
  return new i(e, t, n, r);
}
function qF(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function s_e(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? qF(Object(n), !0).forEach(function(r) {
      Oe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : qF(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function ZF(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLng ? e : new google.maps.LatLng(e.lat, e.lng);
  return t + "";
}
function GF(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLngBounds ? e : new google.maps.LatLngBounds(new google.maps.LatLng(e.south, e.east), new google.maps.LatLng(e.north, e.west));
  return t + "";
}
function a_e(e) {
  var {
    position: t,
    bounds: n,
    mapPaneName: r,
    zIndex: o,
    onLoad: i,
    onUnmount: a,
    getPixelPositionOffset: s,
    children: l
  } = e, u = ye(Tt), c = Tn(() => {
    var d = document.createElement("div");
    return d.style.position = "absolute", d;
  }, []), p = Tn(() => i_e(c, r, t, n, s), [c, r, t, n]);
  return v(() => (i == null || i(p), p == null || p.setMap(u), () => {
    a == null || a(p), p == null || p.setMap(null);
  }), [u, p]), v(() => {
    c.style.zIndex = "".concat(o);
  }, [o, c]), Ci.createPortal(l, c);
}
Ee(a_e);
class _u extends pe {
  constructor(t) {
    super(t), Oe(this, "state", {
      paneEl: null,
      containerStyle: {
        // set initial position
        position: "absolute"
      }
    }), Oe(this, "updatePane", () => {
      var r = this.props.mapPaneName, o = this.overlayView.getPanes();
      Kr(!!r, "OverlayView requires props.mapPaneName but got %s", r), o ? this.setState({
        paneEl: o[r]
      }) : this.setState({
        paneEl: null
      });
    }), Oe(this, "onAdd", () => {
      var r, o;
      this.updatePane(), (r = (o = this.props).onLoad) === null || r === void 0 || r.call(o, this.overlayView);
    }), Oe(this, "onPositionElement", () => {
      var r = this.overlayView.getProjection(), o = s_e({
        x: 0,
        y: 0
      }, this.containerRef.current ? B8(this.containerRef.current, this.props.getPixelPositionOffset) : {}), i = I8(r, o, this.props.bounds, this.props.position);
      if (!r_e(i, {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        left: this.state.containerStyle.left,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        top: this.state.containerStyle.top,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        width: this.state.containerStyle.width,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        height: this.state.containerStyle.height
      })) {
        var a, s, l, u;
        this.setState({
          containerStyle: {
            top: (a = i.top) !== null && a !== void 0 ? a : 0,
            left: (s = i.left) !== null && s !== void 0 ? s : 0,
            width: (l = i.width) !== null && l !== void 0 ? l : 0,
            height: (u = i.height) !== null && u !== void 0 ? u : 0,
            position: "absolute"
          }
        });
      }
    }), Oe(this, "draw", () => {
      this.onPositionElement();
    }), Oe(this, "onRemove", () => {
      var r, o;
      this.setState(() => ({
        paneEl: null
      })), (r = (o = this.props).onUnmount) === null || r === void 0 || r.call(o, this.overlayView);
    }), this.containerRef = Qr();
    var n = new google.maps.OverlayView();
    n.onAdd = this.onAdd, n.draw = this.draw, n.onRemove = this.onRemove, this.overlayView = n;
  }
  componentDidMount() {
    this.overlayView.setMap(this.context);
  }
  componentDidUpdate(t) {
    var n = ZF(t.position), r = ZF(this.props.position), o = GF(t.bounds), i = GF(this.props.bounds);
    (n !== r || o !== i) && this.overlayView.draw(), t.mapPaneName !== this.props.mapPaneName && this.updatePane();
  }
  componentWillUnmount() {
    this.overlayView.setMap(null);
  }
  render() {
    var t = this.state.paneEl;
    return t ? Ci.createPortal(mn.jsx("div", {
      ref: this.containerRef,
      style: this.state.containerStyle,
      children: at.only(this.props.children)
    }), t) : null;
  }
}
Oe(_u, "FLOAT_PANE", "floatPane");
Oe(_u, "MAP_PANE", "mapPane");
Oe(_u, "MARKER_LAYER", "markerLayer");
Oe(_u, "OVERLAY_LAYER", "overlayLayer");
Oe(_u, "OVERLAY_MOUSE_TARGET", "overlayMouseTarget");
Oe(_u, "contextType", Tt);
function l_e() {
}
function XF(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function KF(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? XF(Object(n), !0).forEach(function(r) {
      Oe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : XF(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var YF = {
  onDblClick: "dblclick",
  onClick: "click"
}, JF = {
  opacity(e, t) {
    e.setOpacity(t);
  }
};
function u_e(e) {
  var {
    url: t,
    bounds: n,
    options: r,
    visible: o
  } = e, i = ye(Tt), a = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east)), s = Tn(() => new google.maps.GroundOverlay(t, a, r), []);
  return v(() => {
    s !== null && s.setMap(i);
  }, [i]), v(() => {
    typeof t < "u" && s !== null && (s.set("url", t), s.setMap(i));
  }, [s, t]), v(() => {
    typeof o < "u" && s !== null && s.setOpacity(o ? 1 : 0);
  }, [s, o]), v(() => {
    var l = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east));
    typeof n < "u" && s !== null && (s.set("bounds", l), s.setMap(i));
  }, [s, n]), null;
}
Ee(u_e);
class R8 extends pe {
  constructor() {
    super(...arguments), Oe(this, "registeredEvents", []), Oe(this, "state", {
      groundOverlay: null
    }), Oe(this, "setGroundOverlayCallback", () => {
      this.state.groundOverlay !== null && this.props.onLoad && this.props.onLoad(this.state.groundOverlay);
    });
  }
  componentDidMount() {
    Kr(!!this.props.url || !!this.props.bounds, "For GroundOverlay, url and bounds are passed in to constructor and are immutable after instantiated. This is the behavior of Google Maps JavaScript API v3 ( See https://developers.google.com/maps/documentation/javascript/reference#GroundOverlay) Hence, use the corresponding two props provided by `react-google-maps-api`, url and bounds. In some cases, you'll need the GroundOverlay component to reflect the changes of url and bounds. You can leverage the React's key property to remount the component. Typically, just `key={url}` would serve your need. See https://github.com/tomchentw/react-google-maps/issues/655");
    var t = new google.maps.GroundOverlay(this.props.url, this.props.bounds, KF(KF({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = nn({
      updaterMap: JF,
      eventMap: YF,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        groundOverlay: t
      };
    }, this.setGroundOverlayCallback);
  }
  componentDidUpdate(t) {
    this.state.groundOverlay !== null && (un(this.registeredEvents), this.registeredEvents = nn({
      updaterMap: JF,
      eventMap: YF,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.groundOverlay
    }));
  }
  componentWillUnmount() {
    this.state.groundOverlay && (this.props.onUnmount && this.props.onUnmount(this.state.groundOverlay), this.state.groundOverlay.setMap(null));
  }
  render() {
    return null;
  }
}
Oe(R8, "defaultProps", {
  onLoad: l_e
});
Oe(R8, "contextType", Tt);
function QF(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function vm(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? QF(Object(n), !0).forEach(function(r) {
      Oe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : QF(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var e2 = {}, t2 = {
  data(e, t) {
    e.setData(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function c_e(e) {
  var {
    data: t,
    onLoad: n,
    onUnmount: r,
    options: o
  } = e, i = ye(Tt), [a, s] = k(null);
  return v(() => {
    google.maps.visualization || Kr(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} in useJsApiScript? %s', google.maps.visualization);
  }, []), v(() => {
    Kr(!!t, "data property is required in HeatmapLayer %s", t);
  }, [t]), v(() => {
    a !== null && a.setMap(i);
  }, [i]), v(() => {
    o && a !== null && a.setOptions(o);
  }, [a, o]), v(() => {
    var l = new google.maps.visualization.HeatmapLayer(vm(vm({}, o), {}, {
      data: t,
      map: i
    }));
    return s(l), n && n(l), () => {
      a !== null && (r && r(a), a.setMap(null));
    };
  }, []), null;
}
Ee(c_e);
class p_e extends pe {
  constructor() {
    super(...arguments), Oe(this, "registeredEvents", []), Oe(this, "state", {
      heatmapLayer: null
    }), Oe(this, "setHeatmapLayerCallback", () => {
      this.state.heatmapLayer !== null && this.props.onLoad && this.props.onLoad(this.state.heatmapLayer);
    });
  }
  componentDidMount() {
    Kr(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} to <LoadScript />? %s', google.maps.visualization), Kr(!!this.props.data, "data property is required in HeatmapLayer %s", this.props.data);
    var t = new google.maps.visualization.HeatmapLayer(vm(vm({}, this.props.options), {}, {
      data: this.props.data,
      map: this.context
    }));
    this.registeredEvents = nn({
      updaterMap: t2,
      eventMap: e2,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        heatmapLayer: t
      };
    }, this.setHeatmapLayerCallback);
  }
  componentDidUpdate(t) {
    un(this.registeredEvents), this.registeredEvents = nn({
      updaterMap: t2,
      eventMap: e2,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.heatmapLayer
    });
  }
  componentWillUnmount() {
    this.state.heatmapLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.heatmapLayer), un(this.registeredEvents), this.state.heatmapLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Oe(p_e, "contextType", Tt);
var n2 = {
  onCloseClick: "closeclick",
  onPanoChanged: "pano_changed",
  onPositionChanged: "position_changed",
  onPovChanged: "pov_changed",
  onResize: "resize",
  onStatusChanged: "status_changed",
  onVisibleChanged: "visible_changed",
  onZoomChanged: "zoom_changed"
}, r2 = {
  register(e, t, n) {
    e.registerPanoProvider(t, n);
  },
  links(e, t) {
    e.setLinks(t);
  },
  motionTracking(e, t) {
    e.setMotionTracking(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  pano(e, t) {
    e.setPano(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  pov(e, t) {
    e.setPov(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zoom(e, t) {
    e.setZoom(t);
  }
};
class d_e extends pe {
  constructor() {
    super(...arguments), Oe(this, "registeredEvents", []), Oe(this, "state", {
      streetViewPanorama: null
    }), Oe(this, "setStreetViewPanoramaCallback", () => {
      this.state.streetViewPanorama !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewPanorama);
    });
  }
  componentDidMount() {
    var t, n, r = (t = (n = this.context) === null || n === void 0 ? void 0 : n.getStreetView()) !== null && t !== void 0 ? t : null;
    this.registeredEvents = nn({
      updaterMap: r2,
      eventMap: n2,
      prevProps: {},
      nextProps: this.props,
      instance: r
    }), this.setState(() => ({
      streetViewPanorama: r
    }), this.setStreetViewPanoramaCallback);
  }
  componentDidUpdate(t) {
    this.state.streetViewPanorama !== null && (un(this.registeredEvents), this.registeredEvents = nn({
      updaterMap: r2,
      eventMap: n2,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.streetViewPanorama
    }));
  }
  componentWillUnmount() {
    this.state.streetViewPanorama !== null && (this.props.onUnmount && this.props.onUnmount(this.state.streetViewPanorama), un(this.registeredEvents), this.state.streetViewPanorama.setVisible(!1));
  }
  render() {
    return null;
  }
}
Oe(d_e, "contextType", Tt);
class f_e extends pe {
  constructor() {
    super(...arguments), Oe(this, "state", {
      streetViewService: null
    }), Oe(this, "setStreetViewServiceCallback", () => {
      this.state.streetViewService !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewService);
    });
  }
  componentDidMount() {
    var t = new google.maps.StreetViewService();
    this.setState(function() {
      return {
        streetViewService: t
      };
    }, this.setStreetViewServiceCallback);
  }
  componentWillUnmount() {
    this.state.streetViewService !== null && this.props.onUnmount && this.props.onUnmount(this.state.streetViewService);
  }
  render() {
    return null;
  }
}
Oe(f_e, "contextType", Tt);
var o2 = {
  onDirectionsChanged: "directions_changed"
}, i2 = {
  directions(e, t) {
    e.setDirections(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  panel(e, t) {
    e.setPanel(t);
  },
  routeIndex(e, t) {
    e.setRouteIndex(t);
  }
};
class h_e extends pe {
  constructor() {
    super(...arguments), Oe(this, "registeredEvents", []), Oe(this, "state", {
      directionsRenderer: null
    }), Oe(this, "setDirectionsRendererCallback", () => {
      this.state.directionsRenderer !== null && (this.state.directionsRenderer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.directionsRenderer));
    });
  }
  componentDidMount() {
    var t = new google.maps.DirectionsRenderer(this.props.options);
    this.registeredEvents = nn({
      updaterMap: i2,
      eventMap: o2,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        directionsRenderer: t
      };
    }, this.setDirectionsRendererCallback);
  }
  componentDidUpdate(t) {
    this.state.directionsRenderer !== null && (un(this.registeredEvents), this.registeredEvents = nn({
      updaterMap: i2,
      eventMap: o2,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.directionsRenderer
    }));
  }
  componentWillUnmount() {
    this.state.directionsRenderer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.directionsRenderer), un(this.registeredEvents), this.state.directionsRenderer && this.state.directionsRenderer.setMap(null));
  }
  render() {
    return null;
  }
}
Oe(h_e, "contextType", Tt);
var s2 = {
  onPlacesChanged: "places_changed"
}, a2 = {
  bounds(e, t) {
    e.setBounds(t);
  }
};
class g_e extends pe {
  constructor() {
    super(...arguments), Oe(this, "registeredEvents", []), Oe(this, "containerElement", Qr()), Oe(this, "state", {
      searchBox: null
    }), Oe(this, "setSearchBoxCallback", () => {
      this.state.searchBox !== null && this.props.onLoad && this.props.onLoad(this.state.searchBox);
    });
  }
  componentDidMount() {
    if (Kr(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places), this.containerElement !== null && this.containerElement.current !== null) {
      var t = this.containerElement.current.querySelector("input");
      if (t !== null) {
        var n = new google.maps.places.SearchBox(t, this.props.options);
        this.registeredEvents = nn({
          updaterMap: a2,
          eventMap: s2,
          prevProps: {},
          nextProps: this.props,
          instance: n
        }), this.setState(function() {
          return {
            searchBox: n
          };
        }, this.setSearchBoxCallback);
      }
    }
  }
  componentDidUpdate(t) {
    this.state.searchBox !== null && (un(this.registeredEvents), this.registeredEvents = nn({
      updaterMap: a2,
      eventMap: s2,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.searchBox
    }));
  }
  componentWillUnmount() {
    this.state.searchBox !== null && (this.props.onUnmount && this.props.onUnmount(this.state.searchBox), un(this.registeredEvents));
  }
  render() {
    return mn.jsx("div", {
      ref: this.containerElement,
      children: at.only(this.props.children)
    });
  }
}
Oe(g_e, "contextType", Tt);
var l2 = {
  onPlaceChanged: "place_changed"
}, u2 = {
  bounds(e, t) {
    e.setBounds(t);
  },
  restrictions(e, t) {
    e.setComponentRestrictions(t);
  },
  fields(e, t) {
    e.setFields(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  types(e, t) {
    e.setTypes(t);
  }
};
class N8 extends pe {
  constructor() {
    super(...arguments), Oe(this, "registeredEvents", []), Oe(this, "containerElement", Qr()), Oe(this, "state", {
      autocomplete: null
    }), Oe(this, "setAutocompleteCallback", () => {
      this.state.autocomplete !== null && this.props.onLoad && this.props.onLoad(this.state.autocomplete);
    });
  }
  componentDidMount() {
    var t;
    Kr(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places);
    var n = (t = this.containerElement.current) === null || t === void 0 ? void 0 : t.querySelector("input");
    if (n) {
      var r = new google.maps.places.Autocomplete(n, this.props.options);
      this.registeredEvents = nn({
        updaterMap: u2,
        eventMap: l2,
        prevProps: {},
        nextProps: this.props,
        instance: r
      }), this.setState(() => ({
        autocomplete: r
      }), this.setAutocompleteCallback);
    }
  }
  componentDidUpdate(t) {
    un(this.registeredEvents), this.registeredEvents = nn({
      updaterMap: u2,
      eventMap: l2,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.autocomplete
    });
  }
  componentWillUnmount() {
    this.state.autocomplete !== null && un(this.registeredEvents);
  }
  render() {
    return mn.jsx("div", {
      ref: this.containerElement,
      className: this.props.className,
      children: at.only(this.props.children)
    });
  }
}
Oe(N8, "defaultProps", {
  className: ""
});
Oe(N8, "contextType", Tt);
let m_e = { data: "" }, v_e = (e) => typeof window == "object" ? ((e ? e.querySelector("#_goober") : window._goober) || Object.assign((e || document.head).appendChild(document.createElement("style")), { innerHTML: " ", id: "_goober" })).firstChild : e || m_e, y_e = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g, b_e = /\/\*[^]*?\*\/|  +/g, c2 = /\n+/g, ua = (e, t) => {
  let n = "", r = "", o = "";
  for (let i in e) {
    let a = e[i];
    i[0] == "@" ? i[1] == "i" ? n = i + " " + a + ";" : r += i[1] == "f" ? ua(a, i) : i + "{" + ua(a, i[1] == "k" ? "" : t) + "}" : typeof a == "object" ? r += ua(a, t ? t.replace(/([^,])+/g, (s) => i.replace(/([^,]*:\S+\([^)]*\))|([^,])+/g, (l) => /&/.test(l) ? l.replace(/&/g, s) : s ? s + " " + l : l)) : i) : a != null && (i = /^--/.test(i) ? i : i.replace(/[A-Z]/g, "-$&").toLowerCase(), o += ua.p ? ua.p(i, a) : i + ":" + a + ";");
  }
  return n + (t && o ? t + "{" + o + "}" : o) + r;
}, ps = {}, F8 = (e) => {
  if (typeof e == "object") {
    let t = "";
    for (let n in e) t += n + F8(e[n]);
    return t;
  }
  return e;
}, w_e = (e, t, n, r, o) => {
  let i = F8(e), a = ps[i] || (ps[i] = ((l) => {
    let u = 0, c = 11;
    for (; u < l.length; ) c = 101 * c + l.charCodeAt(u++) >>> 0;
    return "go" + c;
  })(i));
  if (!ps[a]) {
    let l = i !== e ? e : ((u) => {
      let c, p, d = [{}];
      for (; c = y_e.exec(u.replace(b_e, "")); ) c[4] ? d.shift() : c[3] ? (p = c[3].replace(c2, " ").trim(), d.unshift(d[0][p] = d[0][p] || {})) : d[0][c[1]] = c[2].replace(c2, " ").trim();
      return d[0];
    })(e);
    ps[a] = ua(o ? { ["@keyframes " + a]: l } : l, n ? "" : "." + a);
  }
  let s = n && ps.g ? ps.g : null;
  return n && (ps.g = ps[a]), ((l, u, c, p) => {
    p ? u.data = u.data.replace(p, l) : u.data.indexOf(l) === -1 && (u.data = c ? l + u.data : u.data + l);
  })(ps[a], t, r, s), a;
}, C_e = (e, t, n) => e.reduce((r, o, i) => {
  let a = t[i];
  if (a && a.call) {
    let s = a(n), l = s && s.props && s.props.className || /^go/.test(s) && s;
    a = l ? "." + l : s && typeof s == "object" ? s.props ? "" : ua(s, "") : s === !1 ? "" : s;
  }
  return r + o + (a ?? "");
}, "");
function Ay(e) {
  let t = this || {}, n = e.call ? e(t.p) : e;
  return w_e(n.unshift ? n.raw ? C_e(n, [].slice.call(arguments, 1), t.p) : n.reduce((r, o) => Object.assign(r, o && o.call ? o(t.p) : o), {}) : n, v_e(t.target), t.g, t.o, t.k);
}
let z8, Dx, Tx;
Ay.bind({ g: 1 });
let Es = Ay.bind({ k: 1 });
function x_e(e, t, n, r) {
  ua.p = t, z8 = e, Dx = n, Tx = r;
}
function Da(e, t) {
  let n = this || {};
  return function() {
    let r = arguments;
    function o(i, a) {
      let s = Object.assign({}, i), l = s.className || o.className;
      n.p = Object.assign({ theme: Dx && Dx() }, s), n.o = / *go\d+/.test(l), s.className = Ay.apply(n, r) + (l ? " " + l : "");
      let u = e;
      return e[0] && (u = s.as || e, delete s.as), Tx && u[0] && Tx(s), z8(u, s);
    }
    return o;
  };
}
var O_e = (e) => typeof e == "function", E_e = (e, t) => O_e(e) ? e(t) : e, k_e = /* @__PURE__ */ (() => {
  let e;
  return () => {
    if (e === void 0 && typeof window < "u") {
      let t = matchMedia("(prefers-reduced-motion: reduce)");
      e = !t || t.matches;
    }
    return e;
  };
})(), L_e = Es`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`, __e = Es`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`, P_e = Es`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`, S_e = Da("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${L_e} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${__e} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${(e) => e.secondary || "#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${P_e} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`, M_e = Es`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, D_e = Da("div")`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${(e) => e.secondary || "#e0e0e0"};
  border-right-color: ${(e) => e.primary || "#616161"};
  animation: ${M_e} 1s linear infinite;
`, T_e = Es`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`, j_e = Es`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`, A_e = Da("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${T_e} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${j_e} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${(e) => e.secondary || "#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`, B_e = Da("div")`
  position: absolute;
`, I_e = Da("div")`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`, R_e = Es`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`, N_e = Da("div")`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${R_e} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`, F_e = ({ toast: e }) => {
  let { icon: t, type: n, iconTheme: r } = e;
  return t !== void 0 ? typeof t == "string" ? $e.createElement(N_e, null, t) : t : n === "blank" ? null : $e.createElement(I_e, null, $e.createElement(D_e, { ...r }), n !== "loading" && $e.createElement(B_e, null, n === "error" ? $e.createElement(S_e, { ...r }) : $e.createElement(A_e, { ...r })));
}, z_e = (e) => `
0% {transform: translate3d(0,${e * -200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`, U_e = (e) => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${e * -150}%,-1px) scale(.6); opacity:0;}
`, $_e = "0%{opacity:0;} 100%{opacity:1;}", H_e = "0%{opacity:1;} 100%{opacity:0;}", W_e = Da("div")`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`, V_e = Da("div")`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`, q_e = (e, t) => {
  let n = e.includes("top") ? 1 : -1, [r, o] = k_e() ? [$_e, H_e] : [z_e(n), U_e(n)];
  return { animation: t ? `${Es(r)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards` : `${Es(o)} 0.4s forwards cubic-bezier(.06,.71,.55,1)` };
};
$e.memo(({ toast: e, position: t, style: n, children: r }) => {
  let o = e.height ? q_e(e.position || t || "top-center", e.visible) : { opacity: 0 }, i = $e.createElement(F_e, { toast: e }), a = $e.createElement(V_e, { ...e.ariaProps }, E_e(e.message, e));
  return $e.createElement(W_e, { className: e.className, style: { ...o, ...n, ...e.style } }, typeof r == "function" ? r({ icon: i, message: a }) : $e.createElement($e.Fragment, null, i, a));
});
x_e($e.createElement);
Ay`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`;
function Z_e(e) {
  const { error: t } = e, n = "arkynAudioUploadError";
  return t ? /* @__PURE__ */ X.jsx("strong", { className: n, children: t }) : /* @__PURE__ */ X.jsx(X.Fragment, {});
}
function G_e(e) {
  const { label: t, showAsterisk: n } = e, o = `arkynAudioUploadLabel ${n ? "asteriskTrue" : "asteriskFalse"}`;
  return /* @__PURE__ */ X.jsx("strong", { className: o.trim(), children: t });
}
function X_e(e) {
  const { onChange: t, value: n, disableDrag: r = !1, onDragging: o } = e, [i, a] = k(!1), s = rt(null), l = () => {
    a(!0);
  }, u = () => {
    a(!1);
  }, c = (f) => {
    if (r || !i || !s.current) return;
    const m = s.current.getBoundingClientRect(), g = f.clientX - m.left, E = Math.min(Math.max(g / m.width * 100, 0), 100);
    t(E);
  }, p = (f) => {
    if (!s.current) return;
    const m = s.current.getBoundingClientRect(), g = f.clientX - m.left, E = Math.min(Math.max(g / m.width * 100, 0), 100);
    t(E);
  };
  v(() => (i ? (o && o(!0), document.addEventListener("mousemove", c), document.addEventListener("mouseup", u)) : (o && o(!1), document.removeEventListener("mousemove", c), document.removeEventListener("mouseup", u)), () => {
    document.removeEventListener("mousemove", c), document.removeEventListener("mouseup", u);
  }), [i]);
  const h = `arkynSliderTrack ${i ? "isDragging" : "isNotDragging"}`;
  return /* @__PURE__ */ X.jsxs(
    "div",
    {
      className: h,
      ref: s,
      onMouseDown: l,
      onClick: p,
      children: [
        /* @__PURE__ */ X.jsx("div", { className: "arkynSliderFill", style: { width: `${n}%` } }),
        /* @__PURE__ */ X.jsx("div", { className: "arkynSliderThumb", style: { left: `${n}%` } })
      ]
    }
  );
}
function K_e(e) {
  var P, F, L, N;
  const {
    filePath: t,
    disabled: n,
    acceptAudio: r,
    handleSelectFile: o,
    isLoading: i,
    reSendAudio: a,
    changeAudioButtonText: s
  } = e, [l, u] = k(0), c = rt(null), [p, d] = k(!1), [h, f] = k(!1);
  v(() => {
    const I = c.current;
    if (!I) return;
    const H = () => {
      const V = I.duration, q = I.currentTime / V * 100;
      u(q);
    };
    return I.addEventListener("timeupdate", H), () => {
      I.removeEventListener("timeupdate", H);
    };
  }, []);
  function m(I) {
    const H = c.current;
    if (!H) return;
    const V = H.duration, z = I / 100 * V;
    H.currentTime = z;
  }
  function g() {
    var I;
    (I = c.current) == null || I.play(), f(!0);
  }
  function E() {
    var I;
    (I = c.current) == null || I.pause(), f(!1);
  }
  function w() {
    h ? E() : g();
  }
  const M = (P = c.current) == null ? void 0 : P.currentTime, x = (F = c.current) == null ? void 0 : F.duration;
  function y(I) {
    if (!I) return "00:00";
    const H = Math.floor(I / 60), V = Math.floor(I % 60), z = String(H).padStart(2, "0"), q = String(V).padStart(2, "0");
    return `${z}:${q}`;
  }
  p || !h ? (L = c.current) == null || L.pause() : h && ((N = c.current) == null || N.play());
  function C() {
    if (n) return;
    const I = document.createElement("input");
    I.type = "file", I.accept = r, I.onchange = (H) => {
      var z;
      const V = (z = H.target.files) == null ? void 0 : z[0];
      V && o(V);
    }, I.click();
  }
  return /* @__PURE__ */ X.jsxs("div", { className: "arkynAudioUploadHasFileContentContainer", children: [
    /* @__PURE__ */ X.jsx("audio", { ref: c, src: t, onEnded: E }),
    /* @__PURE__ */ X.jsxs("div", { className: "arkynAudioUploadAudioPlayer", children: [
      /* @__PURE__ */ X.jsxs("button", { type: "button", onClick: w, children: [
        h && /* @__PURE__ */ X.jsx(z4, {}),
        !h && /* @__PURE__ */ X.jsx(U4, {})
      ] }),
      /* @__PURE__ */ X.jsx("p", { children: y(M) }),
      /* @__PURE__ */ X.jsx(
        X_e,
        {
          value: l,
          onChange: m,
          onDragging: d
        }
      ),
      /* @__PURE__ */ X.jsx("p", { children: y(x) })
    ] }),
    /* @__PURE__ */ X.jsx(MK, {}),
    /* @__PURE__ */ X.jsxs("div", { className: "arkynAudioUploadButtonsContainer", children: [
      !!a && /* @__PURE__ */ X.jsx(SOe, { orientation: "bottom", text: "Reenviar udio", children: /* @__PURE__ */ X.jsx(
        POe,
        {
          type: "button",
          "aria-label": "resend image",
          variant: "outline",
          scheme: "danger",
          size: "sm",
          isLoading: i,
          onClick: a,
          icon: Yx,
          disabled: n
        }
      ) }),
      /* @__PURE__ */ X.jsx(
        Gk,
        {
          isLoading: i,
          onClick: C,
          variant: "outline",
          size: "sm",
          type: "button",
          disabled: n,
          children: s
        }
      )
    ] })
  ] });
}
function Y_e(e) {
  const {
    dropAudioText: t,
    isLoading: n,
    acceptAudio: r,
    handleSelectFile: o,
    selectAudioButtonText: i,
    disabled: a
  } = e;
  function s(u) {
    if (a) return;
    u.preventDefault();
    const c = u.dataTransfer.files[0];
    c && o(c);
  }
  function l() {
    if (a) return;
    const u = document.createElement("input");
    u.type = "file", u.accept = r, u.onchange = (c) => {
      var d;
      const p = (d = c.target.files) == null ? void 0 : d[0];
      p && o(p);
    }, u.click();
  }
  return /* @__PURE__ */ X.jsxs("div", { onDrop: s, className: "arkynAudioUploadNoFileContent", children: [
    /* @__PURE__ */ X.jsx(
      Gk,
      {
        isLoading: n,
        onClick: l,
        variant: "ghost",
        size: "sm",
        type: "button",
        disabled: a,
        children: i
      }
    ),
    /* @__PURE__ */ X.jsx("p", { children: t })
  ] });
}
function CRe(e) {
  const {
    name: t,
    label: n,
    fileName: r = "file",
    method: o = "POST",
    onUpload: i,
    fileResponseName: a = "url",
    selectAudioButtonText: s = "Selecionar arquivo de udio",
    dropAudioText: l = "Ou arraste e solte um arquivo de udio aqui",
    changeAudioButtonText: u = "Trocar arquivo de udio",
    acceptAudio: c = "audio/*",
    action: p,
    defaultValue: d = "",
    showAsterisk: h = !1,
    disabled: f = !1
  } = e, g = _Oe()[t], [E, w] = k(d), [M, x] = k(""), [y, C] = k(null), [P, F] = k(d), [L, N] = k(!1);
  async function I(J) {
    if (f) return;
    N(!0), C(J), x("");
    const te = new FormData();
    te.append(r, J), await fetch(p, { method: o, body: te }).then(async (ee) => await ee.json()).then((ee) => {
      ee != null && ee.error ? x(ee.error) : w(ee == null ? void 0 : ee[a]), i && i(ee == null ? void 0 : ee[a]);
    }).catch((ee) => {
      console.error(ee), x("Erro ao enviar audio");
    }).finally(() => N(!1));
  }
  function H(J) {
    if (!f) {
      if (console.log(J.type), J.type.indexOf("audio") === -1) {
        x("O arquivo selecionado no  um arquivo de udio");
        return;
      }
      F(URL.createObjectURL(J)), I(J);
    }
  }
  const V = g || M, K = `arkynAudioUpload ${V ? "hasError" : "noHasError"} ${P ? "hasAudio" : "noHasAudio"}`;
  return /* @__PURE__ */ X.jsxs("div", { className: "arkynAudioUploadContainer", children: [
    n && /* @__PURE__ */ X.jsx(G_e, { label: n, showAsterisk: h }),
    /* @__PURE__ */ X.jsxs("div", { className: K, children: [
      /* @__PURE__ */ X.jsx("input", { type: "hidden", name: t, value: E || "" }),
      !P && /* @__PURE__ */ X.jsx(
        Y_e,
        {
          disabled: f,
          isLoading: L,
          acceptAudio: c,
          dropAudioText: l,
          handleSelectFile: H,
          selectAudioButtonText: s
        }
      ),
      P && /* @__PURE__ */ X.jsx(
        K_e,
        {
          filePath: P,
          acceptAudio: c,
          changeAudioButtonText: u,
          disabled: f,
          handleSelectFile: H,
          isLoading: L,
          reSendAudio: V && y ? () => I(y) : void 0
        }
      )
    ] }),
    V && /* @__PURE__ */ X.jsx(Z_e, { error: V })
  ] });
}
function Ap(e) {
  const {
    isLoading: t = !1,
    scheme: n = "primary",
    variant: r = "solid",
    loadingText: o,
    size: i = "md",
    leftIcon: a,
    rightIcon: s,
    disabled: l,
    className: u = "",
    children: c,
    ...p
  } = e, h = { xs: 12, sm: 16, md: 20, lg: 24 }[i], g = `arkynButton ${t ? "loadingTrue" : "loadingFalse"} ${r} ${n} ${i} ${o ? "loadingTextTrue" : "loadingTextFalse"} ${u}`;
  return /* @__PURE__ */ X.jsxs("button", { className: g, disabled: l || t, ...p, children: [
    /* @__PURE__ */ X.jsxs("div", { className: "arkynButtonSpinner", children: [
      /* @__PURE__ */ X.jsx(Gi, { size: h, strokeWidth: 2.5 }),
      o && o
    ] }),
    /* @__PURE__ */ X.jsxs("div", { className: "arkynButtonContent", children: [
      Fh(h, a),
      c,
      Fh(h, s)
    ] })
  ] });
}
function c1() {
  const e = eO(), t = t$(), n = tO(), [r, o] = k(null);
  function i(u, c) {
    return JSON.stringify(u) === JSON.stringify(c);
  }
  function a() {
    r && o(null);
  }
  v(() => {
    var c, p;
    let u = ((p = (c = n[0]) == null ? void 0 : c.data) == null ? void 0 : p.fieldErrors) || {};
    i(r, u) || Object.entries(u).length !== 0 && o(u);
  }, [n, e]), v(() => {
    var u;
    ((u = n[0]) == null ? void 0 : u.state) === "submitting" && a();
  }, [n, t]);
  const s = (e == null ? void 0 : e.fieldErrors) || r;
  let l = {};
  return Object.entries(s || {}).forEach(([u, c]) => {
    typeof c == "string" && typeof u == "string" && (l[u] = c);
  }), l;
}
const U8 = Ze({});
function p2(e) {
  var p;
  const {
    children: t,
    className: n,
    id: r,
    ...o
  } = e, i = c1(), a = rt(null), s = ((p = a.current) == null ? void 0 : p.name) || "", l = (i == null ? void 0 : i[s]) || null, u = B4(), c = `arkynFormController ${n}`;
  return /* @__PURE__ */ X.jsx(U8.Provider, { value: { error: l, id: u, inputRef: a }, children: /* @__PURE__ */ X.jsx(
    "section",
    {
      id: r || s || void 0,
      className: c.trim(),
      ...o,
      children: t
    }
  ) });
}
function Po() {
  return ye(U8);
}
function xRe(e) {
  const {
    name: t,
    className: n = "",
    size: r = "md",
    isError: o,
    defaultChecked: i = !1,
    checked: a = null,
    onCheck: s,
    value: l,
    ...u
  } = e, { id: c, inputRef: p, error: d } = Po(), h = o || !!d, [f, m] = k(i || !1), g = typeof a == "boolean" ? a : f, M = `arkynCheckbox ${r} ${h ? "errorTrue" : "errorFalse"} ${g ? "checkedTrue" : "checkedFalse"} ${n}`;
  function x() {
    const y = f;
    m(!y), s && s(y ? "" : l || "checked");
  }
  return /* @__PURE__ */ X.jsxs(
    "button",
    {
      id: c,
      type: "button",
      className: M,
      onClick: x,
      ...u,
      children: [
        /* @__PURE__ */ X.jsx(
          "input",
          {
            type: "hidden",
            name: t,
            ref: p,
            value: g ? l || "checked" : ""
          }
        ),
        /* @__PURE__ */ X.jsx(Mm, {})
      ]
    }
  );
}
function J_e(e) {
  const { error: t } = e, n = "arkynFileUploadError";
  return t ? /* @__PURE__ */ X.jsx("strong", { className: n, children: t }) : /* @__PURE__ */ X.jsx(X.Fragment, {});
}
function Q_e(e) {
  const { label: t, showAsterisk: n } = e, o = `arkynFileUploadLabel ${n ? "asteriskTrue" : "asteriskFalse"}`;
  return /* @__PURE__ */ X.jsx("strong", { className: o.trim(), children: t });
}
function $8(e) {
  const {
    isLoading: t = !1,
    scheme: n = "primary",
    variant: r = "solid",
    size: o = "md",
    icon: i,
    disabled: a,
    className: s = "",
    ...l
  } = e, u = { xs: 12, sm: 16, md: 20, lg: 24 }, p = `arkynIconButton ${r} ${n} ${o} ${t ? "loadingTrue" : "loadingFalse"} ${s}`;
  return /* @__PURE__ */ X.jsxs(
    "button",
    {
      disabled: a || t,
      className: p.trim(),
      ...l,
      children: [
        /* @__PURE__ */ X.jsx("div", { className: "arkynIconButtonSpinner", children: /* @__PURE__ */ X.jsx(Gi, { size: u[o], strokeWidth: 2.5 }) }),
        /* @__PURE__ */ X.jsx("div", { className: "arkynIconButtonContent", children: /* @__PURE__ */ X.jsx(i, { size: u[o], strokeWidth: 2.5 }) })
      ]
    }
  );
}
function H8(e) {
  const {
    text: t,
    size: n = "lg",
    children: r,
    orientation: o = "top",
    className: i = "",
    ...a
  } = e, s = `arkynTooltip ${n} ${o} ${i}`;
  return /* @__PURE__ */ X.jsxs("div", { className: s.trim(), ...a, children: [
    r,
    /* @__PURE__ */ X.jsx("div", { className: "arkynTooltipText", children: t })
  ] });
}
function ePe(e) {
  const {
    disabled: t,
    file: n,
    isLoading: r,
    acceptFile: o,
    changeFileButtonText: i,
    handleSelectFile: a,
    reSendFile: s
  } = e;
  function l() {
    if (t) return;
    const c = document.createElement("input");
    c.type = "file", c.accept = o, c.onchange = (p) => {
      var h;
      const d = (h = p.target.files) == null ? void 0 : h[0];
      d && a(d);
    }, c.click();
  }
  function u() {
    return n.type.startsWith("image/") ? /* @__PURE__ */ X.jsx($4, {}) : n.type.startsWith("audio/") ? /* @__PURE__ */ X.jsx(H4, {}) : n.type.startsWith("application/zip") ? /* @__PURE__ */ X.jsx(W4, {}) : /* @__PURE__ */ X.jsx(V4, {});
  }
  return /* @__PURE__ */ X.jsxs("div", { className: "arkynFileUploadHasFileContent", children: [
    /* @__PURE__ */ X.jsxs("section", { className: "arkynFileUploadFileContainer", children: [
      /* @__PURE__ */ X.jsx(u, {}),
      /* @__PURE__ */ X.jsx("p", { children: n.name })
    ] }),
    /* @__PURE__ */ X.jsx(N$, {}),
    /* @__PURE__ */ X.jsxs("div", { className: "arkynFileUploadButtonsContainer", children: [
      !!s && /* @__PURE__ */ X.jsx(H8, { orientation: "bottom", text: "Reenviar arquivo", children: /* @__PURE__ */ X.jsx(
        $8,
        {
          type: "button",
          "aria-label": "resend file",
          variant: "outline",
          scheme: "danger",
          size: "sm",
          isLoading: r,
          onClick: s,
          icon: Yx,
          disabled: t
        }
      ) }),
      /* @__PURE__ */ X.jsx(
        Ap,
        {
          isLoading: r,
          onClick: l,
          variant: "outline",
          size: "sm",
          type: "button",
          disabled: t,
          children: i
        }
      )
    ] })
  ] });
}
function tPe(e) {
  const {
    dropFileText: t,
    isLoading: n,
    acceptFile: r,
    handleSelectFile: o,
    selectFileButtonText: i,
    disabled: a
  } = e;
  function s(u) {
    if (a) return;
    u.preventDefault();
    const c = u.dataTransfer.files[0];
    c && o(c);
  }
  function l() {
    if (a) return;
    const u = document.createElement("input");
    u.type = "file", u.accept = r, u.onchange = (c) => {
      var d;
      const p = (d = c.target.files) == null ? void 0 : d[0];
      p && o(p);
    }, u.click();
  }
  return /* @__PURE__ */ X.jsxs("div", { onDrop: s, className: "arkynFileUploadNoFileContent", children: [
    /* @__PURE__ */ X.jsx(
      Gk,
      {
        isLoading: n,
        onClick: l,
        variant: "ghost",
        size: "sm",
        type: "button",
        disabled: a,
        children: i
      }
    ),
    /* @__PURE__ */ X.jsx("p", { children: t })
  ] });
}
function ORe(e) {
  const {
    name: t,
    label: n,
    showAsterisk: r = !1,
    action: o,
    fileName: i = "file",
    method: a = "POST",
    acceptFile: s = "*",
    fileResponseName: l = "url",
    changeFileButtonText: u = "Alterar arquivo",
    selectFileButtonText: c = "Selecionar arquivo",
    dropFileText: p = "Ou arraste e solte o arquivo aqui",
    onUpload: d,
    disabled: h = !1
  } = e, m = c1()[t], [g, E] = k(""), [w, M] = k(""), [x, y] = k(null), [C, P] = k(!1);
  async function F(z) {
    if (h) return;
    P(!0), y(z), M("");
    const q = new FormData();
    q.append(i, z), await fetch(o, { method: a, body: q }).then(async (K) => await K.json()).then((K) => {
      K != null && K.error ? M(K.error) : E(K == null ? void 0 : K[l]), d && d(K == null ? void 0 : K[l]);
    }).catch((K) => {
      console.error(K), M("Erro ao enviar o arquivo");
    }).finally(() => P(!1));
  }
  function L(z) {
    h || F(z);
  }
  const N = m || w, V = `arkynFileUpload ${N ? "hasError" : "noHasError"} ${x ? "hasFile" : "noHasFile"}`;
  return /* @__PURE__ */ X.jsxs("div", { className: "arkynFileUploadContainer", children: [
    n && /* @__PURE__ */ X.jsx(Q_e, { label: n, showAsterisk: r }),
    /* @__PURE__ */ X.jsxs("div", { className: V, children: [
      /* @__PURE__ */ X.jsx("input", { type: "hidden", name: t, value: g || "" }),
      !x && /* @__PURE__ */ X.jsx(
        tPe,
        {
          disabled: h,
          isLoading: C,
          acceptFile: s,
          dropFileText: p,
          handleSelectFile: L,
          selectFileButtonText: c
        }
      ),
      x && /* @__PURE__ */ X.jsx(
        ePe,
        {
          disabled: h,
          isLoading: C,
          acceptFile: s,
          file: x,
          handleSelectFile: L,
          changeFileButtonText: u,
          reSendFile: N && x ? () => F(x) : void 0
        }
      )
    ] }),
    N && /* @__PURE__ */ X.jsx(J_e, { error: N })
  ] });
}
function ERe(e) {
  const { children: t, className: n, ...r } = e, o = `arkynFormError ${n}`, { error: i } = Po();
  return t ? /* @__PURE__ */ X.jsx("strong", { className: o.trim(), ...r, children: t }) : i ? /* @__PURE__ */ X.jsx("strong", { className: o.trim(), ...r, children: i }) : /* @__PURE__ */ X.jsx(X.Fragment, {});
}
function d2(e) {
  const {
    showAsterisk: t = !1,
    className: n = "",
    ...r
  } = e, { id: o } = Po(), a = `arkynFormLabel ${t ? "asteriskTrue" : "asteriskFalse"} ${n}`;
  return /* @__PURE__ */ X.jsx("label", { className: a.trim(), htmlFor: o, ...r });
}
function nPe(e) {
  const {
    disabled: t,
    filePath: n,
    isLoading: r,
    acceptImage: o,
    changeImageButtonText: i,
    handleSelectFile: a,
    reSendImage: s
  } = e;
  function l() {
    if (t) return;
    const u = document.createElement("input");
    u.type = "file", u.accept = o, u.onchange = (c) => {
      var d;
      const p = (d = c.target.files) == null ? void 0 : d[0];
      p && a(p);
    }, u.click();
  }
  return /* @__PURE__ */ X.jsxs(
    "div",
    {
      className: "arkynImageUploadHasFileContent",
      style: { backgroundImage: `url("${n}")` },
      children: [
        s && /* @__PURE__ */ X.jsx(H8, { orientation: "bottom", text: "Reenviar imagem", children: /* @__PURE__ */ X.jsx(
          $8,
          {
            type: "button",
            "aria-label": "resend image",
            variant: "outline",
            scheme: "danger",
            size: "sm",
            isLoading: r,
            onClick: s,
            icon: Yx,
            disabled: t
          }
        ) }),
        /* @__PURE__ */ X.jsx(
          Ap,
          {
            isLoading: r,
            onClick: l,
            variant: "outline",
            size: "sm",
            type: "button",
            disabled: t,
            children: i
          }
        )
      ]
    }
  );
}
function rPe(e) {
  const { error: t } = e, n = "arkynImageUploadError";
  return t ? /* @__PURE__ */ X.jsx("strong", { className: n, children: t }) : /* @__PURE__ */ X.jsx(X.Fragment, {});
}
function oPe(e) {
  const { label: t, showAsterisk: n } = e, o = `arkynImageUploadLabel ${n ? "asteriskTrue" : "asteriskFalse"}`;
  return /* @__PURE__ */ X.jsx("strong", { className: o.trim(), children: t });
}
function iPe(e) {
  const {
    dropImageText: t,
    isLoading: n,
    acceptImage: r,
    handleSelectFile: o,
    selectImageButtonText: i,
    disabled: a
  } = e;
  function s(u) {
    if (a) return;
    u.preventDefault();
    const c = u.dataTransfer.files[0];
    c && o(c);
  }
  function l() {
    if (a) return;
    const u = document.createElement("input");
    u.type = "file", u.accept = r, u.onchange = (c) => {
      var d;
      const p = (d = c.target.files) == null ? void 0 : d[0];
      p && o(p);
    }, u.click();
  }
  return /* @__PURE__ */ X.jsxs("div", { onDrop: s, className: "arkynImageUploadNoFileContent", children: [
    /* @__PURE__ */ X.jsx(
      Ap,
      {
        isLoading: n,
        onClick: l,
        variant: "ghost",
        size: "sm",
        type: "button",
        disabled: a,
        children: i
      }
    ),
    /* @__PURE__ */ X.jsx("p", { children: t })
  ] });
}
function sPe(e) {
  const {
    name: t,
    defaultValue: n = "",
    label: r,
    showAsterisk: o = !1,
    action: i,
    fileName: a = "file",
    method: s = "POST",
    acceptImage: l = "image/*",
    fileResponseName: u = "url",
    changeImageButtonText: c = "Alterar imagem",
    selectImageButtonText: p = "Selecionar imagem",
    dropImageText: d = "Ou arraste e solte a imagem aqui",
    onUpload: h,
    disabled: f = !1
  } = e, g = c1()[t], [E, w] = k(n), [M, x] = k(""), [y, C] = k(null), [P, F] = k(n), [L, N] = k(!1);
  async function I(J) {
    if (f) return;
    N(!0), C(J), x("");
    const te = new FormData();
    te.append(a, J), await fetch(i, { method: s, body: te }).then(async (ee) => await ee.json()).then((ee) => {
      ee != null && ee.error ? x(ee.error) : w(ee == null ? void 0 : ee[u]), h && h(ee == null ? void 0 : ee[u]);
    }).catch((ee) => {
      console.error(ee), x("Erro ao enviar imagem");
    }).finally(() => N(!1));
  }
  function H(J) {
    f || (F(URL.createObjectURL(J)), I(J));
  }
  const V = g || M, K = `arkynImageUpload ${V ? "hasError" : "noHasError"} ${P ? "hasImage" : "noHasImage"}`;
  return /* @__PURE__ */ X.jsxs("div", { className: "arkynImageUploadContainer", children: [
    r && /* @__PURE__ */ X.jsx(oPe, { label: r, showAsterisk: o }),
    /* @__PURE__ */ X.jsxs("div", { className: K, children: [
      /* @__PURE__ */ X.jsx("input", { type: "hidden", name: t, value: E || "" }),
      !P && /* @__PURE__ */ X.jsx(
        iPe,
        {
          disabled: f,
          isLoading: L,
          acceptImage: l,
          dropImageText: d,
          handleSelectFile: H,
          selectImageButtonText: p
        }
      ),
      P && /* @__PURE__ */ X.jsx(
        nPe,
        {
          disabled: f,
          isLoading: L,
          acceptImage: l,
          filePath: P,
          handleSelectFile: H,
          changeImageButtonText: c,
          reSendImage: V && y ? () => I(y) : void 0
        }
      )
    ] }),
    V && /* @__PURE__ */ X.jsx(rPe, { error: V })
  ] });
}
function fa(e, t, n) {
  if (!e) return /* @__PURE__ */ X.jsx(X.Fragment, {});
  if (typeof e == "string") return /* @__PURE__ */ X.jsx("p", { className: n, children: e });
  const r = e;
  return /* @__PURE__ */ X.jsx("p", { className: n, children: /* @__PURE__ */ X.jsx(r, { color: "var(--secondary-600)", size: t, strokeWidth: 2.5 }) });
}
function p1(e) {
  return e && e.replace(/[^0-9]/g, "");
}
function W8(e, t) {
  let n = "", r = 0;
  return Array.from(e).forEach((o, i) => {
    t[i + r].match(/[0-9]/) || (n += t[i + r], r++), n += o;
  }), n;
}
function V8(e) {
  return e.length > 11 ? "CNPJ" : "CPF";
}
const d1 = {
  CPF: "999.999.999-999",
  CNPJ: "99.999.999/9999-99"
}, q8 = p1(d1.CNPJ).length;
function aPe(e, t) {
  const {
    isLoading: n,
    isError: r,
    size: o = "md",
    className: i = "",
    variant: a = "solid",
    prefix: s,
    sufix: l,
    leftIcon: u,
    rightIcon: c,
    disabled: p,
    defaultValue: d,
    readOnly: h,
    onFocus: f,
    onBlur: m,
    title: g,
    style: E,
    onChange: w,
    ...M
  } = e;
  function x(z) {
    let q = p1(z);
    const K = V8(q);
    if (!(q.length > q8))
      return q = W8(q, d1[K]), q;
  }
  const y = c ? "right" : "left", I = `arkyn_input ${s ? "hasPrefix" : ""} ${l ? "hasSufix" : ""} ${a} ${o} ${p || h || n ? "opacity" : ""} ${r ? "errored" : ""} ${t ? "focused" : ""} ${i}`, V = { md: 20, lg: 20 }[o];
  return {
    isLoading: n,
    className: I,
    prefix: fa(s, V, "prefix"),
    sufix: fa(l, V, "sufix"),
    LeftIcon: u,
    RightIcon: c,
    defaultValue: x(d || ""),
    disabled: p,
    readOnly: h,
    onFocus: f,
    onBlur: m,
    title: g,
    style: E,
    onChange: w,
    loadingPosition: y,
    iconSize: V,
    Spinner: /* @__PURE__ */ X.jsx(Gi, { className: "spinner", size: V, strokeWidth: 2.5 }),
    ...M
  };
}
function lPe(e) {
  const [t, n] = k(!1), r = rt(null), { inputRef: o, id: i, error: a } = Po(), s = o || r, l = e.isError || !!a, {
    disabled: u,
    title: c,
    style: p,
    className: d,
    prefix: h,
    sufix: f,
    iconSize: m,
    loadingPosition: g,
    isLoading: E,
    LeftIcon: w,
    readOnly: M,
    onFocus: x,
    onBlur: y,
    RightIcon: C,
    Spinner: P,
    onChange: F,
    value: L,
    defaultValue: N,
    ...I
  } = aPe({ ...e, id: i, isError: l }, t), [H, V] = k(N), z = w && !E, q = C && !E, K = g === "left" && E, J = g === "right" && E;
  function te() {
    u || !(s != null && s.current) || (n(!0), s.current.focus());
  }
  function ee($) {
    let S = p1($.target.value);
    const W = V8(S);
    S.length > q8 || (S = W8(S, d1[W]), $.target.value = S, V(S), F && F($));
  }
  function _($) {
    n(!0), x && x($);
  }
  function D($) {
    n(!1), y && y($);
  }
  return /* @__PURE__ */ X.jsxs(
    "section",
    {
      title: c,
      style: p,
      onClick: te,
      className: d,
      children: [
        h,
        K && P,
        z && /* @__PURE__ */ X.jsx(w, { size: m, strokeWidth: 2.5 }),
        /* @__PURE__ */ X.jsx(
          "input",
          {
            disabled: u || E,
            readOnly: M,
            ref: s,
            value: L || H,
            onFocus: _,
            onChange: ee,
            onBlur: D,
            ...I
          }
        ),
        q && /* @__PURE__ */ X.jsx(C, { size: m, strokeWidth: 2.5 }),
        J && P,
        f
      ]
    }
  );
}
const uPe = 3, cPe = (e = "pt-BR", t, n = "BRL", r = !0) => new Intl.NumberFormat(e, {
  style: "currency",
  currency: n,
  currencyDisplay: "symbol",
  minimumFractionDigits: 2,
  maximumFractionDigits: 2
}).format(t).slice(r ? uPe : 0), lh = 2, f2 = (e) => typeof e == "number" ? e : Number(e.toString().replace(/[^0-9-]/g, "")), jx = (e) => {
  let t = e;
  return typeof e == "string" ? (t = f2(e), t % 1 !== 0 && (t = t.toFixed(lh))) : t = Number.isInteger(e) ? Number(e) * 10 ** lh : e.toFixed(lh), f2(t) / 10 ** lh;
}, h2 = (e, t, n) => {
  if (!t) return [0, ""];
  const r = jx(t), o = cPe(e, r, n);
  return [r, o];
};
function pPe(e, t) {
  const {
    isLoading: n,
    isError: r,
    size: o = "md",
    className: i = "",
    variant: a = "solid",
    prefix: s,
    sufix: l,
    leftIcon: u,
    rightIcon: c,
    disabled: p,
    readOnly: d,
    onFocus: h,
    onBlur: f,
    title: m,
    style: g,
    // showCents = false,
    max: E = 1e9,
    locale: w = "pt-BR",
    currency: M = "BRL",
    ...x
  } = e, y = c ? "right" : "left", I = `arkyn_input ${s ? "hasPrefix" : ""} ${l ? "hasSufix" : ""} ${a} ${o} ${p || d || n ? "opacity" : ""} ${r ? "errored" : ""} ${t ? "focused" : ""} ${i}`, V = { md: 20, lg: 20 }[o];
  return {
    isLoading: n,
    className: I,
    prefix: fa(s, V, "prefix"),
    sufix: fa(l, V, "sufix"),
    LeftIcon: u,
    RightIcon: c,
    disabled: p,
    locale: w,
    currency: M,
    readOnly: d,
    onFocus: h,
    onBlur: f,
    title: m,
    style: g,
    max: E,
    // showCents,
    loadingPosition: y,
    iconSize: V,
    Spinner: /* @__PURE__ */ X.jsx(Gi, { className: "spinner", size: V, strokeWidth: 2.5 }),
    ...x
  };
}
function dPe(e) {
  const [t, n] = k(!1), [r, o] = k("0"), i = rt(null), { inputRef: a, id: s, error: l } = Po(), u = a || i, c = e.isError || !!l, {
    disabled: p,
    title: d,
    style: h,
    className: f,
    prefix: m,
    sufix: g,
    iconSize: E,
    loadingPosition: w,
    isLoading: M,
    LeftIcon: x,
    readOnly: y,
    onFocus: C,
    onBlur: P,
    RightIcon: F,
    Spinner: L,
    value: N,
    max: I,
    onChangeValue: H,
    onKeyPress: V,
    currency: z,
    locale: q,
    name: K,
    defaultValue: J,
    ...te
  } = pPe({ ...e, id: s, isError: c }, t), ee = x && !M, _ = F && !M, D = w === "left" && M, $ = w === "right" && M;
  function S() {
    p || !(u != null && u.current) || (n(!0), u.current.focus());
  }
  function W(Z) {
    n(!0), C && C(Z);
  }
  function O(Z) {
    n(!1), P && P(Z);
  }
  const T = (Z) => {
    const [A, Q] = h2(
      q,
      Z,
      z
    );
    return !I || A <= I ? (o(Q), [A, Q]) : [jx(r), r];
  }, U = (Z) => {
    Z.preventDefault();
    const [A, Q] = T(Z.target.value);
    H && H(Z, String(A), String(Q));
  }, j = (Z) => V && V(Z, Z.key, Z.key);
  return v(() => {
    const Z = N || +J || void 0, [, A] = h2(q, Z, z);
    o(A);
  }, [z, J, N]), /* @__PURE__ */ X.jsxs(
    "section",
    {
      title: d,
      style: h,
      onClick: S,
      className: f,
      children: [
        m,
        D && L,
        ee && /* @__PURE__ */ X.jsx(x, { size: E, strokeWidth: 2.5 }),
        /* @__PURE__ */ X.jsx(
          "input",
          {
            value: r,
            onChange: U,
            onBlur: O,
            onFocus: W,
            onKeyUp: j,
            disabled: p || M,
            readOnly: y,
            ...te
          }
        ),
        /* @__PURE__ */ X.jsx(
          "input",
          {
            type: "hidden",
            ref: u,
            name: K,
            value: jx(r)
          }
        ),
        $ && L,
        _ && /* @__PURE__ */ X.jsx(F, { size: E, strokeWidth: 2.5 }),
        g
      ]
    }
  );
}
function fPe(e, t) {
  const {
    isLoading: n,
    isError: r,
    size: o = "md",
    className: i = "",
    variant: a = "solid",
    prefix: s,
    sufix: l,
    leftIcon: u,
    rightIcon: c,
    disabled: p,
    readOnly: d,
    onFocus: h,
    onBlur: f,
    title: m,
    style: g,
    onChange: E,
    showMask: w = !1,
    type: M,
    ...x
  } = e, y = c ? "right" : "left", I = `arkyn_input ${s ? "hasPrefix" : ""} ${l ? "hasSufix" : ""} ${a} ${o} ${p || d || n ? "opacity" : ""} ${r ? "errored" : ""} ${t ? "focused" : ""} ${i}`, V = { md: 20, lg: 20 }[o];
  return {
    isLoading: n,
    className: I,
    prefix: fa(s, V, "prefix"),
    sufix: fa(l, V, "sufix"),
    LeftIcon: u,
    RightIcon: c,
    disabled: p,
    readOnly: d,
    onFocus: h,
    onBlur: f,
    title: m,
    style: g,
    onChange: E,
    loadingPosition: y,
    iconSize: V,
    showMask: w,
    Spinner: /* @__PURE__ */ X.jsx(Gi, { className: "spinner", size: V, strokeWidth: 2.5 }),
    ...x
  };
}
const hPe = Vr((e, t) => /* @__PURE__ */ X.jsx("input", { ref: t, ...e }));
function gPe(e) {
  const [t, n] = k(!1), r = rt(null), { inputRef: o, id: i, error: a } = Po(), s = o || r, l = e.isError || !!a, {
    disabled: u,
    title: c,
    style: p,
    className: d,
    prefix: h,
    sufix: f,
    iconSize: m,
    loadingPosition: g,
    isLoading: E,
    LeftIcon: w,
    readOnly: M,
    onFocus: x,
    onBlur: y,
    RightIcon: C,
    Spinner: P,
    ...F
  } = fPe({ ...e, id: i, isError: l }, t), L = w && !E, N = C && !E, I = g === "left" && E, H = g === "right" && E;
  function V() {
    u || !(s != null && s.current) || (n(!0), s.current.focus());
  }
  function z(K) {
    n(!0), x && x(K);
  }
  function q(K) {
    n(!1), y && y(K);
  }
  return /* @__PURE__ */ X.jsxs(
    "section",
    {
      title: c,
      style: p,
      onClick: V,
      className: d,
      children: [
        h,
        I && P,
        L && /* @__PURE__ */ X.jsx(w, { size: m, strokeWidth: 2.5 }),
        /* @__PURE__ */ X.jsx(
          Il,
          {
            component: hPe,
            ref: s,
            onFocus: z,
            onBlur: q,
            disabled: u,
            ...F
          }
        ),
        N && /* @__PURE__ */ X.jsx(C, { size: m, strokeWidth: 2.5 }),
        H && P,
        f
      ]
    }
  );
}
function mPe(e, t) {
  const {
    isLoading: n,
    isError: r,
    size: o = "md",
    className: i = "",
    variant: a = "solid",
    prefix: s,
    sufix: l,
    leftIcon: u,
    rightIcon: c,
    disabled: p,
    readOnly: d,
    onFocus: h,
    onBlur: f,
    title: m,
    style: g,
    onChange: E,
    ...w
  } = e, M = c ? "right" : "left", L = `arkyn_input ${s ? "hasPrefix" : ""} ${l ? "hasSufix" : ""} ${a} ${o} ${p || d || n ? "opacity" : ""} ${r ? "errored" : ""} ${t ? "focused" : ""} ${i}`, I = { md: 20, lg: 20 }[o];
  return {
    isLoading: n,
    className: L,
    prefix: fa(s, I, "prefix"),
    sufix: fa(l, I, "sufix"),
    LeftIcon: u,
    RightIcon: c,
    disabled: p,
    readOnly: d,
    onFocus: h,
    onBlur: f,
    title: m,
    style: g,
    onChange: E,
    loadingPosition: M,
    iconSize: I,
    Spinner: /* @__PURE__ */ X.jsx(Gi, { className: "spinner", size: I, strokeWidth: 2.5 }),
    ...w
  };
}
function vPe(e) {
  const [t, n] = k(!1), r = rt(null), { inputRef: o, id: i, error: a } = Po(), s = o || r, l = e.isError || !!a, {
    disabled: u,
    title: c,
    style: p,
    className: d,
    prefix: h,
    sufix: f,
    iconSize: m,
    loadingPosition: g,
    isLoading: E,
    LeftIcon: w,
    readOnly: M,
    onFocus: x,
    onBlur: y,
    RightIcon: C,
    type: P,
    Spinner: F,
    ...L
  } = mPe({ ...e, id: i, isError: l }, t), N = w && !E, I = C && !E, H = g === "left" && E, V = g === "right" && E;
  function z() {
    u || !(s != null && s.current) || (n(!0), s.current.focus());
  }
  function q(J) {
    n(!0), x && x(J);
  }
  function K(J) {
    n(!1), y && y(J);
  }
  return P === "hidden" ? /* @__PURE__ */ X.jsx(
    "input",
    {
      style: { display: "none" },
      readOnly: !0,
      type: "text",
      ref: s,
      ...L
    }
  ) : /* @__PURE__ */ X.jsxs(
    "section",
    {
      title: c,
      style: p,
      onClick: z,
      className: d,
      children: [
        h,
        H && F,
        N && /* @__PURE__ */ X.jsx(w, { size: m, strokeWidth: 2.5 }),
        /* @__PURE__ */ X.jsx(
          "input",
          {
            disabled: u || E,
            readOnly: M,
            ref: s,
            onFocus: q,
            onBlur: K,
            type: P,
            ...L
          }
        ),
        I && /* @__PURE__ */ X.jsx(C, { size: m, strokeWidth: 2.5 }),
        V && F,
        f
      ]
    }
  );
}
function By(e) {
  return e.type === "currency" ? /* @__PURE__ */ X.jsx(dPe, { ...e }) : e.type === "masked" ? /* @__PURE__ */ X.jsx(gPe, { ...e }) : e.type === "cpf-cnpj" ? /* @__PURE__ */ X.jsx(lPe, { ...e }) : /* @__PURE__ */ X.jsx(vPe, { ...e });
}
function yPe(e) {
  const { iconSize: t, isLoading: n, disabled: r, readOnly: o, isFocused: i } = e, l = `arkynMultiSelectChevron ${r || o ? "notAnimate" : ""} ${i ? "focused" : ""}`;
  return n ? /* @__PURE__ */ X.jsx(X.Fragment, {}) : /* @__PURE__ */ X.jsx(Jx, { className: l, size: t, strokeWidth: 2.5 });
}
function bPe(e) {
  const {
    children: t,
    handleContainerFocus: n,
    disabled: r,
    isError: o,
    isLoading: i,
    isFocused: a,
    className: s,
    readOnly: l,
    variant: u,
    size: c,
    id: p,
    prefixExists: d
  } = e, h = d ? "hasPrefix" : "", f = o ? "errored" : "", m = r || l || i ? "opacity" : "", g = a ? "focused" : "";
  return /* @__PURE__ */ X.jsx(
    "section",
    {
      id: p,
      className: `arkynMultiSelectContainer ${h} ${u} ${c} ${m} ${f} ${g} ${s}`,
      onClick: n,
      children: t
    }
  );
}
function wPe(e) {
  const { children: t, size: n } = e, r = `arkynMultiSelectContent ${n}`;
  return /* @__PURE__ */ X.jsx("div", { className: r, children: t });
}
function CPe(e) {
  const { label: t, value: n, handleChangeValue: r } = e;
  return /* @__PURE__ */ X.jsxs("div", { className: "arkynMultiSelectMark", children: [
    t,
    /* @__PURE__ */ X.jsx(
      "button",
      {
        type: "button",
        onClick: (o) => {
          o.stopPropagation(), r(n);
        },
        children: /* @__PURE__ */ X.jsx(Qx, {})
      }
    )
  ] });
}
function xPe(e) {
  const { label: t, optionHasSelected: n, handleChangeValue: r, value: o, size: i } = e, a = n(o) ? "active" : "", s = `arkynMultiSelectOption ${i} ${a}`;
  return /* @__PURE__ */ X.jsxs("div", { onClick: () => r(o), className: s, children: [
    t,
    " ",
    /* @__PURE__ */ X.jsx(Mm, {})
  ] });
}
function OPe(e) {
  const { children: t, isFocused: n, isSearchable: r, onSearch: o } = e;
  function i(a) {
    r && o(a.target.value);
  }
  return n ? /* @__PURE__ */ X.jsxs("div", { className: "arkynMultiSelectOptionsContainer", children: [
    r && /* @__PURE__ */ X.jsx(
      By,
      {
        type: "search",
        name: "search-select",
        variant: "underline",
        leftIcon: e$,
        onChange: i
      }
    ),
    t
  ] }) : /* @__PURE__ */ X.jsx(X.Fragment, {});
}
function EPe(e) {
  const { isFocused: t, handleBlur: n } = e;
  return t ? /* @__PURE__ */ X.jsx("aside", { className: "arkynMultiSelectOverlay", onClick: n }) : /* @__PURE__ */ X.jsx(X.Fragment, {});
}
function kPe(e) {
  const { iconSize: t, isLoading: n } = e;
  return n ? /* @__PURE__ */ X.jsx(
    Gi,
    {
      className: "arkynMultiSelectSpinner",
      size: t,
      strokeWidth: 2.5
    }
  ) : /* @__PURE__ */ X.jsx(X.Fragment, {});
}
function kRe(e) {
  const {
    name: t,
    options: n,
    className: r = "",
    placeholder: o = "Selecione...",
    closeOnSelect: i = !1,
    defaultValue: a = [],
    isError: s,
    isLoading: l = !1,
    readOnly: u = !1,
    isSearchable: c = !1,
    leftIcon: p,
    onSearch: d,
    onSelect: h,
    onBlur: f,
    notFoundText: m = "Sem opes disponveis",
    onFocus: g,
    disabled: E = !1,
    prefix: w,
    size: M = "md",
    value: x,
    variant: y = "solid"
  } = e, C = Po(), P = rt(null), F = C.inputRef || P, L = C.id, N = s || !!C.error, H = { md: 20, lg: 20 }[M], V = R$(w, H, "prefix"), [z, q] = k(""), [K, J] = k(!1), [te, ee] = k(a), _ = x || te;
  function D(j) {
    return _.includes(j);
  }
  function $(j) {
    const Z = n.find((A) => A.value === j);
    return (Z == null ? void 0 : Z.label) || "";
  }
  function S() {
    E || !(F != null && F.current) || K || (J(!0), F.current.focus(), g && g());
  }
  function W() {
    J(!1), f && F.current && F.current.blur();
  }
  function O(j) {
    q(j), d && d(j);
  }
  function T(j) {
    D(j) ? ee(te.filter((Z) => Z !== j)) : ee([...te, j]), h && h(te), i && W();
  }
  const U = n.filter((j) => !!(e.onSearch || !e.isSearchable || j.label.toLowerCase().includes(z.toLowerCase())));
  return /* @__PURE__ */ X.jsxs(
    bPe,
    {
      handleContainerFocus: S,
      disabled: E,
      isError: N,
      isFocused: K,
      isLoading: l,
      readOnly: u,
      size: M,
      variant: y,
      className: r,
      prefixExists: !!w,
      id: L,
      children: [
        /* @__PURE__ */ X.jsx(
          "input",
          {
            ref: F,
            name: t,
            value: JSON.stringify(_),
            type: "hidden"
          }
        ),
        V,
        p && /* @__PURE__ */ X.jsx(p, { size: H, strokeWidth: 2.5 }),
        /* @__PURE__ */ X.jsxs(wPe, { size: M, children: [
          _.map((j) => /* @__PURE__ */ X.jsx(
            CPe,
            {
              label: $(j),
              value: j,
              handleChangeValue: T
            },
            j
          )),
          _.length <= 0 && /* @__PURE__ */ X.jsx("p", { children: o })
        ] }),
        /* @__PURE__ */ X.jsxs(
          OPe,
          {
            isFocused: K,
            isSearchable: c,
            onSearch: O,
            children: [
              U.map(({ label: j, value: Z }) => /* @__PURE__ */ X.jsx(
                xPe,
                {
                  label: j,
                  value: Z,
                  size: M,
                  handleChangeValue: T,
                  optionHasSelected: D
                },
                Z
              )),
              U.length <= 0 && /* @__PURE__ */ X.jsx("p", { children: m })
            ]
          }
        ),
        /* @__PURE__ */ X.jsx(
          yPe,
          {
            disabled: E,
            isFocused: K,
            readOnly: u,
            iconSize: H,
            isLoading: l
          }
        ),
        /* @__PURE__ */ X.jsx(kPe, { iconSize: H, isLoading: l }),
        /* @__PURE__ */ X.jsx(EPe, { handleBlur: W, isFocused: K })
      ]
    }
  );
}
const Zl = [
  {
    name: "Afghanistan",
    code: "+93",
    prefix: null,
    iso: "AF",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/af.svg",
    mask: "__-___-____"
  },
  {
    name: "Aland Islands",
    code: "+358",
    prefix: null,
    iso: "AX",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ax.svg",
    mask: "(___)___-__-__"
  },
  {
    name: "Albania",
    code: "+355",
    prefix: null,
    iso: "AL",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/al.svg",
    mask: "(___)___-___"
  },
  {
    name: "Algeria",
    code: "+213",
    prefix: null,
    iso: "DZ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/dz.svg",
    mask: "__-___-____"
  },
  {
    name: "American Samoa",
    code: "+1",
    prefix: "684",
    iso: "AS",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/as.svg",
    mask: "(684)___-____"
  },
  {
    name: "Andorra",
    code: "+376",
    prefix: null,
    iso: "AD",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ad.svg",
    mask: "___-___"
  },
  {
    name: "Angola",
    code: "+244",
    prefix: null,
    iso: "AO",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ao.svg",
    mask: "(___)___-___"
  },
  {
    name: "Anguilla",
    code: "+1",
    prefix: "264",
    iso: "AI",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ai.svg",
    mask: "(264)___-____"
  },
  {
    name: "Antarctica",
    code: "+672",
    prefix: "1",
    iso: "AQ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/aq.svg",
    mask: "1__-___"
  },
  {
    name: "Antigua and Barbuda",
    code: "+1",
    prefix: "268",
    iso: "AG",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ag.svg",
    mask: "(268)___-____"
  },
  {
    name: "Argentina",
    code: "+54",
    prefix: null,
    iso: "AR",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ar.svg",
    mask: "(___)___-____"
  },
  {
    name: "Armenia",
    code: "+374",
    prefix: null,
    iso: "AM",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/am.svg",
    mask: "__-___-___"
  },
  {
    name: "Aruba",
    code: "+297",
    prefix: null,
    iso: "AW",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/aw.svg",
    mask: "___-____"
  },
  {
    name: "Ascension Island",
    code: "+247",
    prefix: null,
    iso: "AC",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/sh.svg",
    mask: "____"
  },
  {
    name: "Australia",
    code: "+61",
    prefix: null,
    iso: "AU",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/au.svg",
    mask: "_-____-____"
  },
  {
    name: "Austria",
    code: "+43",
    prefix: null,
    iso: "AT",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/at.svg",
    mask: "(___)___-____"
  },
  {
    name: "Azerbaijan",
    code: "+994",
    prefix: null,
    iso: "AZ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/az.svg",
    mask: "__-___-__-__"
  },
  {
    name: "Bahamas",
    code: "+1",
    prefix: "242",
    iso: "BS",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/bs.svg",
    mask: "(242)___-____"
  },
  {
    name: "Bahrain",
    code: "+973",
    prefix: null,
    iso: "BH",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/bh.svg",
    mask: "____-____"
  },
  {
    name: "Bangladesh",
    code: "+880",
    prefix: "1",
    iso: "BD",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/bd.svg",
    mask: "1___-______"
  },
  {
    name: "Barbados",
    code: "+1",
    prefix: "246",
    iso: "BB",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/bb.svg",
    mask: "(246)___-____"
  },
  {
    name: "Belarus",
    code: "+375",
    prefix: null,
    iso: "BY",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/by.svg",
    mask: "(__)___-__-__"
  },
  {
    name: "Belgium",
    code: "+32",
    prefix: null,
    iso: "BE",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/be.svg",
    mask: "(___)___-___"
  },
  {
    name: "Belize",
    code: "+501",
    prefix: null,
    iso: "BZ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/bz.svg",
    mask: "___-____"
  },
  {
    name: "Benin",
    code: "+229",
    prefix: null,
    iso: "BJ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/bj.svg",
    mask: "__-__-____"
  },
  {
    name: "Bermuda",
    code: "+1",
    prefix: "441",
    iso: "BM",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/bm.svg",
    mask: "(441)___-____"
  },
  {
    name: "Bhutan",
    code: "+975",
    prefix: null,
    iso: "BT",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/bt.svg",
    mask: "_-___-___"
  },
  {
    name: "Bolivia",
    code: "+591",
    prefix: null,
    iso: "BO",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/bo.svg",
    mask: "_-___-____"
  },
  {
    name: "Bosnia and Herzegovina",
    code: "+387",
    prefix: null,
    iso: "BA",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ba.svg",
    mask: "__-_____"
  },
  {
    name: "Botswana",
    code: "+267",
    prefix: null,
    iso: "BW",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/bw.svg",
    mask: "__-___-___"
  },
  {
    name: "Brasil",
    code: "+55",
    prefix: null,
    iso: "BR",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/br.svg",
    mask: "(__) _____-____"
  },
  {
    name: "British Indian Ocean Territory",
    code: "+246",
    prefix: null,
    iso: "IO",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/io.svg",
    mask: "___-____"
  },
  {
    name: "Brunei Darussalam",
    code: "+673",
    prefix: null,
    iso: "BN",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/bn.svg",
    mask: "___-____"
  },
  {
    name: "Bulgaria",
    code: "+359",
    prefix: null,
    iso: "BG",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/bg.svg",
    mask: "(___)___-___"
  },
  {
    name: "Burkina Faso",
    code: "+226",
    prefix: null,
    iso: "BF",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/bf.svg",
    mask: "__-__-____"
  },
  {
    name: "Burundi",
    code: "+257",
    prefix: null,
    iso: "BI",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/bi.svg",
    mask: "__-__-____"
  },
  {
    name: "Cambodia",
    code: "+855",
    prefix: null,
    iso: "KH",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/kh.svg",
    mask: "__-___-___"
  },
  {
    name: "Cameroon",
    code: "+237",
    prefix: null,
    iso: "CM",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/cm.svg",
    mask: "____-____"
  },
  {
    name: "Canada",
    code: "+1",
    prefix: null,
    iso: "CA",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ca.svg",
    mask: "(___)___-____"
  },
  {
    name: "Cape Verde",
    code: "+238",
    prefix: null,
    iso: "CV",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/cv.svg",
    mask: "(___)__-__"
  },
  {
    name: "Cayman Islands",
    code: "+1",
    prefix: "345",
    iso: "KY",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ky.svg",
    mask: "(345)___-____"
  },
  {
    name: "Central African Republic",
    code: "+236",
    prefix: null,
    iso: "CF",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/cf.svg",
    mask: "__-__-____"
  },
  {
    name: "Chad",
    code: "+235",
    prefix: null,
    iso: "TD",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/td.svg",
    mask: "__-__-__-__"
  },
  {
    name: "Chile",
    code: "+56",
    prefix: null,
    iso: "CL",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/cl.svg",
    mask: "_-____-____"
  },
  {
    name: "China",
    code: "+86",
    prefix: null,
    iso: "CN",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/cn.svg",
    mask: "__-_____-_____"
  },
  {
    name: "Christmas Island",
    code: "+61",
    prefix: null,
    iso: "CX",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/cx.svg",
    mask: "_-____-____"
  },
  {
    name: "Cocos (Keeling) Islands",
    code: "+61",
    prefix: null,
    iso: "CC",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/cc.svg",
    mask: "_-____-____"
  },
  {
    name: "Colombia",
    code: "+57",
    prefix: null,
    iso: "CO",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/co.svg",
    mask: "(___)___-____"
  },
  {
    name: "Comoros",
    code: "+269",
    prefix: null,
    iso: "KM",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/km.svg",
    mask: "__-_____"
  },
  {
    name: "Congo",
    code: "+242",
    prefix: null,
    iso: "CG",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/cg.svg",
    mask: "__-_____"
  },
  {
    name: "Cook Islands",
    code: "+682",
    prefix: null,
    iso: "CK",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ck.svg",
    mask: "__-___"
  },
  {
    name: "Costa Rica",
    code: "+506",
    prefix: null,
    iso: "CR",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/cr.svg",
    mask: "____-____"
  },
  {
    name: "Croatia",
    code: "+385",
    prefix: null,
    iso: "HR",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/hr.svg",
    mask: "__-___-___"
  },
  {
    name: "Cuba",
    code: "+53",
    prefix: null,
    iso: "CU",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/cu.svg",
    mask: "_-___-____"
  },
  {
    name: "Cyprus",
    code: "+357",
    prefix: null,
    iso: "CY",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/cy.svg",
    mask: "__-___-___"
  },
  {
    name: "Czech Republic",
    code: "+420",
    prefix: null,
    iso: "CZ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/cz.svg",
    mask: "(___)___-___"
  },
  {
    name: "Democratic Republic of the Congo",
    code: "+243",
    prefix: null,
    iso: "CD",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/cd.svg",
    mask: "(___)___-___"
  },
  {
    name: "Denmark",
    code: "+45",
    prefix: null,
    iso: "DK",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/dk.svg",
    mask: "__-__-__-__"
  },
  {
    name: "Djibouti",
    code: "+253",
    prefix: null,
    iso: "DJ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/dj.svg",
    mask: "__-__-__-__"
  },
  {
    name: "Dominica",
    code: "+1",
    prefix: "767",
    iso: "DM",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/dm.svg",
    mask: "(767)___-____"
  },
  {
    name: "Dominican Republic",
    code: "+1",
    prefix: "849",
    iso: "DO",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/do.svg",
    mask: "(894)___-____"
  },
  {
    name: "Ecuador",
    code: "+593",
    prefix: null,
    iso: "EC",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ec.svg",
    mask: "__-___-____"
  },
  {
    name: "Egypt",
    code: "+20",
    prefix: null,
    iso: "EG",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/eg.svg",
    mask: "(___)___-____"
  },
  {
    name: "El Salvador",
    code: "+503",
    prefix: null,
    iso: "SV",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/sv.svg",
    mask: "__-__-____"
  },
  {
    name: "Equatorial Guinea",
    code: "+240",
    prefix: null,
    iso: "GQ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/gq.svg",
    mask: "__-___-____"
  },
  {
    name: "Eritrea",
    code: "+291",
    prefix: null,
    iso: "ER",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/er.svg",
    mask: "_-___-___"
  },
  {
    name: "Estonia",
    code: "+372",
    prefix: null,
    iso: "EE",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ee.svg",
    mask: "____-____"
  },
  {
    name: "Eswatini",
    code: "+268",
    prefix: null,
    iso: "SZ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/sz.svg",
    mask: "__-__-____"
  },
  {
    name: "Ethiopia",
    code: "+251",
    prefix: null,
    iso: "ET",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/et.svg",
    mask: "__-___-____"
  },
  {
    name: "Falkland Islands (Malvinas)",
    code: "+500",
    prefix: null,
    iso: "FK",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/fk.svg",
    mask: "_____"
  },
  {
    name: "Faroe Islands",
    code: "+298",
    prefix: null,
    iso: "FO",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/fo.svg",
    mask: "__ __ __"
  },
  {
    name: "Fiji",
    code: "+679",
    prefix: null,
    iso: "FJ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/fj.svg",
    mask: "__-_____"
  },
  {
    name: "Finland",
    code: "+358",
    prefix: null,
    iso: "FI",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/fi.svg",
    mask: "__ ___ ____"
  },
  {
    name: "France",
    code: "+33",
    prefix: null,
    iso: "FR",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/fr.svg",
    mask: "_ __ __ __ __"
  },
  {
    name: "French Guiana",
    code: "+594",
    prefix: null,
    iso: "GF",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/gf.svg",
    mask: "___ __ __ __"
  },
  {
    name: "French Polynesia",
    code: "+689",
    prefix: null,
    iso: "PF",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/pf.svg",
    mask: "__ __ __ __"
  },
  {
    name: "Gabon",
    code: "+241",
    prefix: null,
    iso: "GA",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ga.svg",
    mask: "_ __ __ __"
  },
  {
    name: "Gambia",
    code: "+220",
    prefix: null,
    iso: "GM",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/gm.svg",
    mask: "___ ____"
  },
  {
    name: "Georgia",
    code: "+995",
    prefix: null,
    iso: "GE",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ge.svg",
    mask: "(___)___-___"
  },
  {
    name: "Germany",
    code: "+49",
    prefix: "3",
    iso: "DE",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/de.svg",
    mask: "(3____) __-____"
  },
  {
    name: "Ghana",
    code: "+233",
    prefix: "03",
    iso: "GH",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/gh.svg",
    mask: "03_ ___ ____"
  },
  {
    name: "Gibraltar",
    code: "+350",
    prefix: null,
    iso: "GI",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/gi.svg",
    mask: "___-_____"
  },
  {
    name: "Greece",
    code: "+30",
    prefix: null,
    iso: "GR",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/gr.svg",
    mask: "(___)___-____"
  },
  {
    name: "Greenland",
    code: "+299",
    prefix: null,
    iso: "GL",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/gl.svg",
    mask: "__-__-__"
  },
  {
    name: "Grenada",
    code: "+1",
    prefix: "473",
    iso: "GD",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/gd.svg",
    mask: "(473)___-____"
  },
  {
    name: "Guadeloupe",
    code: "+590",
    prefix: null,
    iso: "GP",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/gp.svg",
    mask: "___ __ __ __"
  },
  {
    name: "Guam",
    code: "+1",
    prefix: "671",
    iso: "GU",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/gu.svg",
    mask: "671 ___ ____"
  },
  {
    name: "Guatemala",
    code: "+502",
    prefix: null,
    iso: "GT",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/gt.svg",
    mask: "_-___-____"
  },
  {
    name: "Guernsey",
    code: "+44",
    prefix: null,
    iso: "GG",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/gg.svg",
    mask: "(____)______"
  },
  {
    name: "Guinea",
    code: "+224",
    prefix: null,
    iso: "GN",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/gn.svg",
    mask: "__-___-___"
  },
  {
    name: "Guinea-Bissau",
    code: "+245",
    prefix: null,
    iso: "GW",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/gw.svg",
    mask: "_-______"
  },
  {
    name: "Guyana",
    code: "+592",
    prefix: null,
    iso: "GY",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/gy.svg",
    mask: "___-____"
  },
  {
    name: "Haiti",
    code: "+509",
    prefix: null,
    iso: "HT",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ht.svg",
    mask: "__-__-____"
  },
  {
    name: "Holy See (Vatican City State)",
    code: "+39",
    prefix: "06698",
    iso: "VA",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/va.svg",
    mask: "06 698_____"
  },
  {
    name: "Honduras",
    code: "+504",
    prefix: null,
    iso: "HN",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/hn.svg",
    mask: "____-____"
  },
  {
    name: "Hong Kong",
    code: "+852",
    prefix: null,
    iso: "HK",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/hk.svg",
    mask: "____-____"
  },
  {
    name: "Hungary",
    code: "+36",
    prefix: null,
    iso: "HU",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/hu.svg",
    mask: "__ ___ ____"
  },
  {
    name: "Iceland",
    code: "+354",
    prefix: null,
    iso: "IS",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/is.svg",
    mask: "___-____"
  },
  {
    name: "India",
    code: "+91",
    prefix: null,
    iso: "IN",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/in.svg",
    mask: "(____)___-___"
  },
  {
    name: "Indonesia",
    code: "+62",
    prefix: "8",
    iso: "ID",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/id.svg",
    mask: "(8__)___-__-___"
  },
  {
    name: "Iran",
    code: "+98",
    prefix: null,
    iso: "IR",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ir.svg",
    mask: "(___)___-____"
  },
  {
    name: "Iraq",
    code: "+964",
    prefix: null,
    iso: "IQ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/iq.svg",
    mask: "(___)___-____"
  },
  {
    name: "Ireland",
    code: "+353",
    prefix: null,
    iso: "IE",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ie.svg",
    mask: "(___)___-___"
  },
  {
    name: "Isle of Man",
    code: "+44",
    prefix: null,
    iso: "IM",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/im.svg",
    mask: "(____)______"
  },
  {
    name: "Israel",
    code: "+972",
    prefix: "5",
    iso: "IL",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/il.svg",
    mask: "__-___-____"
  },
  {
    name: "Italy",
    code: "+39",
    prefix: null,
    iso: "IT",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/it.svg",
    mask: "(___)____-___"
  },
  {
    name: "Ivory Coast / Cote d'Ivoire",
    code: "+225",
    prefix: null,
    iso: "CI",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ci.svg",
    mask: "__-___-___"
  },
  {
    name: "Jamaica",
    code: "+1",
    prefix: "876",
    iso: "JM",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/jm.svg",
    mask: "(876)___-____"
  },
  {
    name: "Japan",
    code: "+81",
    prefix: null,
    iso: "JP",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/jp.svg",
    mask: "__-____-____"
  },
  {
    name: "Jersey",
    code: "+44",
    prefix: null,
    iso: "JE",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/je.svg",
    mask: "(____)____-______"
  },
  {
    name: "Jordan",
    code: "+962",
    prefix: null,
    iso: "JO",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/jo.svg",
    mask: "_-____-____"
  },
  {
    name: "Kazakhstan",
    code: "+77",
    prefix: null,
    iso: "KZ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/kz.svg",
    mask: "(_____) _ __ __"
  },
  {
    name: "Kenya",
    code: "+254",
    prefix: null,
    iso: "KE",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ke.svg",
    mask: "___-______"
  },
  {
    name: "Kiribati",
    code: "+686",
    prefix: null,
    iso: "KI",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ki.svg",
    mask: "__-___"
  },
  {
    name: "Korea, Democratic People's Republic of Korea",
    code: "+850",
    prefix: null,
    iso: "KP",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/kp.svg",
    mask: "____-_____________"
  },
  {
    name: "Korea, Republic of South Korea",
    code: "+82",
    prefix: null,
    iso: "KR",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/kr.svg",
    mask: "__-___-____"
  },
  {
    name: "Kosovo",
    code: "+383",
    prefix: null,
    iso: "XK",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/xk.svg",
    mask: "___-___-___"
  },
  {
    name: "Kuwait",
    code: "+965",
    prefix: null,
    iso: "KW",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/kw.svg",
    mask: "____-____"
  },
  {
    name: "Kyrgyzstan",
    code: "+996",
    prefix: null,
    iso: "KG",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/kg.svg",
    mask: "(___)___-___"
  },
  {
    name: "Laos",
    code: "+856",
    prefix: "20",
    iso: "LA",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/la.svg",
    mask: "(20__)___-___"
  },
  {
    name: "Latvia",
    code: "+371",
    prefix: null,
    iso: "LV",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/lv.svg",
    mask: "__-___-___"
  },
  {
    name: "Lebanon",
    code: "+961",
    prefix: null,
    iso: "LB",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/lb.svg",
    mask: "__-___-___"
  },
  {
    name: "Lesotho",
    code: "+266",
    prefix: null,
    iso: "LS",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ls.svg",
    mask: "_-___-____"
  },
  {
    name: "Liberia",
    code: "+231",
    prefix: null,
    iso: "LR",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/lr.svg",
    mask: "__-___-___"
  },
  {
    name: "Libya",
    code: "+218",
    prefix: "21",
    iso: "LY",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ly.svg",
    mask: "21-___-____"
  },
  {
    name: "Liechtenstein",
    code: "+423",
    prefix: null,
    iso: "LI",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/li.svg",
    mask: "(___)___-____"
  },
  {
    name: "Lithuania",
    code: "+370",
    prefix: null,
    iso: "LT",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/lt.svg",
    mask: "(___)__-___"
  },
  {
    name: "Luxembourg",
    code: "+352",
    prefix: null,
    iso: "LU",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/lu.svg",
    mask: "(___)___-___"
  },
  {
    name: "Macau",
    code: "+853",
    prefix: null,
    iso: "MO",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/mo.svg",
    mask: "____-____"
  },
  {
    name: "Madagascar",
    code: "+261",
    prefix: null,
    iso: "MG",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/mg.svg",
    mask: "__-__-_____"
  },
  {
    name: "Malawi",
    code: "+265",
    prefix: null,
    iso: "MW",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/mw.svg",
    mask: "_-____-____"
  },
  {
    name: "Malaysia",
    code: "+60",
    prefix: null,
    iso: "MY",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/my.svg",
    mask: "__-___-____"
  },
  {
    name: "Maldives",
    code: "+960",
    prefix: null,
    iso: "MV",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/mv.svg",
    mask: "___-____"
  },
  {
    name: "Mali",
    code: "+223",
    prefix: null,
    iso: "ML",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ml.svg",
    mask: "__-__-____"
  },
  {
    name: "Malta",
    code: "+356",
    prefix: null,
    iso: "MT",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/mt.svg",
    mask: "____-____"
  },
  {
    name: "Marshall Islands",
    code: "+692",
    prefix: null,
    iso: "MH",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/mh.svg",
    mask: "___-____"
  },
  {
    name: "Martinique",
    code: "+596",
    prefix: null,
    iso: "MQ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/mq.svg",
    mask: "(___)__-__-__"
  },
  {
    name: "Mauritania",
    code: "+222",
    prefix: null,
    iso: "MR",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/mr.svg",
    mask: "__-__-____"
  },
  {
    name: "Mauritius",
    code: "+230",
    prefix: null,
    iso: "MU",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/mu.svg",
    mask: "___-____"
  },
  {
    name: "Mayotte",
    code: "+262",
    prefix: null,
    iso: "YT",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/yt.svg",
    mask: "_____-____"
  },
  {
    name: "Mexico",
    code: "+52",
    prefix: null,
    iso: "MX",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/mx.svg",
    mask: "(___)___-____"
  },
  {
    name: "Micronesia, Federated States of Micronesia",
    code: "+691",
    prefix: null,
    iso: "FM",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/fm.svg",
    mask: "___-____"
  },
  {
    name: "Moldova",
    code: "+373",
    prefix: null,
    iso: "MD",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/md.svg",
    mask: "____-____"
  },
  {
    name: "Monaco",
    code: "+377",
    prefix: null,
    iso: "MC",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/mc.svg",
    mask: "(___)___-___"
  },
  {
    name: "Mongolia",
    code: "+976",
    prefix: null,
    iso: "MN",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/mn.svg",
    mask: "__-__-____"
  },
  {
    name: "Montenegro",
    code: "+382",
    prefix: null,
    iso: "ME",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/me.svg",
    mask: "__-___-___"
  },
  {
    name: "Montserrat",
    code: "+1",
    prefix: "664",
    iso: "MS",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ms.svg",
    mask: "(664)___-____"
  },
  {
    name: "Morocco",
    code: "+212",
    prefix: null,
    iso: "MA",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ma.svg",
    mask: "__-____-___"
  },
  {
    name: "Mozambique",
    code: "+258",
    prefix: null,
    iso: "MZ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/mz.svg",
    mask: "__-___-___"
  },
  {
    name: "Myanmar",
    code: "+95",
    prefix: null,
    iso: "MM",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/mm.svg",
    mask: "__-___-___"
  },
  {
    name: "Namibia",
    code: "+264",
    prefix: null,
    iso: "NA",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/na.svg",
    mask: "__-___-____"
  },
  {
    name: "Nauru",
    code: "+674",
    prefix: null,
    iso: "NR",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/nr.svg",
    mask: "___-____"
  },
  {
    name: "Nepal",
    code: "+977",
    prefix: null,
    iso: "NP",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/np.svg",
    mask: "__-___-___"
  },
  {
    name: "Netherlands",
    code: "+31",
    prefix: null,
    iso: "NL",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/nl.svg",
    mask: "__-___-____"
  },
  {
    name: "New Caledonia",
    code: "+687",
    prefix: null,
    iso: "NC",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/nc.svg",
    mask: "__-____"
  },
  {
    name: "New Zealand",
    code: "+64",
    prefix: null,
    iso: "NZ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/nz.svg",
    mask: "(___)___-____"
  },
  {
    name: "Nicaragua",
    code: "+505",
    prefix: null,
    iso: "NI",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ni.svg",
    mask: "____-____"
  },
  {
    name: "Niger",
    code: "+227",
    prefix: null,
    iso: "NE",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ne.svg",
    mask: "__-__-____"
  },
  {
    name: "Nigeria",
    code: "+234",
    prefix: null,
    iso: "NG",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ng.svg",
    mask: "(___)___-____"
  },
  {
    name: "Niue",
    code: "+683",
    prefix: null,
    iso: "NU",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/nu.svg",
    mask: "____"
  },
  {
    name: "Norfolk Island",
    code: "+672",
    prefix: "3",
    iso: "NF",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/nf.svg",
    mask: "3__-___"
  },
  {
    name: "North Macedonia",
    code: "+389",
    prefix: null,
    iso: "MK",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/mk.svg",
    mask: "__-___-___"
  },
  {
    name: "Northern Mariana Islands",
    code: "+1",
    prefix: "670",
    iso: "MP",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/mp.svg",
    mask: "(670)___-____"
  },
  {
    name: "Norway",
    code: "+47",
    prefix: null,
    iso: "NO",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/no.svg",
    mask: "(___)__-___"
  },
  {
    name: "Oman",
    code: "+968",
    prefix: null,
    iso: "OM",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/om.svg",
    mask: "__-___-___"
  },
  {
    name: "Pakistan",
    code: "+92",
    prefix: null,
    iso: "PK",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/pk.svg",
    mask: "(___)___-____"
  },
  {
    name: "Palau",
    code: "+680",
    prefix: null,
    iso: "PW",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/pw.svg",
    mask: "___-____"
  },
  {
    name: "Palestine",
    code: "+970",
    prefix: null,
    iso: "PS",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ps.svg",
    mask: "__-___-____"
  },
  {
    name: "Panama",
    code: "+507",
    prefix: null,
    iso: "PA",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/pa.svg",
    mask: "___-____"
  },
  {
    name: "Papua New Guinea",
    code: "+675",
    prefix: null,
    iso: "PG",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/pg.svg",
    mask: "(___)__-___"
  },
  {
    name: "Paraguay",
    code: "+595",
    prefix: null,
    iso: "PY",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/py.svg",
    mask: "(___)___-___"
  },
  {
    name: "Peru",
    code: "+51",
    prefix: null,
    iso: "PE",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/pe.svg",
    mask: "(___)___-___"
  },
  {
    name: "Philippines",
    code: "+63",
    prefix: null,
    iso: "PH",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ph.svg",
    mask: "(___)___-____"
  },
  {
    name: "Pitcairn",
    code: "+870",
    prefix: null,
    iso: "PN",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/pn.svg",
    mask: "___-___-___"
  },
  {
    name: "Poland",
    code: "+48",
    prefix: null,
    iso: "PL",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/pl.svg",
    mask: "(___)___-___"
  },
  {
    name: "Portugal",
    code: "+351",
    prefix: null,
    iso: "PT",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/pt.svg",
    mask: "__-___-____"
  },
  {
    name: "Puerto Rico",
    code: "+1",
    prefix: null,
    iso: "PR",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/pr.svg",
    mask: "(___) ___ ____"
  },
  {
    name: "Qatar",
    code: "+974",
    prefix: null,
    iso: "QA",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/qa.svg",
    mask: "____-____"
  },
  {
    name: "Reunion",
    code: "+262",
    prefix: null,
    iso: "RE",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/re.svg",
    mask: "_____-____"
  },
  {
    name: "Romania",
    code: "+40",
    prefix: null,
    iso: "RO",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ro.svg",
    mask: "__-___-____"
  },
  {
    name: "Russia",
    code: "+7",
    prefix: null,
    iso: "RU",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ru.svg",
    mask: "(___)___-__-__"
  },
  {
    name: "Rwanda",
    code: "+250",
    prefix: null,
    iso: "RW",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/rw.svg",
    mask: "(___)___-___"
  },
  {
    name: "Saint Barthelemy",
    code: "+590",
    prefix: null,
    iso: "BL",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/bl.svg",
    mask: "___-__-__-__"
  },
  {
    name: "Saint Helena, Ascension and Tristan Da Cunha",
    code: "+290",
    prefix: null,
    iso: "SH",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/sh.svg",
    mask: "____"
  },
  {
    name: "Saint Kitts and Nevis",
    code: "+1",
    prefix: null,
    iso: "KN",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/kn.svg",
    mask: "(869)___-____"
  },
  {
    name: "Saint Lucia",
    code: "+1",
    prefix: "758",
    iso: "LC",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/lc.svg",
    mask: "(758)___-____"
  },
  {
    name: "Saint Martin",
    code: "+590",
    prefix: null,
    iso: "MF",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/mf.svg",
    mask: "(___)___-___"
  },
  {
    name: "Saint Pierre and Miquelon",
    code: "+508",
    prefix: null,
    iso: "PM",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/pm.svg",
    mask: "__-____"
  },
  {
    name: "Saint Vincent and the Grenadines",
    code: "+1",
    prefix: "784",
    iso: "VC",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/vc.svg",
    mask: "(784)___-____"
  },
  {
    name: "Samoa",
    code: "+685",
    prefix: null,
    iso: "WS",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ws.svg",
    mask: "__-____"
  },
  {
    name: "San Marino",
    code: "+378",
    prefix: null,
    iso: "SM",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/sm.svg",
    mask: "____-______"
  },
  {
    name: "Sao Tome and Principe",
    code: "+239",
    prefix: null,
    iso: "ST",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/st.svg",
    mask: "__-_____"
  },
  {
    name: "Saudi Arabia",
    code: "+966",
    prefix: null,
    iso: "SA",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/sa.svg",
    mask: "_-____-____"
  },
  {
    name: "Senegal",
    code: "+221",
    prefix: null,
    iso: "SN",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/sn.svg",
    mask: "__-___-____"
  },
  {
    name: "Serbia",
    code: "+381",
    prefix: null,
    iso: "RS",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/rs.svg",
    mask: "__-___-____"
  },
  {
    name: "Seychelles",
    code: "+248",
    prefix: null,
    iso: "SC",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/sc.svg",
    mask: "_-___-___"
  },
  {
    name: "Sierra Leone",
    code: "+232",
    prefix: null,
    iso: "SL",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/sl.svg",
    mask: "__-______"
  },
  {
    name: "Singapore",
    code: "+65",
    prefix: null,
    iso: "SG",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/sg.svg",
    mask: "____-____"
  },
  {
    name: "Sint Maarten",
    code: "+1",
    prefix: "721",
    iso: "SX",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/sx.svg",
    mask: "(721)___-____"
  },
  {
    name: "Slovakia",
    code: "+421",
    prefix: null,
    iso: "SK",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/sk.svg",
    mask: "(___)___-___"
  },
  {
    name: "Slovenia",
    code: "+386",
    prefix: null,
    iso: "SI",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/si.svg",
    mask: "__-___-___"
  },
  {
    name: "Solomon Islands",
    code: "+677",
    prefix: null,
    iso: "SB",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/sb.svg",
    mask: "___-____"
  },
  {
    name: "Somalia",
    code: "+252",
    prefix: null,
    iso: "SO",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/so.svg",
    mask: "__-___-___"
  },
  {
    name: "South Africa",
    code: "+27",
    prefix: null,
    iso: "ZA",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/za.svg",
    mask: "__-___-____"
  },
  {
    name: "South Georgia and the South Sandwich Islands",
    code: "+500",
    prefix: null,
    iso: "GS",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/gs.svg",
    mask: "_____"
  },
  {
    name: "South Sudan",
    code: "+211",
    prefix: null,
    iso: "SS",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ss.svg",
    mask: "__-___-____"
  },
  {
    name: "Spain",
    code: "+34",
    prefix: null,
    iso: "ES",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/es.svg",
    mask: "(___)___-___"
  },
  {
    name: "Sri Lanka",
    code: "+94",
    prefix: null,
    iso: "LK",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/lk.svg",
    mask: "__-___-____"
  },
  {
    name: "Sudan",
    code: "+249",
    prefix: null,
    iso: "SD",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/sd.svg",
    mask: "__-___-____"
  },
  {
    name: "Suriname",
    code: "+597",
    prefix: null,
    iso: "SR",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/sr.svg",
    mask: "___-____"
  },
  {
    name: "Svalbard and Jan Mayen",
    code: "+47",
    prefix: null,
    iso: "SJ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/sj.svg",
    mask: "(___)__-___"
  },
  {
    name: "Sweden",
    code: "+46",
    prefix: null,
    iso: "SE",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/se.svg",
    mask: "__-___-____"
  },
  {
    name: "Switzerland",
    code: "+41",
    prefix: null,
    iso: "CH",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ch.svg",
    mask: "__-___-____"
  },
  {
    name: "Syrian Arab Republic",
    code: "+963",
    prefix: null,
    iso: "SY",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/sy.svg",
    mask: "__-____-___"
  },
  {
    name: "Taiwan",
    code: "+886",
    prefix: null,
    iso: "TW",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/tw.svg",
    mask: "_-____-____"
  },
  {
    name: "Tajikistan",
    code: "+992",
    prefix: null,
    iso: "TJ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/tj.svg",
    mask: "__-___-____"
  },
  {
    name: "United Republic of Tanzania",
    code: "+255",
    prefix: null,
    iso: "TZ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/tz.svg",
    mask: "__-___-____"
  },
  {
    name: "Thailand",
    code: "+66",
    prefix: null,
    iso: "TH",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/th.svg",
    mask: "__-___-____"
  },
  {
    name: "Timor-Leste",
    code: "+670",
    prefix: null,
    iso: "TL",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/tl.svg",
    mask: "___-_____"
  },
  {
    name: "Togo",
    code: "+228",
    prefix: null,
    iso: "TG",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/tg.svg",
    mask: "__-___-___"
  },
  {
    name: "Tokelau",
    code: "+690",
    prefix: null,
    iso: "TK",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/tk.svg",
    mask: "____"
  },
  {
    name: "Tonga",
    code: "+676",
    prefix: null,
    iso: "TO",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/to.svg",
    mask: "_____"
  },
  {
    name: "Trinidad and Tobago",
    code: "+1",
    prefix: "868",
    iso: "TT",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/tt.svg",
    mask: "(868)___-____"
  },
  {
    name: "Tunisia",
    code: "+216",
    prefix: null,
    iso: "TN",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/tn.svg",
    mask: "__-___-___"
  },
  {
    name: "Turkey",
    code: "+90",
    prefix: null,
    iso: "TR",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/tr.svg",
    mask: "(___)___-____"
  },
  {
    name: "Turkmenistan",
    code: "+993",
    prefix: null,
    iso: "TM",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/tm.svg",
    mask: "_-___-____"
  },
  {
    name: "Turks and Caicos Islands",
    code: "+1",
    prefix: "249",
    iso: "TC",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/tc.svg",
    mask: "(249)___-___"
  },
  {
    name: "Tuvalu",
    code: "+688",
    prefix: null,
    iso: "TV",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/tv.svg",
    mask: "______"
  },
  {
    name: "Uganda",
    code: "+256",
    prefix: null,
    iso: "UG",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ug.svg",
    mask: "(___)___-___"
  },
  {
    name: "Ukraine",
    code: "+380",
    prefix: null,
    iso: "UA",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ua.svg",
    mask: "(__)___-__-__"
  },
  {
    name: "United Arab Emirates",
    code: "+971",
    prefix: null,
    iso: "AE",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ae.svg",
    mask: "_-___-____"
  },
  {
    name: "United Kingdom",
    code: "+44",
    prefix: null,
    iso: "GB",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/gb.svg",
    mask: "__-____-____"
  },
  {
    name: "United States",
    code: "+1",
    prefix: "408",
    iso: "US",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/us.svg",
    mask: "(408)___-____"
  },
  {
    name: "Uruguay",
    code: "+598",
    prefix: null,
    iso: "UY",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/uy.svg",
    mask: "_-___-__-__"
  },
  {
    name: "Uzbekistan",
    code: "+998",
    prefix: null,
    iso: "UZ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/uz.svg",
    mask: "__-___-____"
  },
  {
    name: "Vanuatu",
    code: "+678",
    prefix: null,
    iso: "VU",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/vu.svg",
    mask: "__-_____"
  },
  {
    name: "Venezuela, Bolivarian Republic of Venezuela",
    code: "+58",
    prefix: null,
    iso: "VE",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ve.svg",
    mask: "(___)___-____"
  },
  {
    name: "Vietnam",
    code: "+84",
    prefix: null,
    iso: "VN",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/vn.svg",
    mask: "(___)____-___"
  },
  {
    name: "Virgin Islands, British",
    code: "+1",
    prefix: "284",
    iso: "VG",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/vg.svg",
    mask: "(284)___-____"
  },
  {
    name: "Virgin Islands, U.S.",
    code: "+1",
    prefix: "340",
    iso: "VI",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/vi.svg",
    mask: "(340)___-____"
  },
  {
    name: "Wallis and Futuna",
    code: "+681",
    prefix: null,
    iso: "WF",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/wf.svg",
    mask: "__-____"
  },
  {
    name: "Yemen",
    code: "+967",
    prefix: null,
    iso: "YE",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ye.svg",
    mask: "___-___-___"
  },
  {
    name: "Zambia",
    code: "+260",
    prefix: null,
    iso: "ZM",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/zm.svg",
    mask: "__-___-____"
  },
  {
    name: "Zimbabwe",
    code: "+263",
    prefix: null,
    iso: "ZW",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/zw.svg",
    mask: "_-______"
  }
];
function LPe(e) {
  const {
    children: t,
    onFocus: n,
    disabled: r,
    isError: o,
    isLoading: i,
    isFocused: a,
    className: s = "",
    readOnly: l,
    variant: u,
    size: c,
    id: p
  } = e, m = `arkynPhoneInputContainer ${u} ${c} ${r || l || i ? "opacity" : ""} ${o ? "errored" : ""} ${a ? "focused" : ""} ${s}`;
  return /* @__PURE__ */ X.jsx("section", { id: p, className: m.trim(), onClick: n, children: t });
}
function _Pe(e) {
  const { isOpen: t, onClick: n } = e;
  return t ? /* @__PURE__ */ X.jsx("aside", { className: "arkynPhoneInputCountriesOverlay", onClick: n }) : /* @__PURE__ */ X.jsx(X.Fragment, {});
}
function PPe(e) {
  const { country: t, isActive: n, handleChangeValue: r, size: o } = e, a = `arkynPhoneInputCountryOption ${o} ${n ? "active" : ""}`;
  return /* @__PURE__ */ X.jsxs("div", { onClick: () => r(t), className: a, children: [
    /* @__PURE__ */ X.jsx("img", { src: t.flag, alt: t.name, className: "flag" }),
    t.name,
    " ",
    /* @__PURE__ */ X.jsx("span", { children: t.code }),
    /* @__PURE__ */ X.jsx(Mm, { className: "check" })
  ] });
}
function SPe(e) {
  const { children: t, isOpen: n, onSearch: r, search: o, placeholder: i } = e;
  function a(s) {
    r(s.target.value);
  }
  return n ? /* @__PURE__ */ X.jsxs("div", { className: "arkynPhoneInputCountryOptionsContainer", children: [
    /* @__PURE__ */ X.jsx(
      "input",
      {
        type: "search",
        name: "search-select",
        className: "arkynPhoneInputCountryOptionsContainerSearchSelect",
        value: o,
        id: "input-search",
        placeholder: i,
        onChange: a
      }
    ),
    t
  ] }) : /* @__PURE__ */ X.jsx(X.Fragment, {});
}
function MPe(e) {
  const { currentCountry: t, onClick: n } = e;
  return /* @__PURE__ */ X.jsxs("div", { className: "phoneInputSelectCountry", onClick: n, children: [
    /* @__PURE__ */ X.jsx(
      "img",
      {
        className: "flag",
        src: t.flag,
        alt: t.name
      }
    ),
    /* @__PURE__ */ X.jsx(Jx, { className: "chevronDown", strokeWidth: 2.5 }),
    /* @__PURE__ */ X.jsx(N$, { orientation: "vertical" })
  ] });
}
function f1(e) {
  return e && e.replace(/[^0-9]/g, "");
}
const h1 = {
  EIGTH: "(99) 9999-9999",
  NINE: "(99) 99999-9999"
};
function Z8(e, t) {
  let n = "", r = 0;
  for (let o = 0; o < t.length; o++)
    if (t[o] === "9")
      if (r < e.length)
        n += e[r], r++;
      else
        break;
    else if (r < e.length)
      n += t[o];
    else
      break;
  return n;
}
function G8(e) {
  return e.length > 10 ? "NINE" : "EIGTH";
}
const X8 = f1(h1.NINE).length, DPe = Vr((e, t) => /* @__PURE__ */ X.jsx("input", { ref: t, ...e })), TPe = Vr(
  (e, t) => {
    const { onFocus: n, onBlur: r, size: o, onChange: i, value: a, currentCountry: s, disabled: l } = e, [u, c] = k(!1);
    v(() => {
      u ? i(s.mask) : c(!0);
    }, [s]);
    const p = `phoneInputMask ${o}`;
    function d(h) {
      let f = f1(h.target.value);
      const m = G8(f);
      f.length > X8 || (f = Z8(f, h1[m]), h.target.value = f, i(f));
    }
    return s.code === "+55" ? /* @__PURE__ */ X.jsx(
      "input",
      {
        value: a,
        onChange: d,
        className: p,
        onFocus: n,
        onBlur: r,
        disabled: l,
        ref: t
      }
    ) : /* @__PURE__ */ X.jsx(
      Il,
      {
        value: a,
        onChange: (h) => i(h.target.value),
        className: p,
        component: DPe,
        onFocus: n,
        onBlur: r,
        disabled: l,
        mask: s.mask,
        showMask: !0,
        replacement: { _: /\d/ },
        ref: t
      }
    );
  }
);
function g2(e, t) {
  if (t.code === "+55") {
    let o = f1(e);
    const i = G8(o);
    return o.length > X8 ? void 0 : (o = Z8(o, h1[i]), o);
  }
  let r = t.mask;
  if (t.prefix) {
    const o = /\$+/g;
    r = r.replace(o, t.prefix);
  }
  for (let o = 0, i = 0; o < r.length && i < e.length; o++)
    r[o] === "_" && (r = r.substring(0, o) + e[i] + r.substring(o + 1), i++);
  return r;
}
function jPe(e, t) {
  const n = Zl.find(
    (r) => r.code === e && r.prefix === t
  );
  return n || null;
}
function APe(e) {
  const t = Zl.find((n) => n.code === e);
  return t || null;
}
function BPe(e) {
  const t = e.split(" ")[0].split("-")[0], n = e.split(" ")[0].split("-")[1], r = e.split(" ")[1];
  if (!t || !r)
    return { country: null, formattedNumber: "" };
  if (n) {
    const s = jPe(t, n);
    if (!s) return { country: null, formattedNumber: "" };
    const l = g2(r, s);
    return { country: s, formattedNumber: l };
  }
  const o = APe(t);
  if (!o) return { country: null, formattedNumber: "" };
  const i = g2(r, o);
  return { country: o, formattedNumber: i };
}
function LRe(e) {
  const {
    defaultCountry: t,
    className: n = "",
    disabled: r = !1,
    isError: o = !1,
    isLoading: i = !1,
    readOnly: a = !1,
    size: s = "md",
    defaultValue: l = "",
    variant: u = "solid",
    name: c,
    onChange: p,
    searchCountryPlaceholder: d = "Pesquisar pas",
    notFoundCountryText: h = "Nenhum pas encontrado",
    ...f
  } = e, m = BPe(l), [g, E] = k(!1), [w, M] = k(""), [x, y] = k(!1), [C, P] = k(m.formattedNumber || ""), [F, L] = k(() => {
    if (m.country) return m.country;
    const S = Zl.find((W) => W.iso === t);
    return S || Zl[30];
  }), { id: N, inputRef: I, error: H } = Po(), V = o || !!H, z = rt(null);
  function q() {
    g || x || (E(!0), z.current && z.current.focus());
  }
  function K() {
    y(!0), E(!0);
  }
  function J() {
    y(!1), E(!1);
  }
  function te() {
    E(!0);
  }
  function ee() {
    E(!1);
  }
  function _(S) {
    return S.name.toLowerCase().includes(w.toLowerCase());
  }
  function D(S) {
    return F.prefix ? S.replace(F.prefix, "").replaceAll(" ", "").replaceAll("-", "").replaceAll("(", "").replaceAll(")", "").trim() : S.replaceAll(" ", "").replaceAll("-", "").replaceAll("(", "").replaceAll(")", "").trim();
  }
  function $(S) {
    let W = F.code;
    return F.prefix && (W += `-${F.prefix}`), W += " ", W += D(S || C), W;
  }
  return /* @__PURE__ */ X.jsxs(
    LPe,
    {
      id: N,
      disabled: r,
      isError: V,
      isLoading: i,
      isFocused: g,
      readOnly: a,
      size: s,
      variant: u,
      className: n,
      onFocus: q,
      children: [
        /* @__PURE__ */ X.jsx(
          MPe,
          {
            currentCountry: F,
            onClick: K,
            size: s
          }
        ),
        /* @__PURE__ */ X.jsxs(
          SPe,
          {
            isOpen: x,
            search: w,
            placeholder: d,
            onSearch: M,
            children: [
              Zl.filter((S) => _(S)).map((S) => /* @__PURE__ */ X.jsx(
                PPe,
                {
                  country: S,
                  handleChangeValue: () => {
                    L(S), y(!1), P(S.mask);
                  },
                  isActive: S.iso === F.iso,
                  size: s
                },
                S.iso
              )),
              Zl.filter((S) => _(S)).length === 0 && /* @__PURE__ */ X.jsx("p", { children: h })
            ]
          }
        ),
        /* @__PURE__ */ X.jsx(
          _Pe,
          {
            isOpen: x,
            onClick: J
          }
        ),
        /* @__PURE__ */ X.jsx(
          TPe,
          {
            ref: z,
            currentCountry: F,
            value: C,
            onChange: (S) => {
              P(S), p && p($(S));
            },
            disabled: r,
            onBlur: ee,
            onFocus: te,
            size: s
          }
        ),
        /* @__PURE__ */ X.jsx("input", { ref: I, type: "hidden", name: c, value: $() })
      ]
    }
  );
}
const K8 = Ze({});
function IPe() {
  return ye(K8);
}
function _Re(e) {
  const {
    defaultValue: t,
    name: n,
    value: r,
    onChange: o,
    size: i = "md",
    className: a = "",
    ...s
  } = e, [l, u] = k(t || ""), { inputRef: c, id: p } = Po();
  function d(f) {
    u(f), o && o(f);
  }
  const h = `arkynRadioGroup ${i} ${a}`;
  return /* @__PURE__ */ X.jsxs(
    K8.Provider,
    {
      value: { onChange: d, value: r || l, size: i },
      children: [
        /* @__PURE__ */ X.jsx(
          "input",
          {
            style: { display: "none" },
            type: "text",
            id: p,
            readOnly: !0,
            name: n,
            ref: c,
            value: r || l
          }
        ),
        /* @__PURE__ */ X.jsx("div", { className: h.trim(), ...s })
      ]
    }
  );
}
function PRe(e) {
  const {
    value: t,
    size: n,
    disabled: r,
    children: o,
    className: i = "",
    ...a
  } = e, { onChange: s, size: l, value: u } = IPe(), { error: c } = Po(), m = `arkynRadioBox ${n || l} ${u === t ? "checkedTrue" : "checkedFalse"} ${c ? "errorTrue" : "errorFalse"} ${r ? "disabledTrue" : "disabledFalse"} ${i}`;
  return /* @__PURE__ */ X.jsxs("label", { className: m.trim(), children: [
    /* @__PURE__ */ X.jsx(
      "button",
      {
        type: "button",
        disabled: r,
        onClick: () => s(t),
        onFocus: () => s(t),
        ...a
      }
    ),
    o
  ] });
}
var Ds = {};
Object.defineProperty(Ds, "__esModule", {
  value: !0
});
var RPe = typeof window < "u" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform), hw = {
  alt: "altKey",
  control: "ctrlKey",
  meta: "metaKey",
  shift: "shiftKey"
}, Y8 = {
  add: "+",
  break: "pause",
  cmd: "meta",
  command: "meta",
  ctl: "control",
  ctrl: "control",
  del: "delete",
  down: "arrowdown",
  esc: "escape",
  ins: "insert",
  left: "arrowleft",
  mod: RPe ? "meta" : "control",
  opt: "alt",
  option: "alt",
  return: "enter",
  right: "arrowright",
  space: " ",
  spacebar: " ",
  up: "arrowup",
  win: "meta",
  windows: "meta"
}, g1 = {
  backspace: 8,
  tab: 9,
  enter: 13,
  shift: 16,
  control: 17,
  alt: 18,
  pause: 19,
  capslock: 20,
  escape: 27,
  " ": 32,
  pageup: 33,
  pagedown: 34,
  end: 35,
  home: 36,
  arrowleft: 37,
  arrowup: 38,
  arrowright: 39,
  arrowdown: 40,
  insert: 45,
  delete: 46,
  meta: 91,
  numlock: 144,
  scrolllock: 145,
  ";": 186,
  "=": 187,
  ",": 188,
  "-": 189,
  ".": 190,
  "/": 191,
  "`": 192,
  "[": 219,
  "\\": 220,
  "]": 221,
  "'": 222
};
for (var uh = 1; uh < 20; uh++)
  g1["f" + uh] = 111 + uh;
function Iy(e, t, n) {
  t && !("byKey" in t) && (n = t, t = null), Array.isArray(e) || (e = [e]);
  var r = e.map(function(a) {
    return J8(a, t);
  }), o = function(s) {
    return r.some(function(l) {
      return Q8(l, s);
    });
  }, i = n == null ? o : o(n);
  return i;
}
function NPe(e, t) {
  return Iy(e, t);
}
function FPe(e, t) {
  return Iy(e, { byKey: !0 }, t);
}
function J8(e, t) {
  var n = t && t.byKey, r = {};
  e = e.replace("++", "+add");
  var o = e.split("+"), i = o.length;
  for (var a in hw)
    r[hw[a]] = !1;
  var s = !0, l = !1, u = void 0;
  try {
    for (var c = o[Symbol.iterator](), p; !(s = (p = c.next()).done); s = !0) {
      var d = p.value, h = d.endsWith("?") && d.length > 1;
      h && (d = d.slice(0, -1));
      var f = m1(d), m = hw[f];
      if (d.length > 1 && !m && !Y8[d] && !g1[f])
        throw new TypeError('Unknown modifier: "' + d + '"');
      (i === 1 || !m) && (n ? r.key = f : r.which = e5(d)), m && (r[m] = h ? null : !0);
    }
  } catch (g) {
    l = !0, u = g;
  } finally {
    try {
      !s && c.return && c.return();
    } finally {
      if (l)
        throw u;
    }
  }
  return r;
}
function Q8(e, t) {
  for (var n in e) {
    var r = e[n], o = void 0;
    if (r != null && (n === "key" && t.key != null ? o = t.key.toLowerCase() : n === "which" ? o = r === 91 && t.which === 93 ? 91 : t.which : o = t[n], !(o == null && r === !1) && o !== r))
      return !1;
  }
  return !0;
}
function e5(e) {
  e = m1(e);
  var t = g1[e] || e.toUpperCase().charCodeAt(0);
  return t;
}
function m1(e) {
  return e = e.toLowerCase(), e = Y8[e] || e, e;
}
var zPe = Ds.default = Iy, gw = Ds.isHotkey = Iy;
Ds.isCodeHotkey = NPe;
Ds.isKeyHotkey = FPe;
Ds.parseHotkey = J8;
Ds.compareHotkey = Q8;
Ds.toKeyCode = e5;
Ds.toKeyName = m1;
var UPe = {
  /**
   * Check if a value is a `History` object.
   */
  isHistory(e) {
    return to(e) && Array.isArray(e.redos) && Array.isArray(e.undos) && (e.redos.length === 0 || pa.isOperationList(e.redos[0].operations)) && (e.undos.length === 0 || pa.isOperationList(e.undos[0].operations));
  }
}, mw = /* @__PURE__ */ new WeakMap(), oc = /* @__PURE__ */ new WeakMap(), pl = {
  /**
   * Check if a value is a `HistoryEditor` object.
   */
  isHistoryEditor(e) {
    return UPe.isHistory(e.history) && Y.isEditor(e);
  },
  /**
   * Get the merge flag's current value.
   */
  isMerging(e) {
    return oc.get(e);
  },
  /**
   * Get the saving flag's current value.
   */
  isSaving(e) {
    return mw.get(e);
  },
  /**
   * Redo to the previous saved state.
   */
  redo(e) {
    e.redo();
  },
  /**
   * Undo to the previous saved state.
   */
  undo(e) {
    e.undo();
  },
  /**
   * Apply a series of changes inside a synchronous `fn`, These operations will
   * be merged into the previous history.
   */
  withMerging(e, t) {
    var n = pl.isMerging(e);
    oc.set(e, !0), t(), oc.set(e, n);
  },
  /**
   * Apply a series of changes inside a synchronous `fn`, without merging any of
   * the new operations into previous save point in the history.
   */
  withoutMerging(e, t) {
    var n = pl.isMerging(e);
    oc.set(e, !1), t(), oc.set(e, n);
  },
  /**
   * Apply a series of changes inside a synchronous `fn`, without saving any of
   * their operations into the history.
   */
  withoutSaving(e, t) {
    var n = pl.isSaving(e);
    mw.set(e, !1), t(), mw.set(e, n);
  }
}, $Pe = (e) => {
  var t = e, {
    apply: n
  } = t;
  return t.history = {
    undos: [],
    redos: []
  }, t.redo = () => {
    var {
      history: r
    } = t, {
      redos: o
    } = r;
    if (o.length > 0) {
      var i = o[o.length - 1];
      i.selectionBefore && Le.setSelection(t, i.selectionBefore), pl.withoutSaving(t, () => {
        Y.withoutNormalizing(t, () => {
          for (var a of i.operations)
            t.apply(a);
        });
      }), r.redos.pop(), t.writeHistory("undos", i);
    }
  }, t.undo = () => {
    var {
      history: r
    } = t, {
      undos: o
    } = r;
    if (o.length > 0) {
      var i = o[o.length - 1];
      pl.withoutSaving(t, () => {
        Y.withoutNormalizing(t, () => {
          var a = i.operations.map(pa.inverse).reverse();
          for (var s of a)
            t.apply(s);
          i.selectionBefore && Le.setSelection(t, i.selectionBefore);
        });
      }), t.writeHistory("redos", i), r.undos.pop();
    }
  }, t.apply = (r) => {
    var {
      operations: o,
      history: i
    } = t, {
      undos: a
    } = i, s = a[a.length - 1], l = s && s.operations[s.operations.length - 1], u = pl.isSaving(t), c = pl.isMerging(t);
    if (u == null && (u = WPe(r)), u) {
      if (c == null && (s == null ? c = !1 : o.length !== 0 ? c = !0 : c = HPe(r, l)), s && c)
        s.operations.push(r);
      else {
        var p = {
          operations: [r],
          selectionBefore: t.selection
        };
        t.writeHistory("undos", p);
      }
      for (; a.length > 100; )
        a.shift();
      i.redos = [];
    }
    n(r);
  }, t.writeHistory = (r, o) => {
    t.history[r].push(o);
  }, t;
}, HPe = (e, t) => !!(t && e.type === "insert_text" && t.type === "insert_text" && e.offset === t.offset + t.text.length && se.equals(e.path, t.path) || t && e.type === "remove_text" && t.type === "remove_text" && e.offset + e.text.length === t.offset && se.equals(e.path, t.path)), WPe = (e, t) => e.type !== "set_selection", VPe = GPe, t5 = "---", n5 = "A-Za-z--------", qPe = new RegExp("^[^" + n5 + "]*[" + t5 + "]"), ZPe = new RegExp("^[^" + t5 + "]*[" + n5 + "]");
function GPe(e) {
  return e = String(e || ""), qPe.test(e) ? "rtl" : ZPe.test(e) ? "ltr" : "neutral";
}
const r5 = /* @__PURE__ */ Dm(VPe);
function XPe(e) {
  var t = typeof e;
  return e != null && (t == "object" || t == "function");
}
var v1 = XPe, KPe = typeof Nn == "object" && Nn && Nn.Object === Object && Nn, YPe = KPe, JPe = YPe, QPe = typeof self == "object" && self && self.Object === Object && self, eSe = JPe || QPe || Function("return this")(), o5 = eSe, tSe = o5, nSe = function() {
  return tSe.Date.now();
}, rSe = nSe, oSe = /\s/;
function iSe(e) {
  for (var t = e.length; t-- && oSe.test(e.charAt(t)); )
    ;
  return t;
}
var sSe = iSe, aSe = sSe, lSe = /^\s+/;
function uSe(e) {
  return e && e.slice(0, aSe(e) + 1).replace(lSe, "");
}
var cSe = uSe, pSe = o5, dSe = pSe.Symbol, i5 = dSe, m2 = i5, s5 = Object.prototype, fSe = s5.hasOwnProperty, hSe = s5.toString, ic = m2 ? m2.toStringTag : void 0;
function gSe(e) {
  var t = fSe.call(e, ic), n = e[ic];
  try {
    e[ic] = void 0;
    var r = !0;
  } catch {
  }
  var o = hSe.call(e);
  return r && (t ? e[ic] = n : delete e[ic]), o;
}
var mSe = gSe, vSe = Object.prototype, ySe = vSe.toString;
function bSe(e) {
  return ySe.call(e);
}
var wSe = bSe, v2 = i5, CSe = mSe, xSe = wSe, OSe = "[object Null]", ESe = "[object Undefined]", y2 = v2 ? v2.toStringTag : void 0;
function kSe(e) {
  return e == null ? e === void 0 ? ESe : OSe : y2 && y2 in Object(e) ? CSe(e) : xSe(e);
}
var LSe = kSe;
function _Se(e) {
  return e != null && typeof e == "object";
}
var PSe = _Se, SSe = LSe, MSe = PSe, DSe = "[object Symbol]";
function TSe(e) {
  return typeof e == "symbol" || MSe(e) && SSe(e) == DSe;
}
var jSe = TSe, ASe = cSe, b2 = v1, BSe = jSe, w2 = NaN, ISe = /^[-+]0x[0-9a-f]+$/i, RSe = /^0b[01]+$/i, NSe = /^0o[0-7]+$/i, FSe = parseInt;
function zSe(e) {
  if (typeof e == "number")
    return e;
  if (BSe(e))
    return w2;
  if (b2(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = b2(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = ASe(e);
  var n = RSe.test(e);
  return n || NSe.test(e) ? FSe(e.slice(2), n ? 2 : 8) : ISe.test(e) ? w2 : +e;
}
var USe = zSe, $Se = v1, vw = rSe, C2 = USe, HSe = "Expected a function", WSe = Math.max, VSe = Math.min;
function qSe(e, t, n) {
  var r, o, i, a, s, l, u = 0, c = !1, p = !1, d = !0;
  if (typeof e != "function")
    throw new TypeError(HSe);
  t = C2(t) || 0, $Se(n) && (c = !!n.leading, p = "maxWait" in n, i = p ? WSe(C2(n.maxWait) || 0, t) : i, d = "trailing" in n ? !!n.trailing : d);
  function h(C) {
    var P = r, F = o;
    return r = o = void 0, u = C, a = e.apply(F, P), a;
  }
  function f(C) {
    return u = C, s = setTimeout(E, t), c ? h(C) : a;
  }
  function m(C) {
    var P = C - l, F = C - u, L = t - P;
    return p ? VSe(L, i - F) : L;
  }
  function g(C) {
    var P = C - l, F = C - u;
    return l === void 0 || P >= t || P < 0 || p && F >= i;
  }
  function E() {
    var C = vw();
    if (g(C))
      return w(C);
    s = setTimeout(E, m(C));
  }
  function w(C) {
    return s = void 0, d && r ? h(C) : (r = o = void 0, a);
  }
  function M() {
    s !== void 0 && clearTimeout(s), u = 0, r = l = o = s = void 0;
  }
  function x() {
    return s === void 0 ? a : w(vw());
  }
  function y() {
    var C = vw(), P = g(C);
    if (r = arguments, o = this, l = C, P) {
      if (s === void 0)
        return f(l);
      if (p)
        return clearTimeout(s), s = setTimeout(E, t), h(l);
    }
    return s === void 0 && (s = setTimeout(E, t)), a;
  }
  return y.cancel = M, y.flush = x, y;
}
var a5 = qSe;
const ZSe = /* @__PURE__ */ Dm(a5);
var GSe = a5, XSe = v1, KSe = "Expected a function";
function YSe(e, t, n) {
  var r = !0, o = !0;
  if (typeof e != "function")
    throw new TypeError(KSe);
  return XSe(n) && (r = "leading" in n ? !!n.leading : r, o = "trailing" in n ? !!n.trailing : o), GSe(e, t, {
    leading: r,
    maxWait: t,
    trailing: o
  });
}
var JSe = YSe;
const QSe = /* @__PURE__ */ Dm(JSe), x2 = (e) => typeof e == "object" && e != null && e.nodeType === 1, O2 = (e, t) => (!t || e !== "hidden") && e !== "visible" && e !== "clip", ch = (e, t) => {
  if (e.clientHeight < e.scrollHeight || e.clientWidth < e.scrollWidth) {
    const n = getComputedStyle(e, null);
    return O2(n.overflowY, t) || O2(n.overflowX, t) || ((r) => {
      const o = ((i) => {
        if (!i.ownerDocument || !i.ownerDocument.defaultView) return null;
        try {
          return i.ownerDocument.defaultView.frameElement;
        } catch {
          return null;
        }
      })(r);
      return !!o && (o.clientHeight < r.scrollHeight || o.clientWidth < r.scrollWidth);
    })(e);
  }
  return !1;
}, ph = (e, t, n, r, o, i, a, s) => i < e && a > t || i > e && a < t ? 0 : i <= e && s <= n || a >= t && s >= n ? i - e - r : a > t && s < n || i < e && s > n ? a - t + o : 0, eMe = (e) => {
  const t = e.parentElement;
  return t ?? (e.getRootNode().host || null);
}, E2 = (e, t) => {
  var n, r, o, i;
  if (typeof document > "u") return [];
  const { scrollMode: a, block: s, inline: l, boundary: u, skipOverflowHiddenElements: c } = t, p = typeof u == "function" ? u : (K) => K !== u;
  if (!x2(e)) throw new TypeError("Invalid target");
  const d = document.scrollingElement || document.documentElement, h = [];
  let f = e;
  for (; x2(f) && p(f); ) {
    if (f = eMe(f), f === d) {
      h.push(f);
      break;
    }
    f != null && f === document.body && ch(f) && !ch(document.documentElement) || f != null && ch(f, c) && h.push(f);
  }
  const m = (r = (n = window.visualViewport) == null ? void 0 : n.width) != null ? r : innerWidth, g = (i = (o = window.visualViewport) == null ? void 0 : o.height) != null ? i : innerHeight, { scrollX: E, scrollY: w } = window, { height: M, width: x, top: y, right: C, bottom: P, left: F } = e.getBoundingClientRect(), { top: L, right: N, bottom: I, left: H } = ((K) => {
    const J = window.getComputedStyle(K);
    return { top: parseFloat(J.scrollMarginTop) || 0, right: parseFloat(J.scrollMarginRight) || 0, bottom: parseFloat(J.scrollMarginBottom) || 0, left: parseFloat(J.scrollMarginLeft) || 0 };
  })(e);
  let V = s === "start" || s === "nearest" ? y - L : s === "end" ? P + I : y + M / 2 - L + I, z = l === "center" ? F + x / 2 - H + N : l === "end" ? C + N : F - H;
  const q = [];
  for (let K = 0; K < h.length; K++) {
    const J = h[K], { height: te, width: ee, top: _, right: D, bottom: $, left: S } = J.getBoundingClientRect();
    if (a === "if-needed" && y >= 0 && F >= 0 && P <= g && C <= m && (J === d && !ch(J) || y >= _ && P <= $ && F >= S && C <= D)) return q;
    const W = getComputedStyle(J), O = parseInt(W.borderLeftWidth, 10), T = parseInt(W.borderTopWidth, 10), U = parseInt(W.borderRightWidth, 10), j = parseInt(W.borderBottomWidth, 10);
    let Z = 0, A = 0;
    const Q = "offsetWidth" in J ? J.offsetWidth - J.clientWidth - O - U : 0, R = "offsetHeight" in J ? J.offsetHeight - J.clientHeight - T - j : 0, ue = "offsetWidth" in J ? J.offsetWidth === 0 ? 0 : ee / J.offsetWidth : 0, fe = "offsetHeight" in J ? J.offsetHeight === 0 ? 0 : te / J.offsetHeight : 0;
    if (d === J) Z = s === "start" ? V : s === "end" ? V - g : s === "nearest" ? ph(w, w + g, g, T, j, w + V, w + V + M, M) : V - g / 2, A = l === "start" ? z : l === "center" ? z - m / 2 : l === "end" ? z - m : ph(E, E + m, m, O, U, E + z, E + z + x, x), Z = Math.max(0, Z + w), A = Math.max(0, A + E);
    else {
      Z = s === "start" ? V - _ - T : s === "end" ? V - $ + j + R : s === "nearest" ? ph(_, $, te, T, j + R, V, V + M, M) : V - (_ + te / 2) + R / 2, A = l === "start" ? z - S - O : l === "center" ? z - (S + ee / 2) + Q / 2 : l === "end" ? z - D + U + Q : ph(S, D, ee, O, U + Q, z, z + x, x);
      const { scrollLeft: oe, scrollTop: Re } = J;
      Z = fe === 0 ? 0 : Math.max(0, Math.min(Re + Z / fe, J.scrollHeight - te / fe + R)), A = ue === 0 ? 0 : Math.max(0, Math.min(oe + A / ue, J.scrollWidth - ee / ue + Q)), V += Re - Z, z += oe - A;
    }
    q.push({ el: J, top: Z, left: A });
  }
  return q;
}, tMe = (e) => e === !1 ? { block: "end", inline: "nearest" } : ((t) => t === Object(t) && Object.keys(t).length !== 0)(e) ? e : { block: "start", inline: "nearest" };
function nMe(e, t) {
  if (!e.isConnected || !((o) => {
    let i = o;
    for (; i && i.parentNode; ) {
      if (i.parentNode === document) return !0;
      i = i.parentNode instanceof ShadowRoot ? i.parentNode.host : i.parentNode;
    }
    return !1;
  })(e)) return;
  const n = ((o) => {
    const i = window.getComputedStyle(o);
    return { top: parseFloat(i.scrollMarginTop) || 0, right: parseFloat(i.scrollMarginRight) || 0, bottom: parseFloat(i.scrollMarginBottom) || 0, left: parseFloat(i.scrollMarginLeft) || 0 };
  })(e);
  if (((o) => typeof o == "object" && typeof o.behavior == "function")(t)) return t.behavior(E2(e, t));
  const r = typeof t == "boolean" || t == null ? void 0 : t.behavior;
  for (const { el: o, top: i, left: a } of E2(e, tMe(t))) {
    const s = i - n.top + n.bottom, l = a - n.left + n.right;
    o.scroll({ top: s, left: l, behavior: r });
  }
}
var gl = [], rMe = function() {
  return gl.some(function(e) {
    return e.activeTargets.length > 0;
  });
}, oMe = function() {
  return gl.some(function(e) {
    return e.skippedTargets.length > 0;
  });
}, k2 = "ResizeObserver loop completed with undelivered notifications.", iMe = function() {
  var e;
  typeof ErrorEvent == "function" ? e = new ErrorEvent("error", {
    message: k2
  }) : (e = document.createEvent("Event"), e.initEvent("error", !1, !1), e.message = k2), window.dispatchEvent(e);
}, Bp;
(function(e) {
  e.BORDER_BOX = "border-box", e.CONTENT_BOX = "content-box", e.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(Bp || (Bp = {}));
var ml = function(e) {
  return Object.freeze(e);
}, sMe = /* @__PURE__ */ function() {
  function e(t, n) {
    this.inlineSize = t, this.blockSize = n, ml(this);
  }
  return e;
}(), l5 = function() {
  function e(t, n, r, o) {
    return this.x = t, this.y = n, this.width = r, this.height = o, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, ml(this);
  }
  return e.prototype.toJSON = function() {
    var t = this, n = t.x, r = t.y, o = t.top, i = t.right, a = t.bottom, s = t.left, l = t.width, u = t.height;
    return { x: n, y: r, top: o, right: i, bottom: a, left: s, width: l, height: u };
  }, e.fromRect = function(t) {
    return new e(t.x, t.y, t.width, t.height);
  }, e;
}(), y1 = function(e) {
  return e instanceof SVGElement && "getBBox" in e;
}, u5 = function(e) {
  if (y1(e)) {
    var t = e.getBBox(), n = t.width, r = t.height;
    return !n && !r;
  }
  var o = e, i = o.offsetWidth, a = o.offsetHeight;
  return !(i || a || e.getClientRects().length);
}, L2 = function(e) {
  var t;
  if (e instanceof Element)
    return !0;
  var n = (t = e == null ? void 0 : e.ownerDocument) === null || t === void 0 ? void 0 : t.defaultView;
  return !!(n && e instanceof n.Element);
}, aMe = function(e) {
  switch (e.tagName) {
    case "INPUT":
      if (e.type !== "image")
        break;
    case "VIDEO":
    case "AUDIO":
    case "EMBED":
    case "OBJECT":
    case "CANVAS":
    case "IFRAME":
    case "IMG":
      return !0;
  }
  return !1;
}, Hc = typeof window < "u" ? window : {}, dh = /* @__PURE__ */ new WeakMap(), _2 = /auto|scroll/, lMe = /^tb|vertical/, uMe = /msie|trident/i.test(Hc.navigator && Hc.navigator.userAgent), Bi = function(e) {
  return parseFloat(e || "0");
}, eu = function(e, t, n) {
  return e === void 0 && (e = 0), t === void 0 && (t = 0), n === void 0 && (n = !1), new sMe((n ? t : e) || 0, (n ? e : t) || 0);
}, P2 = ml({
  devicePixelContentBoxSize: eu(),
  borderBoxSize: eu(),
  contentBoxSize: eu(),
  contentRect: new l5(0, 0, 0, 0)
}), c5 = function(e, t) {
  if (t === void 0 && (t = !1), dh.has(e) && !t)
    return dh.get(e);
  if (u5(e))
    return dh.set(e, P2), P2;
  var n = getComputedStyle(e), r = y1(e) && e.ownerSVGElement && e.getBBox(), o = !uMe && n.boxSizing === "border-box", i = lMe.test(n.writingMode || ""), a = !r && _2.test(n.overflowY || ""), s = !r && _2.test(n.overflowX || ""), l = r ? 0 : Bi(n.paddingTop), u = r ? 0 : Bi(n.paddingRight), c = r ? 0 : Bi(n.paddingBottom), p = r ? 0 : Bi(n.paddingLeft), d = r ? 0 : Bi(n.borderTopWidth), h = r ? 0 : Bi(n.borderRightWidth), f = r ? 0 : Bi(n.borderBottomWidth), m = r ? 0 : Bi(n.borderLeftWidth), g = p + u, E = l + c, w = m + h, M = d + f, x = s ? e.offsetHeight - M - e.clientHeight : 0, y = a ? e.offsetWidth - w - e.clientWidth : 0, C = o ? g + w : 0, P = o ? E + M : 0, F = r ? r.width : Bi(n.width) - C - y, L = r ? r.height : Bi(n.height) - P - x, N = F + g + y + w, I = L + E + x + M, H = ml({
    devicePixelContentBoxSize: eu(Math.round(F * devicePixelRatio), Math.round(L * devicePixelRatio), i),
    borderBoxSize: eu(N, I, i),
    contentBoxSize: eu(F, L, i),
    contentRect: new l5(p, l, F, L)
  });
  return dh.set(e, H), H;
}, p5 = function(e, t, n) {
  var r = c5(e, n), o = r.borderBoxSize, i = r.contentBoxSize, a = r.devicePixelContentBoxSize;
  switch (t) {
    case Bp.DEVICE_PIXEL_CONTENT_BOX:
      return a;
    case Bp.BORDER_BOX:
      return o;
    default:
      return i;
  }
}, cMe = /* @__PURE__ */ function() {
  function e(t) {
    var n = c5(t);
    this.target = t, this.contentRect = n.contentRect, this.borderBoxSize = ml([n.borderBoxSize]), this.contentBoxSize = ml([n.contentBoxSize]), this.devicePixelContentBoxSize = ml([n.devicePixelContentBoxSize]);
  }
  return e;
}(), d5 = function(e) {
  if (u5(e))
    return 1 / 0;
  for (var t = 0, n = e.parentNode; n; )
    t += 1, n = n.parentNode;
  return t;
}, pMe = function() {
  var e = 1 / 0, t = [];
  gl.forEach(function(a) {
    if (a.activeTargets.length !== 0) {
      var s = [];
      a.activeTargets.forEach(function(u) {
        var c = new cMe(u.target), p = d5(u.target);
        s.push(c), u.lastReportedSize = p5(u.target, u.observedBox), p < e && (e = p);
      }), t.push(function() {
        a.callback.call(a.observer, s, a.observer);
      }), a.activeTargets.splice(0, a.activeTargets.length);
    }
  });
  for (var n = 0, r = t; n < r.length; n++) {
    var o = r[n];
    o();
  }
  return e;
}, S2 = function(e) {
  gl.forEach(function(n) {
    n.activeTargets.splice(0, n.activeTargets.length), n.skippedTargets.splice(0, n.skippedTargets.length), n.observationTargets.forEach(function(o) {
      o.isActive() && (d5(o.target) > e ? n.activeTargets.push(o) : n.skippedTargets.push(o));
    });
  });
}, dMe = function() {
  var e = 0;
  for (S2(e); rMe(); )
    e = pMe(), S2(e);
  return oMe() && iMe(), e > 0;
}, yw, f5 = [], fMe = function() {
  return f5.splice(0).forEach(function(e) {
    return e();
  });
}, hMe = function(e) {
  if (!yw) {
    var t = 0, n = document.createTextNode(""), r = { characterData: !0 };
    new MutationObserver(function() {
      return fMe();
    }).observe(n, r), yw = function() {
      n.textContent = "".concat(t ? t-- : t++);
    };
  }
  f5.push(e), yw();
}, gMe = function(e) {
  hMe(function() {
    requestAnimationFrame(e);
  });
}, jh = 0, mMe = function() {
  return !!jh;
}, vMe = 250, yMe = { attributes: !0, characterData: !0, childList: !0, subtree: !0 }, M2 = [
  "resize",
  "load",
  "transitionend",
  "animationend",
  "animationstart",
  "animationiteration",
  "keyup",
  "keydown",
  "mouseup",
  "mousedown",
  "mouseover",
  "mouseout",
  "blur",
  "focus"
], D2 = function(e) {
  return e === void 0 && (e = 0), Date.now() + e;
}, bw = !1, bMe = function() {
  function e() {
    var t = this;
    this.stopped = !0, this.listener = function() {
      return t.schedule();
    };
  }
  return e.prototype.run = function(t) {
    var n = this;
    if (t === void 0 && (t = vMe), !bw) {
      bw = !0;
      var r = D2(t);
      gMe(function() {
        var o = !1;
        try {
          o = dMe();
        } finally {
          if (bw = !1, t = r - D2(), !mMe())
            return;
          o ? n.run(1e3) : t > 0 ? n.run(t) : n.start();
        }
      });
    }
  }, e.prototype.schedule = function() {
    this.stop(), this.run();
  }, e.prototype.observe = function() {
    var t = this, n = function() {
      return t.observer && t.observer.observe(document.body, yMe);
    };
    document.body ? n() : Hc.addEventListener("DOMContentLoaded", n);
  }, e.prototype.start = function() {
    var t = this;
    this.stopped && (this.stopped = !1, this.observer = new MutationObserver(this.listener), this.observe(), M2.forEach(function(n) {
      return Hc.addEventListener(n, t.listener, !0);
    }));
  }, e.prototype.stop = function() {
    var t = this;
    this.stopped || (this.observer && this.observer.disconnect(), M2.forEach(function(n) {
      return Hc.removeEventListener(n, t.listener, !0);
    }), this.stopped = !0);
  }, e;
}(), Ax = new bMe(), T2 = function(e) {
  !jh && e > 0 && Ax.start(), jh += e, !jh && Ax.stop();
}, wMe = function(e) {
  return !y1(e) && !aMe(e) && getComputedStyle(e).display === "inline";
}, CMe = function() {
  function e(t, n) {
    this.target = t, this.observedBox = n || Bp.CONTENT_BOX, this.lastReportedSize = {
      inlineSize: 0,
      blockSize: 0
    };
  }
  return e.prototype.isActive = function() {
    var t = p5(this.target, this.observedBox, !0);
    return wMe(this.target) && (this.lastReportedSize = t), this.lastReportedSize.inlineSize !== t.inlineSize || this.lastReportedSize.blockSize !== t.blockSize;
  }, e;
}(), xMe = /* @__PURE__ */ function() {
  function e(t, n) {
    this.activeTargets = [], this.skippedTargets = [], this.observationTargets = [], this.observer = t, this.callback = n;
  }
  return e;
}(), fh = /* @__PURE__ */ new WeakMap(), j2 = function(e, t) {
  for (var n = 0; n < e.length; n += 1)
    if (e[n].target === t)
      return n;
  return -1;
}, hh = function() {
  function e() {
  }
  return e.connect = function(t, n) {
    var r = new xMe(t, n);
    fh.set(t, r);
  }, e.observe = function(t, n, r) {
    var o = fh.get(t), i = o.observationTargets.length === 0;
    j2(o.observationTargets, n) < 0 && (i && gl.push(o), o.observationTargets.push(new CMe(n, r && r.box)), T2(1), Ax.schedule());
  }, e.unobserve = function(t, n) {
    var r = fh.get(t), o = j2(r.observationTargets, n), i = r.observationTargets.length === 1;
    o >= 0 && (i && gl.splice(gl.indexOf(r), 1), r.observationTargets.splice(o, 1), T2(-1));
  }, e.disconnect = function(t) {
    var n = this, r = fh.get(t);
    r.observationTargets.slice().forEach(function(o) {
      return n.unobserve(t, o.target);
    }), r.activeTargets.splice(0, r.activeTargets.length);
  }, e;
}(), OMe = function() {
  function e(t) {
    if (arguments.length === 0)
      throw new TypeError("Failed to construct 'ResizeObserver': 1 argument required, but only 0 present.");
    if (typeof t != "function")
      throw new TypeError("Failed to construct 'ResizeObserver': The callback provided as parameter 1 is not a function.");
    hh.connect(this, t);
  }
  return e.prototype.observe = function(t, n) {
    if (arguments.length === 0)
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': 1 argument required, but only 0 present.");
    if (!L2(t))
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': parameter 1 is not of type 'Element");
    hh.observe(this, t, n);
  }, e.prototype.unobserve = function(t) {
    if (arguments.length === 0)
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': 1 argument required, but only 0 present.");
    if (!L2(t))
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': parameter 1 is not of type 'Element");
    hh.unobserve(this, t);
  }, e.prototype.disconnect = function() {
    hh.disconnect(this);
  }, e.toString = function() {
    return "function ResizeObserver () { [polyfill code] }";
  }, e;
}();
function EMe(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), o, i;
  for (i = 0; i < r.length; i++)
    o = r[i], !(t.indexOf(o) >= 0) && (n[o] = e[o]);
  return n;
}
function uu(e, t) {
  if (e == null) return {};
  var n = EMe(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (o = 0; o < i.length; o++)
      r = i[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
function Ip(e) {
  "@babel/helpers - typeof";
  return Ip = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Ip(e);
}
function kMe(e, t) {
  if (Ip(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (Ip(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function LMe(e) {
  var t = kMe(e, "string");
  return Ip(t) === "symbol" ? t : String(t);
}
function yi(e, t, n) {
  return t = LMe(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
var b1 = /* @__PURE__ */ Ze(null), Ta = () => {
  var e = ye(b1);
  if (!e)
    throw new Error("The `useSlateStatic` hook must be used inside the <Slate> component's context.");
  return e;
}, ww, Cw, h5 = parseInt(ke.version.split(".")[0], 10), g5 = typeof navigator < "u" && typeof window < "u" && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream, A2 = typeof navigator < "u" && /Mac OS X/.test(navigator.userAgent), wo = typeof navigator < "u" && /Android/.test(navigator.userAgent), Gl = typeof navigator < "u" && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent), Qa = typeof navigator < "u" && /AppleWebKit(?!.*Chrome)/i.test(navigator.userAgent), _Me = typeof navigator < "u" && /Edge?\/(?:[0-6][0-9]|[0-7][0-8])(?:\.)/i.test(navigator.userAgent), m5 = typeof navigator < "u" && /Chrome/i.test(navigator.userAgent), PMe = typeof navigator < "u" && /Chrome?\/(?:[0-7][0-5]|[0-6][0-9])(?:\.)/i.test(navigator.userAgent), SMe = wo && typeof navigator < "u" && /Chrome?\/(?:[0-5]?\d)(?:\.)/i.test(navigator.userAgent), MMe = typeof navigator < "u" && /^(?!.*Seamonkey)(?=.*Firefox\/(?:[0-7][0-9]|[0-8][0-6])(?:\.)).*/i.test(navigator.userAgent), DMe = typeof navigator < "u" && /.*UCBrowser/.test(navigator.userAgent), TMe = typeof navigator < "u" && /.*Wechat/.test(navigator.userAgent) && !/.*MacWechat/.test(navigator.userAgent), Ah = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u";
typeof navigator < "u" && /Safari/.test(navigator.userAgent) && /Version\/(\d+)/.test(navigator.userAgent) && ((ww = navigator.userAgent.match(/Version\/(\d+)/)) !== null && ww !== void 0 && ww[1] && parseInt((Cw = navigator.userAgent.match(/Version\/(\d+)/)) === null || Cw === void 0 ? void 0 : Cw[1], 10) < 17);
var $s = (!PMe || !SMe) && !_Me && // globalThis is undefined in older browsers
typeof globalThis < "u" && globalThis.InputEvent && // @ts-ignore The `getTargetRanges` property isn't recognized.
typeof globalThis.InputEvent.prototype.getTargetRanges == "function", tu = /* @__PURE__ */ new WeakMap(), w1 = /* @__PURE__ */ new WeakMap(), C1 = /* @__PURE__ */ new WeakMap(), v5 = /* @__PURE__ */ new WeakMap(), Bh = /* @__PURE__ */ new WeakMap(), Bx = /* @__PURE__ */ new WeakMap(), Rp = /* @__PURE__ */ new WeakMap(), vl = /* @__PURE__ */ new WeakMap(), ym = /* @__PURE__ */ new WeakMap(), Ry = /* @__PURE__ */ new WeakMap(), Ix = /* @__PURE__ */ new WeakMap(), da = /* @__PURE__ */ new WeakMap(), dl = /* @__PURE__ */ new WeakMap(), Wc = /* @__PURE__ */ new WeakMap(), Rx = /* @__PURE__ */ new WeakMap(), x1 = /* @__PURE__ */ new WeakMap(), Pi = /* @__PURE__ */ new WeakMap(), ys = /* @__PURE__ */ new WeakMap(), So = /* @__PURE__ */ new WeakMap(), na = /* @__PURE__ */ new WeakMap(), ra = /* @__PURE__ */ new WeakMap(), y5 = /* @__PURE__ */ new WeakMap(), cu = Symbol("placeholder"), b5 = Symbol("mark-placeholder"), w5 = globalThis.Node, jMe = globalThis.Text, O1 = (e) => e && e.ownerDocument && e.ownerDocument.defaultView || null, AMe = (e) => ha(e) && e.nodeType === 8, vi = (e) => ha(e) && e.nodeType === 1, ha = (e) => {
  var t = O1(e);
  return !!t && e instanceof t.Node;
}, Nx = (e) => {
  var t = e && e.anchorNode && O1(e.anchorNode);
  return !!t && e instanceof t.Selection;
}, C5 = (e) => ha(e) && e.nodeType === 3, BMe = (e) => e.clipboardData && e.clipboardData.getData("text/plain") !== "" && e.clipboardData.types.length === 1, IMe = (e) => {
  var [t, n] = e;
  if (vi(t) && t.childNodes.length) {
    var r = n === t.childNodes.length, o = r ? n - 1 : n;
    for ([t, o] = x5(t, o, r ? "backward" : "forward"), r = o < n; vi(t) && t.childNodes.length; ) {
      var i = r ? t.childNodes.length - 1 : 0;
      t = NMe(t, i, r ? "backward" : "forward");
    }
    n = r && t.textContent != null ? t.textContent.length : 0;
  }
  return [t, n];
}, RMe = (e) => {
  for (var t = e && e.parentNode; t; ) {
    if (t.toString() === "[object ShadowRoot]")
      return !0;
    t = t.parentNode;
  }
  return !1;
}, x5 = (e, t, n) => {
  for (var {
    childNodes: r
  } = e, o = r[t], i = t, a = !1, s = !1; (AMe(o) || vi(o) && o.childNodes.length === 0 || vi(o) && o.getAttribute("contenteditable") === "false") && !(a && s); ) {
    if (i >= r.length) {
      a = !0, i = t - 1, n = "backward";
      continue;
    }
    if (i < 0) {
      s = !0, i = t + 1, n = "forward";
      continue;
    }
    o = r[i], t = i, i += n === "forward" ? 1 : -1;
  }
  return [o, t];
}, NMe = (e, t, n) => {
  var [r] = x5(e, t, n);
  return r;
}, O5 = (e) => {
  var t = "";
  if (C5(e) && e.nodeValue)
    return e.nodeValue;
  if (vi(e)) {
    for (var n of Array.from(e.childNodes))
      t += O5(n);
    var r = getComputedStyle(e).getPropertyValue("display");
    (r === "block" || r === "list" || e.tagName === "BR") && (t += `
`);
  }
  return t;
}, FMe = /data-slate-fragment="(.+?)"/m, zMe = (e) => {
  var t = e.getData("text/html"), [, n] = t.match(FMe) || [];
  return n;
}, Vc = (e) => e.getSelection != null ? e.getSelection() : document.getSelection(), E1 = (e, t, n) => {
  var {
    target: r
  } = t;
  if (vi(r) && r.matches('[contentEditable="false"]'))
    return !1;
  var {
    document: o
  } = ve.getWindow(e);
  if (o.contains(r))
    return ve.hasDOMNode(e, r, {
      editable: !0
    });
  var i = n.find((a) => {
    var {
      addedNodes: s,
      removedNodes: l
    } = a;
    for (var u of s)
      if (u === r || u.contains(r))
        return !0;
    for (var c of l)
      if (c === r || c.contains(r))
        return !0;
  });
  return !i || i === t ? !1 : E1(e, i, n);
}, UMe = () => {
  for (var e = document.activeElement; (t = e) !== null && t !== void 0 && t.shadowRoot && (n = e.shadowRoot) !== null && n !== void 0 && n.activeElement; ) {
    var t, n, r;
    e = (r = e) === null || r === void 0 || (r = r.shadowRoot) === null || r === void 0 ? void 0 : r.activeElement;
  }
  return e;
}, B2 = (e, t) => !!(e.compareDocumentPosition(t) & w5.DOCUMENT_POSITION_PRECEDING), $Me = (e, t) => !!(e.compareDocumentPosition(t) & w5.DOCUMENT_POSITION_FOLLOWING), HMe = 0;
class WMe {
  constructor() {
    yi(this, "id", void 0), this.id = "".concat(HMe++);
  }
}
var ve = {
  androidPendingDiffs: (e) => So.get(e),
  androidScheduleFlush: (e) => {
    var t;
    (t = x1.get(e)) === null || t === void 0 || t();
  },
  blur: (e) => {
    var t = ve.toDOMNode(e, e), n = ve.findDocumentOrShadowRoot(e);
    da.set(e, !1), n.activeElement === t && t.blur();
  },
  deselect: (e) => {
    var {
      selection: t
    } = e, n = ve.findDocumentOrShadowRoot(e), r = Vc(n);
    r && r.rangeCount > 0 && r.removeAllRanges(), t && Le.deselect(e);
  },
  findDocumentOrShadowRoot: (e) => {
    var t = ve.toDOMNode(e, e), n = t.getRootNode();
    return n instanceof Document || n instanceof ShadowRoot ? n : t.ownerDocument;
  },
  findEventRange: (e, t) => {
    "nativeEvent" in t && (t = t.nativeEvent);
    var {
      clientX: n,
      clientY: r,
      target: o
    } = t;
    if (n == null || r == null)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var i = ve.toSlateNode(e, t.target), a = ve.findPath(e, i);
    if (Je.isElement(i) && Y.isVoid(e, i)) {
      var s = o.getBoundingClientRect(), l = e.isInline(i) ? n - s.left < s.left + s.width - n : r - s.top < s.top + s.height - r, u = Y.point(e, a, {
        edge: l ? "start" : "end"
      }), c = l ? Y.before(e, u) : Y.after(e, u);
      if (c) {
        var p = Y.range(e, c);
        return p;
      }
    }
    var d, {
      document: h
    } = ve.getWindow(e);
    if (h.caretRangeFromPoint)
      d = h.caretRangeFromPoint(n, r);
    else {
      var f = h.caretPositionFromPoint(n, r);
      f && (d = h.createRange(), d.setStart(f.offsetNode, f.offset), d.setEnd(f.offsetNode, f.offset));
    }
    if (!d)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var m = ve.toSlateRange(e, d, {
      exactMatch: !1,
      suppressThrow: !1
    });
    return m;
  },
  findKey: (e, t) => {
    var n = ym.get(t);
    return n || (n = new WMe(), ym.set(t, n)), n;
  },
  findPath: (e, t) => {
    for (var n = [], r = t; ; ) {
      var o = C1.get(r);
      if (o == null) {
        if (Y.isEditor(r))
          return n;
        break;
      }
      var i = w1.get(r);
      if (i == null)
        break;
      n.unshift(i), r = o;
    }
    throw new Error("Unable to find the path for Slate node: ".concat(Jr.stringify(t)));
  },
  focus: function(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      retries: 5
    };
    if (!da.get(t)) {
      if (n.retries <= 0)
        throw new Error("Could not set focus, editor seems stuck with pending operations");
      if (t.operations.length > 0) {
        setTimeout(() => {
          ve.focus(t, {
            retries: n.retries - 1
          });
        }, 10);
        return;
      }
      var r = ve.toDOMNode(t, t), o = ve.findDocumentOrShadowRoot(t);
      if (o.activeElement !== r) {
        if (t.selection && o instanceof Document) {
          var i = Vc(o), a = ve.toDOMRange(t, t.selection);
          i == null || i.removeAllRanges(), i == null || i.addRange(a);
        }
        t.selection || Le.select(t, Y.start(t, [])), da.set(t, !0), r.focus({
          preventScroll: !0
        });
      }
    }
  },
  getWindow: (e) => {
    var t = v5.get(e);
    if (!t)
      throw new Error("Unable to find a host window element for this editor");
    return t;
  },
  hasDOMNode: function(t, n) {
    var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      editable: o = !1
    } = r, i = ve.toDOMNode(t, t), a;
    try {
      a = vi(n) ? n : n.parentElement;
    } catch (s) {
      if (s instanceof Error && !s.message.includes('Permission denied to access property "nodeType"'))
        throw s;
    }
    return a ? a.closest("[data-slate-editor]") === i && (!o || a.isContentEditable ? !0 : typeof a.isContentEditable == "boolean" && // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined
    // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable="false"(readOnly)
    a.closest('[contenteditable="false"]') === i || !!a.getAttribute("data-slate-zero-width")) : !1;
  },
  hasEditableTarget: (e, t) => ha(t) && ve.hasDOMNode(e, t, {
    editable: !0
  }),
  hasRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t;
    return Y.hasPath(e, n.path) && Y.hasPath(e, r.path);
  },
  hasSelectableTarget: (e, t) => ve.hasEditableTarget(e, t) || ve.isTargetInsideNonReadonlyVoid(e, t),
  hasTarget: (e, t) => ha(t) && ve.hasDOMNode(e, t),
  insertData: (e, t) => {
    e.insertData(t);
  },
  insertFragmentData: (e, t) => e.insertFragmentData(t),
  insertTextData: (e, t) => e.insertTextData(t),
  isComposing: (e) => !!dl.get(e),
  isFocused: (e) => !!da.get(e),
  isReadOnly: (e) => !!Ix.get(e),
  isTargetInsideNonReadonlyVoid: (e, t) => {
    if (Ix.get(e)) return !1;
    var n = ve.hasTarget(e, t) && ve.toSlateNode(e, t);
    return Je.isElement(n) && Y.isVoid(e, n);
  },
  setFragmentData: (e, t, n) => e.setFragmentData(t, n),
  toDOMNode: (e, t) => {
    var n = Ry.get(e), r = Y.isEditor(t) ? Bh.get(e) : n == null ? void 0 : n.get(ve.findKey(e, t));
    if (!r)
      throw new Error("Cannot resolve a DOM node from Slate node: ".concat(Jr.stringify(t)));
    return r;
  },
  toDOMPoint: (e, t) => {
    var [n] = Y.node(e, t.path), r = ve.toDOMNode(e, n), o;
    Y.void(e, {
      at: t
    }) && (t = {
      path: t.path,
      offset: 0
    });
    for (var i = "[data-slate-string], [data-slate-zero-width]", a = Array.from(r.querySelectorAll(i)), s = 0, l = 0; l < a.length; l++) {
      var u = a[l], c = u.childNodes[0];
      if (!(c == null || c.textContent == null)) {
        var {
          length: p
        } = c.textContent, d = u.getAttribute("data-slate-length"), h = d == null ? p : parseInt(d, 10), f = s + h, m = a[l + 1];
        if (t.offset === f && m !== null && m !== void 0 && m.hasAttribute("data-slate-mark-placeholder")) {
          var g, E = m.childNodes[0];
          o = [
            // COMPAT: If we don't explicity set the dom point to be on the actual
            // dom text element, chrome will put the selection behind the actual dom
            // text element, causing domRange.getBoundingClientRect() calls on a collapsed
            // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)
            // which will cause issues when scrolling to it.
            E instanceof jMe ? E : m,
            (g = m.textContent) !== null && g !== void 0 && g.startsWith("\uFEFF") ? 1 : 0
          ];
          break;
        }
        if (t.offset <= f) {
          var w = Math.min(p, Math.max(0, t.offset - s));
          o = [c, w];
          break;
        }
        s = f;
      }
    }
    if (!o)
      throw new Error("Cannot resolve a DOM point from Slate point: ".concat(Jr.stringify(t)));
    return o;
  },
  toDOMRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t, o = de.isBackward(t), i = ve.toDOMPoint(e, n), a = de.isCollapsed(t) ? i : ve.toDOMPoint(e, r), s = ve.getWindow(e), l = s.document.createRange(), [u, c] = o ? a : i, [p, d] = o ? i : a, h = vi(u) ? u : u.parentElement, f = !!h.getAttribute("data-slate-zero-width"), m = vi(p) ? p : p.parentElement, g = !!m.getAttribute("data-slate-zero-width");
    return l.setStart(u, f ? 1 : c), l.setEnd(p, g ? 1 : d), l;
  },
  toSlateNode: (e, t) => {
    var n = vi(t) ? t : t.parentElement;
    n && !n.hasAttribute("data-slate-node") && (n = n.closest("[data-slate-node]"));
    var r = n ? Rp.get(n) : null;
    if (!r)
      throw new Error("Cannot resolve a Slate node from DOM node: ".concat(n));
    return r;
  },
  toSlatePoint: (e, t, n) => {
    var {
      exactMatch: r,
      suppressThrow: o,
      searchDirection: i = "backward"
    } = n, [a, s] = r ? t : IMe(t), l = a.parentNode, u = null, c = 0;
    if (l) {
      var p, d, h = ve.toDOMNode(e, e), f = l.closest('[data-slate-void="true"]'), m = f && h.contains(f) ? f : null, g = l.closest('[contenteditable="false"]'), E = g && h.contains(g) ? g : null, w = l.closest("[data-slate-leaf]"), M = null;
      if (w) {
        if (u = w.closest('[data-slate-node="text"]'), u) {
          var x = ve.getWindow(e), y = x.document.createRange();
          y.setStart(u, 0), y.setEnd(a, s);
          var C = y.cloneContents(), P = [...Array.prototype.slice.call(C.querySelectorAll("[data-slate-zero-width]")), ...Array.prototype.slice.call(C.querySelectorAll("[contenteditable=false]"))];
          P.forEach((S) => {
            if (wo && !r && S.hasAttribute("data-slate-zero-width") && S.textContent.length > 0 && S.textContext !== "\uFEFF") {
              S.textContent.startsWith("\uFEFF") && (S.textContent = S.textContent.slice(1));
              return;
            }
            S.parentNode.removeChild(S);
          }), c = C.textContent.length, M = u;
        }
      } else if (m) {
        for (var F = m.querySelectorAll("[data-slate-leaf]"), L = 0; L < F.length; L++) {
          var N = F[L];
          if (ve.hasDOMNode(e, N)) {
            w = N;
            break;
          }
        }
        w ? (u = w.closest('[data-slate-node="text"]'), M = w, c = M.textContent.length, M.querySelectorAll("[data-slate-zero-width]").forEach((S) => {
          c -= S.textContent.length;
        })) : c = 1;
      } else if (E) {
        var I = (S) => S ? S.querySelectorAll(
          // Exclude leaf nodes in nested editors
          "[data-slate-leaf]:not(:scope [data-slate-editor] [data-slate-leaf])"
        ) : [], H = E.closest('[data-slate-node="element"]');
        if (i === "forward") {
          var V, z = [...I(H), ...I(H == null ? void 0 : H.nextElementSibling)];
          w = (V = z.find((S) => $Me(E, S))) !== null && V !== void 0 ? V : null;
        } else {
          var q, K = [...I(H == null ? void 0 : H.previousElementSibling), ...I(H)];
          w = (q = K.findLast((S) => B2(E, S))) !== null && q !== void 0 ? q : null;
        }
        w && (u = w.closest('[data-slate-node="text"]'), M = w, i === "forward" ? c = 0 : (c = M.textContent.length, M.querySelectorAll("[data-slate-zero-width]").forEach((S) => {
          c -= S.textContent.length;
        })));
      }
      M && c === M.textContent.length && // COMPAT: Android IMEs might remove the zero width space while composing,
      // and we don't add it for line-breaks.
      wo && M.getAttribute("data-slate-zero-width") === "z" && (p = M.textContent) !== null && p !== void 0 && p.startsWith("\uFEFF") && // COMPAT: If the parent node is a Slate zero-width space, editor is
      // because the text node should have no characters. However, during IME
      // composition the ASCII characters will be prepended to the zero-width
      // space, so subtract 1 from the offset to account for the zero-width
      // space character.
      (l.hasAttribute("data-slate-zero-width") || // COMPAT: In Firefox, `range.cloneContents()` returns an extra trailing '\n'
      // when the document ends with a new-line character. This results in the offset
      // length being off by one, so we need to subtract one to account for this.
      Gl && (d = M.textContent) !== null && d !== void 0 && d.endsWith(`

`)) && c--;
    }
    if (wo && !u && !r) {
      var J = l.hasAttribute("data-slate-node") ? l : l.closest("[data-slate-node]");
      if (J && ve.hasDOMNode(e, J, {
        editable: !0
      })) {
        var te = ve.toSlateNode(e, J), {
          path: ee,
          offset: _
        } = Y.start(e, ve.findPath(e, te));
        return J.querySelector("[data-slate-leaf]") || (_ = s), {
          path: ee,
          offset: _
        };
      }
    }
    if (!u) {
      if (o)
        return null;
      throw new Error("Cannot resolve a Slate point from DOM point: ".concat(t));
    }
    var D = ve.toSlateNode(e, u), $ = ve.findPath(e, D);
    return {
      path: $,
      offset: c
    };
  },
  toSlateRange: (e, t, n) => {
    var r, {
      exactMatch: o,
      suppressThrow: i
    } = n, a = Nx(t) ? t.anchorNode : t.startContainer, s, l, u, c, p;
    if (a)
      if (Nx(t)) {
        if (Gl && t.rangeCount > 1) {
          u = t.focusNode;
          var d = t.getRangeAt(0), h = t.getRangeAt(t.rangeCount - 1);
          if (u instanceof HTMLTableRowElement && d.startContainer instanceof HTMLTableRowElement && h.startContainer instanceof HTMLTableRowElement) {
            let C = function(P) {
              return P.childElementCount > 0 ? C(P.children[0]) : P;
            };
            var f = d.startContainer, m = h.startContainer, g = C(f.children[d.startOffset]), E = C(m.children[h.startOffset]);
            c = 0, E.childNodes.length > 0 ? s = E.childNodes[0] : s = E, g.childNodes.length > 0 ? u = g.childNodes[0] : u = g, E instanceof HTMLElement ? l = E.innerHTML.length : l = 0;
          } else
            d.startContainer === u ? (s = h.endContainer, l = h.endOffset, c = d.startOffset) : (s = d.startContainer, l = d.endOffset, c = h.startOffset);
        } else
          s = t.anchorNode, l = t.anchorOffset, u = t.focusNode, c = t.focusOffset;
        m5 && RMe(s) || Gl ? p = t.anchorNode === t.focusNode && t.anchorOffset === t.focusOffset : p = t.isCollapsed;
      } else
        s = t.startContainer, l = t.startOffset, u = t.endContainer, c = t.endOffset, p = t.collapsed;
    if (s == null || u == null || l == null || c == null)
      throw new Error("Cannot resolve a Slate range from DOM range: ".concat(t));
    Gl && (r = u.textContent) !== null && r !== void 0 && r.endsWith(`

`) && c === u.textContent.length && c--;
    var w = ve.toSlatePoint(e, [s, l], {
      exactMatch: o,
      suppressThrow: i
    });
    if (!w)
      return null;
    var M = B2(s, u) || s === u && c < l, x = p ? w : ve.toSlatePoint(e, [u, c], {
      exactMatch: o,
      suppressThrow: i,
      searchDirection: M ? "forward" : "backward"
    });
    if (!x)
      return null;
    var y = {
      anchor: w,
      focus: x
    };
    return de.isExpanded(y) && de.isForward(y) && vi(u) && Y.void(e, {
      at: y.focus,
      mode: "highest"
    }) && (y = Y.unhangRange(e, y, {
      voids: !0
    })), y;
  }
};
function VMe(e, t) {
  var {
    path: n,
    diff: r
  } = t;
  if (!Y.hasPath(e, n))
    return !1;
  var o = Fe.get(e, n);
  if (!Qe.isText(o))
    return !1;
  if (r.start !== o.text.length || r.text.length === 0)
    return o.text.slice(r.start, r.start + r.text.length) === r.text;
  var i = se.next(n);
  if (!Y.hasPath(e, i))
    return !1;
  var a = Fe.get(e, i);
  return Qe.isText(a) && a.text.startsWith(r.text);
}
function E5(e) {
  for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)
    n[r - 1] = arguments[r];
  return n.reduce((o, i) => o.slice(0, i.start) + i.text + o.slice(i.end), e);
}
function qMe(e, t) {
  for (var n = Math.min(e.length, t.length), r = 0; r < n; r++)
    if (e.charAt(r) !== t.charAt(r))
      return r;
  return n;
}
function ZMe(e, t, n) {
  for (var r = Math.min(e.length, t.length, n), o = 0; o < r; o++)
    if (e.charAt(e.length - o - 1) !== t.charAt(t.length - o - 1))
      return o;
  return r;
}
function k5(e, t) {
  var {
    start: n,
    end: r,
    text: o
  } = t, i = e.slice(n, r), a = qMe(i, o), s = Math.min(i.length - a, o.length - a), l = ZMe(i, o, s), u = {
    start: n + a,
    end: r - l,
    text: o.slice(a, o.length - l)
  };
  return u.start === u.end && u.text.length === 0 ? null : u;
}
function GMe(e, t, n) {
  var r = Math.min(t.start, n.start), o = Math.max(0, Math.min(t.start + t.text.length, n.end) - n.start), i = E5(e, t, n), a = Math.max(n.start + n.text.length, t.start + t.text.length + (t.start + t.text.length > n.start ? n.text.length : 0) - o), s = i.slice(r, a), l = Math.max(t.end, n.end - t.text.length + (t.end - t.start));
  return k5(e, {
    start: r,
    end: l,
    text: s
  });
}
function XMe(e) {
  var {
    path: t,
    diff: n
  } = e;
  return {
    anchor: {
      path: t,
      offset: n.start
    },
    focus: {
      path: t,
      offset: n.end
    }
  };
}
function Fx(e, t) {
  var {
    path: n,
    offset: r
  } = t;
  if (!Y.hasPath(e, n))
    return null;
  var o = Fe.get(e, n);
  if (!Qe.isText(o))
    return null;
  var i = Y.above(e, {
    match: (s) => Je.isElement(s) && Y.isBlock(e, s),
    at: n
  });
  if (!i)
    return null;
  for (; r > o.text.length; ) {
    var a = Y.next(e, {
      at: n,
      match: Qe.isText
    });
    if (!a || !se.isDescendant(a[1], i[1]))
      return null;
    r -= o.text.length, o = a[0], n = a[1];
  }
  return {
    path: n,
    offset: r
  };
}
function I2(e, t) {
  var n = Fx(e, t.anchor);
  if (!n)
    return null;
  if (de.isCollapsed(t))
    return {
      anchor: n,
      focus: n
    };
  var r = Fx(e, t.focus);
  return r ? {
    anchor: n,
    focus: r
  } : null;
}
function zx(e, t, n) {
  var r = So.get(e), o = r == null ? void 0 : r.find((c) => {
    var {
      path: p
    } = c;
    return se.equals(p, t.path);
  });
  if (!o || t.offset <= o.diff.start)
    return jt.transform(t, n, {
      affinity: "backward"
    });
  var {
    diff: i
  } = o;
  if (t.offset <= i.start + i.text.length) {
    var a = {
      path: t.path,
      offset: i.start
    }, s = jt.transform(a, n, {
      affinity: "backward"
    });
    return s ? {
      path: s.path,
      offset: s.offset + t.offset - i.start
    } : null;
  }
  var l = {
    path: t.path,
    offset: t.offset - i.text.length + i.end - i.start
  }, u = jt.transform(l, n, {
    affinity: "backward"
  });
  return u ? n.type === "split_node" && se.equals(n.path, t.path) && l.offset < n.position && i.start < n.position ? u : {
    path: u.path,
    offset: u.offset + i.text.length - i.end + i.start
  } : null;
}
function R2(e, t, n) {
  var r = zx(e, t.anchor, n);
  if (!r)
    return null;
  if (de.isCollapsed(t))
    return {
      anchor: r,
      focus: r
    };
  var o = zx(e, t.focus, n);
  return o ? {
    anchor: r,
    focus: o
  } : null;
}
function KMe(e, t) {
  var {
    path: n,
    diff: r,
    id: o
  } = e;
  switch (t.type) {
    case "insert_text":
      return !se.equals(t.path, n) || t.offset >= r.end ? e : t.offset <= r.start ? {
        diff: {
          start: t.text.length + r.start,
          end: t.text.length + r.end,
          text: r.text
        },
        id: o,
        path: n
      } : {
        diff: {
          start: r.start,
          end: r.end + t.text.length,
          text: r.text
        },
        id: o,
        path: n
      };
    case "remove_text":
      return !se.equals(t.path, n) || t.offset >= r.end ? e : t.offset + t.text.length <= r.start ? {
        diff: {
          start: r.start - t.text.length,
          end: r.end - t.text.length,
          text: r.text
        },
        id: o,
        path: n
      } : {
        diff: {
          start: r.start,
          end: r.end - t.text.length,
          text: r.text
        },
        id: o,
        path: n
      };
    case "split_node":
      return !se.equals(t.path, n) || t.position >= r.end ? {
        diff: r,
        id: o,
        path: se.transform(n, t, {
          affinity: "backward"
        })
      } : t.position > r.start ? {
        diff: {
          start: r.start,
          end: Math.min(t.position, r.end),
          text: r.text
        },
        id: o,
        path: n
      } : {
        diff: {
          start: r.start - t.position,
          end: r.end - t.position,
          text: r.text
        },
        id: o,
        path: se.transform(n, t, {
          affinity: "forward"
        })
      };
    case "merge_node":
      return se.equals(t.path, n) ? {
        diff: {
          start: r.start + t.position,
          end: r.end + t.position,
          text: r.text
        },
        id: o,
        path: se.transform(n, t)
      } : {
        diff: r,
        id: o,
        path: se.transform(n, t)
      };
  }
  var i = se.transform(n, t);
  return i ? {
    diff: r,
    path: i,
    id: o
  } : null;
}
function N2(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function gh(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? N2(Object(n), !0).forEach(function(r) {
      yi(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : N2(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var YMe = 25, JMe = 200, QMe = function() {
}, eDe = (e) => (e == null ? void 0 : e.constructor.name) === "DataTransfer";
function tDe(e) {
  var {
    editor: t,
    scheduleOnDOMSelectionChange: n,
    onDOMSelectionChange: r
  } = e, o = !1, i = null, a = null, s = null, l = 0, u = !1, c = () => {
    var H = ra.get(t);
    if (ra.delete(t), H) {
      var {
        selection: V
      } = t, z = I2(t, H);
      z && (!V || !de.equals(z, V)) && Le.select(t, z);
    }
  }, p = () => {
    var H = na.get(t);
    if (na.delete(t), !!H) {
      if (H.at) {
        var V = jt.isPoint(H.at) ? Fx(t, H.at) : I2(t, H.at);
        if (!V)
          return;
        var z = Y.range(t, V);
        (!t.selection || !de.equals(t.selection, z)) && Le.select(t, V);
      }
      H.run();
    }
  }, d = () => {
    if (a && (clearTimeout(a), a = null), s && (clearTimeout(s), s = null), !x() && !M()) {
      c();
      return;
    }
    o || (o = !0, setTimeout(() => o = !1)), M() && (o = "action");
    var H = t.selection && Y.rangeRef(t, t.selection, {
      affinity: "forward"
    });
    ys.set(t, t.marks), QMe("flush", na.get(t), So.get(t));
    for (var V = x(), z; z = (q = So.get(t)) === null || q === void 0 ? void 0 : q[0]; ) {
      var q, K, J = Pi.get(t);
      J !== void 0 && (Pi.delete(t), t.marks = J), J && u === !1 && (u = null);
      var te = XMe(z);
      (!t.selection || !de.equals(t.selection, te)) && Le.select(t, te), z.diff.text ? Y.insertText(t, z.diff.text) : Y.deleteFragment(t), So.set(t, (K = So.get(t)) === null || K === void 0 ? void 0 : K.filter((D) => {
        var {
          id: $
        } = D;
        return $ !== z.id;
      })), VMe(t, z) || (V = !1, na.delete(t), ys.delete(t), o = "action", ra.delete(t), n.cancel(), r.cancel(), H == null || H.unref());
    }
    var ee = H == null ? void 0 : H.unref();
    if (ee && !ra.get(t) && (!t.selection || !de.equals(ee, t.selection)) && Le.select(t, ee), M()) {
      p();
      return;
    }
    V && n(), n.flush(), r.flush(), c();
    var _ = ys.get(t);
    ys.delete(t), _ !== void 0 && (t.marks = _, t.onChange());
  }, h = (H) => {
    i && clearTimeout(i), i = setTimeout(() => {
      dl.set(t, !1), d();
    }, YMe);
  }, f = (H) => {
    dl.set(t, !0), i && (clearTimeout(i), i = null);
  }, m = function() {
    var V = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1, z = Bx.get(t);
    if (z) {
      if (x() || V) {
        z.style.display = "none";
        return;
      }
      z.style.removeProperty("display");
    }
  }, g = (H, V) => {
    var z, q = (z = So.get(t)) !== null && z !== void 0 ? z : [];
    So.set(t, q);
    var K = Fe.leaf(t, H), J = q.findIndex((_) => se.equals(_.path, H));
    if (J < 0) {
      var te = k5(K.text, V);
      te && q.push({
        path: H,
        diff: V,
        id: l++
      }), m();
      return;
    }
    var ee = GMe(K.text, q[J].diff, V);
    if (!ee) {
      q.splice(J, 1), m();
      return;
    }
    q[J] = gh(gh({}, q[J]), {}, {
      diff: ee
    });
  }, E = function(V) {
    var {
      at: z
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    u = !1, ra.delete(t), n.cancel(), r.cancel(), M() && d(), na.set(t, {
      at: z,
      run: V
    }), s = setTimeout(d);
  }, w = (H) => {
    var V;
    if (a && (clearTimeout(a), a = null), !tu.get(t)) {
      var {
        inputType: z
      } = H, q = null, K = H.dataTransfer || H.data || void 0;
      u !== !1 && z !== "insertText" && z !== "insertCompositionText" && (u = !1);
      var [J] = H.getTargetRanges();
      J && (q = ve.toSlateRange(t, J, {
        exactMatch: !1,
        suppressThrow: !0
      }));
      var te = ve.getWindow(t), ee = te.getSelection();
      if (!q && ee && (J = ee, q = ve.toSlateRange(t, ee, {
        exactMatch: !1,
        suppressThrow: !0
      })), q = (V = q) !== null && V !== void 0 ? V : t.selection, !!q) {
        var _ = !0;
        if (z.startsWith("delete")) {
          if (de.isExpanded(q)) {
            var [D, $] = de.edges(q), S = Fe.leaf(t, D.path);
            if (S.text.length === D.offset && $.offset === 0) {
              var W = Y.next(t, {
                at: D.path,
                match: Qe.isText
              });
              W && se.equals(W[1], $.path) && (q = {
                anchor: $,
                focus: $
              });
            }
          }
          var O = z.endsWith("Backward") ? "backward" : "forward", [T, U] = de.edges(q), [j, Z] = Y.leaf(t, T.path), A = {
            text: "",
            start: T.offset,
            end: U.offset
          }, Q = So.get(t), R = Q == null ? void 0 : Q.find((We) => se.equals(We.path, Z)), ue = R ? [R.diff, A] : [A], fe = E5(j.text, ...ue);
          if (fe.length === 0 && (_ = !1), de.isExpanded(q)) {
            if (_ && se.equals(q.anchor.path, q.focus.path)) {
              var oe = {
                path: q.anchor.path,
                offset: T.offset
              }, Re = Y.range(t, oe, oe);
              return P(Re), g(q.anchor.path, {
                text: "",
                end: U.offset,
                start: T.offset
              });
            }
            return E(() => Y.deleteFragment(t, {
              direction: O
            }), {
              at: q
            });
          }
        }
        switch (z) {
          case "deleteByComposition":
          case "deleteByCut":
          case "deleteByDrag":
            return E(() => Y.deleteFragment(t), {
              at: q
            });
          case "deleteContent":
          case "deleteContentForward": {
            var {
              anchor: He
            } = q;
            if (_ && de.isCollapsed(q)) {
              var Ve = Fe.leaf(t, He.path);
              if (He.offset < Ve.text.length)
                return g(He.path, {
                  text: "",
                  start: He.offset,
                  end: He.offset + 1
                });
            }
            return E(() => Y.deleteForward(t), {
              at: q
            });
          }
          case "deleteContentBackward": {
            var ze, {
              anchor: et
            } = q, Ge = Nx(J) ? J.isCollapsed : !!((ze = J) !== null && ze !== void 0 && ze.collapsed);
            return _ && Ge && de.isCollapsed(q) && et.offset > 0 ? g(et.path, {
              text: "",
              start: et.offset - 1,
              end: et.offset
            }) : E(() => Y.deleteBackward(t), {
              at: q
            });
          }
          case "deleteEntireSoftLine":
            return E(() => {
              Y.deleteBackward(t, {
                unit: "line"
              }), Y.deleteForward(t, {
                unit: "line"
              });
            }, {
              at: q
            });
          case "deleteHardLineBackward":
            return E(() => Y.deleteBackward(t, {
              unit: "block"
            }), {
              at: q
            });
          case "deleteSoftLineBackward":
            return E(() => Y.deleteBackward(t, {
              unit: "line"
            }), {
              at: q
            });
          case "deleteHardLineForward":
            return E(() => Y.deleteForward(t, {
              unit: "block"
            }), {
              at: q
            });
          case "deleteSoftLineForward":
            return E(() => Y.deleteForward(t, {
              unit: "line"
            }), {
              at: q
            });
          case "deleteWordBackward":
            return E(() => Y.deleteBackward(t, {
              unit: "word"
            }), {
              at: q
            });
          case "deleteWordForward":
            return E(() => Y.deleteForward(t, {
              unit: "word"
            }), {
              at: q
            });
          case "insertLineBreak":
            return E(() => Y.insertSoftBreak(t), {
              at: q
            });
          case "insertParagraph":
            return E(() => Y.insertBreak(t), {
              at: q
            });
          case "insertCompositionText":
          case "deleteCompositionText":
          case "insertFromComposition":
          case "insertFromDrop":
          case "insertFromPaste":
          case "insertFromYank":
          case "insertReplacementText":
          case "insertText": {
            if (eDe(K))
              return E(() => ve.insertData(t, K), {
                at: q
              });
            var Pe = K ?? "";
            if (Pi.get(t) && (Pe = Pe.replace("\uFEFF", "")), z === "insertText" && /.*\n.*\n$/.test(Pe) && (Pe = Pe.slice(0, -1)), Pe.includes(`
`))
              return E(() => {
                var We = Pe.split(`
`);
                We.forEach((Ue, nt) => {
                  Ue && Y.insertText(t, Ue), nt !== We.length - 1 && Y.insertSoftBreak(t);
                });
              }, {
                at: q
              });
            if (se.equals(q.anchor.path, q.focus.path)) {
              var [Ye, it] = de.edges(q), _e = {
                start: Ye.offset,
                end: it.offset,
                text: Pe
              };
              if (Pe && u && z === "insertCompositionText") {
                var Se = u.start + u.text.search(/\S|$/), Ke = _e.start + _e.text.search(/\S|$/);
                Ke === Se + 1 && _e.end === u.start + u.text.length ? (_e.start -= 1, u = null, N()) : u = !1;
              } else z === "insertText" ? u === null ? u = _e : u && de.isCollapsed(q) && u.end + u.text.length === Ye.offset ? u = gh(gh({}, u), {}, {
                text: u.text + Pe
              }) : u = !1 : u = !1;
              if (_) {
                g(Ye.path, _e);
                return;
              }
            }
            return E(() => Y.insertText(t, Pe), {
              at: q
            });
          }
        }
      }
    }
  }, M = () => !!na.get(t), x = () => {
    var H;
    return !!((H = So.get(t)) !== null && H !== void 0 && H.length);
  }, y = () => M() || x(), C = () => o, P = (H) => {
    ra.set(t, H), a && (clearTimeout(a), a = null);
    var {
      selection: V
    } = t;
    if (H) {
      var z = !V || !se.equals(V.anchor.path, H.anchor.path), q = !V || !se.equals(V.anchor.path.slice(0, -1), H.anchor.path.slice(0, -1));
      (z && u || q) && (u = !1), (z || x()) && (a = setTimeout(d, JMe));
    }
  }, F = () => {
    (M() || !x()) && d();
  }, L = (H) => {
    x() || (m(!0), setTimeout(m));
  }, N = () => {
    M() || (s = setTimeout(d));
  }, I = (H) => {
    if (!(x() || M()) && H.some((z) => E1(t, z, H))) {
      var V;
      (V = y5.get(t)) === null || V === void 0 || V();
    }
  };
  return {
    flush: d,
    scheduleFlush: N,
    hasPendingDiffs: x,
    hasPendingAction: M,
    hasPendingChanges: y,
    isFlushing: C,
    handleUserSelect: P,
    handleCompositionEnd: h,
    handleCompositionStart: f,
    handleDOMBeforeInput: w,
    handleKeyDown: L,
    handleDomMutations: I,
    handleInput: F
  };
}
function nDe() {
  var e = rt(!1);
  return v(() => (e.current = !0, () => {
    e.current = !1;
  }), []), e.current;
}
var Np = Ah ? I4 : v;
function rDe(e, t, n) {
  var [r] = k(() => new MutationObserver(t));
  Np(() => {
    r.takeRecords();
  }), v(() => {
    if (!e.current)
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    return r.observe(e.current, n), () => r.disconnect();
  }, [r, e, n]);
}
var oDe = ["node"];
function F2(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function iDe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? F2(Object(n), !0).forEach(function(r) {
      yi(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : F2(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var sDe = {
  subtree: !0,
  childList: !0,
  characterData: !0
}, aDe = wo ? (e) => {
  var {
    node: t
  } = e, n = uu(e, oDe);
  if (!wo)
    return null;
  var r = Ta(), o = nDe(), [i] = k(() => tDe(iDe({
    editor: r
  }, n)));
  return rDe(t, i.handleDomMutations, sDe), x1.set(r, i.scheduleFlush), o && i.flush(), i;
} : () => null, lDe = ["anchor", "focus"], uDe = ["anchor", "focus"], cDe = (e, t) => Object.keys(e).length === Object.keys(t).length && Object.keys(e).every((n) => t.hasOwnProperty(n) && e[n] === t[n]), L5 = (e, t) => {
  var n = uu(e, lDe), r = uu(t, uDe);
  return e[cu] === t[cu] && cDe(n, r);
}, pDe = (e, t) => {
  if (e.length !== t.length)
    return !1;
  for (var n = 0; n < e.length; n++) {
    var r = e[n], o = t[n];
    if (!de.equals(r, o) || !L5(r, o))
      return !1;
  }
  return !0;
}, dDe = (e, t) => {
  if (e.length !== t.length)
    return !1;
  for (var n = 0; n < e.length; n++) {
    var r = e[n], o = t[n];
    if (r.anchor.offset !== o.anchor.offset || r.focus.offset !== o.focus.offset || !L5(r, o))
      return !1;
  }
  return !0;
};
function z2(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function fDe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? z2(Object(n), !0).forEach(function(r) {
      yi(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : z2(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var hDe = (e) => {
  var {
    isLast: t,
    leaf: n,
    parent: r,
    text: o
  } = e, i = Ta(), a = ve.findPath(i, o), s = se.parent(a), l = !!n[b5];
  return i.isVoid(r) ? /* @__PURE__ */ ke.createElement(xw, {
    length: Fe.string(r).length
  }) : n.text === "" && r.children[r.children.length - 1] === o && !i.isInline(r) && Y.string(i, s) === "" ? /* @__PURE__ */ ke.createElement(xw, {
    isLineBreak: !0,
    isMarkPlaceholder: l
  }) : n.text === "" ? /* @__PURE__ */ ke.createElement(xw, {
    isMarkPlaceholder: l
  }) : t && n.text.slice(-1) === `
` ? /* @__PURE__ */ ke.createElement(U2, {
    isTrailing: !0,
    text: n.text
  }) : /* @__PURE__ */ ke.createElement(U2, {
    text: n.text
  });
}, U2 = (e) => {
  var {
    text: t,
    isTrailing: n = !1
  } = e, r = rt(null), o = () => "".concat(t ?? "").concat(n ? `
` : ""), [i] = k(o);
  return Np(() => {
    var a = o();
    r.current && r.current.textContent !== a && (r.current.textContent = a);
  }), /* @__PURE__ */ ke.createElement(gDe, {
    ref: r
  }, i);
}, gDe = /* @__PURE__ */ Ee(/* @__PURE__ */ Vr((e, t) => /* @__PURE__ */ ke.createElement("span", {
  "data-slate-string": !0,
  ref: t
}, e.children))), xw = (e) => {
  var {
    length: t = 0,
    isLineBreak: n = !1,
    isMarkPlaceholder: r = !1
  } = e, o = {
    "data-slate-zero-width": n ? "n" : "z",
    "data-slate-length": t
  };
  return r && (o["data-slate-mark-placeholder"] = !0), /* @__PURE__ */ ke.createElement("span", fDe({}, o), !(wo || g5) || !n ? "\uFEFF" : null, n ? /* @__PURE__ */ ke.createElement("br", null) : null);
};
function $2(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function _5(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? $2(Object(n), !0).forEach(function(r) {
      yi(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : $2(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var mDe = wo ? 300 : 0;
function vDe(e, t) {
  e.current && (e.current.disconnect(), t && (e.current = null));
}
function H2(e) {
  e.current && (clearTimeout(e.current), e.current = null);
}
var yDe = (e) => {
  var {
    leaf: t,
    isLast: n,
    text: r,
    parent: o,
    renderPlaceholder: i,
    renderLeaf: a = (w) => /* @__PURE__ */ ke.createElement(wDe, _5({}, w))
  } = e, s = Ta(), l = rt(null), u = rt(null), [c, p] = k(!1), d = rt(null), h = En((w) => {
    if (vDe(l, w == null), w == null) {
      var M;
      Bx.delete(s), (M = t.onPlaceholderResize) === null || M === void 0 || M.call(t, null);
    } else {
      if (Bx.set(s, w), !l.current) {
        var x = window.ResizeObserver || OMe;
        l.current = new x(() => {
          var y;
          (y = t.onPlaceholderResize) === null || y === void 0 || y.call(t, w);
        });
      }
      l.current.observe(w), u.current = w;
    }
  }, [u, t, s]), f = /* @__PURE__ */ ke.createElement(hDe, {
    isLast: n,
    leaf: t,
    parent: o,
    text: r
  }), m = !!t[cu];
  if (v(() => (m ? d.current || (d.current = setTimeout(() => {
    p(!0), d.current = null;
  }, mDe)) : (H2(d), p(!1)), () => H2(d)), [m, p]), m && c) {
    var g = {
      children: t.placeholder,
      attributes: {
        "data-slate-placeholder": !0,
        style: {
          position: "absolute",
          top: 0,
          pointerEvents: "none",
          width: "100%",
          maxWidth: "100%",
          display: "block",
          opacity: "0.333",
          userSelect: "none",
          textDecoration: "none",
          // Fixes https://github.com/udecode/plate/issues/2315
          WebkitUserModify: Qa ? "inherit" : void 0
        },
        contentEditable: !1,
        ref: h
      }
    };
    f = /* @__PURE__ */ ke.createElement(ke.Fragment, null, i(g), f);
  }
  var E = {
    "data-slate-leaf": !0
  };
  return a({
    attributes: E,
    children: f,
    leaf: t,
    text: r
  });
}, bDe = /* @__PURE__ */ ke.memo(yDe, (e, t) => t.parent === e.parent && t.isLast === e.isLast && t.renderLeaf === e.renderLeaf && t.renderPlaceholder === e.renderPlaceholder && t.text === e.text && Qe.equals(t.leaf, e.leaf) && t.leaf[cu] === e.leaf[cu]), wDe = (e) => {
  var {
    attributes: t,
    children: n
  } = e;
  return /* @__PURE__ */ ke.createElement("span", _5({}, t), n);
}, CDe = (e) => {
  for (var {
    decorations: t,
    isLast: n,
    parent: r,
    renderPlaceholder: o,
    renderLeaf: i,
    text: a
  } = e, s = Ta(), l = rt(null), u = Qe.decorations(a, t), c = ve.findKey(s, a), p = [], d = 0; d < u.length; d++) {
    var h = u[d];
    p.push(/* @__PURE__ */ ke.createElement(bDe, {
      isLast: n && d === u.length - 1,
      key: "".concat(c.id, "-").concat(d),
      renderPlaceholder: o,
      leaf: h,
      text: a,
      parent: r,
      renderLeaf: i
    }));
  }
  var f = En((m) => {
    var g = Ry.get(s);
    m ? (g == null || g.set(c, m), vl.set(a, m), Rp.set(m, a)) : (g == null || g.delete(c), vl.delete(a), l.current && Rp.delete(l.current)), l.current = m;
  }, [l, s, c, a]);
  return /* @__PURE__ */ ke.createElement("span", {
    "data-slate-node": "text",
    ref: f
  }, p);
}, P5 = /* @__PURE__ */ ke.memo(CDe, (e, t) => t.parent === e.parent && t.isLast === e.isLast && t.renderLeaf === e.renderLeaf && t.renderPlaceholder === e.renderPlaceholder && t.text === e.text && dDe(t.decorations, e.decorations));
function W2(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Ux(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? W2(Object(n), !0).forEach(function(r) {
      yi(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : W2(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var xDe = (e) => {
  var {
    decorations: t,
    element: n,
    renderElement: r = (w) => /* @__PURE__ */ ke.createElement(EDe, Ux({}, w)),
    renderPlaceholder: o,
    renderLeaf: i,
    selection: a
  } = e, s = Ta(), l = _De(), u = s.isInline(n), c = ve.findKey(s, n), p = En((w) => {
    var M = Ry.get(s);
    w ? (M == null || M.set(c, w), vl.set(n, w), Rp.set(w, n)) : (M == null || M.delete(c), vl.delete(n));
  }, [s, c, n]), d = M5({
    decorations: t,
    node: n,
    renderElement: r,
    renderPlaceholder: o,
    renderLeaf: i,
    selection: a
  }), h = {
    "data-slate-node": "element",
    ref: p
  };
  if (u && (h["data-slate-inline"] = !0), !u && Y.hasInlines(s, n)) {
    var f = Fe.string(n), m = r5(f);
    m === "rtl" && (h.dir = m);
  }
  if (Y.isVoid(s, n)) {
    h["data-slate-void"] = !0, !l && u && (h.contentEditable = !1);
    var g = u ? "span" : "div", [[E]] = Fe.texts(n);
    d = /* @__PURE__ */ ke.createElement(g, {
      "data-slate-spacer": !0,
      style: {
        height: "0",
        color: "transparent",
        outline: "none",
        position: "absolute"
      }
    }, /* @__PURE__ */ ke.createElement(P5, {
      renderPlaceholder: o,
      decorations: [],
      isLast: !1,
      parent: n,
      text: E
    })), w1.set(E, 0), C1.set(E, n);
  }
  return r({
    attributes: h,
    children: d,
    element: n
  });
}, ODe = /* @__PURE__ */ ke.memo(xDe, (e, t) => e.element === t.element && e.renderElement === t.renderElement && e.renderLeaf === t.renderLeaf && e.renderPlaceholder === t.renderPlaceholder && pDe(e.decorations, t.decorations) && (e.selection === t.selection || !!e.selection && !!t.selection && de.equals(e.selection, t.selection))), EDe = (e) => {
  var {
    attributes: t,
    children: n,
    element: r
  } = e, o = Ta(), i = o.isInline(r) ? "span" : "div";
  return /* @__PURE__ */ ke.createElement(i, Ux(Ux({}, t), {}, {
    style: {
      position: "relative"
    }
  }), n);
}, S5 = /* @__PURE__ */ Ze(() => []), kDe = () => ye(S5), LDe = /* @__PURE__ */ Ze(!1), M5 = (e) => {
  var {
    decorations: t,
    node: n,
    renderElement: r,
    renderPlaceholder: o,
    renderLeaf: i,
    selection: a
  } = e, s = kDe(), l = Ta();
  tu.set(l, !1);
  for (var u = ve.findPath(l, n), c = [], p = Je.isElement(n) && !l.isInline(n) && Y.hasInlines(l, n), d = 0; d < n.children.length; d++) {
    var h = u.concat(d), f = n.children[d], m = ve.findKey(l, f), g = Y.range(l, h), E = a && de.intersection(g, a), w = s([f, h]);
    for (var M of t) {
      var x = de.intersection(M, g);
      x && w.push(x);
    }
    Je.isElement(f) ? c.push(/* @__PURE__ */ ke.createElement(LDe.Provider, {
      key: "provider-".concat(m.id),
      value: !!E
    }, /* @__PURE__ */ ke.createElement(ODe, {
      decorations: w,
      element: f,
      key: m.id,
      renderElement: r,
      renderPlaceholder: o,
      renderLeaf: i,
      selection: E
    }))) : c.push(/* @__PURE__ */ ke.createElement(P5, {
      decorations: w,
      key: m.id,
      isLast: p && d === n.children.length - 1,
      parent: n,
      renderPlaceholder: o,
      renderLeaf: i,
      text: f
    })), w1.set(f, d), C1.set(f, n);
  }
  return c;
}, D5 = /* @__PURE__ */ Ze(!1), _De = () => ye(D5), T5 = /* @__PURE__ */ Ze(null), Ny = () => {
  var e = ye(T5);
  if (!e)
    throw new Error("The `useSlate` hook must be used inside the <Slate> component's context.");
  var {
    editor: t
  } = e;
  return t;
};
function PDe() {
  var e = Ta(), t = rt(!1), n = rt(0), r = En(() => {
    if (!t.current) {
      t.current = !0;
      var o = ve.getWindow(e);
      o.cancelAnimationFrame(n.current), n.current = o.requestAnimationFrame(() => {
        t.current = !1;
      });
    }
  }, [e]);
  return v(() => () => cancelAnimationFrame(n.current), []), {
    receivedUserInput: t,
    onUserInput: r
  };
}
var SDe = 3, MDe = {
  bold: "mod+b",
  compose: ["down", "left", "right", "up", "backspace", "enter"],
  moveBackward: "left",
  moveForward: "right",
  moveWordBackward: "ctrl+left",
  moveWordForward: "ctrl+right",
  deleteBackward: "shift?+backspace",
  deleteForward: "shift?+delete",
  extendBackward: "shift+left",
  extendForward: "shift+right",
  italic: "mod+i",
  insertSoftBreak: "shift+enter",
  splitBlock: "enter",
  undo: "mod+z"
}, DDe = {
  moveLineBackward: "opt+up",
  moveLineForward: "opt+down",
  moveWordBackward: "opt+left",
  moveWordForward: "opt+right",
  deleteBackward: ["ctrl+backspace", "ctrl+h"],
  deleteForward: ["ctrl+delete", "ctrl+d"],
  deleteLineBackward: "cmd+shift?+backspace",
  deleteLineForward: ["cmd+shift?+delete", "ctrl+k"],
  deleteWordBackward: "opt+shift?+backspace",
  deleteWordForward: "opt+shift?+delete",
  extendLineBackward: "opt+shift+up",
  extendLineForward: "opt+shift+down",
  redo: "cmd+shift+z",
  transposeCharacter: "ctrl+t"
}, TDe = {
  deleteWordBackward: "ctrl+shift?+backspace",
  deleteWordForward: "ctrl+shift?+delete",
  redo: ["ctrl+y", "ctrl+shift+z"]
}, mr = (e) => {
  var t = MDe[e], n = DDe[e], r = TDe[e], o = t && gw(t), i = n && gw(n), a = r && gw(r);
  return (s) => !!(o && o(s) || A2 && i && i(s) || !A2 && a && a(s));
}, Cr = {
  isBold: mr("bold"),
  isCompose: mr("compose"),
  isMoveBackward: mr("moveBackward"),
  isMoveForward: mr("moveForward"),
  isDeleteBackward: mr("deleteBackward"),
  isDeleteForward: mr("deleteForward"),
  isDeleteLineBackward: mr("deleteLineBackward"),
  isDeleteLineForward: mr("deleteLineForward"),
  isDeleteWordBackward: mr("deleteWordBackward"),
  isDeleteWordForward: mr("deleteWordForward"),
  isExtendBackward: mr("extendBackward"),
  isExtendForward: mr("extendForward"),
  isExtendLineBackward: mr("extendLineBackward"),
  isExtendLineForward: mr("extendLineForward"),
  isItalic: mr("italic"),
  isMoveLineBackward: mr("moveLineBackward"),
  isMoveLineForward: mr("moveLineForward"),
  isMoveWordBackward: mr("moveWordBackward"),
  isMoveWordForward: mr("moveWordForward"),
  isRedo: mr("redo"),
  isSoftBreak: mr("insertSoftBreak"),
  isSplitBlock: mr("splitBlock"),
  isTransposeCharacter: mr("transposeCharacter"),
  isUndo: mr("undo")
}, jDe = (e, t) => {
  var n = [], r = () => {
    n = [];
  }, o = (a) => {
    if (t.current) {
      var s = a.filter((l) => E1(e, l, a));
      n.push(...s);
    }
  };
  function i() {
    n.length > 0 && (n.reverse().forEach((a) => {
      a.type !== "characterData" && (a.removedNodes.forEach((s) => {
        a.target.insertBefore(s, a.nextSibling);
      }), a.addedNodes.forEach((s) => {
        a.target.removeChild(s);
      }));
    }), r());
  }
  return {
    registerMutations: o,
    restoreDOM: i,
    clear: r
  };
}, ADe = {
  subtree: !0,
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0
};
class j5 extends pu {
  constructor() {
    super(...arguments), yi(this, "context", null), yi(this, "manager", null), yi(this, "mutationObserver", null);
  }
  observe() {
    var t, {
      node: n
    } = this.props;
    if (!n.current)
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    (t = this.mutationObserver) === null || t === void 0 || t.observe(n.current, ADe);
  }
  componentDidMount() {
    var {
      receivedUserInput: t
    } = this.props, n = this.context;
    this.manager = jDe(n, t), this.mutationObserver = new MutationObserver(this.manager.registerMutations), this.observe();
  }
  getSnapshotBeforeUpdate() {
    var t, n, r, o = (t = this.mutationObserver) === null || t === void 0 ? void 0 : t.takeRecords();
    if (o != null && o.length) {
      var i;
      (i = this.manager) === null || i === void 0 || i.registerMutations(o);
    }
    return (n = this.mutationObserver) === null || n === void 0 || n.disconnect(), (r = this.manager) === null || r === void 0 || r.restoreDOM(), null;
  }
  componentDidUpdate() {
    var t;
    (t = this.manager) === null || t === void 0 || t.clear(), this.observe();
  }
  componentWillUnmount() {
    var t;
    (t = this.mutationObserver) === null || t === void 0 || t.disconnect();
  }
  render() {
    return this.props.children;
  }
}
yi(j5, "contextType", b1);
var BDe = wo ? j5 : (e) => {
  var {
    children: t
  } = e;
  return /* @__PURE__ */ ke.createElement(ke.Fragment, null, t);
}, IDe = /* @__PURE__ */ Ze(!1), RDe = ["autoFocus", "decorate", "onDOMBeforeInput", "placeholder", "readOnly", "renderElement", "renderLeaf", "renderPlaceholder", "scrollSelectionIntoView", "style", "as", "disableDefaultStyles"], NDe = ["text"];
function V2(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Ii(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? V2(Object(n), !0).forEach(function(r) {
      yi(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : V2(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var FDe = (e) => /* @__PURE__ */ ke.createElement(ke.Fragment, null, M5(e)), zDe = /* @__PURE__ */ Vr((e, t) => {
  var n = En((T) => /* @__PURE__ */ ke.createElement(UDe, Ii({}, T)), []), {
    autoFocus: r,
    decorate: o = $De,
    onDOMBeforeInput: i,
    placeholder: a,
    readOnly: s = !1,
    renderElement: l,
    renderLeaf: u,
    renderPlaceholder: c = n,
    scrollSelectionIntoView: p = HDe,
    style: d = {},
    as: h = "div",
    disableDefaultStyles: f = !1
  } = e, m = uu(e, RDe), g = Ny(), [E, w] = k(!1), M = rt(null), x = rt([]), [y, C] = k(), P = rt(!1), {
    onUserInput: F,
    receivedUserInput: L
  } = PDe(), [, N] = R4((T) => T + 1, 0);
  y5.set(g, N), Ix.set(g, s);
  var I = Tn(() => ({
    isDraggingInternally: !1,
    isUpdatingSelection: !1,
    latestElement: null,
    hasMarkPlaceholder: !1
  }), []);
  v(() => {
    M.current && r && M.current.focus();
  }, [r]);
  var H = rt(), V = Tn(() => QSe(() => {
    if (tu.get(g)) {
      V();
      return;
    }
    var T = ve.toDOMNode(g, g), U = T.getRootNode();
    if (!P.current && Qa && U instanceof ShadowRoot) {
      P.current = !0;
      var j = UMe();
      j ? document.execCommand("indent") : Le.deselect(g), P.current = !1;
      return;
    }
    var Z = H.current;
    if ((wo || !ve.isComposing(g)) && (!I.isUpdatingSelection || Z != null && Z.isFlushing()) && !I.isDraggingInternally) {
      var A = ve.findDocumentOrShadowRoot(g), {
        activeElement: Q
      } = A, R = ve.toDOMNode(g, g), ue = Vc(A);
      if (Q === R ? (I.latestElement = Q, da.set(g, !0)) : da.delete(g), !ue)
        return Le.deselect(g);
      var {
        anchorNode: fe,
        focusNode: oe
      } = ue, Re = ve.hasEditableTarget(g, fe) || ve.isTargetInsideNonReadonlyVoid(g, fe), He = ve.hasTarget(g, oe);
      if (Re && He) {
        var Ve = ve.toSlateRange(g, ue, {
          exactMatch: !1,
          suppressThrow: !0
        });
        Ve && (!ve.isComposing(g) && !(Z != null && Z.hasPendingChanges()) && !(Z != null && Z.isFlushing()) ? Le.select(g, Ve) : Z == null || Z.handleUserSelect(Ve));
      }
      s && (!Re || !He) && Le.deselect(g);
    }
  }, 100), [g, s, I]), z = Tn(() => ZSe(V, 0), [V]);
  H.current = aDe({
    node: M,
    onDOMSelectionChange: V,
    scheduleOnDOMSelectionChange: z
  }), Np(() => {
    var T, U, j;
    M.current && (j = O1(M.current)) ? (v5.set(g, j), Bh.set(g, M.current), vl.set(g, M.current), Rp.set(M.current, g)) : vl.delete(g);
    var {
      selection: Z
    } = g, A = ve.findDocumentOrShadowRoot(g), Q = Vc(A);
    if (!(!Q || !ve.isFocused(g) || (T = H.current) !== null && T !== void 0 && T.hasPendingAction())) {
      var R = (Re) => {
        var He = Q.type !== "None";
        if (!(!Z && !He)) {
          var Ve = Q.focusNode, ze;
          if (Gl && Q.rangeCount > 1) {
            var et = Q.getRangeAt(0), Ge = Q.getRangeAt(Q.rangeCount - 1);
            et.startContainer === Ve ? ze = Ge.endContainer : ze = et.startContainer;
          } else
            ze = Q.anchorNode;
          var Pe = Bh.get(g), Ye = !1;
          if (Pe.contains(ze) && Pe.contains(Ve) && (Ye = !0), He && Ye && Z && !Re) {
            var it = ve.toSlateRange(g, Q, {
              exactMatch: !0,
              // domSelection is not necessarily a valid Slate range
              // (e.g. when clicking on contentEditable:false element)
              suppressThrow: !0
            });
            if (it && de.equals(it, Z)) {
              var _e;
              if (!I.hasMarkPlaceholder || (_e = ze) !== null && _e !== void 0 && (_e = _e.parentElement) !== null && _e !== void 0 && _e.hasAttribute("data-slate-mark-placeholder"))
                return;
            }
          }
          if (Z && !ve.hasRange(g, Z)) {
            g.selection = ve.toSlateRange(g, Q, {
              exactMatch: !1,
              suppressThrow: !0
            });
            return;
          }
          I.isUpdatingSelection = !0;
          var Se = Z && ve.toDOMRange(g, Z);
          return Se ? (ve.isComposing(g) && !wo ? Q.collapseToEnd() : de.isBackward(Z) ? Q.setBaseAndExtent(Se.endContainer, Se.endOffset, Se.startContainer, Se.startOffset) : Q.setBaseAndExtent(Se.startContainer, Se.startOffset, Se.endContainer, Se.endOffset), p(g, Se)) : Q.removeAllRanges(), Se;
        }
      };
      Q.rangeCount <= 1 && R();
      var ue = ((U = H.current) === null || U === void 0 ? void 0 : U.isFlushing()) === "action";
      if (!wo || !ue) {
        setTimeout(() => {
          I.isUpdatingSelection = !1;
        });
        return;
      }
      var fe = null, oe = requestAnimationFrame(() => {
        if (ue) {
          var Re = (He) => {
            try {
              var Ve = ve.toDOMNode(g, g);
              Ve.focus(), R(He);
            } catch {
            }
          };
          Re(), fe = setTimeout(() => {
            Re(!0), I.isUpdatingSelection = !1;
          });
        }
      });
      return () => {
        cancelAnimationFrame(oe), fe && clearTimeout(fe);
      };
    }
  });
  var q = En((T) => {
    var U = ve.toDOMNode(g, g), j = U.getRootNode();
    if (P != null && P.current && Qa && j instanceof ShadowRoot) {
      var Z = T.getTargetRanges(), A = Z[0], Q = new window.Range();
      Q.setStart(A.startContainer, A.startOffset), Q.setEnd(A.endContainer, A.endOffset);
      var R = ve.toSlateRange(g, Q, {
        exactMatch: !1,
        suppressThrow: !1
      });
      Le.select(g, R), T.preventDefault(), T.stopImmediatePropagation();
      return;
    }
    if (F(), !s && ve.hasEditableTarget(g, T.target) && !WDe(T, i)) {
      var ue;
      if (H.current)
        return H.current.handleDOMBeforeInput(T);
      z.flush(), V.flush();
      var {
        selection: fe
      } = g, {
        inputType: oe
      } = T, Re = T.dataTransfer || T.data || void 0, He = oe === "insertCompositionText" || oe === "deleteCompositionText";
      if (He && ve.isComposing(g))
        return;
      var Ve = !1;
      if (oe === "insertText" && fe && de.isCollapsed(fe) && // Only use native character insertion for single characters a-z or space for now.
      // Long-press events (hold a + press 4 = ) to choose a special character otherwise
      // causes duplicate inserts.
      T.data && T.data.length === 1 && /[a-z ]/i.test(T.data) && // Chrome has issues correctly editing the start of nodes: https://bugs.chromium.org/p/chromium/issues/detail?id=1249405
      // When there is an inline element, e.g. a link, and you select
      // right after it (the start of the next node).
      fe.anchor.offset !== 0 && (Ve = !0, g.marks && (Ve = !1), !tu.get(g))) {
        var ze, et, {
          anchor: Ge
        } = fe, [Pe, Ye] = ve.toDOMPoint(g, Ge), it = (ze = Pe.parentElement) === null || ze === void 0 ? void 0 : ze.closest("a"), _e = ve.getWindow(g);
        if (Ve && it && ve.hasDOMNode(g, it)) {
          var Se, Ke = _e == null ? void 0 : _e.document.createTreeWalker(it, NodeFilter.SHOW_TEXT).lastChild();
          Ke === Pe && ((Se = Ke.textContent) === null || Se === void 0 ? void 0 : Se.length) === Ye && (Ve = !1);
        }
        if (Ve && Pe.parentElement && (_e == null || (et = _e.getComputedStyle(Pe.parentElement)) === null || et === void 0 ? void 0 : et.whiteSpace) === "pre") {
          var We = Y.above(g, {
            at: Ge.path,
            match: (st) => Je.isElement(st) && Y.isBlock(g, st)
          });
          We && Fe.string(We[0]).includes("	") && (Ve = !1);
        }
      }
      if ((!oe.startsWith("delete") || oe.startsWith("deleteBy")) && !tu.get(g)) {
        var [Ue] = T.getTargetRanges();
        if (Ue) {
          var nt = ve.toSlateRange(g, Ue, {
            exactMatch: !1,
            suppressThrow: !1
          });
          if (!fe || !de.equals(fe, nt)) {
            Ve = !1;
            var Ie = !He && g.selection && Y.rangeRef(g, g.selection);
            Le.select(g, nt), Ie && Wc.set(g, Ie);
          }
        }
      }
      if (He)
        return;
      if (Ve || T.preventDefault(), fe && de.isExpanded(fe) && oe.startsWith("delete")) {
        var xt = oe.endsWith("Backward") ? "backward" : "forward";
        Y.deleteFragment(g, {
          direction: xt
        });
        return;
      }
      switch (oe) {
        case "deleteByComposition":
        case "deleteByCut":
        case "deleteByDrag": {
          Y.deleteFragment(g);
          break;
        }
        case "deleteContent":
        case "deleteContentForward": {
          Y.deleteForward(g);
          break;
        }
        case "deleteContentBackward": {
          Y.deleteBackward(g);
          break;
        }
        case "deleteEntireSoftLine": {
          Y.deleteBackward(g, {
            unit: "line"
          }), Y.deleteForward(g, {
            unit: "line"
          });
          break;
        }
        case "deleteHardLineBackward": {
          Y.deleteBackward(g, {
            unit: "block"
          });
          break;
        }
        case "deleteSoftLineBackward": {
          Y.deleteBackward(g, {
            unit: "line"
          });
          break;
        }
        case "deleteHardLineForward": {
          Y.deleteForward(g, {
            unit: "block"
          });
          break;
        }
        case "deleteSoftLineForward": {
          Y.deleteForward(g, {
            unit: "line"
          });
          break;
        }
        case "deleteWordBackward": {
          Y.deleteBackward(g, {
            unit: "word"
          });
          break;
        }
        case "deleteWordForward": {
          Y.deleteForward(g, {
            unit: "word"
          });
          break;
        }
        case "insertLineBreak":
          Y.insertSoftBreak(g);
          break;
        case "insertParagraph": {
          Y.insertBreak(g);
          break;
        }
        case "insertFromComposition":
        case "insertFromDrop":
        case "insertFromPaste":
        case "insertFromYank":
        case "insertReplacementText":
        case "insertText": {
          oe === "insertFromComposition" && ve.isComposing(g) && (w(!1), dl.set(g, !1)), (Re == null ? void 0 : Re.constructor.name) === "DataTransfer" ? ve.insertData(g, Re) : typeof Re == "string" && (Ve ? x.current.push(() => Y.insertText(g, Re)) : Y.insertText(g, Re));
          break;
        }
      }
      var ot = (ue = Wc.get(g)) === null || ue === void 0 ? void 0 : ue.unref();
      Wc.delete(g), ot && (!g.selection || !de.equals(g.selection, ot)) && Le.select(g, ot);
    }
  }, [g, V, F, i, s, z]), K = En((T) => {
    T == null ? (V.cancel(), z.cancel(), Bh.delete(g), vl.delete(g), M.current && $s && M.current.removeEventListener("beforeinput", q)) : $s && T.addEventListener("beforeinput", q), M.current = T, typeof t == "function" ? t(T) : t && (t.current = T);
  }, [V, z, g, q, t]);
  Np(() => {
    var T = ve.getWindow(g);
    T.document.addEventListener("selectionchange", z);
    var U = () => {
      I.isDraggingInternally = !1;
    };
    return T.document.addEventListener("dragend", U), T.document.addEventListener("drop", U), () => {
      T.document.removeEventListener("selectionchange", z), T.document.removeEventListener("dragend", U), T.document.removeEventListener("drop", U);
    };
  }, [z, I]);
  var J = o([g, []]), te = a && g.children.length === 1 && Array.from(Fe.texts(g)).length === 1 && Fe.string(g) === "" && !E, ee = En((T) => {
    if (T && te) {
      var U;
      C((U = T.getBoundingClientRect()) === null || U === void 0 ? void 0 : U.height);
    } else
      C(void 0);
  }, [te]);
  if (te) {
    var _ = Y.start(g, []);
    J.push({
      [cu]: !0,
      placeholder: a,
      onPlaceholderResize: ee,
      anchor: _,
      focus: _
    });
  }
  var {
    marks: D
  } = g;
  if (I.hasMarkPlaceholder = !1, g.selection && de.isCollapsed(g.selection) && D) {
    var {
      anchor: $
    } = g.selection, S = Fe.leaf(g, $.path), W = uu(S, NDe);
    if (!Qe.equals(S, D, {
      loose: !0
    })) {
      I.hasMarkPlaceholder = !0;
      var O = Object.fromEntries(Object.keys(W).map((T) => [T, null]));
      J.push(Ii(Ii(Ii({
        [b5]: !0
      }, O), D), {}, {
        anchor: $,
        focus: $
      }));
    }
  }
  return v(() => {
    setTimeout(() => {
      var {
        selection: T
      } = g;
      if (T) {
        var {
          anchor: U
        } = T, j = Fe.leaf(g, U.path);
        if (D && !Qe.equals(j, D, {
          loose: !0
        })) {
          Pi.set(g, D);
          return;
        }
      }
      Pi.delete(g);
    });
  }), /* @__PURE__ */ ke.createElement(D5.Provider, {
    value: s
  }, /* @__PURE__ */ ke.createElement(IDe.Provider, {
    value: E
  }, /* @__PURE__ */ ke.createElement(S5.Provider, {
    value: o
  }, /* @__PURE__ */ ke.createElement(BDe, {
    node: M,
    receivedUserInput: L
  }, /* @__PURE__ */ ke.createElement(h, Ii(Ii({
    role: s ? void 0 : "textbox",
    "aria-multiline": s ? void 0 : !0
  }, m), {}, {
    // COMPAT: Certain browsers don't support the `beforeinput` event, so we'd
    // have to use hacks to make these replacement-based features work.
    // For SSR situations HAS_BEFORE_INPUT_SUPPORT is false and results in prop
    // mismatch warning app moves to browser. Pass-through consumer props when
    // not CAN_USE_DOM (SSR) and default to falsy value
    spellCheck: $s || !Ah ? m.spellCheck : !1,
    autoCorrect: $s || !Ah ? m.autoCorrect : "false",
    autoCapitalize: $s || !Ah ? m.autoCapitalize : "false",
    "data-slate-editor": !0,
    "data-slate-node": "value",
    // explicitly set this
    contentEditable: !s,
    // in some cases, a decoration needs access to the range / selection to decorate a text node,
    // then you will select the whole text node when you select part the of text
    // this magic zIndex="-1" will fix it
    zindex: -1,
    suppressContentEditableWarning: !0,
    ref: K,
    style: Ii(Ii({}, f ? {} : Ii({
      // Allow positioning relative to the editable element.
      position: "relative",
      // Preserve adjacent whitespace and new lines.
      whiteSpace: "pre-wrap",
      // Allow words to break if they are too long.
      wordWrap: "break-word"
    }, y ? {
      minHeight: y
    } : {})), d),
    onBeforeInput: En((T) => {
      if (!$s && !s && !yo(T, m.onBeforeInput) && ve.hasSelectableTarget(g, T.target) && (T.preventDefault(), !ve.isComposing(g))) {
        var U = T.data;
        Y.insertText(g, U);
      }
    }, [m.onBeforeInput, g, s]),
    onInput: En((T) => {
      if (!yo(T, m.onInput)) {
        if (H.current) {
          H.current.handleInput();
          return;
        }
        for (var U of x.current)
          U();
        if (x.current = [], !ve.isFocused(g)) {
          var j = T.nativeEvent, Z = g;
          if (j.inputType === "historyUndo" && typeof Z.undo == "function") {
            Z.undo();
            return;
          }
          if (j.inputType === "historyRedo" && typeof Z.redo == "function") {
            Z.redo();
            return;
          }
        }
      }
    }, [m.onInput, g]),
    onBlur: En((T) => {
      if (!(s || I.isUpdatingSelection || !ve.hasSelectableTarget(g, T.target) || yo(T, m.onBlur))) {
        var U = ve.findDocumentOrShadowRoot(g);
        if (I.latestElement !== U.activeElement) {
          var {
            relatedTarget: j
          } = T, Z = ve.toDOMNode(g, g);
          if (j !== Z && !(vi(j) && j.hasAttribute("data-slate-spacer"))) {
            if (j != null && ha(j) && ve.hasDOMNode(g, j)) {
              var A = ve.toSlateNode(g, j);
              if (Je.isElement(A) && !g.isVoid(A))
                return;
            }
            if (Qa) {
              var Q = Vc(U);
              Q == null || Q.removeAllRanges();
            }
            da.delete(g);
          }
        }
      }
    }, [s, I.isUpdatingSelection, I.latestElement, g, m.onBlur]),
    onClick: En((T) => {
      if (ve.hasTarget(g, T.target) && !yo(T, m.onClick) && ha(T.target)) {
        var U = ve.toSlateNode(g, T.target), j = ve.findPath(g, U);
        if (!Y.hasPath(g, j) || Fe.get(g, j) !== U)
          return;
        if (T.detail === SDe && j.length >= 1) {
          var Z = j;
          if (!(Je.isElement(U) && Y.isBlock(g, U))) {
            var A, Q = Y.above(g, {
              match: (Ve) => Je.isElement(Ve) && Y.isBlock(g, Ve),
              at: j
            });
            Z = (A = Q == null ? void 0 : Q[1]) !== null && A !== void 0 ? A : j.slice(0, 1);
          }
          var R = Y.range(g, Z);
          Le.select(g, R);
          return;
        }
        if (s)
          return;
        var ue = Y.start(g, j), fe = Y.end(g, j), oe = Y.void(g, {
          at: ue
        }), Re = Y.void(g, {
          at: fe
        });
        if (oe && Re && se.equals(oe[1], Re[1])) {
          var He = Y.range(g, ue);
          Le.select(g, He);
        }
      }
    }, [g, m.onClick, s]),
    onCompositionEnd: En((T) => {
      if (ve.hasSelectableTarget(g, T.target)) {
        var U;
        if (ve.isComposing(g) && Promise.resolve().then(() => {
          w(!1), dl.set(g, !1);
        }), (U = H.current) === null || U === void 0 || U.handleCompositionEnd(T), yo(T, m.onCompositionEnd) || wo)
          return;
        if (!Qa && !MMe && !g5 && !TMe && !DMe && T.data) {
          var j = Pi.get(g);
          Pi.delete(g), j !== void 0 && (ys.set(g, g.marks), g.marks = j), Y.insertText(g, T.data);
          var Z = ys.get(g);
          ys.delete(g), Z !== void 0 && (g.marks = Z);
        }
      }
    }, [m.onCompositionEnd, g]),
    onCompositionUpdate: En((T) => {
      ve.hasSelectableTarget(g, T.target) && !yo(T, m.onCompositionUpdate) && (ve.isComposing(g) || (w(!0), dl.set(g, !0)));
    }, [m.onCompositionUpdate, g]),
    onCompositionStart: En((T) => {
      if (ve.hasSelectableTarget(g, T.target)) {
        var U;
        if ((U = H.current) === null || U === void 0 || U.handleCompositionStart(T), yo(T, m.onCompositionStart) || wo)
          return;
        w(!0);
        var {
          selection: j
        } = g;
        if (j && de.isExpanded(j)) {
          Y.deleteFragment(g);
          return;
        }
      }
    }, [m.onCompositionStart, g]),
    onCopy: En((T) => {
      ve.hasSelectableTarget(g, T.target) && !yo(T, m.onCopy) && !q2(T) && (T.preventDefault(), ve.setFragmentData(g, T.clipboardData, "copy"));
    }, [m.onCopy, g]),
    onCut: En((T) => {
      if (!s && ve.hasSelectableTarget(g, T.target) && !yo(T, m.onCut) && !q2(T)) {
        T.preventDefault(), ve.setFragmentData(g, T.clipboardData, "cut");
        var {
          selection: U
        } = g;
        if (U)
          if (de.isExpanded(U))
            Y.deleteFragment(g);
          else {
            var j = Fe.parent(g, U.anchor.path);
            Y.isVoid(g, j) && Le.delete(g);
          }
      }
    }, [s, g, m.onCut]),
    onDragOver: En((T) => {
      if (ve.hasTarget(g, T.target) && !yo(T, m.onDragOver)) {
        var U = ve.toSlateNode(g, T.target);
        Je.isElement(U) && Y.isVoid(g, U) && T.preventDefault();
      }
    }, [m.onDragOver, g]),
    onDragStart: En((T) => {
      if (!s && ve.hasTarget(g, T.target) && !yo(T, m.onDragStart)) {
        var U = ve.toSlateNode(g, T.target), j = ve.findPath(g, U), Z = Je.isElement(U) && Y.isVoid(g, U) || Y.void(g, {
          at: j,
          voids: !0
        });
        if (Z) {
          var A = Y.range(g, j);
          Le.select(g, A);
        }
        I.isDraggingInternally = !0, ve.setFragmentData(g, T.dataTransfer, "drag");
      }
    }, [s, g, m.onDragStart, I]),
    onDrop: En((T) => {
      if (!s && ve.hasTarget(g, T.target) && !yo(T, m.onDrop)) {
        T.preventDefault();
        var U = g.selection, j = ve.findEventRange(g, T), Z = T.dataTransfer;
        Le.select(g, j), I.isDraggingInternally && U && !de.equals(U, j) && !Y.void(g, {
          at: j,
          voids: !0
        }) && Le.delete(g, {
          at: U
        }), ve.insertData(g, Z), ve.isFocused(g) || ve.focus(g);
      }
    }, [s, g, m.onDrop, I]),
    onDragEnd: En((T) => {
      !s && I.isDraggingInternally && m.onDragEnd && ve.hasTarget(g, T.target) && m.onDragEnd(T);
    }, [s, I, m, g]),
    onFocus: En((T) => {
      if (!s && !I.isUpdatingSelection && ve.hasEditableTarget(g, T.target) && !yo(T, m.onFocus)) {
        var U = ve.toDOMNode(g, g), j = ve.findDocumentOrShadowRoot(g);
        if (I.latestElement = j.activeElement, Gl && T.target !== U) {
          U.focus();
          return;
        }
        da.set(g, !0);
      }
    }, [s, I, g, m.onFocus]),
    onKeyDown: En((T) => {
      if (!s && ve.hasEditableTarget(g, T.target)) {
        var U;
        (U = H.current) === null || U === void 0 || U.handleKeyDown(T);
        var {
          nativeEvent: j
        } = T;
        if (ve.isComposing(g) && j.isComposing === !1 && (dl.set(g, !1), w(!1)), yo(T, m.onKeyDown) || ve.isComposing(g))
          return;
        var {
          selection: Z
        } = g, A = g.children[Z !== null ? Z.focus.path[0] : 0], Q = r5(Fe.string(A)) === "rtl";
        if (Cr.isRedo(j)) {
          T.preventDefault();
          var R = g;
          typeof R.redo == "function" && R.redo();
          return;
        }
        if (Cr.isUndo(j)) {
          T.preventDefault();
          var ue = g;
          typeof ue.undo == "function" && ue.undo();
          return;
        }
        if (Cr.isMoveLineBackward(j)) {
          T.preventDefault(), Le.move(g, {
            unit: "line",
            reverse: !0
          });
          return;
        }
        if (Cr.isMoveLineForward(j)) {
          T.preventDefault(), Le.move(g, {
            unit: "line"
          });
          return;
        }
        if (Cr.isExtendLineBackward(j)) {
          T.preventDefault(), Le.move(g, {
            unit: "line",
            edge: "focus",
            reverse: !0
          });
          return;
        }
        if (Cr.isExtendLineForward(j)) {
          T.preventDefault(), Le.move(g, {
            unit: "line",
            edge: "focus"
          });
          return;
        }
        if (Cr.isMoveBackward(j)) {
          T.preventDefault(), Z && de.isCollapsed(Z) ? Le.move(g, {
            reverse: !Q
          }) : Le.collapse(g, {
            edge: Q ? "end" : "start"
          });
          return;
        }
        if (Cr.isMoveForward(j)) {
          T.preventDefault(), Z && de.isCollapsed(Z) ? Le.move(g, {
            reverse: Q
          }) : Le.collapse(g, {
            edge: Q ? "start" : "end"
          });
          return;
        }
        if (Cr.isMoveWordBackward(j)) {
          T.preventDefault(), Z && de.isExpanded(Z) && Le.collapse(g, {
            edge: "focus"
          }), Le.move(g, {
            unit: "word",
            reverse: !Q
          });
          return;
        }
        if (Cr.isMoveWordForward(j)) {
          T.preventDefault(), Z && de.isExpanded(Z) && Le.collapse(g, {
            edge: "focus"
          }), Le.move(g, {
            unit: "word",
            reverse: Q
          });
          return;
        }
        if ($s) {
          if ((m5 || Qa) && Z && (Cr.isDeleteBackward(j) || Cr.isDeleteForward(j)) && de.isCollapsed(Z)) {
            var fe = Fe.parent(g, Z.anchor.path);
            if (Je.isElement(fe) && Y.isVoid(g, fe) && (Y.isInline(g, fe) || Y.isBlock(g, fe))) {
              T.preventDefault(), Y.deleteBackward(g, {
                unit: "block"
              });
              return;
            }
          }
        } else {
          if (Cr.isBold(j) || Cr.isItalic(j) || Cr.isTransposeCharacter(j)) {
            T.preventDefault();
            return;
          }
          if (Cr.isSoftBreak(j)) {
            T.preventDefault(), Y.insertSoftBreak(g);
            return;
          }
          if (Cr.isSplitBlock(j)) {
            T.preventDefault(), Y.insertBreak(g);
            return;
          }
          if (Cr.isDeleteBackward(j)) {
            T.preventDefault(), Z && de.isExpanded(Z) ? Y.deleteFragment(g, {
              direction: "backward"
            }) : Y.deleteBackward(g);
            return;
          }
          if (Cr.isDeleteForward(j)) {
            T.preventDefault(), Z && de.isExpanded(Z) ? Y.deleteFragment(g, {
              direction: "forward"
            }) : Y.deleteForward(g);
            return;
          }
          if (Cr.isDeleteLineBackward(j)) {
            T.preventDefault(), Z && de.isExpanded(Z) ? Y.deleteFragment(g, {
              direction: "backward"
            }) : Y.deleteBackward(g, {
              unit: "line"
            });
            return;
          }
          if (Cr.isDeleteLineForward(j)) {
            T.preventDefault(), Z && de.isExpanded(Z) ? Y.deleteFragment(g, {
              direction: "forward"
            }) : Y.deleteForward(g, {
              unit: "line"
            });
            return;
          }
          if (Cr.isDeleteWordBackward(j)) {
            T.preventDefault(), Z && de.isExpanded(Z) ? Y.deleteFragment(g, {
              direction: "backward"
            }) : Y.deleteBackward(g, {
              unit: "word"
            });
            return;
          }
          if (Cr.isDeleteWordForward(j)) {
            T.preventDefault(), Z && de.isExpanded(Z) ? Y.deleteFragment(g, {
              direction: "forward"
            }) : Y.deleteForward(g, {
              unit: "word"
            });
            return;
          }
        }
      }
    }, [s, g, m.onKeyDown]),
    onPaste: En((T) => {
      !s && ve.hasEditableTarget(g, T.target) && !yo(T, m.onPaste) && (!$s || BMe(T.nativeEvent) || Qa) && (T.preventDefault(), ve.insertData(g, T.clipboardData));
    }, [s, g, m.onPaste])
  }), /* @__PURE__ */ ke.createElement(FDe, {
    decorations: J,
    node: g,
    renderElement: l,
    renderPlaceholder: c,
    renderLeaf: u,
    selection: g.selection
  }))))));
}), UDe = (e) => {
  var {
    attributes: t,
    children: n
  } = e;
  return (
    // COMPAT: Artificially add a line-break to the end on the placeholder element
    // to prevent Android IMEs to pick up its content in autocorrect and to auto-capitalize the first letter
    /* @__PURE__ */ ke.createElement("span", Ii({}, t), n, wo && /* @__PURE__ */ ke.createElement("br", null))
  );
}, $De = () => [], HDe = (e, t) => {
  if (t.getBoundingClientRect && (!e.selection || e.selection && de.isCollapsed(e.selection))) {
    var n = t.startContainer.parentElement;
    n.getBoundingClientRect = t.getBoundingClientRect.bind(t), nMe(n, {
      scrollMode: "if-needed"
    }), delete n.getBoundingClientRect;
  }
}, yo = (e, t) => {
  if (!t)
    return !1;
  var n = t(e);
  return n ?? (e.isDefaultPrevented() || e.isPropagationStopped());
}, q2 = (e) => ha(e.target) && (e.target instanceof HTMLInputElement || e.target instanceof HTMLTextAreaElement), WDe = (e, t) => {
  if (!t)
    return !1;
  var n = t(e);
  return n ?? e.defaultPrevented;
}, VDe = /* @__PURE__ */ Ze(!1), qDe = /* @__PURE__ */ Ze({});
function ZDe(e) {
  var t = rt([]).current, n = rt({
    editor: e
  }).current, r = En((i) => {
    n.editor = i, t.forEach((a) => a(i));
  }, [t, n]), o = Tn(() => ({
    getSlate: () => n.editor,
    addEventListener: (i) => (t.push(i), () => {
      t.splice(t.indexOf(i), 1);
    })
  }), [t, n]);
  return {
    selectorContext: o,
    onChange: r
  };
}
var GDe = ["editor", "children", "onChange", "onSelectionChange", "onValueChange", "initialValue"], XDe = (e) => {
  var {
    editor: t,
    children: n,
    onChange: r,
    onSelectionChange: o,
    onValueChange: i,
    initialValue: a
  } = e, s = uu(e, GDe), [l, u] = ke.useState(() => {
    if (!Fe.isNodeList(a))
      throw new Error("[Slate] initialValue is invalid! Expected a list of elements but got: ".concat(Jr.stringify(a)));
    if (!Y.isEditor(t))
      throw new Error("[Slate] editor is invalid! You passed: ".concat(Jr.stringify(t)));
    return t.children = a, Object.assign(t, s), {
      v: 0,
      editor: t
    };
  }), {
    selectorContext: c,
    onChange: p
  } = ZDe(t), d = En((m) => {
    var g;
    switch (r && r(t.children), m == null || (g = m.operation) === null || g === void 0 ? void 0 : g.type) {
      case "set_selection":
        o == null || o(t.selection);
        break;
      default:
        i == null || i(t.children);
    }
    u((E) => ({
      v: E.v + 1,
      editor: t
    })), p(t);
  }, [t, p, r, o, i]);
  v(() => (Rx.set(t, d), () => {
    Rx.set(t, () => {
    });
  }), [t, d]);
  var [h, f] = k(ve.isFocused(t));
  return v(() => {
    f(ve.isFocused(t));
  }, [t]), Np(() => {
    var m = () => f(ve.isFocused(t));
    return h5 >= 17 ? (document.addEventListener("focusin", m), document.addEventListener("focusout", m), () => {
      document.removeEventListener("focusin", m), document.removeEventListener("focusout", m);
    }) : (document.addEventListener("focus", m, !0), document.addEventListener("blur", m, !0), () => {
      document.removeEventListener("focus", m, !0), document.removeEventListener("blur", m, !0);
    });
  }, []), /* @__PURE__ */ ke.createElement(qDe.Provider, {
    value: c
  }, /* @__PURE__ */ ke.createElement(T5.Provider, {
    value: l
  }, /* @__PURE__ */ ke.createElement(b1.Provider, {
    value: l.editor
  }, /* @__PURE__ */ ke.createElement(VDe.Provider, {
    value: h
  }, n))));
}, Z2 = (e, t) => {
  var n = (t.top + t.bottom) / 2;
  return e.top <= n && e.bottom >= n;
}, G2 = (e, t, n) => {
  var r = ve.toDOMRange(e, t).getBoundingClientRect(), o = ve.toDOMRange(e, n).getBoundingClientRect();
  return Z2(r, o) && Z2(o, r);
}, KDe = (e, t) => {
  var n = Y.range(e, de.end(t)), r = Array.from(Y.positions(e, {
    at: t
  })), o = 0, i = r.length, a = Math.floor(i / 2);
  if (G2(e, Y.range(e, r[o]), n))
    return Y.range(e, r[o], n);
  if (r.length < 2)
    return Y.range(e, r[r.length - 1], n);
  for (; a !== r.length && a !== o; )
    G2(e, Y.range(e, r[a]), n) ? i = a : o = a, a = Math.floor((o + i) / 2);
  return Y.range(e, r[i], n);
};
function X2(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function K2(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? X2(Object(n), !0).forEach(function(r) {
      yi(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : X2(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var YDe = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "x-slate-fragment", r = t, {
    apply: o,
    onChange: i,
    deleteBackward: a,
    addMark: s,
    removeMark: l
  } = r;
  return Ry.set(r, /* @__PURE__ */ new WeakMap()), r.addMark = (u, c) => {
    var p, d;
    (p = x1.get(r)) === null || p === void 0 || p(), !Pi.get(r) && (d = So.get(r)) !== null && d !== void 0 && d.length && Pi.set(r, null), ys.delete(r), s(u, c);
  }, r.removeMark = (u) => {
    var c;
    !Pi.get(r) && (c = So.get(r)) !== null && c !== void 0 && c.length && Pi.set(r, null), ys.delete(r), l(u);
  }, r.deleteBackward = (u) => {
    if (u !== "line")
      return a(u);
    if (r.selection && de.isCollapsed(r.selection)) {
      var c = Y.above(r, {
        match: (f) => Je.isElement(f) && Y.isBlock(r, f),
        at: r.selection
      });
      if (c) {
        var [, p] = c, d = Y.range(r, p, r.selection.anchor), h = KDe(r, d);
        de.isCollapsed(h) || Le.delete(r, {
          at: h
        });
      }
    }
  }, r.apply = (u) => {
    var c = [], p = [], d = So.get(r);
    if (d != null && d.length) {
      var h = d.map((z) => KMe(z, u)).filter(Boolean);
      So.set(r, h);
    }
    var f = ra.get(r);
    f && ra.set(r, R2(r, f, u));
    var m = na.get(r);
    if (m != null && m.at) {
      var g = jt.isPoint(m == null ? void 0 : m.at) ? zx(r, m.at, u) : R2(r, m.at, u);
      na.set(r, g ? K2(K2({}, m), {}, {
        at: g
      }) : null);
    }
    switch (u.type) {
      case "insert_text":
      case "remove_text":
      case "set_node":
      case "split_node": {
        c.push(...Vl(r, u.path));
        break;
      }
      case "set_selection": {
        var E;
        (E = Wc.get(r)) === null || E === void 0 || E.unref(), Wc.delete(r);
        break;
      }
      case "insert_node":
      case "remove_node": {
        c.push(...Vl(r, se.parent(u.path)));
        break;
      }
      case "merge_node": {
        var w = se.previous(u.path);
        c.push(...Vl(r, w));
        break;
      }
      case "move_node": {
        var M = se.common(se.parent(u.path), se.parent(u.newPath));
        c.push(...Vl(r, M));
        var x;
        se.isBefore(u.path, u.newPath) ? (c.push(...Vl(r, se.parent(u.path))), x = u.newPath) : (c.push(...Vl(r, se.parent(u.newPath))), x = u.path);
        var y = Fe.get(t, se.parent(x)), C = ve.findKey(r, y), P = Y.pathRef(r, se.parent(x));
        p.push([P, C]);
        break;
      }
    }
    switch (o(u), u.type) {
      case "insert_node":
      case "remove_node":
      case "merge_node":
      case "move_node":
      case "split_node":
        tu.set(r, !0);
    }
    for (var [F, L] of c) {
      var [N] = Y.node(r, F);
      ym.set(N, L);
    }
    for (var [I, H] of p) {
      if (I.current) {
        var [V] = Y.node(r, I.current);
        ym.set(V, H);
      }
      I.unref();
    }
  }, r.setFragmentData = (u) => {
    var {
      selection: c
    } = r;
    if (c) {
      var [p, d] = de.edges(c), h = Y.void(r, {
        at: p.path
      }), f = Y.void(r, {
        at: d.path
      });
      if (!(de.isCollapsed(c) && !h)) {
        var m = ve.toDOMRange(r, c), g = m.cloneContents(), E = g.childNodes[0];
        if (g.childNodes.forEach((N) => {
          N.textContent && N.textContent.trim() !== "" && (E = N);
        }), f) {
          var [w] = f, M = m.cloneRange(), x = ve.toDOMNode(r, w);
          M.setEndAfter(x), g = M.cloneContents();
        }
        if (h && (E = g.querySelector("[data-slate-spacer]")), Array.from(g.querySelectorAll("[data-slate-zero-width]")).forEach((N) => {
          var I = N.getAttribute("data-slate-zero-width") === "n";
          N.textContent = I ? `
` : "";
        }), C5(E)) {
          var y = E.ownerDocument.createElement("span");
          y.style.whiteSpace = "pre", y.appendChild(E), g.appendChild(y), E = y;
        }
        var C = r.getFragment(), P = JSON.stringify(C), F = window.btoa(encodeURIComponent(P));
        E.setAttribute("data-slate-fragment", F), u.setData("application/".concat(n), F);
        var L = g.ownerDocument.createElement("div");
        return L.appendChild(g), L.setAttribute("hidden", "true"), g.ownerDocument.body.appendChild(L), u.setData("text/html", L.innerHTML), u.setData("text/plain", O5(L)), g.ownerDocument.body.removeChild(L), u;
      }
    }
  }, r.insertData = (u) => {
    r.insertFragmentData(u) || r.insertTextData(u);
  }, r.insertFragmentData = (u) => {
    var c = u.getData("application/".concat(n)) || zMe(u);
    if (c) {
      var p = decodeURIComponent(window.atob(c)), d = JSON.parse(p);
      return r.insertFragment(d), !0;
    }
    return !1;
  }, r.insertTextData = (u) => {
    var c = u.getData("text/plain");
    if (c) {
      var p = c.split(/\r\n|\r|\n/), d = !1;
      for (var h of p)
        d && Le.splitNodes(r, {
          always: !0
        }), r.insertText(h), d = !0;
      return !0;
    }
    return !1;
  }, r.onChange = (u) => {
    var c = h5 < 18 ? Rl.unstable_batchedUpdates : (p) => p();
    c(() => {
      var p = Rx.get(r);
      p && p(u), i(u);
    });
  }, r;
}, Vl = (e, t) => {
  var n = [];
  for (var [r, o] of Y.levels(e, {
    at: t
  })) {
    var i = ve.findKey(e, r);
    n.push([o, i]);
  }
  return n;
};
function A5(e, t, n = "type") {
  const { selection: r } = e;
  if (!r) return !1;
  const [o] = Array.from(
    Y.nodes(e, {
      at: Y.unhangRange(e, r),
      match: (i) => !Y.isEditor(i) && Je.isElement(i) && i[n] === t
    })
  );
  return !!o;
}
const Y2 = ["listItem", "numberedList"], Ih = ["left", "center", "right", "justify"];
function JDe(e, t) {
  const n = Ih.includes(t) ? "align" : "type", r = A5(e, t, n), o = Y2.includes(t);
  Le.unwrapNodes(e, {
    match: (a) => !Y.isEditor(a) && Je.isElement(a) && Y2.includes(a.type) && !Ih.includes(t),
    split: !0
  });
  let i;
  if (Ih.includes(t) ? i = { align: r ? void 0 : t } : i = {
    type: r ? "paragraph" : o ? "listItem" : t
  }, Le.setNodes(e, i), !r && o) {
    const a = { type: t, children: [] };
    Le.wrapNodes(e, a);
  }
}
function Wa({ format: e, icon: t }) {
  const n = Ny(), r = Ih.includes(e) ? "align" : "type", i = A5(n, e, r) ? "activeTrue" : "activeFalse";
  function a(s) {
    s.preventDefault(), JDe(n, e);
  }
  return /* @__PURE__ */ X.jsx(
    "button",
    {
      type: "button",
      className: "arkynRichTextBlockButton " + i,
      onMouseDown: a,
      children: /* @__PURE__ */ X.jsx(t, {})
    }
  );
}
function QDe({ attributes: e, children: t, element: n }) {
  const r = { textAlign: n.align };
  switch (n.type) {
    case "blockQuote":
      return /* @__PURE__ */ X.jsx(
        "blockquote",
        {
          className: "arkynElementBlockquote",
          style: r,
          ...e,
          children: t
        }
      );
    case "bulletedList":
      return /* @__PURE__ */ X.jsx("ul", { className: "arkynElementBulletList", style: r, ...e, children: t });
    case "headingOne":
      return /* @__PURE__ */ X.jsx("h1", { className: "arkynElementHeadingOne", style: r, ...e, children: t });
    case "headingTwo":
      return /* @__PURE__ */ X.jsx("h2", { className: "arkynElementHeadingTwo", style: r, ...e, children: t });
    case "listItem":
      return /* @__PURE__ */ X.jsx("li", { className: "arkynElementListItem", style: r, ...e, children: t });
    case "numberedList":
      return /* @__PURE__ */ X.jsx("ol", { className: "arkynElementNumberedList", style: r, ...e, children: t });
    case "image":
      return /* @__PURE__ */ X.jsxs("div", { style: r, ...e, children: [
        /* @__PURE__ */ X.jsx(
          "img",
          {
            className: "arkynElementImage",
            alt: "arkynElementImage",
            src: (n == null ? void 0 : n.src) || ""
          }
        ),
        t
      ] });
    default:
      return /* @__PURE__ */ X.jsx("p", { className: "arkynElementParagraph", style: r, ...e, children: t });
  }
}
const B5 = Ze({});
function eTe(e) {
  const {
    isVisibled: t,
    makeInvisible: n,
    children: r,
    className: o = "",
    ...i
  } = e, s = `arkynModalContainer ${t ? "visibleTrue" : "visibleFalse"} ${o}`;
  return /* @__PURE__ */ X.jsx(B5.Provider, { value: { makeInvisible: n }, children: /* @__PURE__ */ X.jsx(r$, { children: t && /* @__PURE__ */ X.jsxs("aside", { className: s.trim(), ...i, children: [
    /* @__PURE__ */ X.jsx(
      Gc.div,
      {
        className: "arkynModalContainerOverlay",
        transition: { duration: 0.15, ease: "easeOut" },
        initial: { opacity: 0 },
        animate: { opacity: 1 },
        exit: { opacity: 0 },
        onClick: n
      }
    ),
    /* @__PURE__ */ X.jsx(
      Gc.div,
      {
        className: "arkynModalContainerContent",
        transition: { duration: 0.15, ease: "easeOut" },
        initial: { opacity: 0, scale: 0.75 },
        animate: { opacity: 1, scale: 1 },
        exit: { opacity: 0, scale: 0 },
        children: r
      }
    )
  ] }) }) });
}
function tTe(e) {
  const { alignment: t = "right", className: n, ...r } = e, o = `arkynModalFooter ${t} ${n}`;
  return /* @__PURE__ */ X.jsx("footer", { className: o.trim(), ...r });
}
function nTe(e) {
  const {
    showCloseButton: t = !0,
    className: n,
    children: r,
    ...o
  } = e, { makeInvisible: i } = ye(B5), a = `arkynModalHeader ${n}`;
  return /* @__PURE__ */ X.jsxs("header", { className: a.trim(), ...o, children: [
    r,
    t && /* @__PURE__ */ X.jsx(
      "button",
      {
        type: "button",
        onClick: i,
        "aria-label": "Close modal button",
        className: "arkynModalHeaderCloseButton",
        children: /* @__PURE__ */ X.jsx(Qx, { size: 24 })
      }
    )
  ] });
}
const $x = Ze({});
function rTe() {
  if (!$x)
    throw new Error("useTabContext must be used within a TabProvider");
  return ye($x);
}
function oTe(e) {
  const {
    children: t,
    onClick: n,
    defaultActive: r,
    className: o,
    ...i
  } = e, [a, s] = k(r || ""), [l, u] = k(!0), c = rt(null), p = `arkynTabContainer ${o || ""}`, [d, h] = k({
    width: "0px",
    left: "0px",
    transition: "none"
  }), f = (g, E) => {
    const w = g.getBoundingClientRect(), M = c.current.getBoundingClientRect(), x = E ? void 0 : "none";
    u(!1), h({
      transition: x,
      width: `${w.width}px`,
      left: `${w.left - M.left}px`
    });
  };
  v(() => {
    const g = c.current;
    if (!g) return;
    let E = null;
    E = g.querySelector("button.activeTrue"), E && f(E);
  }, []);
  const m = (g) => {
    const E = g.target;
    E && (s(E.value), E.classList.add("activeTrue"), f(E, !0), n && n(E.value));
  };
  return /* @__PURE__ */ X.jsxs("nav", { ref: c, className: p.trim(), ...i, children: [
    /* @__PURE__ */ X.jsx($x.Provider, { value: { handleTabClick: m, showInitialTab: l, value: a }, children: t }),
    /* @__PURE__ */ X.jsx("div", { className: "activeLine", style: d })
  ] });
}
function J2(e) {
  const { children: t, className: n = "", onClick: r, ...o } = e, { value: i, showInitialTab: a, handleTabClick: s } = rTe(), l = i === o.value && i ? "activeTrue" : "activeFalse", c = `arkynTabButton ${i === o.value && a ? "showBorderBottom" : ""} ${l} ${n}`;
  function p(d) {
    s(d), r && r(d);
  }
  return /* @__PURE__ */ X.jsx(
    "button",
    {
      onClick: p,
      className: c.trim(),
      ...o,
      type: "button",
      children: t
    }
  );
}
function iTe(e) {
  const {
    action: t,
    tabLabels: n = ["Adicionar URL", "Upload de arquivo"],
    modalCancelButton: r = "Cancelar",
    modalConfirmButton: o = "Confirmar",
    modalInputImageLabel: i = "Imagem:",
    modalInputUrlLabel: a = "URL da imagem:",
    modalTitle: s = "Inserir imagem"
  } = e, l = Ny(), [u, c] = k(!1), [p, d] = k(""), [h, f] = k("url");
  function m(g) {
    g.preventDefault(), !(!p || p === "") && (l.insertNodes([
      { type: "paragraph", children: [{ text: "" }] },
      { type: "image", src: p, children: [{ text: "" }] },
      { type: "paragraph", children: [{ text: "" }] }
    ]), c(!1));
  }
  return /* @__PURE__ */ X.jsxs(X.Fragment, { children: [
    /* @__PURE__ */ X.jsx(
      "button",
      {
        type: "button",
        className: "arkynRichTextInsertImage",
        onMouseDown: () => c(!0),
        children: /* @__PURE__ */ X.jsx(q4, {})
      }
    ),
    /* @__PURE__ */ X.jsxs(
      eTe,
      {
        isVisibled: u,
        makeInvisible: () => c(!1),
        children: [
          /* @__PURE__ */ X.jsx(nTe, { children: s }),
          /* @__PURE__ */ X.jsxs("div", { className: "arkynRichTextInsertImageModalContent", children: [
            /* @__PURE__ */ X.jsxs(oTe, { defaultActive: h, onClick: f, children: [
              /* @__PURE__ */ X.jsx(J2, { value: "url", children: n[0] }),
              /* @__PURE__ */ X.jsx(J2, { value: "file", children: n[1] })
            ] }),
            h === "url" && /* @__PURE__ */ X.jsxs(X.Fragment, { children: [
              /* @__PURE__ */ X.jsxs(p2, { children: [
                /* @__PURE__ */ X.jsx(d2, { children: a }),
                /* @__PURE__ */ X.jsx(
                  By,
                  {
                    type: "text",
                    name: "richTextimageURL",
                    defaultValue: p,
                    onChange: (g) => d(g.target.value)
                  }
                )
              ] }),
              p && /* @__PURE__ */ X.jsx(
                "img",
                {
                  className: "arkynRichTextInsertImageModalPreviewImage",
                  src: p,
                  alt: "preview"
                }
              )
            ] }),
            h === "file" && /* @__PURE__ */ X.jsxs(p2, { children: [
              /* @__PURE__ */ X.jsx(d2, { children: i }),
              /* @__PURE__ */ X.jsx(
                sPe,
                {
                  name: "richTextimageURL",
                  action: t,
                  defaultValue: p,
                  onUpload: (g) => d(g || "")
                }
              )
            ] })
          ] }),
          /* @__PURE__ */ X.jsxs(tTe, { children: [
            /* @__PURE__ */ X.jsx(
              Ap,
              {
                type: "button",
                scheme: "danger",
                variant: "outline",
                onClick: () => c(!1),
                children: r
              }
            ),
            /* @__PURE__ */ X.jsx(Ap, { type: "button", onClick: m, children: o })
          ] })
        ]
      }
    )
  ] });
}
function sTe({ attributes: e, children: t, leaf: n }) {
  return n.bold && (t = /* @__PURE__ */ X.jsx("strong", { children: t })), n.code && (t = /* @__PURE__ */ X.jsx("code", { children: t })), n.italic && (t = /* @__PURE__ */ X.jsx("em", { children: t })), n.underline && (t = /* @__PURE__ */ X.jsx("u", { children: t })), /* @__PURE__ */ X.jsx("span", { ...e, children: t });
}
function I5(e, t) {
  const n = Y.marks(e);
  return n ? n[t] === !0 : !1;
}
function R5(e, t) {
  I5(e, t) ? Y.removeMark(e, t) : Y.addMark(e, t, !0);
}
function mh({ format: e, icon: t }) {
  const n = Ny(), o = I5(n, e) ? "activeTrue" : "activeFalse";
  function i(a) {
    a.preventDefault(), R5(n, e);
  }
  return /* @__PURE__ */ X.jsx(
    "button",
    {
      type: "button",
      className: "arkynRichTextMarkButton " + o,
      onMouseDown: i,
      children: /* @__PURE__ */ X.jsx(t, {})
    }
  );
}
function aTe({ children: e }) {
  return /* @__PURE__ */ X.jsx("div", { className: "arkynRichTextToolbar", children: e });
}
function Q2(e) {
  return e.map((t) => Fe.string(t)).join("");
}
const ez = {
  "mod+b": "bold",
  "mod+i": "italic",
  "mod+u": "underline",
  "mod+`": "code"
}, vh = [
  {
    type: "paragraph",
    children: [{ text: "" }]
  }
];
function SRe(e) {
  const {
    name: t,
    hiddenButtons: n,
    imageConfig: r,
    defaultValue: o = "[]",
    enforceCharacterLimit: i = !1,
    onChangeCharactersCount: a,
    maxLimit: s = 2e3,
    onChange: l,
    isError: u
  } = e, c = Tn(() => $Pe(YDe($Z())), []), { id: p, inputRef: d, error: h } = Po(), f = rt(null);
  function m() {
    try {
      const J = JSON.parse(o);
      return !Array.isArray(J) || J.length <= 0 ? vh : J.every(
        (ee) => typeof ee == "object" && ee !== null && "type" in ee && "children" in ee
      ) ? J : vh;
    } catch {
      return vh;
    }
  }
  const g = Q2(m()), [E, w] = k(g.length), [M, x] = k(
    JSON.stringify(m()) || "[]"
  ), [y, C] = k(!1), P = d || f, F = u || !!h, L = En(sTe, []), N = En(QDe, []);
  function I(J) {
    const te = Q2(J);
    w(te.length), a && a(te.length), !(i && te.length >= s) && (x(JSON.stringify(J)), l && l(J), c.children = J, Le.setNodes(c, { children: J }));
  }
  const H = y ? "focusTrue" : "focusFalse", z = `arkynRichText ${F || s < E ? "errorTrue" : "errorFalse"} ${H}`, q = s - E;
  function K(J) {
    return !(n != null && n.includes(J));
  }
  return /* @__PURE__ */ X.jsxs(
    XDe,
    {
      editor: c,
      initialValue: m(),
      onChange: I,
      onValueChange: I,
      children: [
        /* @__PURE__ */ X.jsxs("div", { className: z, children: [
          /* @__PURE__ */ X.jsxs(aTe, { children: [
            K("headingOne") && /* @__PURE__ */ X.jsx(Wa, { format: "headingOne", icon: Z4 }),
            K("headingTwo") && /* @__PURE__ */ X.jsx(Wa, { format: "headingTwo", icon: G4 }),
            K("blockQuote") && /* @__PURE__ */ X.jsx(Wa, { format: "blockQuote", icon: X4 }),
            K("bold") && /* @__PURE__ */ X.jsx(mh, { format: "bold", icon: K4 }),
            K("italic") && /* @__PURE__ */ X.jsx(mh, { format: "italic", icon: Y4 }),
            K("underline") && /* @__PURE__ */ X.jsx(mh, { format: "underline", icon: J4 }),
            K("code") && /* @__PURE__ */ X.jsx(mh, { format: "code", icon: Q4 }),
            K("left") && /* @__PURE__ */ X.jsx(Wa, { format: "left", icon: e7 }),
            K("right") && /* @__PURE__ */ X.jsx(Wa, { format: "right", icon: t7 }),
            K("center") && /* @__PURE__ */ X.jsx(Wa, { format: "center", icon: n7 }),
            K("justify") && /* @__PURE__ */ X.jsx(Wa, { format: "justify", icon: r7 }),
            r && K("image") && /* @__PURE__ */ X.jsx(iTe, { ...r })
          ] }),
          /* @__PURE__ */ X.jsx(
            zDe,
            {
              className: "editorContainer",
              renderElement: N,
              renderLeaf: L,
              spellCheck: !0,
              id: p,
              onFocus: () => C(!0),
              onBlur: () => C(!1),
              onKeyDown: (J) => {
                for (const te in ez)
                  if (zPe(te, J)) {
                    J.preventDefault();
                    const ee = ez[te];
                    R5(c, ee);
                  }
              }
            }
          ),
          q < 0 && /* @__PURE__ */ X.jsx("div", { className: "restatesCharacters", children: q })
        ] }),
        /* @__PURE__ */ X.jsx("input", { type: "hidden", ref: P, name: t, value: M }),
        /* @__PURE__ */ X.jsx("input", { type: "hidden", name: `${t}Count`, value: E })
      ]
    }
  );
}
function lTe(e, t) {
  const {
    isLoading: n,
    isError: r,
    size: o = "md",
    className: i = "",
    variant: a = "solid",
    prefix: s,
    leftIcon: l,
    disabled: u,
    readOnly: c,
    onFocus: p,
    onBlur: d,
    title: h,
    style: f,
    closeOnSelect: m = !0,
    ...g
  } = e, y = `arkyn_select ${s ? "hasPrefix" : ""} ${a} ${o} ${u || c || n ? "opacity" : ""} ${r ? "errored" : ""} ${t ? "focused" : ""} ${i}`, P = { md: 20, lg: 20 }[o];
  return {
    isLoading: n,
    className: y,
    prefix: R$(s, P, "prefix"),
    LeftIcon: l,
    disabled: u || n || c,
    onFocus: p,
    onBlur: d,
    title: h,
    closeOnSelect: m,
    style: f,
    iconSize: P,
    Spinner: /* @__PURE__ */ X.jsx(Gi, { className: "spinner", size: P, strokeWidth: 2.5 }),
    ...g
  };
}
function MRe(e) {
  var U;
  const [t, n] = k(""), [r, o] = k(!1), { inputRef: i, id: a, error: s } = Po(), l = rt(null), u = i || l, c = e.isError || !!s, {
    disabled: p,
    title: d,
    style: h,
    className: f,
    prefix: m,
    iconSize: g,
    isLoading: E,
    LeftIcon: w,
    value: M = null,
    defaultValue: x = "",
    onFocus: y,
    onBlur: C,
    Spinner: P,
    name: F,
    placeholder: L,
    onSelect: N,
    options: I,
    optionMaxHeight: H,
    closeOnSelect: V,
    isSearchable: z,
    onSearch: q,
    ...K
  } = lTe({ ...e, id: a, isError: c }, r), [J, te] = k(x);
  function ee() {
    p || !(u != null && u.current) || r || (o(!0), u.current.focus());
  }
  function _(j) {
    q && (n(""), q(j.target.value)), q || n(j.target.value);
  }
  function D(j) {
    r || (o(!0), y && y(j));
  }
  function $() {
    o(!1), C && u.current && u.current.blur();
  }
  function S(j) {
    const { label: Z, value: A } = j;
    te(J !== A ? A : ""), N && N({ label: Z, value: A }), V && $();
  }
  const W = typeof M == "string" ? M : J, O = ((U = I.find((j) => j.value === W)) == null ? void 0 : U.label) || "", T = () => {
    if (!r && O) return !0;
    if (!r && !O) return !1;
    if (r && O) return !0;
    if (r && !O) return !1;
  };
  return /* @__PURE__ */ X.jsxs(X.Fragment, { children: [
    /* @__PURE__ */ X.jsxs(
      "section",
      {
        title: d,
        style: h,
        onClick: ee,
        className: `${f} placeholder_dark_${T()}`,
        children: [
          m,
          w && /* @__PURE__ */ X.jsx(w, { size: g, strokeWidth: 2.5 }),
          /* @__PURE__ */ X.jsx(
            "input",
            {
              disabled: p,
              readOnly: !0,
              placeholder: O || L,
              onFocus: D,
              ...K
            }
          ),
          /* @__PURE__ */ X.jsx(
            "input",
            {
              type: "hidden",
              ref: u,
              name: F,
              value: W || "",
              readOnly: !0
            }
          ),
          r && /* @__PURE__ */ X.jsxs(
            "div",
            {
              className: "arkyn_select_content",
              style: { overflow: "auto", maxHeight: H },
              children: [
                z && /* @__PURE__ */ X.jsx(
                  By,
                  {
                    type: "search",
                    name: "search-select",
                    variant: "underline",
                    leftIcon: e$,
                    onChange: _
                  }
                ),
                I.filter((j) => !!(e.onSearch || !e.isSearchable || j.label.toLowerCase().includes(t.toLowerCase()))).map(({ label: j, value: Z }) => /* @__PURE__ */ X.jsxs(
                  "div",
                  {
                    onClick: () => S({ label: j, value: Z }),
                    className: W === Z ? "arkyn_select_option active" : "arkyn_select_option",
                    children: [
                      j,
                      " ",
                      /* @__PURE__ */ X.jsx(Mm, {})
                    ]
                  },
                  Z
                )),
                I.length <= 0 && /* @__PURE__ */ X.jsx("p", { children: "Sem opes disponveis" })
              ]
            }
          ),
          !E && /* @__PURE__ */ X.jsx(
            Jx,
            {
              className: "arkyn_select_arrow",
              size: g,
              strokeWidth: 2.5
            }
          ),
          E && P
        ]
      }
    ),
    r && /* @__PURE__ */ X.jsx("aside", { className: "arkyn_select_overlay", onClick: $ })
  ] });
}
function DRe(e) {
  const {
    size: t = "lg",
    defaultChecked: n = !1,
    checked: r = null,
    value: o,
    unCheckedValue: i = "",
    name: a,
    className: s = "",
    onCheck: l,
    ...u
  } = e, [c, p] = k(n), { id: d, inputRef: h } = Po(), f = typeof r == "boolean" ? r : c;
  function m() {
    p(!c), l && l(f ? i : o || "checked");
  }
  const E = `arkynSwitch ${f ? "checkedTrue" : "checkedFalse"} ${t} ${s}`;
  return /* @__PURE__ */ X.jsx("button", { type: "button", onClick: m, className: E, ...u, children: /* @__PURE__ */ X.jsx(
    "input",
    {
      id: d,
      type: "hidden",
      name: a,
      ref: h,
      onClick: m,
      value: f ? o || "checked" : i
    }
  ) });
}
function TRe(e) {
  const {
    variant: t = "solid",
    size: n = "md",
    className: r,
    disabled: o = !1,
    readOnly: i = !1,
    onFocus: a,
    onBlur: s,
    title: l,
    style: u,
    ...c
  } = e, [p, d] = k(!1), { inputRef: h, id: f, error: m } = Po(), g = rt(null), E = h || g, M = e.isError || !!m ? "errorTrue" : "errorFalse", C = `arkynTextarea ${t} ${n} ${o || i ? "opacityTrue" : "opacityFalse"} ${M} ${p ? "focusedTrue" : "focusedFalse"} ${r}`;
  function P() {
    o || !(E != null && E.current) || (d(!0), E.current.focus());
  }
  function F(N) {
    d(!0), a && a(N);
  }
  function L(N) {
    d(!1), s && s(N);
  }
  return /* @__PURE__ */ X.jsx(
    "section",
    {
      title: l,
      style: u,
      onClick: P,
      className: C,
      children: /* @__PURE__ */ X.jsx(
        "textarea",
        {
          id: f,
          disabled: o,
          readOnly: i,
          ref: E,
          onFocus: F,
          onBlur: L,
          ...c
        }
      )
    }
  );
}
function jRe(e) {
  const { className: t = "", ...n } = e, r = `arkynBreadcrumbContainer ${t}`;
  return /* @__PURE__ */ X.jsx("nav", { className: r, ...n });
}
function ARe(e) {
  const { pathname: t } = nO(), {
    className: n = "",
    disabled: r = !1,
    children: o,
    to: i,
    ...a
  } = e, l = `arkynBreadcrumbLink ${t === i ? "active" : "inactive"} ${n}`;
  return r ? /* @__PURE__ */ X.jsxs("p", { className: l, children: [
    /* @__PURE__ */ X.jsx(Fw, { size: 14, strokeWidth: 2.5 }),
    o
  ] }) : /* @__PURE__ */ X.jsxs(s7, { to: i, className: l, ...a, children: [
    /* @__PURE__ */ X.jsx(Fw, { size: 14, strokeWidth: 2.5 }),
    o
  ] });
}
function N5(e = "") {
  const t = nO(), n = new URLSearchParams(t.search), r = e ? `${e}:` : "", o = (i) => {
    Object.entries(i).forEach(([a, s]) => {
      s === void 0 ? n.delete(`${r}${a}`) : n.set(`${r}${a}`, String(s));
    });
  };
  return {
    getParam: (i) => n.get(`${r}${i}`),
    getScopedSearch: (i) => {
      o(i);
      let a = n.toString();
      return a && (a = "?" + a), a;
    }
  };
}
function tz(e, t) {
  return [...new Array(t - e)].map((n, r) => e + r + 1).filter((n) => n > 0);
}
function BRe(e) {
  const {
    scope: t,
    totalCountRegisters: n,
    perPageKey: r = "per_page",
    pageKey: o = "page",
    siblingsCount: i = 2,
    currentPage: a = 1,
    registerPerPage: s = 20,
    ...l
  } = e, u = n$(), { getParam: c, getScopedSearch: p } = N5(t), d = Number(c("page")) || a, h = Number(c("per_page")) || s, f = Math.ceil(n / h), m = d > 1 ? tz(d - 1 - i, d - 1) : [], g = d < f ? tz(
    d,
    Math.min(d + i, f)
  ) : [];
  function E(w) {
    u(p({ page: w }));
  }
  return /* @__PURE__ */ X.jsxs("div", { className: "arkynPagination", ...l, children: [
    /* @__PURE__ */ X.jsx(
      "button",
      {
        className: "arkynPaginationIconButton",
        disabled: d <= 1,
        onClick: () => E(d - 1),
        children: /* @__PURE__ */ X.jsx(o7, {})
      }
    ),
    d > 1 + i && /* @__PURE__ */ X.jsxs(X.Fragment, { children: [
      /* @__PURE__ */ X.jsx(
        "button",
        {
          className: "arkynPaginationPageButton",
          onClick: () => E(1),
          children: "1"
        }
      ),
      d > 2 + i && /* @__PURE__ */ X.jsx("button", { disabled: !0, className: "arkynPaginationSpread", children: /* @__PURE__ */ X.jsx(N1, {}) })
    ] }),
    m.length > 0 && m.map((w, M) => /* @__PURE__ */ X.jsx(
      "button",
      {
        onClick: () => E(w),
        className: "arkynPaginationPageButton",
        children: w
      },
      M
    )),
    /* @__PURE__ */ X.jsx("button", { className: "arkynPaginationCurrent", disabled: !0, children: d }),
    g.length > 0 && g.map((w, M) => /* @__PURE__ */ X.jsx(
      "button",
      {
        onClick: () => E(w),
        className: "arkynPaginationPageButton",
        children: w
      },
      M
    )),
    d + i < f && /* @__PURE__ */ X.jsxs(X.Fragment, { children: [
      d + 1 + i < f && /* @__PURE__ */ X.jsx("button", { disabled: !0, className: "arkynPaginationSpread", children: /* @__PURE__ */ X.jsx(N1, {}) }),
      /* @__PURE__ */ X.jsx(
        "button",
        {
          className: "arkynPaginationPageButton",
          onClick: () => E(f),
          children: f
        }
      )
    ] }),
    /* @__PURE__ */ X.jsx(
      "button",
      {
        className: "arkynPaginationIconButton",
        disabled: d >= f,
        onClick: () => E(d + 1),
        children: /* @__PURE__ */ X.jsx(Fw, {})
      }
    )
  ] });
}
const F5 = Ze({});
function IRe(e) {
  const {
    isVisibled: t,
    makeInvisible: n,
    orientation: r = "left",
    children: o,
    className: i,
    ...a
  } = e, s = r === "left" ? "-100%" : "100%", u = `arkynDrawerContainer ${r} ${t ? "visibleTrue" : "visibleFalse"} ${i}`;
  return /* @__PURE__ */ X.jsx(F5.Provider, { value: { makeInvisible: n }, children: /* @__PURE__ */ X.jsx(r$, { children: t && /* @__PURE__ */ X.jsxs("aside", { className: u.trim(), ...a, children: [
    /* @__PURE__ */ X.jsx(
      Gc.div,
      {
        className: "arkynDrawerContainerOverlay",
        transition: { duration: 0.15, ease: "easeOut" },
        initial: { opacity: 0 },
        animate: { opacity: 1 },
        exit: { opacity: 0 },
        onClick: n
      }
    ),
    /* @__PURE__ */ X.jsx(
      Gc.div,
      {
        className: "arkynDrawerContainerContent",
        transition: { ease: "easeOut", duration: 0.15 },
        initial: { transform: `translateX(${s})` },
        animate: { transform: "translateX(0px)" },
        exit: { transform: `translateX(${s})` },
        children: o
      }
    )
  ] }) }) });
}
function RRe(e) {
  const {
    showCloseButton: t = !0,
    className: n,
    children: r,
    ...o
  } = e, { makeInvisible: i } = ye(F5), a = `arkynDrawerHeader ${n}`;
  return /* @__PURE__ */ X.jsxs("header", { className: a.trim(), ...o, children: [
    r,
    t && /* @__PURE__ */ X.jsx(
      "button",
      {
        className: "arkynDrawerHeaderCloseButton",
        type: "button",
        onClick: i,
        "aria-label": "Close drawer",
        children: /* @__PURE__ */ X.jsx(Qx, { size: 24 })
      }
    )
  ] });
}
function NRe(e) {
  const {
    children: t,
    button: n,
    closeOnClick: r,
    className: o = "",
    orientation: i = "bottomLeft"
  } = e, [a, s] = k(!1), u = `arkynPopover ${i} ${a ? "visibleTrue" : "visibleFalse"} ${o}`;
  function c() {
    a || s(!0);
  }
  return /* @__PURE__ */ X.jsxs("div", { className: u, onClick: c, children: [
    n,
    /* @__PURE__ */ X.jsx(
      Gc.div,
      {
        style: { visibility: a ? "visible" : "hidden" },
        transition: { ease: "easeOut", duration: 0 },
        initial: { opacity: 0 },
        animate: { opacity: a ? 1 : 0 },
        exit: { opacity: 0 },
        onClick: () => r && s(!1),
        className: "arkynPopoverContent",
        children: t
      }
    ),
    a && /* @__PURE__ */ X.jsx("div", { onClick: () => s(!1), className: "arkynPopoverOverlay" })
  ] });
}
function FRe(e) {
  const { message: t, type: n } = e, r = `arkynToast ${n}}`;
  function o() {
    switch (n) {
      case "success":
        return /* @__PURE__ */ X.jsx(QU, {});
      case "danger":
        return /* @__PURE__ */ X.jsx(JU, {});
      default:
        return /* @__PURE__ */ X.jsx(YU, {});
    }
  }
  return /* @__PURE__ */ X.jsxs("div", { className: r, children: [
    /* @__PURE__ */ X.jsxs("div", { children: [
      /* @__PURE__ */ X.jsx("div", { className: "bg" }),
      /* @__PURE__ */ X.jsx(o, {})
    ] }),
    /* @__PURE__ */ X.jsx("p", { children: /* @__PURE__ */ X.jsx("span", { children: t }) })
  ] });
}
var Wr = {}, k1 = {}, Cd = {}, xd = {}, z5 = "Expected a function", nz = NaN, uTe = "[object Symbol]", cTe = /^\s+|\s+$/g, pTe = /^[-+]0x[0-9a-f]+$/i, dTe = /^0b[01]+$/i, fTe = /^0o[0-7]+$/i, hTe = parseInt, gTe = typeof Nn == "object" && Nn && Nn.Object === Object && Nn, mTe = typeof self == "object" && self && self.Object === Object && self, vTe = gTe || mTe || Function("return this")(), yTe = Object.prototype, bTe = yTe.toString, wTe = Math.max, CTe = Math.min, Ow = function() {
  return vTe.Date.now();
};
function xTe(e, t, n) {
  var r, o, i, a, s, l, u = 0, c = !1, p = !1, d = !0;
  if (typeof e != "function")
    throw new TypeError(z5);
  t = rz(t) || 0, bm(n) && (c = !!n.leading, p = "maxWait" in n, i = p ? wTe(rz(n.maxWait) || 0, t) : i, d = "trailing" in n ? !!n.trailing : d);
  function h(C) {
    var P = r, F = o;
    return r = o = void 0, u = C, a = e.apply(F, P), a;
  }
  function f(C) {
    return u = C, s = setTimeout(E, t), c ? h(C) : a;
  }
  function m(C) {
    var P = C - l, F = C - u, L = t - P;
    return p ? CTe(L, i - F) : L;
  }
  function g(C) {
    var P = C - l, F = C - u;
    return l === void 0 || P >= t || P < 0 || p && F >= i;
  }
  function E() {
    var C = Ow();
    if (g(C))
      return w(C);
    s = setTimeout(E, m(C));
  }
  function w(C) {
    return s = void 0, d && r ? h(C) : (r = o = void 0, a);
  }
  function M() {
    s !== void 0 && clearTimeout(s), u = 0, r = l = o = s = void 0;
  }
  function x() {
    return s === void 0 ? a : w(Ow());
  }
  function y() {
    var C = Ow(), P = g(C);
    if (r = arguments, o = this, l = C, P) {
      if (s === void 0)
        return f(l);
      if (p)
        return s = setTimeout(E, t), h(l);
    }
    return s === void 0 && (s = setTimeout(E, t)), a;
  }
  return y.cancel = M, y.flush = x, y;
}
function OTe(e, t, n) {
  var r = !0, o = !0;
  if (typeof e != "function")
    throw new TypeError(z5);
  return bm(n) && (r = "leading" in n ? !!n.leading : r, o = "trailing" in n ? !!n.trailing : o), xTe(e, t, {
    leading: r,
    maxWait: t,
    trailing: o
  });
}
function bm(e) {
  var t = typeof e;
  return !!e && (t == "object" || t == "function");
}
function ETe(e) {
  return !!e && typeof e == "object";
}
function kTe(e) {
  return typeof e == "symbol" || ETe(e) && bTe.call(e) == uTe;
}
function rz(e) {
  if (typeof e == "number")
    return e;
  if (kTe(e))
    return nz;
  if (bm(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = bm(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = e.replace(cTe, "");
  var n = dTe.test(e);
  return n || fTe.test(e) ? hTe(e.slice(2), n ? 2 : 8) : pTe.test(e) ? nz : +e;
}
var LTe = OTe, Od = {};
Object.defineProperty(Od, "__esModule", {
  value: !0
});
Od.addPassiveEventListener = function(t, n, r) {
  var o = r.name;
  o || (o = n, console.warn("Listener must be a named function.")), Rh.has(n) || Rh.set(n, /* @__PURE__ */ new Set());
  var i = Rh.get(n);
  if (!i.has(o)) {
    var a = function() {
      var s = !1;
      try {
        var l = Object.defineProperty({}, "passive", {
          get: function() {
            s = !0;
          }
        });
        window.addEventListener("test", null, l);
      } catch {
      }
      return s;
    }();
    t.addEventListener(n, r, a ? { passive: !0 } : !1), i.add(o);
  }
};
Od.removePassiveEventListener = function(t, n, r) {
  t.removeEventListener(n, r), Rh.get(n).delete(r.name || n);
};
var Rh = /* @__PURE__ */ new Map();
Object.defineProperty(xd, "__esModule", {
  value: !0
});
var _Te = LTe, PTe = STe(_Te), oz = Od;
function STe(e) {
  return e && e.__esModule ? e : { default: e };
}
var MTe = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 66;
  return (0, PTe.default)(t, n);
}, _r = {
  spyCallbacks: [],
  spySetState: [],
  scrollSpyContainers: [],
  mount: function(t, n) {
    if (t) {
      var r = MTe(function(o) {
        _r.scrollHandler(t);
      }, n);
      return _r.scrollSpyContainers.push(t), (0, oz.addPassiveEventListener)(t, "scroll", r), function() {
        (0, oz.removePassiveEventListener)(t, "scroll", r), _r.scrollSpyContainers.splice(_r.scrollSpyContainers.indexOf(t), 1);
      };
    }
    return function() {
    };
  },
  isMounted: function(t) {
    return _r.scrollSpyContainers.indexOf(t) !== -1;
  },
  currentPositionX: function(t) {
    if (t === document) {
      var n = window.scrollY !== void 0, r = (document.compatMode || "") === "CSS1Compat";
      return n ? window.scrollX : r ? document.documentElement.scrollLeft : document.body.scrollLeft;
    } else
      return t.scrollLeft;
  },
  currentPositionY: function(t) {
    if (t === document) {
      var n = window.scrollX !== void 0, r = (document.compatMode || "") === "CSS1Compat";
      return n ? window.scrollY : r ? document.documentElement.scrollTop : document.body.scrollTop;
    } else
      return t.scrollTop;
  },
  scrollHandler: function(t) {
    var n = _r.scrollSpyContainers[_r.scrollSpyContainers.indexOf(t)].spyCallbacks || [];
    n.forEach(function(r) {
      return r(_r.currentPositionX(t), _r.currentPositionY(t));
    });
  },
  addStateHandler: function(t) {
    _r.spySetState.push(t);
  },
  addSpyHandler: function(t, n) {
    var r = _r.scrollSpyContainers[_r.scrollSpyContainers.indexOf(n)];
    r.spyCallbacks || (r.spyCallbacks = []), r.spyCallbacks.push(t);
  },
  updateStates: function() {
    _r.spySetState.forEach(function(t) {
      return t();
    });
  },
  unmount: function(t, n) {
    _r.scrollSpyContainers.forEach(function(r) {
      return r.spyCallbacks && r.spyCallbacks.length && r.spyCallbacks.indexOf(n) > -1 && r.spyCallbacks.splice(r.spyCallbacks.indexOf(n), 1);
    }), _r.spySetState && _r.spySetState.length && _r.spySetState.indexOf(t) > -1 && _r.spySetState.splice(_r.spySetState.indexOf(t), 1), document.removeEventListener("scroll", _r.scrollHandler);
  },
  update: function() {
    return _r.scrollSpyContainers.forEach(function(t) {
      return _r.scrollHandler(t);
    });
  }
};
xd.default = _r;
var Pu = {}, Ed = {};
Object.defineProperty(Ed, "__esModule", {
  value: !0
});
var DTe = function(t, n) {
  var r = t.indexOf("#") === 0 ? t.substring(1) : t, o = r ? "#" + r : "", i = window && window.location, a = o ? i.pathname + i.search + o : i.pathname + i.search;
  n ? history.pushState(history.state, "", a) : history.replaceState(history.state, "", a);
}, TTe = function() {
  return window.location.hash.replace(/^#/, "");
}, jTe = function(t) {
  return function(n) {
    return t.contains ? t != n && t.contains(n) : !!(t.compareDocumentPosition(n) & 16);
  };
}, ATe = function(t) {
  return getComputedStyle(t).position !== "static";
}, Ew = function(t, n) {
  for (var r = t.offsetTop, o = t.offsetParent; o && !n(o); )
    r += o.offsetTop, o = o.offsetParent;
  return { offsetTop: r, offsetParent: o };
}, BTe = function(t, n, r) {
  if (r)
    return t === document ? n.getBoundingClientRect().left + (window.scrollX || window.pageXOffset) : getComputedStyle(t).position !== "static" ? n.offsetLeft : n.offsetLeft - t.offsetLeft;
  if (t === document)
    return n.getBoundingClientRect().top + (window.scrollY || window.pageYOffset);
  if (ATe(t)) {
    if (n.offsetParent !== t) {
      var o = function(c) {
        return c === t || c === document;
      }, i = Ew(n, o), a = i.offsetTop, s = i.offsetParent;
      if (s !== t)
        throw new Error("Seems containerElement is not an ancestor of the Element");
      return a;
    }
    return n.offsetTop;
  }
  if (n.offsetParent === t.offsetParent)
    return n.offsetTop - t.offsetTop;
  var l = function(c) {
    return c === document;
  };
  return Ew(n, l).offsetTop - Ew(t, l).offsetTop;
};
Ed.default = {
  updateHash: DTe,
  getHash: TTe,
  filterElementInContainer: jTe,
  scrollOffset: BTe
};
var Fy = {}, L1 = {};
Object.defineProperty(L1, "__esModule", {
  value: !0
});
L1.default = {
  /*
   * https://github.com/oblador/angular-scroll (duScrollDefaultEasing)
   */
  defaultEasing: function(t) {
    return t < 0.5 ? Math.pow(t * 2, 2) / 2 : 1 - Math.pow((1 - t) * 2, 2) / 2;
  },
  /*
   * https://gist.github.com/gre/1650294
   */
  // no easing, no acceleration
  linear: function(t) {
    return t;
  },
  // accelerating from zero velocity
  easeInQuad: function(t) {
    return t * t;
  },
  // decelerating to zero velocity
  easeOutQuad: function(t) {
    return t * (2 - t);
  },
  // acceleration until halfway, then deceleration
  easeInOutQuad: function(t) {
    return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
  },
  // accelerating from zero velocity 
  easeInCubic: function(t) {
    return t * t * t;
  },
  // decelerating to zero velocity 
  easeOutCubic: function(t) {
    return --t * t * t + 1;
  },
  // acceleration until halfway, then deceleration 
  easeInOutCubic: function(t) {
    return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
  },
  // accelerating from zero velocity 
  easeInQuart: function(t) {
    return t * t * t * t;
  },
  // decelerating to zero velocity 
  easeOutQuart: function(t) {
    return 1 - --t * t * t * t;
  },
  // acceleration until halfway, then deceleration
  easeInOutQuart: function(t) {
    return t < 0.5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t;
  },
  // accelerating from zero velocity
  easeInQuint: function(t) {
    return t * t * t * t * t;
  },
  // decelerating to zero velocity
  easeOutQuint: function(t) {
    return 1 + --t * t * t * t * t;
  },
  // acceleration until halfway, then deceleration 
  easeInOutQuint: function(t) {
    return t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t;
  }
};
var _1 = {};
Object.defineProperty(_1, "__esModule", {
  value: !0
});
var ITe = Od, RTe = ["mousedown", "wheel", "touchmove", "keydown"];
_1.default = {
  subscribe: function(t) {
    return typeof document < "u" && RTe.forEach(function(n) {
      return (0, ITe.addPassiveEventListener)(document, n, t);
    });
  }
};
var kd = {};
Object.defineProperty(kd, "__esModule", {
  value: !0
});
var Hx = {
  registered: {},
  scrollEvent: {
    register: function(t, n) {
      Hx.registered[t] = n;
    },
    remove: function(t) {
      Hx.registered[t] = null;
    }
  }
};
kd.default = Hx;
Object.defineProperty(Fy, "__esModule", {
  value: !0
});
var NTe = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, FTe = Ed;
zy(FTe);
var zTe = L1, iz = zy(zTe), UTe = _1, $Te = zy(UTe), HTe = kd, $i = zy(HTe);
function zy(e) {
  return e && e.__esModule ? e : { default: e };
}
var U5 = function(t) {
  return iz.default[t.smooth] || iz.default.defaultEasing;
}, WTe = function(t) {
  return typeof t == "function" ? t : function() {
    return t;
  };
}, VTe = function() {
  if (typeof window < "u")
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame;
}, Wx = function() {
  return VTe() || function(e, t, n) {
    window.setTimeout(e, n || 1e3 / 60, (/* @__PURE__ */ new Date()).getTime());
  };
}(), $5 = function() {
  return {
    currentPosition: 0,
    startPosition: 0,
    targetPosition: 0,
    progress: 0,
    duration: 0,
    cancel: !1,
    target: null,
    containerElement: null,
    to: null,
    start: null,
    delta: null,
    percent: null,
    delayTimeout: null
  };
}, H5 = function(t) {
  var n = t.data.containerElement;
  if (n && n !== document && n !== document.body)
    return n.scrollLeft;
  var r = window.pageXOffset !== void 0, o = (document.compatMode || "") === "CSS1Compat";
  return r ? window.pageXOffset : o ? document.documentElement.scrollLeft : document.body.scrollLeft;
}, W5 = function(t) {
  var n = t.data.containerElement;
  if (n && n !== document && n !== document.body)
    return n.scrollTop;
  var r = window.pageXOffset !== void 0, o = (document.compatMode || "") === "CSS1Compat";
  return r ? window.pageYOffset : o ? document.documentElement.scrollTop : document.body.scrollTop;
}, qTe = function(t) {
  var n = t.data.containerElement;
  if (n && n !== document && n !== document.body)
    return n.scrollWidth - n.offsetWidth;
  var r = document.body, o = document.documentElement;
  return Math.max(r.scrollWidth, r.offsetWidth, o.clientWidth, o.scrollWidth, o.offsetWidth);
}, ZTe = function(t) {
  var n = t.data.containerElement;
  if (n && n !== document && n !== document.body)
    return n.scrollHeight - n.offsetHeight;
  var r = document.body, o = document.documentElement;
  return Math.max(r.scrollHeight, r.offsetHeight, o.clientHeight, o.scrollHeight, o.offsetHeight);
}, GTe = function e(t, n, r) {
  var o = n.data;
  if (!n.ignoreCancelEvents && o.cancel) {
    $i.default.registered.end && $i.default.registered.end(o.to, o.target, o.currentPositionY);
    return;
  }
  if (o.delta = Math.round(o.targetPosition - o.startPosition), o.start === null && (o.start = r), o.progress = r - o.start, o.percent = o.progress >= o.duration ? 1 : t(o.progress / o.duration), o.currentPosition = o.startPosition + Math.ceil(o.delta * o.percent), o.containerElement && o.containerElement !== document && o.containerElement !== document.body ? n.horizontal ? o.containerElement.scrollLeft = o.currentPosition : o.containerElement.scrollTop = o.currentPosition : n.horizontal ? window.scrollTo(o.currentPosition, 0) : window.scrollTo(0, o.currentPosition), o.percent < 1) {
    var i = e.bind(null, t, n);
    Wx.call(window, i);
    return;
  }
  $i.default.registered.end && $i.default.registered.end(o.to, o.target, o.currentPosition);
}, P1 = function(t) {
  t.data.containerElement = t ? t.containerId ? document.getElementById(t.containerId) : t.container && t.container.nodeType ? t.container : document : null;
}, Ld = function(t, n, r, o) {
  n.data = n.data || $5(), window.clearTimeout(n.data.delayTimeout);
  var i = function() {
    n.data.cancel = !0;
  };
  if ($Te.default.subscribe(i), P1(n), n.data.start = null, n.data.cancel = !1, n.data.startPosition = n.horizontal ? H5(n) : W5(n), n.data.targetPosition = n.absolute ? t : t + n.data.startPosition, n.data.startPosition === n.data.targetPosition) {
    $i.default.registered.end && $i.default.registered.end(n.data.to, n.data.target, n.data.currentPosition);
    return;
  }
  n.data.delta = Math.round(n.data.targetPosition - n.data.startPosition), n.data.duration = WTe(n.duration)(n.data.delta), n.data.duration = isNaN(parseFloat(n.data.duration)) ? 1e3 : parseFloat(n.data.duration), n.data.to = r, n.data.target = o;
  var a = U5(n), s = GTe.bind(null, a, n);
  if (n && n.delay > 0) {
    n.data.delayTimeout = window.setTimeout(function() {
      $i.default.registered.begin && $i.default.registered.begin(n.data.to, n.data.target), Wx.call(window, s);
    }, n.delay);
    return;
  }
  $i.default.registered.begin && $i.default.registered.begin(n.data.to, n.data.target), Wx.call(window, s);
}, Uy = function(t) {
  return t = NTe({}, t), t.data = t.data || $5(), t.absolute = !0, t;
}, XTe = function(t) {
  Ld(0, Uy(t));
}, KTe = function(t, n) {
  Ld(t, Uy(n));
}, YTe = function(t) {
  t = Uy(t), P1(t), Ld(t.horizontal ? qTe(t) : ZTe(t), t);
}, JTe = function(t, n) {
  n = Uy(n), P1(n);
  var r = n.horizontal ? H5(n) : W5(n);
  Ld(t + r, n);
};
Fy.default = {
  animateTopScroll: Ld,
  getAnimationType: U5,
  scrollToTop: XTe,
  scrollToBottom: YTe,
  scrollTo: KTe,
  scrollMore: JTe
};
Object.defineProperty(Pu, "__esModule", {
  value: !0
});
var QTe = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, eje = Ed, tje = S1(eje), nje = Fy, rje = S1(nje), oje = kd, yh = S1(oje);
function S1(e) {
  return e && e.__esModule ? e : { default: e };
}
var bh = {}, sz = void 0;
Pu.default = {
  unmount: function() {
    bh = {};
  },
  register: function(t, n) {
    bh[t] = n;
  },
  unregister: function(t) {
    delete bh[t];
  },
  get: function(t) {
    return bh[t] || document.getElementById(t) || document.getElementsByName(t)[0] || document.getElementsByClassName(t)[0];
  },
  setActiveLink: function(t) {
    return sz = t;
  },
  getActiveLink: function() {
    return sz;
  },
  scrollTo: function(t, n) {
    var r = this.get(t);
    if (!r) {
      console.warn("target Element not found");
      return;
    }
    n = QTe({}, n, { absolute: !1 });
    var o = n.containerId, i = n.container, a = void 0;
    o ? a = document.getElementById(o) : i && i.nodeType ? a = i : a = document, n.absolute = !0;
    var s = n.horizontal, l = tje.default.scrollOffset(a, r, s) + (n.offset || 0);
    if (!n.smooth) {
      yh.default.registered.begin && yh.default.registered.begin(t, r), a === document ? n.horizontal ? window.scrollTo(l, 0) : window.scrollTo(0, l) : a.scrollTop = l, yh.default.registered.end && yh.default.registered.end(t, r);
      return;
    }
    rje.default.animateTopScroll(l, n, t, r);
  }
};
var Vx = { exports: {} }, wh = { exports: {} }, xn = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var az;
function ije() {
  if (az) return xn;
  az = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, h = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, m = e ? Symbol.for("react.block") : 60121, g = e ? Symbol.for("react.fundamental") : 60117, E = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
  function M(y) {
    if (typeof y == "object" && y !== null) {
      var C = y.$$typeof;
      switch (C) {
        case t:
          switch (y = y.type, y) {
            case l:
            case u:
            case r:
            case i:
            case o:
            case p:
              return y;
            default:
              switch (y = y && y.$$typeof, y) {
                case s:
                case c:
                case f:
                case h:
                case a:
                  return y;
                default:
                  return C;
              }
          }
        case n:
          return C;
      }
    }
  }
  function x(y) {
    return M(y) === u;
  }
  return xn.AsyncMode = l, xn.ConcurrentMode = u, xn.ContextConsumer = s, xn.ContextProvider = a, xn.Element = t, xn.ForwardRef = c, xn.Fragment = r, xn.Lazy = f, xn.Memo = h, xn.Portal = n, xn.Profiler = i, xn.StrictMode = o, xn.Suspense = p, xn.isAsyncMode = function(y) {
    return x(y) || M(y) === l;
  }, xn.isConcurrentMode = x, xn.isContextConsumer = function(y) {
    return M(y) === s;
  }, xn.isContextProvider = function(y) {
    return M(y) === a;
  }, xn.isElement = function(y) {
    return typeof y == "object" && y !== null && y.$$typeof === t;
  }, xn.isForwardRef = function(y) {
    return M(y) === c;
  }, xn.isFragment = function(y) {
    return M(y) === r;
  }, xn.isLazy = function(y) {
    return M(y) === f;
  }, xn.isMemo = function(y) {
    return M(y) === h;
  }, xn.isPortal = function(y) {
    return M(y) === n;
  }, xn.isProfiler = function(y) {
    return M(y) === i;
  }, xn.isStrictMode = function(y) {
    return M(y) === o;
  }, xn.isSuspense = function(y) {
    return M(y) === p;
  }, xn.isValidElementType = function(y) {
    return typeof y == "string" || typeof y == "function" || y === r || y === u || y === i || y === o || y === p || y === d || typeof y == "object" && y !== null && (y.$$typeof === f || y.$$typeof === h || y.$$typeof === a || y.$$typeof === s || y.$$typeof === c || y.$$typeof === g || y.$$typeof === E || y.$$typeof === w || y.$$typeof === m);
  }, xn.typeOf = M, xn;
}
var On = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var lz;
function sje() {
  return lz || (lz = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, h = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, m = e ? Symbol.for("react.block") : 60121, g = e ? Symbol.for("react.fundamental") : 60117, E = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
    function M(R) {
      return typeof R == "string" || typeof R == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      R === r || R === u || R === i || R === o || R === p || R === d || typeof R == "object" && R !== null && (R.$$typeof === f || R.$$typeof === h || R.$$typeof === a || R.$$typeof === s || R.$$typeof === c || R.$$typeof === g || R.$$typeof === E || R.$$typeof === w || R.$$typeof === m);
    }
    function x(R) {
      if (typeof R == "object" && R !== null) {
        var ue = R.$$typeof;
        switch (ue) {
          case t:
            var fe = R.type;
            switch (fe) {
              case l:
              case u:
              case r:
              case i:
              case o:
              case p:
                return fe;
              default:
                var oe = fe && fe.$$typeof;
                switch (oe) {
                  case s:
                  case c:
                  case f:
                  case h:
                  case a:
                    return oe;
                  default:
                    return ue;
                }
            }
          case n:
            return ue;
        }
      }
    }
    var y = l, C = u, P = s, F = a, L = t, N = c, I = r, H = f, V = h, z = n, q = i, K = o, J = p, te = !1;
    function ee(R) {
      return te || (te = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), _(R) || x(R) === l;
    }
    function _(R) {
      return x(R) === u;
    }
    function D(R) {
      return x(R) === s;
    }
    function $(R) {
      return x(R) === a;
    }
    function S(R) {
      return typeof R == "object" && R !== null && R.$$typeof === t;
    }
    function W(R) {
      return x(R) === c;
    }
    function O(R) {
      return x(R) === r;
    }
    function T(R) {
      return x(R) === f;
    }
    function U(R) {
      return x(R) === h;
    }
    function j(R) {
      return x(R) === n;
    }
    function Z(R) {
      return x(R) === i;
    }
    function A(R) {
      return x(R) === o;
    }
    function Q(R) {
      return x(R) === p;
    }
    On.AsyncMode = y, On.ConcurrentMode = C, On.ContextConsumer = P, On.ContextProvider = F, On.Element = L, On.ForwardRef = N, On.Fragment = I, On.Lazy = H, On.Memo = V, On.Portal = z, On.Profiler = q, On.StrictMode = K, On.Suspense = J, On.isAsyncMode = ee, On.isConcurrentMode = _, On.isContextConsumer = D, On.isContextProvider = $, On.isElement = S, On.isForwardRef = W, On.isFragment = O, On.isLazy = T, On.isMemo = U, On.isPortal = j, On.isProfiler = Z, On.isStrictMode = A, On.isSuspense = Q, On.isValidElementType = M, On.typeOf = x;
  }()), On;
}
var uz;
function V5() {
  return uz || (uz = 1, process.env.NODE_ENV === "production" ? wh.exports = ije() : wh.exports = sje()), wh.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var kw, cz;
function aje() {
  if (cz) return kw;
  cz = 1;
  var e = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, n = Object.prototype.propertyIsEnumerable;
  function r(i) {
    if (i == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(i);
  }
  function o() {
    try {
      if (!Object.assign)
        return !1;
      var i = new String("abc");
      if (i[5] = "de", Object.getOwnPropertyNames(i)[0] === "5")
        return !1;
      for (var a = {}, s = 0; s < 10; s++)
        a["_" + String.fromCharCode(s)] = s;
      var l = Object.getOwnPropertyNames(a).map(function(c) {
        return a[c];
      });
      if (l.join("") !== "0123456789")
        return !1;
      var u = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(c) {
        u[c] = c;
      }), Object.keys(Object.assign({}, u)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return kw = o() ? Object.assign : function(i, a) {
    for (var s, l = r(i), u, c = 1; c < arguments.length; c++) {
      s = Object(arguments[c]);
      for (var p in s)
        t.call(s, p) && (l[p] = s[p]);
      if (e) {
        u = e(s);
        for (var d = 0; d < u.length; d++)
          n.call(s, u[d]) && (l[u[d]] = s[u[d]]);
      }
    }
    return l;
  }, kw;
}
var Lw, pz;
function M1() {
  if (pz) return Lw;
  pz = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return Lw = e, Lw;
}
var _w, dz;
function q5() {
  return dz || (dz = 1, _w = Function.call.bind(Object.prototype.hasOwnProperty)), _w;
}
var Pw, fz;
function lje() {
  if (fz) return Pw;
  fz = 1;
  var e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = M1(), n = {}, r = q5();
    e = function(i) {
      var a = "Warning: " + i;
      typeof console < "u" && console.error(a);
      try {
        throw new Error(a);
      } catch {
      }
    };
  }
  function o(i, a, s, l, u) {
    if (process.env.NODE_ENV !== "production") {
      for (var c in i)
        if (r(i, c)) {
          var p;
          try {
            if (typeof i[c] != "function") {
              var d = Error(
                (l || "React class") + ": " + s + " type `" + c + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof i[c] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw d.name = "Invariant Violation", d;
            }
            p = i[c](a, c, l, s, null, t);
          } catch (f) {
            p = f;
          }
          if (p && !(p instanceof Error) && e(
            (l || "React class") + ": type specification of " + s + " `" + c + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof p + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), p instanceof Error && !(p.message in n)) {
            n[p.message] = !0;
            var h = u ? u() : "";
            e(
              "Failed " + s + " type: " + p.message + (h ?? "")
            );
          }
        }
    }
  }
  return o.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (n = {});
  }, Pw = o, Pw;
}
var Sw, hz;
function uje() {
  if (hz) return Sw;
  hz = 1;
  var e = V5(), t = aje(), n = M1(), r = q5(), o = lje(), i = function() {
  };
  process.env.NODE_ENV !== "production" && (i = function(s) {
    var l = "Warning: " + s;
    typeof console < "u" && console.error(l);
    try {
      throw new Error(l);
    } catch {
    }
  });
  function a() {
    return null;
  }
  return Sw = function(s, l) {
    var u = typeof Symbol == "function" && Symbol.iterator, c = "@@iterator";
    function p(_) {
      var D = _ && (u && _[u] || _[c]);
      if (typeof D == "function")
        return D;
    }
    var d = "<<anonymous>>", h = {
      array: E("array"),
      bigint: E("bigint"),
      bool: E("boolean"),
      func: E("function"),
      number: E("number"),
      object: E("object"),
      string: E("string"),
      symbol: E("symbol"),
      any: w(),
      arrayOf: M,
      element: x(),
      elementType: y(),
      instanceOf: C,
      node: N(),
      objectOf: F,
      oneOf: P,
      oneOfType: L,
      shape: H,
      exact: V
    };
    function f(_, D) {
      return _ === D ? _ !== 0 || 1 / _ === 1 / D : _ !== _ && D !== D;
    }
    function m(_, D) {
      this.message = _, this.data = D && typeof D == "object" ? D : {}, this.stack = "";
    }
    m.prototype = Error.prototype;
    function g(_) {
      if (process.env.NODE_ENV !== "production")
        var D = {}, $ = 0;
      function S(O, T, U, j, Z, A, Q) {
        if (j = j || d, A = A || U, Q !== n) {
          if (l) {
            var R = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw R.name = "Invariant Violation", R;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var ue = j + ":" + U;
            !D[ue] && // Avoid spamming the console because they are often not actionable except for lib authors
            $ < 3 && (i(
              "You are manually calling a React.PropTypes validation function for the `" + A + "` prop on `" + j + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), D[ue] = !0, $++);
          }
        }
        return T[U] == null ? O ? T[U] === null ? new m("The " + Z + " `" + A + "` is marked as required " + ("in `" + j + "`, but its value is `null`.")) : new m("The " + Z + " `" + A + "` is marked as required in " + ("`" + j + "`, but its value is `undefined`.")) : null : _(T, U, j, Z, A);
      }
      var W = S.bind(null, !1);
      return W.isRequired = S.bind(null, !0), W;
    }
    function E(_) {
      function D($, S, W, O, T, U) {
        var j = $[S], Z = K(j);
        if (Z !== _) {
          var A = J(j);
          return new m(
            "Invalid " + O + " `" + T + "` of type " + ("`" + A + "` supplied to `" + W + "`, expected ") + ("`" + _ + "`."),
            { expectedType: _ }
          );
        }
        return null;
      }
      return g(D);
    }
    function w() {
      return g(a);
    }
    function M(_) {
      function D($, S, W, O, T) {
        if (typeof _ != "function")
          return new m("Property `" + T + "` of component `" + W + "` has invalid PropType notation inside arrayOf.");
        var U = $[S];
        if (!Array.isArray(U)) {
          var j = K(U);
          return new m("Invalid " + O + " `" + T + "` of type " + ("`" + j + "` supplied to `" + W + "`, expected an array."));
        }
        for (var Z = 0; Z < U.length; Z++) {
          var A = _(U, Z, W, O, T + "[" + Z + "]", n);
          if (A instanceof Error)
            return A;
        }
        return null;
      }
      return g(D);
    }
    function x() {
      function _(D, $, S, W, O) {
        var T = D[$];
        if (!s(T)) {
          var U = K(T);
          return new m("Invalid " + W + " `" + O + "` of type " + ("`" + U + "` supplied to `" + S + "`, expected a single ReactElement."));
        }
        return null;
      }
      return g(_);
    }
    function y() {
      function _(D, $, S, W, O) {
        var T = D[$];
        if (!e.isValidElementType(T)) {
          var U = K(T);
          return new m("Invalid " + W + " `" + O + "` of type " + ("`" + U + "` supplied to `" + S + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return g(_);
    }
    function C(_) {
      function D($, S, W, O, T) {
        if (!($[S] instanceof _)) {
          var U = _.name || d, j = ee($[S]);
          return new m("Invalid " + O + " `" + T + "` of type " + ("`" + j + "` supplied to `" + W + "`, expected ") + ("instance of `" + U + "`."));
        }
        return null;
      }
      return g(D);
    }
    function P(_) {
      if (!Array.isArray(_))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? i(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : i("Invalid argument supplied to oneOf, expected an array.")), a;
      function D($, S, W, O, T) {
        for (var U = $[S], j = 0; j < _.length; j++)
          if (f(U, _[j]))
            return null;
        var Z = JSON.stringify(_, function(Q, R) {
          var ue = J(R);
          return ue === "symbol" ? String(R) : R;
        });
        return new m("Invalid " + O + " `" + T + "` of value `" + String(U) + "` " + ("supplied to `" + W + "`, expected one of " + Z + "."));
      }
      return g(D);
    }
    function F(_) {
      function D($, S, W, O, T) {
        if (typeof _ != "function")
          return new m("Property `" + T + "` of component `" + W + "` has invalid PropType notation inside objectOf.");
        var U = $[S], j = K(U);
        if (j !== "object")
          return new m("Invalid " + O + " `" + T + "` of type " + ("`" + j + "` supplied to `" + W + "`, expected an object."));
        for (var Z in U)
          if (r(U, Z)) {
            var A = _(U, Z, W, O, T + "." + Z, n);
            if (A instanceof Error)
              return A;
          }
        return null;
      }
      return g(D);
    }
    function L(_) {
      if (!Array.isArray(_))
        return process.env.NODE_ENV !== "production" && i("Invalid argument supplied to oneOfType, expected an instance of array."), a;
      for (var D = 0; D < _.length; D++) {
        var $ = _[D];
        if (typeof $ != "function")
          return i(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + te($) + " at index " + D + "."
          ), a;
      }
      function S(W, O, T, U, j) {
        for (var Z = [], A = 0; A < _.length; A++) {
          var Q = _[A], R = Q(W, O, T, U, j, n);
          if (R == null)
            return null;
          R.data && r(R.data, "expectedType") && Z.push(R.data.expectedType);
        }
        var ue = Z.length > 0 ? ", expected one of type [" + Z.join(", ") + "]" : "";
        return new m("Invalid " + U + " `" + j + "` supplied to " + ("`" + T + "`" + ue + "."));
      }
      return g(S);
    }
    function N() {
      function _(D, $, S, W, O) {
        return z(D[$]) ? null : new m("Invalid " + W + " `" + O + "` supplied to " + ("`" + S + "`, expected a ReactNode."));
      }
      return g(_);
    }
    function I(_, D, $, S, W) {
      return new m(
        (_ || "React class") + ": " + D + " type `" + $ + "." + S + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + W + "`."
      );
    }
    function H(_) {
      function D($, S, W, O, T) {
        var U = $[S], j = K(U);
        if (j !== "object")
          return new m("Invalid " + O + " `" + T + "` of type `" + j + "` " + ("supplied to `" + W + "`, expected `object`."));
        for (var Z in _) {
          var A = _[Z];
          if (typeof A != "function")
            return I(W, O, T, Z, J(A));
          var Q = A(U, Z, W, O, T + "." + Z, n);
          if (Q)
            return Q;
        }
        return null;
      }
      return g(D);
    }
    function V(_) {
      function D($, S, W, O, T) {
        var U = $[S], j = K(U);
        if (j !== "object")
          return new m("Invalid " + O + " `" + T + "` of type `" + j + "` " + ("supplied to `" + W + "`, expected `object`."));
        var Z = t({}, $[S], _);
        for (var A in Z) {
          var Q = _[A];
          if (r(_, A) && typeof Q != "function")
            return I(W, O, T, A, J(Q));
          if (!Q)
            return new m(
              "Invalid " + O + " `" + T + "` key `" + A + "` supplied to `" + W + "`.\nBad object: " + JSON.stringify($[S], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(_), null, "  ")
            );
          var R = Q(U, A, W, O, T + "." + A, n);
          if (R)
            return R;
        }
        return null;
      }
      return g(D);
    }
    function z(_) {
      switch (typeof _) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !_;
        case "object":
          if (Array.isArray(_))
            return _.every(z);
          if (_ === null || s(_))
            return !0;
          var D = p(_);
          if (D) {
            var $ = D.call(_), S;
            if (D !== _.entries) {
              for (; !(S = $.next()).done; )
                if (!z(S.value))
                  return !1;
            } else
              for (; !(S = $.next()).done; ) {
                var W = S.value;
                if (W && !z(W[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function q(_, D) {
      return _ === "symbol" ? !0 : D ? D["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && D instanceof Symbol : !1;
    }
    function K(_) {
      var D = typeof _;
      return Array.isArray(_) ? "array" : _ instanceof RegExp ? "object" : q(D, _) ? "symbol" : D;
    }
    function J(_) {
      if (typeof _ > "u" || _ === null)
        return "" + _;
      var D = K(_);
      if (D === "object") {
        if (_ instanceof Date)
          return "date";
        if (_ instanceof RegExp)
          return "regexp";
      }
      return D;
    }
    function te(_) {
      var D = J(_);
      switch (D) {
        case "array":
        case "object":
          return "an " + D;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + D;
        default:
          return D;
      }
    }
    function ee(_) {
      return !_.constructor || !_.constructor.name ? d : _.constructor.name;
    }
    return h.checkPropTypes = o, h.resetWarningCache = o.resetWarningCache, h.PropTypes = h, h;
  }, Sw;
}
var Mw, gz;
function cje() {
  if (gz) return Mw;
  gz = 1;
  var e = M1();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, Mw = function() {
    function r(a, s, l, u, c, p) {
      if (p !== e) {
        var d = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw d.name = "Invariant Violation", d;
      }
    }
    r.isRequired = r;
    function o() {
      return r;
    }
    var i = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: o,
      element: r,
      elementType: r,
      instanceOf: o,
      node: r,
      objectOf: o,
      oneOf: o,
      oneOfType: o,
      shape: o,
      exact: o,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return i.PropTypes = i, i;
  }, Mw;
}
if (process.env.NODE_ENV !== "production") {
  var pje = V5(), dje = !0;
  Vx.exports = uje()(pje.isElement, dje);
} else
  Vx.exports = cje()();
var $y = Vx.exports, Hy = {};
Object.defineProperty(Hy, "__esModule", {
  value: !0
});
var fje = Ed, Dw = hje(fje);
function hje(e) {
  return e && e.__esModule ? e : { default: e };
}
var gje = {
  mountFlag: !1,
  initialized: !1,
  scroller: null,
  containers: {},
  mount: function(t) {
    this.scroller = t, this.handleHashChange = this.handleHashChange.bind(this), window.addEventListener("hashchange", this.handleHashChange), this.initStateFromHash(), this.mountFlag = !0;
  },
  mapContainer: function(t, n) {
    this.containers[t] = n;
  },
  isMounted: function() {
    return this.mountFlag;
  },
  isInitialized: function() {
    return this.initialized;
  },
  initStateFromHash: function() {
    var t = this, n = this.getHash();
    n ? window.setTimeout(function() {
      t.scrollTo(n, !0), t.initialized = !0;
    }, 10) : this.initialized = !0;
  },
  scrollTo: function(t, n) {
    var r = this.scroller, o = r.get(t);
    if (o && (n || t !== r.getActiveLink())) {
      var i = this.containers[t] || document;
      r.scrollTo(t, { container: i });
    }
  },
  getHash: function() {
    return Dw.default.getHash();
  },
  changeHash: function(t, n) {
    this.isInitialized() && Dw.default.getHash() !== t && Dw.default.updateHash(t, n);
  },
  handleHashChange: function() {
    this.scrollTo(this.getHash());
  },
  unmount: function() {
    this.scroller = null, this.containers = null, window.removeEventListener("hashchange", this.handleHashChange);
  }
};
Hy.default = gje;
Object.defineProperty(Cd, "__esModule", {
  value: !0
});
var Ch = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, mje = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), vje = ke, mz = _d(vje), yje = xd, xh = _d(yje), bje = Pu, wje = _d(bje), Cje = $y, vr = _d(Cje), xje = Hy, Hs = _d(xje);
function _d(e) {
  return e && e.__esModule ? e : { default: e };
}
function Oje(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Eje(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function kje(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var vz = {
  to: vr.default.string.isRequired,
  containerId: vr.default.string,
  container: vr.default.object,
  activeClass: vr.default.string,
  activeStyle: vr.default.object,
  spy: vr.default.bool,
  horizontal: vr.default.bool,
  smooth: vr.default.oneOfType([vr.default.bool, vr.default.string]),
  offset: vr.default.number,
  delay: vr.default.number,
  isDynamic: vr.default.bool,
  onClick: vr.default.func,
  duration: vr.default.oneOfType([vr.default.number, vr.default.func]),
  absolute: vr.default.bool,
  onSetActive: vr.default.func,
  onSetInactive: vr.default.func,
  ignoreCancelEvents: vr.default.bool,
  hashSpy: vr.default.bool,
  saveHashHistory: vr.default.bool,
  spyThrottle: vr.default.number
};
Cd.default = function(e, t) {
  var n = t || wje.default, r = function(i) {
    kje(a, i);
    function a(s) {
      Oje(this, a);
      var l = Eje(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
      return o.call(l), l.state = {
        active: !1
      }, l.beforeUnmountCallbacks = [], l;
    }
    return mje(a, [{
      key: "getScrollSpyContainer",
      value: function() {
        var l = this.props.containerId, u = this.props.container;
        return l && !u ? document.getElementById(l) : u && u.nodeType ? u : document;
      }
    }, {
      key: "componentDidMount",
      value: function() {
        if (this.props.spy || this.props.hashSpy) {
          var l = this.getScrollSpyContainer();
          if (!xh.default.isMounted(l)) {
            var u = xh.default.mount(l, this.props.spyThrottle);
            this.beforeUnmountCallbacks.push(u);
          }
          this.props.hashSpy && (Hs.default.isMounted() || Hs.default.mount(n), Hs.default.mapContainer(this.props.to, l)), xh.default.addSpyHandler(this.spyHandler, l), this.setState({
            container: l
          });
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        xh.default.unmount(this.stateHandler, this.spyHandler), this.beforeUnmountCallbacks.forEach(function(l) {
          return l();
        });
      }
    }, {
      key: "render",
      value: function() {
        var l = "";
        this.state && this.state.active ? l = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : l = this.props.className;
        var u = {};
        this.state && this.state.active ? u = Ch({}, this.props.style, this.props.activeStyle) : u = Ch({}, this.props.style);
        var c = Ch({}, this.props);
        for (var p in vz)
          c.hasOwnProperty(p) && delete c[p];
        return c.className = l, c.style = u, c.onClick = this.handleClick, mz.default.createElement(e, c);
      }
    }]), a;
  }(mz.default.PureComponent), o = function() {
    var a = this;
    this.scrollTo = function(s, l) {
      n.scrollTo(s, Ch({}, a.state, l));
    }, this.handleClick = function(s) {
      a.props.onClick && a.props.onClick(s), s.stopPropagation && s.stopPropagation(), s.preventDefault && s.preventDefault(), a.scrollTo(a.props.to, a.props);
    }, this.spyHandler = function(s, l) {
      var u = a.getScrollSpyContainer();
      if (!(Hs.default.isMounted() && !Hs.default.isInitialized())) {
        var c = a.props.horizontal, p = a.props.to, d = null, h = void 0, f = void 0;
        if (c) {
          var m = 0, g = 0, E = 0;
          if (u.getBoundingClientRect) {
            var w = u.getBoundingClientRect();
            E = w.left;
          }
          if (!d || a.props.isDynamic) {
            if (d = n.get(p), !d)
              return;
            var M = d.getBoundingClientRect();
            m = M.left - E + s, g = m + M.width;
          }
          var x = s - a.props.offset;
          h = x >= Math.floor(m) && x < Math.floor(g), f = x < Math.floor(m) || x >= Math.floor(g);
        } else {
          var y = 0, C = 0, P = 0;
          if (u.getBoundingClientRect) {
            var F = u.getBoundingClientRect();
            P = F.top;
          }
          if (!d || a.props.isDynamic) {
            if (d = n.get(p), !d)
              return;
            var L = d.getBoundingClientRect();
            y = L.top - P + l, C = y + L.height;
          }
          var N = l - a.props.offset;
          h = N >= Math.floor(y) && N < Math.floor(C), f = N < Math.floor(y) || N >= Math.floor(C);
        }
        var I = n.getActiveLink();
        if (f) {
          if (p === I && n.setActiveLink(void 0), a.props.hashSpy && Hs.default.getHash() === p) {
            var H = a.props.saveHashHistory, V = H === void 0 ? !1 : H;
            Hs.default.changeHash("", V);
          }
          a.props.spy && a.state.active && (a.setState({ active: !1 }), a.props.onSetInactive && a.props.onSetInactive(p, d));
        }
        if (h && (I !== p || a.state.active === !1)) {
          n.setActiveLink(p);
          var z = a.props.saveHashHistory, q = z === void 0 ? !1 : z;
          a.props.hashSpy && Hs.default.changeHash(p, q), a.props.spy && (a.setState({ active: !0 }), a.props.onSetActive && a.props.onSetActive(p, d));
        }
      }
    };
  };
  return r.propTypes = vz, r.defaultProps = { offset: 0 }, r;
};
Object.defineProperty(k1, "__esModule", {
  value: !0
});
var Lje = ke, yz = Z5(Lje), _je = Cd, Pje = Z5(_je);
function Z5(e) {
  return e && e.__esModule ? e : { default: e };
}
function Sje(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function bz(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function Mje(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var Dje = function(e) {
  Mje(t, e);
  function t() {
    var n, r, o, i;
    Sje(this, t);
    for (var a = arguments.length, s = Array(a), l = 0; l < a; l++)
      s[l] = arguments[l];
    return i = (r = (o = bz(this, (n = t.__proto__ || Object.getPrototypeOf(t)).call.apply(n, [this].concat(s))), o), o.render = function() {
      return yz.default.createElement(
        "a",
        o.props,
        o.props.children
      );
    }, r), bz(o, i);
  }
  return t;
}(yz.default.Component);
k1.default = (0, Pje.default)(Dje);
var D1 = {};
Object.defineProperty(D1, "__esModule", {
  value: !0
});
var Tje = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), jje = ke, wz = G5(jje), Aje = Cd, Bje = G5(Aje);
function G5(e) {
  return e && e.__esModule ? e : { default: e };
}
function Ije(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Rje(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function Nje(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var Fje = function(e) {
  Nje(t, e);
  function t() {
    return Ije(this, t), Rje(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return Tje(t, [{
    key: "render",
    value: function() {
      return wz.default.createElement(
        "button",
        this.props,
        this.props.children
      );
    }
  }]), t;
}(wz.default.Component);
D1.default = (0, Bje.default)(Fje);
var T1 = {}, Wy = {};
Object.defineProperty(Wy, "__esModule", {
  value: !0
});
var zje = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, Uje = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), $je = ke, Cz = Vy($je), Hje = Rl;
Vy(Hje);
var Wje = Pu, xz = Vy(Wje), Vje = $y, Oz = Vy(Vje);
function Vy(e) {
  return e && e.__esModule ? e : { default: e };
}
function qje(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Zje(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function Gje(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
Wy.default = function(e) {
  var t = function(n) {
    Gje(r, n);
    function r(o) {
      qje(this, r);
      var i = Zje(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
      return i.childBindings = {
        domNode: null
      }, i;
    }
    return Uje(r, [{
      key: "componentDidMount",
      value: function() {
        if (typeof window > "u")
          return !1;
        this.registerElems(this.props.name);
      }
    }, {
      key: "componentDidUpdate",
      value: function(i) {
        this.props.name !== i.name && this.registerElems(this.props.name);
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        if (typeof window > "u")
          return !1;
        xz.default.unregister(this.props.name);
      }
    }, {
      key: "registerElems",
      value: function(i) {
        xz.default.register(i, this.childBindings.domNode);
      }
    }, {
      key: "render",
      value: function() {
        return Cz.default.createElement(e, zje({}, this.props, { parentBindings: this.childBindings }));
      }
    }]), r;
  }(Cz.default.Component);
  return t.propTypes = {
    name: Oz.default.string,
    id: Oz.default.string
  }, t;
};
Object.defineProperty(T1, "__esModule", {
  value: !0
});
var Ez = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, Xje = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), Kje = ke, kz = j1(Kje), Yje = Wy, Jje = j1(Yje), Qje = $y, Lz = j1(Qje);
function j1(e) {
  return e && e.__esModule ? e : { default: e };
}
function eAe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function tAe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function nAe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var X5 = function(e) {
  nAe(t, e);
  function t() {
    return eAe(this, t), tAe(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return Xje(t, [{
    key: "render",
    value: function() {
      var r = this, o = Ez({}, this.props);
      return delete o.name, o.parentBindings && delete o.parentBindings, kz.default.createElement(
        "div",
        Ez({}, o, { ref: function(a) {
          r.props.parentBindings.domNode = a;
        } }),
        this.props.children
      );
    }
  }]), t;
}(kz.default.Component);
X5.propTypes = {
  name: Lz.default.string,
  id: Lz.default.string
};
T1.default = (0, Jje.default)(X5);
var Tw = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, _z = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}();
function Pz(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Sz(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function Mz(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var Oh = ke, Va = xd, jw = Pu, jr = $y, Ws = Hy, Dz = {
  to: jr.string.isRequired,
  containerId: jr.string,
  container: jr.object,
  activeClass: jr.string,
  spy: jr.bool,
  smooth: jr.oneOfType([jr.bool, jr.string]),
  offset: jr.number,
  delay: jr.number,
  isDynamic: jr.bool,
  onClick: jr.func,
  duration: jr.oneOfType([jr.number, jr.func]),
  absolute: jr.bool,
  onSetActive: jr.func,
  onSetInactive: jr.func,
  ignoreCancelEvents: jr.bool,
  hashSpy: jr.bool,
  spyThrottle: jr.number
}, rAe = {
  Scroll: function(t, n) {
    console.warn("Helpers.Scroll is deprecated since v1.7.0");
    var r = n || jw, o = function(a) {
      Mz(s, a);
      function s(l) {
        Pz(this, s);
        var u = Sz(this, (s.__proto__ || Object.getPrototypeOf(s)).call(this, l));
        return i.call(u), u.state = {
          active: !1
        }, u;
      }
      return _z(s, [{
        key: "getScrollSpyContainer",
        value: function() {
          var u = this.props.containerId, c = this.props.container;
          return u ? document.getElementById(u) : c && c.nodeType ? c : document;
        }
      }, {
        key: "componentDidMount",
        value: function() {
          if (this.props.spy || this.props.hashSpy) {
            var u = this.getScrollSpyContainer();
            Va.isMounted(u) || Va.mount(u, this.props.spyThrottle), this.props.hashSpy && (Ws.isMounted() || Ws.mount(r), Ws.mapContainer(this.props.to, u)), this.props.spy && Va.addStateHandler(this.stateHandler), Va.addSpyHandler(this.spyHandler, u), this.setState({
              container: u
            });
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          Va.unmount(this.stateHandler, this.spyHandler);
        }
      }, {
        key: "render",
        value: function() {
          var u = "";
          this.state && this.state.active ? u = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : u = this.props.className;
          var c = Tw({}, this.props);
          for (var p in Dz)
            c.hasOwnProperty(p) && delete c[p];
          return c.className = u, c.onClick = this.handleClick, Oh.createElement(t, c);
        }
      }]), s;
    }(Oh.Component), i = function() {
      var s = this;
      this.scrollTo = function(l, u) {
        r.scrollTo(l, Tw({}, s.state, u));
      }, this.handleClick = function(l) {
        s.props.onClick && s.props.onClick(l), l.stopPropagation && l.stopPropagation(), l.preventDefault && l.preventDefault(), s.scrollTo(s.props.to, s.props);
      }, this.stateHandler = function() {
        r.getActiveLink() !== s.props.to && (s.state !== null && s.state.active && s.props.onSetInactive && s.props.onSetInactive(), s.setState({ active: !1 }));
      }, this.spyHandler = function(l) {
        var u = s.getScrollSpyContainer();
        if (!(Ws.isMounted() && !Ws.isInitialized())) {
          var c = s.props.to, p = null, d = 0, h = 0, f = 0;
          if (u.getBoundingClientRect) {
            var m = u.getBoundingClientRect();
            f = m.top;
          }
          if (!p || s.props.isDynamic) {
            if (p = r.get(c), !p)
              return;
            var g = p.getBoundingClientRect();
            d = g.top - f + l, h = d + g.height;
          }
          var E = l - s.props.offset, w = E >= Math.floor(d) && E < Math.floor(h), M = E < Math.floor(d) || E >= Math.floor(h), x = r.getActiveLink();
          if (M)
            return c === x && r.setActiveLink(void 0), s.props.hashSpy && Ws.getHash() === c && Ws.changeHash(), s.props.spy && s.state.active && (s.setState({ active: !1 }), s.props.onSetInactive && s.props.onSetInactive()), Va.updateStates();
          if (w && x !== c)
            return r.setActiveLink(c), s.props.hashSpy && Ws.changeHash(c), s.props.spy && (s.setState({ active: !0 }), s.props.onSetActive && s.props.onSetActive(c)), Va.updateStates();
        }
      };
    };
    return o.propTypes = Dz, o.defaultProps = { offset: 0 }, o;
  },
  Element: function(t) {
    console.warn("Helpers.Element is deprecated since v1.7.0");
    var n = function(r) {
      Mz(o, r);
      function o(i) {
        Pz(this, o);
        var a = Sz(this, (o.__proto__ || Object.getPrototypeOf(o)).call(this, i));
        return a.childBindings = {
          domNode: null
        }, a;
      }
      return _z(o, [{
        key: "componentDidMount",
        value: function() {
          if (typeof window > "u")
            return !1;
          this.registerElems(this.props.name);
        }
      }, {
        key: "componentDidUpdate",
        value: function(a) {
          this.props.name !== a.name && this.registerElems(this.props.name);
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          if (typeof window > "u")
            return !1;
          jw.unregister(this.props.name);
        }
      }, {
        key: "registerElems",
        value: function(a) {
          jw.register(a, this.childBindings.domNode);
        }
      }, {
        key: "render",
        value: function() {
          return Oh.createElement(t, Tw({}, this.props, { parentBindings: this.childBindings }));
        }
      }]), o;
    }(Oh.Component);
    return n.propTypes = {
      name: jr.string,
      id: jr.string
    }, n;
  }
}, oAe = rAe;
Object.defineProperty(Wr, "__esModule", {
  value: !0
});
Wr.Helpers = Wr.ScrollElement = Wr.ScrollLink = s4 = Wr.animateScroll = Wr.scrollSpy = Wr.Events = Wr.scroller = Wr.Element = Wr.Button = Wr.Link = void 0;
var iAe = k1, K5 = es(iAe), sAe = D1, Y5 = es(sAe), aAe = T1, J5 = es(aAe), lAe = Pu, Q5 = es(lAe), uAe = kd, e4 = es(uAe), cAe = xd, t4 = es(cAe), pAe = Fy, n4 = es(pAe), dAe = Cd, r4 = es(dAe), fAe = Wy, o4 = es(fAe), hAe = oAe, i4 = es(hAe);
function es(e) {
  return e && e.__esModule ? e : { default: e };
}
Wr.Link = K5.default;
Wr.Button = Y5.default;
Wr.Element = J5.default;
Wr.scroller = Q5.default;
Wr.Events = e4.default;
Wr.scrollSpy = t4.default;
var s4 = Wr.animateScroll = n4.default;
Wr.ScrollLink = r4.default;
Wr.ScrollElement = o4.default;
Wr.Helpers = i4.default;
Wr.default = { Link: K5.default, Button: Y5.default, Element: J5.default, scroller: Q5.default, Events: e4.default, scrollSpy: t4.default, animateScroll: n4.default, ScrollLink: r4.default, ScrollElement: o4.default, Helpers: i4.default };
const A1 = Ze({}), a4 = Ze({});
function gAe() {
  const e = ye(a4);
  if (Object.entries(e).length === 0)
    throw new Error("useToast must be used within a Provider");
  return e;
}
function Tz(e) {
  return e && typeof e.title == "string" && typeof e.message == "string" && (e.size === void 0 || e.size === "md" || e.size === "lg") && (e.type === "success" || e.type === "danger");
}
function zRe() {
  const e = eO(), { closeModal: t, closeAll: n, modalIsOpen: r } = ye(A1), { showToast: o } = gAe(), { getParam: i } = N5(), { pathname: a } = nO(), s = n$(), l = i("closeAllModals"), u = tO();
  v(() => {
    var d, h;
    const c = ((h = (d = u[0]) == null ? void 0 : d.data) == null ? void 0 : h.closeModalKey) || "", p = r(c);
    c && p && t(c);
  }, [u]), v(() => {
    l === "true" && (n(), s(a));
  }, [l]), v(() => {
    const c = e == null ? void 0 : e.closeModalKey;
    c && t(c);
  }, [e]), v(() => {
    const c = e == null ? void 0 : e.closeAllModals;
    typeof c == "boolean" && c && n();
  }, [e]), v(() => {
    const c = e == null ? void 0 : e.toast, p = e == null ? void 0 : e.message;
    Tz(c) && o(c), !Tz(c) && p && o({ message: p, type: "danger" });
  }, [e]), v(() => {
    var c, p;
    if (typeof ((c = e == null ? void 0 : e.data) == null ? void 0 : c.scrollTo) == "string") {
      const d = document.getElementById((p = e == null ? void 0 : e.data) == null ? void 0 : p.scrollTo);
      d && s4.scrollTo(d.offsetTop - 200);
    }
  }, [e]);
}
const l4 = Ze({});
function URe(e) {
  const t = ye(l4);
  if (Object.entries(t).length === 0)
    throw new Error("useDrawer must be used within a Provider");
  if (e) {
    const {
      drawerData: n,
      drawerIsOpen: r,
      openDrawer: o,
      closeDrawer: i
    } = t, a = r(e), s = n(e);
    return { drawerIsOpen: a, drawerData: s, openDrawer: (c) => o(e, c), closeDrawer: () => i(e) };
  } else
    return t;
}
function mAe() {
  return () => {
  };
}
function vAe() {
  return N4(
    mAe,
    () => !0,
    () => !1
  );
}
function $Re(e) {
  const t = ye(A1);
  if (Object.entries(t).length === 0)
    throw new Error("useModal must be used within a Provider");
  if (e) {
    const {
      modalData: n,
      modalIsOpen: r,
      openModal: o,
      closeModal: i
    } = t, a = r(e), s = n(e);
    return { modalIsOpen: a, modalData: s, openModal: (c) => o(e, c), closeModal: () => i(e) };
  } else
    return t;
}
function HRe(e) {
  const { children: t = !1 } = e, [n, r] = k([]);
  function o(l) {
    return !!n.some((u) => u.key === l);
  }
  function i(l) {
    var u;
    return (u = n.find((c) => c.key === l)) == null ? void 0 : u.data;
  }
  function a(l, u) {
    const c = o(l);
    r(c ? (p) => [...p.filter((h) => h.key !== l), { key: l, data: u }] : [...n, { key: l, data: u }]);
  }
  function s(l) {
    r(n.filter((u) => u.key !== l));
  }
  return /* @__PURE__ */ X.jsx(
    l4.Provider,
    {
      value: { drawerIsOpen: o, drawerData: i, openDrawer: a, closeDrawer: s },
      children: t
    }
  );
}
function Fp(e) {
  "@babel/helpers - typeof";
  return Fp = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Fp(e);
}
function yAe(e, t) {
  if (Fp(e) != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (Fp(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function bAe(e) {
  var t = yAe(e, "string");
  return Fp(t) == "symbol" ? t : t + "";
}
function ge(e, t, n) {
  return (t = bAe(t)) in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function u4(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var Aw, jz;
function wAe() {
  if (jz) return Aw;
  jz = 1;
  var e = process.env.NODE_ENV, t = function(r, o, i, a, s, l, u, c) {
    if (e !== "production" && o === void 0)
      throw new Error("invariant requires an error message argument");
    if (!r) {
      var p;
      if (o === void 0)
        p = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
      else {
        var d = [i, a, s, l, u, c], h = 0;
        p = new Error(o.replace(/%s/g, function() {
          return d[h++];
        })), p.name = "Invariant Violation";
      }
      throw p.framesToPop = 1, p;
    }
  };
  return Aw = t, Aw;
}
var CAe = wAe(), Yr = /* @__PURE__ */ u4(CAe), _t = Ze(null);
function xAe() {
  Yr(!!ye, "useGoogleMap is React hook and requires React version 16.8+");
  var e = ye(_t);
  return Yr(!!e, "useGoogleMap needs a GoogleMap available up in the tree"), e;
}
function OAe(e, t, n) {
  return Object.keys(e).reduce(function(o, i) {
    return t(o, e[i], i);
  }, n);
}
function EAe(e, t) {
  Object.keys(e).forEach((n) => t(e[n], n));
}
function kAe(e, t, n, r) {
  var o = {}, i = (a, s) => {
    var l = n[s];
    l !== t[s] && (o[s] = l, a(r, l));
  };
  return EAe(e, i), o;
}
function LAe(e, t, n) {
  var r = OAe(n, function(i, a, s) {
    return typeof e[s] == "function" && i.push(google.maps.event.addListener(t, a, e[s])), i;
  }, []);
  return r;
}
function _Ae(e) {
  google.maps.event.removeListener(e);
}
function qt() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  e.forEach(_Ae);
}
function Ft(e) {
  var {
    updaterMap: t,
    eventMap: n,
    prevProps: r,
    nextProps: o,
    instance: i
  } = e, a = LAe(o, i, n);
  return kAe(t, r, o, i), a;
}
var Az = {
  onDblClick: "dblclick",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMapTypeIdChanged: "maptypeid_changed",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseDown: "mousedown",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onTilesLoaded: "tilesloaded",
  onBoundsChanged: "bounds_changed",
  onCenterChanged: "center_changed",
  onClick: "click",
  onDrag: "drag",
  onHeadingChanged: "heading_changed",
  onIdle: "idle",
  onProjectionChanged: "projection_changed",
  onResize: "resize",
  onTiltChanged: "tilt_changed",
  onZoomChanged: "zoom_changed"
}, Bz = {
  extraMapTypes(e, t) {
    t.forEach(function(r, o) {
      e.mapTypes.set(String(o), r);
    });
  },
  center(e, t) {
    e.setCenter(t);
  },
  clickableIcons(e, t) {
    e.setClickableIcons(t);
  },
  heading(e, t) {
    e.setHeading(t);
  },
  mapTypeId(e, t) {
    e.setMapTypeId(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  streetView(e, t) {
    e.setStreetView(t);
  },
  tilt(e, t) {
    e.setTilt(t);
  },
  zoom(e, t) {
    e.setZoom(t);
  }
};
function PAe(e) {
  var {
    children: t,
    options: n,
    id: r,
    mapContainerStyle: o,
    mapContainerClassName: i,
    center: a,
    // clickableIcons,
    // extraMapTypes,
    // heading,
    // mapTypeId,
    onClick: s,
    onDblClick: l,
    onDrag: u,
    onDragEnd: c,
    onDragStart: p,
    onMouseMove: d,
    onMouseOut: h,
    onMouseOver: f,
    onMouseDown: m,
    onMouseUp: g,
    onRightClick: E,
    // onMapTypeIdChanged,
    // onTilesLoaded,
    // onBoundsChanged,
    onCenterChanged: w,
    // onHeadingChanged,
    // onIdle,
    // onProjectionChanged,
    // onResize,
    // onTiltChanged,
    // onZoomChanged,
    onLoad: M,
    onUnmount: x
  } = e, [y, C] = k(null), P = rt(null), [F, L] = k(null), [N, I] = k(null), [H, V] = k(null), [z, q] = k(null), [K, J] = k(null), [te, ee] = k(null), [_, D] = k(null), [$, S] = k(null), [W, O] = k(null), [T, U] = k(null), [j, Z] = k(null), [A, Q] = k(null);
  return v(() => {
    n && y !== null && y.setOptions(n);
  }, [y, n]), v(() => {
    y !== null && typeof a < "u" && y.setCenter(a);
  }, [y, a]), v(() => {
    y && l && (N !== null && google.maps.event.removeListener(N), I(google.maps.event.addListener(y, "dblclick", l)));
  }, [l]), v(() => {
    y && c && (H !== null && google.maps.event.removeListener(H), V(google.maps.event.addListener(y, "dragend", c)));
  }, [c]), v(() => {
    y && p && (z !== null && google.maps.event.removeListener(z), q(google.maps.event.addListener(y, "dragstart", p)));
  }, [p]), v(() => {
    y && m && (K !== null && google.maps.event.removeListener(K), J(google.maps.event.addListener(y, "mousedown", m)));
  }, [m]), v(() => {
    y && d && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(y, "mousemove", d)));
  }, [d]), v(() => {
    y && h && (_ !== null && google.maps.event.removeListener(_), D(google.maps.event.addListener(y, "mouseout", h)));
  }, [h]), v(() => {
    y && f && ($ !== null && google.maps.event.removeListener($), S(google.maps.event.addListener(y, "mouseover", f)));
  }, [f]), v(() => {
    y && g && (W !== null && google.maps.event.removeListener(W), O(google.maps.event.addListener(y, "mouseup", g)));
  }, [g]), v(() => {
    y && E && (T !== null && google.maps.event.removeListener(T), U(google.maps.event.addListener(y, "rightclick", E)));
  }, [E]), v(() => {
    y && s && (j !== null && google.maps.event.removeListener(j), Z(google.maps.event.addListener(y, "click", s)));
  }, [s]), v(() => {
    y && u && (A !== null && google.maps.event.removeListener(A), Q(google.maps.event.addListener(y, "drag", u)));
  }, [u]), v(() => {
    y && w && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(y, "center_changed", w)));
  }, [s]), v(() => {
    var R = P.current === null ? null : new google.maps.Map(P.current, n);
    return C(R), R !== null && M && M(R), () => {
      R !== null && x && x(R);
    };
  }, []), X.jsx("div", {
    id: r,
    ref: P,
    style: o,
    className: i,
    children: X.jsx(_t.Provider, {
      value: y,
      children: y !== null ? t : null
    })
  });
}
Ee(PAe);
let SAe = class extends pe {
  constructor() {
    super(...arguments), ge(this, "state", {
      map: null
    }), ge(this, "registeredEvents", []), ge(this, "mapRef", null), ge(this, "getInstance", () => this.mapRef === null ? null : new google.maps.Map(this.mapRef, this.props.options)), ge(this, "panTo", (t) => {
      var n = this.getInstance();
      n && n.panTo(t);
    }), ge(this, "setMapCallback", () => {
      this.state.map !== null && this.props.onLoad && this.props.onLoad(this.state.map);
    }), ge(this, "getRef", (t) => {
      this.mapRef = t;
    });
  }
  componentDidMount() {
    var t = this.getInstance();
    this.registeredEvents = Ft({
      updaterMap: Bz,
      eventMap: Az,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        map: t
      };
    }, this.setMapCallback);
  }
  componentDidUpdate(t) {
    this.state.map !== null && (qt(this.registeredEvents), this.registeredEvents = Ft({
      updaterMap: Bz,
      eventMap: Az,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.map
    }));
  }
  componentWillUnmount() {
    this.state.map !== null && (this.props.onUnmount && this.props.onUnmount(this.state.map), qt(this.registeredEvents));
  }
  render() {
    return X.jsx("div", {
      id: this.props.id,
      ref: this.getRef,
      style: this.props.mapContainerStyle,
      className: this.props.mapContainerClassName,
      children: X.jsx(_t.Provider, {
        value: this.state.map,
        children: this.state.map !== null ? this.props.children : null
      })
    });
  }
};
function Iz(e, t, n, r, o, i, a) {
  try {
    var s = e[i](a), l = s.value;
  } catch (u) {
    return void n(u);
  }
  s.done ? t(l) : Promise.resolve(l).then(r, o);
}
function c4(e) {
  return function() {
    var t = this, n = arguments;
    return new Promise(function(r, o) {
      var i = e.apply(t, n);
      function a(l) {
        Iz(i, r, o, a, s, "next", l);
      }
      function s(l) {
        Iz(i, r, o, a, s, "throw", l);
      }
      a(void 0);
    });
  };
}
function p4(e) {
  var {
    googleMapsApiKey: t,
    googleMapsClientId: n,
    version: r = "weekly",
    language: o,
    region: i,
    libraries: a,
    channel: s,
    mapIds: l,
    authReferrerPolicy: u
  } = e, c = [];
  return Yr(t && n || !(t && n), "You need to specify either googleMapsApiKey or googleMapsClientId for @react-google-maps/api load script to work. You cannot use both at the same time."), t ? c.push("key=".concat(t)) : n && c.push("client=".concat(n)), r && c.push("v=".concat(r)), o && c.push("language=".concat(o)), i && c.push("region=".concat(i)), a && a.length && c.push("libraries=".concat(a.sort().join(","))), s && c.push("channel=".concat(s)), l && l.length && c.push("map_ids=".concat(l.join(","))), u && c.push("auth_referrer_policy=".concat(u)), c.push("loading=async"), c.push("callback=initMap"), "https://maps.googleapis.com/maps/api/js?".concat(c.join("&"));
}
var fl = typeof document < "u";
function d4(e) {
  var {
    url: t,
    id: n,
    nonce: r
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } = e;
  return fl ? new Promise(function(i, a) {
    var s = document.getElementById(n), l = window;
    if (s) {
      var u = s.getAttribute("data-state");
      if (s.src === t && u !== "error") {
        if (u === "ready")
          return i(n);
        var c = l.initMap, p = s.onerror;
        l.initMap = function() {
          c && c(), i(n);
        }, s.onerror = function(h) {
          p && p(h), a(h);
        };
        return;
      } else
        s.remove();
    }
    var d = document.createElement("script");
    d.type = "text/javascript", d.src = t, d.id = n, d.async = !0, d.nonce = r || "", d.onerror = function(f) {
      d.setAttribute("data-state", "error"), a(f);
    }, l.initMap = function() {
      d.setAttribute("data-state", "ready"), i(n);
    }, document.head.appendChild(d);
  }).catch((o) => {
    throw console.error("injectScript error: ", o), o;
  }) : Promise.reject(new Error("document is undefined"));
}
function Rz(e) {
  var t = e.href;
  return t && (t.indexOf("https://fonts.googleapis.com/css?family=Roboto") === 0 || t.indexOf("https://fonts.googleapis.com/css?family=Google+Sans+Text") === 0) ? !0 : (
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.styleSheet.cssText = "", !0) : (
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.innerHTML = "", !0) : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.innerHTML
      )
    )
  );
}
function f4() {
  var e = document.getElementsByTagName("head")[0];
  if (e) {
    var t = e.insertBefore.bind(e);
    e.insertBefore = function(o, i) {
      return Rz(o) || Reflect.apply(t, e, [o, i]), o;
    };
    var n = e.appendChild.bind(e);
    e.appendChild = function(o) {
      return Rz(o) || Reflect.apply(n, e, [o]), o;
    };
  }
}
var sc = !1;
function h4() {
  return X.jsx("div", {
    children: "Loading..."
  });
}
var qx = {
  id: "script-loader",
  version: "weekly"
};
class g4 extends pe {
  constructor() {
    super(...arguments), ge(this, "check", null), ge(this, "state", {
      loaded: !1
    }), ge(this, "cleanupCallback", () => {
      delete window.google.maps, this.injectScript();
    }), ge(this, "isCleaningUp", /* @__PURE__ */ c4(function* () {
      function t(n) {
        if (!sc)
          n();
        else if (fl)
          var r = window.setInterval(function() {
            sc || (window.clearInterval(r), n());
          }, 1);
      }
      return new Promise(t);
    })), ge(this, "cleanup", () => {
      sc = !0;
      var t = document.getElementById(this.props.id);
      t && t.parentNode && t.parentNode.removeChild(t), Array.prototype.slice.call(document.getElementsByTagName("script")).filter(function(r) {
        return typeof r.src == "string" && r.src.includes("maps.googleapis");
      }).forEach(function(r) {
        r.parentNode && r.parentNode.removeChild(r);
      }), Array.prototype.slice.call(document.getElementsByTagName("link")).filter(function(r) {
        return r.href === "https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Google+Sans";
      }).forEach(function(r) {
        r.parentNode && r.parentNode.removeChild(r);
      }), Array.prototype.slice.call(document.getElementsByTagName("style")).filter(function(r) {
        return r.innerText !== void 0 && r.innerText.length > 0 && r.innerText.includes(".gm-");
      }).forEach(function(r) {
        r.parentNode && r.parentNode.removeChild(r);
      });
    }), ge(this, "injectScript", () => {
      this.props.preventGoogleFontsLoading && f4(), Yr(!!this.props.id, 'LoadScript requires "id" prop to be a string: %s', this.props.id);
      var t = {
        id: this.props.id,
        nonce: this.props.nonce,
        url: p4(this.props)
      };
      d4(t).then(() => {
        this.props.onLoad && this.props.onLoad(), this.setState(function() {
          return {
            loaded: !0
          };
        });
      }).catch((n) => {
        this.props.onError && this.props.onError(n), console.error(`
          There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(this.props.googleMapsApiKey || "-", ") or Client ID (").concat(this.props.googleMapsClientId || "-", `) to <LoadScript />
          Otherwise it is a Network issue.
        `));
      });
    }), ge(this, "getRef", (t) => {
      this.check = t;
    });
  }
  componentDidMount() {
    if (fl) {
      if (window.google && window.google.maps && !sc) {
        console.error("google api is already presented");
        return;
      }
      this.isCleaningUp().then(this.injectScript).catch(function(n) {
        console.error("Error at injecting script after cleaning up: ", n);
      });
    }
  }
  componentDidUpdate(t) {
    this.props.libraries !== t.libraries && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), fl && t.language !== this.props.language && (this.cleanup(), this.setState(function() {
      return {
        loaded: !1
      };
    }, this.cleanupCallback));
  }
  componentWillUnmount() {
    if (fl) {
      this.cleanup();
      var t = () => {
        this.check || (delete window.google, sc = !1);
      };
      window.setTimeout(t, 1), this.props.onUnmount && this.props.onUnmount();
    }
  }
  render() {
    return X.jsxs(X.Fragment, {
      children: [X.jsx("div", {
        ref: this.getRef
      }), this.state.loaded ? this.props.children : this.props.loadingElement || X.jsx(h4, {})]
    });
  }
}
ge(g4, "defaultProps", qx);
function MAe(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.includes(r)) continue;
    n[r] = e[r];
  }
  return n;
}
function B1(e, t) {
  if (e == null) return {};
  var n, r, o = MAe(e, t);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (r = 0; r < i.length; r++) n = i[r], t.includes(n) || {}.propertyIsEnumerable.call(e, n) && (o[n] = e[n]);
  }
  return o;
}
var Nz;
function DAe(e) {
  var {
    id: t = qx.id,
    version: n = qx.version,
    nonce: r,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    preventGoogleFontsLoading: u,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  } = e, h = rt(!1), [f, m] = k(!1), [g, E] = k(void 0);
  v(function() {
    return h.current = !0, () => {
      h.current = !1;
    };
  }, []), v(function() {
    fl && u && f4();
  }, [u]), v(function() {
    f && Yr(!!window.google, "useLoadScript was marked as loaded, but window.google is not present. Something went wrong.");
  }, [f]);
  var w = p4({
    version: n,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  });
  v(function() {
    if (!fl)
      return;
    function y() {
      h.current && (m(!0), Nz = w);
    }
    if (window.google && window.google.maps && Nz === w) {
      y();
      return;
    }
    d4({
      id: t,
      url: w,
      nonce: r
    }).then(y).catch(function(P) {
      h.current && E(P), console.warn(`
        There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(o || "-", ") or Client ID (").concat(i || "-", `)
        Otherwise it is a Network issue.
      `)), console.error(P);
    });
  }, [t, w, r]);
  var M = rt(void 0);
  return v(function() {
    M.current && l !== M.current && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), M.current = l;
  }, [l]), {
    isLoaded: f,
    loadError: g,
    url: w
  };
}
var TAe = ["loadingElement", "onLoad", "onError", "onUnmount", "children"], jAe = X.jsx(h4, {});
function AAe(e) {
  var {
    loadingElement: t,
    onLoad: n,
    onError: r,
    onUnmount: o,
    children: i
  } = e, a = B1(e, TAe), {
    isLoaded: s,
    loadError: l
  } = DAe(a);
  return v(function() {
    s && typeof n == "function" && n();
  }, [s, n]), v(function() {
    l && typeof r == "function" && r(l);
  }, [l, r]), v(function() {
    return () => {
      o && o();
    };
  }, [o]), s ? i : t || jAe;
}
Ee(AAe);
var Fz;
(function(e) {
  e[e.INITIALIZED = 0] = "INITIALIZED", e[e.LOADING = 1] = "LOADING", e[e.SUCCESS = 2] = "SUCCESS", e[e.FAILURE = 3] = "FAILURE";
})(Fz || (Fz = {}));
function zz(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function wm(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? zz(Object(n), !0).forEach(function(r) {
      ge(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : zz(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Uz = {}, $z = {
  options(e, t) {
    e.setOptions(t);
  }
};
function BAe(e) {
  var {
    options: t,
    onLoad: n,
    onUnmount: r
  } = e, o = ye(_t), [i, a] = k(null);
  return v(() => {
    i !== null && i.setMap(o);
  }, [o]), v(() => {
    t && i !== null && i.setOptions(t);
  }, [i, t]), v(() => {
    var s = new google.maps.TrafficLayer(wm(wm({}, t), {}, {
      map: o
    }));
    return a(s), n && n(s), () => {
      i !== null && (r && r(i), i.setMap(null));
    };
  }, []), null;
}
Ee(BAe);
class IAe extends pe {
  constructor() {
    super(...arguments), ge(this, "state", {
      trafficLayer: null
    }), ge(this, "setTrafficLayerCallback", () => {
      this.state.trafficLayer !== null && this.props.onLoad && this.props.onLoad(this.state.trafficLayer);
    }), ge(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = new google.maps.TrafficLayer(wm(wm({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Ft({
      updaterMap: $z,
      eventMap: Uz,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        trafficLayer: t
      };
    }, this.setTrafficLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.trafficLayer !== null && (qt(this.registeredEvents), this.registeredEvents = Ft({
      updaterMap: $z,
      eventMap: Uz,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.trafficLayer
    }));
  }
  componentWillUnmount() {
    this.state.trafficLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.trafficLayer), qt(this.registeredEvents), this.state.trafficLayer.setMap(null));
  }
  render() {
    return null;
  }
}
ge(IAe, "contextType", _t);
function RAe(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = ye(_t), [o, i] = k(null);
  return v(() => {
    o !== null && o.setMap(r);
  }, [r]), v(() => {
    var a = new google.maps.BicyclingLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      a !== null && (n && n(a), a.setMap(null));
    };
  }, []), null;
}
Ee(RAe);
class NAe extends pe {
  constructor() {
    super(...arguments), ge(this, "state", {
      bicyclingLayer: null
    }), ge(this, "setBicyclingLayerCallback", () => {
      this.state.bicyclingLayer !== null && (this.state.bicyclingLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.bicyclingLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.BicyclingLayer();
    this.setState(() => ({
      bicyclingLayer: t
    }), this.setBicyclingLayerCallback);
  }
  componentWillUnmount() {
    this.state.bicyclingLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.bicyclingLayer), this.state.bicyclingLayer.setMap(null));
  }
  render() {
    return null;
  }
}
ge(NAe, "contextType", _t);
function FAe(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = ye(_t), [o, i] = k(null);
  return v(() => {
    o !== null && o.setMap(r);
  }, [r]), v(() => {
    var a = new google.maps.TransitLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      o !== null && (n && n(o), o.setMap(null));
    };
  }, []), null;
}
Ee(FAe);
class zAe extends pe {
  constructor() {
    super(...arguments), ge(this, "state", {
      transitLayer: null
    }), ge(this, "setTransitLayerCallback", () => {
      this.state.transitLayer !== null && (this.state.transitLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.transitLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.TransitLayer();
    this.setState(function() {
      return {
        transitLayer: t
      };
    }, this.setTransitLayerCallback);
  }
  componentWillUnmount() {
    this.state.transitLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.transitLayer), this.state.transitLayer.setMap(null));
  }
  render() {
    return null;
  }
}
ge(zAe, "contextType", _t);
function Hz(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Cm(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Hz(Object(n), !0).forEach(function(r) {
      ge(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Hz(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Wz = {
  onCircleComplete: "circlecomplete",
  onMarkerComplete: "markercomplete",
  onOverlayComplete: "overlaycomplete",
  onPolygonComplete: "polygoncomplete",
  onPolylineComplete: "polylinecomplete",
  onRectangleComplete: "rectanglecomplete"
}, Vz = {
  drawingMode(e, t) {
    e.setDrawingMode(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function UAe(e) {
  var {
    options: t,
    drawingMode: n,
    onCircleComplete: r,
    onMarkerComplete: o,
    onOverlayComplete: i,
    onPolygonComplete: a,
    onPolylineComplete: s,
    onRectangleComplete: l,
    onLoad: u,
    onUnmount: c
  } = e, p = ye(_t), [d, h] = k(null), [f, m] = k(null), [g, E] = k(null), [w, M] = k(null), [x, y] = k(null), [C, P] = k(null), [F, L] = k(null);
  return v(() => {
    d !== null && d.setMap(p);
  }, [p]), v(() => {
    t && d !== null && d.setOptions(t);
  }, [d, t]), v(() => {
    d !== null && d.setDrawingMode(n ?? null);
  }, [d, n]), v(() => {
    d && r && (f !== null && google.maps.event.removeListener(f), m(google.maps.event.addListener(d, "circlecomplete", r)));
  }, [d, r]), v(() => {
    d && o && (g !== null && google.maps.event.removeListener(g), E(google.maps.event.addListener(d, "markercomplete", o)));
  }, [d, o]), v(() => {
    d && i && (w !== null && google.maps.event.removeListener(w), M(google.maps.event.addListener(d, "overlaycomplete", i)));
  }, [d, i]), v(() => {
    d && a && (x !== null && google.maps.event.removeListener(x), y(google.maps.event.addListener(d, "polygoncomplete", a)));
  }, [d, a]), v(() => {
    d && s && (C !== null && google.maps.event.removeListener(C), P(google.maps.event.addListener(d, "polylinecomplete", s)));
  }, [d, s]), v(() => {
    d && l && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(d, "rectanglecomplete", l)));
  }, [d, l]), v(() => {
    Yr(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
    var N = new google.maps.drawing.DrawingManager(Cm(Cm({}, t), {}, {
      map: p
    }));
    return n && N.setDrawingMode(n), r && m(google.maps.event.addListener(N, "circlecomplete", r)), o && E(google.maps.event.addListener(N, "markercomplete", o)), i && M(google.maps.event.addListener(N, "overlaycomplete", i)), a && y(google.maps.event.addListener(N, "polygoncomplete", a)), s && P(google.maps.event.addListener(N, "polylinecomplete", s)), l && L(google.maps.event.addListener(N, "rectanglecomplete", l)), h(N), u && u(N), () => {
      d !== null && (f && google.maps.event.removeListener(f), g && google.maps.event.removeListener(g), w && google.maps.event.removeListener(w), x && google.maps.event.removeListener(x), C && google.maps.event.removeListener(C), F && google.maps.event.removeListener(F), c && c(d), d.setMap(null));
    };
  }, []), null;
}
Ee(UAe);
class $Ae extends pe {
  constructor(t) {
    super(t), ge(this, "registeredEvents", []), ge(this, "state", {
      drawingManager: null
    }), ge(this, "setDrawingManagerCallback", () => {
      this.state.drawingManager !== null && this.props.onLoad && this.props.onLoad(this.state.drawingManager);
    }), Yr(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
  }
  componentDidMount() {
    var t = new google.maps.drawing.DrawingManager(Cm(Cm({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Ft({
      updaterMap: Vz,
      eventMap: Wz,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        drawingManager: t
      };
    }, this.setDrawingManagerCallback);
  }
  componentDidUpdate(t) {
    this.state.drawingManager !== null && (qt(this.registeredEvents), this.registeredEvents = Ft({
      updaterMap: Vz,
      eventMap: Wz,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.drawingManager
    }));
  }
  componentWillUnmount() {
    this.state.drawingManager !== null && (this.props.onUnmount && this.props.onUnmount(this.state.drawingManager), qt(this.registeredEvents), this.state.drawingManager.setMap(null));
  }
  render() {
    return null;
  }
}
ge($Ae, "contextType", _t);
function qz(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function nu(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? qz(Object(n), !0).forEach(function(r) {
      ge(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : qz(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Zz = {
  onAnimationChanged: "animation_changed",
  onClick: "click",
  onClickableChanged: "clickable_changed",
  onCursorChanged: "cursor_changed",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDraggableChanged: "draggable_changed",
  onDragStart: "dragstart",
  onFlatChanged: "flat_changed",
  onIconChanged: "icon_changed",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onPositionChanged: "position_changed",
  onRightClick: "rightclick",
  onShapeChanged: "shape_changed",
  onTitleChanged: "title_changed",
  onVisibleChanged: "visible_changed",
  onZindexChanged: "zindex_changed"
}, Gz = {
  animation(e, t) {
    e.setAnimation(t);
  },
  clickable(e, t) {
    e.setClickable(t);
  },
  cursor(e, t) {
    e.setCursor(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  icon(e, t) {
    e.setIcon(t);
  },
  label(e, t) {
    e.setLabel(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  opacity(e, t) {
    e.setOpacity(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  shape(e, t) {
    e.setShape(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, xm = {};
function HAe(e) {
  var {
    position: t,
    options: n,
    clusterer: r,
    noClustererRedraw: o,
    children: i,
    draggable: a,
    visible: s,
    animation: l,
    clickable: u,
    cursor: c,
    icon: p,
    label: d,
    opacity: h,
    shape: f,
    title: m,
    zIndex: g,
    onClick: E,
    onDblClick: w,
    onDrag: M,
    onDragEnd: x,
    onDragStart: y,
    onMouseOut: C,
    onMouseOver: P,
    onMouseUp: F,
    onMouseDown: L,
    onRightClick: N,
    onClickableChanged: I,
    onCursorChanged: H,
    onAnimationChanged: V,
    onDraggableChanged: z,
    onFlatChanged: q,
    onIconChanged: K,
    onPositionChanged: J,
    onShapeChanged: te,
    onTitleChanged: ee,
    onVisibleChanged: _,
    onZindexChanged: D,
    onLoad: $,
    onUnmount: S
  } = e, W = ye(_t), [O, T] = k(null), [U, j] = k(null), [Z, A] = k(null), [Q, R] = k(null), [ue, fe] = k(null), [oe, Re] = k(null), [He, Ve] = k(null), [ze, et] = k(null), [Ge, Pe] = k(null), [Ye, it] = k(null), [_e, Se] = k(null), [Ke, We] = k(null), [Ue, nt] = k(null), [Ie, xt] = k(null), [ot, st] = k(null), [lt, Ot] = k(null), [ut, ct] = k(null), [tt, Xe] = k(null), [Et, kt] = k(null), [pt, kn] = k(null), [dt, Ln] = k(null), [ft, rn] = k(null);
  v(() => {
    O !== null && O.setMap(W);
  }, [W]), v(() => {
    typeof n < "u" && O !== null && O.setOptions(n);
  }, [O, n]), v(() => {
    typeof a < "u" && O !== null && O.setDraggable(a);
  }, [O, a]), v(() => {
    t && O !== null && O.setPosition(t);
  }, [O, t]), v(() => {
    typeof s < "u" && O !== null && O.setVisible(s);
  }, [O, s]), v(() => {
    O == null || O.setAnimation(l);
  }, [O, l]), v(() => {
    O && u !== void 0 && O.setClickable(u);
  }, [O, u]), v(() => {
    O && c !== void 0 && O.setCursor(c);
  }, [O, c]), v(() => {
    O && p !== void 0 && O.setIcon(p);
  }, [O, p]), v(() => {
    O && d !== void 0 && O.setLabel(d);
  }, [O, d]), v(() => {
    O && h !== void 0 && O.setOpacity(h);
  }, [O, h]), v(() => {
    O && f !== void 0 && O.setShape(f);
  }, [O, f]), v(() => {
    O && m !== void 0 && O.setTitle(m);
  }, [O, m]), v(() => {
    O && g !== void 0 && O.setZIndex(g);
  }, [O, g]), v(() => {
    O && w && (U !== null && google.maps.event.removeListener(U), j(google.maps.event.addListener(O, "dblclick", w)));
  }, [w]), v(() => {
    O && x && (Z !== null && google.maps.event.removeListener(Z), A(google.maps.event.addListener(O, "dragend", x)));
  }, [x]), v(() => {
    O && y && (Q !== null && google.maps.event.removeListener(Q), R(google.maps.event.addListener(O, "dragstart", y)));
  }, [y]), v(() => {
    O && L && (ue !== null && google.maps.event.removeListener(ue), fe(google.maps.event.addListener(O, "mousedown", L)));
  }, [L]), v(() => {
    O && C && (oe !== null && google.maps.event.removeListener(oe), Re(google.maps.event.addListener(O, "mouseout", C)));
  }, [C]), v(() => {
    O && P && (He !== null && google.maps.event.removeListener(He), Ve(google.maps.event.addListener(O, "mouseover", P)));
  }, [P]), v(() => {
    O && F && (ze !== null && google.maps.event.removeListener(ze), et(google.maps.event.addListener(O, "mouseup", F)));
  }, [F]), v(() => {
    O && N && (Ge !== null && google.maps.event.removeListener(Ge), Pe(google.maps.event.addListener(O, "rightclick", N)));
  }, [N]), v(() => {
    O && E && (Ye !== null && google.maps.event.removeListener(Ye), it(google.maps.event.addListener(O, "click", E)));
  }, [E]), v(() => {
    O && M && (_e !== null && google.maps.event.removeListener(_e), Se(google.maps.event.addListener(O, "drag", M)));
  }, [M]), v(() => {
    O && I && (Ke !== null && google.maps.event.removeListener(Ke), We(google.maps.event.addListener(O, "clickable_changed", I)));
  }, [I]), v(() => {
    O && H && (Ue !== null && google.maps.event.removeListener(Ue), nt(google.maps.event.addListener(O, "cursor_changed", H)));
  }, [H]), v(() => {
    O && V && (Ie !== null && google.maps.event.removeListener(Ie), xt(google.maps.event.addListener(O, "animation_changed", V)));
  }, [V]), v(() => {
    O && z && (ot !== null && google.maps.event.removeListener(ot), st(google.maps.event.addListener(O, "draggable_changed", z)));
  }, [z]), v(() => {
    O && q && (lt !== null && google.maps.event.removeListener(lt), Ot(google.maps.event.addListener(O, "flat_changed", q)));
  }, [q]), v(() => {
    O && K && (ut !== null && google.maps.event.removeListener(ut), ct(google.maps.event.addListener(O, "icon_changed", K)));
  }, [K]), v(() => {
    O && J && (tt !== null && google.maps.event.removeListener(tt), Xe(google.maps.event.addListener(O, "position_changed", J)));
  }, [J]), v(() => {
    O && te && (Et !== null && google.maps.event.removeListener(Et), kt(google.maps.event.addListener(O, "shape_changed", te)));
  }, [te]), v(() => {
    O && ee && (pt !== null && google.maps.event.removeListener(pt), kn(google.maps.event.addListener(O, "title_changed", ee)));
  }, [ee]), v(() => {
    O && _ && (dt !== null && google.maps.event.removeListener(dt), Ln(google.maps.event.addListener(O, "visible_changed", _)));
  }, [_]), v(() => {
    O && D && (ft !== null && google.maps.event.removeListener(ft), rn(google.maps.event.addListener(O, "zindex_changed", D)));
  }, [D]), v(() => {
    var ht = nu(nu(nu({}, n || xm), r ? xm : {
      map: W
    }), {}, {
      position: t
    }), re = new google.maps.Marker(ht);
    return r ? r.addMarker(re, !!o) : re.setMap(W), t && re.setPosition(t), typeof s < "u" && re.setVisible(s), typeof a < "u" && re.setDraggable(a), typeof u < "u" && re.setClickable(u), typeof c == "string" && re.setCursor(c), p && re.setIcon(p), typeof d < "u" && re.setLabel(d), typeof h < "u" && re.setOpacity(h), f && re.setShape(f), typeof m == "string" && re.setTitle(m), typeof g == "number" && re.setZIndex(g), w && j(google.maps.event.addListener(re, "dblclick", w)), x && A(google.maps.event.addListener(re, "dragend", x)), y && R(google.maps.event.addListener(re, "dragstart", y)), L && fe(google.maps.event.addListener(re, "mousedown", L)), C && Re(google.maps.event.addListener(re, "mouseout", C)), P && Ve(google.maps.event.addListener(re, "mouseover", P)), F && et(google.maps.event.addListener(re, "mouseup", F)), N && Pe(google.maps.event.addListener(re, "rightclick", N)), E && it(google.maps.event.addListener(re, "click", E)), M && Se(google.maps.event.addListener(re, "drag", M)), I && We(google.maps.event.addListener(re, "clickable_changed", I)), H && nt(google.maps.event.addListener(re, "cursor_changed", H)), V && xt(google.maps.event.addListener(re, "animation_changed", V)), z && st(google.maps.event.addListener(re, "draggable_changed", z)), q && Ot(google.maps.event.addListener(re, "flat_changed", q)), K && ct(google.maps.event.addListener(re, "icon_changed", K)), J && Xe(google.maps.event.addListener(re, "position_changed", J)), te && kt(google.maps.event.addListener(re, "shape_changed", te)), ee && kn(google.maps.event.addListener(re, "title_changed", ee)), _ && Ln(google.maps.event.addListener(re, "visible_changed", _)), D && rn(google.maps.event.addListener(re, "zindex_changed", D)), T(re), $ && $(re), () => {
      U !== null && google.maps.event.removeListener(U), Z !== null && google.maps.event.removeListener(Z), Q !== null && google.maps.event.removeListener(Q), ue !== null && google.maps.event.removeListener(ue), oe !== null && google.maps.event.removeListener(oe), He !== null && google.maps.event.removeListener(He), ze !== null && google.maps.event.removeListener(ze), Ge !== null && google.maps.event.removeListener(Ge), Ye !== null && google.maps.event.removeListener(Ye), Ke !== null && google.maps.event.removeListener(Ke), Ue !== null && google.maps.event.removeListener(Ue), Ie !== null && google.maps.event.removeListener(Ie), ot !== null && google.maps.event.removeListener(ot), lt !== null && google.maps.event.removeListener(lt), ut !== null && google.maps.event.removeListener(ut), tt !== null && google.maps.event.removeListener(tt), pt !== null && google.maps.event.removeListener(pt), dt !== null && google.maps.event.removeListener(dt), ft !== null && google.maps.event.removeListener(ft), S && S(re), r ? r.removeMarker(re, !!o) : re && re.setMap(null);
    };
  }, []);
  var br = Tn(() => i ? at.map(i, (ht) => {
    if (!bi(ht))
      return ht;
    var re = ht;
    return wi(re, {
      anchor: O
    });
  }) : null, [i, O]);
  return X.jsx(X.Fragment, {
    children: br
  }) || null;
}
Ee(HAe);
class m4 extends pe {
  constructor() {
    super(...arguments), ge(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this;
    return c4(function* () {
      var n = nu(nu(nu({}, t.props.options || xm), t.props.clusterer ? xm : {
        map: t.context
      }), {}, {
        position: t.props.position
      });
      t.marker = new google.maps.Marker(n), t.props.clusterer ? t.props.clusterer.addMarker(t.marker, !!t.props.noClustererRedraw) : t.marker.setMap(t.context), t.registeredEvents = Ft({
        updaterMap: Gz,
        eventMap: Zz,
        prevProps: {},
        nextProps: t.props,
        instance: t.marker
      }), t.props.onLoad && t.props.onLoad(t.marker);
    })();
  }
  componentDidUpdate(t) {
    this.marker && (qt(this.registeredEvents), this.registeredEvents = Ft({
      updaterMap: Gz,
      eventMap: Zz,
      prevProps: t,
      nextProps: this.props,
      instance: this.marker
    }));
  }
  componentWillUnmount() {
    this.marker && (this.props.onUnmount && this.props.onUnmount(this.marker), qt(this.registeredEvents), this.props.clusterer ? this.props.clusterer.removeMarker(this.marker, !!this.props.noClustererRedraw) : this.marker && this.marker.setMap(null));
  }
  render() {
    var t = this.props.children ? at.map(this.props.children, (n) => {
      if (!bi(n))
        return n;
      var r = n;
      return wi(r, {
        anchor: this.marker
      });
    }) : null;
    return t || null;
  }
}
ge(m4, "contextType", _t);
var WAe = (
  /** @class */
  function() {
    function e(t, n) {
      t.getClusterer().extend(e, google.maps.OverlayView), this.cluster = t, this.clusterClassName = this.cluster.getClusterer().getClusterClass(), this.className = this.clusterClassName, this.styles = n, this.center = void 0, this.div = null, this.sums = null, this.visible = !1, this.boundsChangedListener = null, this.url = "", this.height = 0, this.width = 0, this.anchorText = [0, 0], this.anchorIcon = [0, 0], this.textColor = "black", this.textSize = 11, this.textDecoration = "none", this.fontWeight = "bold", this.fontStyle = "normal", this.fontFamily = "Arial,sans-serif", this.backgroundPosition = "0 0", this.cMouseDownInCluster = null, this.cDraggingMapByCluster = null, this.timeOut = null, this.setMap(t.getMap()), this.onBoundsChanged = this.onBoundsChanged.bind(this), this.onMouseDown = this.onMouseDown.bind(this), this.onClick = this.onClick.bind(this), this.onMouseOver = this.onMouseOver.bind(this), this.onMouseOut = this.onMouseOut.bind(this), this.onAdd = this.onAdd.bind(this), this.onRemove = this.onRemove.bind(this), this.draw = this.draw.bind(this), this.hide = this.hide.bind(this), this.show = this.show.bind(this), this.useStyle = this.useStyle.bind(this), this.setCenter = this.setCenter.bind(this), this.getPosFromLatLng = this.getPosFromLatLng.bind(this);
    }
    return e.prototype.onBoundsChanged = function() {
      this.cDraggingMapByCluster = this.cMouseDownInCluster;
    }, e.prototype.onMouseDown = function() {
      this.cMouseDownInCluster = !0, this.cDraggingMapByCluster = !1;
    }, e.prototype.onClick = function(t) {
      if (this.cMouseDownInCluster = !1, !this.cDraggingMapByCluster) {
        var n = this.cluster.getClusterer();
        if (google.maps.event.trigger(n, "click", this.cluster), google.maps.event.trigger(n, "clusterclick", this.cluster), n.getZoomOnClick()) {
          var r = n.getMaxZoom(), o = this.cluster.getBounds(), i = n.getMap();
          i !== null && "fitBounds" in i && i.fitBounds(o), this.timeOut = window.setTimeout(function() {
            var a = n.getMap();
            if (a !== null) {
              "fitBounds" in a && a.fitBounds(o);
              var s = a.getZoom() || 0;
              r !== null && s > r && a.setZoom(r + 1);
            }
          }, 100);
        }
        t.cancelBubble = !0, t.stopPropagation && t.stopPropagation();
      }
    }, e.prototype.onMouseOver = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseover", this.cluster);
    }, e.prototype.onMouseOut = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseout", this.cluster);
    }, e.prototype.onAdd = function() {
      var t;
      this.div = document.createElement("div"), this.div.className = this.className, this.visible && this.show(), (t = this.getPanes()) === null || t === void 0 || t.overlayMouseTarget.appendChild(this.div);
      var n = this.getMap();
      n !== null && (this.boundsChangedListener = google.maps.event.addListener(n, "bounds_changed", this.onBoundsChanged), this.div.addEventListener("mousedown", this.onMouseDown), this.div.addEventListener("click", this.onClick), this.div.addEventListener("mouseover", this.onMouseOver), this.div.addEventListener("mouseout", this.onMouseOut));
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.hide(), this.boundsChangedListener !== null && google.maps.event.removeListener(this.boundsChangedListener), this.div.removeEventListener("mousedown", this.onMouseDown), this.div.removeEventListener("click", this.onClick), this.div.removeEventListener("mouseover", this.onMouseOver), this.div.removeEventListener("mouseout", this.onMouseOut), this.div.parentNode.removeChild(this.div), this.timeOut !== null && (window.clearTimeout(this.timeOut), this.timeOut = null), this.div = null);
    }, e.prototype.draw = function() {
      if (this.visible && this.div !== null && this.center) {
        var t = this.getPosFromLatLng(this.center);
        this.div.style.top = t !== null ? "".concat(t.y, "px") : "0", this.div.style.left = t !== null ? "".concat(t.x, "px") : "0";
      }
    }, e.prototype.hide = function() {
      this.div && (this.div.style.display = "none"), this.visible = !1;
    }, e.prototype.show = function() {
      var t, n, r, o, i, a;
      if (this.div && this.center) {
        var s = this.sums === null || typeof this.sums.title > "u" || this.sums.title === "" ? this.cluster.getClusterer().getTitle() : this.sums.title, l = this.backgroundPosition.split(" "), u = parseInt(((t = l[0]) === null || t === void 0 ? void 0 : t.replace(/^\s+|\s+$/g, "")) || "0", 10), c = parseInt(((n = l[1]) === null || n === void 0 ? void 0 : n.replace(/^\s+|\s+$/g, "")) || "0", 10), p = this.getPosFromLatLng(this.center);
        this.div.className = this.className, this.div.setAttribute("style", "cursor: pointer; position: absolute; top: ".concat(p !== null ? "".concat(p.y, "px") : "0", "; left: ").concat(p !== null ? "".concat(p.x, "px") : "0", "; width: ").concat(this.width, "px; height: ").concat(this.height, "px; "));
        var d = document.createElement("img");
        d.alt = s, d.src = this.url, d.width = this.width, d.height = this.height, d.setAttribute("style", "position: absolute; top: ".concat(c, "px; left: ").concat(u, "px")), this.cluster.getClusterer().enableRetinaIcons || (d.style.clip = "rect(-".concat(c, "px, -").concat(u + this.width, "px, -").concat(c + this.height, ", -").concat(u, ")"));
        var h = document.createElement("div");
        h.setAttribute("style", "position: absolute; top: ".concat(this.anchorText[0], "px; left: ").concat(this.anchorText[1], "px; color: ").concat(this.textColor, "; font-size: ").concat(this.textSize, "px; font-family: ").concat(this.fontFamily, "; font-weight: ").concat(this.fontWeight, "; fontStyle: ").concat(this.fontStyle, "; text-decoration: ").concat(this.textDecoration, "; text-align: center; width: ").concat(this.width, "px; line-height: ").concat(this.height, "px")), !((r = this.sums) === null || r === void 0) && r.text && (h.innerText = "".concat((o = this.sums) === null || o === void 0 ? void 0 : o.text)), !((i = this.sums) === null || i === void 0) && i.html && (h.innerHTML = "".concat((a = this.sums) === null || a === void 0 ? void 0 : a.html)), this.div.innerHTML = "", this.div.appendChild(d), this.div.appendChild(h), this.div.title = s, this.div.style.display = "";
      }
      this.visible = !0;
    }, e.prototype.useStyle = function(t) {
      this.sums = t;
      var n = this.cluster.getClusterer().getStyles(), r = n[Math.min(n.length - 1, Math.max(0, t.index - 1))];
      r && (this.url = r.url, this.height = r.height, this.width = r.width, r.className && (this.className = "".concat(this.clusterClassName, " ").concat(r.className)), this.anchorText = r.anchorText || [0, 0], this.anchorIcon = r.anchorIcon || [this.height / 2, this.width / 2], this.textColor = r.textColor || "black", this.textSize = r.textSize || 11, this.textDecoration = r.textDecoration || "none", this.fontWeight = r.fontWeight || "bold", this.fontStyle = r.fontStyle || "normal", this.fontFamily = r.fontFamily || "Arial,sans-serif", this.backgroundPosition = r.backgroundPosition || "0 0");
    }, e.prototype.setCenter = function(t) {
      this.center = t;
    }, e.prototype.getPosFromLatLng = function(t) {
      var n = this.getProjection().fromLatLngToDivPixel(t);
      return n !== null && (n.x -= this.anchorIcon[1], n.y -= this.anchorIcon[0]), n;
    }, e;
  }()
), VAe = (
  /** @class */
  function() {
    function e(t) {
      this.markerClusterer = t, this.map = this.markerClusterer.getMap(), this.gridSize = this.markerClusterer.getGridSize(), this.minClusterSize = this.markerClusterer.getMinimumClusterSize(), this.averageCenter = this.markerClusterer.getAverageCenter(), this.markers = [], this.center = void 0, this.bounds = null, this.clusterIcon = new WAe(this, this.markerClusterer.getStyles()), this.getSize = this.getSize.bind(this), this.getMarkers = this.getMarkers.bind(this), this.getCenter = this.getCenter.bind(this), this.getMap = this.getMap.bind(this), this.getClusterer = this.getClusterer.bind(this), this.getBounds = this.getBounds.bind(this), this.remove = this.remove.bind(this), this.addMarker = this.addMarker.bind(this), this.isMarkerInClusterBounds = this.isMarkerInClusterBounds.bind(this), this.calculateBounds = this.calculateBounds.bind(this), this.updateIcon = this.updateIcon.bind(this), this.isMarkerAlreadyAdded = this.isMarkerAlreadyAdded.bind(this);
    }
    return e.prototype.getSize = function() {
      return this.markers.length;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getCenter = function() {
      return this.center;
    }, e.prototype.getMap = function() {
      return this.map;
    }, e.prototype.getClusterer = function() {
      return this.markerClusterer;
    }, e.prototype.getBounds = function() {
      for (var t = new google.maps.LatLngBounds(this.center, this.center), n = this.getMarkers(), r = 0, o = n; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && t.extend(a);
      }
      return t;
    }, e.prototype.remove = function() {
      this.clusterIcon.setMap(null), this.markers = [], delete this.markers;
    }, e.prototype.addMarker = function(t) {
      var n;
      if (this.isMarkerAlreadyAdded(t))
        return !1;
      if (this.center) {
        if (this.averageCenter) {
          var r = t.getPosition();
          if (r) {
            var o = this.markers.length + 1;
            this.center = new google.maps.LatLng((this.center.lat() * (o - 1) + r.lat()) / o, (this.center.lng() * (o - 1) + r.lng()) / o), this.calculateBounds();
          }
        }
      } else {
        var r = t.getPosition();
        r && (this.center = r, this.calculateBounds());
      }
      t.isAdded = !0, this.markers.push(t);
      var i = this.markers.length, a = this.markerClusterer.getMaxZoom(), s = (n = this.map) === null || n === void 0 ? void 0 : n.getZoom();
      if (a !== null && typeof s < "u" && s > a)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i < this.minClusterSize)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i === this.minClusterSize)
        for (var l = 0, u = this.markers; l < u.length; l++) {
          var c = u[l];
          c.setMap(null);
        }
      else
        t.setMap(null);
      return !0;
    }, e.prototype.isMarkerInClusterBounds = function(t) {
      if (this.bounds !== null) {
        var n = t.getPosition();
        if (n)
          return this.bounds.contains(n);
      }
      return !1;
    }, e.prototype.calculateBounds = function() {
      this.bounds = this.markerClusterer.getExtendedBounds(new google.maps.LatLngBounds(this.center, this.center));
    }, e.prototype.updateIcon = function() {
      var t, n = this.markers.length, r = this.markerClusterer.getMaxZoom(), o = (t = this.map) === null || t === void 0 ? void 0 : t.getZoom();
      if (r !== null && typeof o < "u" && o > r) {
        this.clusterIcon.hide();
        return;
      }
      if (n < this.minClusterSize) {
        this.clusterIcon.hide();
        return;
      }
      this.center && this.clusterIcon.setCenter(this.center), this.clusterIcon.useStyle(this.markerClusterer.getCalculator()(this.markers, this.markerClusterer.getStyles().length)), this.clusterIcon.show();
    }, e.prototype.isMarkerAlreadyAdded = function(t) {
      if (this.markers.includes)
        return this.markers.includes(t);
      for (var n = 0; n < this.markers.length; n++)
        if (t === this.markers[n])
          return !0;
      return !1;
    }, e;
  }()
);
function qAe(e, t) {
  var n = e.length, r = n.toString().length, o = Math.min(r, t);
  return {
    text: n.toString(),
    index: o,
    title: ""
  };
}
var ZAe = 2e3, GAe = 500, XAe = "https://developers.google.com/maps/documentation/javascript/examples/markerclusterer/m", KAe = "png", YAe = [53, 56, 66, 78, 90], JAe = "cluster", v4 = (
  /** @class */
  function() {
    function e(t, n, r) {
      n === void 0 && (n = []), r === void 0 && (r = {}), this.getMinimumClusterSize = this.getMinimumClusterSize.bind(this), this.setMinimumClusterSize = this.setMinimumClusterSize.bind(this), this.getEnableRetinaIcons = this.getEnableRetinaIcons.bind(this), this.setEnableRetinaIcons = this.setEnableRetinaIcons.bind(this), this.addToClosestCluster = this.addToClosestCluster.bind(this), this.getImageExtension = this.getImageExtension.bind(this), this.setImageExtension = this.setImageExtension.bind(this), this.getExtendedBounds = this.getExtendedBounds.bind(this), this.getAverageCenter = this.getAverageCenter.bind(this), this.setAverageCenter = this.setAverageCenter.bind(this), this.getTotalClusters = this.getTotalClusters.bind(this), this.fitMapToMarkers = this.fitMapToMarkers.bind(this), this.getIgnoreHidden = this.getIgnoreHidden.bind(this), this.setIgnoreHidden = this.setIgnoreHidden.bind(this), this.getClusterClass = this.getClusterClass.bind(this), this.setClusterClass = this.setClusterClass.bind(this), this.getTotalMarkers = this.getTotalMarkers.bind(this), this.getZoomOnClick = this.getZoomOnClick.bind(this), this.setZoomOnClick = this.setZoomOnClick.bind(this), this.getBatchSizeIE = this.getBatchSizeIE.bind(this), this.setBatchSizeIE = this.setBatchSizeIE.bind(this), this.createClusters = this.createClusters.bind(this), this.onZoomChanged = this.onZoomChanged.bind(this), this.getImageSizes = this.getImageSizes.bind(this), this.setImageSizes = this.setImageSizes.bind(this), this.getCalculator = this.getCalculator.bind(this), this.setCalculator = this.setCalculator.bind(this), this.removeMarkers = this.removeMarkers.bind(this), this.resetViewport = this.resetViewport.bind(this), this.getImagePath = this.getImagePath.bind(this), this.setImagePath = this.setImagePath.bind(this), this.pushMarkerTo = this.pushMarkerTo.bind(this), this.removeMarker = this.removeMarker.bind(this), this.clearMarkers = this.clearMarkers.bind(this), this.setupStyles = this.setupStyles.bind(this), this.getGridSize = this.getGridSize.bind(this), this.setGridSize = this.setGridSize.bind(this), this.getClusters = this.getClusters.bind(this), this.getMaxZoom = this.getMaxZoom.bind(this), this.setMaxZoom = this.setMaxZoom.bind(this), this.getMarkers = this.getMarkers.bind(this), this.addMarkers = this.addMarkers.bind(this), this.getStyles = this.getStyles.bind(this), this.setStyles = this.setStyles.bind(this), this.addMarker = this.addMarker.bind(this), this.onRemove = this.onRemove.bind(this), this.getTitle = this.getTitle.bind(this), this.setTitle = this.setTitle.bind(this), this.repaint = this.repaint.bind(this), this.onIdle = this.onIdle.bind(this), this.redraw = this.redraw.bind(this), this.onAdd = this.onAdd.bind(this), this.draw = this.draw.bind(this), this.extend = this.extend.bind(this), this.extend(e, google.maps.OverlayView), this.markers = [], this.clusters = [], this.listeners = [], this.activeMap = null, this.ready = !1, this.gridSize = r.gridSize || 60, this.minClusterSize = r.minimumClusterSize || 2, this.maxZoom = r.maxZoom || null, this.styles = r.styles || [], this.title = r.title || "", this.zoomOnClick = !0, r.zoomOnClick !== void 0 && (this.zoomOnClick = r.zoomOnClick), this.averageCenter = !1, r.averageCenter !== void 0 && (this.averageCenter = r.averageCenter), this.ignoreHidden = !1, r.ignoreHidden !== void 0 && (this.ignoreHidden = r.ignoreHidden), this.enableRetinaIcons = !1, r.enableRetinaIcons !== void 0 && (this.enableRetinaIcons = r.enableRetinaIcons), this.imagePath = r.imagePath || XAe, this.imageExtension = r.imageExtension || KAe, this.imageSizes = r.imageSizes || YAe, this.calculator = r.calculator || qAe, this.batchSize = r.batchSize || ZAe, this.batchSizeIE = r.batchSizeIE || GAe, this.clusterClass = r.clusterClass || JAe, navigator.userAgent.toLowerCase().indexOf("msie") !== -1 && (this.batchSize = this.batchSizeIE), this.timerRefStatic = null, this.setupStyles(), this.addMarkers(n, !0), this.setMap(t);
    }
    return e.prototype.onZoomChanged = function() {
      var t, n;
      this.resetViewport(!1), (((t = this.getMap()) === null || t === void 0 ? void 0 : t.getZoom()) === (this.get("minZoom") || 0) || ((n = this.getMap()) === null || n === void 0 ? void 0 : n.getZoom()) === this.get("maxZoom")) && google.maps.event.trigger(this, "idle");
    }, e.prototype.onIdle = function() {
      this.redraw();
    }, e.prototype.onAdd = function() {
      var t = this.getMap();
      this.activeMap = t, this.ready = !0, this.repaint(), t !== null && (this.listeners = [google.maps.event.addListener(t, "zoom_changed", this.onZoomChanged), google.maps.event.addListener(t, "idle", this.onIdle)]);
    }, e.prototype.onRemove = function() {
      for (var t = 0, n = this.markers; t < n.length; t++) {
        var r = n[t];
        r.getMap() !== this.activeMap && r.setMap(this.activeMap);
      }
      for (var o = 0, i = this.clusters; o < i.length; o++) {
        var a = i[o];
        a.remove();
      }
      this.clusters = [];
      for (var s = 0, l = this.listeners; s < l.length; s++) {
        var u = l[s];
        google.maps.event.removeListener(u);
      }
      this.listeners = [], this.activeMap = null, this.ready = !1;
    }, e.prototype.draw = function() {
    }, e.prototype.getMap = function() {
      return null;
    }, e.prototype.getPanes = function() {
      return null;
    }, e.prototype.getProjection = function() {
      return {
        fromContainerPixelToLatLng: function() {
          return null;
        },
        fromDivPixelToLatLng: function() {
          return null;
        },
        fromLatLngToContainerPixel: function() {
          return null;
        },
        fromLatLngToDivPixel: function() {
          return null;
        },
        getVisibleRegion: function() {
          return null;
        },
        getWorldWidth: function() {
          return 0;
        }
      };
    }, e.prototype.setMap = function() {
    }, e.prototype.addListener = function() {
      return {
        remove: function() {
        }
      };
    }, e.prototype.bindTo = function() {
    }, e.prototype.get = function() {
    }, e.prototype.notify = function() {
    }, e.prototype.set = function() {
    }, e.prototype.setValues = function() {
    }, e.prototype.unbind = function() {
    }, e.prototype.unbindAll = function() {
    }, e.prototype.setupStyles = function() {
      if (!(this.styles.length > 0))
        for (var t = 0; t < this.imageSizes.length; t++)
          this.styles.push({
            url: "".concat(this.imagePath + (t + 1), ".").concat(this.imageExtension),
            height: this.imageSizes[t] || 0,
            width: this.imageSizes[t] || 0
          });
    }, e.prototype.fitMapToMarkers = function() {
      for (var t = this.getMarkers(), n = new google.maps.LatLngBounds(), r = 0, o = t; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && n.extend(a);
      }
      var s = this.getMap();
      s !== null && "fitBounds" in s && s.fitBounds(n);
    }, e.prototype.getGridSize = function() {
      return this.gridSize;
    }, e.prototype.setGridSize = function(t) {
      this.gridSize = t;
    }, e.prototype.getMinimumClusterSize = function() {
      return this.minClusterSize;
    }, e.prototype.setMinimumClusterSize = function(t) {
      this.minClusterSize = t;
    }, e.prototype.getMaxZoom = function() {
      return this.maxZoom;
    }, e.prototype.setMaxZoom = function(t) {
      this.maxZoom = t;
    }, e.prototype.getStyles = function() {
      return this.styles;
    }, e.prototype.setStyles = function(t) {
      this.styles = t;
    }, e.prototype.getTitle = function() {
      return this.title;
    }, e.prototype.setTitle = function(t) {
      this.title = t;
    }, e.prototype.getZoomOnClick = function() {
      return this.zoomOnClick;
    }, e.prototype.setZoomOnClick = function(t) {
      this.zoomOnClick = t;
    }, e.prototype.getAverageCenter = function() {
      return this.averageCenter;
    }, e.prototype.setAverageCenter = function(t) {
      this.averageCenter = t;
    }, e.prototype.getIgnoreHidden = function() {
      return this.ignoreHidden;
    }, e.prototype.setIgnoreHidden = function(t) {
      this.ignoreHidden = t;
    }, e.prototype.getEnableRetinaIcons = function() {
      return this.enableRetinaIcons;
    }, e.prototype.setEnableRetinaIcons = function(t) {
      this.enableRetinaIcons = t;
    }, e.prototype.getImageExtension = function() {
      return this.imageExtension;
    }, e.prototype.setImageExtension = function(t) {
      this.imageExtension = t;
    }, e.prototype.getImagePath = function() {
      return this.imagePath;
    }, e.prototype.setImagePath = function(t) {
      this.imagePath = t;
    }, e.prototype.getImageSizes = function() {
      return this.imageSizes;
    }, e.prototype.setImageSizes = function(t) {
      this.imageSizes = t;
    }, e.prototype.getCalculator = function() {
      return this.calculator;
    }, e.prototype.setCalculator = function(t) {
      this.calculator = t;
    }, e.prototype.getBatchSizeIE = function() {
      return this.batchSizeIE;
    }, e.prototype.setBatchSizeIE = function(t) {
      this.batchSizeIE = t;
    }, e.prototype.getClusterClass = function() {
      return this.clusterClass;
    }, e.prototype.setClusterClass = function(t) {
      this.clusterClass = t;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getTotalMarkers = function() {
      return this.markers.length;
    }, e.prototype.getClusters = function() {
      return this.clusters;
    }, e.prototype.getTotalClusters = function() {
      return this.clusters.length;
    }, e.prototype.addMarker = function(t, n) {
      this.pushMarkerTo(t), n || this.redraw();
    }, e.prototype.addMarkers = function(t, n) {
      for (var r in t)
        if (Object.prototype.hasOwnProperty.call(t, r)) {
          var o = t[r];
          o && this.pushMarkerTo(o);
        }
      n || this.redraw();
    }, e.prototype.pushMarkerTo = function(t) {
      var n = this;
      t.getDraggable() && google.maps.event.addListener(t, "dragend", function() {
        n.ready && (t.isAdded = !1, n.repaint());
      }), t.isAdded = !1, this.markers.push(t);
    }, e.prototype.removeMarker_ = function(t) {
      var n = -1;
      if (this.markers.indexOf)
        n = this.markers.indexOf(t);
      else
        for (var r = 0; r < this.markers.length; r++)
          if (t === this.markers[r]) {
            n = r;
            break;
          }
      return n === -1 ? !1 : (t.setMap(null), this.markers.splice(n, 1), !0);
    }, e.prototype.removeMarker = function(t, n) {
      var r = this.removeMarker_(t);
      return !n && r && this.repaint(), r;
    }, e.prototype.removeMarkers = function(t, n) {
      for (var r = !1, o = 0, i = t; o < i.length; o++) {
        var a = i[o];
        r = r || this.removeMarker_(a);
      }
      return !n && r && this.repaint(), r;
    }, e.prototype.clearMarkers = function() {
      this.resetViewport(!0), this.markers = [];
    }, e.prototype.repaint = function() {
      var t = this.clusters.slice();
      this.clusters = [], this.resetViewport(!1), this.redraw(), setTimeout(function() {
        for (var r = 0, o = t; r < o.length; r++) {
          var i = o[r];
          i.remove();
        }
      }, 0);
    }, e.prototype.getExtendedBounds = function(t) {
      var n = this.getProjection(), r = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getNorthEast().lat(), t.getNorthEast().lng())
      );
      r !== null && (r.x += this.gridSize, r.y -= this.gridSize);
      var o = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getSouthWest().lat(), t.getSouthWest().lng())
      );
      if (o !== null && (o.x -= this.gridSize, o.y += this.gridSize), r !== null) {
        var i = n.fromDivPixelToLatLng(r);
        i !== null && t.extend(i);
      }
      if (o !== null) {
        var a = n.fromDivPixelToLatLng(o);
        a !== null && t.extend(a);
      }
      return t;
    }, e.prototype.redraw = function() {
      this.createClusters(0);
    }, e.prototype.resetViewport = function(t) {
      for (var n = 0, r = this.clusters; n < r.length; n++) {
        var o = r[n];
        o.remove();
      }
      this.clusters = [];
      for (var i = 0, a = this.markers; i < a.length; i++) {
        var s = a[i];
        s.isAdded = !1, t && s.setMap(null);
      }
    }, e.prototype.distanceBetweenPoints = function(t, n) {
      var r = 6371, o = (n.lat() - t.lat()) * Math.PI / 180, i = (n.lng() - t.lng()) * Math.PI / 180, a = Math.sin(o / 2) * Math.sin(o / 2) + Math.cos(t.lat() * Math.PI / 180) * Math.cos(n.lat() * Math.PI / 180) * Math.sin(i / 2) * Math.sin(i / 2);
      return r * (2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)));
    }, e.prototype.isMarkerInBounds = function(t, n) {
      var r = t.getPosition();
      return r ? n.contains(r) : !1;
    }, e.prototype.addToClosestCluster = function(t) {
      for (var n, r = 4e4, o = null, i = 0, a = this.clusters; i < a.length; i++) {
        var s = a[i];
        n = s;
        var l = n.getCenter(), u = t.getPosition();
        if (l && u) {
          var c = this.distanceBetweenPoints(l, u);
          c < r && (r = c, o = n);
        }
      }
      o && o.isMarkerInClusterBounds(t) ? o.addMarker(t) : (n = new VAe(this), n.addMarker(t), this.clusters.push(n));
    }, e.prototype.createClusters = function(t) {
      var n = this;
      if (this.ready) {
        t === 0 && (google.maps.event.trigger(this, "clusteringbegin", this), this.timerRefStatic !== null && (window.clearTimeout(this.timerRefStatic), delete this.timerRefStatic));
        for (var r = this.getMap(), o = r !== null && ("getBounds" in r) ? r.getBounds() : null, i = (r == null ? void 0 : r.getZoom()) || 0, a = i > 3 ? new google.maps.LatLngBounds(o == null ? void 0 : o.getSouthWest(), o == null ? void 0 : o.getNorthEast()) : new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625)), s = this.getExtendedBounds(a), l = Math.min(t + this.batchSize, this.markers.length), u = t; u < l; u++) {
          var c = this.markers[u];
          c && !c.isAdded && this.isMarkerInBounds(c, s) && (!this.ignoreHidden || this.ignoreHidden && c.getVisible()) && this.addToClosestCluster(c);
        }
        if (l < this.markers.length)
          this.timerRefStatic = window.setTimeout(function() {
            n.createClusters(l);
          }, 0);
        else {
          this.timerRefStatic = null, google.maps.event.trigger(this, "clusteringend", this);
          for (var p = 0, d = this.clusters; p < d.length; p++) {
            var h = d[p];
            h.updateIcon();
          }
        }
      }
    }, e.prototype.extend = function(t, n) {
      return (function(o) {
        for (var i in o.prototype) {
          var a = i;
          this.prototype[a] = o.prototype[a];
        }
        return this;
      }).apply(t, [n]);
    }, e;
  }()
);
function Xz(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function QAe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Xz(Object(n), !0).forEach(function(r) {
      ge(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Xz(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var mi = {
  onClick: "click",
  onClusteringBegin: "clusteringbegin",
  onClusteringEnd: "clusteringend",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover"
}, gn = {
  averageCenter(e, t) {
    e.setAverageCenter(t);
  },
  batchSizeIE(e, t) {
    e.setBatchSizeIE(t);
  },
  calculator(e, t) {
    e.setCalculator(t);
  },
  clusterClass(e, t) {
    e.setClusterClass(t);
  },
  enableRetinaIcons(e, t) {
    e.setEnableRetinaIcons(t);
  },
  gridSize(e, t) {
    e.setGridSize(t);
  },
  ignoreHidden(e, t) {
    e.setIgnoreHidden(t);
  },
  imageExtension(e, t) {
    e.setImageExtension(t);
  },
  imagePath(e, t) {
    e.setImagePath(t);
  },
  imageSizes(e, t) {
    e.setImageSizes(t);
  },
  maxZoom(e, t) {
    e.setMaxZoom(t);
  },
  minimumClusterSize(e, t) {
    e.setMinimumClusterSize(t);
  },
  styles(e, t) {
    e.setStyles(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  zoomOnClick(e, t) {
    e.setZoomOnClick(t);
  }
}, eBe = {};
function tBe(e) {
  var {
    children: t,
    options: n,
    averageCenter: r,
    batchSizeIE: o,
    calculator: i,
    clusterClass: a,
    enableRetinaIcons: s,
    gridSize: l,
    ignoreHidden: u,
    imageExtension: c,
    imagePath: p,
    imageSizes: d,
    maxZoom: h,
    minimumClusterSize: f,
    styles: m,
    title: g,
    zoomOnClick: E,
    onClick: w,
    onClusteringBegin: M,
    onClusteringEnd: x,
    onMouseOver: y,
    onMouseOut: C,
    onLoad: P,
    onUnmount: F
  } = e, [L, N] = k(null), I = ye(_t), [H, V] = k(null), [z, q] = k(null), [K, J] = k(null), [te, ee] = k(null), [_, D] = k(null);
  return v(() => {
    L && C && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(L, mi.onMouseOut, C)));
  }, [C]), v(() => {
    L && y && (_ !== null && google.maps.event.removeListener(_), D(google.maps.event.addListener(L, mi.onMouseOver, y)));
  }, [y]), v(() => {
    L && w && (H !== null && google.maps.event.removeListener(H), V(google.maps.event.addListener(L, mi.onClick, w)));
  }, [w]), v(() => {
    L && M && (z !== null && google.maps.event.removeListener(z), q(google.maps.event.addListener(L, mi.onClusteringBegin, M)));
  }, [M]), v(() => {
    L && x && (K !== null && google.maps.event.removeListener(K), q(google.maps.event.addListener(L, mi.onClusteringEnd, x)));
  }, [x]), v(() => {
    typeof r < "u" && L !== null && gn.averageCenter(L, r);
  }, [L, r]), v(() => {
    typeof o < "u" && L !== null && gn.batchSizeIE(L, o);
  }, [L, o]), v(() => {
    typeof i < "u" && L !== null && gn.calculator(L, i);
  }, [L, i]), v(() => {
    typeof a < "u" && L !== null && gn.clusterClass(L, a);
  }, [L, a]), v(() => {
    typeof s < "u" && L !== null && gn.enableRetinaIcons(L, s);
  }, [L, s]), v(() => {
    typeof l < "u" && L !== null && gn.gridSize(L, l);
  }, [L, l]), v(() => {
    typeof u < "u" && L !== null && gn.ignoreHidden(L, u);
  }, [L, u]), v(() => {
    typeof c < "u" && L !== null && gn.imageExtension(L, c);
  }, [L, c]), v(() => {
    typeof p < "u" && L !== null && gn.imagePath(L, p);
  }, [L, p]), v(() => {
    typeof d < "u" && L !== null && gn.imageSizes(L, d);
  }, [L, d]), v(() => {
    typeof h < "u" && L !== null && gn.maxZoom(L, h);
  }, [L, h]), v(() => {
    typeof f < "u" && L !== null && gn.minimumClusterSize(L, f);
  }, [L, f]), v(() => {
    typeof m < "u" && L !== null && gn.styles(L, m);
  }, [L, m]), v(() => {
    typeof g < "u" && L !== null && gn.title(L, g);
  }, [L, g]), v(() => {
    typeof E < "u" && L !== null && gn.zoomOnClick(L, E);
  }, [L, E]), v(() => {
    if (I) {
      var $ = QAe({}, n || eBe), S = new v4(I, [], $);
      return r && gn.averageCenter(S, r), o && gn.batchSizeIE(S, o), i && gn.calculator(S, i), a && gn.clusterClass(S, a), s && gn.enableRetinaIcons(S, s), l && gn.gridSize(S, l), u && gn.ignoreHidden(S, u), c && gn.imageExtension(S, c), p && gn.imagePath(S, p), d && gn.imageSizes(S, d), h && gn.maxZoom(S, h), f && gn.minimumClusterSize(S, f), m && gn.styles(S, m), g && gn.title(S, g), E && gn.zoomOnClick(S, E), C && ee(google.maps.event.addListener(S, mi.onMouseOut, C)), y && D(google.maps.event.addListener(S, mi.onMouseOver, y)), w && V(google.maps.event.addListener(S, mi.onClick, w)), M && q(google.maps.event.addListener(S, mi.onClusteringBegin, M)), x && J(google.maps.event.addListener(S, mi.onClusteringEnd, x)), N(S), P && P(S), () => {
        te !== null && google.maps.event.removeListener(te), _ !== null && google.maps.event.removeListener(_), H !== null && google.maps.event.removeListener(H), z !== null && google.maps.event.removeListener(z), K !== null && google.maps.event.removeListener(K), F && F(S);
      };
    }
  }, []), L !== null && t(L) || null;
}
Ee(tBe);
class nBe extends pe {
  constructor() {
    super(...arguments), ge(this, "registeredEvents", []), ge(this, "state", {
      markerClusterer: null
    }), ge(this, "setClustererCallback", () => {
      this.state.markerClusterer !== null && this.props.onLoad && this.props.onLoad(this.state.markerClusterer);
    });
  }
  componentDidMount() {
    if (this.context) {
      var t = new v4(this.context, [], this.props.options);
      this.registeredEvents = Ft({
        updaterMap: gn,
        eventMap: mi,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        markerClusterer: t
      }), this.setClustererCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.markerClusterer && (qt(this.registeredEvents), this.registeredEvents = Ft({
      updaterMap: gn,
      eventMap: mi,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.markerClusterer
    }));
  }
  componentWillUnmount() {
    this.state.markerClusterer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.markerClusterer), qt(this.registeredEvents), this.state.markerClusterer.setMap(null));
  }
  render() {
    return this.state.markerClusterer !== null ? this.props.children(this.state.markerClusterer) : null;
  }
}
ge(nBe, "contextType", _t);
function Kz(e) {
  e.cancelBubble = !0, e.stopPropagation && e.stopPropagation();
}
var y4 = (
  /** @class */
  function() {
    function e(t) {
      t === void 0 && (t = {}), this.getCloseClickHandler = this.getCloseClickHandler.bind(this), this.closeClickHandler = this.closeClickHandler.bind(this), this.createInfoBoxDiv = this.createInfoBoxDiv.bind(this), this.addClickHandler = this.addClickHandler.bind(this), this.getCloseBoxImg = this.getCloseBoxImg.bind(this), this.getBoxWidths = this.getBoxWidths.bind(this), this.setBoxStyle = this.setBoxStyle.bind(this), this.setPosition = this.setPosition.bind(this), this.getPosition = this.getPosition.bind(this), this.setOptions = this.setOptions.bind(this), this.setContent = this.setContent.bind(this), this.setVisible = this.setVisible.bind(this), this.getContent = this.getContent.bind(this), this.getVisible = this.getVisible.bind(this), this.setZIndex = this.setZIndex.bind(this), this.getZIndex = this.getZIndex.bind(this), this.onRemove = this.onRemove.bind(this), this.panBox = this.panBox.bind(this), this.extend = this.extend.bind(this), this.close = this.close.bind(this), this.draw = this.draw.bind(this), this.show = this.show.bind(this), this.hide = this.hide.bind(this), this.open = this.open.bind(this), this.extend(e, google.maps.OverlayView), this.content = t.content || "", this.disableAutoPan = t.disableAutoPan || !1, this.maxWidth = t.maxWidth || 0, this.pixelOffset = t.pixelOffset || new google.maps.Size(0, 0), this.position = t.position || new google.maps.LatLng(0, 0), this.zIndex = t.zIndex || null, this.boxClass = t.boxClass || "infoBox", this.boxStyle = t.boxStyle || {}, this.closeBoxMargin = t.closeBoxMargin || "2px", this.closeBoxURL = t.closeBoxURL || "http://www.google.com/intl/en_us/mapfiles/close.gif", t.closeBoxURL === "" && (this.closeBoxURL = ""), this.infoBoxClearance = t.infoBoxClearance || new google.maps.Size(1, 1), typeof t.visible > "u" && (typeof t.isHidden > "u" ? t.visible = !0 : t.visible = !t.isHidden), this.isHidden = !t.visible, this.alignBottom = t.alignBottom || !1, this.pane = t.pane || "floatPane", this.enableEventPropagation = t.enableEventPropagation || !1, this.div = null, this.closeListener = null, this.moveListener = null, this.mapListener = null, this.contextListener = null, this.eventListeners = null, this.fixedWidthSet = null;
    }
    return e.prototype.createInfoBoxDiv = function() {
      var t = this, n = function(c) {
        c.returnValue = !1, c.preventDefault && c.preventDefault(), t.enableEventPropagation || Kz(c);
      };
      if (!this.div) {
        this.div = document.createElement("div"), this.setBoxStyle(), typeof this.content == "string" ? this.div.innerHTML = this.getCloseBoxImg() + this.content : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(this.content));
        var r = this.getPanes();
        if (r !== null && r[this.pane].appendChild(this.div), this.addClickHandler(), this.div.style.width)
          this.fixedWidthSet = !0;
        else if (this.maxWidth !== 0 && this.div.offsetWidth > this.maxWidth)
          this.div.style.width = this.maxWidth + "px", this.fixedWidthSet = !0;
        else {
          var o = this.getBoxWidths();
          this.div.style.width = this.div.offsetWidth - o.left - o.right + "px", this.fixedWidthSet = !1;
        }
        if (this.panBox(this.disableAutoPan), !this.enableEventPropagation) {
          this.eventListeners = [];
          for (var i = ["mousedown", "mouseover", "mouseout", "mouseup", "click", "dblclick", "touchstart", "touchend", "touchmove"], a = 0, s = i; a < s.length; a++) {
            var l = s[a];
            this.eventListeners.push(google.maps.event.addListener(this.div, l, Kz));
          }
          this.eventListeners.push(google.maps.event.addListener(this.div, "mouseover", function() {
            t.div && (t.div.style.cursor = "default");
          }));
        }
        this.contextListener = google.maps.event.addListener(this.div, "contextmenu", n), google.maps.event.trigger(this, "domready");
      }
    }, e.prototype.getCloseBoxImg = function() {
      var t = "";
      return this.closeBoxURL !== "" && (t = '<img alt=""', t += ' aria-hidden="true"', t += " src='" + this.closeBoxURL + "'", t += " align=right", t += " style='", t += " position: relative;", t += " cursor: pointer;", t += " margin: " + this.closeBoxMargin + ";", t += "'>"), t;
    }, e.prototype.addClickHandler = function() {
      this.closeListener = this.div && this.div.firstChild && this.closeBoxURL !== "" ? google.maps.event.addListener(this.div.firstChild, "click", this.getCloseClickHandler()) : null;
    }, e.prototype.closeClickHandler = function(t) {
      t.cancelBubble = !0, t.stopPropagation && t.stopPropagation(), google.maps.event.trigger(this, "closeclick"), this.close();
    }, e.prototype.getCloseClickHandler = function() {
      return this.closeClickHandler;
    }, e.prototype.panBox = function(t) {
      if (this.div && !t) {
        var n = this.getMap();
        if (n instanceof google.maps.Map) {
          var r = 0, o = 0, i = n.getBounds();
          i && !i.contains(this.position) && n.setCenter(this.position);
          var a = n.getDiv(), s = a.offsetWidth, l = a.offsetHeight, u = this.pixelOffset.width, c = this.pixelOffset.height, p = this.div.offsetWidth, d = this.div.offsetHeight, h = this.infoBoxClearance.width, f = this.infoBoxClearance.height, m = this.getProjection(), g = m.fromLatLngToContainerPixel(this.position);
          g !== null && (g.x < -u + h ? r = g.x + u - h : g.x + p + u + h > s && (r = g.x + p + u + h - s), this.alignBottom ? g.y < -c + f + d ? o = g.y + c - f - d : g.y + c + f > l && (o = g.y + c + f - l) : g.y < -c + f ? o = g.y + c - f : g.y + d + c + f > l && (o = g.y + d + c + f - l)), r === 0 && o === 0 || n.panBy(r, o);
        }
      }
    }, e.prototype.setBoxStyle = function() {
      if (this.div) {
        this.div.className = this.boxClass, this.div.style.cssText = "";
        var t = this.boxStyle;
        for (var n in t)
          Object.prototype.hasOwnProperty.call(t, n) && (this.div.style[n] = t[n]);
        if (this.div.style.webkitTransform = "translateZ(0)", typeof this.div.style.opacity < "u" && this.div.style.opacity !== "") {
          var r = parseFloat(this.div.style.opacity || "");
          this.div.style.msFilter = '"progid:DXImageTransform.Microsoft.Alpha(Opacity=' + r * 100 + ')"', this.div.style.filter = "alpha(opacity=" + r * 100 + ")";
        }
        this.div.style.position = "absolute", this.div.style.visibility = "hidden", this.zIndex !== null && (this.div.style.zIndex = this.zIndex + ""), this.div.style.overflow || (this.div.style.overflow = "auto");
      }
    }, e.prototype.getBoxWidths = function() {
      var t = {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0
      };
      if (!this.div)
        return t;
      if (document.defaultView) {
        var n = this.div.ownerDocument, r = n && n.defaultView ? n.defaultView.getComputedStyle(this.div, "") : null;
        r && (t.top = parseInt(r.borderTopWidth || "", 10) || 0, t.bottom = parseInt(r.borderBottomWidth || "", 10) || 0, t.left = parseInt(r.borderLeftWidth || "", 10) || 0, t.right = parseInt(r.borderRightWidth || "", 10) || 0);
      } else if (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        document.documentElement.currentStyle
      ) {
        var o = this.div.currentStyle;
        o && (t.top = parseInt(o.borderTopWidth || "", 10) || 0, t.bottom = parseInt(o.borderBottomWidth || "", 10) || 0, t.left = parseInt(o.borderLeftWidth || "", 10) || 0, t.right = parseInt(o.borderRightWidth || "", 10) || 0);
      }
      return t;
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.div.parentNode.removeChild(this.div), this.div = null);
    }, e.prototype.draw = function() {
      if (this.createInfoBoxDiv(), this.div) {
        var t = this.getProjection(), n = t.fromLatLngToDivPixel(this.position);
        n !== null && (this.div.style.left = n.x + this.pixelOffset.width + "px", this.alignBottom ? this.div.style.bottom = -(n.y + this.pixelOffset.height) + "px" : this.div.style.top = n.y + this.pixelOffset.height + "px"), this.isHidden ? this.div.style.visibility = "hidden" : this.div.style.visibility = "visible";
      }
    }, e.prototype.setOptions = function(t) {
      t === void 0 && (t = {}), typeof t.boxClass < "u" && (this.boxClass = t.boxClass, this.setBoxStyle()), typeof t.boxStyle < "u" && (this.boxStyle = t.boxStyle, this.setBoxStyle()), typeof t.content < "u" && this.setContent(t.content), typeof t.disableAutoPan < "u" && (this.disableAutoPan = t.disableAutoPan), typeof t.maxWidth < "u" && (this.maxWidth = t.maxWidth), typeof t.pixelOffset < "u" && (this.pixelOffset = t.pixelOffset), typeof t.alignBottom < "u" && (this.alignBottom = t.alignBottom), typeof t.position < "u" && this.setPosition(t.position), typeof t.zIndex < "u" && this.setZIndex(t.zIndex), typeof t.closeBoxMargin < "u" && (this.closeBoxMargin = t.closeBoxMargin), typeof t.closeBoxURL < "u" && (this.closeBoxURL = t.closeBoxURL), typeof t.infoBoxClearance < "u" && (this.infoBoxClearance = t.infoBoxClearance), typeof t.isHidden < "u" && (this.isHidden = t.isHidden), typeof t.visible < "u" && (this.isHidden = !t.visible), typeof t.enableEventPropagation < "u" && (this.enableEventPropagation = t.enableEventPropagation), this.div && this.draw();
    }, e.prototype.setContent = function(t) {
      this.content = t, this.div && (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.fixedWidthSet || (this.div.style.width = ""), typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t)), this.fixedWidthSet || (this.div.style.width = this.div.offsetWidth + "px", typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t))), this.addClickHandler()), google.maps.event.trigger(this, "content_changed");
    }, e.prototype.setPosition = function(t) {
      this.position = t, this.div && this.draw(), google.maps.event.trigger(this, "position_changed");
    }, e.prototype.setVisible = function(t) {
      this.isHidden = !t, this.div && (this.div.style.visibility = this.isHidden ? "hidden" : "visible");
    }, e.prototype.setZIndex = function(t) {
      this.zIndex = t, this.div && (this.div.style.zIndex = t + ""), google.maps.event.trigger(this, "zindex_changed");
    }, e.prototype.getContent = function() {
      return this.content;
    }, e.prototype.getPosition = function() {
      return this.position;
    }, e.prototype.getZIndex = function() {
      return this.zIndex;
    }, e.prototype.getVisible = function() {
      var t = this.getMap();
      return typeof t > "u" || t === null ? !1 : !this.isHidden;
    }, e.prototype.show = function() {
      this.isHidden = !1, this.div && (this.div.style.visibility = "visible");
    }, e.prototype.hide = function() {
      this.isHidden = !0, this.div && (this.div.style.visibility = "hidden");
    }, e.prototype.open = function(t, n) {
      var r = this;
      n && (this.position = n.getPosition(), this.moveListener = google.maps.event.addListener(n, "position_changed", function() {
        var o = n.getPosition();
        r.setPosition(o);
      }), this.mapListener = google.maps.event.addListener(n, "map_changed", function() {
        r.setMap(n.map);
      })), this.setMap(t), this.div && this.panBox();
    }, e.prototype.close = function() {
      if (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.eventListeners) {
        for (var t = 0, n = this.eventListeners; t < n.length; t++) {
          var r = n[t];
          google.maps.event.removeListener(r);
        }
        this.eventListeners = null;
      }
      this.moveListener && (google.maps.event.removeListener(this.moveListener), this.moveListener = null), this.mapListener && (google.maps.event.removeListener(this.mapListener), this.mapListener = null), this.contextListener && (google.maps.event.removeListener(this.contextListener), this.contextListener = null), this.setMap(null);
    }, e.prototype.extend = function(t, n) {
      return (function(o) {
        for (var i in o.prototype)
          Object.prototype.hasOwnProperty.call(this, i) || (this.prototype[i] = o.prototype[i]);
        return this;
      }).apply(t, [n]);
    }, e;
  }()
), rBe = ["position"], oBe = ["position"];
function Yz(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Om(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Yz(Object(n), !0).forEach(function(r) {
      ge(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Yz(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Jz = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, Qz = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    t instanceof google.maps.LatLng ? e.setPosition(t) : e.setPosition(new google.maps.LatLng(t.lat, t.lng));
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, iBe = {};
function sBe(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, h = ye(_t), [f, m] = k(null), [g, E] = k(null), [w, M] = k(null), [x, y] = k(null), [C, P] = k(null), [F, L] = k(null), N = rt(null);
  return v(() => {
    h && f !== null && (f.close(), n ? f.open(h, n) : f.getPosition() && f.open(h));
  }, [h, f, n]), v(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), v(() => {
    if (o && f !== null) {
      var I = o instanceof google.maps.LatLng ? o : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        new google.maps.LatLng(o.lat, o.lng)
      );
      f.setPosition(I);
    }
  }, [o]), v(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), v(() => {
    f && a && (g !== null && google.maps.event.removeListener(g), E(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), v(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), M(google.maps.event.addListener(f, "domready", s)));
  }, [s]), v(() => {
    f && l && (x !== null && google.maps.event.removeListener(x), y(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), v(() => {
    f && u && (C !== null && google.maps.event.removeListener(C), P(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), v(() => {
    f && c && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), v(() => {
    if (h) {
      var I = r || iBe, {
        position: H
      } = I, V = B1(I, rBe), z;
      H && !(H instanceof google.maps.LatLng) && (z = new google.maps.LatLng(H.lat, H.lng));
      var q = new y4(Om(Om({}, V), z ? {
        position: z
      } : {}));
      N.current = document.createElement("div"), m(q), a && E(google.maps.event.addListener(q, "closeclick", a)), s && M(google.maps.event.addListener(q, "domready", s)), l && y(google.maps.event.addListener(q, "content_changed", l)), u && P(google.maps.event.addListener(q, "position_changed", u)), c && L(google.maps.event.addListener(q, "zindex_changed", c)), q.setContent(N.current), n ? q.open(h, n) : q.getPosition() ? q.open(h) : Yr(!1, "You must provide either an anchor or a position prop for <InfoBox>."), p && p(q);
    }
    return () => {
      f !== null && (g && google.maps.event.removeListener(g), x && google.maps.event.removeListener(x), w && google.maps.event.removeListener(w), C && google.maps.event.removeListener(C), F && google.maps.event.removeListener(F), d && d(f), f.close());
    };
  }, []), N.current ? yr(at.only(t), N.current) : null;
}
Ee(sBe);
class aBe extends pe {
  constructor() {
    super(...arguments), ge(this, "registeredEvents", []), ge(this, "containerElement", null), ge(this, "state", {
      infoBox: null
    }), ge(this, "open", (t, n) => {
      n ? this.context !== null && t.open(this.context, n) : t.getPosition() ? this.context !== null && t.open(this.context) : Yr(!1, "You must provide either an anchor or a position prop for <InfoBox>.");
    }), ge(this, "setInfoBoxCallback", () => {
      this.state.infoBox !== null && this.containerElement !== null && (this.state.infoBox.setContent(this.containerElement), this.open(this.state.infoBox, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoBox));
    });
  }
  componentDidMount() {
    var t = this.props.options || {}, {
      position: n
    } = t, r = B1(t, oBe), o;
    n && !(n instanceof google.maps.LatLng) && (o = new google.maps.LatLng(n.lat, n.lng));
    var i = new y4(Om(Om({}, r), o ? {
      position: o
    } : {}));
    this.containerElement = document.createElement("div"), this.registeredEvents = Ft({
      updaterMap: Qz,
      eventMap: Jz,
      prevProps: {},
      nextProps: this.props,
      instance: i
    }), this.setState({
      infoBox: i
    }, this.setInfoBoxCallback);
  }
  componentDidUpdate(t) {
    var {
      infoBox: n
    } = this.state;
    n !== null && (qt(this.registeredEvents), this.registeredEvents = Ft({
      updaterMap: Qz,
      eventMap: Jz,
      prevProps: t,
      nextProps: this.props,
      instance: n
    }));
  }
  componentWillUnmount() {
    var {
      onUnmount: t
    } = this.props, {
      infoBox: n
    } = this.state;
    n !== null && (t && t(n), qt(this.registeredEvents), n.close());
  }
  render() {
    return this.containerElement ? yr(at.only(this.props.children), this.containerElement) : null;
  }
}
ge(aBe, "contextType", _t);
var Bw, eU;
function lBe() {
  return eU || (eU = 1, Bw = function e(t, n) {
    if (t === n) return !0;
    if (t && n && typeof t == "object" && typeof n == "object") {
      if (t.constructor !== n.constructor) return !1;
      var r, o, i;
      if (Array.isArray(t)) {
        if (r = t.length, r != n.length) return !1;
        for (o = r; o-- !== 0; ) if (!e(t[o], n[o])) return !1;
        return !0;
      }
      if (t.constructor === RegExp) return t.source === n.source && t.flags === n.flags;
      if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === n.valueOf();
      if (t.toString !== Object.prototype.toString) return t.toString() === n.toString();
      if (i = Object.keys(t), r = i.length, r !== Object.keys(n).length) return !1;
      for (o = r; o-- !== 0; ) if (!Object.prototype.hasOwnProperty.call(n, i[o])) return !1;
      for (o = r; o-- !== 0; ) {
        var a = i[o];
        if (!e(t[a], n[a])) return !1;
      }
      return !0;
    }
    return t !== t && n !== n;
  }), Bw;
}
var uBe = lBe(), tU = /* @__PURE__ */ u4(uBe), nU = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array], Iw = 1, ac = 8;
class I1 {
  /**
   * Creates an index from raw `ArrayBuffer` data.
   * @param {ArrayBuffer} data
   */
  static from(t) {
    if (!(t instanceof ArrayBuffer))
      throw new Error("Data must be an instance of ArrayBuffer.");
    var [n, r] = new Uint8Array(t, 0, 2);
    if (n !== 219)
      throw new Error("Data does not appear to be in a KDBush format.");
    var o = r >> 4;
    if (o !== Iw)
      throw new Error("Got v".concat(o, " data when expected v").concat(Iw, "."));
    var i = nU[r & 15];
    if (!i)
      throw new Error("Unrecognized array type.");
    var [a] = new Uint16Array(t, 2, 1), [s] = new Uint32Array(t, 4, 1);
    return new I1(s, a, i, t);
  }
  /**
   * Creates an index that will hold a given number of items.
   * @param {number} numItems
   * @param {number} [nodeSize=64] Size of the KD-tree node (64 by default).
   * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).
   * @param {ArrayBuffer} [data] (For internal use only)
   */
  constructor(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 64, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Float64Array, o = arguments.length > 3 ? arguments[3] : void 0;
    if (isNaN(t) || t < 0) throw new Error("Unpexpected numItems value: ".concat(t, "."));
    this.numItems = +t, this.nodeSize = Math.min(Math.max(+n, 2), 65535), this.ArrayType = r, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
    var i = nU.indexOf(this.ArrayType), a = t * 2 * this.ArrayType.BYTES_PER_ELEMENT, s = t * this.IndexArrayType.BYTES_PER_ELEMENT, l = (8 - s % 8) % 8;
    if (i < 0)
      throw new Error("Unexpected typed array class: ".concat(r, "."));
    o && o instanceof ArrayBuffer ? (this.data = o, this.ids = new this.IndexArrayType(this.data, ac, t), this.coords = new this.ArrayType(this.data, ac + s + l, t * 2), this._pos = t * 2, this._finished = !0) : (this.data = new ArrayBuffer(ac + a + s + l), this.ids = new this.IndexArrayType(this.data, ac, t), this.coords = new this.ArrayType(this.data, ac + s + l, t * 2), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, (Iw << 4) + i]), new Uint16Array(this.data, 2, 1)[0] = n, new Uint32Array(this.data, 4, 1)[0] = t);
  }
  /**
   * Add a point to the index.
   * @param {number} x
   * @param {number} y
   * @returns {number} An incremental index associated with the added item (starting from `0`).
   */
  add(t, n) {
    var r = this._pos >> 1;
    return this.ids[r] = r, this.coords[this._pos++] = t, this.coords[this._pos++] = n, r;
  }
  /**
   * Perform indexing of the added points.
   */
  finish() {
    var t = this._pos >> 1;
    if (t !== this.numItems)
      throw new Error("Added ".concat(t, " items when expected ").concat(this.numItems, "."));
    return Zx(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
  }
  /**
   * Search the index for items within a given bounding box.
   * @param {number} minX
   * @param {number} minY
   * @param {number} maxX
   * @param {number} maxY
   * @returns {number[]} An array of indices correponding to the found items.
   */
  range(t, n, r, o) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: i,
      coords: a,
      nodeSize: s
    } = this, l = [0, i.length - 1, 0], u = []; l.length; ) {
      var c = l.pop() || 0, p = l.pop() || 0, d = l.pop() || 0;
      if (p - d <= s) {
        for (var h = d; h <= p; h++) {
          var f = a[2 * h], m = a[2 * h + 1];
          f >= t && f <= r && m >= n && m <= o && u.push(i[h]);
        }
        continue;
      }
      var g = d + p >> 1, E = a[2 * g], w = a[2 * g + 1];
      E >= t && E <= r && w >= n && w <= o && u.push(i[g]), (c === 0 ? t <= E : n <= w) && (l.push(d), l.push(g - 1), l.push(1 - c)), (c === 0 ? r >= E : o >= w) && (l.push(g + 1), l.push(p), l.push(1 - c));
    }
    return u;
  }
  /**
   * Search the index for items within a given radius.
   * @param {number} qx
   * @param {number} qy
   * @param {number} r Query radius.
   * @returns {number[]} An array of indices correponding to the found items.
   */
  within(t, n, r) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: o,
      coords: i,
      nodeSize: a
    } = this, s = [0, o.length - 1, 0], l = [], u = r * r; s.length; ) {
      var c = s.pop() || 0, p = s.pop() || 0, d = s.pop() || 0;
      if (p - d <= a) {
        for (var h = d; h <= p; h++)
          rU(i[2 * h], i[2 * h + 1], t, n) <= u && l.push(o[h]);
        continue;
      }
      var f = d + p >> 1, m = i[2 * f], g = i[2 * f + 1];
      rU(m, g, t, n) <= u && l.push(o[f]), (c === 0 ? t - r <= m : n - r <= g) && (s.push(d), s.push(f - 1), s.push(1 - c)), (c === 0 ? t + r >= m : n + r >= g) && (s.push(f + 1), s.push(p), s.push(1 - c));
    }
    return l;
  }
}
function Zx(e, t, n, r, o, i) {
  if (!(o - r <= n)) {
    var a = r + o >> 1;
    b4(e, t, a, r, o, i), Zx(e, t, n, r, a - 1, 1 - i), Zx(e, t, n, a + 1, o, 1 - i);
  }
}
function b4(e, t, n, r, o, i) {
  for (; o > r; ) {
    if (o - r > 600) {
      var a = o - r + 1, s = n - r + 1, l = Math.log(a), u = 0.5 * Math.exp(2 * l / 3), c = 0.5 * Math.sqrt(l * u * (a - u) / a) * (s - a / 2 < 0 ? -1 : 1), p = Math.max(r, Math.floor(n - s * u / a + c)), d = Math.min(o, Math.floor(n + (a - s) * u / a + c));
      b4(e, t, n, p, d, i);
    }
    var h = t[2 * n + i], f = r, m = o;
    for (lc(e, t, r, n), t[2 * o + i] > h && lc(e, t, r, o); f < m; ) {
      for (lc(e, t, f, m), f++, m--; t[2 * f + i] < h; ) f++;
      for (; t[2 * m + i] > h; ) m--;
    }
    t[2 * r + i] === h ? lc(e, t, r, m) : (m++, lc(e, t, m, o)), m <= n && (r = m + 1), n <= m && (o = m - 1);
  }
}
function lc(e, t, n, r) {
  Rw(e, n, r), Rw(t, 2 * n, 2 * r), Rw(t, 2 * n + 1, 2 * r + 1);
}
function Rw(e, t, n) {
  var r = e[t];
  e[t] = e[n], e[n] = r;
}
function rU(e, t, n, r) {
  var o = e - n, i = t - r;
  return o * o + i * i;
}
var cBe = {
  minZoom: 0,
  // min zoom to generate clusters on
  maxZoom: 16,
  // max zoom level to cluster the points on
  minPoints: 2,
  // minimum points to form a cluster
  radius: 40,
  // cluster radius in pixels
  extent: 512,
  // tile extent (radius is calculated relative to it)
  nodeSize: 64,
  // size of the KD-tree leaf node, affects performance
  log: !1,
  // whether to log timing info
  // whether to generate numeric ids for input features (in vector tiles)
  generateId: !1,
  // a reduce function for calculating custom cluster properties
  reduce: null,
  // (accumulated, props) => { accumulated.sum += props.sum; }
  // properties to use for individual points when running the reducer
  map: (e) => e
  // props => ({sum: props.my_value})
}, oU = Math.fround || /* @__PURE__ */ ((e) => (t) => (e[0] = +t, e[0]))(new Float32Array(1)), qa = 2, oa = 3, Nw = 4, Ks = 5, w4 = 6;
class pBe {
  constructor(t) {
    this.options = Object.assign(Object.create(cBe), t), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
  }
  load(t) {
    var {
      log: n,
      minZoom: r,
      maxZoom: o
    } = this.options;
    n && console.time("total time");
    var i = "prepare ".concat(t.length, " points");
    n && console.time(i), this.points = t;
    for (var a = [], s = 0; s < t.length; s++) {
      var l = t[s];
      if (l.geometry) {
        var [u, c] = l.geometry.coordinates, p = oU(Eh(u)), d = oU(kh(c));
        a.push(
          p,
          d,
          // projected point coordinates
          1 / 0,
          // the last zoom the point was processed at
          s,
          // index of the source feature in the original input array
          -1,
          // parent cluster id
          1
          // number of points in a cluster
        ), this.options.reduce && a.push(0);
      }
    }
    var h = this.trees[o + 1] = this._createTree(a);
    n && console.timeEnd(i);
    for (var f = o; f >= r; f--) {
      var m = +Date.now();
      h = this.trees[f] = this._createTree(this._cluster(h, f)), n && console.log("z%d: %d clusters in %dms", f, h.numItems, +Date.now() - m);
    }
    return n && console.timeEnd("total time"), this;
  }
  getClusters(t, n) {
    var r = ((t[0] + 180) % 360 + 360) % 360 - 180, o = Math.max(-90, Math.min(90, t[1])), i = t[2] === 180 ? 180 : ((t[2] + 180) % 360 + 360) % 360 - 180, a = Math.max(-90, Math.min(90, t[3]));
    if (t[2] - t[0] >= 360)
      r = -180, i = 180;
    else if (r > i) {
      var s = this.getClusters([r, o, 180, a], n), l = this.getClusters([-180, o, i, a], n);
      return s.concat(l);
    }
    var u = this.trees[this._limitZoom(n)], c = u.range(Eh(r), kh(a), Eh(i), kh(o)), p = u.data, d = [];
    for (var h of c) {
      var f = this.stride * h;
      d.push(p[f + Ks] > 1 ? iU(p, f, this.clusterProps) : this.points[p[f + oa]]);
    }
    return d;
  }
  getChildren(t) {
    var n = this._getOriginId(t), r = this._getOriginZoom(t), o = "No cluster with the specified id.", i = this.trees[r];
    if (!i) throw new Error(o);
    var a = i.data;
    if (n * this.stride >= a.length) throw new Error(o);
    var s = this.options.radius / (this.options.extent * Math.pow(2, r - 1)), l = a[n * this.stride], u = a[n * this.stride + 1], c = i.within(l, u, s), p = [];
    for (var d of c) {
      var h = d * this.stride;
      a[h + Nw] === t && p.push(a[h + Ks] > 1 ? iU(a, h, this.clusterProps) : this.points[a[h + oa]]);
    }
    if (p.length === 0) throw new Error(o);
    return p;
  }
  getLeaves(t, n, r) {
    n = n || 10, r = r || 0;
    var o = [];
    return this._appendLeaves(o, t, n, r, 0), o;
  }
  getTile(t, n, r) {
    var o = this.trees[this._limitZoom(t)], i = Math.pow(2, t), {
      extent: a,
      radius: s
    } = this.options, l = s / a, u = (r - l) / i, c = (r + 1 + l) / i, p = {
      features: []
    };
    return this._addTileFeatures(o.range((n - l) / i, u, (n + 1 + l) / i, c), o.data, n, r, i, p), n === 0 && this._addTileFeatures(o.range(1 - l / i, u, 1, c), o.data, i, r, i, p), n === i - 1 && this._addTileFeatures(o.range(0, u, l / i, c), o.data, -1, r, i, p), p.features.length ? p : null;
  }
  getClusterExpansionZoom(t) {
    for (var n = this._getOriginZoom(t) - 1; n <= this.options.maxZoom; ) {
      var r = this.getChildren(t);
      if (n++, r.length !== 1) break;
      t = r[0].properties.cluster_id;
    }
    return n;
  }
  _appendLeaves(t, n, r, o, i) {
    var a = this.getChildren(n);
    for (var s of a) {
      var l = s.properties;
      if (l && l.cluster ? i + l.point_count <= o ? i += l.point_count : i = this._appendLeaves(t, l.cluster_id, r, o, i) : i < o ? i++ : t.push(s), t.length === r) break;
    }
    return i;
  }
  _createTree(t) {
    for (var n = new I1(t.length / this.stride | 0, this.options.nodeSize, Float32Array), r = 0; r < t.length; r += this.stride) n.add(t[r], t[r + 1]);
    return n.finish(), n.data = t, n;
  }
  _addTileFeatures(t, n, r, o, i, a) {
    for (var s of t) {
      var l = s * this.stride, u = n[l + Ks] > 1, c = void 0, p = void 0, d = void 0;
      if (u)
        c = C4(n, l, this.clusterProps), p = n[l], d = n[l + 1];
      else {
        var h = this.points[n[l + oa]];
        c = h.properties;
        var [f, m] = h.geometry.coordinates;
        p = Eh(f), d = kh(m);
      }
      var g = {
        type: 1,
        geometry: [[Math.round(this.options.extent * (p * i - r)), Math.round(this.options.extent * (d * i - o))]],
        tags: c
      }, E = void 0;
      u || this.options.generateId ? E = n[l + oa] : E = this.points[n[l + oa]].id, E !== void 0 && (g.id = E), a.features.push(g);
    }
  }
  _limitZoom(t) {
    return Math.max(this.options.minZoom, Math.min(Math.floor(+t), this.options.maxZoom + 1));
  }
  _cluster(t, n) {
    for (var {
      radius: r,
      extent: o,
      reduce: i,
      minPoints: a
    } = this.options, s = r / (o * Math.pow(2, n)), l = t.data, u = [], c = this.stride, p = 0; p < l.length; p += c)
      if (!(l[p + qa] <= n)) {
        l[p + qa] = n;
        var d = l[p], h = l[p + 1], f = t.within(l[p], l[p + 1], s), m = l[p + Ks], g = m;
        for (var E of f) {
          var w = E * c;
          l[w + qa] > n && (g += l[w + Ks]);
        }
        if (g > m && g >= a) {
          var M = d * m, x = h * m, y = void 0, C = -1, P = ((p / c | 0) << 5) + (n + 1) + this.points.length;
          for (var F of f) {
            var L = F * c;
            if (!(l[L + qa] <= n)) {
              l[L + qa] = n;
              var N = l[L + Ks];
              M += l[L] * N, x += l[L + 1] * N, l[L + Nw] = P, i && (y || (y = this._map(l, p, !0), C = this.clusterProps.length, this.clusterProps.push(y)), i(y, this._map(l, L)));
            }
          }
          l[p + Nw] = P, u.push(M / g, x / g, 1 / 0, P, -1, g), i && u.push(C);
        } else {
          for (var I = 0; I < c; I++) u.push(l[p + I]);
          if (g > 1)
            for (var H of f) {
              var V = H * c;
              if (!(l[V + qa] <= n)) {
                l[V + qa] = n;
                for (var z = 0; z < c; z++) u.push(l[V + z]);
              }
            }
        }
      }
    return u;
  }
  // get index of the point from which the cluster originated
  _getOriginId(t) {
    return t - this.points.length >> 5;
  }
  // get zoom of the point from which the cluster originated
  _getOriginZoom(t) {
    return (t - this.points.length) % 32;
  }
  _map(t, n, r) {
    if (t[n + Ks] > 1) {
      var o = this.clusterProps[t[n + w4]];
      return r ? Object.assign({}, o) : o;
    }
    var i = this.points[t[n + oa]].properties, a = this.options.map(i);
    return r && a === i ? Object.assign({}, a) : a;
  }
}
function iU(e, t, n) {
  return {
    type: "Feature",
    id: e[t + oa],
    properties: C4(e, t, n),
    geometry: {
      type: "Point",
      coordinates: [dBe(e[t]), fBe(e[t + 1])]
    }
  };
}
function C4(e, t, n) {
  var r = e[t + Ks], o = r >= 1e4 ? "".concat(Math.round(r / 1e3), "k") : r >= 1e3 ? "".concat(Math.round(r / 100) / 10, "k") : r, i = e[t + w4], a = i === -1 ? {} : Object.assign({}, n[i]);
  return Object.assign(a, {
    cluster: !0,
    cluster_id: e[t + oa],
    point_count: r,
    point_count_abbreviated: o
  });
}
function Eh(e) {
  return e / 360 + 0.5;
}
function kh(e) {
  var t = Math.sin(e * Math.PI / 180), n = 0.5 - 0.25 * Math.log((1 + t) / (1 - t)) / Math.PI;
  return n < 0 ? 0 : n > 1 ? 1 : n;
}
function dBe(e) {
  return (e - 0.5) * 360;
}
function fBe(e) {
  var t = (180 - e * 360) * Math.PI / 180;
  return 360 * Math.atan(Math.exp(t)) / Math.PI - 90;
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function hBe(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
    t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
  return n;
}
class Jo {
  static isAdvancedMarkerAvailable(t) {
    return google.maps.marker && t.getMapCapabilities().isAdvancedMarkersAvailable === !0;
  }
  static isAdvancedMarker(t) {
    return google.maps.marker && t instanceof google.maps.marker.AdvancedMarkerElement;
  }
  static setMap(t, n) {
    this.isAdvancedMarker(t) ? t.map = n : t.setMap(n);
  }
  static getPosition(t) {
    if (this.isAdvancedMarker(t)) {
      if (t.position) {
        if (t.position instanceof google.maps.LatLng)
          return t.position;
        if (t.position.lat && t.position.lng)
          return new google.maps.LatLng(t.position.lat, t.position.lng);
      }
      return new google.maps.LatLng(null);
    }
    return t.getPosition();
  }
  static getVisible(t) {
    return this.isAdvancedMarker(t) ? !0 : t.getVisible();
  }
}
class Gx {
  constructor(t) {
    var {
      markers: n,
      position: r
    } = t;
    this.markers = n, r && (r instanceof google.maps.LatLng ? this._position = r : this._position = new google.maps.LatLng(r));
  }
  get bounds() {
    if (!(this.markers.length === 0 && !this._position)) {
      var t = new google.maps.LatLngBounds(this._position, this._position);
      for (var n of this.markers)
        t.extend(Jo.getPosition(n));
      return t;
    }
  }
  get position() {
    return this._position || this.bounds.getCenter();
  }
  /**
   * Get the count of **visible** markers.
   */
  get count() {
    return this.markers.filter((t) => Jo.getVisible(t)).length;
  }
  /**
   * Add a marker to the cluster.
   */
  push(t) {
    this.markers.push(t);
  }
  /**
   * Cleanup references and remove marker from map.
   */
  delete() {
    this.marker && (Jo.setMap(this.marker, null), this.marker = void 0), this.markers.length = 0;
  }
}
class gBe {
  constructor(t) {
    var {
      maxZoom: n = 16
    } = t;
    this.maxZoom = n;
  }
  /**
   * Helper function to bypass clustering based upon some map state such as
   * zoom, number of markers, etc.
   *
   * ```typescript
   *  cluster({markers, map}: AlgorithmInput): Cluster[] {
   *    if (shouldBypassClustering(map)) {
   *      return this.noop({markers})
   *    }
   * }
   * ```
   */
  noop(t) {
    var {
      markers: n
    } = t;
    return mBe(n);
  }
}
var mBe = (e) => {
  var t = e.map((n) => new Gx({
    position: Jo.getPosition(n),
    markers: [n]
  }));
  return t;
};
class vBe extends gBe {
  constructor(t) {
    var {
      maxZoom: n,
      radius: r = 60
    } = t, o = hBe(t, ["maxZoom", "radius"]);
    super({
      maxZoom: n
    }), this.state = {
      zoom: -1
    }, this.superCluster = new pBe(Object.assign({
      maxZoom: this.maxZoom,
      radius: r
    }, o));
  }
  calculate(t) {
    var n = !1, r = {
      zoom: t.map.getZoom()
    };
    if (!tU(t.markers, this.markers)) {
      n = !0, this.markers = [...t.markers];
      var o = this.markers.map((i) => {
        var a = Jo.getPosition(i), s = [a.lng(), a.lat()];
        return {
          type: "Feature",
          geometry: {
            type: "Point",
            coordinates: s
          },
          properties: {
            marker: i
          }
        };
      });
      this.superCluster.load(o);
    }
    return n || (this.state.zoom <= this.maxZoom || r.zoom <= this.maxZoom) && (n = !tU(this.state, r)), this.state = r, n && (this.clusters = this.cluster(t)), {
      clusters: this.clusters,
      changed: n
    };
  }
  cluster(t) {
    var {
      map: n
    } = t;
    return this.superCluster.getClusters([-180, -90, 180, 90], Math.round(n.getZoom())).map((r) => this.transformCluster(r));
  }
  transformCluster(t) {
    var {
      geometry: {
        coordinates: [n, r]
      },
      properties: o
    } = t;
    if (o.cluster)
      return new Gx({
        markers: this.superCluster.getLeaves(o.cluster_id, 1 / 0).map((a) => a.properties.marker),
        position: {
          lat: r,
          lng: n
        }
      });
    var i = o.marker;
    return new Gx({
      markers: [i],
      position: Jo.getPosition(i)
    });
  }
}
class yBe {
  constructor(t, n) {
    this.markers = {
      sum: t.length
    };
    var r = n.map((i) => i.count), o = r.reduce((i, a) => i + a, 0);
    this.clusters = {
      count: n.length,
      markers: {
        mean: o / n.length,
        sum: o,
        min: Math.min(...r),
        max: Math.max(...r)
      }
    };
  }
}
class bBe {
  /**
   * The default render function for the library used by {@link MarkerClusterer}.
   *
   * Currently set to use the following:
   *
   * ```typescript
   * // change color if this cluster has more markers than the mean cluster
   * const color =
   *   count > Math.max(10, stats.clusters.markers.mean)
   *     ? "#ff0000"
   *     : "#0000ff";
   *
   * // create svg url with fill color
   * const svg = window.btoa(`
   * <svg fill="${color}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240">
   *   <circle cx="120" cy="120" opacity=".6" r="70" />
   *   <circle cx="120" cy="120" opacity=".3" r="90" />
   *   <circle cx="120" cy="120" opacity=".2" r="110" />
   *   <circle cx="120" cy="120" opacity=".1" r="130" />
   * </svg>`);
   *
   * // create marker using svg icon
   * return new google.maps.Marker({
   *   position,
   *   icon: {
   *     url: `data:image/svg+xml;base64,${svg}`,
   *     scaledSize: new google.maps.Size(45, 45),
   *   },
   *   label: {
   *     text: String(count),
   *     color: "rgba(255,255,255,0.9)",
   *     fontSize: "12px",
   *   },
   *   // adjust zIndex to be above other markers
   *   zIndex: 1000 + count,
   * });
   * ```
   */
  render(t, n, r) {
    var {
      count: o,
      position: i
    } = t, a = o > Math.max(10, n.clusters.markers.mean) ? "#ff0000" : "#0000ff", s = '<svg fill="'.concat(a, `" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" width="50" height="50">
<circle cx="120" cy="120" opacity=".6" r="70" />
<circle cx="120" cy="120" opacity=".3" r="90" />
<circle cx="120" cy="120" opacity=".2" r="110" />
<text x="50%" y="50%" style="fill:#fff" text-anchor="middle" font-size="50" dominant-baseline="middle" font-family="roboto,arial,sans-serif">`).concat(o, `</text>
</svg>`), l = "Cluster of ".concat(o, " markers"), u = Number(google.maps.Marker.MAX_ZINDEX) + o;
    if (Jo.isAdvancedMarkerAvailable(r)) {
      var c = new DOMParser(), p = c.parseFromString(s, "image/svg+xml").documentElement;
      p.setAttribute("transform", "translate(0 25)");
      var d = {
        map: r,
        position: i,
        zIndex: u,
        title: l,
        content: p
      };
      return new google.maps.marker.AdvancedMarkerElement(d);
    }
    var h = {
      position: i,
      zIndex: u,
      title: l,
      icon: {
        url: "data:image/svg+xml;base64,".concat(btoa(s)),
        anchor: new google.maps.Point(25, 25)
      }
    };
    return new google.maps.Marker(h);
  }
}
function wBe(e, t) {
  for (var n in t.prototype)
    e.prototype[n] = t.prototype[n];
}
class R1 {
  constructor() {
    wBe(R1, google.maps.OverlayView);
  }
}
var qc;
(function(e) {
  e.CLUSTERING_BEGIN = "clusteringbegin", e.CLUSTERING_END = "clusteringend", e.CLUSTER_CLICK = "click";
})(qc || (qc = {}));
var CBe = (e, t, n) => {
  n.fitBounds(t.bounds);
};
class xBe extends R1 {
  constructor(t) {
    var {
      map: n,
      markers: r = [],
      algorithmOptions: o = {},
      algorithm: i = new vBe(o),
      renderer: a = new bBe(),
      onClusterClick: s = CBe
    } = t;
    super(), this.markers = [...r], this.clusters = [], this.algorithm = i, this.renderer = a, this.onClusterClick = s, n && this.setMap(n);
  }
  addMarker(t, n) {
    this.markers.includes(t) || (this.markers.push(t), n || this.render());
  }
  addMarkers(t, n) {
    t.forEach((r) => {
      this.addMarker(r, !0);
    }), n || this.render();
  }
  removeMarker(t, n) {
    var r = this.markers.indexOf(t);
    return r === -1 ? !1 : (Jo.setMap(t, null), this.markers.splice(r, 1), n || this.render(), !0);
  }
  removeMarkers(t, n) {
    var r = !1;
    return t.forEach((o) => {
      r = this.removeMarker(o, !0) || r;
    }), r && !n && this.render(), r;
  }
  clearMarkers(t) {
    this.markers.length = 0, t || this.render();
  }
  /**
   * Recalculates and draws all the marker clusters.
   */
  render() {
    var t = this.getMap();
    if (t instanceof google.maps.Map && t.getProjection()) {
      google.maps.event.trigger(this, qc.CLUSTERING_BEGIN, this);
      var {
        clusters: n,
        changed: r
      } = this.algorithm.calculate({
        markers: this.markers,
        map: t,
        mapCanvasProjection: this.getProjection()
      });
      if (r || r == null) {
        var o = /* @__PURE__ */ new Set();
        for (var i of n)
          i.markers.length == 1 && o.add(i.markers[0]);
        var a = [];
        for (var s of this.clusters)
          s.marker != null && (s.markers.length == 1 ? o.has(s.marker) || Jo.setMap(s.marker, null) : a.push(s.marker));
        this.clusters = n, this.renderClusters(), requestAnimationFrame(() => a.forEach((l) => Jo.setMap(l, null)));
      }
      google.maps.event.trigger(this, qc.CLUSTERING_END, this);
    }
  }
  onAdd() {
    this.idleListener = this.getMap().addListener("idle", this.render.bind(this)), this.render();
  }
  onRemove() {
    google.maps.event.removeListener(this.idleListener), this.reset();
  }
  reset() {
    this.markers.forEach((t) => Jo.setMap(t, null)), this.clusters.forEach((t) => t.delete()), this.clusters = [];
  }
  renderClusters() {
    var t = new yBe(this.markers, this.clusters), n = this.getMap();
    this.clusters.forEach((r) => {
      r.markers.length === 1 ? r.marker = r.markers[0] : (r.marker = this.renderer.render(r, t, n), r.markers.forEach((o) => Jo.setMap(o, null)), this.onClusterClick && r.marker.addListener(
        "click",
        /* istanbul ignore next */
        (o) => {
          google.maps.event.trigger(this, qc.CLUSTER_CLICK, r), this.onClusterClick(o, r, n);
        }
      )), Jo.setMap(r.marker, n);
    });
  }
}
function sU(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function aU(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? sU(Object(n), !0).forEach(function(r) {
      ge(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : sU(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function OBe(e) {
  var t = xAe(), [n, r] = k(null);
  return v(() => {
    if (t && n === null) {
      var o = new xBe(aU(aU({}, e), {}, {
        map: t
      }));
      r(o);
    }
  }, [t]), n;
}
function EBe(e) {
  var {
    children: t,
    options: n
  } = e, r = OBe(n);
  return r !== null ? t(r) : null;
}
Ee(EBe);
var lU = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, uU = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
function kBe(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, h = ye(_t), [f, m] = k(null), [g, E] = k(null), [w, M] = k(null), [x, y] = k(null), [C, P] = k(null), [F, L] = k(null), N = rt(null);
  return v(() => {
    f !== null && (f.close(), n ? f.open(h, n) : f.getPosition() && f.open(h));
  }, [h, f, n]), v(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), v(() => {
    o && f !== null && f.setPosition(o);
  }, [o]), v(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), v(() => {
    f && a && (g !== null && google.maps.event.removeListener(g), E(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), v(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), M(google.maps.event.addListener(f, "domready", s)));
  }, [s]), v(() => {
    f && l && (x !== null && google.maps.event.removeListener(x), y(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), v(() => {
    f && u && (C !== null && google.maps.event.removeListener(C), P(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), v(() => {
    f && c && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), v(() => {
    var I = new google.maps.InfoWindow(r);
    return m(I), N.current = document.createElement("div"), a && E(google.maps.event.addListener(I, "closeclick", a)), s && M(google.maps.event.addListener(I, "domready", s)), l && y(google.maps.event.addListener(I, "content_changed", l)), u && P(google.maps.event.addListener(I, "position_changed", u)), c && L(google.maps.event.addListener(I, "zindex_changed", c)), I.setContent(N.current), o && I.setPosition(o), i && I.setZIndex(i), n ? I.open(h, n) : I.getPosition() ? I.open(h) : Yr(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>."), p && p(I), () => {
      g && google.maps.event.removeListener(g), x && google.maps.event.removeListener(x), w && google.maps.event.removeListener(w), C && google.maps.event.removeListener(C), F && google.maps.event.removeListener(F), d && d(I), I.close();
    };
  }, []), N.current ? yr(at.only(t), N.current) : null;
}
Ee(kBe);
class LBe extends pe {
  constructor() {
    super(...arguments), ge(this, "registeredEvents", []), ge(this, "containerElement", null), ge(this, "state", {
      infoWindow: null
    }), ge(this, "open", (t, n) => {
      n ? t.open(this.context, n) : t.getPosition() ? t.open(this.context) : Yr(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>.");
    }), ge(this, "setInfoWindowCallback", () => {
      this.state.infoWindow !== null && this.containerElement !== null && (this.state.infoWindow.setContent(this.containerElement), this.open(this.state.infoWindow, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoWindow));
    });
  }
  componentDidMount() {
    var t = new google.maps.InfoWindow(this.props.options);
    this.containerElement = document.createElement("div"), this.registeredEvents = Ft({
      updaterMap: uU,
      eventMap: lU,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(() => ({
      infoWindow: t
    }), this.setInfoWindowCallback);
  }
  componentDidUpdate(t) {
    this.state.infoWindow !== null && (qt(this.registeredEvents), this.registeredEvents = Ft({
      updaterMap: uU,
      eventMap: lU,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.infoWindow
    }));
  }
  componentWillUnmount() {
    this.state.infoWindow !== null && (qt(this.registeredEvents), this.props.onUnmount && this.props.onUnmount(this.state.infoWindow), this.state.infoWindow.close());
  }
  render() {
    return this.containerElement ? yr(at.only(this.props.children), this.containerElement) : null;
  }
}
ge(LBe, "contextType", _t);
function cU(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Em(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? cU(Object(n), !0).forEach(function(r) {
      ge(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : cU(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var pU = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, dU = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, _Be = {};
function PBe(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: h,
    onRightClick: f,
    onClick: m,
    onDrag: g,
    onLoad: E,
    onUnmount: w
  } = e, M = ye(_t), [x, y] = k(null), [C, P] = k(null), [F, L] = k(null), [N, I] = k(null), [H, V] = k(null), [z, q] = k(null), [K, J] = k(null), [te, ee] = k(null), [_, D] = k(null), [$, S] = k(null), [W, O] = k(null), [T, U] = k(null);
  return v(() => {
    x !== null && x.setMap(M);
  }, [M]), v(() => {
    typeof t < "u" && x !== null && x.setOptions(t);
  }, [x, t]), v(() => {
    typeof n < "u" && x !== null && x.setDraggable(n);
  }, [x, n]), v(() => {
    typeof r < "u" && x !== null && x.setEditable(r);
  }, [x, r]), v(() => {
    typeof o < "u" && x !== null && x.setVisible(o);
  }, [x, o]), v(() => {
    typeof i < "u" && x !== null && x.setPath(i);
  }, [x, i]), v(() => {
    x && a && (C !== null && google.maps.event.removeListener(C), P(google.maps.event.addListener(x, "dblclick", a)));
  }, [a]), v(() => {
    x && s && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(x, "dragend", s)));
  }, [s]), v(() => {
    x && l && (N !== null && google.maps.event.removeListener(N), I(google.maps.event.addListener(x, "dragstart", l)));
  }, [l]), v(() => {
    x && u && (H !== null && google.maps.event.removeListener(H), V(google.maps.event.addListener(x, "mousedown", u)));
  }, [u]), v(() => {
    x && c && (z !== null && google.maps.event.removeListener(z), q(google.maps.event.addListener(x, "mousemove", c)));
  }, [c]), v(() => {
    x && p && (K !== null && google.maps.event.removeListener(K), J(google.maps.event.addListener(x, "mouseout", p)));
  }, [p]), v(() => {
    x && d && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(x, "mouseover", d)));
  }, [d]), v(() => {
    x && h && (_ !== null && google.maps.event.removeListener(_), D(google.maps.event.addListener(x, "mouseup", h)));
  }, [h]), v(() => {
    x && f && ($ !== null && google.maps.event.removeListener($), S(google.maps.event.addListener(x, "rightclick", f)));
  }, [f]), v(() => {
    x && m && (W !== null && google.maps.event.removeListener(W), O(google.maps.event.addListener(x, "click", m)));
  }, [m]), v(() => {
    x && g && (T !== null && google.maps.event.removeListener(T), U(google.maps.event.addListener(x, "drag", g)));
  }, [g]), v(() => {
    var j = new google.maps.Polyline(Em(Em({}, t || _Be), {}, {
      map: M
    }));
    return i && j.setPath(i), typeof o < "u" && j.setVisible(o), typeof r < "u" && j.setEditable(r), typeof n < "u" && j.setDraggable(n), a && P(google.maps.event.addListener(j, "dblclick", a)), s && L(google.maps.event.addListener(j, "dragend", s)), l && I(google.maps.event.addListener(j, "dragstart", l)), u && V(google.maps.event.addListener(j, "mousedown", u)), c && q(google.maps.event.addListener(j, "mousemove", c)), p && J(google.maps.event.addListener(j, "mouseout", p)), d && ee(google.maps.event.addListener(j, "mouseover", d)), h && D(google.maps.event.addListener(j, "mouseup", h)), f && S(google.maps.event.addListener(j, "rightclick", f)), m && O(google.maps.event.addListener(j, "click", m)), g && U(google.maps.event.addListener(j, "drag", g)), y(j), E && E(j), () => {
      C !== null && google.maps.event.removeListener(C), F !== null && google.maps.event.removeListener(F), N !== null && google.maps.event.removeListener(N), H !== null && google.maps.event.removeListener(H), z !== null && google.maps.event.removeListener(z), K !== null && google.maps.event.removeListener(K), te !== null && google.maps.event.removeListener(te), _ !== null && google.maps.event.removeListener(_), $ !== null && google.maps.event.removeListener($), W !== null && google.maps.event.removeListener(W), w && w(j), j.setMap(null);
    };
  }, []), null;
}
Ee(PBe);
class SBe extends pe {
  constructor() {
    super(...arguments), ge(this, "registeredEvents", []), ge(this, "state", {
      polyline: null
    }), ge(this, "setPolylineCallback", () => {
      this.state.polyline !== null && this.props.onLoad && this.props.onLoad(this.state.polyline);
    });
  }
  componentDidMount() {
    var t = new google.maps.Polyline(Em(Em({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Ft({
      updaterMap: dU,
      eventMap: pU,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        polyline: t
      };
    }, this.setPolylineCallback);
  }
  componentDidUpdate(t) {
    this.state.polyline !== null && (qt(this.registeredEvents), this.registeredEvents = Ft({
      updaterMap: dU,
      eventMap: pU,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.polyline
    }));
  }
  componentWillUnmount() {
    this.state.polyline !== null && (this.props.onUnmount && this.props.onUnmount(this.state.polyline), qt(this.registeredEvents), this.state.polyline.setMap(null));
  }
  render() {
    return null;
  }
}
ge(SBe, "contextType", _t);
function fU(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function hU(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? fU(Object(n), !0).forEach(function(r) {
      ge(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : fU(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var gU = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, mU = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  paths(e, t) {
    e.setPaths(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function MBe(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    paths: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: h,
    onMouseUp: f,
    onRightClick: m,
    onClick: g,
    onDrag: E,
    onLoad: w,
    onUnmount: M,
    onEdit: x
  } = e, y = ye(_t), [C, P] = k(null), [F, L] = k(null), [N, I] = k(null), [H, V] = k(null), [z, q] = k(null), [K, J] = k(null), [te, ee] = k(null), [_, D] = k(null), [$, S] = k(null), [W, O] = k(null), [T, U] = k(null), [j, Z] = k(null);
  return v(() => {
    C !== null && C.setMap(y);
  }, [y]), v(() => {
    typeof t < "u" && C !== null && C.setOptions(t);
  }, [C, t]), v(() => {
    typeof n < "u" && C !== null && C.setDraggable(n);
  }, [C, n]), v(() => {
    typeof r < "u" && C !== null && C.setEditable(r);
  }, [C, r]), v(() => {
    typeof o < "u" && C !== null && C.setVisible(o);
  }, [C, o]), v(() => {
    typeof i < "u" && C !== null && C.setPath(i);
  }, [C, i]), v(() => {
    typeof a < "u" && C !== null && C.setPaths(a);
  }, [C, a]), v(() => {
    C && typeof s == "function" && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(C, "dblclick", s)));
  }, [s]), v(() => {
    C && (google.maps.event.addListener(C.getPath(), "insert_at", () => {
      x == null || x(C);
    }), google.maps.event.addListener(C.getPath(), "set_at", () => {
      x == null || x(C);
    }), google.maps.event.addListener(C.getPath(), "remove_at", () => {
      x == null || x(C);
    }));
  }, [C, x]), v(() => {
    C && typeof l == "function" && (N !== null && google.maps.event.removeListener(N), I(google.maps.event.addListener(C, "dragend", l)));
  }, [l]), v(() => {
    C && typeof u == "function" && (H !== null && google.maps.event.removeListener(H), V(google.maps.event.addListener(C, "dragstart", u)));
  }, [u]), v(() => {
    C && typeof c == "function" && (z !== null && google.maps.event.removeListener(z), q(google.maps.event.addListener(C, "mousedown", c)));
  }, [c]), v(() => {
    C && typeof p == "function" && (K !== null && google.maps.event.removeListener(K), J(google.maps.event.addListener(C, "mousemove", p)));
  }, [p]), v(() => {
    C && typeof d == "function" && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(C, "mouseout", d)));
  }, [d]), v(() => {
    C && typeof h == "function" && (_ !== null && google.maps.event.removeListener(_), D(google.maps.event.addListener(C, "mouseover", h)));
  }, [h]), v(() => {
    C && typeof f == "function" && ($ !== null && google.maps.event.removeListener($), S(google.maps.event.addListener(C, "mouseup", f)));
  }, [f]), v(() => {
    C && typeof m == "function" && (W !== null && google.maps.event.removeListener(W), O(google.maps.event.addListener(C, "rightclick", m)));
  }, [m]), v(() => {
    C && typeof g == "function" && (T !== null && google.maps.event.removeListener(T), U(google.maps.event.addListener(C, "click", g)));
  }, [g]), v(() => {
    C && typeof E == "function" && (j !== null && google.maps.event.removeListener(j), Z(google.maps.event.addListener(C, "drag", E)));
  }, [E]), v(() => {
    var A = new google.maps.Polygon(hU(hU({}, t), {}, {
      map: y
    }));
    return i && A.setPath(i), a && A.setPaths(a), typeof o < "u" && A.setVisible(o), typeof r < "u" && A.setEditable(r), typeof n < "u" && A.setDraggable(n), s && L(google.maps.event.addListener(A, "dblclick", s)), l && I(google.maps.event.addListener(A, "dragend", l)), u && V(google.maps.event.addListener(A, "dragstart", u)), c && q(google.maps.event.addListener(A, "mousedown", c)), p && J(google.maps.event.addListener(A, "mousemove", p)), d && ee(google.maps.event.addListener(A, "mouseout", d)), h && D(google.maps.event.addListener(A, "mouseover", h)), f && S(google.maps.event.addListener(A, "mouseup", f)), m && O(google.maps.event.addListener(A, "rightclick", m)), g && U(google.maps.event.addListener(A, "click", g)), E && Z(google.maps.event.addListener(A, "drag", E)), P(A), w && w(A), () => {
      F !== null && google.maps.event.removeListener(F), N !== null && google.maps.event.removeListener(N), H !== null && google.maps.event.removeListener(H), z !== null && google.maps.event.removeListener(z), K !== null && google.maps.event.removeListener(K), te !== null && google.maps.event.removeListener(te), _ !== null && google.maps.event.removeListener(_), $ !== null && google.maps.event.removeListener($), W !== null && google.maps.event.removeListener(W), T !== null && google.maps.event.removeListener(T), M && M(A), A.setMap(null);
    };
  }, []), null;
}
Ee(MBe);
class DBe extends pe {
  constructor() {
    super(...arguments), ge(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this.props.options || {};
    this.polygon = new google.maps.Polygon(t), this.polygon.setMap(this.context), this.registeredEvents = Ft({
      updaterMap: mU,
      eventMap: gU,
      prevProps: {},
      nextProps: this.props,
      instance: this.polygon
    }), this.props.onLoad && this.props.onLoad(this.polygon);
  }
  componentDidUpdate(t) {
    this.polygon && (qt(this.registeredEvents), this.registeredEvents = Ft({
      updaterMap: mU,
      eventMap: gU,
      prevProps: t,
      nextProps: this.props,
      instance: this.polygon
    }));
  }
  componentWillUnmount() {
    this.polygon && (this.props.onUnmount && this.props.onUnmount(this.polygon), qt(this.registeredEvents), this.polygon && this.polygon.setMap(null));
  }
  render() {
    return null;
  }
}
ge(DBe, "contextType", _t);
function vU(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function km(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? vU(Object(n), !0).forEach(function(r) {
      ge(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : vU(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var yU = {
  onBoundsChanged: "bounds_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, bU = {
  bounds(e, t) {
    e.setBounds(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function TBe(e) {
  var {
    options: t,
    bounds: n,
    draggable: r,
    editable: o,
    visible: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: h,
    onRightClick: f,
    onClick: m,
    onDrag: g,
    onBoundsChanged: E,
    onLoad: w,
    onUnmount: M
  } = e, x = ye(_t), [y, C] = k(null), [P, F] = k(null), [L, N] = k(null), [I, H] = k(null), [V, z] = k(null), [q, K] = k(null), [J, te] = k(null), [ee, _] = k(null), [D, $] = k(null), [S, W] = k(null), [O, T] = k(null), [U, j] = k(null), [Z, A] = k(null);
  return v(() => {
    y !== null && y.setMap(x);
  }, [x]), v(() => {
    typeof t < "u" && y !== null && y.setOptions(t);
  }, [y, t]), v(() => {
    typeof r < "u" && y !== null && y.setDraggable(r);
  }, [y, r]), v(() => {
    typeof o < "u" && y !== null && y.setEditable(o);
  }, [y, o]), v(() => {
    typeof i < "u" && y !== null && y.setVisible(i);
  }, [y, i]), v(() => {
    typeof n < "u" && y !== null && y.setBounds(n);
  }, [y, n]), v(() => {
    y && a && (P !== null && google.maps.event.removeListener(P), F(google.maps.event.addListener(y, "dblclick", a)));
  }, [a]), v(() => {
    y && s && (L !== null && google.maps.event.removeListener(L), N(google.maps.event.addListener(y, "dragend", s)));
  }, [s]), v(() => {
    y && l && (I !== null && google.maps.event.removeListener(I), H(google.maps.event.addListener(y, "dragstart", l)));
  }, [l]), v(() => {
    y && u && (V !== null && google.maps.event.removeListener(V), z(google.maps.event.addListener(y, "mousedown", u)));
  }, [u]), v(() => {
    y && c && (q !== null && google.maps.event.removeListener(q), K(google.maps.event.addListener(y, "mousemove", c)));
  }, [c]), v(() => {
    y && p && (J !== null && google.maps.event.removeListener(J), te(google.maps.event.addListener(y, "mouseout", p)));
  }, [p]), v(() => {
    y && d && (ee !== null && google.maps.event.removeListener(ee), _(google.maps.event.addListener(y, "mouseover", d)));
  }, [d]), v(() => {
    y && h && (D !== null && google.maps.event.removeListener(D), $(google.maps.event.addListener(y, "mouseup", h)));
  }, [h]), v(() => {
    y && f && (S !== null && google.maps.event.removeListener(S), W(google.maps.event.addListener(y, "rightclick", f)));
  }, [f]), v(() => {
    y && m && (O !== null && google.maps.event.removeListener(O), T(google.maps.event.addListener(y, "click", m)));
  }, [m]), v(() => {
    y && g && (U !== null && google.maps.event.removeListener(U), j(google.maps.event.addListener(y, "drag", g)));
  }, [g]), v(() => {
    y && E && (Z !== null && google.maps.event.removeListener(Z), A(google.maps.event.addListener(y, "bounds_changed", E)));
  }, [E]), v(() => {
    var Q = new google.maps.Rectangle(km(km({}, t), {}, {
      map: x
    }));
    return typeof i < "u" && Q.setVisible(i), typeof o < "u" && Q.setEditable(o), typeof r < "u" && Q.setDraggable(r), typeof n < "u" && Q.setBounds(n), a && F(google.maps.event.addListener(Q, "dblclick", a)), s && N(google.maps.event.addListener(Q, "dragend", s)), l && H(google.maps.event.addListener(Q, "dragstart", l)), u && z(google.maps.event.addListener(Q, "mousedown", u)), c && K(google.maps.event.addListener(Q, "mousemove", c)), p && te(google.maps.event.addListener(Q, "mouseout", p)), d && _(google.maps.event.addListener(Q, "mouseover", d)), h && $(google.maps.event.addListener(Q, "mouseup", h)), f && W(google.maps.event.addListener(Q, "rightclick", f)), m && T(google.maps.event.addListener(Q, "click", m)), g && j(google.maps.event.addListener(Q, "drag", g)), E && A(google.maps.event.addListener(Q, "bounds_changed", E)), C(Q), w && w(Q), () => {
      P !== null && google.maps.event.removeListener(P), L !== null && google.maps.event.removeListener(L), I !== null && google.maps.event.removeListener(I), V !== null && google.maps.event.removeListener(V), q !== null && google.maps.event.removeListener(q), J !== null && google.maps.event.removeListener(J), ee !== null && google.maps.event.removeListener(ee), D !== null && google.maps.event.removeListener(D), S !== null && google.maps.event.removeListener(S), O !== null && google.maps.event.removeListener(O), U !== null && google.maps.event.removeListener(U), Z !== null && google.maps.event.removeListener(Z), M && M(Q), Q.setMap(null);
    };
  }, []), null;
}
Ee(TBe);
class jBe extends pe {
  constructor() {
    super(...arguments), ge(this, "registeredEvents", []), ge(this, "state", {
      rectangle: null
    }), ge(this, "setRectangleCallback", () => {
      this.state.rectangle !== null && this.props.onLoad && this.props.onLoad(this.state.rectangle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Rectangle(km(km({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Ft({
      updaterMap: bU,
      eventMap: yU,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        rectangle: t
      };
    }, this.setRectangleCallback);
  }
  componentDidUpdate(t) {
    this.state.rectangle !== null && (qt(this.registeredEvents), this.registeredEvents = Ft({
      updaterMap: bU,
      eventMap: yU,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.rectangle
    }));
  }
  componentWillUnmount() {
    this.state.rectangle !== null && (this.props.onUnmount && this.props.onUnmount(this.state.rectangle), qt(this.registeredEvents), this.state.rectangle.setMap(null));
  }
  render() {
    return null;
  }
}
ge(jBe, "contextType", _t);
function wU(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Lm(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? wU(Object(n), !0).forEach(function(r) {
      ge(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : wU(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var CU = {
  onCenterChanged: "center_changed",
  onRadiusChanged: "radius_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, xU = {
  center(e, t) {
    e.setCenter(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  radius(e, t) {
    e.setRadius(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, ABe = {};
function BBe(e) {
  var {
    options: t,
    center: n,
    radius: r,
    draggable: o,
    editable: i,
    visible: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: h,
    onMouseUp: f,
    onRightClick: m,
    onClick: g,
    onDrag: E,
    onCenterChanged: w,
    onRadiusChanged: M,
    onLoad: x,
    onUnmount: y
  } = e, C = ye(_t), [P, F] = k(null), [L, N] = k(null), [I, H] = k(null), [V, z] = k(null), [q, K] = k(null), [J, te] = k(null), [ee, _] = k(null), [D, $] = k(null), [S, W] = k(null), [O, T] = k(null), [U, j] = k(null), [Z, A] = k(null), [Q, R] = k(null), [ue, fe] = k(null);
  return v(() => {
    P !== null && P.setMap(C);
  }, [C]), v(() => {
    typeof t < "u" && P !== null && P.setOptions(t);
  }, [P, t]), v(() => {
    typeof o < "u" && P !== null && P.setDraggable(o);
  }, [P, o]), v(() => {
    typeof i < "u" && P !== null && P.setEditable(i);
  }, [P, i]), v(() => {
    typeof a < "u" && P !== null && P.setVisible(a);
  }, [P, a]), v(() => {
    typeof r == "number" && P !== null && P.setRadius(r);
  }, [P, r]), v(() => {
    typeof n < "u" && P !== null && P.setCenter(n);
  }, [P, n]), v(() => {
    P && s && (L !== null && google.maps.event.removeListener(L), N(google.maps.event.addListener(P, "dblclick", s)));
  }, [s]), v(() => {
    P && l && (I !== null && google.maps.event.removeListener(I), H(google.maps.event.addListener(P, "dragend", l)));
  }, [l]), v(() => {
    P && u && (V !== null && google.maps.event.removeListener(V), z(google.maps.event.addListener(P, "dragstart", u)));
  }, [u]), v(() => {
    P && c && (q !== null && google.maps.event.removeListener(q), K(google.maps.event.addListener(P, "mousedown", c)));
  }, [c]), v(() => {
    P && p && (J !== null && google.maps.event.removeListener(J), te(google.maps.event.addListener(P, "mousemove", p)));
  }, [p]), v(() => {
    P && d && (ee !== null && google.maps.event.removeListener(ee), _(google.maps.event.addListener(P, "mouseout", d)));
  }, [d]), v(() => {
    P && h && (D !== null && google.maps.event.removeListener(D), $(google.maps.event.addListener(P, "mouseover", h)));
  }, [h]), v(() => {
    P && f && (S !== null && google.maps.event.removeListener(S), W(google.maps.event.addListener(P, "mouseup", f)));
  }, [f]), v(() => {
    P && m && (O !== null && google.maps.event.removeListener(O), T(google.maps.event.addListener(P, "rightclick", m)));
  }, [m]), v(() => {
    P && g && (U !== null && google.maps.event.removeListener(U), j(google.maps.event.addListener(P, "click", g)));
  }, [g]), v(() => {
    P && E && (Z !== null && google.maps.event.removeListener(Z), A(google.maps.event.addListener(P, "drag", E)));
  }, [E]), v(() => {
    P && w && (Q !== null && google.maps.event.removeListener(Q), R(google.maps.event.addListener(P, "center_changed", w)));
  }, [g]), v(() => {
    P && M && (ue !== null && google.maps.event.removeListener(ue), fe(google.maps.event.addListener(P, "radius_changed", M)));
  }, [M]), v(() => {
    var oe = new google.maps.Circle(Lm(Lm({}, t || ABe), {}, {
      map: C
    }));
    return typeof r == "number" && oe.setRadius(r), typeof n < "u" && oe.setCenter(n), typeof r == "number" && oe.setRadius(r), typeof a < "u" && oe.setVisible(a), typeof i < "u" && oe.setEditable(i), typeof o < "u" && oe.setDraggable(o), s && N(google.maps.event.addListener(oe, "dblclick", s)), l && H(google.maps.event.addListener(oe, "dragend", l)), u && z(google.maps.event.addListener(oe, "dragstart", u)), c && K(google.maps.event.addListener(oe, "mousedown", c)), p && te(google.maps.event.addListener(oe, "mousemove", p)), d && _(google.maps.event.addListener(oe, "mouseout", d)), h && $(google.maps.event.addListener(oe, "mouseover", h)), f && W(google.maps.event.addListener(oe, "mouseup", f)), m && T(google.maps.event.addListener(oe, "rightclick", m)), g && j(google.maps.event.addListener(oe, "click", g)), E && A(google.maps.event.addListener(oe, "drag", E)), w && R(google.maps.event.addListener(oe, "center_changed", w)), M && fe(google.maps.event.addListener(oe, "radius_changed", M)), F(oe), x && x(oe), () => {
      L !== null && google.maps.event.removeListener(L), I !== null && google.maps.event.removeListener(I), V !== null && google.maps.event.removeListener(V), q !== null && google.maps.event.removeListener(q), J !== null && google.maps.event.removeListener(J), ee !== null && google.maps.event.removeListener(ee), D !== null && google.maps.event.removeListener(D), S !== null && google.maps.event.removeListener(S), O !== null && google.maps.event.removeListener(O), U !== null && google.maps.event.removeListener(U), Q !== null && google.maps.event.removeListener(Q), ue !== null && google.maps.event.removeListener(ue), y && y(oe), oe.setMap(null);
    };
  }, []), null;
}
Ee(BBe);
class IBe extends pe {
  constructor() {
    super(...arguments), ge(this, "registeredEvents", []), ge(this, "state", {
      circle: null
    }), ge(this, "setCircleCallback", () => {
      this.state.circle !== null && this.props.onLoad && this.props.onLoad(this.state.circle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Circle(Lm(Lm({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Ft({
      updaterMap: xU,
      eventMap: CU,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        circle: t
      };
    }, this.setCircleCallback);
  }
  componentDidUpdate(t) {
    this.state.circle !== null && (qt(this.registeredEvents), this.registeredEvents = Ft({
      updaterMap: xU,
      eventMap: CU,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.circle
    }));
  }
  componentWillUnmount() {
    if (this.state.circle !== null) {
      var t;
      this.props.onUnmount && this.props.onUnmount(this.state.circle), qt(this.registeredEvents), (t = this.state.circle) === null || t === void 0 || t.setMap(null);
    }
  }
  render() {
    return null;
  }
}
ge(IBe, "contextType", _t);
function OU(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function _m(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? OU(Object(n), !0).forEach(function(r) {
      ge(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : OU(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var EU = {
  onClick: "click",
  onDblClick: "dblclick",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onAddFeature: "addfeature",
  onRemoveFeature: "removefeature",
  onRemoveProperty: "removeproperty",
  onSetGeometry: "setgeometry",
  onSetProperty: "setproperty"
}, kU = {
  add(e, t) {
    e.add(t);
  },
  addgeojson(e, t, n) {
    e.addGeoJson(t, n);
  },
  contains(e, t) {
    e.contains(t);
  },
  foreach(e, t) {
    e.forEach(t);
  },
  loadgeojson(e, t, n, r) {
    e.loadGeoJson(t, n, r);
  },
  overridestyle(e, t, n) {
    e.overrideStyle(t, n);
  },
  remove(e, t) {
    e.remove(t);
  },
  revertstyle(e, t) {
    e.revertStyle(t);
  },
  controlposition(e, t) {
    e.setControlPosition(t);
  },
  controls(e, t) {
    e.setControls(t);
  },
  drawingmode(e, t) {
    e.setDrawingMode(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  style(e, t) {
    e.setStyle(t);
  },
  togeojson(e, t) {
    e.toGeoJson(t);
  }
};
function RBe(e) {
  var {
    options: t,
    onClick: n,
    onDblClick: r,
    onMouseDown: o,
    onMouseMove: i,
    onMouseOut: a,
    onMouseOver: s,
    onMouseUp: l,
    onRightClick: u,
    onAddFeature: c,
    onRemoveFeature: p,
    onRemoveProperty: d,
    onSetGeometry: h,
    onSetProperty: f,
    onLoad: m,
    onUnmount: g
  } = e, E = ye(_t), [w, M] = k(null), [x, y] = k(null), [C, P] = k(null), [F, L] = k(null), [N, I] = k(null), [H, V] = k(null), [z, q] = k(null), [K, J] = k(null), [te, ee] = k(null), [_, D] = k(null), [$, S] = k(null), [W, O] = k(null), [T, U] = k(null), [j, Z] = k(null);
  return v(() => {
    w !== null && w.setMap(E);
  }, [E]), v(() => {
    w && r && (x !== null && google.maps.event.removeListener(x), y(google.maps.event.addListener(w, "dblclick", r)));
  }, [r]), v(() => {
    w && o && (C !== null && google.maps.event.removeListener(C), P(google.maps.event.addListener(w, "mousedown", o)));
  }, [o]), v(() => {
    w && i && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(w, "mousemove", i)));
  }, [i]), v(() => {
    w && a && (N !== null && google.maps.event.removeListener(N), I(google.maps.event.addListener(w, "mouseout", a)));
  }, [a]), v(() => {
    w && s && (H !== null && google.maps.event.removeListener(H), V(google.maps.event.addListener(w, "mouseover", s)));
  }, [s]), v(() => {
    w && l && (z !== null && google.maps.event.removeListener(z), q(google.maps.event.addListener(w, "mouseup", l)));
  }, [l]), v(() => {
    w && u && (K !== null && google.maps.event.removeListener(K), J(google.maps.event.addListener(w, "rightclick", u)));
  }, [u]), v(() => {
    w && n && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(w, "click", n)));
  }, [n]), v(() => {
    w && c && (_ !== null && google.maps.event.removeListener(_), D(google.maps.event.addListener(w, "addfeature", c)));
  }, [c]), v(() => {
    w && p && ($ !== null && google.maps.event.removeListener($), S(google.maps.event.addListener(w, "removefeature", p)));
  }, [p]), v(() => {
    w && d && (W !== null && google.maps.event.removeListener(W), O(google.maps.event.addListener(w, "removeproperty", d)));
  }, [d]), v(() => {
    w && h && (T !== null && google.maps.event.removeListener(T), U(google.maps.event.addListener(w, "setgeometry", h)));
  }, [h]), v(() => {
    w && f && (j !== null && google.maps.event.removeListener(j), Z(google.maps.event.addListener(w, "setproperty", f)));
  }, [f]), v(() => {
    if (E !== null) {
      var A = new google.maps.Data(_m(_m({}, t), {}, {
        map: E
      }));
      r && y(google.maps.event.addListener(A, "dblclick", r)), o && P(google.maps.event.addListener(A, "mousedown", o)), i && L(google.maps.event.addListener(A, "mousemove", i)), a && I(google.maps.event.addListener(A, "mouseout", a)), s && V(google.maps.event.addListener(A, "mouseover", s)), l && q(google.maps.event.addListener(A, "mouseup", l)), u && J(google.maps.event.addListener(A, "rightclick", u)), n && ee(google.maps.event.addListener(A, "click", n)), c && D(google.maps.event.addListener(A, "addfeature", c)), p && S(google.maps.event.addListener(A, "removefeature", p)), d && O(google.maps.event.addListener(A, "removeproperty", d)), h && U(google.maps.event.addListener(A, "setgeometry", h)), f && Z(google.maps.event.addListener(A, "setproperty", f)), M(A), m && m(A);
    }
    return () => {
      w && (x !== null && google.maps.event.removeListener(x), C !== null && google.maps.event.removeListener(C), F !== null && google.maps.event.removeListener(F), N !== null && google.maps.event.removeListener(N), H !== null && google.maps.event.removeListener(H), z !== null && google.maps.event.removeListener(z), K !== null && google.maps.event.removeListener(K), te !== null && google.maps.event.removeListener(te), _ !== null && google.maps.event.removeListener(_), $ !== null && google.maps.event.removeListener($), W !== null && google.maps.event.removeListener(W), T !== null && google.maps.event.removeListener(T), j !== null && google.maps.event.removeListener(j), g && g(w), w.setMap(null));
    };
  }, []), null;
}
Ee(RBe);
class NBe extends pe {
  constructor() {
    super(...arguments), ge(this, "registeredEvents", []), ge(this, "state", {
      data: null
    }), ge(this, "setDataCallback", () => {
      this.state.data !== null && this.props.onLoad && this.props.onLoad(this.state.data);
    });
  }
  componentDidMount() {
    if (this.context !== null) {
      var t = new google.maps.Data(_m(_m({}, this.props.options), {}, {
        map: this.context
      }));
      this.registeredEvents = Ft({
        updaterMap: kU,
        eventMap: EU,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        data: t
      }), this.setDataCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.data !== null && (qt(this.registeredEvents), this.registeredEvents = Ft({
      updaterMap: kU,
      eventMap: EU,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.data
    }));
  }
  componentWillUnmount() {
    this.state.data !== null && (this.props.onUnmount && this.props.onUnmount(this.state.data), qt(this.registeredEvents), this.state.data && this.state.data.setMap(null));
  }
  render() {
    return null;
  }
}
ge(NBe, "contextType", _t);
function LU(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function _U(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? LU(Object(n), !0).forEach(function(r) {
      ge(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : LU(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var PU = {
  onClick: "click",
  onDefaultViewportChanged: "defaultviewport_changed",
  onStatusChanged: "status_changed"
}, SU = {
  options(e, t) {
    e.setOptions(t);
  },
  url(e, t) {
    e.setUrl(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
class FBe extends pe {
  constructor() {
    super(...arguments), ge(this, "registeredEvents", []), ge(this, "state", {
      kmlLayer: null
    }), ge(this, "setKmlLayerCallback", () => {
      this.state.kmlLayer !== null && this.props.onLoad && this.props.onLoad(this.state.kmlLayer);
    });
  }
  componentDidMount() {
    var t = new google.maps.KmlLayer(_U(_U({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Ft({
      updaterMap: SU,
      eventMap: PU,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        kmlLayer: t
      };
    }, this.setKmlLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.kmlLayer !== null && (qt(this.registeredEvents), this.registeredEvents = Ft({
      updaterMap: SU,
      eventMap: PU,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.kmlLayer
    }));
  }
  componentWillUnmount() {
    this.state.kmlLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.kmlLayer), qt(this.registeredEvents), this.state.kmlLayer.setMap(null));
  }
  render() {
    return null;
  }
}
ge(FBe, "contextType", _t);
function x4(e, t) {
  return typeof t == "function" ? t(e.offsetWidth, e.offsetHeight) : {
    x: 0,
    y: 0
  };
}
function zBe(e, t) {
  return new t(e.lat, e.lng);
}
function UBe(e, t) {
  return new t(new google.maps.LatLng(e.ne.lat, e.ne.lng), new google.maps.LatLng(e.sw.lat, e.sw.lng));
}
function $Be(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function HBe(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function WBe(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n.getNorthEast()), o = e && e.fromLatLngToDivPixel(n.getSouthWest());
  return r && o ? {
    left: "".concat(o.x + t.x, "px"),
    top: "".concat(r.y + t.y, "px"),
    width: "".concat(r.x - o.x - t.x, "px"),
    height: "".concat(o.y - r.y - t.y, "px")
  } : {
    left: "-9999px",
    top: "-9999px"
  };
}
function VBe(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n);
  if (r) {
    var {
      x: o,
      y: i
    } = r;
    return {
      left: "".concat(o + t.x, "px"),
      top: "".concat(i + t.y, "px")
    };
  }
  return {
    left: "-9999px",
    top: "-9999px"
  };
}
function O4(e, t, n, r) {
  return n !== void 0 ? WBe(e, t, HBe(n, google.maps.LatLngBounds, UBe)) : VBe(e, t, $Be(r, google.maps.LatLng, zBe));
}
function qBe(e, t) {
  return e.left === t.left && e.top === t.top && e.width === t.height && e.height === t.height;
}
function MU(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ZBe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? MU(Object(n), !0).forEach(function(r) {
      ge(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : MU(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function GBe(e, t, n, r, o) {
  class i extends google.maps.OverlayView {
    constructor(s, l, u, c) {
      super(), this.container = s, this.pane = l, this.position = u, this.bounds = c;
    }
    onAdd() {
      var s, l = (s = this.getPanes()) === null || s === void 0 ? void 0 : s[this.pane];
      l == null || l.appendChild(this.container);
    }
    draw() {
      var s = this.getProjection(), l = ZBe({}, this.container ? x4(this.container, o) : {
        x: 0,
        y: 0
      }), u = O4(s, l, this.bounds, this.position);
      for (var [c, p] of Object.entries(u))
        this.container.style[c] = p;
    }
    onRemove() {
      this.container.parentNode !== null && this.container.parentNode.removeChild(this.container);
    }
  }
  return new i(e, t, n, r);
}
function DU(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function XBe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? DU(Object(n), !0).forEach(function(r) {
      ge(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : DU(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function TU(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLng ? e : new google.maps.LatLng(e.lat, e.lng);
  return t + "";
}
function jU(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLngBounds ? e : new google.maps.LatLngBounds(new google.maps.LatLng(e.south, e.east), new google.maps.LatLng(e.north, e.west));
  return t + "";
}
function KBe(e) {
  var {
    position: t,
    bounds: n,
    mapPaneName: r,
    zIndex: o,
    onLoad: i,
    onUnmount: a,
    getPixelPositionOffset: s,
    children: l
  } = e, u = ye(_t), c = Tn(() => {
    var d = document.createElement("div");
    return d.style.position = "absolute", d;
  }, []), p = Tn(() => GBe(c, r, t, n, s), [c, r, t, n]);
  return v(() => (i == null || i(p), p == null || p.setMap(u), () => {
    a == null || a(p), p == null || p.setMap(null);
  }), [u, p]), v(() => {
    c.style.zIndex = "".concat(o);
  }, [o, c]), Ci.createPortal(l, c);
}
Ee(KBe);
class Su extends pe {
  constructor(t) {
    super(t), ge(this, "state", {
      paneEl: null,
      containerStyle: {
        // set initial position
        position: "absolute"
      }
    }), ge(this, "updatePane", () => {
      var r = this.props.mapPaneName, o = this.overlayView.getPanes();
      Yr(!!r, "OverlayView requires props.mapPaneName but got %s", r), o ? this.setState({
        paneEl: o[r]
      }) : this.setState({
        paneEl: null
      });
    }), ge(this, "onAdd", () => {
      var r, o;
      this.updatePane(), (r = (o = this.props).onLoad) === null || r === void 0 || r.call(o, this.overlayView);
    }), ge(this, "onPositionElement", () => {
      var r = this.overlayView.getProjection(), o = XBe({
        x: 0,
        y: 0
      }, this.containerRef.current ? x4(this.containerRef.current, this.props.getPixelPositionOffset) : {}), i = O4(r, o, this.props.bounds, this.props.position);
      if (!qBe(i, {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        left: this.state.containerStyle.left,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        top: this.state.containerStyle.top,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        width: this.state.containerStyle.width,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        height: this.state.containerStyle.height
      })) {
        var a, s, l, u;
        this.setState({
          containerStyle: {
            top: (a = i.top) !== null && a !== void 0 ? a : 0,
            left: (s = i.left) !== null && s !== void 0 ? s : 0,
            width: (l = i.width) !== null && l !== void 0 ? l : 0,
            height: (u = i.height) !== null && u !== void 0 ? u : 0,
            position: "absolute"
          }
        });
      }
    }), ge(this, "draw", () => {
      this.onPositionElement();
    }), ge(this, "onRemove", () => {
      var r, o;
      this.setState(() => ({
        paneEl: null
      })), (r = (o = this.props).onUnmount) === null || r === void 0 || r.call(o, this.overlayView);
    }), this.containerRef = Qr();
    var n = new google.maps.OverlayView();
    n.onAdd = this.onAdd, n.draw = this.draw, n.onRemove = this.onRemove, this.overlayView = n;
  }
  componentDidMount() {
    this.overlayView.setMap(this.context);
  }
  componentDidUpdate(t) {
    var n = TU(t.position), r = TU(this.props.position), o = jU(t.bounds), i = jU(this.props.bounds);
    (n !== r || o !== i) && this.overlayView.draw(), t.mapPaneName !== this.props.mapPaneName && this.updatePane();
  }
  componentWillUnmount() {
    this.overlayView.setMap(null);
  }
  render() {
    var t = this.state.paneEl;
    return t ? Ci.createPortal(X.jsx("div", {
      ref: this.containerRef,
      style: this.state.containerStyle,
      children: at.only(this.props.children)
    }), t) : null;
  }
}
ge(Su, "FLOAT_PANE", "floatPane");
ge(Su, "MAP_PANE", "mapPane");
ge(Su, "MARKER_LAYER", "markerLayer");
ge(Su, "OVERLAY_LAYER", "overlayLayer");
ge(Su, "OVERLAY_MOUSE_TARGET", "overlayMouseTarget");
ge(Su, "contextType", _t);
function YBe() {
}
function AU(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function BU(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? AU(Object(n), !0).forEach(function(r) {
      ge(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : AU(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var IU = {
  onDblClick: "dblclick",
  onClick: "click"
}, RU = {
  opacity(e, t) {
    e.setOpacity(t);
  }
};
function JBe(e) {
  var {
    url: t,
    bounds: n,
    options: r,
    visible: o
  } = e, i = ye(_t), a = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east)), s = Tn(() => new google.maps.GroundOverlay(t, a, r), []);
  return v(() => {
    s !== null && s.setMap(i);
  }, [i]), v(() => {
    typeof t < "u" && s !== null && (s.set("url", t), s.setMap(i));
  }, [s, t]), v(() => {
    typeof o < "u" && s !== null && s.setOpacity(o ? 1 : 0);
  }, [s, o]), v(() => {
    var l = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east));
    typeof n < "u" && s !== null && (s.set("bounds", l), s.setMap(i));
  }, [s, n]), null;
}
Ee(JBe);
class E4 extends pe {
  constructor() {
    super(...arguments), ge(this, "registeredEvents", []), ge(this, "state", {
      groundOverlay: null
    }), ge(this, "setGroundOverlayCallback", () => {
      this.state.groundOverlay !== null && this.props.onLoad && this.props.onLoad(this.state.groundOverlay);
    });
  }
  componentDidMount() {
    Yr(!!this.props.url || !!this.props.bounds, "For GroundOverlay, url and bounds are passed in to constructor and are immutable after instantiated. This is the behavior of Google Maps JavaScript API v3 ( See https://developers.google.com/maps/documentation/javascript/reference#GroundOverlay) Hence, use the corresponding two props provided by `react-google-maps-api`, url and bounds. In some cases, you'll need the GroundOverlay component to reflect the changes of url and bounds. You can leverage the React's key property to remount the component. Typically, just `key={url}` would serve your need. See https://github.com/tomchentw/react-google-maps/issues/655");
    var t = new google.maps.GroundOverlay(this.props.url, this.props.bounds, BU(BU({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Ft({
      updaterMap: RU,
      eventMap: IU,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        groundOverlay: t
      };
    }, this.setGroundOverlayCallback);
  }
  componentDidUpdate(t) {
    this.state.groundOverlay !== null && (qt(this.registeredEvents), this.registeredEvents = Ft({
      updaterMap: RU,
      eventMap: IU,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.groundOverlay
    }));
  }
  componentWillUnmount() {
    this.state.groundOverlay && (this.props.onUnmount && this.props.onUnmount(this.state.groundOverlay), this.state.groundOverlay.setMap(null));
  }
  render() {
    return null;
  }
}
ge(E4, "defaultProps", {
  onLoad: YBe
});
ge(E4, "contextType", _t);
function NU(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Pm(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? NU(Object(n), !0).forEach(function(r) {
      ge(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : NU(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var FU = {}, zU = {
  data(e, t) {
    e.setData(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function QBe(e) {
  var {
    data: t,
    onLoad: n,
    onUnmount: r,
    options: o
  } = e, i = ye(_t), [a, s] = k(null);
  return v(() => {
    google.maps.visualization || Yr(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} in useJsApiScript? %s', google.maps.visualization);
  }, []), v(() => {
    Yr(!!t, "data property is required in HeatmapLayer %s", t);
  }, [t]), v(() => {
    a !== null && a.setMap(i);
  }, [i]), v(() => {
    o && a !== null && a.setOptions(o);
  }, [a, o]), v(() => {
    var l = new google.maps.visualization.HeatmapLayer(Pm(Pm({}, o), {}, {
      data: t,
      map: i
    }));
    return s(l), n && n(l), () => {
      a !== null && (r && r(a), a.setMap(null));
    };
  }, []), null;
}
Ee(QBe);
class eIe extends pe {
  constructor() {
    super(...arguments), ge(this, "registeredEvents", []), ge(this, "state", {
      heatmapLayer: null
    }), ge(this, "setHeatmapLayerCallback", () => {
      this.state.heatmapLayer !== null && this.props.onLoad && this.props.onLoad(this.state.heatmapLayer);
    });
  }
  componentDidMount() {
    Yr(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} to <LoadScript />? %s', google.maps.visualization), Yr(!!this.props.data, "data property is required in HeatmapLayer %s", this.props.data);
    var t = new google.maps.visualization.HeatmapLayer(Pm(Pm({}, this.props.options), {}, {
      data: this.props.data,
      map: this.context
    }));
    this.registeredEvents = Ft({
      updaterMap: zU,
      eventMap: FU,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        heatmapLayer: t
      };
    }, this.setHeatmapLayerCallback);
  }
  componentDidUpdate(t) {
    qt(this.registeredEvents), this.registeredEvents = Ft({
      updaterMap: zU,
      eventMap: FU,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.heatmapLayer
    });
  }
  componentWillUnmount() {
    this.state.heatmapLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.heatmapLayer), qt(this.registeredEvents), this.state.heatmapLayer.setMap(null));
  }
  render() {
    return null;
  }
}
ge(eIe, "contextType", _t);
var UU = {
  onCloseClick: "closeclick",
  onPanoChanged: "pano_changed",
  onPositionChanged: "position_changed",
  onPovChanged: "pov_changed",
  onResize: "resize",
  onStatusChanged: "status_changed",
  onVisibleChanged: "visible_changed",
  onZoomChanged: "zoom_changed"
}, $U = {
  register(e, t, n) {
    e.registerPanoProvider(t, n);
  },
  links(e, t) {
    e.setLinks(t);
  },
  motionTracking(e, t) {
    e.setMotionTracking(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  pano(e, t) {
    e.setPano(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  pov(e, t) {
    e.setPov(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zoom(e, t) {
    e.setZoom(t);
  }
};
class tIe extends pe {
  constructor() {
    super(...arguments), ge(this, "registeredEvents", []), ge(this, "state", {
      streetViewPanorama: null
    }), ge(this, "setStreetViewPanoramaCallback", () => {
      this.state.streetViewPanorama !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewPanorama);
    });
  }
  componentDidMount() {
    var t, n, r = (t = (n = this.context) === null || n === void 0 ? void 0 : n.getStreetView()) !== null && t !== void 0 ? t : null;
    this.registeredEvents = Ft({
      updaterMap: $U,
      eventMap: UU,
      prevProps: {},
      nextProps: this.props,
      instance: r
    }), this.setState(() => ({
      streetViewPanorama: r
    }), this.setStreetViewPanoramaCallback);
  }
  componentDidUpdate(t) {
    this.state.streetViewPanorama !== null && (qt(this.registeredEvents), this.registeredEvents = Ft({
      updaterMap: $U,
      eventMap: UU,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.streetViewPanorama
    }));
  }
  componentWillUnmount() {
    this.state.streetViewPanorama !== null && (this.props.onUnmount && this.props.onUnmount(this.state.streetViewPanorama), qt(this.registeredEvents), this.state.streetViewPanorama.setVisible(!1));
  }
  render() {
    return null;
  }
}
ge(tIe, "contextType", _t);
class nIe extends pe {
  constructor() {
    super(...arguments), ge(this, "state", {
      streetViewService: null
    }), ge(this, "setStreetViewServiceCallback", () => {
      this.state.streetViewService !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewService);
    });
  }
  componentDidMount() {
    var t = new google.maps.StreetViewService();
    this.setState(function() {
      return {
        streetViewService: t
      };
    }, this.setStreetViewServiceCallback);
  }
  componentWillUnmount() {
    this.state.streetViewService !== null && this.props.onUnmount && this.props.onUnmount(this.state.streetViewService);
  }
  render() {
    return null;
  }
}
ge(nIe, "contextType", _t);
var HU = {
  onDirectionsChanged: "directions_changed"
}, WU = {
  directions(e, t) {
    e.setDirections(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  panel(e, t) {
    e.setPanel(t);
  },
  routeIndex(e, t) {
    e.setRouteIndex(t);
  }
};
class rIe extends pe {
  constructor() {
    super(...arguments), ge(this, "registeredEvents", []), ge(this, "state", {
      directionsRenderer: null
    }), ge(this, "setDirectionsRendererCallback", () => {
      this.state.directionsRenderer !== null && (this.state.directionsRenderer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.directionsRenderer));
    });
  }
  componentDidMount() {
    var t = new google.maps.DirectionsRenderer(this.props.options);
    this.registeredEvents = Ft({
      updaterMap: WU,
      eventMap: HU,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        directionsRenderer: t
      };
    }, this.setDirectionsRendererCallback);
  }
  componentDidUpdate(t) {
    this.state.directionsRenderer !== null && (qt(this.registeredEvents), this.registeredEvents = Ft({
      updaterMap: WU,
      eventMap: HU,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.directionsRenderer
    }));
  }
  componentWillUnmount() {
    this.state.directionsRenderer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.directionsRenderer), qt(this.registeredEvents), this.state.directionsRenderer && this.state.directionsRenderer.setMap(null));
  }
  render() {
    return null;
  }
}
ge(rIe, "contextType", _t);
var VU = {
  onPlacesChanged: "places_changed"
}, qU = {
  bounds(e, t) {
    e.setBounds(t);
  }
};
class k4 extends pe {
  constructor() {
    super(...arguments), ge(this, "registeredEvents", []), ge(this, "containerElement", Qr()), ge(this, "state", {
      searchBox: null
    }), ge(this, "setSearchBoxCallback", () => {
      this.state.searchBox !== null && this.props.onLoad && this.props.onLoad(this.state.searchBox);
    });
  }
  componentDidMount() {
    if (Yr(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places), this.containerElement !== null && this.containerElement.current !== null) {
      var t = this.containerElement.current.querySelector("input");
      if (t !== null) {
        var n = new google.maps.places.SearchBox(t, this.props.options);
        this.registeredEvents = Ft({
          updaterMap: qU,
          eventMap: VU,
          prevProps: {},
          nextProps: this.props,
          instance: n
        }), this.setState(function() {
          return {
            searchBox: n
          };
        }, this.setSearchBoxCallback);
      }
    }
  }
  componentDidUpdate(t) {
    this.state.searchBox !== null && (qt(this.registeredEvents), this.registeredEvents = Ft({
      updaterMap: qU,
      eventMap: VU,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.searchBox
    }));
  }
  componentWillUnmount() {
    this.state.searchBox !== null && (this.props.onUnmount && this.props.onUnmount(this.state.searchBox), qt(this.registeredEvents));
  }
  render() {
    return X.jsx("div", {
      ref: this.containerElement,
      children: at.only(this.props.children)
    });
  }
}
ge(k4, "contextType", _t);
var ZU = {
  onPlaceChanged: "place_changed"
}, GU = {
  bounds(e, t) {
    e.setBounds(t);
  },
  restrictions(e, t) {
    e.setComponentRestrictions(t);
  },
  fields(e, t) {
    e.setFields(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  types(e, t) {
    e.setTypes(t);
  }
};
class L4 extends pe {
  constructor() {
    super(...arguments), ge(this, "registeredEvents", []), ge(this, "containerElement", Qr()), ge(this, "state", {
      autocomplete: null
    }), ge(this, "setAutocompleteCallback", () => {
      this.state.autocomplete !== null && this.props.onLoad && this.props.onLoad(this.state.autocomplete);
    });
  }
  componentDidMount() {
    var t;
    Yr(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places);
    var n = (t = this.containerElement.current) === null || t === void 0 ? void 0 : t.querySelector("input");
    if (n) {
      var r = new google.maps.places.Autocomplete(n, this.props.options);
      this.registeredEvents = Ft({
        updaterMap: GU,
        eventMap: ZU,
        prevProps: {},
        nextProps: this.props,
        instance: r
      }), this.setState(() => ({
        autocomplete: r
      }), this.setAutocompleteCallback);
    }
  }
  componentDidUpdate(t) {
    qt(this.registeredEvents), this.registeredEvents = Ft({
      updaterMap: GU,
      eventMap: ZU,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.autocomplete
    });
  }
  componentWillUnmount() {
    this.state.autocomplete !== null && qt(this.registeredEvents);
  }
  render() {
    return X.jsx("div", {
      ref: this.containerElement,
      className: this.props.className,
      children: at.only(this.props.children)
    });
  }
}
ge(L4, "defaultProps", {
  className: ""
});
ge(L4, "contextType", _t);
function VRe({
  googleMapsApiKey: e,
  children: t,
  ...n
}) {
  return /* @__PURE__ */ X.jsx(
    g4,
    {
      libraries: ["places", "marker", "maps"],
      googleMapsApiKey: e,
      ...n,
      children: t
    }
  );
}
function qRe(e) {
  const { children: t = !1 } = e, [n, r] = k([]);
  function o(u) {
    return !!n.some((c) => c.key === u);
  }
  function i(u) {
    var c;
    return (c = n.find((p) => p.key === u)) == null ? void 0 : c.data;
  }
  function a(u, c) {
    const p = o(u);
    r(p ? (d) => [...d.filter((f) => f.key !== u), { key: u, data: c }] : [...n, { key: u, data: c }]);
  }
  function s(u) {
    r(n.filter((c) => c.key !== u));
  }
  function l() {
    r([]);
  }
  return /* @__PURE__ */ X.jsx(
    A1.Provider,
    {
      value: { modalIsOpen: o, modalData: i, openModal: a, closeModal: s, closeAll: l },
      children: t
    }
  );
}
let oIe = { data: "" }, iIe = (e) => typeof window == "object" ? ((e ? e.querySelector("#_goober") : window._goober) || Object.assign((e || document.head).appendChild(document.createElement("style")), { innerHTML: " ", id: "_goober" })).firstChild : e || oIe, sIe = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g, aIe = /\/\*[^]*?\*\/|  +/g, XU = /\n+/g, ca = (e, t) => {
  let n = "", r = "", o = "";
  for (let i in e) {
    let a = e[i];
    i[0] == "@" ? i[1] == "i" ? n = i + " " + a + ";" : r += i[1] == "f" ? ca(a, i) : i + "{" + ca(a, i[1] == "k" ? "" : t) + "}" : typeof a == "object" ? r += ca(a, t ? t.replace(/([^,])+/g, (s) => i.replace(/([^,]*:\S+\([^)]*\))|([^,])+/g, (l) => /&/.test(l) ? l.replace(/&/g, s) : s ? s + " " + l : l)) : i) : a != null && (i = /^--/.test(i) ? i : i.replace(/[A-Z]/g, "-$&").toLowerCase(), o += ca.p ? ca.p(i, a) : i + ":" + a + ";");
  }
  return n + (t && o ? t + "{" + o + "}" : o) + r;
}, ds = {}, _4 = (e) => {
  if (typeof e == "object") {
    let t = "";
    for (let n in e) t += n + _4(e[n]);
    return t;
  }
  return e;
}, lIe = (e, t, n, r, o) => {
  let i = _4(e), a = ds[i] || (ds[i] = ((l) => {
    let u = 0, c = 11;
    for (; u < l.length; ) c = 101 * c + l.charCodeAt(u++) >>> 0;
    return "go" + c;
  })(i));
  if (!ds[a]) {
    let l = i !== e ? e : ((u) => {
      let c, p, d = [{}];
      for (; c = sIe.exec(u.replace(aIe, "")); ) c[4] ? d.shift() : c[3] ? (p = c[3].replace(XU, " ").trim(), d.unshift(d[0][p] = d[0][p] || {})) : d[0][c[1]] = c[2].replace(XU, " ").trim();
      return d[0];
    })(e);
    ds[a] = ca(o ? { ["@keyframes " + a]: l } : l, n ? "" : "." + a);
  }
  let s = n && ds.g ? ds.g : null;
  return n && (ds.g = ds[a]), ((l, u, c, p) => {
    p ? u.data = u.data.replace(p, l) : u.data.indexOf(l) === -1 && (u.data = c ? l + u.data : u.data + l);
  })(ds[a], t, r, s), a;
}, uIe = (e, t, n) => e.reduce((r, o, i) => {
  let a = t[i];
  if (a && a.call) {
    let s = a(n), l = s && s.props && s.props.className || /^go/.test(s) && s;
    a = l ? "." + l : s && typeof s == "object" ? s.props ? "" : ca(s, "") : s === !1 ? "" : s;
  }
  return r + o + (a ?? "");
}, "");
function qy(e) {
  let t = this || {}, n = e.call ? e(t.p) : e;
  return lIe(n.unshift ? n.raw ? uIe(n, [].slice.call(arguments, 1), t.p) : n.reduce((r, o) => Object.assign(r, o && o.call ? o(t.p) : o), {}) : n, iIe(t.target), t.g, t.o, t.k);
}
let P4, Xx, Kx;
qy.bind({ g: 1 });
let ks = qy.bind({ k: 1 });
function cIe(e, t, n, r) {
  ca.p = t, P4 = e, Xx = n, Kx = r;
}
function ja(e, t) {
  let n = this || {};
  return function() {
    let r = arguments;
    function o(i, a) {
      let s = Object.assign({}, i), l = s.className || o.className;
      n.p = Object.assign({ theme: Xx && Xx() }, s), n.o = / *go\d+/.test(l), s.className = qy.apply(n, r) + (l ? " " + l : "");
      let u = e;
      return e[0] && (u = s.as || e, delete s.as), Kx && u[0] && Kx(s), P4(u, s);
    }
    return o;
  };
}
var pIe = (e) => typeof e == "function", Sm = (e, t) => pIe(e) ? e(t) : e, dIe = /* @__PURE__ */ (() => {
  let e = 0;
  return () => (++e).toString();
})(), S4 = /* @__PURE__ */ (() => {
  let e;
  return () => {
    if (e === void 0 && typeof window < "u") {
      let t = matchMedia("(prefers-reduced-motion: reduce)");
      e = !t || t.matches;
    }
    return e;
  };
})(), fIe = 20, M4 = (e, t) => {
  switch (t.type) {
    case 0:
      return { ...e, toasts: [t.toast, ...e.toasts].slice(0, fIe) };
    case 1:
      return { ...e, toasts: e.toasts.map((i) => i.id === t.toast.id ? { ...i, ...t.toast } : i) };
    case 2:
      let { toast: n } = t;
      return M4(e, { type: e.toasts.find((i) => i.id === n.id) ? 1 : 0, toast: n });
    case 3:
      let { toastId: r } = t;
      return { ...e, toasts: e.toasts.map((i) => i.id === r || r === void 0 ? { ...i, dismissed: !0, visible: !1 } : i) };
    case 4:
      return t.toastId === void 0 ? { ...e, toasts: [] } : { ...e, toasts: e.toasts.filter((i) => i.id !== t.toastId) };
    case 5:
      return { ...e, pausedAt: t.time };
    case 6:
      let o = t.time - (e.pausedAt || 0);
      return { ...e, pausedAt: void 0, toasts: e.toasts.map((i) => ({ ...i, pauseDuration: i.pauseDuration + o })) };
  }
}, Nh = [], hl = { toasts: [], pausedAt: void 0 }, Wl = (e) => {
  hl = M4(hl, e), Nh.forEach((t) => {
    t(hl);
  });
}, hIe = { blank: 4e3, error: 4e3, success: 2e3, loading: 1 / 0, custom: 4e3 }, gIe = (e = {}) => {
  let [t, n] = k(hl), r = rt(hl);
  v(() => (r.current !== hl && n(hl), Nh.push(n), () => {
    let i = Nh.indexOf(n);
    i > -1 && Nh.splice(i, 1);
  }), []);
  let o = t.toasts.map((i) => {
    var a, s, l;
    return { ...e, ...e[i.type], ...i, removeDelay: i.removeDelay || ((a = e[i.type]) == null ? void 0 : a.removeDelay) || (e == null ? void 0 : e.removeDelay), duration: i.duration || ((s = e[i.type]) == null ? void 0 : s.duration) || (e == null ? void 0 : e.duration) || hIe[i.type], style: { ...e.style, ...(l = e[i.type]) == null ? void 0 : l.style, ...i.style } };
  });
  return { ...t, toasts: o };
}, mIe = (e, t = "blank", n) => ({ createdAt: Date.now(), visible: !0, dismissed: !1, type: t, ariaProps: { role: "status", "aria-live": "polite" }, message: e, pauseDuration: 0, ...n, id: (n == null ? void 0 : n.id) || dIe() }), Pd = (e) => (t, n) => {
  let r = mIe(t, e, n);
  return Wl({ type: 2, toast: r }), r.id;
}, bo = (e, t) => Pd("blank")(e, t);
bo.error = Pd("error");
bo.success = Pd("success");
bo.loading = Pd("loading");
bo.custom = Pd("custom");
bo.dismiss = (e) => {
  Wl({ type: 3, toastId: e });
};
bo.remove = (e) => Wl({ type: 4, toastId: e });
bo.promise = (e, t, n) => {
  let r = bo.loading(t.loading, { ...n, ...n == null ? void 0 : n.loading });
  return typeof e == "function" && (e = e()), e.then((o) => {
    let i = t.success ? Sm(t.success, o) : void 0;
    return i ? bo.success(i, { id: r, ...n, ...n == null ? void 0 : n.success }) : bo.dismiss(r), o;
  }).catch((o) => {
    let i = t.error ? Sm(t.error, o) : void 0;
    i ? bo.error(i, { id: r, ...n, ...n == null ? void 0 : n.error }) : bo.dismiss(r);
  }), e;
};
var vIe = (e, t) => {
  Wl({ type: 1, toast: { id: e, height: t } });
}, yIe = () => {
  Wl({ type: 5, time: Date.now() });
}, Zc = /* @__PURE__ */ new Map(), bIe = 1e3, wIe = (e, t = bIe) => {
  if (Zc.has(e)) return;
  let n = setTimeout(() => {
    Zc.delete(e), Wl({ type: 4, toastId: e });
  }, t);
  Zc.set(e, n);
}, CIe = (e) => {
  let { toasts: t, pausedAt: n } = gIe(e);
  v(() => {
    if (n) return;
    let i = Date.now(), a = t.map((s) => {
      if (s.duration === 1 / 0) return;
      let l = (s.duration || 0) + s.pauseDuration - (i - s.createdAt);
      if (l < 0) {
        s.visible && bo.dismiss(s.id);
        return;
      }
      return setTimeout(() => bo.dismiss(s.id), l);
    });
    return () => {
      a.forEach((s) => s && clearTimeout(s));
    };
  }, [t, n]);
  let r = En(() => {
    n && Wl({ type: 6, time: Date.now() });
  }, [n]), o = En((i, a) => {
    let { reverseOrder: s = !1, gutter: l = 8, defaultPosition: u } = a || {}, c = t.filter((h) => (h.position || u) === (i.position || u) && h.height), p = c.findIndex((h) => h.id === i.id), d = c.filter((h, f) => f < p && h.visible).length;
    return c.filter((h) => h.visible).slice(...s ? [d + 1] : [0, d]).reduce((h, f) => h + (f.height || 0) + l, 0);
  }, [t]);
  return v(() => {
    t.forEach((i) => {
      if (i.dismissed) wIe(i.id, i.removeDelay);
      else {
        let a = Zc.get(i.id);
        a && (clearTimeout(a), Zc.delete(i.id));
      }
    });
  }, [t]), { toasts: t, handlers: { updateHeight: vIe, startPause: yIe, endPause: r, calculateOffset: o } };
}, xIe = ks`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`, OIe = ks`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`, EIe = ks`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`, kIe = ja("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${xIe} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${OIe} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${(e) => e.secondary || "#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${EIe} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`, LIe = ks`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, _Ie = ja("div")`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${(e) => e.secondary || "#e0e0e0"};
  border-right-color: ${(e) => e.primary || "#616161"};
  animation: ${LIe} 1s linear infinite;
`, PIe = ks`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`, SIe = ks`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`, MIe = ja("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${PIe} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${SIe} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${(e) => e.secondary || "#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`, DIe = ja("div")`
  position: absolute;
`, TIe = ja("div")`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`, jIe = ks`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`, AIe = ja("div")`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${jIe} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`, BIe = ({ toast: e }) => {
  let { icon: t, type: n, iconTheme: r } = e;
  return t !== void 0 ? typeof t == "string" ? $e.createElement(AIe, null, t) : t : n === "blank" ? null : $e.createElement(TIe, null, $e.createElement(_Ie, { ...r }), n !== "loading" && $e.createElement(DIe, null, n === "error" ? $e.createElement(kIe, { ...r }) : $e.createElement(MIe, { ...r })));
}, IIe = (e) => `
0% {transform: translate3d(0,${e * -200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`, RIe = (e) => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${e * -150}%,-1px) scale(.6); opacity:0;}
`, NIe = "0%{opacity:0;} 100%{opacity:1;}", FIe = "0%{opacity:1;} 100%{opacity:0;}", zIe = ja("div")`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`, UIe = ja("div")`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`, $Ie = (e, t) => {
  let n = e.includes("top") ? 1 : -1, [r, o] = S4() ? [NIe, FIe] : [IIe(n), RIe(n)];
  return { animation: t ? `${ks(r)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards` : `${ks(o)} 0.4s forwards cubic-bezier(.06,.71,.55,1)` };
}, HIe = $e.memo(({ toast: e, position: t, style: n, children: r }) => {
  let o = e.height ? $Ie(e.position || t || "top-center", e.visible) : { opacity: 0 }, i = $e.createElement(BIe, { toast: e }), a = $e.createElement(UIe, { ...e.ariaProps }, Sm(e.message, e));
  return $e.createElement(zIe, { className: e.className, style: { ...o, ...n, ...e.style } }, typeof r == "function" ? r({ icon: i, message: a }) : $e.createElement($e.Fragment, null, i, a));
});
cIe($e.createElement);
var WIe = ({ id: e, className: t, style: n, onHeightUpdate: r, children: o }) => {
  let i = $e.useCallback((a) => {
    if (a) {
      let s = () => {
        let l = a.getBoundingClientRect().height;
        r(e, l);
      };
      s(), new MutationObserver(s).observe(a, { subtree: !0, childList: !0, characterData: !0 });
    }
  }, [e, r]);
  return $e.createElement("div", { ref: i, className: t, style: n }, o);
}, VIe = (e, t) => {
  let n = e.includes("top"), r = n ? { top: 0 } : { bottom: 0 }, o = e.includes("center") ? { justifyContent: "center" } : e.includes("right") ? { justifyContent: "flex-end" } : {};
  return { left: 0, right: 0, display: "flex", position: "absolute", transition: S4() ? void 0 : "all 230ms cubic-bezier(.21,1.02,.73,1)", transform: `translateY(${t * (n ? 1 : -1)}px)`, ...r, ...o };
}, qIe = qy`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`, Lh = 16, ZIe = ({ reverseOrder: e, position: t = "top-center", toastOptions: n, gutter: r, children: o, containerStyle: i, containerClassName: a }) => {
  let { toasts: s, handlers: l } = CIe(n);
  return $e.createElement("div", { id: "_rht_toaster", style: { position: "fixed", zIndex: 9999, top: Lh, left: Lh, right: Lh, bottom: Lh, pointerEvents: "none", ...i }, className: a, onMouseEnter: l.startPause, onMouseLeave: l.endPause }, s.map((u) => {
    let c = u.position || t, p = l.calculateOffset(u, { reverseOrder: e, gutter: r, defaultPosition: t }), d = VIe(c, p);
    return $e.createElement(WIe, { id: u.id, key: u.id, onHeightUpdate: l.updateHeight, className: u.visible ? qIe : "", style: d }, u.type === "custom" ? Sm(u.message, u) : o ? o(u) : $e.createElement(HIe, { toast: u, position: c }));
  }));
}, KU = bo;
function ZRe({ children: e }) {
  function t(n) {
    switch (n.type) {
      case "success":
        return KU.success(n.message, {
          style: {
            background: "#10B981",
            color: "#ffffff",
            padding: "12px 16px",
            fontSize: "14px",
            fontWeight: 600
          },
          iconTheme: {
            primary: "#059669",
            secondary: "#ffffff"
          }
        });
      case "danger":
        return KU.error(n.message, {
          style: {
            background: "#E11D48",
            color: "#ffffff",
            padding: "12px 16px",
            fontSize: "14px",
            fontWeight: 600
          },
          iconTheme: {
            primary: "#BE123C",
            secondary: "#ffffff"
          }
        });
    }
  }
  return /* @__PURE__ */ X.jsxs(a4.Provider, { value: { showToast: t }, children: [
    /* @__PURE__ */ X.jsx(
      ZIe,
      {
        position: "top-right",
        containerStyle: { zIndex: 999999999999999 }
      }
    ),
    e
  ] });
}
function D4({ children: e, fallback: t = null }) {
  return vAe() ? /* @__PURE__ */ X.jsx(X.Fragment, { children: e() }) : /* @__PURE__ */ X.jsx(X.Fragment, { children: t });
}
let GIe = class {
  constructor(t, n) {
    Sd(this, "pixelId");
    Sd(this, "autoConfig");
    Sd(this, "initialized");
    this.pixelId = t, this.autoConfig = (n == null ? void 0 : n.autoConfig) || !0, this.initialized = !1;
  }
  loadFacebookPixel() {
    if (window.fbq) return;
    const t = function(...o) {
      t.callMethod ? t.callMethod.apply(t, o) : t.queue.push(o);
    };
    window._fbq || (window._fbq = t), t.push = t, t.loaded = !0, t.version = "2.0", t.queue = [];
    const n = document.createElement("script");
    n.async = !0, n.src = "https://connect.facebook.net/en_US/fbevents.js";
    const r = document.getElementsByTagName("script")[0];
    if (!r.parentNode)
      throw new Error("No script tag found in the document");
    r.parentNode.insertBefore(n, r), window.fbq = t;
  }
  init(t = {}) {
    if (this.initialized = typeof window < "u" && !!window.fbq, this.loadFacebookPixel(), !window.fbq)
      throw new Error("window.fbq is not defined");
    this.autoConfig === !1 ? window.fbq("set", "autoConfig", !1, this.pixelId) : window.fbq("init", this.pixelId, t), this.initialized = !0;
  }
  pageView() {
    this.initialized && window.fbq && window.fbq("track", "PageView");
  }
  track(t, n) {
    this.initialized && window.fbq && window.fbq("track", t, n);
  }
  trackSingle(t, n, r) {
    this.initialized && window.fbq && window.fbq("trackSingle", t, n, r);
  }
  trackCustom(t, n) {
    this.initialized && window.fbq && window.fbq("trackCustom", t, n);
  }
  trackSingleCustom(t, n, r) {
    this.initialized && window.fbq && window.fbq("trackSingle", t, n, r);
  }
  grantConsent() {
    this.initialized && window.fbq && window.fbq("consent", "grant");
  }
  revokeConsent() {
    this.initialized && window.fbq && window.fbq("consent", "revoke");
  }
};
function XIe(e) {
  const {
    pixelId: t,
    options: n,
    pageView: r,
    track: o,
    trackCustom: i,
    trackSingle: a,
    trackSingleCustom: s,
    grantConsent: l,
    revokeConsent: u
  } = e, c = new GIe(t, n);
  return c.init(), r && c.pageView(), l && c.grantConsent(), u && c.revokeConsent(), o && c.track(...o), i && c.trackCustom(...i), a && c.trackSingle(t, ...a), s && c.trackSingleCustom(t, ...s), /* @__PURE__ */ X.jsx(X.Fragment, {});
}
function XRe(e) {
  return process.env.NODE_ENV !== "production" && !e.showInDevMode ? /* @__PURE__ */ X.jsx(X.Fragment, {}) : /* @__PURE__ */ X.jsx(D4, { children: () => /* @__PURE__ */ X.jsx(XIe, { ...e }) });
}
function KRe({
  coordinates: e,
  zoom: t = 18,
  draggable: n = !1,
  className: r,
  ...o
}) {
  return e ? /* @__PURE__ */ X.jsx("div", { className: "arkynGoogleMapPinned " + r, ...o, children: /* @__PURE__ */ X.jsx(
    SAe,
    {
      zoom: t,
      center: e,
      mapContainerStyle: {
        borderRadius: "var(--rounded-cards)",
        width: "100%",
        height: "100%"
      },
      children: /* @__PURE__ */ X.jsx(m4, { draggable: n, position: e })
    }
  ) }) : /* @__PURE__ */ X.jsx("div", { className: "arkynGoogleMapPinnedEmpty " + r, ...o, children: /* @__PURE__ */ X.jsx(i7, {}) });
}
function YRe({
  onChange: e,
  onPlaceChanged: t,
  options: n,
  ...r
}) {
  const [o, i] = k(null), a = (l) => i(l), s = () => {
    var h, f, m, g;
    const u = o.getPlaces()[0], c = u == null ? void 0 : u.address_components;
    function p(E) {
      const w = c.find((M) => M.types[0] === E);
      return w ? w.long_name : "";
    }
    function d(E) {
      const w = c.find((M) => M.types[0] === E);
      return w ? w.short_name : "";
    }
    if (u) {
      const E = p("route"), w = p("street_number"), M = p("sublocality_level_1"), x = p("administrative_area_level_2"), y = p("administrative_area_level_1"), C = d("administrative_area_level_1"), P = p("postal_code"), F = (f = (h = u.geometry) == null ? void 0 : h.location) == null ? void 0 : f.lat(), L = (g = (m = u.geometry) == null ? void 0 : m.location) == null ? void 0 : g.lng();
      t && t({
        street: E,
        city: x,
        state: y,
        district: M,
        cep: P,
        streetNumber: w,
        stateShortName: C,
        coordinates: { lat: F, lng: L }
      });
    }
  };
  return /* @__PURE__ */ X.jsx(
    k4,
    {
      onLoad: a,
      onPlacesChanged: s,
      options: n,
      children: /* @__PURE__ */ X.jsx(By, { type: "text", onChange: (l) => e(l.target.value), ...r })
    }
  );
}
function T4(e) {
  const { dataLayer: t, dataLayerName: n } = e;
  return `
  window.${n} = window.${n} || [];
  window.${n}.push(${JSON.stringify(t)})`;
}
function KIe(e) {
  const { id: t, events: n, dataLayer: r, dataLayerName: o, preview: i, auth: a } = e, s = `&gtm_auth=${a}`, l = `&gtm_preview=${i}`;
  t || console.warn("GTM Id is required");
  const u = `
    <iframe src="https://www.googletagmanager.com/ns.html?id=${t}${s}${l}&gtm_cookies_win=x"
      height="0" width="0" style="display:none;visibility:hidden" id="tag-manager"></iframe>`, c = `
    (function(w,d,s,l,i){w[l]=w[l]||[];
      w[l].push({'gtm.start': new Date().getTime(),event:'gtm.js', ${JSON.stringify(
    n
  ).slice(1, -1)}});
      var f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';
      j.async=true;j.src='https://www.googletagmanager.com/gtm.js?id='+i+dl+'${s}${l}&gtm_cookies_win=x';
      f.parentNode.insertBefore(j,f);
    })(window,document,'script','${o}','${t}');`, p = T4({ dataLayer: r, dataLayerName: o });
  return {
    iframe: u,
    script: c,
    dataLayerVar: p
  };
}
let YIe = class {
  initializeDataScript(t) {
    const n = document.createElement("script");
    return n.innerHTML = t, n;
  }
  initializeGTMElements(t) {
    const n = KIe(t), r = () => {
      const a = document.createElement("noscript");
      return a.innerHTML = n.iframe, a;
    }, o = () => {
      const a = document.createElement("script");
      return a.innerHTML = n.script, a;
    }, i = this.initializeDataScript(n.dataLayerVar);
    return {
      noScript: r,
      script: o,
      dataScript: i
    };
  }
  initializeDataLayer(t) {
    const { dataLayer: n, dataLayerName: r } = t;
    if (window[r]) return window[r].push(n);
    const o = T4({ dataLayer: n, dataLayerName: r }), i = this.initializeDataScript(o);
    document.head.insertBefore(i, document.head.childNodes[0]);
  }
  initialize(t) {
    const {
      events: n,
      gtmId: r,
      dataLayer: o,
      auth: i = "",
      preview: a = "",
      dataLayerName: s = "dataLayer"
    } = t, l = this.initializeGTMElements({
      id: r,
      events: n,
      dataLayer: o || void 0,
      dataLayerName: s,
      auth: i,
      preview: a
    });
    o && document.head.appendChild(l.dataScript), document.head.insertBefore(l.script(), document.head.childNodes[0]), document.body.insertBefore(l.noScript(), document.body.childNodes[0]);
  }
};
function JIe(e) {
  return new YIe().initialize(e), /* @__PURE__ */ X.jsx(X.Fragment, {});
}
function QRe(e) {
  const {
    gtmId: t,
    auth: n = "",
    preview: r = "",
    dataLayerName: o = "dataLayer",
    events: i = {},
    dataLayer: a = {},
    showInDevMode: s = !1
  } = e;
  return process.env.NODE_ENV !== "production" && !s ? /* @__PURE__ */ X.jsx(X.Fragment, {}) : /* @__PURE__ */ X.jsx(D4, { children: () => /* @__PURE__ */ X.jsx(
    JIe,
    {
      auth: n,
      dataLayer: a,
      dataLayerName: o,
      events: i,
      gtmId: t,
      preview: r
    }
  ) });
}
export {
  sRe as AlertContainer,
  aRe as AlertContent,
  lRe as AlertDescription,
  uRe as AlertIcon,
  u7 as AlertTitle,
  CRe as AudioUpload,
  fRe as Badge,
  jRe as BreadcrumbContainer,
  ARe as BreadcrumbLink,
  Ap as Button,
  hRe as Card,
  xRe as Checkbox,
  D4 as ClientOnly,
  N$ as Divider,
  IRe as DrawerContainer,
  RRe as DrawerHeader,
  HRe as DrawerProvider,
  XRe as FacebookPixel,
  ORe as FileUpload,
  p2 as FormController,
  ERe as FormError,
  d2 as FormLabel,
  KRe as GoogleMap,
  VRe as GoogleProvider,
  YRe as GoogleSearchPlaces,
  QRe as GoogleTagManager,
  $8 as IconButton,
  sPe as ImageUpload,
  By as Input,
  eTe as ModalContainer,
  tTe as ModalFooter,
  nTe as ModalHeader,
  qRe as ModalProvider,
  kRe as MultiSelect,
  BRe as Pagination,
  LRe as PhoneInput,
  NRe as Popover,
  PRe as RadioBox,
  _Re as RadioGroup,
  SRe as RichText,
  MRe as Select,
  gRe as Skeleton,
  X_e as Slider,
  DRe as Switch,
  J2 as TabButton,
  oTe as TabContainer,
  mRe as TableBody,
  vRe as TableCaption,
  yRe as TableContainer,
  bRe as TableFooter,
  wRe as TableHeader,
  TRe as Textarea,
  FRe as Toast,
  ZRe as ToastProvider,
  H8 as Tooltip,
  cRe as getHtmlFromRichTextValue,
  pRe as getRichTextValueFromHtml,
  dRe as isHtml,
  R$ as morpheme,
  zRe as useAutomation,
  URe as useDrawer,
  c1 as useFieldErrors,
  Po as useFormController,
  vAe as useHydrated,
  $Re as useModal,
  N5 as useScopedParams,
  gAe as useToast
};
