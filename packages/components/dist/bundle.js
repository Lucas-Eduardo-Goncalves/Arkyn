var Vse = Object.defineProperty;
var Zse = (e, t, n) => t in e ? Vse(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n;
var Xg = (e, t, n) => Zse(e, typeof t != "symbol" ? t + "" : t, n);
import * as Ne from "react";
import be, { createContext as $e, useContext as ge, Children as at, forwardRef as Cr, useState as k, useEffect as h, memo as me, useRef as dt, useMemo as ln, isValidElement as yi, cloneElement as bi, Component as au, PureComponent as pe, createRef as so, useId as qse, useCallback as Jn, useLayoutEffect as Gse, useReducer as Kse, useSyncExternalStore as Xse } from "react";
import { Info as bG, AlertTriangle as Yse, XCircle as wG, CheckCircle2 as CG, Loader2 as ma, Pause as Jse, Play as Qse, RefreshCw as qP, Check as l0, FileImage as eae, FileAudio as tae, FileArchive as nae, File as rae, ChevronDown as GP, X as KP, Search as OG, Image as oae, Heading1 as iae, Heading2 as sae, Quote as aae, Bold as lae, Italic as uae, Underline as cae, Code as pae, AlignLeft as dae, AlignRight as fae, AlignCenter as hae, AlignJustify as gae, ChevronRight as QL, ChevronLeft as mae, Ellipsis as zj, MapPinned as vae } from "lucide-react";
import { useActionData as XP, useNavigation as xG, useFetchers as YP, useLocation as JP, Link as yae, useNavigate as EG } from "@remix-run/react";
import { InputMask as ol } from "@react-input/mask";
import { AnimatePresence as kG, motion as Uf } from "framer-motion";
import * as wi from "react-dom";
import il, { createPortal as zn } from "react-dom";
var fr = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function u0(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var e1 = { exports: {} }, ed = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Uj;
function bae() {
  if (Uj) return ed;
  Uj = 1;
  var e = be, t = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, o = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, i = { key: !0, ref: !0, __self: !0, __source: !0 };
  function a(s, l, u) {
    var c, p = {}, d = null, g = null;
    u !== void 0 && (d = "" + u), l.key !== void 0 && (d = "" + l.key), l.ref !== void 0 && (g = l.ref);
    for (c in l) r.call(l, c) && !i.hasOwnProperty(c) && (p[c] = l[c]);
    if (s && s.defaultProps) for (c in l = s.defaultProps, l) p[c] === void 0 && (p[c] = l[c]);
    return { $$typeof: t, type: s, key: d, ref: g, props: p, _owner: o.current };
  }
  return ed.Fragment = n, ed.jsx = a, ed.jsxs = a, ed;
}
var td = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Hj;
function wae() {
  return Hj || (Hj = 1, process.env.NODE_ENV !== "production" && function() {
    var e = be, t = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), a = Symbol.for("react.provider"), s = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), c = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), d = Symbol.for("react.lazy"), g = Symbol.for("react.offscreen"), f = Symbol.iterator, m = "@@iterator";
    function b(y) {
      if (y === null || typeof y != "object")
        return null;
      var R = f && y[f] || y[m];
      return typeof R == "function" ? R : null;
    }
    var E = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function w(y) {
      {
        for (var R = arguments.length, G = new Array(R > 1 ? R - 1 : 0), ne = 1; ne < R; ne++)
          G[ne - 1] = arguments[ne];
        M("error", y, G);
      }
    }
    function M(y, R, G) {
      {
        var ne = E.ReactDebugCurrentFrame, ae = ne.getStackAddendum();
        ae !== "" && (R += "%s", G = G.concat([ae]));
        var ue = G.map(function(se) {
          return String(se);
        });
        ue.unshift("Warning: " + R), Function.prototype.apply.call(console[y], console, ue);
      }
    }
    var x = !1, v = !1, C = !1, P = !1, F = !1, L;
    L = Symbol.for("react.module.reference");
    function B(y) {
      return !!(typeof y == "string" || typeof y == "function" || y === r || y === i || F || y === o || y === u || y === c || P || y === g || x || v || C || typeof y == "object" && y !== null && (y.$$typeof === d || y.$$typeof === p || y.$$typeof === a || y.$$typeof === s || y.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      y.$$typeof === L || y.getModuleId !== void 0));
    }
    function N(y, R, G) {
      var ne = y.displayName;
      if (ne)
        return ne;
      var ae = R.displayName || R.name || "";
      return ae !== "" ? G + "(" + ae + ")" : G;
    }
    function $(y) {
      return y.displayName || "Context";
    }
    function V(y) {
      if (y == null)
        return null;
      if (typeof y.tag == "number" && w("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof y == "function")
        return y.displayName || y.name || null;
      if (typeof y == "string")
        return y;
      switch (y) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case i:
          return "Profiler";
        case o:
          return "StrictMode";
        case u:
          return "Suspense";
        case c:
          return "SuspenseList";
      }
      if (typeof y == "object")
        switch (y.$$typeof) {
          case s:
            var R = y;
            return $(R) + ".Consumer";
          case a:
            var G = y;
            return $(G._context) + ".Provider";
          case l:
            return N(y, y.render, "ForwardRef");
          case p:
            var ne = y.displayName || null;
            return ne !== null ? ne : V(y.type) || "Memo";
          case d: {
            var ae = y, ue = ae._payload, se = ae._init;
            try {
              return V(se(ue));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var H = Object.assign, Z = 0, K, Y, Q, J, _, D, z;
    function S() {
    }
    S.__reactDisabledLog = !0;
    function W() {
      {
        if (Z === 0) {
          K = console.log, Y = console.info, Q = console.warn, J = console.error, _ = console.group, D = console.groupCollapsed, z = console.groupEnd;
          var y = {
            configurable: !0,
            enumerable: !0,
            value: S,
            writable: !0
          };
          Object.defineProperties(console, {
            info: y,
            log: y,
            warn: y,
            error: y,
            group: y,
            groupCollapsed: y,
            groupEnd: y
          });
        }
        Z++;
      }
    }
    function O() {
      {
        if (Z--, Z === 0) {
          var y = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: H({}, y, {
              value: K
            }),
            info: H({}, y, {
              value: Y
            }),
            warn: H({}, y, {
              value: Q
            }),
            error: H({}, y, {
              value: J
            }),
            group: H({}, y, {
              value: _
            }),
            groupCollapsed: H({}, y, {
              value: D
            }),
            groupEnd: H({}, y, {
              value: z
            })
          });
        }
        Z < 0 && w("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var j = E.ReactCurrentDispatcher, U;
    function T(y, R, G) {
      {
        if (U === void 0)
          try {
            throw Error();
          } catch (ae) {
            var ne = ae.stack.trim().match(/\n( *(at )?)/);
            U = ne && ne[1] || "";
          }
        return `
` + U + y;
      }
    }
    var q = !1, A;
    {
      var X = typeof WeakMap == "function" ? WeakMap : Map;
      A = new X();
    }
    function I(y, R) {
      if (!y || q)
        return "";
      {
        var G = A.get(y);
        if (G !== void 0)
          return G;
      }
      var ne;
      q = !0;
      var ae = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var ue;
      ue = j.current, j.current = null, W();
      try {
        if (R) {
          var se = function() {
            throw Error();
          };
          if (Object.defineProperty(se.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(se, []);
            } catch (je) {
              ne = je;
            }
            Reflect.construct(y, [], se);
          } else {
            try {
              se.call();
            } catch (je) {
              ne = je;
            }
            y.call(se.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (je) {
            ne = je;
          }
          y();
        }
      } catch (je) {
        if (je && ne && typeof je.stack == "string") {
          for (var ie = je.stack.split(`
`), Oe = ne.stack.split(`
`), de = ie.length - 1, fe = Oe.length - 1; de >= 1 && fe >= 0 && ie[de] !== Oe[fe]; )
            fe--;
          for (; de >= 1 && fe >= 0; de--, fe--)
            if (ie[de] !== Oe[fe]) {
              if (de !== 1 || fe !== 1)
                do
                  if (de--, fe--, fe < 0 || ie[de] !== Oe[fe]) {
                    var ze = `
` + ie[de].replace(" at new ", " at ");
                    return y.displayName && ze.includes("<anonymous>") && (ze = ze.replace("<anonymous>", y.displayName)), typeof y == "function" && A.set(y, ze), ze;
                  }
                while (de >= 1 && fe >= 0);
              break;
            }
        }
      } finally {
        q = !1, j.current = ue, O(), Error.prepareStackTrace = ae;
      }
      var Et = y ? y.displayName || y.name : "", bt = Et ? T(Et) : "";
      return typeof y == "function" && A.set(y, bt), bt;
    }
    function le(y, R, G) {
      return I(y, !1);
    }
    function he(y) {
      var R = y.prototype;
      return !!(R && R.isReactComponent);
    }
    function oe(y, R, G) {
      if (y == null)
        return "";
      if (typeof y == "function")
        return I(y, he(y));
      if (typeof y == "string")
        return T(y);
      switch (y) {
        case u:
          return T("Suspense");
        case c:
          return T("SuspenseList");
      }
      if (typeof y == "object")
        switch (y.$$typeof) {
          case l:
            return le(y.render);
          case p:
            return oe(y.type, R, G);
          case d: {
            var ne = y, ae = ne._payload, ue = ne._init;
            try {
              return oe(ue(ae), R, G);
            } catch {
            }
          }
        }
      return "";
    }
    var Ae = Object.prototype.hasOwnProperty, Ue = {}, He = E.ReactDebugCurrentFrame;
    function Re(y) {
      if (y) {
        var R = y._owner, G = oe(y.type, y._source, R ? R.type : null);
        He.setExtraStackFrame(G);
      } else
        He.setExtraStackFrame(null);
    }
    function nt(y, R, G, ne, ae) {
      {
        var ue = Function.call.bind(Ae);
        for (var se in y)
          if (ue(y, se)) {
            var ie = void 0;
            try {
              if (typeof y[se] != "function") {
                var Oe = Error((ne || "React class") + ": " + G + " type `" + se + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof y[se] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw Oe.name = "Invariant Violation", Oe;
              }
              ie = y[se](R, se, ne, G, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (de) {
              ie = de;
            }
            ie && !(ie instanceof Error) && (Re(ae), w("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", ne || "React class", G, se, typeof ie), Re(null)), ie instanceof Error && !(ie.message in Ue) && (Ue[ie.message] = !0, Re(ae), w("Failed %s type: %s", G, ie.message), Re(null));
          }
      }
    }
    var Ve = Array.isArray;
    function we(y) {
      return Ve(y);
    }
    function et(y) {
      {
        var R = typeof Symbol == "function" && Symbol.toStringTag, G = R && y[Symbol.toStringTag] || y.constructor.name || "Object";
        return G;
      }
    }
    function lt(y) {
      try {
        return ye(y), !1;
      } catch {
        return !0;
      }
    }
    function ye(y) {
      return "" + y;
    }
    function ke(y) {
      if (lt(y))
        return w("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", et(y)), ye(y);
    }
    var Qe = E.ReactCurrentOwner, Fe = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, Ie, ot;
    function Ee(y) {
      if (Ae.call(y, "ref")) {
        var R = Object.getOwnPropertyDescriptor(y, "ref").get;
        if (R && R.isReactWarning)
          return !1;
      }
      return y.ref !== void 0;
    }
    function wt(y) {
      if (Ae.call(y, "key")) {
        var R = Object.getOwnPropertyDescriptor(y, "key").get;
        if (R && R.isReactWarning)
          return !1;
      }
      return y.key !== void 0;
    }
    function it(y, R) {
      typeof y.ref == "string" && Qe.current;
    }
    function st(y, R) {
      {
        var G = function() {
          Ie || (Ie = !0, w("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", R));
        };
        G.isReactWarning = !0, Object.defineProperty(y, "key", {
          get: G,
          configurable: !0
        });
      }
    }
    function ut(y, R) {
      {
        var G = function() {
          ot || (ot = !0, w("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", R));
        };
        G.isReactWarning = !0, Object.defineProperty(y, "ref", {
          get: G,
          configurable: !0
        });
      }
    }
    var Ct = function(y, R, G, ne, ae, ue, se) {
      var ie = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: y,
        key: R,
        ref: G,
        props: se,
        // Record the component responsible for creating this element.
        _owner: ue
      };
      return ie._store = {}, Object.defineProperty(ie._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(ie, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ne
      }), Object.defineProperty(ie, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ae
      }), Object.freeze && (Object.freeze(ie.props), Object.freeze(ie)), ie;
    };
    function ct(y, R, G, ne, ae) {
      {
        var ue, se = {}, ie = null, Oe = null;
        G !== void 0 && (ke(G), ie = "" + G), wt(R) && (ke(R.key), ie = "" + R.key), Ee(R) && (Oe = R.ref, it(R, ae));
        for (ue in R)
          Ae.call(R, ue) && !Fe.hasOwnProperty(ue) && (se[ue] = R[ue]);
        if (y && y.defaultProps) {
          var de = y.defaultProps;
          for (ue in de)
            se[ue] === void 0 && (se[ue] = de[ue]);
        }
        if (ie || Oe) {
          var fe = typeof y == "function" ? y.displayName || y.name || "Unknown" : y;
          ie && st(se, fe), Oe && ut(se, fe);
        }
        return Ct(y, ie, Oe, ae, ne, Qe.current, se);
      }
    }
    var pt = E.ReactCurrentOwner, rt = E.ReactDebugCurrentFrame;
    function We(y) {
      if (y) {
        var R = y._owner, G = oe(y.type, y._source, R ? R.type : null);
        rt.setExtraStackFrame(G);
      } else
        rt.setExtraStackFrame(null);
    }
    var Ot;
    Ot = !1;
    function xt(y) {
      return typeof y == "object" && y !== null && y.$$typeof === t;
    }
    function gt() {
      {
        if (pt.current) {
          var y = V(pt.current.type);
          if (y)
            return `

Check the render method of \`` + y + "`.";
        }
        return "";
      }
    }
    function Ht(y) {
      return "";
    }
    var mt = {};
    function Wt(y) {
      {
        var R = gt();
        if (!R) {
          var G = typeof y == "string" ? y : y.displayName || y.name;
          G && (R = `

Check the top-level render call using <` + G + ">.");
        }
        return R;
      }
    }
    function vt(y, R) {
      {
        if (!y._store || y._store.validated || y.key != null)
          return;
        y._store.validated = !0;
        var G = Wt(R);
        if (mt[G])
          return;
        mt[G] = !0;
        var ne = "";
        y && y._owner && y._owner !== pt.current && (ne = " It was passed a child from " + V(y._owner.type) + "."), We(y), w('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', G, ne), We(null);
      }
    }
    function kt(y, R) {
      {
        if (typeof y != "object")
          return;
        if (we(y))
          for (var G = 0; G < y.length; G++) {
            var ne = y[G];
            xt(ne) && vt(ne, R);
          }
        else if (xt(y))
          y._store && (y._store.validated = !0);
        else if (y) {
          var ae = b(y);
          if (typeof ae == "function" && ae !== y.entries)
            for (var ue = ae.call(y), se; !(se = ue.next()).done; )
              xt(se.value) && vt(se.value, R);
        }
      }
    }
    function Un(y) {
      {
        var R = y.type;
        if (R == null || typeof R == "string")
          return;
        var G;
        if (typeof R == "function")
          G = R.propTypes;
        else if (typeof R == "object" && (R.$$typeof === l || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        R.$$typeof === p))
          G = R.propTypes;
        else
          return;
        if (G) {
          var ne = V(R);
          nt(G, y.props, "prop", ne, y);
        } else if (R.PropTypes !== void 0 && !Ot) {
          Ot = !0;
          var ae = V(R);
          w("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", ae || "Unknown");
        }
        typeof R.getDefaultProps == "function" && !R.getDefaultProps.isReactClassApproved && w("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function yt(y) {
      {
        for (var R = Object.keys(y.props), G = 0; G < R.length; G++) {
          var ne = R[G];
          if (ne !== "children" && ne !== "key") {
            We(y), w("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", ne), We(null);
            break;
          }
        }
        y.ref !== null && (We(y), w("Invalid attribute `ref` supplied to `React.Fragment`."), We(null));
      }
    }
    var re = {};
    function ao(y, R, G, ne, ae, ue) {
      {
        var se = B(y);
        if (!se) {
          var ie = "";
          (y === void 0 || typeof y == "object" && y !== null && Object.keys(y).length === 0) && (ie += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var Oe = Ht();
          Oe ? ie += Oe : ie += gt();
          var de;
          y === null ? de = "null" : we(y) ? de = "array" : y !== void 0 && y.$$typeof === t ? (de = "<" + (V(y.type) || "Unknown") + " />", ie = " Did you accidentally export a JSX literal instead of a component?") : de = typeof y, w("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", de, ie);
        }
        var fe = ct(y, R, G, ae, ue);
        if (fe == null)
          return fe;
        if (se) {
          var ze = R.children;
          if (ze !== void 0)
            if (ne)
              if (we(ze)) {
                for (var Et = 0; Et < ze.length; Et++)
                  kt(ze[Et], y);
                Object.freeze && Object.freeze(ze);
              } else
                w("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              kt(ze, y);
        }
        if (Ae.call(R, "key")) {
          var bt = V(y), je = Object.keys(R).filter(function(Li) {
            return Li !== "key";
          }), Hn = je.length > 0 ? "{key: someKey, " + je.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!re[bt + Hn]) {
            var ki = je.length > 0 ? "{" + je.join(": ..., ") + ": ...}" : "{}";
            w(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, Hn, bt, ki, bt), re[bt + Hn] = !0;
          }
        }
        return y === r ? yt(fe) : Un(fe), fe;
      }
    }
    function Ci(y, R, G) {
      return ao(y, R, G, !0);
    }
    function Oi(y, R, G) {
      return ao(y, R, G, !1);
    }
    var xi = Oi, Ei = Ci;
    td.Fragment = r, td.jsx = xi, td.jsxs = Ei;
  }()), td;
}
process.env.NODE_ENV === "production" ? e1.exports = bae() : e1.exports = wae();
var ee = e1.exports;
function Cae(e) {
  const { className: t, ...n } = e, r = `arkynAlertTitle ${t}`;
  return /* @__PURE__ */ ee.jsx("div", { className: r.trim(), ...n });
}
const LG = $e({});
function Oae() {
  return ge(LG);
}
function yit(e) {
  const { schema: t, children: n, className: r, ...o } = e, s = !((u) => {
    let c = !1;
    const p = (d) => {
      Array.isArray(d) ? d.forEach(p) : d && typeof d == "object" && "type" in d && (d.type === Cae ? c = !0 : d.props && d.props.children && p(d.props.children));
    };
    return p(u), c;
  })(n) ? "nonExistsAlertTitle" : "existsAlertTitle", l = `arkynAlertContainer ${t} ${s} ${r}`;
  return /* @__PURE__ */ ee.jsx(LG.Provider, { value: e, children: /* @__PURE__ */ ee.jsx("div", { className: l.trim(), ...o, children: n }) });
}
function bit(e) {
  const { className: t, ...n } = e, r = `arkynAlertContent ${t}`;
  return /* @__PURE__ */ ee.jsx("div", { className: r.trim(), ...n });
}
function wit(e) {
  const { className: t, ...n } = e, r = `arkynAlertDescription ${t}`;
  return /* @__PURE__ */ ee.jsx("div", { className: r.trim(), ...n });
}
function Cit(e) {
  const { className: t, ...n } = e, { schema: r } = Oae(), o = `arkynAlertIcon ${r} ${t}`;
  switch (r) {
    case "success":
      return /* @__PURE__ */ ee.jsx(CG, { className: o, ...n });
    case "danger":
      return /* @__PURE__ */ ee.jsx(wG, { className: o, ...n });
    case "warning":
      return /* @__PURE__ */ ee.jsx(Yse, { className: o, ...n });
    case "info":
      return /* @__PURE__ */ ee.jsx(bG, { className: o, ...n });
  }
}
function Fy(e, t) {
  return t ? /* @__PURE__ */ ee.jsx(t, { size: e, strokeWidth: 2.5 }) : /* @__PURE__ */ ee.jsx(ee.Fragment, {});
}
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function Wj(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function Xo(e) {
  var t, n;
  return Wj(e) === !1 ? !1 : (t = e.constructor, t === void 0 ? !0 : (n = t.prototype, !(Wj(n) === !1 || n.hasOwnProperty("isPrototypeOf") === !1)));
}
var _G = Symbol.for("immer-nothing"), $j = Symbol.for("immer-draftable"), ys = Symbol.for("immer-state"), xae = process.env.NODE_ENV !== "production" ? [
  // All error codes, starting by 0:
  function(e) {
    return `The plugin for '${e}' has not been loaded into Immer. To enable the plugin, import and call \`enable${e}()\` when initializing your application.`;
  },
  function(e) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${e}'`;
  },
  "This object has been frozen and should not be mutated",
  function(e) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + e;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(e) {
    return `'current' expects a draft, got: ${e}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(e) {
    return `'original' expects a draft, got: ${e}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function Ui(e, ...t) {
  if (process.env.NODE_ENV !== "production") {
    const n = xae[e], r = typeof n == "function" ? n.apply(null, t) : n;
    throw new Error(`[Immer] ${r}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var wp = Object.getPrototypeOf;
function _c(e) {
  return !!e && !!e[ys];
}
function Pc(e) {
  var t;
  return e ? PG(e) || Array.isArray(e) || !!e[$j] || !!((t = e.constructor) != null && t[$j]) || p0(e) || d0(e) : !1;
}
var Eae = Object.prototype.constructor.toString();
function PG(e) {
  if (!e || typeof e != "object")
    return !1;
  const t = wp(e);
  if (t === null)
    return !0;
  const n = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
  return n === Object ? !0 : typeof n == "function" && Function.toString.call(n) === Eae;
}
function zy(e, t) {
  c0(e) === 0 ? Reflect.ownKeys(e).forEach((n) => {
    t(n, e[n], e);
  }) : e.forEach((n, r) => t(r, n, e));
}
function c0(e) {
  const t = e[ys];
  return t ? t.type_ : Array.isArray(e) ? 1 : p0(e) ? 2 : d0(e) ? 3 : 0;
}
function t1(e, t) {
  return c0(e) === 2 ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t);
}
function SG(e, t, n) {
  const r = c0(e);
  r === 2 ? e.set(t, n) : r === 3 ? e.add(n) : e[t] = n;
}
function kae(e, t) {
  return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && t !== t;
}
function p0(e) {
  return e instanceof Map;
}
function d0(e) {
  return e instanceof Set;
}
function Xu(e) {
  return e.copy_ || e.base_;
}
function n1(e, t) {
  if (p0(e))
    return new Map(e);
  if (d0(e))
    return new Set(e);
  if (Array.isArray(e))
    return Array.prototype.slice.call(e);
  const n = PG(e);
  if (t === !0 || t === "class_only" && !n) {
    const r = Object.getOwnPropertyDescriptors(e);
    delete r[ys];
    let o = Reflect.ownKeys(r);
    for (let i = 0; i < o.length; i++) {
      const a = o[i], s = r[a];
      s.writable === !1 && (s.writable = !0, s.configurable = !0), (s.get || s.set) && (r[a] = {
        configurable: !0,
        writable: !0,
        // could live with !!desc.set as well here...
        enumerable: s.enumerable,
        value: e[a]
      });
    }
    return Object.create(wp(e), r);
  } else {
    const r = wp(e);
    if (r !== null && n)
      return { ...e };
    const o = Object.create(r);
    return Object.assign(o, e);
  }
}
function QP(e, t = !1) {
  return f0(e) || _c(e) || !Pc(e) || (c0(e) > 1 && (e.set = e.add = e.clear = e.delete = Lae), Object.freeze(e), t && Object.entries(e).forEach(([n, r]) => QP(r, !0))), e;
}
function Lae() {
  Ui(2);
}
function f0(e) {
  return Object.isFrozen(e);
}
var _ae = {};
function Sc(e) {
  const t = _ae[e];
  return t || Ui(0, e), t;
}
var Hf;
function MG() {
  return Hf;
}
function Pae(e, t) {
  return {
    drafts_: [],
    parent_: e,
    immer_: t,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0
  };
}
function Vj(e, t) {
  t && (Sc("Patches"), e.patches_ = [], e.inversePatches_ = [], e.patchListener_ = t);
}
function r1(e) {
  o1(e), e.drafts_.forEach(Sae), e.drafts_ = null;
}
function o1(e) {
  e === Hf && (Hf = e.parent_);
}
function Zj(e) {
  return Hf = Pae(Hf, e);
}
function Sae(e) {
  const t = e[ys];
  t.type_ === 0 || t.type_ === 1 ? t.revoke_() : t.revoked_ = !0;
}
function qj(e, t) {
  t.unfinalizedDrafts_ = t.drafts_.length;
  const n = t.drafts_[0];
  return e !== void 0 && e !== n ? (n[ys].modified_ && (r1(t), Ui(4)), Pc(e) && (e = Uy(t, e), t.parent_ || Hy(t, e)), t.patches_ && Sc("Patches").generateReplacementPatches_(
    n[ys].base_,
    e,
    t.patches_,
    t.inversePatches_
  )) : e = Uy(t, n, []), r1(t), t.patches_ && t.patchListener_(t.patches_, t.inversePatches_), e !== _G ? e : void 0;
}
function Uy(e, t, n) {
  if (f0(t))
    return t;
  const r = t[ys];
  if (!r)
    return zy(
      t,
      (o, i) => Gj(e, r, t, o, i, n)
    ), t;
  if (r.scope_ !== e)
    return t;
  if (!r.modified_)
    return Hy(e, r.base_, !0), r.base_;
  if (!r.finalized_) {
    r.finalized_ = !0, r.scope_.unfinalizedDrafts_--;
    const o = r.copy_;
    let i = o, a = !1;
    r.type_ === 3 && (i = new Set(o), o.clear(), a = !0), zy(
      i,
      (s, l) => Gj(e, r, o, s, l, n, a)
    ), Hy(e, o, !1), n && e.patches_ && Sc("Patches").generatePatches_(
      r,
      n,
      e.patches_,
      e.inversePatches_
    );
  }
  return r.copy_;
}
function Gj(e, t, n, r, o, i, a) {
  if (process.env.NODE_ENV !== "production" && o === n && Ui(5), _c(o)) {
    const s = i && t && t.type_ !== 3 && // Set objects are atomic since they have no keys.
    !t1(t.assigned_, r) ? i.concat(r) : void 0, l = Uy(e, o, s);
    if (SG(n, r, l), _c(l))
      e.canAutoFreeze_ = !1;
    else
      return;
  } else a && n.add(o);
  if (Pc(o) && !f0(o)) {
    if (!e.immer_.autoFreeze_ && e.unfinalizedDrafts_ < 1)
      return;
    Uy(e, o), (!t || !t.scope_.parent_) && typeof r != "symbol" && Object.prototype.propertyIsEnumerable.call(n, r) && Hy(e, o);
  }
}
function Hy(e, t, n = !1) {
  !e.parent_ && e.immer_.autoFreeze_ && e.canAutoFreeze_ && QP(t, n);
}
function Mae(e, t) {
  const n = Array.isArray(e), r = {
    type_: n ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: t ? t.scope_ : MG(),
    // True for both shallow and deep changes.
    modified_: !1,
    // Used during finalization.
    finalized_: !1,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: t,
    // The base state.
    base_: e,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: !1
  };
  let o = r, i = eS;
  n && (o = [r], i = Wf);
  const { revoke: a, proxy: s } = Proxy.revocable(o, i);
  return r.draft_ = s, r.revoke_ = a, s;
}
var eS = {
  get(e, t) {
    if (t === ys)
      return e;
    const n = Xu(e);
    if (!t1(n, t))
      return Dae(e, n, t);
    const r = n[t];
    return e.finalized_ || !Pc(r) ? r : r === px(e.base_, t) ? (dx(e), e.copy_[t] = s1(r, e)) : r;
  },
  has(e, t) {
    return t in Xu(e);
  },
  ownKeys(e) {
    return Reflect.ownKeys(Xu(e));
  },
  set(e, t, n) {
    const r = DG(Xu(e), t);
    if (r != null && r.set)
      return r.set.call(e.draft_, n), !0;
    if (!e.modified_) {
      const o = px(Xu(e), t), i = o == null ? void 0 : o[ys];
      if (i && i.base_ === n)
        return e.copy_[t] = n, e.assigned_[t] = !1, !0;
      if (kae(n, o) && (n !== void 0 || t1(e.base_, t)))
        return !0;
      dx(e), i1(e);
    }
    return e.copy_[t] === n && // special case: handle new props with value 'undefined'
    (n !== void 0 || t in e.copy_) || // special case: NaN
    Number.isNaN(n) && Number.isNaN(e.copy_[t]) || (e.copy_[t] = n, e.assigned_[t] = !0), !0;
  },
  deleteProperty(e, t) {
    return px(e.base_, t) !== void 0 || t in e.base_ ? (e.assigned_[t] = !1, dx(e), i1(e)) : delete e.assigned_[t], e.copy_ && delete e.copy_[t], !0;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(e, t) {
    const n = Xu(e), r = Reflect.getOwnPropertyDescriptor(n, t);
    return r && {
      writable: !0,
      configurable: e.type_ !== 1 || t !== "length",
      enumerable: r.enumerable,
      value: n[t]
    };
  },
  defineProperty() {
    Ui(11);
  },
  getPrototypeOf(e) {
    return wp(e.base_);
  },
  setPrototypeOf() {
    Ui(12);
  }
}, Wf = {};
zy(eS, (e, t) => {
  Wf[e] = function() {
    return arguments[0] = arguments[0][0], t.apply(this, arguments);
  };
});
Wf.deleteProperty = function(e, t) {
  return process.env.NODE_ENV !== "production" && isNaN(parseInt(t)) && Ui(13), Wf.set.call(this, e, t, void 0);
};
Wf.set = function(e, t, n) {
  return process.env.NODE_ENV !== "production" && t !== "length" && isNaN(parseInt(t)) && Ui(14), eS.set.call(this, e[0], t, n, e[0]);
};
function px(e, t) {
  const n = e[ys];
  return (n ? Xu(n) : e)[t];
}
function Dae(e, t, n) {
  var o;
  const r = DG(t, n);
  return r ? "value" in r ? r.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (o = r.get) == null ? void 0 : o.call(e.draft_)
  ) : void 0;
}
function DG(e, t) {
  if (!(t in e))
    return;
  let n = wp(e);
  for (; n; ) {
    const r = Object.getOwnPropertyDescriptor(n, t);
    if (r)
      return r;
    n = wp(n);
  }
}
function i1(e) {
  e.modified_ || (e.modified_ = !0, e.parent_ && i1(e.parent_));
}
function dx(e) {
  e.copy_ || (e.copy_ = n1(
    e.base_,
    e.scope_.immer_.useStrictShallowCopy_
  ));
}
var Tae = class {
  constructor(e) {
    this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.produce = (t, n, r) => {
      if (typeof t == "function" && typeof n != "function") {
        const i = n;
        n = t;
        const a = this;
        return function(l = i, ...u) {
          return a.produce(l, (c) => n.call(this, c, ...u));
        };
      }
      typeof n != "function" && Ui(6), r !== void 0 && typeof r != "function" && Ui(7);
      let o;
      if (Pc(t)) {
        const i = Zj(this), a = s1(t, void 0);
        let s = !0;
        try {
          o = n(a), s = !1;
        } finally {
          s ? r1(i) : o1(i);
        }
        return Vj(i, r), qj(o, i);
      } else if (!t || typeof t != "object") {
        if (o = n(t), o === void 0 && (o = t), o === _G && (o = void 0), this.autoFreeze_ && QP(o, !0), r) {
          const i = [], a = [];
          Sc("Patches").generateReplacementPatches_(t, o, i, a), r(i, a);
        }
        return o;
      } else
        Ui(1, t);
    }, this.produceWithPatches = (t, n) => {
      if (typeof t == "function")
        return (a, ...s) => this.produceWithPatches(a, (l) => t(l, ...s));
      let r, o;
      return [this.produce(t, n, (a, s) => {
        r = a, o = s;
      }), r, o];
    }, typeof (e == null ? void 0 : e.autoFreeze) == "boolean" && this.setAutoFreeze(e.autoFreeze), typeof (e == null ? void 0 : e.useStrictShallowCopy) == "boolean" && this.setUseStrictShallowCopy(e.useStrictShallowCopy);
  }
  createDraft(e) {
    Pc(e) || Ui(8), _c(e) && (e = jae(e));
    const t = Zj(this), n = s1(e, void 0);
    return n[ys].isManual_ = !0, o1(t), n;
  }
  finishDraft(e, t) {
    const n = e && e[ys];
    (!n || !n.isManual_) && Ui(9);
    const { scope_: r } = n;
    return Vj(r, t), qj(void 0, r);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(e) {
    this.autoFreeze_ = e;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(e) {
    this.useStrictShallowCopy_ = e;
  }
  applyPatches(e, t) {
    let n;
    for (n = t.length - 1; n >= 0; n--) {
      const o = t[n];
      if (o.path.length === 0 && o.op === "replace") {
        e = o.value;
        break;
      }
    }
    n > -1 && (t = t.slice(n + 1));
    const r = Sc("Patches").applyPatches_;
    return _c(e) ? r(e, t) : this.produce(
      e,
      (o) => r(o, t)
    );
  }
};
function s1(e, t) {
  const n = p0(e) ? Sc("MapSet").proxyMap_(e, t) : d0(e) ? Sc("MapSet").proxySet_(e, t) : Mae(e, t);
  return (t ? t.scope_ : MG()).drafts_.push(n), n;
}
function jae(e) {
  return _c(e) || Ui(10, e), TG(e);
}
function TG(e) {
  if (!Pc(e) || f0(e))
    return e;
  const t = e[ys];
  let n;
  if (t) {
    if (!t.modified_)
      return t.base_;
    t.finalized_ = !0, n = n1(e, t.scope_.immer_.useStrictShallowCopy_);
  } else
    n = n1(e, !0);
  return zy(n, (r, o) => {
    SG(n, r, TG(o));
  }), t && (t.finalized_ = !1), n;
}
var bs = new Tae(), tS = bs.produce;
bs.produceWithPatches.bind(
  bs
);
bs.setAutoFreeze.bind(bs);
bs.setUseStrictShallowCopy.bind(bs);
bs.applyPatches.bind(bs);
var Kj = bs.createDraft.bind(bs), Xj = bs.finishDraft.bind(bs), Aae = {
  transform(e, t) {
    var {
      current: n,
      affinity: r
    } = e;
    if (n != null) {
      var o = ce.transform(n, t, {
        affinity: r
      });
      e.current = o, o == null && e.unref();
    }
  }
}, Rae = {
  transform(e, t) {
    var {
      current: n,
      affinity: r
    } = e;
    if (n != null) {
      var o = $t.transform(n, t, {
        affinity: r
      });
      e.current = o, o == null && e.unref();
    }
  }
}, Iae = {
  transform(e, t) {
    var {
      current: n,
      affinity: r
    } = e;
    if (n != null) {
      var o = ve.transform(n, t, {
        affinity: r
      });
      e.current = o, o == null && e.unref();
    }
  }
}, Wy = /* @__PURE__ */ new WeakMap(), $y = /* @__PURE__ */ new WeakMap(), of = /* @__PURE__ */ new WeakMap(), jG = /* @__PURE__ */ new WeakMap(), Yj = /* @__PURE__ */ new WeakMap(), Jj = /* @__PURE__ */ new WeakMap(), Qj = /* @__PURE__ */ new WeakMap(), ce = {
  ancestors(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = ce.levels(e, t);
    return n ? r = r.slice(1) : r = r.slice(0, -1), r;
  },
  common(e, t) {
    for (var n = [], r = 0; r < e.length && r < t.length; r++) {
      var o = e[r], i = t[r];
      if (o !== i)
        break;
      n.push(o);
    }
    return n;
  },
  compare(e, t) {
    for (var n = Math.min(e.length, t.length), r = 0; r < n; r++) {
      if (e[r] < t[r]) return -1;
      if (e[r] > t[r]) return 1;
    }
    return 0;
  },
  endsAfter(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return ce.equals(r, o) && i > a;
  },
  endsAt(e, t) {
    var n = e.length, r = e.slice(0, n), o = t.slice(0, n);
    return ce.equals(r, o);
  },
  endsBefore(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return ce.equals(r, o) && i < a;
  },
  equals(e, t) {
    return e.length === t.length && e.every((n, r) => n === t[r]);
  },
  hasPrevious(e) {
    return e[e.length - 1] > 0;
  },
  isAfter(e, t) {
    return ce.compare(e, t) === 1;
  },
  isAncestor(e, t) {
    return e.length < t.length && ce.compare(e, t) === 0;
  },
  isBefore(e, t) {
    return ce.compare(e, t) === -1;
  },
  isChild(e, t) {
    return e.length === t.length + 1 && ce.compare(e, t) === 0;
  },
  isCommon(e, t) {
    return e.length <= t.length && ce.compare(e, t) === 0;
  },
  isDescendant(e, t) {
    return e.length > t.length && ce.compare(e, t) === 0;
  },
  isParent(e, t) {
    return e.length + 1 === t.length && ce.compare(e, t) === 0;
  },
  isPath(e) {
    return Array.isArray(e) && (e.length === 0 || typeof e[0] == "number");
  },
  isSibling(e, t) {
    if (e.length !== t.length)
      return !1;
    var n = e.slice(0, -1), r = t.slice(0, -1), o = e[e.length - 1], i = t[t.length - 1];
    return o !== i && ce.equals(n, r);
  },
  levels(e) {
    for (var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = [], o = 0; o <= e.length; o++)
      r.push(e.slice(0, o));
    return n && r.reverse(), r;
  },
  next(e) {
    if (e.length === 0)
      throw new Error("Cannot get the next path of a root path [".concat(e, "], because it has no next index."));
    var t = e[e.length - 1];
    return e.slice(0, -1).concat(t + 1);
  },
  operationCanTransformPath(e) {
    switch (e.type) {
      case "insert_node":
      case "remove_node":
      case "merge_node":
      case "split_node":
      case "move_node":
        return !0;
      default:
        return !1;
    }
  },
  parent(e) {
    if (e.length === 0)
      throw new Error("Cannot get the parent path of the root path [".concat(e, "]."));
    return e.slice(0, -1);
  },
  previous(e) {
    if (e.length === 0)
      throw new Error("Cannot get the previous path of a root path [".concat(e, "], because it has no previous index."));
    var t = e[e.length - 1];
    if (t <= 0)
      throw new Error("Cannot get the previous path of a first child path [".concat(e, "] because it would result in a negative index."));
    return e.slice(0, -1).concat(t - 1);
  },
  relative(e, t) {
    if (!ce.isAncestor(t, e) && !ce.equals(e, t))
      throw new Error("Cannot get the relative path of [".concat(e, "] inside ancestor [").concat(t, "], because it is not above or equal to the path."));
    return e.slice(t.length);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!e) return null;
    var r = [...e], {
      affinity: o = "forward"
    } = n;
    if (e.length === 0)
      return r;
    switch (t.type) {
      case "insert_node": {
        var {
          path: i
        } = t;
        (ce.equals(i, r) || ce.endsBefore(i, r) || ce.isAncestor(i, r)) && (r[i.length - 1] += 1);
        break;
      }
      case "remove_node": {
        var {
          path: a
        } = t;
        if (ce.equals(a, r) || ce.isAncestor(a, r))
          return null;
        ce.endsBefore(a, r) && (r[a.length - 1] -= 1);
        break;
      }
      case "merge_node": {
        var {
          path: s,
          position: l
        } = t;
        ce.equals(s, r) || ce.endsBefore(s, r) ? r[s.length - 1] -= 1 : ce.isAncestor(s, r) && (r[s.length - 1] -= 1, r[s.length] += l);
        break;
      }
      case "split_node": {
        var {
          path: u,
          position: c
        } = t;
        if (ce.equals(u, r)) {
          if (o === "forward")
            r[r.length - 1] += 1;
          else if (o !== "backward") return null;
        } else ce.endsBefore(u, r) ? r[u.length - 1] += 1 : ce.isAncestor(u, r) && e[u.length] >= c && (r[u.length - 1] += 1, r[u.length] -= c);
        break;
      }
      case "move_node": {
        var {
          path: p,
          newPath: d
        } = t;
        if (ce.equals(p, d))
          return r;
        if (ce.isAncestor(p, r) || ce.equals(p, r)) {
          var g = d.slice();
          return ce.endsBefore(p, d) && p.length < d.length && (g[p.length - 1] -= 1), g.concat(r.slice(p.length));
        } else ce.isSibling(p, d) && (ce.isAncestor(d, r) || ce.equals(d, r)) ? ce.endsBefore(p, r) ? r[p.length - 1] -= 1 : r[p.length - 1] += 1 : ce.endsBefore(d, r) || ce.equals(d, r) || ce.isAncestor(d, r) ? (ce.endsBefore(p, r) && (r[p.length - 1] -= 1), r[d.length - 1] += 1) : ce.endsBefore(p, r) && (ce.equals(d, r) && (r[d.length - 1] += 1), r[p.length - 1] -= 1);
        break;
      }
    }
    return r;
  }
};
function $f(e) {
  "@babel/helpers - typeof";
  return $f = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, $f(e);
}
function Nae(e, t) {
  if ($f(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if ($f(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function Bae(e) {
  var t = Nae(e, "string");
  return $f(t) === "symbol" ? t : String(t);
}
function Mi(e, t, n) {
  return t = Bae(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function eA(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function nd(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? eA(Object(n), !0).forEach(function(r) {
      Mi(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : eA(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Fae = (e, t, n) => {
  switch (n.type) {
    case "insert_node": {
      var {
        path: r,
        node: o
      } = n, i = tt.parent(e, r), a = r[r.length - 1];
      if (a > i.children.length)
        throw new Error('Cannot apply an "insert_node" operation at path ['.concat(r, "] because the destination is past the end of the node."));
      if (i.children.splice(a, 0, o), t)
        for (var [s, l] of ve.points(t))
          t[l] = $t.transform(s, n);
      break;
    }
    case "insert_text": {
      var {
        path: u,
        offset: c,
        text: p
      } = n;
      if (p.length === 0) break;
      var d = tt.leaf(e, u), g = d.text.slice(0, c), f = d.text.slice(c);
      if (d.text = g + p + f, t)
        for (var [m, b] of ve.points(t))
          t[b] = $t.transform(m, n);
      break;
    }
    case "merge_node": {
      var {
        path: E
      } = n, w = tt.get(e, E), M = ce.previous(E), x = tt.get(e, M), v = tt.parent(e, E), C = E[E.length - 1];
      if (ht.isText(w) && ht.isText(x))
        x.text += w.text;
      else if (!ht.isText(w) && !ht.isText(x))
        x.children.push(...w.children);
      else
        throw new Error('Cannot apply a "merge_node" operation at path ['.concat(E, "] to nodes of different interfaces: ").concat(Ko.stringify(w), " ").concat(Ko.stringify(x)));
      if (v.children.splice(C, 1), t)
        for (var [P, F] of ve.points(t))
          t[F] = $t.transform(P, n);
      break;
    }
    case "move_node": {
      var {
        path: L,
        newPath: B
      } = n;
      if (ce.isAncestor(L, B))
        throw new Error("Cannot move a path [".concat(L, "] to new path [").concat(B, "] because the destination is inside itself."));
      var N = tt.get(e, L), $ = tt.parent(e, L), V = L[L.length - 1];
      $.children.splice(V, 1);
      var H = ce.transform(L, n), Z = tt.get(e, ce.parent(H)), K = H[H.length - 1];
      if (Z.children.splice(K, 0, N), t)
        for (var [Y, Q] of ve.points(t))
          t[Q] = $t.transform(Y, n);
      break;
    }
    case "remove_node": {
      var {
        path: J
      } = n, _ = J[J.length - 1], D = tt.parent(e, J);
      if (D.children.splice(_, 1), t)
        for (var [z, S] of ve.points(t)) {
          var W = $t.transform(z, n);
          if (t != null && W != null)
            t[S] = W;
          else {
            var O = void 0, j = void 0;
            for (var [U, T] of tt.texts(e))
              if (ce.compare(T, J) === -1)
                O = [U, T];
              else {
                j = [U, T];
                break;
              }
            var q = !1;
            O && j && (ce.equals(j[1], J) ? q = !ce.hasPrevious(j[1]) : q = ce.common(O[1], J).length < ce.common(j[1], J).length), O && !q ? (z.path = O[1], z.offset = O[0].text.length) : j ? (z.path = j[1], z.offset = 0) : t = null;
          }
        }
      break;
    }
    case "remove_text": {
      var {
        path: A,
        offset: X,
        text: I
      } = n;
      if (I.length === 0) break;
      var le = tt.leaf(e, A), he = le.text.slice(0, X), oe = le.text.slice(X + I.length);
      if (le.text = he + oe, t)
        for (var [Ae, Ue] of ve.points(t))
          t[Ue] = $t.transform(Ae, n);
      break;
    }
    case "set_node": {
      var {
        path: He,
        properties: Re,
        newProperties: nt
      } = n;
      if (He.length === 0)
        throw new Error("Cannot set properties on the root node!");
      var Ve = tt.get(e, He);
      for (var we in nt) {
        if (we === "children" || we === "text")
          throw new Error('Cannot set the "'.concat(we, '" property of nodes!'));
        var et = nt[we];
        et == null ? delete Ve[we] : Ve[we] = et;
      }
      for (var lt in Re)
        nt.hasOwnProperty(lt) || delete Ve[lt];
      break;
    }
    case "set_selection": {
      var {
        newProperties: ye
      } = n;
      if (ye == null)
        t = ye;
      else {
        if (t == null) {
          if (!ve.isRange(ye))
            throw new Error('Cannot apply an incomplete "set_selection" operation properties '.concat(Ko.stringify(ye), " when there is no current selection."));
          t = nd({}, ye);
        }
        for (var ke in ye) {
          var Qe = ye[ke];
          if (Qe == null) {
            if (ke === "anchor" || ke === "focus")
              throw new Error('Cannot remove the "'.concat(ke, '" selection property'));
            delete t[ke];
          } else
            t[ke] = Qe;
        }
      }
      break;
    }
    case "split_node": {
      var {
        path: Fe,
        position: Ie,
        properties: ot
      } = n;
      if (Fe.length === 0)
        throw new Error('Cannot apply a "split_node" operation at path ['.concat(Fe, "] because the root node cannot be split."));
      var Ee = tt.get(e, Fe), wt = tt.parent(e, Fe), it = Fe[Fe.length - 1], st;
      if (ht.isText(Ee)) {
        var ut = Ee.text.slice(0, Ie), Ct = Ee.text.slice(Ie);
        Ee.text = ut, st = nd(nd({}, ot), {}, {
          text: Ct
        });
      } else {
        var ct = Ee.children.slice(0, Ie), pt = Ee.children.slice(Ie);
        Ee.children = ct, st = nd(nd({}, ot), {}, {
          children: pt
        });
      }
      if (wt.children.splice(it + 1, 0, st), t)
        for (var [rt, We] of ve.points(t))
          t[We] = $t.transform(rt, n);
      break;
    }
  }
  return t;
}, zae = {
  transform(e, t) {
    e.children = Kj(e.children);
    var n = e.selection && Kj(e.selection);
    try {
      n = Fae(e, n, t);
    } finally {
      e.children = Xj(e.children), n ? e.selection = _c(n) ? Xj(n) : n : e.selection = null;
    }
  }
}, Uae = {
  insertNodes(e, t, n) {
    e.insertNodes(t, n);
  },
  liftNodes(e, t) {
    e.liftNodes(t);
  },
  mergeNodes(e, t) {
    e.mergeNodes(t);
  },
  moveNodes(e, t) {
    e.moveNodes(t);
  },
  removeNodes(e, t) {
    e.removeNodes(t);
  },
  setNodes(e, t, n) {
    e.setNodes(t, n);
  },
  splitNodes(e, t) {
    e.splitNodes(t);
  },
  unsetNodes(e, t, n) {
    e.unsetNodes(t, n);
  },
  unwrapNodes(e, t) {
    e.unwrapNodes(t);
  },
  wrapNodes(e, t, n) {
    e.wrapNodes(t, n);
  }
}, Hae = {
  collapse(e, t) {
    e.collapse(t);
  },
  deselect(e) {
    e.deselect();
  },
  move(e, t) {
    e.move(t);
  },
  select(e, t) {
    e.select(t);
  },
  setPoint(e, t, n) {
    e.setPoint(t, n);
  },
  setSelection(e, t) {
    e.setSelection(t);
  }
}, AG = (e, t) => {
  for (var n in e) {
    var r = e[n], o = t[n];
    if (Xo(r) && Xo(o)) {
      if (!AG(r, o)) return !1;
    } else if (Array.isArray(r) && Array.isArray(o)) {
      if (r.length !== o.length) return !1;
      for (var i = 0; i < r.length; i++)
        if (r[i] !== o[i]) return !1;
    } else if (r !== o)
      return !1;
  }
  for (var a in t)
    if (e[a] === void 0 && t[a] !== void 0)
      return !1;
  return !0;
};
function Wae(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), o, i;
  for (i = 0; i < r.length; i++)
    o = r[i], !(t.indexOf(o) >= 0) && (n[o] = e[o]);
  return n;
}
function Ka(e, t) {
  if (e == null) return {};
  var n = Wae(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (o = 0; o < i.length; o++)
      r = i[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
var $ae = ["anchor", "focus"];
function tA(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Vae(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? tA(Object(n), !0).forEach(function(r) {
      Mi(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : tA(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var ve = {
  edges(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, {
      anchor: r,
      focus: o
    } = e;
    return ve.isBackward(e) === n ? [r, o] : [o, r];
  },
  end(e) {
    var [, t] = ve.edges(e);
    return t;
  },
  equals(e, t) {
    return $t.equals(e.anchor, t.anchor) && $t.equals(e.focus, t.focus);
  },
  includes(e, t) {
    if (ve.isRange(t)) {
      if (ve.includes(e, t.anchor) || ve.includes(e, t.focus))
        return !0;
      var [n, r] = ve.edges(e), [o, i] = ve.edges(t);
      return $t.isBefore(n, o) && $t.isAfter(r, i);
    }
    var [a, s] = ve.edges(e), l = !1, u = !1;
    return $t.isPoint(t) ? (l = $t.compare(t, a) >= 0, u = $t.compare(t, s) <= 0) : (l = ce.compare(t, a.path) >= 0, u = ce.compare(t, s.path) <= 0), l && u;
  },
  intersection(e, t) {
    var n = Ka(e, $ae), [r, o] = ve.edges(e), [i, a] = ve.edges(t), s = $t.isBefore(r, i) ? i : r, l = $t.isBefore(o, a) ? o : a;
    return $t.isBefore(l, s) ? null : Vae({
      anchor: s,
      focus: l
    }, n);
  },
  isBackward(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return $t.isAfter(t, n);
  },
  isCollapsed(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return $t.equals(t, n);
  },
  isExpanded(e) {
    return !ve.isCollapsed(e);
  },
  isForward(e) {
    return !ve.isBackward(e);
  },
  isRange(e) {
    return Xo(e) && $t.isPoint(e.anchor) && $t.isPoint(e.focus);
  },
  *points(e) {
    yield [e.anchor, "anchor"], yield [e.focus, "focus"];
  },
  start(e) {
    var [t] = ve.edges(e);
    return t;
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return tS(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "inward"
      } = n, i, a;
      if (o === "inward") {
        var s = ve.isCollapsed(r);
        ve.isForward(r) ? (i = "forward", a = s ? i : "backward") : (i = "backward", a = s ? i : "forward");
      } else o === "outward" ? ve.isForward(r) ? (i = "backward", a = "forward") : (i = "forward", a = "backward") : (i = o, a = o);
      var l = $t.transform(r.anchor, t, {
        affinity: i
      }), u = $t.transform(r.focus, t, {
        affinity: a
      });
      if (!l || !u)
        return null;
      r.anchor = l, r.focus = u;
    });
  }
}, nA = (e) => Xo(e) && tt.isNodeList(e.children) && !te.isEditor(e), ft = {
  isAncestor(e) {
    return Xo(e) && tt.isNodeList(e.children);
  },
  isElement: nA,
  isElementList(e) {
    return Array.isArray(e) && e.every((t) => ft.isElement(t));
  },
  isElementProps(e) {
    return e.children !== void 0;
  },
  isElementType: function(t, n) {
    var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "type";
    return nA(t) && t[r] === n;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "children" && e[n] !== t[n])
        return !1;
    return !0;
  }
}, Zae = ["children"], qae = ["text"], rA = /* @__PURE__ */ new WeakMap(), tt = {
  ancestor(e, t) {
    var n = tt.get(e, t);
    if (ht.isText(n))
      throw new Error("Cannot get the ancestor node at path [".concat(t, "] because it refers to a text node instead: ").concat(Ko.stringify(n)));
    return n;
  },
  ancestors(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of ce.ancestors(t, n)) {
        var o = tt.ancestor(e, r), i = [o, r];
        yield i;
      }
    }();
  },
  child(e, t) {
    if (ht.isText(e))
      throw new Error("Cannot get the child of a text node: ".concat(Ko.stringify(e)));
    var n = e.children[t];
    if (n == null)
      throw new Error("Cannot get child at index `".concat(t, "` in node: ").concat(Ko.stringify(e)));
    return n;
  },
  children(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var {
        reverse: r = !1
      } = n, o = tt.ancestor(e, t), {
        children: i
      } = o, a = r ? i.length - 1 : 0; r ? a >= 0 : a < i.length; ) {
        var s = tt.child(o, a), l = t.concat(a);
        yield [s, l], a = r ? a - 1 : a + 1;
      }
    }();
  },
  common(e, t, n) {
    var r = ce.common(t, n), o = tt.get(e, r);
    return [o, r];
  },
  descendant(e, t) {
    var n = tt.get(e, t);
    if (te.isEditor(n))
      throw new Error("Cannot get the descendant node at path [".concat(t, "] because it refers to the root editor node instead: ").concat(Ko.stringify(n)));
    return n;
  },
  descendants(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of tt.nodes(e, t))
        r.length !== 0 && (yield [n, r]);
    }();
  },
  elements(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of tt.nodes(e, t))
        ft.isElement(n) && (yield [n, r]);
    }();
  },
  extractProps(e) {
    if (ft.isAncestor(e)) {
      var t = Ka(e, Zae);
      return t;
    } else {
      var t = Ka(e, qae);
      return t;
    }
  },
  first(e, t) {
    for (var n = t.slice(), r = tt.get(e, n); r && !(ht.isText(r) || r.children.length === 0); )
      r = r.children[0], n.push(0);
    return [r, n];
  },
  fragment(e, t) {
    if (ht.isText(e))
      throw new Error("Cannot get a fragment starting from a root text node: ".concat(Ko.stringify(e)));
    var n = tS({
      children: e.children
    }, (r) => {
      var [o, i] = ve.edges(t), a = tt.nodes(r, {
        reverse: !0,
        pass: (d) => {
          var [, g] = d;
          return !ve.includes(t, g);
        }
      });
      for (var [, s] of a) {
        if (!ve.includes(t, s)) {
          var l = tt.parent(r, s), u = s[s.length - 1];
          l.children.splice(u, 1);
        }
        if (ce.equals(s, i.path)) {
          var c = tt.leaf(r, s);
          c.text = c.text.slice(0, i.offset);
        }
        if (ce.equals(s, o.path)) {
          var p = tt.leaf(r, s);
          p.text = p.text.slice(o.offset);
        }
      }
      te.isEditor(r) && (r.selection = null);
    });
    return n.children;
  },
  get(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (ht.isText(n) || !n.children[o])
        throw new Error("Cannot find a descendant at path [".concat(t, "] in node: ").concat(Ko.stringify(e)));
      n = n.children[o];
    }
    return n;
  },
  has(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (ht.isText(n) || !n.children[o])
        return !1;
      n = n.children[o];
    }
    return !0;
  },
  isNode(e) {
    return ht.isText(e) || ft.isElement(e) || te.isEditor(e);
  },
  isNodeList(e) {
    if (!Array.isArray(e))
      return !1;
    var t = rA.get(e);
    if (t !== void 0)
      return t;
    var n = e.every((r) => tt.isNode(r));
    return rA.set(e, n), n;
  },
  last(e, t) {
    for (var n = t.slice(), r = tt.get(e, n); r && !(ht.isText(r) || r.children.length === 0); ) {
      var o = r.children.length - 1;
      r = r.children[o], n.push(o);
    }
    return [r, n];
  },
  leaf(e, t) {
    var n = tt.get(e, t);
    if (!ht.isText(n))
      throw new Error("Cannot get the leaf node at path [".concat(t, "] because it refers to a non-leaf node: ").concat(Ko.stringify(n)));
    return n;
  },
  levels(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of ce.levels(t, n)) {
        var o = tt.get(e, r);
        yield [o, r];
      }
    }();
  },
  matches(e, t) {
    return ft.isElement(e) && ft.isElementProps(t) && ft.matches(e, t) || ht.isText(e) && ht.isTextProps(t) && ht.matches(e, t);
  },
  nodes(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var {
        pass: n,
        reverse: r = !1
      } = t, {
        from: o = [],
        to: i
      } = t, a = /* @__PURE__ */ new Set(), s = [], l = e; !(i && (r ? ce.isBefore(s, i) : ce.isAfter(s, i))); ) {
        if (a.has(l) || (yield [l, s]), !a.has(l) && !ht.isText(l) && l.children.length !== 0 && (n == null || n([l, s]) === !1)) {
          a.add(l);
          var u = r ? l.children.length - 1 : 0;
          ce.isAncestor(s, o) && (u = o[s.length]), s = s.concat(u), l = tt.get(e, s);
          continue;
        }
        if (s.length === 0)
          break;
        if (!r) {
          var c = ce.next(s);
          if (tt.has(e, c)) {
            s = c, l = tt.get(e, s);
            continue;
          }
        }
        if (r && s[s.length - 1] !== 0) {
          var p = ce.previous(s);
          s = p, l = tt.get(e, s);
          continue;
        }
        s = ce.parent(s), l = tt.get(e, s), a.add(l);
      }
    }();
  },
  parent(e, t) {
    var n = ce.parent(t), r = tt.get(e, n);
    if (ht.isText(r))
      throw new Error("Cannot get the parent of path [".concat(t, "] because it does not exist in the root."));
    return r;
  },
  string(e) {
    return ht.isText(e) ? e.text : e.children.map(tt.string).join("");
  },
  texts(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of tt.nodes(e, t))
        ht.isText(n) && (yield [n, r]);
    }();
  }
};
function oA(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Ir(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? oA(Object(n), !0).forEach(function(r) {
      Mi(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : oA(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var ru = {
  isNodeOperation(e) {
    return ru.isOperation(e) && e.type.endsWith("_node");
  },
  isOperation(e) {
    if (!Xo(e))
      return !1;
    switch (e.type) {
      case "insert_node":
        return ce.isPath(e.path) && tt.isNode(e.node);
      case "insert_text":
        return typeof e.offset == "number" && typeof e.text == "string" && ce.isPath(e.path);
      case "merge_node":
        return typeof e.position == "number" && ce.isPath(e.path) && Xo(e.properties);
      case "move_node":
        return ce.isPath(e.path) && ce.isPath(e.newPath);
      case "remove_node":
        return ce.isPath(e.path) && tt.isNode(e.node);
      case "remove_text":
        return typeof e.offset == "number" && typeof e.text == "string" && ce.isPath(e.path);
      case "set_node":
        return ce.isPath(e.path) && Xo(e.properties) && Xo(e.newProperties);
      case "set_selection":
        return e.properties === null && ve.isRange(e.newProperties) || e.newProperties === null && ve.isRange(e.properties) || Xo(e.properties) && Xo(e.newProperties);
      case "split_node":
        return ce.isPath(e.path) && typeof e.position == "number" && Xo(e.properties);
      default:
        return !1;
    }
  },
  isOperationList(e) {
    return Array.isArray(e) && e.every((t) => ru.isOperation(t));
  },
  isSelectionOperation(e) {
    return ru.isOperation(e) && e.type.endsWith("_selection");
  },
  isTextOperation(e) {
    return ru.isOperation(e) && e.type.endsWith("_text");
  },
  inverse(e) {
    switch (e.type) {
      case "insert_node":
        return Ir(Ir({}, e), {}, {
          type: "remove_node"
        });
      case "insert_text":
        return Ir(Ir({}, e), {}, {
          type: "remove_text"
        });
      case "merge_node":
        return Ir(Ir({}, e), {}, {
          type: "split_node",
          path: ce.previous(e.path)
        });
      case "move_node": {
        var {
          newPath: t,
          path: n
        } = e;
        if (ce.equals(t, n))
          return e;
        if (ce.isSibling(n, t))
          return Ir(Ir({}, e), {}, {
            path: t,
            newPath: n
          });
        var r = ce.transform(n, e), o = ce.transform(ce.next(n), e);
        return Ir(Ir({}, e), {}, {
          path: r,
          newPath: o
        });
      }
      case "remove_node":
        return Ir(Ir({}, e), {}, {
          type: "insert_node"
        });
      case "remove_text":
        return Ir(Ir({}, e), {}, {
          type: "insert_text"
        });
      case "set_node": {
        var {
          properties: i,
          newProperties: a
        } = e;
        return Ir(Ir({}, e), {}, {
          properties: a,
          newProperties: i
        });
      }
      case "set_selection": {
        var {
          properties: s,
          newProperties: l
        } = e;
        return s == null ? Ir(Ir({}, e), {}, {
          properties: l,
          newProperties: null
        }) : l == null ? Ir(Ir({}, e), {}, {
          properties: null,
          newProperties: s
        }) : Ir(Ir({}, e), {}, {
          properties: l,
          newProperties: s
        });
      }
      case "split_node":
        return Ir(Ir({}, e), {}, {
          type: "merge_node",
          path: ce.next(e.path)
        });
    }
  }
}, iA = /* @__PURE__ */ new WeakMap(), Gae = (e) => {
  var t = iA.get(e);
  if (t !== void 0)
    return t;
  if (!Xo(e))
    return !1;
  var n = typeof e.addMark == "function" && typeof e.apply == "function" && typeof e.deleteFragment == "function" && typeof e.insertBreak == "function" && typeof e.insertSoftBreak == "function" && typeof e.insertFragment == "function" && typeof e.insertNode == "function" && typeof e.insertText == "function" && typeof e.isElementReadOnly == "function" && typeof e.isInline == "function" && typeof e.isSelectable == "function" && typeof e.isVoid == "function" && typeof e.normalizeNode == "function" && typeof e.onChange == "function" && typeof e.removeMark == "function" && typeof e.getDirtyPaths == "function" && (e.marks === null || Xo(e.marks)) && (e.selection === null || ve.isRange(e.selection)) && tt.isNodeList(e.children) && ru.isOperationList(e.operations);
  return iA.set(e, n), n;
}, te = {
  above(e, t) {
    return e.above(t);
  },
  addMark(e, t, n) {
    e.addMark(t, n);
  },
  after(e, t, n) {
    return e.after(t, n);
  },
  before(e, t, n) {
    return e.before(t, n);
  },
  deleteBackward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteBackward(n);
  },
  deleteForward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteForward(n);
  },
  deleteFragment(e, t) {
    e.deleteFragment(t);
  },
  edges(e, t) {
    return e.edges(t);
  },
  elementReadOnly(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return e.elementReadOnly(t);
  },
  end(e, t) {
    return e.end(t);
  },
  first(e, t) {
    return e.first(t);
  },
  fragment(e, t) {
    return e.fragment(t);
  },
  hasBlocks(e, t) {
    return e.hasBlocks(t);
  },
  hasInlines(e, t) {
    return e.hasInlines(t);
  },
  hasPath(e, t) {
    return e.hasPath(t);
  },
  hasTexts(e, t) {
    return e.hasTexts(t);
  },
  insertBreak(e) {
    e.insertBreak();
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertNode(e, t) {
    e.insertNode(t);
  },
  insertSoftBreak(e) {
    e.insertSoftBreak();
  },
  insertText(e, t) {
    e.insertText(t);
  },
  isBlock(e, t) {
    return e.isBlock(t);
  },
  isEdge(e, t, n) {
    return e.isEdge(t, n);
  },
  isEditor(e) {
    return Gae(e);
  },
  isElementReadOnly(e, t) {
    return e.isElementReadOnly(t);
  },
  isEmpty(e, t) {
    return e.isEmpty(t);
  },
  isEnd(e, t, n) {
    return e.isEnd(t, n);
  },
  isInline(e, t) {
    return e.isInline(t);
  },
  isNormalizing(e) {
    return e.isNormalizing();
  },
  isSelectable(e, t) {
    return e.isSelectable(t);
  },
  isStart(e, t, n) {
    return e.isStart(t, n);
  },
  isVoid(e, t) {
    return e.isVoid(t);
  },
  last(e, t) {
    return e.last(t);
  },
  leaf(e, t, n) {
    return e.leaf(t, n);
  },
  levels(e, t) {
    return e.levels(t);
  },
  marks(e) {
    return e.getMarks();
  },
  next(e, t) {
    return e.next(t);
  },
  node(e, t, n) {
    return e.node(t, n);
  },
  nodes(e, t) {
    return e.nodes(t);
  },
  normalize(e, t) {
    e.normalize(t);
  },
  parent(e, t, n) {
    return e.parent(t, n);
  },
  path(e, t, n) {
    return e.path(t, n);
  },
  pathRef(e, t, n) {
    return e.pathRef(t, n);
  },
  pathRefs(e) {
    return e.pathRefs();
  },
  point(e, t, n) {
    return e.point(t, n);
  },
  pointRef(e, t, n) {
    return e.pointRef(t, n);
  },
  pointRefs(e) {
    return e.pointRefs();
  },
  positions(e, t) {
    return e.positions(t);
  },
  previous(e, t) {
    return e.previous(t);
  },
  range(e, t, n) {
    return e.range(t, n);
  },
  rangeRef(e, t, n) {
    return e.rangeRef(t, n);
  },
  rangeRefs(e) {
    return e.rangeRefs();
  },
  removeMark(e, t) {
    e.removeMark(t);
  },
  setNormalizing(e, t) {
    e.setNormalizing(t);
  },
  start(e, t) {
    return e.start(t);
  },
  string(e, t, n) {
    return e.string(t, n);
  },
  unhangRange(e, t, n) {
    return e.unhangRange(t, n);
  },
  void(e, t) {
    return e.void(t);
  },
  withoutNormalizing(e, t) {
    e.withoutNormalizing(t);
  },
  shouldMergeNodesRemovePrevNode: (e, t, n) => e.shouldMergeNodesRemovePrevNode(t, n)
}, Kae = {
  isSpan(e) {
    return Array.isArray(e) && e.length === 2 && e.every(ce.isPath);
  }
};
function sA(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function aA(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? sA(Object(n), !0).forEach(function(r) {
      Mi(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : sA(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var $t = {
  compare(e, t) {
    var n = ce.compare(e.path, t.path);
    return n === 0 ? e.offset < t.offset ? -1 : e.offset > t.offset ? 1 : 0 : n;
  },
  isAfter(e, t) {
    return $t.compare(e, t) === 1;
  },
  isBefore(e, t) {
    return $t.compare(e, t) === -1;
  },
  equals(e, t) {
    return e.offset === t.offset && ce.equals(e.path, t.path);
  },
  isPoint(e) {
    return Xo(e) && typeof e.offset == "number" && ce.isPath(e.path);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return tS(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "forward"
      } = n, {
        path: i,
        offset: a
      } = r;
      switch (t.type) {
        case "insert_node":
        case "move_node": {
          r.path = ce.transform(i, t, n);
          break;
        }
        case "insert_text": {
          ce.equals(t.path, i) && (t.offset < a || t.offset === a && o === "forward") && (r.offset += t.text.length);
          break;
        }
        case "merge_node": {
          ce.equals(t.path, i) && (r.offset += t.position), r.path = ce.transform(i, t, n);
          break;
        }
        case "remove_text": {
          ce.equals(t.path, i) && t.offset <= a && (r.offset -= Math.min(a - t.offset, t.text.length));
          break;
        }
        case "remove_node": {
          if (ce.equals(t.path, i) || ce.isAncestor(t.path, i))
            return null;
          r.path = ce.transform(i, t, n);
          break;
        }
        case "split_node": {
          if (ce.equals(t.path, i)) {
            if (t.position === a && o == null)
              return null;
            (t.position < a || t.position === a && o === "forward") && (r.offset -= t.position, r.path = ce.transform(i, t, aA(aA({}, n), {}, {
              affinity: "forward"
            })));
          } else
            r.path = ce.transform(i, t, n);
          break;
        }
      }
    });
  }
}, lA = void 0, Ko = {
  setScrubber(e) {
    lA = e;
  },
  stringify(e) {
    return JSON.stringify(e, lA);
  }
}, Xae = ["text"], Yae = ["anchor", "focus"];
function uA(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ka(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? uA(Object(n), !0).forEach(function(r) {
      Mi(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : uA(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var ht = {
  equals(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      loose: r = !1
    } = n;
    function o(i) {
      var a = Ka(i, Xae);
      return a;
    }
    return AG(r ? o(e) : e, r ? o(t) : t);
  },
  isText(e) {
    return Xo(e) && typeof e.text == "string";
  },
  isTextList(e) {
    return Array.isArray(e) && e.every((t) => ht.isText(t));
  },
  isTextProps(e) {
    return e.text !== void 0;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "text" && (!e.hasOwnProperty(n) || e[n] !== t[n]))
        return !1;
    return !0;
  },
  decorations(e, t) {
    var n = [ka({}, e)];
    for (var r of t) {
      var o = Ka(r, Yae), [i, a] = ve.edges(r), s = [], l = 0, u = i.offset, c = a.offset;
      for (var p of n) {
        var {
          length: d
        } = p.text, g = l;
        if (l += d, u <= g && l <= c) {
          Object.assign(p, o), s.push(p);
          continue;
        }
        if (u !== c && (u === l || c === g) || u > l || c < g || c === g && g !== 0) {
          s.push(p);
          continue;
        }
        var f = p, m = void 0, b = void 0;
        if (c < l) {
          var E = c - g;
          b = ka(ka({}, f), {}, {
            text: f.text.slice(E)
          }), f = ka(ka({}, f), {}, {
            text: f.text.slice(0, E)
          });
        }
        if (u > g) {
          var w = u - g;
          m = ka(ka({}, f), {}, {
            text: f.text.slice(0, w)
          }), f = ka(ka({}, f), {}, {
            text: f.text.slice(w)
          });
        }
        Object.assign(f, o), m && s.push(m), s.push(f), b && s.push(b);
      }
      n = s;
    }
    return n;
  }
}, nS = (e) => e.selection ? e.selection : e.children.length > 0 ? te.end(e, []) : [0], Mp = (e, t) => {
  var [n] = te.node(e, t);
  return (r) => r === n;
}, rS = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, r = !n, o = n ? rle(t) : t, i = Lt.None, a = Lt.None, s = 0, l = null, u = null;
  for (var c of o) {
    var p = c.codePointAt(0);
    if (!p) break;
    var d = gle(c, p);
    if ([i, a] = r ? [a, d] : [d, i], ap(i, Lt.ZWJ) && ap(a, Lt.ExtPict) && (r ? l = cA(t.substring(0, s)) : l = cA(t.substring(0, t.length - s)), !l) || ap(i, Lt.RI) && ap(a, Lt.RI) && (u !== null ? u = !u : r ? u = !0 : u = wle(t.substring(0, t.length - s)), !u) || i !== Lt.None && a !== Lt.None && vle(i, a))
      break;
    s += c.length;
  }
  return s || 1;
}, Jae = /\s/, Qae = /[\u002B\u0021-\u0023\u0025-\u002A\u002C-\u002F\u003A\u003B\u003F\u0040\u005B-\u005D\u005F\u007B\u007D\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E3B\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]/, ele = /['\u2018\u2019]/, tle = function(t) {
  for (var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, r = 0, o = !1; t.length > 0; ) {
    var i = rS(t, n), [a, s] = oS(t, i, n);
    if (nle(a, s, n))
      o = !0, r += i;
    else if (!o)
      r += i;
    else
      break;
    t = s;
  }
  return r;
}, oS = (e, t, n) => {
  if (n) {
    var r = e.length - t;
    return [e.slice(r, e.length), e.slice(0, r)];
  }
  return [e.slice(0, t), e.slice(t)];
}, nle = function e(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
  if (Jae.test(t))
    return !1;
  if (ele.test(t)) {
    var o = rS(n, r), [i, a] = oS(n, o, r);
    if (e(i, a, r))
      return !0;
  }
  return !Qae.test(t);
}, rle = function* (t) {
  for (var n = t.length - 1, r = 0; r < t.length; r++) {
    var o = t.charAt(n - r);
    if (ile(o.charCodeAt(0))) {
      var i = t.charAt(n - r - 1);
      if (ole(i.charCodeAt(0))) {
        yield i + o, r++;
        continue;
      }
    }
    yield o;
  }
}, ole = (e) => e >= 55296 && e <= 56319, ile = (e) => e >= 56320 && e <= 57343, Lt;
(function(e) {
  e[e.None = 0] = "None", e[e.Extend = 1] = "Extend", e[e.ZWJ = 2] = "ZWJ", e[e.RI = 4] = "RI", e[e.Prepend = 8] = "Prepend", e[e.SpacingMark = 16] = "SpacingMark", e[e.L = 32] = "L", e[e.V = 64] = "V", e[e.T = 128] = "T", e[e.LV = 256] = "LV", e[e.LVT = 512] = "LVT", e[e.ExtPict = 1024] = "ExtPict", e[e.Any = 2048] = "Any";
})(Lt || (Lt = {}));
var sle = /^(?:[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09BE\u09C1-\u09C4\u09CD\u09D7\u09E2\u09E3\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01\u0B3C\u0B3E\u0B3F\u0B41-\u0B44\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B82\u0BBE\u0BC0\u0BCD\u0BD7\u0C00\u0C04\u0C3C\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CBF\u0CC2\u0CC6\u0CCC\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D3E\u0D41-\u0D44\u0D4D\u0D57\u0D62\u0D63\u0D81\u0DCA\u0DCF\u0DD2-\u0DD4\u0DD6\u0DDF\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732\u1733\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u180F\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ACE\u1B00-\u1B03\u1B34-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DFF\u200C\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA82C\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFF9E\uFF9F]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD803[\uDD24-\uDD27\uDEAB\uDEAC\uDEFD-\uDEFF\uDF46-\uDF50\uDF82-\uDF85]|\uD804[\uDC01\uDC38-\uDC46\uDC70\uDC73\uDC74\uDC7F-\uDC81\uDCB3-\uDCB6\uDCB9\uDCBA\uDCC2\uDD00-\uDD02\uDD27-\uDD2B\uDD2D-\uDD34\uDD73\uDD80\uDD81\uDDB6-\uDDBE\uDDC9-\uDDCC\uDDCF\uDE2F-\uDE31\uDE34\uDE36\uDE37\uDE3E\uDE41\uDEDF\uDEE3-\uDEEA\uDF00\uDF01\uDF3B\uDF3C\uDF3E\uDF40\uDF57\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC38-\uDC3F\uDC42-\uDC44\uDC46\uDC5E\uDCB0\uDCB3-\uDCB8\uDCBA\uDCBD\uDCBF\uDCC0\uDCC2\uDCC3\uDDAF\uDDB2-\uDDB5\uDDBC\uDDBD\uDDBF\uDDC0\uDDDC\uDDDD\uDE33-\uDE3A\uDE3D\uDE3F\uDE40\uDEAB\uDEAD\uDEB0-\uDEB5\uDEB7\uDF1D-\uDF1F\uDF22-\uDF25\uDF27-\uDF2B]|\uD806[\uDC2F-\uDC37\uDC39\uDC3A\uDD30\uDD3B\uDD3C\uDD3E\uDD43\uDDD4-\uDDD7\uDDDA\uDDDB\uDDE0\uDE01-\uDE0A\uDE33-\uDE38\uDE3B-\uDE3E\uDE47\uDE51-\uDE56\uDE59-\uDE5B\uDE8A-\uDE96\uDE98\uDE99]|\uD807[\uDC30-\uDC36\uDC38-\uDC3D\uDC3F\uDC92-\uDCA7\uDCAA-\uDCB0\uDCB2\uDCB3\uDCB5\uDCB6\uDD31-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD45\uDD47\uDD90\uDD91\uDD95\uDD97\uDEF3\uDEF4\uDF00\uDF01\uDF36-\uDF3A\uDF40\uDF42]|\uD80D[\uDC40\uDC47-\uDC55]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF4F\uDF8F-\uDF92\uDFE4]|\uD82F[\uDC9D\uDC9E]|\uD833[\uDF00-\uDF2D\uDF30-\uDF46]|\uD834[\uDD65\uDD67-\uDD69\uDD6E-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A\uDC8F\uDD30-\uDD36\uDEAE\uDEEC-\uDEEF]|\uD839[\uDCEC-\uDCEF]|\uD83A[\uDCD0-\uDCD6\uDD44-\uDD4A]|\uD83C[\uDFFB-\uDFFF]|\uDB40[\uDC20-\uDC7F\uDD00-\uDDEF])$/, ale = /^(?:[\u0600-\u0605\u06DD\u070F\u0890\u0891\u08E2\u0D4E]|\uD804[\uDCBD\uDCCD\uDDC2\uDDC3]|\uD806[\uDD3F\uDD41\uDE3A\uDE84-\uDE89]|\uD807\uDD46)$/, lle = /^(?:[\u0903\u093B\u093E-\u0940\u0949-\u094C\u094E\u094F\u0982\u0983\u09BF\u09C0\u09C7\u09C8\u09CB\u09CC\u0A03\u0A3E-\u0A40\u0A83\u0ABE-\u0AC0\u0AC9\u0ACB\u0ACC\u0B02\u0B03\u0B40\u0B47\u0B48\u0B4B\u0B4C\u0BBF\u0BC1\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCC\u0C01-\u0C03\u0C41-\u0C44\u0C82\u0C83\u0CBE\u0CC0\u0CC1\u0CC3\u0CC4\u0CC7\u0CC8\u0CCA\u0CCB\u0D02\u0D03\u0D3F\u0D40\u0D46-\u0D48\u0D4A-\u0D4C\u0D82\u0D83\u0DD0\u0DD1\u0DD8-\u0DDE\u0DF2\u0DF3\u0E33\u0EB3\u0F3E\u0F3F\u0F7F\u1031\u103B\u103C\u1056\u1057\u1084\u1715\u1734\u17B6\u17BE-\u17C5\u17C7\u17C8\u1923-\u1926\u1929-\u192B\u1930\u1931\u1933-\u1938\u1A19\u1A1A\u1A55\u1A57\u1A6D-\u1A72\u1B04\u1B3B\u1B3D-\u1B41\u1B43\u1B44\u1B82\u1BA1\u1BA6\u1BA7\u1BAA\u1BE7\u1BEA-\u1BEC\u1BEE\u1BF2\u1BF3\u1C24-\u1C2B\u1C34\u1C35\u1CE1\u1CF7\uA823\uA824\uA827\uA880\uA881\uA8B4-\uA8C3\uA952\uA953\uA983\uA9B4\uA9B5\uA9BA\uA9BB\uA9BE-\uA9C0\uAA2F\uAA30\uAA33\uAA34\uAA4D\uAAEB\uAAEE\uAAEF\uAAF5\uABE3\uABE4\uABE6\uABE7\uABE9\uABEA\uABEC]|\uD804[\uDC00\uDC02\uDC82\uDCB0-\uDCB2\uDCB7\uDCB8\uDD2C\uDD45\uDD46\uDD82\uDDB3-\uDDB5\uDDBF\uDDC0\uDDCE\uDE2C-\uDE2E\uDE32\uDE33\uDE35\uDEE0-\uDEE2\uDF02\uDF03\uDF3F\uDF41-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF62\uDF63]|\uD805[\uDC35-\uDC37\uDC40\uDC41\uDC45\uDCB1\uDCB2\uDCB9\uDCBB\uDCBC\uDCBE\uDCC1\uDDB0\uDDB1\uDDB8-\uDDBB\uDDBE\uDE30-\uDE32\uDE3B\uDE3C\uDE3E\uDEAC\uDEAE\uDEAF\uDEB6\uDF26]|\uD806[\uDC2C-\uDC2E\uDC38\uDD31-\uDD35\uDD37\uDD38\uDD3D\uDD40\uDD42\uDDD1-\uDDD3\uDDDC-\uDDDF\uDDE4\uDE39\uDE57\uDE58\uDE97]|\uD807[\uDC2F\uDC3E\uDCA9\uDCB1\uDCB4\uDD8A-\uDD8E\uDD93\uDD94\uDD96\uDEF5\uDEF6]|\uD81B[\uDF51-\uDF87\uDFF0\uDFF1]|\uD834[\uDD66\uDD6D])$/, ule = /^[\u1100-\u115F\uA960-\uA97C]$/, cle = /^[\u1160-\u11A7\uD7B0-\uD7C6]$/, ple = /^[\u11A8-\u11FF\uD7CB-\uD7FB]$/, dle = /^[\uAC00\uAC1C\uAC38\uAC54\uAC70\uAC8C\uACA8\uACC4\uACE0\uACFC\uAD18\uAD34\uAD50\uAD6C\uAD88\uADA4\uADC0\uADDC\uADF8\uAE14\uAE30\uAE4C\uAE68\uAE84\uAEA0\uAEBC\uAED8\uAEF4\uAF10\uAF2C\uAF48\uAF64\uAF80\uAF9C\uAFB8\uAFD4\uAFF0\uB00C\uB028\uB044\uB060\uB07C\uB098\uB0B4\uB0D0\uB0EC\uB108\uB124\uB140\uB15C\uB178\uB194\uB1B0\uB1CC\uB1E8\uB204\uB220\uB23C\uB258\uB274\uB290\uB2AC\uB2C8\uB2E4\uB300\uB31C\uB338\uB354\uB370\uB38C\uB3A8\uB3C4\uB3E0\uB3FC\uB418\uB434\uB450\uB46C\uB488\uB4A4\uB4C0\uB4DC\uB4F8\uB514\uB530\uB54C\uB568\uB584\uB5A0\uB5BC\uB5D8\uB5F4\uB610\uB62C\uB648\uB664\uB680\uB69C\uB6B8\uB6D4\uB6F0\uB70C\uB728\uB744\uB760\uB77C\uB798\uB7B4\uB7D0\uB7EC\uB808\uB824\uB840\uB85C\uB878\uB894\uB8B0\uB8CC\uB8E8\uB904\uB920\uB93C\uB958\uB974\uB990\uB9AC\uB9C8\uB9E4\uBA00\uBA1C\uBA38\uBA54\uBA70\uBA8C\uBAA8\uBAC4\uBAE0\uBAFC\uBB18\uBB34\uBB50\uBB6C\uBB88\uBBA4\uBBC0\uBBDC\uBBF8\uBC14\uBC30\uBC4C\uBC68\uBC84\uBCA0\uBCBC\uBCD8\uBCF4\uBD10\uBD2C\uBD48\uBD64\uBD80\uBD9C\uBDB8\uBDD4\uBDF0\uBE0C\uBE28\uBE44\uBE60\uBE7C\uBE98\uBEB4\uBED0\uBEEC\uBF08\uBF24\uBF40\uBF5C\uBF78\uBF94\uBFB0\uBFCC\uBFE8\uC004\uC020\uC03C\uC058\uC074\uC090\uC0AC\uC0C8\uC0E4\uC100\uC11C\uC138\uC154\uC170\uC18C\uC1A8\uC1C4\uC1E0\uC1FC\uC218\uC234\uC250\uC26C\uC288\uC2A4\uC2C0\uC2DC\uC2F8\uC314\uC330\uC34C\uC368\uC384\uC3A0\uC3BC\uC3D8\uC3F4\uC410\uC42C\uC448\uC464\uC480\uC49C\uC4B8\uC4D4\uC4F0\uC50C\uC528\uC544\uC560\uC57C\uC598\uC5B4\uC5D0\uC5EC\uC608\uC624\uC640\uC65C\uC678\uC694\uC6B0\uC6CC\uC6E8\uC704\uC720\uC73C\uC758\uC774\uC790\uC7AC\uC7C8\uC7E4\uC800\uC81C\uC838\uC854\uC870\uC88C\uC8A8\uC8C4\uC8E0\uC8FC\uC918\uC934\uC950\uC96C\uC988\uC9A4\uC9C0\uC9DC\uC9F8\uCA14\uCA30\uCA4C\uCA68\uCA84\uCAA0\uCABC\uCAD8\uCAF4\uCB10\uCB2C\uCB48\uCB64\uCB80\uCB9C\uCBB8\uCBD4\uCBF0\uCC0C\uCC28\uCC44\uCC60\uCC7C\uCC98\uCCB4\uCCD0\uCCEC\uCD08\uCD24\uCD40\uCD5C\uCD78\uCD94\uCDB0\uCDCC\uCDE8\uCE04\uCE20\uCE3C\uCE58\uCE74\uCE90\uCEAC\uCEC8\uCEE4\uCF00\uCF1C\uCF38\uCF54\uCF70\uCF8C\uCFA8\uCFC4\uCFE0\uCFFC\uD018\uD034\uD050\uD06C\uD088\uD0A4\uD0C0\uD0DC\uD0F8\uD114\uD130\uD14C\uD168\uD184\uD1A0\uD1BC\uD1D8\uD1F4\uD210\uD22C\uD248\uD264\uD280\uD29C\uD2B8\uD2D4\uD2F0\uD30C\uD328\uD344\uD360\uD37C\uD398\uD3B4\uD3D0\uD3EC\uD408\uD424\uD440\uD45C\uD478\uD494\uD4B0\uD4CC\uD4E8\uD504\uD520\uD53C\uD558\uD574\uD590\uD5AC\uD5C8\uD5E4\uD600\uD61C\uD638\uD654\uD670\uD68C\uD6A8\uD6C4\uD6E0\uD6FC\uD718\uD734\uD750\uD76C\uD788]$/, fle = /^[\uAC01-\uAC1B\uAC1D-\uAC37\uAC39-\uAC53\uAC55-\uAC6F\uAC71-\uAC8B\uAC8D-\uACA7\uACA9-\uACC3\uACC5-\uACDF\uACE1-\uACFB\uACFD-\uAD17\uAD19-\uAD33\uAD35-\uAD4F\uAD51-\uAD6B\uAD6D-\uAD87\uAD89-\uADA3\uADA5-\uADBF\uADC1-\uADDB\uADDD-\uADF7\uADF9-\uAE13\uAE15-\uAE2F\uAE31-\uAE4B\uAE4D-\uAE67\uAE69-\uAE83\uAE85-\uAE9F\uAEA1-\uAEBB\uAEBD-\uAED7\uAED9-\uAEF3\uAEF5-\uAF0F\uAF11-\uAF2B\uAF2D-\uAF47\uAF49-\uAF63\uAF65-\uAF7F\uAF81-\uAF9B\uAF9D-\uAFB7\uAFB9-\uAFD3\uAFD5-\uAFEF\uAFF1-\uB00B\uB00D-\uB027\uB029-\uB043\uB045-\uB05F\uB061-\uB07B\uB07D-\uB097\uB099-\uB0B3\uB0B5-\uB0CF\uB0D1-\uB0EB\uB0ED-\uB107\uB109-\uB123\uB125-\uB13F\uB141-\uB15B\uB15D-\uB177\uB179-\uB193\uB195-\uB1AF\uB1B1-\uB1CB\uB1CD-\uB1E7\uB1E9-\uB203\uB205-\uB21F\uB221-\uB23B\uB23D-\uB257\uB259-\uB273\uB275-\uB28F\uB291-\uB2AB\uB2AD-\uB2C7\uB2C9-\uB2E3\uB2E5-\uB2FF\uB301-\uB31B\uB31D-\uB337\uB339-\uB353\uB355-\uB36F\uB371-\uB38B\uB38D-\uB3A7\uB3A9-\uB3C3\uB3C5-\uB3DF\uB3E1-\uB3FB\uB3FD-\uB417\uB419-\uB433\uB435-\uB44F\uB451-\uB46B\uB46D-\uB487\uB489-\uB4A3\uB4A5-\uB4BF\uB4C1-\uB4DB\uB4DD-\uB4F7\uB4F9-\uB513\uB515-\uB52F\uB531-\uB54B\uB54D-\uB567\uB569-\uB583\uB585-\uB59F\uB5A1-\uB5BB\uB5BD-\uB5D7\uB5D9-\uB5F3\uB5F5-\uB60F\uB611-\uB62B\uB62D-\uB647\uB649-\uB663\uB665-\uB67F\uB681-\uB69B\uB69D-\uB6B7\uB6B9-\uB6D3\uB6D5-\uB6EF\uB6F1-\uB70B\uB70D-\uB727\uB729-\uB743\uB745-\uB75F\uB761-\uB77B\uB77D-\uB797\uB799-\uB7B3\uB7B5-\uB7CF\uB7D1-\uB7EB\uB7ED-\uB807\uB809-\uB823\uB825-\uB83F\uB841-\uB85B\uB85D-\uB877\uB879-\uB893\uB895-\uB8AF\uB8B1-\uB8CB\uB8CD-\uB8E7\uB8E9-\uB903\uB905-\uB91F\uB921-\uB93B\uB93D-\uB957\uB959-\uB973\uB975-\uB98F\uB991-\uB9AB\uB9AD-\uB9C7\uB9C9-\uB9E3\uB9E5-\uB9FF\uBA01-\uBA1B\uBA1D-\uBA37\uBA39-\uBA53\uBA55-\uBA6F\uBA71-\uBA8B\uBA8D-\uBAA7\uBAA9-\uBAC3\uBAC5-\uBADF\uBAE1-\uBAFB\uBAFD-\uBB17\uBB19-\uBB33\uBB35-\uBB4F\uBB51-\uBB6B\uBB6D-\uBB87\uBB89-\uBBA3\uBBA5-\uBBBF\uBBC1-\uBBDB\uBBDD-\uBBF7\uBBF9-\uBC13\uBC15-\uBC2F\uBC31-\uBC4B\uBC4D-\uBC67\uBC69-\uBC83\uBC85-\uBC9F\uBCA1-\uBCBB\uBCBD-\uBCD7\uBCD9-\uBCF3\uBCF5-\uBD0F\uBD11-\uBD2B\uBD2D-\uBD47\uBD49-\uBD63\uBD65-\uBD7F\uBD81-\uBD9B\uBD9D-\uBDB7\uBDB9-\uBDD3\uBDD5-\uBDEF\uBDF1-\uBE0B\uBE0D-\uBE27\uBE29-\uBE43\uBE45-\uBE5F\uBE61-\uBE7B\uBE7D-\uBE97\uBE99-\uBEB3\uBEB5-\uBECF\uBED1-\uBEEB\uBEED-\uBF07\uBF09-\uBF23\uBF25-\uBF3F\uBF41-\uBF5B\uBF5D-\uBF77\uBF79-\uBF93\uBF95-\uBFAF\uBFB1-\uBFCB\uBFCD-\uBFE7\uBFE9-\uC003\uC005-\uC01F\uC021-\uC03B\uC03D-\uC057\uC059-\uC073\uC075-\uC08F\uC091-\uC0AB\uC0AD-\uC0C7\uC0C9-\uC0E3\uC0E5-\uC0FF\uC101-\uC11B\uC11D-\uC137\uC139-\uC153\uC155-\uC16F\uC171-\uC18B\uC18D-\uC1A7\uC1A9-\uC1C3\uC1C5-\uC1DF\uC1E1-\uC1FB\uC1FD-\uC217\uC219-\uC233\uC235-\uC24F\uC251-\uC26B\uC26D-\uC287\uC289-\uC2A3\uC2A5-\uC2BF\uC2C1-\uC2DB\uC2DD-\uC2F7\uC2F9-\uC313\uC315-\uC32F\uC331-\uC34B\uC34D-\uC367\uC369-\uC383\uC385-\uC39F\uC3A1-\uC3BB\uC3BD-\uC3D7\uC3D9-\uC3F3\uC3F5-\uC40F\uC411-\uC42B\uC42D-\uC447\uC449-\uC463\uC465-\uC47F\uC481-\uC49B\uC49D-\uC4B7\uC4B9-\uC4D3\uC4D5-\uC4EF\uC4F1-\uC50B\uC50D-\uC527\uC529-\uC543\uC545-\uC55F\uC561-\uC57B\uC57D-\uC597\uC599-\uC5B3\uC5B5-\uC5CF\uC5D1-\uC5EB\uC5ED-\uC607\uC609-\uC623\uC625-\uC63F\uC641-\uC65B\uC65D-\uC677\uC679-\uC693\uC695-\uC6AF\uC6B1-\uC6CB\uC6CD-\uC6E7\uC6E9-\uC703\uC705-\uC71F\uC721-\uC73B\uC73D-\uC757\uC759-\uC773\uC775-\uC78F\uC791-\uC7AB\uC7AD-\uC7C7\uC7C9-\uC7E3\uC7E5-\uC7FF\uC801-\uC81B\uC81D-\uC837\uC839-\uC853\uC855-\uC86F\uC871-\uC88B\uC88D-\uC8A7\uC8A9-\uC8C3\uC8C5-\uC8DF\uC8E1-\uC8FB\uC8FD-\uC917\uC919-\uC933\uC935-\uC94F\uC951-\uC96B\uC96D-\uC987\uC989-\uC9A3\uC9A5-\uC9BF\uC9C1-\uC9DB\uC9DD-\uC9F7\uC9F9-\uCA13\uCA15-\uCA2F\uCA31-\uCA4B\uCA4D-\uCA67\uCA69-\uCA83\uCA85-\uCA9F\uCAA1-\uCABB\uCABD-\uCAD7\uCAD9-\uCAF3\uCAF5-\uCB0F\uCB11-\uCB2B\uCB2D-\uCB47\uCB49-\uCB63\uCB65-\uCB7F\uCB81-\uCB9B\uCB9D-\uCBB7\uCBB9-\uCBD3\uCBD5-\uCBEF\uCBF1-\uCC0B\uCC0D-\uCC27\uCC29-\uCC43\uCC45-\uCC5F\uCC61-\uCC7B\uCC7D-\uCC97\uCC99-\uCCB3\uCCB5-\uCCCF\uCCD1-\uCCEB\uCCED-\uCD07\uCD09-\uCD23\uCD25-\uCD3F\uCD41-\uCD5B\uCD5D-\uCD77\uCD79-\uCD93\uCD95-\uCDAF\uCDB1-\uCDCB\uCDCD-\uCDE7\uCDE9-\uCE03\uCE05-\uCE1F\uCE21-\uCE3B\uCE3D-\uCE57\uCE59-\uCE73\uCE75-\uCE8F\uCE91-\uCEAB\uCEAD-\uCEC7\uCEC9-\uCEE3\uCEE5-\uCEFF\uCF01-\uCF1B\uCF1D-\uCF37\uCF39-\uCF53\uCF55-\uCF6F\uCF71-\uCF8B\uCF8D-\uCFA7\uCFA9-\uCFC3\uCFC5-\uCFDF\uCFE1-\uCFFB\uCFFD-\uD017\uD019-\uD033\uD035-\uD04F\uD051-\uD06B\uD06D-\uD087\uD089-\uD0A3\uD0A5-\uD0BF\uD0C1-\uD0DB\uD0DD-\uD0F7\uD0F9-\uD113\uD115-\uD12F\uD131-\uD14B\uD14D-\uD167\uD169-\uD183\uD185-\uD19F\uD1A1-\uD1BB\uD1BD-\uD1D7\uD1D9-\uD1F3\uD1F5-\uD20F\uD211-\uD22B\uD22D-\uD247\uD249-\uD263\uD265-\uD27F\uD281-\uD29B\uD29D-\uD2B7\uD2B9-\uD2D3\uD2D5-\uD2EF\uD2F1-\uD30B\uD30D-\uD327\uD329-\uD343\uD345-\uD35F\uD361-\uD37B\uD37D-\uD397\uD399-\uD3B3\uD3B5-\uD3CF\uD3D1-\uD3EB\uD3ED-\uD407\uD409-\uD423\uD425-\uD43F\uD441-\uD45B\uD45D-\uD477\uD479-\uD493\uD495-\uD4AF\uD4B1-\uD4CB\uD4CD-\uD4E7\uD4E9-\uD503\uD505-\uD51F\uD521-\uD53B\uD53D-\uD557\uD559-\uD573\uD575-\uD58F\uD591-\uD5AB\uD5AD-\uD5C7\uD5C9-\uD5E3\uD5E5-\uD5FF\uD601-\uD61B\uD61D-\uD637\uD639-\uD653\uD655-\uD66F\uD671-\uD68B\uD68D-\uD6A7\uD6A9-\uD6C3\uD6C5-\uD6DF\uD6E1-\uD6FB\uD6FD-\uD717\uD719-\uD733\uD735-\uD74F\uD751-\uD76B\uD76D-\uD787\uD789-\uD7A3]$/, hle = /^(?:[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u2388\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2605\u2607-\u2612\u2614-\u2685\u2690-\u2705\u2708-\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763-\u2767\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC00-\uDCFF\uDD0D-\uDD0F\uDD2F\uDD6C-\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDAD-\uDDE5\uDE01-\uDE0F\uDE1A\uDE2F\uDE32-\uDE3A\uDE3C-\uDE3F\uDE49-\uDFFA]|\uD83D[\uDC00-\uDD3D\uDD46-\uDE4F\uDE80-\uDEFF\uDF74-\uDF7F\uDFD5-\uDFFF]|\uD83E[\uDC0C-\uDC0F\uDC48-\uDC4F\uDC5A-\uDC5F\uDC88-\uDC8F\uDCAE-\uDCFF\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDEFF]|\uD83F[\uDC00-\uDFFD])$/, gle = (e, t) => {
  var n = Lt.Any;
  return e.search(sle) !== -1 && (n |= Lt.Extend), t === 8205 && (n |= Lt.ZWJ), t >= 127462 && t <= 127487 && (n |= Lt.RI), e.search(ale) !== -1 && (n |= Lt.Prepend), e.search(lle) !== -1 && (n |= Lt.SpacingMark), e.search(ule) !== -1 && (n |= Lt.L), e.search(cle) !== -1 && (n |= Lt.V), e.search(ple) !== -1 && (n |= Lt.T), e.search(dle) !== -1 && (n |= Lt.LV), e.search(fle) !== -1 && (n |= Lt.LVT), e.search(hle) !== -1 && (n |= Lt.ExtPict), n;
};
function ap(e, t) {
  return (e & t) !== 0;
}
var mle = [
  // GB6
  [Lt.L, Lt.L | Lt.V | Lt.LV | Lt.LVT],
  // GB7
  [Lt.LV | Lt.V, Lt.V | Lt.T],
  // GB8
  [Lt.LVT | Lt.T, Lt.T],
  // GB9
  [Lt.Any, Lt.Extend | Lt.ZWJ],
  // GB9a
  [Lt.Any, Lt.SpacingMark],
  // GB9b
  [Lt.Prepend, Lt.Any],
  // GB11
  [Lt.ZWJ, Lt.ExtPict],
  // GB12 and GB13
  [Lt.RI, Lt.RI]
];
function vle(e, t) {
  return mle.findIndex((n) => ap(e, n[0]) && ap(t, n[1])) === -1;
}
var yle = /(?:[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u2388\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2605\u2607-\u2612\u2614-\u2685\u2690-\u2705\u2708-\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763-\u2767\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC00-\uDCFF\uDD0D-\uDD0F\uDD2F\uDD6C-\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDAD-\uDDE5\uDE01-\uDE0F\uDE1A\uDE2F\uDE32-\uDE3A\uDE3C-\uDE3F\uDE49-\uDFFA]|\uD83D[\uDC00-\uDD3D\uDD46-\uDE4F\uDE80-\uDEFF\uDF74-\uDF7F\uDFD5-\uDFFF]|\uD83E[\uDC0C-\uDC0F\uDC48-\uDC4F\uDC5A-\uDC5F\uDC88-\uDC8F\uDCAE-\uDCFF\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDEFF]|\uD83F[\uDC00-\uDFFD])(?:[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09BE\u09C1-\u09C4\u09CD\u09D7\u09E2\u09E3\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01\u0B3C\u0B3E\u0B3F\u0B41-\u0B44\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B82\u0BBE\u0BC0\u0BCD\u0BD7\u0C00\u0C04\u0C3C\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CBF\u0CC2\u0CC6\u0CCC\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D3E\u0D41-\u0D44\u0D4D\u0D57\u0D62\u0D63\u0D81\u0DCA\u0DCF\u0DD2-\u0DD4\u0DD6\u0DDF\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732\u1733\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u180F\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ACE\u1B00-\u1B03\u1B34-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DFF\u200C\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA82C\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFF9E\uFF9F]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD803[\uDD24-\uDD27\uDEAB\uDEAC\uDEFD-\uDEFF\uDF46-\uDF50\uDF82-\uDF85]|\uD804[\uDC01\uDC38-\uDC46\uDC70\uDC73\uDC74\uDC7F-\uDC81\uDCB3-\uDCB6\uDCB9\uDCBA\uDCC2\uDD00-\uDD02\uDD27-\uDD2B\uDD2D-\uDD34\uDD73\uDD80\uDD81\uDDB6-\uDDBE\uDDC9-\uDDCC\uDDCF\uDE2F-\uDE31\uDE34\uDE36\uDE37\uDE3E\uDE41\uDEDF\uDEE3-\uDEEA\uDF00\uDF01\uDF3B\uDF3C\uDF3E\uDF40\uDF57\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC38-\uDC3F\uDC42-\uDC44\uDC46\uDC5E\uDCB0\uDCB3-\uDCB8\uDCBA\uDCBD\uDCBF\uDCC0\uDCC2\uDCC3\uDDAF\uDDB2-\uDDB5\uDDBC\uDDBD\uDDBF\uDDC0\uDDDC\uDDDD\uDE33-\uDE3A\uDE3D\uDE3F\uDE40\uDEAB\uDEAD\uDEB0-\uDEB5\uDEB7\uDF1D-\uDF1F\uDF22-\uDF25\uDF27-\uDF2B]|\uD806[\uDC2F-\uDC37\uDC39\uDC3A\uDD30\uDD3B\uDD3C\uDD3E\uDD43\uDDD4-\uDDD7\uDDDA\uDDDB\uDDE0\uDE01-\uDE0A\uDE33-\uDE38\uDE3B-\uDE3E\uDE47\uDE51-\uDE56\uDE59-\uDE5B\uDE8A-\uDE96\uDE98\uDE99]|\uD807[\uDC30-\uDC36\uDC38-\uDC3D\uDC3F\uDC92-\uDCA7\uDCAA-\uDCB0\uDCB2\uDCB3\uDCB5\uDCB6\uDD31-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD45\uDD47\uDD90\uDD91\uDD95\uDD97\uDEF3\uDEF4\uDF00\uDF01\uDF36-\uDF3A\uDF40\uDF42]|\uD80D[\uDC40\uDC47-\uDC55]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF4F\uDF8F-\uDF92\uDFE4]|\uD82F[\uDC9D\uDC9E]|\uD833[\uDF00-\uDF2D\uDF30-\uDF46]|\uD834[\uDD65\uDD67-\uDD69\uDD6E-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A\uDC8F\uDD30-\uDD36\uDEAE\uDEEC-\uDEEF]|\uD839[\uDCEC-\uDCEF]|\uD83A[\uDCD0-\uDCD6\uDD44-\uDD4A]|\uD83C[\uDFFB-\uDFFF]|\uDB40[\uDC20-\uDC7F\uDD00-\uDDEF])*\u200D$/, cA = (e) => e.search(yle) !== -1, ble = /(?:\uD83C[\uDDE6-\uDDFF])+$/g, wle = (e) => {
  var t = e.match(ble);
  if (t === null)
    return !1;
  var n = t[0].length / 2;
  return n % 2 === 1;
}, Cle = {
  delete(e, t) {
    e.delete(t);
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertText(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    te.withoutNormalizing(e, () => {
      var {
        voids: r = !1
      } = n, {
        at: o = nS(e)
      } = n;
      if (ce.isPath(o) && (o = te.range(e, o)), ve.isRange(o))
        if (ve.isCollapsed(o))
          o = o.anchor;
        else {
          var i = ve.end(o);
          if (!r && te.void(e, {
            at: i
          }))
            return;
          var a = ve.start(o), s = te.pointRef(e, a), l = te.pointRef(e, i);
          Be.delete(e, {
            at: o,
            voids: r
          });
          var u = s.unref(), c = l.unref();
          o = u || c, Be.setSelection(e, {
            anchor: o,
            focus: o
          });
        }
      if (!(!r && te.void(e, {
        at: o
      }) || te.elementReadOnly(e, {
        at: o
      }))) {
        var {
          path: p,
          offset: d
        } = o;
        t.length > 0 && e.apply({
          type: "insert_text",
          path: p,
          offset: d,
          text: t
        });
      }
    });
  }
};
function pA(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Yg(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? pA(Object(n), !0).forEach(function(r) {
      Mi(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : pA(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Be = Yg(Yg(Yg(Yg({}, zae), Uae), Hae), Cle), ky = /* @__PURE__ */ new WeakMap(), Ole = (e) => ky.get(e) || !1, xle = (e, t, n) => {
  var r = ky.get(e) || !1;
  ky.set(e, !0);
  try {
    t(), n();
  } finally {
    ky.set(e, r);
  }
};
function RG(e, t, n) {
  var r = Wy.get(e) || [], o = $y.get(e) || /* @__PURE__ */ new Set(), i, a, s = (p) => {
    if (p) {
      var d = p.join(",");
      a.has(d) || (a.add(d), i.push(p));
    }
  };
  if (n) {
    i = [], a = /* @__PURE__ */ new Set();
    for (var l of r) {
      var u = n(l);
      s(u);
    }
  } else
    i = r, a = o;
  for (var c of t)
    s(c);
  Wy.set(e, i), $y.set(e, a);
}
var Ele = (e, t) => {
  for (var n of te.pathRefs(e))
    Aae.transform(n, t);
  for (var r of te.pointRefs(e))
    Rae.transform(r, t);
  for (var o of te.rangeRefs(e))
    Iae.transform(o, t);
  if (!Ole(e)) {
    var i = ce.operationCanTransformPath(t) ? (a) => ce.transform(a, t) : void 0;
    RG(e, e.getDirtyPaths(t), i);
  }
  Be.transform(e, t), e.operations.push(t), te.normalize(e, {
    operation: t
  }), t.type === "set_selection" && (e.marks = null), of.get(e) || (of.set(e, !0), Promise.resolve().then(() => {
    of.set(e, !1), e.onChange({
      operation: t
    }), e.operations = [];
  }));
}, kle = (e, t) => {
  switch (t.type) {
    case "insert_text":
    case "remove_text":
    case "set_node": {
      var {
        path: n
      } = t;
      return ce.levels(n);
    }
    case "insert_node": {
      var {
        node: r,
        path: o
      } = t, i = ce.levels(o), a = ht.isText(r) ? [] : Array.from(tt.nodes(r), (B) => {
        var [, N] = B;
        return o.concat(N);
      });
      return [...i, ...a];
    }
    case "merge_node": {
      var {
        path: s
      } = t, l = ce.ancestors(s), u = ce.previous(s);
      return [...l, u];
    }
    case "move_node": {
      var {
        path: c,
        newPath: p
      } = t;
      if (ce.equals(c, p))
        return [];
      var d = [], g = [];
      for (var f of ce.ancestors(c)) {
        var m = ce.transform(f, t);
        d.push(m);
      }
      for (var b of ce.ancestors(p)) {
        var E = ce.transform(b, t);
        g.push(E);
      }
      var w = g[g.length - 1], M = p[p.length - 1], x = w.concat(M);
      return [...d, ...g, x];
    }
    case "remove_node": {
      var {
        path: v
      } = t, C = ce.ancestors(v);
      return [...C];
    }
    case "split_node": {
      var {
        path: P
      } = t, F = ce.levels(P), L = ce.next(P);
      return [...F, L];
    }
    default:
      return [];
  }
}, Lle = (e) => {
  var {
    selection: t
  } = e;
  return t ? tt.fragment(e, t) : [];
}, _le = (e, t) => {
  var [n, r] = t;
  if (!ht.isText(n)) {
    if (ft.isElement(n) && n.children.length === 0) {
      var o = {
        text: ""
      };
      Be.insertNodes(e, o, {
        at: r.concat(0),
        voids: !0
      });
      return;
    }
    for (var i = te.isEditor(n) ? !1 : ft.isElement(n) && (e.isInline(n) || n.children.length === 0 || ht.isText(n.children[0]) || e.isInline(n.children[0])), a = 0, s = 0; s < n.children.length; s++, a++) {
      var l = tt.get(e, r);
      if (!ht.isText(l)) {
        var u = l.children[a], c = l.children[a - 1], p = s === n.children.length - 1, d = ht.isText(u) || ft.isElement(u) && e.isInline(u);
        if (d !== i)
          Be.removeNodes(e, {
            at: r.concat(a),
            voids: !0
          }), a--;
        else if (ft.isElement(u)) {
          if (e.isInline(u)) {
            if (c == null || !ht.isText(c)) {
              var g = {
                text: ""
              };
              Be.insertNodes(e, g, {
                at: r.concat(a),
                voids: !0
              }), a++;
            } else if (p) {
              var f = {
                text: ""
              };
              Be.insertNodes(e, f, {
                at: r.concat(a + 1),
                voids: !0
              }), a++;
            }
          }
        } else {
          if (!ht.isText(u) && !("children" in u)) {
            var m = u;
            m.children = [];
          }
          c != null && ht.isText(c) && (ht.equals(u, c, {
            loose: !0
          }) ? (Be.mergeNodes(e, {
            at: r.concat(a),
            voids: !0
          }), a--) : c.text === "" ? (Be.removeNodes(e, {
            at: r.concat(a - 1),
            voids: !0
          }), a--) : u.text === "" && (Be.removeNodes(e, {
            at: r.concat(a),
            voids: !0
          }), a--));
        }
      }
    }
  }
}, Ple = (e, t) => {
  var {
    iteration: n,
    initialDirtyPathsLength: r
  } = t, o = r * 42;
  if (n > o)
    throw new Error("Could not completely normalize the editor after ".concat(o, " iterations! This is usually due to incorrect normalization logic that leaves a node in an invalid state."));
  return !0;
}, Sle = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    voids: r = !1,
    mode: o = "lowest",
    at: i = t.selection,
    match: a
  } = n;
  if (i) {
    var s = te.path(t, i), l = o === "lowest";
    for (var [u, c] of te.levels(t, {
      at: s,
      voids: r,
      match: a,
      reverse: l
    }))
      if (!ht.isText(u)) {
        if (ve.isRange(i)) {
          if (ce.isAncestor(c, i.anchor.path) && ce.isAncestor(c, i.focus.path))
            return [u, c];
        } else if (!ce.equals(s, c))
          return [u, c];
      }
  }
};
function dA(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function fA(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? dA(Object(n), !0).forEach(function(r) {
      Mi(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : dA(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Mle = (e, t, n) => {
  var {
    selection: r
  } = e;
  if (r) {
    var o = (p, d) => {
      if (!ht.isText(p))
        return !1;
      var [g, f] = te.parent(e, d);
      return !e.isVoid(g) || e.markableVoid(g);
    }, i = ve.isExpanded(r), a = !1;
    if (!i) {
      var [s, l] = te.node(e, r);
      if (s && o(s, l)) {
        var [u] = te.parent(e, l);
        a = u && e.markableVoid(u);
      }
    }
    if (i || a)
      Be.setNodes(e, {
        [t]: n
      }, {
        match: o,
        split: !0,
        voids: !0
      });
    else {
      var c = fA(fA({}, te.marks(e) || {}), {}, {
        [t]: n
      });
      e.marks = c, of.get(e) || e.onChange();
    }
  }
};
function hA(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function gA(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? hA(Object(n), !0).forEach(function(r) {
      Mi(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : hA(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Dle = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, o = te.point(t, n, {
    edge: "end"
  }), i = te.end(t, []), a = {
    anchor: o,
    focus: i
  }, {
    distance: s = 1
  } = r, l = 0, u;
  for (var c of te.positions(t, gA(gA({}, r), {}, {
    at: a
  }))) {
    if (l > s)
      break;
    l !== 0 && (u = c), l++;
  }
  return u;
};
function mA(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function vA(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? mA(Object(n), !0).forEach(function(r) {
      Mi(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : mA(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Tle = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, o = te.start(t, []), i = te.point(t, n, {
    edge: "start"
  }), a = {
    anchor: o,
    focus: i
  }, {
    distance: s = 1
  } = r, l = 0, u;
  for (var c of te.positions(t, vA(vA({}, r), {}, {
    at: a,
    reverse: !0
  }))) {
    if (l > s)
      break;
    l !== 0 && (u = c), l++;
  }
  return u;
}, jle = (e, t) => {
  var {
    selection: n
  } = e;
  n && ve.isCollapsed(n) && Be.delete(e, {
    unit: t,
    reverse: !0
  });
}, Ale = (e, t) => {
  var {
    selection: n
  } = e;
  n && ve.isCollapsed(n) && Be.delete(e, {
    unit: t
  });
}, Rle = function(t) {
  var {
    direction: n = "forward"
  } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    selection: r
  } = t;
  r && ve.isExpanded(r) && Be.delete(t, {
    reverse: n === "backward"
  });
}, Ile = (e, t) => [te.start(e, t), te.end(e, t)];
function yA(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function bA(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? yA(Object(n), !0).forEach(function(r) {
      Mi(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : yA(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Nle = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return te.above(t, bA(bA({}, n), {}, {
    match: (r) => ft.isElement(r) && te.isElementReadOnly(t, r)
  }));
}, Ble = (e, t) => te.point(e, t, {
  edge: "end"
}), Fle = (e, t) => {
  var n = te.path(e, t, {
    edge: "start"
  });
  return te.node(e, n);
}, zle = (e, t) => {
  var n = te.range(e, t);
  return tt.fragment(e, n);
};
function wA(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function CA(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? wA(Object(n), !0).forEach(function(r) {
      Mi(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : wA(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Ule = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return te.above(t, CA(CA({}, n), {}, {
    match: (r) => ft.isElement(r) && te.isVoid(t, r)
  }));
}, Hle = (e, t) => t.children.some((n) => ft.isElement(n) && te.isBlock(e, n)), Wle = (e, t) => t.children.some((n) => ht.isText(n) || te.isInline(e, n)), $le = (e, t) => tt.has(e, t), Vle = (e, t) => t.children.every((n) => ht.isText(n)), Zle = (e) => {
  Be.splitNodes(e, {
    always: !0
  });
}, qle = (e, t, n) => {
  Be.insertNodes(e, t, n);
}, Gle = (e) => {
  Be.splitNodes(e, {
    always: !0
  });
};
function OA(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Kle(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? OA(Object(n), !0).forEach(function(r) {
      Mi(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : OA(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Xle = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    selection: o,
    marks: i
  } = t;
  if (o) {
    if (i) {
      var a = Kle({
        text: n
      }, i);
      Be.insertNodes(t, a, {
        at: r.at,
        voids: r.voids
      });
    } else
      Be.insertText(t, n, r);
    t.marks = null;
  }
}, Yle = (e, t) => !e.isInline(t), Jle = (e, t, n) => te.isStart(e, t, n) || te.isEnd(e, t, n), Qle = (e, t) => {
  var {
    children: n
  } = t, [r] = n;
  return n.length === 0 || n.length === 1 && ht.isText(r) && r.text === "" && !e.isVoid(t);
}, eue = (e, t, n) => {
  var r = te.end(e, n);
  return $t.equals(t, r);
}, tue = (e) => {
  var t = jG.get(e);
  return t === void 0 ? !0 : t;
}, nue = (e, t, n) => {
  if (t.offset !== 0)
    return !1;
  var r = te.start(e, n);
  return $t.equals(t, r);
}, rue = (e, t) => {
  var n = te.path(e, t, {
    edge: "end"
  });
  return te.node(e, n);
}, oue = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, o = te.path(t, n, r), i = tt.leaf(t, o);
  return [i, o];
};
function iue(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return function* () {
    var {
      at: n = e.selection,
      reverse: r = !1,
      voids: o = !1
    } = t, {
      match: i
    } = t;
    if (i == null && (i = () => !0), !!n) {
      var a = [], s = te.path(e, n);
      for (var [l, u] of tt.levels(e, s))
        if (i(l, u) && (a.push([l, u]), !o && ft.isElement(l) && te.isVoid(e, l)))
          break;
      r && a.reverse(), yield* a;
    }
  }();
}
var sue = ["text"], aue = ["text"], lue = function(t) {
  var {
    marks: n,
    selection: r
  } = t;
  if (!r)
    return null;
  var {
    anchor: o,
    focus: i
  } = r;
  if (n)
    return n;
  if (ve.isExpanded(r)) {
    var a = te.isEnd(t, o, o.path);
    if (a) {
      var s = te.after(t, o);
      s && (o = s);
    }
    var [l] = te.nodes(t, {
      match: ht.isText,
      at: {
        anchor: o,
        focus: i
      }
    });
    if (l) {
      var [u] = l, c = Ka(u, sue);
      return c;
    } else
      return {};
  }
  var {
    path: p
  } = o, [d] = te.leaf(t, p);
  if (o.offset === 0) {
    var g = te.previous(t, {
      at: p,
      match: ht.isText
    }), f = te.above(t, {
      match: (x) => ft.isElement(x) && te.isVoid(t, x) && t.markableVoid(x)
    });
    if (!f) {
      var m = te.above(t, {
        match: (x) => ft.isElement(x) && te.isBlock(t, x)
      });
      if (g && m) {
        var [b, E] = g, [, w] = m;
        ce.isAncestor(w, E) && (d = b);
      }
    }
  }
  var M = Ka(d, aue);
  return M;
}, uue = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    mode: r = "lowest",
    voids: o = !1
  } = n, {
    match: i,
    at: a = t.selection
  } = n;
  if (a) {
    var s = te.after(t, a, {
      voids: o
    });
    if (s) {
      var [, l] = te.last(t, []), u = [s.path, l];
      if (ce.isPath(a) && a.length === 0)
        throw new Error("Cannot get the next node from the root node!");
      if (i == null)
        if (ce.isPath(a)) {
          var [c] = te.parent(t, a);
          i = (d) => c.children.includes(d);
        } else
          i = () => !0;
      var [p] = te.nodes(t, {
        at: u,
        match: i,
        mode: r,
        voids: o
      });
      return p;
    }
  }
}, cue = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, o = te.path(t, n, r), i = tt.get(t, o);
  return [i, o];
};
function pue(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return function* () {
    var {
      at: n = e.selection,
      mode: r = "all",
      universal: o = !1,
      reverse: i = !1,
      voids: a = !1,
      ignoreNonSelectable: s = !1
    } = t, {
      match: l
    } = t;
    if (l || (l = () => !0), !!n) {
      var u, c;
      if (Kae.isSpan(n))
        u = n[0], c = n[1];
      else {
        var p = te.path(e, n, {
          edge: "start"
        }), d = te.path(e, n, {
          edge: "end"
        });
        u = i ? d : p, c = i ? p : d;
      }
      var g = tt.nodes(e, {
        reverse: i,
        from: u,
        to: c,
        pass: (x) => {
          var [v] = x;
          return ft.isElement(v) ? !!(!a && (te.isVoid(e, v) || te.isElementReadOnly(e, v)) || s && !te.isSelectable(e, v)) : !1;
        }
      }), f = [], m;
      for (var [b, E] of g)
        if (!(s && ft.isElement(b) && !te.isSelectable(e, b))) {
          var w = m && ce.compare(E, m[1]) === 0;
          if (!(r === "highest" && w)) {
            if (!l(b, E)) {
              if (o && !w && ht.isText(b))
                return;
              continue;
            }
            if (r === "lowest" && w) {
              m = [b, E];
              continue;
            }
            var M = r === "lowest" ? m : [b, E];
            M && (o ? f.push(M) : yield M), m = [b, E];
          }
        }
      r === "lowest" && m && (o ? f.push(m) : yield m), o && (yield* f);
    }
  }();
}
var due = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    force: r = !1,
    operation: o
  } = n, i = (c) => Wy.get(c) || [], a = (c) => $y.get(c) || /* @__PURE__ */ new Set(), s = (c) => {
    var p = i(c).pop(), d = p.join(",");
    return a(c).delete(d), p;
  };
  if (te.isNormalizing(t)) {
    if (r) {
      var l = Array.from(tt.nodes(t), (c) => {
        var [, p] = c;
        return p;
      }), u = new Set(l.map((c) => c.join(",")));
      Wy.set(t, l), $y.set(t, u);
    }
    i(t).length !== 0 && te.withoutNormalizing(t, () => {
      for (var c of i(t))
        if (tt.has(t, c)) {
          var p = te.node(t, c), [d, g] = p;
          ft.isElement(d) && d.children.length === 0 && t.normalizeNode(p, {
            operation: o
          });
        }
      for (var f = i(t), m = f.length, b = 0; f.length !== 0; ) {
        if (!t.shouldNormalize({
          dirtyPaths: f,
          iteration: b,
          initialDirtyPathsLength: m,
          operation: o
        }))
          return;
        var E = s(t);
        if (tt.has(t, E)) {
          var w = te.node(t, E);
          t.normalizeNode(w, {
            operation: o
          });
        }
        b++, f = i(t);
      }
    });
  }
}, fue = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, o = te.path(t, n, r), i = ce.parent(o), a = te.node(t, i);
  return a;
}, hue = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    affinity: o = "forward"
  } = r, i = {
    current: n,
    affinity: o,
    unref() {
      var {
        current: s
      } = i, l = te.pathRefs(t);
      return l.delete(i), i.current = null, s;
    }
  }, a = te.pathRefs(t);
  return a.add(i), i;
}, gue = (e) => {
  var t = Yj.get(e);
  return t || (t = /* @__PURE__ */ new Set(), Yj.set(e, t)), t;
}, mue = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    depth: o,
    edge: i
  } = r;
  if (ce.isPath(n)) {
    if (i === "start") {
      var [, a] = tt.first(t, n);
      n = a;
    } else if (i === "end") {
      var [, s] = tt.last(t, n);
      n = s;
    }
  }
  return ve.isRange(n) && (i === "start" ? n = ve.start(n) : i === "end" ? n = ve.end(n) : n = ce.common(n.anchor.path, n.focus.path)), $t.isPoint(n) && (n = n.path), o != null && (n = n.slice(0, o)), n;
}, vue = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    affinity: o = "forward"
  } = r, i = {
    current: n,
    affinity: o,
    unref() {
      var {
        current: s
      } = i, l = te.pointRefs(t);
      return l.delete(i), i.current = null, s;
    }
  }, a = te.pointRefs(t);
  return a.add(i), i;
}, yue = (e) => {
  var t = Jj.get(e);
  return t || (t = /* @__PURE__ */ new Set(), Jj.set(e, t)), t;
}, bue = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    edge: o = "start"
  } = r;
  if (ce.isPath(n)) {
    var i;
    if (o === "end") {
      var [, a] = tt.last(t, n);
      i = a;
    } else {
      var [, s] = tt.first(t, n);
      i = s;
    }
    var l = tt.get(t, i);
    if (!ht.isText(l))
      throw new Error("Cannot get the ".concat(o, " point in the node at path [").concat(n, "] because it has no ").concat(o, " text node."));
    return {
      path: i,
      offset: o === "end" ? l.text.length : 0
    };
  }
  if (ve.isRange(n)) {
    var [u, c] = ve.edges(n);
    return o === "start" ? u : c;
  }
  return n;
};
function wue(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return function* () {
    var {
      at: n = e.selection,
      unit: r = "offset",
      reverse: o = !1,
      voids: i = !1,
      ignoreNonSelectable: a = !1
    } = t;
    if (!n)
      return;
    var s = te.range(e, n), [l, u] = ve.edges(s), c = o ? u : l, p = !1, d = "", g = 0, f = 0, m = 0;
    for (var [b, E] of te.nodes(e, {
      at: n,
      reverse: o,
      voids: i,
      ignoreNonSelectable: a
    })) {
      if (ft.isElement(b)) {
        if (!i && (e.isVoid(b) || e.isElementReadOnly(b))) {
          yield te.start(e, E);
          continue;
        }
        if (e.isInline(b)) continue;
        if (te.hasInlines(e, b)) {
          var w = ce.isAncestor(E, u.path) ? u : te.end(e, E), M = ce.isAncestor(E, l.path) ? l : te.start(e, E);
          d = te.string(e, {
            anchor: M,
            focus: w
          }, {
            voids: i
          }), p = !0;
        }
      }
      if (ht.isText(b)) {
        var x = ce.equals(E, c.path);
        for (x ? (f = o ? c.offset : b.text.length - c.offset, m = c.offset) : (f = b.text.length, m = o ? f : 0), (x || p || r === "offset") && (yield {
          path: E,
          offset: m
        }, p = !1); ; ) {
          if (g === 0) {
            if (d === "") break;
            g = v(d, r, o), d = oS(d, g, o)[1];
          }
          if (m = o ? m - g : m + g, f = f - g, f < 0) {
            g = -f;
            break;
          }
          g = 0, yield {
            path: E,
            offset: m
          };
        }
      }
    }
    function v(C, P, F) {
      return P === "character" ? rS(C, F) : P === "word" ? tle(C, F) : P === "line" || P === "block" ? C.length : 1;
    }
  }();
}
var Cue = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    mode: r = "lowest",
    voids: o = !1
  } = n, {
    match: i,
    at: a = t.selection
  } = n;
  if (a) {
    var s = te.before(t, a, {
      voids: o
    });
    if (s) {
      var [, l] = te.first(t, []), u = [s.path, l];
      if (ce.isPath(a) && a.length === 0)
        throw new Error("Cannot get the previous node from the root node!");
      if (i == null)
        if (ce.isPath(a)) {
          var [c] = te.parent(t, a);
          i = (d) => c.children.includes(d);
        } else
          i = () => !0;
      var [p] = te.nodes(t, {
        reverse: !0,
        at: u,
        match: i,
        mode: r,
        voids: o
      });
      return p;
    }
  }
}, Oue = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    affinity: o = "forward"
  } = r, i = {
    current: n,
    affinity: o,
    unref() {
      var {
        current: s
      } = i, l = te.rangeRefs(t);
      return l.delete(i), i.current = null, s;
    }
  }, a = te.rangeRefs(t);
  return a.add(i), i;
}, xue = (e) => {
  var t = Qj.get(e);
  return t || (t = /* @__PURE__ */ new Set(), Qj.set(e, t)), t;
}, Eue = (e, t, n) => {
  if (ve.isRange(t) && !n)
    return t;
  var r = te.start(e, t), o = te.end(e, n || t);
  return {
    anchor: r,
    focus: o
  };
};
function xA(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function kue(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? xA(Object(n), !0).forEach(function(r) {
      Mi(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : xA(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Lue = (e, t) => {
  var {
    selection: n
  } = e;
  if (n) {
    var r = (c, p) => {
      if (!ht.isText(c))
        return !1;
      var [d, g] = te.parent(e, p);
      return !e.isVoid(d) || e.markableVoid(d);
    }, o = ve.isExpanded(n), i = !1;
    if (!o) {
      var [a, s] = te.node(e, n);
      if (a && r(a, s)) {
        var [l] = te.parent(e, s);
        i = l && e.markableVoid(l);
      }
    }
    if (o || i)
      Be.unsetNodes(e, t, {
        match: r,
        split: !0,
        voids: !0
      });
    else {
      var u = kue({}, te.marks(e) || {});
      delete u[t], e.marks = u, of.get(e) || e.onChange();
    }
  }
}, _ue = (e, t) => {
  jG.set(e, t);
}, Pue = (e, t) => te.point(e, t, {
  edge: "start"
}), Sue = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    voids: o = !1
  } = r, i = te.range(t, n), [a, s] = ve.edges(i), l = "";
  for (var [u, c] of te.nodes(t, {
    at: i,
    match: ht.isText,
    voids: o
  })) {
    var p = u.text;
    ce.equals(c, s.path) && (p = p.slice(0, s.offset)), ce.equals(c, a.path) && (p = p.slice(a.offset)), l += p;
  }
  return l;
}, Mue = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    voids: o = !1
  } = r, [i, a] = ve.edges(n);
  if (i.offset !== 0 || a.offset !== 0 || ve.isCollapsed(n) || ce.hasPrevious(a.path))
    return n;
  var s = te.above(t, {
    at: a,
    match: (f) => ft.isElement(f) && te.isBlock(t, f),
    voids: o
  }), l = s ? s[1] : [], u = te.start(t, i), c = {
    anchor: u,
    focus: a
  }, p = !0;
  for (var [d, g] of te.nodes(t, {
    at: c,
    match: ht.isText,
    reverse: !0,
    voids: o
  })) {
    if (p) {
      p = !1;
      continue;
    }
    if (d.text !== "" || ce.isBefore(g, l)) {
      a = {
        path: g,
        offset: d.text.length
      };
      break;
    }
  }
  return {
    anchor: i,
    focus: a
  };
}, Due = (e, t) => {
  var n = te.isNormalizing(e);
  te.setNormalizing(e, !1);
  try {
    t();
  } finally {
    te.setNormalizing(e, n);
  }
  te.normalize(e);
}, Tue = (e, t, n) => {
  var [r, o] = t;
  return ft.isElement(r) && te.isEmpty(e, r) || ht.isText(r) && r.text === "" && o[o.length - 1] !== 0;
}, jue = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  te.withoutNormalizing(t, () => {
    var r, o, {
      reverse: i = !1,
      unit: a = "character",
      distance: s = 1,
      voids: l = !1
    } = n, {
      at: u = t.selection,
      hanging: c = !1
    } = n;
    if (u) {
      var p = !1;
      if (ve.isRange(u) && ve.isCollapsed(u) && (p = !0, u = u.anchor), $t.isPoint(u)) {
        var d = te.void(t, {
          at: u,
          mode: "highest"
        });
        if (!l && d) {
          var [, g] = d;
          u = g;
        } else {
          var f = {
            unit: a,
            distance: s
          }, m = i ? te.before(t, u, f) || te.start(t, []) : te.after(t, u, f) || te.end(t, []);
          u = {
            anchor: u,
            focus: m
          }, c = !0;
        }
      }
      if (ce.isPath(u)) {
        Be.removeNodes(t, {
          at: u,
          voids: l
        });
        return;
      }
      if (!ve.isCollapsed(u)) {
        if (!c) {
          var [, b] = ve.edges(u), E = te.end(t, []);
          $t.equals(b, E) || (u = te.unhangRange(t, u, {
            voids: l
          }));
        }
        var [w, M] = ve.edges(u), x = te.above(t, {
          match: (he) => ft.isElement(he) && te.isBlock(t, he),
          at: w,
          voids: l
        }), v = te.above(t, {
          match: (he) => ft.isElement(he) && te.isBlock(t, he),
          at: M,
          voids: l
        }), C = x && v && !ce.equals(x[1], v[1]), P = ce.equals(w.path, M.path), F = l ? null : (r = te.void(t, {
          at: w,
          mode: "highest"
        })) !== null && r !== void 0 ? r : te.elementReadOnly(t, {
          at: w,
          mode: "highest"
        }), L = l ? null : (o = te.void(t, {
          at: M,
          mode: "highest"
        })) !== null && o !== void 0 ? o : te.elementReadOnly(t, {
          at: M,
          mode: "highest"
        });
        if (F) {
          var B = te.before(t, w);
          B && x && ce.isAncestor(x[1], B.path) && (w = B);
        }
        if (L) {
          var N = te.after(t, M);
          N && v && ce.isAncestor(v[1], N.path) && (M = N);
        }
        var $ = [], V;
        for (var H of te.nodes(t, {
          at: u,
          voids: l
        })) {
          var [Z, K] = H;
          V && ce.compare(K, V) === 0 || (!l && ft.isElement(Z) && (te.isVoid(t, Z) || te.isElementReadOnly(t, Z)) || !ce.isCommon(K, w.path) && !ce.isCommon(K, M.path)) && ($.push(H), V = K);
        }
        var Y = Array.from($, (he) => {
          var [, oe] = he;
          return te.pathRef(t, oe);
        }), Q = te.pointRef(t, w), J = te.pointRef(t, M), _ = "";
        if (!P && !F) {
          var D = Q.current, [z] = te.leaf(t, D), {
            path: S
          } = D, {
            offset: W
          } = w, O = z.text.slice(W);
          O.length > 0 && (t.apply({
            type: "remove_text",
            path: S,
            offset: W,
            text: O
          }), _ = O);
        }
        if (Y.reverse().map((he) => he.unref()).filter((he) => he !== null).forEach((he) => Be.removeNodes(t, {
          at: he,
          voids: l
        })), !L) {
          var j = J.current, [U] = te.leaf(t, j), {
            path: T
          } = j, q = P ? w.offset : 0, A = U.text.slice(q, M.offset);
          A.length > 0 && (t.apply({
            type: "remove_text",
            path: T,
            offset: q,
            text: A
          }), _ = A);
        }
        !P && C && J.current && Q.current && Be.mergeNodes(t, {
          at: J.current,
          hanging: !0,
          voids: l
        }), p && i && a === "character" && _.length > 1 && _.match(/[\u0E00-\u0E7F]+/) && Be.insertText(t, _.slice(0, _.length - s));
        var X = Q.unref(), I = J.unref(), le = i ? X || I : I || X;
        n.at == null && le && Be.select(t, le);
      }
    }
  });
}, Aue = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  te.withoutNormalizing(t, () => {
    var {
      hanging: o = !1,
      voids: i = !1
    } = r, {
      at: a = nS(t),
      batchDirty: s = !0
    } = r;
    if (n.length) {
      if (ve.isRange(a))
        if (o || (a = te.unhangRange(t, a, {
          voids: i
        })), ve.isCollapsed(a))
          a = a.anchor;
        else {
          var [, l] = ve.edges(a);
          if (!i && te.void(t, {
            at: l
          }))
            return;
          var u = te.pointRef(t, l);
          Be.delete(t, {
            at: a
          }), a = u.unref();
        }
      else ce.isPath(a) && (a = te.start(t, a));
      if (!(!i && te.void(t, {
        at: a
      }))) {
        var c = te.above(t, {
          at: a,
          match: (O) => ft.isElement(O) && te.isInline(t, O),
          mode: "highest",
          voids: i
        });
        if (c) {
          var [, p] = c;
          if (te.isEnd(t, a, p)) {
            var d = te.after(t, p);
            a = d;
          } else if (te.isStart(t, a, p)) {
            var g = te.before(t, p);
            a = g;
          }
        }
        var f = te.above(t, {
          match: (O) => ft.isElement(O) && te.isBlock(t, O),
          at: a,
          voids: i
        }), [, m] = f, b = te.isStart(t, a, m), E = te.isEnd(t, a, m), w = b && E, M = !b || b && E, x = !E, [, v] = tt.first({
          children: n
        }, []), [, C] = tt.last({
          children: n
        }, []), P = [], F = (O) => {
          var [j, U] = O, T = U.length === 0;
          return T ? !1 : w ? !0 : !(M && ce.isAncestor(U, v) && ft.isElement(j) && !t.isVoid(j) && !t.isInline(j) || x && ce.isAncestor(U, C) && ft.isElement(j) && !t.isVoid(j) && !t.isInline(j));
        };
        for (var L of tt.nodes({
          children: n
        }, {
          pass: F
        }))
          F(L) && P.push(L);
        var B = [], N = [], $ = [], V = !0, H = !1;
        for (var [Z] of P)
          ft.isElement(Z) && !t.isInline(Z) ? (V = !1, H = !0, N.push(Z)) : V ? B.push(Z) : $.push(Z);
        var [K] = te.nodes(t, {
          at: a,
          match: (O) => ht.isText(O) || te.isInline(t, O),
          mode: "highest",
          voids: i
        }), [, Y] = K, Q = te.isStart(t, a, Y), J = te.isEnd(t, a, Y), _ = te.pathRef(t, E && !$.length ? ce.next(m) : m), D = te.pathRef(t, J ? ce.next(Y) : Y);
        Be.splitNodes(t, {
          at: a,
          match: (O) => H ? ft.isElement(O) && te.isBlock(t, O) : ht.isText(O) || te.isInline(t, O),
          mode: H ? "lowest" : "highest",
          always: H && (!b || B.length > 0) && (!E || $.length > 0),
          voids: i
        });
        var z = te.pathRef(t, !Q || Q && J ? ce.next(Y) : Y);
        if (Be.insertNodes(t, B, {
          at: z.current,
          match: (O) => ht.isText(O) || te.isInline(t, O),
          mode: "highest",
          voids: i,
          batchDirty: s
        }), w && !B.length && N.length && !$.length && Be.delete(t, {
          at: m,
          voids: i
        }), Be.insertNodes(t, N, {
          at: _.current,
          match: (O) => ft.isElement(O) && te.isBlock(t, O),
          mode: "lowest",
          voids: i,
          batchDirty: s
        }), Be.insertNodes(t, $, {
          at: D.current,
          match: (O) => ht.isText(O) || te.isInline(t, O),
          mode: "highest",
          voids: i,
          batchDirty: s
        }), !r.at) {
          var S;
          if ($.length > 0 && D.current ? S = ce.previous(D.current) : N.length > 0 && _.current ? S = ce.previous(_.current) : z.current && (S = ce.previous(z.current)), S) {
            var W = te.end(t, S);
            Be.select(t, W);
          }
        }
        z.unref(), _.unref(), D.unref();
      }
    }
  });
}, Rue = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    edge: r = "anchor"
  } = n, {
    selection: o
  } = t;
  if (o) {
    if (r === "anchor")
      Be.select(t, o.anchor);
    else if (r === "focus")
      Be.select(t, o.focus);
    else if (r === "start") {
      var [i] = ve.edges(o);
      Be.select(t, i);
    } else if (r === "end") {
      var [, a] = ve.edges(o);
      Be.select(t, a);
    }
  } else return;
}, Iue = (e) => {
  var {
    selection: t
  } = e;
  t && e.apply({
    type: "set_selection",
    properties: t,
    newProperties: null
  });
}, Nue = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    selection: r
  } = t, {
    distance: o = 1,
    unit: i = "character",
    reverse: a = !1
  } = n, {
    edge: s = null
  } = n;
  if (r) {
    s === "start" && (s = ve.isBackward(r) ? "focus" : "anchor"), s === "end" && (s = ve.isBackward(r) ? "anchor" : "focus");
    var {
      anchor: l,
      focus: u
    } = r, c = {
      distance: o,
      unit: i,
      ignoreNonSelectable: !0
    }, p = {};
    if (s == null || s === "anchor") {
      var d = a ? te.before(t, l, c) : te.after(t, l, c);
      d && (p.anchor = d);
    }
    if (s == null || s === "focus") {
      var g = a ? te.before(t, u, c) : te.after(t, u, c);
      g && (p.focus = g);
    }
    Be.setSelection(t, p);
  }
}, Bue = (e, t) => {
  var {
    selection: n
  } = e;
  if (t = te.range(e, t), n) {
    Be.setSelection(e, t);
    return;
  }
  if (!ve.isRange(t))
    throw new Error("When setting the selection and the current selection is `null` you must provide at least an `anchor` and `focus`, but you passed: ".concat(Ko.stringify(t)));
  e.apply({
    type: "set_selection",
    properties: n,
    newProperties: t
  });
};
function EA(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function kA(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? EA(Object(n), !0).forEach(function(r) {
      Mi(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : EA(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Fue = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    selection: o
  } = t, {
    edge: i = "both"
  } = r;
  if (o) {
    i === "start" && (i = ve.isBackward(o) ? "focus" : "anchor"), i === "end" && (i = ve.isBackward(o) ? "anchor" : "focus");
    var {
      anchor: a,
      focus: s
    } = o, l = i === "anchor" ? a : s;
    Be.setSelection(t, {
      [i === "anchor" ? "anchor" : "focus"]: kA(kA({}, l), n)
    });
  }
}, zue = (e, t) => {
  var {
    selection: n
  } = e, r = {}, o = {};
  if (n) {
    for (var i in t)
      (i === "anchor" && t.anchor != null && !$t.equals(t.anchor, n.anchor) || i === "focus" && t.focus != null && !$t.equals(t.focus, n.focus) || i !== "anchor" && i !== "focus" && t[i] !== n[i]) && (r[i] = n[i], o[i] = t[i]);
    Object.keys(r).length > 0 && e.apply({
      type: "set_selection",
      properties: r,
      newProperties: o
    });
  }
}, Uue = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  te.withoutNormalizing(t, () => {
    var {
      hanging: o = !1,
      voids: i = !1,
      mode: a = "lowest",
      batchDirty: s = !0
    } = r, {
      at: l,
      match: u,
      select: c
    } = r;
    if (tt.isNode(n) && (n = [n]), n.length !== 0) {
      var [p] = n;
      if (l || (l = nS(t), c !== !1 && (c = !0)), c == null && (c = !1), ve.isRange(l))
        if (o || (l = te.unhangRange(t, l, {
          voids: i
        })), ve.isCollapsed(l))
          l = l.anchor;
        else {
          var [, d] = ve.edges(l), g = te.pointRef(t, d);
          Be.delete(t, {
            at: l
          }), l = g.unref();
        }
      if ($t.isPoint(l)) {
        u == null && (ht.isText(p) ? u = (B) => ht.isText(B) : t.isInline(p) ? u = (B) => ht.isText(B) || te.isInline(t, B) : u = (B) => ft.isElement(B) && te.isBlock(t, B));
        var [f] = te.nodes(t, {
          at: l.path,
          match: u,
          mode: a,
          voids: i
        });
        if (f) {
          var [, m] = f, b = te.pathRef(t, m), E = te.isEnd(t, l, m);
          Be.splitNodes(t, {
            at: l,
            match: u,
            mode: a,
            voids: i
          });
          var w = b.unref();
          l = E ? ce.next(w) : w;
        } else
          return;
      }
      var M = ce.parent(l), x = l[l.length - 1];
      if (!(!i && te.void(t, {
        at: M
      }))) {
        if (s) {
          var v = [], C = ce.levels(M);
          xle(t, () => {
            var B = function() {
              var V = M.concat(x);
              x++;
              var H = {
                type: "insert_node",
                path: V,
                node: N
              };
              t.apply(H), l = ce.next(l), v.push(H), ht.isText ? C.push(...Array.from(tt.nodes(N), (Z) => {
                var [, K] = Z;
                return V.concat(K);
              })) : C.push(V);
            };
            for (var N of n)
              B();
          }, () => {
            RG(t, C, (B) => {
              var N = B;
              for (var $ of v)
                if (ce.operationCanTransformPath($) && (N = ce.transform(N, $), !N))
                  return null;
              return N;
            });
          });
        } else
          for (var P of n) {
            var F = M.concat(x);
            x++, t.apply({
              type: "insert_node",
              path: F,
              node: P
            }), l = ce.next(l);
          }
        if (l = ce.previous(l), c) {
          var L = te.end(t, l);
          L && Be.select(t, L);
        }
      }
    }
  });
}, Hue = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  te.withoutNormalizing(t, () => {
    var {
      at: r = t.selection,
      mode: o = "lowest",
      voids: i = !1
    } = n, {
      match: a
    } = n;
    if (a == null && (a = ce.isPath(r) ? Mp(t, r) : (x) => ft.isElement(x) && te.isBlock(t, x)), !!r) {
      var s = te.nodes(t, {
        at: r,
        match: a,
        mode: o,
        voids: i
      }), l = Array.from(s, (x) => {
        var [, v] = x;
        return te.pathRef(t, v);
      });
      for (var u of l) {
        var c = u.unref();
        if (c.length < 2)
          throw new Error("Cannot lift node at a path [".concat(c, "] because it has a depth of less than `2`."));
        var p = te.node(t, ce.parent(c)), [d, g] = p, f = c[c.length - 1], {
          length: m
        } = d.children;
        if (m === 1) {
          var b = ce.next(g);
          Be.moveNodes(t, {
            at: c,
            to: b,
            voids: i
          }), Be.removeNodes(t, {
            at: g,
            voids: i
          });
        } else if (f === 0)
          Be.moveNodes(t, {
            at: c,
            to: g,
            voids: i
          });
        else if (f === m - 1) {
          var E = ce.next(g);
          Be.moveNodes(t, {
            at: c,
            to: E,
            voids: i
          });
        } else {
          var w = ce.next(c), M = ce.next(g);
          Be.splitNodes(t, {
            at: w,
            voids: i
          }), Be.moveNodes(t, {
            at: c,
            to: M,
            voids: i
          });
        }
      }
    }
  });
}, Wue = ["text"], $ue = ["children"], IG = (e, t) => {
  if (ft.isElement(t)) {
    var n = t;
    return te.isVoid(e, t) ? !0 : n.children.length === 1 ? IG(e, n.children[0]) : !1;
  } else return !te.isEditor(t);
}, Vue = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  te.withoutNormalizing(t, () => {
    var {
      match: r,
      at: o = t.selection
    } = n, {
      hanging: i = !1,
      voids: a = !1,
      mode: s = "lowest"
    } = n;
    if (o) {
      if (r == null)
        if (ce.isPath(o)) {
          var [l] = te.parent(t, o);
          r = (B) => l.children.includes(B);
        } else
          r = (B) => ft.isElement(B) && te.isBlock(t, B);
      if (!i && ve.isRange(o) && (o = te.unhangRange(t, o, {
        voids: a
      })), ve.isRange(o))
        if (ve.isCollapsed(o))
          o = o.anchor;
        else {
          var [, u] = ve.edges(o), c = te.pointRef(t, u);
          Be.delete(t, {
            at: o
          }), o = c.unref(), n.at == null && Be.select(t, o);
        }
      var [p] = te.nodes(t, {
        at: o,
        match: r,
        voids: a,
        mode: s
      }), d = te.previous(t, {
        at: o,
        match: r,
        voids: a,
        mode: s
      });
      if (!(!p || !d)) {
        var [g, f] = p, [m, b] = d;
        if (!(f.length === 0 || b.length === 0)) {
          var E = ce.next(b), w = ce.common(f, b), M = ce.isSibling(f, b), x = Array.from(te.levels(t, {
            at: f
          }), (B) => {
            var [N] = B;
            return N;
          }).slice(w.length).slice(0, -1), v = te.above(t, {
            at: f,
            mode: "highest",
            match: (B) => x.includes(B) && IG(t, B)
          }), C = v && te.pathRef(t, v[1]), P, F;
          if (ht.isText(g) && ht.isText(m)) {
            var L = Ka(g, Wue);
            F = m.text.length, P = L;
          } else if (ft.isElement(g) && ft.isElement(m)) {
            var L = Ka(g, $ue);
            F = m.children.length, P = L;
          } else
            throw new Error("Cannot merge the node at path [".concat(f, "] with the previous sibling because it is not the same kind: ").concat(Ko.stringify(g), " ").concat(Ko.stringify(m)));
          M || Be.moveNodes(t, {
            at: f,
            to: E,
            voids: a
          }), C && Be.removeNodes(t, {
            at: C.current,
            voids: a
          }), te.shouldMergeNodesRemovePrevNode(t, d, p) ? Be.removeNodes(t, {
            at: b,
            voids: a
          }) : t.apply({
            type: "merge_node",
            path: E,
            position: F,
            properties: P
          }), C && C.unref();
        }
      }
    }
  });
}, Zue = (e, t) => {
  te.withoutNormalizing(e, () => {
    var {
      to: n,
      at: r = e.selection,
      mode: o = "lowest",
      voids: i = !1
    } = t, {
      match: a
    } = t;
    if (r) {
      a == null && (a = ce.isPath(r) ? Mp(e, r) : (g) => ft.isElement(g) && te.isBlock(e, g));
      var s = te.pathRef(e, n), l = te.nodes(e, {
        at: r,
        match: a,
        mode: o,
        voids: i
      }), u = Array.from(l, (g) => {
        var [, f] = g;
        return te.pathRef(e, f);
      });
      for (var c of u) {
        var p = c.unref(), d = s.current;
        p.length !== 0 && e.apply({
          type: "move_node",
          path: p,
          newPath: d
        }), s.current && ce.isSibling(d, p) && ce.isAfter(d, p) && (s.current = ce.next(s.current));
      }
      s.unref();
    }
  });
}, que = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  te.withoutNormalizing(t, () => {
    var {
      hanging: r = !1,
      voids: o = !1,
      mode: i = "lowest"
    } = n, {
      at: a = t.selection,
      match: s
    } = n;
    if (a) {
      s == null && (s = ce.isPath(a) ? Mp(t, a) : (g) => ft.isElement(g) && te.isBlock(t, g)), !r && ve.isRange(a) && (a = te.unhangRange(t, a, {
        voids: o
      }));
      var l = te.nodes(t, {
        at: a,
        match: s,
        mode: i,
        voids: o
      }), u = Array.from(l, (g) => {
        var [, f] = g;
        return te.pathRef(t, f);
      });
      for (var c of u) {
        var p = c.unref();
        if (p) {
          var [d] = te.node(t, p);
          t.apply({
            type: "remove_node",
            path: p,
            node: d
          });
        }
      }
    }
  });
}, Gue = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  te.withoutNormalizing(t, () => {
    var {
      match: o,
      at: i = t.selection,
      compare: a,
      merge: s
    } = r, {
      hanging: l = !1,
      mode: u = "lowest",
      split: c = !1,
      voids: p = !1
    } = r;
    if (i) {
      if (o == null && (o = ce.isPath(i) ? Mp(t, i) : (F) => ft.isElement(F) && te.isBlock(t, F)), !l && ve.isRange(i) && (i = te.unhangRange(t, i, {
        voids: p
      })), c && ve.isRange(i)) {
        if (ve.isCollapsed(i) && te.leaf(t, i.anchor)[0].text.length > 0)
          return;
        var d = te.rangeRef(t, i, {
          affinity: "inward"
        }), [g, f] = ve.edges(i), m = u === "lowest" ? "lowest" : "highest", b = te.isEnd(t, f, f.path);
        Be.splitNodes(t, {
          at: f,
          match: o,
          mode: m,
          voids: p,
          always: !b
        });
        var E = te.isStart(t, g, g.path);
        Be.splitNodes(t, {
          at: g,
          match: o,
          mode: m,
          voids: p,
          always: !E
        }), i = d.unref(), r.at == null && Be.select(t, i);
      }
      a || (a = (F, L) => F !== L);
      for (var [w, M] of te.nodes(t, {
        at: i,
        match: o,
        mode: u,
        voids: p
      })) {
        var x = {}, v = {};
        if (M.length !== 0) {
          var C = !1;
          for (var P in n)
            P === "children" || P === "text" || a(n[P], w[P]) && (C = !0, w.hasOwnProperty(P) && (x[P] = w[P]), s ? n[P] != null && (v[P] = s(w[P], n[P])) : n[P] != null && (v[P] = n[P]));
          C && t.apply({
            type: "set_node",
            path: M,
            properties: x,
            newProperties: v
          });
        }
      }
    }
  });
}, Kue = (e, t) => {
  if (ve.isCollapsed(t))
    return t.anchor;
  var [, n] = ve.edges(t), r = te.pointRef(e, n);
  return Be.delete(e, {
    at: t
  }), r.unref();
}, Xue = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  te.withoutNormalizing(t, () => {
    var {
      mode: r = "lowest",
      voids: o = !1
    } = n, {
      match: i,
      at: a = t.selection,
      height: s = 0,
      always: l = !1
    } = n;
    if (i == null && (i = (J) => ft.isElement(J) && te.isBlock(t, J)), ve.isRange(a) && (a = Kue(t, a)), ce.isPath(a)) {
      var u = a, c = te.point(t, u), [p] = te.parent(t, u);
      i = (J) => J === p, s = c.path.length - u.length + 1, a = c, l = !0;
    }
    if (a) {
      var d = te.pointRef(t, a, {
        affinity: "backward"
      }), g;
      try {
        var [f] = te.nodes(t, {
          at: a,
          match: i,
          mode: r,
          voids: o
        });
        if (!f)
          return;
        var m = te.void(t, {
          at: a,
          mode: "highest"
        }), b = 0;
        if (!o && m) {
          var [E, w] = m;
          if (ft.isElement(E) && t.isInline(E)) {
            var M = te.after(t, w);
            if (!M) {
              var x = {
                text: ""
              }, v = ce.next(w);
              Be.insertNodes(t, x, {
                at: v,
                voids: o
              }), M = te.point(t, v);
            }
            a = M, l = !0;
          }
          var C = a.path.length - w.length;
          s = C + 1, l = !0;
        }
        g = te.pointRef(t, a);
        var P = a.path.length - s, [, F] = f, L = a.path.slice(0, P), B = s === 0 ? a.offset : a.path[P] + b;
        for (var [N, $] of te.levels(t, {
          at: L,
          reverse: !0,
          voids: o
        })) {
          var V = !1;
          if ($.length < F.length || $.length === 0 || !o && ft.isElement(N) && te.isVoid(t, N))
            break;
          var H = d.current, Z = te.isEnd(t, H, $);
          if (l || !d || !te.isEdge(t, H, $)) {
            V = !0;
            var K = tt.extractProps(N);
            t.apply({
              type: "split_node",
              path: $,
              position: B,
              properties: K
            });
          }
          B = $[$.length - 1] + (V || Z ? 1 : 0);
        }
        if (n.at == null) {
          var Y = g.current || te.end(t, []);
          Be.select(t, Y);
        }
      } finally {
        var Q;
        d.unref(), (Q = g) === null || Q === void 0 || Q.unref();
      }
    }
  });
}, Yue = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Array.isArray(n) || (n = [n]);
  var o = {};
  for (var i of n)
    o[i] = null;
  Be.setNodes(t, o, r);
}, Jue = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  te.withoutNormalizing(t, () => {
    var {
      mode: r = "lowest",
      split: o = !1,
      voids: i = !1
    } = n, {
      at: a = t.selection,
      match: s
    } = n;
    if (a) {
      s == null && (s = ce.isPath(a) ? Mp(t, a) : (g) => ft.isElement(g) && te.isBlock(t, g)), ce.isPath(a) && (a = te.range(t, a));
      var l = ve.isRange(a) ? te.rangeRef(t, a) : null, u = te.nodes(t, {
        at: a,
        match: s,
        mode: r,
        voids: i
      }), c = Array.from(
        u,
        (g) => {
          var [, f] = g;
          return te.pathRef(t, f);
        }
        // unwrapNode will call liftNode which does not support splitting the node when nested.
        // If we do not reverse the order and call it from top to the bottom, it will remove all blocks
        // that wrap target node. So we reverse the order.
      ).reverse(), p = function() {
        var f = d.unref(), [m] = te.node(t, f), b = te.range(t, f);
        o && l && (b = ve.intersection(l.current, b)), Be.liftNodes(t, {
          at: b,
          match: (E) => ft.isAncestor(m) && m.children.includes(E),
          voids: i
        });
      };
      for (var d of c)
        p();
      l && l.unref();
    }
  });
};
function LA(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function _A(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? LA(Object(n), !0).forEach(function(r) {
      Mi(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : LA(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Que = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  te.withoutNormalizing(t, () => {
    var {
      mode: o = "lowest",
      split: i = !1,
      voids: a = !1
    } = r, {
      match: s,
      at: l = t.selection
    } = r;
    if (l) {
      if (s == null && (ce.isPath(l) ? s = Mp(t, l) : t.isInline(n) ? s = (b) => ft.isElement(b) && te.isInline(t, b) || ht.isText(b) : s = (b) => ft.isElement(b) && te.isBlock(t, b)), i && ve.isRange(l)) {
        var [u, c] = ve.edges(l), p = te.rangeRef(t, l, {
          affinity: "inward"
        });
        Be.splitNodes(t, {
          at: c,
          match: s,
          voids: a
        }), Be.splitNodes(t, {
          at: u,
          match: s,
          voids: a
        }), l = p.unref(), r.at == null && Be.select(t, l);
      }
      var d = Array.from(te.nodes(t, {
        at: l,
        match: t.isInline(n) ? (b) => ft.isElement(b) && te.isBlock(t, b) : (b) => te.isEditor(b),
        mode: "lowest",
        voids: a
      })), g = function() {
        var E = ve.isRange(l) ? ve.intersection(l, te.range(t, m)) : l;
        if (!E)
          return 0;
        var w = Array.from(te.nodes(t, {
          at: E,
          match: s,
          mode: o,
          voids: a
        }));
        if (w.length > 0) {
          var [M] = w, x = w[w.length - 1], [, v] = M, [, C] = x;
          if (v.length === 0 && C.length === 0)
            return 0;
          var P = ce.equals(v, C) ? ce.parent(v) : ce.common(v, C), F = te.range(t, v, C), L = te.node(t, P), [B] = L, N = P.length + 1, $ = ce.next(C.slice(0, N)), V = _A(_A({}, n), {}, {
            children: []
          });
          Be.insertNodes(t, V, {
            at: $,
            voids: a
          }), Be.moveNodes(t, {
            at: F,
            match: (H) => ft.isAncestor(B) && B.children.includes(H),
            to: $.concat(0),
            voids: a
          });
        }
      }, f;
      for (var [, m] of d)
        f = g();
    }
  });
}, ece = () => {
  var e = {
    children: [],
    operations: [],
    selection: null,
    marks: null,
    isElementReadOnly: () => !1,
    isInline: () => !1,
    isSelectable: () => !0,
    isVoid: () => !1,
    markableVoid: () => !1,
    onChange: () => {
    },
    // Core
    apply: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Ele(e, ...r);
    },
    // Editor
    addMark: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Mle(e, ...r);
    },
    deleteBackward: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return jle(e, ...r);
    },
    deleteForward: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Ale(e, ...r);
    },
    deleteFragment: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Rle(e, ...r);
    },
    getFragment: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Lle(e, ...r);
    },
    insertBreak: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Zle(e, ...r);
    },
    insertSoftBreak: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Gle(e, ...r);
    },
    insertFragment: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Aue(e, ...r);
    },
    insertNode: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return qle(e, ...r);
    },
    insertText: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Xle(e, ...r);
    },
    normalizeNode: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return _le(e, ...r);
    },
    removeMark: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Lue(e, ...r);
    },
    getDirtyPaths: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return kle(e, ...r);
    },
    shouldNormalize: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Ple(e, ...r);
    },
    // Editor interface
    above: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Sle(e, ...r);
    },
    after: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Dle(e, ...r);
    },
    before: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Tle(e, ...r);
    },
    collapse: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Rue(e, ...r);
    },
    delete: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return jue(e, ...r);
    },
    deselect: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Iue(e, ...r);
    },
    edges: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Ile(e, ...r);
    },
    elementReadOnly: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Nle(e, ...r);
    },
    end: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Ble(e, ...r);
    },
    first: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Fle(e, ...r);
    },
    fragment: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return zle(e, ...r);
    },
    getMarks: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return lue(e, ...r);
    },
    hasBlocks: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Hle(e, ...r);
    },
    hasInlines: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Wle(e, ...r);
    },
    hasPath: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return $le(e, ...r);
    },
    hasTexts: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Vle(e, ...r);
    },
    insertNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Uue(e, ...r);
    },
    isBlock: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Yle(e, ...r);
    },
    isEdge: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Jle(e, ...r);
    },
    isEmpty: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Qle(e, ...r);
    },
    isEnd: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return eue(e, ...r);
    },
    isNormalizing: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return tue(e, ...r);
    },
    isStart: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return nue(e, ...r);
    },
    last: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return rue(e, ...r);
    },
    leaf: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return oue(e, ...r);
    },
    levels: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return iue(e, ...r);
    },
    liftNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Hue(e, ...r);
    },
    mergeNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Vue(e, ...r);
    },
    move: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Nue(e, ...r);
    },
    moveNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Zue(e, ...r);
    },
    next: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return uue(e, ...r);
    },
    node: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return cue(e, ...r);
    },
    nodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return pue(e, ...r);
    },
    normalize: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return due(e, ...r);
    },
    parent: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return fue(e, ...r);
    },
    path: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return mue(e, ...r);
    },
    pathRef: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return hue(e, ...r);
    },
    pathRefs: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return gue(e, ...r);
    },
    point: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return bue(e, ...r);
    },
    pointRef: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return vue(e, ...r);
    },
    pointRefs: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return yue(e, ...r);
    },
    positions: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return wue(e, ...r);
    },
    previous: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Cue(e, ...r);
    },
    range: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Eue(e, ...r);
    },
    rangeRef: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Oue(e, ...r);
    },
    rangeRefs: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return xue(e, ...r);
    },
    removeNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return que(e, ...r);
    },
    select: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Bue(e, ...r);
    },
    setNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Gue(e, ...r);
    },
    setNormalizing: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return _ue(e, ...r);
    },
    setPoint: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Fue(e, ...r);
    },
    setSelection: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return zue(e, ...r);
    },
    splitNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Xue(e, ...r);
    },
    start: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Pue(e, ...r);
    },
    string: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Sue(e, ...r);
    },
    unhangRange: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Mue(e, ...r);
    },
    unsetNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Yue(e, ...r);
    },
    unwrapNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Jue(e, ...r);
    },
    void: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Ule(e, ...r);
    },
    withoutNormalizing: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Due(e, ...r);
    },
    wrapNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Que(e, ...r);
    },
    shouldMergeNodesRemovePrevNode: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Tue(e, ...r);
    }
  };
  return e;
};
const NG = (e) => {
  if (ht.isText(e)) {
    let t = e.text;
    return e.bold && (t = `<strong>${t}</strong>`), e.code && (t = `<code>${t}</code>`), e.italic && (t = `<em>${t}</em>`), e.underline && (t = `<u>${t}</u>`), t;
  }
  if (ft.isElement(e)) {
    const t = e.children.map((r) => NG(r)).join(""), n = e.align || "left";
    switch (e.type) {
      case "image":
        return `<img src="${e.src}" class="align_${n}" />`;
      case "paragraph":
        return `<p class="align_${n}">${t}</p>`;
      case "blockQuote":
        return `<blockquote class="align_${n}">${t}</blockquote>`;
      case "bulletedList":
        return `<ul class="align_${n}">${t}</ul>`;
      case "headingOne":
        return `<h1 class="align_${n}">${t}</h1>`;
      case "headingTwo":
        return `<h2 class="align_${n}">${t}</h2>`;
      case "listItem":
        return `<li class="align_${n}">${t}</li>`;
      case "numberedList":
        return `<ol class="align_${n}">${t}</ol>`;
      default:
        return t;
    }
  }
  return "";
}, Oit = (e) => e.map((t) => NG(t)).join("");
var BG = {}, iS = {}, sS = {}, Yc = {}, aS = {}, lS = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Doctype = e.CDATA = e.Tag = e.Style = e.Script = e.Comment = e.Directive = e.Text = e.Root = e.isTag = e.ElementType = void 0;
  var t;
  (function(r) {
    r.Root = "root", r.Text = "text", r.Directive = "directive", r.Comment = "comment", r.Script = "script", r.Style = "style", r.Tag = "tag", r.CDATA = "cdata", r.Doctype = "doctype";
  })(t = e.ElementType || (e.ElementType = {}));
  function n(r) {
    return r.type === t.Tag || r.type === t.Script || r.type === t.Style;
  }
  e.isTag = n, e.Root = t.Root, e.Text = t.Text, e.Directive = t.Directive, e.Comment = t.Comment, e.Script = t.Script, e.Style = t.Style, e.Tag = t.Tag, e.CDATA = t.CDATA, e.Doctype = t.Doctype;
})(lS);
var Qt = {}, lu = fr && fr.__extends || /* @__PURE__ */ function() {
  var e = function(t, n) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, o) {
      r.__proto__ = o;
    } || function(r, o) {
      for (var i in o) Object.prototype.hasOwnProperty.call(o, i) && (r[i] = o[i]);
    }, e(t, n);
  };
  return function(t, n) {
    if (typeof n != "function" && n !== null)
      throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
    e(t, n);
    function r() {
      this.constructor = t;
    }
    t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
  };
}(), sf = fr && fr.__assign || function() {
  return sf = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) {
      t = arguments[n];
      for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
    }
    return e;
  }, sf.apply(this, arguments);
};
Object.defineProperty(Qt, "__esModule", { value: !0 });
Qt.cloneNode = Qt.hasChildren = Qt.isDocument = Qt.isDirective = Qt.isComment = Qt.isText = Qt.isCDATA = Qt.isTag = Qt.Element = Qt.Document = Qt.CDATA = Qt.NodeWithChildren = Qt.ProcessingInstruction = Qt.Comment = Qt.Text = Qt.DataNode = Qt.Node = void 0;
var Ki = lS, uS = (
  /** @class */
  function() {
    function e() {
      this.parent = null, this.prev = null, this.next = null, this.startIndex = null, this.endIndex = null;
    }
    return Object.defineProperty(e.prototype, "parentNode", {
      // Read-write aliases for properties
      /**
       * Same as {@link parent}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.parent;
      },
      set: function(t) {
        this.parent = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "previousSibling", {
      /**
       * Same as {@link prev}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.prev;
      },
      set: function(t) {
        this.prev = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "nextSibling", {
      /**
       * Same as {@link next}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.next;
      },
      set: function(t) {
        this.next = t;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.cloneNode = function(t) {
      return t === void 0 && (t = !1), cS(this, t);
    }, e;
  }()
);
Qt.Node = uS;
var h0 = (
  /** @class */
  function(e) {
    lu(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.data = n, r;
    }
    return Object.defineProperty(t.prototype, "nodeValue", {
      /**
       * Same as {@link data}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.data;
      },
      set: function(n) {
        this.data = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(uS)
);
Qt.DataNode = h0;
var FG = (
  /** @class */
  function(e) {
    lu(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Ki.ElementType.Text, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 3;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(h0)
);
Qt.Text = FG;
var zG = (
  /** @class */
  function(e) {
    lu(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Ki.ElementType.Comment, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 8;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(h0)
);
Qt.Comment = zG;
var UG = (
  /** @class */
  function(e) {
    lu(t, e);
    function t(n, r) {
      var o = e.call(this, r) || this;
      return o.name = n, o.type = Ki.ElementType.Directive, o;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(h0)
);
Qt.ProcessingInstruction = UG;
var g0 = (
  /** @class */
  function(e) {
    lu(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.children = n, r;
    }
    return Object.defineProperty(t.prototype, "firstChild", {
      // Aliases
      /** First child of the node. */
      get: function() {
        var n;
        return (n = this.children[0]) !== null && n !== void 0 ? n : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "lastChild", {
      /** Last child of the node. */
      get: function() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "childNodes", {
      /**
       * Same as {@link children}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.children;
      },
      set: function(n) {
        this.children = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(uS)
);
Qt.NodeWithChildren = g0;
var HG = (
  /** @class */
  function(e) {
    lu(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Ki.ElementType.CDATA, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 4;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(g0)
);
Qt.CDATA = HG;
var WG = (
  /** @class */
  function(e) {
    lu(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Ki.ElementType.Root, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 9;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(g0)
);
Qt.Document = WG;
var $G = (
  /** @class */
  function(e) {
    lu(t, e);
    function t(n, r, o, i) {
      o === void 0 && (o = []), i === void 0 && (i = n === "script" ? Ki.ElementType.Script : n === "style" ? Ki.ElementType.Style : Ki.ElementType.Tag);
      var a = e.call(this, o) || this;
      return a.name = n, a.attribs = r, a.type = i, a;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "tagName", {
      // DOM Level 1 aliases
      /**
       * Same as {@link name}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.name;
      },
      set: function(n) {
        this.name = n;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "attributes", {
      get: function() {
        var n = this;
        return Object.keys(this.attribs).map(function(r) {
          var o, i;
          return {
            name: r,
            value: n.attribs[r],
            namespace: (o = n["x-attribsNamespace"]) === null || o === void 0 ? void 0 : o[r],
            prefix: (i = n["x-attribsPrefix"]) === null || i === void 0 ? void 0 : i[r]
          };
        });
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(g0)
);
Qt.Element = $G;
function VG(e) {
  return (0, Ki.isTag)(e);
}
Qt.isTag = VG;
function ZG(e) {
  return e.type === Ki.ElementType.CDATA;
}
Qt.isCDATA = ZG;
function qG(e) {
  return e.type === Ki.ElementType.Text;
}
Qt.isText = qG;
function GG(e) {
  return e.type === Ki.ElementType.Comment;
}
Qt.isComment = GG;
function KG(e) {
  return e.type === Ki.ElementType.Directive;
}
Qt.isDirective = KG;
function XG(e) {
  return e.type === Ki.ElementType.Root;
}
Qt.isDocument = XG;
function tce(e) {
  return Object.prototype.hasOwnProperty.call(e, "children");
}
Qt.hasChildren = tce;
function cS(e, t) {
  t === void 0 && (t = !1);
  var n;
  if (qG(e))
    n = new FG(e.data);
  else if (GG(e))
    n = new zG(e.data);
  else if (VG(e)) {
    var r = t ? fx(e.children) : [], o = new $G(e.name, sf({}, e.attribs), r);
    r.forEach(function(l) {
      return l.parent = o;
    }), e.namespace != null && (o.namespace = e.namespace), e["x-attribsNamespace"] && (o["x-attribsNamespace"] = sf({}, e["x-attribsNamespace"])), e["x-attribsPrefix"] && (o["x-attribsPrefix"] = sf({}, e["x-attribsPrefix"])), n = o;
  } else if (ZG(e)) {
    var r = t ? fx(e.children) : [], i = new HG(r);
    r.forEach(function(u) {
      return u.parent = i;
    }), n = i;
  } else if (XG(e)) {
    var r = t ? fx(e.children) : [], a = new WG(r);
    r.forEach(function(u) {
      return u.parent = a;
    }), e["x-mode"] && (a["x-mode"] = e["x-mode"]), n = a;
  } else if (KG(e)) {
    var s = new UG(e.name, e.data);
    e["x-name"] != null && (s["x-name"] = e["x-name"], s["x-publicId"] = e["x-publicId"], s["x-systemId"] = e["x-systemId"]), n = s;
  } else
    throw new Error("Not implemented yet: ".concat(e.type));
  return n.startIndex = e.startIndex, n.endIndex = e.endIndex, e.sourceCodeLocation != null && (n.sourceCodeLocation = e.sourceCodeLocation), n;
}
Qt.cloneNode = cS;
function fx(e) {
  for (var t = e.map(function(r) {
    return cS(r, !0);
  }), n = 1; n < t.length; n++)
    t[n].prev = t[n - 1], t[n - 1].next = t[n];
  return t;
}
(function(e) {
  var t = fr && fr.__createBinding || (Object.create ? function(s, l, u, c) {
    c === void 0 && (c = u);
    var p = Object.getOwnPropertyDescriptor(l, u);
    (!p || ("get" in p ? !l.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
      return l[u];
    } }), Object.defineProperty(s, c, p);
  } : function(s, l, u, c) {
    c === void 0 && (c = u), s[c] = l[u];
  }), n = fr && fr.__exportStar || function(s, l) {
    for (var u in s) u !== "default" && !Object.prototype.hasOwnProperty.call(l, u) && t(l, s, u);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.DomHandler = void 0;
  var r = lS, o = Qt;
  n(Qt, e);
  var i = {
    withStartIndices: !1,
    withEndIndices: !1,
    xmlMode: !1
  }, a = (
    /** @class */
    function() {
      function s(l, u, c) {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null, typeof u == "function" && (c = u, u = i), typeof l == "object" && (u = l, l = void 0), this.callback = l ?? null, this.options = u ?? i, this.elementCB = c ?? null;
      }
      return s.prototype.onparserinit = function(l) {
        this.parser = l;
      }, s.prototype.onreset = function() {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null;
      }, s.prototype.onend = function() {
        this.done || (this.done = !0, this.parser = null, this.handleCallback(null));
      }, s.prototype.onerror = function(l) {
        this.handleCallback(l);
      }, s.prototype.onclosetag = function() {
        this.lastNode = null;
        var l = this.tagStack.pop();
        this.options.withEndIndices && (l.endIndex = this.parser.endIndex), this.elementCB && this.elementCB(l);
      }, s.prototype.onopentag = function(l, u) {
        var c = this.options.xmlMode ? r.ElementType.Tag : void 0, p = new o.Element(l, u, void 0, c);
        this.addNode(p), this.tagStack.push(p);
      }, s.prototype.ontext = function(l) {
        var u = this.lastNode;
        if (u && u.type === r.ElementType.Text)
          u.data += l, this.options.withEndIndices && (u.endIndex = this.parser.endIndex);
        else {
          var c = new o.Text(l);
          this.addNode(c), this.lastNode = c;
        }
      }, s.prototype.oncomment = function(l) {
        if (this.lastNode && this.lastNode.type === r.ElementType.Comment) {
          this.lastNode.data += l;
          return;
        }
        var u = new o.Comment(l);
        this.addNode(u), this.lastNode = u;
      }, s.prototype.oncommentend = function() {
        this.lastNode = null;
      }, s.prototype.oncdatastart = function() {
        var l = new o.Text(""), u = new o.CDATA([l]);
        this.addNode(u), l.parent = u, this.lastNode = l;
      }, s.prototype.oncdataend = function() {
        this.lastNode = null;
      }, s.prototype.onprocessinginstruction = function(l, u) {
        var c = new o.ProcessingInstruction(l, u);
        this.addNode(c);
      }, s.prototype.handleCallback = function(l) {
        if (typeof this.callback == "function")
          this.callback(l, this.dom);
        else if (l)
          throw l;
      }, s.prototype.addNode = function(l) {
        var u = this.tagStack[this.tagStack.length - 1], c = u.children[u.children.length - 1];
        this.options.withStartIndices && (l.startIndex = this.parser.startIndex), this.options.withEndIndices && (l.endIndex = this.parser.endIndex), u.children.push(l), c && (l.prev = c, c.next = l), l.parent = u, this.lastNode = null;
      }, s;
    }()
  );
  e.DomHandler = a, e.default = a;
})(aS);
var YG = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CARRIAGE_RETURN_PLACEHOLDER_REGEX = e.CARRIAGE_RETURN_PLACEHOLDER = e.CARRIAGE_RETURN_REGEX = e.CARRIAGE_RETURN = e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES = void 0, e.CASE_SENSITIVE_TAG_NAMES = [
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "linearGradient",
    "radialGradient",
    "textPath"
  ], e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES.reduce(function(t, n) {
    return t[n.toLowerCase()] = n, t;
  }, {}), e.CARRIAGE_RETURN = "\r", e.CARRIAGE_RETURN_REGEX = new RegExp(e.CARRIAGE_RETURN, "g"), e.CARRIAGE_RETURN_PLACEHOLDER = "__HTML_DOM_PARSER_CARRIAGE_RETURN_PLACEHOLDER_".concat(Date.now(), "__"), e.CARRIAGE_RETURN_PLACEHOLDER_REGEX = new RegExp(e.CARRIAGE_RETURN_PLACEHOLDER, "g");
})(YG);
Object.defineProperty(Yc, "__esModule", { value: !0 });
Yc.formatAttributes = JG;
Yc.escapeSpecialCharacters = oce;
Yc.revertEscapedCharacters = QG;
Yc.formatDOM = eK;
var Jg = aS, Vf = YG;
function nce(e) {
  return Vf.CASE_SENSITIVE_TAG_NAMES_MAP[e];
}
function JG(e) {
  for (var t = {}, n = 0, r = e.length; n < r; n++) {
    var o = e[n];
    t[o.name] = o.value;
  }
  return t;
}
function rce(e) {
  e = e.toLowerCase();
  var t = nce(e);
  return t || e;
}
function oce(e) {
  return e.replace(Vf.CARRIAGE_RETURN_REGEX, Vf.CARRIAGE_RETURN_PLACEHOLDER);
}
function QG(e) {
  return e.replace(Vf.CARRIAGE_RETURN_PLACEHOLDER_REGEX, Vf.CARRIAGE_RETURN);
}
function eK(e, t, n) {
  t === void 0 && (t = null);
  for (var r = [], o, i = 0, a = e.length; i < a; i++) {
    var s = e[i];
    switch (s.nodeType) {
      case 1: {
        var l = rce(s.nodeName);
        o = new Jg.Element(l, JG(s.attributes)), o.children = eK(
          // template children are on content
          l === "template" ? s.content.childNodes : s.childNodes,
          o
        );
        break;
      }
      case 3:
        o = new Jg.Text(QG(s.nodeValue));
        break;
      case 8:
        o = new Jg.Comment(s.nodeValue);
        break;
      default:
        continue;
    }
    var u = r[i - 1] || null;
    u && (u.next = o), o.parent = t, o.prev = u, o.next = null, r.push(o);
  }
  return n && (o = new Jg.ProcessingInstruction(n.substring(0, n.indexOf(" ")).toLowerCase(), n), o.next = r[0] || null, o.parent = t, r.unshift(o), r[1] && (r[1].prev = r[0])), r;
}
Object.defineProperty(sS, "__esModule", { value: !0 });
sS.default = uce;
var ice = Yc, PA = "html", SA = "head", Qg = "body", sce = /<([a-zA-Z]+[0-9]?)/, MA = /<head[^]*>/i, DA = /<body[^]*>/i, Vy = function(e, t) {
  throw new Error("This browser does not support `document.implementation.createHTMLDocument`");
}, a1 = function(e, t) {
  throw new Error("This browser does not support `DOMParser.prototype.parseFromString`");
}, TA = typeof window == "object" && window.DOMParser;
if (typeof TA == "function") {
  var ace = new TA(), lce = "text/html";
  a1 = function(e, t) {
    return t && (e = "<".concat(t, ">").concat(e, "</").concat(t, ">")), ace.parseFromString(e, lce);
  }, Vy = a1;
}
if (typeof document == "object" && document.implementation) {
  var em = document.implementation.createHTMLDocument();
  Vy = function(e, t) {
    if (t) {
      var n = em.documentElement.querySelector(t);
      return n && (n.innerHTML = e), em;
    }
    return em.documentElement.innerHTML = e, em;
  };
}
var tm = typeof document == "object" && document.createElement("template"), l1;
tm && tm.content && (l1 = function(e) {
  return tm.innerHTML = e, tm.content.childNodes;
});
function uce(e) {
  var t, n;
  e = (0, ice.escapeSpecialCharacters)(e);
  var r = e.match(sce), o = r && r[1] ? r[1].toLowerCase() : "";
  switch (o) {
    case PA: {
      var i = a1(e);
      if (!MA.test(e)) {
        var a = i.querySelector(SA);
        (t = a == null ? void 0 : a.parentNode) === null || t === void 0 || t.removeChild(a);
      }
      if (!DA.test(e)) {
        var a = i.querySelector(Qg);
        (n = a == null ? void 0 : a.parentNode) === null || n === void 0 || n.removeChild(a);
      }
      return i.querySelectorAll(PA);
    }
    case SA:
    case Qg: {
      var s = Vy(e).querySelectorAll(o);
      return DA.test(e) && MA.test(e) ? s[0].parentNode.childNodes : s;
    }
    default: {
      if (l1)
        return l1(e);
      var a = Vy(e, Qg).querySelector(Qg);
      return a.childNodes;
    }
  }
}
var cce = fr && fr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(iS, "__esModule", { value: !0 });
iS.default = hce;
var pce = cce(sS), dce = Yc, fce = /<(![a-zA-Z\s]+)>/;
function hce(e) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e)
    return [];
  var t = e.match(fce), n = t ? t[1] : void 0;
  return (0, dce.formatDOM)((0, pce.default)(e), null, n);
}
var m0 = {}, Vs = {}, v0 = {}, gce = 0;
v0.SAME = gce;
var mce = 1;
v0.CAMELCASE = mce;
v0.possibleStandardNames = {
  accept: 0,
  acceptCharset: 1,
  "accept-charset": "acceptCharset",
  accessKey: 1,
  action: 0,
  allowFullScreen: 1,
  alt: 0,
  as: 0,
  async: 0,
  autoCapitalize: 1,
  autoComplete: 1,
  autoCorrect: 1,
  autoFocus: 1,
  autoPlay: 1,
  autoSave: 1,
  capture: 0,
  cellPadding: 1,
  cellSpacing: 1,
  challenge: 0,
  charSet: 1,
  checked: 0,
  children: 0,
  cite: 0,
  class: "className",
  classID: 1,
  className: 1,
  cols: 0,
  colSpan: 1,
  content: 0,
  contentEditable: 1,
  contextMenu: 1,
  controls: 0,
  controlsList: 1,
  coords: 0,
  crossOrigin: 1,
  dangerouslySetInnerHTML: 1,
  data: 0,
  dateTime: 1,
  default: 0,
  defaultChecked: 1,
  defaultValue: 1,
  defer: 0,
  dir: 0,
  disabled: 0,
  disablePictureInPicture: 1,
  disableRemotePlayback: 1,
  download: 0,
  draggable: 0,
  encType: 1,
  enterKeyHint: 1,
  for: "htmlFor",
  form: 0,
  formMethod: 1,
  formAction: 1,
  formEncType: 1,
  formNoValidate: 1,
  formTarget: 1,
  frameBorder: 1,
  headers: 0,
  height: 0,
  hidden: 0,
  high: 0,
  href: 0,
  hrefLang: 1,
  htmlFor: 1,
  httpEquiv: 1,
  "http-equiv": "httpEquiv",
  icon: 0,
  id: 0,
  innerHTML: 1,
  inputMode: 1,
  integrity: 0,
  is: 0,
  itemID: 1,
  itemProp: 1,
  itemRef: 1,
  itemScope: 1,
  itemType: 1,
  keyParams: 1,
  keyType: 1,
  kind: 0,
  label: 0,
  lang: 0,
  list: 0,
  loop: 0,
  low: 0,
  manifest: 0,
  marginWidth: 1,
  marginHeight: 1,
  max: 0,
  maxLength: 1,
  media: 0,
  mediaGroup: 1,
  method: 0,
  min: 0,
  minLength: 1,
  multiple: 0,
  muted: 0,
  name: 0,
  noModule: 1,
  nonce: 0,
  noValidate: 1,
  open: 0,
  optimum: 0,
  pattern: 0,
  placeholder: 0,
  playsInline: 1,
  poster: 0,
  preload: 0,
  profile: 0,
  radioGroup: 1,
  readOnly: 1,
  referrerPolicy: 1,
  rel: 0,
  required: 0,
  reversed: 0,
  role: 0,
  rows: 0,
  rowSpan: 1,
  sandbox: 0,
  scope: 0,
  scoped: 0,
  scrolling: 0,
  seamless: 0,
  selected: 0,
  shape: 0,
  size: 0,
  sizes: 0,
  span: 0,
  spellCheck: 1,
  src: 0,
  srcDoc: 1,
  srcLang: 1,
  srcSet: 1,
  start: 0,
  step: 0,
  style: 0,
  summary: 0,
  tabIndex: 1,
  target: 0,
  title: 0,
  type: 0,
  useMap: 1,
  value: 0,
  width: 0,
  wmode: 0,
  wrap: 0,
  about: 0,
  accentHeight: 1,
  "accent-height": "accentHeight",
  accumulate: 0,
  additive: 0,
  alignmentBaseline: 1,
  "alignment-baseline": "alignmentBaseline",
  allowReorder: 1,
  alphabetic: 0,
  amplitude: 0,
  arabicForm: 1,
  "arabic-form": "arabicForm",
  ascent: 0,
  attributeName: 1,
  attributeType: 1,
  autoReverse: 1,
  azimuth: 0,
  baseFrequency: 1,
  baselineShift: 1,
  "baseline-shift": "baselineShift",
  baseProfile: 1,
  bbox: 0,
  begin: 0,
  bias: 0,
  by: 0,
  calcMode: 1,
  capHeight: 1,
  "cap-height": "capHeight",
  clip: 0,
  clipPath: 1,
  "clip-path": "clipPath",
  clipPathUnits: 1,
  clipRule: 1,
  "clip-rule": "clipRule",
  color: 0,
  colorInterpolation: 1,
  "color-interpolation": "colorInterpolation",
  colorInterpolationFilters: 1,
  "color-interpolation-filters": "colorInterpolationFilters",
  colorProfile: 1,
  "color-profile": "colorProfile",
  colorRendering: 1,
  "color-rendering": "colorRendering",
  contentScriptType: 1,
  contentStyleType: 1,
  cursor: 0,
  cx: 0,
  cy: 0,
  d: 0,
  datatype: 0,
  decelerate: 0,
  descent: 0,
  diffuseConstant: 1,
  direction: 0,
  display: 0,
  divisor: 0,
  dominantBaseline: 1,
  "dominant-baseline": "dominantBaseline",
  dur: 0,
  dx: 0,
  dy: 0,
  edgeMode: 1,
  elevation: 0,
  enableBackground: 1,
  "enable-background": "enableBackground",
  end: 0,
  exponent: 0,
  externalResourcesRequired: 1,
  fill: 0,
  fillOpacity: 1,
  "fill-opacity": "fillOpacity",
  fillRule: 1,
  "fill-rule": "fillRule",
  filter: 0,
  filterRes: 1,
  filterUnits: 1,
  floodOpacity: 1,
  "flood-opacity": "floodOpacity",
  floodColor: 1,
  "flood-color": "floodColor",
  focusable: 0,
  fontFamily: 1,
  "font-family": "fontFamily",
  fontSize: 1,
  "font-size": "fontSize",
  fontSizeAdjust: 1,
  "font-size-adjust": "fontSizeAdjust",
  fontStretch: 1,
  "font-stretch": "fontStretch",
  fontStyle: 1,
  "font-style": "fontStyle",
  fontVariant: 1,
  "font-variant": "fontVariant",
  fontWeight: 1,
  "font-weight": "fontWeight",
  format: 0,
  from: 0,
  fx: 0,
  fy: 0,
  g1: 0,
  g2: 0,
  glyphName: 1,
  "glyph-name": "glyphName",
  glyphOrientationHorizontal: 1,
  "glyph-orientation-horizontal": "glyphOrientationHorizontal",
  glyphOrientationVertical: 1,
  "glyph-orientation-vertical": "glyphOrientationVertical",
  glyphRef: 1,
  gradientTransform: 1,
  gradientUnits: 1,
  hanging: 0,
  horizAdvX: 1,
  "horiz-adv-x": "horizAdvX",
  horizOriginX: 1,
  "horiz-origin-x": "horizOriginX",
  ideographic: 0,
  imageRendering: 1,
  "image-rendering": "imageRendering",
  in2: 0,
  in: 0,
  inlist: 0,
  intercept: 0,
  k1: 0,
  k2: 0,
  k3: 0,
  k4: 0,
  k: 0,
  kernelMatrix: 1,
  kernelUnitLength: 1,
  kerning: 0,
  keyPoints: 1,
  keySplines: 1,
  keyTimes: 1,
  lengthAdjust: 1,
  letterSpacing: 1,
  "letter-spacing": "letterSpacing",
  lightingColor: 1,
  "lighting-color": "lightingColor",
  limitingConeAngle: 1,
  local: 0,
  markerEnd: 1,
  "marker-end": "markerEnd",
  markerHeight: 1,
  markerMid: 1,
  "marker-mid": "markerMid",
  markerStart: 1,
  "marker-start": "markerStart",
  markerUnits: 1,
  markerWidth: 1,
  mask: 0,
  maskContentUnits: 1,
  maskUnits: 1,
  mathematical: 0,
  mode: 0,
  numOctaves: 1,
  offset: 0,
  opacity: 0,
  operator: 0,
  order: 0,
  orient: 0,
  orientation: 0,
  origin: 0,
  overflow: 0,
  overlinePosition: 1,
  "overline-position": "overlinePosition",
  overlineThickness: 1,
  "overline-thickness": "overlineThickness",
  paintOrder: 1,
  "paint-order": "paintOrder",
  panose1: 0,
  "panose-1": "panose1",
  pathLength: 1,
  patternContentUnits: 1,
  patternTransform: 1,
  patternUnits: 1,
  pointerEvents: 1,
  "pointer-events": "pointerEvents",
  points: 0,
  pointsAtX: 1,
  pointsAtY: 1,
  pointsAtZ: 1,
  prefix: 0,
  preserveAlpha: 1,
  preserveAspectRatio: 1,
  primitiveUnits: 1,
  property: 0,
  r: 0,
  radius: 0,
  refX: 1,
  refY: 1,
  renderingIntent: 1,
  "rendering-intent": "renderingIntent",
  repeatCount: 1,
  repeatDur: 1,
  requiredExtensions: 1,
  requiredFeatures: 1,
  resource: 0,
  restart: 0,
  result: 0,
  results: 0,
  rotate: 0,
  rx: 0,
  ry: 0,
  scale: 0,
  security: 0,
  seed: 0,
  shapeRendering: 1,
  "shape-rendering": "shapeRendering",
  slope: 0,
  spacing: 0,
  specularConstant: 1,
  specularExponent: 1,
  speed: 0,
  spreadMethod: 1,
  startOffset: 1,
  stdDeviation: 1,
  stemh: 0,
  stemv: 0,
  stitchTiles: 1,
  stopColor: 1,
  "stop-color": "stopColor",
  stopOpacity: 1,
  "stop-opacity": "stopOpacity",
  strikethroughPosition: 1,
  "strikethrough-position": "strikethroughPosition",
  strikethroughThickness: 1,
  "strikethrough-thickness": "strikethroughThickness",
  string: 0,
  stroke: 0,
  strokeDasharray: 1,
  "stroke-dasharray": "strokeDasharray",
  strokeDashoffset: 1,
  "stroke-dashoffset": "strokeDashoffset",
  strokeLinecap: 1,
  "stroke-linecap": "strokeLinecap",
  strokeLinejoin: 1,
  "stroke-linejoin": "strokeLinejoin",
  strokeMiterlimit: 1,
  "stroke-miterlimit": "strokeMiterlimit",
  strokeWidth: 1,
  "stroke-width": "strokeWidth",
  strokeOpacity: 1,
  "stroke-opacity": "strokeOpacity",
  suppressContentEditableWarning: 1,
  suppressHydrationWarning: 1,
  surfaceScale: 1,
  systemLanguage: 1,
  tableValues: 1,
  targetX: 1,
  targetY: 1,
  textAnchor: 1,
  "text-anchor": "textAnchor",
  textDecoration: 1,
  "text-decoration": "textDecoration",
  textLength: 1,
  textRendering: 1,
  "text-rendering": "textRendering",
  to: 0,
  transform: 0,
  typeof: 0,
  u1: 0,
  u2: 0,
  underlinePosition: 1,
  "underline-position": "underlinePosition",
  underlineThickness: 1,
  "underline-thickness": "underlineThickness",
  unicode: 0,
  unicodeBidi: 1,
  "unicode-bidi": "unicodeBidi",
  unicodeRange: 1,
  "unicode-range": "unicodeRange",
  unitsPerEm: 1,
  "units-per-em": "unitsPerEm",
  unselectable: 0,
  vAlphabetic: 1,
  "v-alphabetic": "vAlphabetic",
  values: 0,
  vectorEffect: 1,
  "vector-effect": "vectorEffect",
  version: 0,
  vertAdvY: 1,
  "vert-adv-y": "vertAdvY",
  vertOriginX: 1,
  "vert-origin-x": "vertOriginX",
  vertOriginY: 1,
  "vert-origin-y": "vertOriginY",
  vHanging: 1,
  "v-hanging": "vHanging",
  vIdeographic: 1,
  "v-ideographic": "vIdeographic",
  viewBox: 1,
  viewTarget: 1,
  visibility: 0,
  vMathematical: 1,
  "v-mathematical": "vMathematical",
  vocab: 0,
  widths: 0,
  wordSpacing: 1,
  "word-spacing": "wordSpacing",
  writingMode: 1,
  "writing-mode": "writingMode",
  x1: 0,
  x2: 0,
  x: 0,
  xChannelSelector: 1,
  xHeight: 1,
  "x-height": "xHeight",
  xlinkActuate: 1,
  "xlink:actuate": "xlinkActuate",
  xlinkArcrole: 1,
  "xlink:arcrole": "xlinkArcrole",
  xlinkHref: 1,
  "xlink:href": "xlinkHref",
  xlinkRole: 1,
  "xlink:role": "xlinkRole",
  xlinkShow: 1,
  "xlink:show": "xlinkShow",
  xlinkTitle: 1,
  "xlink:title": "xlinkTitle",
  xlinkType: 1,
  "xlink:type": "xlinkType",
  xmlBase: 1,
  "xml:base": "xmlBase",
  xmlLang: 1,
  "xml:lang": "xmlLang",
  xmlns: 0,
  "xml:space": "xmlSpace",
  xmlnsXlink: 1,
  "xmlns:xlink": "xmlnsXlink",
  xmlSpace: 1,
  y1: 0,
  y2: 0,
  y: 0,
  yChannelSelector: 1,
  z: 0,
  zoomAndPan: 1
};
const tK = 0, uu = 1, y0 = 2, b0 = 3, pS = 4, nK = 5, rK = 6;
function vce(e) {
  return ri.hasOwnProperty(e) ? ri[e] : null;
}
function Di(e, t, n, r, o, i, a) {
  this.acceptsBooleans = t === y0 || t === b0 || t === pS, this.attributeName = r, this.attributeNamespace = o, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = i, this.removeEmptyString = a;
}
const ri = {}, yce = [
  "children",
  "dangerouslySetInnerHTML",
  // TODO: This prevents the assignment of defaultValue to regular
  // elements (not just inputs). Now that ReactDOMInput assigns to the
  // defaultValue property -- do we need this?
  "defaultValue",
  "defaultChecked",
  "innerHTML",
  "suppressContentEditableWarning",
  "suppressHydrationWarning",
  "style"
];
yce.forEach((e) => {
  ri[e] = new Di(
    e,
    tK,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"]
].forEach(([e, t]) => {
  ri[e] = new Di(
    e,
    uu,
    !1,
    // mustUseProperty
    t,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["contentEditable", "draggable", "spellCheck", "value"].forEach((e) => {
  ri[e] = new Di(
    e,
    y0,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha"
].forEach((e) => {
  ri[e] = new Di(
    e,
    y0,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "allowFullScreen",
  "async",
  // Note: there is a special case that prevents it from being written to the DOM
  // on the client side because the browsers are inconsistent. Instead we call focus().
  "autoFocus",
  "autoPlay",
  "controls",
  "default",
  "defer",
  "disabled",
  "disablePictureInPicture",
  "disableRemotePlayback",
  "formNoValidate",
  "hidden",
  "loop",
  "noModule",
  "noValidate",
  "open",
  "playsInline",
  "readOnly",
  "required",
  "reversed",
  "scoped",
  "seamless",
  // Microdata
  "itemScope"
].forEach((e) => {
  ri[e] = new Di(
    e,
    b0,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "checked",
  // Note: `option.selected` is not updated if `select.multiple` is
  // disabled with `removeAttribute`. We have special logic for handling this.
  "multiple",
  "muted",
  "selected"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  ri[e] = new Di(
    e,
    b0,
    !0,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "capture",
  "download"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  ri[e] = new Di(
    e,
    pS,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "cols",
  "rows",
  "size",
  "span"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  ri[e] = new Di(
    e,
    rK,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["rowSpan", "start"].forEach((e) => {
  ri[e] = new Di(
    e,
    nK,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const dS = /[\-\:]([a-z])/g, fS = (e) => e[1].toUpperCase();
[
  "accent-height",
  "alignment-baseline",
  "arabic-form",
  "baseline-shift",
  "cap-height",
  "clip-path",
  "clip-rule",
  "color-interpolation",
  "color-interpolation-filters",
  "color-profile",
  "color-rendering",
  "dominant-baseline",
  "enable-background",
  "fill-opacity",
  "fill-rule",
  "flood-color",
  "flood-opacity",
  "font-family",
  "font-size",
  "font-size-adjust",
  "font-stretch",
  "font-style",
  "font-variant",
  "font-weight",
  "glyph-name",
  "glyph-orientation-horizontal",
  "glyph-orientation-vertical",
  "horiz-adv-x",
  "horiz-origin-x",
  "image-rendering",
  "letter-spacing",
  "lighting-color",
  "marker-end",
  "marker-mid",
  "marker-start",
  "overline-position",
  "overline-thickness",
  "paint-order",
  "panose-1",
  "pointer-events",
  "rendering-intent",
  "shape-rendering",
  "stop-color",
  "stop-opacity",
  "strikethrough-position",
  "strikethrough-thickness",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "text-anchor",
  "text-decoration",
  "text-rendering",
  "underline-position",
  "underline-thickness",
  "unicode-bidi",
  "unicode-range",
  "units-per-em",
  "v-alphabetic",
  "v-hanging",
  "v-ideographic",
  "v-mathematical",
  "vector-effect",
  "vert-adv-y",
  "vert-origin-x",
  "vert-origin-y",
  "word-spacing",
  "writing-mode",
  "xmlns:xlink",
  "x-height"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(dS, fS);
  ri[t] = new Di(
    t,
    uu,
    !1,
    // mustUseProperty
    e,
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xlink:actuate",
  "xlink:arcrole",
  "xlink:role",
  "xlink:show",
  "xlink:title",
  "xlink:type"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(dS, fS);
  ri[t] = new Di(
    t,
    uu,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/1999/xlink",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xml:base",
  "xml:lang",
  "xml:space"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(dS, fS);
  ri[t] = new Di(
    t,
    uu,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/XML/1998/namespace",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["tabIndex", "crossOrigin"].forEach((e) => {
  ri[e] = new Di(
    e,
    uu,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const bce = "xlinkHref";
ri[bce] = new Di(
  "xlinkHref",
  uu,
  !1,
  // mustUseProperty
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  // sanitizeURL
  !1
  // removeEmptyString
);
["src", "href", "action", "formAction"].forEach((e) => {
  ri[e] = new Di(
    e,
    uu,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !0,
    // sanitizeURL
    !0
    // removeEmptyString
  );
});
const {
  CAMELCASE: wce,
  SAME: Cce,
  possibleStandardNames: jA
} = v0, Oce = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", xce = Oce + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", Ece = RegExp.prototype.test.bind(
  // eslint-disable-next-line no-misleading-character-class
  new RegExp("^(data|aria)-[" + xce + "]*$")
), kce = Object.keys(
  jA
).reduce((e, t) => {
  const n = jA[t];
  return n === Cce ? e[t] = t : n === wce ? e[t.toLowerCase()] = t : e[t] = n, e;
}, {});
Vs.BOOLEAN = b0;
Vs.BOOLEANISH_STRING = y0;
Vs.NUMERIC = nK;
Vs.OVERLOADED_BOOLEAN = pS;
Vs.POSITIVE_NUMERIC = rK;
Vs.RESERVED = tK;
Vs.STRING = uu;
Vs.getPropertyInfo = vce;
Vs.isCustomAttribute = Ece;
Vs.possibleStandardNames = kce;
var hS = {}, gS = {}, AA = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, Lce = /\n/g, _ce = /^\s*/, Pce = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, Sce = /^:\s*/, Mce = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, Dce = /^[;\s]*/, Tce = /^\s+|\s+$/g, jce = `
`, RA = "/", IA = "*", ic = "", Ace = "comment", Rce = "declaration", Ice = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e) return [];
  t = t || {};
  var n = 1, r = 1;
  function o(f) {
    var m = f.match(Lce);
    m && (n += m.length);
    var b = f.lastIndexOf(jce);
    r = ~b ? f.length - b : r + f.length;
  }
  function i() {
    var f = { line: n, column: r };
    return function(m) {
      return m.position = new a(f), u(), m;
    };
  }
  function a(f) {
    this.start = f, this.end = { line: n, column: r }, this.source = t.source;
  }
  a.prototype.content = e;
  function s(f) {
    var m = new Error(
      t.source + ":" + n + ":" + r + ": " + f
    );
    if (m.reason = f, m.filename = t.source, m.line = n, m.column = r, m.source = e, !t.silent) throw m;
  }
  function l(f) {
    var m = f.exec(e);
    if (m) {
      var b = m[0];
      return o(b), e = e.slice(b.length), m;
    }
  }
  function u() {
    l(_ce);
  }
  function c(f) {
    var m;
    for (f = f || []; m = p(); )
      m !== !1 && f.push(m);
    return f;
  }
  function p() {
    var f = i();
    if (!(RA != e.charAt(0) || IA != e.charAt(1))) {
      for (var m = 2; ic != e.charAt(m) && (IA != e.charAt(m) || RA != e.charAt(m + 1)); )
        ++m;
      if (m += 2, ic === e.charAt(m - 1))
        return s("End of comment missing");
      var b = e.slice(2, m - 2);
      return r += 2, o(b), e = e.slice(m), r += 2, f({
        type: Ace,
        comment: b
      });
    }
  }
  function d() {
    var f = i(), m = l(Pce);
    if (m) {
      if (p(), !l(Sce)) return s("property missing ':'");
      var b = l(Mce), E = f({
        type: Rce,
        property: NA(m[0].replace(AA, ic)),
        value: b ? NA(b[0].replace(AA, ic)) : ic
      });
      return l(Dce), E;
    }
  }
  function g() {
    var f = [];
    c(f);
    for (var m; m = d(); )
      m !== !1 && (f.push(m), c(f));
    return f;
  }
  return u(), g();
};
function NA(e) {
  return e ? e.replace(Tce, ic) : ic;
}
var Nce = fr && fr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(gS, "__esModule", { value: !0 });
gS.default = Fce;
var Bce = Nce(Ice);
function Fce(e, t) {
  var n = null;
  if (!e || typeof e != "string")
    return n;
  var r = (0, Bce.default)(e), o = typeof t == "function";
  return r.forEach(function(i) {
    if (i.type === "declaration") {
      var a = i.property, s = i.value;
      o ? t(a, s, i) : s && (n = n || {}, n[a] = s);
    }
  }), n;
}
var w0 = {};
Object.defineProperty(w0, "__esModule", { value: !0 });
w0.camelCase = void 0;
var zce = /^--[a-zA-Z0-9_-]+$/, Uce = /-([a-z])/g, Hce = /^[^-]+$/, Wce = /^-(webkit|moz|ms|o|khtml)-/, $ce = /^-(ms)-/, Vce = function(e) {
  return !e || Hce.test(e) || zce.test(e);
}, Zce = function(e, t) {
  return t.toUpperCase();
}, BA = function(e, t) {
  return "".concat(t, "-");
}, qce = function(e, t) {
  return t === void 0 && (t = {}), Vce(e) ? e : (e = e.toLowerCase(), t.reactCompat ? e = e.replace($ce, BA) : e = e.replace(Wce, BA), e.replace(Uce, Zce));
};
w0.camelCase = qce;
var Gce = fr && fr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
}, Kce = Gce(gS), Xce = w0;
function u1(e, t) {
  var n = {};
  return !e || typeof e != "string" || (0, Kce.default)(e, function(r, o) {
    r && o && (n[(0, Xce.camelCase)(r, t)] = o);
  }), n;
}
u1.default = u1;
var Yce = u1;
(function(e) {
  var t = fr && fr.__importDefault || function(c) {
    return c && c.__esModule ? c : { default: c };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.returnFirstArg = e.canTextBeChildOfNode = e.ELEMENTS_WITH_NO_TEXT_CHILDREN = e.PRESERVE_CUSTOM_ATTRIBUTES = void 0, e.isCustomComponent = i, e.setStyleProp = s;
  var n = be, r = t(Yce), o = /* @__PURE__ */ new Set([
    "annotation-xml",
    "color-profile",
    "font-face",
    "font-face-src",
    "font-face-uri",
    "font-face-format",
    "font-face-name",
    "missing-glyph"
  ]);
  function i(c, p) {
    return c.includes("-") ? !o.has(c) : !!(p && typeof p.is == "string");
  }
  var a = {
    reactCompat: !0
  };
  function s(c, p) {
    if (typeof c == "string") {
      if (!c.trim()) {
        p.style = {};
        return;
      }
      try {
        p.style = (0, r.default)(c, a);
      } catch {
        p.style = {};
      }
    }
  }
  e.PRESERVE_CUSTOM_ATTRIBUTES = Number(n.version.split(".")[0]) >= 16, e.ELEMENTS_WITH_NO_TEXT_CHILDREN = /* @__PURE__ */ new Set([
    "tr",
    "tbody",
    "thead",
    "tfoot",
    "colgroup",
    "table",
    "head",
    "html",
    "frameset"
  ]);
  var l = function(c) {
    return !e.ELEMENTS_WITH_NO_TEXT_CHILDREN.has(c.name);
  };
  e.canTextBeChildOfNode = l;
  var u = function(c) {
    return c;
  };
  e.returnFirstArg = u;
})(hS);
Object.defineProperty(m0, "__esModule", { value: !0 });
m0.default = tpe;
var Wd = Vs, FA = hS, Jce = ["checked", "value"], Qce = ["input", "select", "textarea"], epe = {
  reset: !0,
  submit: !0
};
function tpe(e, t) {
  e === void 0 && (e = {});
  var n = {}, r = !!(e.type && epe[e.type]);
  for (var o in e) {
    var i = e[o];
    if ((0, Wd.isCustomAttribute)(o)) {
      n[o] = i;
      continue;
    }
    var a = o.toLowerCase(), s = zA(a);
    if (s) {
      var l = (0, Wd.getPropertyInfo)(s);
      switch (Jce.includes(s) && Qce.includes(t) && !r && (s = zA("default" + a)), n[s] = i, l && l.type) {
        case Wd.BOOLEAN:
          n[s] = !0;
          break;
        case Wd.OVERLOADED_BOOLEAN:
          i === "" && (n[s] = !0);
          break;
      }
      continue;
    }
    FA.PRESERVE_CUSTOM_ATTRIBUTES && (n[o] = i);
  }
  return (0, FA.setStyleProp)(e.style, n), n;
}
function zA(e) {
  return Wd.possibleStandardNames[e];
}
var mS = {}, npe = fr && fr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(mS, "__esModule", { value: !0 });
mS.default = oK;
var hx = be, rpe = npe(m0), af = hS, ope = {
  cloneElement: hx.cloneElement,
  createElement: hx.createElement,
  isValidElement: hx.isValidElement
};
function oK(e, t) {
  t === void 0 && (t = {});
  for (var n = [], r = typeof t.replace == "function", o = t.transform || af.returnFirstArg, i = t.library || ope, a = i.cloneElement, s = i.createElement, l = i.isValidElement, u = e.length, c = 0; c < u; c++) {
    var p = e[c];
    if (r) {
      var d = t.replace(p, c);
      if (l(d)) {
        u > 1 && (d = a(d, {
          key: d.key || c
        })), n.push(o(d, p, c));
        continue;
      }
    }
    if (p.type === "text") {
      var g = !p.data.trim().length;
      if (g && p.parent && !(0, af.canTextBeChildOfNode)(p.parent) || t.trim && g)
        continue;
      n.push(o(p.data, p, c));
      continue;
    }
    var f = p, m = {};
    ipe(f) ? ((0, af.setStyleProp)(f.attribs.style, f.attribs), m = f.attribs) : f.attribs && (m = (0, rpe.default)(f.attribs, f.name));
    var b = void 0;
    switch (p.type) {
      case "script":
      case "style":
        p.children[0] && (m.dangerouslySetInnerHTML = {
          __html: p.children[0].data
        });
        break;
      case "tag":
        p.name === "textarea" && p.children[0] ? m.defaultValue = p.children[0].data : p.children && p.children.length && (b = oK(p.children, t));
        break;
      default:
        continue;
    }
    u > 1 && (m.key = c), n.push(o(s(p.name, m, b), p, c));
  }
  return n.length === 1 ? n[0] : n;
}
function ipe(e) {
  return af.PRESERVE_CUSTOM_ATTRIBUTES && e.type === "tag" && (0, af.isCustomComponent)(e.name, e.attribs);
}
(function(e) {
  var t = fr && fr.__importDefault || function(l) {
    return l && l.__esModule ? l : { default: l };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.htmlToDOM = e.domToReact = e.attributesToProps = e.Text = e.ProcessingInstruction = e.Element = e.Comment = void 0, e.default = s;
  var n = t(iS);
  e.htmlToDOM = n.default;
  var r = t(m0);
  e.attributesToProps = r.default;
  var o = t(mS);
  e.domToReact = o.default;
  var i = aS;
  Object.defineProperty(e, "Comment", { enumerable: !0, get: function() {
    return i.Comment;
  } }), Object.defineProperty(e, "Element", { enumerable: !0, get: function() {
    return i.Element;
  } }), Object.defineProperty(e, "ProcessingInstruction", { enumerable: !0, get: function() {
    return i.ProcessingInstruction;
  } }), Object.defineProperty(e, "Text", { enumerable: !0, get: function() {
    return i.Text;
  } });
  var a = { lowerCaseAttributeNames: !1 };
  function s(l, u) {
    if (typeof l != "string")
      throw new TypeError("First argument must be a string");
    return l ? (0, o.default)((0, n.default)(l, (u == null ? void 0 : u.htmlparser2) || a), u) : [];
  }
})(BG);
const UA = /* @__PURE__ */ u0(BG), spe = UA.default || UA, c1 = (e) => {
  var r;
  if (typeof e == "string")
    return { text: e };
  const t = Array.isArray(e.props.children) ? e.props.children.map((o) => c1(o)) : [{ text: e.props.children || "" }], n = (r = e.props.className) == null ? void 0 : r.replace("align_", "");
  switch (e.type) {
    case "img":
      return {
        type: "image",
        align: n,
        src: e.props.src,
        children: [{ text: "" }]
      };
    case "p":
      return { type: "paragraph", align: n, children: t };
    case "blockquote":
      return { type: "blockQuote", align: n, children: t };
    case "ul":
      return { type: "bulletedList", align: n, children: t };
    case "ol":
      return { type: "numberedList", align: n, children: t };
    case "li":
      return { type: "listItem", align: n, children: t };
    case "h1":
      return { type: "headingOne", align: n, children: t };
    case "h2":
      return { type: "headingTwo", align: n, children: t };
    case "strong":
      return { text: e.props.children, bold: !0 };
    case "code":
      return { text: e.props.children, code: !0 };
    case "em":
      return { text: e.props.children, italic: !0 };
    case "u":
      return { text: e.props.children, underline: !0 };
    default:
      return { text: e.props.children || "" };
  }
}, xit = (e) => {
  const t = spe(e);
  return Array.isArray(t) ? t.map((n) => typeof n == "string" ? { text: n } : c1(n)) : typeof t == "string" ? [{ text: t }] : [c1(t)];
}, Eit = (e) => /<\/?[a-z][\s\S]*>/i.test(e);
function iK(e, t, n) {
  if (!e) return /* @__PURE__ */ ee.jsx(ee.Fragment, {});
  if (typeof e == "string") return /* @__PURE__ */ ee.jsx("p", { className: n, children: e });
  const r = e;
  return /* @__PURE__ */ ee.jsx("p", { className: n, children: /* @__PURE__ */ ee.jsx(r, { color: "var(--secondary-600)", size: t, strokeWidth: 2.5 }) });
}
function kit(e) {
  const {
    variant: t = "ghost",
    scheme: n = "primary",
    size: r = "md",
    leftIcon: o,
    rightIcon: i,
    className: a = "",
    children: s,
    ...l
  } = e, c = { md: 12, lg: 14 }[r], p = `arkynBadge ${t} ${n} ${r} ${a}`;
  return /* @__PURE__ */ ee.jsxs("div", { className: p.trim(), ...l, children: [
    Fy(c, o),
    s,
    Fy(c, i)
  ] });
}
function Lit(e) {
  const { className: t, ...n } = e, r = `arkynCard ${t}`;
  return /* @__PURE__ */ ee.jsx("div", { className: r.trim(), ...n });
}
function sK(e) {
  const {
    className: t,
    orientation: n = "horizontal",
    ...r
  } = e, o = `arkynDivider ${n} ${t}`;
  return /* @__PURE__ */ ee.jsx("div", { className: o.trim(), ...r });
}
function _it(e) {
  const { className: t, ...n } = e, r = `arkynSkeleton ${t}`;
  return /* @__PURE__ */ ee.jsx("aside", { className: r.trim(), ...n });
}
function Pit(e) {
  const {
    emptyMessage: t = "Nenhum dado adicionado.",
    className: n,
    children: r,
    ...o
  } = e, i = `arkynTableBody ${n}`, a = at.count(r) === 0;
  return /* @__PURE__ */ ee.jsx("tbody", { className: i.trim(), ...o, children: a ? /* @__PURE__ */ ee.jsx("tr", { className: "arkynTableBodyEmptyLine", children: /* @__PURE__ */ ee.jsx("td", { colSpan: 100, children: /* @__PURE__ */ ee.jsx("div", { children: t }) }) }) : r });
}
function Sit(e) {
  const { className: t, children: n, ...r } = e, o = `arkynTableCaption ${t}`;
  return /* @__PURE__ */ ee.jsx("caption", { className: o.trim(), ...r, children: /* @__PURE__ */ ee.jsx("div", { className: "arkynTableCaptionContent", children: n }) });
}
function Mit(e) {
  const { children: t, className: n, ...r } = e, o = `arkynTableContainer ${n}`;
  return /* @__PURE__ */ ee.jsx("div", { className: o.trim(), ...r, children: /* @__PURE__ */ ee.jsx("table", { children: t }) });
}
function Dit(e) {
  const { className: t, children: n, ...r } = e, o = `arkynTableFooter ${t}`;
  return /* @__PURE__ */ ee.jsxs("tfoot", { className: o.trim(), ...r, children: [
    /* @__PURE__ */ ee.jsx("tr", { className: "spacingRow" }),
    /* @__PURE__ */ ee.jsx("tr", { children: /* @__PURE__ */ ee.jsx("th", { colSpan: 100, children: /* @__PURE__ */ ee.jsx("div", { className: "arkynTableFooterContent", children: n }) }) })
  ] });
}
function Tit(e) {
  const { className: t, children: n, ...r } = e, o = `arkynTableHeader ${t}`;
  return /* @__PURE__ */ ee.jsxs("thead", { className: o.trim(), ...r, children: [
    /* @__PURE__ */ ee.jsx("tr", { children: n }),
    /* @__PURE__ */ ee.jsx("tr", { className: "spacingRow" })
  ] });
}
var hr = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function ape(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var p1 = { exports: {} }, rd = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var HA;
function lpe() {
  if (HA) return rd;
  HA = 1;
  var e = be, t = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, o = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, i = { key: !0, ref: !0, __self: !0, __source: !0 };
  function a(s, l, u) {
    var c, p = {}, d = null, g = null;
    u !== void 0 && (d = "" + u), l.key !== void 0 && (d = "" + l.key), l.ref !== void 0 && (g = l.ref);
    for (c in l) r.call(l, c) && !i.hasOwnProperty(c) && (p[c] = l[c]);
    if (s && s.defaultProps) for (c in l = s.defaultProps, l) p[c] === void 0 && (p[c] = l[c]);
    return { $$typeof: t, type: s, key: d, ref: g, props: p, _owner: o.current };
  }
  return rd.Fragment = n, rd.jsx = a, rd.jsxs = a, rd;
}
var nm = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var WA;
function upe() {
  return WA || (WA = 1, process.env.NODE_ENV !== "production" && function() {
    var e = be, t = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), a = Symbol.for("react.provider"), s = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), c = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), d = Symbol.for("react.lazy"), g = Symbol.for("react.offscreen"), f = Symbol.iterator, m = "@@iterator";
    function b(y) {
      if (y === null || typeof y != "object")
        return null;
      var R = f && y[f] || y[m];
      return typeof R == "function" ? R : null;
    }
    var E = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function w(y) {
      {
        for (var R = arguments.length, G = new Array(R > 1 ? R - 1 : 0), ne = 1; ne < R; ne++)
          G[ne - 1] = arguments[ne];
        M("error", y, G);
      }
    }
    function M(y, R, G) {
      {
        var ne = E.ReactDebugCurrentFrame, ae = ne.getStackAddendum();
        ae !== "" && (R += "%s", G = G.concat([ae]));
        var ue = G.map(function(se) {
          return String(se);
        });
        ue.unshift("Warning: " + R), Function.prototype.apply.call(console[y], console, ue);
      }
    }
    var x = !1, v = !1, C = !1, P = !1, F = !1, L;
    L = Symbol.for("react.module.reference");
    function B(y) {
      return !!(typeof y == "string" || typeof y == "function" || y === r || y === i || F || y === o || y === u || y === c || P || y === g || x || v || C || typeof y == "object" && y !== null && (y.$$typeof === d || y.$$typeof === p || y.$$typeof === a || y.$$typeof === s || y.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      y.$$typeof === L || y.getModuleId !== void 0));
    }
    function N(y, R, G) {
      var ne = y.displayName;
      if (ne)
        return ne;
      var ae = R.displayName || R.name || "";
      return ae !== "" ? G + "(" + ae + ")" : G;
    }
    function $(y) {
      return y.displayName || "Context";
    }
    function V(y) {
      if (y == null)
        return null;
      if (typeof y.tag == "number" && w("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof y == "function")
        return y.displayName || y.name || null;
      if (typeof y == "string")
        return y;
      switch (y) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case i:
          return "Profiler";
        case o:
          return "StrictMode";
        case u:
          return "Suspense";
        case c:
          return "SuspenseList";
      }
      if (typeof y == "object")
        switch (y.$$typeof) {
          case s:
            var R = y;
            return $(R) + ".Consumer";
          case a:
            var G = y;
            return $(G._context) + ".Provider";
          case l:
            return N(y, y.render, "ForwardRef");
          case p:
            var ne = y.displayName || null;
            return ne !== null ? ne : V(y.type) || "Memo";
          case d: {
            var ae = y, ue = ae._payload, se = ae._init;
            try {
              return V(se(ue));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var H = Object.assign, Z = 0, K, Y, Q, J, _, D, z;
    function S() {
    }
    S.__reactDisabledLog = !0;
    function W() {
      {
        if (Z === 0) {
          K = console.log, Y = console.info, Q = console.warn, J = console.error, _ = console.group, D = console.groupCollapsed, z = console.groupEnd;
          var y = {
            configurable: !0,
            enumerable: !0,
            value: S,
            writable: !0
          };
          Object.defineProperties(console, {
            info: y,
            log: y,
            warn: y,
            error: y,
            group: y,
            groupCollapsed: y,
            groupEnd: y
          });
        }
        Z++;
      }
    }
    function O() {
      {
        if (Z--, Z === 0) {
          var y = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: H({}, y, {
              value: K
            }),
            info: H({}, y, {
              value: Y
            }),
            warn: H({}, y, {
              value: Q
            }),
            error: H({}, y, {
              value: J
            }),
            group: H({}, y, {
              value: _
            }),
            groupCollapsed: H({}, y, {
              value: D
            }),
            groupEnd: H({}, y, {
              value: z
            })
          });
        }
        Z < 0 && w("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var j = E.ReactCurrentDispatcher, U;
    function T(y, R, G) {
      {
        if (U === void 0)
          try {
            throw Error();
          } catch (ae) {
            var ne = ae.stack.trim().match(/\n( *(at )?)/);
            U = ne && ne[1] || "";
          }
        return `
` + U + y;
      }
    }
    var q = !1, A;
    {
      var X = typeof WeakMap == "function" ? WeakMap : Map;
      A = new X();
    }
    function I(y, R) {
      if (!y || q)
        return "";
      {
        var G = A.get(y);
        if (G !== void 0)
          return G;
      }
      var ne;
      q = !0;
      var ae = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var ue;
      ue = j.current, j.current = null, W();
      try {
        if (R) {
          var se = function() {
            throw Error();
          };
          if (Object.defineProperty(se.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(se, []);
            } catch (je) {
              ne = je;
            }
            Reflect.construct(y, [], se);
          } else {
            try {
              se.call();
            } catch (je) {
              ne = je;
            }
            y.call(se.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (je) {
            ne = je;
          }
          y();
        }
      } catch (je) {
        if (je && ne && typeof je.stack == "string") {
          for (var ie = je.stack.split(`
`), Oe = ne.stack.split(`
`), de = ie.length - 1, fe = Oe.length - 1; de >= 1 && fe >= 0 && ie[de] !== Oe[fe]; )
            fe--;
          for (; de >= 1 && fe >= 0; de--, fe--)
            if (ie[de] !== Oe[fe]) {
              if (de !== 1 || fe !== 1)
                do
                  if (de--, fe--, fe < 0 || ie[de] !== Oe[fe]) {
                    var ze = `
` + ie[de].replace(" at new ", " at ");
                    return y.displayName && ze.includes("<anonymous>") && (ze = ze.replace("<anonymous>", y.displayName)), typeof y == "function" && A.set(y, ze), ze;
                  }
                while (de >= 1 && fe >= 0);
              break;
            }
        }
      } finally {
        q = !1, j.current = ue, O(), Error.prepareStackTrace = ae;
      }
      var Et = y ? y.displayName || y.name : "", bt = Et ? T(Et) : "";
      return typeof y == "function" && A.set(y, bt), bt;
    }
    function le(y, R, G) {
      return I(y, !1);
    }
    function he(y) {
      var R = y.prototype;
      return !!(R && R.isReactComponent);
    }
    function oe(y, R, G) {
      if (y == null)
        return "";
      if (typeof y == "function")
        return I(y, he(y));
      if (typeof y == "string")
        return T(y);
      switch (y) {
        case u:
          return T("Suspense");
        case c:
          return T("SuspenseList");
      }
      if (typeof y == "object")
        switch (y.$$typeof) {
          case l:
            return le(y.render);
          case p:
            return oe(y.type, R, G);
          case d: {
            var ne = y, ae = ne._payload, ue = ne._init;
            try {
              return oe(ue(ae), R, G);
            } catch {
            }
          }
        }
      return "";
    }
    var Ae = Object.prototype.hasOwnProperty, Ue = {}, He = E.ReactDebugCurrentFrame;
    function Re(y) {
      if (y) {
        var R = y._owner, G = oe(y.type, y._source, R ? R.type : null);
        He.setExtraStackFrame(G);
      } else
        He.setExtraStackFrame(null);
    }
    function nt(y, R, G, ne, ae) {
      {
        var ue = Function.call.bind(Ae);
        for (var se in y)
          if (ue(y, se)) {
            var ie = void 0;
            try {
              if (typeof y[se] != "function") {
                var Oe = Error((ne || "React class") + ": " + G + " type `" + se + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof y[se] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw Oe.name = "Invariant Violation", Oe;
              }
              ie = y[se](R, se, ne, G, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (de) {
              ie = de;
            }
            ie && !(ie instanceof Error) && (Re(ae), w("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", ne || "React class", G, se, typeof ie), Re(null)), ie instanceof Error && !(ie.message in Ue) && (Ue[ie.message] = !0, Re(ae), w("Failed %s type: %s", G, ie.message), Re(null));
          }
      }
    }
    var Ve = Array.isArray;
    function we(y) {
      return Ve(y);
    }
    function et(y) {
      {
        var R = typeof Symbol == "function" && Symbol.toStringTag, G = R && y[Symbol.toStringTag] || y.constructor.name || "Object";
        return G;
      }
    }
    function lt(y) {
      try {
        return ye(y), !1;
      } catch {
        return !0;
      }
    }
    function ye(y) {
      return "" + y;
    }
    function ke(y) {
      if (lt(y))
        return w("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", et(y)), ye(y);
    }
    var Qe = E.ReactCurrentOwner, Fe = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, Ie, ot;
    function Ee(y) {
      if (Ae.call(y, "ref")) {
        var R = Object.getOwnPropertyDescriptor(y, "ref").get;
        if (R && R.isReactWarning)
          return !1;
      }
      return y.ref !== void 0;
    }
    function wt(y) {
      if (Ae.call(y, "key")) {
        var R = Object.getOwnPropertyDescriptor(y, "key").get;
        if (R && R.isReactWarning)
          return !1;
      }
      return y.key !== void 0;
    }
    function it(y, R) {
      typeof y.ref == "string" && Qe.current;
    }
    function st(y, R) {
      {
        var G = function() {
          Ie || (Ie = !0, w("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", R));
        };
        G.isReactWarning = !0, Object.defineProperty(y, "key", {
          get: G,
          configurable: !0
        });
      }
    }
    function ut(y, R) {
      {
        var G = function() {
          ot || (ot = !0, w("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", R));
        };
        G.isReactWarning = !0, Object.defineProperty(y, "ref", {
          get: G,
          configurable: !0
        });
      }
    }
    var Ct = function(y, R, G, ne, ae, ue, se) {
      var ie = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: y,
        key: R,
        ref: G,
        props: se,
        // Record the component responsible for creating this element.
        _owner: ue
      };
      return ie._store = {}, Object.defineProperty(ie._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(ie, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ne
      }), Object.defineProperty(ie, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ae
      }), Object.freeze && (Object.freeze(ie.props), Object.freeze(ie)), ie;
    };
    function ct(y, R, G, ne, ae) {
      {
        var ue, se = {}, ie = null, Oe = null;
        G !== void 0 && (ke(G), ie = "" + G), wt(R) && (ke(R.key), ie = "" + R.key), Ee(R) && (Oe = R.ref, it(R));
        for (ue in R)
          Ae.call(R, ue) && !Fe.hasOwnProperty(ue) && (se[ue] = R[ue]);
        if (y && y.defaultProps) {
          var de = y.defaultProps;
          for (ue in de)
            se[ue] === void 0 && (se[ue] = de[ue]);
        }
        if (ie || Oe) {
          var fe = typeof y == "function" ? y.displayName || y.name || "Unknown" : y;
          ie && st(se, fe), Oe && ut(se, fe);
        }
        return Ct(y, ie, Oe, ae, ne, Qe.current, se);
      }
    }
    var pt = E.ReactCurrentOwner, rt = E.ReactDebugCurrentFrame;
    function We(y) {
      if (y) {
        var R = y._owner, G = oe(y.type, y._source, R ? R.type : null);
        rt.setExtraStackFrame(G);
      } else
        rt.setExtraStackFrame(null);
    }
    var Ot;
    Ot = !1;
    function xt(y) {
      return typeof y == "object" && y !== null && y.$$typeof === t;
    }
    function gt() {
      {
        if (pt.current) {
          var y = V(pt.current.type);
          if (y)
            return `

Check the render method of \`` + y + "`.";
        }
        return "";
      }
    }
    function Ht(y) {
      return "";
    }
    var mt = {};
    function Wt(y) {
      {
        var R = gt();
        if (!R) {
          var G = typeof y == "string" ? y : y.displayName || y.name;
          G && (R = `

Check the top-level render call using <` + G + ">.");
        }
        return R;
      }
    }
    function vt(y, R) {
      {
        if (!y._store || y._store.validated || y.key != null)
          return;
        y._store.validated = !0;
        var G = Wt(R);
        if (mt[G])
          return;
        mt[G] = !0;
        var ne = "";
        y && y._owner && y._owner !== pt.current && (ne = " It was passed a child from " + V(y._owner.type) + "."), We(y), w('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', G, ne), We(null);
      }
    }
    function kt(y, R) {
      {
        if (typeof y != "object")
          return;
        if (we(y))
          for (var G = 0; G < y.length; G++) {
            var ne = y[G];
            xt(ne) && vt(ne, R);
          }
        else if (xt(y))
          y._store && (y._store.validated = !0);
        else if (y) {
          var ae = b(y);
          if (typeof ae == "function" && ae !== y.entries)
            for (var ue = ae.call(y), se; !(se = ue.next()).done; )
              xt(se.value) && vt(se.value, R);
        }
      }
    }
    function Un(y) {
      {
        var R = y.type;
        if (R == null || typeof R == "string")
          return;
        var G;
        if (typeof R == "function")
          G = R.propTypes;
        else if (typeof R == "object" && (R.$$typeof === l || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        R.$$typeof === p))
          G = R.propTypes;
        else
          return;
        if (G) {
          var ne = V(R);
          nt(G, y.props, "prop", ne, y);
        } else if (R.PropTypes !== void 0 && !Ot) {
          Ot = !0;
          var ae = V(R);
          w("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", ae || "Unknown");
        }
        typeof R.getDefaultProps == "function" && !R.getDefaultProps.isReactClassApproved && w("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function yt(y) {
      {
        for (var R = Object.keys(y.props), G = 0; G < R.length; G++) {
          var ne = R[G];
          if (ne !== "children" && ne !== "key") {
            We(y), w("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", ne), We(null);
            break;
          }
        }
        y.ref !== null && (We(y), w("Invalid attribute `ref` supplied to `React.Fragment`."), We(null));
      }
    }
    var re = {};
    function ao(y, R, G, ne, ae, ue) {
      {
        var se = B(y);
        if (!se) {
          var ie = "";
          (y === void 0 || typeof y == "object" && y !== null && Object.keys(y).length === 0) && (ie += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var Oe = Ht();
          Oe ? ie += Oe : ie += gt();
          var de;
          y === null ? de = "null" : we(y) ? de = "array" : y !== void 0 && y.$$typeof === t ? (de = "<" + (V(y.type) || "Unknown") + " />", ie = " Did you accidentally export a JSX literal instead of a component?") : de = typeof y, w("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", de, ie);
        }
        var fe = ct(y, R, G, ae, ue);
        if (fe == null)
          return fe;
        if (se) {
          var ze = R.children;
          if (ze !== void 0)
            if (ne)
              if (we(ze)) {
                for (var Et = 0; Et < ze.length; Et++)
                  kt(ze[Et], y);
                Object.freeze && Object.freeze(ze);
              } else
                w("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              kt(ze, y);
        }
        if (Ae.call(R, "key")) {
          var bt = V(y), je = Object.keys(R).filter(function(Li) {
            return Li !== "key";
          }), Hn = je.length > 0 ? "{key: someKey, " + je.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!re[bt + Hn]) {
            var ki = je.length > 0 ? "{" + je.join(": ..., ") + ": ...}" : "{}";
            w(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, Hn, bt, ki, bt), re[bt + Hn] = !0;
          }
        }
        return y === r ? yt(fe) : Un(fe), fe;
      }
    }
    function Ci(y, R, G) {
      return ao(y, R, G, !0);
    }
    function Oi(y, R, G) {
      return ao(y, R, G, !1);
    }
    var xi = Oi, Ei = Ci;
    nm.Fragment = r, nm.jsx = xi, nm.jsxs = Ei;
  }()), nm;
}
process.env.NODE_ENV === "production" ? p1.exports = lpe() : p1.exports = upe();
var Fn = p1.exports;
$e({});
function $A(e, t) {
  return t ? /* @__PURE__ */ Fn.jsx(t, { size: e, strokeWidth: 2.5 }) : /* @__PURE__ */ Fn.jsx(Fn.Fragment, {});
}
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function VA(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function pi(e) {
  var t, n;
  return VA(e) === !1 ? !1 : (t = e.constructor, t === void 0 ? !0 : (n = t.prototype, !(VA(n) === !1 || n.hasOwnProperty("isPrototypeOf") === !1)));
}
var aK = Symbol.for("immer-nothing"), ZA = Symbol.for("immer-draftable"), ws = Symbol.for("immer-state"), cpe = process.env.NODE_ENV !== "production" ? [
  // All error codes, starting by 0:
  function(e) {
    return `The plugin for '${e}' has not been loaded into Immer. To enable the plugin, import and call \`enable${e}()\` when initializing your application.`;
  },
  function(e) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${e}'`;
  },
  "This object has been frozen and should not be mutated",
  function(e) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + e;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(e) {
    return `'current' expects a draft, got: ${e}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(e) {
    return `'original' expects a draft, got: ${e}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function Hi(e, ...t) {
  if (process.env.NODE_ENV !== "production") {
    const n = cpe[e], r = typeof n == "function" ? n.apply(null, t) : n;
    throw new Error(`[Immer] ${r}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var Cp = Object.getPrototypeOf;
function Mc(e) {
  return !!e && !!e[ws];
}
function Dc(e) {
  var t;
  return e ? lK(e) || Array.isArray(e) || !!e[ZA] || !!((t = e.constructor) != null && t[ZA]) || O0(e) || x0(e) : !1;
}
var ppe = Object.prototype.constructor.toString();
function lK(e) {
  if (!e || typeof e != "object")
    return !1;
  const t = Cp(e);
  if (t === null)
    return !0;
  const n = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
  return n === Object ? !0 : typeof n == "function" && Function.toString.call(n) === ppe;
}
function Zy(e, t) {
  C0(e) === 0 ? Reflect.ownKeys(e).forEach((n) => {
    t(n, e[n], e);
  }) : e.forEach((n, r) => t(r, n, e));
}
function C0(e) {
  const t = e[ws];
  return t ? t.type_ : Array.isArray(e) ? 1 : O0(e) ? 2 : x0(e) ? 3 : 0;
}
function d1(e, t) {
  return C0(e) === 2 ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t);
}
function uK(e, t, n) {
  const r = C0(e);
  r === 2 ? e.set(t, n) : r === 3 ? e.add(n) : e[t] = n;
}
function dpe(e, t) {
  return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && t !== t;
}
function O0(e) {
  return e instanceof Map;
}
function x0(e) {
  return e instanceof Set;
}
function Yu(e) {
  return e.copy_ || e.base_;
}
function f1(e, t) {
  if (O0(e))
    return new Map(e);
  if (x0(e))
    return new Set(e);
  if (Array.isArray(e))
    return Array.prototype.slice.call(e);
  const n = lK(e);
  if (t === !0 || t === "class_only" && !n) {
    const r = Object.getOwnPropertyDescriptors(e);
    delete r[ws];
    let o = Reflect.ownKeys(r);
    for (let i = 0; i < o.length; i++) {
      const a = o[i], s = r[a];
      s.writable === !1 && (s.writable = !0, s.configurable = !0), (s.get || s.set) && (r[a] = {
        configurable: !0,
        writable: !0,
        // could live with !!desc.set as well here...
        enumerable: s.enumerable,
        value: e[a]
      });
    }
    return Object.create(Cp(e), r);
  } else {
    const r = Cp(e);
    if (r !== null && n)
      return { ...e };
    const o = Object.create(r);
    return Object.assign(o, e);
  }
}
function vS(e, t = !1) {
  return E0(e) || Mc(e) || !Dc(e) || (C0(e) > 1 && (e.set = e.add = e.clear = e.delete = fpe), Object.freeze(e), t && Object.entries(e).forEach(([n, r]) => vS(r, !0))), e;
}
function fpe() {
  Hi(2);
}
function E0(e) {
  return Object.isFrozen(e);
}
var hpe = {};
function Tc(e) {
  const t = hpe[e];
  return t || Hi(0, e), t;
}
var Zf;
function cK() {
  return Zf;
}
function gpe(e, t) {
  return {
    drafts_: [],
    parent_: e,
    immer_: t,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0
  };
}
function qA(e, t) {
  t && (Tc("Patches"), e.patches_ = [], e.inversePatches_ = [], e.patchListener_ = t);
}
function h1(e) {
  g1(e), e.drafts_.forEach(mpe), e.drafts_ = null;
}
function g1(e) {
  e === Zf && (Zf = e.parent_);
}
function GA(e) {
  return Zf = gpe(Zf, e);
}
function mpe(e) {
  const t = e[ws];
  t.type_ === 0 || t.type_ === 1 ? t.revoke_() : t.revoked_ = !0;
}
function KA(e, t) {
  t.unfinalizedDrafts_ = t.drafts_.length;
  const n = t.drafts_[0];
  return e !== void 0 && e !== n ? (n[ws].modified_ && (h1(t), Hi(4)), Dc(e) && (e = qy(t, e), t.parent_ || Gy(t, e)), t.patches_ && Tc("Patches").generateReplacementPatches_(
    n[ws].base_,
    e,
    t.patches_,
    t.inversePatches_
  )) : e = qy(t, n, []), h1(t), t.patches_ && t.patchListener_(t.patches_, t.inversePatches_), e !== aK ? e : void 0;
}
function qy(e, t, n) {
  if (E0(t))
    return t;
  const r = t[ws];
  if (!r)
    return Zy(
      t,
      (o, i) => XA(e, r, t, o, i, n)
    ), t;
  if (r.scope_ !== e)
    return t;
  if (!r.modified_)
    return Gy(e, r.base_, !0), r.base_;
  if (!r.finalized_) {
    r.finalized_ = !0, r.scope_.unfinalizedDrafts_--;
    const o = r.copy_;
    let i = o, a = !1;
    r.type_ === 3 && (i = new Set(o), o.clear(), a = !0), Zy(
      i,
      (s, l) => XA(e, r, o, s, l, n, a)
    ), Gy(e, o, !1), n && e.patches_ && Tc("Patches").generatePatches_(
      r,
      n,
      e.patches_,
      e.inversePatches_
    );
  }
  return r.copy_;
}
function XA(e, t, n, r, o, i, a) {
  if (process.env.NODE_ENV !== "production" && o === n && Hi(5), Mc(o)) {
    const s = i && t && t.type_ !== 3 && // Set objects are atomic since they have no keys.
    !d1(t.assigned_, r) ? i.concat(r) : void 0, l = qy(e, o, s);
    if (uK(n, r, l), Mc(l))
      e.canAutoFreeze_ = !1;
    else
      return;
  } else a && n.add(o);
  if (Dc(o) && !E0(o)) {
    if (!e.immer_.autoFreeze_ && e.unfinalizedDrafts_ < 1)
      return;
    qy(e, o), (!t || !t.scope_.parent_) && typeof r != "symbol" && Object.prototype.propertyIsEnumerable.call(n, r) && Gy(e, o);
  }
}
function Gy(e, t, n = !1) {
  !e.parent_ && e.immer_.autoFreeze_ && e.canAutoFreeze_ && vS(t, n);
}
function vpe(e, t) {
  const n = Array.isArray(e), r = {
    type_: n ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: t ? t.scope_ : cK(),
    // True for both shallow and deep changes.
    modified_: !1,
    // Used during finalization.
    finalized_: !1,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: t,
    // The base state.
    base_: e,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: !1
  };
  let o = r, i = yS;
  n && (o = [r], i = qf);
  const { revoke: a, proxy: s } = Proxy.revocable(o, i);
  return r.draft_ = s, r.revoke_ = a, s;
}
var yS = {
  get(e, t) {
    if (t === ws)
      return e;
    const n = Yu(e);
    if (!d1(n, t))
      return ype(e, n, t);
    const r = n[t];
    return e.finalized_ || !Dc(r) ? r : r === gx(e.base_, t) ? (mx(e), e.copy_[t] = v1(r, e)) : r;
  },
  has(e, t) {
    return t in Yu(e);
  },
  ownKeys(e) {
    return Reflect.ownKeys(Yu(e));
  },
  set(e, t, n) {
    const r = pK(Yu(e), t);
    if (r != null && r.set)
      return r.set.call(e.draft_, n), !0;
    if (!e.modified_) {
      const o = gx(Yu(e), t), i = o == null ? void 0 : o[ws];
      if (i && i.base_ === n)
        return e.copy_[t] = n, e.assigned_[t] = !1, !0;
      if (dpe(n, o) && (n !== void 0 || d1(e.base_, t)))
        return !0;
      mx(e), m1(e);
    }
    return e.copy_[t] === n && // special case: handle new props with value 'undefined'
    (n !== void 0 || t in e.copy_) || // special case: NaN
    Number.isNaN(n) && Number.isNaN(e.copy_[t]) || (e.copy_[t] = n, e.assigned_[t] = !0), !0;
  },
  deleteProperty(e, t) {
    return gx(e.base_, t) !== void 0 || t in e.base_ ? (e.assigned_[t] = !1, mx(e), m1(e)) : delete e.assigned_[t], e.copy_ && delete e.copy_[t], !0;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(e, t) {
    const n = Yu(e), r = Reflect.getOwnPropertyDescriptor(n, t);
    return r && {
      writable: !0,
      configurable: e.type_ !== 1 || t !== "length",
      enumerable: r.enumerable,
      value: n[t]
    };
  },
  defineProperty() {
    Hi(11);
  },
  getPrototypeOf(e) {
    return Cp(e.base_);
  },
  setPrototypeOf() {
    Hi(12);
  }
}, qf = {};
Zy(yS, (e, t) => {
  qf[e] = function() {
    return arguments[0] = arguments[0][0], t.apply(this, arguments);
  };
});
qf.deleteProperty = function(e, t) {
  return process.env.NODE_ENV !== "production" && isNaN(parseInt(t)) && Hi(13), qf.set.call(this, e, t, void 0);
};
qf.set = function(e, t, n) {
  return process.env.NODE_ENV !== "production" && t !== "length" && isNaN(parseInt(t)) && Hi(14), yS.set.call(this, e[0], t, n, e[0]);
};
function gx(e, t) {
  const n = e[ws];
  return (n ? Yu(n) : e)[t];
}
function ype(e, t, n) {
  var r;
  const o = pK(t, n);
  return o ? "value" in o ? o.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (r = o.get) == null ? void 0 : r.call(e.draft_)
  ) : void 0;
}
function pK(e, t) {
  if (!(t in e))
    return;
  let n = Cp(e);
  for (; n; ) {
    const r = Object.getOwnPropertyDescriptor(n, t);
    if (r)
      return r;
    n = Cp(n);
  }
}
function m1(e) {
  e.modified_ || (e.modified_ = !0, e.parent_ && m1(e.parent_));
}
function mx(e) {
  e.copy_ || (e.copy_ = f1(
    e.base_,
    e.scope_.immer_.useStrictShallowCopy_
  ));
}
var bpe = class {
  constructor(e) {
    this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.produce = (t, n, r) => {
      if (typeof t == "function" && typeof n != "function") {
        const i = n;
        n = t;
        const a = this;
        return function(s = i, ...l) {
          return a.produce(s, (u) => n.call(this, u, ...l));
        };
      }
      typeof n != "function" && Hi(6), r !== void 0 && typeof r != "function" && Hi(7);
      let o;
      if (Dc(t)) {
        const i = GA(this), a = v1(t, void 0);
        let s = !0;
        try {
          o = n(a), s = !1;
        } finally {
          s ? h1(i) : g1(i);
        }
        return qA(i, r), KA(o, i);
      } else if (!t || typeof t != "object") {
        if (o = n(t), o === void 0 && (o = t), o === aK && (o = void 0), this.autoFreeze_ && vS(o, !0), r) {
          const i = [], a = [];
          Tc("Patches").generateReplacementPatches_(t, o, i, a), r(i, a);
        }
        return o;
      } else
        Hi(1, t);
    }, this.produceWithPatches = (t, n) => {
      if (typeof t == "function")
        return (i, ...a) => this.produceWithPatches(i, (s) => t(s, ...a));
      let r, o;
      return [this.produce(t, n, (i, a) => {
        r = i, o = a;
      }), r, o];
    }, typeof (e == null ? void 0 : e.autoFreeze) == "boolean" && this.setAutoFreeze(e.autoFreeze), typeof (e == null ? void 0 : e.useStrictShallowCopy) == "boolean" && this.setUseStrictShallowCopy(e.useStrictShallowCopy);
  }
  createDraft(e) {
    Dc(e) || Hi(8), Mc(e) && (e = wpe(e));
    const t = GA(this), n = v1(e, void 0);
    return n[ws].isManual_ = !0, g1(t), n;
  }
  finishDraft(e, t) {
    const n = e && e[ws];
    (!n || !n.isManual_) && Hi(9);
    const { scope_: r } = n;
    return qA(r, t), KA(void 0, r);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(e) {
    this.autoFreeze_ = e;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(e) {
    this.useStrictShallowCopy_ = e;
  }
  applyPatches(e, t) {
    let n;
    for (n = t.length - 1; n >= 0; n--) {
      const o = t[n];
      if (o.path.length === 0 && o.op === "replace") {
        e = o.value;
        break;
      }
    }
    n > -1 && (t = t.slice(n + 1));
    const r = Tc("Patches").applyPatches_;
    return Mc(e) ? r(e, t) : this.produce(
      e,
      (o) => r(o, t)
    );
  }
};
function v1(e, t) {
  const n = O0(e) ? Tc("MapSet").proxyMap_(e, t) : x0(e) ? Tc("MapSet").proxySet_(e, t) : vpe(e, t);
  return (t ? t.scope_ : cK()).drafts_.push(n), n;
}
function wpe(e) {
  return Mc(e) || Hi(10, e), dK(e);
}
function dK(e) {
  if (!Dc(e) || E0(e))
    return e;
  const t = e[ws];
  let n;
  if (t) {
    if (!t.modified_)
      return t.base_;
    t.finalized_ = !0, n = f1(e, t.scope_.immer_.useStrictShallowCopy_);
  } else
    n = f1(e, !0);
  return Zy(n, (r, o) => {
    uK(n, r, dK(o));
  }), t && (t.finalized_ = !1), n;
}
var Cs = new bpe(), bS = Cs.produce;
Cs.produceWithPatches.bind(
  Cs
);
Cs.setAutoFreeze.bind(Cs);
Cs.setUseStrictShallowCopy.bind(Cs);
Cs.applyPatches.bind(Cs);
var YA = Cs.createDraft.bind(Cs), JA = Cs.finishDraft.bind(Cs), Ze = {
  ancestors(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = Ze.levels(e, t);
    return n ? r = r.slice(1) : r = r.slice(0, -1), r;
  },
  common(e, t) {
    for (var n = [], r = 0; r < e.length && r < t.length; r++) {
      var o = e[r], i = t[r];
      if (o !== i)
        break;
      n.push(o);
    }
    return n;
  },
  compare(e, t) {
    for (var n = Math.min(e.length, t.length), r = 0; r < n; r++) {
      if (e[r] < t[r]) return -1;
      if (e[r] > t[r]) return 1;
    }
    return 0;
  },
  endsAfter(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return Ze.equals(r, o) && i > a;
  },
  endsAt(e, t) {
    var n = e.length, r = e.slice(0, n), o = t.slice(0, n);
    return Ze.equals(r, o);
  },
  endsBefore(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return Ze.equals(r, o) && i < a;
  },
  equals(e, t) {
    return e.length === t.length && e.every((n, r) => n === t[r]);
  },
  hasPrevious(e) {
    return e[e.length - 1] > 0;
  },
  isAfter(e, t) {
    return Ze.compare(e, t) === 1;
  },
  isAncestor(e, t) {
    return e.length < t.length && Ze.compare(e, t) === 0;
  },
  isBefore(e, t) {
    return Ze.compare(e, t) === -1;
  },
  isChild(e, t) {
    return e.length === t.length + 1 && Ze.compare(e, t) === 0;
  },
  isCommon(e, t) {
    return e.length <= t.length && Ze.compare(e, t) === 0;
  },
  isDescendant(e, t) {
    return e.length > t.length && Ze.compare(e, t) === 0;
  },
  isParent(e, t) {
    return e.length + 1 === t.length && Ze.compare(e, t) === 0;
  },
  isPath(e) {
    return Array.isArray(e) && (e.length === 0 || typeof e[0] == "number");
  },
  isSibling(e, t) {
    if (e.length !== t.length)
      return !1;
    var n = e.slice(0, -1), r = t.slice(0, -1), o = e[e.length - 1], i = t[t.length - 1];
    return o !== i && Ze.equals(n, r);
  },
  levels(e) {
    for (var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = [], o = 0; o <= e.length; o++)
      r.push(e.slice(0, o));
    return n && r.reverse(), r;
  },
  next(e) {
    if (e.length === 0)
      throw new Error("Cannot get the next path of a root path [".concat(e, "], because it has no next index."));
    var t = e[e.length - 1];
    return e.slice(0, -1).concat(t + 1);
  },
  operationCanTransformPath(e) {
    switch (e.type) {
      case "insert_node":
      case "remove_node":
      case "merge_node":
      case "split_node":
      case "move_node":
        return !0;
      default:
        return !1;
    }
  },
  parent(e) {
    if (e.length === 0)
      throw new Error("Cannot get the parent path of the root path [".concat(e, "]."));
    return e.slice(0, -1);
  },
  previous(e) {
    if (e.length === 0)
      throw new Error("Cannot get the previous path of a root path [".concat(e, "], because it has no previous index."));
    var t = e[e.length - 1];
    if (t <= 0)
      throw new Error("Cannot get the previous path of a first child path [".concat(e, "] because it would result in a negative index."));
    return e.slice(0, -1).concat(t - 1);
  },
  relative(e, t) {
    if (!Ze.isAncestor(t, e) && !Ze.equals(e, t))
      throw new Error("Cannot get the relative path of [".concat(e, "] inside ancestor [").concat(t, "], because it is not above or equal to the path."));
    return e.slice(t.length);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!e) return null;
    var r = [...e], {
      affinity: o = "forward"
    } = n;
    if (e.length === 0)
      return r;
    switch (t.type) {
      case "insert_node": {
        var {
          path: i
        } = t;
        (Ze.equals(i, r) || Ze.endsBefore(i, r) || Ze.isAncestor(i, r)) && (r[i.length - 1] += 1);
        break;
      }
      case "remove_node": {
        var {
          path: a
        } = t;
        if (Ze.equals(a, r) || Ze.isAncestor(a, r))
          return null;
        Ze.endsBefore(a, r) && (r[a.length - 1] -= 1);
        break;
      }
      case "merge_node": {
        var {
          path: s,
          position: l
        } = t;
        Ze.equals(s, r) || Ze.endsBefore(s, r) ? r[s.length - 1] -= 1 : Ze.isAncestor(s, r) && (r[s.length - 1] -= 1, r[s.length] += l);
        break;
      }
      case "split_node": {
        var {
          path: u,
          position: c
        } = t;
        if (Ze.equals(u, r)) {
          if (o === "forward")
            r[r.length - 1] += 1;
          else if (o !== "backward") return null;
        } else Ze.endsBefore(u, r) ? r[u.length - 1] += 1 : Ze.isAncestor(u, r) && e[u.length] >= c && (r[u.length - 1] += 1, r[u.length] -= c);
        break;
      }
      case "move_node": {
        var {
          path: p,
          newPath: d
        } = t;
        if (Ze.equals(p, d))
          return r;
        if (Ze.isAncestor(p, r) || Ze.equals(p, r)) {
          var g = d.slice();
          return Ze.endsBefore(p, d) && p.length < d.length && (g[p.length - 1] -= 1), g.concat(r.slice(p.length));
        } else Ze.isSibling(p, d) && (Ze.isAncestor(d, r) || Ze.equals(d, r)) ? Ze.endsBefore(p, r) ? r[p.length - 1] -= 1 : r[p.length - 1] += 1 : Ze.endsBefore(d, r) || Ze.equals(d, r) || Ze.isAncestor(d, r) ? (Ze.endsBefore(p, r) && (r[p.length - 1] -= 1), r[d.length - 1] += 1) : Ze.endsBefore(p, r) && (Ze.equals(d, r) && (r[d.length - 1] += 1), r[p.length - 1] -= 1);
        break;
      }
    }
    return r;
  }
};
function Gf(e) {
  "@babel/helpers - typeof";
  return Gf = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Gf(e);
}
function Cpe(e, t) {
  if (Gf(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (Gf(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function Ope(e) {
  var t = Cpe(e, "string");
  return Gf(t) === "symbol" ? t : String(t);
}
function Dp(e, t, n) {
  return t = Ope(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function QA(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function od(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? QA(Object(n), !0).forEach(function(r) {
      Dp(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : QA(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var xpe = (e, t, n) => {
  switch (n.type) {
    case "insert_node": {
      var {
        path: r,
        node: o
      } = n, i = _t.parent(e, r), a = r[r.length - 1];
      if (a > i.children.length)
        throw new Error('Cannot apply an "insert_node" operation at path ['.concat(r, "] because the destination is past the end of the node."));
      if (i.children.splice(a, 0, o), t)
        for (var [s, l] of Vt.points(t))
          t[l] = Sr.transform(s, n);
      break;
    }
    case "insert_text": {
      var {
        path: u,
        offset: c,
        text: p
      } = n;
      if (p.length === 0) break;
      var d = _t.leaf(e, u), g = d.text.slice(0, c), f = d.text.slice(c);
      if (d.text = g + p + f, t)
        for (var [m, b] of Vt.points(t))
          t[b] = Sr.transform(m, n);
      break;
    }
    case "merge_node": {
      var {
        path: E
      } = n, w = _t.get(e, E), M = Ze.previous(E), x = _t.get(e, M), v = _t.parent(e, E), C = E[E.length - 1];
      if (Lo.isText(w) && Lo.isText(x))
        x.text += w.text;
      else if (!Lo.isText(w) && !Lo.isText(x))
        x.children.push(...w.children);
      else
        throw new Error('Cannot apply a "merge_node" operation at path ['.concat(E, "] to nodes of different interfaces: ").concat(rs.stringify(w), " ").concat(rs.stringify(x)));
      if (v.children.splice(C, 1), t)
        for (var [P, F] of Vt.points(t))
          t[F] = Sr.transform(P, n);
      break;
    }
    case "move_node": {
      var {
        path: L,
        newPath: B
      } = n;
      if (Ze.isAncestor(L, B))
        throw new Error("Cannot move a path [".concat(L, "] to new path [").concat(B, "] because the destination is inside itself."));
      var N = _t.get(e, L), $ = _t.parent(e, L), V = L[L.length - 1];
      $.children.splice(V, 1);
      var H = Ze.transform(L, n), Z = _t.get(e, Ze.parent(H)), K = H[H.length - 1];
      if (Z.children.splice(K, 0, N), t)
        for (var [Y, Q] of Vt.points(t))
          t[Q] = Sr.transform(Y, n);
      break;
    }
    case "remove_node": {
      var {
        path: J
      } = n, _ = J[J.length - 1], D = _t.parent(e, J);
      if (D.children.splice(_, 1), t)
        for (var [z, S] of Vt.points(t)) {
          var W = Sr.transform(z, n);
          if (t != null && W != null)
            t[S] = W;
          else {
            var O = void 0, j = void 0;
            for (var [U, T] of _t.texts(e))
              if (Ze.compare(T, J) === -1)
                O = [U, T];
              else {
                j = [U, T];
                break;
              }
            var q = !1;
            O && j && (Ze.equals(j[1], J) ? q = !Ze.hasPrevious(j[1]) : q = Ze.common(O[1], J).length < Ze.common(j[1], J).length), O && !q ? (z.path = O[1], z.offset = O[0].text.length) : j ? (z.path = j[1], z.offset = 0) : t = null;
          }
        }
      break;
    }
    case "remove_text": {
      var {
        path: A,
        offset: X,
        text: I
      } = n;
      if (I.length === 0) break;
      var le = _t.leaf(e, A), he = le.text.slice(0, X), oe = le.text.slice(X + I.length);
      if (le.text = he + oe, t)
        for (var [Ae, Ue] of Vt.points(t))
          t[Ue] = Sr.transform(Ae, n);
      break;
    }
    case "set_node": {
      var {
        path: He,
        properties: Re,
        newProperties: nt
      } = n;
      if (He.length === 0)
        throw new Error("Cannot set properties on the root node!");
      var Ve = _t.get(e, He);
      for (var we in nt) {
        if (we === "children" || we === "text")
          throw new Error('Cannot set the "'.concat(we, '" property of nodes!'));
        var et = nt[we];
        et == null ? delete Ve[we] : Ve[we] = et;
      }
      for (var lt in Re)
        nt.hasOwnProperty(lt) || delete Ve[lt];
      break;
    }
    case "set_selection": {
      var {
        newProperties: ye
      } = n;
      if (ye == null)
        t = ye;
      else {
        if (t == null) {
          if (!Vt.isRange(ye))
            throw new Error('Cannot apply an incomplete "set_selection" operation properties '.concat(rs.stringify(ye), " when there is no current selection."));
          t = od({}, ye);
        }
        for (var ke in ye) {
          var Qe = ye[ke];
          if (Qe == null) {
            if (ke === "anchor" || ke === "focus")
              throw new Error('Cannot remove the "'.concat(ke, '" selection property'));
            delete t[ke];
          } else
            t[ke] = Qe;
        }
      }
      break;
    }
    case "split_node": {
      var {
        path: Fe,
        position: Ie,
        properties: ot
      } = n;
      if (Fe.length === 0)
        throw new Error('Cannot apply a "split_node" operation at path ['.concat(Fe, "] because the root node cannot be split."));
      var Ee = _t.get(e, Fe), wt = _t.parent(e, Fe), it = Fe[Fe.length - 1], st;
      if (Lo.isText(Ee)) {
        var ut = Ee.text.slice(0, Ie), Ct = Ee.text.slice(Ie);
        Ee.text = ut, st = od(od({}, ot), {}, {
          text: Ct
        });
      } else {
        var ct = Ee.children.slice(0, Ie), pt = Ee.children.slice(Ie);
        Ee.children = ct, st = od(od({}, ot), {}, {
          children: pt
        });
      }
      if (wt.children.splice(it + 1, 0, st), t)
        for (var [rt, We] of Vt.points(t))
          t[We] = Sr.transform(rt, n);
      break;
    }
  }
  return t;
}, Epe = {
  transform(e, t) {
    e.children = YA(e.children);
    var n = e.selection && YA(e.selection);
    try {
      n = xpe(e, n, t);
    } finally {
      e.children = JA(e.children), n ? e.selection = Mc(n) ? JA(n) : n : e.selection = null;
    }
  }
}, kpe = {
  insertNodes(e, t, n) {
    e.insertNodes(t, n);
  },
  liftNodes(e, t) {
    e.liftNodes(t);
  },
  mergeNodes(e, t) {
    e.mergeNodes(t);
  },
  moveNodes(e, t) {
    e.moveNodes(t);
  },
  removeNodes(e, t) {
    e.removeNodes(t);
  },
  setNodes(e, t, n) {
    e.setNodes(t, n);
  },
  splitNodes(e, t) {
    e.splitNodes(t);
  },
  unsetNodes(e, t, n) {
    e.unsetNodes(t, n);
  },
  unwrapNodes(e, t) {
    e.unwrapNodes(t);
  },
  wrapNodes(e, t, n) {
    e.wrapNodes(t, n);
  }
}, Lpe = {
  collapse(e, t) {
    e.collapse(t);
  },
  deselect(e) {
    e.deselect();
  },
  move(e, t) {
    e.move(t);
  },
  select(e, t) {
    e.select(t);
  },
  setPoint(e, t, n) {
    e.setPoint(t, n);
  },
  setSelection(e, t) {
    e.setSelection(t);
  }
}, fK = (e, t) => {
  for (var n in e) {
    var r = e[n], o = t[n];
    if (pi(r) && pi(o)) {
      if (!fK(r, o)) return !1;
    } else if (Array.isArray(r) && Array.isArray(o)) {
      if (r.length !== o.length) return !1;
      for (var i = 0; i < r.length; i++)
        if (r[i] !== o[i]) return !1;
    } else if (r !== o)
      return !1;
  }
  for (var a in t)
    if (e[a] === void 0 && t[a] !== void 0)
      return !1;
  return !0;
};
function _pe(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), o, i;
  for (i = 0; i < r.length; i++)
    o = r[i], !(t.indexOf(o) >= 0) && (n[o] = e[o]);
  return n;
}
function Kf(e, t) {
  if (e == null) return {};
  var n = _pe(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (o = 0; o < i.length; o++)
      r = i[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
var Ppe = ["anchor", "focus"];
function eR(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Spe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? eR(Object(n), !0).forEach(function(r) {
      Dp(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : eR(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Vt = {
  edges(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, {
      anchor: r,
      focus: o
    } = e;
    return Vt.isBackward(e) === n ? [r, o] : [o, r];
  },
  end(e) {
    var [, t] = Vt.edges(e);
    return t;
  },
  equals(e, t) {
    return Sr.equals(e.anchor, t.anchor) && Sr.equals(e.focus, t.focus);
  },
  includes(e, t) {
    if (Vt.isRange(t)) {
      if (Vt.includes(e, t.anchor) || Vt.includes(e, t.focus))
        return !0;
      var [n, r] = Vt.edges(e), [o, i] = Vt.edges(t);
      return Sr.isBefore(n, o) && Sr.isAfter(r, i);
    }
    var [a, s] = Vt.edges(e), l = !1, u = !1;
    return Sr.isPoint(t) ? (l = Sr.compare(t, a) >= 0, u = Sr.compare(t, s) <= 0) : (l = Ze.compare(t, a.path) >= 0, u = Ze.compare(t, s.path) <= 0), l && u;
  },
  intersection(e, t) {
    var n = Kf(e, Ppe), [r, o] = Vt.edges(e), [i, a] = Vt.edges(t), s = Sr.isBefore(r, i) ? i : r, l = Sr.isBefore(o, a) ? o : a;
    return Sr.isBefore(l, s) ? null : Spe({
      anchor: s,
      focus: l
    }, n);
  },
  isBackward(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return Sr.isAfter(t, n);
  },
  isCollapsed(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return Sr.equals(t, n);
  },
  isExpanded(e) {
    return !Vt.isCollapsed(e);
  },
  isForward(e) {
    return !Vt.isBackward(e);
  },
  isRange(e) {
    return pi(e) && Sr.isPoint(e.anchor) && Sr.isPoint(e.focus);
  },
  *points(e) {
    yield [e.anchor, "anchor"], yield [e.focus, "focus"];
  },
  start(e) {
    var [t] = Vt.edges(e);
    return t;
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return bS(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "inward"
      } = n, i, a;
      if (o === "inward") {
        var s = Vt.isCollapsed(r);
        Vt.isForward(r) ? (i = "forward", a = s ? i : "backward") : (i = "backward", a = s ? i : "forward");
      } else o === "outward" ? Vt.isForward(r) ? (i = "backward", a = "forward") : (i = "forward", a = "backward") : (i = o, a = o);
      var l = Sr.transform(r.anchor, t, {
        affinity: i
      }), u = Sr.transform(r.focus, t, {
        affinity: a
      });
      if (!l || !u)
        return null;
      r.anchor = l, r.focus = u;
    });
  }
}, tR = (e) => pi(e) && _t.isNodeList(e.children) && !sr.isEditor(e), Ua = {
  isAncestor(e) {
    return pi(e) && _t.isNodeList(e.children);
  },
  isElement: tR,
  isElementList(e) {
    return Array.isArray(e) && e.every((t) => Ua.isElement(t));
  },
  isElementProps(e) {
    return e.children !== void 0;
  },
  isElementType: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "type";
    return tR(e) && e[n] === t;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "children" && e[n] !== t[n])
        return !1;
    return !0;
  }
}, Mpe = ["children"], Dpe = ["text"], nR = /* @__PURE__ */ new WeakMap(), _t = {
  ancestor(e, t) {
    var n = _t.get(e, t);
    if (Lo.isText(n))
      throw new Error("Cannot get the ancestor node at path [".concat(t, "] because it refers to a text node instead: ").concat(rs.stringify(n)));
    return n;
  },
  ancestors(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of Ze.ancestors(t, n)) {
        var o = _t.ancestor(e, r), i = [o, r];
        yield i;
      }
    }();
  },
  child(e, t) {
    if (Lo.isText(e))
      throw new Error("Cannot get the child of a text node: ".concat(rs.stringify(e)));
    var n = e.children[t];
    if (n == null)
      throw new Error("Cannot get child at index `".concat(t, "` in node: ").concat(rs.stringify(e)));
    return n;
  },
  children(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var {
        reverse: r = !1
      } = n, o = _t.ancestor(e, t), {
        children: i
      } = o, a = r ? i.length - 1 : 0; r ? a >= 0 : a < i.length; ) {
        var s = _t.child(o, a), l = t.concat(a);
        yield [s, l], a = r ? a - 1 : a + 1;
      }
    }();
  },
  common(e, t, n) {
    var r = Ze.common(t, n), o = _t.get(e, r);
    return [o, r];
  },
  descendant(e, t) {
    var n = _t.get(e, t);
    if (sr.isEditor(n))
      throw new Error("Cannot get the descendant node at path [".concat(t, "] because it refers to the root editor node instead: ").concat(rs.stringify(n)));
    return n;
  },
  descendants(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of _t.nodes(e, t))
        r.length !== 0 && (yield [n, r]);
    }();
  },
  elements(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of _t.nodes(e, t))
        Ua.isElement(n) && (yield [n, r]);
    }();
  },
  extractProps(e) {
    if (Ua.isAncestor(e)) {
      var t = Kf(e, Mpe);
      return t;
    } else {
      var t = Kf(e, Dpe);
      return t;
    }
  },
  first(e, t) {
    for (var n = t.slice(), r = _t.get(e, n); r && !(Lo.isText(r) || r.children.length === 0); )
      r = r.children[0], n.push(0);
    return [r, n];
  },
  fragment(e, t) {
    if (Lo.isText(e))
      throw new Error("Cannot get a fragment starting from a root text node: ".concat(rs.stringify(e)));
    var n = bS({
      children: e.children
    }, (r) => {
      var [o, i] = Vt.edges(t), a = _t.nodes(r, {
        reverse: !0,
        pass: (d) => {
          var [, g] = d;
          return !Vt.includes(t, g);
        }
      });
      for (var [, s] of a) {
        if (!Vt.includes(t, s)) {
          var l = _t.parent(r, s), u = s[s.length - 1];
          l.children.splice(u, 1);
        }
        if (Ze.equals(s, i.path)) {
          var c = _t.leaf(r, s);
          c.text = c.text.slice(0, i.offset);
        }
        if (Ze.equals(s, o.path)) {
          var p = _t.leaf(r, s);
          p.text = p.text.slice(o.offset);
        }
      }
      sr.isEditor(r) && (r.selection = null);
    });
    return n.children;
  },
  get(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (Lo.isText(n) || !n.children[o])
        throw new Error("Cannot find a descendant at path [".concat(t, "] in node: ").concat(rs.stringify(e)));
      n = n.children[o];
    }
    return n;
  },
  has(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (Lo.isText(n) || !n.children[o])
        return !1;
      n = n.children[o];
    }
    return !0;
  },
  isNode(e) {
    return Lo.isText(e) || Ua.isElement(e) || sr.isEditor(e);
  },
  isNodeList(e) {
    if (!Array.isArray(e))
      return !1;
    var t = nR.get(e);
    if (t !== void 0)
      return t;
    var n = e.every((r) => _t.isNode(r));
    return nR.set(e, n), n;
  },
  last(e, t) {
    for (var n = t.slice(), r = _t.get(e, n); r && !(Lo.isText(r) || r.children.length === 0); ) {
      var o = r.children.length - 1;
      r = r.children[o], n.push(o);
    }
    return [r, n];
  },
  leaf(e, t) {
    var n = _t.get(e, t);
    if (!Lo.isText(n))
      throw new Error("Cannot get the leaf node at path [".concat(t, "] because it refers to a non-leaf node: ").concat(rs.stringify(n)));
    return n;
  },
  levels(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of Ze.levels(t, n)) {
        var o = _t.get(e, r);
        yield [o, r];
      }
    }();
  },
  matches(e, t) {
    return Ua.isElement(e) && Ua.isElementProps(t) && Ua.matches(e, t) || Lo.isText(e) && Lo.isTextProps(t) && Lo.matches(e, t);
  },
  nodes(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var {
        pass: n,
        reverse: r = !1
      } = t, {
        from: o = [],
        to: i
      } = t, a = /* @__PURE__ */ new Set(), s = [], l = e; !(i && (r ? Ze.isBefore(s, i) : Ze.isAfter(s, i))); ) {
        if (a.has(l) || (yield [l, s]), !a.has(l) && !Lo.isText(l) && l.children.length !== 0 && (n == null || n([l, s]) === !1)) {
          a.add(l);
          var u = r ? l.children.length - 1 : 0;
          Ze.isAncestor(s, o) && (u = o[s.length]), s = s.concat(u), l = _t.get(e, s);
          continue;
        }
        if (s.length === 0)
          break;
        if (!r) {
          var c = Ze.next(s);
          if (_t.has(e, c)) {
            s = c, l = _t.get(e, s);
            continue;
          }
        }
        if (r && s[s.length - 1] !== 0) {
          var p = Ze.previous(s);
          s = p, l = _t.get(e, s);
          continue;
        }
        s = Ze.parent(s), l = _t.get(e, s), a.add(l);
      }
    }();
  },
  parent(e, t) {
    var n = Ze.parent(t), r = _t.get(e, n);
    if (Lo.isText(r))
      throw new Error("Cannot get the parent of path [".concat(t, "] because it does not exist in the root."));
    return r;
  },
  string(e) {
    return Lo.isText(e) ? e.text : e.children.map(_t.string).join("");
  },
  texts(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of _t.nodes(e, t))
        Lo.isText(n) && (yield [n, r]);
    }();
  }
};
function rR(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Nr(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? rR(Object(n), !0).forEach(function(r) {
      Dp(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : rR(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var $d = {
  isNodeOperation(e) {
    return $d.isOperation(e) && e.type.endsWith("_node");
  },
  isOperation(e) {
    if (!pi(e))
      return !1;
    switch (e.type) {
      case "insert_node":
        return Ze.isPath(e.path) && _t.isNode(e.node);
      case "insert_text":
        return typeof e.offset == "number" && typeof e.text == "string" && Ze.isPath(e.path);
      case "merge_node":
        return typeof e.position == "number" && Ze.isPath(e.path) && pi(e.properties);
      case "move_node":
        return Ze.isPath(e.path) && Ze.isPath(e.newPath);
      case "remove_node":
        return Ze.isPath(e.path) && _t.isNode(e.node);
      case "remove_text":
        return typeof e.offset == "number" && typeof e.text == "string" && Ze.isPath(e.path);
      case "set_node":
        return Ze.isPath(e.path) && pi(e.properties) && pi(e.newProperties);
      case "set_selection":
        return e.properties === null && Vt.isRange(e.newProperties) || e.newProperties === null && Vt.isRange(e.properties) || pi(e.properties) && pi(e.newProperties);
      case "split_node":
        return Ze.isPath(e.path) && typeof e.position == "number" && pi(e.properties);
      default:
        return !1;
    }
  },
  isOperationList(e) {
    return Array.isArray(e) && e.every((t) => $d.isOperation(t));
  },
  isSelectionOperation(e) {
    return $d.isOperation(e) && e.type.endsWith("_selection");
  },
  isTextOperation(e) {
    return $d.isOperation(e) && e.type.endsWith("_text");
  },
  inverse(e) {
    switch (e.type) {
      case "insert_node":
        return Nr(Nr({}, e), {}, {
          type: "remove_node"
        });
      case "insert_text":
        return Nr(Nr({}, e), {}, {
          type: "remove_text"
        });
      case "merge_node":
        return Nr(Nr({}, e), {}, {
          type: "split_node",
          path: Ze.previous(e.path)
        });
      case "move_node": {
        var {
          newPath: t,
          path: n
        } = e;
        if (Ze.equals(t, n))
          return e;
        if (Ze.isSibling(n, t))
          return Nr(Nr({}, e), {}, {
            path: t,
            newPath: n
          });
        var r = Ze.transform(n, e), o = Ze.transform(Ze.next(n), e);
        return Nr(Nr({}, e), {}, {
          path: r,
          newPath: o
        });
      }
      case "remove_node":
        return Nr(Nr({}, e), {}, {
          type: "insert_node"
        });
      case "remove_text":
        return Nr(Nr({}, e), {}, {
          type: "insert_text"
        });
      case "set_node": {
        var {
          properties: i,
          newProperties: a
        } = e;
        return Nr(Nr({}, e), {}, {
          properties: a,
          newProperties: i
        });
      }
      case "set_selection": {
        var {
          properties: s,
          newProperties: l
        } = e;
        return s == null ? Nr(Nr({}, e), {}, {
          properties: l,
          newProperties: null
        }) : l == null ? Nr(Nr({}, e), {}, {
          properties: null,
          newProperties: s
        }) : Nr(Nr({}, e), {}, {
          properties: l,
          newProperties: s
        });
      }
      case "split_node":
        return Nr(Nr({}, e), {}, {
          type: "merge_node",
          path: Ze.next(e.path)
        });
    }
  }
}, oR = /* @__PURE__ */ new WeakMap(), Tpe = (e) => {
  var t = oR.get(e);
  if (t !== void 0)
    return t;
  if (!pi(e))
    return !1;
  var n = typeof e.addMark == "function" && typeof e.apply == "function" && typeof e.deleteFragment == "function" && typeof e.insertBreak == "function" && typeof e.insertSoftBreak == "function" && typeof e.insertFragment == "function" && typeof e.insertNode == "function" && typeof e.insertText == "function" && typeof e.isElementReadOnly == "function" && typeof e.isInline == "function" && typeof e.isSelectable == "function" && typeof e.isVoid == "function" && typeof e.normalizeNode == "function" && typeof e.onChange == "function" && typeof e.removeMark == "function" && typeof e.getDirtyPaths == "function" && (e.marks === null || pi(e.marks)) && (e.selection === null || Vt.isRange(e.selection)) && _t.isNodeList(e.children) && $d.isOperationList(e.operations);
  return oR.set(e, n), n;
}, sr = {
  above(e, t) {
    return e.above(t);
  },
  addMark(e, t, n) {
    e.addMark(t, n);
  },
  after(e, t, n) {
    return e.after(t, n);
  },
  before(e, t, n) {
    return e.before(t, n);
  },
  deleteBackward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteBackward(n);
  },
  deleteForward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteForward(n);
  },
  deleteFragment(e, t) {
    e.deleteFragment(t);
  },
  edges(e, t) {
    return e.edges(t);
  },
  elementReadOnly(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return e.elementReadOnly(t);
  },
  end(e, t) {
    return e.end(t);
  },
  first(e, t) {
    return e.first(t);
  },
  fragment(e, t) {
    return e.fragment(t);
  },
  hasBlocks(e, t) {
    return e.hasBlocks(t);
  },
  hasInlines(e, t) {
    return e.hasInlines(t);
  },
  hasPath(e, t) {
    return e.hasPath(t);
  },
  hasTexts(e, t) {
    return e.hasTexts(t);
  },
  insertBreak(e) {
    e.insertBreak();
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertNode(e, t) {
    e.insertNode(t);
  },
  insertSoftBreak(e) {
    e.insertSoftBreak();
  },
  insertText(e, t) {
    e.insertText(t);
  },
  isBlock(e, t) {
    return e.isBlock(t);
  },
  isEdge(e, t, n) {
    return e.isEdge(t, n);
  },
  isEditor(e) {
    return Tpe(e);
  },
  isElementReadOnly(e, t) {
    return e.isElementReadOnly(t);
  },
  isEmpty(e, t) {
    return e.isEmpty(t);
  },
  isEnd(e, t, n) {
    return e.isEnd(t, n);
  },
  isInline(e, t) {
    return e.isInline(t);
  },
  isNormalizing(e) {
    return e.isNormalizing();
  },
  isSelectable(e, t) {
    return e.isSelectable(t);
  },
  isStart(e, t, n) {
    return e.isStart(t, n);
  },
  isVoid(e, t) {
    return e.isVoid(t);
  },
  last(e, t) {
    return e.last(t);
  },
  leaf(e, t, n) {
    return e.leaf(t, n);
  },
  levels(e, t) {
    return e.levels(t);
  },
  marks(e) {
    return e.getMarks();
  },
  next(e, t) {
    return e.next(t);
  },
  node(e, t, n) {
    return e.node(t, n);
  },
  nodes(e, t) {
    return e.nodes(t);
  },
  normalize(e, t) {
    e.normalize(t);
  },
  parent(e, t, n) {
    return e.parent(t, n);
  },
  path(e, t, n) {
    return e.path(t, n);
  },
  pathRef(e, t, n) {
    return e.pathRef(t, n);
  },
  pathRefs(e) {
    return e.pathRefs();
  },
  point(e, t, n) {
    return e.point(t, n);
  },
  pointRef(e, t, n) {
    return e.pointRef(t, n);
  },
  pointRefs(e) {
    return e.pointRefs();
  },
  positions(e, t) {
    return e.positions(t);
  },
  previous(e, t) {
    return e.previous(t);
  },
  range(e, t, n) {
    return e.range(t, n);
  },
  rangeRef(e, t, n) {
    return e.rangeRef(t, n);
  },
  rangeRefs(e) {
    return e.rangeRefs();
  },
  removeMark(e, t) {
    e.removeMark(t);
  },
  setNormalizing(e, t) {
    e.setNormalizing(t);
  },
  start(e, t) {
    return e.start(t);
  },
  string(e, t, n) {
    return e.string(t, n);
  },
  unhangRange(e, t, n) {
    return e.unhangRange(t, n);
  },
  void(e, t) {
    return e.void(t);
  },
  withoutNormalizing(e, t) {
    e.withoutNormalizing(t);
  },
  shouldMergeNodesRemovePrevNode: (e, t, n) => e.shouldMergeNodesRemovePrevNode(t, n)
};
function iR(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function sR(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? iR(Object(n), !0).forEach(function(r) {
      Dp(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : iR(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Sr = {
  compare(e, t) {
    var n = Ze.compare(e.path, t.path);
    return n === 0 ? e.offset < t.offset ? -1 : e.offset > t.offset ? 1 : 0 : n;
  },
  isAfter(e, t) {
    return Sr.compare(e, t) === 1;
  },
  isBefore(e, t) {
    return Sr.compare(e, t) === -1;
  },
  equals(e, t) {
    return e.offset === t.offset && Ze.equals(e.path, t.path);
  },
  isPoint(e) {
    return pi(e) && typeof e.offset == "number" && Ze.isPath(e.path);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return bS(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "forward"
      } = n, {
        path: i,
        offset: a
      } = r;
      switch (t.type) {
        case "insert_node":
        case "move_node": {
          r.path = Ze.transform(i, t, n);
          break;
        }
        case "insert_text": {
          Ze.equals(t.path, i) && (t.offset < a || t.offset === a && o === "forward") && (r.offset += t.text.length);
          break;
        }
        case "merge_node": {
          Ze.equals(t.path, i) && (r.offset += t.position), r.path = Ze.transform(i, t, n);
          break;
        }
        case "remove_text": {
          Ze.equals(t.path, i) && t.offset <= a && (r.offset -= Math.min(a - t.offset, t.text.length));
          break;
        }
        case "remove_node": {
          if (Ze.equals(t.path, i) || Ze.isAncestor(t.path, i))
            return null;
          r.path = Ze.transform(i, t, n);
          break;
        }
        case "split_node": {
          if (Ze.equals(t.path, i)) {
            if (t.position === a && o == null)
              return null;
            (t.position < a || t.position === a && o === "forward") && (r.offset -= t.position, r.path = Ze.transform(i, t, sR(sR({}, n), {}, {
              affinity: "forward"
            })));
          } else
            r.path = Ze.transform(i, t, n);
          break;
        }
      }
    });
  }
}, aR = void 0, rs = {
  setScrubber(e) {
    aR = e;
  },
  stringify(e) {
    return JSON.stringify(e, aR);
  }
}, jpe = ["text"], Ape = ["anchor", "focus"];
function lR(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function La(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? lR(Object(n), !0).forEach(function(r) {
      Dp(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : lR(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Lo = {
  equals(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      loose: r = !1
    } = n;
    function o(i) {
      var a = Kf(i, jpe);
      return a;
    }
    return fK(r ? o(e) : e, r ? o(t) : t);
  },
  isText(e) {
    return pi(e) && typeof e.text == "string";
  },
  isTextList(e) {
    return Array.isArray(e) && e.every((t) => Lo.isText(t));
  },
  isTextProps(e) {
    return e.text !== void 0;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "text" && (!e.hasOwnProperty(n) || e[n] !== t[n]))
        return !1;
    return !0;
  },
  decorations(e, t) {
    var n = [La({}, e)];
    for (var r of t) {
      var o = Kf(r, Ape), [i, a] = Vt.edges(r), s = [], l = 0, u = i.offset, c = a.offset;
      for (var p of n) {
        var {
          length: d
        } = p.text, g = l;
        if (l += d, u <= g && l <= c) {
          Object.assign(p, o), s.push(p);
          continue;
        }
        if (u !== c && (u === l || c === g) || u > l || c < g || c === g && g !== 0) {
          s.push(p);
          continue;
        }
        var f = p, m = void 0, b = void 0;
        if (c < l) {
          var E = c - g;
          b = La(La({}, f), {}, {
            text: f.text.slice(E)
          }), f = La(La({}, f), {}, {
            text: f.text.slice(0, E)
          });
        }
        if (u > g) {
          var w = u - g;
          m = La(La({}, f), {}, {
            text: f.text.slice(0, w)
          }), f = La(La({}, f), {}, {
            text: f.text.slice(w)
          });
        }
        Object.assign(f, o), m && s.push(m), s.push(f), b && s.push(b);
      }
      n = s;
    }
    return n;
  }
}, Rpe = (e) => e.selection ? e.selection : e.children.length > 0 ? sr.end(e, []) : [0], Or;
(function(e) {
  e[e.None = 0] = "None", e[e.Extend = 1] = "Extend", e[e.ZWJ = 2] = "ZWJ", e[e.RI = 4] = "RI", e[e.Prepend = 8] = "Prepend", e[e.SpacingMark = 16] = "SpacingMark", e[e.L = 32] = "L", e[e.V = 64] = "V", e[e.T = 128] = "T", e[e.LV = 256] = "LV", e[e.LVT = 512] = "LVT", e[e.ExtPict = 1024] = "ExtPict", e[e.Any = 2048] = "Any";
})(Or || (Or = {}));
Or.L, Or.L | Or.V | Or.LV | Or.LVT, Or.LV | Or.V, Or.V | Or.T, Or.LVT | Or.T, Or.T, Or.Any, Or.Extend | Or.ZWJ, Or.Any, Or.SpacingMark, Or.Prepend, Or.Any, Or.ZWJ, Or.ExtPict, Or.RI, Or.RI;
var Ipe = {
  delete(e, t) {
    e.delete(t);
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertText(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    sr.withoutNormalizing(e, () => {
      var {
        voids: r = !1
      } = n, {
        at: o = Rpe(e)
      } = n;
      if (Ze.isPath(o) && (o = sr.range(e, o)), Vt.isRange(o))
        if (Vt.isCollapsed(o))
          o = o.anchor;
        else {
          var i = Vt.end(o);
          if (!r && sr.void(e, {
            at: i
          }))
            return;
          var a = Vt.start(o), s = sr.pointRef(e, a), l = sr.pointRef(e, i);
          Ky.delete(e, {
            at: o,
            voids: r
          });
          var u = s.unref(), c = l.unref();
          o = u || c, Ky.setSelection(e, {
            anchor: o,
            focus: o
          });
        }
      if (!(!r && sr.void(e, {
        at: o
      }) || sr.elementReadOnly(e, {
        at: o
      }))) {
        var {
          path: p,
          offset: d
        } = o;
        t.length > 0 && e.apply({
          type: "insert_text",
          path: p,
          offset: d,
          text: t
        });
      }
    });
  }
};
function uR(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function rm(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? uR(Object(n), !0).forEach(function(r) {
      Dp(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : uR(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Ky = rm(rm(rm(rm({}, Epe), kpe), Lpe), Ipe), hK = {}, wS = {}, CS = {}, Jc = {}, OS = {}, xS = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Doctype = e.CDATA = e.Tag = e.Style = e.Script = e.Comment = e.Directive = e.Text = e.Root = e.isTag = e.ElementType = void 0;
  var t;
  (function(r) {
    r.Root = "root", r.Text = "text", r.Directive = "directive", r.Comment = "comment", r.Script = "script", r.Style = "style", r.Tag = "tag", r.CDATA = "cdata", r.Doctype = "doctype";
  })(t = e.ElementType || (e.ElementType = {}));
  function n(r) {
    return r.type === t.Tag || r.type === t.Script || r.type === t.Style;
  }
  e.isTag = n, e.Root = t.Root, e.Text = t.Text, e.Directive = t.Directive, e.Comment = t.Comment, e.Script = t.Script, e.Style = t.Style, e.Tag = t.Tag, e.CDATA = t.CDATA, e.Doctype = t.Doctype;
})(xS);
var en = {}, cu = hr && hr.__extends || /* @__PURE__ */ function() {
  var e = function(t, n) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, o) {
      r.__proto__ = o;
    } || function(r, o) {
      for (var i in o) Object.prototype.hasOwnProperty.call(o, i) && (r[i] = o[i]);
    }, e(t, n);
  };
  return function(t, n) {
    if (typeof n != "function" && n !== null)
      throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
    e(t, n);
    function r() {
      this.constructor = t;
    }
    t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
  };
}(), lf = hr && hr.__assign || function() {
  return lf = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) {
      t = arguments[n];
      for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
    }
    return e;
  }, lf.apply(this, arguments);
};
Object.defineProperty(en, "__esModule", { value: !0 });
en.cloneNode = en.hasChildren = en.isDocument = en.isDirective = en.isComment = en.isText = en.isCDATA = en.isTag = en.Element = en.Document = en.CDATA = en.NodeWithChildren = en.ProcessingInstruction = en.Comment = en.Text = en.DataNode = en.Node = void 0;
var Xi = xS, ES = (
  /** @class */
  function() {
    function e() {
      this.parent = null, this.prev = null, this.next = null, this.startIndex = null, this.endIndex = null;
    }
    return Object.defineProperty(e.prototype, "parentNode", {
      // Read-write aliases for properties
      /**
       * Same as {@link parent}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.parent;
      },
      set: function(t) {
        this.parent = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "previousSibling", {
      /**
       * Same as {@link prev}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.prev;
      },
      set: function(t) {
        this.prev = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "nextSibling", {
      /**
       * Same as {@link next}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.next;
      },
      set: function(t) {
        this.next = t;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.cloneNode = function(t) {
      return t === void 0 && (t = !1), kS(this, t);
    }, e;
  }()
);
en.Node = ES;
var k0 = (
  /** @class */
  function(e) {
    cu(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.data = n, r;
    }
    return Object.defineProperty(t.prototype, "nodeValue", {
      /**
       * Same as {@link data}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.data;
      },
      set: function(n) {
        this.data = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(ES)
);
en.DataNode = k0;
var gK = (
  /** @class */
  function(e) {
    cu(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Xi.ElementType.Text, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 3;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(k0)
);
en.Text = gK;
var mK = (
  /** @class */
  function(e) {
    cu(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Xi.ElementType.Comment, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 8;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(k0)
);
en.Comment = mK;
var vK = (
  /** @class */
  function(e) {
    cu(t, e);
    function t(n, r) {
      var o = e.call(this, r) || this;
      return o.name = n, o.type = Xi.ElementType.Directive, o;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(k0)
);
en.ProcessingInstruction = vK;
var L0 = (
  /** @class */
  function(e) {
    cu(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.children = n, r;
    }
    return Object.defineProperty(t.prototype, "firstChild", {
      // Aliases
      /** First child of the node. */
      get: function() {
        var n;
        return (n = this.children[0]) !== null && n !== void 0 ? n : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "lastChild", {
      /** Last child of the node. */
      get: function() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "childNodes", {
      /**
       * Same as {@link children}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.children;
      },
      set: function(n) {
        this.children = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(ES)
);
en.NodeWithChildren = L0;
var yK = (
  /** @class */
  function(e) {
    cu(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Xi.ElementType.CDATA, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 4;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(L0)
);
en.CDATA = yK;
var bK = (
  /** @class */
  function(e) {
    cu(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Xi.ElementType.Root, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 9;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(L0)
);
en.Document = bK;
var wK = (
  /** @class */
  function(e) {
    cu(t, e);
    function t(n, r, o, i) {
      o === void 0 && (o = []), i === void 0 && (i = n === "script" ? Xi.ElementType.Script : n === "style" ? Xi.ElementType.Style : Xi.ElementType.Tag);
      var a = e.call(this, o) || this;
      return a.name = n, a.attribs = r, a.type = i, a;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "tagName", {
      // DOM Level 1 aliases
      /**
       * Same as {@link name}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.name;
      },
      set: function(n) {
        this.name = n;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "attributes", {
      get: function() {
        var n = this;
        return Object.keys(this.attribs).map(function(r) {
          var o, i;
          return {
            name: r,
            value: n.attribs[r],
            namespace: (o = n["x-attribsNamespace"]) === null || o === void 0 ? void 0 : o[r],
            prefix: (i = n["x-attribsPrefix"]) === null || i === void 0 ? void 0 : i[r]
          };
        });
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(L0)
);
en.Element = wK;
function CK(e) {
  return (0, Xi.isTag)(e);
}
en.isTag = CK;
function OK(e) {
  return e.type === Xi.ElementType.CDATA;
}
en.isCDATA = OK;
function xK(e) {
  return e.type === Xi.ElementType.Text;
}
en.isText = xK;
function EK(e) {
  return e.type === Xi.ElementType.Comment;
}
en.isComment = EK;
function kK(e) {
  return e.type === Xi.ElementType.Directive;
}
en.isDirective = kK;
function LK(e) {
  return e.type === Xi.ElementType.Root;
}
en.isDocument = LK;
function Npe(e) {
  return Object.prototype.hasOwnProperty.call(e, "children");
}
en.hasChildren = Npe;
function kS(e, t) {
  t === void 0 && (t = !1);
  var n;
  if (xK(e))
    n = new gK(e.data);
  else if (EK(e))
    n = new mK(e.data);
  else if (CK(e)) {
    var r = t ? vx(e.children) : [], o = new wK(e.name, lf({}, e.attribs), r);
    r.forEach(function(l) {
      return l.parent = o;
    }), e.namespace != null && (o.namespace = e.namespace), e["x-attribsNamespace"] && (o["x-attribsNamespace"] = lf({}, e["x-attribsNamespace"])), e["x-attribsPrefix"] && (o["x-attribsPrefix"] = lf({}, e["x-attribsPrefix"])), n = o;
  } else if (OK(e)) {
    var r = t ? vx(e.children) : [], i = new yK(r);
    r.forEach(function(u) {
      return u.parent = i;
    }), n = i;
  } else if (LK(e)) {
    var r = t ? vx(e.children) : [], a = new bK(r);
    r.forEach(function(u) {
      return u.parent = a;
    }), e["x-mode"] && (a["x-mode"] = e["x-mode"]), n = a;
  } else if (kK(e)) {
    var s = new vK(e.name, e.data);
    e["x-name"] != null && (s["x-name"] = e["x-name"], s["x-publicId"] = e["x-publicId"], s["x-systemId"] = e["x-systemId"]), n = s;
  } else
    throw new Error("Not implemented yet: ".concat(e.type));
  return n.startIndex = e.startIndex, n.endIndex = e.endIndex, e.sourceCodeLocation != null && (n.sourceCodeLocation = e.sourceCodeLocation), n;
}
en.cloneNode = kS;
function vx(e) {
  for (var t = e.map(function(r) {
    return kS(r, !0);
  }), n = 1; n < t.length; n++)
    t[n].prev = t[n - 1], t[n - 1].next = t[n];
  return t;
}
(function(e) {
  var t = hr && hr.__createBinding || (Object.create ? function(s, l, u, c) {
    c === void 0 && (c = u);
    var p = Object.getOwnPropertyDescriptor(l, u);
    (!p || ("get" in p ? !l.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
      return l[u];
    } }), Object.defineProperty(s, c, p);
  } : function(s, l, u, c) {
    c === void 0 && (c = u), s[c] = l[u];
  }), n = hr && hr.__exportStar || function(s, l) {
    for (var u in s) u !== "default" && !Object.prototype.hasOwnProperty.call(l, u) && t(l, s, u);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.DomHandler = void 0;
  var r = xS, o = en;
  n(en, e);
  var i = {
    withStartIndices: !1,
    withEndIndices: !1,
    xmlMode: !1
  }, a = (
    /** @class */
    function() {
      function s(l, u, c) {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null, typeof u == "function" && (c = u, u = i), typeof l == "object" && (u = l, l = void 0), this.callback = l ?? null, this.options = u ?? i, this.elementCB = c ?? null;
      }
      return s.prototype.onparserinit = function(l) {
        this.parser = l;
      }, s.prototype.onreset = function() {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null;
      }, s.prototype.onend = function() {
        this.done || (this.done = !0, this.parser = null, this.handleCallback(null));
      }, s.prototype.onerror = function(l) {
        this.handleCallback(l);
      }, s.prototype.onclosetag = function() {
        this.lastNode = null;
        var l = this.tagStack.pop();
        this.options.withEndIndices && (l.endIndex = this.parser.endIndex), this.elementCB && this.elementCB(l);
      }, s.prototype.onopentag = function(l, u) {
        var c = this.options.xmlMode ? r.ElementType.Tag : void 0, p = new o.Element(l, u, void 0, c);
        this.addNode(p), this.tagStack.push(p);
      }, s.prototype.ontext = function(l) {
        var u = this.lastNode;
        if (u && u.type === r.ElementType.Text)
          u.data += l, this.options.withEndIndices && (u.endIndex = this.parser.endIndex);
        else {
          var c = new o.Text(l);
          this.addNode(c), this.lastNode = c;
        }
      }, s.prototype.oncomment = function(l) {
        if (this.lastNode && this.lastNode.type === r.ElementType.Comment) {
          this.lastNode.data += l;
          return;
        }
        var u = new o.Comment(l);
        this.addNode(u), this.lastNode = u;
      }, s.prototype.oncommentend = function() {
        this.lastNode = null;
      }, s.prototype.oncdatastart = function() {
        var l = new o.Text(""), u = new o.CDATA([l]);
        this.addNode(u), l.parent = u, this.lastNode = l;
      }, s.prototype.oncdataend = function() {
        this.lastNode = null;
      }, s.prototype.onprocessinginstruction = function(l, u) {
        var c = new o.ProcessingInstruction(l, u);
        this.addNode(c);
      }, s.prototype.handleCallback = function(l) {
        if (typeof this.callback == "function")
          this.callback(l, this.dom);
        else if (l)
          throw l;
      }, s.prototype.addNode = function(l) {
        var u = this.tagStack[this.tagStack.length - 1], c = u.children[u.children.length - 1];
        this.options.withStartIndices && (l.startIndex = this.parser.startIndex), this.options.withEndIndices && (l.endIndex = this.parser.endIndex), u.children.push(l), c && (l.prev = c, c.next = l), l.parent = u, this.lastNode = null;
      }, s;
    }()
  );
  e.DomHandler = a, e.default = a;
})(OS);
var _K = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CARRIAGE_RETURN_PLACEHOLDER_REGEX = e.CARRIAGE_RETURN_PLACEHOLDER = e.CARRIAGE_RETURN_REGEX = e.CARRIAGE_RETURN = e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES = void 0, e.CASE_SENSITIVE_TAG_NAMES = [
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "linearGradient",
    "radialGradient",
    "textPath"
  ], e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES.reduce(function(t, n) {
    return t[n.toLowerCase()] = n, t;
  }, {}), e.CARRIAGE_RETURN = "\r", e.CARRIAGE_RETURN_REGEX = new RegExp(e.CARRIAGE_RETURN, "g"), e.CARRIAGE_RETURN_PLACEHOLDER = "__HTML_DOM_PARSER_CARRIAGE_RETURN_PLACEHOLDER_".concat(Date.now(), "__"), e.CARRIAGE_RETURN_PLACEHOLDER_REGEX = new RegExp(e.CARRIAGE_RETURN_PLACEHOLDER, "g");
})(_K);
Object.defineProperty(Jc, "__esModule", { value: !0 });
Jc.formatAttributes = PK;
Jc.escapeSpecialCharacters = zpe;
Jc.revertEscapedCharacters = SK;
Jc.formatDOM = MK;
var om = OS, Xf = _K;
function Bpe(e) {
  return Xf.CASE_SENSITIVE_TAG_NAMES_MAP[e];
}
function PK(e) {
  for (var t = {}, n = 0, r = e.length; n < r; n++) {
    var o = e[n];
    t[o.name] = o.value;
  }
  return t;
}
function Fpe(e) {
  e = e.toLowerCase();
  var t = Bpe(e);
  return t || e;
}
function zpe(e) {
  return e.replace(Xf.CARRIAGE_RETURN_REGEX, Xf.CARRIAGE_RETURN_PLACEHOLDER);
}
function SK(e) {
  return e.replace(Xf.CARRIAGE_RETURN_PLACEHOLDER_REGEX, Xf.CARRIAGE_RETURN);
}
function MK(e, t, n) {
  t === void 0 && (t = null);
  for (var r = [], o, i = 0, a = e.length; i < a; i++) {
    var s = e[i];
    switch (s.nodeType) {
      case 1: {
        var l = Fpe(s.nodeName);
        o = new om.Element(l, PK(s.attributes)), o.children = MK(
          // template children are on content
          l === "template" ? s.content.childNodes : s.childNodes,
          o
        );
        break;
      }
      case 3:
        o = new om.Text(SK(s.nodeValue));
        break;
      case 8:
        o = new om.Comment(s.nodeValue);
        break;
      default:
        continue;
    }
    var u = r[i - 1] || null;
    u && (u.next = o), o.parent = t, o.prev = u, o.next = null, r.push(o);
  }
  return n && (o = new om.ProcessingInstruction(n.substring(0, n.indexOf(" ")).toLowerCase(), n), o.next = r[0] || null, o.parent = t, r.unshift(o), r[1] && (r[1].prev = r[0])), r;
}
Object.defineProperty(CS, "__esModule", { value: !0 });
CS.default = Vpe;
var Upe = Jc, cR = "html", pR = "head", im = "body", Hpe = /<([a-zA-Z]+[0-9]?)/, dR = /<head[^]*>/i, fR = /<body[^]*>/i, Xy = function(e, t) {
  throw new Error("This browser does not support `document.implementation.createHTMLDocument`");
}, y1 = function(e, t) {
  throw new Error("This browser does not support `DOMParser.prototype.parseFromString`");
}, hR = typeof window == "object" && window.DOMParser;
if (typeof hR == "function") {
  var Wpe = new hR(), $pe = "text/html";
  y1 = function(e, t) {
    return t && (e = "<".concat(t, ">").concat(e, "</").concat(t, ">")), Wpe.parseFromString(e, $pe);
  }, Xy = y1;
}
if (typeof document == "object" && document.implementation) {
  var sm = document.implementation.createHTMLDocument();
  Xy = function(e, t) {
    if (t) {
      var n = sm.documentElement.querySelector(t);
      return n && (n.innerHTML = e), sm;
    }
    return sm.documentElement.innerHTML = e, sm;
  };
}
var am = typeof document == "object" && document.createElement("template"), b1;
am && am.content && (b1 = function(e) {
  return am.innerHTML = e, am.content.childNodes;
});
function Vpe(e) {
  var t, n;
  e = (0, Upe.escapeSpecialCharacters)(e);
  var r = e.match(Hpe), o = r && r[1] ? r[1].toLowerCase() : "";
  switch (o) {
    case cR: {
      var i = y1(e);
      if (!dR.test(e)) {
        var a = i.querySelector(pR);
        (t = a == null ? void 0 : a.parentNode) === null || t === void 0 || t.removeChild(a);
      }
      if (!fR.test(e)) {
        var a = i.querySelector(im);
        (n = a == null ? void 0 : a.parentNode) === null || n === void 0 || n.removeChild(a);
      }
      return i.querySelectorAll(cR);
    }
    case pR:
    case im: {
      var s = Xy(e).querySelectorAll(o);
      return fR.test(e) && dR.test(e) ? s[0].parentNode.childNodes : s;
    }
    default: {
      if (b1)
        return b1(e);
      var a = Xy(e, im).querySelector(im);
      return a.childNodes;
    }
  }
}
var Zpe = hr && hr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(wS, "__esModule", { value: !0 });
wS.default = Xpe;
var qpe = Zpe(CS), Gpe = Jc, Kpe = /<(![a-zA-Z\s]+)>/;
function Xpe(e) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e)
    return [];
  var t = e.match(Kpe), n = t ? t[1] : void 0;
  return (0, Gpe.formatDOM)((0, qpe.default)(e), null, n);
}
var _0 = {}, Zs = {}, P0 = {}, Ype = 0;
P0.SAME = Ype;
var Jpe = 1;
P0.CAMELCASE = Jpe;
P0.possibleStandardNames = {
  accept: 0,
  acceptCharset: 1,
  "accept-charset": "acceptCharset",
  accessKey: 1,
  action: 0,
  allowFullScreen: 1,
  alt: 0,
  as: 0,
  async: 0,
  autoCapitalize: 1,
  autoComplete: 1,
  autoCorrect: 1,
  autoFocus: 1,
  autoPlay: 1,
  autoSave: 1,
  capture: 0,
  cellPadding: 1,
  cellSpacing: 1,
  challenge: 0,
  charSet: 1,
  checked: 0,
  children: 0,
  cite: 0,
  class: "className",
  classID: 1,
  className: 1,
  cols: 0,
  colSpan: 1,
  content: 0,
  contentEditable: 1,
  contextMenu: 1,
  controls: 0,
  controlsList: 1,
  coords: 0,
  crossOrigin: 1,
  dangerouslySetInnerHTML: 1,
  data: 0,
  dateTime: 1,
  default: 0,
  defaultChecked: 1,
  defaultValue: 1,
  defer: 0,
  dir: 0,
  disabled: 0,
  disablePictureInPicture: 1,
  disableRemotePlayback: 1,
  download: 0,
  draggable: 0,
  encType: 1,
  enterKeyHint: 1,
  for: "htmlFor",
  form: 0,
  formMethod: 1,
  formAction: 1,
  formEncType: 1,
  formNoValidate: 1,
  formTarget: 1,
  frameBorder: 1,
  headers: 0,
  height: 0,
  hidden: 0,
  high: 0,
  href: 0,
  hrefLang: 1,
  htmlFor: 1,
  httpEquiv: 1,
  "http-equiv": "httpEquiv",
  icon: 0,
  id: 0,
  innerHTML: 1,
  inputMode: 1,
  integrity: 0,
  is: 0,
  itemID: 1,
  itemProp: 1,
  itemRef: 1,
  itemScope: 1,
  itemType: 1,
  keyParams: 1,
  keyType: 1,
  kind: 0,
  label: 0,
  lang: 0,
  list: 0,
  loop: 0,
  low: 0,
  manifest: 0,
  marginWidth: 1,
  marginHeight: 1,
  max: 0,
  maxLength: 1,
  media: 0,
  mediaGroup: 1,
  method: 0,
  min: 0,
  minLength: 1,
  multiple: 0,
  muted: 0,
  name: 0,
  noModule: 1,
  nonce: 0,
  noValidate: 1,
  open: 0,
  optimum: 0,
  pattern: 0,
  placeholder: 0,
  playsInline: 1,
  poster: 0,
  preload: 0,
  profile: 0,
  radioGroup: 1,
  readOnly: 1,
  referrerPolicy: 1,
  rel: 0,
  required: 0,
  reversed: 0,
  role: 0,
  rows: 0,
  rowSpan: 1,
  sandbox: 0,
  scope: 0,
  scoped: 0,
  scrolling: 0,
  seamless: 0,
  selected: 0,
  shape: 0,
  size: 0,
  sizes: 0,
  span: 0,
  spellCheck: 1,
  src: 0,
  srcDoc: 1,
  srcLang: 1,
  srcSet: 1,
  start: 0,
  step: 0,
  style: 0,
  summary: 0,
  tabIndex: 1,
  target: 0,
  title: 0,
  type: 0,
  useMap: 1,
  value: 0,
  width: 0,
  wmode: 0,
  wrap: 0,
  about: 0,
  accentHeight: 1,
  "accent-height": "accentHeight",
  accumulate: 0,
  additive: 0,
  alignmentBaseline: 1,
  "alignment-baseline": "alignmentBaseline",
  allowReorder: 1,
  alphabetic: 0,
  amplitude: 0,
  arabicForm: 1,
  "arabic-form": "arabicForm",
  ascent: 0,
  attributeName: 1,
  attributeType: 1,
  autoReverse: 1,
  azimuth: 0,
  baseFrequency: 1,
  baselineShift: 1,
  "baseline-shift": "baselineShift",
  baseProfile: 1,
  bbox: 0,
  begin: 0,
  bias: 0,
  by: 0,
  calcMode: 1,
  capHeight: 1,
  "cap-height": "capHeight",
  clip: 0,
  clipPath: 1,
  "clip-path": "clipPath",
  clipPathUnits: 1,
  clipRule: 1,
  "clip-rule": "clipRule",
  color: 0,
  colorInterpolation: 1,
  "color-interpolation": "colorInterpolation",
  colorInterpolationFilters: 1,
  "color-interpolation-filters": "colorInterpolationFilters",
  colorProfile: 1,
  "color-profile": "colorProfile",
  colorRendering: 1,
  "color-rendering": "colorRendering",
  contentScriptType: 1,
  contentStyleType: 1,
  cursor: 0,
  cx: 0,
  cy: 0,
  d: 0,
  datatype: 0,
  decelerate: 0,
  descent: 0,
  diffuseConstant: 1,
  direction: 0,
  display: 0,
  divisor: 0,
  dominantBaseline: 1,
  "dominant-baseline": "dominantBaseline",
  dur: 0,
  dx: 0,
  dy: 0,
  edgeMode: 1,
  elevation: 0,
  enableBackground: 1,
  "enable-background": "enableBackground",
  end: 0,
  exponent: 0,
  externalResourcesRequired: 1,
  fill: 0,
  fillOpacity: 1,
  "fill-opacity": "fillOpacity",
  fillRule: 1,
  "fill-rule": "fillRule",
  filter: 0,
  filterRes: 1,
  filterUnits: 1,
  floodOpacity: 1,
  "flood-opacity": "floodOpacity",
  floodColor: 1,
  "flood-color": "floodColor",
  focusable: 0,
  fontFamily: 1,
  "font-family": "fontFamily",
  fontSize: 1,
  "font-size": "fontSize",
  fontSizeAdjust: 1,
  "font-size-adjust": "fontSizeAdjust",
  fontStretch: 1,
  "font-stretch": "fontStretch",
  fontStyle: 1,
  "font-style": "fontStyle",
  fontVariant: 1,
  "font-variant": "fontVariant",
  fontWeight: 1,
  "font-weight": "fontWeight",
  format: 0,
  from: 0,
  fx: 0,
  fy: 0,
  g1: 0,
  g2: 0,
  glyphName: 1,
  "glyph-name": "glyphName",
  glyphOrientationHorizontal: 1,
  "glyph-orientation-horizontal": "glyphOrientationHorizontal",
  glyphOrientationVertical: 1,
  "glyph-orientation-vertical": "glyphOrientationVertical",
  glyphRef: 1,
  gradientTransform: 1,
  gradientUnits: 1,
  hanging: 0,
  horizAdvX: 1,
  "horiz-adv-x": "horizAdvX",
  horizOriginX: 1,
  "horiz-origin-x": "horizOriginX",
  ideographic: 0,
  imageRendering: 1,
  "image-rendering": "imageRendering",
  in2: 0,
  in: 0,
  inlist: 0,
  intercept: 0,
  k1: 0,
  k2: 0,
  k3: 0,
  k4: 0,
  k: 0,
  kernelMatrix: 1,
  kernelUnitLength: 1,
  kerning: 0,
  keyPoints: 1,
  keySplines: 1,
  keyTimes: 1,
  lengthAdjust: 1,
  letterSpacing: 1,
  "letter-spacing": "letterSpacing",
  lightingColor: 1,
  "lighting-color": "lightingColor",
  limitingConeAngle: 1,
  local: 0,
  markerEnd: 1,
  "marker-end": "markerEnd",
  markerHeight: 1,
  markerMid: 1,
  "marker-mid": "markerMid",
  markerStart: 1,
  "marker-start": "markerStart",
  markerUnits: 1,
  markerWidth: 1,
  mask: 0,
  maskContentUnits: 1,
  maskUnits: 1,
  mathematical: 0,
  mode: 0,
  numOctaves: 1,
  offset: 0,
  opacity: 0,
  operator: 0,
  order: 0,
  orient: 0,
  orientation: 0,
  origin: 0,
  overflow: 0,
  overlinePosition: 1,
  "overline-position": "overlinePosition",
  overlineThickness: 1,
  "overline-thickness": "overlineThickness",
  paintOrder: 1,
  "paint-order": "paintOrder",
  panose1: 0,
  "panose-1": "panose1",
  pathLength: 1,
  patternContentUnits: 1,
  patternTransform: 1,
  patternUnits: 1,
  pointerEvents: 1,
  "pointer-events": "pointerEvents",
  points: 0,
  pointsAtX: 1,
  pointsAtY: 1,
  pointsAtZ: 1,
  prefix: 0,
  preserveAlpha: 1,
  preserveAspectRatio: 1,
  primitiveUnits: 1,
  property: 0,
  r: 0,
  radius: 0,
  refX: 1,
  refY: 1,
  renderingIntent: 1,
  "rendering-intent": "renderingIntent",
  repeatCount: 1,
  repeatDur: 1,
  requiredExtensions: 1,
  requiredFeatures: 1,
  resource: 0,
  restart: 0,
  result: 0,
  results: 0,
  rotate: 0,
  rx: 0,
  ry: 0,
  scale: 0,
  security: 0,
  seed: 0,
  shapeRendering: 1,
  "shape-rendering": "shapeRendering",
  slope: 0,
  spacing: 0,
  specularConstant: 1,
  specularExponent: 1,
  speed: 0,
  spreadMethod: 1,
  startOffset: 1,
  stdDeviation: 1,
  stemh: 0,
  stemv: 0,
  stitchTiles: 1,
  stopColor: 1,
  "stop-color": "stopColor",
  stopOpacity: 1,
  "stop-opacity": "stopOpacity",
  strikethroughPosition: 1,
  "strikethrough-position": "strikethroughPosition",
  strikethroughThickness: 1,
  "strikethrough-thickness": "strikethroughThickness",
  string: 0,
  stroke: 0,
  strokeDasharray: 1,
  "stroke-dasharray": "strokeDasharray",
  strokeDashoffset: 1,
  "stroke-dashoffset": "strokeDashoffset",
  strokeLinecap: 1,
  "stroke-linecap": "strokeLinecap",
  strokeLinejoin: 1,
  "stroke-linejoin": "strokeLinejoin",
  strokeMiterlimit: 1,
  "stroke-miterlimit": "strokeMiterlimit",
  strokeWidth: 1,
  "stroke-width": "strokeWidth",
  strokeOpacity: 1,
  "stroke-opacity": "strokeOpacity",
  suppressContentEditableWarning: 1,
  suppressHydrationWarning: 1,
  surfaceScale: 1,
  systemLanguage: 1,
  tableValues: 1,
  targetX: 1,
  targetY: 1,
  textAnchor: 1,
  "text-anchor": "textAnchor",
  textDecoration: 1,
  "text-decoration": "textDecoration",
  textLength: 1,
  textRendering: 1,
  "text-rendering": "textRendering",
  to: 0,
  transform: 0,
  typeof: 0,
  u1: 0,
  u2: 0,
  underlinePosition: 1,
  "underline-position": "underlinePosition",
  underlineThickness: 1,
  "underline-thickness": "underlineThickness",
  unicode: 0,
  unicodeBidi: 1,
  "unicode-bidi": "unicodeBidi",
  unicodeRange: 1,
  "unicode-range": "unicodeRange",
  unitsPerEm: 1,
  "units-per-em": "unitsPerEm",
  unselectable: 0,
  vAlphabetic: 1,
  "v-alphabetic": "vAlphabetic",
  values: 0,
  vectorEffect: 1,
  "vector-effect": "vectorEffect",
  version: 0,
  vertAdvY: 1,
  "vert-adv-y": "vertAdvY",
  vertOriginX: 1,
  "vert-origin-x": "vertOriginX",
  vertOriginY: 1,
  "vert-origin-y": "vertOriginY",
  vHanging: 1,
  "v-hanging": "vHanging",
  vIdeographic: 1,
  "v-ideographic": "vIdeographic",
  viewBox: 1,
  viewTarget: 1,
  visibility: 0,
  vMathematical: 1,
  "v-mathematical": "vMathematical",
  vocab: 0,
  widths: 0,
  wordSpacing: 1,
  "word-spacing": "wordSpacing",
  writingMode: 1,
  "writing-mode": "writingMode",
  x1: 0,
  x2: 0,
  x: 0,
  xChannelSelector: 1,
  xHeight: 1,
  "x-height": "xHeight",
  xlinkActuate: 1,
  "xlink:actuate": "xlinkActuate",
  xlinkArcrole: 1,
  "xlink:arcrole": "xlinkArcrole",
  xlinkHref: 1,
  "xlink:href": "xlinkHref",
  xlinkRole: 1,
  "xlink:role": "xlinkRole",
  xlinkShow: 1,
  "xlink:show": "xlinkShow",
  xlinkTitle: 1,
  "xlink:title": "xlinkTitle",
  xlinkType: 1,
  "xlink:type": "xlinkType",
  xmlBase: 1,
  "xml:base": "xmlBase",
  xmlLang: 1,
  "xml:lang": "xmlLang",
  xmlns: 0,
  "xml:space": "xmlSpace",
  xmlnsXlink: 1,
  "xmlns:xlink": "xmlnsXlink",
  xmlSpace: 1,
  y1: 0,
  y2: 0,
  y: 0,
  yChannelSelector: 1,
  z: 0,
  zoomAndPan: 1
};
const DK = 0, pu = 1, S0 = 2, M0 = 3, LS = 4, TK = 5, jK = 6;
function Qpe(e) {
  return oi.hasOwnProperty(e) ? oi[e] : null;
}
function Ti(e, t, n, r, o, i, a) {
  this.acceptsBooleans = t === S0 || t === M0 || t === LS, this.attributeName = r, this.attributeNamespace = o, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = i, this.removeEmptyString = a;
}
const oi = {}, ede = [
  "children",
  "dangerouslySetInnerHTML",
  // TODO: This prevents the assignment of defaultValue to regular
  // elements (not just inputs). Now that ReactDOMInput assigns to the
  // defaultValue property -- do we need this?
  "defaultValue",
  "defaultChecked",
  "innerHTML",
  "suppressContentEditableWarning",
  "suppressHydrationWarning",
  "style"
];
ede.forEach((e) => {
  oi[e] = new Ti(
    e,
    DK,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"]
].forEach(([e, t]) => {
  oi[e] = new Ti(
    e,
    pu,
    !1,
    // mustUseProperty
    t,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["contentEditable", "draggable", "spellCheck", "value"].forEach((e) => {
  oi[e] = new Ti(
    e,
    S0,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha"
].forEach((e) => {
  oi[e] = new Ti(
    e,
    S0,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "allowFullScreen",
  "async",
  // Note: there is a special case that prevents it from being written to the DOM
  // on the client side because the browsers are inconsistent. Instead we call focus().
  "autoFocus",
  "autoPlay",
  "controls",
  "default",
  "defer",
  "disabled",
  "disablePictureInPicture",
  "disableRemotePlayback",
  "formNoValidate",
  "hidden",
  "loop",
  "noModule",
  "noValidate",
  "open",
  "playsInline",
  "readOnly",
  "required",
  "reversed",
  "scoped",
  "seamless",
  // Microdata
  "itemScope"
].forEach((e) => {
  oi[e] = new Ti(
    e,
    M0,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "checked",
  // Note: `option.selected` is not updated if `select.multiple` is
  // disabled with `removeAttribute`. We have special logic for handling this.
  "multiple",
  "muted",
  "selected"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  oi[e] = new Ti(
    e,
    M0,
    !0,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "capture",
  "download"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  oi[e] = new Ti(
    e,
    LS,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "cols",
  "rows",
  "size",
  "span"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  oi[e] = new Ti(
    e,
    jK,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["rowSpan", "start"].forEach((e) => {
  oi[e] = new Ti(
    e,
    TK,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const _S = /[\-\:]([a-z])/g, PS = (e) => e[1].toUpperCase();
[
  "accent-height",
  "alignment-baseline",
  "arabic-form",
  "baseline-shift",
  "cap-height",
  "clip-path",
  "clip-rule",
  "color-interpolation",
  "color-interpolation-filters",
  "color-profile",
  "color-rendering",
  "dominant-baseline",
  "enable-background",
  "fill-opacity",
  "fill-rule",
  "flood-color",
  "flood-opacity",
  "font-family",
  "font-size",
  "font-size-adjust",
  "font-stretch",
  "font-style",
  "font-variant",
  "font-weight",
  "glyph-name",
  "glyph-orientation-horizontal",
  "glyph-orientation-vertical",
  "horiz-adv-x",
  "horiz-origin-x",
  "image-rendering",
  "letter-spacing",
  "lighting-color",
  "marker-end",
  "marker-mid",
  "marker-start",
  "overline-position",
  "overline-thickness",
  "paint-order",
  "panose-1",
  "pointer-events",
  "rendering-intent",
  "shape-rendering",
  "stop-color",
  "stop-opacity",
  "strikethrough-position",
  "strikethrough-thickness",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "text-anchor",
  "text-decoration",
  "text-rendering",
  "underline-position",
  "underline-thickness",
  "unicode-bidi",
  "unicode-range",
  "units-per-em",
  "v-alphabetic",
  "v-hanging",
  "v-ideographic",
  "v-mathematical",
  "vector-effect",
  "vert-adv-y",
  "vert-origin-x",
  "vert-origin-y",
  "word-spacing",
  "writing-mode",
  "xmlns:xlink",
  "x-height"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(_S, PS);
  oi[t] = new Ti(
    t,
    pu,
    !1,
    // mustUseProperty
    e,
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xlink:actuate",
  "xlink:arcrole",
  "xlink:role",
  "xlink:show",
  "xlink:title",
  "xlink:type"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(_S, PS);
  oi[t] = new Ti(
    t,
    pu,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/1999/xlink",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xml:base",
  "xml:lang",
  "xml:space"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(_S, PS);
  oi[t] = new Ti(
    t,
    pu,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/XML/1998/namespace",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["tabIndex", "crossOrigin"].forEach((e) => {
  oi[e] = new Ti(
    e,
    pu,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const tde = "xlinkHref";
oi[tde] = new Ti(
  "xlinkHref",
  pu,
  !1,
  // mustUseProperty
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  // sanitizeURL
  !1
  // removeEmptyString
);
["src", "href", "action", "formAction"].forEach((e) => {
  oi[e] = new Ti(
    e,
    pu,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !0,
    // sanitizeURL
    !0
    // removeEmptyString
  );
});
const {
  CAMELCASE: nde,
  SAME: rde,
  possibleStandardNames: gR
} = P0, ode = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", ide = ode + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", sde = RegExp.prototype.test.bind(
  // eslint-disable-next-line no-misleading-character-class
  new RegExp("^(data|aria)-[" + ide + "]*$")
), ade = Object.keys(
  gR
).reduce((e, t) => {
  const n = gR[t];
  return n === rde ? e[t] = t : n === nde ? e[t.toLowerCase()] = t : e[t] = n, e;
}, {});
Zs.BOOLEAN = M0;
Zs.BOOLEANISH_STRING = S0;
Zs.NUMERIC = TK;
Zs.OVERLOADED_BOOLEAN = LS;
Zs.POSITIVE_NUMERIC = jK;
Zs.RESERVED = DK;
Zs.STRING = pu;
Zs.getPropertyInfo = Qpe;
Zs.isCustomAttribute = sde;
Zs.possibleStandardNames = ade;
var SS = {}, MS = {}, mR = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, lde = /\n/g, ude = /^\s*/, cde = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, pde = /^:\s*/, dde = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, fde = /^[;\s]*/, hde = /^\s+|\s+$/g, gde = `
`, vR = "/", yR = "*", sc = "", mde = "comment", vde = "declaration", yde = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e) return [];
  t = t || {};
  var n = 1, r = 1;
  function o(f) {
    var m = f.match(lde);
    m && (n += m.length);
    var b = f.lastIndexOf(gde);
    r = ~b ? f.length - b : r + f.length;
  }
  function i() {
    var f = { line: n, column: r };
    return function(m) {
      return m.position = new a(f), u(), m;
    };
  }
  function a(f) {
    this.start = f, this.end = { line: n, column: r }, this.source = t.source;
  }
  a.prototype.content = e;
  function s(f) {
    var m = new Error(
      t.source + ":" + n + ":" + r + ": " + f
    );
    if (m.reason = f, m.filename = t.source, m.line = n, m.column = r, m.source = e, !t.silent) throw m;
  }
  function l(f) {
    var m = f.exec(e);
    if (m) {
      var b = m[0];
      return o(b), e = e.slice(b.length), m;
    }
  }
  function u() {
    l(ude);
  }
  function c(f) {
    var m;
    for (f = f || []; m = p(); )
      m !== !1 && f.push(m);
    return f;
  }
  function p() {
    var f = i();
    if (!(vR != e.charAt(0) || yR != e.charAt(1))) {
      for (var m = 2; sc != e.charAt(m) && (yR != e.charAt(m) || vR != e.charAt(m + 1)); )
        ++m;
      if (m += 2, sc === e.charAt(m - 1))
        return s("End of comment missing");
      var b = e.slice(2, m - 2);
      return r += 2, o(b), e = e.slice(m), r += 2, f({
        type: mde,
        comment: b
      });
    }
  }
  function d() {
    var f = i(), m = l(cde);
    if (m) {
      if (p(), !l(pde)) return s("property missing ':'");
      var b = l(dde), E = f({
        type: vde,
        property: bR(m[0].replace(mR, sc)),
        value: b ? bR(b[0].replace(mR, sc)) : sc
      });
      return l(fde), E;
    }
  }
  function g() {
    var f = [];
    c(f);
    for (var m; m = d(); )
      m !== !1 && (f.push(m), c(f));
    return f;
  }
  return u(), g();
};
function bR(e) {
  return e ? e.replace(hde, sc) : sc;
}
var bde = hr && hr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(MS, "__esModule", { value: !0 });
MS.default = Cde;
var wde = bde(yde);
function Cde(e, t) {
  var n = null;
  if (!e || typeof e != "string")
    return n;
  var r = (0, wde.default)(e), o = typeof t == "function";
  return r.forEach(function(i) {
    if (i.type === "declaration") {
      var a = i.property, s = i.value;
      o ? t(a, s, i) : s && (n = n || {}, n[a] = s);
    }
  }), n;
}
var D0 = {};
Object.defineProperty(D0, "__esModule", { value: !0 });
D0.camelCase = void 0;
var Ode = /^--[a-zA-Z0-9_-]+$/, xde = /-([a-z])/g, Ede = /^[^-]+$/, kde = /^-(webkit|moz|ms|o|khtml)-/, Lde = /^-(ms)-/, _de = function(e) {
  return !e || Ede.test(e) || Ode.test(e);
}, Pde = function(e, t) {
  return t.toUpperCase();
}, wR = function(e, t) {
  return "".concat(t, "-");
}, Sde = function(e, t) {
  return t === void 0 && (t = {}), _de(e) ? e : (e = e.toLowerCase(), t.reactCompat ? e = e.replace(Lde, wR) : e = e.replace(kde, wR), e.replace(xde, Pde));
};
D0.camelCase = Sde;
var Mde = hr && hr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
}, Dde = Mde(MS), Tde = D0;
function w1(e, t) {
  var n = {};
  return !e || typeof e != "string" || (0, Dde.default)(e, function(r, o) {
    r && o && (n[(0, Tde.camelCase)(r, t)] = o);
  }), n;
}
w1.default = w1;
var jde = w1;
(function(e) {
  var t = hr && hr.__importDefault || function(c) {
    return c && c.__esModule ? c : { default: c };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.returnFirstArg = e.canTextBeChildOfNode = e.ELEMENTS_WITH_NO_TEXT_CHILDREN = e.PRESERVE_CUSTOM_ATTRIBUTES = void 0, e.isCustomComponent = i, e.setStyleProp = s;
  var n = be, r = t(jde), o = /* @__PURE__ */ new Set([
    "annotation-xml",
    "color-profile",
    "font-face",
    "font-face-src",
    "font-face-uri",
    "font-face-format",
    "font-face-name",
    "missing-glyph"
  ]);
  function i(c, p) {
    return c.includes("-") ? !o.has(c) : !!(p && typeof p.is == "string");
  }
  var a = {
    reactCompat: !0
  };
  function s(c, p) {
    if (typeof c == "string") {
      if (!c.trim()) {
        p.style = {};
        return;
      }
      try {
        p.style = (0, r.default)(c, a);
      } catch {
        p.style = {};
      }
    }
  }
  e.PRESERVE_CUSTOM_ATTRIBUTES = Number(n.version.split(".")[0]) >= 16, e.ELEMENTS_WITH_NO_TEXT_CHILDREN = /* @__PURE__ */ new Set([
    "tr",
    "tbody",
    "thead",
    "tfoot",
    "colgroup",
    "table",
    "head",
    "html",
    "frameset"
  ]);
  var l = function(c) {
    return !e.ELEMENTS_WITH_NO_TEXT_CHILDREN.has(c.name);
  };
  e.canTextBeChildOfNode = l;
  var u = function(c) {
    return c;
  };
  e.returnFirstArg = u;
})(SS);
Object.defineProperty(_0, "__esModule", { value: !0 });
_0.default = Nde;
var Vd = Zs, CR = SS, Ade = ["checked", "value"], Rde = ["input", "select", "textarea"], Ide = {
  reset: !0,
  submit: !0
};
function Nde(e, t) {
  e === void 0 && (e = {});
  var n = {}, r = !!(e.type && Ide[e.type]);
  for (var o in e) {
    var i = e[o];
    if ((0, Vd.isCustomAttribute)(o)) {
      n[o] = i;
      continue;
    }
    var a = o.toLowerCase(), s = OR(a);
    if (s) {
      var l = (0, Vd.getPropertyInfo)(s);
      switch (Ade.includes(s) && Rde.includes(t) && !r && (s = OR("default" + a)), n[s] = i, l && l.type) {
        case Vd.BOOLEAN:
          n[s] = !0;
          break;
        case Vd.OVERLOADED_BOOLEAN:
          i === "" && (n[s] = !0);
          break;
      }
      continue;
    }
    CR.PRESERVE_CUSTOM_ATTRIBUTES && (n[o] = i);
  }
  return (0, CR.setStyleProp)(e.style, n), n;
}
function OR(e) {
  return Vd.possibleStandardNames[e];
}
var DS = {}, Bde = hr && hr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(DS, "__esModule", { value: !0 });
DS.default = AK;
var yx = be, Fde = Bde(_0), uf = SS, zde = {
  cloneElement: yx.cloneElement,
  createElement: yx.createElement,
  isValidElement: yx.isValidElement
};
function AK(e, t) {
  t === void 0 && (t = {});
  for (var n = [], r = typeof t.replace == "function", o = t.transform || uf.returnFirstArg, i = t.library || zde, a = i.cloneElement, s = i.createElement, l = i.isValidElement, u = e.length, c = 0; c < u; c++) {
    var p = e[c];
    if (r) {
      var d = t.replace(p, c);
      if (l(d)) {
        u > 1 && (d = a(d, {
          key: d.key || c
        })), n.push(o(d, p, c));
        continue;
      }
    }
    if (p.type === "text") {
      var g = !p.data.trim().length;
      if (g && p.parent && !(0, uf.canTextBeChildOfNode)(p.parent) || t.trim && g)
        continue;
      n.push(o(p.data, p, c));
      continue;
    }
    var f = p, m = {};
    Ude(f) ? ((0, uf.setStyleProp)(f.attribs.style, f.attribs), m = f.attribs) : f.attribs && (m = (0, Fde.default)(f.attribs, f.name));
    var b = void 0;
    switch (p.type) {
      case "script":
      case "style":
        p.children[0] && (m.dangerouslySetInnerHTML = {
          __html: p.children[0].data
        });
        break;
      case "tag":
        p.name === "textarea" && p.children[0] ? m.defaultValue = p.children[0].data : p.children && p.children.length && (b = AK(p.children, t));
        break;
      default:
        continue;
    }
    u > 1 && (m.key = c), n.push(o(s(p.name, m, b), p, c));
  }
  return n.length === 1 ? n[0] : n;
}
function Ude(e) {
  return uf.PRESERVE_CUSTOM_ATTRIBUTES && e.type === "tag" && (0, uf.isCustomComponent)(e.name, e.attribs);
}
(function(e) {
  var t = hr && hr.__importDefault || function(l) {
    return l && l.__esModule ? l : { default: l };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.htmlToDOM = e.domToReact = e.attributesToProps = e.Text = e.ProcessingInstruction = e.Element = e.Comment = void 0, e.default = s;
  var n = t(wS);
  e.htmlToDOM = n.default;
  var r = t(_0);
  e.attributesToProps = r.default;
  var o = t(DS);
  e.domToReact = o.default;
  var i = OS;
  Object.defineProperty(e, "Comment", { enumerable: !0, get: function() {
    return i.Comment;
  } }), Object.defineProperty(e, "Element", { enumerable: !0, get: function() {
    return i.Element;
  } }), Object.defineProperty(e, "ProcessingInstruction", { enumerable: !0, get: function() {
    return i.ProcessingInstruction;
  } }), Object.defineProperty(e, "Text", { enumerable: !0, get: function() {
    return i.Text;
  } });
  var a = { lowerCaseAttributeNames: !1 };
  function s(l, u) {
    if (typeof l != "string")
      throw new TypeError("First argument must be a string");
    return l ? (0, o.default)((0, n.default)(l, (u == null ? void 0 : u.htmlparser2) || a), u) : [];
  }
})(hK);
const xR = /* @__PURE__ */ ape(hK);
xR.default;
function Hde(e) {
  const {
    className: t,
    orientation: n = "horizontal",
    ...r
  } = e, o = `arkynDivider ${n} ${t}`;
  return /* @__PURE__ */ Fn.jsx("div", { className: o.trim(), ...r });
}
var gr = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Wde(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var C1 = { exports: {} }, id = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var ER;
function $de() {
  if (ER) return id;
  ER = 1;
  var e = be, t = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, o = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, i = { key: !0, ref: !0, __self: !0, __source: !0 };
  function a(s, l, u) {
    var c, p = {}, d = null, g = null;
    u !== void 0 && (d = "" + u), l.key !== void 0 && (d = "" + l.key), l.ref !== void 0 && (g = l.ref);
    for (c in l) r.call(l, c) && !i.hasOwnProperty(c) && (p[c] = l[c]);
    if (s && s.defaultProps) for (c in l = s.defaultProps, l) p[c] === void 0 && (p[c] = l[c]);
    return { $$typeof: t, type: s, key: d, ref: g, props: p, _owner: o.current };
  }
  return id.Fragment = n, id.jsx = a, id.jsxs = a, id;
}
var lm = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var kR;
function Vde() {
  return kR || (kR = 1, process.env.NODE_ENV !== "production" && function() {
    var e = be, t = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), a = Symbol.for("react.provider"), s = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), c = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), d = Symbol.for("react.lazy"), g = Symbol.for("react.offscreen"), f = Symbol.iterator, m = "@@iterator";
    function b(y) {
      if (y === null || typeof y != "object")
        return null;
      var R = f && y[f] || y[m];
      return typeof R == "function" ? R : null;
    }
    var E = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function w(y) {
      {
        for (var R = arguments.length, G = new Array(R > 1 ? R - 1 : 0), ne = 1; ne < R; ne++)
          G[ne - 1] = arguments[ne];
        M("error", y, G);
      }
    }
    function M(y, R, G) {
      {
        var ne = E.ReactDebugCurrentFrame, ae = ne.getStackAddendum();
        ae !== "" && (R += "%s", G = G.concat([ae]));
        var ue = G.map(function(se) {
          return String(se);
        });
        ue.unshift("Warning: " + R), Function.prototype.apply.call(console[y], console, ue);
      }
    }
    var x = !1, v = !1, C = !1, P = !1, F = !1, L;
    L = Symbol.for("react.module.reference");
    function B(y) {
      return !!(typeof y == "string" || typeof y == "function" || y === r || y === i || F || y === o || y === u || y === c || P || y === g || x || v || C || typeof y == "object" && y !== null && (y.$$typeof === d || y.$$typeof === p || y.$$typeof === a || y.$$typeof === s || y.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      y.$$typeof === L || y.getModuleId !== void 0));
    }
    function N(y, R, G) {
      var ne = y.displayName;
      if (ne)
        return ne;
      var ae = R.displayName || R.name || "";
      return ae !== "" ? G + "(" + ae + ")" : G;
    }
    function $(y) {
      return y.displayName || "Context";
    }
    function V(y) {
      if (y == null)
        return null;
      if (typeof y.tag == "number" && w("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof y == "function")
        return y.displayName || y.name || null;
      if (typeof y == "string")
        return y;
      switch (y) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case i:
          return "Profiler";
        case o:
          return "StrictMode";
        case u:
          return "Suspense";
        case c:
          return "SuspenseList";
      }
      if (typeof y == "object")
        switch (y.$$typeof) {
          case s:
            var R = y;
            return $(R) + ".Consumer";
          case a:
            var G = y;
            return $(G._context) + ".Provider";
          case l:
            return N(y, y.render, "ForwardRef");
          case p:
            var ne = y.displayName || null;
            return ne !== null ? ne : V(y.type) || "Memo";
          case d: {
            var ae = y, ue = ae._payload, se = ae._init;
            try {
              return V(se(ue));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var H = Object.assign, Z = 0, K, Y, Q, J, _, D, z;
    function S() {
    }
    S.__reactDisabledLog = !0;
    function W() {
      {
        if (Z === 0) {
          K = console.log, Y = console.info, Q = console.warn, J = console.error, _ = console.group, D = console.groupCollapsed, z = console.groupEnd;
          var y = {
            configurable: !0,
            enumerable: !0,
            value: S,
            writable: !0
          };
          Object.defineProperties(console, {
            info: y,
            log: y,
            warn: y,
            error: y,
            group: y,
            groupCollapsed: y,
            groupEnd: y
          });
        }
        Z++;
      }
    }
    function O() {
      {
        if (Z--, Z === 0) {
          var y = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: H({}, y, {
              value: K
            }),
            info: H({}, y, {
              value: Y
            }),
            warn: H({}, y, {
              value: Q
            }),
            error: H({}, y, {
              value: J
            }),
            group: H({}, y, {
              value: _
            }),
            groupCollapsed: H({}, y, {
              value: D
            }),
            groupEnd: H({}, y, {
              value: z
            })
          });
        }
        Z < 0 && w("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var j = E.ReactCurrentDispatcher, U;
    function T(y, R, G) {
      {
        if (U === void 0)
          try {
            throw Error();
          } catch (ae) {
            var ne = ae.stack.trim().match(/\n( *(at )?)/);
            U = ne && ne[1] || "";
          }
        return `
` + U + y;
      }
    }
    var q = !1, A;
    {
      var X = typeof WeakMap == "function" ? WeakMap : Map;
      A = new X();
    }
    function I(y, R) {
      if (!y || q)
        return "";
      {
        var G = A.get(y);
        if (G !== void 0)
          return G;
      }
      var ne;
      q = !0;
      var ae = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var ue;
      ue = j.current, j.current = null, W();
      try {
        if (R) {
          var se = function() {
            throw Error();
          };
          if (Object.defineProperty(se.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(se, []);
            } catch (je) {
              ne = je;
            }
            Reflect.construct(y, [], se);
          } else {
            try {
              se.call();
            } catch (je) {
              ne = je;
            }
            y.call(se.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (je) {
            ne = je;
          }
          y();
        }
      } catch (je) {
        if (je && ne && typeof je.stack == "string") {
          for (var ie = je.stack.split(`
`), Oe = ne.stack.split(`
`), de = ie.length - 1, fe = Oe.length - 1; de >= 1 && fe >= 0 && ie[de] !== Oe[fe]; )
            fe--;
          for (; de >= 1 && fe >= 0; de--, fe--)
            if (ie[de] !== Oe[fe]) {
              if (de !== 1 || fe !== 1)
                do
                  if (de--, fe--, fe < 0 || ie[de] !== Oe[fe]) {
                    var ze = `
` + ie[de].replace(" at new ", " at ");
                    return y.displayName && ze.includes("<anonymous>") && (ze = ze.replace("<anonymous>", y.displayName)), typeof y == "function" && A.set(y, ze), ze;
                  }
                while (de >= 1 && fe >= 0);
              break;
            }
        }
      } finally {
        q = !1, j.current = ue, O(), Error.prepareStackTrace = ae;
      }
      var Et = y ? y.displayName || y.name : "", bt = Et ? T(Et) : "";
      return typeof y == "function" && A.set(y, bt), bt;
    }
    function le(y, R, G) {
      return I(y, !1);
    }
    function he(y) {
      var R = y.prototype;
      return !!(R && R.isReactComponent);
    }
    function oe(y, R, G) {
      if (y == null)
        return "";
      if (typeof y == "function")
        return I(y, he(y));
      if (typeof y == "string")
        return T(y);
      switch (y) {
        case u:
          return T("Suspense");
        case c:
          return T("SuspenseList");
      }
      if (typeof y == "object")
        switch (y.$$typeof) {
          case l:
            return le(y.render);
          case p:
            return oe(y.type, R, G);
          case d: {
            var ne = y, ae = ne._payload, ue = ne._init;
            try {
              return oe(ue(ae), R, G);
            } catch {
            }
          }
        }
      return "";
    }
    var Ae = Object.prototype.hasOwnProperty, Ue = {}, He = E.ReactDebugCurrentFrame;
    function Re(y) {
      if (y) {
        var R = y._owner, G = oe(y.type, y._source, R ? R.type : null);
        He.setExtraStackFrame(G);
      } else
        He.setExtraStackFrame(null);
    }
    function nt(y, R, G, ne, ae) {
      {
        var ue = Function.call.bind(Ae);
        for (var se in y)
          if (ue(y, se)) {
            var ie = void 0;
            try {
              if (typeof y[se] != "function") {
                var Oe = Error((ne || "React class") + ": " + G + " type `" + se + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof y[se] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw Oe.name = "Invariant Violation", Oe;
              }
              ie = y[se](R, se, ne, G, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (de) {
              ie = de;
            }
            ie && !(ie instanceof Error) && (Re(ae), w("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", ne || "React class", G, se, typeof ie), Re(null)), ie instanceof Error && !(ie.message in Ue) && (Ue[ie.message] = !0, Re(ae), w("Failed %s type: %s", G, ie.message), Re(null));
          }
      }
    }
    var Ve = Array.isArray;
    function we(y) {
      return Ve(y);
    }
    function et(y) {
      {
        var R = typeof Symbol == "function" && Symbol.toStringTag, G = R && y[Symbol.toStringTag] || y.constructor.name || "Object";
        return G;
      }
    }
    function lt(y) {
      try {
        return ye(y), !1;
      } catch {
        return !0;
      }
    }
    function ye(y) {
      return "" + y;
    }
    function ke(y) {
      if (lt(y))
        return w("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", et(y)), ye(y);
    }
    var Qe = E.ReactCurrentOwner, Fe = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, Ie, ot;
    function Ee(y) {
      if (Ae.call(y, "ref")) {
        var R = Object.getOwnPropertyDescriptor(y, "ref").get;
        if (R && R.isReactWarning)
          return !1;
      }
      return y.ref !== void 0;
    }
    function wt(y) {
      if (Ae.call(y, "key")) {
        var R = Object.getOwnPropertyDescriptor(y, "key").get;
        if (R && R.isReactWarning)
          return !1;
      }
      return y.key !== void 0;
    }
    function it(y, R) {
      typeof y.ref == "string" && Qe.current;
    }
    function st(y, R) {
      {
        var G = function() {
          Ie || (Ie = !0, w("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", R));
        };
        G.isReactWarning = !0, Object.defineProperty(y, "key", {
          get: G,
          configurable: !0
        });
      }
    }
    function ut(y, R) {
      {
        var G = function() {
          ot || (ot = !0, w("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", R));
        };
        G.isReactWarning = !0, Object.defineProperty(y, "ref", {
          get: G,
          configurable: !0
        });
      }
    }
    var Ct = function(y, R, G, ne, ae, ue, se) {
      var ie = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: y,
        key: R,
        ref: G,
        props: se,
        // Record the component responsible for creating this element.
        _owner: ue
      };
      return ie._store = {}, Object.defineProperty(ie._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(ie, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ne
      }), Object.defineProperty(ie, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ae
      }), Object.freeze && (Object.freeze(ie.props), Object.freeze(ie)), ie;
    };
    function ct(y, R, G, ne, ae) {
      {
        var ue, se = {}, ie = null, Oe = null;
        G !== void 0 && (ke(G), ie = "" + G), wt(R) && (ke(R.key), ie = "" + R.key), Ee(R) && (Oe = R.ref, it(R));
        for (ue in R)
          Ae.call(R, ue) && !Fe.hasOwnProperty(ue) && (se[ue] = R[ue]);
        if (y && y.defaultProps) {
          var de = y.defaultProps;
          for (ue in de)
            se[ue] === void 0 && (se[ue] = de[ue]);
        }
        if (ie || Oe) {
          var fe = typeof y == "function" ? y.displayName || y.name || "Unknown" : y;
          ie && st(se, fe), Oe && ut(se, fe);
        }
        return Ct(y, ie, Oe, ae, ne, Qe.current, se);
      }
    }
    var pt = E.ReactCurrentOwner, rt = E.ReactDebugCurrentFrame;
    function We(y) {
      if (y) {
        var R = y._owner, G = oe(y.type, y._source, R ? R.type : null);
        rt.setExtraStackFrame(G);
      } else
        rt.setExtraStackFrame(null);
    }
    var Ot;
    Ot = !1;
    function xt(y) {
      return typeof y == "object" && y !== null && y.$$typeof === t;
    }
    function gt() {
      {
        if (pt.current) {
          var y = V(pt.current.type);
          if (y)
            return `

Check the render method of \`` + y + "`.";
        }
        return "";
      }
    }
    function Ht(y) {
      return "";
    }
    var mt = {};
    function Wt(y) {
      {
        var R = gt();
        if (!R) {
          var G = typeof y == "string" ? y : y.displayName || y.name;
          G && (R = `

Check the top-level render call using <` + G + ">.");
        }
        return R;
      }
    }
    function vt(y, R) {
      {
        if (!y._store || y._store.validated || y.key != null)
          return;
        y._store.validated = !0;
        var G = Wt(R);
        if (mt[G])
          return;
        mt[G] = !0;
        var ne = "";
        y && y._owner && y._owner !== pt.current && (ne = " It was passed a child from " + V(y._owner.type) + "."), We(y), w('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', G, ne), We(null);
      }
    }
    function kt(y, R) {
      {
        if (typeof y != "object")
          return;
        if (we(y))
          for (var G = 0; G < y.length; G++) {
            var ne = y[G];
            xt(ne) && vt(ne, R);
          }
        else if (xt(y))
          y._store && (y._store.validated = !0);
        else if (y) {
          var ae = b(y);
          if (typeof ae == "function" && ae !== y.entries)
            for (var ue = ae.call(y), se; !(se = ue.next()).done; )
              xt(se.value) && vt(se.value, R);
        }
      }
    }
    function Un(y) {
      {
        var R = y.type;
        if (R == null || typeof R == "string")
          return;
        var G;
        if (typeof R == "function")
          G = R.propTypes;
        else if (typeof R == "object" && (R.$$typeof === l || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        R.$$typeof === p))
          G = R.propTypes;
        else
          return;
        if (G) {
          var ne = V(R);
          nt(G, y.props, "prop", ne, y);
        } else if (R.PropTypes !== void 0 && !Ot) {
          Ot = !0;
          var ae = V(R);
          w("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", ae || "Unknown");
        }
        typeof R.getDefaultProps == "function" && !R.getDefaultProps.isReactClassApproved && w("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function yt(y) {
      {
        for (var R = Object.keys(y.props), G = 0; G < R.length; G++) {
          var ne = R[G];
          if (ne !== "children" && ne !== "key") {
            We(y), w("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", ne), We(null);
            break;
          }
        }
        y.ref !== null && (We(y), w("Invalid attribute `ref` supplied to `React.Fragment`."), We(null));
      }
    }
    var re = {};
    function ao(y, R, G, ne, ae, ue) {
      {
        var se = B(y);
        if (!se) {
          var ie = "";
          (y === void 0 || typeof y == "object" && y !== null && Object.keys(y).length === 0) && (ie += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var Oe = Ht();
          Oe ? ie += Oe : ie += gt();
          var de;
          y === null ? de = "null" : we(y) ? de = "array" : y !== void 0 && y.$$typeof === t ? (de = "<" + (V(y.type) || "Unknown") + " />", ie = " Did you accidentally export a JSX literal instead of a component?") : de = typeof y, w("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", de, ie);
        }
        var fe = ct(y, R, G, ae, ue);
        if (fe == null)
          return fe;
        if (se) {
          var ze = R.children;
          if (ze !== void 0)
            if (ne)
              if (we(ze)) {
                for (var Et = 0; Et < ze.length; Et++)
                  kt(ze[Et], y);
                Object.freeze && Object.freeze(ze);
              } else
                w("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              kt(ze, y);
        }
        if (Ae.call(R, "key")) {
          var bt = V(y), je = Object.keys(R).filter(function(Li) {
            return Li !== "key";
          }), Hn = je.length > 0 ? "{key: someKey, " + je.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!re[bt + Hn]) {
            var ki = je.length > 0 ? "{" + je.join(": ..., ") + ": ...}" : "{}";
            w(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, Hn, bt, ki, bt), re[bt + Hn] = !0;
          }
        }
        return y === r ? yt(fe) : Un(fe), fe;
      }
    }
    function Ci(y, R, G) {
      return ao(y, R, G, !0);
    }
    function Oi(y, R, G) {
      return ao(y, R, G, !1);
    }
    var xi = Oi, Ei = Ci;
    lm.Fragment = r, lm.jsx = xi, lm.jsxs = Ei;
  }()), lm;
}
process.env.NODE_ENV === "production" ? C1.exports = $de() : C1.exports = Vde();
var Yo = C1.exports;
$e({});
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function LR(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function di(e) {
  var t, n;
  return LR(e) === !1 ? !1 : (t = e.constructor, t === void 0 ? !0 : (n = t.prototype, !(LR(n) === !1 || n.hasOwnProperty("isPrototypeOf") === !1)));
}
var RK = Symbol.for("immer-nothing"), _R = Symbol.for("immer-draftable"), Os = Symbol.for("immer-state"), Zde = process.env.NODE_ENV !== "production" ? [
  // All error codes, starting by 0:
  function(e) {
    return `The plugin for '${e}' has not been loaded into Immer. To enable the plugin, import and call \`enable${e}()\` when initializing your application.`;
  },
  function(e) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${e}'`;
  },
  "This object has been frozen and should not be mutated",
  function(e) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + e;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(e) {
    return `'current' expects a draft, got: ${e}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(e) {
    return `'original' expects a draft, got: ${e}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function Wi(e, ...t) {
  if (process.env.NODE_ENV !== "production") {
    const n = Zde[e], r = typeof n == "function" ? n.apply(null, t) : n;
    throw new Error(`[Immer] ${r}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var Op = Object.getPrototypeOf;
function jc(e) {
  return !!e && !!e[Os];
}
function Ac(e) {
  var t;
  return e ? IK(e) || Array.isArray(e) || !!e[_R] || !!((t = e.constructor) != null && t[_R]) || j0(e) || A0(e) : !1;
}
var qde = Object.prototype.constructor.toString();
function IK(e) {
  if (!e || typeof e != "object")
    return !1;
  const t = Op(e);
  if (t === null)
    return !0;
  const n = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
  return n === Object ? !0 : typeof n == "function" && Function.toString.call(n) === qde;
}
function Yy(e, t) {
  T0(e) === 0 ? Reflect.ownKeys(e).forEach((n) => {
    t(n, e[n], e);
  }) : e.forEach((n, r) => t(r, n, e));
}
function T0(e) {
  const t = e[Os];
  return t ? t.type_ : Array.isArray(e) ? 1 : j0(e) ? 2 : A0(e) ? 3 : 0;
}
function O1(e, t) {
  return T0(e) === 2 ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t);
}
function NK(e, t, n) {
  const r = T0(e);
  r === 2 ? e.set(t, n) : r === 3 ? e.add(n) : e[t] = n;
}
function Gde(e, t) {
  return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && t !== t;
}
function j0(e) {
  return e instanceof Map;
}
function A0(e) {
  return e instanceof Set;
}
function Ju(e) {
  return e.copy_ || e.base_;
}
function x1(e, t) {
  if (j0(e))
    return new Map(e);
  if (A0(e))
    return new Set(e);
  if (Array.isArray(e))
    return Array.prototype.slice.call(e);
  const n = IK(e);
  if (t === !0 || t === "class_only" && !n) {
    const r = Object.getOwnPropertyDescriptors(e);
    delete r[Os];
    let o = Reflect.ownKeys(r);
    for (let i = 0; i < o.length; i++) {
      const a = o[i], s = r[a];
      s.writable === !1 && (s.writable = !0, s.configurable = !0), (s.get || s.set) && (r[a] = {
        configurable: !0,
        writable: !0,
        // could live with !!desc.set as well here...
        enumerable: s.enumerable,
        value: e[a]
      });
    }
    return Object.create(Op(e), r);
  } else {
    const r = Op(e);
    if (r !== null && n)
      return { ...e };
    const o = Object.create(r);
    return Object.assign(o, e);
  }
}
function TS(e, t = !1) {
  return R0(e) || jc(e) || !Ac(e) || (T0(e) > 1 && (e.set = e.add = e.clear = e.delete = Kde), Object.freeze(e), t && Object.entries(e).forEach(([n, r]) => TS(r, !0))), e;
}
function Kde() {
  Wi(2);
}
function R0(e) {
  return Object.isFrozen(e);
}
var Xde = {};
function Rc(e) {
  const t = Xde[e];
  return t || Wi(0, e), t;
}
var Yf;
function BK() {
  return Yf;
}
function Yde(e, t) {
  return {
    drafts_: [],
    parent_: e,
    immer_: t,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0
  };
}
function PR(e, t) {
  t && (Rc("Patches"), e.patches_ = [], e.inversePatches_ = [], e.patchListener_ = t);
}
function E1(e) {
  k1(e), e.drafts_.forEach(Jde), e.drafts_ = null;
}
function k1(e) {
  e === Yf && (Yf = e.parent_);
}
function SR(e) {
  return Yf = Yde(Yf, e);
}
function Jde(e) {
  const t = e[Os];
  t.type_ === 0 || t.type_ === 1 ? t.revoke_() : t.revoked_ = !0;
}
function MR(e, t) {
  t.unfinalizedDrafts_ = t.drafts_.length;
  const n = t.drafts_[0];
  return e !== void 0 && e !== n ? (n[Os].modified_ && (E1(t), Wi(4)), Ac(e) && (e = Jy(t, e), t.parent_ || Qy(t, e)), t.patches_ && Rc("Patches").generateReplacementPatches_(
    n[Os].base_,
    e,
    t.patches_,
    t.inversePatches_
  )) : e = Jy(t, n, []), E1(t), t.patches_ && t.patchListener_(t.patches_, t.inversePatches_), e !== RK ? e : void 0;
}
function Jy(e, t, n) {
  if (R0(t))
    return t;
  const r = t[Os];
  if (!r)
    return Yy(
      t,
      (o, i) => DR(e, r, t, o, i, n)
    ), t;
  if (r.scope_ !== e)
    return t;
  if (!r.modified_)
    return Qy(e, r.base_, !0), r.base_;
  if (!r.finalized_) {
    r.finalized_ = !0, r.scope_.unfinalizedDrafts_--;
    const o = r.copy_;
    let i = o, a = !1;
    r.type_ === 3 && (i = new Set(o), o.clear(), a = !0), Yy(
      i,
      (s, l) => DR(e, r, o, s, l, n, a)
    ), Qy(e, o, !1), n && e.patches_ && Rc("Patches").generatePatches_(
      r,
      n,
      e.patches_,
      e.inversePatches_
    );
  }
  return r.copy_;
}
function DR(e, t, n, r, o, i, a) {
  if (process.env.NODE_ENV !== "production" && o === n && Wi(5), jc(o)) {
    const s = i && t && t.type_ !== 3 && // Set objects are atomic since they have no keys.
    !O1(t.assigned_, r) ? i.concat(r) : void 0, l = Jy(e, o, s);
    if (NK(n, r, l), jc(l))
      e.canAutoFreeze_ = !1;
    else
      return;
  } else a && n.add(o);
  if (Ac(o) && !R0(o)) {
    if (!e.immer_.autoFreeze_ && e.unfinalizedDrafts_ < 1)
      return;
    Jy(e, o), (!t || !t.scope_.parent_) && typeof r != "symbol" && Object.prototype.propertyIsEnumerable.call(n, r) && Qy(e, o);
  }
}
function Qy(e, t, n = !1) {
  !e.parent_ && e.immer_.autoFreeze_ && e.canAutoFreeze_ && TS(t, n);
}
function Qde(e, t) {
  const n = Array.isArray(e), r = {
    type_: n ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: t ? t.scope_ : BK(),
    // True for both shallow and deep changes.
    modified_: !1,
    // Used during finalization.
    finalized_: !1,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: t,
    // The base state.
    base_: e,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: !1
  };
  let o = r, i = jS;
  n && (o = [r], i = Jf);
  const { revoke: a, proxy: s } = Proxy.revocable(o, i);
  return r.draft_ = s, r.revoke_ = a, s;
}
var jS = {
  get(e, t) {
    if (t === Os)
      return e;
    const n = Ju(e);
    if (!O1(n, t))
      return efe(e, n, t);
    const r = n[t];
    return e.finalized_ || !Ac(r) ? r : r === bx(e.base_, t) ? (wx(e), e.copy_[t] = _1(r, e)) : r;
  },
  has(e, t) {
    return t in Ju(e);
  },
  ownKeys(e) {
    return Reflect.ownKeys(Ju(e));
  },
  set(e, t, n) {
    const r = FK(Ju(e), t);
    if (r != null && r.set)
      return r.set.call(e.draft_, n), !0;
    if (!e.modified_) {
      const o = bx(Ju(e), t), i = o == null ? void 0 : o[Os];
      if (i && i.base_ === n)
        return e.copy_[t] = n, e.assigned_[t] = !1, !0;
      if (Gde(n, o) && (n !== void 0 || O1(e.base_, t)))
        return !0;
      wx(e), L1(e);
    }
    return e.copy_[t] === n && // special case: handle new props with value 'undefined'
    (n !== void 0 || t in e.copy_) || // special case: NaN
    Number.isNaN(n) && Number.isNaN(e.copy_[t]) || (e.copy_[t] = n, e.assigned_[t] = !0), !0;
  },
  deleteProperty(e, t) {
    return bx(e.base_, t) !== void 0 || t in e.base_ ? (e.assigned_[t] = !1, wx(e), L1(e)) : delete e.assigned_[t], e.copy_ && delete e.copy_[t], !0;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(e, t) {
    const n = Ju(e), r = Reflect.getOwnPropertyDescriptor(n, t);
    return r && {
      writable: !0,
      configurable: e.type_ !== 1 || t !== "length",
      enumerable: r.enumerable,
      value: n[t]
    };
  },
  defineProperty() {
    Wi(11);
  },
  getPrototypeOf(e) {
    return Op(e.base_);
  },
  setPrototypeOf() {
    Wi(12);
  }
}, Jf = {};
Yy(jS, (e, t) => {
  Jf[e] = function() {
    return arguments[0] = arguments[0][0], t.apply(this, arguments);
  };
});
Jf.deleteProperty = function(e, t) {
  return process.env.NODE_ENV !== "production" && isNaN(parseInt(t)) && Wi(13), Jf.set.call(this, e, t, void 0);
};
Jf.set = function(e, t, n) {
  return process.env.NODE_ENV !== "production" && t !== "length" && isNaN(parseInt(t)) && Wi(14), jS.set.call(this, e[0], t, n, e[0]);
};
function bx(e, t) {
  const n = e[Os];
  return (n ? Ju(n) : e)[t];
}
function efe(e, t, n) {
  var r;
  const o = FK(t, n);
  return o ? "value" in o ? o.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (r = o.get) == null ? void 0 : r.call(e.draft_)
  ) : void 0;
}
function FK(e, t) {
  if (!(t in e))
    return;
  let n = Op(e);
  for (; n; ) {
    const r = Object.getOwnPropertyDescriptor(n, t);
    if (r)
      return r;
    n = Op(n);
  }
}
function L1(e) {
  e.modified_ || (e.modified_ = !0, e.parent_ && L1(e.parent_));
}
function wx(e) {
  e.copy_ || (e.copy_ = x1(
    e.base_,
    e.scope_.immer_.useStrictShallowCopy_
  ));
}
var tfe = class {
  constructor(e) {
    this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.produce = (t, n, r) => {
      if (typeof t == "function" && typeof n != "function") {
        const i = n;
        n = t;
        const a = this;
        return function(s = i, ...l) {
          return a.produce(s, (u) => n.call(this, u, ...l));
        };
      }
      typeof n != "function" && Wi(6), r !== void 0 && typeof r != "function" && Wi(7);
      let o;
      if (Ac(t)) {
        const i = SR(this), a = _1(t, void 0);
        let s = !0;
        try {
          o = n(a), s = !1;
        } finally {
          s ? E1(i) : k1(i);
        }
        return PR(i, r), MR(o, i);
      } else if (!t || typeof t != "object") {
        if (o = n(t), o === void 0 && (o = t), o === RK && (o = void 0), this.autoFreeze_ && TS(o, !0), r) {
          const i = [], a = [];
          Rc("Patches").generateReplacementPatches_(t, o, i, a), r(i, a);
        }
        return o;
      } else
        Wi(1, t);
    }, this.produceWithPatches = (t, n) => {
      if (typeof t == "function")
        return (i, ...a) => this.produceWithPatches(i, (s) => t(s, ...a));
      let r, o;
      return [this.produce(t, n, (i, a) => {
        r = i, o = a;
      }), r, o];
    }, typeof (e == null ? void 0 : e.autoFreeze) == "boolean" && this.setAutoFreeze(e.autoFreeze), typeof (e == null ? void 0 : e.useStrictShallowCopy) == "boolean" && this.setUseStrictShallowCopy(e.useStrictShallowCopy);
  }
  createDraft(e) {
    Ac(e) || Wi(8), jc(e) && (e = nfe(e));
    const t = SR(this), n = _1(e, void 0);
    return n[Os].isManual_ = !0, k1(t), n;
  }
  finishDraft(e, t) {
    const n = e && e[Os];
    (!n || !n.isManual_) && Wi(9);
    const { scope_: r } = n;
    return PR(r, t), MR(void 0, r);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(e) {
    this.autoFreeze_ = e;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(e) {
    this.useStrictShallowCopy_ = e;
  }
  applyPatches(e, t) {
    let n;
    for (n = t.length - 1; n >= 0; n--) {
      const o = t[n];
      if (o.path.length === 0 && o.op === "replace") {
        e = o.value;
        break;
      }
    }
    n > -1 && (t = t.slice(n + 1));
    const r = Rc("Patches").applyPatches_;
    return jc(e) ? r(e, t) : this.produce(
      e,
      (o) => r(o, t)
    );
  }
};
function _1(e, t) {
  const n = j0(e) ? Rc("MapSet").proxyMap_(e, t) : A0(e) ? Rc("MapSet").proxySet_(e, t) : Qde(e, t);
  return (t ? t.scope_ : BK()).drafts_.push(n), n;
}
function nfe(e) {
  return jc(e) || Wi(10, e), zK(e);
}
function zK(e) {
  if (!Ac(e) || R0(e))
    return e;
  const t = e[Os];
  let n;
  if (t) {
    if (!t.modified_)
      return t.base_;
    t.finalized_ = !0, n = x1(e, t.scope_.immer_.useStrictShallowCopy_);
  } else
    n = x1(e, !0);
  return Yy(n, (r, o) => {
    NK(n, r, zK(o));
  }), t && (t.finalized_ = !1), n;
}
var xs = new tfe(), AS = xs.produce;
xs.produceWithPatches.bind(
  xs
);
xs.setAutoFreeze.bind(xs);
xs.setUseStrictShallowCopy.bind(xs);
xs.applyPatches.bind(xs);
var TR = xs.createDraft.bind(xs), jR = xs.finishDraft.bind(xs), qe = {
  ancestors(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = qe.levels(e, t);
    return n ? r = r.slice(1) : r = r.slice(0, -1), r;
  },
  common(e, t) {
    for (var n = [], r = 0; r < e.length && r < t.length; r++) {
      var o = e[r], i = t[r];
      if (o !== i)
        break;
      n.push(o);
    }
    return n;
  },
  compare(e, t) {
    for (var n = Math.min(e.length, t.length), r = 0; r < n; r++) {
      if (e[r] < t[r]) return -1;
      if (e[r] > t[r]) return 1;
    }
    return 0;
  },
  endsAfter(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return qe.equals(r, o) && i > a;
  },
  endsAt(e, t) {
    var n = e.length, r = e.slice(0, n), o = t.slice(0, n);
    return qe.equals(r, o);
  },
  endsBefore(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return qe.equals(r, o) && i < a;
  },
  equals(e, t) {
    return e.length === t.length && e.every((n, r) => n === t[r]);
  },
  hasPrevious(e) {
    return e[e.length - 1] > 0;
  },
  isAfter(e, t) {
    return qe.compare(e, t) === 1;
  },
  isAncestor(e, t) {
    return e.length < t.length && qe.compare(e, t) === 0;
  },
  isBefore(e, t) {
    return qe.compare(e, t) === -1;
  },
  isChild(e, t) {
    return e.length === t.length + 1 && qe.compare(e, t) === 0;
  },
  isCommon(e, t) {
    return e.length <= t.length && qe.compare(e, t) === 0;
  },
  isDescendant(e, t) {
    return e.length > t.length && qe.compare(e, t) === 0;
  },
  isParent(e, t) {
    return e.length + 1 === t.length && qe.compare(e, t) === 0;
  },
  isPath(e) {
    return Array.isArray(e) && (e.length === 0 || typeof e[0] == "number");
  },
  isSibling(e, t) {
    if (e.length !== t.length)
      return !1;
    var n = e.slice(0, -1), r = t.slice(0, -1), o = e[e.length - 1], i = t[t.length - 1];
    return o !== i && qe.equals(n, r);
  },
  levels(e) {
    for (var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = [], o = 0; o <= e.length; o++)
      r.push(e.slice(0, o));
    return n && r.reverse(), r;
  },
  next(e) {
    if (e.length === 0)
      throw new Error("Cannot get the next path of a root path [".concat(e, "], because it has no next index."));
    var t = e[e.length - 1];
    return e.slice(0, -1).concat(t + 1);
  },
  operationCanTransformPath(e) {
    switch (e.type) {
      case "insert_node":
      case "remove_node":
      case "merge_node":
      case "split_node":
      case "move_node":
        return !0;
      default:
        return !1;
    }
  },
  parent(e) {
    if (e.length === 0)
      throw new Error("Cannot get the parent path of the root path [".concat(e, "]."));
    return e.slice(0, -1);
  },
  previous(e) {
    if (e.length === 0)
      throw new Error("Cannot get the previous path of a root path [".concat(e, "], because it has no previous index."));
    var t = e[e.length - 1];
    if (t <= 0)
      throw new Error("Cannot get the previous path of a first child path [".concat(e, "] because it would result in a negative index."));
    return e.slice(0, -1).concat(t - 1);
  },
  relative(e, t) {
    if (!qe.isAncestor(t, e) && !qe.equals(e, t))
      throw new Error("Cannot get the relative path of [".concat(e, "] inside ancestor [").concat(t, "], because it is not above or equal to the path."));
    return e.slice(t.length);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!e) return null;
    var r = [...e], {
      affinity: o = "forward"
    } = n;
    if (e.length === 0)
      return r;
    switch (t.type) {
      case "insert_node": {
        var {
          path: i
        } = t;
        (qe.equals(i, r) || qe.endsBefore(i, r) || qe.isAncestor(i, r)) && (r[i.length - 1] += 1);
        break;
      }
      case "remove_node": {
        var {
          path: a
        } = t;
        if (qe.equals(a, r) || qe.isAncestor(a, r))
          return null;
        qe.endsBefore(a, r) && (r[a.length - 1] -= 1);
        break;
      }
      case "merge_node": {
        var {
          path: s,
          position: l
        } = t;
        qe.equals(s, r) || qe.endsBefore(s, r) ? r[s.length - 1] -= 1 : qe.isAncestor(s, r) && (r[s.length - 1] -= 1, r[s.length] += l);
        break;
      }
      case "split_node": {
        var {
          path: u,
          position: c
        } = t;
        if (qe.equals(u, r)) {
          if (o === "forward")
            r[r.length - 1] += 1;
          else if (o !== "backward") return null;
        } else qe.endsBefore(u, r) ? r[u.length - 1] += 1 : qe.isAncestor(u, r) && e[u.length] >= c && (r[u.length - 1] += 1, r[u.length] -= c);
        break;
      }
      case "move_node": {
        var {
          path: p,
          newPath: d
        } = t;
        if (qe.equals(p, d))
          return r;
        if (qe.isAncestor(p, r) || qe.equals(p, r)) {
          var g = d.slice();
          return qe.endsBefore(p, d) && p.length < d.length && (g[p.length - 1] -= 1), g.concat(r.slice(p.length));
        } else qe.isSibling(p, d) && (qe.isAncestor(d, r) || qe.equals(d, r)) ? qe.endsBefore(p, r) ? r[p.length - 1] -= 1 : r[p.length - 1] += 1 : qe.endsBefore(d, r) || qe.equals(d, r) || qe.isAncestor(d, r) ? (qe.endsBefore(p, r) && (r[p.length - 1] -= 1), r[d.length - 1] += 1) : qe.endsBefore(p, r) && (qe.equals(d, r) && (r[d.length - 1] += 1), r[p.length - 1] -= 1);
        break;
      }
    }
    return r;
  }
};
function Qf(e) {
  "@babel/helpers - typeof";
  return Qf = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Qf(e);
}
function rfe(e, t) {
  if (Qf(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (Qf(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function ofe(e) {
  var t = rfe(e, "string");
  return Qf(t) === "symbol" ? t : String(t);
}
function Tp(e, t, n) {
  return t = ofe(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function AR(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function sd(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? AR(Object(n), !0).forEach(function(r) {
      Tp(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : AR(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var ife = (e, t, n) => {
  switch (n.type) {
    case "insert_node": {
      var {
        path: r,
        node: o
      } = n, i = Pt.parent(e, r), a = r[r.length - 1];
      if (a > i.children.length)
        throw new Error('Cannot apply an "insert_node" operation at path ['.concat(r, "] because the destination is past the end of the node."));
      if (i.children.splice(a, 0, o), t)
        for (var [s, l] of Zt.points(t))
          t[l] = Mr.transform(s, n);
      break;
    }
    case "insert_text": {
      var {
        path: u,
        offset: c,
        text: p
      } = n;
      if (p.length === 0) break;
      var d = Pt.leaf(e, u), g = d.text.slice(0, c), f = d.text.slice(c);
      if (d.text = g + p + f, t)
        for (var [m, b] of Zt.points(t))
          t[b] = Mr.transform(m, n);
      break;
    }
    case "merge_node": {
      var {
        path: E
      } = n, w = Pt.get(e, E), M = qe.previous(E), x = Pt.get(e, M), v = Pt.parent(e, E), C = E[E.length - 1];
      if (_o.isText(w) && _o.isText(x))
        x.text += w.text;
      else if (!_o.isText(w) && !_o.isText(x))
        x.children.push(...w.children);
      else
        throw new Error('Cannot apply a "merge_node" operation at path ['.concat(E, "] to nodes of different interfaces: ").concat(os.stringify(w), " ").concat(os.stringify(x)));
      if (v.children.splice(C, 1), t)
        for (var [P, F] of Zt.points(t))
          t[F] = Mr.transform(P, n);
      break;
    }
    case "move_node": {
      var {
        path: L,
        newPath: B
      } = n;
      if (qe.isAncestor(L, B))
        throw new Error("Cannot move a path [".concat(L, "] to new path [").concat(B, "] because the destination is inside itself."));
      var N = Pt.get(e, L), $ = Pt.parent(e, L), V = L[L.length - 1];
      $.children.splice(V, 1);
      var H = qe.transform(L, n), Z = Pt.get(e, qe.parent(H)), K = H[H.length - 1];
      if (Z.children.splice(K, 0, N), t)
        for (var [Y, Q] of Zt.points(t))
          t[Q] = Mr.transform(Y, n);
      break;
    }
    case "remove_node": {
      var {
        path: J
      } = n, _ = J[J.length - 1], D = Pt.parent(e, J);
      if (D.children.splice(_, 1), t)
        for (var [z, S] of Zt.points(t)) {
          var W = Mr.transform(z, n);
          if (t != null && W != null)
            t[S] = W;
          else {
            var O = void 0, j = void 0;
            for (var [U, T] of Pt.texts(e))
              if (qe.compare(T, J) === -1)
                O = [U, T];
              else {
                j = [U, T];
                break;
              }
            var q = !1;
            O && j && (qe.equals(j[1], J) ? q = !qe.hasPrevious(j[1]) : q = qe.common(O[1], J).length < qe.common(j[1], J).length), O && !q ? (z.path = O[1], z.offset = O[0].text.length) : j ? (z.path = j[1], z.offset = 0) : t = null;
          }
        }
      break;
    }
    case "remove_text": {
      var {
        path: A,
        offset: X,
        text: I
      } = n;
      if (I.length === 0) break;
      var le = Pt.leaf(e, A), he = le.text.slice(0, X), oe = le.text.slice(X + I.length);
      if (le.text = he + oe, t)
        for (var [Ae, Ue] of Zt.points(t))
          t[Ue] = Mr.transform(Ae, n);
      break;
    }
    case "set_node": {
      var {
        path: He,
        properties: Re,
        newProperties: nt
      } = n;
      if (He.length === 0)
        throw new Error("Cannot set properties on the root node!");
      var Ve = Pt.get(e, He);
      for (var we in nt) {
        if (we === "children" || we === "text")
          throw new Error('Cannot set the "'.concat(we, '" property of nodes!'));
        var et = nt[we];
        et == null ? delete Ve[we] : Ve[we] = et;
      }
      for (var lt in Re)
        nt.hasOwnProperty(lt) || delete Ve[lt];
      break;
    }
    case "set_selection": {
      var {
        newProperties: ye
      } = n;
      if (ye == null)
        t = ye;
      else {
        if (t == null) {
          if (!Zt.isRange(ye))
            throw new Error('Cannot apply an incomplete "set_selection" operation properties '.concat(os.stringify(ye), " when there is no current selection."));
          t = sd({}, ye);
        }
        for (var ke in ye) {
          var Qe = ye[ke];
          if (Qe == null) {
            if (ke === "anchor" || ke === "focus")
              throw new Error('Cannot remove the "'.concat(ke, '" selection property'));
            delete t[ke];
          } else
            t[ke] = Qe;
        }
      }
      break;
    }
    case "split_node": {
      var {
        path: Fe,
        position: Ie,
        properties: ot
      } = n;
      if (Fe.length === 0)
        throw new Error('Cannot apply a "split_node" operation at path ['.concat(Fe, "] because the root node cannot be split."));
      var Ee = Pt.get(e, Fe), wt = Pt.parent(e, Fe), it = Fe[Fe.length - 1], st;
      if (_o.isText(Ee)) {
        var ut = Ee.text.slice(0, Ie), Ct = Ee.text.slice(Ie);
        Ee.text = ut, st = sd(sd({}, ot), {}, {
          text: Ct
        });
      } else {
        var ct = Ee.children.slice(0, Ie), pt = Ee.children.slice(Ie);
        Ee.children = ct, st = sd(sd({}, ot), {}, {
          children: pt
        });
      }
      if (wt.children.splice(it + 1, 0, st), t)
        for (var [rt, We] of Zt.points(t))
          t[We] = Mr.transform(rt, n);
      break;
    }
  }
  return t;
}, sfe = {
  transform(e, t) {
    e.children = TR(e.children);
    var n = e.selection && TR(e.selection);
    try {
      n = ife(e, n, t);
    } finally {
      e.children = jR(e.children), n ? e.selection = jc(n) ? jR(n) : n : e.selection = null;
    }
  }
}, afe = {
  insertNodes(e, t, n) {
    e.insertNodes(t, n);
  },
  liftNodes(e, t) {
    e.liftNodes(t);
  },
  mergeNodes(e, t) {
    e.mergeNodes(t);
  },
  moveNodes(e, t) {
    e.moveNodes(t);
  },
  removeNodes(e, t) {
    e.removeNodes(t);
  },
  setNodes(e, t, n) {
    e.setNodes(t, n);
  },
  splitNodes(e, t) {
    e.splitNodes(t);
  },
  unsetNodes(e, t, n) {
    e.unsetNodes(t, n);
  },
  unwrapNodes(e, t) {
    e.unwrapNodes(t);
  },
  wrapNodes(e, t, n) {
    e.wrapNodes(t, n);
  }
}, lfe = {
  collapse(e, t) {
    e.collapse(t);
  },
  deselect(e) {
    e.deselect();
  },
  move(e, t) {
    e.move(t);
  },
  select(e, t) {
    e.select(t);
  },
  setPoint(e, t, n) {
    e.setPoint(t, n);
  },
  setSelection(e, t) {
    e.setSelection(t);
  }
}, UK = (e, t) => {
  for (var n in e) {
    var r = e[n], o = t[n];
    if (di(r) && di(o)) {
      if (!UK(r, o)) return !1;
    } else if (Array.isArray(r) && Array.isArray(o)) {
      if (r.length !== o.length) return !1;
      for (var i = 0; i < r.length; i++)
        if (r[i] !== o[i]) return !1;
    } else if (r !== o)
      return !1;
  }
  for (var a in t)
    if (e[a] === void 0 && t[a] !== void 0)
      return !1;
  return !0;
};
function ufe(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), o, i;
  for (i = 0; i < r.length; i++)
    o = r[i], !(t.indexOf(o) >= 0) && (n[o] = e[o]);
  return n;
}
function eh(e, t) {
  if (e == null) return {};
  var n = ufe(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (o = 0; o < i.length; o++)
      r = i[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
var cfe = ["anchor", "focus"];
function RR(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function pfe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? RR(Object(n), !0).forEach(function(r) {
      Tp(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : RR(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Zt = {
  edges(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, {
      anchor: r,
      focus: o
    } = e;
    return Zt.isBackward(e) === n ? [r, o] : [o, r];
  },
  end(e) {
    var [, t] = Zt.edges(e);
    return t;
  },
  equals(e, t) {
    return Mr.equals(e.anchor, t.anchor) && Mr.equals(e.focus, t.focus);
  },
  includes(e, t) {
    if (Zt.isRange(t)) {
      if (Zt.includes(e, t.anchor) || Zt.includes(e, t.focus))
        return !0;
      var [n, r] = Zt.edges(e), [o, i] = Zt.edges(t);
      return Mr.isBefore(n, o) && Mr.isAfter(r, i);
    }
    var [a, s] = Zt.edges(e), l = !1, u = !1;
    return Mr.isPoint(t) ? (l = Mr.compare(t, a) >= 0, u = Mr.compare(t, s) <= 0) : (l = qe.compare(t, a.path) >= 0, u = qe.compare(t, s.path) <= 0), l && u;
  },
  intersection(e, t) {
    var n = eh(e, cfe), [r, o] = Zt.edges(e), [i, a] = Zt.edges(t), s = Mr.isBefore(r, i) ? i : r, l = Mr.isBefore(o, a) ? o : a;
    return Mr.isBefore(l, s) ? null : pfe({
      anchor: s,
      focus: l
    }, n);
  },
  isBackward(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return Mr.isAfter(t, n);
  },
  isCollapsed(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return Mr.equals(t, n);
  },
  isExpanded(e) {
    return !Zt.isCollapsed(e);
  },
  isForward(e) {
    return !Zt.isBackward(e);
  },
  isRange(e) {
    return di(e) && Mr.isPoint(e.anchor) && Mr.isPoint(e.focus);
  },
  *points(e) {
    yield [e.anchor, "anchor"], yield [e.focus, "focus"];
  },
  start(e) {
    var [t] = Zt.edges(e);
    return t;
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return AS(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "inward"
      } = n, i, a;
      if (o === "inward") {
        var s = Zt.isCollapsed(r);
        Zt.isForward(r) ? (i = "forward", a = s ? i : "backward") : (i = "backward", a = s ? i : "forward");
      } else o === "outward" ? Zt.isForward(r) ? (i = "backward", a = "forward") : (i = "forward", a = "backward") : (i = o, a = o);
      var l = Mr.transform(r.anchor, t, {
        affinity: i
      }), u = Mr.transform(r.focus, t, {
        affinity: a
      });
      if (!l || !u)
        return null;
      r.anchor = l, r.focus = u;
    });
  }
}, IR = (e) => di(e) && Pt.isNodeList(e.children) && !ar.isEditor(e), Ha = {
  isAncestor(e) {
    return di(e) && Pt.isNodeList(e.children);
  },
  isElement: IR,
  isElementList(e) {
    return Array.isArray(e) && e.every((t) => Ha.isElement(t));
  },
  isElementProps(e) {
    return e.children !== void 0;
  },
  isElementType: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "type";
    return IR(e) && e[n] === t;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "children" && e[n] !== t[n])
        return !1;
    return !0;
  }
}, dfe = ["children"], ffe = ["text"], NR = /* @__PURE__ */ new WeakMap(), Pt = {
  ancestor(e, t) {
    var n = Pt.get(e, t);
    if (_o.isText(n))
      throw new Error("Cannot get the ancestor node at path [".concat(t, "] because it refers to a text node instead: ").concat(os.stringify(n)));
    return n;
  },
  ancestors(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of qe.ancestors(t, n)) {
        var o = Pt.ancestor(e, r), i = [o, r];
        yield i;
      }
    }();
  },
  child(e, t) {
    if (_o.isText(e))
      throw new Error("Cannot get the child of a text node: ".concat(os.stringify(e)));
    var n = e.children[t];
    if (n == null)
      throw new Error("Cannot get child at index `".concat(t, "` in node: ").concat(os.stringify(e)));
    return n;
  },
  children(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var {
        reverse: r = !1
      } = n, o = Pt.ancestor(e, t), {
        children: i
      } = o, a = r ? i.length - 1 : 0; r ? a >= 0 : a < i.length; ) {
        var s = Pt.child(o, a), l = t.concat(a);
        yield [s, l], a = r ? a - 1 : a + 1;
      }
    }();
  },
  common(e, t, n) {
    var r = qe.common(t, n), o = Pt.get(e, r);
    return [o, r];
  },
  descendant(e, t) {
    var n = Pt.get(e, t);
    if (ar.isEditor(n))
      throw new Error("Cannot get the descendant node at path [".concat(t, "] because it refers to the root editor node instead: ").concat(os.stringify(n)));
    return n;
  },
  descendants(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Pt.nodes(e, t))
        r.length !== 0 && (yield [n, r]);
    }();
  },
  elements(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Pt.nodes(e, t))
        Ha.isElement(n) && (yield [n, r]);
    }();
  },
  extractProps(e) {
    if (Ha.isAncestor(e)) {
      var t = eh(e, dfe);
      return t;
    } else {
      var t = eh(e, ffe);
      return t;
    }
  },
  first(e, t) {
    for (var n = t.slice(), r = Pt.get(e, n); r && !(_o.isText(r) || r.children.length === 0); )
      r = r.children[0], n.push(0);
    return [r, n];
  },
  fragment(e, t) {
    if (_o.isText(e))
      throw new Error("Cannot get a fragment starting from a root text node: ".concat(os.stringify(e)));
    var n = AS({
      children: e.children
    }, (r) => {
      var [o, i] = Zt.edges(t), a = Pt.nodes(r, {
        reverse: !0,
        pass: (d) => {
          var [, g] = d;
          return !Zt.includes(t, g);
        }
      });
      for (var [, s] of a) {
        if (!Zt.includes(t, s)) {
          var l = Pt.parent(r, s), u = s[s.length - 1];
          l.children.splice(u, 1);
        }
        if (qe.equals(s, i.path)) {
          var c = Pt.leaf(r, s);
          c.text = c.text.slice(0, i.offset);
        }
        if (qe.equals(s, o.path)) {
          var p = Pt.leaf(r, s);
          p.text = p.text.slice(o.offset);
        }
      }
      ar.isEditor(r) && (r.selection = null);
    });
    return n.children;
  },
  get(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (_o.isText(n) || !n.children[o])
        throw new Error("Cannot find a descendant at path [".concat(t, "] in node: ").concat(os.stringify(e)));
      n = n.children[o];
    }
    return n;
  },
  has(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (_o.isText(n) || !n.children[o])
        return !1;
      n = n.children[o];
    }
    return !0;
  },
  isNode(e) {
    return _o.isText(e) || Ha.isElement(e) || ar.isEditor(e);
  },
  isNodeList(e) {
    if (!Array.isArray(e))
      return !1;
    var t = NR.get(e);
    if (t !== void 0)
      return t;
    var n = e.every((r) => Pt.isNode(r));
    return NR.set(e, n), n;
  },
  last(e, t) {
    for (var n = t.slice(), r = Pt.get(e, n); r && !(_o.isText(r) || r.children.length === 0); ) {
      var o = r.children.length - 1;
      r = r.children[o], n.push(o);
    }
    return [r, n];
  },
  leaf(e, t) {
    var n = Pt.get(e, t);
    if (!_o.isText(n))
      throw new Error("Cannot get the leaf node at path [".concat(t, "] because it refers to a non-leaf node: ").concat(os.stringify(n)));
    return n;
  },
  levels(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of qe.levels(t, n)) {
        var o = Pt.get(e, r);
        yield [o, r];
      }
    }();
  },
  matches(e, t) {
    return Ha.isElement(e) && Ha.isElementProps(t) && Ha.matches(e, t) || _o.isText(e) && _o.isTextProps(t) && _o.matches(e, t);
  },
  nodes(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var {
        pass: n,
        reverse: r = !1
      } = t, {
        from: o = [],
        to: i
      } = t, a = /* @__PURE__ */ new Set(), s = [], l = e; !(i && (r ? qe.isBefore(s, i) : qe.isAfter(s, i))); ) {
        if (a.has(l) || (yield [l, s]), !a.has(l) && !_o.isText(l) && l.children.length !== 0 && (n == null || n([l, s]) === !1)) {
          a.add(l);
          var u = r ? l.children.length - 1 : 0;
          qe.isAncestor(s, o) && (u = o[s.length]), s = s.concat(u), l = Pt.get(e, s);
          continue;
        }
        if (s.length === 0)
          break;
        if (!r) {
          var c = qe.next(s);
          if (Pt.has(e, c)) {
            s = c, l = Pt.get(e, s);
            continue;
          }
        }
        if (r && s[s.length - 1] !== 0) {
          var p = qe.previous(s);
          s = p, l = Pt.get(e, s);
          continue;
        }
        s = qe.parent(s), l = Pt.get(e, s), a.add(l);
      }
    }();
  },
  parent(e, t) {
    var n = qe.parent(t), r = Pt.get(e, n);
    if (_o.isText(r))
      throw new Error("Cannot get the parent of path [".concat(t, "] because it does not exist in the root."));
    return r;
  },
  string(e) {
    return _o.isText(e) ? e.text : e.children.map(Pt.string).join("");
  },
  texts(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Pt.nodes(e, t))
        _o.isText(n) && (yield [n, r]);
    }();
  }
};
function BR(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Br(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? BR(Object(n), !0).forEach(function(r) {
      Tp(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : BR(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Zd = {
  isNodeOperation(e) {
    return Zd.isOperation(e) && e.type.endsWith("_node");
  },
  isOperation(e) {
    if (!di(e))
      return !1;
    switch (e.type) {
      case "insert_node":
        return qe.isPath(e.path) && Pt.isNode(e.node);
      case "insert_text":
        return typeof e.offset == "number" && typeof e.text == "string" && qe.isPath(e.path);
      case "merge_node":
        return typeof e.position == "number" && qe.isPath(e.path) && di(e.properties);
      case "move_node":
        return qe.isPath(e.path) && qe.isPath(e.newPath);
      case "remove_node":
        return qe.isPath(e.path) && Pt.isNode(e.node);
      case "remove_text":
        return typeof e.offset == "number" && typeof e.text == "string" && qe.isPath(e.path);
      case "set_node":
        return qe.isPath(e.path) && di(e.properties) && di(e.newProperties);
      case "set_selection":
        return e.properties === null && Zt.isRange(e.newProperties) || e.newProperties === null && Zt.isRange(e.properties) || di(e.properties) && di(e.newProperties);
      case "split_node":
        return qe.isPath(e.path) && typeof e.position == "number" && di(e.properties);
      default:
        return !1;
    }
  },
  isOperationList(e) {
    return Array.isArray(e) && e.every((t) => Zd.isOperation(t));
  },
  isSelectionOperation(e) {
    return Zd.isOperation(e) && e.type.endsWith("_selection");
  },
  isTextOperation(e) {
    return Zd.isOperation(e) && e.type.endsWith("_text");
  },
  inverse(e) {
    switch (e.type) {
      case "insert_node":
        return Br(Br({}, e), {}, {
          type: "remove_node"
        });
      case "insert_text":
        return Br(Br({}, e), {}, {
          type: "remove_text"
        });
      case "merge_node":
        return Br(Br({}, e), {}, {
          type: "split_node",
          path: qe.previous(e.path)
        });
      case "move_node": {
        var {
          newPath: t,
          path: n
        } = e;
        if (qe.equals(t, n))
          return e;
        if (qe.isSibling(n, t))
          return Br(Br({}, e), {}, {
            path: t,
            newPath: n
          });
        var r = qe.transform(n, e), o = qe.transform(qe.next(n), e);
        return Br(Br({}, e), {}, {
          path: r,
          newPath: o
        });
      }
      case "remove_node":
        return Br(Br({}, e), {}, {
          type: "insert_node"
        });
      case "remove_text":
        return Br(Br({}, e), {}, {
          type: "insert_text"
        });
      case "set_node": {
        var {
          properties: i,
          newProperties: a
        } = e;
        return Br(Br({}, e), {}, {
          properties: a,
          newProperties: i
        });
      }
      case "set_selection": {
        var {
          properties: s,
          newProperties: l
        } = e;
        return s == null ? Br(Br({}, e), {}, {
          properties: l,
          newProperties: null
        }) : l == null ? Br(Br({}, e), {}, {
          properties: null,
          newProperties: s
        }) : Br(Br({}, e), {}, {
          properties: l,
          newProperties: s
        });
      }
      case "split_node":
        return Br(Br({}, e), {}, {
          type: "merge_node",
          path: qe.next(e.path)
        });
    }
  }
}, FR = /* @__PURE__ */ new WeakMap(), hfe = (e) => {
  var t = FR.get(e);
  if (t !== void 0)
    return t;
  if (!di(e))
    return !1;
  var n = typeof e.addMark == "function" && typeof e.apply == "function" && typeof e.deleteFragment == "function" && typeof e.insertBreak == "function" && typeof e.insertSoftBreak == "function" && typeof e.insertFragment == "function" && typeof e.insertNode == "function" && typeof e.insertText == "function" && typeof e.isElementReadOnly == "function" && typeof e.isInline == "function" && typeof e.isSelectable == "function" && typeof e.isVoid == "function" && typeof e.normalizeNode == "function" && typeof e.onChange == "function" && typeof e.removeMark == "function" && typeof e.getDirtyPaths == "function" && (e.marks === null || di(e.marks)) && (e.selection === null || Zt.isRange(e.selection)) && Pt.isNodeList(e.children) && Zd.isOperationList(e.operations);
  return FR.set(e, n), n;
}, ar = {
  above(e, t) {
    return e.above(t);
  },
  addMark(e, t, n) {
    e.addMark(t, n);
  },
  after(e, t, n) {
    return e.after(t, n);
  },
  before(e, t, n) {
    return e.before(t, n);
  },
  deleteBackward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteBackward(n);
  },
  deleteForward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteForward(n);
  },
  deleteFragment(e, t) {
    e.deleteFragment(t);
  },
  edges(e, t) {
    return e.edges(t);
  },
  elementReadOnly(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return e.elementReadOnly(t);
  },
  end(e, t) {
    return e.end(t);
  },
  first(e, t) {
    return e.first(t);
  },
  fragment(e, t) {
    return e.fragment(t);
  },
  hasBlocks(e, t) {
    return e.hasBlocks(t);
  },
  hasInlines(e, t) {
    return e.hasInlines(t);
  },
  hasPath(e, t) {
    return e.hasPath(t);
  },
  hasTexts(e, t) {
    return e.hasTexts(t);
  },
  insertBreak(e) {
    e.insertBreak();
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertNode(e, t) {
    e.insertNode(t);
  },
  insertSoftBreak(e) {
    e.insertSoftBreak();
  },
  insertText(e, t) {
    e.insertText(t);
  },
  isBlock(e, t) {
    return e.isBlock(t);
  },
  isEdge(e, t, n) {
    return e.isEdge(t, n);
  },
  isEditor(e) {
    return hfe(e);
  },
  isElementReadOnly(e, t) {
    return e.isElementReadOnly(t);
  },
  isEmpty(e, t) {
    return e.isEmpty(t);
  },
  isEnd(e, t, n) {
    return e.isEnd(t, n);
  },
  isInline(e, t) {
    return e.isInline(t);
  },
  isNormalizing(e) {
    return e.isNormalizing();
  },
  isSelectable(e, t) {
    return e.isSelectable(t);
  },
  isStart(e, t, n) {
    return e.isStart(t, n);
  },
  isVoid(e, t) {
    return e.isVoid(t);
  },
  last(e, t) {
    return e.last(t);
  },
  leaf(e, t, n) {
    return e.leaf(t, n);
  },
  levels(e, t) {
    return e.levels(t);
  },
  marks(e) {
    return e.getMarks();
  },
  next(e, t) {
    return e.next(t);
  },
  node(e, t, n) {
    return e.node(t, n);
  },
  nodes(e, t) {
    return e.nodes(t);
  },
  normalize(e, t) {
    e.normalize(t);
  },
  parent(e, t, n) {
    return e.parent(t, n);
  },
  path(e, t, n) {
    return e.path(t, n);
  },
  pathRef(e, t, n) {
    return e.pathRef(t, n);
  },
  pathRefs(e) {
    return e.pathRefs();
  },
  point(e, t, n) {
    return e.point(t, n);
  },
  pointRef(e, t, n) {
    return e.pointRef(t, n);
  },
  pointRefs(e) {
    return e.pointRefs();
  },
  positions(e, t) {
    return e.positions(t);
  },
  previous(e, t) {
    return e.previous(t);
  },
  range(e, t, n) {
    return e.range(t, n);
  },
  rangeRef(e, t, n) {
    return e.rangeRef(t, n);
  },
  rangeRefs(e) {
    return e.rangeRefs();
  },
  removeMark(e, t) {
    e.removeMark(t);
  },
  setNormalizing(e, t) {
    e.setNormalizing(t);
  },
  start(e, t) {
    return e.start(t);
  },
  string(e, t, n) {
    return e.string(t, n);
  },
  unhangRange(e, t, n) {
    return e.unhangRange(t, n);
  },
  void(e, t) {
    return e.void(t);
  },
  withoutNormalizing(e, t) {
    e.withoutNormalizing(t);
  },
  shouldMergeNodesRemovePrevNode: (e, t, n) => e.shouldMergeNodesRemovePrevNode(t, n)
};
function zR(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function UR(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? zR(Object(n), !0).forEach(function(r) {
      Tp(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : zR(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Mr = {
  compare(e, t) {
    var n = qe.compare(e.path, t.path);
    return n === 0 ? e.offset < t.offset ? -1 : e.offset > t.offset ? 1 : 0 : n;
  },
  isAfter(e, t) {
    return Mr.compare(e, t) === 1;
  },
  isBefore(e, t) {
    return Mr.compare(e, t) === -1;
  },
  equals(e, t) {
    return e.offset === t.offset && qe.equals(e.path, t.path);
  },
  isPoint(e) {
    return di(e) && typeof e.offset == "number" && qe.isPath(e.path);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return AS(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "forward"
      } = n, {
        path: i,
        offset: a
      } = r;
      switch (t.type) {
        case "insert_node":
        case "move_node": {
          r.path = qe.transform(i, t, n);
          break;
        }
        case "insert_text": {
          qe.equals(t.path, i) && (t.offset < a || t.offset === a && o === "forward") && (r.offset += t.text.length);
          break;
        }
        case "merge_node": {
          qe.equals(t.path, i) && (r.offset += t.position), r.path = qe.transform(i, t, n);
          break;
        }
        case "remove_text": {
          qe.equals(t.path, i) && t.offset <= a && (r.offset -= Math.min(a - t.offset, t.text.length));
          break;
        }
        case "remove_node": {
          if (qe.equals(t.path, i) || qe.isAncestor(t.path, i))
            return null;
          r.path = qe.transform(i, t, n);
          break;
        }
        case "split_node": {
          if (qe.equals(t.path, i)) {
            if (t.position === a && o == null)
              return null;
            (t.position < a || t.position === a && o === "forward") && (r.offset -= t.position, r.path = qe.transform(i, t, UR(UR({}, n), {}, {
              affinity: "forward"
            })));
          } else
            r.path = qe.transform(i, t, n);
          break;
        }
      }
    });
  }
}, HR = void 0, os = {
  setScrubber(e) {
    HR = e;
  },
  stringify(e) {
    return JSON.stringify(e, HR);
  }
}, gfe = ["text"], mfe = ["anchor", "focus"];
function WR(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function _a(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? WR(Object(n), !0).forEach(function(r) {
      Tp(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : WR(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var _o = {
  equals(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      loose: r = !1
    } = n;
    function o(i) {
      var a = eh(i, gfe);
      return a;
    }
    return UK(r ? o(e) : e, r ? o(t) : t);
  },
  isText(e) {
    return di(e) && typeof e.text == "string";
  },
  isTextList(e) {
    return Array.isArray(e) && e.every((t) => _o.isText(t));
  },
  isTextProps(e) {
    return e.text !== void 0;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "text" && (!e.hasOwnProperty(n) || e[n] !== t[n]))
        return !1;
    return !0;
  },
  decorations(e, t) {
    var n = [_a({}, e)];
    for (var r of t) {
      var o = eh(r, mfe), [i, a] = Zt.edges(r), s = [], l = 0, u = i.offset, c = a.offset;
      for (var p of n) {
        var {
          length: d
        } = p.text, g = l;
        if (l += d, u <= g && l <= c) {
          Object.assign(p, o), s.push(p);
          continue;
        }
        if (u !== c && (u === l || c === g) || u > l || c < g || c === g && g !== 0) {
          s.push(p);
          continue;
        }
        var f = p, m = void 0, b = void 0;
        if (c < l) {
          var E = c - g;
          b = _a(_a({}, f), {}, {
            text: f.text.slice(E)
          }), f = _a(_a({}, f), {}, {
            text: f.text.slice(0, E)
          });
        }
        if (u > g) {
          var w = u - g;
          m = _a(_a({}, f), {}, {
            text: f.text.slice(0, w)
          }), f = _a(_a({}, f), {}, {
            text: f.text.slice(w)
          });
        }
        Object.assign(f, o), m && s.push(m), s.push(f), b && s.push(b);
      }
      n = s;
    }
    return n;
  }
}, vfe = (e) => e.selection ? e.selection : e.children.length > 0 ? ar.end(e, []) : [0], xr;
(function(e) {
  e[e.None = 0] = "None", e[e.Extend = 1] = "Extend", e[e.ZWJ = 2] = "ZWJ", e[e.RI = 4] = "RI", e[e.Prepend = 8] = "Prepend", e[e.SpacingMark = 16] = "SpacingMark", e[e.L = 32] = "L", e[e.V = 64] = "V", e[e.T = 128] = "T", e[e.LV = 256] = "LV", e[e.LVT = 512] = "LVT", e[e.ExtPict = 1024] = "ExtPict", e[e.Any = 2048] = "Any";
})(xr || (xr = {}));
xr.L, xr.L | xr.V | xr.LV | xr.LVT, xr.LV | xr.V, xr.V | xr.T, xr.LVT | xr.T, xr.T, xr.Any, xr.Extend | xr.ZWJ, xr.Any, xr.SpacingMark, xr.Prepend, xr.Any, xr.ZWJ, xr.ExtPict, xr.RI, xr.RI;
var yfe = {
  delete(e, t) {
    e.delete(t);
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertText(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    ar.withoutNormalizing(e, () => {
      var {
        voids: r = !1
      } = n, {
        at: o = vfe(e)
      } = n;
      if (qe.isPath(o) && (o = ar.range(e, o)), Zt.isRange(o))
        if (Zt.isCollapsed(o))
          o = o.anchor;
        else {
          var i = Zt.end(o);
          if (!r && ar.void(e, {
            at: i
          }))
            return;
          var a = Zt.start(o), s = ar.pointRef(e, a), l = ar.pointRef(e, i);
          eb.delete(e, {
            at: o,
            voids: r
          });
          var u = s.unref(), c = l.unref();
          o = u || c, eb.setSelection(e, {
            anchor: o,
            focus: o
          });
        }
      if (!(!r && ar.void(e, {
        at: o
      }) || ar.elementReadOnly(e, {
        at: o
      }))) {
        var {
          path: p,
          offset: d
        } = o;
        t.length > 0 && e.apply({
          type: "insert_text",
          path: p,
          offset: d,
          text: t
        });
      }
    });
  }
};
function $R(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function um(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? $R(Object(n), !0).forEach(function(r) {
      Tp(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : $R(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var eb = um(um(um(um({}, sfe), afe), lfe), yfe), HK = {}, RS = {}, IS = {}, Qc = {}, NS = {}, BS = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Doctype = e.CDATA = e.Tag = e.Style = e.Script = e.Comment = e.Directive = e.Text = e.Root = e.isTag = e.ElementType = void 0;
  var t;
  (function(r) {
    r.Root = "root", r.Text = "text", r.Directive = "directive", r.Comment = "comment", r.Script = "script", r.Style = "style", r.Tag = "tag", r.CDATA = "cdata", r.Doctype = "doctype";
  })(t = e.ElementType || (e.ElementType = {}));
  function n(r) {
    return r.type === t.Tag || r.type === t.Script || r.type === t.Style;
  }
  e.isTag = n, e.Root = t.Root, e.Text = t.Text, e.Directive = t.Directive, e.Comment = t.Comment, e.Script = t.Script, e.Style = t.Style, e.Tag = t.Tag, e.CDATA = t.CDATA, e.Doctype = t.Doctype;
})(BS);
var tn = {}, du = gr && gr.__extends || /* @__PURE__ */ function() {
  var e = function(t, n) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, o) {
      r.__proto__ = o;
    } || function(r, o) {
      for (var i in o) Object.prototype.hasOwnProperty.call(o, i) && (r[i] = o[i]);
    }, e(t, n);
  };
  return function(t, n) {
    if (typeof n != "function" && n !== null)
      throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
    e(t, n);
    function r() {
      this.constructor = t;
    }
    t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
  };
}(), cf = gr && gr.__assign || function() {
  return cf = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) {
      t = arguments[n];
      for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
    }
    return e;
  }, cf.apply(this, arguments);
};
Object.defineProperty(tn, "__esModule", { value: !0 });
tn.cloneNode = tn.hasChildren = tn.isDocument = tn.isDirective = tn.isComment = tn.isText = tn.isCDATA = tn.isTag = tn.Element = tn.Document = tn.CDATA = tn.NodeWithChildren = tn.ProcessingInstruction = tn.Comment = tn.Text = tn.DataNode = tn.Node = void 0;
var Yi = BS, FS = (
  /** @class */
  function() {
    function e() {
      this.parent = null, this.prev = null, this.next = null, this.startIndex = null, this.endIndex = null;
    }
    return Object.defineProperty(e.prototype, "parentNode", {
      // Read-write aliases for properties
      /**
       * Same as {@link parent}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.parent;
      },
      set: function(t) {
        this.parent = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "previousSibling", {
      /**
       * Same as {@link prev}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.prev;
      },
      set: function(t) {
        this.prev = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "nextSibling", {
      /**
       * Same as {@link next}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.next;
      },
      set: function(t) {
        this.next = t;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.cloneNode = function(t) {
      return t === void 0 && (t = !1), zS(this, t);
    }, e;
  }()
);
tn.Node = FS;
var I0 = (
  /** @class */
  function(e) {
    du(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.data = n, r;
    }
    return Object.defineProperty(t.prototype, "nodeValue", {
      /**
       * Same as {@link data}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.data;
      },
      set: function(n) {
        this.data = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(FS)
);
tn.DataNode = I0;
var WK = (
  /** @class */
  function(e) {
    du(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Yi.ElementType.Text, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 3;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(I0)
);
tn.Text = WK;
var $K = (
  /** @class */
  function(e) {
    du(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Yi.ElementType.Comment, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 8;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(I0)
);
tn.Comment = $K;
var VK = (
  /** @class */
  function(e) {
    du(t, e);
    function t(n, r) {
      var o = e.call(this, r) || this;
      return o.name = n, o.type = Yi.ElementType.Directive, o;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(I0)
);
tn.ProcessingInstruction = VK;
var N0 = (
  /** @class */
  function(e) {
    du(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.children = n, r;
    }
    return Object.defineProperty(t.prototype, "firstChild", {
      // Aliases
      /** First child of the node. */
      get: function() {
        var n;
        return (n = this.children[0]) !== null && n !== void 0 ? n : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "lastChild", {
      /** Last child of the node. */
      get: function() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "childNodes", {
      /**
       * Same as {@link children}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.children;
      },
      set: function(n) {
        this.children = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(FS)
);
tn.NodeWithChildren = N0;
var ZK = (
  /** @class */
  function(e) {
    du(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Yi.ElementType.CDATA, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 4;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(N0)
);
tn.CDATA = ZK;
var qK = (
  /** @class */
  function(e) {
    du(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Yi.ElementType.Root, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 9;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(N0)
);
tn.Document = qK;
var GK = (
  /** @class */
  function(e) {
    du(t, e);
    function t(n, r, o, i) {
      o === void 0 && (o = []), i === void 0 && (i = n === "script" ? Yi.ElementType.Script : n === "style" ? Yi.ElementType.Style : Yi.ElementType.Tag);
      var a = e.call(this, o) || this;
      return a.name = n, a.attribs = r, a.type = i, a;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "tagName", {
      // DOM Level 1 aliases
      /**
       * Same as {@link name}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.name;
      },
      set: function(n) {
        this.name = n;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "attributes", {
      get: function() {
        var n = this;
        return Object.keys(this.attribs).map(function(r) {
          var o, i;
          return {
            name: r,
            value: n.attribs[r],
            namespace: (o = n["x-attribsNamespace"]) === null || o === void 0 ? void 0 : o[r],
            prefix: (i = n["x-attribsPrefix"]) === null || i === void 0 ? void 0 : i[r]
          };
        });
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(N0)
);
tn.Element = GK;
function KK(e) {
  return (0, Yi.isTag)(e);
}
tn.isTag = KK;
function XK(e) {
  return e.type === Yi.ElementType.CDATA;
}
tn.isCDATA = XK;
function YK(e) {
  return e.type === Yi.ElementType.Text;
}
tn.isText = YK;
function JK(e) {
  return e.type === Yi.ElementType.Comment;
}
tn.isComment = JK;
function QK(e) {
  return e.type === Yi.ElementType.Directive;
}
tn.isDirective = QK;
function eX(e) {
  return e.type === Yi.ElementType.Root;
}
tn.isDocument = eX;
function bfe(e) {
  return Object.prototype.hasOwnProperty.call(e, "children");
}
tn.hasChildren = bfe;
function zS(e, t) {
  t === void 0 && (t = !1);
  var n;
  if (YK(e))
    n = new WK(e.data);
  else if (JK(e))
    n = new $K(e.data);
  else if (KK(e)) {
    var r = t ? Cx(e.children) : [], o = new GK(e.name, cf({}, e.attribs), r);
    r.forEach(function(l) {
      return l.parent = o;
    }), e.namespace != null && (o.namespace = e.namespace), e["x-attribsNamespace"] && (o["x-attribsNamespace"] = cf({}, e["x-attribsNamespace"])), e["x-attribsPrefix"] && (o["x-attribsPrefix"] = cf({}, e["x-attribsPrefix"])), n = o;
  } else if (XK(e)) {
    var r = t ? Cx(e.children) : [], i = new ZK(r);
    r.forEach(function(u) {
      return u.parent = i;
    }), n = i;
  } else if (eX(e)) {
    var r = t ? Cx(e.children) : [], a = new qK(r);
    r.forEach(function(u) {
      return u.parent = a;
    }), e["x-mode"] && (a["x-mode"] = e["x-mode"]), n = a;
  } else if (QK(e)) {
    var s = new VK(e.name, e.data);
    e["x-name"] != null && (s["x-name"] = e["x-name"], s["x-publicId"] = e["x-publicId"], s["x-systemId"] = e["x-systemId"]), n = s;
  } else
    throw new Error("Not implemented yet: ".concat(e.type));
  return n.startIndex = e.startIndex, n.endIndex = e.endIndex, e.sourceCodeLocation != null && (n.sourceCodeLocation = e.sourceCodeLocation), n;
}
tn.cloneNode = zS;
function Cx(e) {
  for (var t = e.map(function(r) {
    return zS(r, !0);
  }), n = 1; n < t.length; n++)
    t[n].prev = t[n - 1], t[n - 1].next = t[n];
  return t;
}
(function(e) {
  var t = gr && gr.__createBinding || (Object.create ? function(s, l, u, c) {
    c === void 0 && (c = u);
    var p = Object.getOwnPropertyDescriptor(l, u);
    (!p || ("get" in p ? !l.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
      return l[u];
    } }), Object.defineProperty(s, c, p);
  } : function(s, l, u, c) {
    c === void 0 && (c = u), s[c] = l[u];
  }), n = gr && gr.__exportStar || function(s, l) {
    for (var u in s) u !== "default" && !Object.prototype.hasOwnProperty.call(l, u) && t(l, s, u);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.DomHandler = void 0;
  var r = BS, o = tn;
  n(tn, e);
  var i = {
    withStartIndices: !1,
    withEndIndices: !1,
    xmlMode: !1
  }, a = (
    /** @class */
    function() {
      function s(l, u, c) {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null, typeof u == "function" && (c = u, u = i), typeof l == "object" && (u = l, l = void 0), this.callback = l ?? null, this.options = u ?? i, this.elementCB = c ?? null;
      }
      return s.prototype.onparserinit = function(l) {
        this.parser = l;
      }, s.prototype.onreset = function() {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null;
      }, s.prototype.onend = function() {
        this.done || (this.done = !0, this.parser = null, this.handleCallback(null));
      }, s.prototype.onerror = function(l) {
        this.handleCallback(l);
      }, s.prototype.onclosetag = function() {
        this.lastNode = null;
        var l = this.tagStack.pop();
        this.options.withEndIndices && (l.endIndex = this.parser.endIndex), this.elementCB && this.elementCB(l);
      }, s.prototype.onopentag = function(l, u) {
        var c = this.options.xmlMode ? r.ElementType.Tag : void 0, p = new o.Element(l, u, void 0, c);
        this.addNode(p), this.tagStack.push(p);
      }, s.prototype.ontext = function(l) {
        var u = this.lastNode;
        if (u && u.type === r.ElementType.Text)
          u.data += l, this.options.withEndIndices && (u.endIndex = this.parser.endIndex);
        else {
          var c = new o.Text(l);
          this.addNode(c), this.lastNode = c;
        }
      }, s.prototype.oncomment = function(l) {
        if (this.lastNode && this.lastNode.type === r.ElementType.Comment) {
          this.lastNode.data += l;
          return;
        }
        var u = new o.Comment(l);
        this.addNode(u), this.lastNode = u;
      }, s.prototype.oncommentend = function() {
        this.lastNode = null;
      }, s.prototype.oncdatastart = function() {
        var l = new o.Text(""), u = new o.CDATA([l]);
        this.addNode(u), l.parent = u, this.lastNode = l;
      }, s.prototype.oncdataend = function() {
        this.lastNode = null;
      }, s.prototype.onprocessinginstruction = function(l, u) {
        var c = new o.ProcessingInstruction(l, u);
        this.addNode(c);
      }, s.prototype.handleCallback = function(l) {
        if (typeof this.callback == "function")
          this.callback(l, this.dom);
        else if (l)
          throw l;
      }, s.prototype.addNode = function(l) {
        var u = this.tagStack[this.tagStack.length - 1], c = u.children[u.children.length - 1];
        this.options.withStartIndices && (l.startIndex = this.parser.startIndex), this.options.withEndIndices && (l.endIndex = this.parser.endIndex), u.children.push(l), c && (l.prev = c, c.next = l), l.parent = u, this.lastNode = null;
      }, s;
    }()
  );
  e.DomHandler = a, e.default = a;
})(NS);
var tX = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CARRIAGE_RETURN_PLACEHOLDER_REGEX = e.CARRIAGE_RETURN_PLACEHOLDER = e.CARRIAGE_RETURN_REGEX = e.CARRIAGE_RETURN = e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES = void 0, e.CASE_SENSITIVE_TAG_NAMES = [
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "linearGradient",
    "radialGradient",
    "textPath"
  ], e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES.reduce(function(t, n) {
    return t[n.toLowerCase()] = n, t;
  }, {}), e.CARRIAGE_RETURN = "\r", e.CARRIAGE_RETURN_REGEX = new RegExp(e.CARRIAGE_RETURN, "g"), e.CARRIAGE_RETURN_PLACEHOLDER = "__HTML_DOM_PARSER_CARRIAGE_RETURN_PLACEHOLDER_".concat(Date.now(), "__"), e.CARRIAGE_RETURN_PLACEHOLDER_REGEX = new RegExp(e.CARRIAGE_RETURN_PLACEHOLDER, "g");
})(tX);
Object.defineProperty(Qc, "__esModule", { value: !0 });
Qc.formatAttributes = nX;
Qc.escapeSpecialCharacters = Ofe;
Qc.revertEscapedCharacters = rX;
Qc.formatDOM = oX;
var cm = NS, th = tX;
function wfe(e) {
  return th.CASE_SENSITIVE_TAG_NAMES_MAP[e];
}
function nX(e) {
  for (var t = {}, n = 0, r = e.length; n < r; n++) {
    var o = e[n];
    t[o.name] = o.value;
  }
  return t;
}
function Cfe(e) {
  e = e.toLowerCase();
  var t = wfe(e);
  return t || e;
}
function Ofe(e) {
  return e.replace(th.CARRIAGE_RETURN_REGEX, th.CARRIAGE_RETURN_PLACEHOLDER);
}
function rX(e) {
  return e.replace(th.CARRIAGE_RETURN_PLACEHOLDER_REGEX, th.CARRIAGE_RETURN);
}
function oX(e, t, n) {
  t === void 0 && (t = null);
  for (var r = [], o, i = 0, a = e.length; i < a; i++) {
    var s = e[i];
    switch (s.nodeType) {
      case 1: {
        var l = Cfe(s.nodeName);
        o = new cm.Element(l, nX(s.attributes)), o.children = oX(
          // template children are on content
          l === "template" ? s.content.childNodes : s.childNodes,
          o
        );
        break;
      }
      case 3:
        o = new cm.Text(rX(s.nodeValue));
        break;
      case 8:
        o = new cm.Comment(s.nodeValue);
        break;
      default:
        continue;
    }
    var u = r[i - 1] || null;
    u && (u.next = o), o.parent = t, o.prev = u, o.next = null, r.push(o);
  }
  return n && (o = new cm.ProcessingInstruction(n.substring(0, n.indexOf(" ")).toLowerCase(), n), o.next = r[0] || null, o.parent = t, r.unshift(o), r[1] && (r[1].prev = r[0])), r;
}
Object.defineProperty(IS, "__esModule", { value: !0 });
IS.default = _fe;
var xfe = Qc, VR = "html", ZR = "head", pm = "body", Efe = /<([a-zA-Z]+[0-9]?)/, qR = /<head[^]*>/i, GR = /<body[^]*>/i, tb = function(e, t) {
  throw new Error("This browser does not support `document.implementation.createHTMLDocument`");
}, P1 = function(e, t) {
  throw new Error("This browser does not support `DOMParser.prototype.parseFromString`");
}, KR = typeof window == "object" && window.DOMParser;
if (typeof KR == "function") {
  var kfe = new KR(), Lfe = "text/html";
  P1 = function(e, t) {
    return t && (e = "<".concat(t, ">").concat(e, "</").concat(t, ">")), kfe.parseFromString(e, Lfe);
  }, tb = P1;
}
if (typeof document == "object" && document.implementation) {
  var dm = document.implementation.createHTMLDocument();
  tb = function(e, t) {
    if (t) {
      var n = dm.documentElement.querySelector(t);
      return n && (n.innerHTML = e), dm;
    }
    return dm.documentElement.innerHTML = e, dm;
  };
}
var fm = typeof document == "object" && document.createElement("template"), S1;
fm && fm.content && (S1 = function(e) {
  return fm.innerHTML = e, fm.content.childNodes;
});
function _fe(e) {
  var t, n;
  e = (0, xfe.escapeSpecialCharacters)(e);
  var r = e.match(Efe), o = r && r[1] ? r[1].toLowerCase() : "";
  switch (o) {
    case VR: {
      var i = P1(e);
      if (!qR.test(e)) {
        var a = i.querySelector(ZR);
        (t = a == null ? void 0 : a.parentNode) === null || t === void 0 || t.removeChild(a);
      }
      if (!GR.test(e)) {
        var a = i.querySelector(pm);
        (n = a == null ? void 0 : a.parentNode) === null || n === void 0 || n.removeChild(a);
      }
      return i.querySelectorAll(VR);
    }
    case ZR:
    case pm: {
      var s = tb(e).querySelectorAll(o);
      return GR.test(e) && qR.test(e) ? s[0].parentNode.childNodes : s;
    }
    default: {
      if (S1)
        return S1(e);
      var a = tb(e, pm).querySelector(pm);
      return a.childNodes;
    }
  }
}
var Pfe = gr && gr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(RS, "__esModule", { value: !0 });
RS.default = Tfe;
var Sfe = Pfe(IS), Mfe = Qc, Dfe = /<(![a-zA-Z\s]+)>/;
function Tfe(e) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e)
    return [];
  var t = e.match(Dfe), n = t ? t[1] : void 0;
  return (0, Mfe.formatDOM)((0, Sfe.default)(e), null, n);
}
var B0 = {}, qs = {}, F0 = {}, jfe = 0;
F0.SAME = jfe;
var Afe = 1;
F0.CAMELCASE = Afe;
F0.possibleStandardNames = {
  accept: 0,
  acceptCharset: 1,
  "accept-charset": "acceptCharset",
  accessKey: 1,
  action: 0,
  allowFullScreen: 1,
  alt: 0,
  as: 0,
  async: 0,
  autoCapitalize: 1,
  autoComplete: 1,
  autoCorrect: 1,
  autoFocus: 1,
  autoPlay: 1,
  autoSave: 1,
  capture: 0,
  cellPadding: 1,
  cellSpacing: 1,
  challenge: 0,
  charSet: 1,
  checked: 0,
  children: 0,
  cite: 0,
  class: "className",
  classID: 1,
  className: 1,
  cols: 0,
  colSpan: 1,
  content: 0,
  contentEditable: 1,
  contextMenu: 1,
  controls: 0,
  controlsList: 1,
  coords: 0,
  crossOrigin: 1,
  dangerouslySetInnerHTML: 1,
  data: 0,
  dateTime: 1,
  default: 0,
  defaultChecked: 1,
  defaultValue: 1,
  defer: 0,
  dir: 0,
  disabled: 0,
  disablePictureInPicture: 1,
  disableRemotePlayback: 1,
  download: 0,
  draggable: 0,
  encType: 1,
  enterKeyHint: 1,
  for: "htmlFor",
  form: 0,
  formMethod: 1,
  formAction: 1,
  formEncType: 1,
  formNoValidate: 1,
  formTarget: 1,
  frameBorder: 1,
  headers: 0,
  height: 0,
  hidden: 0,
  high: 0,
  href: 0,
  hrefLang: 1,
  htmlFor: 1,
  httpEquiv: 1,
  "http-equiv": "httpEquiv",
  icon: 0,
  id: 0,
  innerHTML: 1,
  inputMode: 1,
  integrity: 0,
  is: 0,
  itemID: 1,
  itemProp: 1,
  itemRef: 1,
  itemScope: 1,
  itemType: 1,
  keyParams: 1,
  keyType: 1,
  kind: 0,
  label: 0,
  lang: 0,
  list: 0,
  loop: 0,
  low: 0,
  manifest: 0,
  marginWidth: 1,
  marginHeight: 1,
  max: 0,
  maxLength: 1,
  media: 0,
  mediaGroup: 1,
  method: 0,
  min: 0,
  minLength: 1,
  multiple: 0,
  muted: 0,
  name: 0,
  noModule: 1,
  nonce: 0,
  noValidate: 1,
  open: 0,
  optimum: 0,
  pattern: 0,
  placeholder: 0,
  playsInline: 1,
  poster: 0,
  preload: 0,
  profile: 0,
  radioGroup: 1,
  readOnly: 1,
  referrerPolicy: 1,
  rel: 0,
  required: 0,
  reversed: 0,
  role: 0,
  rows: 0,
  rowSpan: 1,
  sandbox: 0,
  scope: 0,
  scoped: 0,
  scrolling: 0,
  seamless: 0,
  selected: 0,
  shape: 0,
  size: 0,
  sizes: 0,
  span: 0,
  spellCheck: 1,
  src: 0,
  srcDoc: 1,
  srcLang: 1,
  srcSet: 1,
  start: 0,
  step: 0,
  style: 0,
  summary: 0,
  tabIndex: 1,
  target: 0,
  title: 0,
  type: 0,
  useMap: 1,
  value: 0,
  width: 0,
  wmode: 0,
  wrap: 0,
  about: 0,
  accentHeight: 1,
  "accent-height": "accentHeight",
  accumulate: 0,
  additive: 0,
  alignmentBaseline: 1,
  "alignment-baseline": "alignmentBaseline",
  allowReorder: 1,
  alphabetic: 0,
  amplitude: 0,
  arabicForm: 1,
  "arabic-form": "arabicForm",
  ascent: 0,
  attributeName: 1,
  attributeType: 1,
  autoReverse: 1,
  azimuth: 0,
  baseFrequency: 1,
  baselineShift: 1,
  "baseline-shift": "baselineShift",
  baseProfile: 1,
  bbox: 0,
  begin: 0,
  bias: 0,
  by: 0,
  calcMode: 1,
  capHeight: 1,
  "cap-height": "capHeight",
  clip: 0,
  clipPath: 1,
  "clip-path": "clipPath",
  clipPathUnits: 1,
  clipRule: 1,
  "clip-rule": "clipRule",
  color: 0,
  colorInterpolation: 1,
  "color-interpolation": "colorInterpolation",
  colorInterpolationFilters: 1,
  "color-interpolation-filters": "colorInterpolationFilters",
  colorProfile: 1,
  "color-profile": "colorProfile",
  colorRendering: 1,
  "color-rendering": "colorRendering",
  contentScriptType: 1,
  contentStyleType: 1,
  cursor: 0,
  cx: 0,
  cy: 0,
  d: 0,
  datatype: 0,
  decelerate: 0,
  descent: 0,
  diffuseConstant: 1,
  direction: 0,
  display: 0,
  divisor: 0,
  dominantBaseline: 1,
  "dominant-baseline": "dominantBaseline",
  dur: 0,
  dx: 0,
  dy: 0,
  edgeMode: 1,
  elevation: 0,
  enableBackground: 1,
  "enable-background": "enableBackground",
  end: 0,
  exponent: 0,
  externalResourcesRequired: 1,
  fill: 0,
  fillOpacity: 1,
  "fill-opacity": "fillOpacity",
  fillRule: 1,
  "fill-rule": "fillRule",
  filter: 0,
  filterRes: 1,
  filterUnits: 1,
  floodOpacity: 1,
  "flood-opacity": "floodOpacity",
  floodColor: 1,
  "flood-color": "floodColor",
  focusable: 0,
  fontFamily: 1,
  "font-family": "fontFamily",
  fontSize: 1,
  "font-size": "fontSize",
  fontSizeAdjust: 1,
  "font-size-adjust": "fontSizeAdjust",
  fontStretch: 1,
  "font-stretch": "fontStretch",
  fontStyle: 1,
  "font-style": "fontStyle",
  fontVariant: 1,
  "font-variant": "fontVariant",
  fontWeight: 1,
  "font-weight": "fontWeight",
  format: 0,
  from: 0,
  fx: 0,
  fy: 0,
  g1: 0,
  g2: 0,
  glyphName: 1,
  "glyph-name": "glyphName",
  glyphOrientationHorizontal: 1,
  "glyph-orientation-horizontal": "glyphOrientationHorizontal",
  glyphOrientationVertical: 1,
  "glyph-orientation-vertical": "glyphOrientationVertical",
  glyphRef: 1,
  gradientTransform: 1,
  gradientUnits: 1,
  hanging: 0,
  horizAdvX: 1,
  "horiz-adv-x": "horizAdvX",
  horizOriginX: 1,
  "horiz-origin-x": "horizOriginX",
  ideographic: 0,
  imageRendering: 1,
  "image-rendering": "imageRendering",
  in2: 0,
  in: 0,
  inlist: 0,
  intercept: 0,
  k1: 0,
  k2: 0,
  k3: 0,
  k4: 0,
  k: 0,
  kernelMatrix: 1,
  kernelUnitLength: 1,
  kerning: 0,
  keyPoints: 1,
  keySplines: 1,
  keyTimes: 1,
  lengthAdjust: 1,
  letterSpacing: 1,
  "letter-spacing": "letterSpacing",
  lightingColor: 1,
  "lighting-color": "lightingColor",
  limitingConeAngle: 1,
  local: 0,
  markerEnd: 1,
  "marker-end": "markerEnd",
  markerHeight: 1,
  markerMid: 1,
  "marker-mid": "markerMid",
  markerStart: 1,
  "marker-start": "markerStart",
  markerUnits: 1,
  markerWidth: 1,
  mask: 0,
  maskContentUnits: 1,
  maskUnits: 1,
  mathematical: 0,
  mode: 0,
  numOctaves: 1,
  offset: 0,
  opacity: 0,
  operator: 0,
  order: 0,
  orient: 0,
  orientation: 0,
  origin: 0,
  overflow: 0,
  overlinePosition: 1,
  "overline-position": "overlinePosition",
  overlineThickness: 1,
  "overline-thickness": "overlineThickness",
  paintOrder: 1,
  "paint-order": "paintOrder",
  panose1: 0,
  "panose-1": "panose1",
  pathLength: 1,
  patternContentUnits: 1,
  patternTransform: 1,
  patternUnits: 1,
  pointerEvents: 1,
  "pointer-events": "pointerEvents",
  points: 0,
  pointsAtX: 1,
  pointsAtY: 1,
  pointsAtZ: 1,
  prefix: 0,
  preserveAlpha: 1,
  preserveAspectRatio: 1,
  primitiveUnits: 1,
  property: 0,
  r: 0,
  radius: 0,
  refX: 1,
  refY: 1,
  renderingIntent: 1,
  "rendering-intent": "renderingIntent",
  repeatCount: 1,
  repeatDur: 1,
  requiredExtensions: 1,
  requiredFeatures: 1,
  resource: 0,
  restart: 0,
  result: 0,
  results: 0,
  rotate: 0,
  rx: 0,
  ry: 0,
  scale: 0,
  security: 0,
  seed: 0,
  shapeRendering: 1,
  "shape-rendering": "shapeRendering",
  slope: 0,
  spacing: 0,
  specularConstant: 1,
  specularExponent: 1,
  speed: 0,
  spreadMethod: 1,
  startOffset: 1,
  stdDeviation: 1,
  stemh: 0,
  stemv: 0,
  stitchTiles: 1,
  stopColor: 1,
  "stop-color": "stopColor",
  stopOpacity: 1,
  "stop-opacity": "stopOpacity",
  strikethroughPosition: 1,
  "strikethrough-position": "strikethroughPosition",
  strikethroughThickness: 1,
  "strikethrough-thickness": "strikethroughThickness",
  string: 0,
  stroke: 0,
  strokeDasharray: 1,
  "stroke-dasharray": "strokeDasharray",
  strokeDashoffset: 1,
  "stroke-dashoffset": "strokeDashoffset",
  strokeLinecap: 1,
  "stroke-linecap": "strokeLinecap",
  strokeLinejoin: 1,
  "stroke-linejoin": "strokeLinejoin",
  strokeMiterlimit: 1,
  "stroke-miterlimit": "strokeMiterlimit",
  strokeWidth: 1,
  "stroke-width": "strokeWidth",
  strokeOpacity: 1,
  "stroke-opacity": "strokeOpacity",
  suppressContentEditableWarning: 1,
  suppressHydrationWarning: 1,
  surfaceScale: 1,
  systemLanguage: 1,
  tableValues: 1,
  targetX: 1,
  targetY: 1,
  textAnchor: 1,
  "text-anchor": "textAnchor",
  textDecoration: 1,
  "text-decoration": "textDecoration",
  textLength: 1,
  textRendering: 1,
  "text-rendering": "textRendering",
  to: 0,
  transform: 0,
  typeof: 0,
  u1: 0,
  u2: 0,
  underlinePosition: 1,
  "underline-position": "underlinePosition",
  underlineThickness: 1,
  "underline-thickness": "underlineThickness",
  unicode: 0,
  unicodeBidi: 1,
  "unicode-bidi": "unicodeBidi",
  unicodeRange: 1,
  "unicode-range": "unicodeRange",
  unitsPerEm: 1,
  "units-per-em": "unitsPerEm",
  unselectable: 0,
  vAlphabetic: 1,
  "v-alphabetic": "vAlphabetic",
  values: 0,
  vectorEffect: 1,
  "vector-effect": "vectorEffect",
  version: 0,
  vertAdvY: 1,
  "vert-adv-y": "vertAdvY",
  vertOriginX: 1,
  "vert-origin-x": "vertOriginX",
  vertOriginY: 1,
  "vert-origin-y": "vertOriginY",
  vHanging: 1,
  "v-hanging": "vHanging",
  vIdeographic: 1,
  "v-ideographic": "vIdeographic",
  viewBox: 1,
  viewTarget: 1,
  visibility: 0,
  vMathematical: 1,
  "v-mathematical": "vMathematical",
  vocab: 0,
  widths: 0,
  wordSpacing: 1,
  "word-spacing": "wordSpacing",
  writingMode: 1,
  "writing-mode": "writingMode",
  x1: 0,
  x2: 0,
  x: 0,
  xChannelSelector: 1,
  xHeight: 1,
  "x-height": "xHeight",
  xlinkActuate: 1,
  "xlink:actuate": "xlinkActuate",
  xlinkArcrole: 1,
  "xlink:arcrole": "xlinkArcrole",
  xlinkHref: 1,
  "xlink:href": "xlinkHref",
  xlinkRole: 1,
  "xlink:role": "xlinkRole",
  xlinkShow: 1,
  "xlink:show": "xlinkShow",
  xlinkTitle: 1,
  "xlink:title": "xlinkTitle",
  xlinkType: 1,
  "xlink:type": "xlinkType",
  xmlBase: 1,
  "xml:base": "xmlBase",
  xmlLang: 1,
  "xml:lang": "xmlLang",
  xmlns: 0,
  "xml:space": "xmlSpace",
  xmlnsXlink: 1,
  "xmlns:xlink": "xmlnsXlink",
  xmlSpace: 1,
  y1: 0,
  y2: 0,
  y: 0,
  yChannelSelector: 1,
  z: 0,
  zoomAndPan: 1
};
const iX = 0, fu = 1, z0 = 2, U0 = 3, US = 4, sX = 5, aX = 6;
function Rfe(e) {
  return ii.hasOwnProperty(e) ? ii[e] : null;
}
function ji(e, t, n, r, o, i, a) {
  this.acceptsBooleans = t === z0 || t === U0 || t === US, this.attributeName = r, this.attributeNamespace = o, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = i, this.removeEmptyString = a;
}
const ii = {}, Ife = [
  "children",
  "dangerouslySetInnerHTML",
  // TODO: This prevents the assignment of defaultValue to regular
  // elements (not just inputs). Now that ReactDOMInput assigns to the
  // defaultValue property -- do we need this?
  "defaultValue",
  "defaultChecked",
  "innerHTML",
  "suppressContentEditableWarning",
  "suppressHydrationWarning",
  "style"
];
Ife.forEach((e) => {
  ii[e] = new ji(
    e,
    iX,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"]
].forEach(([e, t]) => {
  ii[e] = new ji(
    e,
    fu,
    !1,
    // mustUseProperty
    t,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["contentEditable", "draggable", "spellCheck", "value"].forEach((e) => {
  ii[e] = new ji(
    e,
    z0,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha"
].forEach((e) => {
  ii[e] = new ji(
    e,
    z0,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "allowFullScreen",
  "async",
  // Note: there is a special case that prevents it from being written to the DOM
  // on the client side because the browsers are inconsistent. Instead we call focus().
  "autoFocus",
  "autoPlay",
  "controls",
  "default",
  "defer",
  "disabled",
  "disablePictureInPicture",
  "disableRemotePlayback",
  "formNoValidate",
  "hidden",
  "loop",
  "noModule",
  "noValidate",
  "open",
  "playsInline",
  "readOnly",
  "required",
  "reversed",
  "scoped",
  "seamless",
  // Microdata
  "itemScope"
].forEach((e) => {
  ii[e] = new ji(
    e,
    U0,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "checked",
  // Note: `option.selected` is not updated if `select.multiple` is
  // disabled with `removeAttribute`. We have special logic for handling this.
  "multiple",
  "muted",
  "selected"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  ii[e] = new ji(
    e,
    U0,
    !0,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "capture",
  "download"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  ii[e] = new ji(
    e,
    US,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "cols",
  "rows",
  "size",
  "span"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  ii[e] = new ji(
    e,
    aX,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["rowSpan", "start"].forEach((e) => {
  ii[e] = new ji(
    e,
    sX,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const HS = /[\-\:]([a-z])/g, WS = (e) => e[1].toUpperCase();
[
  "accent-height",
  "alignment-baseline",
  "arabic-form",
  "baseline-shift",
  "cap-height",
  "clip-path",
  "clip-rule",
  "color-interpolation",
  "color-interpolation-filters",
  "color-profile",
  "color-rendering",
  "dominant-baseline",
  "enable-background",
  "fill-opacity",
  "fill-rule",
  "flood-color",
  "flood-opacity",
  "font-family",
  "font-size",
  "font-size-adjust",
  "font-stretch",
  "font-style",
  "font-variant",
  "font-weight",
  "glyph-name",
  "glyph-orientation-horizontal",
  "glyph-orientation-vertical",
  "horiz-adv-x",
  "horiz-origin-x",
  "image-rendering",
  "letter-spacing",
  "lighting-color",
  "marker-end",
  "marker-mid",
  "marker-start",
  "overline-position",
  "overline-thickness",
  "paint-order",
  "panose-1",
  "pointer-events",
  "rendering-intent",
  "shape-rendering",
  "stop-color",
  "stop-opacity",
  "strikethrough-position",
  "strikethrough-thickness",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "text-anchor",
  "text-decoration",
  "text-rendering",
  "underline-position",
  "underline-thickness",
  "unicode-bidi",
  "unicode-range",
  "units-per-em",
  "v-alphabetic",
  "v-hanging",
  "v-ideographic",
  "v-mathematical",
  "vector-effect",
  "vert-adv-y",
  "vert-origin-x",
  "vert-origin-y",
  "word-spacing",
  "writing-mode",
  "xmlns:xlink",
  "x-height"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(HS, WS);
  ii[t] = new ji(
    t,
    fu,
    !1,
    // mustUseProperty
    e,
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xlink:actuate",
  "xlink:arcrole",
  "xlink:role",
  "xlink:show",
  "xlink:title",
  "xlink:type"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(HS, WS);
  ii[t] = new ji(
    t,
    fu,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/1999/xlink",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xml:base",
  "xml:lang",
  "xml:space"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(HS, WS);
  ii[t] = new ji(
    t,
    fu,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/XML/1998/namespace",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["tabIndex", "crossOrigin"].forEach((e) => {
  ii[e] = new ji(
    e,
    fu,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const Nfe = "xlinkHref";
ii[Nfe] = new ji(
  "xlinkHref",
  fu,
  !1,
  // mustUseProperty
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  // sanitizeURL
  !1
  // removeEmptyString
);
["src", "href", "action", "formAction"].forEach((e) => {
  ii[e] = new ji(
    e,
    fu,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !0,
    // sanitizeURL
    !0
    // removeEmptyString
  );
});
const {
  CAMELCASE: Bfe,
  SAME: Ffe,
  possibleStandardNames: XR
} = F0, zfe = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", Ufe = zfe + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", Hfe = RegExp.prototype.test.bind(
  // eslint-disable-next-line no-misleading-character-class
  new RegExp("^(data|aria)-[" + Ufe + "]*$")
), Wfe = Object.keys(
  XR
).reduce((e, t) => {
  const n = XR[t];
  return n === Ffe ? e[t] = t : n === Bfe ? e[t.toLowerCase()] = t : e[t] = n, e;
}, {});
qs.BOOLEAN = U0;
qs.BOOLEANISH_STRING = z0;
qs.NUMERIC = sX;
qs.OVERLOADED_BOOLEAN = US;
qs.POSITIVE_NUMERIC = aX;
qs.RESERVED = iX;
qs.STRING = fu;
qs.getPropertyInfo = Rfe;
qs.isCustomAttribute = Hfe;
qs.possibleStandardNames = Wfe;
var $S = {}, VS = {}, YR = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, $fe = /\n/g, Vfe = /^\s*/, Zfe = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, qfe = /^:\s*/, Gfe = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, Kfe = /^[;\s]*/, Xfe = /^\s+|\s+$/g, Yfe = `
`, JR = "/", QR = "*", ac = "", Jfe = "comment", Qfe = "declaration", ehe = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e) return [];
  t = t || {};
  var n = 1, r = 1;
  function o(f) {
    var m = f.match($fe);
    m && (n += m.length);
    var b = f.lastIndexOf(Yfe);
    r = ~b ? f.length - b : r + f.length;
  }
  function i() {
    var f = { line: n, column: r };
    return function(m) {
      return m.position = new a(f), u(), m;
    };
  }
  function a(f) {
    this.start = f, this.end = { line: n, column: r }, this.source = t.source;
  }
  a.prototype.content = e;
  function s(f) {
    var m = new Error(
      t.source + ":" + n + ":" + r + ": " + f
    );
    if (m.reason = f, m.filename = t.source, m.line = n, m.column = r, m.source = e, !t.silent) throw m;
  }
  function l(f) {
    var m = f.exec(e);
    if (m) {
      var b = m[0];
      return o(b), e = e.slice(b.length), m;
    }
  }
  function u() {
    l(Vfe);
  }
  function c(f) {
    var m;
    for (f = f || []; m = p(); )
      m !== !1 && f.push(m);
    return f;
  }
  function p() {
    var f = i();
    if (!(JR != e.charAt(0) || QR != e.charAt(1))) {
      for (var m = 2; ac != e.charAt(m) && (QR != e.charAt(m) || JR != e.charAt(m + 1)); )
        ++m;
      if (m += 2, ac === e.charAt(m - 1))
        return s("End of comment missing");
      var b = e.slice(2, m - 2);
      return r += 2, o(b), e = e.slice(m), r += 2, f({
        type: Jfe,
        comment: b
      });
    }
  }
  function d() {
    var f = i(), m = l(Zfe);
    if (m) {
      if (p(), !l(qfe)) return s("property missing ':'");
      var b = l(Gfe), E = f({
        type: Qfe,
        property: eI(m[0].replace(YR, ac)),
        value: b ? eI(b[0].replace(YR, ac)) : ac
      });
      return l(Kfe), E;
    }
  }
  function g() {
    var f = [];
    c(f);
    for (var m; m = d(); )
      m !== !1 && (f.push(m), c(f));
    return f;
  }
  return u(), g();
};
function eI(e) {
  return e ? e.replace(Xfe, ac) : ac;
}
var the = gr && gr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(VS, "__esModule", { value: !0 });
VS.default = rhe;
var nhe = the(ehe);
function rhe(e, t) {
  var n = null;
  if (!e || typeof e != "string")
    return n;
  var r = (0, nhe.default)(e), o = typeof t == "function";
  return r.forEach(function(i) {
    if (i.type === "declaration") {
      var a = i.property, s = i.value;
      o ? t(a, s, i) : s && (n = n || {}, n[a] = s);
    }
  }), n;
}
var H0 = {};
Object.defineProperty(H0, "__esModule", { value: !0 });
H0.camelCase = void 0;
var ohe = /^--[a-zA-Z0-9_-]+$/, ihe = /-([a-z])/g, she = /^[^-]+$/, ahe = /^-(webkit|moz|ms|o|khtml)-/, lhe = /^-(ms)-/, uhe = function(e) {
  return !e || she.test(e) || ohe.test(e);
}, che = function(e, t) {
  return t.toUpperCase();
}, tI = function(e, t) {
  return "".concat(t, "-");
}, phe = function(e, t) {
  return t === void 0 && (t = {}), uhe(e) ? e : (e = e.toLowerCase(), t.reactCompat ? e = e.replace(lhe, tI) : e = e.replace(ahe, tI), e.replace(ihe, che));
};
H0.camelCase = phe;
var dhe = gr && gr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
}, fhe = dhe(VS), hhe = H0;
function M1(e, t) {
  var n = {};
  return !e || typeof e != "string" || (0, fhe.default)(e, function(r, o) {
    r && o && (n[(0, hhe.camelCase)(r, t)] = o);
  }), n;
}
M1.default = M1;
var ghe = M1;
(function(e) {
  var t = gr && gr.__importDefault || function(c) {
    return c && c.__esModule ? c : { default: c };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.returnFirstArg = e.canTextBeChildOfNode = e.ELEMENTS_WITH_NO_TEXT_CHILDREN = e.PRESERVE_CUSTOM_ATTRIBUTES = void 0, e.isCustomComponent = i, e.setStyleProp = s;
  var n = be, r = t(ghe), o = /* @__PURE__ */ new Set([
    "annotation-xml",
    "color-profile",
    "font-face",
    "font-face-src",
    "font-face-uri",
    "font-face-format",
    "font-face-name",
    "missing-glyph"
  ]);
  function i(c, p) {
    return c.includes("-") ? !o.has(c) : !!(p && typeof p.is == "string");
  }
  var a = {
    reactCompat: !0
  };
  function s(c, p) {
    if (typeof c == "string") {
      if (!c.trim()) {
        p.style = {};
        return;
      }
      try {
        p.style = (0, r.default)(c, a);
      } catch {
        p.style = {};
      }
    }
  }
  e.PRESERVE_CUSTOM_ATTRIBUTES = Number(n.version.split(".")[0]) >= 16, e.ELEMENTS_WITH_NO_TEXT_CHILDREN = /* @__PURE__ */ new Set([
    "tr",
    "tbody",
    "thead",
    "tfoot",
    "colgroup",
    "table",
    "head",
    "html",
    "frameset"
  ]);
  var l = function(c) {
    return !e.ELEMENTS_WITH_NO_TEXT_CHILDREN.has(c.name);
  };
  e.canTextBeChildOfNode = l;
  var u = function(c) {
    return c;
  };
  e.returnFirstArg = u;
})($S);
Object.defineProperty(B0, "__esModule", { value: !0 });
B0.default = bhe;
var qd = qs, nI = $S, mhe = ["checked", "value"], vhe = ["input", "select", "textarea"], yhe = {
  reset: !0,
  submit: !0
};
function bhe(e, t) {
  e === void 0 && (e = {});
  var n = {}, r = !!(e.type && yhe[e.type]);
  for (var o in e) {
    var i = e[o];
    if ((0, qd.isCustomAttribute)(o)) {
      n[o] = i;
      continue;
    }
    var a = o.toLowerCase(), s = rI(a);
    if (s) {
      var l = (0, qd.getPropertyInfo)(s);
      switch (mhe.includes(s) && vhe.includes(t) && !r && (s = rI("default" + a)), n[s] = i, l && l.type) {
        case qd.BOOLEAN:
          n[s] = !0;
          break;
        case qd.OVERLOADED_BOOLEAN:
          i === "" && (n[s] = !0);
          break;
      }
      continue;
    }
    nI.PRESERVE_CUSTOM_ATTRIBUTES && (n[o] = i);
  }
  return (0, nI.setStyleProp)(e.style, n), n;
}
function rI(e) {
  return qd.possibleStandardNames[e];
}
var ZS = {}, whe = gr && gr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(ZS, "__esModule", { value: !0 });
ZS.default = lX;
var Ox = be, Che = whe(B0), pf = $S, Ohe = {
  cloneElement: Ox.cloneElement,
  createElement: Ox.createElement,
  isValidElement: Ox.isValidElement
};
function lX(e, t) {
  t === void 0 && (t = {});
  for (var n = [], r = typeof t.replace == "function", o = t.transform || pf.returnFirstArg, i = t.library || Ohe, a = i.cloneElement, s = i.createElement, l = i.isValidElement, u = e.length, c = 0; c < u; c++) {
    var p = e[c];
    if (r) {
      var d = t.replace(p, c);
      if (l(d)) {
        u > 1 && (d = a(d, {
          key: d.key || c
        })), n.push(o(d, p, c));
        continue;
      }
    }
    if (p.type === "text") {
      var g = !p.data.trim().length;
      if (g && p.parent && !(0, pf.canTextBeChildOfNode)(p.parent) || t.trim && g)
        continue;
      n.push(o(p.data, p, c));
      continue;
    }
    var f = p, m = {};
    xhe(f) ? ((0, pf.setStyleProp)(f.attribs.style, f.attribs), m = f.attribs) : f.attribs && (m = (0, Che.default)(f.attribs, f.name));
    var b = void 0;
    switch (p.type) {
      case "script":
      case "style":
        p.children[0] && (m.dangerouslySetInnerHTML = {
          __html: p.children[0].data
        });
        break;
      case "tag":
        p.name === "textarea" && p.children[0] ? m.defaultValue = p.children[0].data : p.children && p.children.length && (b = lX(p.children, t));
        break;
      default:
        continue;
    }
    u > 1 && (m.key = c), n.push(o(s(p.name, m, b), p, c));
  }
  return n.length === 1 ? n[0] : n;
}
function xhe(e) {
  return pf.PRESERVE_CUSTOM_ATTRIBUTES && e.type === "tag" && (0, pf.isCustomComponent)(e.name, e.attribs);
}
(function(e) {
  var t = gr && gr.__importDefault || function(l) {
    return l && l.__esModule ? l : { default: l };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.htmlToDOM = e.domToReact = e.attributesToProps = e.Text = e.ProcessingInstruction = e.Element = e.Comment = void 0, e.default = s;
  var n = t(RS);
  e.htmlToDOM = n.default;
  var r = t(B0);
  e.attributesToProps = r.default;
  var o = t(ZS);
  e.domToReact = o.default;
  var i = NS;
  Object.defineProperty(e, "Comment", { enumerable: !0, get: function() {
    return i.Comment;
  } }), Object.defineProperty(e, "Element", { enumerable: !0, get: function() {
    return i.Element;
  } }), Object.defineProperty(e, "ProcessingInstruction", { enumerable: !0, get: function() {
    return i.ProcessingInstruction;
  } }), Object.defineProperty(e, "Text", { enumerable: !0, get: function() {
    return i.Text;
  } });
  var a = { lowerCaseAttributeNames: !1 };
  function s(l, u) {
    if (typeof l != "string")
      throw new TypeError("First argument must be a string");
    return l ? (0, o.default)((0, n.default)(l, (u == null ? void 0 : u.htmlparser2) || a), u) : [];
  }
})(HK);
const Ehe = /* @__PURE__ */ Wde(HK);
Ehe.default;
var mr = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function khe(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var D1 = { exports: {} }, ad = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var oI;
function Lhe() {
  if (oI) return ad;
  oI = 1;
  var e = be, t = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, o = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, i = { key: !0, ref: !0, __self: !0, __source: !0 };
  function a(s, l, u) {
    var c, p = {}, d = null, g = null;
    u !== void 0 && (d = "" + u), l.key !== void 0 && (d = "" + l.key), l.ref !== void 0 && (g = l.ref);
    for (c in l) r.call(l, c) && !i.hasOwnProperty(c) && (p[c] = l[c]);
    if (s && s.defaultProps) for (c in l = s.defaultProps, l) p[c] === void 0 && (p[c] = l[c]);
    return { $$typeof: t, type: s, key: d, ref: g, props: p, _owner: o.current };
  }
  return ad.Fragment = n, ad.jsx = a, ad.jsxs = a, ad;
}
var hm = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var iI;
function _he() {
  return iI || (iI = 1, process.env.NODE_ENV !== "production" && function() {
    var e = be, t = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), a = Symbol.for("react.provider"), s = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), c = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), d = Symbol.for("react.lazy"), g = Symbol.for("react.offscreen"), f = Symbol.iterator, m = "@@iterator";
    function b(y) {
      if (y === null || typeof y != "object")
        return null;
      var R = f && y[f] || y[m];
      return typeof R == "function" ? R : null;
    }
    var E = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function w(y) {
      {
        for (var R = arguments.length, G = new Array(R > 1 ? R - 1 : 0), ne = 1; ne < R; ne++)
          G[ne - 1] = arguments[ne];
        M("error", y, G);
      }
    }
    function M(y, R, G) {
      {
        var ne = E.ReactDebugCurrentFrame, ae = ne.getStackAddendum();
        ae !== "" && (R += "%s", G = G.concat([ae]));
        var ue = G.map(function(se) {
          return String(se);
        });
        ue.unshift("Warning: " + R), Function.prototype.apply.call(console[y], console, ue);
      }
    }
    var x = !1, v = !1, C = !1, P = !1, F = !1, L;
    L = Symbol.for("react.module.reference");
    function B(y) {
      return !!(typeof y == "string" || typeof y == "function" || y === r || y === i || F || y === o || y === u || y === c || P || y === g || x || v || C || typeof y == "object" && y !== null && (y.$$typeof === d || y.$$typeof === p || y.$$typeof === a || y.$$typeof === s || y.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      y.$$typeof === L || y.getModuleId !== void 0));
    }
    function N(y, R, G) {
      var ne = y.displayName;
      if (ne)
        return ne;
      var ae = R.displayName || R.name || "";
      return ae !== "" ? G + "(" + ae + ")" : G;
    }
    function $(y) {
      return y.displayName || "Context";
    }
    function V(y) {
      if (y == null)
        return null;
      if (typeof y.tag == "number" && w("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof y == "function")
        return y.displayName || y.name || null;
      if (typeof y == "string")
        return y;
      switch (y) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case i:
          return "Profiler";
        case o:
          return "StrictMode";
        case u:
          return "Suspense";
        case c:
          return "SuspenseList";
      }
      if (typeof y == "object")
        switch (y.$$typeof) {
          case s:
            var R = y;
            return $(R) + ".Consumer";
          case a:
            var G = y;
            return $(G._context) + ".Provider";
          case l:
            return N(y, y.render, "ForwardRef");
          case p:
            var ne = y.displayName || null;
            return ne !== null ? ne : V(y.type) || "Memo";
          case d: {
            var ae = y, ue = ae._payload, se = ae._init;
            try {
              return V(se(ue));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var H = Object.assign, Z = 0, K, Y, Q, J, _, D, z;
    function S() {
    }
    S.__reactDisabledLog = !0;
    function W() {
      {
        if (Z === 0) {
          K = console.log, Y = console.info, Q = console.warn, J = console.error, _ = console.group, D = console.groupCollapsed, z = console.groupEnd;
          var y = {
            configurable: !0,
            enumerable: !0,
            value: S,
            writable: !0
          };
          Object.defineProperties(console, {
            info: y,
            log: y,
            warn: y,
            error: y,
            group: y,
            groupCollapsed: y,
            groupEnd: y
          });
        }
        Z++;
      }
    }
    function O() {
      {
        if (Z--, Z === 0) {
          var y = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: H({}, y, {
              value: K
            }),
            info: H({}, y, {
              value: Y
            }),
            warn: H({}, y, {
              value: Q
            }),
            error: H({}, y, {
              value: J
            }),
            group: H({}, y, {
              value: _
            }),
            groupCollapsed: H({}, y, {
              value: D
            }),
            groupEnd: H({}, y, {
              value: z
            })
          });
        }
        Z < 0 && w("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var j = E.ReactCurrentDispatcher, U;
    function T(y, R, G) {
      {
        if (U === void 0)
          try {
            throw Error();
          } catch (ae) {
            var ne = ae.stack.trim().match(/\n( *(at )?)/);
            U = ne && ne[1] || "";
          }
        return `
` + U + y;
      }
    }
    var q = !1, A;
    {
      var X = typeof WeakMap == "function" ? WeakMap : Map;
      A = new X();
    }
    function I(y, R) {
      if (!y || q)
        return "";
      {
        var G = A.get(y);
        if (G !== void 0)
          return G;
      }
      var ne;
      q = !0;
      var ae = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var ue;
      ue = j.current, j.current = null, W();
      try {
        if (R) {
          var se = function() {
            throw Error();
          };
          if (Object.defineProperty(se.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(se, []);
            } catch (je) {
              ne = je;
            }
            Reflect.construct(y, [], se);
          } else {
            try {
              se.call();
            } catch (je) {
              ne = je;
            }
            y.call(se.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (je) {
            ne = je;
          }
          y();
        }
      } catch (je) {
        if (je && ne && typeof je.stack == "string") {
          for (var ie = je.stack.split(`
`), Oe = ne.stack.split(`
`), de = ie.length - 1, fe = Oe.length - 1; de >= 1 && fe >= 0 && ie[de] !== Oe[fe]; )
            fe--;
          for (; de >= 1 && fe >= 0; de--, fe--)
            if (ie[de] !== Oe[fe]) {
              if (de !== 1 || fe !== 1)
                do
                  if (de--, fe--, fe < 0 || ie[de] !== Oe[fe]) {
                    var ze = `
` + ie[de].replace(" at new ", " at ");
                    return y.displayName && ze.includes("<anonymous>") && (ze = ze.replace("<anonymous>", y.displayName)), typeof y == "function" && A.set(y, ze), ze;
                  }
                while (de >= 1 && fe >= 0);
              break;
            }
        }
      } finally {
        q = !1, j.current = ue, O(), Error.prepareStackTrace = ae;
      }
      var Et = y ? y.displayName || y.name : "", bt = Et ? T(Et) : "";
      return typeof y == "function" && A.set(y, bt), bt;
    }
    function le(y, R, G) {
      return I(y, !1);
    }
    function he(y) {
      var R = y.prototype;
      return !!(R && R.isReactComponent);
    }
    function oe(y, R, G) {
      if (y == null)
        return "";
      if (typeof y == "function")
        return I(y, he(y));
      if (typeof y == "string")
        return T(y);
      switch (y) {
        case u:
          return T("Suspense");
        case c:
          return T("SuspenseList");
      }
      if (typeof y == "object")
        switch (y.$$typeof) {
          case l:
            return le(y.render);
          case p:
            return oe(y.type, R, G);
          case d: {
            var ne = y, ae = ne._payload, ue = ne._init;
            try {
              return oe(ue(ae), R, G);
            } catch {
            }
          }
        }
      return "";
    }
    var Ae = Object.prototype.hasOwnProperty, Ue = {}, He = E.ReactDebugCurrentFrame;
    function Re(y) {
      if (y) {
        var R = y._owner, G = oe(y.type, y._source, R ? R.type : null);
        He.setExtraStackFrame(G);
      } else
        He.setExtraStackFrame(null);
    }
    function nt(y, R, G, ne, ae) {
      {
        var ue = Function.call.bind(Ae);
        for (var se in y)
          if (ue(y, se)) {
            var ie = void 0;
            try {
              if (typeof y[se] != "function") {
                var Oe = Error((ne || "React class") + ": " + G + " type `" + se + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof y[se] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw Oe.name = "Invariant Violation", Oe;
              }
              ie = y[se](R, se, ne, G, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (de) {
              ie = de;
            }
            ie && !(ie instanceof Error) && (Re(ae), w("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", ne || "React class", G, se, typeof ie), Re(null)), ie instanceof Error && !(ie.message in Ue) && (Ue[ie.message] = !0, Re(ae), w("Failed %s type: %s", G, ie.message), Re(null));
          }
      }
    }
    var Ve = Array.isArray;
    function we(y) {
      return Ve(y);
    }
    function et(y) {
      {
        var R = typeof Symbol == "function" && Symbol.toStringTag, G = R && y[Symbol.toStringTag] || y.constructor.name || "Object";
        return G;
      }
    }
    function lt(y) {
      try {
        return ye(y), !1;
      } catch {
        return !0;
      }
    }
    function ye(y) {
      return "" + y;
    }
    function ke(y) {
      if (lt(y))
        return w("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", et(y)), ye(y);
    }
    var Qe = E.ReactCurrentOwner, Fe = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, Ie, ot;
    function Ee(y) {
      if (Ae.call(y, "ref")) {
        var R = Object.getOwnPropertyDescriptor(y, "ref").get;
        if (R && R.isReactWarning)
          return !1;
      }
      return y.ref !== void 0;
    }
    function wt(y) {
      if (Ae.call(y, "key")) {
        var R = Object.getOwnPropertyDescriptor(y, "key").get;
        if (R && R.isReactWarning)
          return !1;
      }
      return y.key !== void 0;
    }
    function it(y, R) {
      typeof y.ref == "string" && Qe.current;
    }
    function st(y, R) {
      {
        var G = function() {
          Ie || (Ie = !0, w("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", R));
        };
        G.isReactWarning = !0, Object.defineProperty(y, "key", {
          get: G,
          configurable: !0
        });
      }
    }
    function ut(y, R) {
      {
        var G = function() {
          ot || (ot = !0, w("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", R));
        };
        G.isReactWarning = !0, Object.defineProperty(y, "ref", {
          get: G,
          configurable: !0
        });
      }
    }
    var Ct = function(y, R, G, ne, ae, ue, se) {
      var ie = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: y,
        key: R,
        ref: G,
        props: se,
        // Record the component responsible for creating this element.
        _owner: ue
      };
      return ie._store = {}, Object.defineProperty(ie._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(ie, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ne
      }), Object.defineProperty(ie, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ae
      }), Object.freeze && (Object.freeze(ie.props), Object.freeze(ie)), ie;
    };
    function ct(y, R, G, ne, ae) {
      {
        var ue, se = {}, ie = null, Oe = null;
        G !== void 0 && (ke(G), ie = "" + G), wt(R) && (ke(R.key), ie = "" + R.key), Ee(R) && (Oe = R.ref, it(R));
        for (ue in R)
          Ae.call(R, ue) && !Fe.hasOwnProperty(ue) && (se[ue] = R[ue]);
        if (y && y.defaultProps) {
          var de = y.defaultProps;
          for (ue in de)
            se[ue] === void 0 && (se[ue] = de[ue]);
        }
        if (ie || Oe) {
          var fe = typeof y == "function" ? y.displayName || y.name || "Unknown" : y;
          ie && st(se, fe), Oe && ut(se, fe);
        }
        return Ct(y, ie, Oe, ae, ne, Qe.current, se);
      }
    }
    var pt = E.ReactCurrentOwner, rt = E.ReactDebugCurrentFrame;
    function We(y) {
      if (y) {
        var R = y._owner, G = oe(y.type, y._source, R ? R.type : null);
        rt.setExtraStackFrame(G);
      } else
        rt.setExtraStackFrame(null);
    }
    var Ot;
    Ot = !1;
    function xt(y) {
      return typeof y == "object" && y !== null && y.$$typeof === t;
    }
    function gt() {
      {
        if (pt.current) {
          var y = V(pt.current.type);
          if (y)
            return `

Check the render method of \`` + y + "`.";
        }
        return "";
      }
    }
    function Ht(y) {
      return "";
    }
    var mt = {};
    function Wt(y) {
      {
        var R = gt();
        if (!R) {
          var G = typeof y == "string" ? y : y.displayName || y.name;
          G && (R = `

Check the top-level render call using <` + G + ">.");
        }
        return R;
      }
    }
    function vt(y, R) {
      {
        if (!y._store || y._store.validated || y.key != null)
          return;
        y._store.validated = !0;
        var G = Wt(R);
        if (mt[G])
          return;
        mt[G] = !0;
        var ne = "";
        y && y._owner && y._owner !== pt.current && (ne = " It was passed a child from " + V(y._owner.type) + "."), We(y), w('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', G, ne), We(null);
      }
    }
    function kt(y, R) {
      {
        if (typeof y != "object")
          return;
        if (we(y))
          for (var G = 0; G < y.length; G++) {
            var ne = y[G];
            xt(ne) && vt(ne, R);
          }
        else if (xt(y))
          y._store && (y._store.validated = !0);
        else if (y) {
          var ae = b(y);
          if (typeof ae == "function" && ae !== y.entries)
            for (var ue = ae.call(y), se; !(se = ue.next()).done; )
              xt(se.value) && vt(se.value, R);
        }
      }
    }
    function Un(y) {
      {
        var R = y.type;
        if (R == null || typeof R == "string")
          return;
        var G;
        if (typeof R == "function")
          G = R.propTypes;
        else if (typeof R == "object" && (R.$$typeof === l || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        R.$$typeof === p))
          G = R.propTypes;
        else
          return;
        if (G) {
          var ne = V(R);
          nt(G, y.props, "prop", ne, y);
        } else if (R.PropTypes !== void 0 && !Ot) {
          Ot = !0;
          var ae = V(R);
          w("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", ae || "Unknown");
        }
        typeof R.getDefaultProps == "function" && !R.getDefaultProps.isReactClassApproved && w("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function yt(y) {
      {
        for (var R = Object.keys(y.props), G = 0; G < R.length; G++) {
          var ne = R[G];
          if (ne !== "children" && ne !== "key") {
            We(y), w("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", ne), We(null);
            break;
          }
        }
        y.ref !== null && (We(y), w("Invalid attribute `ref` supplied to `React.Fragment`."), We(null));
      }
    }
    var re = {};
    function ao(y, R, G, ne, ae, ue) {
      {
        var se = B(y);
        if (!se) {
          var ie = "";
          (y === void 0 || typeof y == "object" && y !== null && Object.keys(y).length === 0) && (ie += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var Oe = Ht();
          Oe ? ie += Oe : ie += gt();
          var de;
          y === null ? de = "null" : we(y) ? de = "array" : y !== void 0 && y.$$typeof === t ? (de = "<" + (V(y.type) || "Unknown") + " />", ie = " Did you accidentally export a JSX literal instead of a component?") : de = typeof y, w("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", de, ie);
        }
        var fe = ct(y, R, G, ae, ue);
        if (fe == null)
          return fe;
        if (se) {
          var ze = R.children;
          if (ze !== void 0)
            if (ne)
              if (we(ze)) {
                for (var Et = 0; Et < ze.length; Et++)
                  kt(ze[Et], y);
                Object.freeze && Object.freeze(ze);
              } else
                w("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              kt(ze, y);
        }
        if (Ae.call(R, "key")) {
          var bt = V(y), je = Object.keys(R).filter(function(Li) {
            return Li !== "key";
          }), Hn = je.length > 0 ? "{key: someKey, " + je.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!re[bt + Hn]) {
            var ki = je.length > 0 ? "{" + je.join(": ..., ") + ": ...}" : "{}";
            w(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, Hn, bt, ki, bt), re[bt + Hn] = !0;
          }
        }
        return y === r ? yt(fe) : Un(fe), fe;
      }
    }
    function Ci(y, R, G) {
      return ao(y, R, G, !0);
    }
    function Oi(y, R, G) {
      return ao(y, R, G, !1);
    }
    var xi = Oi, Ei = Ci;
    hm.Fragment = r, hm.jsx = xi, hm.jsxs = Ei;
  }()), hm;
}
process.env.NODE_ENV === "production" ? D1.exports = Lhe() : D1.exports = _he();
var Jo = D1.exports;
$e({});
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function sI(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function fi(e) {
  var t, n;
  return sI(e) === !1 ? !1 : (t = e.constructor, t === void 0 ? !0 : (n = t.prototype, !(sI(n) === !1 || n.hasOwnProperty("isPrototypeOf") === !1)));
}
var uX = Symbol.for("immer-nothing"), aI = Symbol.for("immer-draftable"), Es = Symbol.for("immer-state"), Phe = process.env.NODE_ENV !== "production" ? [
  // All error codes, starting by 0:
  function(e) {
    return `The plugin for '${e}' has not been loaded into Immer. To enable the plugin, import and call \`enable${e}()\` when initializing your application.`;
  },
  function(e) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${e}'`;
  },
  "This object has been frozen and should not be mutated",
  function(e) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + e;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(e) {
    return `'current' expects a draft, got: ${e}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(e) {
    return `'original' expects a draft, got: ${e}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function $i(e, ...t) {
  if (process.env.NODE_ENV !== "production") {
    const n = Phe[e], r = typeof n == "function" ? n.apply(null, t) : n;
    throw new Error(`[Immer] ${r}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var xp = Object.getPrototypeOf;
function Ic(e) {
  return !!e && !!e[Es];
}
function Nc(e) {
  var t;
  return e ? cX(e) || Array.isArray(e) || !!e[aI] || !!((t = e.constructor) != null && t[aI]) || $0(e) || V0(e) : !1;
}
var She = Object.prototype.constructor.toString();
function cX(e) {
  if (!e || typeof e != "object")
    return !1;
  const t = xp(e);
  if (t === null)
    return !0;
  const n = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
  return n === Object ? !0 : typeof n == "function" && Function.toString.call(n) === She;
}
function nb(e, t) {
  W0(e) === 0 ? Reflect.ownKeys(e).forEach((n) => {
    t(n, e[n], e);
  }) : e.forEach((n, r) => t(r, n, e));
}
function W0(e) {
  const t = e[Es];
  return t ? t.type_ : Array.isArray(e) ? 1 : $0(e) ? 2 : V0(e) ? 3 : 0;
}
function T1(e, t) {
  return W0(e) === 2 ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t);
}
function pX(e, t, n) {
  const r = W0(e);
  r === 2 ? e.set(t, n) : r === 3 ? e.add(n) : e[t] = n;
}
function Mhe(e, t) {
  return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && t !== t;
}
function $0(e) {
  return e instanceof Map;
}
function V0(e) {
  return e instanceof Set;
}
function Qu(e) {
  return e.copy_ || e.base_;
}
function j1(e, t) {
  if ($0(e))
    return new Map(e);
  if (V0(e))
    return new Set(e);
  if (Array.isArray(e))
    return Array.prototype.slice.call(e);
  const n = cX(e);
  if (t === !0 || t === "class_only" && !n) {
    const r = Object.getOwnPropertyDescriptors(e);
    delete r[Es];
    let o = Reflect.ownKeys(r);
    for (let i = 0; i < o.length; i++) {
      const a = o[i], s = r[a];
      s.writable === !1 && (s.writable = !0, s.configurable = !0), (s.get || s.set) && (r[a] = {
        configurable: !0,
        writable: !0,
        // could live with !!desc.set as well here...
        enumerable: s.enumerable,
        value: e[a]
      });
    }
    return Object.create(xp(e), r);
  } else {
    const r = xp(e);
    if (r !== null && n)
      return { ...e };
    const o = Object.create(r);
    return Object.assign(o, e);
  }
}
function qS(e, t = !1) {
  return Z0(e) || Ic(e) || !Nc(e) || (W0(e) > 1 && (e.set = e.add = e.clear = e.delete = Dhe), Object.freeze(e), t && Object.entries(e).forEach(([n, r]) => qS(r, !0))), e;
}
function Dhe() {
  $i(2);
}
function Z0(e) {
  return Object.isFrozen(e);
}
var The = {};
function Bc(e) {
  const t = The[e];
  return t || $i(0, e), t;
}
var nh;
function dX() {
  return nh;
}
function jhe(e, t) {
  return {
    drafts_: [],
    parent_: e,
    immer_: t,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0
  };
}
function lI(e, t) {
  t && (Bc("Patches"), e.patches_ = [], e.inversePatches_ = [], e.patchListener_ = t);
}
function A1(e) {
  R1(e), e.drafts_.forEach(Ahe), e.drafts_ = null;
}
function R1(e) {
  e === nh && (nh = e.parent_);
}
function uI(e) {
  return nh = jhe(nh, e);
}
function Ahe(e) {
  const t = e[Es];
  t.type_ === 0 || t.type_ === 1 ? t.revoke_() : t.revoked_ = !0;
}
function cI(e, t) {
  t.unfinalizedDrafts_ = t.drafts_.length;
  const n = t.drafts_[0];
  return e !== void 0 && e !== n ? (n[Es].modified_ && (A1(t), $i(4)), Nc(e) && (e = rb(t, e), t.parent_ || ob(t, e)), t.patches_ && Bc("Patches").generateReplacementPatches_(
    n[Es].base_,
    e,
    t.patches_,
    t.inversePatches_
  )) : e = rb(t, n, []), A1(t), t.patches_ && t.patchListener_(t.patches_, t.inversePatches_), e !== uX ? e : void 0;
}
function rb(e, t, n) {
  if (Z0(t))
    return t;
  const r = t[Es];
  if (!r)
    return nb(
      t,
      (o, i) => pI(e, r, t, o, i, n)
    ), t;
  if (r.scope_ !== e)
    return t;
  if (!r.modified_)
    return ob(e, r.base_, !0), r.base_;
  if (!r.finalized_) {
    r.finalized_ = !0, r.scope_.unfinalizedDrafts_--;
    const o = r.copy_;
    let i = o, a = !1;
    r.type_ === 3 && (i = new Set(o), o.clear(), a = !0), nb(
      i,
      (s, l) => pI(e, r, o, s, l, n, a)
    ), ob(e, o, !1), n && e.patches_ && Bc("Patches").generatePatches_(
      r,
      n,
      e.patches_,
      e.inversePatches_
    );
  }
  return r.copy_;
}
function pI(e, t, n, r, o, i, a) {
  if (process.env.NODE_ENV !== "production" && o === n && $i(5), Ic(o)) {
    const s = i && t && t.type_ !== 3 && // Set objects are atomic since they have no keys.
    !T1(t.assigned_, r) ? i.concat(r) : void 0, l = rb(e, o, s);
    if (pX(n, r, l), Ic(l))
      e.canAutoFreeze_ = !1;
    else
      return;
  } else a && n.add(o);
  if (Nc(o) && !Z0(o)) {
    if (!e.immer_.autoFreeze_ && e.unfinalizedDrafts_ < 1)
      return;
    rb(e, o), (!t || !t.scope_.parent_) && typeof r != "symbol" && Object.prototype.propertyIsEnumerable.call(n, r) && ob(e, o);
  }
}
function ob(e, t, n = !1) {
  !e.parent_ && e.immer_.autoFreeze_ && e.canAutoFreeze_ && qS(t, n);
}
function Rhe(e, t) {
  const n = Array.isArray(e), r = {
    type_: n ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: t ? t.scope_ : dX(),
    // True for both shallow and deep changes.
    modified_: !1,
    // Used during finalization.
    finalized_: !1,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: t,
    // The base state.
    base_: e,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: !1
  };
  let o = r, i = GS;
  n && (o = [r], i = rh);
  const { revoke: a, proxy: s } = Proxy.revocable(o, i);
  return r.draft_ = s, r.revoke_ = a, s;
}
var GS = {
  get(e, t) {
    if (t === Es)
      return e;
    const n = Qu(e);
    if (!T1(n, t))
      return Ihe(e, n, t);
    const r = n[t];
    return e.finalized_ || !Nc(r) ? r : r === xx(e.base_, t) ? (Ex(e), e.copy_[t] = N1(r, e)) : r;
  },
  has(e, t) {
    return t in Qu(e);
  },
  ownKeys(e) {
    return Reflect.ownKeys(Qu(e));
  },
  set(e, t, n) {
    const r = fX(Qu(e), t);
    if (r != null && r.set)
      return r.set.call(e.draft_, n), !0;
    if (!e.modified_) {
      const o = xx(Qu(e), t), i = o == null ? void 0 : o[Es];
      if (i && i.base_ === n)
        return e.copy_[t] = n, e.assigned_[t] = !1, !0;
      if (Mhe(n, o) && (n !== void 0 || T1(e.base_, t)))
        return !0;
      Ex(e), I1(e);
    }
    return e.copy_[t] === n && // special case: handle new props with value 'undefined'
    (n !== void 0 || t in e.copy_) || // special case: NaN
    Number.isNaN(n) && Number.isNaN(e.copy_[t]) || (e.copy_[t] = n, e.assigned_[t] = !0), !0;
  },
  deleteProperty(e, t) {
    return xx(e.base_, t) !== void 0 || t in e.base_ ? (e.assigned_[t] = !1, Ex(e), I1(e)) : delete e.assigned_[t], e.copy_ && delete e.copy_[t], !0;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(e, t) {
    const n = Qu(e), r = Reflect.getOwnPropertyDescriptor(n, t);
    return r && {
      writable: !0,
      configurable: e.type_ !== 1 || t !== "length",
      enumerable: r.enumerable,
      value: n[t]
    };
  },
  defineProperty() {
    $i(11);
  },
  getPrototypeOf(e) {
    return xp(e.base_);
  },
  setPrototypeOf() {
    $i(12);
  }
}, rh = {};
nb(GS, (e, t) => {
  rh[e] = function() {
    return arguments[0] = arguments[0][0], t.apply(this, arguments);
  };
});
rh.deleteProperty = function(e, t) {
  return process.env.NODE_ENV !== "production" && isNaN(parseInt(t)) && $i(13), rh.set.call(this, e, t, void 0);
};
rh.set = function(e, t, n) {
  return process.env.NODE_ENV !== "production" && t !== "length" && isNaN(parseInt(t)) && $i(14), GS.set.call(this, e[0], t, n, e[0]);
};
function xx(e, t) {
  const n = e[Es];
  return (n ? Qu(n) : e)[t];
}
function Ihe(e, t, n) {
  var r;
  const o = fX(t, n);
  return o ? "value" in o ? o.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (r = o.get) == null ? void 0 : r.call(e.draft_)
  ) : void 0;
}
function fX(e, t) {
  if (!(t in e))
    return;
  let n = xp(e);
  for (; n; ) {
    const r = Object.getOwnPropertyDescriptor(n, t);
    if (r)
      return r;
    n = xp(n);
  }
}
function I1(e) {
  e.modified_ || (e.modified_ = !0, e.parent_ && I1(e.parent_));
}
function Ex(e) {
  e.copy_ || (e.copy_ = j1(
    e.base_,
    e.scope_.immer_.useStrictShallowCopy_
  ));
}
var Nhe = class {
  constructor(e) {
    this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.produce = (t, n, r) => {
      if (typeof t == "function" && typeof n != "function") {
        const i = n;
        n = t;
        const a = this;
        return function(s = i, ...l) {
          return a.produce(s, (u) => n.call(this, u, ...l));
        };
      }
      typeof n != "function" && $i(6), r !== void 0 && typeof r != "function" && $i(7);
      let o;
      if (Nc(t)) {
        const i = uI(this), a = N1(t, void 0);
        let s = !0;
        try {
          o = n(a), s = !1;
        } finally {
          s ? A1(i) : R1(i);
        }
        return lI(i, r), cI(o, i);
      } else if (!t || typeof t != "object") {
        if (o = n(t), o === void 0 && (o = t), o === uX && (o = void 0), this.autoFreeze_ && qS(o, !0), r) {
          const i = [], a = [];
          Bc("Patches").generateReplacementPatches_(t, o, i, a), r(i, a);
        }
        return o;
      } else
        $i(1, t);
    }, this.produceWithPatches = (t, n) => {
      if (typeof t == "function")
        return (i, ...a) => this.produceWithPatches(i, (s) => t(s, ...a));
      let r, o;
      return [this.produce(t, n, (i, a) => {
        r = i, o = a;
      }), r, o];
    }, typeof (e == null ? void 0 : e.autoFreeze) == "boolean" && this.setAutoFreeze(e.autoFreeze), typeof (e == null ? void 0 : e.useStrictShallowCopy) == "boolean" && this.setUseStrictShallowCopy(e.useStrictShallowCopy);
  }
  createDraft(e) {
    Nc(e) || $i(8), Ic(e) && (e = Bhe(e));
    const t = uI(this), n = N1(e, void 0);
    return n[Es].isManual_ = !0, R1(t), n;
  }
  finishDraft(e, t) {
    const n = e && e[Es];
    (!n || !n.isManual_) && $i(9);
    const { scope_: r } = n;
    return lI(r, t), cI(void 0, r);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(e) {
    this.autoFreeze_ = e;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(e) {
    this.useStrictShallowCopy_ = e;
  }
  applyPatches(e, t) {
    let n;
    for (n = t.length - 1; n >= 0; n--) {
      const o = t[n];
      if (o.path.length === 0 && o.op === "replace") {
        e = o.value;
        break;
      }
    }
    n > -1 && (t = t.slice(n + 1));
    const r = Bc("Patches").applyPatches_;
    return Ic(e) ? r(e, t) : this.produce(
      e,
      (o) => r(o, t)
    );
  }
};
function N1(e, t) {
  const n = $0(e) ? Bc("MapSet").proxyMap_(e, t) : V0(e) ? Bc("MapSet").proxySet_(e, t) : Rhe(e, t);
  return (t ? t.scope_ : dX()).drafts_.push(n), n;
}
function Bhe(e) {
  return Ic(e) || $i(10, e), hX(e);
}
function hX(e) {
  if (!Nc(e) || Z0(e))
    return e;
  const t = e[Es];
  let n;
  if (t) {
    if (!t.modified_)
      return t.base_;
    t.finalized_ = !0, n = j1(e, t.scope_.immer_.useStrictShallowCopy_);
  } else
    n = j1(e, !0);
  return nb(n, (r, o) => {
    pX(n, r, hX(o));
  }), t && (t.finalized_ = !1), n;
}
var ks = new Nhe(), KS = ks.produce;
ks.produceWithPatches.bind(
  ks
);
ks.setAutoFreeze.bind(ks);
ks.setUseStrictShallowCopy.bind(ks);
ks.applyPatches.bind(ks);
var dI = ks.createDraft.bind(ks), fI = ks.finishDraft.bind(ks), Ge = {
  ancestors(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = Ge.levels(e, t);
    return n ? r = r.slice(1) : r = r.slice(0, -1), r;
  },
  common(e, t) {
    for (var n = [], r = 0; r < e.length && r < t.length; r++) {
      var o = e[r], i = t[r];
      if (o !== i)
        break;
      n.push(o);
    }
    return n;
  },
  compare(e, t) {
    for (var n = Math.min(e.length, t.length), r = 0; r < n; r++) {
      if (e[r] < t[r]) return -1;
      if (e[r] > t[r]) return 1;
    }
    return 0;
  },
  endsAfter(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return Ge.equals(r, o) && i > a;
  },
  endsAt(e, t) {
    var n = e.length, r = e.slice(0, n), o = t.slice(0, n);
    return Ge.equals(r, o);
  },
  endsBefore(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return Ge.equals(r, o) && i < a;
  },
  equals(e, t) {
    return e.length === t.length && e.every((n, r) => n === t[r]);
  },
  hasPrevious(e) {
    return e[e.length - 1] > 0;
  },
  isAfter(e, t) {
    return Ge.compare(e, t) === 1;
  },
  isAncestor(e, t) {
    return e.length < t.length && Ge.compare(e, t) === 0;
  },
  isBefore(e, t) {
    return Ge.compare(e, t) === -1;
  },
  isChild(e, t) {
    return e.length === t.length + 1 && Ge.compare(e, t) === 0;
  },
  isCommon(e, t) {
    return e.length <= t.length && Ge.compare(e, t) === 0;
  },
  isDescendant(e, t) {
    return e.length > t.length && Ge.compare(e, t) === 0;
  },
  isParent(e, t) {
    return e.length + 1 === t.length && Ge.compare(e, t) === 0;
  },
  isPath(e) {
    return Array.isArray(e) && (e.length === 0 || typeof e[0] == "number");
  },
  isSibling(e, t) {
    if (e.length !== t.length)
      return !1;
    var n = e.slice(0, -1), r = t.slice(0, -1), o = e[e.length - 1], i = t[t.length - 1];
    return o !== i && Ge.equals(n, r);
  },
  levels(e) {
    for (var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = [], o = 0; o <= e.length; o++)
      r.push(e.slice(0, o));
    return n && r.reverse(), r;
  },
  next(e) {
    if (e.length === 0)
      throw new Error("Cannot get the next path of a root path [".concat(e, "], because it has no next index."));
    var t = e[e.length - 1];
    return e.slice(0, -1).concat(t + 1);
  },
  operationCanTransformPath(e) {
    switch (e.type) {
      case "insert_node":
      case "remove_node":
      case "merge_node":
      case "split_node":
      case "move_node":
        return !0;
      default:
        return !1;
    }
  },
  parent(e) {
    if (e.length === 0)
      throw new Error("Cannot get the parent path of the root path [".concat(e, "]."));
    return e.slice(0, -1);
  },
  previous(e) {
    if (e.length === 0)
      throw new Error("Cannot get the previous path of a root path [".concat(e, "], because it has no previous index."));
    var t = e[e.length - 1];
    if (t <= 0)
      throw new Error("Cannot get the previous path of a first child path [".concat(e, "] because it would result in a negative index."));
    return e.slice(0, -1).concat(t - 1);
  },
  relative(e, t) {
    if (!Ge.isAncestor(t, e) && !Ge.equals(e, t))
      throw new Error("Cannot get the relative path of [".concat(e, "] inside ancestor [").concat(t, "], because it is not above or equal to the path."));
    return e.slice(t.length);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!e) return null;
    var r = [...e], {
      affinity: o = "forward"
    } = n;
    if (e.length === 0)
      return r;
    switch (t.type) {
      case "insert_node": {
        var {
          path: i
        } = t;
        (Ge.equals(i, r) || Ge.endsBefore(i, r) || Ge.isAncestor(i, r)) && (r[i.length - 1] += 1);
        break;
      }
      case "remove_node": {
        var {
          path: a
        } = t;
        if (Ge.equals(a, r) || Ge.isAncestor(a, r))
          return null;
        Ge.endsBefore(a, r) && (r[a.length - 1] -= 1);
        break;
      }
      case "merge_node": {
        var {
          path: s,
          position: l
        } = t;
        Ge.equals(s, r) || Ge.endsBefore(s, r) ? r[s.length - 1] -= 1 : Ge.isAncestor(s, r) && (r[s.length - 1] -= 1, r[s.length] += l);
        break;
      }
      case "split_node": {
        var {
          path: u,
          position: c
        } = t;
        if (Ge.equals(u, r)) {
          if (o === "forward")
            r[r.length - 1] += 1;
          else if (o !== "backward") return null;
        } else Ge.endsBefore(u, r) ? r[u.length - 1] += 1 : Ge.isAncestor(u, r) && e[u.length] >= c && (r[u.length - 1] += 1, r[u.length] -= c);
        break;
      }
      case "move_node": {
        var {
          path: p,
          newPath: d
        } = t;
        if (Ge.equals(p, d))
          return r;
        if (Ge.isAncestor(p, r) || Ge.equals(p, r)) {
          var g = d.slice();
          return Ge.endsBefore(p, d) && p.length < d.length && (g[p.length - 1] -= 1), g.concat(r.slice(p.length));
        } else Ge.isSibling(p, d) && (Ge.isAncestor(d, r) || Ge.equals(d, r)) ? Ge.endsBefore(p, r) ? r[p.length - 1] -= 1 : r[p.length - 1] += 1 : Ge.endsBefore(d, r) || Ge.equals(d, r) || Ge.isAncestor(d, r) ? (Ge.endsBefore(p, r) && (r[p.length - 1] -= 1), r[d.length - 1] += 1) : Ge.endsBefore(p, r) && (Ge.equals(d, r) && (r[d.length - 1] += 1), r[p.length - 1] -= 1);
        break;
      }
    }
    return r;
  }
};
function oh(e) {
  "@babel/helpers - typeof";
  return oh = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, oh(e);
}
function Fhe(e, t) {
  if (oh(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (oh(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function zhe(e) {
  var t = Fhe(e, "string");
  return oh(t) === "symbol" ? t : String(t);
}
function jp(e, t, n) {
  return t = zhe(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function hI(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ld(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? hI(Object(n), !0).forEach(function(r) {
      jp(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : hI(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Uhe = (e, t, n) => {
  switch (n.type) {
    case "insert_node": {
      var {
        path: r,
        node: o
      } = n, i = St.parent(e, r), a = r[r.length - 1];
      if (a > i.children.length)
        throw new Error('Cannot apply an "insert_node" operation at path ['.concat(r, "] because the destination is past the end of the node."));
      if (i.children.splice(a, 0, o), t)
        for (var [s, l] of qt.points(t))
          t[l] = Dr.transform(s, n);
      break;
    }
    case "insert_text": {
      var {
        path: u,
        offset: c,
        text: p
      } = n;
      if (p.length === 0) break;
      var d = St.leaf(e, u), g = d.text.slice(0, c), f = d.text.slice(c);
      if (d.text = g + p + f, t)
        for (var [m, b] of qt.points(t))
          t[b] = Dr.transform(m, n);
      break;
    }
    case "merge_node": {
      var {
        path: E
      } = n, w = St.get(e, E), M = Ge.previous(E), x = St.get(e, M), v = St.parent(e, E), C = E[E.length - 1];
      if (Po.isText(w) && Po.isText(x))
        x.text += w.text;
      else if (!Po.isText(w) && !Po.isText(x))
        x.children.push(...w.children);
      else
        throw new Error('Cannot apply a "merge_node" operation at path ['.concat(E, "] to nodes of different interfaces: ").concat(is.stringify(w), " ").concat(is.stringify(x)));
      if (v.children.splice(C, 1), t)
        for (var [P, F] of qt.points(t))
          t[F] = Dr.transform(P, n);
      break;
    }
    case "move_node": {
      var {
        path: L,
        newPath: B
      } = n;
      if (Ge.isAncestor(L, B))
        throw new Error("Cannot move a path [".concat(L, "] to new path [").concat(B, "] because the destination is inside itself."));
      var N = St.get(e, L), $ = St.parent(e, L), V = L[L.length - 1];
      $.children.splice(V, 1);
      var H = Ge.transform(L, n), Z = St.get(e, Ge.parent(H)), K = H[H.length - 1];
      if (Z.children.splice(K, 0, N), t)
        for (var [Y, Q] of qt.points(t))
          t[Q] = Dr.transform(Y, n);
      break;
    }
    case "remove_node": {
      var {
        path: J
      } = n, _ = J[J.length - 1], D = St.parent(e, J);
      if (D.children.splice(_, 1), t)
        for (var [z, S] of qt.points(t)) {
          var W = Dr.transform(z, n);
          if (t != null && W != null)
            t[S] = W;
          else {
            var O = void 0, j = void 0;
            for (var [U, T] of St.texts(e))
              if (Ge.compare(T, J) === -1)
                O = [U, T];
              else {
                j = [U, T];
                break;
              }
            var q = !1;
            O && j && (Ge.equals(j[1], J) ? q = !Ge.hasPrevious(j[1]) : q = Ge.common(O[1], J).length < Ge.common(j[1], J).length), O && !q ? (z.path = O[1], z.offset = O[0].text.length) : j ? (z.path = j[1], z.offset = 0) : t = null;
          }
        }
      break;
    }
    case "remove_text": {
      var {
        path: A,
        offset: X,
        text: I
      } = n;
      if (I.length === 0) break;
      var le = St.leaf(e, A), he = le.text.slice(0, X), oe = le.text.slice(X + I.length);
      if (le.text = he + oe, t)
        for (var [Ae, Ue] of qt.points(t))
          t[Ue] = Dr.transform(Ae, n);
      break;
    }
    case "set_node": {
      var {
        path: He,
        properties: Re,
        newProperties: nt
      } = n;
      if (He.length === 0)
        throw new Error("Cannot set properties on the root node!");
      var Ve = St.get(e, He);
      for (var we in nt) {
        if (we === "children" || we === "text")
          throw new Error('Cannot set the "'.concat(we, '" property of nodes!'));
        var et = nt[we];
        et == null ? delete Ve[we] : Ve[we] = et;
      }
      for (var lt in Re)
        nt.hasOwnProperty(lt) || delete Ve[lt];
      break;
    }
    case "set_selection": {
      var {
        newProperties: ye
      } = n;
      if (ye == null)
        t = ye;
      else {
        if (t == null) {
          if (!qt.isRange(ye))
            throw new Error('Cannot apply an incomplete "set_selection" operation properties '.concat(is.stringify(ye), " when there is no current selection."));
          t = ld({}, ye);
        }
        for (var ke in ye) {
          var Qe = ye[ke];
          if (Qe == null) {
            if (ke === "anchor" || ke === "focus")
              throw new Error('Cannot remove the "'.concat(ke, '" selection property'));
            delete t[ke];
          } else
            t[ke] = Qe;
        }
      }
      break;
    }
    case "split_node": {
      var {
        path: Fe,
        position: Ie,
        properties: ot
      } = n;
      if (Fe.length === 0)
        throw new Error('Cannot apply a "split_node" operation at path ['.concat(Fe, "] because the root node cannot be split."));
      var Ee = St.get(e, Fe), wt = St.parent(e, Fe), it = Fe[Fe.length - 1], st;
      if (Po.isText(Ee)) {
        var ut = Ee.text.slice(0, Ie), Ct = Ee.text.slice(Ie);
        Ee.text = ut, st = ld(ld({}, ot), {}, {
          text: Ct
        });
      } else {
        var ct = Ee.children.slice(0, Ie), pt = Ee.children.slice(Ie);
        Ee.children = ct, st = ld(ld({}, ot), {}, {
          children: pt
        });
      }
      if (wt.children.splice(it + 1, 0, st), t)
        for (var [rt, We] of qt.points(t))
          t[We] = Dr.transform(rt, n);
      break;
    }
  }
  return t;
}, Hhe = {
  transform(e, t) {
    e.children = dI(e.children);
    var n = e.selection && dI(e.selection);
    try {
      n = Uhe(e, n, t);
    } finally {
      e.children = fI(e.children), n ? e.selection = Ic(n) ? fI(n) : n : e.selection = null;
    }
  }
}, Whe = {
  insertNodes(e, t, n) {
    e.insertNodes(t, n);
  },
  liftNodes(e, t) {
    e.liftNodes(t);
  },
  mergeNodes(e, t) {
    e.mergeNodes(t);
  },
  moveNodes(e, t) {
    e.moveNodes(t);
  },
  removeNodes(e, t) {
    e.removeNodes(t);
  },
  setNodes(e, t, n) {
    e.setNodes(t, n);
  },
  splitNodes(e, t) {
    e.splitNodes(t);
  },
  unsetNodes(e, t, n) {
    e.unsetNodes(t, n);
  },
  unwrapNodes(e, t) {
    e.unwrapNodes(t);
  },
  wrapNodes(e, t, n) {
    e.wrapNodes(t, n);
  }
}, $he = {
  collapse(e, t) {
    e.collapse(t);
  },
  deselect(e) {
    e.deselect();
  },
  move(e, t) {
    e.move(t);
  },
  select(e, t) {
    e.select(t);
  },
  setPoint(e, t, n) {
    e.setPoint(t, n);
  },
  setSelection(e, t) {
    e.setSelection(t);
  }
}, gX = (e, t) => {
  for (var n in e) {
    var r = e[n], o = t[n];
    if (fi(r) && fi(o)) {
      if (!gX(r, o)) return !1;
    } else if (Array.isArray(r) && Array.isArray(o)) {
      if (r.length !== o.length) return !1;
      for (var i = 0; i < r.length; i++)
        if (r[i] !== o[i]) return !1;
    } else if (r !== o)
      return !1;
  }
  for (var a in t)
    if (e[a] === void 0 && t[a] !== void 0)
      return !1;
  return !0;
};
function Vhe(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), o, i;
  for (i = 0; i < r.length; i++)
    o = r[i], !(t.indexOf(o) >= 0) && (n[o] = e[o]);
  return n;
}
function ih(e, t) {
  if (e == null) return {};
  var n = Vhe(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (o = 0; o < i.length; o++)
      r = i[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
var Zhe = ["anchor", "focus"];
function gI(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function qhe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? gI(Object(n), !0).forEach(function(r) {
      jp(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : gI(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var qt = {
  edges(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, {
      anchor: r,
      focus: o
    } = e;
    return qt.isBackward(e) === n ? [r, o] : [o, r];
  },
  end(e) {
    var [, t] = qt.edges(e);
    return t;
  },
  equals(e, t) {
    return Dr.equals(e.anchor, t.anchor) && Dr.equals(e.focus, t.focus);
  },
  includes(e, t) {
    if (qt.isRange(t)) {
      if (qt.includes(e, t.anchor) || qt.includes(e, t.focus))
        return !0;
      var [n, r] = qt.edges(e), [o, i] = qt.edges(t);
      return Dr.isBefore(n, o) && Dr.isAfter(r, i);
    }
    var [a, s] = qt.edges(e), l = !1, u = !1;
    return Dr.isPoint(t) ? (l = Dr.compare(t, a) >= 0, u = Dr.compare(t, s) <= 0) : (l = Ge.compare(t, a.path) >= 0, u = Ge.compare(t, s.path) <= 0), l && u;
  },
  intersection(e, t) {
    var n = ih(e, Zhe), [r, o] = qt.edges(e), [i, a] = qt.edges(t), s = Dr.isBefore(r, i) ? i : r, l = Dr.isBefore(o, a) ? o : a;
    return Dr.isBefore(l, s) ? null : qhe({
      anchor: s,
      focus: l
    }, n);
  },
  isBackward(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return Dr.isAfter(t, n);
  },
  isCollapsed(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return Dr.equals(t, n);
  },
  isExpanded(e) {
    return !qt.isCollapsed(e);
  },
  isForward(e) {
    return !qt.isBackward(e);
  },
  isRange(e) {
    return fi(e) && Dr.isPoint(e.anchor) && Dr.isPoint(e.focus);
  },
  *points(e) {
    yield [e.anchor, "anchor"], yield [e.focus, "focus"];
  },
  start(e) {
    var [t] = qt.edges(e);
    return t;
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return KS(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "inward"
      } = n, i, a;
      if (o === "inward") {
        var s = qt.isCollapsed(r);
        qt.isForward(r) ? (i = "forward", a = s ? i : "backward") : (i = "backward", a = s ? i : "forward");
      } else o === "outward" ? qt.isForward(r) ? (i = "backward", a = "forward") : (i = "forward", a = "backward") : (i = o, a = o);
      var l = Dr.transform(r.anchor, t, {
        affinity: i
      }), u = Dr.transform(r.focus, t, {
        affinity: a
      });
      if (!l || !u)
        return null;
      r.anchor = l, r.focus = u;
    });
  }
}, mI = (e) => fi(e) && St.isNodeList(e.children) && !lr.isEditor(e), Wa = {
  isAncestor(e) {
    return fi(e) && St.isNodeList(e.children);
  },
  isElement: mI,
  isElementList(e) {
    return Array.isArray(e) && e.every((t) => Wa.isElement(t));
  },
  isElementProps(e) {
    return e.children !== void 0;
  },
  isElementType: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "type";
    return mI(e) && e[n] === t;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "children" && e[n] !== t[n])
        return !1;
    return !0;
  }
}, Ghe = ["children"], Khe = ["text"], vI = /* @__PURE__ */ new WeakMap(), St = {
  ancestor(e, t) {
    var n = St.get(e, t);
    if (Po.isText(n))
      throw new Error("Cannot get the ancestor node at path [".concat(t, "] because it refers to a text node instead: ").concat(is.stringify(n)));
    return n;
  },
  ancestors(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of Ge.ancestors(t, n)) {
        var o = St.ancestor(e, r), i = [o, r];
        yield i;
      }
    }();
  },
  child(e, t) {
    if (Po.isText(e))
      throw new Error("Cannot get the child of a text node: ".concat(is.stringify(e)));
    var n = e.children[t];
    if (n == null)
      throw new Error("Cannot get child at index `".concat(t, "` in node: ").concat(is.stringify(e)));
    return n;
  },
  children(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var {
        reverse: r = !1
      } = n, o = St.ancestor(e, t), {
        children: i
      } = o, a = r ? i.length - 1 : 0; r ? a >= 0 : a < i.length; ) {
        var s = St.child(o, a), l = t.concat(a);
        yield [s, l], a = r ? a - 1 : a + 1;
      }
    }();
  },
  common(e, t, n) {
    var r = Ge.common(t, n), o = St.get(e, r);
    return [o, r];
  },
  descendant(e, t) {
    var n = St.get(e, t);
    if (lr.isEditor(n))
      throw new Error("Cannot get the descendant node at path [".concat(t, "] because it refers to the root editor node instead: ").concat(is.stringify(n)));
    return n;
  },
  descendants(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of St.nodes(e, t))
        r.length !== 0 && (yield [n, r]);
    }();
  },
  elements(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of St.nodes(e, t))
        Wa.isElement(n) && (yield [n, r]);
    }();
  },
  extractProps(e) {
    if (Wa.isAncestor(e)) {
      var t = ih(e, Ghe);
      return t;
    } else {
      var t = ih(e, Khe);
      return t;
    }
  },
  first(e, t) {
    for (var n = t.slice(), r = St.get(e, n); r && !(Po.isText(r) || r.children.length === 0); )
      r = r.children[0], n.push(0);
    return [r, n];
  },
  fragment(e, t) {
    if (Po.isText(e))
      throw new Error("Cannot get a fragment starting from a root text node: ".concat(is.stringify(e)));
    var n = KS({
      children: e.children
    }, (r) => {
      var [o, i] = qt.edges(t), a = St.nodes(r, {
        reverse: !0,
        pass: (d) => {
          var [, g] = d;
          return !qt.includes(t, g);
        }
      });
      for (var [, s] of a) {
        if (!qt.includes(t, s)) {
          var l = St.parent(r, s), u = s[s.length - 1];
          l.children.splice(u, 1);
        }
        if (Ge.equals(s, i.path)) {
          var c = St.leaf(r, s);
          c.text = c.text.slice(0, i.offset);
        }
        if (Ge.equals(s, o.path)) {
          var p = St.leaf(r, s);
          p.text = p.text.slice(o.offset);
        }
      }
      lr.isEditor(r) && (r.selection = null);
    });
    return n.children;
  },
  get(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (Po.isText(n) || !n.children[o])
        throw new Error("Cannot find a descendant at path [".concat(t, "] in node: ").concat(is.stringify(e)));
      n = n.children[o];
    }
    return n;
  },
  has(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (Po.isText(n) || !n.children[o])
        return !1;
      n = n.children[o];
    }
    return !0;
  },
  isNode(e) {
    return Po.isText(e) || Wa.isElement(e) || lr.isEditor(e);
  },
  isNodeList(e) {
    if (!Array.isArray(e))
      return !1;
    var t = vI.get(e);
    if (t !== void 0)
      return t;
    var n = e.every((r) => St.isNode(r));
    return vI.set(e, n), n;
  },
  last(e, t) {
    for (var n = t.slice(), r = St.get(e, n); r && !(Po.isText(r) || r.children.length === 0); ) {
      var o = r.children.length - 1;
      r = r.children[o], n.push(o);
    }
    return [r, n];
  },
  leaf(e, t) {
    var n = St.get(e, t);
    if (!Po.isText(n))
      throw new Error("Cannot get the leaf node at path [".concat(t, "] because it refers to a non-leaf node: ").concat(is.stringify(n)));
    return n;
  },
  levels(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of Ge.levels(t, n)) {
        var o = St.get(e, r);
        yield [o, r];
      }
    }();
  },
  matches(e, t) {
    return Wa.isElement(e) && Wa.isElementProps(t) && Wa.matches(e, t) || Po.isText(e) && Po.isTextProps(t) && Po.matches(e, t);
  },
  nodes(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var {
        pass: n,
        reverse: r = !1
      } = t, {
        from: o = [],
        to: i
      } = t, a = /* @__PURE__ */ new Set(), s = [], l = e; !(i && (r ? Ge.isBefore(s, i) : Ge.isAfter(s, i))); ) {
        if (a.has(l) || (yield [l, s]), !a.has(l) && !Po.isText(l) && l.children.length !== 0 && (n == null || n([l, s]) === !1)) {
          a.add(l);
          var u = r ? l.children.length - 1 : 0;
          Ge.isAncestor(s, o) && (u = o[s.length]), s = s.concat(u), l = St.get(e, s);
          continue;
        }
        if (s.length === 0)
          break;
        if (!r) {
          var c = Ge.next(s);
          if (St.has(e, c)) {
            s = c, l = St.get(e, s);
            continue;
          }
        }
        if (r && s[s.length - 1] !== 0) {
          var p = Ge.previous(s);
          s = p, l = St.get(e, s);
          continue;
        }
        s = Ge.parent(s), l = St.get(e, s), a.add(l);
      }
    }();
  },
  parent(e, t) {
    var n = Ge.parent(t), r = St.get(e, n);
    if (Po.isText(r))
      throw new Error("Cannot get the parent of path [".concat(t, "] because it does not exist in the root."));
    return r;
  },
  string(e) {
    return Po.isText(e) ? e.text : e.children.map(St.string).join("");
  },
  texts(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of St.nodes(e, t))
        Po.isText(n) && (yield [n, r]);
    }();
  }
};
function yI(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Fr(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? yI(Object(n), !0).forEach(function(r) {
      jp(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : yI(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Gd = {
  isNodeOperation(e) {
    return Gd.isOperation(e) && e.type.endsWith("_node");
  },
  isOperation(e) {
    if (!fi(e))
      return !1;
    switch (e.type) {
      case "insert_node":
        return Ge.isPath(e.path) && St.isNode(e.node);
      case "insert_text":
        return typeof e.offset == "number" && typeof e.text == "string" && Ge.isPath(e.path);
      case "merge_node":
        return typeof e.position == "number" && Ge.isPath(e.path) && fi(e.properties);
      case "move_node":
        return Ge.isPath(e.path) && Ge.isPath(e.newPath);
      case "remove_node":
        return Ge.isPath(e.path) && St.isNode(e.node);
      case "remove_text":
        return typeof e.offset == "number" && typeof e.text == "string" && Ge.isPath(e.path);
      case "set_node":
        return Ge.isPath(e.path) && fi(e.properties) && fi(e.newProperties);
      case "set_selection":
        return e.properties === null && qt.isRange(e.newProperties) || e.newProperties === null && qt.isRange(e.properties) || fi(e.properties) && fi(e.newProperties);
      case "split_node":
        return Ge.isPath(e.path) && typeof e.position == "number" && fi(e.properties);
      default:
        return !1;
    }
  },
  isOperationList(e) {
    return Array.isArray(e) && e.every((t) => Gd.isOperation(t));
  },
  isSelectionOperation(e) {
    return Gd.isOperation(e) && e.type.endsWith("_selection");
  },
  isTextOperation(e) {
    return Gd.isOperation(e) && e.type.endsWith("_text");
  },
  inverse(e) {
    switch (e.type) {
      case "insert_node":
        return Fr(Fr({}, e), {}, {
          type: "remove_node"
        });
      case "insert_text":
        return Fr(Fr({}, e), {}, {
          type: "remove_text"
        });
      case "merge_node":
        return Fr(Fr({}, e), {}, {
          type: "split_node",
          path: Ge.previous(e.path)
        });
      case "move_node": {
        var {
          newPath: t,
          path: n
        } = e;
        if (Ge.equals(t, n))
          return e;
        if (Ge.isSibling(n, t))
          return Fr(Fr({}, e), {}, {
            path: t,
            newPath: n
          });
        var r = Ge.transform(n, e), o = Ge.transform(Ge.next(n), e);
        return Fr(Fr({}, e), {}, {
          path: r,
          newPath: o
        });
      }
      case "remove_node":
        return Fr(Fr({}, e), {}, {
          type: "insert_node"
        });
      case "remove_text":
        return Fr(Fr({}, e), {}, {
          type: "insert_text"
        });
      case "set_node": {
        var {
          properties: i,
          newProperties: a
        } = e;
        return Fr(Fr({}, e), {}, {
          properties: a,
          newProperties: i
        });
      }
      case "set_selection": {
        var {
          properties: s,
          newProperties: l
        } = e;
        return s == null ? Fr(Fr({}, e), {}, {
          properties: l,
          newProperties: null
        }) : l == null ? Fr(Fr({}, e), {}, {
          properties: null,
          newProperties: s
        }) : Fr(Fr({}, e), {}, {
          properties: l,
          newProperties: s
        });
      }
      case "split_node":
        return Fr(Fr({}, e), {}, {
          type: "merge_node",
          path: Ge.next(e.path)
        });
    }
  }
}, bI = /* @__PURE__ */ new WeakMap(), Xhe = (e) => {
  var t = bI.get(e);
  if (t !== void 0)
    return t;
  if (!fi(e))
    return !1;
  var n = typeof e.addMark == "function" && typeof e.apply == "function" && typeof e.deleteFragment == "function" && typeof e.insertBreak == "function" && typeof e.insertSoftBreak == "function" && typeof e.insertFragment == "function" && typeof e.insertNode == "function" && typeof e.insertText == "function" && typeof e.isElementReadOnly == "function" && typeof e.isInline == "function" && typeof e.isSelectable == "function" && typeof e.isVoid == "function" && typeof e.normalizeNode == "function" && typeof e.onChange == "function" && typeof e.removeMark == "function" && typeof e.getDirtyPaths == "function" && (e.marks === null || fi(e.marks)) && (e.selection === null || qt.isRange(e.selection)) && St.isNodeList(e.children) && Gd.isOperationList(e.operations);
  return bI.set(e, n), n;
}, lr = {
  above(e, t) {
    return e.above(t);
  },
  addMark(e, t, n) {
    e.addMark(t, n);
  },
  after(e, t, n) {
    return e.after(t, n);
  },
  before(e, t, n) {
    return e.before(t, n);
  },
  deleteBackward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteBackward(n);
  },
  deleteForward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteForward(n);
  },
  deleteFragment(e, t) {
    e.deleteFragment(t);
  },
  edges(e, t) {
    return e.edges(t);
  },
  elementReadOnly(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return e.elementReadOnly(t);
  },
  end(e, t) {
    return e.end(t);
  },
  first(e, t) {
    return e.first(t);
  },
  fragment(e, t) {
    return e.fragment(t);
  },
  hasBlocks(e, t) {
    return e.hasBlocks(t);
  },
  hasInlines(e, t) {
    return e.hasInlines(t);
  },
  hasPath(e, t) {
    return e.hasPath(t);
  },
  hasTexts(e, t) {
    return e.hasTexts(t);
  },
  insertBreak(e) {
    e.insertBreak();
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertNode(e, t) {
    e.insertNode(t);
  },
  insertSoftBreak(e) {
    e.insertSoftBreak();
  },
  insertText(e, t) {
    e.insertText(t);
  },
  isBlock(e, t) {
    return e.isBlock(t);
  },
  isEdge(e, t, n) {
    return e.isEdge(t, n);
  },
  isEditor(e) {
    return Xhe(e);
  },
  isElementReadOnly(e, t) {
    return e.isElementReadOnly(t);
  },
  isEmpty(e, t) {
    return e.isEmpty(t);
  },
  isEnd(e, t, n) {
    return e.isEnd(t, n);
  },
  isInline(e, t) {
    return e.isInline(t);
  },
  isNormalizing(e) {
    return e.isNormalizing();
  },
  isSelectable(e, t) {
    return e.isSelectable(t);
  },
  isStart(e, t, n) {
    return e.isStart(t, n);
  },
  isVoid(e, t) {
    return e.isVoid(t);
  },
  last(e, t) {
    return e.last(t);
  },
  leaf(e, t, n) {
    return e.leaf(t, n);
  },
  levels(e, t) {
    return e.levels(t);
  },
  marks(e) {
    return e.getMarks();
  },
  next(e, t) {
    return e.next(t);
  },
  node(e, t, n) {
    return e.node(t, n);
  },
  nodes(e, t) {
    return e.nodes(t);
  },
  normalize(e, t) {
    e.normalize(t);
  },
  parent(e, t, n) {
    return e.parent(t, n);
  },
  path(e, t, n) {
    return e.path(t, n);
  },
  pathRef(e, t, n) {
    return e.pathRef(t, n);
  },
  pathRefs(e) {
    return e.pathRefs();
  },
  point(e, t, n) {
    return e.point(t, n);
  },
  pointRef(e, t, n) {
    return e.pointRef(t, n);
  },
  pointRefs(e) {
    return e.pointRefs();
  },
  positions(e, t) {
    return e.positions(t);
  },
  previous(e, t) {
    return e.previous(t);
  },
  range(e, t, n) {
    return e.range(t, n);
  },
  rangeRef(e, t, n) {
    return e.rangeRef(t, n);
  },
  rangeRefs(e) {
    return e.rangeRefs();
  },
  removeMark(e, t) {
    e.removeMark(t);
  },
  setNormalizing(e, t) {
    e.setNormalizing(t);
  },
  start(e, t) {
    return e.start(t);
  },
  string(e, t, n) {
    return e.string(t, n);
  },
  unhangRange(e, t, n) {
    return e.unhangRange(t, n);
  },
  void(e, t) {
    return e.void(t);
  },
  withoutNormalizing(e, t) {
    e.withoutNormalizing(t);
  },
  shouldMergeNodesRemovePrevNode: (e, t, n) => e.shouldMergeNodesRemovePrevNode(t, n)
};
function wI(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function CI(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? wI(Object(n), !0).forEach(function(r) {
      jp(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : wI(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Dr = {
  compare(e, t) {
    var n = Ge.compare(e.path, t.path);
    return n === 0 ? e.offset < t.offset ? -1 : e.offset > t.offset ? 1 : 0 : n;
  },
  isAfter(e, t) {
    return Dr.compare(e, t) === 1;
  },
  isBefore(e, t) {
    return Dr.compare(e, t) === -1;
  },
  equals(e, t) {
    return e.offset === t.offset && Ge.equals(e.path, t.path);
  },
  isPoint(e) {
    return fi(e) && typeof e.offset == "number" && Ge.isPath(e.path);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return KS(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "forward"
      } = n, {
        path: i,
        offset: a
      } = r;
      switch (t.type) {
        case "insert_node":
        case "move_node": {
          r.path = Ge.transform(i, t, n);
          break;
        }
        case "insert_text": {
          Ge.equals(t.path, i) && (t.offset < a || t.offset === a && o === "forward") && (r.offset += t.text.length);
          break;
        }
        case "merge_node": {
          Ge.equals(t.path, i) && (r.offset += t.position), r.path = Ge.transform(i, t, n);
          break;
        }
        case "remove_text": {
          Ge.equals(t.path, i) && t.offset <= a && (r.offset -= Math.min(a - t.offset, t.text.length));
          break;
        }
        case "remove_node": {
          if (Ge.equals(t.path, i) || Ge.isAncestor(t.path, i))
            return null;
          r.path = Ge.transform(i, t, n);
          break;
        }
        case "split_node": {
          if (Ge.equals(t.path, i)) {
            if (t.position === a && o == null)
              return null;
            (t.position < a || t.position === a && o === "forward") && (r.offset -= t.position, r.path = Ge.transform(i, t, CI(CI({}, n), {}, {
              affinity: "forward"
            })));
          } else
            r.path = Ge.transform(i, t, n);
          break;
        }
      }
    });
  }
}, OI = void 0, is = {
  setScrubber(e) {
    OI = e;
  },
  stringify(e) {
    return JSON.stringify(e, OI);
  }
}, Yhe = ["text"], Jhe = ["anchor", "focus"];
function xI(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Pa(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? xI(Object(n), !0).forEach(function(r) {
      jp(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : xI(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Po = {
  equals(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      loose: r = !1
    } = n;
    function o(i) {
      var a = ih(i, Yhe);
      return a;
    }
    return gX(r ? o(e) : e, r ? o(t) : t);
  },
  isText(e) {
    return fi(e) && typeof e.text == "string";
  },
  isTextList(e) {
    return Array.isArray(e) && e.every((t) => Po.isText(t));
  },
  isTextProps(e) {
    return e.text !== void 0;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "text" && (!e.hasOwnProperty(n) || e[n] !== t[n]))
        return !1;
    return !0;
  },
  decorations(e, t) {
    var n = [Pa({}, e)];
    for (var r of t) {
      var o = ih(r, Jhe), [i, a] = qt.edges(r), s = [], l = 0, u = i.offset, c = a.offset;
      for (var p of n) {
        var {
          length: d
        } = p.text, g = l;
        if (l += d, u <= g && l <= c) {
          Object.assign(p, o), s.push(p);
          continue;
        }
        if (u !== c && (u === l || c === g) || u > l || c < g || c === g && g !== 0) {
          s.push(p);
          continue;
        }
        var f = p, m = void 0, b = void 0;
        if (c < l) {
          var E = c - g;
          b = Pa(Pa({}, f), {}, {
            text: f.text.slice(E)
          }), f = Pa(Pa({}, f), {}, {
            text: f.text.slice(0, E)
          });
        }
        if (u > g) {
          var w = u - g;
          m = Pa(Pa({}, f), {}, {
            text: f.text.slice(0, w)
          }), f = Pa(Pa({}, f), {}, {
            text: f.text.slice(w)
          });
        }
        Object.assign(f, o), m && s.push(m), s.push(f), b && s.push(b);
      }
      n = s;
    }
    return n;
  }
}, Qhe = (e) => e.selection ? e.selection : e.children.length > 0 ? lr.end(e, []) : [0], Er;
(function(e) {
  e[e.None = 0] = "None", e[e.Extend = 1] = "Extend", e[e.ZWJ = 2] = "ZWJ", e[e.RI = 4] = "RI", e[e.Prepend = 8] = "Prepend", e[e.SpacingMark = 16] = "SpacingMark", e[e.L = 32] = "L", e[e.V = 64] = "V", e[e.T = 128] = "T", e[e.LV = 256] = "LV", e[e.LVT = 512] = "LVT", e[e.ExtPict = 1024] = "ExtPict", e[e.Any = 2048] = "Any";
})(Er || (Er = {}));
Er.L, Er.L | Er.V | Er.LV | Er.LVT, Er.LV | Er.V, Er.V | Er.T, Er.LVT | Er.T, Er.T, Er.Any, Er.Extend | Er.ZWJ, Er.Any, Er.SpacingMark, Er.Prepend, Er.Any, Er.ZWJ, Er.ExtPict, Er.RI, Er.RI;
var ege = {
  delete(e, t) {
    e.delete(t);
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertText(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    lr.withoutNormalizing(e, () => {
      var {
        voids: r = !1
      } = n, {
        at: o = Qhe(e)
      } = n;
      if (Ge.isPath(o) && (o = lr.range(e, o)), qt.isRange(o))
        if (qt.isCollapsed(o))
          o = o.anchor;
        else {
          var i = qt.end(o);
          if (!r && lr.void(e, {
            at: i
          }))
            return;
          var a = qt.start(o), s = lr.pointRef(e, a), l = lr.pointRef(e, i);
          ib.delete(e, {
            at: o,
            voids: r
          });
          var u = s.unref(), c = l.unref();
          o = u || c, ib.setSelection(e, {
            anchor: o,
            focus: o
          });
        }
      if (!(!r && lr.void(e, {
        at: o
      }) || lr.elementReadOnly(e, {
        at: o
      }))) {
        var {
          path: p,
          offset: d
        } = o;
        t.length > 0 && e.apply({
          type: "insert_text",
          path: p,
          offset: d,
          text: t
        });
      }
    });
  }
};
function EI(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function gm(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? EI(Object(n), !0).forEach(function(r) {
      jp(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : EI(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var ib = gm(gm(gm(gm({}, Hhe), Whe), $he), ege), mX = {}, XS = {}, YS = {}, ep = {}, JS = {}, QS = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Doctype = e.CDATA = e.Tag = e.Style = e.Script = e.Comment = e.Directive = e.Text = e.Root = e.isTag = e.ElementType = void 0;
  var t;
  (function(r) {
    r.Root = "root", r.Text = "text", r.Directive = "directive", r.Comment = "comment", r.Script = "script", r.Style = "style", r.Tag = "tag", r.CDATA = "cdata", r.Doctype = "doctype";
  })(t = e.ElementType || (e.ElementType = {}));
  function n(r) {
    return r.type === t.Tag || r.type === t.Script || r.type === t.Style;
  }
  e.isTag = n, e.Root = t.Root, e.Text = t.Text, e.Directive = t.Directive, e.Comment = t.Comment, e.Script = t.Script, e.Style = t.Style, e.Tag = t.Tag, e.CDATA = t.CDATA, e.Doctype = t.Doctype;
})(QS);
var nn = {}, hu = mr && mr.__extends || /* @__PURE__ */ function() {
  var e = function(t, n) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, o) {
      r.__proto__ = o;
    } || function(r, o) {
      for (var i in o) Object.prototype.hasOwnProperty.call(o, i) && (r[i] = o[i]);
    }, e(t, n);
  };
  return function(t, n) {
    if (typeof n != "function" && n !== null)
      throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
    e(t, n);
    function r() {
      this.constructor = t;
    }
    t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
  };
}(), df = mr && mr.__assign || function() {
  return df = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) {
      t = arguments[n];
      for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
    }
    return e;
  }, df.apply(this, arguments);
};
Object.defineProperty(nn, "__esModule", { value: !0 });
nn.cloneNode = nn.hasChildren = nn.isDocument = nn.isDirective = nn.isComment = nn.isText = nn.isCDATA = nn.isTag = nn.Element = nn.Document = nn.CDATA = nn.NodeWithChildren = nn.ProcessingInstruction = nn.Comment = nn.Text = nn.DataNode = nn.Node = void 0;
var Ji = QS, eM = (
  /** @class */
  function() {
    function e() {
      this.parent = null, this.prev = null, this.next = null, this.startIndex = null, this.endIndex = null;
    }
    return Object.defineProperty(e.prototype, "parentNode", {
      // Read-write aliases for properties
      /**
       * Same as {@link parent}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.parent;
      },
      set: function(t) {
        this.parent = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "previousSibling", {
      /**
       * Same as {@link prev}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.prev;
      },
      set: function(t) {
        this.prev = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "nextSibling", {
      /**
       * Same as {@link next}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.next;
      },
      set: function(t) {
        this.next = t;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.cloneNode = function(t) {
      return t === void 0 && (t = !1), tM(this, t);
    }, e;
  }()
);
nn.Node = eM;
var q0 = (
  /** @class */
  function(e) {
    hu(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.data = n, r;
    }
    return Object.defineProperty(t.prototype, "nodeValue", {
      /**
       * Same as {@link data}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.data;
      },
      set: function(n) {
        this.data = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(eM)
);
nn.DataNode = q0;
var vX = (
  /** @class */
  function(e) {
    hu(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Ji.ElementType.Text, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 3;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(q0)
);
nn.Text = vX;
var yX = (
  /** @class */
  function(e) {
    hu(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Ji.ElementType.Comment, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 8;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(q0)
);
nn.Comment = yX;
var bX = (
  /** @class */
  function(e) {
    hu(t, e);
    function t(n, r) {
      var o = e.call(this, r) || this;
      return o.name = n, o.type = Ji.ElementType.Directive, o;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(q0)
);
nn.ProcessingInstruction = bX;
var G0 = (
  /** @class */
  function(e) {
    hu(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.children = n, r;
    }
    return Object.defineProperty(t.prototype, "firstChild", {
      // Aliases
      /** First child of the node. */
      get: function() {
        var n;
        return (n = this.children[0]) !== null && n !== void 0 ? n : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "lastChild", {
      /** Last child of the node. */
      get: function() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "childNodes", {
      /**
       * Same as {@link children}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.children;
      },
      set: function(n) {
        this.children = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(eM)
);
nn.NodeWithChildren = G0;
var wX = (
  /** @class */
  function(e) {
    hu(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Ji.ElementType.CDATA, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 4;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(G0)
);
nn.CDATA = wX;
var CX = (
  /** @class */
  function(e) {
    hu(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Ji.ElementType.Root, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 9;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(G0)
);
nn.Document = CX;
var OX = (
  /** @class */
  function(e) {
    hu(t, e);
    function t(n, r, o, i) {
      o === void 0 && (o = []), i === void 0 && (i = n === "script" ? Ji.ElementType.Script : n === "style" ? Ji.ElementType.Style : Ji.ElementType.Tag);
      var a = e.call(this, o) || this;
      return a.name = n, a.attribs = r, a.type = i, a;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "tagName", {
      // DOM Level 1 aliases
      /**
       * Same as {@link name}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.name;
      },
      set: function(n) {
        this.name = n;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "attributes", {
      get: function() {
        var n = this;
        return Object.keys(this.attribs).map(function(r) {
          var o, i;
          return {
            name: r,
            value: n.attribs[r],
            namespace: (o = n["x-attribsNamespace"]) === null || o === void 0 ? void 0 : o[r],
            prefix: (i = n["x-attribsPrefix"]) === null || i === void 0 ? void 0 : i[r]
          };
        });
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(G0)
);
nn.Element = OX;
function xX(e) {
  return (0, Ji.isTag)(e);
}
nn.isTag = xX;
function EX(e) {
  return e.type === Ji.ElementType.CDATA;
}
nn.isCDATA = EX;
function kX(e) {
  return e.type === Ji.ElementType.Text;
}
nn.isText = kX;
function LX(e) {
  return e.type === Ji.ElementType.Comment;
}
nn.isComment = LX;
function _X(e) {
  return e.type === Ji.ElementType.Directive;
}
nn.isDirective = _X;
function PX(e) {
  return e.type === Ji.ElementType.Root;
}
nn.isDocument = PX;
function tge(e) {
  return Object.prototype.hasOwnProperty.call(e, "children");
}
nn.hasChildren = tge;
function tM(e, t) {
  t === void 0 && (t = !1);
  var n;
  if (kX(e))
    n = new vX(e.data);
  else if (LX(e))
    n = new yX(e.data);
  else if (xX(e)) {
    var r = t ? kx(e.children) : [], o = new OX(e.name, df({}, e.attribs), r);
    r.forEach(function(l) {
      return l.parent = o;
    }), e.namespace != null && (o.namespace = e.namespace), e["x-attribsNamespace"] && (o["x-attribsNamespace"] = df({}, e["x-attribsNamespace"])), e["x-attribsPrefix"] && (o["x-attribsPrefix"] = df({}, e["x-attribsPrefix"])), n = o;
  } else if (EX(e)) {
    var r = t ? kx(e.children) : [], i = new wX(r);
    r.forEach(function(u) {
      return u.parent = i;
    }), n = i;
  } else if (PX(e)) {
    var r = t ? kx(e.children) : [], a = new CX(r);
    r.forEach(function(u) {
      return u.parent = a;
    }), e["x-mode"] && (a["x-mode"] = e["x-mode"]), n = a;
  } else if (_X(e)) {
    var s = new bX(e.name, e.data);
    e["x-name"] != null && (s["x-name"] = e["x-name"], s["x-publicId"] = e["x-publicId"], s["x-systemId"] = e["x-systemId"]), n = s;
  } else
    throw new Error("Not implemented yet: ".concat(e.type));
  return n.startIndex = e.startIndex, n.endIndex = e.endIndex, e.sourceCodeLocation != null && (n.sourceCodeLocation = e.sourceCodeLocation), n;
}
nn.cloneNode = tM;
function kx(e) {
  for (var t = e.map(function(r) {
    return tM(r, !0);
  }), n = 1; n < t.length; n++)
    t[n].prev = t[n - 1], t[n - 1].next = t[n];
  return t;
}
(function(e) {
  var t = mr && mr.__createBinding || (Object.create ? function(s, l, u, c) {
    c === void 0 && (c = u);
    var p = Object.getOwnPropertyDescriptor(l, u);
    (!p || ("get" in p ? !l.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
      return l[u];
    } }), Object.defineProperty(s, c, p);
  } : function(s, l, u, c) {
    c === void 0 && (c = u), s[c] = l[u];
  }), n = mr && mr.__exportStar || function(s, l) {
    for (var u in s) u !== "default" && !Object.prototype.hasOwnProperty.call(l, u) && t(l, s, u);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.DomHandler = void 0;
  var r = QS, o = nn;
  n(nn, e);
  var i = {
    withStartIndices: !1,
    withEndIndices: !1,
    xmlMode: !1
  }, a = (
    /** @class */
    function() {
      function s(l, u, c) {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null, typeof u == "function" && (c = u, u = i), typeof l == "object" && (u = l, l = void 0), this.callback = l ?? null, this.options = u ?? i, this.elementCB = c ?? null;
      }
      return s.prototype.onparserinit = function(l) {
        this.parser = l;
      }, s.prototype.onreset = function() {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null;
      }, s.prototype.onend = function() {
        this.done || (this.done = !0, this.parser = null, this.handleCallback(null));
      }, s.prototype.onerror = function(l) {
        this.handleCallback(l);
      }, s.prototype.onclosetag = function() {
        this.lastNode = null;
        var l = this.tagStack.pop();
        this.options.withEndIndices && (l.endIndex = this.parser.endIndex), this.elementCB && this.elementCB(l);
      }, s.prototype.onopentag = function(l, u) {
        var c = this.options.xmlMode ? r.ElementType.Tag : void 0, p = new o.Element(l, u, void 0, c);
        this.addNode(p), this.tagStack.push(p);
      }, s.prototype.ontext = function(l) {
        var u = this.lastNode;
        if (u && u.type === r.ElementType.Text)
          u.data += l, this.options.withEndIndices && (u.endIndex = this.parser.endIndex);
        else {
          var c = new o.Text(l);
          this.addNode(c), this.lastNode = c;
        }
      }, s.prototype.oncomment = function(l) {
        if (this.lastNode && this.lastNode.type === r.ElementType.Comment) {
          this.lastNode.data += l;
          return;
        }
        var u = new o.Comment(l);
        this.addNode(u), this.lastNode = u;
      }, s.prototype.oncommentend = function() {
        this.lastNode = null;
      }, s.prototype.oncdatastart = function() {
        var l = new o.Text(""), u = new o.CDATA([l]);
        this.addNode(u), l.parent = u, this.lastNode = l;
      }, s.prototype.oncdataend = function() {
        this.lastNode = null;
      }, s.prototype.onprocessinginstruction = function(l, u) {
        var c = new o.ProcessingInstruction(l, u);
        this.addNode(c);
      }, s.prototype.handleCallback = function(l) {
        if (typeof this.callback == "function")
          this.callback(l, this.dom);
        else if (l)
          throw l;
      }, s.prototype.addNode = function(l) {
        var u = this.tagStack[this.tagStack.length - 1], c = u.children[u.children.length - 1];
        this.options.withStartIndices && (l.startIndex = this.parser.startIndex), this.options.withEndIndices && (l.endIndex = this.parser.endIndex), u.children.push(l), c && (l.prev = c, c.next = l), l.parent = u, this.lastNode = null;
      }, s;
    }()
  );
  e.DomHandler = a, e.default = a;
})(JS);
var SX = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CARRIAGE_RETURN_PLACEHOLDER_REGEX = e.CARRIAGE_RETURN_PLACEHOLDER = e.CARRIAGE_RETURN_REGEX = e.CARRIAGE_RETURN = e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES = void 0, e.CASE_SENSITIVE_TAG_NAMES = [
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "linearGradient",
    "radialGradient",
    "textPath"
  ], e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES.reduce(function(t, n) {
    return t[n.toLowerCase()] = n, t;
  }, {}), e.CARRIAGE_RETURN = "\r", e.CARRIAGE_RETURN_REGEX = new RegExp(e.CARRIAGE_RETURN, "g"), e.CARRIAGE_RETURN_PLACEHOLDER = "__HTML_DOM_PARSER_CARRIAGE_RETURN_PLACEHOLDER_".concat(Date.now(), "__"), e.CARRIAGE_RETURN_PLACEHOLDER_REGEX = new RegExp(e.CARRIAGE_RETURN_PLACEHOLDER, "g");
})(SX);
Object.defineProperty(ep, "__esModule", { value: !0 });
ep.formatAttributes = MX;
ep.escapeSpecialCharacters = oge;
ep.revertEscapedCharacters = DX;
ep.formatDOM = TX;
var mm = JS, sh = SX;
function nge(e) {
  return sh.CASE_SENSITIVE_TAG_NAMES_MAP[e];
}
function MX(e) {
  for (var t = {}, n = 0, r = e.length; n < r; n++) {
    var o = e[n];
    t[o.name] = o.value;
  }
  return t;
}
function rge(e) {
  e = e.toLowerCase();
  var t = nge(e);
  return t || e;
}
function oge(e) {
  return e.replace(sh.CARRIAGE_RETURN_REGEX, sh.CARRIAGE_RETURN_PLACEHOLDER);
}
function DX(e) {
  return e.replace(sh.CARRIAGE_RETURN_PLACEHOLDER_REGEX, sh.CARRIAGE_RETURN);
}
function TX(e, t, n) {
  t === void 0 && (t = null);
  for (var r = [], o, i = 0, a = e.length; i < a; i++) {
    var s = e[i];
    switch (s.nodeType) {
      case 1: {
        var l = rge(s.nodeName);
        o = new mm.Element(l, MX(s.attributes)), o.children = TX(
          // template children are on content
          l === "template" ? s.content.childNodes : s.childNodes,
          o
        );
        break;
      }
      case 3:
        o = new mm.Text(DX(s.nodeValue));
        break;
      case 8:
        o = new mm.Comment(s.nodeValue);
        break;
      default:
        continue;
    }
    var u = r[i - 1] || null;
    u && (u.next = o), o.parent = t, o.prev = u, o.next = null, r.push(o);
  }
  return n && (o = new mm.ProcessingInstruction(n.substring(0, n.indexOf(" ")).toLowerCase(), n), o.next = r[0] || null, o.parent = t, r.unshift(o), r[1] && (r[1].prev = r[0])), r;
}
Object.defineProperty(YS, "__esModule", { value: !0 });
YS.default = uge;
var ige = ep, kI = "html", LI = "head", vm = "body", sge = /<([a-zA-Z]+[0-9]?)/, _I = /<head[^]*>/i, PI = /<body[^]*>/i, sb = function(e, t) {
  throw new Error("This browser does not support `document.implementation.createHTMLDocument`");
}, B1 = function(e, t) {
  throw new Error("This browser does not support `DOMParser.prototype.parseFromString`");
}, SI = typeof window == "object" && window.DOMParser;
if (typeof SI == "function") {
  var age = new SI(), lge = "text/html";
  B1 = function(e, t) {
    return t && (e = "<".concat(t, ">").concat(e, "</").concat(t, ">")), age.parseFromString(e, lge);
  }, sb = B1;
}
if (typeof document == "object" && document.implementation) {
  var ym = document.implementation.createHTMLDocument();
  sb = function(e, t) {
    if (t) {
      var n = ym.documentElement.querySelector(t);
      return n && (n.innerHTML = e), ym;
    }
    return ym.documentElement.innerHTML = e, ym;
  };
}
var bm = typeof document == "object" && document.createElement("template"), F1;
bm && bm.content && (F1 = function(e) {
  return bm.innerHTML = e, bm.content.childNodes;
});
function uge(e) {
  var t, n;
  e = (0, ige.escapeSpecialCharacters)(e);
  var r = e.match(sge), o = r && r[1] ? r[1].toLowerCase() : "";
  switch (o) {
    case kI: {
      var i = B1(e);
      if (!_I.test(e)) {
        var a = i.querySelector(LI);
        (t = a == null ? void 0 : a.parentNode) === null || t === void 0 || t.removeChild(a);
      }
      if (!PI.test(e)) {
        var a = i.querySelector(vm);
        (n = a == null ? void 0 : a.parentNode) === null || n === void 0 || n.removeChild(a);
      }
      return i.querySelectorAll(kI);
    }
    case LI:
    case vm: {
      var s = sb(e).querySelectorAll(o);
      return PI.test(e) && _I.test(e) ? s[0].parentNode.childNodes : s;
    }
    default: {
      if (F1)
        return F1(e);
      var a = sb(e, vm).querySelector(vm);
      return a.childNodes;
    }
  }
}
var cge = mr && mr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(XS, "__esModule", { value: !0 });
XS.default = hge;
var pge = cge(YS), dge = ep, fge = /<(![a-zA-Z\s]+)>/;
function hge(e) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e)
    return [];
  var t = e.match(fge), n = t ? t[1] : void 0;
  return (0, dge.formatDOM)((0, pge.default)(e), null, n);
}
var K0 = {}, Gs = {}, X0 = {}, gge = 0;
X0.SAME = gge;
var mge = 1;
X0.CAMELCASE = mge;
X0.possibleStandardNames = {
  accept: 0,
  acceptCharset: 1,
  "accept-charset": "acceptCharset",
  accessKey: 1,
  action: 0,
  allowFullScreen: 1,
  alt: 0,
  as: 0,
  async: 0,
  autoCapitalize: 1,
  autoComplete: 1,
  autoCorrect: 1,
  autoFocus: 1,
  autoPlay: 1,
  autoSave: 1,
  capture: 0,
  cellPadding: 1,
  cellSpacing: 1,
  challenge: 0,
  charSet: 1,
  checked: 0,
  children: 0,
  cite: 0,
  class: "className",
  classID: 1,
  className: 1,
  cols: 0,
  colSpan: 1,
  content: 0,
  contentEditable: 1,
  contextMenu: 1,
  controls: 0,
  controlsList: 1,
  coords: 0,
  crossOrigin: 1,
  dangerouslySetInnerHTML: 1,
  data: 0,
  dateTime: 1,
  default: 0,
  defaultChecked: 1,
  defaultValue: 1,
  defer: 0,
  dir: 0,
  disabled: 0,
  disablePictureInPicture: 1,
  disableRemotePlayback: 1,
  download: 0,
  draggable: 0,
  encType: 1,
  enterKeyHint: 1,
  for: "htmlFor",
  form: 0,
  formMethod: 1,
  formAction: 1,
  formEncType: 1,
  formNoValidate: 1,
  formTarget: 1,
  frameBorder: 1,
  headers: 0,
  height: 0,
  hidden: 0,
  high: 0,
  href: 0,
  hrefLang: 1,
  htmlFor: 1,
  httpEquiv: 1,
  "http-equiv": "httpEquiv",
  icon: 0,
  id: 0,
  innerHTML: 1,
  inputMode: 1,
  integrity: 0,
  is: 0,
  itemID: 1,
  itemProp: 1,
  itemRef: 1,
  itemScope: 1,
  itemType: 1,
  keyParams: 1,
  keyType: 1,
  kind: 0,
  label: 0,
  lang: 0,
  list: 0,
  loop: 0,
  low: 0,
  manifest: 0,
  marginWidth: 1,
  marginHeight: 1,
  max: 0,
  maxLength: 1,
  media: 0,
  mediaGroup: 1,
  method: 0,
  min: 0,
  minLength: 1,
  multiple: 0,
  muted: 0,
  name: 0,
  noModule: 1,
  nonce: 0,
  noValidate: 1,
  open: 0,
  optimum: 0,
  pattern: 0,
  placeholder: 0,
  playsInline: 1,
  poster: 0,
  preload: 0,
  profile: 0,
  radioGroup: 1,
  readOnly: 1,
  referrerPolicy: 1,
  rel: 0,
  required: 0,
  reversed: 0,
  role: 0,
  rows: 0,
  rowSpan: 1,
  sandbox: 0,
  scope: 0,
  scoped: 0,
  scrolling: 0,
  seamless: 0,
  selected: 0,
  shape: 0,
  size: 0,
  sizes: 0,
  span: 0,
  spellCheck: 1,
  src: 0,
  srcDoc: 1,
  srcLang: 1,
  srcSet: 1,
  start: 0,
  step: 0,
  style: 0,
  summary: 0,
  tabIndex: 1,
  target: 0,
  title: 0,
  type: 0,
  useMap: 1,
  value: 0,
  width: 0,
  wmode: 0,
  wrap: 0,
  about: 0,
  accentHeight: 1,
  "accent-height": "accentHeight",
  accumulate: 0,
  additive: 0,
  alignmentBaseline: 1,
  "alignment-baseline": "alignmentBaseline",
  allowReorder: 1,
  alphabetic: 0,
  amplitude: 0,
  arabicForm: 1,
  "arabic-form": "arabicForm",
  ascent: 0,
  attributeName: 1,
  attributeType: 1,
  autoReverse: 1,
  azimuth: 0,
  baseFrequency: 1,
  baselineShift: 1,
  "baseline-shift": "baselineShift",
  baseProfile: 1,
  bbox: 0,
  begin: 0,
  bias: 0,
  by: 0,
  calcMode: 1,
  capHeight: 1,
  "cap-height": "capHeight",
  clip: 0,
  clipPath: 1,
  "clip-path": "clipPath",
  clipPathUnits: 1,
  clipRule: 1,
  "clip-rule": "clipRule",
  color: 0,
  colorInterpolation: 1,
  "color-interpolation": "colorInterpolation",
  colorInterpolationFilters: 1,
  "color-interpolation-filters": "colorInterpolationFilters",
  colorProfile: 1,
  "color-profile": "colorProfile",
  colorRendering: 1,
  "color-rendering": "colorRendering",
  contentScriptType: 1,
  contentStyleType: 1,
  cursor: 0,
  cx: 0,
  cy: 0,
  d: 0,
  datatype: 0,
  decelerate: 0,
  descent: 0,
  diffuseConstant: 1,
  direction: 0,
  display: 0,
  divisor: 0,
  dominantBaseline: 1,
  "dominant-baseline": "dominantBaseline",
  dur: 0,
  dx: 0,
  dy: 0,
  edgeMode: 1,
  elevation: 0,
  enableBackground: 1,
  "enable-background": "enableBackground",
  end: 0,
  exponent: 0,
  externalResourcesRequired: 1,
  fill: 0,
  fillOpacity: 1,
  "fill-opacity": "fillOpacity",
  fillRule: 1,
  "fill-rule": "fillRule",
  filter: 0,
  filterRes: 1,
  filterUnits: 1,
  floodOpacity: 1,
  "flood-opacity": "floodOpacity",
  floodColor: 1,
  "flood-color": "floodColor",
  focusable: 0,
  fontFamily: 1,
  "font-family": "fontFamily",
  fontSize: 1,
  "font-size": "fontSize",
  fontSizeAdjust: 1,
  "font-size-adjust": "fontSizeAdjust",
  fontStretch: 1,
  "font-stretch": "fontStretch",
  fontStyle: 1,
  "font-style": "fontStyle",
  fontVariant: 1,
  "font-variant": "fontVariant",
  fontWeight: 1,
  "font-weight": "fontWeight",
  format: 0,
  from: 0,
  fx: 0,
  fy: 0,
  g1: 0,
  g2: 0,
  glyphName: 1,
  "glyph-name": "glyphName",
  glyphOrientationHorizontal: 1,
  "glyph-orientation-horizontal": "glyphOrientationHorizontal",
  glyphOrientationVertical: 1,
  "glyph-orientation-vertical": "glyphOrientationVertical",
  glyphRef: 1,
  gradientTransform: 1,
  gradientUnits: 1,
  hanging: 0,
  horizAdvX: 1,
  "horiz-adv-x": "horizAdvX",
  horizOriginX: 1,
  "horiz-origin-x": "horizOriginX",
  ideographic: 0,
  imageRendering: 1,
  "image-rendering": "imageRendering",
  in2: 0,
  in: 0,
  inlist: 0,
  intercept: 0,
  k1: 0,
  k2: 0,
  k3: 0,
  k4: 0,
  k: 0,
  kernelMatrix: 1,
  kernelUnitLength: 1,
  kerning: 0,
  keyPoints: 1,
  keySplines: 1,
  keyTimes: 1,
  lengthAdjust: 1,
  letterSpacing: 1,
  "letter-spacing": "letterSpacing",
  lightingColor: 1,
  "lighting-color": "lightingColor",
  limitingConeAngle: 1,
  local: 0,
  markerEnd: 1,
  "marker-end": "markerEnd",
  markerHeight: 1,
  markerMid: 1,
  "marker-mid": "markerMid",
  markerStart: 1,
  "marker-start": "markerStart",
  markerUnits: 1,
  markerWidth: 1,
  mask: 0,
  maskContentUnits: 1,
  maskUnits: 1,
  mathematical: 0,
  mode: 0,
  numOctaves: 1,
  offset: 0,
  opacity: 0,
  operator: 0,
  order: 0,
  orient: 0,
  orientation: 0,
  origin: 0,
  overflow: 0,
  overlinePosition: 1,
  "overline-position": "overlinePosition",
  overlineThickness: 1,
  "overline-thickness": "overlineThickness",
  paintOrder: 1,
  "paint-order": "paintOrder",
  panose1: 0,
  "panose-1": "panose1",
  pathLength: 1,
  patternContentUnits: 1,
  patternTransform: 1,
  patternUnits: 1,
  pointerEvents: 1,
  "pointer-events": "pointerEvents",
  points: 0,
  pointsAtX: 1,
  pointsAtY: 1,
  pointsAtZ: 1,
  prefix: 0,
  preserveAlpha: 1,
  preserveAspectRatio: 1,
  primitiveUnits: 1,
  property: 0,
  r: 0,
  radius: 0,
  refX: 1,
  refY: 1,
  renderingIntent: 1,
  "rendering-intent": "renderingIntent",
  repeatCount: 1,
  repeatDur: 1,
  requiredExtensions: 1,
  requiredFeatures: 1,
  resource: 0,
  restart: 0,
  result: 0,
  results: 0,
  rotate: 0,
  rx: 0,
  ry: 0,
  scale: 0,
  security: 0,
  seed: 0,
  shapeRendering: 1,
  "shape-rendering": "shapeRendering",
  slope: 0,
  spacing: 0,
  specularConstant: 1,
  specularExponent: 1,
  speed: 0,
  spreadMethod: 1,
  startOffset: 1,
  stdDeviation: 1,
  stemh: 0,
  stemv: 0,
  stitchTiles: 1,
  stopColor: 1,
  "stop-color": "stopColor",
  stopOpacity: 1,
  "stop-opacity": "stopOpacity",
  strikethroughPosition: 1,
  "strikethrough-position": "strikethroughPosition",
  strikethroughThickness: 1,
  "strikethrough-thickness": "strikethroughThickness",
  string: 0,
  stroke: 0,
  strokeDasharray: 1,
  "stroke-dasharray": "strokeDasharray",
  strokeDashoffset: 1,
  "stroke-dashoffset": "strokeDashoffset",
  strokeLinecap: 1,
  "stroke-linecap": "strokeLinecap",
  strokeLinejoin: 1,
  "stroke-linejoin": "strokeLinejoin",
  strokeMiterlimit: 1,
  "stroke-miterlimit": "strokeMiterlimit",
  strokeWidth: 1,
  "stroke-width": "strokeWidth",
  strokeOpacity: 1,
  "stroke-opacity": "strokeOpacity",
  suppressContentEditableWarning: 1,
  suppressHydrationWarning: 1,
  surfaceScale: 1,
  systemLanguage: 1,
  tableValues: 1,
  targetX: 1,
  targetY: 1,
  textAnchor: 1,
  "text-anchor": "textAnchor",
  textDecoration: 1,
  "text-decoration": "textDecoration",
  textLength: 1,
  textRendering: 1,
  "text-rendering": "textRendering",
  to: 0,
  transform: 0,
  typeof: 0,
  u1: 0,
  u2: 0,
  underlinePosition: 1,
  "underline-position": "underlinePosition",
  underlineThickness: 1,
  "underline-thickness": "underlineThickness",
  unicode: 0,
  unicodeBidi: 1,
  "unicode-bidi": "unicodeBidi",
  unicodeRange: 1,
  "unicode-range": "unicodeRange",
  unitsPerEm: 1,
  "units-per-em": "unitsPerEm",
  unselectable: 0,
  vAlphabetic: 1,
  "v-alphabetic": "vAlphabetic",
  values: 0,
  vectorEffect: 1,
  "vector-effect": "vectorEffect",
  version: 0,
  vertAdvY: 1,
  "vert-adv-y": "vertAdvY",
  vertOriginX: 1,
  "vert-origin-x": "vertOriginX",
  vertOriginY: 1,
  "vert-origin-y": "vertOriginY",
  vHanging: 1,
  "v-hanging": "vHanging",
  vIdeographic: 1,
  "v-ideographic": "vIdeographic",
  viewBox: 1,
  viewTarget: 1,
  visibility: 0,
  vMathematical: 1,
  "v-mathematical": "vMathematical",
  vocab: 0,
  widths: 0,
  wordSpacing: 1,
  "word-spacing": "wordSpacing",
  writingMode: 1,
  "writing-mode": "writingMode",
  x1: 0,
  x2: 0,
  x: 0,
  xChannelSelector: 1,
  xHeight: 1,
  "x-height": "xHeight",
  xlinkActuate: 1,
  "xlink:actuate": "xlinkActuate",
  xlinkArcrole: 1,
  "xlink:arcrole": "xlinkArcrole",
  xlinkHref: 1,
  "xlink:href": "xlinkHref",
  xlinkRole: 1,
  "xlink:role": "xlinkRole",
  xlinkShow: 1,
  "xlink:show": "xlinkShow",
  xlinkTitle: 1,
  "xlink:title": "xlinkTitle",
  xlinkType: 1,
  "xlink:type": "xlinkType",
  xmlBase: 1,
  "xml:base": "xmlBase",
  xmlLang: 1,
  "xml:lang": "xmlLang",
  xmlns: 0,
  "xml:space": "xmlSpace",
  xmlnsXlink: 1,
  "xmlns:xlink": "xmlnsXlink",
  xmlSpace: 1,
  y1: 0,
  y2: 0,
  y: 0,
  yChannelSelector: 1,
  z: 0,
  zoomAndPan: 1
};
const jX = 0, gu = 1, Y0 = 2, J0 = 3, nM = 4, AX = 5, RX = 6;
function vge(e) {
  return si.hasOwnProperty(e) ? si[e] : null;
}
function Ai(e, t, n, r, o, i, a) {
  this.acceptsBooleans = t === Y0 || t === J0 || t === nM, this.attributeName = r, this.attributeNamespace = o, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = i, this.removeEmptyString = a;
}
const si = {}, yge = [
  "children",
  "dangerouslySetInnerHTML",
  // TODO: This prevents the assignment of defaultValue to regular
  // elements (not just inputs). Now that ReactDOMInput assigns to the
  // defaultValue property -- do we need this?
  "defaultValue",
  "defaultChecked",
  "innerHTML",
  "suppressContentEditableWarning",
  "suppressHydrationWarning",
  "style"
];
yge.forEach((e) => {
  si[e] = new Ai(
    e,
    jX,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"]
].forEach(([e, t]) => {
  si[e] = new Ai(
    e,
    gu,
    !1,
    // mustUseProperty
    t,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["contentEditable", "draggable", "spellCheck", "value"].forEach((e) => {
  si[e] = new Ai(
    e,
    Y0,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha"
].forEach((e) => {
  si[e] = new Ai(
    e,
    Y0,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "allowFullScreen",
  "async",
  // Note: there is a special case that prevents it from being written to the DOM
  // on the client side because the browsers are inconsistent. Instead we call focus().
  "autoFocus",
  "autoPlay",
  "controls",
  "default",
  "defer",
  "disabled",
  "disablePictureInPicture",
  "disableRemotePlayback",
  "formNoValidate",
  "hidden",
  "loop",
  "noModule",
  "noValidate",
  "open",
  "playsInline",
  "readOnly",
  "required",
  "reversed",
  "scoped",
  "seamless",
  // Microdata
  "itemScope"
].forEach((e) => {
  si[e] = new Ai(
    e,
    J0,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "checked",
  // Note: `option.selected` is not updated if `select.multiple` is
  // disabled with `removeAttribute`. We have special logic for handling this.
  "multiple",
  "muted",
  "selected"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  si[e] = new Ai(
    e,
    J0,
    !0,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "capture",
  "download"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  si[e] = new Ai(
    e,
    nM,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "cols",
  "rows",
  "size",
  "span"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  si[e] = new Ai(
    e,
    RX,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["rowSpan", "start"].forEach((e) => {
  si[e] = new Ai(
    e,
    AX,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const rM = /[\-\:]([a-z])/g, oM = (e) => e[1].toUpperCase();
[
  "accent-height",
  "alignment-baseline",
  "arabic-form",
  "baseline-shift",
  "cap-height",
  "clip-path",
  "clip-rule",
  "color-interpolation",
  "color-interpolation-filters",
  "color-profile",
  "color-rendering",
  "dominant-baseline",
  "enable-background",
  "fill-opacity",
  "fill-rule",
  "flood-color",
  "flood-opacity",
  "font-family",
  "font-size",
  "font-size-adjust",
  "font-stretch",
  "font-style",
  "font-variant",
  "font-weight",
  "glyph-name",
  "glyph-orientation-horizontal",
  "glyph-orientation-vertical",
  "horiz-adv-x",
  "horiz-origin-x",
  "image-rendering",
  "letter-spacing",
  "lighting-color",
  "marker-end",
  "marker-mid",
  "marker-start",
  "overline-position",
  "overline-thickness",
  "paint-order",
  "panose-1",
  "pointer-events",
  "rendering-intent",
  "shape-rendering",
  "stop-color",
  "stop-opacity",
  "strikethrough-position",
  "strikethrough-thickness",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "text-anchor",
  "text-decoration",
  "text-rendering",
  "underline-position",
  "underline-thickness",
  "unicode-bidi",
  "unicode-range",
  "units-per-em",
  "v-alphabetic",
  "v-hanging",
  "v-ideographic",
  "v-mathematical",
  "vector-effect",
  "vert-adv-y",
  "vert-origin-x",
  "vert-origin-y",
  "word-spacing",
  "writing-mode",
  "xmlns:xlink",
  "x-height"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(rM, oM);
  si[t] = new Ai(
    t,
    gu,
    !1,
    // mustUseProperty
    e,
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xlink:actuate",
  "xlink:arcrole",
  "xlink:role",
  "xlink:show",
  "xlink:title",
  "xlink:type"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(rM, oM);
  si[t] = new Ai(
    t,
    gu,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/1999/xlink",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xml:base",
  "xml:lang",
  "xml:space"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(rM, oM);
  si[t] = new Ai(
    t,
    gu,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/XML/1998/namespace",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["tabIndex", "crossOrigin"].forEach((e) => {
  si[e] = new Ai(
    e,
    gu,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const bge = "xlinkHref";
si[bge] = new Ai(
  "xlinkHref",
  gu,
  !1,
  // mustUseProperty
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  // sanitizeURL
  !1
  // removeEmptyString
);
["src", "href", "action", "formAction"].forEach((e) => {
  si[e] = new Ai(
    e,
    gu,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !0,
    // sanitizeURL
    !0
    // removeEmptyString
  );
});
const {
  CAMELCASE: wge,
  SAME: Cge,
  possibleStandardNames: MI
} = X0, Oge = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", xge = Oge + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", Ege = RegExp.prototype.test.bind(
  // eslint-disable-next-line no-misleading-character-class
  new RegExp("^(data|aria)-[" + xge + "]*$")
), kge = Object.keys(
  MI
).reduce((e, t) => {
  const n = MI[t];
  return n === Cge ? e[t] = t : n === wge ? e[t.toLowerCase()] = t : e[t] = n, e;
}, {});
Gs.BOOLEAN = J0;
Gs.BOOLEANISH_STRING = Y0;
Gs.NUMERIC = AX;
Gs.OVERLOADED_BOOLEAN = nM;
Gs.POSITIVE_NUMERIC = RX;
Gs.RESERVED = jX;
Gs.STRING = gu;
Gs.getPropertyInfo = vge;
Gs.isCustomAttribute = Ege;
Gs.possibleStandardNames = kge;
var iM = {}, sM = {}, DI = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, Lge = /\n/g, _ge = /^\s*/, Pge = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, Sge = /^:\s*/, Mge = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, Dge = /^[;\s]*/, Tge = /^\s+|\s+$/g, jge = `
`, TI = "/", jI = "*", lc = "", Age = "comment", Rge = "declaration", Ige = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e) return [];
  t = t || {};
  var n = 1, r = 1;
  function o(f) {
    var m = f.match(Lge);
    m && (n += m.length);
    var b = f.lastIndexOf(jge);
    r = ~b ? f.length - b : r + f.length;
  }
  function i() {
    var f = { line: n, column: r };
    return function(m) {
      return m.position = new a(f), u(), m;
    };
  }
  function a(f) {
    this.start = f, this.end = { line: n, column: r }, this.source = t.source;
  }
  a.prototype.content = e;
  function s(f) {
    var m = new Error(
      t.source + ":" + n + ":" + r + ": " + f
    );
    if (m.reason = f, m.filename = t.source, m.line = n, m.column = r, m.source = e, !t.silent) throw m;
  }
  function l(f) {
    var m = f.exec(e);
    if (m) {
      var b = m[0];
      return o(b), e = e.slice(b.length), m;
    }
  }
  function u() {
    l(_ge);
  }
  function c(f) {
    var m;
    for (f = f || []; m = p(); )
      m !== !1 && f.push(m);
    return f;
  }
  function p() {
    var f = i();
    if (!(TI != e.charAt(0) || jI != e.charAt(1))) {
      for (var m = 2; lc != e.charAt(m) && (jI != e.charAt(m) || TI != e.charAt(m + 1)); )
        ++m;
      if (m += 2, lc === e.charAt(m - 1))
        return s("End of comment missing");
      var b = e.slice(2, m - 2);
      return r += 2, o(b), e = e.slice(m), r += 2, f({
        type: Age,
        comment: b
      });
    }
  }
  function d() {
    var f = i(), m = l(Pge);
    if (m) {
      if (p(), !l(Sge)) return s("property missing ':'");
      var b = l(Mge), E = f({
        type: Rge,
        property: AI(m[0].replace(DI, lc)),
        value: b ? AI(b[0].replace(DI, lc)) : lc
      });
      return l(Dge), E;
    }
  }
  function g() {
    var f = [];
    c(f);
    for (var m; m = d(); )
      m !== !1 && (f.push(m), c(f));
    return f;
  }
  return u(), g();
};
function AI(e) {
  return e ? e.replace(Tge, lc) : lc;
}
var Nge = mr && mr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(sM, "__esModule", { value: !0 });
sM.default = Fge;
var Bge = Nge(Ige);
function Fge(e, t) {
  var n = null;
  if (!e || typeof e != "string")
    return n;
  var r = (0, Bge.default)(e), o = typeof t == "function";
  return r.forEach(function(i) {
    if (i.type === "declaration") {
      var a = i.property, s = i.value;
      o ? t(a, s, i) : s && (n = n || {}, n[a] = s);
    }
  }), n;
}
var Q0 = {};
Object.defineProperty(Q0, "__esModule", { value: !0 });
Q0.camelCase = void 0;
var zge = /^--[a-zA-Z0-9_-]+$/, Uge = /-([a-z])/g, Hge = /^[^-]+$/, Wge = /^-(webkit|moz|ms|o|khtml)-/, $ge = /^-(ms)-/, Vge = function(e) {
  return !e || Hge.test(e) || zge.test(e);
}, Zge = function(e, t) {
  return t.toUpperCase();
}, RI = function(e, t) {
  return "".concat(t, "-");
}, qge = function(e, t) {
  return t === void 0 && (t = {}), Vge(e) ? e : (e = e.toLowerCase(), t.reactCompat ? e = e.replace($ge, RI) : e = e.replace(Wge, RI), e.replace(Uge, Zge));
};
Q0.camelCase = qge;
var Gge = mr && mr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
}, Kge = Gge(sM), Xge = Q0;
function z1(e, t) {
  var n = {};
  return !e || typeof e != "string" || (0, Kge.default)(e, function(r, o) {
    r && o && (n[(0, Xge.camelCase)(r, t)] = o);
  }), n;
}
z1.default = z1;
var Yge = z1;
(function(e) {
  var t = mr && mr.__importDefault || function(c) {
    return c && c.__esModule ? c : { default: c };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.returnFirstArg = e.canTextBeChildOfNode = e.ELEMENTS_WITH_NO_TEXT_CHILDREN = e.PRESERVE_CUSTOM_ATTRIBUTES = void 0, e.isCustomComponent = i, e.setStyleProp = s;
  var n = be, r = t(Yge), o = /* @__PURE__ */ new Set([
    "annotation-xml",
    "color-profile",
    "font-face",
    "font-face-src",
    "font-face-uri",
    "font-face-format",
    "font-face-name",
    "missing-glyph"
  ]);
  function i(c, p) {
    return c.includes("-") ? !o.has(c) : !!(p && typeof p.is == "string");
  }
  var a = {
    reactCompat: !0
  };
  function s(c, p) {
    if (typeof c == "string") {
      if (!c.trim()) {
        p.style = {};
        return;
      }
      try {
        p.style = (0, r.default)(c, a);
      } catch {
        p.style = {};
      }
    }
  }
  e.PRESERVE_CUSTOM_ATTRIBUTES = Number(n.version.split(".")[0]) >= 16, e.ELEMENTS_WITH_NO_TEXT_CHILDREN = /* @__PURE__ */ new Set([
    "tr",
    "tbody",
    "thead",
    "tfoot",
    "colgroup",
    "table",
    "head",
    "html",
    "frameset"
  ]);
  var l = function(c) {
    return !e.ELEMENTS_WITH_NO_TEXT_CHILDREN.has(c.name);
  };
  e.canTextBeChildOfNode = l;
  var u = function(c) {
    return c;
  };
  e.returnFirstArg = u;
})(iM);
Object.defineProperty(K0, "__esModule", { value: !0 });
K0.default = tme;
var Kd = Gs, II = iM, Jge = ["checked", "value"], Qge = ["input", "select", "textarea"], eme = {
  reset: !0,
  submit: !0
};
function tme(e, t) {
  e === void 0 && (e = {});
  var n = {}, r = !!(e.type && eme[e.type]);
  for (var o in e) {
    var i = e[o];
    if ((0, Kd.isCustomAttribute)(o)) {
      n[o] = i;
      continue;
    }
    var a = o.toLowerCase(), s = NI(a);
    if (s) {
      var l = (0, Kd.getPropertyInfo)(s);
      switch (Jge.includes(s) && Qge.includes(t) && !r && (s = NI("default" + a)), n[s] = i, l && l.type) {
        case Kd.BOOLEAN:
          n[s] = !0;
          break;
        case Kd.OVERLOADED_BOOLEAN:
          i === "" && (n[s] = !0);
          break;
      }
      continue;
    }
    II.PRESERVE_CUSTOM_ATTRIBUTES && (n[o] = i);
  }
  return (0, II.setStyleProp)(e.style, n), n;
}
function NI(e) {
  return Kd.possibleStandardNames[e];
}
var aM = {}, nme = mr && mr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(aM, "__esModule", { value: !0 });
aM.default = IX;
var Lx = be, rme = nme(K0), ff = iM, ome = {
  cloneElement: Lx.cloneElement,
  createElement: Lx.createElement,
  isValidElement: Lx.isValidElement
};
function IX(e, t) {
  t === void 0 && (t = {});
  for (var n = [], r = typeof t.replace == "function", o = t.transform || ff.returnFirstArg, i = t.library || ome, a = i.cloneElement, s = i.createElement, l = i.isValidElement, u = e.length, c = 0; c < u; c++) {
    var p = e[c];
    if (r) {
      var d = t.replace(p, c);
      if (l(d)) {
        u > 1 && (d = a(d, {
          key: d.key || c
        })), n.push(o(d, p, c));
        continue;
      }
    }
    if (p.type === "text") {
      var g = !p.data.trim().length;
      if (g && p.parent && !(0, ff.canTextBeChildOfNode)(p.parent) || t.trim && g)
        continue;
      n.push(o(p.data, p, c));
      continue;
    }
    var f = p, m = {};
    ime(f) ? ((0, ff.setStyleProp)(f.attribs.style, f.attribs), m = f.attribs) : f.attribs && (m = (0, rme.default)(f.attribs, f.name));
    var b = void 0;
    switch (p.type) {
      case "script":
      case "style":
        p.children[0] && (m.dangerouslySetInnerHTML = {
          __html: p.children[0].data
        });
        break;
      case "tag":
        p.name === "textarea" && p.children[0] ? m.defaultValue = p.children[0].data : p.children && p.children.length && (b = IX(p.children, t));
        break;
      default:
        continue;
    }
    u > 1 && (m.key = c), n.push(o(s(p.name, m, b), p, c));
  }
  return n.length === 1 ? n[0] : n;
}
function ime(e) {
  return ff.PRESERVE_CUSTOM_ATTRIBUTES && e.type === "tag" && (0, ff.isCustomComponent)(e.name, e.attribs);
}
(function(e) {
  var t = mr && mr.__importDefault || function(l) {
    return l && l.__esModule ? l : { default: l };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.htmlToDOM = e.domToReact = e.attributesToProps = e.Text = e.ProcessingInstruction = e.Element = e.Comment = void 0, e.default = s;
  var n = t(XS);
  e.htmlToDOM = n.default;
  var r = t(K0);
  e.attributesToProps = r.default;
  var o = t(aM);
  e.domToReact = o.default;
  var i = JS;
  Object.defineProperty(e, "Comment", { enumerable: !0, get: function() {
    return i.Comment;
  } }), Object.defineProperty(e, "Element", { enumerable: !0, get: function() {
    return i.Element;
  } }), Object.defineProperty(e, "ProcessingInstruction", { enumerable: !0, get: function() {
    return i.ProcessingInstruction;
  } }), Object.defineProperty(e, "Text", { enumerable: !0, get: function() {
    return i.Text;
  } });
  var a = { lowerCaseAttributeNames: !1 };
  function s(l, u) {
    if (typeof l != "string")
      throw new TypeError("First argument must be a string");
    return l ? (0, o.default)((0, n.default)(l, (u == null ? void 0 : u.htmlparser2) || a), u) : [];
  }
})(mX);
const sme = /* @__PURE__ */ khe(mX);
sme.default;
var vr = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function ame(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var U1 = { exports: {} }, ud = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var BI;
function lme() {
  if (BI) return ud;
  BI = 1;
  var e = be, t = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, o = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, i = { key: !0, ref: !0, __self: !0, __source: !0 };
  function a(s, l, u) {
    var c, p = {}, d = null, g = null;
    u !== void 0 && (d = "" + u), l.key !== void 0 && (d = "" + l.key), l.ref !== void 0 && (g = l.ref);
    for (c in l) r.call(l, c) && !i.hasOwnProperty(c) && (p[c] = l[c]);
    if (s && s.defaultProps) for (c in l = s.defaultProps, l) p[c] === void 0 && (p[c] = l[c]);
    return { $$typeof: t, type: s, key: d, ref: g, props: p, _owner: o.current };
  }
  return ud.Fragment = n, ud.jsx = a, ud.jsxs = a, ud;
}
var wm = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var FI;
function ume() {
  return FI || (FI = 1, process.env.NODE_ENV !== "production" && function() {
    var e = be, t = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), a = Symbol.for("react.provider"), s = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), c = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), d = Symbol.for("react.lazy"), g = Symbol.for("react.offscreen"), f = Symbol.iterator, m = "@@iterator";
    function b(y) {
      if (y === null || typeof y != "object")
        return null;
      var R = f && y[f] || y[m];
      return typeof R == "function" ? R : null;
    }
    var E = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function w(y) {
      {
        for (var R = arguments.length, G = new Array(R > 1 ? R - 1 : 0), ne = 1; ne < R; ne++)
          G[ne - 1] = arguments[ne];
        M("error", y, G);
      }
    }
    function M(y, R, G) {
      {
        var ne = E.ReactDebugCurrentFrame, ae = ne.getStackAddendum();
        ae !== "" && (R += "%s", G = G.concat([ae]));
        var ue = G.map(function(se) {
          return String(se);
        });
        ue.unshift("Warning: " + R), Function.prototype.apply.call(console[y], console, ue);
      }
    }
    var x = !1, v = !1, C = !1, P = !1, F = !1, L;
    L = Symbol.for("react.module.reference");
    function B(y) {
      return !!(typeof y == "string" || typeof y == "function" || y === r || y === i || F || y === o || y === u || y === c || P || y === g || x || v || C || typeof y == "object" && y !== null && (y.$$typeof === d || y.$$typeof === p || y.$$typeof === a || y.$$typeof === s || y.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      y.$$typeof === L || y.getModuleId !== void 0));
    }
    function N(y, R, G) {
      var ne = y.displayName;
      if (ne)
        return ne;
      var ae = R.displayName || R.name || "";
      return ae !== "" ? G + "(" + ae + ")" : G;
    }
    function $(y) {
      return y.displayName || "Context";
    }
    function V(y) {
      if (y == null)
        return null;
      if (typeof y.tag == "number" && w("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof y == "function")
        return y.displayName || y.name || null;
      if (typeof y == "string")
        return y;
      switch (y) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case i:
          return "Profiler";
        case o:
          return "StrictMode";
        case u:
          return "Suspense";
        case c:
          return "SuspenseList";
      }
      if (typeof y == "object")
        switch (y.$$typeof) {
          case s:
            var R = y;
            return $(R) + ".Consumer";
          case a:
            var G = y;
            return $(G._context) + ".Provider";
          case l:
            return N(y, y.render, "ForwardRef");
          case p:
            var ne = y.displayName || null;
            return ne !== null ? ne : V(y.type) || "Memo";
          case d: {
            var ae = y, ue = ae._payload, se = ae._init;
            try {
              return V(se(ue));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var H = Object.assign, Z = 0, K, Y, Q, J, _, D, z;
    function S() {
    }
    S.__reactDisabledLog = !0;
    function W() {
      {
        if (Z === 0) {
          K = console.log, Y = console.info, Q = console.warn, J = console.error, _ = console.group, D = console.groupCollapsed, z = console.groupEnd;
          var y = {
            configurable: !0,
            enumerable: !0,
            value: S,
            writable: !0
          };
          Object.defineProperties(console, {
            info: y,
            log: y,
            warn: y,
            error: y,
            group: y,
            groupCollapsed: y,
            groupEnd: y
          });
        }
        Z++;
      }
    }
    function O() {
      {
        if (Z--, Z === 0) {
          var y = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: H({}, y, {
              value: K
            }),
            info: H({}, y, {
              value: Y
            }),
            warn: H({}, y, {
              value: Q
            }),
            error: H({}, y, {
              value: J
            }),
            group: H({}, y, {
              value: _
            }),
            groupCollapsed: H({}, y, {
              value: D
            }),
            groupEnd: H({}, y, {
              value: z
            })
          });
        }
        Z < 0 && w("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var j = E.ReactCurrentDispatcher, U;
    function T(y, R, G) {
      {
        if (U === void 0)
          try {
            throw Error();
          } catch (ae) {
            var ne = ae.stack.trim().match(/\n( *(at )?)/);
            U = ne && ne[1] || "";
          }
        return `
` + U + y;
      }
    }
    var q = !1, A;
    {
      var X = typeof WeakMap == "function" ? WeakMap : Map;
      A = new X();
    }
    function I(y, R) {
      if (!y || q)
        return "";
      {
        var G = A.get(y);
        if (G !== void 0)
          return G;
      }
      var ne;
      q = !0;
      var ae = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var ue;
      ue = j.current, j.current = null, W();
      try {
        if (R) {
          var se = function() {
            throw Error();
          };
          if (Object.defineProperty(se.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(se, []);
            } catch (je) {
              ne = je;
            }
            Reflect.construct(y, [], se);
          } else {
            try {
              se.call();
            } catch (je) {
              ne = je;
            }
            y.call(se.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (je) {
            ne = je;
          }
          y();
        }
      } catch (je) {
        if (je && ne && typeof je.stack == "string") {
          for (var ie = je.stack.split(`
`), Oe = ne.stack.split(`
`), de = ie.length - 1, fe = Oe.length - 1; de >= 1 && fe >= 0 && ie[de] !== Oe[fe]; )
            fe--;
          for (; de >= 1 && fe >= 0; de--, fe--)
            if (ie[de] !== Oe[fe]) {
              if (de !== 1 || fe !== 1)
                do
                  if (de--, fe--, fe < 0 || ie[de] !== Oe[fe]) {
                    var ze = `
` + ie[de].replace(" at new ", " at ");
                    return y.displayName && ze.includes("<anonymous>") && (ze = ze.replace("<anonymous>", y.displayName)), typeof y == "function" && A.set(y, ze), ze;
                  }
                while (de >= 1 && fe >= 0);
              break;
            }
        }
      } finally {
        q = !1, j.current = ue, O(), Error.prepareStackTrace = ae;
      }
      var Et = y ? y.displayName || y.name : "", bt = Et ? T(Et) : "";
      return typeof y == "function" && A.set(y, bt), bt;
    }
    function le(y, R, G) {
      return I(y, !1);
    }
    function he(y) {
      var R = y.prototype;
      return !!(R && R.isReactComponent);
    }
    function oe(y, R, G) {
      if (y == null)
        return "";
      if (typeof y == "function")
        return I(y, he(y));
      if (typeof y == "string")
        return T(y);
      switch (y) {
        case u:
          return T("Suspense");
        case c:
          return T("SuspenseList");
      }
      if (typeof y == "object")
        switch (y.$$typeof) {
          case l:
            return le(y.render);
          case p:
            return oe(y.type, R, G);
          case d: {
            var ne = y, ae = ne._payload, ue = ne._init;
            try {
              return oe(ue(ae), R, G);
            } catch {
            }
          }
        }
      return "";
    }
    var Ae = Object.prototype.hasOwnProperty, Ue = {}, He = E.ReactDebugCurrentFrame;
    function Re(y) {
      if (y) {
        var R = y._owner, G = oe(y.type, y._source, R ? R.type : null);
        He.setExtraStackFrame(G);
      } else
        He.setExtraStackFrame(null);
    }
    function nt(y, R, G, ne, ae) {
      {
        var ue = Function.call.bind(Ae);
        for (var se in y)
          if (ue(y, se)) {
            var ie = void 0;
            try {
              if (typeof y[se] != "function") {
                var Oe = Error((ne || "React class") + ": " + G + " type `" + se + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof y[se] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw Oe.name = "Invariant Violation", Oe;
              }
              ie = y[se](R, se, ne, G, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (de) {
              ie = de;
            }
            ie && !(ie instanceof Error) && (Re(ae), w("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", ne || "React class", G, se, typeof ie), Re(null)), ie instanceof Error && !(ie.message in Ue) && (Ue[ie.message] = !0, Re(ae), w("Failed %s type: %s", G, ie.message), Re(null));
          }
      }
    }
    var Ve = Array.isArray;
    function we(y) {
      return Ve(y);
    }
    function et(y) {
      {
        var R = typeof Symbol == "function" && Symbol.toStringTag, G = R && y[Symbol.toStringTag] || y.constructor.name || "Object";
        return G;
      }
    }
    function lt(y) {
      try {
        return ye(y), !1;
      } catch {
        return !0;
      }
    }
    function ye(y) {
      return "" + y;
    }
    function ke(y) {
      if (lt(y))
        return w("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", et(y)), ye(y);
    }
    var Qe = E.ReactCurrentOwner, Fe = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, Ie, ot;
    function Ee(y) {
      if (Ae.call(y, "ref")) {
        var R = Object.getOwnPropertyDescriptor(y, "ref").get;
        if (R && R.isReactWarning)
          return !1;
      }
      return y.ref !== void 0;
    }
    function wt(y) {
      if (Ae.call(y, "key")) {
        var R = Object.getOwnPropertyDescriptor(y, "key").get;
        if (R && R.isReactWarning)
          return !1;
      }
      return y.key !== void 0;
    }
    function it(y, R) {
      typeof y.ref == "string" && Qe.current;
    }
    function st(y, R) {
      {
        var G = function() {
          Ie || (Ie = !0, w("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", R));
        };
        G.isReactWarning = !0, Object.defineProperty(y, "key", {
          get: G,
          configurable: !0
        });
      }
    }
    function ut(y, R) {
      {
        var G = function() {
          ot || (ot = !0, w("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", R));
        };
        G.isReactWarning = !0, Object.defineProperty(y, "ref", {
          get: G,
          configurable: !0
        });
      }
    }
    var Ct = function(y, R, G, ne, ae, ue, se) {
      var ie = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: y,
        key: R,
        ref: G,
        props: se,
        // Record the component responsible for creating this element.
        _owner: ue
      };
      return ie._store = {}, Object.defineProperty(ie._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(ie, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ne
      }), Object.defineProperty(ie, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ae
      }), Object.freeze && (Object.freeze(ie.props), Object.freeze(ie)), ie;
    };
    function ct(y, R, G, ne, ae) {
      {
        var ue, se = {}, ie = null, Oe = null;
        G !== void 0 && (ke(G), ie = "" + G), wt(R) && (ke(R.key), ie = "" + R.key), Ee(R) && (Oe = R.ref, it(R));
        for (ue in R)
          Ae.call(R, ue) && !Fe.hasOwnProperty(ue) && (se[ue] = R[ue]);
        if (y && y.defaultProps) {
          var de = y.defaultProps;
          for (ue in de)
            se[ue] === void 0 && (se[ue] = de[ue]);
        }
        if (ie || Oe) {
          var fe = typeof y == "function" ? y.displayName || y.name || "Unknown" : y;
          ie && st(se, fe), Oe && ut(se, fe);
        }
        return Ct(y, ie, Oe, ae, ne, Qe.current, se);
      }
    }
    var pt = E.ReactCurrentOwner, rt = E.ReactDebugCurrentFrame;
    function We(y) {
      if (y) {
        var R = y._owner, G = oe(y.type, y._source, R ? R.type : null);
        rt.setExtraStackFrame(G);
      } else
        rt.setExtraStackFrame(null);
    }
    var Ot;
    Ot = !1;
    function xt(y) {
      return typeof y == "object" && y !== null && y.$$typeof === t;
    }
    function gt() {
      {
        if (pt.current) {
          var y = V(pt.current.type);
          if (y)
            return `

Check the render method of \`` + y + "`.";
        }
        return "";
      }
    }
    function Ht(y) {
      return "";
    }
    var mt = {};
    function Wt(y) {
      {
        var R = gt();
        if (!R) {
          var G = typeof y == "string" ? y : y.displayName || y.name;
          G && (R = `

Check the top-level render call using <` + G + ">.");
        }
        return R;
      }
    }
    function vt(y, R) {
      {
        if (!y._store || y._store.validated || y.key != null)
          return;
        y._store.validated = !0;
        var G = Wt(R);
        if (mt[G])
          return;
        mt[G] = !0;
        var ne = "";
        y && y._owner && y._owner !== pt.current && (ne = " It was passed a child from " + V(y._owner.type) + "."), We(y), w('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', G, ne), We(null);
      }
    }
    function kt(y, R) {
      {
        if (typeof y != "object")
          return;
        if (we(y))
          for (var G = 0; G < y.length; G++) {
            var ne = y[G];
            xt(ne) && vt(ne, R);
          }
        else if (xt(y))
          y._store && (y._store.validated = !0);
        else if (y) {
          var ae = b(y);
          if (typeof ae == "function" && ae !== y.entries)
            for (var ue = ae.call(y), se; !(se = ue.next()).done; )
              xt(se.value) && vt(se.value, R);
        }
      }
    }
    function Un(y) {
      {
        var R = y.type;
        if (R == null || typeof R == "string")
          return;
        var G;
        if (typeof R == "function")
          G = R.propTypes;
        else if (typeof R == "object" && (R.$$typeof === l || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        R.$$typeof === p))
          G = R.propTypes;
        else
          return;
        if (G) {
          var ne = V(R);
          nt(G, y.props, "prop", ne, y);
        } else if (R.PropTypes !== void 0 && !Ot) {
          Ot = !0;
          var ae = V(R);
          w("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", ae || "Unknown");
        }
        typeof R.getDefaultProps == "function" && !R.getDefaultProps.isReactClassApproved && w("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function yt(y) {
      {
        for (var R = Object.keys(y.props), G = 0; G < R.length; G++) {
          var ne = R[G];
          if (ne !== "children" && ne !== "key") {
            We(y), w("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", ne), We(null);
            break;
          }
        }
        y.ref !== null && (We(y), w("Invalid attribute `ref` supplied to `React.Fragment`."), We(null));
      }
    }
    var re = {};
    function ao(y, R, G, ne, ae, ue) {
      {
        var se = B(y);
        if (!se) {
          var ie = "";
          (y === void 0 || typeof y == "object" && y !== null && Object.keys(y).length === 0) && (ie += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var Oe = Ht();
          Oe ? ie += Oe : ie += gt();
          var de;
          y === null ? de = "null" : we(y) ? de = "array" : y !== void 0 && y.$$typeof === t ? (de = "<" + (V(y.type) || "Unknown") + " />", ie = " Did you accidentally export a JSX literal instead of a component?") : de = typeof y, w("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", de, ie);
        }
        var fe = ct(y, R, G, ae, ue);
        if (fe == null)
          return fe;
        if (se) {
          var ze = R.children;
          if (ze !== void 0)
            if (ne)
              if (we(ze)) {
                for (var Et = 0; Et < ze.length; Et++)
                  kt(ze[Et], y);
                Object.freeze && Object.freeze(ze);
              } else
                w("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              kt(ze, y);
        }
        if (Ae.call(R, "key")) {
          var bt = V(y), je = Object.keys(R).filter(function(Li) {
            return Li !== "key";
          }), Hn = je.length > 0 ? "{key: someKey, " + je.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!re[bt + Hn]) {
            var ki = je.length > 0 ? "{" + je.join(": ..., ") + ": ...}" : "{}";
            w(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, Hn, bt, ki, bt), re[bt + Hn] = !0;
          }
        }
        return y === r ? yt(fe) : Un(fe), fe;
      }
    }
    function Ci(y, R, G) {
      return ao(y, R, G, !0);
    }
    function Oi(y, R, G) {
      return ao(y, R, G, !1);
    }
    var xi = Oi, Ei = Ci;
    wm.Fragment = r, wm.jsx = xi, wm.jsxs = Ei;
  }()), wm;
}
process.env.NODE_ENV === "production" ? U1.exports = lme() : U1.exports = ume();
var Qo = U1.exports;
$e({});
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function zI(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function hi(e) {
  var t, n;
  return zI(e) === !1 ? !1 : (t = e.constructor, t === void 0 ? !0 : (n = t.prototype, !(zI(n) === !1 || n.hasOwnProperty("isPrototypeOf") === !1)));
}
var NX = Symbol.for("immer-nothing"), UI = Symbol.for("immer-draftable"), Ls = Symbol.for("immer-state"), cme = process.env.NODE_ENV !== "production" ? [
  // All error codes, starting by 0:
  function(e) {
    return `The plugin for '${e}' has not been loaded into Immer. To enable the plugin, import and call \`enable${e}()\` when initializing your application.`;
  },
  function(e) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${e}'`;
  },
  "This object has been frozen and should not be mutated",
  function(e) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + e;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(e) {
    return `'current' expects a draft, got: ${e}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(e) {
    return `'original' expects a draft, got: ${e}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function Vi(e, ...t) {
  if (process.env.NODE_ENV !== "production") {
    const n = cme[e], r = typeof n == "function" ? n.apply(null, t) : n;
    throw new Error(`[Immer] ${r}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var Ep = Object.getPrototypeOf;
function Fc(e) {
  return !!e && !!e[Ls];
}
function zc(e) {
  var t;
  return e ? BX(e) || Array.isArray(e) || !!e[UI] || !!((t = e.constructor) != null && t[UI]) || tC(e) || nC(e) : !1;
}
var pme = Object.prototype.constructor.toString();
function BX(e) {
  if (!e || typeof e != "object")
    return !1;
  const t = Ep(e);
  if (t === null)
    return !0;
  const n = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
  return n === Object ? !0 : typeof n == "function" && Function.toString.call(n) === pme;
}
function ab(e, t) {
  eC(e) === 0 ? Reflect.ownKeys(e).forEach((n) => {
    t(n, e[n], e);
  }) : e.forEach((n, r) => t(r, n, e));
}
function eC(e) {
  const t = e[Ls];
  return t ? t.type_ : Array.isArray(e) ? 1 : tC(e) ? 2 : nC(e) ? 3 : 0;
}
function H1(e, t) {
  return eC(e) === 2 ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t);
}
function FX(e, t, n) {
  const r = eC(e);
  r === 2 ? e.set(t, n) : r === 3 ? e.add(n) : e[t] = n;
}
function dme(e, t) {
  return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && t !== t;
}
function tC(e) {
  return e instanceof Map;
}
function nC(e) {
  return e instanceof Set;
}
function ec(e) {
  return e.copy_ || e.base_;
}
function W1(e, t) {
  if (tC(e))
    return new Map(e);
  if (nC(e))
    return new Set(e);
  if (Array.isArray(e))
    return Array.prototype.slice.call(e);
  const n = BX(e);
  if (t === !0 || t === "class_only" && !n) {
    const r = Object.getOwnPropertyDescriptors(e);
    delete r[Ls];
    let o = Reflect.ownKeys(r);
    for (let i = 0; i < o.length; i++) {
      const a = o[i], s = r[a];
      s.writable === !1 && (s.writable = !0, s.configurable = !0), (s.get || s.set) && (r[a] = {
        configurable: !0,
        writable: !0,
        // could live with !!desc.set as well here...
        enumerable: s.enumerable,
        value: e[a]
      });
    }
    return Object.create(Ep(e), r);
  } else {
    const r = Ep(e);
    if (r !== null && n)
      return { ...e };
    const o = Object.create(r);
    return Object.assign(o, e);
  }
}
function lM(e, t = !1) {
  return rC(e) || Fc(e) || !zc(e) || (eC(e) > 1 && (e.set = e.add = e.clear = e.delete = fme), Object.freeze(e), t && Object.entries(e).forEach(([n, r]) => lM(r, !0))), e;
}
function fme() {
  Vi(2);
}
function rC(e) {
  return Object.isFrozen(e);
}
var hme = {};
function Uc(e) {
  const t = hme[e];
  return t || Vi(0, e), t;
}
var ah;
function zX() {
  return ah;
}
function gme(e, t) {
  return {
    drafts_: [],
    parent_: e,
    immer_: t,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0
  };
}
function HI(e, t) {
  t && (Uc("Patches"), e.patches_ = [], e.inversePatches_ = [], e.patchListener_ = t);
}
function $1(e) {
  V1(e), e.drafts_.forEach(mme), e.drafts_ = null;
}
function V1(e) {
  e === ah && (ah = e.parent_);
}
function WI(e) {
  return ah = gme(ah, e);
}
function mme(e) {
  const t = e[Ls];
  t.type_ === 0 || t.type_ === 1 ? t.revoke_() : t.revoked_ = !0;
}
function $I(e, t) {
  t.unfinalizedDrafts_ = t.drafts_.length;
  const n = t.drafts_[0];
  return e !== void 0 && e !== n ? (n[Ls].modified_ && ($1(t), Vi(4)), zc(e) && (e = lb(t, e), t.parent_ || ub(t, e)), t.patches_ && Uc("Patches").generateReplacementPatches_(
    n[Ls].base_,
    e,
    t.patches_,
    t.inversePatches_
  )) : e = lb(t, n, []), $1(t), t.patches_ && t.patchListener_(t.patches_, t.inversePatches_), e !== NX ? e : void 0;
}
function lb(e, t, n) {
  if (rC(t))
    return t;
  const r = t[Ls];
  if (!r)
    return ab(
      t,
      (o, i) => VI(e, r, t, o, i, n)
    ), t;
  if (r.scope_ !== e)
    return t;
  if (!r.modified_)
    return ub(e, r.base_, !0), r.base_;
  if (!r.finalized_) {
    r.finalized_ = !0, r.scope_.unfinalizedDrafts_--;
    const o = r.copy_;
    let i = o, a = !1;
    r.type_ === 3 && (i = new Set(o), o.clear(), a = !0), ab(
      i,
      (s, l) => VI(e, r, o, s, l, n, a)
    ), ub(e, o, !1), n && e.patches_ && Uc("Patches").generatePatches_(
      r,
      n,
      e.patches_,
      e.inversePatches_
    );
  }
  return r.copy_;
}
function VI(e, t, n, r, o, i, a) {
  if (process.env.NODE_ENV !== "production" && o === n && Vi(5), Fc(o)) {
    const s = i && t && t.type_ !== 3 && // Set objects are atomic since they have no keys.
    !H1(t.assigned_, r) ? i.concat(r) : void 0, l = lb(e, o, s);
    if (FX(n, r, l), Fc(l))
      e.canAutoFreeze_ = !1;
    else
      return;
  } else a && n.add(o);
  if (zc(o) && !rC(o)) {
    if (!e.immer_.autoFreeze_ && e.unfinalizedDrafts_ < 1)
      return;
    lb(e, o), (!t || !t.scope_.parent_) && typeof r != "symbol" && Object.prototype.propertyIsEnumerable.call(n, r) && ub(e, o);
  }
}
function ub(e, t, n = !1) {
  !e.parent_ && e.immer_.autoFreeze_ && e.canAutoFreeze_ && lM(t, n);
}
function vme(e, t) {
  const n = Array.isArray(e), r = {
    type_: n ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: t ? t.scope_ : zX(),
    // True for both shallow and deep changes.
    modified_: !1,
    // Used during finalization.
    finalized_: !1,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: t,
    // The base state.
    base_: e,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: !1
  };
  let o = r, i = uM;
  n && (o = [r], i = lh);
  const { revoke: a, proxy: s } = Proxy.revocable(o, i);
  return r.draft_ = s, r.revoke_ = a, s;
}
var uM = {
  get(e, t) {
    if (t === Ls)
      return e;
    const n = ec(e);
    if (!H1(n, t))
      return yme(e, n, t);
    const r = n[t];
    return e.finalized_ || !zc(r) ? r : r === _x(e.base_, t) ? (Px(e), e.copy_[t] = q1(r, e)) : r;
  },
  has(e, t) {
    return t in ec(e);
  },
  ownKeys(e) {
    return Reflect.ownKeys(ec(e));
  },
  set(e, t, n) {
    const r = UX(ec(e), t);
    if (r != null && r.set)
      return r.set.call(e.draft_, n), !0;
    if (!e.modified_) {
      const o = _x(ec(e), t), i = o == null ? void 0 : o[Ls];
      if (i && i.base_ === n)
        return e.copy_[t] = n, e.assigned_[t] = !1, !0;
      if (dme(n, o) && (n !== void 0 || H1(e.base_, t)))
        return !0;
      Px(e), Z1(e);
    }
    return e.copy_[t] === n && // special case: handle new props with value 'undefined'
    (n !== void 0 || t in e.copy_) || // special case: NaN
    Number.isNaN(n) && Number.isNaN(e.copy_[t]) || (e.copy_[t] = n, e.assigned_[t] = !0), !0;
  },
  deleteProperty(e, t) {
    return _x(e.base_, t) !== void 0 || t in e.base_ ? (e.assigned_[t] = !1, Px(e), Z1(e)) : delete e.assigned_[t], e.copy_ && delete e.copy_[t], !0;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(e, t) {
    const n = ec(e), r = Reflect.getOwnPropertyDescriptor(n, t);
    return r && {
      writable: !0,
      configurable: e.type_ !== 1 || t !== "length",
      enumerable: r.enumerable,
      value: n[t]
    };
  },
  defineProperty() {
    Vi(11);
  },
  getPrototypeOf(e) {
    return Ep(e.base_);
  },
  setPrototypeOf() {
    Vi(12);
  }
}, lh = {};
ab(uM, (e, t) => {
  lh[e] = function() {
    return arguments[0] = arguments[0][0], t.apply(this, arguments);
  };
});
lh.deleteProperty = function(e, t) {
  return process.env.NODE_ENV !== "production" && isNaN(parseInt(t)) && Vi(13), lh.set.call(this, e, t, void 0);
};
lh.set = function(e, t, n) {
  return process.env.NODE_ENV !== "production" && t !== "length" && isNaN(parseInt(t)) && Vi(14), uM.set.call(this, e[0], t, n, e[0]);
};
function _x(e, t) {
  const n = e[Ls];
  return (n ? ec(n) : e)[t];
}
function yme(e, t, n) {
  var r;
  const o = UX(t, n);
  return o ? "value" in o ? o.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (r = o.get) == null ? void 0 : r.call(e.draft_)
  ) : void 0;
}
function UX(e, t) {
  if (!(t in e))
    return;
  let n = Ep(e);
  for (; n; ) {
    const r = Object.getOwnPropertyDescriptor(n, t);
    if (r)
      return r;
    n = Ep(n);
  }
}
function Z1(e) {
  e.modified_ || (e.modified_ = !0, e.parent_ && Z1(e.parent_));
}
function Px(e) {
  e.copy_ || (e.copy_ = W1(
    e.base_,
    e.scope_.immer_.useStrictShallowCopy_
  ));
}
var bme = class {
  constructor(e) {
    this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.produce = (t, n, r) => {
      if (typeof t == "function" && typeof n != "function") {
        const i = n;
        n = t;
        const a = this;
        return function(s = i, ...l) {
          return a.produce(s, (u) => n.call(this, u, ...l));
        };
      }
      typeof n != "function" && Vi(6), r !== void 0 && typeof r != "function" && Vi(7);
      let o;
      if (zc(t)) {
        const i = WI(this), a = q1(t, void 0);
        let s = !0;
        try {
          o = n(a), s = !1;
        } finally {
          s ? $1(i) : V1(i);
        }
        return HI(i, r), $I(o, i);
      } else if (!t || typeof t != "object") {
        if (o = n(t), o === void 0 && (o = t), o === NX && (o = void 0), this.autoFreeze_ && lM(o, !0), r) {
          const i = [], a = [];
          Uc("Patches").generateReplacementPatches_(t, o, i, a), r(i, a);
        }
        return o;
      } else
        Vi(1, t);
    }, this.produceWithPatches = (t, n) => {
      if (typeof t == "function")
        return (i, ...a) => this.produceWithPatches(i, (s) => t(s, ...a));
      let r, o;
      return [this.produce(t, n, (i, a) => {
        r = i, o = a;
      }), r, o];
    }, typeof (e == null ? void 0 : e.autoFreeze) == "boolean" && this.setAutoFreeze(e.autoFreeze), typeof (e == null ? void 0 : e.useStrictShallowCopy) == "boolean" && this.setUseStrictShallowCopy(e.useStrictShallowCopy);
  }
  createDraft(e) {
    zc(e) || Vi(8), Fc(e) && (e = wme(e));
    const t = WI(this), n = q1(e, void 0);
    return n[Ls].isManual_ = !0, V1(t), n;
  }
  finishDraft(e, t) {
    const n = e && e[Ls];
    (!n || !n.isManual_) && Vi(9);
    const { scope_: r } = n;
    return HI(r, t), $I(void 0, r);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(e) {
    this.autoFreeze_ = e;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(e) {
    this.useStrictShallowCopy_ = e;
  }
  applyPatches(e, t) {
    let n;
    for (n = t.length - 1; n >= 0; n--) {
      const o = t[n];
      if (o.path.length === 0 && o.op === "replace") {
        e = o.value;
        break;
      }
    }
    n > -1 && (t = t.slice(n + 1));
    const r = Uc("Patches").applyPatches_;
    return Fc(e) ? r(e, t) : this.produce(
      e,
      (o) => r(o, t)
    );
  }
};
function q1(e, t) {
  const n = tC(e) ? Uc("MapSet").proxyMap_(e, t) : nC(e) ? Uc("MapSet").proxySet_(e, t) : vme(e, t);
  return (t ? t.scope_ : zX()).drafts_.push(n), n;
}
function wme(e) {
  return Fc(e) || Vi(10, e), HX(e);
}
function HX(e) {
  if (!zc(e) || rC(e))
    return e;
  const t = e[Ls];
  let n;
  if (t) {
    if (!t.modified_)
      return t.base_;
    t.finalized_ = !0, n = W1(e, t.scope_.immer_.useStrictShallowCopy_);
  } else
    n = W1(e, !0);
  return ab(n, (r, o) => {
    FX(n, r, HX(o));
  }), t && (t.finalized_ = !1), n;
}
var _s = new bme(), cM = _s.produce;
_s.produceWithPatches.bind(
  _s
);
_s.setAutoFreeze.bind(_s);
_s.setUseStrictShallowCopy.bind(_s);
_s.applyPatches.bind(_s);
var ZI = _s.createDraft.bind(_s), qI = _s.finishDraft.bind(_s), Ke = {
  ancestors(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = Ke.levels(e, t);
    return n ? r = r.slice(1) : r = r.slice(0, -1), r;
  },
  common(e, t) {
    for (var n = [], r = 0; r < e.length && r < t.length; r++) {
      var o = e[r], i = t[r];
      if (o !== i)
        break;
      n.push(o);
    }
    return n;
  },
  compare(e, t) {
    for (var n = Math.min(e.length, t.length), r = 0; r < n; r++) {
      if (e[r] < t[r]) return -1;
      if (e[r] > t[r]) return 1;
    }
    return 0;
  },
  endsAfter(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return Ke.equals(r, o) && i > a;
  },
  endsAt(e, t) {
    var n = e.length, r = e.slice(0, n), o = t.slice(0, n);
    return Ke.equals(r, o);
  },
  endsBefore(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return Ke.equals(r, o) && i < a;
  },
  equals(e, t) {
    return e.length === t.length && e.every((n, r) => n === t[r]);
  },
  hasPrevious(e) {
    return e[e.length - 1] > 0;
  },
  isAfter(e, t) {
    return Ke.compare(e, t) === 1;
  },
  isAncestor(e, t) {
    return e.length < t.length && Ke.compare(e, t) === 0;
  },
  isBefore(e, t) {
    return Ke.compare(e, t) === -1;
  },
  isChild(e, t) {
    return e.length === t.length + 1 && Ke.compare(e, t) === 0;
  },
  isCommon(e, t) {
    return e.length <= t.length && Ke.compare(e, t) === 0;
  },
  isDescendant(e, t) {
    return e.length > t.length && Ke.compare(e, t) === 0;
  },
  isParent(e, t) {
    return e.length + 1 === t.length && Ke.compare(e, t) === 0;
  },
  isPath(e) {
    return Array.isArray(e) && (e.length === 0 || typeof e[0] == "number");
  },
  isSibling(e, t) {
    if (e.length !== t.length)
      return !1;
    var n = e.slice(0, -1), r = t.slice(0, -1), o = e[e.length - 1], i = t[t.length - 1];
    return o !== i && Ke.equals(n, r);
  },
  levels(e) {
    for (var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = [], o = 0; o <= e.length; o++)
      r.push(e.slice(0, o));
    return n && r.reverse(), r;
  },
  next(e) {
    if (e.length === 0)
      throw new Error("Cannot get the next path of a root path [".concat(e, "], because it has no next index."));
    var t = e[e.length - 1];
    return e.slice(0, -1).concat(t + 1);
  },
  operationCanTransformPath(e) {
    switch (e.type) {
      case "insert_node":
      case "remove_node":
      case "merge_node":
      case "split_node":
      case "move_node":
        return !0;
      default:
        return !1;
    }
  },
  parent(e) {
    if (e.length === 0)
      throw new Error("Cannot get the parent path of the root path [".concat(e, "]."));
    return e.slice(0, -1);
  },
  previous(e) {
    if (e.length === 0)
      throw new Error("Cannot get the previous path of a root path [".concat(e, "], because it has no previous index."));
    var t = e[e.length - 1];
    if (t <= 0)
      throw new Error("Cannot get the previous path of a first child path [".concat(e, "] because it would result in a negative index."));
    return e.slice(0, -1).concat(t - 1);
  },
  relative(e, t) {
    if (!Ke.isAncestor(t, e) && !Ke.equals(e, t))
      throw new Error("Cannot get the relative path of [".concat(e, "] inside ancestor [").concat(t, "], because it is not above or equal to the path."));
    return e.slice(t.length);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!e) return null;
    var r = [...e], {
      affinity: o = "forward"
    } = n;
    if (e.length === 0)
      return r;
    switch (t.type) {
      case "insert_node": {
        var {
          path: i
        } = t;
        (Ke.equals(i, r) || Ke.endsBefore(i, r) || Ke.isAncestor(i, r)) && (r[i.length - 1] += 1);
        break;
      }
      case "remove_node": {
        var {
          path: a
        } = t;
        if (Ke.equals(a, r) || Ke.isAncestor(a, r))
          return null;
        Ke.endsBefore(a, r) && (r[a.length - 1] -= 1);
        break;
      }
      case "merge_node": {
        var {
          path: s,
          position: l
        } = t;
        Ke.equals(s, r) || Ke.endsBefore(s, r) ? r[s.length - 1] -= 1 : Ke.isAncestor(s, r) && (r[s.length - 1] -= 1, r[s.length] += l);
        break;
      }
      case "split_node": {
        var {
          path: u,
          position: c
        } = t;
        if (Ke.equals(u, r)) {
          if (o === "forward")
            r[r.length - 1] += 1;
          else if (o !== "backward") return null;
        } else Ke.endsBefore(u, r) ? r[u.length - 1] += 1 : Ke.isAncestor(u, r) && e[u.length] >= c && (r[u.length - 1] += 1, r[u.length] -= c);
        break;
      }
      case "move_node": {
        var {
          path: p,
          newPath: d
        } = t;
        if (Ke.equals(p, d))
          return r;
        if (Ke.isAncestor(p, r) || Ke.equals(p, r)) {
          var g = d.slice();
          return Ke.endsBefore(p, d) && p.length < d.length && (g[p.length - 1] -= 1), g.concat(r.slice(p.length));
        } else Ke.isSibling(p, d) && (Ke.isAncestor(d, r) || Ke.equals(d, r)) ? Ke.endsBefore(p, r) ? r[p.length - 1] -= 1 : r[p.length - 1] += 1 : Ke.endsBefore(d, r) || Ke.equals(d, r) || Ke.isAncestor(d, r) ? (Ke.endsBefore(p, r) && (r[p.length - 1] -= 1), r[d.length - 1] += 1) : Ke.endsBefore(p, r) && (Ke.equals(d, r) && (r[d.length - 1] += 1), r[p.length - 1] -= 1);
        break;
      }
    }
    return r;
  }
};
function uh(e) {
  "@babel/helpers - typeof";
  return uh = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, uh(e);
}
function Cme(e, t) {
  if (uh(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (uh(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function Ome(e) {
  var t = Cme(e, "string");
  return uh(t) === "symbol" ? t : String(t);
}
function Ap(e, t, n) {
  return t = Ome(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function GI(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function cd(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? GI(Object(n), !0).forEach(function(r) {
      Ap(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : GI(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var xme = (e, t, n) => {
  switch (n.type) {
    case "insert_node": {
      var {
        path: r,
        node: o
      } = n, i = Mt.parent(e, r), a = r[r.length - 1];
      if (a > i.children.length)
        throw new Error('Cannot apply an "insert_node" operation at path ['.concat(r, "] because the destination is past the end of the node."));
      if (i.children.splice(a, 0, o), t)
        for (var [s, l] of Gt.points(t))
          t[l] = Tr.transform(s, n);
      break;
    }
    case "insert_text": {
      var {
        path: u,
        offset: c,
        text: p
      } = n;
      if (p.length === 0) break;
      var d = Mt.leaf(e, u), g = d.text.slice(0, c), f = d.text.slice(c);
      if (d.text = g + p + f, t)
        for (var [m, b] of Gt.points(t))
          t[b] = Tr.transform(m, n);
      break;
    }
    case "merge_node": {
      var {
        path: E
      } = n, w = Mt.get(e, E), M = Ke.previous(E), x = Mt.get(e, M), v = Mt.parent(e, E), C = E[E.length - 1];
      if (So.isText(w) && So.isText(x))
        x.text += w.text;
      else if (!So.isText(w) && !So.isText(x))
        x.children.push(...w.children);
      else
        throw new Error('Cannot apply a "merge_node" operation at path ['.concat(E, "] to nodes of different interfaces: ").concat(ss.stringify(w), " ").concat(ss.stringify(x)));
      if (v.children.splice(C, 1), t)
        for (var [P, F] of Gt.points(t))
          t[F] = Tr.transform(P, n);
      break;
    }
    case "move_node": {
      var {
        path: L,
        newPath: B
      } = n;
      if (Ke.isAncestor(L, B))
        throw new Error("Cannot move a path [".concat(L, "] to new path [").concat(B, "] because the destination is inside itself."));
      var N = Mt.get(e, L), $ = Mt.parent(e, L), V = L[L.length - 1];
      $.children.splice(V, 1);
      var H = Ke.transform(L, n), Z = Mt.get(e, Ke.parent(H)), K = H[H.length - 1];
      if (Z.children.splice(K, 0, N), t)
        for (var [Y, Q] of Gt.points(t))
          t[Q] = Tr.transform(Y, n);
      break;
    }
    case "remove_node": {
      var {
        path: J
      } = n, _ = J[J.length - 1], D = Mt.parent(e, J);
      if (D.children.splice(_, 1), t)
        for (var [z, S] of Gt.points(t)) {
          var W = Tr.transform(z, n);
          if (t != null && W != null)
            t[S] = W;
          else {
            var O = void 0, j = void 0;
            for (var [U, T] of Mt.texts(e))
              if (Ke.compare(T, J) === -1)
                O = [U, T];
              else {
                j = [U, T];
                break;
              }
            var q = !1;
            O && j && (Ke.equals(j[1], J) ? q = !Ke.hasPrevious(j[1]) : q = Ke.common(O[1], J).length < Ke.common(j[1], J).length), O && !q ? (z.path = O[1], z.offset = O[0].text.length) : j ? (z.path = j[1], z.offset = 0) : t = null;
          }
        }
      break;
    }
    case "remove_text": {
      var {
        path: A,
        offset: X,
        text: I
      } = n;
      if (I.length === 0) break;
      var le = Mt.leaf(e, A), he = le.text.slice(0, X), oe = le.text.slice(X + I.length);
      if (le.text = he + oe, t)
        for (var [Ae, Ue] of Gt.points(t))
          t[Ue] = Tr.transform(Ae, n);
      break;
    }
    case "set_node": {
      var {
        path: He,
        properties: Re,
        newProperties: nt
      } = n;
      if (He.length === 0)
        throw new Error("Cannot set properties on the root node!");
      var Ve = Mt.get(e, He);
      for (var we in nt) {
        if (we === "children" || we === "text")
          throw new Error('Cannot set the "'.concat(we, '" property of nodes!'));
        var et = nt[we];
        et == null ? delete Ve[we] : Ve[we] = et;
      }
      for (var lt in Re)
        nt.hasOwnProperty(lt) || delete Ve[lt];
      break;
    }
    case "set_selection": {
      var {
        newProperties: ye
      } = n;
      if (ye == null)
        t = ye;
      else {
        if (t == null) {
          if (!Gt.isRange(ye))
            throw new Error('Cannot apply an incomplete "set_selection" operation properties '.concat(ss.stringify(ye), " when there is no current selection."));
          t = cd({}, ye);
        }
        for (var ke in ye) {
          var Qe = ye[ke];
          if (Qe == null) {
            if (ke === "anchor" || ke === "focus")
              throw new Error('Cannot remove the "'.concat(ke, '" selection property'));
            delete t[ke];
          } else
            t[ke] = Qe;
        }
      }
      break;
    }
    case "split_node": {
      var {
        path: Fe,
        position: Ie,
        properties: ot
      } = n;
      if (Fe.length === 0)
        throw new Error('Cannot apply a "split_node" operation at path ['.concat(Fe, "] because the root node cannot be split."));
      var Ee = Mt.get(e, Fe), wt = Mt.parent(e, Fe), it = Fe[Fe.length - 1], st;
      if (So.isText(Ee)) {
        var ut = Ee.text.slice(0, Ie), Ct = Ee.text.slice(Ie);
        Ee.text = ut, st = cd(cd({}, ot), {}, {
          text: Ct
        });
      } else {
        var ct = Ee.children.slice(0, Ie), pt = Ee.children.slice(Ie);
        Ee.children = ct, st = cd(cd({}, ot), {}, {
          children: pt
        });
      }
      if (wt.children.splice(it + 1, 0, st), t)
        for (var [rt, We] of Gt.points(t))
          t[We] = Tr.transform(rt, n);
      break;
    }
  }
  return t;
}, Eme = {
  transform(e, t) {
    e.children = ZI(e.children);
    var n = e.selection && ZI(e.selection);
    try {
      n = xme(e, n, t);
    } finally {
      e.children = qI(e.children), n ? e.selection = Fc(n) ? qI(n) : n : e.selection = null;
    }
  }
}, kme = {
  insertNodes(e, t, n) {
    e.insertNodes(t, n);
  },
  liftNodes(e, t) {
    e.liftNodes(t);
  },
  mergeNodes(e, t) {
    e.mergeNodes(t);
  },
  moveNodes(e, t) {
    e.moveNodes(t);
  },
  removeNodes(e, t) {
    e.removeNodes(t);
  },
  setNodes(e, t, n) {
    e.setNodes(t, n);
  },
  splitNodes(e, t) {
    e.splitNodes(t);
  },
  unsetNodes(e, t, n) {
    e.unsetNodes(t, n);
  },
  unwrapNodes(e, t) {
    e.unwrapNodes(t);
  },
  wrapNodes(e, t, n) {
    e.wrapNodes(t, n);
  }
}, Lme = {
  collapse(e, t) {
    e.collapse(t);
  },
  deselect(e) {
    e.deselect();
  },
  move(e, t) {
    e.move(t);
  },
  select(e, t) {
    e.select(t);
  },
  setPoint(e, t, n) {
    e.setPoint(t, n);
  },
  setSelection(e, t) {
    e.setSelection(t);
  }
}, WX = (e, t) => {
  for (var n in e) {
    var r = e[n], o = t[n];
    if (hi(r) && hi(o)) {
      if (!WX(r, o)) return !1;
    } else if (Array.isArray(r) && Array.isArray(o)) {
      if (r.length !== o.length) return !1;
      for (var i = 0; i < r.length; i++)
        if (r[i] !== o[i]) return !1;
    } else if (r !== o)
      return !1;
  }
  for (var a in t)
    if (e[a] === void 0 && t[a] !== void 0)
      return !1;
  return !0;
};
function _me(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), o, i;
  for (i = 0; i < r.length; i++)
    o = r[i], !(t.indexOf(o) >= 0) && (n[o] = e[o]);
  return n;
}
function ch(e, t) {
  if (e == null) return {};
  var n = _me(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (o = 0; o < i.length; o++)
      r = i[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
var Pme = ["anchor", "focus"];
function KI(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Sme(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? KI(Object(n), !0).forEach(function(r) {
      Ap(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : KI(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Gt = {
  edges(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, {
      anchor: r,
      focus: o
    } = e;
    return Gt.isBackward(e) === n ? [r, o] : [o, r];
  },
  end(e) {
    var [, t] = Gt.edges(e);
    return t;
  },
  equals(e, t) {
    return Tr.equals(e.anchor, t.anchor) && Tr.equals(e.focus, t.focus);
  },
  includes(e, t) {
    if (Gt.isRange(t)) {
      if (Gt.includes(e, t.anchor) || Gt.includes(e, t.focus))
        return !0;
      var [n, r] = Gt.edges(e), [o, i] = Gt.edges(t);
      return Tr.isBefore(n, o) && Tr.isAfter(r, i);
    }
    var [a, s] = Gt.edges(e), l = !1, u = !1;
    return Tr.isPoint(t) ? (l = Tr.compare(t, a) >= 0, u = Tr.compare(t, s) <= 0) : (l = Ke.compare(t, a.path) >= 0, u = Ke.compare(t, s.path) <= 0), l && u;
  },
  intersection(e, t) {
    var n = ch(e, Pme), [r, o] = Gt.edges(e), [i, a] = Gt.edges(t), s = Tr.isBefore(r, i) ? i : r, l = Tr.isBefore(o, a) ? o : a;
    return Tr.isBefore(l, s) ? null : Sme({
      anchor: s,
      focus: l
    }, n);
  },
  isBackward(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return Tr.isAfter(t, n);
  },
  isCollapsed(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return Tr.equals(t, n);
  },
  isExpanded(e) {
    return !Gt.isCollapsed(e);
  },
  isForward(e) {
    return !Gt.isBackward(e);
  },
  isRange(e) {
    return hi(e) && Tr.isPoint(e.anchor) && Tr.isPoint(e.focus);
  },
  *points(e) {
    yield [e.anchor, "anchor"], yield [e.focus, "focus"];
  },
  start(e) {
    var [t] = Gt.edges(e);
    return t;
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return cM(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "inward"
      } = n, i, a;
      if (o === "inward") {
        var s = Gt.isCollapsed(r);
        Gt.isForward(r) ? (i = "forward", a = s ? i : "backward") : (i = "backward", a = s ? i : "forward");
      } else o === "outward" ? Gt.isForward(r) ? (i = "backward", a = "forward") : (i = "forward", a = "backward") : (i = o, a = o);
      var l = Tr.transform(r.anchor, t, {
        affinity: i
      }), u = Tr.transform(r.focus, t, {
        affinity: a
      });
      if (!l || !u)
        return null;
      r.anchor = l, r.focus = u;
    });
  }
}, XI = (e) => hi(e) && Mt.isNodeList(e.children) && !ur.isEditor(e), $a = {
  isAncestor(e) {
    return hi(e) && Mt.isNodeList(e.children);
  },
  isElement: XI,
  isElementList(e) {
    return Array.isArray(e) && e.every((t) => $a.isElement(t));
  },
  isElementProps(e) {
    return e.children !== void 0;
  },
  isElementType: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "type";
    return XI(e) && e[n] === t;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "children" && e[n] !== t[n])
        return !1;
    return !0;
  }
}, Mme = ["children"], Dme = ["text"], YI = /* @__PURE__ */ new WeakMap(), Mt = {
  ancestor(e, t) {
    var n = Mt.get(e, t);
    if (So.isText(n))
      throw new Error("Cannot get the ancestor node at path [".concat(t, "] because it refers to a text node instead: ").concat(ss.stringify(n)));
    return n;
  },
  ancestors(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of Ke.ancestors(t, n)) {
        var o = Mt.ancestor(e, r), i = [o, r];
        yield i;
      }
    }();
  },
  child(e, t) {
    if (So.isText(e))
      throw new Error("Cannot get the child of a text node: ".concat(ss.stringify(e)));
    var n = e.children[t];
    if (n == null)
      throw new Error("Cannot get child at index `".concat(t, "` in node: ").concat(ss.stringify(e)));
    return n;
  },
  children(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var {
        reverse: r = !1
      } = n, o = Mt.ancestor(e, t), {
        children: i
      } = o, a = r ? i.length - 1 : 0; r ? a >= 0 : a < i.length; ) {
        var s = Mt.child(o, a), l = t.concat(a);
        yield [s, l], a = r ? a - 1 : a + 1;
      }
    }();
  },
  common(e, t, n) {
    var r = Ke.common(t, n), o = Mt.get(e, r);
    return [o, r];
  },
  descendant(e, t) {
    var n = Mt.get(e, t);
    if (ur.isEditor(n))
      throw new Error("Cannot get the descendant node at path [".concat(t, "] because it refers to the root editor node instead: ").concat(ss.stringify(n)));
    return n;
  },
  descendants(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Mt.nodes(e, t))
        r.length !== 0 && (yield [n, r]);
    }();
  },
  elements(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Mt.nodes(e, t))
        $a.isElement(n) && (yield [n, r]);
    }();
  },
  extractProps(e) {
    if ($a.isAncestor(e)) {
      var t = ch(e, Mme);
      return t;
    } else {
      var t = ch(e, Dme);
      return t;
    }
  },
  first(e, t) {
    for (var n = t.slice(), r = Mt.get(e, n); r && !(So.isText(r) || r.children.length === 0); )
      r = r.children[0], n.push(0);
    return [r, n];
  },
  fragment(e, t) {
    if (So.isText(e))
      throw new Error("Cannot get a fragment starting from a root text node: ".concat(ss.stringify(e)));
    var n = cM({
      children: e.children
    }, (r) => {
      var [o, i] = Gt.edges(t), a = Mt.nodes(r, {
        reverse: !0,
        pass: (d) => {
          var [, g] = d;
          return !Gt.includes(t, g);
        }
      });
      for (var [, s] of a) {
        if (!Gt.includes(t, s)) {
          var l = Mt.parent(r, s), u = s[s.length - 1];
          l.children.splice(u, 1);
        }
        if (Ke.equals(s, i.path)) {
          var c = Mt.leaf(r, s);
          c.text = c.text.slice(0, i.offset);
        }
        if (Ke.equals(s, o.path)) {
          var p = Mt.leaf(r, s);
          p.text = p.text.slice(o.offset);
        }
      }
      ur.isEditor(r) && (r.selection = null);
    });
    return n.children;
  },
  get(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (So.isText(n) || !n.children[o])
        throw new Error("Cannot find a descendant at path [".concat(t, "] in node: ").concat(ss.stringify(e)));
      n = n.children[o];
    }
    return n;
  },
  has(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (So.isText(n) || !n.children[o])
        return !1;
      n = n.children[o];
    }
    return !0;
  },
  isNode(e) {
    return So.isText(e) || $a.isElement(e) || ur.isEditor(e);
  },
  isNodeList(e) {
    if (!Array.isArray(e))
      return !1;
    var t = YI.get(e);
    if (t !== void 0)
      return t;
    var n = e.every((r) => Mt.isNode(r));
    return YI.set(e, n), n;
  },
  last(e, t) {
    for (var n = t.slice(), r = Mt.get(e, n); r && !(So.isText(r) || r.children.length === 0); ) {
      var o = r.children.length - 1;
      r = r.children[o], n.push(o);
    }
    return [r, n];
  },
  leaf(e, t) {
    var n = Mt.get(e, t);
    if (!So.isText(n))
      throw new Error("Cannot get the leaf node at path [".concat(t, "] because it refers to a non-leaf node: ").concat(ss.stringify(n)));
    return n;
  },
  levels(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of Ke.levels(t, n)) {
        var o = Mt.get(e, r);
        yield [o, r];
      }
    }();
  },
  matches(e, t) {
    return $a.isElement(e) && $a.isElementProps(t) && $a.matches(e, t) || So.isText(e) && So.isTextProps(t) && So.matches(e, t);
  },
  nodes(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var {
        pass: n,
        reverse: r = !1
      } = t, {
        from: o = [],
        to: i
      } = t, a = /* @__PURE__ */ new Set(), s = [], l = e; !(i && (r ? Ke.isBefore(s, i) : Ke.isAfter(s, i))); ) {
        if (a.has(l) || (yield [l, s]), !a.has(l) && !So.isText(l) && l.children.length !== 0 && (n == null || n([l, s]) === !1)) {
          a.add(l);
          var u = r ? l.children.length - 1 : 0;
          Ke.isAncestor(s, o) && (u = o[s.length]), s = s.concat(u), l = Mt.get(e, s);
          continue;
        }
        if (s.length === 0)
          break;
        if (!r) {
          var c = Ke.next(s);
          if (Mt.has(e, c)) {
            s = c, l = Mt.get(e, s);
            continue;
          }
        }
        if (r && s[s.length - 1] !== 0) {
          var p = Ke.previous(s);
          s = p, l = Mt.get(e, s);
          continue;
        }
        s = Ke.parent(s), l = Mt.get(e, s), a.add(l);
      }
    }();
  },
  parent(e, t) {
    var n = Ke.parent(t), r = Mt.get(e, n);
    if (So.isText(r))
      throw new Error("Cannot get the parent of path [".concat(t, "] because it does not exist in the root."));
    return r;
  },
  string(e) {
    return So.isText(e) ? e.text : e.children.map(Mt.string).join("");
  },
  texts(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Mt.nodes(e, t))
        So.isText(n) && (yield [n, r]);
    }();
  }
};
function JI(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function zr(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? JI(Object(n), !0).forEach(function(r) {
      Ap(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : JI(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Xd = {
  isNodeOperation(e) {
    return Xd.isOperation(e) && e.type.endsWith("_node");
  },
  isOperation(e) {
    if (!hi(e))
      return !1;
    switch (e.type) {
      case "insert_node":
        return Ke.isPath(e.path) && Mt.isNode(e.node);
      case "insert_text":
        return typeof e.offset == "number" && typeof e.text == "string" && Ke.isPath(e.path);
      case "merge_node":
        return typeof e.position == "number" && Ke.isPath(e.path) && hi(e.properties);
      case "move_node":
        return Ke.isPath(e.path) && Ke.isPath(e.newPath);
      case "remove_node":
        return Ke.isPath(e.path) && Mt.isNode(e.node);
      case "remove_text":
        return typeof e.offset == "number" && typeof e.text == "string" && Ke.isPath(e.path);
      case "set_node":
        return Ke.isPath(e.path) && hi(e.properties) && hi(e.newProperties);
      case "set_selection":
        return e.properties === null && Gt.isRange(e.newProperties) || e.newProperties === null && Gt.isRange(e.properties) || hi(e.properties) && hi(e.newProperties);
      case "split_node":
        return Ke.isPath(e.path) && typeof e.position == "number" && hi(e.properties);
      default:
        return !1;
    }
  },
  isOperationList(e) {
    return Array.isArray(e) && e.every((t) => Xd.isOperation(t));
  },
  isSelectionOperation(e) {
    return Xd.isOperation(e) && e.type.endsWith("_selection");
  },
  isTextOperation(e) {
    return Xd.isOperation(e) && e.type.endsWith("_text");
  },
  inverse(e) {
    switch (e.type) {
      case "insert_node":
        return zr(zr({}, e), {}, {
          type: "remove_node"
        });
      case "insert_text":
        return zr(zr({}, e), {}, {
          type: "remove_text"
        });
      case "merge_node":
        return zr(zr({}, e), {}, {
          type: "split_node",
          path: Ke.previous(e.path)
        });
      case "move_node": {
        var {
          newPath: t,
          path: n
        } = e;
        if (Ke.equals(t, n))
          return e;
        if (Ke.isSibling(n, t))
          return zr(zr({}, e), {}, {
            path: t,
            newPath: n
          });
        var r = Ke.transform(n, e), o = Ke.transform(Ke.next(n), e);
        return zr(zr({}, e), {}, {
          path: r,
          newPath: o
        });
      }
      case "remove_node":
        return zr(zr({}, e), {}, {
          type: "insert_node"
        });
      case "remove_text":
        return zr(zr({}, e), {}, {
          type: "insert_text"
        });
      case "set_node": {
        var {
          properties: i,
          newProperties: a
        } = e;
        return zr(zr({}, e), {}, {
          properties: a,
          newProperties: i
        });
      }
      case "set_selection": {
        var {
          properties: s,
          newProperties: l
        } = e;
        return s == null ? zr(zr({}, e), {}, {
          properties: l,
          newProperties: null
        }) : l == null ? zr(zr({}, e), {}, {
          properties: null,
          newProperties: s
        }) : zr(zr({}, e), {}, {
          properties: l,
          newProperties: s
        });
      }
      case "split_node":
        return zr(zr({}, e), {}, {
          type: "merge_node",
          path: Ke.next(e.path)
        });
    }
  }
}, QI = /* @__PURE__ */ new WeakMap(), Tme = (e) => {
  var t = QI.get(e);
  if (t !== void 0)
    return t;
  if (!hi(e))
    return !1;
  var n = typeof e.addMark == "function" && typeof e.apply == "function" && typeof e.deleteFragment == "function" && typeof e.insertBreak == "function" && typeof e.insertSoftBreak == "function" && typeof e.insertFragment == "function" && typeof e.insertNode == "function" && typeof e.insertText == "function" && typeof e.isElementReadOnly == "function" && typeof e.isInline == "function" && typeof e.isSelectable == "function" && typeof e.isVoid == "function" && typeof e.normalizeNode == "function" && typeof e.onChange == "function" && typeof e.removeMark == "function" && typeof e.getDirtyPaths == "function" && (e.marks === null || hi(e.marks)) && (e.selection === null || Gt.isRange(e.selection)) && Mt.isNodeList(e.children) && Xd.isOperationList(e.operations);
  return QI.set(e, n), n;
}, ur = {
  above(e, t) {
    return e.above(t);
  },
  addMark(e, t, n) {
    e.addMark(t, n);
  },
  after(e, t, n) {
    return e.after(t, n);
  },
  before(e, t, n) {
    return e.before(t, n);
  },
  deleteBackward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteBackward(n);
  },
  deleteForward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteForward(n);
  },
  deleteFragment(e, t) {
    e.deleteFragment(t);
  },
  edges(e, t) {
    return e.edges(t);
  },
  elementReadOnly(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return e.elementReadOnly(t);
  },
  end(e, t) {
    return e.end(t);
  },
  first(e, t) {
    return e.first(t);
  },
  fragment(e, t) {
    return e.fragment(t);
  },
  hasBlocks(e, t) {
    return e.hasBlocks(t);
  },
  hasInlines(e, t) {
    return e.hasInlines(t);
  },
  hasPath(e, t) {
    return e.hasPath(t);
  },
  hasTexts(e, t) {
    return e.hasTexts(t);
  },
  insertBreak(e) {
    e.insertBreak();
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertNode(e, t) {
    e.insertNode(t);
  },
  insertSoftBreak(e) {
    e.insertSoftBreak();
  },
  insertText(e, t) {
    e.insertText(t);
  },
  isBlock(e, t) {
    return e.isBlock(t);
  },
  isEdge(e, t, n) {
    return e.isEdge(t, n);
  },
  isEditor(e) {
    return Tme(e);
  },
  isElementReadOnly(e, t) {
    return e.isElementReadOnly(t);
  },
  isEmpty(e, t) {
    return e.isEmpty(t);
  },
  isEnd(e, t, n) {
    return e.isEnd(t, n);
  },
  isInline(e, t) {
    return e.isInline(t);
  },
  isNormalizing(e) {
    return e.isNormalizing();
  },
  isSelectable(e, t) {
    return e.isSelectable(t);
  },
  isStart(e, t, n) {
    return e.isStart(t, n);
  },
  isVoid(e, t) {
    return e.isVoid(t);
  },
  last(e, t) {
    return e.last(t);
  },
  leaf(e, t, n) {
    return e.leaf(t, n);
  },
  levels(e, t) {
    return e.levels(t);
  },
  marks(e) {
    return e.getMarks();
  },
  next(e, t) {
    return e.next(t);
  },
  node(e, t, n) {
    return e.node(t, n);
  },
  nodes(e, t) {
    return e.nodes(t);
  },
  normalize(e, t) {
    e.normalize(t);
  },
  parent(e, t, n) {
    return e.parent(t, n);
  },
  path(e, t, n) {
    return e.path(t, n);
  },
  pathRef(e, t, n) {
    return e.pathRef(t, n);
  },
  pathRefs(e) {
    return e.pathRefs();
  },
  point(e, t, n) {
    return e.point(t, n);
  },
  pointRef(e, t, n) {
    return e.pointRef(t, n);
  },
  pointRefs(e) {
    return e.pointRefs();
  },
  positions(e, t) {
    return e.positions(t);
  },
  previous(e, t) {
    return e.previous(t);
  },
  range(e, t, n) {
    return e.range(t, n);
  },
  rangeRef(e, t, n) {
    return e.rangeRef(t, n);
  },
  rangeRefs(e) {
    return e.rangeRefs();
  },
  removeMark(e, t) {
    e.removeMark(t);
  },
  setNormalizing(e, t) {
    e.setNormalizing(t);
  },
  start(e, t) {
    return e.start(t);
  },
  string(e, t, n) {
    return e.string(t, n);
  },
  unhangRange(e, t, n) {
    return e.unhangRange(t, n);
  },
  void(e, t) {
    return e.void(t);
  },
  withoutNormalizing(e, t) {
    e.withoutNormalizing(t);
  },
  shouldMergeNodesRemovePrevNode: (e, t, n) => e.shouldMergeNodesRemovePrevNode(t, n)
};
function eN(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function tN(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? eN(Object(n), !0).forEach(function(r) {
      Ap(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : eN(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Tr = {
  compare(e, t) {
    var n = Ke.compare(e.path, t.path);
    return n === 0 ? e.offset < t.offset ? -1 : e.offset > t.offset ? 1 : 0 : n;
  },
  isAfter(e, t) {
    return Tr.compare(e, t) === 1;
  },
  isBefore(e, t) {
    return Tr.compare(e, t) === -1;
  },
  equals(e, t) {
    return e.offset === t.offset && Ke.equals(e.path, t.path);
  },
  isPoint(e) {
    return hi(e) && typeof e.offset == "number" && Ke.isPath(e.path);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return cM(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "forward"
      } = n, {
        path: i,
        offset: a
      } = r;
      switch (t.type) {
        case "insert_node":
        case "move_node": {
          r.path = Ke.transform(i, t, n);
          break;
        }
        case "insert_text": {
          Ke.equals(t.path, i) && (t.offset < a || t.offset === a && o === "forward") && (r.offset += t.text.length);
          break;
        }
        case "merge_node": {
          Ke.equals(t.path, i) && (r.offset += t.position), r.path = Ke.transform(i, t, n);
          break;
        }
        case "remove_text": {
          Ke.equals(t.path, i) && t.offset <= a && (r.offset -= Math.min(a - t.offset, t.text.length));
          break;
        }
        case "remove_node": {
          if (Ke.equals(t.path, i) || Ke.isAncestor(t.path, i))
            return null;
          r.path = Ke.transform(i, t, n);
          break;
        }
        case "split_node": {
          if (Ke.equals(t.path, i)) {
            if (t.position === a && o == null)
              return null;
            (t.position < a || t.position === a && o === "forward") && (r.offset -= t.position, r.path = Ke.transform(i, t, tN(tN({}, n), {}, {
              affinity: "forward"
            })));
          } else
            r.path = Ke.transform(i, t, n);
          break;
        }
      }
    });
  }
}, nN = void 0, ss = {
  setScrubber(e) {
    nN = e;
  },
  stringify(e) {
    return JSON.stringify(e, nN);
  }
}, jme = ["text"], Ame = ["anchor", "focus"];
function rN(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Sa(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? rN(Object(n), !0).forEach(function(r) {
      Ap(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : rN(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var So = {
  equals(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      loose: r = !1
    } = n;
    function o(i) {
      var a = ch(i, jme);
      return a;
    }
    return WX(r ? o(e) : e, r ? o(t) : t);
  },
  isText(e) {
    return hi(e) && typeof e.text == "string";
  },
  isTextList(e) {
    return Array.isArray(e) && e.every((t) => So.isText(t));
  },
  isTextProps(e) {
    return e.text !== void 0;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "text" && (!e.hasOwnProperty(n) || e[n] !== t[n]))
        return !1;
    return !0;
  },
  decorations(e, t) {
    var n = [Sa({}, e)];
    for (var r of t) {
      var o = ch(r, Ame), [i, a] = Gt.edges(r), s = [], l = 0, u = i.offset, c = a.offset;
      for (var p of n) {
        var {
          length: d
        } = p.text, g = l;
        if (l += d, u <= g && l <= c) {
          Object.assign(p, o), s.push(p);
          continue;
        }
        if (u !== c && (u === l || c === g) || u > l || c < g || c === g && g !== 0) {
          s.push(p);
          continue;
        }
        var f = p, m = void 0, b = void 0;
        if (c < l) {
          var E = c - g;
          b = Sa(Sa({}, f), {}, {
            text: f.text.slice(E)
          }), f = Sa(Sa({}, f), {}, {
            text: f.text.slice(0, E)
          });
        }
        if (u > g) {
          var w = u - g;
          m = Sa(Sa({}, f), {}, {
            text: f.text.slice(0, w)
          }), f = Sa(Sa({}, f), {}, {
            text: f.text.slice(w)
          });
        }
        Object.assign(f, o), m && s.push(m), s.push(f), b && s.push(b);
      }
      n = s;
    }
    return n;
  }
}, Rme = (e) => e.selection ? e.selection : e.children.length > 0 ? ur.end(e, []) : [0], kr;
(function(e) {
  e[e.None = 0] = "None", e[e.Extend = 1] = "Extend", e[e.ZWJ = 2] = "ZWJ", e[e.RI = 4] = "RI", e[e.Prepend = 8] = "Prepend", e[e.SpacingMark = 16] = "SpacingMark", e[e.L = 32] = "L", e[e.V = 64] = "V", e[e.T = 128] = "T", e[e.LV = 256] = "LV", e[e.LVT = 512] = "LVT", e[e.ExtPict = 1024] = "ExtPict", e[e.Any = 2048] = "Any";
})(kr || (kr = {}));
kr.L, kr.L | kr.V | kr.LV | kr.LVT, kr.LV | kr.V, kr.V | kr.T, kr.LVT | kr.T, kr.T, kr.Any, kr.Extend | kr.ZWJ, kr.Any, kr.SpacingMark, kr.Prepend, kr.Any, kr.ZWJ, kr.ExtPict, kr.RI, kr.RI;
var Ime = {
  delete(e, t) {
    e.delete(t);
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertText(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    ur.withoutNormalizing(e, () => {
      var {
        voids: r = !1
      } = n, {
        at: o = Rme(e)
      } = n;
      if (Ke.isPath(o) && (o = ur.range(e, o)), Gt.isRange(o))
        if (Gt.isCollapsed(o))
          o = o.anchor;
        else {
          var i = Gt.end(o);
          if (!r && ur.void(e, {
            at: i
          }))
            return;
          var a = Gt.start(o), s = ur.pointRef(e, a), l = ur.pointRef(e, i);
          cb.delete(e, {
            at: o,
            voids: r
          });
          var u = s.unref(), c = l.unref();
          o = u || c, cb.setSelection(e, {
            anchor: o,
            focus: o
          });
        }
      if (!(!r && ur.void(e, {
        at: o
      }) || ur.elementReadOnly(e, {
        at: o
      }))) {
        var {
          path: p,
          offset: d
        } = o;
        t.length > 0 && e.apply({
          type: "insert_text",
          path: p,
          offset: d,
          text: t
        });
      }
    });
  }
};
function oN(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Cm(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? oN(Object(n), !0).forEach(function(r) {
      Ap(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : oN(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var cb = Cm(Cm(Cm(Cm({}, Eme), kme), Lme), Ime), $X = {}, pM = {}, dM = {}, tp = {}, fM = {}, hM = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Doctype = e.CDATA = e.Tag = e.Style = e.Script = e.Comment = e.Directive = e.Text = e.Root = e.isTag = e.ElementType = void 0;
  var t;
  (function(r) {
    r.Root = "root", r.Text = "text", r.Directive = "directive", r.Comment = "comment", r.Script = "script", r.Style = "style", r.Tag = "tag", r.CDATA = "cdata", r.Doctype = "doctype";
  })(t = e.ElementType || (e.ElementType = {}));
  function n(r) {
    return r.type === t.Tag || r.type === t.Script || r.type === t.Style;
  }
  e.isTag = n, e.Root = t.Root, e.Text = t.Text, e.Directive = t.Directive, e.Comment = t.Comment, e.Script = t.Script, e.Style = t.Style, e.Tag = t.Tag, e.CDATA = t.CDATA, e.Doctype = t.Doctype;
})(hM);
var rn = {}, mu = vr && vr.__extends || /* @__PURE__ */ function() {
  var e = function(t, n) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, o) {
      r.__proto__ = o;
    } || function(r, o) {
      for (var i in o) Object.prototype.hasOwnProperty.call(o, i) && (r[i] = o[i]);
    }, e(t, n);
  };
  return function(t, n) {
    if (typeof n != "function" && n !== null)
      throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
    e(t, n);
    function r() {
      this.constructor = t;
    }
    t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
  };
}(), hf = vr && vr.__assign || function() {
  return hf = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) {
      t = arguments[n];
      for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
    }
    return e;
  }, hf.apply(this, arguments);
};
Object.defineProperty(rn, "__esModule", { value: !0 });
rn.cloneNode = rn.hasChildren = rn.isDocument = rn.isDirective = rn.isComment = rn.isText = rn.isCDATA = rn.isTag = rn.Element = rn.Document = rn.CDATA = rn.NodeWithChildren = rn.ProcessingInstruction = rn.Comment = rn.Text = rn.DataNode = rn.Node = void 0;
var Qi = hM, gM = (
  /** @class */
  function() {
    function e() {
      this.parent = null, this.prev = null, this.next = null, this.startIndex = null, this.endIndex = null;
    }
    return Object.defineProperty(e.prototype, "parentNode", {
      // Read-write aliases for properties
      /**
       * Same as {@link parent}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.parent;
      },
      set: function(t) {
        this.parent = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "previousSibling", {
      /**
       * Same as {@link prev}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.prev;
      },
      set: function(t) {
        this.prev = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "nextSibling", {
      /**
       * Same as {@link next}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.next;
      },
      set: function(t) {
        this.next = t;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.cloneNode = function(t) {
      return t === void 0 && (t = !1), mM(this, t);
    }, e;
  }()
);
rn.Node = gM;
var oC = (
  /** @class */
  function(e) {
    mu(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.data = n, r;
    }
    return Object.defineProperty(t.prototype, "nodeValue", {
      /**
       * Same as {@link data}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.data;
      },
      set: function(n) {
        this.data = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(gM)
);
rn.DataNode = oC;
var VX = (
  /** @class */
  function(e) {
    mu(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Qi.ElementType.Text, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 3;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(oC)
);
rn.Text = VX;
var ZX = (
  /** @class */
  function(e) {
    mu(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Qi.ElementType.Comment, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 8;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(oC)
);
rn.Comment = ZX;
var qX = (
  /** @class */
  function(e) {
    mu(t, e);
    function t(n, r) {
      var o = e.call(this, r) || this;
      return o.name = n, o.type = Qi.ElementType.Directive, o;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(oC)
);
rn.ProcessingInstruction = qX;
var iC = (
  /** @class */
  function(e) {
    mu(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.children = n, r;
    }
    return Object.defineProperty(t.prototype, "firstChild", {
      // Aliases
      /** First child of the node. */
      get: function() {
        var n;
        return (n = this.children[0]) !== null && n !== void 0 ? n : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "lastChild", {
      /** Last child of the node. */
      get: function() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "childNodes", {
      /**
       * Same as {@link children}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.children;
      },
      set: function(n) {
        this.children = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(gM)
);
rn.NodeWithChildren = iC;
var GX = (
  /** @class */
  function(e) {
    mu(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Qi.ElementType.CDATA, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 4;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(iC)
);
rn.CDATA = GX;
var KX = (
  /** @class */
  function(e) {
    mu(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Qi.ElementType.Root, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 9;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(iC)
);
rn.Document = KX;
var XX = (
  /** @class */
  function(e) {
    mu(t, e);
    function t(n, r, o, i) {
      o === void 0 && (o = []), i === void 0 && (i = n === "script" ? Qi.ElementType.Script : n === "style" ? Qi.ElementType.Style : Qi.ElementType.Tag);
      var a = e.call(this, o) || this;
      return a.name = n, a.attribs = r, a.type = i, a;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "tagName", {
      // DOM Level 1 aliases
      /**
       * Same as {@link name}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.name;
      },
      set: function(n) {
        this.name = n;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "attributes", {
      get: function() {
        var n = this;
        return Object.keys(this.attribs).map(function(r) {
          var o, i;
          return {
            name: r,
            value: n.attribs[r],
            namespace: (o = n["x-attribsNamespace"]) === null || o === void 0 ? void 0 : o[r],
            prefix: (i = n["x-attribsPrefix"]) === null || i === void 0 ? void 0 : i[r]
          };
        });
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(iC)
);
rn.Element = XX;
function YX(e) {
  return (0, Qi.isTag)(e);
}
rn.isTag = YX;
function JX(e) {
  return e.type === Qi.ElementType.CDATA;
}
rn.isCDATA = JX;
function QX(e) {
  return e.type === Qi.ElementType.Text;
}
rn.isText = QX;
function eY(e) {
  return e.type === Qi.ElementType.Comment;
}
rn.isComment = eY;
function tY(e) {
  return e.type === Qi.ElementType.Directive;
}
rn.isDirective = tY;
function nY(e) {
  return e.type === Qi.ElementType.Root;
}
rn.isDocument = nY;
function Nme(e) {
  return Object.prototype.hasOwnProperty.call(e, "children");
}
rn.hasChildren = Nme;
function mM(e, t) {
  t === void 0 && (t = !1);
  var n;
  if (QX(e))
    n = new VX(e.data);
  else if (eY(e))
    n = new ZX(e.data);
  else if (YX(e)) {
    var r = t ? Sx(e.children) : [], o = new XX(e.name, hf({}, e.attribs), r);
    r.forEach(function(l) {
      return l.parent = o;
    }), e.namespace != null && (o.namespace = e.namespace), e["x-attribsNamespace"] && (o["x-attribsNamespace"] = hf({}, e["x-attribsNamespace"])), e["x-attribsPrefix"] && (o["x-attribsPrefix"] = hf({}, e["x-attribsPrefix"])), n = o;
  } else if (JX(e)) {
    var r = t ? Sx(e.children) : [], i = new GX(r);
    r.forEach(function(u) {
      return u.parent = i;
    }), n = i;
  } else if (nY(e)) {
    var r = t ? Sx(e.children) : [], a = new KX(r);
    r.forEach(function(u) {
      return u.parent = a;
    }), e["x-mode"] && (a["x-mode"] = e["x-mode"]), n = a;
  } else if (tY(e)) {
    var s = new qX(e.name, e.data);
    e["x-name"] != null && (s["x-name"] = e["x-name"], s["x-publicId"] = e["x-publicId"], s["x-systemId"] = e["x-systemId"]), n = s;
  } else
    throw new Error("Not implemented yet: ".concat(e.type));
  return n.startIndex = e.startIndex, n.endIndex = e.endIndex, e.sourceCodeLocation != null && (n.sourceCodeLocation = e.sourceCodeLocation), n;
}
rn.cloneNode = mM;
function Sx(e) {
  for (var t = e.map(function(r) {
    return mM(r, !0);
  }), n = 1; n < t.length; n++)
    t[n].prev = t[n - 1], t[n - 1].next = t[n];
  return t;
}
(function(e) {
  var t = vr && vr.__createBinding || (Object.create ? function(s, l, u, c) {
    c === void 0 && (c = u);
    var p = Object.getOwnPropertyDescriptor(l, u);
    (!p || ("get" in p ? !l.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
      return l[u];
    } }), Object.defineProperty(s, c, p);
  } : function(s, l, u, c) {
    c === void 0 && (c = u), s[c] = l[u];
  }), n = vr && vr.__exportStar || function(s, l) {
    for (var u in s) u !== "default" && !Object.prototype.hasOwnProperty.call(l, u) && t(l, s, u);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.DomHandler = void 0;
  var r = hM, o = rn;
  n(rn, e);
  var i = {
    withStartIndices: !1,
    withEndIndices: !1,
    xmlMode: !1
  }, a = (
    /** @class */
    function() {
      function s(l, u, c) {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null, typeof u == "function" && (c = u, u = i), typeof l == "object" && (u = l, l = void 0), this.callback = l ?? null, this.options = u ?? i, this.elementCB = c ?? null;
      }
      return s.prototype.onparserinit = function(l) {
        this.parser = l;
      }, s.prototype.onreset = function() {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null;
      }, s.prototype.onend = function() {
        this.done || (this.done = !0, this.parser = null, this.handleCallback(null));
      }, s.prototype.onerror = function(l) {
        this.handleCallback(l);
      }, s.prototype.onclosetag = function() {
        this.lastNode = null;
        var l = this.tagStack.pop();
        this.options.withEndIndices && (l.endIndex = this.parser.endIndex), this.elementCB && this.elementCB(l);
      }, s.prototype.onopentag = function(l, u) {
        var c = this.options.xmlMode ? r.ElementType.Tag : void 0, p = new o.Element(l, u, void 0, c);
        this.addNode(p), this.tagStack.push(p);
      }, s.prototype.ontext = function(l) {
        var u = this.lastNode;
        if (u && u.type === r.ElementType.Text)
          u.data += l, this.options.withEndIndices && (u.endIndex = this.parser.endIndex);
        else {
          var c = new o.Text(l);
          this.addNode(c), this.lastNode = c;
        }
      }, s.prototype.oncomment = function(l) {
        if (this.lastNode && this.lastNode.type === r.ElementType.Comment) {
          this.lastNode.data += l;
          return;
        }
        var u = new o.Comment(l);
        this.addNode(u), this.lastNode = u;
      }, s.prototype.oncommentend = function() {
        this.lastNode = null;
      }, s.prototype.oncdatastart = function() {
        var l = new o.Text(""), u = new o.CDATA([l]);
        this.addNode(u), l.parent = u, this.lastNode = l;
      }, s.prototype.oncdataend = function() {
        this.lastNode = null;
      }, s.prototype.onprocessinginstruction = function(l, u) {
        var c = new o.ProcessingInstruction(l, u);
        this.addNode(c);
      }, s.prototype.handleCallback = function(l) {
        if (typeof this.callback == "function")
          this.callback(l, this.dom);
        else if (l)
          throw l;
      }, s.prototype.addNode = function(l) {
        var u = this.tagStack[this.tagStack.length - 1], c = u.children[u.children.length - 1];
        this.options.withStartIndices && (l.startIndex = this.parser.startIndex), this.options.withEndIndices && (l.endIndex = this.parser.endIndex), u.children.push(l), c && (l.prev = c, c.next = l), l.parent = u, this.lastNode = null;
      }, s;
    }()
  );
  e.DomHandler = a, e.default = a;
})(fM);
var rY = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CARRIAGE_RETURN_PLACEHOLDER_REGEX = e.CARRIAGE_RETURN_PLACEHOLDER = e.CARRIAGE_RETURN_REGEX = e.CARRIAGE_RETURN = e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES = void 0, e.CASE_SENSITIVE_TAG_NAMES = [
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "linearGradient",
    "radialGradient",
    "textPath"
  ], e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES.reduce(function(t, n) {
    return t[n.toLowerCase()] = n, t;
  }, {}), e.CARRIAGE_RETURN = "\r", e.CARRIAGE_RETURN_REGEX = new RegExp(e.CARRIAGE_RETURN, "g"), e.CARRIAGE_RETURN_PLACEHOLDER = "__HTML_DOM_PARSER_CARRIAGE_RETURN_PLACEHOLDER_".concat(Date.now(), "__"), e.CARRIAGE_RETURN_PLACEHOLDER_REGEX = new RegExp(e.CARRIAGE_RETURN_PLACEHOLDER, "g");
})(rY);
Object.defineProperty(tp, "__esModule", { value: !0 });
tp.formatAttributes = oY;
tp.escapeSpecialCharacters = zme;
tp.revertEscapedCharacters = iY;
tp.formatDOM = sY;
var Om = fM, ph = rY;
function Bme(e) {
  return ph.CASE_SENSITIVE_TAG_NAMES_MAP[e];
}
function oY(e) {
  for (var t = {}, n = 0, r = e.length; n < r; n++) {
    var o = e[n];
    t[o.name] = o.value;
  }
  return t;
}
function Fme(e) {
  e = e.toLowerCase();
  var t = Bme(e);
  return t || e;
}
function zme(e) {
  return e.replace(ph.CARRIAGE_RETURN_REGEX, ph.CARRIAGE_RETURN_PLACEHOLDER);
}
function iY(e) {
  return e.replace(ph.CARRIAGE_RETURN_PLACEHOLDER_REGEX, ph.CARRIAGE_RETURN);
}
function sY(e, t, n) {
  t === void 0 && (t = null);
  for (var r = [], o, i = 0, a = e.length; i < a; i++) {
    var s = e[i];
    switch (s.nodeType) {
      case 1: {
        var l = Fme(s.nodeName);
        o = new Om.Element(l, oY(s.attributes)), o.children = sY(
          // template children are on content
          l === "template" ? s.content.childNodes : s.childNodes,
          o
        );
        break;
      }
      case 3:
        o = new Om.Text(iY(s.nodeValue));
        break;
      case 8:
        o = new Om.Comment(s.nodeValue);
        break;
      default:
        continue;
    }
    var u = r[i - 1] || null;
    u && (u.next = o), o.parent = t, o.prev = u, o.next = null, r.push(o);
  }
  return n && (o = new Om.ProcessingInstruction(n.substring(0, n.indexOf(" ")).toLowerCase(), n), o.next = r[0] || null, o.parent = t, r.unshift(o), r[1] && (r[1].prev = r[0])), r;
}
Object.defineProperty(dM, "__esModule", { value: !0 });
dM.default = Vme;
var Ume = tp, iN = "html", sN = "head", xm = "body", Hme = /<([a-zA-Z]+[0-9]?)/, aN = /<head[^]*>/i, lN = /<body[^]*>/i, pb = function(e, t) {
  throw new Error("This browser does not support `document.implementation.createHTMLDocument`");
}, G1 = function(e, t) {
  throw new Error("This browser does not support `DOMParser.prototype.parseFromString`");
}, uN = typeof window == "object" && window.DOMParser;
if (typeof uN == "function") {
  var Wme = new uN(), $me = "text/html";
  G1 = function(e, t) {
    return t && (e = "<".concat(t, ">").concat(e, "</").concat(t, ">")), Wme.parseFromString(e, $me);
  }, pb = G1;
}
if (typeof document == "object" && document.implementation) {
  var Em = document.implementation.createHTMLDocument();
  pb = function(e, t) {
    if (t) {
      var n = Em.documentElement.querySelector(t);
      return n && (n.innerHTML = e), Em;
    }
    return Em.documentElement.innerHTML = e, Em;
  };
}
var km = typeof document == "object" && document.createElement("template"), K1;
km && km.content && (K1 = function(e) {
  return km.innerHTML = e, km.content.childNodes;
});
function Vme(e) {
  var t, n;
  e = (0, Ume.escapeSpecialCharacters)(e);
  var r = e.match(Hme), o = r && r[1] ? r[1].toLowerCase() : "";
  switch (o) {
    case iN: {
      var i = G1(e);
      if (!aN.test(e)) {
        var a = i.querySelector(sN);
        (t = a == null ? void 0 : a.parentNode) === null || t === void 0 || t.removeChild(a);
      }
      if (!lN.test(e)) {
        var a = i.querySelector(xm);
        (n = a == null ? void 0 : a.parentNode) === null || n === void 0 || n.removeChild(a);
      }
      return i.querySelectorAll(iN);
    }
    case sN:
    case xm: {
      var s = pb(e).querySelectorAll(o);
      return lN.test(e) && aN.test(e) ? s[0].parentNode.childNodes : s;
    }
    default: {
      if (K1)
        return K1(e);
      var a = pb(e, xm).querySelector(xm);
      return a.childNodes;
    }
  }
}
var Zme = vr && vr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(pM, "__esModule", { value: !0 });
pM.default = Xme;
var qme = Zme(dM), Gme = tp, Kme = /<(![a-zA-Z\s]+)>/;
function Xme(e) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e)
    return [];
  var t = e.match(Kme), n = t ? t[1] : void 0;
  return (0, Gme.formatDOM)((0, qme.default)(e), null, n);
}
var sC = {}, Ks = {}, aC = {}, Yme = 0;
aC.SAME = Yme;
var Jme = 1;
aC.CAMELCASE = Jme;
aC.possibleStandardNames = {
  accept: 0,
  acceptCharset: 1,
  "accept-charset": "acceptCharset",
  accessKey: 1,
  action: 0,
  allowFullScreen: 1,
  alt: 0,
  as: 0,
  async: 0,
  autoCapitalize: 1,
  autoComplete: 1,
  autoCorrect: 1,
  autoFocus: 1,
  autoPlay: 1,
  autoSave: 1,
  capture: 0,
  cellPadding: 1,
  cellSpacing: 1,
  challenge: 0,
  charSet: 1,
  checked: 0,
  children: 0,
  cite: 0,
  class: "className",
  classID: 1,
  className: 1,
  cols: 0,
  colSpan: 1,
  content: 0,
  contentEditable: 1,
  contextMenu: 1,
  controls: 0,
  controlsList: 1,
  coords: 0,
  crossOrigin: 1,
  dangerouslySetInnerHTML: 1,
  data: 0,
  dateTime: 1,
  default: 0,
  defaultChecked: 1,
  defaultValue: 1,
  defer: 0,
  dir: 0,
  disabled: 0,
  disablePictureInPicture: 1,
  disableRemotePlayback: 1,
  download: 0,
  draggable: 0,
  encType: 1,
  enterKeyHint: 1,
  for: "htmlFor",
  form: 0,
  formMethod: 1,
  formAction: 1,
  formEncType: 1,
  formNoValidate: 1,
  formTarget: 1,
  frameBorder: 1,
  headers: 0,
  height: 0,
  hidden: 0,
  high: 0,
  href: 0,
  hrefLang: 1,
  htmlFor: 1,
  httpEquiv: 1,
  "http-equiv": "httpEquiv",
  icon: 0,
  id: 0,
  innerHTML: 1,
  inputMode: 1,
  integrity: 0,
  is: 0,
  itemID: 1,
  itemProp: 1,
  itemRef: 1,
  itemScope: 1,
  itemType: 1,
  keyParams: 1,
  keyType: 1,
  kind: 0,
  label: 0,
  lang: 0,
  list: 0,
  loop: 0,
  low: 0,
  manifest: 0,
  marginWidth: 1,
  marginHeight: 1,
  max: 0,
  maxLength: 1,
  media: 0,
  mediaGroup: 1,
  method: 0,
  min: 0,
  minLength: 1,
  multiple: 0,
  muted: 0,
  name: 0,
  noModule: 1,
  nonce: 0,
  noValidate: 1,
  open: 0,
  optimum: 0,
  pattern: 0,
  placeholder: 0,
  playsInline: 1,
  poster: 0,
  preload: 0,
  profile: 0,
  radioGroup: 1,
  readOnly: 1,
  referrerPolicy: 1,
  rel: 0,
  required: 0,
  reversed: 0,
  role: 0,
  rows: 0,
  rowSpan: 1,
  sandbox: 0,
  scope: 0,
  scoped: 0,
  scrolling: 0,
  seamless: 0,
  selected: 0,
  shape: 0,
  size: 0,
  sizes: 0,
  span: 0,
  spellCheck: 1,
  src: 0,
  srcDoc: 1,
  srcLang: 1,
  srcSet: 1,
  start: 0,
  step: 0,
  style: 0,
  summary: 0,
  tabIndex: 1,
  target: 0,
  title: 0,
  type: 0,
  useMap: 1,
  value: 0,
  width: 0,
  wmode: 0,
  wrap: 0,
  about: 0,
  accentHeight: 1,
  "accent-height": "accentHeight",
  accumulate: 0,
  additive: 0,
  alignmentBaseline: 1,
  "alignment-baseline": "alignmentBaseline",
  allowReorder: 1,
  alphabetic: 0,
  amplitude: 0,
  arabicForm: 1,
  "arabic-form": "arabicForm",
  ascent: 0,
  attributeName: 1,
  attributeType: 1,
  autoReverse: 1,
  azimuth: 0,
  baseFrequency: 1,
  baselineShift: 1,
  "baseline-shift": "baselineShift",
  baseProfile: 1,
  bbox: 0,
  begin: 0,
  bias: 0,
  by: 0,
  calcMode: 1,
  capHeight: 1,
  "cap-height": "capHeight",
  clip: 0,
  clipPath: 1,
  "clip-path": "clipPath",
  clipPathUnits: 1,
  clipRule: 1,
  "clip-rule": "clipRule",
  color: 0,
  colorInterpolation: 1,
  "color-interpolation": "colorInterpolation",
  colorInterpolationFilters: 1,
  "color-interpolation-filters": "colorInterpolationFilters",
  colorProfile: 1,
  "color-profile": "colorProfile",
  colorRendering: 1,
  "color-rendering": "colorRendering",
  contentScriptType: 1,
  contentStyleType: 1,
  cursor: 0,
  cx: 0,
  cy: 0,
  d: 0,
  datatype: 0,
  decelerate: 0,
  descent: 0,
  diffuseConstant: 1,
  direction: 0,
  display: 0,
  divisor: 0,
  dominantBaseline: 1,
  "dominant-baseline": "dominantBaseline",
  dur: 0,
  dx: 0,
  dy: 0,
  edgeMode: 1,
  elevation: 0,
  enableBackground: 1,
  "enable-background": "enableBackground",
  end: 0,
  exponent: 0,
  externalResourcesRequired: 1,
  fill: 0,
  fillOpacity: 1,
  "fill-opacity": "fillOpacity",
  fillRule: 1,
  "fill-rule": "fillRule",
  filter: 0,
  filterRes: 1,
  filterUnits: 1,
  floodOpacity: 1,
  "flood-opacity": "floodOpacity",
  floodColor: 1,
  "flood-color": "floodColor",
  focusable: 0,
  fontFamily: 1,
  "font-family": "fontFamily",
  fontSize: 1,
  "font-size": "fontSize",
  fontSizeAdjust: 1,
  "font-size-adjust": "fontSizeAdjust",
  fontStretch: 1,
  "font-stretch": "fontStretch",
  fontStyle: 1,
  "font-style": "fontStyle",
  fontVariant: 1,
  "font-variant": "fontVariant",
  fontWeight: 1,
  "font-weight": "fontWeight",
  format: 0,
  from: 0,
  fx: 0,
  fy: 0,
  g1: 0,
  g2: 0,
  glyphName: 1,
  "glyph-name": "glyphName",
  glyphOrientationHorizontal: 1,
  "glyph-orientation-horizontal": "glyphOrientationHorizontal",
  glyphOrientationVertical: 1,
  "glyph-orientation-vertical": "glyphOrientationVertical",
  glyphRef: 1,
  gradientTransform: 1,
  gradientUnits: 1,
  hanging: 0,
  horizAdvX: 1,
  "horiz-adv-x": "horizAdvX",
  horizOriginX: 1,
  "horiz-origin-x": "horizOriginX",
  ideographic: 0,
  imageRendering: 1,
  "image-rendering": "imageRendering",
  in2: 0,
  in: 0,
  inlist: 0,
  intercept: 0,
  k1: 0,
  k2: 0,
  k3: 0,
  k4: 0,
  k: 0,
  kernelMatrix: 1,
  kernelUnitLength: 1,
  kerning: 0,
  keyPoints: 1,
  keySplines: 1,
  keyTimes: 1,
  lengthAdjust: 1,
  letterSpacing: 1,
  "letter-spacing": "letterSpacing",
  lightingColor: 1,
  "lighting-color": "lightingColor",
  limitingConeAngle: 1,
  local: 0,
  markerEnd: 1,
  "marker-end": "markerEnd",
  markerHeight: 1,
  markerMid: 1,
  "marker-mid": "markerMid",
  markerStart: 1,
  "marker-start": "markerStart",
  markerUnits: 1,
  markerWidth: 1,
  mask: 0,
  maskContentUnits: 1,
  maskUnits: 1,
  mathematical: 0,
  mode: 0,
  numOctaves: 1,
  offset: 0,
  opacity: 0,
  operator: 0,
  order: 0,
  orient: 0,
  orientation: 0,
  origin: 0,
  overflow: 0,
  overlinePosition: 1,
  "overline-position": "overlinePosition",
  overlineThickness: 1,
  "overline-thickness": "overlineThickness",
  paintOrder: 1,
  "paint-order": "paintOrder",
  panose1: 0,
  "panose-1": "panose1",
  pathLength: 1,
  patternContentUnits: 1,
  patternTransform: 1,
  patternUnits: 1,
  pointerEvents: 1,
  "pointer-events": "pointerEvents",
  points: 0,
  pointsAtX: 1,
  pointsAtY: 1,
  pointsAtZ: 1,
  prefix: 0,
  preserveAlpha: 1,
  preserveAspectRatio: 1,
  primitiveUnits: 1,
  property: 0,
  r: 0,
  radius: 0,
  refX: 1,
  refY: 1,
  renderingIntent: 1,
  "rendering-intent": "renderingIntent",
  repeatCount: 1,
  repeatDur: 1,
  requiredExtensions: 1,
  requiredFeatures: 1,
  resource: 0,
  restart: 0,
  result: 0,
  results: 0,
  rotate: 0,
  rx: 0,
  ry: 0,
  scale: 0,
  security: 0,
  seed: 0,
  shapeRendering: 1,
  "shape-rendering": "shapeRendering",
  slope: 0,
  spacing: 0,
  specularConstant: 1,
  specularExponent: 1,
  speed: 0,
  spreadMethod: 1,
  startOffset: 1,
  stdDeviation: 1,
  stemh: 0,
  stemv: 0,
  stitchTiles: 1,
  stopColor: 1,
  "stop-color": "stopColor",
  stopOpacity: 1,
  "stop-opacity": "stopOpacity",
  strikethroughPosition: 1,
  "strikethrough-position": "strikethroughPosition",
  strikethroughThickness: 1,
  "strikethrough-thickness": "strikethroughThickness",
  string: 0,
  stroke: 0,
  strokeDasharray: 1,
  "stroke-dasharray": "strokeDasharray",
  strokeDashoffset: 1,
  "stroke-dashoffset": "strokeDashoffset",
  strokeLinecap: 1,
  "stroke-linecap": "strokeLinecap",
  strokeLinejoin: 1,
  "stroke-linejoin": "strokeLinejoin",
  strokeMiterlimit: 1,
  "stroke-miterlimit": "strokeMiterlimit",
  strokeWidth: 1,
  "stroke-width": "strokeWidth",
  strokeOpacity: 1,
  "stroke-opacity": "strokeOpacity",
  suppressContentEditableWarning: 1,
  suppressHydrationWarning: 1,
  surfaceScale: 1,
  systemLanguage: 1,
  tableValues: 1,
  targetX: 1,
  targetY: 1,
  textAnchor: 1,
  "text-anchor": "textAnchor",
  textDecoration: 1,
  "text-decoration": "textDecoration",
  textLength: 1,
  textRendering: 1,
  "text-rendering": "textRendering",
  to: 0,
  transform: 0,
  typeof: 0,
  u1: 0,
  u2: 0,
  underlinePosition: 1,
  "underline-position": "underlinePosition",
  underlineThickness: 1,
  "underline-thickness": "underlineThickness",
  unicode: 0,
  unicodeBidi: 1,
  "unicode-bidi": "unicodeBidi",
  unicodeRange: 1,
  "unicode-range": "unicodeRange",
  unitsPerEm: 1,
  "units-per-em": "unitsPerEm",
  unselectable: 0,
  vAlphabetic: 1,
  "v-alphabetic": "vAlphabetic",
  values: 0,
  vectorEffect: 1,
  "vector-effect": "vectorEffect",
  version: 0,
  vertAdvY: 1,
  "vert-adv-y": "vertAdvY",
  vertOriginX: 1,
  "vert-origin-x": "vertOriginX",
  vertOriginY: 1,
  "vert-origin-y": "vertOriginY",
  vHanging: 1,
  "v-hanging": "vHanging",
  vIdeographic: 1,
  "v-ideographic": "vIdeographic",
  viewBox: 1,
  viewTarget: 1,
  visibility: 0,
  vMathematical: 1,
  "v-mathematical": "vMathematical",
  vocab: 0,
  widths: 0,
  wordSpacing: 1,
  "word-spacing": "wordSpacing",
  writingMode: 1,
  "writing-mode": "writingMode",
  x1: 0,
  x2: 0,
  x: 0,
  xChannelSelector: 1,
  xHeight: 1,
  "x-height": "xHeight",
  xlinkActuate: 1,
  "xlink:actuate": "xlinkActuate",
  xlinkArcrole: 1,
  "xlink:arcrole": "xlinkArcrole",
  xlinkHref: 1,
  "xlink:href": "xlinkHref",
  xlinkRole: 1,
  "xlink:role": "xlinkRole",
  xlinkShow: 1,
  "xlink:show": "xlinkShow",
  xlinkTitle: 1,
  "xlink:title": "xlinkTitle",
  xlinkType: 1,
  "xlink:type": "xlinkType",
  xmlBase: 1,
  "xml:base": "xmlBase",
  xmlLang: 1,
  "xml:lang": "xmlLang",
  xmlns: 0,
  "xml:space": "xmlSpace",
  xmlnsXlink: 1,
  "xmlns:xlink": "xmlnsXlink",
  xmlSpace: 1,
  y1: 0,
  y2: 0,
  y: 0,
  yChannelSelector: 1,
  z: 0,
  zoomAndPan: 1
};
const aY = 0, vu = 1, lC = 2, uC = 3, vM = 4, lY = 5, uY = 6;
function Qme(e) {
  return ai.hasOwnProperty(e) ? ai[e] : null;
}
function Ri(e, t, n, r, o, i, a) {
  this.acceptsBooleans = t === lC || t === uC || t === vM, this.attributeName = r, this.attributeNamespace = o, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = i, this.removeEmptyString = a;
}
const ai = {}, eve = [
  "children",
  "dangerouslySetInnerHTML",
  // TODO: This prevents the assignment of defaultValue to regular
  // elements (not just inputs). Now that ReactDOMInput assigns to the
  // defaultValue property -- do we need this?
  "defaultValue",
  "defaultChecked",
  "innerHTML",
  "suppressContentEditableWarning",
  "suppressHydrationWarning",
  "style"
];
eve.forEach((e) => {
  ai[e] = new Ri(
    e,
    aY,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"]
].forEach(([e, t]) => {
  ai[e] = new Ri(
    e,
    vu,
    !1,
    // mustUseProperty
    t,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["contentEditable", "draggable", "spellCheck", "value"].forEach((e) => {
  ai[e] = new Ri(
    e,
    lC,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha"
].forEach((e) => {
  ai[e] = new Ri(
    e,
    lC,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "allowFullScreen",
  "async",
  // Note: there is a special case that prevents it from being written to the DOM
  // on the client side because the browsers are inconsistent. Instead we call focus().
  "autoFocus",
  "autoPlay",
  "controls",
  "default",
  "defer",
  "disabled",
  "disablePictureInPicture",
  "disableRemotePlayback",
  "formNoValidate",
  "hidden",
  "loop",
  "noModule",
  "noValidate",
  "open",
  "playsInline",
  "readOnly",
  "required",
  "reversed",
  "scoped",
  "seamless",
  // Microdata
  "itemScope"
].forEach((e) => {
  ai[e] = new Ri(
    e,
    uC,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "checked",
  // Note: `option.selected` is not updated if `select.multiple` is
  // disabled with `removeAttribute`. We have special logic for handling this.
  "multiple",
  "muted",
  "selected"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  ai[e] = new Ri(
    e,
    uC,
    !0,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "capture",
  "download"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  ai[e] = new Ri(
    e,
    vM,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "cols",
  "rows",
  "size",
  "span"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  ai[e] = new Ri(
    e,
    uY,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["rowSpan", "start"].forEach((e) => {
  ai[e] = new Ri(
    e,
    lY,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const yM = /[\-\:]([a-z])/g, bM = (e) => e[1].toUpperCase();
[
  "accent-height",
  "alignment-baseline",
  "arabic-form",
  "baseline-shift",
  "cap-height",
  "clip-path",
  "clip-rule",
  "color-interpolation",
  "color-interpolation-filters",
  "color-profile",
  "color-rendering",
  "dominant-baseline",
  "enable-background",
  "fill-opacity",
  "fill-rule",
  "flood-color",
  "flood-opacity",
  "font-family",
  "font-size",
  "font-size-adjust",
  "font-stretch",
  "font-style",
  "font-variant",
  "font-weight",
  "glyph-name",
  "glyph-orientation-horizontal",
  "glyph-orientation-vertical",
  "horiz-adv-x",
  "horiz-origin-x",
  "image-rendering",
  "letter-spacing",
  "lighting-color",
  "marker-end",
  "marker-mid",
  "marker-start",
  "overline-position",
  "overline-thickness",
  "paint-order",
  "panose-1",
  "pointer-events",
  "rendering-intent",
  "shape-rendering",
  "stop-color",
  "stop-opacity",
  "strikethrough-position",
  "strikethrough-thickness",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "text-anchor",
  "text-decoration",
  "text-rendering",
  "underline-position",
  "underline-thickness",
  "unicode-bidi",
  "unicode-range",
  "units-per-em",
  "v-alphabetic",
  "v-hanging",
  "v-ideographic",
  "v-mathematical",
  "vector-effect",
  "vert-adv-y",
  "vert-origin-x",
  "vert-origin-y",
  "word-spacing",
  "writing-mode",
  "xmlns:xlink",
  "x-height"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(yM, bM);
  ai[t] = new Ri(
    t,
    vu,
    !1,
    // mustUseProperty
    e,
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xlink:actuate",
  "xlink:arcrole",
  "xlink:role",
  "xlink:show",
  "xlink:title",
  "xlink:type"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(yM, bM);
  ai[t] = new Ri(
    t,
    vu,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/1999/xlink",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xml:base",
  "xml:lang",
  "xml:space"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(yM, bM);
  ai[t] = new Ri(
    t,
    vu,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/XML/1998/namespace",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["tabIndex", "crossOrigin"].forEach((e) => {
  ai[e] = new Ri(
    e,
    vu,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const tve = "xlinkHref";
ai[tve] = new Ri(
  "xlinkHref",
  vu,
  !1,
  // mustUseProperty
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  // sanitizeURL
  !1
  // removeEmptyString
);
["src", "href", "action", "formAction"].forEach((e) => {
  ai[e] = new Ri(
    e,
    vu,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !0,
    // sanitizeURL
    !0
    // removeEmptyString
  );
});
const {
  CAMELCASE: nve,
  SAME: rve,
  possibleStandardNames: cN
} = aC, ove = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", ive = ove + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", sve = RegExp.prototype.test.bind(
  // eslint-disable-next-line no-misleading-character-class
  new RegExp("^(data|aria)-[" + ive + "]*$")
), ave = Object.keys(
  cN
).reduce((e, t) => {
  const n = cN[t];
  return n === rve ? e[t] = t : n === nve ? e[t.toLowerCase()] = t : e[t] = n, e;
}, {});
Ks.BOOLEAN = uC;
Ks.BOOLEANISH_STRING = lC;
Ks.NUMERIC = lY;
Ks.OVERLOADED_BOOLEAN = vM;
Ks.POSITIVE_NUMERIC = uY;
Ks.RESERVED = aY;
Ks.STRING = vu;
Ks.getPropertyInfo = Qme;
Ks.isCustomAttribute = sve;
Ks.possibleStandardNames = ave;
var wM = {}, CM = {}, pN = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, lve = /\n/g, uve = /^\s*/, cve = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, pve = /^:\s*/, dve = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, fve = /^[;\s]*/, hve = /^\s+|\s+$/g, gve = `
`, dN = "/", fN = "*", uc = "", mve = "comment", vve = "declaration", yve = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e) return [];
  t = t || {};
  var n = 1, r = 1;
  function o(f) {
    var m = f.match(lve);
    m && (n += m.length);
    var b = f.lastIndexOf(gve);
    r = ~b ? f.length - b : r + f.length;
  }
  function i() {
    var f = { line: n, column: r };
    return function(m) {
      return m.position = new a(f), u(), m;
    };
  }
  function a(f) {
    this.start = f, this.end = { line: n, column: r }, this.source = t.source;
  }
  a.prototype.content = e;
  function s(f) {
    var m = new Error(
      t.source + ":" + n + ":" + r + ": " + f
    );
    if (m.reason = f, m.filename = t.source, m.line = n, m.column = r, m.source = e, !t.silent) throw m;
  }
  function l(f) {
    var m = f.exec(e);
    if (m) {
      var b = m[0];
      return o(b), e = e.slice(b.length), m;
    }
  }
  function u() {
    l(uve);
  }
  function c(f) {
    var m;
    for (f = f || []; m = p(); )
      m !== !1 && f.push(m);
    return f;
  }
  function p() {
    var f = i();
    if (!(dN != e.charAt(0) || fN != e.charAt(1))) {
      for (var m = 2; uc != e.charAt(m) && (fN != e.charAt(m) || dN != e.charAt(m + 1)); )
        ++m;
      if (m += 2, uc === e.charAt(m - 1))
        return s("End of comment missing");
      var b = e.slice(2, m - 2);
      return r += 2, o(b), e = e.slice(m), r += 2, f({
        type: mve,
        comment: b
      });
    }
  }
  function d() {
    var f = i(), m = l(cve);
    if (m) {
      if (p(), !l(pve)) return s("property missing ':'");
      var b = l(dve), E = f({
        type: vve,
        property: hN(m[0].replace(pN, uc)),
        value: b ? hN(b[0].replace(pN, uc)) : uc
      });
      return l(fve), E;
    }
  }
  function g() {
    var f = [];
    c(f);
    for (var m; m = d(); )
      m !== !1 && (f.push(m), c(f));
    return f;
  }
  return u(), g();
};
function hN(e) {
  return e ? e.replace(hve, uc) : uc;
}
var bve = vr && vr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(CM, "__esModule", { value: !0 });
CM.default = Cve;
var wve = bve(yve);
function Cve(e, t) {
  var n = null;
  if (!e || typeof e != "string")
    return n;
  var r = (0, wve.default)(e), o = typeof t == "function";
  return r.forEach(function(i) {
    if (i.type === "declaration") {
      var a = i.property, s = i.value;
      o ? t(a, s, i) : s && (n = n || {}, n[a] = s);
    }
  }), n;
}
var cC = {};
Object.defineProperty(cC, "__esModule", { value: !0 });
cC.camelCase = void 0;
var Ove = /^--[a-zA-Z0-9_-]+$/, xve = /-([a-z])/g, Eve = /^[^-]+$/, kve = /^-(webkit|moz|ms|o|khtml)-/, Lve = /^-(ms)-/, _ve = function(e) {
  return !e || Eve.test(e) || Ove.test(e);
}, Pve = function(e, t) {
  return t.toUpperCase();
}, gN = function(e, t) {
  return "".concat(t, "-");
}, Sve = function(e, t) {
  return t === void 0 && (t = {}), _ve(e) ? e : (e = e.toLowerCase(), t.reactCompat ? e = e.replace(Lve, gN) : e = e.replace(kve, gN), e.replace(xve, Pve));
};
cC.camelCase = Sve;
var Mve = vr && vr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
}, Dve = Mve(CM), Tve = cC;
function X1(e, t) {
  var n = {};
  return !e || typeof e != "string" || (0, Dve.default)(e, function(r, o) {
    r && o && (n[(0, Tve.camelCase)(r, t)] = o);
  }), n;
}
X1.default = X1;
var jve = X1;
(function(e) {
  var t = vr && vr.__importDefault || function(c) {
    return c && c.__esModule ? c : { default: c };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.returnFirstArg = e.canTextBeChildOfNode = e.ELEMENTS_WITH_NO_TEXT_CHILDREN = e.PRESERVE_CUSTOM_ATTRIBUTES = void 0, e.isCustomComponent = i, e.setStyleProp = s;
  var n = be, r = t(jve), o = /* @__PURE__ */ new Set([
    "annotation-xml",
    "color-profile",
    "font-face",
    "font-face-src",
    "font-face-uri",
    "font-face-format",
    "font-face-name",
    "missing-glyph"
  ]);
  function i(c, p) {
    return c.includes("-") ? !o.has(c) : !!(p && typeof p.is == "string");
  }
  var a = {
    reactCompat: !0
  };
  function s(c, p) {
    if (typeof c == "string") {
      if (!c.trim()) {
        p.style = {};
        return;
      }
      try {
        p.style = (0, r.default)(c, a);
      } catch {
        p.style = {};
      }
    }
  }
  e.PRESERVE_CUSTOM_ATTRIBUTES = Number(n.version.split(".")[0]) >= 16, e.ELEMENTS_WITH_NO_TEXT_CHILDREN = /* @__PURE__ */ new Set([
    "tr",
    "tbody",
    "thead",
    "tfoot",
    "colgroup",
    "table",
    "head",
    "html",
    "frameset"
  ]);
  var l = function(c) {
    return !e.ELEMENTS_WITH_NO_TEXT_CHILDREN.has(c.name);
  };
  e.canTextBeChildOfNode = l;
  var u = function(c) {
    return c;
  };
  e.returnFirstArg = u;
})(wM);
Object.defineProperty(sC, "__esModule", { value: !0 });
sC.default = Nve;
var Yd = Ks, mN = wM, Ave = ["checked", "value"], Rve = ["input", "select", "textarea"], Ive = {
  reset: !0,
  submit: !0
};
function Nve(e, t) {
  e === void 0 && (e = {});
  var n = {}, r = !!(e.type && Ive[e.type]);
  for (var o in e) {
    var i = e[o];
    if ((0, Yd.isCustomAttribute)(o)) {
      n[o] = i;
      continue;
    }
    var a = o.toLowerCase(), s = vN(a);
    if (s) {
      var l = (0, Yd.getPropertyInfo)(s);
      switch (Ave.includes(s) && Rve.includes(t) && !r && (s = vN("default" + a)), n[s] = i, l && l.type) {
        case Yd.BOOLEAN:
          n[s] = !0;
          break;
        case Yd.OVERLOADED_BOOLEAN:
          i === "" && (n[s] = !0);
          break;
      }
      continue;
    }
    mN.PRESERVE_CUSTOM_ATTRIBUTES && (n[o] = i);
  }
  return (0, mN.setStyleProp)(e.style, n), n;
}
function vN(e) {
  return Yd.possibleStandardNames[e];
}
var OM = {}, Bve = vr && vr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(OM, "__esModule", { value: !0 });
OM.default = cY;
var Mx = be, Fve = Bve(sC), gf = wM, zve = {
  cloneElement: Mx.cloneElement,
  createElement: Mx.createElement,
  isValidElement: Mx.isValidElement
};
function cY(e, t) {
  t === void 0 && (t = {});
  for (var n = [], r = typeof t.replace == "function", o = t.transform || gf.returnFirstArg, i = t.library || zve, a = i.cloneElement, s = i.createElement, l = i.isValidElement, u = e.length, c = 0; c < u; c++) {
    var p = e[c];
    if (r) {
      var d = t.replace(p, c);
      if (l(d)) {
        u > 1 && (d = a(d, {
          key: d.key || c
        })), n.push(o(d, p, c));
        continue;
      }
    }
    if (p.type === "text") {
      var g = !p.data.trim().length;
      if (g && p.parent && !(0, gf.canTextBeChildOfNode)(p.parent) || t.trim && g)
        continue;
      n.push(o(p.data, p, c));
      continue;
    }
    var f = p, m = {};
    Uve(f) ? ((0, gf.setStyleProp)(f.attribs.style, f.attribs), m = f.attribs) : f.attribs && (m = (0, Fve.default)(f.attribs, f.name));
    var b = void 0;
    switch (p.type) {
      case "script":
      case "style":
        p.children[0] && (m.dangerouslySetInnerHTML = {
          __html: p.children[0].data
        });
        break;
      case "tag":
        p.name === "textarea" && p.children[0] ? m.defaultValue = p.children[0].data : p.children && p.children.length && (b = cY(p.children, t));
        break;
      default:
        continue;
    }
    u > 1 && (m.key = c), n.push(o(s(p.name, m, b), p, c));
  }
  return n.length === 1 ? n[0] : n;
}
function Uve(e) {
  return gf.PRESERVE_CUSTOM_ATTRIBUTES && e.type === "tag" && (0, gf.isCustomComponent)(e.name, e.attribs);
}
(function(e) {
  var t = vr && vr.__importDefault || function(l) {
    return l && l.__esModule ? l : { default: l };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.htmlToDOM = e.domToReact = e.attributesToProps = e.Text = e.ProcessingInstruction = e.Element = e.Comment = void 0, e.default = s;
  var n = t(pM);
  e.htmlToDOM = n.default;
  var r = t(sC);
  e.attributesToProps = r.default;
  var o = t(OM);
  e.domToReact = o.default;
  var i = fM;
  Object.defineProperty(e, "Comment", { enumerable: !0, get: function() {
    return i.Comment;
  } }), Object.defineProperty(e, "Element", { enumerable: !0, get: function() {
    return i.Element;
  } }), Object.defineProperty(e, "ProcessingInstruction", { enumerable: !0, get: function() {
    return i.ProcessingInstruction;
  } }), Object.defineProperty(e, "Text", { enumerable: !0, get: function() {
    return i.Text;
  } });
  var a = { lowerCaseAttributeNames: !1 };
  function s(l, u) {
    if (typeof l != "string")
      throw new TypeError("First argument must be a string");
    return l ? (0, o.default)((0, n.default)(l, (u == null ? void 0 : u.htmlparser2) || a), u) : [];
  }
})($X);
const Hve = /* @__PURE__ */ ame($X);
Hve.default;
var yr = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Wve(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var Y1 = { exports: {} }, pd = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var yN;
function $ve() {
  if (yN) return pd;
  yN = 1;
  var e = be, t = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, o = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, i = { key: !0, ref: !0, __self: !0, __source: !0 };
  function a(s, l, u) {
    var c, p = {}, d = null, g = null;
    u !== void 0 && (d = "" + u), l.key !== void 0 && (d = "" + l.key), l.ref !== void 0 && (g = l.ref);
    for (c in l) r.call(l, c) && !i.hasOwnProperty(c) && (p[c] = l[c]);
    if (s && s.defaultProps) for (c in l = s.defaultProps, l) p[c] === void 0 && (p[c] = l[c]);
    return { $$typeof: t, type: s, key: d, ref: g, props: p, _owner: o.current };
  }
  return pd.Fragment = n, pd.jsx = a, pd.jsxs = a, pd;
}
var Lm = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var bN;
function Vve() {
  return bN || (bN = 1, process.env.NODE_ENV !== "production" && function() {
    var e = be, t = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), a = Symbol.for("react.provider"), s = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), c = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), d = Symbol.for("react.lazy"), g = Symbol.for("react.offscreen"), f = Symbol.iterator, m = "@@iterator";
    function b(y) {
      if (y === null || typeof y != "object")
        return null;
      var R = f && y[f] || y[m];
      return typeof R == "function" ? R : null;
    }
    var E = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function w(y) {
      {
        for (var R = arguments.length, G = new Array(R > 1 ? R - 1 : 0), ne = 1; ne < R; ne++)
          G[ne - 1] = arguments[ne];
        M("error", y, G);
      }
    }
    function M(y, R, G) {
      {
        var ne = E.ReactDebugCurrentFrame, ae = ne.getStackAddendum();
        ae !== "" && (R += "%s", G = G.concat([ae]));
        var ue = G.map(function(se) {
          return String(se);
        });
        ue.unshift("Warning: " + R), Function.prototype.apply.call(console[y], console, ue);
      }
    }
    var x = !1, v = !1, C = !1, P = !1, F = !1, L;
    L = Symbol.for("react.module.reference");
    function B(y) {
      return !!(typeof y == "string" || typeof y == "function" || y === r || y === i || F || y === o || y === u || y === c || P || y === g || x || v || C || typeof y == "object" && y !== null && (y.$$typeof === d || y.$$typeof === p || y.$$typeof === a || y.$$typeof === s || y.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      y.$$typeof === L || y.getModuleId !== void 0));
    }
    function N(y, R, G) {
      var ne = y.displayName;
      if (ne)
        return ne;
      var ae = R.displayName || R.name || "";
      return ae !== "" ? G + "(" + ae + ")" : G;
    }
    function $(y) {
      return y.displayName || "Context";
    }
    function V(y) {
      if (y == null)
        return null;
      if (typeof y.tag == "number" && w("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof y == "function")
        return y.displayName || y.name || null;
      if (typeof y == "string")
        return y;
      switch (y) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case i:
          return "Profiler";
        case o:
          return "StrictMode";
        case u:
          return "Suspense";
        case c:
          return "SuspenseList";
      }
      if (typeof y == "object")
        switch (y.$$typeof) {
          case s:
            var R = y;
            return $(R) + ".Consumer";
          case a:
            var G = y;
            return $(G._context) + ".Provider";
          case l:
            return N(y, y.render, "ForwardRef");
          case p:
            var ne = y.displayName || null;
            return ne !== null ? ne : V(y.type) || "Memo";
          case d: {
            var ae = y, ue = ae._payload, se = ae._init;
            try {
              return V(se(ue));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var H = Object.assign, Z = 0, K, Y, Q, J, _, D, z;
    function S() {
    }
    S.__reactDisabledLog = !0;
    function W() {
      {
        if (Z === 0) {
          K = console.log, Y = console.info, Q = console.warn, J = console.error, _ = console.group, D = console.groupCollapsed, z = console.groupEnd;
          var y = {
            configurable: !0,
            enumerable: !0,
            value: S,
            writable: !0
          };
          Object.defineProperties(console, {
            info: y,
            log: y,
            warn: y,
            error: y,
            group: y,
            groupCollapsed: y,
            groupEnd: y
          });
        }
        Z++;
      }
    }
    function O() {
      {
        if (Z--, Z === 0) {
          var y = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: H({}, y, {
              value: K
            }),
            info: H({}, y, {
              value: Y
            }),
            warn: H({}, y, {
              value: Q
            }),
            error: H({}, y, {
              value: J
            }),
            group: H({}, y, {
              value: _
            }),
            groupCollapsed: H({}, y, {
              value: D
            }),
            groupEnd: H({}, y, {
              value: z
            })
          });
        }
        Z < 0 && w("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var j = E.ReactCurrentDispatcher, U;
    function T(y, R, G) {
      {
        if (U === void 0)
          try {
            throw Error();
          } catch (ae) {
            var ne = ae.stack.trim().match(/\n( *(at )?)/);
            U = ne && ne[1] || "";
          }
        return `
` + U + y;
      }
    }
    var q = !1, A;
    {
      var X = typeof WeakMap == "function" ? WeakMap : Map;
      A = new X();
    }
    function I(y, R) {
      if (!y || q)
        return "";
      {
        var G = A.get(y);
        if (G !== void 0)
          return G;
      }
      var ne;
      q = !0;
      var ae = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var ue;
      ue = j.current, j.current = null, W();
      try {
        if (R) {
          var se = function() {
            throw Error();
          };
          if (Object.defineProperty(se.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(se, []);
            } catch (je) {
              ne = je;
            }
            Reflect.construct(y, [], se);
          } else {
            try {
              se.call();
            } catch (je) {
              ne = je;
            }
            y.call(se.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (je) {
            ne = je;
          }
          y();
        }
      } catch (je) {
        if (je && ne && typeof je.stack == "string") {
          for (var ie = je.stack.split(`
`), Oe = ne.stack.split(`
`), de = ie.length - 1, fe = Oe.length - 1; de >= 1 && fe >= 0 && ie[de] !== Oe[fe]; )
            fe--;
          for (; de >= 1 && fe >= 0; de--, fe--)
            if (ie[de] !== Oe[fe]) {
              if (de !== 1 || fe !== 1)
                do
                  if (de--, fe--, fe < 0 || ie[de] !== Oe[fe]) {
                    var ze = `
` + ie[de].replace(" at new ", " at ");
                    return y.displayName && ze.includes("<anonymous>") && (ze = ze.replace("<anonymous>", y.displayName)), typeof y == "function" && A.set(y, ze), ze;
                  }
                while (de >= 1 && fe >= 0);
              break;
            }
        }
      } finally {
        q = !1, j.current = ue, O(), Error.prepareStackTrace = ae;
      }
      var Et = y ? y.displayName || y.name : "", bt = Et ? T(Et) : "";
      return typeof y == "function" && A.set(y, bt), bt;
    }
    function le(y, R, G) {
      return I(y, !1);
    }
    function he(y) {
      var R = y.prototype;
      return !!(R && R.isReactComponent);
    }
    function oe(y, R, G) {
      if (y == null)
        return "";
      if (typeof y == "function")
        return I(y, he(y));
      if (typeof y == "string")
        return T(y);
      switch (y) {
        case u:
          return T("Suspense");
        case c:
          return T("SuspenseList");
      }
      if (typeof y == "object")
        switch (y.$$typeof) {
          case l:
            return le(y.render);
          case p:
            return oe(y.type, R, G);
          case d: {
            var ne = y, ae = ne._payload, ue = ne._init;
            try {
              return oe(ue(ae), R, G);
            } catch {
            }
          }
        }
      return "";
    }
    var Ae = Object.prototype.hasOwnProperty, Ue = {}, He = E.ReactDebugCurrentFrame;
    function Re(y) {
      if (y) {
        var R = y._owner, G = oe(y.type, y._source, R ? R.type : null);
        He.setExtraStackFrame(G);
      } else
        He.setExtraStackFrame(null);
    }
    function nt(y, R, G, ne, ae) {
      {
        var ue = Function.call.bind(Ae);
        for (var se in y)
          if (ue(y, se)) {
            var ie = void 0;
            try {
              if (typeof y[se] != "function") {
                var Oe = Error((ne || "React class") + ": " + G + " type `" + se + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof y[se] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw Oe.name = "Invariant Violation", Oe;
              }
              ie = y[se](R, se, ne, G, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (de) {
              ie = de;
            }
            ie && !(ie instanceof Error) && (Re(ae), w("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", ne || "React class", G, se, typeof ie), Re(null)), ie instanceof Error && !(ie.message in Ue) && (Ue[ie.message] = !0, Re(ae), w("Failed %s type: %s", G, ie.message), Re(null));
          }
      }
    }
    var Ve = Array.isArray;
    function we(y) {
      return Ve(y);
    }
    function et(y) {
      {
        var R = typeof Symbol == "function" && Symbol.toStringTag, G = R && y[Symbol.toStringTag] || y.constructor.name || "Object";
        return G;
      }
    }
    function lt(y) {
      try {
        return ye(y), !1;
      } catch {
        return !0;
      }
    }
    function ye(y) {
      return "" + y;
    }
    function ke(y) {
      if (lt(y))
        return w("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", et(y)), ye(y);
    }
    var Qe = E.ReactCurrentOwner, Fe = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, Ie, ot;
    function Ee(y) {
      if (Ae.call(y, "ref")) {
        var R = Object.getOwnPropertyDescriptor(y, "ref").get;
        if (R && R.isReactWarning)
          return !1;
      }
      return y.ref !== void 0;
    }
    function wt(y) {
      if (Ae.call(y, "key")) {
        var R = Object.getOwnPropertyDescriptor(y, "key").get;
        if (R && R.isReactWarning)
          return !1;
      }
      return y.key !== void 0;
    }
    function it(y, R) {
      typeof y.ref == "string" && Qe.current;
    }
    function st(y, R) {
      {
        var G = function() {
          Ie || (Ie = !0, w("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", R));
        };
        G.isReactWarning = !0, Object.defineProperty(y, "key", {
          get: G,
          configurable: !0
        });
      }
    }
    function ut(y, R) {
      {
        var G = function() {
          ot || (ot = !0, w("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", R));
        };
        G.isReactWarning = !0, Object.defineProperty(y, "ref", {
          get: G,
          configurable: !0
        });
      }
    }
    var Ct = function(y, R, G, ne, ae, ue, se) {
      var ie = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: y,
        key: R,
        ref: G,
        props: se,
        // Record the component responsible for creating this element.
        _owner: ue
      };
      return ie._store = {}, Object.defineProperty(ie._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(ie, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ne
      }), Object.defineProperty(ie, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ae
      }), Object.freeze && (Object.freeze(ie.props), Object.freeze(ie)), ie;
    };
    function ct(y, R, G, ne, ae) {
      {
        var ue, se = {}, ie = null, Oe = null;
        G !== void 0 && (ke(G), ie = "" + G), wt(R) && (ke(R.key), ie = "" + R.key), Ee(R) && (Oe = R.ref, it(R));
        for (ue in R)
          Ae.call(R, ue) && !Fe.hasOwnProperty(ue) && (se[ue] = R[ue]);
        if (y && y.defaultProps) {
          var de = y.defaultProps;
          for (ue in de)
            se[ue] === void 0 && (se[ue] = de[ue]);
        }
        if (ie || Oe) {
          var fe = typeof y == "function" ? y.displayName || y.name || "Unknown" : y;
          ie && st(se, fe), Oe && ut(se, fe);
        }
        return Ct(y, ie, Oe, ae, ne, Qe.current, se);
      }
    }
    var pt = E.ReactCurrentOwner, rt = E.ReactDebugCurrentFrame;
    function We(y) {
      if (y) {
        var R = y._owner, G = oe(y.type, y._source, R ? R.type : null);
        rt.setExtraStackFrame(G);
      } else
        rt.setExtraStackFrame(null);
    }
    var Ot;
    Ot = !1;
    function xt(y) {
      return typeof y == "object" && y !== null && y.$$typeof === t;
    }
    function gt() {
      {
        if (pt.current) {
          var y = V(pt.current.type);
          if (y)
            return `

Check the render method of \`` + y + "`.";
        }
        return "";
      }
    }
    function Ht(y) {
      return "";
    }
    var mt = {};
    function Wt(y) {
      {
        var R = gt();
        if (!R) {
          var G = typeof y == "string" ? y : y.displayName || y.name;
          G && (R = `

Check the top-level render call using <` + G + ">.");
        }
        return R;
      }
    }
    function vt(y, R) {
      {
        if (!y._store || y._store.validated || y.key != null)
          return;
        y._store.validated = !0;
        var G = Wt(R);
        if (mt[G])
          return;
        mt[G] = !0;
        var ne = "";
        y && y._owner && y._owner !== pt.current && (ne = " It was passed a child from " + V(y._owner.type) + "."), We(y), w('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', G, ne), We(null);
      }
    }
    function kt(y, R) {
      {
        if (typeof y != "object")
          return;
        if (we(y))
          for (var G = 0; G < y.length; G++) {
            var ne = y[G];
            xt(ne) && vt(ne, R);
          }
        else if (xt(y))
          y._store && (y._store.validated = !0);
        else if (y) {
          var ae = b(y);
          if (typeof ae == "function" && ae !== y.entries)
            for (var ue = ae.call(y), se; !(se = ue.next()).done; )
              xt(se.value) && vt(se.value, R);
        }
      }
    }
    function Un(y) {
      {
        var R = y.type;
        if (R == null || typeof R == "string")
          return;
        var G;
        if (typeof R == "function")
          G = R.propTypes;
        else if (typeof R == "object" && (R.$$typeof === l || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        R.$$typeof === p))
          G = R.propTypes;
        else
          return;
        if (G) {
          var ne = V(R);
          nt(G, y.props, "prop", ne, y);
        } else if (R.PropTypes !== void 0 && !Ot) {
          Ot = !0;
          var ae = V(R);
          w("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", ae || "Unknown");
        }
        typeof R.getDefaultProps == "function" && !R.getDefaultProps.isReactClassApproved && w("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function yt(y) {
      {
        for (var R = Object.keys(y.props), G = 0; G < R.length; G++) {
          var ne = R[G];
          if (ne !== "children" && ne !== "key") {
            We(y), w("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", ne), We(null);
            break;
          }
        }
        y.ref !== null && (We(y), w("Invalid attribute `ref` supplied to `React.Fragment`."), We(null));
      }
    }
    var re = {};
    function ao(y, R, G, ne, ae, ue) {
      {
        var se = B(y);
        if (!se) {
          var ie = "";
          (y === void 0 || typeof y == "object" && y !== null && Object.keys(y).length === 0) && (ie += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var Oe = Ht();
          Oe ? ie += Oe : ie += gt();
          var de;
          y === null ? de = "null" : we(y) ? de = "array" : y !== void 0 && y.$$typeof === t ? (de = "<" + (V(y.type) || "Unknown") + " />", ie = " Did you accidentally export a JSX literal instead of a component?") : de = typeof y, w("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", de, ie);
        }
        var fe = ct(y, R, G, ae, ue);
        if (fe == null)
          return fe;
        if (se) {
          var ze = R.children;
          if (ze !== void 0)
            if (ne)
              if (we(ze)) {
                for (var Et = 0; Et < ze.length; Et++)
                  kt(ze[Et], y);
                Object.freeze && Object.freeze(ze);
              } else
                w("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              kt(ze, y);
        }
        if (Ae.call(R, "key")) {
          var bt = V(y), je = Object.keys(R).filter(function(Li) {
            return Li !== "key";
          }), Hn = je.length > 0 ? "{key: someKey, " + je.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!re[bt + Hn]) {
            var ki = je.length > 0 ? "{" + je.join(": ..., ") + ": ...}" : "{}";
            w(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, Hn, bt, ki, bt), re[bt + Hn] = !0;
          }
        }
        return y === r ? yt(fe) : Un(fe), fe;
      }
    }
    function Ci(y, R, G) {
      return ao(y, R, G, !0);
    }
    function Oi(y, R, G) {
      return ao(y, R, G, !1);
    }
    var xi = Oi, Ei = Ci;
    Lm.Fragment = r, Lm.jsx = xi, Lm.jsxs = Ei;
  }()), Lm;
}
process.env.NODE_ENV === "production" ? Y1.exports = $ve() : Y1.exports = Vve();
var ei = Y1.exports;
$e({});
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function wN(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function gi(e) {
  var t, n;
  return wN(e) === !1 ? !1 : (t = e.constructor, t === void 0 ? !0 : (n = t.prototype, !(wN(n) === !1 || n.hasOwnProperty("isPrototypeOf") === !1)));
}
var pY = Symbol.for("immer-nothing"), CN = Symbol.for("immer-draftable"), Ps = Symbol.for("immer-state"), Zve = process.env.NODE_ENV !== "production" ? [
  // All error codes, starting by 0:
  function(e) {
    return `The plugin for '${e}' has not been loaded into Immer. To enable the plugin, import and call \`enable${e}()\` when initializing your application.`;
  },
  function(e) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${e}'`;
  },
  "This object has been frozen and should not be mutated",
  function(e) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + e;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(e) {
    return `'current' expects a draft, got: ${e}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(e) {
    return `'original' expects a draft, got: ${e}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function Zi(e, ...t) {
  if (process.env.NODE_ENV !== "production") {
    const n = Zve[e], r = typeof n == "function" ? n.apply(null, t) : n;
    throw new Error(`[Immer] ${r}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var kp = Object.getPrototypeOf;
function Hc(e) {
  return !!e && !!e[Ps];
}
function Wc(e) {
  var t;
  return e ? dY(e) || Array.isArray(e) || !!e[CN] || !!((t = e.constructor) != null && t[CN]) || dC(e) || fC(e) : !1;
}
var qve = Object.prototype.constructor.toString();
function dY(e) {
  if (!e || typeof e != "object")
    return !1;
  const t = kp(e);
  if (t === null)
    return !0;
  const n = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
  return n === Object ? !0 : typeof n == "function" && Function.toString.call(n) === qve;
}
function db(e, t) {
  pC(e) === 0 ? Reflect.ownKeys(e).forEach((n) => {
    t(n, e[n], e);
  }) : e.forEach((n, r) => t(r, n, e));
}
function pC(e) {
  const t = e[Ps];
  return t ? t.type_ : Array.isArray(e) ? 1 : dC(e) ? 2 : fC(e) ? 3 : 0;
}
function J1(e, t) {
  return pC(e) === 2 ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t);
}
function fY(e, t, n) {
  const r = pC(e);
  r === 2 ? e.set(t, n) : r === 3 ? e.add(n) : e[t] = n;
}
function Gve(e, t) {
  return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && t !== t;
}
function dC(e) {
  return e instanceof Map;
}
function fC(e) {
  return e instanceof Set;
}
function tc(e) {
  return e.copy_ || e.base_;
}
function Q1(e, t) {
  if (dC(e))
    return new Map(e);
  if (fC(e))
    return new Set(e);
  if (Array.isArray(e))
    return Array.prototype.slice.call(e);
  const n = dY(e);
  if (t === !0 || t === "class_only" && !n) {
    const r = Object.getOwnPropertyDescriptors(e);
    delete r[Ps];
    let o = Reflect.ownKeys(r);
    for (let i = 0; i < o.length; i++) {
      const a = o[i], s = r[a];
      s.writable === !1 && (s.writable = !0, s.configurable = !0), (s.get || s.set) && (r[a] = {
        configurable: !0,
        writable: !0,
        // could live with !!desc.set as well here...
        enumerable: s.enumerable,
        value: e[a]
      });
    }
    return Object.create(kp(e), r);
  } else {
    const r = kp(e);
    if (r !== null && n)
      return { ...e };
    const o = Object.create(r);
    return Object.assign(o, e);
  }
}
function xM(e, t = !1) {
  return hC(e) || Hc(e) || !Wc(e) || (pC(e) > 1 && (e.set = e.add = e.clear = e.delete = Kve), Object.freeze(e), t && Object.entries(e).forEach(([n, r]) => xM(r, !0))), e;
}
function Kve() {
  Zi(2);
}
function hC(e) {
  return Object.isFrozen(e);
}
var Xve = {};
function $c(e) {
  const t = Xve[e];
  return t || Zi(0, e), t;
}
var dh;
function hY() {
  return dh;
}
function Yve(e, t) {
  return {
    drafts_: [],
    parent_: e,
    immer_: t,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0
  };
}
function ON(e, t) {
  t && ($c("Patches"), e.patches_ = [], e.inversePatches_ = [], e.patchListener_ = t);
}
function e_(e) {
  t_(e), e.drafts_.forEach(Jve), e.drafts_ = null;
}
function t_(e) {
  e === dh && (dh = e.parent_);
}
function xN(e) {
  return dh = Yve(dh, e);
}
function Jve(e) {
  const t = e[Ps];
  t.type_ === 0 || t.type_ === 1 ? t.revoke_() : t.revoked_ = !0;
}
function EN(e, t) {
  t.unfinalizedDrafts_ = t.drafts_.length;
  const n = t.drafts_[0];
  return e !== void 0 && e !== n ? (n[Ps].modified_ && (e_(t), Zi(4)), Wc(e) && (e = fb(t, e), t.parent_ || hb(t, e)), t.patches_ && $c("Patches").generateReplacementPatches_(
    n[Ps].base_,
    e,
    t.patches_,
    t.inversePatches_
  )) : e = fb(t, n, []), e_(t), t.patches_ && t.patchListener_(t.patches_, t.inversePatches_), e !== pY ? e : void 0;
}
function fb(e, t, n) {
  if (hC(t))
    return t;
  const r = t[Ps];
  if (!r)
    return db(
      t,
      (o, i) => kN(e, r, t, o, i, n)
    ), t;
  if (r.scope_ !== e)
    return t;
  if (!r.modified_)
    return hb(e, r.base_, !0), r.base_;
  if (!r.finalized_) {
    r.finalized_ = !0, r.scope_.unfinalizedDrafts_--;
    const o = r.copy_;
    let i = o, a = !1;
    r.type_ === 3 && (i = new Set(o), o.clear(), a = !0), db(
      i,
      (s, l) => kN(e, r, o, s, l, n, a)
    ), hb(e, o, !1), n && e.patches_ && $c("Patches").generatePatches_(
      r,
      n,
      e.patches_,
      e.inversePatches_
    );
  }
  return r.copy_;
}
function kN(e, t, n, r, o, i, a) {
  if (process.env.NODE_ENV !== "production" && o === n && Zi(5), Hc(o)) {
    const s = i && t && t.type_ !== 3 && // Set objects are atomic since they have no keys.
    !J1(t.assigned_, r) ? i.concat(r) : void 0, l = fb(e, o, s);
    if (fY(n, r, l), Hc(l))
      e.canAutoFreeze_ = !1;
    else
      return;
  } else a && n.add(o);
  if (Wc(o) && !hC(o)) {
    if (!e.immer_.autoFreeze_ && e.unfinalizedDrafts_ < 1)
      return;
    fb(e, o), (!t || !t.scope_.parent_) && typeof r != "symbol" && Object.prototype.propertyIsEnumerable.call(n, r) && hb(e, o);
  }
}
function hb(e, t, n = !1) {
  !e.parent_ && e.immer_.autoFreeze_ && e.canAutoFreeze_ && xM(t, n);
}
function Qve(e, t) {
  const n = Array.isArray(e), r = {
    type_: n ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: t ? t.scope_ : hY(),
    // True for both shallow and deep changes.
    modified_: !1,
    // Used during finalization.
    finalized_: !1,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: t,
    // The base state.
    base_: e,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: !1
  };
  let o = r, i = EM;
  n && (o = [r], i = fh);
  const { revoke: a, proxy: s } = Proxy.revocable(o, i);
  return r.draft_ = s, r.revoke_ = a, s;
}
var EM = {
  get(e, t) {
    if (t === Ps)
      return e;
    const n = tc(e);
    if (!J1(n, t))
      return eye(e, n, t);
    const r = n[t];
    return e.finalized_ || !Wc(r) ? r : r === Dx(e.base_, t) ? (Tx(e), e.copy_[t] = r_(r, e)) : r;
  },
  has(e, t) {
    return t in tc(e);
  },
  ownKeys(e) {
    return Reflect.ownKeys(tc(e));
  },
  set(e, t, n) {
    const r = gY(tc(e), t);
    if (r != null && r.set)
      return r.set.call(e.draft_, n), !0;
    if (!e.modified_) {
      const o = Dx(tc(e), t), i = o == null ? void 0 : o[Ps];
      if (i && i.base_ === n)
        return e.copy_[t] = n, e.assigned_[t] = !1, !0;
      if (Gve(n, o) && (n !== void 0 || J1(e.base_, t)))
        return !0;
      Tx(e), n_(e);
    }
    return e.copy_[t] === n && // special case: handle new props with value 'undefined'
    (n !== void 0 || t in e.copy_) || // special case: NaN
    Number.isNaN(n) && Number.isNaN(e.copy_[t]) || (e.copy_[t] = n, e.assigned_[t] = !0), !0;
  },
  deleteProperty(e, t) {
    return Dx(e.base_, t) !== void 0 || t in e.base_ ? (e.assigned_[t] = !1, Tx(e), n_(e)) : delete e.assigned_[t], e.copy_ && delete e.copy_[t], !0;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(e, t) {
    const n = tc(e), r = Reflect.getOwnPropertyDescriptor(n, t);
    return r && {
      writable: !0,
      configurable: e.type_ !== 1 || t !== "length",
      enumerable: r.enumerable,
      value: n[t]
    };
  },
  defineProperty() {
    Zi(11);
  },
  getPrototypeOf(e) {
    return kp(e.base_);
  },
  setPrototypeOf() {
    Zi(12);
  }
}, fh = {};
db(EM, (e, t) => {
  fh[e] = function() {
    return arguments[0] = arguments[0][0], t.apply(this, arguments);
  };
});
fh.deleteProperty = function(e, t) {
  return process.env.NODE_ENV !== "production" && isNaN(parseInt(t)) && Zi(13), fh.set.call(this, e, t, void 0);
};
fh.set = function(e, t, n) {
  return process.env.NODE_ENV !== "production" && t !== "length" && isNaN(parseInt(t)) && Zi(14), EM.set.call(this, e[0], t, n, e[0]);
};
function Dx(e, t) {
  const n = e[Ps];
  return (n ? tc(n) : e)[t];
}
function eye(e, t, n) {
  var r;
  const o = gY(t, n);
  return o ? "value" in o ? o.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (r = o.get) == null ? void 0 : r.call(e.draft_)
  ) : void 0;
}
function gY(e, t) {
  if (!(t in e))
    return;
  let n = kp(e);
  for (; n; ) {
    const r = Object.getOwnPropertyDescriptor(n, t);
    if (r)
      return r;
    n = kp(n);
  }
}
function n_(e) {
  e.modified_ || (e.modified_ = !0, e.parent_ && n_(e.parent_));
}
function Tx(e) {
  e.copy_ || (e.copy_ = Q1(
    e.base_,
    e.scope_.immer_.useStrictShallowCopy_
  ));
}
var tye = class {
  constructor(e) {
    this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.produce = (t, n, r) => {
      if (typeof t == "function" && typeof n != "function") {
        const i = n;
        n = t;
        const a = this;
        return function(s = i, ...l) {
          return a.produce(s, (u) => n.call(this, u, ...l));
        };
      }
      typeof n != "function" && Zi(6), r !== void 0 && typeof r != "function" && Zi(7);
      let o;
      if (Wc(t)) {
        const i = xN(this), a = r_(t, void 0);
        let s = !0;
        try {
          o = n(a), s = !1;
        } finally {
          s ? e_(i) : t_(i);
        }
        return ON(i, r), EN(o, i);
      } else if (!t || typeof t != "object") {
        if (o = n(t), o === void 0 && (o = t), o === pY && (o = void 0), this.autoFreeze_ && xM(o, !0), r) {
          const i = [], a = [];
          $c("Patches").generateReplacementPatches_(t, o, i, a), r(i, a);
        }
        return o;
      } else
        Zi(1, t);
    }, this.produceWithPatches = (t, n) => {
      if (typeof t == "function")
        return (i, ...a) => this.produceWithPatches(i, (s) => t(s, ...a));
      let r, o;
      return [this.produce(t, n, (i, a) => {
        r = i, o = a;
      }), r, o];
    }, typeof (e == null ? void 0 : e.autoFreeze) == "boolean" && this.setAutoFreeze(e.autoFreeze), typeof (e == null ? void 0 : e.useStrictShallowCopy) == "boolean" && this.setUseStrictShallowCopy(e.useStrictShallowCopy);
  }
  createDraft(e) {
    Wc(e) || Zi(8), Hc(e) && (e = nye(e));
    const t = xN(this), n = r_(e, void 0);
    return n[Ps].isManual_ = !0, t_(t), n;
  }
  finishDraft(e, t) {
    const n = e && e[Ps];
    (!n || !n.isManual_) && Zi(9);
    const { scope_: r } = n;
    return ON(r, t), EN(void 0, r);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(e) {
    this.autoFreeze_ = e;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(e) {
    this.useStrictShallowCopy_ = e;
  }
  applyPatches(e, t) {
    let n;
    for (n = t.length - 1; n >= 0; n--) {
      const o = t[n];
      if (o.path.length === 0 && o.op === "replace") {
        e = o.value;
        break;
      }
    }
    n > -1 && (t = t.slice(n + 1));
    const r = $c("Patches").applyPatches_;
    return Hc(e) ? r(e, t) : this.produce(
      e,
      (o) => r(o, t)
    );
  }
};
function r_(e, t) {
  const n = dC(e) ? $c("MapSet").proxyMap_(e, t) : fC(e) ? $c("MapSet").proxySet_(e, t) : Qve(e, t);
  return (t ? t.scope_ : hY()).drafts_.push(n), n;
}
function nye(e) {
  return Hc(e) || Zi(10, e), mY(e);
}
function mY(e) {
  if (!Wc(e) || hC(e))
    return e;
  const t = e[Ps];
  let n;
  if (t) {
    if (!t.modified_)
      return t.base_;
    t.finalized_ = !0, n = Q1(e, t.scope_.immer_.useStrictShallowCopy_);
  } else
    n = Q1(e, !0);
  return db(n, (r, o) => {
    fY(n, r, mY(o));
  }), t && (t.finalized_ = !1), n;
}
var Ss = new tye(), kM = Ss.produce;
Ss.produceWithPatches.bind(
  Ss
);
Ss.setAutoFreeze.bind(Ss);
Ss.setUseStrictShallowCopy.bind(Ss);
Ss.applyPatches.bind(Ss);
var LN = Ss.createDraft.bind(Ss), _N = Ss.finishDraft.bind(Ss), Xe = {
  ancestors(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = Xe.levels(e, t);
    return n ? r = r.slice(1) : r = r.slice(0, -1), r;
  },
  common(e, t) {
    for (var n = [], r = 0; r < e.length && r < t.length; r++) {
      var o = e[r], i = t[r];
      if (o !== i)
        break;
      n.push(o);
    }
    return n;
  },
  compare(e, t) {
    for (var n = Math.min(e.length, t.length), r = 0; r < n; r++) {
      if (e[r] < t[r]) return -1;
      if (e[r] > t[r]) return 1;
    }
    return 0;
  },
  endsAfter(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return Xe.equals(r, o) && i > a;
  },
  endsAt(e, t) {
    var n = e.length, r = e.slice(0, n), o = t.slice(0, n);
    return Xe.equals(r, o);
  },
  endsBefore(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return Xe.equals(r, o) && i < a;
  },
  equals(e, t) {
    return e.length === t.length && e.every((n, r) => n === t[r]);
  },
  hasPrevious(e) {
    return e[e.length - 1] > 0;
  },
  isAfter(e, t) {
    return Xe.compare(e, t) === 1;
  },
  isAncestor(e, t) {
    return e.length < t.length && Xe.compare(e, t) === 0;
  },
  isBefore(e, t) {
    return Xe.compare(e, t) === -1;
  },
  isChild(e, t) {
    return e.length === t.length + 1 && Xe.compare(e, t) === 0;
  },
  isCommon(e, t) {
    return e.length <= t.length && Xe.compare(e, t) === 0;
  },
  isDescendant(e, t) {
    return e.length > t.length && Xe.compare(e, t) === 0;
  },
  isParent(e, t) {
    return e.length + 1 === t.length && Xe.compare(e, t) === 0;
  },
  isPath(e) {
    return Array.isArray(e) && (e.length === 0 || typeof e[0] == "number");
  },
  isSibling(e, t) {
    if (e.length !== t.length)
      return !1;
    var n = e.slice(0, -1), r = t.slice(0, -1), o = e[e.length - 1], i = t[t.length - 1];
    return o !== i && Xe.equals(n, r);
  },
  levels(e) {
    for (var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = [], o = 0; o <= e.length; o++)
      r.push(e.slice(0, o));
    return n && r.reverse(), r;
  },
  next(e) {
    if (e.length === 0)
      throw new Error("Cannot get the next path of a root path [".concat(e, "], because it has no next index."));
    var t = e[e.length - 1];
    return e.slice(0, -1).concat(t + 1);
  },
  operationCanTransformPath(e) {
    switch (e.type) {
      case "insert_node":
      case "remove_node":
      case "merge_node":
      case "split_node":
      case "move_node":
        return !0;
      default:
        return !1;
    }
  },
  parent(e) {
    if (e.length === 0)
      throw new Error("Cannot get the parent path of the root path [".concat(e, "]."));
    return e.slice(0, -1);
  },
  previous(e) {
    if (e.length === 0)
      throw new Error("Cannot get the previous path of a root path [".concat(e, "], because it has no previous index."));
    var t = e[e.length - 1];
    if (t <= 0)
      throw new Error("Cannot get the previous path of a first child path [".concat(e, "] because it would result in a negative index."));
    return e.slice(0, -1).concat(t - 1);
  },
  relative(e, t) {
    if (!Xe.isAncestor(t, e) && !Xe.equals(e, t))
      throw new Error("Cannot get the relative path of [".concat(e, "] inside ancestor [").concat(t, "], because it is not above or equal to the path."));
    return e.slice(t.length);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!e) return null;
    var r = [...e], {
      affinity: o = "forward"
    } = n;
    if (e.length === 0)
      return r;
    switch (t.type) {
      case "insert_node": {
        var {
          path: i
        } = t;
        (Xe.equals(i, r) || Xe.endsBefore(i, r) || Xe.isAncestor(i, r)) && (r[i.length - 1] += 1);
        break;
      }
      case "remove_node": {
        var {
          path: a
        } = t;
        if (Xe.equals(a, r) || Xe.isAncestor(a, r))
          return null;
        Xe.endsBefore(a, r) && (r[a.length - 1] -= 1);
        break;
      }
      case "merge_node": {
        var {
          path: s,
          position: l
        } = t;
        Xe.equals(s, r) || Xe.endsBefore(s, r) ? r[s.length - 1] -= 1 : Xe.isAncestor(s, r) && (r[s.length - 1] -= 1, r[s.length] += l);
        break;
      }
      case "split_node": {
        var {
          path: u,
          position: c
        } = t;
        if (Xe.equals(u, r)) {
          if (o === "forward")
            r[r.length - 1] += 1;
          else if (o !== "backward") return null;
        } else Xe.endsBefore(u, r) ? r[u.length - 1] += 1 : Xe.isAncestor(u, r) && e[u.length] >= c && (r[u.length - 1] += 1, r[u.length] -= c);
        break;
      }
      case "move_node": {
        var {
          path: p,
          newPath: d
        } = t;
        if (Xe.equals(p, d))
          return r;
        if (Xe.isAncestor(p, r) || Xe.equals(p, r)) {
          var g = d.slice();
          return Xe.endsBefore(p, d) && p.length < d.length && (g[p.length - 1] -= 1), g.concat(r.slice(p.length));
        } else Xe.isSibling(p, d) && (Xe.isAncestor(d, r) || Xe.equals(d, r)) ? Xe.endsBefore(p, r) ? r[p.length - 1] -= 1 : r[p.length - 1] += 1 : Xe.endsBefore(d, r) || Xe.equals(d, r) || Xe.isAncestor(d, r) ? (Xe.endsBefore(p, r) && (r[p.length - 1] -= 1), r[d.length - 1] += 1) : Xe.endsBefore(p, r) && (Xe.equals(d, r) && (r[d.length - 1] += 1), r[p.length - 1] -= 1);
        break;
      }
    }
    return r;
  }
};
function hh(e) {
  "@babel/helpers - typeof";
  return hh = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, hh(e);
}
function rye(e, t) {
  if (hh(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (hh(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function oye(e) {
  var t = rye(e, "string");
  return hh(t) === "symbol" ? t : String(t);
}
function Rp(e, t, n) {
  return t = oye(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function PN(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function dd(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? PN(Object(n), !0).forEach(function(r) {
      Rp(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : PN(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var iye = (e, t, n) => {
  switch (n.type) {
    case "insert_node": {
      var {
        path: r,
        node: o
      } = n, i = Dt.parent(e, r), a = r[r.length - 1];
      if (a > i.children.length)
        throw new Error('Cannot apply an "insert_node" operation at path ['.concat(r, "] because the destination is past the end of the node."));
      if (i.children.splice(a, 0, o), t)
        for (var [s, l] of Kt.points(t))
          t[l] = jr.transform(s, n);
      break;
    }
    case "insert_text": {
      var {
        path: u,
        offset: c,
        text: p
      } = n;
      if (p.length === 0) break;
      var d = Dt.leaf(e, u), g = d.text.slice(0, c), f = d.text.slice(c);
      if (d.text = g + p + f, t)
        for (var [m, b] of Kt.points(t))
          t[b] = jr.transform(m, n);
      break;
    }
    case "merge_node": {
      var {
        path: E
      } = n, w = Dt.get(e, E), M = Xe.previous(E), x = Dt.get(e, M), v = Dt.parent(e, E), C = E[E.length - 1];
      if (Mo.isText(w) && Mo.isText(x))
        x.text += w.text;
      else if (!Mo.isText(w) && !Mo.isText(x))
        x.children.push(...w.children);
      else
        throw new Error('Cannot apply a "merge_node" operation at path ['.concat(E, "] to nodes of different interfaces: ").concat(as.stringify(w), " ").concat(as.stringify(x)));
      if (v.children.splice(C, 1), t)
        for (var [P, F] of Kt.points(t))
          t[F] = jr.transform(P, n);
      break;
    }
    case "move_node": {
      var {
        path: L,
        newPath: B
      } = n;
      if (Xe.isAncestor(L, B))
        throw new Error("Cannot move a path [".concat(L, "] to new path [").concat(B, "] because the destination is inside itself."));
      var N = Dt.get(e, L), $ = Dt.parent(e, L), V = L[L.length - 1];
      $.children.splice(V, 1);
      var H = Xe.transform(L, n), Z = Dt.get(e, Xe.parent(H)), K = H[H.length - 1];
      if (Z.children.splice(K, 0, N), t)
        for (var [Y, Q] of Kt.points(t))
          t[Q] = jr.transform(Y, n);
      break;
    }
    case "remove_node": {
      var {
        path: J
      } = n, _ = J[J.length - 1], D = Dt.parent(e, J);
      if (D.children.splice(_, 1), t)
        for (var [z, S] of Kt.points(t)) {
          var W = jr.transform(z, n);
          if (t != null && W != null)
            t[S] = W;
          else {
            var O = void 0, j = void 0;
            for (var [U, T] of Dt.texts(e))
              if (Xe.compare(T, J) === -1)
                O = [U, T];
              else {
                j = [U, T];
                break;
              }
            var q = !1;
            O && j && (Xe.equals(j[1], J) ? q = !Xe.hasPrevious(j[1]) : q = Xe.common(O[1], J).length < Xe.common(j[1], J).length), O && !q ? (z.path = O[1], z.offset = O[0].text.length) : j ? (z.path = j[1], z.offset = 0) : t = null;
          }
        }
      break;
    }
    case "remove_text": {
      var {
        path: A,
        offset: X,
        text: I
      } = n;
      if (I.length === 0) break;
      var le = Dt.leaf(e, A), he = le.text.slice(0, X), oe = le.text.slice(X + I.length);
      if (le.text = he + oe, t)
        for (var [Ae, Ue] of Kt.points(t))
          t[Ue] = jr.transform(Ae, n);
      break;
    }
    case "set_node": {
      var {
        path: He,
        properties: Re,
        newProperties: nt
      } = n;
      if (He.length === 0)
        throw new Error("Cannot set properties on the root node!");
      var Ve = Dt.get(e, He);
      for (var we in nt) {
        if (we === "children" || we === "text")
          throw new Error('Cannot set the "'.concat(we, '" property of nodes!'));
        var et = nt[we];
        et == null ? delete Ve[we] : Ve[we] = et;
      }
      for (var lt in Re)
        nt.hasOwnProperty(lt) || delete Ve[lt];
      break;
    }
    case "set_selection": {
      var {
        newProperties: ye
      } = n;
      if (ye == null)
        t = ye;
      else {
        if (t == null) {
          if (!Kt.isRange(ye))
            throw new Error('Cannot apply an incomplete "set_selection" operation properties '.concat(as.stringify(ye), " when there is no current selection."));
          t = dd({}, ye);
        }
        for (var ke in ye) {
          var Qe = ye[ke];
          if (Qe == null) {
            if (ke === "anchor" || ke === "focus")
              throw new Error('Cannot remove the "'.concat(ke, '" selection property'));
            delete t[ke];
          } else
            t[ke] = Qe;
        }
      }
      break;
    }
    case "split_node": {
      var {
        path: Fe,
        position: Ie,
        properties: ot
      } = n;
      if (Fe.length === 0)
        throw new Error('Cannot apply a "split_node" operation at path ['.concat(Fe, "] because the root node cannot be split."));
      var Ee = Dt.get(e, Fe), wt = Dt.parent(e, Fe), it = Fe[Fe.length - 1], st;
      if (Mo.isText(Ee)) {
        var ut = Ee.text.slice(0, Ie), Ct = Ee.text.slice(Ie);
        Ee.text = ut, st = dd(dd({}, ot), {}, {
          text: Ct
        });
      } else {
        var ct = Ee.children.slice(0, Ie), pt = Ee.children.slice(Ie);
        Ee.children = ct, st = dd(dd({}, ot), {}, {
          children: pt
        });
      }
      if (wt.children.splice(it + 1, 0, st), t)
        for (var [rt, We] of Kt.points(t))
          t[We] = jr.transform(rt, n);
      break;
    }
  }
  return t;
}, sye = {
  transform(e, t) {
    e.children = LN(e.children);
    var n = e.selection && LN(e.selection);
    try {
      n = iye(e, n, t);
    } finally {
      e.children = _N(e.children), n ? e.selection = Hc(n) ? _N(n) : n : e.selection = null;
    }
  }
}, aye = {
  insertNodes(e, t, n) {
    e.insertNodes(t, n);
  },
  liftNodes(e, t) {
    e.liftNodes(t);
  },
  mergeNodes(e, t) {
    e.mergeNodes(t);
  },
  moveNodes(e, t) {
    e.moveNodes(t);
  },
  removeNodes(e, t) {
    e.removeNodes(t);
  },
  setNodes(e, t, n) {
    e.setNodes(t, n);
  },
  splitNodes(e, t) {
    e.splitNodes(t);
  },
  unsetNodes(e, t, n) {
    e.unsetNodes(t, n);
  },
  unwrapNodes(e, t) {
    e.unwrapNodes(t);
  },
  wrapNodes(e, t, n) {
    e.wrapNodes(t, n);
  }
}, lye = {
  collapse(e, t) {
    e.collapse(t);
  },
  deselect(e) {
    e.deselect();
  },
  move(e, t) {
    e.move(t);
  },
  select(e, t) {
    e.select(t);
  },
  setPoint(e, t, n) {
    e.setPoint(t, n);
  },
  setSelection(e, t) {
    e.setSelection(t);
  }
}, vY = (e, t) => {
  for (var n in e) {
    var r = e[n], o = t[n];
    if (gi(r) && gi(o)) {
      if (!vY(r, o)) return !1;
    } else if (Array.isArray(r) && Array.isArray(o)) {
      if (r.length !== o.length) return !1;
      for (var i = 0; i < r.length; i++)
        if (r[i] !== o[i]) return !1;
    } else if (r !== o)
      return !1;
  }
  for (var a in t)
    if (e[a] === void 0 && t[a] !== void 0)
      return !1;
  return !0;
};
function uye(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), o, i;
  for (i = 0; i < r.length; i++)
    o = r[i], !(t.indexOf(o) >= 0) && (n[o] = e[o]);
  return n;
}
function gh(e, t) {
  if (e == null) return {};
  var n = uye(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (o = 0; o < i.length; o++)
      r = i[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
var cye = ["anchor", "focus"];
function SN(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function pye(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? SN(Object(n), !0).forEach(function(r) {
      Rp(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : SN(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Kt = {
  edges(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, {
      anchor: r,
      focus: o
    } = e;
    return Kt.isBackward(e) === n ? [r, o] : [o, r];
  },
  end(e) {
    var [, t] = Kt.edges(e);
    return t;
  },
  equals(e, t) {
    return jr.equals(e.anchor, t.anchor) && jr.equals(e.focus, t.focus);
  },
  includes(e, t) {
    if (Kt.isRange(t)) {
      if (Kt.includes(e, t.anchor) || Kt.includes(e, t.focus))
        return !0;
      var [n, r] = Kt.edges(e), [o, i] = Kt.edges(t);
      return jr.isBefore(n, o) && jr.isAfter(r, i);
    }
    var [a, s] = Kt.edges(e), l = !1, u = !1;
    return jr.isPoint(t) ? (l = jr.compare(t, a) >= 0, u = jr.compare(t, s) <= 0) : (l = Xe.compare(t, a.path) >= 0, u = Xe.compare(t, s.path) <= 0), l && u;
  },
  intersection(e, t) {
    var n = gh(e, cye), [r, o] = Kt.edges(e), [i, a] = Kt.edges(t), s = jr.isBefore(r, i) ? i : r, l = jr.isBefore(o, a) ? o : a;
    return jr.isBefore(l, s) ? null : pye({
      anchor: s,
      focus: l
    }, n);
  },
  isBackward(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return jr.isAfter(t, n);
  },
  isCollapsed(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return jr.equals(t, n);
  },
  isExpanded(e) {
    return !Kt.isCollapsed(e);
  },
  isForward(e) {
    return !Kt.isBackward(e);
  },
  isRange(e) {
    return gi(e) && jr.isPoint(e.anchor) && jr.isPoint(e.focus);
  },
  *points(e) {
    yield [e.anchor, "anchor"], yield [e.focus, "focus"];
  },
  start(e) {
    var [t] = Kt.edges(e);
    return t;
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return kM(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "inward"
      } = n, i, a;
      if (o === "inward") {
        var s = Kt.isCollapsed(r);
        Kt.isForward(r) ? (i = "forward", a = s ? i : "backward") : (i = "backward", a = s ? i : "forward");
      } else o === "outward" ? Kt.isForward(r) ? (i = "backward", a = "forward") : (i = "forward", a = "backward") : (i = o, a = o);
      var l = jr.transform(r.anchor, t, {
        affinity: i
      }), u = jr.transform(r.focus, t, {
        affinity: a
      });
      if (!l || !u)
        return null;
      r.anchor = l, r.focus = u;
    });
  }
}, MN = (e) => gi(e) && Dt.isNodeList(e.children) && !cr.isEditor(e), Va = {
  isAncestor(e) {
    return gi(e) && Dt.isNodeList(e.children);
  },
  isElement: MN,
  isElementList(e) {
    return Array.isArray(e) && e.every((t) => Va.isElement(t));
  },
  isElementProps(e) {
    return e.children !== void 0;
  },
  isElementType: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "type";
    return MN(e) && e[n] === t;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "children" && e[n] !== t[n])
        return !1;
    return !0;
  }
}, dye = ["children"], fye = ["text"], DN = /* @__PURE__ */ new WeakMap(), Dt = {
  ancestor(e, t) {
    var n = Dt.get(e, t);
    if (Mo.isText(n))
      throw new Error("Cannot get the ancestor node at path [".concat(t, "] because it refers to a text node instead: ").concat(as.stringify(n)));
    return n;
  },
  ancestors(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of Xe.ancestors(t, n)) {
        var o = Dt.ancestor(e, r), i = [o, r];
        yield i;
      }
    }();
  },
  child(e, t) {
    if (Mo.isText(e))
      throw new Error("Cannot get the child of a text node: ".concat(as.stringify(e)));
    var n = e.children[t];
    if (n == null)
      throw new Error("Cannot get child at index `".concat(t, "` in node: ").concat(as.stringify(e)));
    return n;
  },
  children(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var {
        reverse: r = !1
      } = n, o = Dt.ancestor(e, t), {
        children: i
      } = o, a = r ? i.length - 1 : 0; r ? a >= 0 : a < i.length; ) {
        var s = Dt.child(o, a), l = t.concat(a);
        yield [s, l], a = r ? a - 1 : a + 1;
      }
    }();
  },
  common(e, t, n) {
    var r = Xe.common(t, n), o = Dt.get(e, r);
    return [o, r];
  },
  descendant(e, t) {
    var n = Dt.get(e, t);
    if (cr.isEditor(n))
      throw new Error("Cannot get the descendant node at path [".concat(t, "] because it refers to the root editor node instead: ").concat(as.stringify(n)));
    return n;
  },
  descendants(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Dt.nodes(e, t))
        r.length !== 0 && (yield [n, r]);
    }();
  },
  elements(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Dt.nodes(e, t))
        Va.isElement(n) && (yield [n, r]);
    }();
  },
  extractProps(e) {
    if (Va.isAncestor(e)) {
      var t = gh(e, dye);
      return t;
    } else {
      var t = gh(e, fye);
      return t;
    }
  },
  first(e, t) {
    for (var n = t.slice(), r = Dt.get(e, n); r && !(Mo.isText(r) || r.children.length === 0); )
      r = r.children[0], n.push(0);
    return [r, n];
  },
  fragment(e, t) {
    if (Mo.isText(e))
      throw new Error("Cannot get a fragment starting from a root text node: ".concat(as.stringify(e)));
    var n = kM({
      children: e.children
    }, (r) => {
      var [o, i] = Kt.edges(t), a = Dt.nodes(r, {
        reverse: !0,
        pass: (d) => {
          var [, g] = d;
          return !Kt.includes(t, g);
        }
      });
      for (var [, s] of a) {
        if (!Kt.includes(t, s)) {
          var l = Dt.parent(r, s), u = s[s.length - 1];
          l.children.splice(u, 1);
        }
        if (Xe.equals(s, i.path)) {
          var c = Dt.leaf(r, s);
          c.text = c.text.slice(0, i.offset);
        }
        if (Xe.equals(s, o.path)) {
          var p = Dt.leaf(r, s);
          p.text = p.text.slice(o.offset);
        }
      }
      cr.isEditor(r) && (r.selection = null);
    });
    return n.children;
  },
  get(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (Mo.isText(n) || !n.children[o])
        throw new Error("Cannot find a descendant at path [".concat(t, "] in node: ").concat(as.stringify(e)));
      n = n.children[o];
    }
    return n;
  },
  has(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (Mo.isText(n) || !n.children[o])
        return !1;
      n = n.children[o];
    }
    return !0;
  },
  isNode(e) {
    return Mo.isText(e) || Va.isElement(e) || cr.isEditor(e);
  },
  isNodeList(e) {
    if (!Array.isArray(e))
      return !1;
    var t = DN.get(e);
    if (t !== void 0)
      return t;
    var n = e.every((r) => Dt.isNode(r));
    return DN.set(e, n), n;
  },
  last(e, t) {
    for (var n = t.slice(), r = Dt.get(e, n); r && !(Mo.isText(r) || r.children.length === 0); ) {
      var o = r.children.length - 1;
      r = r.children[o], n.push(o);
    }
    return [r, n];
  },
  leaf(e, t) {
    var n = Dt.get(e, t);
    if (!Mo.isText(n))
      throw new Error("Cannot get the leaf node at path [".concat(t, "] because it refers to a non-leaf node: ").concat(as.stringify(n)));
    return n;
  },
  levels(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of Xe.levels(t, n)) {
        var o = Dt.get(e, r);
        yield [o, r];
      }
    }();
  },
  matches(e, t) {
    return Va.isElement(e) && Va.isElementProps(t) && Va.matches(e, t) || Mo.isText(e) && Mo.isTextProps(t) && Mo.matches(e, t);
  },
  nodes(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var {
        pass: n,
        reverse: r = !1
      } = t, {
        from: o = [],
        to: i
      } = t, a = /* @__PURE__ */ new Set(), s = [], l = e; !(i && (r ? Xe.isBefore(s, i) : Xe.isAfter(s, i))); ) {
        if (a.has(l) || (yield [l, s]), !a.has(l) && !Mo.isText(l) && l.children.length !== 0 && (n == null || n([l, s]) === !1)) {
          a.add(l);
          var u = r ? l.children.length - 1 : 0;
          Xe.isAncestor(s, o) && (u = o[s.length]), s = s.concat(u), l = Dt.get(e, s);
          continue;
        }
        if (s.length === 0)
          break;
        if (!r) {
          var c = Xe.next(s);
          if (Dt.has(e, c)) {
            s = c, l = Dt.get(e, s);
            continue;
          }
        }
        if (r && s[s.length - 1] !== 0) {
          var p = Xe.previous(s);
          s = p, l = Dt.get(e, s);
          continue;
        }
        s = Xe.parent(s), l = Dt.get(e, s), a.add(l);
      }
    }();
  },
  parent(e, t) {
    var n = Xe.parent(t), r = Dt.get(e, n);
    if (Mo.isText(r))
      throw new Error("Cannot get the parent of path [".concat(t, "] because it does not exist in the root."));
    return r;
  },
  string(e) {
    return Mo.isText(e) ? e.text : e.children.map(Dt.string).join("");
  },
  texts(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Dt.nodes(e, t))
        Mo.isText(n) && (yield [n, r]);
    }();
  }
};
function TN(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Ur(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? TN(Object(n), !0).forEach(function(r) {
      Rp(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : TN(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Jd = {
  isNodeOperation(e) {
    return Jd.isOperation(e) && e.type.endsWith("_node");
  },
  isOperation(e) {
    if (!gi(e))
      return !1;
    switch (e.type) {
      case "insert_node":
        return Xe.isPath(e.path) && Dt.isNode(e.node);
      case "insert_text":
        return typeof e.offset == "number" && typeof e.text == "string" && Xe.isPath(e.path);
      case "merge_node":
        return typeof e.position == "number" && Xe.isPath(e.path) && gi(e.properties);
      case "move_node":
        return Xe.isPath(e.path) && Xe.isPath(e.newPath);
      case "remove_node":
        return Xe.isPath(e.path) && Dt.isNode(e.node);
      case "remove_text":
        return typeof e.offset == "number" && typeof e.text == "string" && Xe.isPath(e.path);
      case "set_node":
        return Xe.isPath(e.path) && gi(e.properties) && gi(e.newProperties);
      case "set_selection":
        return e.properties === null && Kt.isRange(e.newProperties) || e.newProperties === null && Kt.isRange(e.properties) || gi(e.properties) && gi(e.newProperties);
      case "split_node":
        return Xe.isPath(e.path) && typeof e.position == "number" && gi(e.properties);
      default:
        return !1;
    }
  },
  isOperationList(e) {
    return Array.isArray(e) && e.every((t) => Jd.isOperation(t));
  },
  isSelectionOperation(e) {
    return Jd.isOperation(e) && e.type.endsWith("_selection");
  },
  isTextOperation(e) {
    return Jd.isOperation(e) && e.type.endsWith("_text");
  },
  inverse(e) {
    switch (e.type) {
      case "insert_node":
        return Ur(Ur({}, e), {}, {
          type: "remove_node"
        });
      case "insert_text":
        return Ur(Ur({}, e), {}, {
          type: "remove_text"
        });
      case "merge_node":
        return Ur(Ur({}, e), {}, {
          type: "split_node",
          path: Xe.previous(e.path)
        });
      case "move_node": {
        var {
          newPath: t,
          path: n
        } = e;
        if (Xe.equals(t, n))
          return e;
        if (Xe.isSibling(n, t))
          return Ur(Ur({}, e), {}, {
            path: t,
            newPath: n
          });
        var r = Xe.transform(n, e), o = Xe.transform(Xe.next(n), e);
        return Ur(Ur({}, e), {}, {
          path: r,
          newPath: o
        });
      }
      case "remove_node":
        return Ur(Ur({}, e), {}, {
          type: "insert_node"
        });
      case "remove_text":
        return Ur(Ur({}, e), {}, {
          type: "insert_text"
        });
      case "set_node": {
        var {
          properties: i,
          newProperties: a
        } = e;
        return Ur(Ur({}, e), {}, {
          properties: a,
          newProperties: i
        });
      }
      case "set_selection": {
        var {
          properties: s,
          newProperties: l
        } = e;
        return s == null ? Ur(Ur({}, e), {}, {
          properties: l,
          newProperties: null
        }) : l == null ? Ur(Ur({}, e), {}, {
          properties: null,
          newProperties: s
        }) : Ur(Ur({}, e), {}, {
          properties: l,
          newProperties: s
        });
      }
      case "split_node":
        return Ur(Ur({}, e), {}, {
          type: "merge_node",
          path: Xe.next(e.path)
        });
    }
  }
}, jN = /* @__PURE__ */ new WeakMap(), hye = (e) => {
  var t = jN.get(e);
  if (t !== void 0)
    return t;
  if (!gi(e))
    return !1;
  var n = typeof e.addMark == "function" && typeof e.apply == "function" && typeof e.deleteFragment == "function" && typeof e.insertBreak == "function" && typeof e.insertSoftBreak == "function" && typeof e.insertFragment == "function" && typeof e.insertNode == "function" && typeof e.insertText == "function" && typeof e.isElementReadOnly == "function" && typeof e.isInline == "function" && typeof e.isSelectable == "function" && typeof e.isVoid == "function" && typeof e.normalizeNode == "function" && typeof e.onChange == "function" && typeof e.removeMark == "function" && typeof e.getDirtyPaths == "function" && (e.marks === null || gi(e.marks)) && (e.selection === null || Kt.isRange(e.selection)) && Dt.isNodeList(e.children) && Jd.isOperationList(e.operations);
  return jN.set(e, n), n;
}, cr = {
  above(e, t) {
    return e.above(t);
  },
  addMark(e, t, n) {
    e.addMark(t, n);
  },
  after(e, t, n) {
    return e.after(t, n);
  },
  before(e, t, n) {
    return e.before(t, n);
  },
  deleteBackward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteBackward(n);
  },
  deleteForward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteForward(n);
  },
  deleteFragment(e, t) {
    e.deleteFragment(t);
  },
  edges(e, t) {
    return e.edges(t);
  },
  elementReadOnly(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return e.elementReadOnly(t);
  },
  end(e, t) {
    return e.end(t);
  },
  first(e, t) {
    return e.first(t);
  },
  fragment(e, t) {
    return e.fragment(t);
  },
  hasBlocks(e, t) {
    return e.hasBlocks(t);
  },
  hasInlines(e, t) {
    return e.hasInlines(t);
  },
  hasPath(e, t) {
    return e.hasPath(t);
  },
  hasTexts(e, t) {
    return e.hasTexts(t);
  },
  insertBreak(e) {
    e.insertBreak();
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertNode(e, t) {
    e.insertNode(t);
  },
  insertSoftBreak(e) {
    e.insertSoftBreak();
  },
  insertText(e, t) {
    e.insertText(t);
  },
  isBlock(e, t) {
    return e.isBlock(t);
  },
  isEdge(e, t, n) {
    return e.isEdge(t, n);
  },
  isEditor(e) {
    return hye(e);
  },
  isElementReadOnly(e, t) {
    return e.isElementReadOnly(t);
  },
  isEmpty(e, t) {
    return e.isEmpty(t);
  },
  isEnd(e, t, n) {
    return e.isEnd(t, n);
  },
  isInline(e, t) {
    return e.isInline(t);
  },
  isNormalizing(e) {
    return e.isNormalizing();
  },
  isSelectable(e, t) {
    return e.isSelectable(t);
  },
  isStart(e, t, n) {
    return e.isStart(t, n);
  },
  isVoid(e, t) {
    return e.isVoid(t);
  },
  last(e, t) {
    return e.last(t);
  },
  leaf(e, t, n) {
    return e.leaf(t, n);
  },
  levels(e, t) {
    return e.levels(t);
  },
  marks(e) {
    return e.getMarks();
  },
  next(e, t) {
    return e.next(t);
  },
  node(e, t, n) {
    return e.node(t, n);
  },
  nodes(e, t) {
    return e.nodes(t);
  },
  normalize(e, t) {
    e.normalize(t);
  },
  parent(e, t, n) {
    return e.parent(t, n);
  },
  path(e, t, n) {
    return e.path(t, n);
  },
  pathRef(e, t, n) {
    return e.pathRef(t, n);
  },
  pathRefs(e) {
    return e.pathRefs();
  },
  point(e, t, n) {
    return e.point(t, n);
  },
  pointRef(e, t, n) {
    return e.pointRef(t, n);
  },
  pointRefs(e) {
    return e.pointRefs();
  },
  positions(e, t) {
    return e.positions(t);
  },
  previous(e, t) {
    return e.previous(t);
  },
  range(e, t, n) {
    return e.range(t, n);
  },
  rangeRef(e, t, n) {
    return e.rangeRef(t, n);
  },
  rangeRefs(e) {
    return e.rangeRefs();
  },
  removeMark(e, t) {
    e.removeMark(t);
  },
  setNormalizing(e, t) {
    e.setNormalizing(t);
  },
  start(e, t) {
    return e.start(t);
  },
  string(e, t, n) {
    return e.string(t, n);
  },
  unhangRange(e, t, n) {
    return e.unhangRange(t, n);
  },
  void(e, t) {
    return e.void(t);
  },
  withoutNormalizing(e, t) {
    e.withoutNormalizing(t);
  },
  shouldMergeNodesRemovePrevNode: (e, t, n) => e.shouldMergeNodesRemovePrevNode(t, n)
};
function AN(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function RN(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? AN(Object(n), !0).forEach(function(r) {
      Rp(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : AN(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var jr = {
  compare(e, t) {
    var n = Xe.compare(e.path, t.path);
    return n === 0 ? e.offset < t.offset ? -1 : e.offset > t.offset ? 1 : 0 : n;
  },
  isAfter(e, t) {
    return jr.compare(e, t) === 1;
  },
  isBefore(e, t) {
    return jr.compare(e, t) === -1;
  },
  equals(e, t) {
    return e.offset === t.offset && Xe.equals(e.path, t.path);
  },
  isPoint(e) {
    return gi(e) && typeof e.offset == "number" && Xe.isPath(e.path);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return kM(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "forward"
      } = n, {
        path: i,
        offset: a
      } = r;
      switch (t.type) {
        case "insert_node":
        case "move_node": {
          r.path = Xe.transform(i, t, n);
          break;
        }
        case "insert_text": {
          Xe.equals(t.path, i) && (t.offset < a || t.offset === a && o === "forward") && (r.offset += t.text.length);
          break;
        }
        case "merge_node": {
          Xe.equals(t.path, i) && (r.offset += t.position), r.path = Xe.transform(i, t, n);
          break;
        }
        case "remove_text": {
          Xe.equals(t.path, i) && t.offset <= a && (r.offset -= Math.min(a - t.offset, t.text.length));
          break;
        }
        case "remove_node": {
          if (Xe.equals(t.path, i) || Xe.isAncestor(t.path, i))
            return null;
          r.path = Xe.transform(i, t, n);
          break;
        }
        case "split_node": {
          if (Xe.equals(t.path, i)) {
            if (t.position === a && o == null)
              return null;
            (t.position < a || t.position === a && o === "forward") && (r.offset -= t.position, r.path = Xe.transform(i, t, RN(RN({}, n), {}, {
              affinity: "forward"
            })));
          } else
            r.path = Xe.transform(i, t, n);
          break;
        }
      }
    });
  }
}, IN = void 0, as = {
  setScrubber(e) {
    IN = e;
  },
  stringify(e) {
    return JSON.stringify(e, IN);
  }
}, gye = ["text"], mye = ["anchor", "focus"];
function NN(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Ma(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? NN(Object(n), !0).forEach(function(r) {
      Rp(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : NN(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Mo = {
  equals(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      loose: r = !1
    } = n;
    function o(i) {
      var a = gh(i, gye);
      return a;
    }
    return vY(r ? o(e) : e, r ? o(t) : t);
  },
  isText(e) {
    return gi(e) && typeof e.text == "string";
  },
  isTextList(e) {
    return Array.isArray(e) && e.every((t) => Mo.isText(t));
  },
  isTextProps(e) {
    return e.text !== void 0;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "text" && (!e.hasOwnProperty(n) || e[n] !== t[n]))
        return !1;
    return !0;
  },
  decorations(e, t) {
    var n = [Ma({}, e)];
    for (var r of t) {
      var o = gh(r, mye), [i, a] = Kt.edges(r), s = [], l = 0, u = i.offset, c = a.offset;
      for (var p of n) {
        var {
          length: d
        } = p.text, g = l;
        if (l += d, u <= g && l <= c) {
          Object.assign(p, o), s.push(p);
          continue;
        }
        if (u !== c && (u === l || c === g) || u > l || c < g || c === g && g !== 0) {
          s.push(p);
          continue;
        }
        var f = p, m = void 0, b = void 0;
        if (c < l) {
          var E = c - g;
          b = Ma(Ma({}, f), {}, {
            text: f.text.slice(E)
          }), f = Ma(Ma({}, f), {}, {
            text: f.text.slice(0, E)
          });
        }
        if (u > g) {
          var w = u - g;
          m = Ma(Ma({}, f), {}, {
            text: f.text.slice(0, w)
          }), f = Ma(Ma({}, f), {}, {
            text: f.text.slice(w)
          });
        }
        Object.assign(f, o), m && s.push(m), s.push(f), b && s.push(b);
      }
      n = s;
    }
    return n;
  }
}, vye = (e) => e.selection ? e.selection : e.children.length > 0 ? cr.end(e, []) : [0], Lr;
(function(e) {
  e[e.None = 0] = "None", e[e.Extend = 1] = "Extend", e[e.ZWJ = 2] = "ZWJ", e[e.RI = 4] = "RI", e[e.Prepend = 8] = "Prepend", e[e.SpacingMark = 16] = "SpacingMark", e[e.L = 32] = "L", e[e.V = 64] = "V", e[e.T = 128] = "T", e[e.LV = 256] = "LV", e[e.LVT = 512] = "LVT", e[e.ExtPict = 1024] = "ExtPict", e[e.Any = 2048] = "Any";
})(Lr || (Lr = {}));
Lr.L, Lr.L | Lr.V | Lr.LV | Lr.LVT, Lr.LV | Lr.V, Lr.V | Lr.T, Lr.LVT | Lr.T, Lr.T, Lr.Any, Lr.Extend | Lr.ZWJ, Lr.Any, Lr.SpacingMark, Lr.Prepend, Lr.Any, Lr.ZWJ, Lr.ExtPict, Lr.RI, Lr.RI;
var yye = {
  delete(e, t) {
    e.delete(t);
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertText(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    cr.withoutNormalizing(e, () => {
      var {
        voids: r = !1
      } = n, {
        at: o = vye(e)
      } = n;
      if (Xe.isPath(o) && (o = cr.range(e, o)), Kt.isRange(o))
        if (Kt.isCollapsed(o))
          o = o.anchor;
        else {
          var i = Kt.end(o);
          if (!r && cr.void(e, {
            at: i
          }))
            return;
          var a = Kt.start(o), s = cr.pointRef(e, a), l = cr.pointRef(e, i);
          gb.delete(e, {
            at: o,
            voids: r
          });
          var u = s.unref(), c = l.unref();
          o = u || c, gb.setSelection(e, {
            anchor: o,
            focus: o
          });
        }
      if (!(!r && cr.void(e, {
        at: o
      }) || cr.elementReadOnly(e, {
        at: o
      }))) {
        var {
          path: p,
          offset: d
        } = o;
        t.length > 0 && e.apply({
          type: "insert_text",
          path: p,
          offset: d,
          text: t
        });
      }
    });
  }
};
function BN(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function _m(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? BN(Object(n), !0).forEach(function(r) {
      Rp(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : BN(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var gb = _m(_m(_m(_m({}, sye), aye), lye), yye), yY = {}, LM = {}, _M = {}, np = {}, PM = {}, SM = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Doctype = e.CDATA = e.Tag = e.Style = e.Script = e.Comment = e.Directive = e.Text = e.Root = e.isTag = e.ElementType = void 0;
  var t;
  (function(r) {
    r.Root = "root", r.Text = "text", r.Directive = "directive", r.Comment = "comment", r.Script = "script", r.Style = "style", r.Tag = "tag", r.CDATA = "cdata", r.Doctype = "doctype";
  })(t = e.ElementType || (e.ElementType = {}));
  function n(r) {
    return r.type === t.Tag || r.type === t.Script || r.type === t.Style;
  }
  e.isTag = n, e.Root = t.Root, e.Text = t.Text, e.Directive = t.Directive, e.Comment = t.Comment, e.Script = t.Script, e.Style = t.Style, e.Tag = t.Tag, e.CDATA = t.CDATA, e.Doctype = t.Doctype;
})(SM);
var on = {}, yu = yr && yr.__extends || /* @__PURE__ */ function() {
  var e = function(t, n) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, o) {
      r.__proto__ = o;
    } || function(r, o) {
      for (var i in o) Object.prototype.hasOwnProperty.call(o, i) && (r[i] = o[i]);
    }, e(t, n);
  };
  return function(t, n) {
    if (typeof n != "function" && n !== null)
      throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
    e(t, n);
    function r() {
      this.constructor = t;
    }
    t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
  };
}(), mf = yr && yr.__assign || function() {
  return mf = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) {
      t = arguments[n];
      for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
    }
    return e;
  }, mf.apply(this, arguments);
};
Object.defineProperty(on, "__esModule", { value: !0 });
on.cloneNode = on.hasChildren = on.isDocument = on.isDirective = on.isComment = on.isText = on.isCDATA = on.isTag = on.Element = on.Document = on.CDATA = on.NodeWithChildren = on.ProcessingInstruction = on.Comment = on.Text = on.DataNode = on.Node = void 0;
var es = SM, MM = (
  /** @class */
  function() {
    function e() {
      this.parent = null, this.prev = null, this.next = null, this.startIndex = null, this.endIndex = null;
    }
    return Object.defineProperty(e.prototype, "parentNode", {
      // Read-write aliases for properties
      /**
       * Same as {@link parent}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.parent;
      },
      set: function(t) {
        this.parent = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "previousSibling", {
      /**
       * Same as {@link prev}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.prev;
      },
      set: function(t) {
        this.prev = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "nextSibling", {
      /**
       * Same as {@link next}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.next;
      },
      set: function(t) {
        this.next = t;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.cloneNode = function(t) {
      return t === void 0 && (t = !1), DM(this, t);
    }, e;
  }()
);
on.Node = MM;
var gC = (
  /** @class */
  function(e) {
    yu(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.data = n, r;
    }
    return Object.defineProperty(t.prototype, "nodeValue", {
      /**
       * Same as {@link data}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.data;
      },
      set: function(n) {
        this.data = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(MM)
);
on.DataNode = gC;
var bY = (
  /** @class */
  function(e) {
    yu(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = es.ElementType.Text, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 3;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(gC)
);
on.Text = bY;
var wY = (
  /** @class */
  function(e) {
    yu(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = es.ElementType.Comment, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 8;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(gC)
);
on.Comment = wY;
var CY = (
  /** @class */
  function(e) {
    yu(t, e);
    function t(n, r) {
      var o = e.call(this, r) || this;
      return o.name = n, o.type = es.ElementType.Directive, o;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(gC)
);
on.ProcessingInstruction = CY;
var mC = (
  /** @class */
  function(e) {
    yu(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.children = n, r;
    }
    return Object.defineProperty(t.prototype, "firstChild", {
      // Aliases
      /** First child of the node. */
      get: function() {
        var n;
        return (n = this.children[0]) !== null && n !== void 0 ? n : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "lastChild", {
      /** Last child of the node. */
      get: function() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "childNodes", {
      /**
       * Same as {@link children}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.children;
      },
      set: function(n) {
        this.children = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(MM)
);
on.NodeWithChildren = mC;
var OY = (
  /** @class */
  function(e) {
    yu(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = es.ElementType.CDATA, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 4;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(mC)
);
on.CDATA = OY;
var xY = (
  /** @class */
  function(e) {
    yu(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = es.ElementType.Root, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 9;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(mC)
);
on.Document = xY;
var EY = (
  /** @class */
  function(e) {
    yu(t, e);
    function t(n, r, o, i) {
      o === void 0 && (o = []), i === void 0 && (i = n === "script" ? es.ElementType.Script : n === "style" ? es.ElementType.Style : es.ElementType.Tag);
      var a = e.call(this, o) || this;
      return a.name = n, a.attribs = r, a.type = i, a;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "tagName", {
      // DOM Level 1 aliases
      /**
       * Same as {@link name}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.name;
      },
      set: function(n) {
        this.name = n;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "attributes", {
      get: function() {
        var n = this;
        return Object.keys(this.attribs).map(function(r) {
          var o, i;
          return {
            name: r,
            value: n.attribs[r],
            namespace: (o = n["x-attribsNamespace"]) === null || o === void 0 ? void 0 : o[r],
            prefix: (i = n["x-attribsPrefix"]) === null || i === void 0 ? void 0 : i[r]
          };
        });
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(mC)
);
on.Element = EY;
function kY(e) {
  return (0, es.isTag)(e);
}
on.isTag = kY;
function LY(e) {
  return e.type === es.ElementType.CDATA;
}
on.isCDATA = LY;
function _Y(e) {
  return e.type === es.ElementType.Text;
}
on.isText = _Y;
function PY(e) {
  return e.type === es.ElementType.Comment;
}
on.isComment = PY;
function SY(e) {
  return e.type === es.ElementType.Directive;
}
on.isDirective = SY;
function MY(e) {
  return e.type === es.ElementType.Root;
}
on.isDocument = MY;
function bye(e) {
  return Object.prototype.hasOwnProperty.call(e, "children");
}
on.hasChildren = bye;
function DM(e, t) {
  t === void 0 && (t = !1);
  var n;
  if (_Y(e))
    n = new bY(e.data);
  else if (PY(e))
    n = new wY(e.data);
  else if (kY(e)) {
    var r = t ? jx(e.children) : [], o = new EY(e.name, mf({}, e.attribs), r);
    r.forEach(function(l) {
      return l.parent = o;
    }), e.namespace != null && (o.namespace = e.namespace), e["x-attribsNamespace"] && (o["x-attribsNamespace"] = mf({}, e["x-attribsNamespace"])), e["x-attribsPrefix"] && (o["x-attribsPrefix"] = mf({}, e["x-attribsPrefix"])), n = o;
  } else if (LY(e)) {
    var r = t ? jx(e.children) : [], i = new OY(r);
    r.forEach(function(u) {
      return u.parent = i;
    }), n = i;
  } else if (MY(e)) {
    var r = t ? jx(e.children) : [], a = new xY(r);
    r.forEach(function(u) {
      return u.parent = a;
    }), e["x-mode"] && (a["x-mode"] = e["x-mode"]), n = a;
  } else if (SY(e)) {
    var s = new CY(e.name, e.data);
    e["x-name"] != null && (s["x-name"] = e["x-name"], s["x-publicId"] = e["x-publicId"], s["x-systemId"] = e["x-systemId"]), n = s;
  } else
    throw new Error("Not implemented yet: ".concat(e.type));
  return n.startIndex = e.startIndex, n.endIndex = e.endIndex, e.sourceCodeLocation != null && (n.sourceCodeLocation = e.sourceCodeLocation), n;
}
on.cloneNode = DM;
function jx(e) {
  for (var t = e.map(function(r) {
    return DM(r, !0);
  }), n = 1; n < t.length; n++)
    t[n].prev = t[n - 1], t[n - 1].next = t[n];
  return t;
}
(function(e) {
  var t = yr && yr.__createBinding || (Object.create ? function(s, l, u, c) {
    c === void 0 && (c = u);
    var p = Object.getOwnPropertyDescriptor(l, u);
    (!p || ("get" in p ? !l.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
      return l[u];
    } }), Object.defineProperty(s, c, p);
  } : function(s, l, u, c) {
    c === void 0 && (c = u), s[c] = l[u];
  }), n = yr && yr.__exportStar || function(s, l) {
    for (var u in s) u !== "default" && !Object.prototype.hasOwnProperty.call(l, u) && t(l, s, u);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.DomHandler = void 0;
  var r = SM, o = on;
  n(on, e);
  var i = {
    withStartIndices: !1,
    withEndIndices: !1,
    xmlMode: !1
  }, a = (
    /** @class */
    function() {
      function s(l, u, c) {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null, typeof u == "function" && (c = u, u = i), typeof l == "object" && (u = l, l = void 0), this.callback = l ?? null, this.options = u ?? i, this.elementCB = c ?? null;
      }
      return s.prototype.onparserinit = function(l) {
        this.parser = l;
      }, s.prototype.onreset = function() {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null;
      }, s.prototype.onend = function() {
        this.done || (this.done = !0, this.parser = null, this.handleCallback(null));
      }, s.prototype.onerror = function(l) {
        this.handleCallback(l);
      }, s.prototype.onclosetag = function() {
        this.lastNode = null;
        var l = this.tagStack.pop();
        this.options.withEndIndices && (l.endIndex = this.parser.endIndex), this.elementCB && this.elementCB(l);
      }, s.prototype.onopentag = function(l, u) {
        var c = this.options.xmlMode ? r.ElementType.Tag : void 0, p = new o.Element(l, u, void 0, c);
        this.addNode(p), this.tagStack.push(p);
      }, s.prototype.ontext = function(l) {
        var u = this.lastNode;
        if (u && u.type === r.ElementType.Text)
          u.data += l, this.options.withEndIndices && (u.endIndex = this.parser.endIndex);
        else {
          var c = new o.Text(l);
          this.addNode(c), this.lastNode = c;
        }
      }, s.prototype.oncomment = function(l) {
        if (this.lastNode && this.lastNode.type === r.ElementType.Comment) {
          this.lastNode.data += l;
          return;
        }
        var u = new o.Comment(l);
        this.addNode(u), this.lastNode = u;
      }, s.prototype.oncommentend = function() {
        this.lastNode = null;
      }, s.prototype.oncdatastart = function() {
        var l = new o.Text(""), u = new o.CDATA([l]);
        this.addNode(u), l.parent = u, this.lastNode = l;
      }, s.prototype.oncdataend = function() {
        this.lastNode = null;
      }, s.prototype.onprocessinginstruction = function(l, u) {
        var c = new o.ProcessingInstruction(l, u);
        this.addNode(c);
      }, s.prototype.handleCallback = function(l) {
        if (typeof this.callback == "function")
          this.callback(l, this.dom);
        else if (l)
          throw l;
      }, s.prototype.addNode = function(l) {
        var u = this.tagStack[this.tagStack.length - 1], c = u.children[u.children.length - 1];
        this.options.withStartIndices && (l.startIndex = this.parser.startIndex), this.options.withEndIndices && (l.endIndex = this.parser.endIndex), u.children.push(l), c && (l.prev = c, c.next = l), l.parent = u, this.lastNode = null;
      }, s;
    }()
  );
  e.DomHandler = a, e.default = a;
})(PM);
var DY = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CARRIAGE_RETURN_PLACEHOLDER_REGEX = e.CARRIAGE_RETURN_PLACEHOLDER = e.CARRIAGE_RETURN_REGEX = e.CARRIAGE_RETURN = e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES = void 0, e.CASE_SENSITIVE_TAG_NAMES = [
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "linearGradient",
    "radialGradient",
    "textPath"
  ], e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES.reduce(function(t, n) {
    return t[n.toLowerCase()] = n, t;
  }, {}), e.CARRIAGE_RETURN = "\r", e.CARRIAGE_RETURN_REGEX = new RegExp(e.CARRIAGE_RETURN, "g"), e.CARRIAGE_RETURN_PLACEHOLDER = "__HTML_DOM_PARSER_CARRIAGE_RETURN_PLACEHOLDER_".concat(Date.now(), "__"), e.CARRIAGE_RETURN_PLACEHOLDER_REGEX = new RegExp(e.CARRIAGE_RETURN_PLACEHOLDER, "g");
})(DY);
Object.defineProperty(np, "__esModule", { value: !0 });
np.formatAttributes = TY;
np.escapeSpecialCharacters = Oye;
np.revertEscapedCharacters = jY;
np.formatDOM = AY;
var Pm = PM, mh = DY;
function wye(e) {
  return mh.CASE_SENSITIVE_TAG_NAMES_MAP[e];
}
function TY(e) {
  for (var t = {}, n = 0, r = e.length; n < r; n++) {
    var o = e[n];
    t[o.name] = o.value;
  }
  return t;
}
function Cye(e) {
  e = e.toLowerCase();
  var t = wye(e);
  return t || e;
}
function Oye(e) {
  return e.replace(mh.CARRIAGE_RETURN_REGEX, mh.CARRIAGE_RETURN_PLACEHOLDER);
}
function jY(e) {
  return e.replace(mh.CARRIAGE_RETURN_PLACEHOLDER_REGEX, mh.CARRIAGE_RETURN);
}
function AY(e, t, n) {
  t === void 0 && (t = null);
  for (var r = [], o, i = 0, a = e.length; i < a; i++) {
    var s = e[i];
    switch (s.nodeType) {
      case 1: {
        var l = Cye(s.nodeName);
        o = new Pm.Element(l, TY(s.attributes)), o.children = AY(
          // template children are on content
          l === "template" ? s.content.childNodes : s.childNodes,
          o
        );
        break;
      }
      case 3:
        o = new Pm.Text(jY(s.nodeValue));
        break;
      case 8:
        o = new Pm.Comment(s.nodeValue);
        break;
      default:
        continue;
    }
    var u = r[i - 1] || null;
    u && (u.next = o), o.parent = t, o.prev = u, o.next = null, r.push(o);
  }
  return n && (o = new Pm.ProcessingInstruction(n.substring(0, n.indexOf(" ")).toLowerCase(), n), o.next = r[0] || null, o.parent = t, r.unshift(o), r[1] && (r[1].prev = r[0])), r;
}
Object.defineProperty(_M, "__esModule", { value: !0 });
_M.default = _ye;
var xye = np, FN = "html", zN = "head", Sm = "body", Eye = /<([a-zA-Z]+[0-9]?)/, UN = /<head[^]*>/i, HN = /<body[^]*>/i, mb = function(e, t) {
  throw new Error("This browser does not support `document.implementation.createHTMLDocument`");
}, o_ = function(e, t) {
  throw new Error("This browser does not support `DOMParser.prototype.parseFromString`");
}, WN = typeof window == "object" && window.DOMParser;
if (typeof WN == "function") {
  var kye = new WN(), Lye = "text/html";
  o_ = function(e, t) {
    return t && (e = "<".concat(t, ">").concat(e, "</").concat(t, ">")), kye.parseFromString(e, Lye);
  }, mb = o_;
}
if (typeof document == "object" && document.implementation) {
  var Mm = document.implementation.createHTMLDocument();
  mb = function(e, t) {
    if (t) {
      var n = Mm.documentElement.querySelector(t);
      return n && (n.innerHTML = e), Mm;
    }
    return Mm.documentElement.innerHTML = e, Mm;
  };
}
var Dm = typeof document == "object" && document.createElement("template"), i_;
Dm && Dm.content && (i_ = function(e) {
  return Dm.innerHTML = e, Dm.content.childNodes;
});
function _ye(e) {
  var t, n;
  e = (0, xye.escapeSpecialCharacters)(e);
  var r = e.match(Eye), o = r && r[1] ? r[1].toLowerCase() : "";
  switch (o) {
    case FN: {
      var i = o_(e);
      if (!UN.test(e)) {
        var a = i.querySelector(zN);
        (t = a == null ? void 0 : a.parentNode) === null || t === void 0 || t.removeChild(a);
      }
      if (!HN.test(e)) {
        var a = i.querySelector(Sm);
        (n = a == null ? void 0 : a.parentNode) === null || n === void 0 || n.removeChild(a);
      }
      return i.querySelectorAll(FN);
    }
    case zN:
    case Sm: {
      var s = mb(e).querySelectorAll(o);
      return HN.test(e) && UN.test(e) ? s[0].parentNode.childNodes : s;
    }
    default: {
      if (i_)
        return i_(e);
      var a = mb(e, Sm).querySelector(Sm);
      return a.childNodes;
    }
  }
}
var Pye = yr && yr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(LM, "__esModule", { value: !0 });
LM.default = Tye;
var Sye = Pye(_M), Mye = np, Dye = /<(![a-zA-Z\s]+)>/;
function Tye(e) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e)
    return [];
  var t = e.match(Dye), n = t ? t[1] : void 0;
  return (0, Mye.formatDOM)((0, Sye.default)(e), null, n);
}
var vC = {}, Xs = {}, yC = {}, jye = 0;
yC.SAME = jye;
var Aye = 1;
yC.CAMELCASE = Aye;
yC.possibleStandardNames = {
  accept: 0,
  acceptCharset: 1,
  "accept-charset": "acceptCharset",
  accessKey: 1,
  action: 0,
  allowFullScreen: 1,
  alt: 0,
  as: 0,
  async: 0,
  autoCapitalize: 1,
  autoComplete: 1,
  autoCorrect: 1,
  autoFocus: 1,
  autoPlay: 1,
  autoSave: 1,
  capture: 0,
  cellPadding: 1,
  cellSpacing: 1,
  challenge: 0,
  charSet: 1,
  checked: 0,
  children: 0,
  cite: 0,
  class: "className",
  classID: 1,
  className: 1,
  cols: 0,
  colSpan: 1,
  content: 0,
  contentEditable: 1,
  contextMenu: 1,
  controls: 0,
  controlsList: 1,
  coords: 0,
  crossOrigin: 1,
  dangerouslySetInnerHTML: 1,
  data: 0,
  dateTime: 1,
  default: 0,
  defaultChecked: 1,
  defaultValue: 1,
  defer: 0,
  dir: 0,
  disabled: 0,
  disablePictureInPicture: 1,
  disableRemotePlayback: 1,
  download: 0,
  draggable: 0,
  encType: 1,
  enterKeyHint: 1,
  for: "htmlFor",
  form: 0,
  formMethod: 1,
  formAction: 1,
  formEncType: 1,
  formNoValidate: 1,
  formTarget: 1,
  frameBorder: 1,
  headers: 0,
  height: 0,
  hidden: 0,
  high: 0,
  href: 0,
  hrefLang: 1,
  htmlFor: 1,
  httpEquiv: 1,
  "http-equiv": "httpEquiv",
  icon: 0,
  id: 0,
  innerHTML: 1,
  inputMode: 1,
  integrity: 0,
  is: 0,
  itemID: 1,
  itemProp: 1,
  itemRef: 1,
  itemScope: 1,
  itemType: 1,
  keyParams: 1,
  keyType: 1,
  kind: 0,
  label: 0,
  lang: 0,
  list: 0,
  loop: 0,
  low: 0,
  manifest: 0,
  marginWidth: 1,
  marginHeight: 1,
  max: 0,
  maxLength: 1,
  media: 0,
  mediaGroup: 1,
  method: 0,
  min: 0,
  minLength: 1,
  multiple: 0,
  muted: 0,
  name: 0,
  noModule: 1,
  nonce: 0,
  noValidate: 1,
  open: 0,
  optimum: 0,
  pattern: 0,
  placeholder: 0,
  playsInline: 1,
  poster: 0,
  preload: 0,
  profile: 0,
  radioGroup: 1,
  readOnly: 1,
  referrerPolicy: 1,
  rel: 0,
  required: 0,
  reversed: 0,
  role: 0,
  rows: 0,
  rowSpan: 1,
  sandbox: 0,
  scope: 0,
  scoped: 0,
  scrolling: 0,
  seamless: 0,
  selected: 0,
  shape: 0,
  size: 0,
  sizes: 0,
  span: 0,
  spellCheck: 1,
  src: 0,
  srcDoc: 1,
  srcLang: 1,
  srcSet: 1,
  start: 0,
  step: 0,
  style: 0,
  summary: 0,
  tabIndex: 1,
  target: 0,
  title: 0,
  type: 0,
  useMap: 1,
  value: 0,
  width: 0,
  wmode: 0,
  wrap: 0,
  about: 0,
  accentHeight: 1,
  "accent-height": "accentHeight",
  accumulate: 0,
  additive: 0,
  alignmentBaseline: 1,
  "alignment-baseline": "alignmentBaseline",
  allowReorder: 1,
  alphabetic: 0,
  amplitude: 0,
  arabicForm: 1,
  "arabic-form": "arabicForm",
  ascent: 0,
  attributeName: 1,
  attributeType: 1,
  autoReverse: 1,
  azimuth: 0,
  baseFrequency: 1,
  baselineShift: 1,
  "baseline-shift": "baselineShift",
  baseProfile: 1,
  bbox: 0,
  begin: 0,
  bias: 0,
  by: 0,
  calcMode: 1,
  capHeight: 1,
  "cap-height": "capHeight",
  clip: 0,
  clipPath: 1,
  "clip-path": "clipPath",
  clipPathUnits: 1,
  clipRule: 1,
  "clip-rule": "clipRule",
  color: 0,
  colorInterpolation: 1,
  "color-interpolation": "colorInterpolation",
  colorInterpolationFilters: 1,
  "color-interpolation-filters": "colorInterpolationFilters",
  colorProfile: 1,
  "color-profile": "colorProfile",
  colorRendering: 1,
  "color-rendering": "colorRendering",
  contentScriptType: 1,
  contentStyleType: 1,
  cursor: 0,
  cx: 0,
  cy: 0,
  d: 0,
  datatype: 0,
  decelerate: 0,
  descent: 0,
  diffuseConstant: 1,
  direction: 0,
  display: 0,
  divisor: 0,
  dominantBaseline: 1,
  "dominant-baseline": "dominantBaseline",
  dur: 0,
  dx: 0,
  dy: 0,
  edgeMode: 1,
  elevation: 0,
  enableBackground: 1,
  "enable-background": "enableBackground",
  end: 0,
  exponent: 0,
  externalResourcesRequired: 1,
  fill: 0,
  fillOpacity: 1,
  "fill-opacity": "fillOpacity",
  fillRule: 1,
  "fill-rule": "fillRule",
  filter: 0,
  filterRes: 1,
  filterUnits: 1,
  floodOpacity: 1,
  "flood-opacity": "floodOpacity",
  floodColor: 1,
  "flood-color": "floodColor",
  focusable: 0,
  fontFamily: 1,
  "font-family": "fontFamily",
  fontSize: 1,
  "font-size": "fontSize",
  fontSizeAdjust: 1,
  "font-size-adjust": "fontSizeAdjust",
  fontStretch: 1,
  "font-stretch": "fontStretch",
  fontStyle: 1,
  "font-style": "fontStyle",
  fontVariant: 1,
  "font-variant": "fontVariant",
  fontWeight: 1,
  "font-weight": "fontWeight",
  format: 0,
  from: 0,
  fx: 0,
  fy: 0,
  g1: 0,
  g2: 0,
  glyphName: 1,
  "glyph-name": "glyphName",
  glyphOrientationHorizontal: 1,
  "glyph-orientation-horizontal": "glyphOrientationHorizontal",
  glyphOrientationVertical: 1,
  "glyph-orientation-vertical": "glyphOrientationVertical",
  glyphRef: 1,
  gradientTransform: 1,
  gradientUnits: 1,
  hanging: 0,
  horizAdvX: 1,
  "horiz-adv-x": "horizAdvX",
  horizOriginX: 1,
  "horiz-origin-x": "horizOriginX",
  ideographic: 0,
  imageRendering: 1,
  "image-rendering": "imageRendering",
  in2: 0,
  in: 0,
  inlist: 0,
  intercept: 0,
  k1: 0,
  k2: 0,
  k3: 0,
  k4: 0,
  k: 0,
  kernelMatrix: 1,
  kernelUnitLength: 1,
  kerning: 0,
  keyPoints: 1,
  keySplines: 1,
  keyTimes: 1,
  lengthAdjust: 1,
  letterSpacing: 1,
  "letter-spacing": "letterSpacing",
  lightingColor: 1,
  "lighting-color": "lightingColor",
  limitingConeAngle: 1,
  local: 0,
  markerEnd: 1,
  "marker-end": "markerEnd",
  markerHeight: 1,
  markerMid: 1,
  "marker-mid": "markerMid",
  markerStart: 1,
  "marker-start": "markerStart",
  markerUnits: 1,
  markerWidth: 1,
  mask: 0,
  maskContentUnits: 1,
  maskUnits: 1,
  mathematical: 0,
  mode: 0,
  numOctaves: 1,
  offset: 0,
  opacity: 0,
  operator: 0,
  order: 0,
  orient: 0,
  orientation: 0,
  origin: 0,
  overflow: 0,
  overlinePosition: 1,
  "overline-position": "overlinePosition",
  overlineThickness: 1,
  "overline-thickness": "overlineThickness",
  paintOrder: 1,
  "paint-order": "paintOrder",
  panose1: 0,
  "panose-1": "panose1",
  pathLength: 1,
  patternContentUnits: 1,
  patternTransform: 1,
  patternUnits: 1,
  pointerEvents: 1,
  "pointer-events": "pointerEvents",
  points: 0,
  pointsAtX: 1,
  pointsAtY: 1,
  pointsAtZ: 1,
  prefix: 0,
  preserveAlpha: 1,
  preserveAspectRatio: 1,
  primitiveUnits: 1,
  property: 0,
  r: 0,
  radius: 0,
  refX: 1,
  refY: 1,
  renderingIntent: 1,
  "rendering-intent": "renderingIntent",
  repeatCount: 1,
  repeatDur: 1,
  requiredExtensions: 1,
  requiredFeatures: 1,
  resource: 0,
  restart: 0,
  result: 0,
  results: 0,
  rotate: 0,
  rx: 0,
  ry: 0,
  scale: 0,
  security: 0,
  seed: 0,
  shapeRendering: 1,
  "shape-rendering": "shapeRendering",
  slope: 0,
  spacing: 0,
  specularConstant: 1,
  specularExponent: 1,
  speed: 0,
  spreadMethod: 1,
  startOffset: 1,
  stdDeviation: 1,
  stemh: 0,
  stemv: 0,
  stitchTiles: 1,
  stopColor: 1,
  "stop-color": "stopColor",
  stopOpacity: 1,
  "stop-opacity": "stopOpacity",
  strikethroughPosition: 1,
  "strikethrough-position": "strikethroughPosition",
  strikethroughThickness: 1,
  "strikethrough-thickness": "strikethroughThickness",
  string: 0,
  stroke: 0,
  strokeDasharray: 1,
  "stroke-dasharray": "strokeDasharray",
  strokeDashoffset: 1,
  "stroke-dashoffset": "strokeDashoffset",
  strokeLinecap: 1,
  "stroke-linecap": "strokeLinecap",
  strokeLinejoin: 1,
  "stroke-linejoin": "strokeLinejoin",
  strokeMiterlimit: 1,
  "stroke-miterlimit": "strokeMiterlimit",
  strokeWidth: 1,
  "stroke-width": "strokeWidth",
  strokeOpacity: 1,
  "stroke-opacity": "strokeOpacity",
  suppressContentEditableWarning: 1,
  suppressHydrationWarning: 1,
  surfaceScale: 1,
  systemLanguage: 1,
  tableValues: 1,
  targetX: 1,
  targetY: 1,
  textAnchor: 1,
  "text-anchor": "textAnchor",
  textDecoration: 1,
  "text-decoration": "textDecoration",
  textLength: 1,
  textRendering: 1,
  "text-rendering": "textRendering",
  to: 0,
  transform: 0,
  typeof: 0,
  u1: 0,
  u2: 0,
  underlinePosition: 1,
  "underline-position": "underlinePosition",
  underlineThickness: 1,
  "underline-thickness": "underlineThickness",
  unicode: 0,
  unicodeBidi: 1,
  "unicode-bidi": "unicodeBidi",
  unicodeRange: 1,
  "unicode-range": "unicodeRange",
  unitsPerEm: 1,
  "units-per-em": "unitsPerEm",
  unselectable: 0,
  vAlphabetic: 1,
  "v-alphabetic": "vAlphabetic",
  values: 0,
  vectorEffect: 1,
  "vector-effect": "vectorEffect",
  version: 0,
  vertAdvY: 1,
  "vert-adv-y": "vertAdvY",
  vertOriginX: 1,
  "vert-origin-x": "vertOriginX",
  vertOriginY: 1,
  "vert-origin-y": "vertOriginY",
  vHanging: 1,
  "v-hanging": "vHanging",
  vIdeographic: 1,
  "v-ideographic": "vIdeographic",
  viewBox: 1,
  viewTarget: 1,
  visibility: 0,
  vMathematical: 1,
  "v-mathematical": "vMathematical",
  vocab: 0,
  widths: 0,
  wordSpacing: 1,
  "word-spacing": "wordSpacing",
  writingMode: 1,
  "writing-mode": "writingMode",
  x1: 0,
  x2: 0,
  x: 0,
  xChannelSelector: 1,
  xHeight: 1,
  "x-height": "xHeight",
  xlinkActuate: 1,
  "xlink:actuate": "xlinkActuate",
  xlinkArcrole: 1,
  "xlink:arcrole": "xlinkArcrole",
  xlinkHref: 1,
  "xlink:href": "xlinkHref",
  xlinkRole: 1,
  "xlink:role": "xlinkRole",
  xlinkShow: 1,
  "xlink:show": "xlinkShow",
  xlinkTitle: 1,
  "xlink:title": "xlinkTitle",
  xlinkType: 1,
  "xlink:type": "xlinkType",
  xmlBase: 1,
  "xml:base": "xmlBase",
  xmlLang: 1,
  "xml:lang": "xmlLang",
  xmlns: 0,
  "xml:space": "xmlSpace",
  xmlnsXlink: 1,
  "xmlns:xlink": "xmlnsXlink",
  xmlSpace: 1,
  y1: 0,
  y2: 0,
  y: 0,
  yChannelSelector: 1,
  z: 0,
  zoomAndPan: 1
};
const RY = 0, bu = 1, bC = 2, wC = 3, TM = 4, IY = 5, NY = 6;
function Rye(e) {
  return li.hasOwnProperty(e) ? li[e] : null;
}
function Ii(e, t, n, r, o, i, a) {
  this.acceptsBooleans = t === bC || t === wC || t === TM, this.attributeName = r, this.attributeNamespace = o, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = i, this.removeEmptyString = a;
}
const li = {}, Iye = [
  "children",
  "dangerouslySetInnerHTML",
  // TODO: This prevents the assignment of defaultValue to regular
  // elements (not just inputs). Now that ReactDOMInput assigns to the
  // defaultValue property -- do we need this?
  "defaultValue",
  "defaultChecked",
  "innerHTML",
  "suppressContentEditableWarning",
  "suppressHydrationWarning",
  "style"
];
Iye.forEach((e) => {
  li[e] = new Ii(
    e,
    RY,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"]
].forEach(([e, t]) => {
  li[e] = new Ii(
    e,
    bu,
    !1,
    // mustUseProperty
    t,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["contentEditable", "draggable", "spellCheck", "value"].forEach((e) => {
  li[e] = new Ii(
    e,
    bC,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha"
].forEach((e) => {
  li[e] = new Ii(
    e,
    bC,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "allowFullScreen",
  "async",
  // Note: there is a special case that prevents it from being written to the DOM
  // on the client side because the browsers are inconsistent. Instead we call focus().
  "autoFocus",
  "autoPlay",
  "controls",
  "default",
  "defer",
  "disabled",
  "disablePictureInPicture",
  "disableRemotePlayback",
  "formNoValidate",
  "hidden",
  "loop",
  "noModule",
  "noValidate",
  "open",
  "playsInline",
  "readOnly",
  "required",
  "reversed",
  "scoped",
  "seamless",
  // Microdata
  "itemScope"
].forEach((e) => {
  li[e] = new Ii(
    e,
    wC,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "checked",
  // Note: `option.selected` is not updated if `select.multiple` is
  // disabled with `removeAttribute`. We have special logic for handling this.
  "multiple",
  "muted",
  "selected"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  li[e] = new Ii(
    e,
    wC,
    !0,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "capture",
  "download"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  li[e] = new Ii(
    e,
    TM,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "cols",
  "rows",
  "size",
  "span"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  li[e] = new Ii(
    e,
    NY,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["rowSpan", "start"].forEach((e) => {
  li[e] = new Ii(
    e,
    IY,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const jM = /[\-\:]([a-z])/g, AM = (e) => e[1].toUpperCase();
[
  "accent-height",
  "alignment-baseline",
  "arabic-form",
  "baseline-shift",
  "cap-height",
  "clip-path",
  "clip-rule",
  "color-interpolation",
  "color-interpolation-filters",
  "color-profile",
  "color-rendering",
  "dominant-baseline",
  "enable-background",
  "fill-opacity",
  "fill-rule",
  "flood-color",
  "flood-opacity",
  "font-family",
  "font-size",
  "font-size-adjust",
  "font-stretch",
  "font-style",
  "font-variant",
  "font-weight",
  "glyph-name",
  "glyph-orientation-horizontal",
  "glyph-orientation-vertical",
  "horiz-adv-x",
  "horiz-origin-x",
  "image-rendering",
  "letter-spacing",
  "lighting-color",
  "marker-end",
  "marker-mid",
  "marker-start",
  "overline-position",
  "overline-thickness",
  "paint-order",
  "panose-1",
  "pointer-events",
  "rendering-intent",
  "shape-rendering",
  "stop-color",
  "stop-opacity",
  "strikethrough-position",
  "strikethrough-thickness",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "text-anchor",
  "text-decoration",
  "text-rendering",
  "underline-position",
  "underline-thickness",
  "unicode-bidi",
  "unicode-range",
  "units-per-em",
  "v-alphabetic",
  "v-hanging",
  "v-ideographic",
  "v-mathematical",
  "vector-effect",
  "vert-adv-y",
  "vert-origin-x",
  "vert-origin-y",
  "word-spacing",
  "writing-mode",
  "xmlns:xlink",
  "x-height"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(jM, AM);
  li[t] = new Ii(
    t,
    bu,
    !1,
    // mustUseProperty
    e,
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xlink:actuate",
  "xlink:arcrole",
  "xlink:role",
  "xlink:show",
  "xlink:title",
  "xlink:type"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(jM, AM);
  li[t] = new Ii(
    t,
    bu,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/1999/xlink",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xml:base",
  "xml:lang",
  "xml:space"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(jM, AM);
  li[t] = new Ii(
    t,
    bu,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/XML/1998/namespace",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["tabIndex", "crossOrigin"].forEach((e) => {
  li[e] = new Ii(
    e,
    bu,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const Nye = "xlinkHref";
li[Nye] = new Ii(
  "xlinkHref",
  bu,
  !1,
  // mustUseProperty
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  // sanitizeURL
  !1
  // removeEmptyString
);
["src", "href", "action", "formAction"].forEach((e) => {
  li[e] = new Ii(
    e,
    bu,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !0,
    // sanitizeURL
    !0
    // removeEmptyString
  );
});
const {
  CAMELCASE: Bye,
  SAME: Fye,
  possibleStandardNames: $N
} = yC, zye = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", Uye = zye + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", Hye = RegExp.prototype.test.bind(
  // eslint-disable-next-line no-misleading-character-class
  new RegExp("^(data|aria)-[" + Uye + "]*$")
), Wye = Object.keys(
  $N
).reduce((e, t) => {
  const n = $N[t];
  return n === Fye ? e[t] = t : n === Bye ? e[t.toLowerCase()] = t : e[t] = n, e;
}, {});
Xs.BOOLEAN = wC;
Xs.BOOLEANISH_STRING = bC;
Xs.NUMERIC = IY;
Xs.OVERLOADED_BOOLEAN = TM;
Xs.POSITIVE_NUMERIC = NY;
Xs.RESERVED = RY;
Xs.STRING = bu;
Xs.getPropertyInfo = Rye;
Xs.isCustomAttribute = Hye;
Xs.possibleStandardNames = Wye;
var RM = {}, IM = {}, VN = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, $ye = /\n/g, Vye = /^\s*/, Zye = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, qye = /^:\s*/, Gye = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, Kye = /^[;\s]*/, Xye = /^\s+|\s+$/g, Yye = `
`, ZN = "/", qN = "*", cc = "", Jye = "comment", Qye = "declaration", ebe = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e) return [];
  t = t || {};
  var n = 1, r = 1;
  function o(f) {
    var m = f.match($ye);
    m && (n += m.length);
    var b = f.lastIndexOf(Yye);
    r = ~b ? f.length - b : r + f.length;
  }
  function i() {
    var f = { line: n, column: r };
    return function(m) {
      return m.position = new a(f), u(), m;
    };
  }
  function a(f) {
    this.start = f, this.end = { line: n, column: r }, this.source = t.source;
  }
  a.prototype.content = e;
  function s(f) {
    var m = new Error(
      t.source + ":" + n + ":" + r + ": " + f
    );
    if (m.reason = f, m.filename = t.source, m.line = n, m.column = r, m.source = e, !t.silent) throw m;
  }
  function l(f) {
    var m = f.exec(e);
    if (m) {
      var b = m[0];
      return o(b), e = e.slice(b.length), m;
    }
  }
  function u() {
    l(Vye);
  }
  function c(f) {
    var m;
    for (f = f || []; m = p(); )
      m !== !1 && f.push(m);
    return f;
  }
  function p() {
    var f = i();
    if (!(ZN != e.charAt(0) || qN != e.charAt(1))) {
      for (var m = 2; cc != e.charAt(m) && (qN != e.charAt(m) || ZN != e.charAt(m + 1)); )
        ++m;
      if (m += 2, cc === e.charAt(m - 1))
        return s("End of comment missing");
      var b = e.slice(2, m - 2);
      return r += 2, o(b), e = e.slice(m), r += 2, f({
        type: Jye,
        comment: b
      });
    }
  }
  function d() {
    var f = i(), m = l(Zye);
    if (m) {
      if (p(), !l(qye)) return s("property missing ':'");
      var b = l(Gye), E = f({
        type: Qye,
        property: GN(m[0].replace(VN, cc)),
        value: b ? GN(b[0].replace(VN, cc)) : cc
      });
      return l(Kye), E;
    }
  }
  function g() {
    var f = [];
    c(f);
    for (var m; m = d(); )
      m !== !1 && (f.push(m), c(f));
    return f;
  }
  return u(), g();
};
function GN(e) {
  return e ? e.replace(Xye, cc) : cc;
}
var tbe = yr && yr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(IM, "__esModule", { value: !0 });
IM.default = rbe;
var nbe = tbe(ebe);
function rbe(e, t) {
  var n = null;
  if (!e || typeof e != "string")
    return n;
  var r = (0, nbe.default)(e), o = typeof t == "function";
  return r.forEach(function(i) {
    if (i.type === "declaration") {
      var a = i.property, s = i.value;
      o ? t(a, s, i) : s && (n = n || {}, n[a] = s);
    }
  }), n;
}
var CC = {};
Object.defineProperty(CC, "__esModule", { value: !0 });
CC.camelCase = void 0;
var obe = /^--[a-zA-Z0-9_-]+$/, ibe = /-([a-z])/g, sbe = /^[^-]+$/, abe = /^-(webkit|moz|ms|o|khtml)-/, lbe = /^-(ms)-/, ube = function(e) {
  return !e || sbe.test(e) || obe.test(e);
}, cbe = function(e, t) {
  return t.toUpperCase();
}, KN = function(e, t) {
  return "".concat(t, "-");
}, pbe = function(e, t) {
  return t === void 0 && (t = {}), ube(e) ? e : (e = e.toLowerCase(), t.reactCompat ? e = e.replace(lbe, KN) : e = e.replace(abe, KN), e.replace(ibe, cbe));
};
CC.camelCase = pbe;
var dbe = yr && yr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
}, fbe = dbe(IM), hbe = CC;
function s_(e, t) {
  var n = {};
  return !e || typeof e != "string" || (0, fbe.default)(e, function(r, o) {
    r && o && (n[(0, hbe.camelCase)(r, t)] = o);
  }), n;
}
s_.default = s_;
var gbe = s_;
(function(e) {
  var t = yr && yr.__importDefault || function(c) {
    return c && c.__esModule ? c : { default: c };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.returnFirstArg = e.canTextBeChildOfNode = e.ELEMENTS_WITH_NO_TEXT_CHILDREN = e.PRESERVE_CUSTOM_ATTRIBUTES = void 0, e.isCustomComponent = i, e.setStyleProp = s;
  var n = be, r = t(gbe), o = /* @__PURE__ */ new Set([
    "annotation-xml",
    "color-profile",
    "font-face",
    "font-face-src",
    "font-face-uri",
    "font-face-format",
    "font-face-name",
    "missing-glyph"
  ]);
  function i(c, p) {
    return c.includes("-") ? !o.has(c) : !!(p && typeof p.is == "string");
  }
  var a = {
    reactCompat: !0
  };
  function s(c, p) {
    if (typeof c == "string") {
      if (!c.trim()) {
        p.style = {};
        return;
      }
      try {
        p.style = (0, r.default)(c, a);
      } catch {
        p.style = {};
      }
    }
  }
  e.PRESERVE_CUSTOM_ATTRIBUTES = Number(n.version.split(".")[0]) >= 16, e.ELEMENTS_WITH_NO_TEXT_CHILDREN = /* @__PURE__ */ new Set([
    "tr",
    "tbody",
    "thead",
    "tfoot",
    "colgroup",
    "table",
    "head",
    "html",
    "frameset"
  ]);
  var l = function(c) {
    return !e.ELEMENTS_WITH_NO_TEXT_CHILDREN.has(c.name);
  };
  e.canTextBeChildOfNode = l;
  var u = function(c) {
    return c;
  };
  e.returnFirstArg = u;
})(RM);
Object.defineProperty(vC, "__esModule", { value: !0 });
vC.default = bbe;
var Qd = Xs, XN = RM, mbe = ["checked", "value"], vbe = ["input", "select", "textarea"], ybe = {
  reset: !0,
  submit: !0
};
function bbe(e, t) {
  e === void 0 && (e = {});
  var n = {}, r = !!(e.type && ybe[e.type]);
  for (var o in e) {
    var i = e[o];
    if ((0, Qd.isCustomAttribute)(o)) {
      n[o] = i;
      continue;
    }
    var a = o.toLowerCase(), s = YN(a);
    if (s) {
      var l = (0, Qd.getPropertyInfo)(s);
      switch (mbe.includes(s) && vbe.includes(t) && !r && (s = YN("default" + a)), n[s] = i, l && l.type) {
        case Qd.BOOLEAN:
          n[s] = !0;
          break;
        case Qd.OVERLOADED_BOOLEAN:
          i === "" && (n[s] = !0);
          break;
      }
      continue;
    }
    XN.PRESERVE_CUSTOM_ATTRIBUTES && (n[o] = i);
  }
  return (0, XN.setStyleProp)(e.style, n), n;
}
function YN(e) {
  return Qd.possibleStandardNames[e];
}
var NM = {}, wbe = yr && yr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(NM, "__esModule", { value: !0 });
NM.default = BY;
var Ax = be, Cbe = wbe(vC), vf = RM, Obe = {
  cloneElement: Ax.cloneElement,
  createElement: Ax.createElement,
  isValidElement: Ax.isValidElement
};
function BY(e, t) {
  t === void 0 && (t = {});
  for (var n = [], r = typeof t.replace == "function", o = t.transform || vf.returnFirstArg, i = t.library || Obe, a = i.cloneElement, s = i.createElement, l = i.isValidElement, u = e.length, c = 0; c < u; c++) {
    var p = e[c];
    if (r) {
      var d = t.replace(p, c);
      if (l(d)) {
        u > 1 && (d = a(d, {
          key: d.key || c
        })), n.push(o(d, p, c));
        continue;
      }
    }
    if (p.type === "text") {
      var g = !p.data.trim().length;
      if (g && p.parent && !(0, vf.canTextBeChildOfNode)(p.parent) || t.trim && g)
        continue;
      n.push(o(p.data, p, c));
      continue;
    }
    var f = p, m = {};
    xbe(f) ? ((0, vf.setStyleProp)(f.attribs.style, f.attribs), m = f.attribs) : f.attribs && (m = (0, Cbe.default)(f.attribs, f.name));
    var b = void 0;
    switch (p.type) {
      case "script":
      case "style":
        p.children[0] && (m.dangerouslySetInnerHTML = {
          __html: p.children[0].data
        });
        break;
      case "tag":
        p.name === "textarea" && p.children[0] ? m.defaultValue = p.children[0].data : p.children && p.children.length && (b = BY(p.children, t));
        break;
      default:
        continue;
    }
    u > 1 && (m.key = c), n.push(o(s(p.name, m, b), p, c));
  }
  return n.length === 1 ? n[0] : n;
}
function xbe(e) {
  return vf.PRESERVE_CUSTOM_ATTRIBUTES && e.type === "tag" && (0, vf.isCustomComponent)(e.name, e.attribs);
}
(function(e) {
  var t = yr && yr.__importDefault || function(l) {
    return l && l.__esModule ? l : { default: l };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.htmlToDOM = e.domToReact = e.attributesToProps = e.Text = e.ProcessingInstruction = e.Element = e.Comment = void 0, e.default = s;
  var n = t(LM);
  e.htmlToDOM = n.default;
  var r = t(vC);
  e.attributesToProps = r.default;
  var o = t(NM);
  e.domToReact = o.default;
  var i = PM;
  Object.defineProperty(e, "Comment", { enumerable: !0, get: function() {
    return i.Comment;
  } }), Object.defineProperty(e, "Element", { enumerable: !0, get: function() {
    return i.Element;
  } }), Object.defineProperty(e, "ProcessingInstruction", { enumerable: !0, get: function() {
    return i.ProcessingInstruction;
  } }), Object.defineProperty(e, "Text", { enumerable: !0, get: function() {
    return i.Text;
  } });
  var a = { lowerCaseAttributeNames: !1 };
  function s(l, u) {
    if (typeof l != "string")
      throw new TypeError("First argument must be a string");
    return l ? (0, o.default)((0, n.default)(l, (u == null ? void 0 : u.htmlparser2) || a), u) : [];
  }
})(yY);
const Ebe = /* @__PURE__ */ Wve(yY);
Ebe.default;
var br = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function kbe(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var a_ = { exports: {} }, fd = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var JN;
function Lbe() {
  if (JN) return fd;
  JN = 1;
  var e = be, t = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, o = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, i = { key: !0, ref: !0, __self: !0, __source: !0 };
  function a(s, l, u) {
    var c, p = {}, d = null, g = null;
    u !== void 0 && (d = "" + u), l.key !== void 0 && (d = "" + l.key), l.ref !== void 0 && (g = l.ref);
    for (c in l) r.call(l, c) && !i.hasOwnProperty(c) && (p[c] = l[c]);
    if (s && s.defaultProps) for (c in l = s.defaultProps, l) p[c] === void 0 && (p[c] = l[c]);
    return { $$typeof: t, type: s, key: d, ref: g, props: p, _owner: o.current };
  }
  return fd.Fragment = n, fd.jsx = a, fd.jsxs = a, fd;
}
var Tm = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var QN;
function _be() {
  return QN || (QN = 1, process.env.NODE_ENV !== "production" && function() {
    var e = be, t = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), a = Symbol.for("react.provider"), s = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), c = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), d = Symbol.for("react.lazy"), g = Symbol.for("react.offscreen"), f = Symbol.iterator, m = "@@iterator";
    function b(y) {
      if (y === null || typeof y != "object")
        return null;
      var R = f && y[f] || y[m];
      return typeof R == "function" ? R : null;
    }
    var E = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function w(y) {
      {
        for (var R = arguments.length, G = new Array(R > 1 ? R - 1 : 0), ne = 1; ne < R; ne++)
          G[ne - 1] = arguments[ne];
        M("error", y, G);
      }
    }
    function M(y, R, G) {
      {
        var ne = E.ReactDebugCurrentFrame, ae = ne.getStackAddendum();
        ae !== "" && (R += "%s", G = G.concat([ae]));
        var ue = G.map(function(se) {
          return String(se);
        });
        ue.unshift("Warning: " + R), Function.prototype.apply.call(console[y], console, ue);
      }
    }
    var x = !1, v = !1, C = !1, P = !1, F = !1, L;
    L = Symbol.for("react.module.reference");
    function B(y) {
      return !!(typeof y == "string" || typeof y == "function" || y === r || y === i || F || y === o || y === u || y === c || P || y === g || x || v || C || typeof y == "object" && y !== null && (y.$$typeof === d || y.$$typeof === p || y.$$typeof === a || y.$$typeof === s || y.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      y.$$typeof === L || y.getModuleId !== void 0));
    }
    function N(y, R, G) {
      var ne = y.displayName;
      if (ne)
        return ne;
      var ae = R.displayName || R.name || "";
      return ae !== "" ? G + "(" + ae + ")" : G;
    }
    function $(y) {
      return y.displayName || "Context";
    }
    function V(y) {
      if (y == null)
        return null;
      if (typeof y.tag == "number" && w("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof y == "function")
        return y.displayName || y.name || null;
      if (typeof y == "string")
        return y;
      switch (y) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case i:
          return "Profiler";
        case o:
          return "StrictMode";
        case u:
          return "Suspense";
        case c:
          return "SuspenseList";
      }
      if (typeof y == "object")
        switch (y.$$typeof) {
          case s:
            var R = y;
            return $(R) + ".Consumer";
          case a:
            var G = y;
            return $(G._context) + ".Provider";
          case l:
            return N(y, y.render, "ForwardRef");
          case p:
            var ne = y.displayName || null;
            return ne !== null ? ne : V(y.type) || "Memo";
          case d: {
            var ae = y, ue = ae._payload, se = ae._init;
            try {
              return V(se(ue));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var H = Object.assign, Z = 0, K, Y, Q, J, _, D, z;
    function S() {
    }
    S.__reactDisabledLog = !0;
    function W() {
      {
        if (Z === 0) {
          K = console.log, Y = console.info, Q = console.warn, J = console.error, _ = console.group, D = console.groupCollapsed, z = console.groupEnd;
          var y = {
            configurable: !0,
            enumerable: !0,
            value: S,
            writable: !0
          };
          Object.defineProperties(console, {
            info: y,
            log: y,
            warn: y,
            error: y,
            group: y,
            groupCollapsed: y,
            groupEnd: y
          });
        }
        Z++;
      }
    }
    function O() {
      {
        if (Z--, Z === 0) {
          var y = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: H({}, y, {
              value: K
            }),
            info: H({}, y, {
              value: Y
            }),
            warn: H({}, y, {
              value: Q
            }),
            error: H({}, y, {
              value: J
            }),
            group: H({}, y, {
              value: _
            }),
            groupCollapsed: H({}, y, {
              value: D
            }),
            groupEnd: H({}, y, {
              value: z
            })
          });
        }
        Z < 0 && w("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var j = E.ReactCurrentDispatcher, U;
    function T(y, R, G) {
      {
        if (U === void 0)
          try {
            throw Error();
          } catch (ae) {
            var ne = ae.stack.trim().match(/\n( *(at )?)/);
            U = ne && ne[1] || "";
          }
        return `
` + U + y;
      }
    }
    var q = !1, A;
    {
      var X = typeof WeakMap == "function" ? WeakMap : Map;
      A = new X();
    }
    function I(y, R) {
      if (!y || q)
        return "";
      {
        var G = A.get(y);
        if (G !== void 0)
          return G;
      }
      var ne;
      q = !0;
      var ae = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var ue;
      ue = j.current, j.current = null, W();
      try {
        if (R) {
          var se = function() {
            throw Error();
          };
          if (Object.defineProperty(se.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(se, []);
            } catch (je) {
              ne = je;
            }
            Reflect.construct(y, [], se);
          } else {
            try {
              se.call();
            } catch (je) {
              ne = je;
            }
            y.call(se.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (je) {
            ne = je;
          }
          y();
        }
      } catch (je) {
        if (je && ne && typeof je.stack == "string") {
          for (var ie = je.stack.split(`
`), Oe = ne.stack.split(`
`), de = ie.length - 1, fe = Oe.length - 1; de >= 1 && fe >= 0 && ie[de] !== Oe[fe]; )
            fe--;
          for (; de >= 1 && fe >= 0; de--, fe--)
            if (ie[de] !== Oe[fe]) {
              if (de !== 1 || fe !== 1)
                do
                  if (de--, fe--, fe < 0 || ie[de] !== Oe[fe]) {
                    var ze = `
` + ie[de].replace(" at new ", " at ");
                    return y.displayName && ze.includes("<anonymous>") && (ze = ze.replace("<anonymous>", y.displayName)), typeof y == "function" && A.set(y, ze), ze;
                  }
                while (de >= 1 && fe >= 0);
              break;
            }
        }
      } finally {
        q = !1, j.current = ue, O(), Error.prepareStackTrace = ae;
      }
      var Et = y ? y.displayName || y.name : "", bt = Et ? T(Et) : "";
      return typeof y == "function" && A.set(y, bt), bt;
    }
    function le(y, R, G) {
      return I(y, !1);
    }
    function he(y) {
      var R = y.prototype;
      return !!(R && R.isReactComponent);
    }
    function oe(y, R, G) {
      if (y == null)
        return "";
      if (typeof y == "function")
        return I(y, he(y));
      if (typeof y == "string")
        return T(y);
      switch (y) {
        case u:
          return T("Suspense");
        case c:
          return T("SuspenseList");
      }
      if (typeof y == "object")
        switch (y.$$typeof) {
          case l:
            return le(y.render);
          case p:
            return oe(y.type, R, G);
          case d: {
            var ne = y, ae = ne._payload, ue = ne._init;
            try {
              return oe(ue(ae), R, G);
            } catch {
            }
          }
        }
      return "";
    }
    var Ae = Object.prototype.hasOwnProperty, Ue = {}, He = E.ReactDebugCurrentFrame;
    function Re(y) {
      if (y) {
        var R = y._owner, G = oe(y.type, y._source, R ? R.type : null);
        He.setExtraStackFrame(G);
      } else
        He.setExtraStackFrame(null);
    }
    function nt(y, R, G, ne, ae) {
      {
        var ue = Function.call.bind(Ae);
        for (var se in y)
          if (ue(y, se)) {
            var ie = void 0;
            try {
              if (typeof y[se] != "function") {
                var Oe = Error((ne || "React class") + ": " + G + " type `" + se + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof y[se] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw Oe.name = "Invariant Violation", Oe;
              }
              ie = y[se](R, se, ne, G, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (de) {
              ie = de;
            }
            ie && !(ie instanceof Error) && (Re(ae), w("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", ne || "React class", G, se, typeof ie), Re(null)), ie instanceof Error && !(ie.message in Ue) && (Ue[ie.message] = !0, Re(ae), w("Failed %s type: %s", G, ie.message), Re(null));
          }
      }
    }
    var Ve = Array.isArray;
    function we(y) {
      return Ve(y);
    }
    function et(y) {
      {
        var R = typeof Symbol == "function" && Symbol.toStringTag, G = R && y[Symbol.toStringTag] || y.constructor.name || "Object";
        return G;
      }
    }
    function lt(y) {
      try {
        return ye(y), !1;
      } catch {
        return !0;
      }
    }
    function ye(y) {
      return "" + y;
    }
    function ke(y) {
      if (lt(y))
        return w("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", et(y)), ye(y);
    }
    var Qe = E.ReactCurrentOwner, Fe = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, Ie, ot;
    function Ee(y) {
      if (Ae.call(y, "ref")) {
        var R = Object.getOwnPropertyDescriptor(y, "ref").get;
        if (R && R.isReactWarning)
          return !1;
      }
      return y.ref !== void 0;
    }
    function wt(y) {
      if (Ae.call(y, "key")) {
        var R = Object.getOwnPropertyDescriptor(y, "key").get;
        if (R && R.isReactWarning)
          return !1;
      }
      return y.key !== void 0;
    }
    function it(y, R) {
      typeof y.ref == "string" && Qe.current;
    }
    function st(y, R) {
      {
        var G = function() {
          Ie || (Ie = !0, w("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", R));
        };
        G.isReactWarning = !0, Object.defineProperty(y, "key", {
          get: G,
          configurable: !0
        });
      }
    }
    function ut(y, R) {
      {
        var G = function() {
          ot || (ot = !0, w("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", R));
        };
        G.isReactWarning = !0, Object.defineProperty(y, "ref", {
          get: G,
          configurable: !0
        });
      }
    }
    var Ct = function(y, R, G, ne, ae, ue, se) {
      var ie = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: y,
        key: R,
        ref: G,
        props: se,
        // Record the component responsible for creating this element.
        _owner: ue
      };
      return ie._store = {}, Object.defineProperty(ie._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(ie, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ne
      }), Object.defineProperty(ie, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ae
      }), Object.freeze && (Object.freeze(ie.props), Object.freeze(ie)), ie;
    };
    function ct(y, R, G, ne, ae) {
      {
        var ue, se = {}, ie = null, Oe = null;
        G !== void 0 && (ke(G), ie = "" + G), wt(R) && (ke(R.key), ie = "" + R.key), Ee(R) && (Oe = R.ref, it(R));
        for (ue in R)
          Ae.call(R, ue) && !Fe.hasOwnProperty(ue) && (se[ue] = R[ue]);
        if (y && y.defaultProps) {
          var de = y.defaultProps;
          for (ue in de)
            se[ue] === void 0 && (se[ue] = de[ue]);
        }
        if (ie || Oe) {
          var fe = typeof y == "function" ? y.displayName || y.name || "Unknown" : y;
          ie && st(se, fe), Oe && ut(se, fe);
        }
        return Ct(y, ie, Oe, ae, ne, Qe.current, se);
      }
    }
    var pt = E.ReactCurrentOwner, rt = E.ReactDebugCurrentFrame;
    function We(y) {
      if (y) {
        var R = y._owner, G = oe(y.type, y._source, R ? R.type : null);
        rt.setExtraStackFrame(G);
      } else
        rt.setExtraStackFrame(null);
    }
    var Ot;
    Ot = !1;
    function xt(y) {
      return typeof y == "object" && y !== null && y.$$typeof === t;
    }
    function gt() {
      {
        if (pt.current) {
          var y = V(pt.current.type);
          if (y)
            return `

Check the render method of \`` + y + "`.";
        }
        return "";
      }
    }
    function Ht(y) {
      return "";
    }
    var mt = {};
    function Wt(y) {
      {
        var R = gt();
        if (!R) {
          var G = typeof y == "string" ? y : y.displayName || y.name;
          G && (R = `

Check the top-level render call using <` + G + ">.");
        }
        return R;
      }
    }
    function vt(y, R) {
      {
        if (!y._store || y._store.validated || y.key != null)
          return;
        y._store.validated = !0;
        var G = Wt(R);
        if (mt[G])
          return;
        mt[G] = !0;
        var ne = "";
        y && y._owner && y._owner !== pt.current && (ne = " It was passed a child from " + V(y._owner.type) + "."), We(y), w('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', G, ne), We(null);
      }
    }
    function kt(y, R) {
      {
        if (typeof y != "object")
          return;
        if (we(y))
          for (var G = 0; G < y.length; G++) {
            var ne = y[G];
            xt(ne) && vt(ne, R);
          }
        else if (xt(y))
          y._store && (y._store.validated = !0);
        else if (y) {
          var ae = b(y);
          if (typeof ae == "function" && ae !== y.entries)
            for (var ue = ae.call(y), se; !(se = ue.next()).done; )
              xt(se.value) && vt(se.value, R);
        }
      }
    }
    function Un(y) {
      {
        var R = y.type;
        if (R == null || typeof R == "string")
          return;
        var G;
        if (typeof R == "function")
          G = R.propTypes;
        else if (typeof R == "object" && (R.$$typeof === l || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        R.$$typeof === p))
          G = R.propTypes;
        else
          return;
        if (G) {
          var ne = V(R);
          nt(G, y.props, "prop", ne, y);
        } else if (R.PropTypes !== void 0 && !Ot) {
          Ot = !0;
          var ae = V(R);
          w("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", ae || "Unknown");
        }
        typeof R.getDefaultProps == "function" && !R.getDefaultProps.isReactClassApproved && w("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function yt(y) {
      {
        for (var R = Object.keys(y.props), G = 0; G < R.length; G++) {
          var ne = R[G];
          if (ne !== "children" && ne !== "key") {
            We(y), w("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", ne), We(null);
            break;
          }
        }
        y.ref !== null && (We(y), w("Invalid attribute `ref` supplied to `React.Fragment`."), We(null));
      }
    }
    var re = {};
    function ao(y, R, G, ne, ae, ue) {
      {
        var se = B(y);
        if (!se) {
          var ie = "";
          (y === void 0 || typeof y == "object" && y !== null && Object.keys(y).length === 0) && (ie += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var Oe = Ht();
          Oe ? ie += Oe : ie += gt();
          var de;
          y === null ? de = "null" : we(y) ? de = "array" : y !== void 0 && y.$$typeof === t ? (de = "<" + (V(y.type) || "Unknown") + " />", ie = " Did you accidentally export a JSX literal instead of a component?") : de = typeof y, w("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", de, ie);
        }
        var fe = ct(y, R, G, ae, ue);
        if (fe == null)
          return fe;
        if (se) {
          var ze = R.children;
          if (ze !== void 0)
            if (ne)
              if (we(ze)) {
                for (var Et = 0; Et < ze.length; Et++)
                  kt(ze[Et], y);
                Object.freeze && Object.freeze(ze);
              } else
                w("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              kt(ze, y);
        }
        if (Ae.call(R, "key")) {
          var bt = V(y), je = Object.keys(R).filter(function(Li) {
            return Li !== "key";
          }), Hn = je.length > 0 ? "{key: someKey, " + je.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!re[bt + Hn]) {
            var ki = je.length > 0 ? "{" + je.join(": ..., ") + ": ...}" : "{}";
            w(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, Hn, bt, ki, bt), re[bt + Hn] = !0;
          }
        }
        return y === r ? yt(fe) : Un(fe), fe;
      }
    }
    function Ci(y, R, G) {
      return ao(y, R, G, !0);
    }
    function Oi(y, R, G) {
      return ao(y, R, G, !1);
    }
    var xi = Oi, Ei = Ci;
    Tm.Fragment = r, Tm.jsx = xi, Tm.jsxs = Ei;
  }()), Tm;
}
process.env.NODE_ENV === "production" ? a_.exports = Lbe() : a_.exports = _be();
var ti = a_.exports;
$e({});
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function eB(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function mi(e) {
  var t, n;
  return eB(e) === !1 ? !1 : (t = e.constructor, t === void 0 ? !0 : (n = t.prototype, !(eB(n) === !1 || n.hasOwnProperty("isPrototypeOf") === !1)));
}
var FY = Symbol.for("immer-nothing"), tB = Symbol.for("immer-draftable"), Ms = Symbol.for("immer-state"), Pbe = process.env.NODE_ENV !== "production" ? [
  // All error codes, starting by 0:
  function(e) {
    return `The plugin for '${e}' has not been loaded into Immer. To enable the plugin, import and call \`enable${e}()\` when initializing your application.`;
  },
  function(e) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${e}'`;
  },
  "This object has been frozen and should not be mutated",
  function(e) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + e;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(e) {
    return `'current' expects a draft, got: ${e}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(e) {
    return `'original' expects a draft, got: ${e}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function qi(e, ...t) {
  if (process.env.NODE_ENV !== "production") {
    const n = Pbe[e], r = typeof n == "function" ? n.apply(null, t) : n;
    throw new Error(`[Immer] ${r}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var Lp = Object.getPrototypeOf;
function Vc(e) {
  return !!e && !!e[Ms];
}
function Zc(e) {
  var t;
  return e ? zY(e) || Array.isArray(e) || !!e[tB] || !!((t = e.constructor) != null && t[tB]) || xC(e) || EC(e) : !1;
}
var Sbe = Object.prototype.constructor.toString();
function zY(e) {
  if (!e || typeof e != "object")
    return !1;
  const t = Lp(e);
  if (t === null)
    return !0;
  const n = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
  return n === Object ? !0 : typeof n == "function" && Function.toString.call(n) === Sbe;
}
function vb(e, t) {
  OC(e) === 0 ? Reflect.ownKeys(e).forEach((n) => {
    t(n, e[n], e);
  }) : e.forEach((n, r) => t(r, n, e));
}
function OC(e) {
  const t = e[Ms];
  return t ? t.type_ : Array.isArray(e) ? 1 : xC(e) ? 2 : EC(e) ? 3 : 0;
}
function l_(e, t) {
  return OC(e) === 2 ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t);
}
function UY(e, t, n) {
  const r = OC(e);
  r === 2 ? e.set(t, n) : r === 3 ? e.add(n) : e[t] = n;
}
function Mbe(e, t) {
  return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && t !== t;
}
function xC(e) {
  return e instanceof Map;
}
function EC(e) {
  return e instanceof Set;
}
function nc(e) {
  return e.copy_ || e.base_;
}
function u_(e, t) {
  if (xC(e))
    return new Map(e);
  if (EC(e))
    return new Set(e);
  if (Array.isArray(e))
    return Array.prototype.slice.call(e);
  const n = zY(e);
  if (t === !0 || t === "class_only" && !n) {
    const r = Object.getOwnPropertyDescriptors(e);
    delete r[Ms];
    let o = Reflect.ownKeys(r);
    for (let i = 0; i < o.length; i++) {
      const a = o[i], s = r[a];
      s.writable === !1 && (s.writable = !0, s.configurable = !0), (s.get || s.set) && (r[a] = {
        configurable: !0,
        writable: !0,
        // could live with !!desc.set as well here...
        enumerable: s.enumerable,
        value: e[a]
      });
    }
    return Object.create(Lp(e), r);
  } else {
    const r = Lp(e);
    if (r !== null && n)
      return { ...e };
    const o = Object.create(r);
    return Object.assign(o, e);
  }
}
function BM(e, t = !1) {
  return kC(e) || Vc(e) || !Zc(e) || (OC(e) > 1 && (e.set = e.add = e.clear = e.delete = Dbe), Object.freeze(e), t && Object.entries(e).forEach(([n, r]) => BM(r, !0))), e;
}
function Dbe() {
  qi(2);
}
function kC(e) {
  return Object.isFrozen(e);
}
var Tbe = {};
function qc(e) {
  const t = Tbe[e];
  return t || qi(0, e), t;
}
var vh;
function HY() {
  return vh;
}
function jbe(e, t) {
  return {
    drafts_: [],
    parent_: e,
    immer_: t,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0
  };
}
function nB(e, t) {
  t && (qc("Patches"), e.patches_ = [], e.inversePatches_ = [], e.patchListener_ = t);
}
function c_(e) {
  p_(e), e.drafts_.forEach(Abe), e.drafts_ = null;
}
function p_(e) {
  e === vh && (vh = e.parent_);
}
function rB(e) {
  return vh = jbe(vh, e);
}
function Abe(e) {
  const t = e[Ms];
  t.type_ === 0 || t.type_ === 1 ? t.revoke_() : t.revoked_ = !0;
}
function oB(e, t) {
  t.unfinalizedDrafts_ = t.drafts_.length;
  const n = t.drafts_[0];
  return e !== void 0 && e !== n ? (n[Ms].modified_ && (c_(t), qi(4)), Zc(e) && (e = yb(t, e), t.parent_ || bb(t, e)), t.patches_ && qc("Patches").generateReplacementPatches_(
    n[Ms].base_,
    e,
    t.patches_,
    t.inversePatches_
  )) : e = yb(t, n, []), c_(t), t.patches_ && t.patchListener_(t.patches_, t.inversePatches_), e !== FY ? e : void 0;
}
function yb(e, t, n) {
  if (kC(t))
    return t;
  const r = t[Ms];
  if (!r)
    return vb(
      t,
      (o, i) => iB(e, r, t, o, i, n)
    ), t;
  if (r.scope_ !== e)
    return t;
  if (!r.modified_)
    return bb(e, r.base_, !0), r.base_;
  if (!r.finalized_) {
    r.finalized_ = !0, r.scope_.unfinalizedDrafts_--;
    const o = r.copy_;
    let i = o, a = !1;
    r.type_ === 3 && (i = new Set(o), o.clear(), a = !0), vb(
      i,
      (s, l) => iB(e, r, o, s, l, n, a)
    ), bb(e, o, !1), n && e.patches_ && qc("Patches").generatePatches_(
      r,
      n,
      e.patches_,
      e.inversePatches_
    );
  }
  return r.copy_;
}
function iB(e, t, n, r, o, i, a) {
  if (process.env.NODE_ENV !== "production" && o === n && qi(5), Vc(o)) {
    const s = i && t && t.type_ !== 3 && // Set objects are atomic since they have no keys.
    !l_(t.assigned_, r) ? i.concat(r) : void 0, l = yb(e, o, s);
    if (UY(n, r, l), Vc(l))
      e.canAutoFreeze_ = !1;
    else
      return;
  } else a && n.add(o);
  if (Zc(o) && !kC(o)) {
    if (!e.immer_.autoFreeze_ && e.unfinalizedDrafts_ < 1)
      return;
    yb(e, o), (!t || !t.scope_.parent_) && typeof r != "symbol" && Object.prototype.propertyIsEnumerable.call(n, r) && bb(e, o);
  }
}
function bb(e, t, n = !1) {
  !e.parent_ && e.immer_.autoFreeze_ && e.canAutoFreeze_ && BM(t, n);
}
function Rbe(e, t) {
  const n = Array.isArray(e), r = {
    type_: n ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: t ? t.scope_ : HY(),
    // True for both shallow and deep changes.
    modified_: !1,
    // Used during finalization.
    finalized_: !1,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: t,
    // The base state.
    base_: e,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: !1
  };
  let o = r, i = FM;
  n && (o = [r], i = yh);
  const { revoke: a, proxy: s } = Proxy.revocable(o, i);
  return r.draft_ = s, r.revoke_ = a, s;
}
var FM = {
  get(e, t) {
    if (t === Ms)
      return e;
    const n = nc(e);
    if (!l_(n, t))
      return Ibe(e, n, t);
    const r = n[t];
    return e.finalized_ || !Zc(r) ? r : r === Rx(e.base_, t) ? (Ix(e), e.copy_[t] = f_(r, e)) : r;
  },
  has(e, t) {
    return t in nc(e);
  },
  ownKeys(e) {
    return Reflect.ownKeys(nc(e));
  },
  set(e, t, n) {
    const r = WY(nc(e), t);
    if (r != null && r.set)
      return r.set.call(e.draft_, n), !0;
    if (!e.modified_) {
      const o = Rx(nc(e), t), i = o == null ? void 0 : o[Ms];
      if (i && i.base_ === n)
        return e.copy_[t] = n, e.assigned_[t] = !1, !0;
      if (Mbe(n, o) && (n !== void 0 || l_(e.base_, t)))
        return !0;
      Ix(e), d_(e);
    }
    return e.copy_[t] === n && // special case: handle new props with value 'undefined'
    (n !== void 0 || t in e.copy_) || // special case: NaN
    Number.isNaN(n) && Number.isNaN(e.copy_[t]) || (e.copy_[t] = n, e.assigned_[t] = !0), !0;
  },
  deleteProperty(e, t) {
    return Rx(e.base_, t) !== void 0 || t in e.base_ ? (e.assigned_[t] = !1, Ix(e), d_(e)) : delete e.assigned_[t], e.copy_ && delete e.copy_[t], !0;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(e, t) {
    const n = nc(e), r = Reflect.getOwnPropertyDescriptor(n, t);
    return r && {
      writable: !0,
      configurable: e.type_ !== 1 || t !== "length",
      enumerable: r.enumerable,
      value: n[t]
    };
  },
  defineProperty() {
    qi(11);
  },
  getPrototypeOf(e) {
    return Lp(e.base_);
  },
  setPrototypeOf() {
    qi(12);
  }
}, yh = {};
vb(FM, (e, t) => {
  yh[e] = function() {
    return arguments[0] = arguments[0][0], t.apply(this, arguments);
  };
});
yh.deleteProperty = function(e, t) {
  return process.env.NODE_ENV !== "production" && isNaN(parseInt(t)) && qi(13), yh.set.call(this, e, t, void 0);
};
yh.set = function(e, t, n) {
  return process.env.NODE_ENV !== "production" && t !== "length" && isNaN(parseInt(t)) && qi(14), FM.set.call(this, e[0], t, n, e[0]);
};
function Rx(e, t) {
  const n = e[Ms];
  return (n ? nc(n) : e)[t];
}
function Ibe(e, t, n) {
  var r;
  const o = WY(t, n);
  return o ? "value" in o ? o.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (r = o.get) == null ? void 0 : r.call(e.draft_)
  ) : void 0;
}
function WY(e, t) {
  if (!(t in e))
    return;
  let n = Lp(e);
  for (; n; ) {
    const r = Object.getOwnPropertyDescriptor(n, t);
    if (r)
      return r;
    n = Lp(n);
  }
}
function d_(e) {
  e.modified_ || (e.modified_ = !0, e.parent_ && d_(e.parent_));
}
function Ix(e) {
  e.copy_ || (e.copy_ = u_(
    e.base_,
    e.scope_.immer_.useStrictShallowCopy_
  ));
}
var Nbe = class {
  constructor(e) {
    this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.produce = (t, n, r) => {
      if (typeof t == "function" && typeof n != "function") {
        const i = n;
        n = t;
        const a = this;
        return function(s = i, ...l) {
          return a.produce(s, (u) => n.call(this, u, ...l));
        };
      }
      typeof n != "function" && qi(6), r !== void 0 && typeof r != "function" && qi(7);
      let o;
      if (Zc(t)) {
        const i = rB(this), a = f_(t, void 0);
        let s = !0;
        try {
          o = n(a), s = !1;
        } finally {
          s ? c_(i) : p_(i);
        }
        return nB(i, r), oB(o, i);
      } else if (!t || typeof t != "object") {
        if (o = n(t), o === void 0 && (o = t), o === FY && (o = void 0), this.autoFreeze_ && BM(o, !0), r) {
          const i = [], a = [];
          qc("Patches").generateReplacementPatches_(t, o, i, a), r(i, a);
        }
        return o;
      } else
        qi(1, t);
    }, this.produceWithPatches = (t, n) => {
      if (typeof t == "function")
        return (i, ...a) => this.produceWithPatches(i, (s) => t(s, ...a));
      let r, o;
      return [this.produce(t, n, (i, a) => {
        r = i, o = a;
      }), r, o];
    }, typeof (e == null ? void 0 : e.autoFreeze) == "boolean" && this.setAutoFreeze(e.autoFreeze), typeof (e == null ? void 0 : e.useStrictShallowCopy) == "boolean" && this.setUseStrictShallowCopy(e.useStrictShallowCopy);
  }
  createDraft(e) {
    Zc(e) || qi(8), Vc(e) && (e = Bbe(e));
    const t = rB(this), n = f_(e, void 0);
    return n[Ms].isManual_ = !0, p_(t), n;
  }
  finishDraft(e, t) {
    const n = e && e[Ms];
    (!n || !n.isManual_) && qi(9);
    const { scope_: r } = n;
    return nB(r, t), oB(void 0, r);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(e) {
    this.autoFreeze_ = e;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(e) {
    this.useStrictShallowCopy_ = e;
  }
  applyPatches(e, t) {
    let n;
    for (n = t.length - 1; n >= 0; n--) {
      const o = t[n];
      if (o.path.length === 0 && o.op === "replace") {
        e = o.value;
        break;
      }
    }
    n > -1 && (t = t.slice(n + 1));
    const r = qc("Patches").applyPatches_;
    return Vc(e) ? r(e, t) : this.produce(
      e,
      (o) => r(o, t)
    );
  }
};
function f_(e, t) {
  const n = xC(e) ? qc("MapSet").proxyMap_(e, t) : EC(e) ? qc("MapSet").proxySet_(e, t) : Rbe(e, t);
  return (t ? t.scope_ : HY()).drafts_.push(n), n;
}
function Bbe(e) {
  return Vc(e) || qi(10, e), $Y(e);
}
function $Y(e) {
  if (!Zc(e) || kC(e))
    return e;
  const t = e[Ms];
  let n;
  if (t) {
    if (!t.modified_)
      return t.base_;
    t.finalized_ = !0, n = u_(e, t.scope_.immer_.useStrictShallowCopy_);
  } else
    n = u_(e, !0);
  return vb(n, (r, o) => {
    UY(n, r, $Y(o));
  }), t && (t.finalized_ = !1), n;
}
var Ds = new Nbe(), zM = Ds.produce;
Ds.produceWithPatches.bind(
  Ds
);
Ds.setAutoFreeze.bind(Ds);
Ds.setUseStrictShallowCopy.bind(Ds);
Ds.applyPatches.bind(Ds);
var sB = Ds.createDraft.bind(Ds), aB = Ds.finishDraft.bind(Ds), Ye = {
  ancestors(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = Ye.levels(e, t);
    return n ? r = r.slice(1) : r = r.slice(0, -1), r;
  },
  common(e, t) {
    for (var n = [], r = 0; r < e.length && r < t.length; r++) {
      var o = e[r], i = t[r];
      if (o !== i)
        break;
      n.push(o);
    }
    return n;
  },
  compare(e, t) {
    for (var n = Math.min(e.length, t.length), r = 0; r < n; r++) {
      if (e[r] < t[r]) return -1;
      if (e[r] > t[r]) return 1;
    }
    return 0;
  },
  endsAfter(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return Ye.equals(r, o) && i > a;
  },
  endsAt(e, t) {
    var n = e.length, r = e.slice(0, n), o = t.slice(0, n);
    return Ye.equals(r, o);
  },
  endsBefore(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return Ye.equals(r, o) && i < a;
  },
  equals(e, t) {
    return e.length === t.length && e.every((n, r) => n === t[r]);
  },
  hasPrevious(e) {
    return e[e.length - 1] > 0;
  },
  isAfter(e, t) {
    return Ye.compare(e, t) === 1;
  },
  isAncestor(e, t) {
    return e.length < t.length && Ye.compare(e, t) === 0;
  },
  isBefore(e, t) {
    return Ye.compare(e, t) === -1;
  },
  isChild(e, t) {
    return e.length === t.length + 1 && Ye.compare(e, t) === 0;
  },
  isCommon(e, t) {
    return e.length <= t.length && Ye.compare(e, t) === 0;
  },
  isDescendant(e, t) {
    return e.length > t.length && Ye.compare(e, t) === 0;
  },
  isParent(e, t) {
    return e.length + 1 === t.length && Ye.compare(e, t) === 0;
  },
  isPath(e) {
    return Array.isArray(e) && (e.length === 0 || typeof e[0] == "number");
  },
  isSibling(e, t) {
    if (e.length !== t.length)
      return !1;
    var n = e.slice(0, -1), r = t.slice(0, -1), o = e[e.length - 1], i = t[t.length - 1];
    return o !== i && Ye.equals(n, r);
  },
  levels(e) {
    for (var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = [], o = 0; o <= e.length; o++)
      r.push(e.slice(0, o));
    return n && r.reverse(), r;
  },
  next(e) {
    if (e.length === 0)
      throw new Error("Cannot get the next path of a root path [".concat(e, "], because it has no next index."));
    var t = e[e.length - 1];
    return e.slice(0, -1).concat(t + 1);
  },
  operationCanTransformPath(e) {
    switch (e.type) {
      case "insert_node":
      case "remove_node":
      case "merge_node":
      case "split_node":
      case "move_node":
        return !0;
      default:
        return !1;
    }
  },
  parent(e) {
    if (e.length === 0)
      throw new Error("Cannot get the parent path of the root path [".concat(e, "]."));
    return e.slice(0, -1);
  },
  previous(e) {
    if (e.length === 0)
      throw new Error("Cannot get the previous path of a root path [".concat(e, "], because it has no previous index."));
    var t = e[e.length - 1];
    if (t <= 0)
      throw new Error("Cannot get the previous path of a first child path [".concat(e, "] because it would result in a negative index."));
    return e.slice(0, -1).concat(t - 1);
  },
  relative(e, t) {
    if (!Ye.isAncestor(t, e) && !Ye.equals(e, t))
      throw new Error("Cannot get the relative path of [".concat(e, "] inside ancestor [").concat(t, "], because it is not above or equal to the path."));
    return e.slice(t.length);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!e) return null;
    var r = [...e], {
      affinity: o = "forward"
    } = n;
    if (e.length === 0)
      return r;
    switch (t.type) {
      case "insert_node": {
        var {
          path: i
        } = t;
        (Ye.equals(i, r) || Ye.endsBefore(i, r) || Ye.isAncestor(i, r)) && (r[i.length - 1] += 1);
        break;
      }
      case "remove_node": {
        var {
          path: a
        } = t;
        if (Ye.equals(a, r) || Ye.isAncestor(a, r))
          return null;
        Ye.endsBefore(a, r) && (r[a.length - 1] -= 1);
        break;
      }
      case "merge_node": {
        var {
          path: s,
          position: l
        } = t;
        Ye.equals(s, r) || Ye.endsBefore(s, r) ? r[s.length - 1] -= 1 : Ye.isAncestor(s, r) && (r[s.length - 1] -= 1, r[s.length] += l);
        break;
      }
      case "split_node": {
        var {
          path: u,
          position: c
        } = t;
        if (Ye.equals(u, r)) {
          if (o === "forward")
            r[r.length - 1] += 1;
          else if (o !== "backward") return null;
        } else Ye.endsBefore(u, r) ? r[u.length - 1] += 1 : Ye.isAncestor(u, r) && e[u.length] >= c && (r[u.length - 1] += 1, r[u.length] -= c);
        break;
      }
      case "move_node": {
        var {
          path: p,
          newPath: d
        } = t;
        if (Ye.equals(p, d))
          return r;
        if (Ye.isAncestor(p, r) || Ye.equals(p, r)) {
          var g = d.slice();
          return Ye.endsBefore(p, d) && p.length < d.length && (g[p.length - 1] -= 1), g.concat(r.slice(p.length));
        } else Ye.isSibling(p, d) && (Ye.isAncestor(d, r) || Ye.equals(d, r)) ? Ye.endsBefore(p, r) ? r[p.length - 1] -= 1 : r[p.length - 1] += 1 : Ye.endsBefore(d, r) || Ye.equals(d, r) || Ye.isAncestor(d, r) ? (Ye.endsBefore(p, r) && (r[p.length - 1] -= 1), r[d.length - 1] += 1) : Ye.endsBefore(p, r) && (Ye.equals(d, r) && (r[d.length - 1] += 1), r[p.length - 1] -= 1);
        break;
      }
    }
    return r;
  }
};
function bh(e) {
  "@babel/helpers - typeof";
  return bh = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, bh(e);
}
function Fbe(e, t) {
  if (bh(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (bh(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function zbe(e) {
  var t = Fbe(e, "string");
  return bh(t) === "symbol" ? t : String(t);
}
function Ip(e, t, n) {
  return t = zbe(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function lB(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function hd(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? lB(Object(n), !0).forEach(function(r) {
      Ip(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : lB(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Ube = (e, t, n) => {
  switch (n.type) {
    case "insert_node": {
      var {
        path: r,
        node: o
      } = n, i = Tt.parent(e, r), a = r[r.length - 1];
      if (a > i.children.length)
        throw new Error('Cannot apply an "insert_node" operation at path ['.concat(r, "] because the destination is past the end of the node."));
      if (i.children.splice(a, 0, o), t)
        for (var [s, l] of Xt.points(t))
          t[l] = Ar.transform(s, n);
      break;
    }
    case "insert_text": {
      var {
        path: u,
        offset: c,
        text: p
      } = n;
      if (p.length === 0) break;
      var d = Tt.leaf(e, u), g = d.text.slice(0, c), f = d.text.slice(c);
      if (d.text = g + p + f, t)
        for (var [m, b] of Xt.points(t))
          t[b] = Ar.transform(m, n);
      break;
    }
    case "merge_node": {
      var {
        path: E
      } = n, w = Tt.get(e, E), M = Ye.previous(E), x = Tt.get(e, M), v = Tt.parent(e, E), C = E[E.length - 1];
      if (Do.isText(w) && Do.isText(x))
        x.text += w.text;
      else if (!Do.isText(w) && !Do.isText(x))
        x.children.push(...w.children);
      else
        throw new Error('Cannot apply a "merge_node" operation at path ['.concat(E, "] to nodes of different interfaces: ").concat(ls.stringify(w), " ").concat(ls.stringify(x)));
      if (v.children.splice(C, 1), t)
        for (var [P, F] of Xt.points(t))
          t[F] = Ar.transform(P, n);
      break;
    }
    case "move_node": {
      var {
        path: L,
        newPath: B
      } = n;
      if (Ye.isAncestor(L, B))
        throw new Error("Cannot move a path [".concat(L, "] to new path [").concat(B, "] because the destination is inside itself."));
      var N = Tt.get(e, L), $ = Tt.parent(e, L), V = L[L.length - 1];
      $.children.splice(V, 1);
      var H = Ye.transform(L, n), Z = Tt.get(e, Ye.parent(H)), K = H[H.length - 1];
      if (Z.children.splice(K, 0, N), t)
        for (var [Y, Q] of Xt.points(t))
          t[Q] = Ar.transform(Y, n);
      break;
    }
    case "remove_node": {
      var {
        path: J
      } = n, _ = J[J.length - 1], D = Tt.parent(e, J);
      if (D.children.splice(_, 1), t)
        for (var [z, S] of Xt.points(t)) {
          var W = Ar.transform(z, n);
          if (t != null && W != null)
            t[S] = W;
          else {
            var O = void 0, j = void 0;
            for (var [U, T] of Tt.texts(e))
              if (Ye.compare(T, J) === -1)
                O = [U, T];
              else {
                j = [U, T];
                break;
              }
            var q = !1;
            O && j && (Ye.equals(j[1], J) ? q = !Ye.hasPrevious(j[1]) : q = Ye.common(O[1], J).length < Ye.common(j[1], J).length), O && !q ? (z.path = O[1], z.offset = O[0].text.length) : j ? (z.path = j[1], z.offset = 0) : t = null;
          }
        }
      break;
    }
    case "remove_text": {
      var {
        path: A,
        offset: X,
        text: I
      } = n;
      if (I.length === 0) break;
      var le = Tt.leaf(e, A), he = le.text.slice(0, X), oe = le.text.slice(X + I.length);
      if (le.text = he + oe, t)
        for (var [Ae, Ue] of Xt.points(t))
          t[Ue] = Ar.transform(Ae, n);
      break;
    }
    case "set_node": {
      var {
        path: He,
        properties: Re,
        newProperties: nt
      } = n;
      if (He.length === 0)
        throw new Error("Cannot set properties on the root node!");
      var Ve = Tt.get(e, He);
      for (var we in nt) {
        if (we === "children" || we === "text")
          throw new Error('Cannot set the "'.concat(we, '" property of nodes!'));
        var et = nt[we];
        et == null ? delete Ve[we] : Ve[we] = et;
      }
      for (var lt in Re)
        nt.hasOwnProperty(lt) || delete Ve[lt];
      break;
    }
    case "set_selection": {
      var {
        newProperties: ye
      } = n;
      if (ye == null)
        t = ye;
      else {
        if (t == null) {
          if (!Xt.isRange(ye))
            throw new Error('Cannot apply an incomplete "set_selection" operation properties '.concat(ls.stringify(ye), " when there is no current selection."));
          t = hd({}, ye);
        }
        for (var ke in ye) {
          var Qe = ye[ke];
          if (Qe == null) {
            if (ke === "anchor" || ke === "focus")
              throw new Error('Cannot remove the "'.concat(ke, '" selection property'));
            delete t[ke];
          } else
            t[ke] = Qe;
        }
      }
      break;
    }
    case "split_node": {
      var {
        path: Fe,
        position: Ie,
        properties: ot
      } = n;
      if (Fe.length === 0)
        throw new Error('Cannot apply a "split_node" operation at path ['.concat(Fe, "] because the root node cannot be split."));
      var Ee = Tt.get(e, Fe), wt = Tt.parent(e, Fe), it = Fe[Fe.length - 1], st;
      if (Do.isText(Ee)) {
        var ut = Ee.text.slice(0, Ie), Ct = Ee.text.slice(Ie);
        Ee.text = ut, st = hd(hd({}, ot), {}, {
          text: Ct
        });
      } else {
        var ct = Ee.children.slice(0, Ie), pt = Ee.children.slice(Ie);
        Ee.children = ct, st = hd(hd({}, ot), {}, {
          children: pt
        });
      }
      if (wt.children.splice(it + 1, 0, st), t)
        for (var [rt, We] of Xt.points(t))
          t[We] = Ar.transform(rt, n);
      break;
    }
  }
  return t;
}, Hbe = {
  transform(e, t) {
    e.children = sB(e.children);
    var n = e.selection && sB(e.selection);
    try {
      n = Ube(e, n, t);
    } finally {
      e.children = aB(e.children), n ? e.selection = Vc(n) ? aB(n) : n : e.selection = null;
    }
  }
}, Wbe = {
  insertNodes(e, t, n) {
    e.insertNodes(t, n);
  },
  liftNodes(e, t) {
    e.liftNodes(t);
  },
  mergeNodes(e, t) {
    e.mergeNodes(t);
  },
  moveNodes(e, t) {
    e.moveNodes(t);
  },
  removeNodes(e, t) {
    e.removeNodes(t);
  },
  setNodes(e, t, n) {
    e.setNodes(t, n);
  },
  splitNodes(e, t) {
    e.splitNodes(t);
  },
  unsetNodes(e, t, n) {
    e.unsetNodes(t, n);
  },
  unwrapNodes(e, t) {
    e.unwrapNodes(t);
  },
  wrapNodes(e, t, n) {
    e.wrapNodes(t, n);
  }
}, $be = {
  collapse(e, t) {
    e.collapse(t);
  },
  deselect(e) {
    e.deselect();
  },
  move(e, t) {
    e.move(t);
  },
  select(e, t) {
    e.select(t);
  },
  setPoint(e, t, n) {
    e.setPoint(t, n);
  },
  setSelection(e, t) {
    e.setSelection(t);
  }
}, VY = (e, t) => {
  for (var n in e) {
    var r = e[n], o = t[n];
    if (mi(r) && mi(o)) {
      if (!VY(r, o)) return !1;
    } else if (Array.isArray(r) && Array.isArray(o)) {
      if (r.length !== o.length) return !1;
      for (var i = 0; i < r.length; i++)
        if (r[i] !== o[i]) return !1;
    } else if (r !== o)
      return !1;
  }
  for (var a in t)
    if (e[a] === void 0 && t[a] !== void 0)
      return !1;
  return !0;
};
function Vbe(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), o, i;
  for (i = 0; i < r.length; i++)
    o = r[i], !(t.indexOf(o) >= 0) && (n[o] = e[o]);
  return n;
}
function wh(e, t) {
  if (e == null) return {};
  var n = Vbe(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (o = 0; o < i.length; o++)
      r = i[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
var Zbe = ["anchor", "focus"];
function uB(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function qbe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? uB(Object(n), !0).forEach(function(r) {
      Ip(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : uB(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Xt = {
  edges(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, {
      anchor: r,
      focus: o
    } = e;
    return Xt.isBackward(e) === n ? [r, o] : [o, r];
  },
  end(e) {
    var [, t] = Xt.edges(e);
    return t;
  },
  equals(e, t) {
    return Ar.equals(e.anchor, t.anchor) && Ar.equals(e.focus, t.focus);
  },
  includes(e, t) {
    if (Xt.isRange(t)) {
      if (Xt.includes(e, t.anchor) || Xt.includes(e, t.focus))
        return !0;
      var [n, r] = Xt.edges(e), [o, i] = Xt.edges(t);
      return Ar.isBefore(n, o) && Ar.isAfter(r, i);
    }
    var [a, s] = Xt.edges(e), l = !1, u = !1;
    return Ar.isPoint(t) ? (l = Ar.compare(t, a) >= 0, u = Ar.compare(t, s) <= 0) : (l = Ye.compare(t, a.path) >= 0, u = Ye.compare(t, s.path) <= 0), l && u;
  },
  intersection(e, t) {
    var n = wh(e, Zbe), [r, o] = Xt.edges(e), [i, a] = Xt.edges(t), s = Ar.isBefore(r, i) ? i : r, l = Ar.isBefore(o, a) ? o : a;
    return Ar.isBefore(l, s) ? null : qbe({
      anchor: s,
      focus: l
    }, n);
  },
  isBackward(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return Ar.isAfter(t, n);
  },
  isCollapsed(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return Ar.equals(t, n);
  },
  isExpanded(e) {
    return !Xt.isCollapsed(e);
  },
  isForward(e) {
    return !Xt.isBackward(e);
  },
  isRange(e) {
    return mi(e) && Ar.isPoint(e.anchor) && Ar.isPoint(e.focus);
  },
  *points(e) {
    yield [e.anchor, "anchor"], yield [e.focus, "focus"];
  },
  start(e) {
    var [t] = Xt.edges(e);
    return t;
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return zM(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "inward"
      } = n, i, a;
      if (o === "inward") {
        var s = Xt.isCollapsed(r);
        Xt.isForward(r) ? (i = "forward", a = s ? i : "backward") : (i = "backward", a = s ? i : "forward");
      } else o === "outward" ? Xt.isForward(r) ? (i = "backward", a = "forward") : (i = "forward", a = "backward") : (i = o, a = o);
      var l = Ar.transform(r.anchor, t, {
        affinity: i
      }), u = Ar.transform(r.focus, t, {
        affinity: a
      });
      if (!l || !u)
        return null;
      r.anchor = l, r.focus = u;
    });
  }
}, cB = (e) => mi(e) && Tt.isNodeList(e.children) && !pr.isEditor(e), Za = {
  isAncestor(e) {
    return mi(e) && Tt.isNodeList(e.children);
  },
  isElement: cB,
  isElementList(e) {
    return Array.isArray(e) && e.every((t) => Za.isElement(t));
  },
  isElementProps(e) {
    return e.children !== void 0;
  },
  isElementType: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "type";
    return cB(e) && e[n] === t;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "children" && e[n] !== t[n])
        return !1;
    return !0;
  }
}, Gbe = ["children"], Kbe = ["text"], pB = /* @__PURE__ */ new WeakMap(), Tt = {
  ancestor(e, t) {
    var n = Tt.get(e, t);
    if (Do.isText(n))
      throw new Error("Cannot get the ancestor node at path [".concat(t, "] because it refers to a text node instead: ").concat(ls.stringify(n)));
    return n;
  },
  ancestors(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of Ye.ancestors(t, n)) {
        var o = Tt.ancestor(e, r), i = [o, r];
        yield i;
      }
    }();
  },
  child(e, t) {
    if (Do.isText(e))
      throw new Error("Cannot get the child of a text node: ".concat(ls.stringify(e)));
    var n = e.children[t];
    if (n == null)
      throw new Error("Cannot get child at index `".concat(t, "` in node: ").concat(ls.stringify(e)));
    return n;
  },
  children(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var {
        reverse: r = !1
      } = n, o = Tt.ancestor(e, t), {
        children: i
      } = o, a = r ? i.length - 1 : 0; r ? a >= 0 : a < i.length; ) {
        var s = Tt.child(o, a), l = t.concat(a);
        yield [s, l], a = r ? a - 1 : a + 1;
      }
    }();
  },
  common(e, t, n) {
    var r = Ye.common(t, n), o = Tt.get(e, r);
    return [o, r];
  },
  descendant(e, t) {
    var n = Tt.get(e, t);
    if (pr.isEditor(n))
      throw new Error("Cannot get the descendant node at path [".concat(t, "] because it refers to the root editor node instead: ").concat(ls.stringify(n)));
    return n;
  },
  descendants(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Tt.nodes(e, t))
        r.length !== 0 && (yield [n, r]);
    }();
  },
  elements(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Tt.nodes(e, t))
        Za.isElement(n) && (yield [n, r]);
    }();
  },
  extractProps(e) {
    if (Za.isAncestor(e)) {
      var t = wh(e, Gbe);
      return t;
    } else {
      var t = wh(e, Kbe);
      return t;
    }
  },
  first(e, t) {
    for (var n = t.slice(), r = Tt.get(e, n); r && !(Do.isText(r) || r.children.length === 0); )
      r = r.children[0], n.push(0);
    return [r, n];
  },
  fragment(e, t) {
    if (Do.isText(e))
      throw new Error("Cannot get a fragment starting from a root text node: ".concat(ls.stringify(e)));
    var n = zM({
      children: e.children
    }, (r) => {
      var [o, i] = Xt.edges(t), a = Tt.nodes(r, {
        reverse: !0,
        pass: (d) => {
          var [, g] = d;
          return !Xt.includes(t, g);
        }
      });
      for (var [, s] of a) {
        if (!Xt.includes(t, s)) {
          var l = Tt.parent(r, s), u = s[s.length - 1];
          l.children.splice(u, 1);
        }
        if (Ye.equals(s, i.path)) {
          var c = Tt.leaf(r, s);
          c.text = c.text.slice(0, i.offset);
        }
        if (Ye.equals(s, o.path)) {
          var p = Tt.leaf(r, s);
          p.text = p.text.slice(o.offset);
        }
      }
      pr.isEditor(r) && (r.selection = null);
    });
    return n.children;
  },
  get(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (Do.isText(n) || !n.children[o])
        throw new Error("Cannot find a descendant at path [".concat(t, "] in node: ").concat(ls.stringify(e)));
      n = n.children[o];
    }
    return n;
  },
  has(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (Do.isText(n) || !n.children[o])
        return !1;
      n = n.children[o];
    }
    return !0;
  },
  isNode(e) {
    return Do.isText(e) || Za.isElement(e) || pr.isEditor(e);
  },
  isNodeList(e) {
    if (!Array.isArray(e))
      return !1;
    var t = pB.get(e);
    if (t !== void 0)
      return t;
    var n = e.every((r) => Tt.isNode(r));
    return pB.set(e, n), n;
  },
  last(e, t) {
    for (var n = t.slice(), r = Tt.get(e, n); r && !(Do.isText(r) || r.children.length === 0); ) {
      var o = r.children.length - 1;
      r = r.children[o], n.push(o);
    }
    return [r, n];
  },
  leaf(e, t) {
    var n = Tt.get(e, t);
    if (!Do.isText(n))
      throw new Error("Cannot get the leaf node at path [".concat(t, "] because it refers to a non-leaf node: ").concat(ls.stringify(n)));
    return n;
  },
  levels(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of Ye.levels(t, n)) {
        var o = Tt.get(e, r);
        yield [o, r];
      }
    }();
  },
  matches(e, t) {
    return Za.isElement(e) && Za.isElementProps(t) && Za.matches(e, t) || Do.isText(e) && Do.isTextProps(t) && Do.matches(e, t);
  },
  nodes(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var {
        pass: n,
        reverse: r = !1
      } = t, {
        from: o = [],
        to: i
      } = t, a = /* @__PURE__ */ new Set(), s = [], l = e; !(i && (r ? Ye.isBefore(s, i) : Ye.isAfter(s, i))); ) {
        if (a.has(l) || (yield [l, s]), !a.has(l) && !Do.isText(l) && l.children.length !== 0 && (n == null || n([l, s]) === !1)) {
          a.add(l);
          var u = r ? l.children.length - 1 : 0;
          Ye.isAncestor(s, o) && (u = o[s.length]), s = s.concat(u), l = Tt.get(e, s);
          continue;
        }
        if (s.length === 0)
          break;
        if (!r) {
          var c = Ye.next(s);
          if (Tt.has(e, c)) {
            s = c, l = Tt.get(e, s);
            continue;
          }
        }
        if (r && s[s.length - 1] !== 0) {
          var p = Ye.previous(s);
          s = p, l = Tt.get(e, s);
          continue;
        }
        s = Ye.parent(s), l = Tt.get(e, s), a.add(l);
      }
    }();
  },
  parent(e, t) {
    var n = Ye.parent(t), r = Tt.get(e, n);
    if (Do.isText(r))
      throw new Error("Cannot get the parent of path [".concat(t, "] because it does not exist in the root."));
    return r;
  },
  string(e) {
    return Do.isText(e) ? e.text : e.children.map(Tt.string).join("");
  },
  texts(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Tt.nodes(e, t))
        Do.isText(n) && (yield [n, r]);
    }();
  }
};
function dB(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Hr(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? dB(Object(n), !0).forEach(function(r) {
      Ip(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : dB(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var ef = {
  isNodeOperation(e) {
    return ef.isOperation(e) && e.type.endsWith("_node");
  },
  isOperation(e) {
    if (!mi(e))
      return !1;
    switch (e.type) {
      case "insert_node":
        return Ye.isPath(e.path) && Tt.isNode(e.node);
      case "insert_text":
        return typeof e.offset == "number" && typeof e.text == "string" && Ye.isPath(e.path);
      case "merge_node":
        return typeof e.position == "number" && Ye.isPath(e.path) && mi(e.properties);
      case "move_node":
        return Ye.isPath(e.path) && Ye.isPath(e.newPath);
      case "remove_node":
        return Ye.isPath(e.path) && Tt.isNode(e.node);
      case "remove_text":
        return typeof e.offset == "number" && typeof e.text == "string" && Ye.isPath(e.path);
      case "set_node":
        return Ye.isPath(e.path) && mi(e.properties) && mi(e.newProperties);
      case "set_selection":
        return e.properties === null && Xt.isRange(e.newProperties) || e.newProperties === null && Xt.isRange(e.properties) || mi(e.properties) && mi(e.newProperties);
      case "split_node":
        return Ye.isPath(e.path) && typeof e.position == "number" && mi(e.properties);
      default:
        return !1;
    }
  },
  isOperationList(e) {
    return Array.isArray(e) && e.every((t) => ef.isOperation(t));
  },
  isSelectionOperation(e) {
    return ef.isOperation(e) && e.type.endsWith("_selection");
  },
  isTextOperation(e) {
    return ef.isOperation(e) && e.type.endsWith("_text");
  },
  inverse(e) {
    switch (e.type) {
      case "insert_node":
        return Hr(Hr({}, e), {}, {
          type: "remove_node"
        });
      case "insert_text":
        return Hr(Hr({}, e), {}, {
          type: "remove_text"
        });
      case "merge_node":
        return Hr(Hr({}, e), {}, {
          type: "split_node",
          path: Ye.previous(e.path)
        });
      case "move_node": {
        var {
          newPath: t,
          path: n
        } = e;
        if (Ye.equals(t, n))
          return e;
        if (Ye.isSibling(n, t))
          return Hr(Hr({}, e), {}, {
            path: t,
            newPath: n
          });
        var r = Ye.transform(n, e), o = Ye.transform(Ye.next(n), e);
        return Hr(Hr({}, e), {}, {
          path: r,
          newPath: o
        });
      }
      case "remove_node":
        return Hr(Hr({}, e), {}, {
          type: "insert_node"
        });
      case "remove_text":
        return Hr(Hr({}, e), {}, {
          type: "insert_text"
        });
      case "set_node": {
        var {
          properties: i,
          newProperties: a
        } = e;
        return Hr(Hr({}, e), {}, {
          properties: a,
          newProperties: i
        });
      }
      case "set_selection": {
        var {
          properties: s,
          newProperties: l
        } = e;
        return s == null ? Hr(Hr({}, e), {}, {
          properties: l,
          newProperties: null
        }) : l == null ? Hr(Hr({}, e), {}, {
          properties: null,
          newProperties: s
        }) : Hr(Hr({}, e), {}, {
          properties: l,
          newProperties: s
        });
      }
      case "split_node":
        return Hr(Hr({}, e), {}, {
          type: "merge_node",
          path: Ye.next(e.path)
        });
    }
  }
}, fB = /* @__PURE__ */ new WeakMap(), Xbe = (e) => {
  var t = fB.get(e);
  if (t !== void 0)
    return t;
  if (!mi(e))
    return !1;
  var n = typeof e.addMark == "function" && typeof e.apply == "function" && typeof e.deleteFragment == "function" && typeof e.insertBreak == "function" && typeof e.insertSoftBreak == "function" && typeof e.insertFragment == "function" && typeof e.insertNode == "function" && typeof e.insertText == "function" && typeof e.isElementReadOnly == "function" && typeof e.isInline == "function" && typeof e.isSelectable == "function" && typeof e.isVoid == "function" && typeof e.normalizeNode == "function" && typeof e.onChange == "function" && typeof e.removeMark == "function" && typeof e.getDirtyPaths == "function" && (e.marks === null || mi(e.marks)) && (e.selection === null || Xt.isRange(e.selection)) && Tt.isNodeList(e.children) && ef.isOperationList(e.operations);
  return fB.set(e, n), n;
}, pr = {
  above(e, t) {
    return e.above(t);
  },
  addMark(e, t, n) {
    e.addMark(t, n);
  },
  after(e, t, n) {
    return e.after(t, n);
  },
  before(e, t, n) {
    return e.before(t, n);
  },
  deleteBackward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteBackward(n);
  },
  deleteForward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteForward(n);
  },
  deleteFragment(e, t) {
    e.deleteFragment(t);
  },
  edges(e, t) {
    return e.edges(t);
  },
  elementReadOnly(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return e.elementReadOnly(t);
  },
  end(e, t) {
    return e.end(t);
  },
  first(e, t) {
    return e.first(t);
  },
  fragment(e, t) {
    return e.fragment(t);
  },
  hasBlocks(e, t) {
    return e.hasBlocks(t);
  },
  hasInlines(e, t) {
    return e.hasInlines(t);
  },
  hasPath(e, t) {
    return e.hasPath(t);
  },
  hasTexts(e, t) {
    return e.hasTexts(t);
  },
  insertBreak(e) {
    e.insertBreak();
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertNode(e, t) {
    e.insertNode(t);
  },
  insertSoftBreak(e) {
    e.insertSoftBreak();
  },
  insertText(e, t) {
    e.insertText(t);
  },
  isBlock(e, t) {
    return e.isBlock(t);
  },
  isEdge(e, t, n) {
    return e.isEdge(t, n);
  },
  isEditor(e) {
    return Xbe(e);
  },
  isElementReadOnly(e, t) {
    return e.isElementReadOnly(t);
  },
  isEmpty(e, t) {
    return e.isEmpty(t);
  },
  isEnd(e, t, n) {
    return e.isEnd(t, n);
  },
  isInline(e, t) {
    return e.isInline(t);
  },
  isNormalizing(e) {
    return e.isNormalizing();
  },
  isSelectable(e, t) {
    return e.isSelectable(t);
  },
  isStart(e, t, n) {
    return e.isStart(t, n);
  },
  isVoid(e, t) {
    return e.isVoid(t);
  },
  last(e, t) {
    return e.last(t);
  },
  leaf(e, t, n) {
    return e.leaf(t, n);
  },
  levels(e, t) {
    return e.levels(t);
  },
  marks(e) {
    return e.getMarks();
  },
  next(e, t) {
    return e.next(t);
  },
  node(e, t, n) {
    return e.node(t, n);
  },
  nodes(e, t) {
    return e.nodes(t);
  },
  normalize(e, t) {
    e.normalize(t);
  },
  parent(e, t, n) {
    return e.parent(t, n);
  },
  path(e, t, n) {
    return e.path(t, n);
  },
  pathRef(e, t, n) {
    return e.pathRef(t, n);
  },
  pathRefs(e) {
    return e.pathRefs();
  },
  point(e, t, n) {
    return e.point(t, n);
  },
  pointRef(e, t, n) {
    return e.pointRef(t, n);
  },
  pointRefs(e) {
    return e.pointRefs();
  },
  positions(e, t) {
    return e.positions(t);
  },
  previous(e, t) {
    return e.previous(t);
  },
  range(e, t, n) {
    return e.range(t, n);
  },
  rangeRef(e, t, n) {
    return e.rangeRef(t, n);
  },
  rangeRefs(e) {
    return e.rangeRefs();
  },
  removeMark(e, t) {
    e.removeMark(t);
  },
  setNormalizing(e, t) {
    e.setNormalizing(t);
  },
  start(e, t) {
    return e.start(t);
  },
  string(e, t, n) {
    return e.string(t, n);
  },
  unhangRange(e, t, n) {
    return e.unhangRange(t, n);
  },
  void(e, t) {
    return e.void(t);
  },
  withoutNormalizing(e, t) {
    e.withoutNormalizing(t);
  },
  shouldMergeNodesRemovePrevNode: (e, t, n) => e.shouldMergeNodesRemovePrevNode(t, n)
};
function hB(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function gB(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? hB(Object(n), !0).forEach(function(r) {
      Ip(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : hB(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Ar = {
  compare(e, t) {
    var n = Ye.compare(e.path, t.path);
    return n === 0 ? e.offset < t.offset ? -1 : e.offset > t.offset ? 1 : 0 : n;
  },
  isAfter(e, t) {
    return Ar.compare(e, t) === 1;
  },
  isBefore(e, t) {
    return Ar.compare(e, t) === -1;
  },
  equals(e, t) {
    return e.offset === t.offset && Ye.equals(e.path, t.path);
  },
  isPoint(e) {
    return mi(e) && typeof e.offset == "number" && Ye.isPath(e.path);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return zM(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "forward"
      } = n, {
        path: i,
        offset: a
      } = r;
      switch (t.type) {
        case "insert_node":
        case "move_node": {
          r.path = Ye.transform(i, t, n);
          break;
        }
        case "insert_text": {
          Ye.equals(t.path, i) && (t.offset < a || t.offset === a && o === "forward") && (r.offset += t.text.length);
          break;
        }
        case "merge_node": {
          Ye.equals(t.path, i) && (r.offset += t.position), r.path = Ye.transform(i, t, n);
          break;
        }
        case "remove_text": {
          Ye.equals(t.path, i) && t.offset <= a && (r.offset -= Math.min(a - t.offset, t.text.length));
          break;
        }
        case "remove_node": {
          if (Ye.equals(t.path, i) || Ye.isAncestor(t.path, i))
            return null;
          r.path = Ye.transform(i, t, n);
          break;
        }
        case "split_node": {
          if (Ye.equals(t.path, i)) {
            if (t.position === a && o == null)
              return null;
            (t.position < a || t.position === a && o === "forward") && (r.offset -= t.position, r.path = Ye.transform(i, t, gB(gB({}, n), {}, {
              affinity: "forward"
            })));
          } else
            r.path = Ye.transform(i, t, n);
          break;
        }
      }
    });
  }
}, mB = void 0, ls = {
  setScrubber(e) {
    mB = e;
  },
  stringify(e) {
    return JSON.stringify(e, mB);
  }
}, Ybe = ["text"], Jbe = ["anchor", "focus"];
function vB(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Da(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? vB(Object(n), !0).forEach(function(r) {
      Ip(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : vB(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Do = {
  equals(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      loose: r = !1
    } = n;
    function o(i) {
      var a = wh(i, Ybe);
      return a;
    }
    return VY(r ? o(e) : e, r ? o(t) : t);
  },
  isText(e) {
    return mi(e) && typeof e.text == "string";
  },
  isTextList(e) {
    return Array.isArray(e) && e.every((t) => Do.isText(t));
  },
  isTextProps(e) {
    return e.text !== void 0;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "text" && (!e.hasOwnProperty(n) || e[n] !== t[n]))
        return !1;
    return !0;
  },
  decorations(e, t) {
    var n = [Da({}, e)];
    for (var r of t) {
      var o = wh(r, Jbe), [i, a] = Xt.edges(r), s = [], l = 0, u = i.offset, c = a.offset;
      for (var p of n) {
        var {
          length: d
        } = p.text, g = l;
        if (l += d, u <= g && l <= c) {
          Object.assign(p, o), s.push(p);
          continue;
        }
        if (u !== c && (u === l || c === g) || u > l || c < g || c === g && g !== 0) {
          s.push(p);
          continue;
        }
        var f = p, m = void 0, b = void 0;
        if (c < l) {
          var E = c - g;
          b = Da(Da({}, f), {}, {
            text: f.text.slice(E)
          }), f = Da(Da({}, f), {}, {
            text: f.text.slice(0, E)
          });
        }
        if (u > g) {
          var w = u - g;
          m = Da(Da({}, f), {}, {
            text: f.text.slice(0, w)
          }), f = Da(Da({}, f), {}, {
            text: f.text.slice(w)
          });
        }
        Object.assign(f, o), m && s.push(m), s.push(f), b && s.push(b);
      }
      n = s;
    }
    return n;
  }
}, Qbe = (e) => e.selection ? e.selection : e.children.length > 0 ? pr.end(e, []) : [0], _r;
(function(e) {
  e[e.None = 0] = "None", e[e.Extend = 1] = "Extend", e[e.ZWJ = 2] = "ZWJ", e[e.RI = 4] = "RI", e[e.Prepend = 8] = "Prepend", e[e.SpacingMark = 16] = "SpacingMark", e[e.L = 32] = "L", e[e.V = 64] = "V", e[e.T = 128] = "T", e[e.LV = 256] = "LV", e[e.LVT = 512] = "LVT", e[e.ExtPict = 1024] = "ExtPict", e[e.Any = 2048] = "Any";
})(_r || (_r = {}));
_r.L, _r.L | _r.V | _r.LV | _r.LVT, _r.LV | _r.V, _r.V | _r.T, _r.LVT | _r.T, _r.T, _r.Any, _r.Extend | _r.ZWJ, _r.Any, _r.SpacingMark, _r.Prepend, _r.Any, _r.ZWJ, _r.ExtPict, _r.RI, _r.RI;
var ewe = {
  delete(e, t) {
    e.delete(t);
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertText(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    pr.withoutNormalizing(e, () => {
      var {
        voids: r = !1
      } = n, {
        at: o = Qbe(e)
      } = n;
      if (Ye.isPath(o) && (o = pr.range(e, o)), Xt.isRange(o))
        if (Xt.isCollapsed(o))
          o = o.anchor;
        else {
          var i = Xt.end(o);
          if (!r && pr.void(e, {
            at: i
          }))
            return;
          var a = Xt.start(o), s = pr.pointRef(e, a), l = pr.pointRef(e, i);
          wb.delete(e, {
            at: o,
            voids: r
          });
          var u = s.unref(), c = l.unref();
          o = u || c, wb.setSelection(e, {
            anchor: o,
            focus: o
          });
        }
      if (!(!r && pr.void(e, {
        at: o
      }) || pr.elementReadOnly(e, {
        at: o
      }))) {
        var {
          path: p,
          offset: d
        } = o;
        t.length > 0 && e.apply({
          type: "insert_text",
          path: p,
          offset: d,
          text: t
        });
      }
    });
  }
};
function yB(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function jm(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? yB(Object(n), !0).forEach(function(r) {
      Ip(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : yB(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var wb = jm(jm(jm(jm({}, Hbe), Wbe), $be), ewe), ZY = {}, UM = {}, HM = {}, rp = {}, WM = {}, $M = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Doctype = e.CDATA = e.Tag = e.Style = e.Script = e.Comment = e.Directive = e.Text = e.Root = e.isTag = e.ElementType = void 0;
  var t;
  (function(r) {
    r.Root = "root", r.Text = "text", r.Directive = "directive", r.Comment = "comment", r.Script = "script", r.Style = "style", r.Tag = "tag", r.CDATA = "cdata", r.Doctype = "doctype";
  })(t = e.ElementType || (e.ElementType = {}));
  function n(r) {
    return r.type === t.Tag || r.type === t.Script || r.type === t.Style;
  }
  e.isTag = n, e.Root = t.Root, e.Text = t.Text, e.Directive = t.Directive, e.Comment = t.Comment, e.Script = t.Script, e.Style = t.Style, e.Tag = t.Tag, e.CDATA = t.CDATA, e.Doctype = t.Doctype;
})($M);
var sn = {}, wu = br && br.__extends || /* @__PURE__ */ function() {
  var e = function(t, n) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, o) {
      r.__proto__ = o;
    } || function(r, o) {
      for (var i in o) Object.prototype.hasOwnProperty.call(o, i) && (r[i] = o[i]);
    }, e(t, n);
  };
  return function(t, n) {
    if (typeof n != "function" && n !== null)
      throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
    e(t, n);
    function r() {
      this.constructor = t;
    }
    t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
  };
}(), yf = br && br.__assign || function() {
  return yf = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) {
      t = arguments[n];
      for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
    }
    return e;
  }, yf.apply(this, arguments);
};
Object.defineProperty(sn, "__esModule", { value: !0 });
sn.cloneNode = sn.hasChildren = sn.isDocument = sn.isDirective = sn.isComment = sn.isText = sn.isCDATA = sn.isTag = sn.Element = sn.Document = sn.CDATA = sn.NodeWithChildren = sn.ProcessingInstruction = sn.Comment = sn.Text = sn.DataNode = sn.Node = void 0;
var ts = $M, VM = (
  /** @class */
  function() {
    function e() {
      this.parent = null, this.prev = null, this.next = null, this.startIndex = null, this.endIndex = null;
    }
    return Object.defineProperty(e.prototype, "parentNode", {
      // Read-write aliases for properties
      /**
       * Same as {@link parent}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.parent;
      },
      set: function(t) {
        this.parent = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "previousSibling", {
      /**
       * Same as {@link prev}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.prev;
      },
      set: function(t) {
        this.prev = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "nextSibling", {
      /**
       * Same as {@link next}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.next;
      },
      set: function(t) {
        this.next = t;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.cloneNode = function(t) {
      return t === void 0 && (t = !1), ZM(this, t);
    }, e;
  }()
);
sn.Node = VM;
var LC = (
  /** @class */
  function(e) {
    wu(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.data = n, r;
    }
    return Object.defineProperty(t.prototype, "nodeValue", {
      /**
       * Same as {@link data}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.data;
      },
      set: function(n) {
        this.data = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(VM)
);
sn.DataNode = LC;
var qY = (
  /** @class */
  function(e) {
    wu(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = ts.ElementType.Text, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 3;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(LC)
);
sn.Text = qY;
var GY = (
  /** @class */
  function(e) {
    wu(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = ts.ElementType.Comment, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 8;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(LC)
);
sn.Comment = GY;
var KY = (
  /** @class */
  function(e) {
    wu(t, e);
    function t(n, r) {
      var o = e.call(this, r) || this;
      return o.name = n, o.type = ts.ElementType.Directive, o;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(LC)
);
sn.ProcessingInstruction = KY;
var _C = (
  /** @class */
  function(e) {
    wu(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.children = n, r;
    }
    return Object.defineProperty(t.prototype, "firstChild", {
      // Aliases
      /** First child of the node. */
      get: function() {
        var n;
        return (n = this.children[0]) !== null && n !== void 0 ? n : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "lastChild", {
      /** Last child of the node. */
      get: function() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "childNodes", {
      /**
       * Same as {@link children}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.children;
      },
      set: function(n) {
        this.children = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(VM)
);
sn.NodeWithChildren = _C;
var XY = (
  /** @class */
  function(e) {
    wu(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = ts.ElementType.CDATA, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 4;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(_C)
);
sn.CDATA = XY;
var YY = (
  /** @class */
  function(e) {
    wu(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = ts.ElementType.Root, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 9;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(_C)
);
sn.Document = YY;
var JY = (
  /** @class */
  function(e) {
    wu(t, e);
    function t(n, r, o, i) {
      o === void 0 && (o = []), i === void 0 && (i = n === "script" ? ts.ElementType.Script : n === "style" ? ts.ElementType.Style : ts.ElementType.Tag);
      var a = e.call(this, o) || this;
      return a.name = n, a.attribs = r, a.type = i, a;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "tagName", {
      // DOM Level 1 aliases
      /**
       * Same as {@link name}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.name;
      },
      set: function(n) {
        this.name = n;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "attributes", {
      get: function() {
        var n = this;
        return Object.keys(this.attribs).map(function(r) {
          var o, i;
          return {
            name: r,
            value: n.attribs[r],
            namespace: (o = n["x-attribsNamespace"]) === null || o === void 0 ? void 0 : o[r],
            prefix: (i = n["x-attribsPrefix"]) === null || i === void 0 ? void 0 : i[r]
          };
        });
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(_C)
);
sn.Element = JY;
function QY(e) {
  return (0, ts.isTag)(e);
}
sn.isTag = QY;
function eJ(e) {
  return e.type === ts.ElementType.CDATA;
}
sn.isCDATA = eJ;
function tJ(e) {
  return e.type === ts.ElementType.Text;
}
sn.isText = tJ;
function nJ(e) {
  return e.type === ts.ElementType.Comment;
}
sn.isComment = nJ;
function rJ(e) {
  return e.type === ts.ElementType.Directive;
}
sn.isDirective = rJ;
function oJ(e) {
  return e.type === ts.ElementType.Root;
}
sn.isDocument = oJ;
function twe(e) {
  return Object.prototype.hasOwnProperty.call(e, "children");
}
sn.hasChildren = twe;
function ZM(e, t) {
  t === void 0 && (t = !1);
  var n;
  if (tJ(e))
    n = new qY(e.data);
  else if (nJ(e))
    n = new GY(e.data);
  else if (QY(e)) {
    var r = t ? Nx(e.children) : [], o = new JY(e.name, yf({}, e.attribs), r);
    r.forEach(function(l) {
      return l.parent = o;
    }), e.namespace != null && (o.namespace = e.namespace), e["x-attribsNamespace"] && (o["x-attribsNamespace"] = yf({}, e["x-attribsNamespace"])), e["x-attribsPrefix"] && (o["x-attribsPrefix"] = yf({}, e["x-attribsPrefix"])), n = o;
  } else if (eJ(e)) {
    var r = t ? Nx(e.children) : [], i = new XY(r);
    r.forEach(function(u) {
      return u.parent = i;
    }), n = i;
  } else if (oJ(e)) {
    var r = t ? Nx(e.children) : [], a = new YY(r);
    r.forEach(function(u) {
      return u.parent = a;
    }), e["x-mode"] && (a["x-mode"] = e["x-mode"]), n = a;
  } else if (rJ(e)) {
    var s = new KY(e.name, e.data);
    e["x-name"] != null && (s["x-name"] = e["x-name"], s["x-publicId"] = e["x-publicId"], s["x-systemId"] = e["x-systemId"]), n = s;
  } else
    throw new Error("Not implemented yet: ".concat(e.type));
  return n.startIndex = e.startIndex, n.endIndex = e.endIndex, e.sourceCodeLocation != null && (n.sourceCodeLocation = e.sourceCodeLocation), n;
}
sn.cloneNode = ZM;
function Nx(e) {
  for (var t = e.map(function(r) {
    return ZM(r, !0);
  }), n = 1; n < t.length; n++)
    t[n].prev = t[n - 1], t[n - 1].next = t[n];
  return t;
}
(function(e) {
  var t = br && br.__createBinding || (Object.create ? function(s, l, u, c) {
    c === void 0 && (c = u);
    var p = Object.getOwnPropertyDescriptor(l, u);
    (!p || ("get" in p ? !l.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
      return l[u];
    } }), Object.defineProperty(s, c, p);
  } : function(s, l, u, c) {
    c === void 0 && (c = u), s[c] = l[u];
  }), n = br && br.__exportStar || function(s, l) {
    for (var u in s) u !== "default" && !Object.prototype.hasOwnProperty.call(l, u) && t(l, s, u);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.DomHandler = void 0;
  var r = $M, o = sn;
  n(sn, e);
  var i = {
    withStartIndices: !1,
    withEndIndices: !1,
    xmlMode: !1
  }, a = (
    /** @class */
    function() {
      function s(l, u, c) {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null, typeof u == "function" && (c = u, u = i), typeof l == "object" && (u = l, l = void 0), this.callback = l ?? null, this.options = u ?? i, this.elementCB = c ?? null;
      }
      return s.prototype.onparserinit = function(l) {
        this.parser = l;
      }, s.prototype.onreset = function() {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null;
      }, s.prototype.onend = function() {
        this.done || (this.done = !0, this.parser = null, this.handleCallback(null));
      }, s.prototype.onerror = function(l) {
        this.handleCallback(l);
      }, s.prototype.onclosetag = function() {
        this.lastNode = null;
        var l = this.tagStack.pop();
        this.options.withEndIndices && (l.endIndex = this.parser.endIndex), this.elementCB && this.elementCB(l);
      }, s.prototype.onopentag = function(l, u) {
        var c = this.options.xmlMode ? r.ElementType.Tag : void 0, p = new o.Element(l, u, void 0, c);
        this.addNode(p), this.tagStack.push(p);
      }, s.prototype.ontext = function(l) {
        var u = this.lastNode;
        if (u && u.type === r.ElementType.Text)
          u.data += l, this.options.withEndIndices && (u.endIndex = this.parser.endIndex);
        else {
          var c = new o.Text(l);
          this.addNode(c), this.lastNode = c;
        }
      }, s.prototype.oncomment = function(l) {
        if (this.lastNode && this.lastNode.type === r.ElementType.Comment) {
          this.lastNode.data += l;
          return;
        }
        var u = new o.Comment(l);
        this.addNode(u), this.lastNode = u;
      }, s.prototype.oncommentend = function() {
        this.lastNode = null;
      }, s.prototype.oncdatastart = function() {
        var l = new o.Text(""), u = new o.CDATA([l]);
        this.addNode(u), l.parent = u, this.lastNode = l;
      }, s.prototype.oncdataend = function() {
        this.lastNode = null;
      }, s.prototype.onprocessinginstruction = function(l, u) {
        var c = new o.ProcessingInstruction(l, u);
        this.addNode(c);
      }, s.prototype.handleCallback = function(l) {
        if (typeof this.callback == "function")
          this.callback(l, this.dom);
        else if (l)
          throw l;
      }, s.prototype.addNode = function(l) {
        var u = this.tagStack[this.tagStack.length - 1], c = u.children[u.children.length - 1];
        this.options.withStartIndices && (l.startIndex = this.parser.startIndex), this.options.withEndIndices && (l.endIndex = this.parser.endIndex), u.children.push(l), c && (l.prev = c, c.next = l), l.parent = u, this.lastNode = null;
      }, s;
    }()
  );
  e.DomHandler = a, e.default = a;
})(WM);
var iJ = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CARRIAGE_RETURN_PLACEHOLDER_REGEX = e.CARRIAGE_RETURN_PLACEHOLDER = e.CARRIAGE_RETURN_REGEX = e.CARRIAGE_RETURN = e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES = void 0, e.CASE_SENSITIVE_TAG_NAMES = [
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "linearGradient",
    "radialGradient",
    "textPath"
  ], e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES.reduce(function(t, n) {
    return t[n.toLowerCase()] = n, t;
  }, {}), e.CARRIAGE_RETURN = "\r", e.CARRIAGE_RETURN_REGEX = new RegExp(e.CARRIAGE_RETURN, "g"), e.CARRIAGE_RETURN_PLACEHOLDER = "__HTML_DOM_PARSER_CARRIAGE_RETURN_PLACEHOLDER_".concat(Date.now(), "__"), e.CARRIAGE_RETURN_PLACEHOLDER_REGEX = new RegExp(e.CARRIAGE_RETURN_PLACEHOLDER, "g");
})(iJ);
Object.defineProperty(rp, "__esModule", { value: !0 });
rp.formatAttributes = sJ;
rp.escapeSpecialCharacters = owe;
rp.revertEscapedCharacters = aJ;
rp.formatDOM = lJ;
var Am = WM, Ch = iJ;
function nwe(e) {
  return Ch.CASE_SENSITIVE_TAG_NAMES_MAP[e];
}
function sJ(e) {
  for (var t = {}, n = 0, r = e.length; n < r; n++) {
    var o = e[n];
    t[o.name] = o.value;
  }
  return t;
}
function rwe(e) {
  e = e.toLowerCase();
  var t = nwe(e);
  return t || e;
}
function owe(e) {
  return e.replace(Ch.CARRIAGE_RETURN_REGEX, Ch.CARRIAGE_RETURN_PLACEHOLDER);
}
function aJ(e) {
  return e.replace(Ch.CARRIAGE_RETURN_PLACEHOLDER_REGEX, Ch.CARRIAGE_RETURN);
}
function lJ(e, t, n) {
  t === void 0 && (t = null);
  for (var r = [], o, i = 0, a = e.length; i < a; i++) {
    var s = e[i];
    switch (s.nodeType) {
      case 1: {
        var l = rwe(s.nodeName);
        o = new Am.Element(l, sJ(s.attributes)), o.children = lJ(
          // template children are on content
          l === "template" ? s.content.childNodes : s.childNodes,
          o
        );
        break;
      }
      case 3:
        o = new Am.Text(aJ(s.nodeValue));
        break;
      case 8:
        o = new Am.Comment(s.nodeValue);
        break;
      default:
        continue;
    }
    var u = r[i - 1] || null;
    u && (u.next = o), o.parent = t, o.prev = u, o.next = null, r.push(o);
  }
  return n && (o = new Am.ProcessingInstruction(n.substring(0, n.indexOf(" ")).toLowerCase(), n), o.next = r[0] || null, o.parent = t, r.unshift(o), r[1] && (r[1].prev = r[0])), r;
}
Object.defineProperty(HM, "__esModule", { value: !0 });
HM.default = uwe;
var iwe = rp, bB = "html", wB = "head", Rm = "body", swe = /<([a-zA-Z]+[0-9]?)/, CB = /<head[^]*>/i, OB = /<body[^]*>/i, Cb = function(e, t) {
  throw new Error("This browser does not support `document.implementation.createHTMLDocument`");
}, h_ = function(e, t) {
  throw new Error("This browser does not support `DOMParser.prototype.parseFromString`");
}, xB = typeof window == "object" && window.DOMParser;
if (typeof xB == "function") {
  var awe = new xB(), lwe = "text/html";
  h_ = function(e, t) {
    return t && (e = "<".concat(t, ">").concat(e, "</").concat(t, ">")), awe.parseFromString(e, lwe);
  }, Cb = h_;
}
if (typeof document == "object" && document.implementation) {
  var Im = document.implementation.createHTMLDocument();
  Cb = function(e, t) {
    if (t) {
      var n = Im.documentElement.querySelector(t);
      return n && (n.innerHTML = e), Im;
    }
    return Im.documentElement.innerHTML = e, Im;
  };
}
var Nm = typeof document == "object" && document.createElement("template"), g_;
Nm && Nm.content && (g_ = function(e) {
  return Nm.innerHTML = e, Nm.content.childNodes;
});
function uwe(e) {
  var t, n;
  e = (0, iwe.escapeSpecialCharacters)(e);
  var r = e.match(swe), o = r && r[1] ? r[1].toLowerCase() : "";
  switch (o) {
    case bB: {
      var i = h_(e);
      if (!CB.test(e)) {
        var a = i.querySelector(wB);
        (t = a == null ? void 0 : a.parentNode) === null || t === void 0 || t.removeChild(a);
      }
      if (!OB.test(e)) {
        var a = i.querySelector(Rm);
        (n = a == null ? void 0 : a.parentNode) === null || n === void 0 || n.removeChild(a);
      }
      return i.querySelectorAll(bB);
    }
    case wB:
    case Rm: {
      var s = Cb(e).querySelectorAll(o);
      return OB.test(e) && CB.test(e) ? s[0].parentNode.childNodes : s;
    }
    default: {
      if (g_)
        return g_(e);
      var a = Cb(e, Rm).querySelector(Rm);
      return a.childNodes;
    }
  }
}
var cwe = br && br.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(UM, "__esModule", { value: !0 });
UM.default = hwe;
var pwe = cwe(HM), dwe = rp, fwe = /<(![a-zA-Z\s]+)>/;
function hwe(e) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e)
    return [];
  var t = e.match(fwe), n = t ? t[1] : void 0;
  return (0, dwe.formatDOM)((0, pwe.default)(e), null, n);
}
var PC = {}, Ys = {}, SC = {}, gwe = 0;
SC.SAME = gwe;
var mwe = 1;
SC.CAMELCASE = mwe;
SC.possibleStandardNames = {
  accept: 0,
  acceptCharset: 1,
  "accept-charset": "acceptCharset",
  accessKey: 1,
  action: 0,
  allowFullScreen: 1,
  alt: 0,
  as: 0,
  async: 0,
  autoCapitalize: 1,
  autoComplete: 1,
  autoCorrect: 1,
  autoFocus: 1,
  autoPlay: 1,
  autoSave: 1,
  capture: 0,
  cellPadding: 1,
  cellSpacing: 1,
  challenge: 0,
  charSet: 1,
  checked: 0,
  children: 0,
  cite: 0,
  class: "className",
  classID: 1,
  className: 1,
  cols: 0,
  colSpan: 1,
  content: 0,
  contentEditable: 1,
  contextMenu: 1,
  controls: 0,
  controlsList: 1,
  coords: 0,
  crossOrigin: 1,
  dangerouslySetInnerHTML: 1,
  data: 0,
  dateTime: 1,
  default: 0,
  defaultChecked: 1,
  defaultValue: 1,
  defer: 0,
  dir: 0,
  disabled: 0,
  disablePictureInPicture: 1,
  disableRemotePlayback: 1,
  download: 0,
  draggable: 0,
  encType: 1,
  enterKeyHint: 1,
  for: "htmlFor",
  form: 0,
  formMethod: 1,
  formAction: 1,
  formEncType: 1,
  formNoValidate: 1,
  formTarget: 1,
  frameBorder: 1,
  headers: 0,
  height: 0,
  hidden: 0,
  high: 0,
  href: 0,
  hrefLang: 1,
  htmlFor: 1,
  httpEquiv: 1,
  "http-equiv": "httpEquiv",
  icon: 0,
  id: 0,
  innerHTML: 1,
  inputMode: 1,
  integrity: 0,
  is: 0,
  itemID: 1,
  itemProp: 1,
  itemRef: 1,
  itemScope: 1,
  itemType: 1,
  keyParams: 1,
  keyType: 1,
  kind: 0,
  label: 0,
  lang: 0,
  list: 0,
  loop: 0,
  low: 0,
  manifest: 0,
  marginWidth: 1,
  marginHeight: 1,
  max: 0,
  maxLength: 1,
  media: 0,
  mediaGroup: 1,
  method: 0,
  min: 0,
  minLength: 1,
  multiple: 0,
  muted: 0,
  name: 0,
  noModule: 1,
  nonce: 0,
  noValidate: 1,
  open: 0,
  optimum: 0,
  pattern: 0,
  placeholder: 0,
  playsInline: 1,
  poster: 0,
  preload: 0,
  profile: 0,
  radioGroup: 1,
  readOnly: 1,
  referrerPolicy: 1,
  rel: 0,
  required: 0,
  reversed: 0,
  role: 0,
  rows: 0,
  rowSpan: 1,
  sandbox: 0,
  scope: 0,
  scoped: 0,
  scrolling: 0,
  seamless: 0,
  selected: 0,
  shape: 0,
  size: 0,
  sizes: 0,
  span: 0,
  spellCheck: 1,
  src: 0,
  srcDoc: 1,
  srcLang: 1,
  srcSet: 1,
  start: 0,
  step: 0,
  style: 0,
  summary: 0,
  tabIndex: 1,
  target: 0,
  title: 0,
  type: 0,
  useMap: 1,
  value: 0,
  width: 0,
  wmode: 0,
  wrap: 0,
  about: 0,
  accentHeight: 1,
  "accent-height": "accentHeight",
  accumulate: 0,
  additive: 0,
  alignmentBaseline: 1,
  "alignment-baseline": "alignmentBaseline",
  allowReorder: 1,
  alphabetic: 0,
  amplitude: 0,
  arabicForm: 1,
  "arabic-form": "arabicForm",
  ascent: 0,
  attributeName: 1,
  attributeType: 1,
  autoReverse: 1,
  azimuth: 0,
  baseFrequency: 1,
  baselineShift: 1,
  "baseline-shift": "baselineShift",
  baseProfile: 1,
  bbox: 0,
  begin: 0,
  bias: 0,
  by: 0,
  calcMode: 1,
  capHeight: 1,
  "cap-height": "capHeight",
  clip: 0,
  clipPath: 1,
  "clip-path": "clipPath",
  clipPathUnits: 1,
  clipRule: 1,
  "clip-rule": "clipRule",
  color: 0,
  colorInterpolation: 1,
  "color-interpolation": "colorInterpolation",
  colorInterpolationFilters: 1,
  "color-interpolation-filters": "colorInterpolationFilters",
  colorProfile: 1,
  "color-profile": "colorProfile",
  colorRendering: 1,
  "color-rendering": "colorRendering",
  contentScriptType: 1,
  contentStyleType: 1,
  cursor: 0,
  cx: 0,
  cy: 0,
  d: 0,
  datatype: 0,
  decelerate: 0,
  descent: 0,
  diffuseConstant: 1,
  direction: 0,
  display: 0,
  divisor: 0,
  dominantBaseline: 1,
  "dominant-baseline": "dominantBaseline",
  dur: 0,
  dx: 0,
  dy: 0,
  edgeMode: 1,
  elevation: 0,
  enableBackground: 1,
  "enable-background": "enableBackground",
  end: 0,
  exponent: 0,
  externalResourcesRequired: 1,
  fill: 0,
  fillOpacity: 1,
  "fill-opacity": "fillOpacity",
  fillRule: 1,
  "fill-rule": "fillRule",
  filter: 0,
  filterRes: 1,
  filterUnits: 1,
  floodOpacity: 1,
  "flood-opacity": "floodOpacity",
  floodColor: 1,
  "flood-color": "floodColor",
  focusable: 0,
  fontFamily: 1,
  "font-family": "fontFamily",
  fontSize: 1,
  "font-size": "fontSize",
  fontSizeAdjust: 1,
  "font-size-adjust": "fontSizeAdjust",
  fontStretch: 1,
  "font-stretch": "fontStretch",
  fontStyle: 1,
  "font-style": "fontStyle",
  fontVariant: 1,
  "font-variant": "fontVariant",
  fontWeight: 1,
  "font-weight": "fontWeight",
  format: 0,
  from: 0,
  fx: 0,
  fy: 0,
  g1: 0,
  g2: 0,
  glyphName: 1,
  "glyph-name": "glyphName",
  glyphOrientationHorizontal: 1,
  "glyph-orientation-horizontal": "glyphOrientationHorizontal",
  glyphOrientationVertical: 1,
  "glyph-orientation-vertical": "glyphOrientationVertical",
  glyphRef: 1,
  gradientTransform: 1,
  gradientUnits: 1,
  hanging: 0,
  horizAdvX: 1,
  "horiz-adv-x": "horizAdvX",
  horizOriginX: 1,
  "horiz-origin-x": "horizOriginX",
  ideographic: 0,
  imageRendering: 1,
  "image-rendering": "imageRendering",
  in2: 0,
  in: 0,
  inlist: 0,
  intercept: 0,
  k1: 0,
  k2: 0,
  k3: 0,
  k4: 0,
  k: 0,
  kernelMatrix: 1,
  kernelUnitLength: 1,
  kerning: 0,
  keyPoints: 1,
  keySplines: 1,
  keyTimes: 1,
  lengthAdjust: 1,
  letterSpacing: 1,
  "letter-spacing": "letterSpacing",
  lightingColor: 1,
  "lighting-color": "lightingColor",
  limitingConeAngle: 1,
  local: 0,
  markerEnd: 1,
  "marker-end": "markerEnd",
  markerHeight: 1,
  markerMid: 1,
  "marker-mid": "markerMid",
  markerStart: 1,
  "marker-start": "markerStart",
  markerUnits: 1,
  markerWidth: 1,
  mask: 0,
  maskContentUnits: 1,
  maskUnits: 1,
  mathematical: 0,
  mode: 0,
  numOctaves: 1,
  offset: 0,
  opacity: 0,
  operator: 0,
  order: 0,
  orient: 0,
  orientation: 0,
  origin: 0,
  overflow: 0,
  overlinePosition: 1,
  "overline-position": "overlinePosition",
  overlineThickness: 1,
  "overline-thickness": "overlineThickness",
  paintOrder: 1,
  "paint-order": "paintOrder",
  panose1: 0,
  "panose-1": "panose1",
  pathLength: 1,
  patternContentUnits: 1,
  patternTransform: 1,
  patternUnits: 1,
  pointerEvents: 1,
  "pointer-events": "pointerEvents",
  points: 0,
  pointsAtX: 1,
  pointsAtY: 1,
  pointsAtZ: 1,
  prefix: 0,
  preserveAlpha: 1,
  preserveAspectRatio: 1,
  primitiveUnits: 1,
  property: 0,
  r: 0,
  radius: 0,
  refX: 1,
  refY: 1,
  renderingIntent: 1,
  "rendering-intent": "renderingIntent",
  repeatCount: 1,
  repeatDur: 1,
  requiredExtensions: 1,
  requiredFeatures: 1,
  resource: 0,
  restart: 0,
  result: 0,
  results: 0,
  rotate: 0,
  rx: 0,
  ry: 0,
  scale: 0,
  security: 0,
  seed: 0,
  shapeRendering: 1,
  "shape-rendering": "shapeRendering",
  slope: 0,
  spacing: 0,
  specularConstant: 1,
  specularExponent: 1,
  speed: 0,
  spreadMethod: 1,
  startOffset: 1,
  stdDeviation: 1,
  stemh: 0,
  stemv: 0,
  stitchTiles: 1,
  stopColor: 1,
  "stop-color": "stopColor",
  stopOpacity: 1,
  "stop-opacity": "stopOpacity",
  strikethroughPosition: 1,
  "strikethrough-position": "strikethroughPosition",
  strikethroughThickness: 1,
  "strikethrough-thickness": "strikethroughThickness",
  string: 0,
  stroke: 0,
  strokeDasharray: 1,
  "stroke-dasharray": "strokeDasharray",
  strokeDashoffset: 1,
  "stroke-dashoffset": "strokeDashoffset",
  strokeLinecap: 1,
  "stroke-linecap": "strokeLinecap",
  strokeLinejoin: 1,
  "stroke-linejoin": "strokeLinejoin",
  strokeMiterlimit: 1,
  "stroke-miterlimit": "strokeMiterlimit",
  strokeWidth: 1,
  "stroke-width": "strokeWidth",
  strokeOpacity: 1,
  "stroke-opacity": "strokeOpacity",
  suppressContentEditableWarning: 1,
  suppressHydrationWarning: 1,
  surfaceScale: 1,
  systemLanguage: 1,
  tableValues: 1,
  targetX: 1,
  targetY: 1,
  textAnchor: 1,
  "text-anchor": "textAnchor",
  textDecoration: 1,
  "text-decoration": "textDecoration",
  textLength: 1,
  textRendering: 1,
  "text-rendering": "textRendering",
  to: 0,
  transform: 0,
  typeof: 0,
  u1: 0,
  u2: 0,
  underlinePosition: 1,
  "underline-position": "underlinePosition",
  underlineThickness: 1,
  "underline-thickness": "underlineThickness",
  unicode: 0,
  unicodeBidi: 1,
  "unicode-bidi": "unicodeBidi",
  unicodeRange: 1,
  "unicode-range": "unicodeRange",
  unitsPerEm: 1,
  "units-per-em": "unitsPerEm",
  unselectable: 0,
  vAlphabetic: 1,
  "v-alphabetic": "vAlphabetic",
  values: 0,
  vectorEffect: 1,
  "vector-effect": "vectorEffect",
  version: 0,
  vertAdvY: 1,
  "vert-adv-y": "vertAdvY",
  vertOriginX: 1,
  "vert-origin-x": "vertOriginX",
  vertOriginY: 1,
  "vert-origin-y": "vertOriginY",
  vHanging: 1,
  "v-hanging": "vHanging",
  vIdeographic: 1,
  "v-ideographic": "vIdeographic",
  viewBox: 1,
  viewTarget: 1,
  visibility: 0,
  vMathematical: 1,
  "v-mathematical": "vMathematical",
  vocab: 0,
  widths: 0,
  wordSpacing: 1,
  "word-spacing": "wordSpacing",
  writingMode: 1,
  "writing-mode": "writingMode",
  x1: 0,
  x2: 0,
  x: 0,
  xChannelSelector: 1,
  xHeight: 1,
  "x-height": "xHeight",
  xlinkActuate: 1,
  "xlink:actuate": "xlinkActuate",
  xlinkArcrole: 1,
  "xlink:arcrole": "xlinkArcrole",
  xlinkHref: 1,
  "xlink:href": "xlinkHref",
  xlinkRole: 1,
  "xlink:role": "xlinkRole",
  xlinkShow: 1,
  "xlink:show": "xlinkShow",
  xlinkTitle: 1,
  "xlink:title": "xlinkTitle",
  xlinkType: 1,
  "xlink:type": "xlinkType",
  xmlBase: 1,
  "xml:base": "xmlBase",
  xmlLang: 1,
  "xml:lang": "xmlLang",
  xmlns: 0,
  "xml:space": "xmlSpace",
  xmlnsXlink: 1,
  "xmlns:xlink": "xmlnsXlink",
  xmlSpace: 1,
  y1: 0,
  y2: 0,
  y: 0,
  yChannelSelector: 1,
  z: 0,
  zoomAndPan: 1
};
const uJ = 0, Cu = 1, MC = 2, DC = 3, qM = 4, cJ = 5, pJ = 6;
function vwe(e) {
  return ui.hasOwnProperty(e) ? ui[e] : null;
}
function Ni(e, t, n, r, o, i, a) {
  this.acceptsBooleans = t === MC || t === DC || t === qM, this.attributeName = r, this.attributeNamespace = o, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = i, this.removeEmptyString = a;
}
const ui = {}, ywe = [
  "children",
  "dangerouslySetInnerHTML",
  // TODO: This prevents the assignment of defaultValue to regular
  // elements (not just inputs). Now that ReactDOMInput assigns to the
  // defaultValue property -- do we need this?
  "defaultValue",
  "defaultChecked",
  "innerHTML",
  "suppressContentEditableWarning",
  "suppressHydrationWarning",
  "style"
];
ywe.forEach((e) => {
  ui[e] = new Ni(
    e,
    uJ,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"]
].forEach(([e, t]) => {
  ui[e] = new Ni(
    e,
    Cu,
    !1,
    // mustUseProperty
    t,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["contentEditable", "draggable", "spellCheck", "value"].forEach((e) => {
  ui[e] = new Ni(
    e,
    MC,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha"
].forEach((e) => {
  ui[e] = new Ni(
    e,
    MC,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "allowFullScreen",
  "async",
  // Note: there is a special case that prevents it from being written to the DOM
  // on the client side because the browsers are inconsistent. Instead we call focus().
  "autoFocus",
  "autoPlay",
  "controls",
  "default",
  "defer",
  "disabled",
  "disablePictureInPicture",
  "disableRemotePlayback",
  "formNoValidate",
  "hidden",
  "loop",
  "noModule",
  "noValidate",
  "open",
  "playsInline",
  "readOnly",
  "required",
  "reversed",
  "scoped",
  "seamless",
  // Microdata
  "itemScope"
].forEach((e) => {
  ui[e] = new Ni(
    e,
    DC,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "checked",
  // Note: `option.selected` is not updated if `select.multiple` is
  // disabled with `removeAttribute`. We have special logic for handling this.
  "multiple",
  "muted",
  "selected"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  ui[e] = new Ni(
    e,
    DC,
    !0,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "capture",
  "download"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  ui[e] = new Ni(
    e,
    qM,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "cols",
  "rows",
  "size",
  "span"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  ui[e] = new Ni(
    e,
    pJ,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["rowSpan", "start"].forEach((e) => {
  ui[e] = new Ni(
    e,
    cJ,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const GM = /[\-\:]([a-z])/g, KM = (e) => e[1].toUpperCase();
[
  "accent-height",
  "alignment-baseline",
  "arabic-form",
  "baseline-shift",
  "cap-height",
  "clip-path",
  "clip-rule",
  "color-interpolation",
  "color-interpolation-filters",
  "color-profile",
  "color-rendering",
  "dominant-baseline",
  "enable-background",
  "fill-opacity",
  "fill-rule",
  "flood-color",
  "flood-opacity",
  "font-family",
  "font-size",
  "font-size-adjust",
  "font-stretch",
  "font-style",
  "font-variant",
  "font-weight",
  "glyph-name",
  "glyph-orientation-horizontal",
  "glyph-orientation-vertical",
  "horiz-adv-x",
  "horiz-origin-x",
  "image-rendering",
  "letter-spacing",
  "lighting-color",
  "marker-end",
  "marker-mid",
  "marker-start",
  "overline-position",
  "overline-thickness",
  "paint-order",
  "panose-1",
  "pointer-events",
  "rendering-intent",
  "shape-rendering",
  "stop-color",
  "stop-opacity",
  "strikethrough-position",
  "strikethrough-thickness",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "text-anchor",
  "text-decoration",
  "text-rendering",
  "underline-position",
  "underline-thickness",
  "unicode-bidi",
  "unicode-range",
  "units-per-em",
  "v-alphabetic",
  "v-hanging",
  "v-ideographic",
  "v-mathematical",
  "vector-effect",
  "vert-adv-y",
  "vert-origin-x",
  "vert-origin-y",
  "word-spacing",
  "writing-mode",
  "xmlns:xlink",
  "x-height"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(GM, KM);
  ui[t] = new Ni(
    t,
    Cu,
    !1,
    // mustUseProperty
    e,
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xlink:actuate",
  "xlink:arcrole",
  "xlink:role",
  "xlink:show",
  "xlink:title",
  "xlink:type"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(GM, KM);
  ui[t] = new Ni(
    t,
    Cu,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/1999/xlink",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xml:base",
  "xml:lang",
  "xml:space"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(GM, KM);
  ui[t] = new Ni(
    t,
    Cu,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/XML/1998/namespace",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["tabIndex", "crossOrigin"].forEach((e) => {
  ui[e] = new Ni(
    e,
    Cu,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const bwe = "xlinkHref";
ui[bwe] = new Ni(
  "xlinkHref",
  Cu,
  !1,
  // mustUseProperty
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  // sanitizeURL
  !1
  // removeEmptyString
);
["src", "href", "action", "formAction"].forEach((e) => {
  ui[e] = new Ni(
    e,
    Cu,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !0,
    // sanitizeURL
    !0
    // removeEmptyString
  );
});
const {
  CAMELCASE: wwe,
  SAME: Cwe,
  possibleStandardNames: EB
} = SC, Owe = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", xwe = Owe + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", Ewe = RegExp.prototype.test.bind(
  // eslint-disable-next-line no-misleading-character-class
  new RegExp("^(data|aria)-[" + xwe + "]*$")
), kwe = Object.keys(
  EB
).reduce((e, t) => {
  const n = EB[t];
  return n === Cwe ? e[t] = t : n === wwe ? e[t.toLowerCase()] = t : e[t] = n, e;
}, {});
Ys.BOOLEAN = DC;
Ys.BOOLEANISH_STRING = MC;
Ys.NUMERIC = cJ;
Ys.OVERLOADED_BOOLEAN = qM;
Ys.POSITIVE_NUMERIC = pJ;
Ys.RESERVED = uJ;
Ys.STRING = Cu;
Ys.getPropertyInfo = vwe;
Ys.isCustomAttribute = Ewe;
Ys.possibleStandardNames = kwe;
var XM = {}, YM = {}, kB = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, Lwe = /\n/g, _we = /^\s*/, Pwe = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, Swe = /^:\s*/, Mwe = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, Dwe = /^[;\s]*/, Twe = /^\s+|\s+$/g, jwe = `
`, LB = "/", _B = "*", pc = "", Awe = "comment", Rwe = "declaration", Iwe = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e) return [];
  t = t || {};
  var n = 1, r = 1;
  function o(f) {
    var m = f.match(Lwe);
    m && (n += m.length);
    var b = f.lastIndexOf(jwe);
    r = ~b ? f.length - b : r + f.length;
  }
  function i() {
    var f = { line: n, column: r };
    return function(m) {
      return m.position = new a(f), u(), m;
    };
  }
  function a(f) {
    this.start = f, this.end = { line: n, column: r }, this.source = t.source;
  }
  a.prototype.content = e;
  function s(f) {
    var m = new Error(
      t.source + ":" + n + ":" + r + ": " + f
    );
    if (m.reason = f, m.filename = t.source, m.line = n, m.column = r, m.source = e, !t.silent) throw m;
  }
  function l(f) {
    var m = f.exec(e);
    if (m) {
      var b = m[0];
      return o(b), e = e.slice(b.length), m;
    }
  }
  function u() {
    l(_we);
  }
  function c(f) {
    var m;
    for (f = f || []; m = p(); )
      m !== !1 && f.push(m);
    return f;
  }
  function p() {
    var f = i();
    if (!(LB != e.charAt(0) || _B != e.charAt(1))) {
      for (var m = 2; pc != e.charAt(m) && (_B != e.charAt(m) || LB != e.charAt(m + 1)); )
        ++m;
      if (m += 2, pc === e.charAt(m - 1))
        return s("End of comment missing");
      var b = e.slice(2, m - 2);
      return r += 2, o(b), e = e.slice(m), r += 2, f({
        type: Awe,
        comment: b
      });
    }
  }
  function d() {
    var f = i(), m = l(Pwe);
    if (m) {
      if (p(), !l(Swe)) return s("property missing ':'");
      var b = l(Mwe), E = f({
        type: Rwe,
        property: PB(m[0].replace(kB, pc)),
        value: b ? PB(b[0].replace(kB, pc)) : pc
      });
      return l(Dwe), E;
    }
  }
  function g() {
    var f = [];
    c(f);
    for (var m; m = d(); )
      m !== !1 && (f.push(m), c(f));
    return f;
  }
  return u(), g();
};
function PB(e) {
  return e ? e.replace(Twe, pc) : pc;
}
var Nwe = br && br.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(YM, "__esModule", { value: !0 });
YM.default = Fwe;
var Bwe = Nwe(Iwe);
function Fwe(e, t) {
  var n = null;
  if (!e || typeof e != "string")
    return n;
  var r = (0, Bwe.default)(e), o = typeof t == "function";
  return r.forEach(function(i) {
    if (i.type === "declaration") {
      var a = i.property, s = i.value;
      o ? t(a, s, i) : s && (n = n || {}, n[a] = s);
    }
  }), n;
}
var TC = {};
Object.defineProperty(TC, "__esModule", { value: !0 });
TC.camelCase = void 0;
var zwe = /^--[a-zA-Z0-9_-]+$/, Uwe = /-([a-z])/g, Hwe = /^[^-]+$/, Wwe = /^-(webkit|moz|ms|o|khtml)-/, $we = /^-(ms)-/, Vwe = function(e) {
  return !e || Hwe.test(e) || zwe.test(e);
}, Zwe = function(e, t) {
  return t.toUpperCase();
}, SB = function(e, t) {
  return "".concat(t, "-");
}, qwe = function(e, t) {
  return t === void 0 && (t = {}), Vwe(e) ? e : (e = e.toLowerCase(), t.reactCompat ? e = e.replace($we, SB) : e = e.replace(Wwe, SB), e.replace(Uwe, Zwe));
};
TC.camelCase = qwe;
var Gwe = br && br.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
}, Kwe = Gwe(YM), Xwe = TC;
function m_(e, t) {
  var n = {};
  return !e || typeof e != "string" || (0, Kwe.default)(e, function(r, o) {
    r && o && (n[(0, Xwe.camelCase)(r, t)] = o);
  }), n;
}
m_.default = m_;
var Ywe = m_;
(function(e) {
  var t = br && br.__importDefault || function(c) {
    return c && c.__esModule ? c : { default: c };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.returnFirstArg = e.canTextBeChildOfNode = e.ELEMENTS_WITH_NO_TEXT_CHILDREN = e.PRESERVE_CUSTOM_ATTRIBUTES = void 0, e.isCustomComponent = i, e.setStyleProp = s;
  var n = be, r = t(Ywe), o = /* @__PURE__ */ new Set([
    "annotation-xml",
    "color-profile",
    "font-face",
    "font-face-src",
    "font-face-uri",
    "font-face-format",
    "font-face-name",
    "missing-glyph"
  ]);
  function i(c, p) {
    return c.includes("-") ? !o.has(c) : !!(p && typeof p.is == "string");
  }
  var a = {
    reactCompat: !0
  };
  function s(c, p) {
    if (typeof c == "string") {
      if (!c.trim()) {
        p.style = {};
        return;
      }
      try {
        p.style = (0, r.default)(c, a);
      } catch {
        p.style = {};
      }
    }
  }
  e.PRESERVE_CUSTOM_ATTRIBUTES = Number(n.version.split(".")[0]) >= 16, e.ELEMENTS_WITH_NO_TEXT_CHILDREN = /* @__PURE__ */ new Set([
    "tr",
    "tbody",
    "thead",
    "tfoot",
    "colgroup",
    "table",
    "head",
    "html",
    "frameset"
  ]);
  var l = function(c) {
    return !e.ELEMENTS_WITH_NO_TEXT_CHILDREN.has(c.name);
  };
  e.canTextBeChildOfNode = l;
  var u = function(c) {
    return c;
  };
  e.returnFirstArg = u;
})(XM);
Object.defineProperty(PC, "__esModule", { value: !0 });
PC.default = t0e;
var tf = Ys, MB = XM, Jwe = ["checked", "value"], Qwe = ["input", "select", "textarea"], e0e = {
  reset: !0,
  submit: !0
};
function t0e(e, t) {
  e === void 0 && (e = {});
  var n = {}, r = !!(e.type && e0e[e.type]);
  for (var o in e) {
    var i = e[o];
    if ((0, tf.isCustomAttribute)(o)) {
      n[o] = i;
      continue;
    }
    var a = o.toLowerCase(), s = DB(a);
    if (s) {
      var l = (0, tf.getPropertyInfo)(s);
      switch (Jwe.includes(s) && Qwe.includes(t) && !r && (s = DB("default" + a)), n[s] = i, l && l.type) {
        case tf.BOOLEAN:
          n[s] = !0;
          break;
        case tf.OVERLOADED_BOOLEAN:
          i === "" && (n[s] = !0);
          break;
      }
      continue;
    }
    MB.PRESERVE_CUSTOM_ATTRIBUTES && (n[o] = i);
  }
  return (0, MB.setStyleProp)(e.style, n), n;
}
function DB(e) {
  return tf.possibleStandardNames[e];
}
var JM = {}, n0e = br && br.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(JM, "__esModule", { value: !0 });
JM.default = dJ;
var Bx = be, r0e = n0e(PC), bf = XM, o0e = {
  cloneElement: Bx.cloneElement,
  createElement: Bx.createElement,
  isValidElement: Bx.isValidElement
};
function dJ(e, t) {
  t === void 0 && (t = {});
  for (var n = [], r = typeof t.replace == "function", o = t.transform || bf.returnFirstArg, i = t.library || o0e, a = i.cloneElement, s = i.createElement, l = i.isValidElement, u = e.length, c = 0; c < u; c++) {
    var p = e[c];
    if (r) {
      var d = t.replace(p, c);
      if (l(d)) {
        u > 1 && (d = a(d, {
          key: d.key || c
        })), n.push(o(d, p, c));
        continue;
      }
    }
    if (p.type === "text") {
      var g = !p.data.trim().length;
      if (g && p.parent && !(0, bf.canTextBeChildOfNode)(p.parent) || t.trim && g)
        continue;
      n.push(o(p.data, p, c));
      continue;
    }
    var f = p, m = {};
    i0e(f) ? ((0, bf.setStyleProp)(f.attribs.style, f.attribs), m = f.attribs) : f.attribs && (m = (0, r0e.default)(f.attribs, f.name));
    var b = void 0;
    switch (p.type) {
      case "script":
      case "style":
        p.children[0] && (m.dangerouslySetInnerHTML = {
          __html: p.children[0].data
        });
        break;
      case "tag":
        p.name === "textarea" && p.children[0] ? m.defaultValue = p.children[0].data : p.children && p.children.length && (b = dJ(p.children, t));
        break;
      default:
        continue;
    }
    u > 1 && (m.key = c), n.push(o(s(p.name, m, b), p, c));
  }
  return n.length === 1 ? n[0] : n;
}
function i0e(e) {
  return bf.PRESERVE_CUSTOM_ATTRIBUTES && e.type === "tag" && (0, bf.isCustomComponent)(e.name, e.attribs);
}
(function(e) {
  var t = br && br.__importDefault || function(l) {
    return l && l.__esModule ? l : { default: l };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.htmlToDOM = e.domToReact = e.attributesToProps = e.Text = e.ProcessingInstruction = e.Element = e.Comment = void 0, e.default = s;
  var n = t(UM);
  e.htmlToDOM = n.default;
  var r = t(PC);
  e.attributesToProps = r.default;
  var o = t(JM);
  e.domToReact = o.default;
  var i = WM;
  Object.defineProperty(e, "Comment", { enumerable: !0, get: function() {
    return i.Comment;
  } }), Object.defineProperty(e, "Element", { enumerable: !0, get: function() {
    return i.Element;
  } }), Object.defineProperty(e, "ProcessingInstruction", { enumerable: !0, get: function() {
    return i.ProcessingInstruction;
  } }), Object.defineProperty(e, "Text", { enumerable: !0, get: function() {
    return i.Text;
  } });
  var a = { lowerCaseAttributeNames: !1 };
  function s(l, u) {
    if (typeof l != "string")
      throw new TypeError("First argument must be a string");
    return l ? (0, o.default)((0, n.default)(l, (u == null ? void 0 : u.htmlparser2) || a), u) : [];
  }
})(ZY);
const s0e = /* @__PURE__ */ kbe(ZY);
s0e.default;
var wr = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function a0e(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var v_ = { exports: {} }, gd = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var TB;
function l0e() {
  if (TB) return gd;
  TB = 1;
  var e = be, t = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, o = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, i = { key: !0, ref: !0, __self: !0, __source: !0 };
  function a(s, l, u) {
    var c, p = {}, d = null, g = null;
    u !== void 0 && (d = "" + u), l.key !== void 0 && (d = "" + l.key), l.ref !== void 0 && (g = l.ref);
    for (c in l) r.call(l, c) && !i.hasOwnProperty(c) && (p[c] = l[c]);
    if (s && s.defaultProps) for (c in l = s.defaultProps, l) p[c] === void 0 && (p[c] = l[c]);
    return { $$typeof: t, type: s, key: d, ref: g, props: p, _owner: o.current };
  }
  return gd.Fragment = n, gd.jsx = a, gd.jsxs = a, gd;
}
var Bm = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var jB;
function u0e() {
  return jB || (jB = 1, process.env.NODE_ENV !== "production" && function() {
    var e = be, t = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), a = Symbol.for("react.provider"), s = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), c = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), d = Symbol.for("react.lazy"), g = Symbol.for("react.offscreen"), f = Symbol.iterator, m = "@@iterator";
    function b(y) {
      if (y === null || typeof y != "object")
        return null;
      var R = f && y[f] || y[m];
      return typeof R == "function" ? R : null;
    }
    var E = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function w(y) {
      {
        for (var R = arguments.length, G = new Array(R > 1 ? R - 1 : 0), ne = 1; ne < R; ne++)
          G[ne - 1] = arguments[ne];
        M("error", y, G);
      }
    }
    function M(y, R, G) {
      {
        var ne = E.ReactDebugCurrentFrame, ae = ne.getStackAddendum();
        ae !== "" && (R += "%s", G = G.concat([ae]));
        var ue = G.map(function(se) {
          return String(se);
        });
        ue.unshift("Warning: " + R), Function.prototype.apply.call(console[y], console, ue);
      }
    }
    var x = !1, v = !1, C = !1, P = !1, F = !1, L;
    L = Symbol.for("react.module.reference");
    function B(y) {
      return !!(typeof y == "string" || typeof y == "function" || y === r || y === i || F || y === o || y === u || y === c || P || y === g || x || v || C || typeof y == "object" && y !== null && (y.$$typeof === d || y.$$typeof === p || y.$$typeof === a || y.$$typeof === s || y.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      y.$$typeof === L || y.getModuleId !== void 0));
    }
    function N(y, R, G) {
      var ne = y.displayName;
      if (ne)
        return ne;
      var ae = R.displayName || R.name || "";
      return ae !== "" ? G + "(" + ae + ")" : G;
    }
    function $(y) {
      return y.displayName || "Context";
    }
    function V(y) {
      if (y == null)
        return null;
      if (typeof y.tag == "number" && w("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof y == "function")
        return y.displayName || y.name || null;
      if (typeof y == "string")
        return y;
      switch (y) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case i:
          return "Profiler";
        case o:
          return "StrictMode";
        case u:
          return "Suspense";
        case c:
          return "SuspenseList";
      }
      if (typeof y == "object")
        switch (y.$$typeof) {
          case s:
            var R = y;
            return $(R) + ".Consumer";
          case a:
            var G = y;
            return $(G._context) + ".Provider";
          case l:
            return N(y, y.render, "ForwardRef");
          case p:
            var ne = y.displayName || null;
            return ne !== null ? ne : V(y.type) || "Memo";
          case d: {
            var ae = y, ue = ae._payload, se = ae._init;
            try {
              return V(se(ue));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var H = Object.assign, Z = 0, K, Y, Q, J, _, D, z;
    function S() {
    }
    S.__reactDisabledLog = !0;
    function W() {
      {
        if (Z === 0) {
          K = console.log, Y = console.info, Q = console.warn, J = console.error, _ = console.group, D = console.groupCollapsed, z = console.groupEnd;
          var y = {
            configurable: !0,
            enumerable: !0,
            value: S,
            writable: !0
          };
          Object.defineProperties(console, {
            info: y,
            log: y,
            warn: y,
            error: y,
            group: y,
            groupCollapsed: y,
            groupEnd: y
          });
        }
        Z++;
      }
    }
    function O() {
      {
        if (Z--, Z === 0) {
          var y = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: H({}, y, {
              value: K
            }),
            info: H({}, y, {
              value: Y
            }),
            warn: H({}, y, {
              value: Q
            }),
            error: H({}, y, {
              value: J
            }),
            group: H({}, y, {
              value: _
            }),
            groupCollapsed: H({}, y, {
              value: D
            }),
            groupEnd: H({}, y, {
              value: z
            })
          });
        }
        Z < 0 && w("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var j = E.ReactCurrentDispatcher, U;
    function T(y, R, G) {
      {
        if (U === void 0)
          try {
            throw Error();
          } catch (ae) {
            var ne = ae.stack.trim().match(/\n( *(at )?)/);
            U = ne && ne[1] || "";
          }
        return `
` + U + y;
      }
    }
    var q = !1, A;
    {
      var X = typeof WeakMap == "function" ? WeakMap : Map;
      A = new X();
    }
    function I(y, R) {
      if (!y || q)
        return "";
      {
        var G = A.get(y);
        if (G !== void 0)
          return G;
      }
      var ne;
      q = !0;
      var ae = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var ue;
      ue = j.current, j.current = null, W();
      try {
        if (R) {
          var se = function() {
            throw Error();
          };
          if (Object.defineProperty(se.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(se, []);
            } catch (je) {
              ne = je;
            }
            Reflect.construct(y, [], se);
          } else {
            try {
              se.call();
            } catch (je) {
              ne = je;
            }
            y.call(se.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (je) {
            ne = je;
          }
          y();
        }
      } catch (je) {
        if (je && ne && typeof je.stack == "string") {
          for (var ie = je.stack.split(`
`), Oe = ne.stack.split(`
`), de = ie.length - 1, fe = Oe.length - 1; de >= 1 && fe >= 0 && ie[de] !== Oe[fe]; )
            fe--;
          for (; de >= 1 && fe >= 0; de--, fe--)
            if (ie[de] !== Oe[fe]) {
              if (de !== 1 || fe !== 1)
                do
                  if (de--, fe--, fe < 0 || ie[de] !== Oe[fe]) {
                    var ze = `
` + ie[de].replace(" at new ", " at ");
                    return y.displayName && ze.includes("<anonymous>") && (ze = ze.replace("<anonymous>", y.displayName)), typeof y == "function" && A.set(y, ze), ze;
                  }
                while (de >= 1 && fe >= 0);
              break;
            }
        }
      } finally {
        q = !1, j.current = ue, O(), Error.prepareStackTrace = ae;
      }
      var Et = y ? y.displayName || y.name : "", bt = Et ? T(Et) : "";
      return typeof y == "function" && A.set(y, bt), bt;
    }
    function le(y, R, G) {
      return I(y, !1);
    }
    function he(y) {
      var R = y.prototype;
      return !!(R && R.isReactComponent);
    }
    function oe(y, R, G) {
      if (y == null)
        return "";
      if (typeof y == "function")
        return I(y, he(y));
      if (typeof y == "string")
        return T(y);
      switch (y) {
        case u:
          return T("Suspense");
        case c:
          return T("SuspenseList");
      }
      if (typeof y == "object")
        switch (y.$$typeof) {
          case l:
            return le(y.render);
          case p:
            return oe(y.type, R, G);
          case d: {
            var ne = y, ae = ne._payload, ue = ne._init;
            try {
              return oe(ue(ae), R, G);
            } catch {
            }
          }
        }
      return "";
    }
    var Ae = Object.prototype.hasOwnProperty, Ue = {}, He = E.ReactDebugCurrentFrame;
    function Re(y) {
      if (y) {
        var R = y._owner, G = oe(y.type, y._source, R ? R.type : null);
        He.setExtraStackFrame(G);
      } else
        He.setExtraStackFrame(null);
    }
    function nt(y, R, G, ne, ae) {
      {
        var ue = Function.call.bind(Ae);
        for (var se in y)
          if (ue(y, se)) {
            var ie = void 0;
            try {
              if (typeof y[se] != "function") {
                var Oe = Error((ne || "React class") + ": " + G + " type `" + se + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof y[se] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw Oe.name = "Invariant Violation", Oe;
              }
              ie = y[se](R, se, ne, G, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (de) {
              ie = de;
            }
            ie && !(ie instanceof Error) && (Re(ae), w("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", ne || "React class", G, se, typeof ie), Re(null)), ie instanceof Error && !(ie.message in Ue) && (Ue[ie.message] = !0, Re(ae), w("Failed %s type: %s", G, ie.message), Re(null));
          }
      }
    }
    var Ve = Array.isArray;
    function we(y) {
      return Ve(y);
    }
    function et(y) {
      {
        var R = typeof Symbol == "function" && Symbol.toStringTag, G = R && y[Symbol.toStringTag] || y.constructor.name || "Object";
        return G;
      }
    }
    function lt(y) {
      try {
        return ye(y), !1;
      } catch {
        return !0;
      }
    }
    function ye(y) {
      return "" + y;
    }
    function ke(y) {
      if (lt(y))
        return w("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", et(y)), ye(y);
    }
    var Qe = E.ReactCurrentOwner, Fe = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, Ie, ot;
    function Ee(y) {
      if (Ae.call(y, "ref")) {
        var R = Object.getOwnPropertyDescriptor(y, "ref").get;
        if (R && R.isReactWarning)
          return !1;
      }
      return y.ref !== void 0;
    }
    function wt(y) {
      if (Ae.call(y, "key")) {
        var R = Object.getOwnPropertyDescriptor(y, "key").get;
        if (R && R.isReactWarning)
          return !1;
      }
      return y.key !== void 0;
    }
    function it(y, R) {
      typeof y.ref == "string" && Qe.current;
    }
    function st(y, R) {
      {
        var G = function() {
          Ie || (Ie = !0, w("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", R));
        };
        G.isReactWarning = !0, Object.defineProperty(y, "key", {
          get: G,
          configurable: !0
        });
      }
    }
    function ut(y, R) {
      {
        var G = function() {
          ot || (ot = !0, w("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", R));
        };
        G.isReactWarning = !0, Object.defineProperty(y, "ref", {
          get: G,
          configurable: !0
        });
      }
    }
    var Ct = function(y, R, G, ne, ae, ue, se) {
      var ie = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: y,
        key: R,
        ref: G,
        props: se,
        // Record the component responsible for creating this element.
        _owner: ue
      };
      return ie._store = {}, Object.defineProperty(ie._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(ie, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ne
      }), Object.defineProperty(ie, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ae
      }), Object.freeze && (Object.freeze(ie.props), Object.freeze(ie)), ie;
    };
    function ct(y, R, G, ne, ae) {
      {
        var ue, se = {}, ie = null, Oe = null;
        G !== void 0 && (ke(G), ie = "" + G), wt(R) && (ke(R.key), ie = "" + R.key), Ee(R) && (Oe = R.ref, it(R));
        for (ue in R)
          Ae.call(R, ue) && !Fe.hasOwnProperty(ue) && (se[ue] = R[ue]);
        if (y && y.defaultProps) {
          var de = y.defaultProps;
          for (ue in de)
            se[ue] === void 0 && (se[ue] = de[ue]);
        }
        if (ie || Oe) {
          var fe = typeof y == "function" ? y.displayName || y.name || "Unknown" : y;
          ie && st(se, fe), Oe && ut(se, fe);
        }
        return Ct(y, ie, Oe, ae, ne, Qe.current, se);
      }
    }
    var pt = E.ReactCurrentOwner, rt = E.ReactDebugCurrentFrame;
    function We(y) {
      if (y) {
        var R = y._owner, G = oe(y.type, y._source, R ? R.type : null);
        rt.setExtraStackFrame(G);
      } else
        rt.setExtraStackFrame(null);
    }
    var Ot;
    Ot = !1;
    function xt(y) {
      return typeof y == "object" && y !== null && y.$$typeof === t;
    }
    function gt() {
      {
        if (pt.current) {
          var y = V(pt.current.type);
          if (y)
            return `

Check the render method of \`` + y + "`.";
        }
        return "";
      }
    }
    function Ht(y) {
      return "";
    }
    var mt = {};
    function Wt(y) {
      {
        var R = gt();
        if (!R) {
          var G = typeof y == "string" ? y : y.displayName || y.name;
          G && (R = `

Check the top-level render call using <` + G + ">.");
        }
        return R;
      }
    }
    function vt(y, R) {
      {
        if (!y._store || y._store.validated || y.key != null)
          return;
        y._store.validated = !0;
        var G = Wt(R);
        if (mt[G])
          return;
        mt[G] = !0;
        var ne = "";
        y && y._owner && y._owner !== pt.current && (ne = " It was passed a child from " + V(y._owner.type) + "."), We(y), w('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', G, ne), We(null);
      }
    }
    function kt(y, R) {
      {
        if (typeof y != "object")
          return;
        if (we(y))
          for (var G = 0; G < y.length; G++) {
            var ne = y[G];
            xt(ne) && vt(ne, R);
          }
        else if (xt(y))
          y._store && (y._store.validated = !0);
        else if (y) {
          var ae = b(y);
          if (typeof ae == "function" && ae !== y.entries)
            for (var ue = ae.call(y), se; !(se = ue.next()).done; )
              xt(se.value) && vt(se.value, R);
        }
      }
    }
    function Un(y) {
      {
        var R = y.type;
        if (R == null || typeof R == "string")
          return;
        var G;
        if (typeof R == "function")
          G = R.propTypes;
        else if (typeof R == "object" && (R.$$typeof === l || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        R.$$typeof === p))
          G = R.propTypes;
        else
          return;
        if (G) {
          var ne = V(R);
          nt(G, y.props, "prop", ne, y);
        } else if (R.PropTypes !== void 0 && !Ot) {
          Ot = !0;
          var ae = V(R);
          w("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", ae || "Unknown");
        }
        typeof R.getDefaultProps == "function" && !R.getDefaultProps.isReactClassApproved && w("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function yt(y) {
      {
        for (var R = Object.keys(y.props), G = 0; G < R.length; G++) {
          var ne = R[G];
          if (ne !== "children" && ne !== "key") {
            We(y), w("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", ne), We(null);
            break;
          }
        }
        y.ref !== null && (We(y), w("Invalid attribute `ref` supplied to `React.Fragment`."), We(null));
      }
    }
    var re = {};
    function ao(y, R, G, ne, ae, ue) {
      {
        var se = B(y);
        if (!se) {
          var ie = "";
          (y === void 0 || typeof y == "object" && y !== null && Object.keys(y).length === 0) && (ie += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var Oe = Ht();
          Oe ? ie += Oe : ie += gt();
          var de;
          y === null ? de = "null" : we(y) ? de = "array" : y !== void 0 && y.$$typeof === t ? (de = "<" + (V(y.type) || "Unknown") + " />", ie = " Did you accidentally export a JSX literal instead of a component?") : de = typeof y, w("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", de, ie);
        }
        var fe = ct(y, R, G, ae, ue);
        if (fe == null)
          return fe;
        if (se) {
          var ze = R.children;
          if (ze !== void 0)
            if (ne)
              if (we(ze)) {
                for (var Et = 0; Et < ze.length; Et++)
                  kt(ze[Et], y);
                Object.freeze && Object.freeze(ze);
              } else
                w("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              kt(ze, y);
        }
        if (Ae.call(R, "key")) {
          var bt = V(y), je = Object.keys(R).filter(function(Li) {
            return Li !== "key";
          }), Hn = je.length > 0 ? "{key: someKey, " + je.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!re[bt + Hn]) {
            var ki = je.length > 0 ? "{" + je.join(": ..., ") + ": ...}" : "{}";
            w(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, Hn, bt, ki, bt), re[bt + Hn] = !0;
          }
        }
        return y === r ? yt(fe) : Un(fe), fe;
      }
    }
    function Ci(y, R, G) {
      return ao(y, R, G, !0);
    }
    function Oi(y, R, G) {
      return ao(y, R, G, !1);
    }
    var xi = Oi, Ei = Ci;
    Bm.Fragment = r, Bm.jsx = xi, Bm.jsxs = Ei;
  }()), Bm;
}
process.env.NODE_ENV === "production" ? v_.exports = l0e() : v_.exports = u0e();
var ni = v_.exports;
$e({});
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function AB(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function vi(e) {
  var t, n;
  return AB(e) === !1 ? !1 : (t = e.constructor, t === void 0 ? !0 : (n = t.prototype, !(AB(n) === !1 || n.hasOwnProperty("isPrototypeOf") === !1)));
}
var fJ = Symbol.for("immer-nothing"), RB = Symbol.for("immer-draftable"), Ts = Symbol.for("immer-state"), c0e = process.env.NODE_ENV !== "production" ? [
  // All error codes, starting by 0:
  function(e) {
    return `The plugin for '${e}' has not been loaded into Immer. To enable the plugin, import and call \`enable${e}()\` when initializing your application.`;
  },
  function(e) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${e}'`;
  },
  "This object has been frozen and should not be mutated",
  function(e) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + e;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(e) {
    return `'current' expects a draft, got: ${e}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(e) {
    return `'original' expects a draft, got: ${e}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function Gi(e, ...t) {
  if (process.env.NODE_ENV !== "production") {
    const n = c0e[e], r = typeof n == "function" ? n.apply(null, t) : n;
    throw new Error(`[Immer] ${r}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var _p = Object.getPrototypeOf;
function Gc(e) {
  return !!e && !!e[Ts];
}
function Kc(e) {
  var t;
  return e ? hJ(e) || Array.isArray(e) || !!e[RB] || !!((t = e.constructor) != null && t[RB]) || AC(e) || RC(e) : !1;
}
var p0e = Object.prototype.constructor.toString();
function hJ(e) {
  if (!e || typeof e != "object")
    return !1;
  const t = _p(e);
  if (t === null)
    return !0;
  const n = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
  return n === Object ? !0 : typeof n == "function" && Function.toString.call(n) === p0e;
}
function Ob(e, t) {
  jC(e) === 0 ? Reflect.ownKeys(e).forEach((n) => {
    t(n, e[n], e);
  }) : e.forEach((n, r) => t(r, n, e));
}
function jC(e) {
  const t = e[Ts];
  return t ? t.type_ : Array.isArray(e) ? 1 : AC(e) ? 2 : RC(e) ? 3 : 0;
}
function y_(e, t) {
  return jC(e) === 2 ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t);
}
function gJ(e, t, n) {
  const r = jC(e);
  r === 2 ? e.set(t, n) : r === 3 ? e.add(n) : e[t] = n;
}
function d0e(e, t) {
  return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && t !== t;
}
function AC(e) {
  return e instanceof Map;
}
function RC(e) {
  return e instanceof Set;
}
function rc(e) {
  return e.copy_ || e.base_;
}
function b_(e, t) {
  if (AC(e))
    return new Map(e);
  if (RC(e))
    return new Set(e);
  if (Array.isArray(e))
    return Array.prototype.slice.call(e);
  const n = hJ(e);
  if (t === !0 || t === "class_only" && !n) {
    const r = Object.getOwnPropertyDescriptors(e);
    delete r[Ts];
    let o = Reflect.ownKeys(r);
    for (let i = 0; i < o.length; i++) {
      const a = o[i], s = r[a];
      s.writable === !1 && (s.writable = !0, s.configurable = !0), (s.get || s.set) && (r[a] = {
        configurable: !0,
        writable: !0,
        // could live with !!desc.set as well here...
        enumerable: s.enumerable,
        value: e[a]
      });
    }
    return Object.create(_p(e), r);
  } else {
    const r = _p(e);
    if (r !== null && n)
      return { ...e };
    const o = Object.create(r);
    return Object.assign(o, e);
  }
}
function QM(e, t = !1) {
  return IC(e) || Gc(e) || !Kc(e) || (jC(e) > 1 && (e.set = e.add = e.clear = e.delete = f0e), Object.freeze(e), t && Object.entries(e).forEach(([n, r]) => QM(r, !0))), e;
}
function f0e() {
  Gi(2);
}
function IC(e) {
  return Object.isFrozen(e);
}
var h0e = {};
function Xc(e) {
  const t = h0e[e];
  return t || Gi(0, e), t;
}
var Oh;
function mJ() {
  return Oh;
}
function g0e(e, t) {
  return {
    drafts_: [],
    parent_: e,
    immer_: t,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0
  };
}
function IB(e, t) {
  t && (Xc("Patches"), e.patches_ = [], e.inversePatches_ = [], e.patchListener_ = t);
}
function w_(e) {
  C_(e), e.drafts_.forEach(m0e), e.drafts_ = null;
}
function C_(e) {
  e === Oh && (Oh = e.parent_);
}
function NB(e) {
  return Oh = g0e(Oh, e);
}
function m0e(e) {
  const t = e[Ts];
  t.type_ === 0 || t.type_ === 1 ? t.revoke_() : t.revoked_ = !0;
}
function BB(e, t) {
  t.unfinalizedDrafts_ = t.drafts_.length;
  const n = t.drafts_[0];
  return e !== void 0 && e !== n ? (n[Ts].modified_ && (w_(t), Gi(4)), Kc(e) && (e = xb(t, e), t.parent_ || Eb(t, e)), t.patches_ && Xc("Patches").generateReplacementPatches_(
    n[Ts].base_,
    e,
    t.patches_,
    t.inversePatches_
  )) : e = xb(t, n, []), w_(t), t.patches_ && t.patchListener_(t.patches_, t.inversePatches_), e !== fJ ? e : void 0;
}
function xb(e, t, n) {
  if (IC(t))
    return t;
  const r = t[Ts];
  if (!r)
    return Ob(
      t,
      (o, i) => FB(e, r, t, o, i, n)
    ), t;
  if (r.scope_ !== e)
    return t;
  if (!r.modified_)
    return Eb(e, r.base_, !0), r.base_;
  if (!r.finalized_) {
    r.finalized_ = !0, r.scope_.unfinalizedDrafts_--;
    const o = r.copy_;
    let i = o, a = !1;
    r.type_ === 3 && (i = new Set(o), o.clear(), a = !0), Ob(
      i,
      (s, l) => FB(e, r, o, s, l, n, a)
    ), Eb(e, o, !1), n && e.patches_ && Xc("Patches").generatePatches_(
      r,
      n,
      e.patches_,
      e.inversePatches_
    );
  }
  return r.copy_;
}
function FB(e, t, n, r, o, i, a) {
  if (process.env.NODE_ENV !== "production" && o === n && Gi(5), Gc(o)) {
    const s = i && t && t.type_ !== 3 && // Set objects are atomic since they have no keys.
    !y_(t.assigned_, r) ? i.concat(r) : void 0, l = xb(e, o, s);
    if (gJ(n, r, l), Gc(l))
      e.canAutoFreeze_ = !1;
    else
      return;
  } else a && n.add(o);
  if (Kc(o) && !IC(o)) {
    if (!e.immer_.autoFreeze_ && e.unfinalizedDrafts_ < 1)
      return;
    xb(e, o), (!t || !t.scope_.parent_) && typeof r != "symbol" && Object.prototype.propertyIsEnumerable.call(n, r) && Eb(e, o);
  }
}
function Eb(e, t, n = !1) {
  !e.parent_ && e.immer_.autoFreeze_ && e.canAutoFreeze_ && QM(t, n);
}
function v0e(e, t) {
  const n = Array.isArray(e), r = {
    type_: n ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: t ? t.scope_ : mJ(),
    // True for both shallow and deep changes.
    modified_: !1,
    // Used during finalization.
    finalized_: !1,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: t,
    // The base state.
    base_: e,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: !1
  };
  let o = r, i = eD;
  n && (o = [r], i = xh);
  const { revoke: a, proxy: s } = Proxy.revocable(o, i);
  return r.draft_ = s, r.revoke_ = a, s;
}
var eD = {
  get(e, t) {
    if (t === Ts)
      return e;
    const n = rc(e);
    if (!y_(n, t))
      return y0e(e, n, t);
    const r = n[t];
    return e.finalized_ || !Kc(r) ? r : r === Fx(e.base_, t) ? (zx(e), e.copy_[t] = x_(r, e)) : r;
  },
  has(e, t) {
    return t in rc(e);
  },
  ownKeys(e) {
    return Reflect.ownKeys(rc(e));
  },
  set(e, t, n) {
    const r = vJ(rc(e), t);
    if (r != null && r.set)
      return r.set.call(e.draft_, n), !0;
    if (!e.modified_) {
      const o = Fx(rc(e), t), i = o == null ? void 0 : o[Ts];
      if (i && i.base_ === n)
        return e.copy_[t] = n, e.assigned_[t] = !1, !0;
      if (d0e(n, o) && (n !== void 0 || y_(e.base_, t)))
        return !0;
      zx(e), O_(e);
    }
    return e.copy_[t] === n && // special case: handle new props with value 'undefined'
    (n !== void 0 || t in e.copy_) || // special case: NaN
    Number.isNaN(n) && Number.isNaN(e.copy_[t]) || (e.copy_[t] = n, e.assigned_[t] = !0), !0;
  },
  deleteProperty(e, t) {
    return Fx(e.base_, t) !== void 0 || t in e.base_ ? (e.assigned_[t] = !1, zx(e), O_(e)) : delete e.assigned_[t], e.copy_ && delete e.copy_[t], !0;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(e, t) {
    const n = rc(e), r = Reflect.getOwnPropertyDescriptor(n, t);
    return r && {
      writable: !0,
      configurable: e.type_ !== 1 || t !== "length",
      enumerable: r.enumerable,
      value: n[t]
    };
  },
  defineProperty() {
    Gi(11);
  },
  getPrototypeOf(e) {
    return _p(e.base_);
  },
  setPrototypeOf() {
    Gi(12);
  }
}, xh = {};
Ob(eD, (e, t) => {
  xh[e] = function() {
    return arguments[0] = arguments[0][0], t.apply(this, arguments);
  };
});
xh.deleteProperty = function(e, t) {
  return process.env.NODE_ENV !== "production" && isNaN(parseInt(t)) && Gi(13), xh.set.call(this, e, t, void 0);
};
xh.set = function(e, t, n) {
  return process.env.NODE_ENV !== "production" && t !== "length" && isNaN(parseInt(t)) && Gi(14), eD.set.call(this, e[0], t, n, e[0]);
};
function Fx(e, t) {
  const n = e[Ts];
  return (n ? rc(n) : e)[t];
}
function y0e(e, t, n) {
  var r;
  const o = vJ(t, n);
  return o ? "value" in o ? o.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (r = o.get) == null ? void 0 : r.call(e.draft_)
  ) : void 0;
}
function vJ(e, t) {
  if (!(t in e))
    return;
  let n = _p(e);
  for (; n; ) {
    const r = Object.getOwnPropertyDescriptor(n, t);
    if (r)
      return r;
    n = _p(n);
  }
}
function O_(e) {
  e.modified_ || (e.modified_ = !0, e.parent_ && O_(e.parent_));
}
function zx(e) {
  e.copy_ || (e.copy_ = b_(
    e.base_,
    e.scope_.immer_.useStrictShallowCopy_
  ));
}
var b0e = class {
  constructor(e) {
    this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.produce = (t, n, r) => {
      if (typeof t == "function" && typeof n != "function") {
        const i = n;
        n = t;
        const a = this;
        return function(s = i, ...l) {
          return a.produce(s, (u) => n.call(this, u, ...l));
        };
      }
      typeof n != "function" && Gi(6), r !== void 0 && typeof r != "function" && Gi(7);
      let o;
      if (Kc(t)) {
        const i = NB(this), a = x_(t, void 0);
        let s = !0;
        try {
          o = n(a), s = !1;
        } finally {
          s ? w_(i) : C_(i);
        }
        return IB(i, r), BB(o, i);
      } else if (!t || typeof t != "object") {
        if (o = n(t), o === void 0 && (o = t), o === fJ && (o = void 0), this.autoFreeze_ && QM(o, !0), r) {
          const i = [], a = [];
          Xc("Patches").generateReplacementPatches_(t, o, i, a), r(i, a);
        }
        return o;
      } else
        Gi(1, t);
    }, this.produceWithPatches = (t, n) => {
      if (typeof t == "function")
        return (i, ...a) => this.produceWithPatches(i, (s) => t(s, ...a));
      let r, o;
      return [this.produce(t, n, (i, a) => {
        r = i, o = a;
      }), r, o];
    }, typeof (e == null ? void 0 : e.autoFreeze) == "boolean" && this.setAutoFreeze(e.autoFreeze), typeof (e == null ? void 0 : e.useStrictShallowCopy) == "boolean" && this.setUseStrictShallowCopy(e.useStrictShallowCopy);
  }
  createDraft(e) {
    Kc(e) || Gi(8), Gc(e) && (e = w0e(e));
    const t = NB(this), n = x_(e, void 0);
    return n[Ts].isManual_ = !0, C_(t), n;
  }
  finishDraft(e, t) {
    const n = e && e[Ts];
    (!n || !n.isManual_) && Gi(9);
    const { scope_: r } = n;
    return IB(r, t), BB(void 0, r);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(e) {
    this.autoFreeze_ = e;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(e) {
    this.useStrictShallowCopy_ = e;
  }
  applyPatches(e, t) {
    let n;
    for (n = t.length - 1; n >= 0; n--) {
      const o = t[n];
      if (o.path.length === 0 && o.op === "replace") {
        e = o.value;
        break;
      }
    }
    n > -1 && (t = t.slice(n + 1));
    const r = Xc("Patches").applyPatches_;
    return Gc(e) ? r(e, t) : this.produce(
      e,
      (o) => r(o, t)
    );
  }
};
function x_(e, t) {
  const n = AC(e) ? Xc("MapSet").proxyMap_(e, t) : RC(e) ? Xc("MapSet").proxySet_(e, t) : v0e(e, t);
  return (t ? t.scope_ : mJ()).drafts_.push(n), n;
}
function w0e(e) {
  return Gc(e) || Gi(10, e), yJ(e);
}
function yJ(e) {
  if (!Kc(e) || IC(e))
    return e;
  const t = e[Ts];
  let n;
  if (t) {
    if (!t.modified_)
      return t.base_;
    t.finalized_ = !0, n = b_(e, t.scope_.immer_.useStrictShallowCopy_);
  } else
    n = b_(e, !0);
  return Ob(n, (r, o) => {
    gJ(n, r, yJ(o));
  }), t && (t.finalized_ = !1), n;
}
var js = new b0e(), tD = js.produce;
js.produceWithPatches.bind(
  js
);
js.setAutoFreeze.bind(js);
js.setUseStrictShallowCopy.bind(js);
js.applyPatches.bind(js);
var zB = js.createDraft.bind(js), UB = js.finishDraft.bind(js), Je = {
  ancestors(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = Je.levels(e, t);
    return n ? r = r.slice(1) : r = r.slice(0, -1), r;
  },
  common(e, t) {
    for (var n = [], r = 0; r < e.length && r < t.length; r++) {
      var o = e[r], i = t[r];
      if (o !== i)
        break;
      n.push(o);
    }
    return n;
  },
  compare(e, t) {
    for (var n = Math.min(e.length, t.length), r = 0; r < n; r++) {
      if (e[r] < t[r]) return -1;
      if (e[r] > t[r]) return 1;
    }
    return 0;
  },
  endsAfter(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return Je.equals(r, o) && i > a;
  },
  endsAt(e, t) {
    var n = e.length, r = e.slice(0, n), o = t.slice(0, n);
    return Je.equals(r, o);
  },
  endsBefore(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return Je.equals(r, o) && i < a;
  },
  equals(e, t) {
    return e.length === t.length && e.every((n, r) => n === t[r]);
  },
  hasPrevious(e) {
    return e[e.length - 1] > 0;
  },
  isAfter(e, t) {
    return Je.compare(e, t) === 1;
  },
  isAncestor(e, t) {
    return e.length < t.length && Je.compare(e, t) === 0;
  },
  isBefore(e, t) {
    return Je.compare(e, t) === -1;
  },
  isChild(e, t) {
    return e.length === t.length + 1 && Je.compare(e, t) === 0;
  },
  isCommon(e, t) {
    return e.length <= t.length && Je.compare(e, t) === 0;
  },
  isDescendant(e, t) {
    return e.length > t.length && Je.compare(e, t) === 0;
  },
  isParent(e, t) {
    return e.length + 1 === t.length && Je.compare(e, t) === 0;
  },
  isPath(e) {
    return Array.isArray(e) && (e.length === 0 || typeof e[0] == "number");
  },
  isSibling(e, t) {
    if (e.length !== t.length)
      return !1;
    var n = e.slice(0, -1), r = t.slice(0, -1), o = e[e.length - 1], i = t[t.length - 1];
    return o !== i && Je.equals(n, r);
  },
  levels(e) {
    for (var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = [], o = 0; o <= e.length; o++)
      r.push(e.slice(0, o));
    return n && r.reverse(), r;
  },
  next(e) {
    if (e.length === 0)
      throw new Error("Cannot get the next path of a root path [".concat(e, "], because it has no next index."));
    var t = e[e.length - 1];
    return e.slice(0, -1).concat(t + 1);
  },
  operationCanTransformPath(e) {
    switch (e.type) {
      case "insert_node":
      case "remove_node":
      case "merge_node":
      case "split_node":
      case "move_node":
        return !0;
      default:
        return !1;
    }
  },
  parent(e) {
    if (e.length === 0)
      throw new Error("Cannot get the parent path of the root path [".concat(e, "]."));
    return e.slice(0, -1);
  },
  previous(e) {
    if (e.length === 0)
      throw new Error("Cannot get the previous path of a root path [".concat(e, "], because it has no previous index."));
    var t = e[e.length - 1];
    if (t <= 0)
      throw new Error("Cannot get the previous path of a first child path [".concat(e, "] because it would result in a negative index."));
    return e.slice(0, -1).concat(t - 1);
  },
  relative(e, t) {
    if (!Je.isAncestor(t, e) && !Je.equals(e, t))
      throw new Error("Cannot get the relative path of [".concat(e, "] inside ancestor [").concat(t, "], because it is not above or equal to the path."));
    return e.slice(t.length);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!e) return null;
    var r = [...e], {
      affinity: o = "forward"
    } = n;
    if (e.length === 0)
      return r;
    switch (t.type) {
      case "insert_node": {
        var {
          path: i
        } = t;
        (Je.equals(i, r) || Je.endsBefore(i, r) || Je.isAncestor(i, r)) && (r[i.length - 1] += 1);
        break;
      }
      case "remove_node": {
        var {
          path: a
        } = t;
        if (Je.equals(a, r) || Je.isAncestor(a, r))
          return null;
        Je.endsBefore(a, r) && (r[a.length - 1] -= 1);
        break;
      }
      case "merge_node": {
        var {
          path: s,
          position: l
        } = t;
        Je.equals(s, r) || Je.endsBefore(s, r) ? r[s.length - 1] -= 1 : Je.isAncestor(s, r) && (r[s.length - 1] -= 1, r[s.length] += l);
        break;
      }
      case "split_node": {
        var {
          path: u,
          position: c
        } = t;
        if (Je.equals(u, r)) {
          if (o === "forward")
            r[r.length - 1] += 1;
          else if (o !== "backward") return null;
        } else Je.endsBefore(u, r) ? r[u.length - 1] += 1 : Je.isAncestor(u, r) && e[u.length] >= c && (r[u.length - 1] += 1, r[u.length] -= c);
        break;
      }
      case "move_node": {
        var {
          path: p,
          newPath: d
        } = t;
        if (Je.equals(p, d))
          return r;
        if (Je.isAncestor(p, r) || Je.equals(p, r)) {
          var g = d.slice();
          return Je.endsBefore(p, d) && p.length < d.length && (g[p.length - 1] -= 1), g.concat(r.slice(p.length));
        } else Je.isSibling(p, d) && (Je.isAncestor(d, r) || Je.equals(d, r)) ? Je.endsBefore(p, r) ? r[p.length - 1] -= 1 : r[p.length - 1] += 1 : Je.endsBefore(d, r) || Je.equals(d, r) || Je.isAncestor(d, r) ? (Je.endsBefore(p, r) && (r[p.length - 1] -= 1), r[d.length - 1] += 1) : Je.endsBefore(p, r) && (Je.equals(d, r) && (r[d.length - 1] += 1), r[p.length - 1] -= 1);
        break;
      }
    }
    return r;
  }
};
function Eh(e) {
  "@babel/helpers - typeof";
  return Eh = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Eh(e);
}
function C0e(e, t) {
  if (Eh(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (Eh(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function O0e(e) {
  var t = C0e(e, "string");
  return Eh(t) === "symbol" ? t : String(t);
}
function Np(e, t, n) {
  return t = O0e(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function HB(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function md(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? HB(Object(n), !0).forEach(function(r) {
      Np(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : HB(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var x0e = (e, t, n) => {
  switch (n.type) {
    case "insert_node": {
      var {
        path: r,
        node: o
      } = n, i = jt.parent(e, r), a = r[r.length - 1];
      if (a > i.children.length)
        throw new Error('Cannot apply an "insert_node" operation at path ['.concat(r, "] because the destination is past the end of the node."));
      if (i.children.splice(a, 0, o), t)
        for (var [s, l] of Yt.points(t))
          t[l] = Rr.transform(s, n);
      break;
    }
    case "insert_text": {
      var {
        path: u,
        offset: c,
        text: p
      } = n;
      if (p.length === 0) break;
      var d = jt.leaf(e, u), g = d.text.slice(0, c), f = d.text.slice(c);
      if (d.text = g + p + f, t)
        for (var [m, b] of Yt.points(t))
          t[b] = Rr.transform(m, n);
      break;
    }
    case "merge_node": {
      var {
        path: E
      } = n, w = jt.get(e, E), M = Je.previous(E), x = jt.get(e, M), v = jt.parent(e, E), C = E[E.length - 1];
      if (To.isText(w) && To.isText(x))
        x.text += w.text;
      else if (!To.isText(w) && !To.isText(x))
        x.children.push(...w.children);
      else
        throw new Error('Cannot apply a "merge_node" operation at path ['.concat(E, "] to nodes of different interfaces: ").concat(us.stringify(w), " ").concat(us.stringify(x)));
      if (v.children.splice(C, 1), t)
        for (var [P, F] of Yt.points(t))
          t[F] = Rr.transform(P, n);
      break;
    }
    case "move_node": {
      var {
        path: L,
        newPath: B
      } = n;
      if (Je.isAncestor(L, B))
        throw new Error("Cannot move a path [".concat(L, "] to new path [").concat(B, "] because the destination is inside itself."));
      var N = jt.get(e, L), $ = jt.parent(e, L), V = L[L.length - 1];
      $.children.splice(V, 1);
      var H = Je.transform(L, n), Z = jt.get(e, Je.parent(H)), K = H[H.length - 1];
      if (Z.children.splice(K, 0, N), t)
        for (var [Y, Q] of Yt.points(t))
          t[Q] = Rr.transform(Y, n);
      break;
    }
    case "remove_node": {
      var {
        path: J
      } = n, _ = J[J.length - 1], D = jt.parent(e, J);
      if (D.children.splice(_, 1), t)
        for (var [z, S] of Yt.points(t)) {
          var W = Rr.transform(z, n);
          if (t != null && W != null)
            t[S] = W;
          else {
            var O = void 0, j = void 0;
            for (var [U, T] of jt.texts(e))
              if (Je.compare(T, J) === -1)
                O = [U, T];
              else {
                j = [U, T];
                break;
              }
            var q = !1;
            O && j && (Je.equals(j[1], J) ? q = !Je.hasPrevious(j[1]) : q = Je.common(O[1], J).length < Je.common(j[1], J).length), O && !q ? (z.path = O[1], z.offset = O[0].text.length) : j ? (z.path = j[1], z.offset = 0) : t = null;
          }
        }
      break;
    }
    case "remove_text": {
      var {
        path: A,
        offset: X,
        text: I
      } = n;
      if (I.length === 0) break;
      var le = jt.leaf(e, A), he = le.text.slice(0, X), oe = le.text.slice(X + I.length);
      if (le.text = he + oe, t)
        for (var [Ae, Ue] of Yt.points(t))
          t[Ue] = Rr.transform(Ae, n);
      break;
    }
    case "set_node": {
      var {
        path: He,
        properties: Re,
        newProperties: nt
      } = n;
      if (He.length === 0)
        throw new Error("Cannot set properties on the root node!");
      var Ve = jt.get(e, He);
      for (var we in nt) {
        if (we === "children" || we === "text")
          throw new Error('Cannot set the "'.concat(we, '" property of nodes!'));
        var et = nt[we];
        et == null ? delete Ve[we] : Ve[we] = et;
      }
      for (var lt in Re)
        nt.hasOwnProperty(lt) || delete Ve[lt];
      break;
    }
    case "set_selection": {
      var {
        newProperties: ye
      } = n;
      if (ye == null)
        t = ye;
      else {
        if (t == null) {
          if (!Yt.isRange(ye))
            throw new Error('Cannot apply an incomplete "set_selection" operation properties '.concat(us.stringify(ye), " when there is no current selection."));
          t = md({}, ye);
        }
        for (var ke in ye) {
          var Qe = ye[ke];
          if (Qe == null) {
            if (ke === "anchor" || ke === "focus")
              throw new Error('Cannot remove the "'.concat(ke, '" selection property'));
            delete t[ke];
          } else
            t[ke] = Qe;
        }
      }
      break;
    }
    case "split_node": {
      var {
        path: Fe,
        position: Ie,
        properties: ot
      } = n;
      if (Fe.length === 0)
        throw new Error('Cannot apply a "split_node" operation at path ['.concat(Fe, "] because the root node cannot be split."));
      var Ee = jt.get(e, Fe), wt = jt.parent(e, Fe), it = Fe[Fe.length - 1], st;
      if (To.isText(Ee)) {
        var ut = Ee.text.slice(0, Ie), Ct = Ee.text.slice(Ie);
        Ee.text = ut, st = md(md({}, ot), {}, {
          text: Ct
        });
      } else {
        var ct = Ee.children.slice(0, Ie), pt = Ee.children.slice(Ie);
        Ee.children = ct, st = md(md({}, ot), {}, {
          children: pt
        });
      }
      if (wt.children.splice(it + 1, 0, st), t)
        for (var [rt, We] of Yt.points(t))
          t[We] = Rr.transform(rt, n);
      break;
    }
  }
  return t;
}, E0e = {
  transform(e, t) {
    e.children = zB(e.children);
    var n = e.selection && zB(e.selection);
    try {
      n = x0e(e, n, t);
    } finally {
      e.children = UB(e.children), n ? e.selection = Gc(n) ? UB(n) : n : e.selection = null;
    }
  }
}, k0e = {
  insertNodes(e, t, n) {
    e.insertNodes(t, n);
  },
  liftNodes(e, t) {
    e.liftNodes(t);
  },
  mergeNodes(e, t) {
    e.mergeNodes(t);
  },
  moveNodes(e, t) {
    e.moveNodes(t);
  },
  removeNodes(e, t) {
    e.removeNodes(t);
  },
  setNodes(e, t, n) {
    e.setNodes(t, n);
  },
  splitNodes(e, t) {
    e.splitNodes(t);
  },
  unsetNodes(e, t, n) {
    e.unsetNodes(t, n);
  },
  unwrapNodes(e, t) {
    e.unwrapNodes(t);
  },
  wrapNodes(e, t, n) {
    e.wrapNodes(t, n);
  }
}, L0e = {
  collapse(e, t) {
    e.collapse(t);
  },
  deselect(e) {
    e.deselect();
  },
  move(e, t) {
    e.move(t);
  },
  select(e, t) {
    e.select(t);
  },
  setPoint(e, t, n) {
    e.setPoint(t, n);
  },
  setSelection(e, t) {
    e.setSelection(t);
  }
}, bJ = (e, t) => {
  for (var n in e) {
    var r = e[n], o = t[n];
    if (vi(r) && vi(o)) {
      if (!bJ(r, o)) return !1;
    } else if (Array.isArray(r) && Array.isArray(o)) {
      if (r.length !== o.length) return !1;
      for (var i = 0; i < r.length; i++)
        if (r[i] !== o[i]) return !1;
    } else if (r !== o)
      return !1;
  }
  for (var a in t)
    if (e[a] === void 0 && t[a] !== void 0)
      return !1;
  return !0;
};
function _0e(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), o, i;
  for (i = 0; i < r.length; i++)
    o = r[i], !(t.indexOf(o) >= 0) && (n[o] = e[o]);
  return n;
}
function kh(e, t) {
  if (e == null) return {};
  var n = _0e(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (o = 0; o < i.length; o++)
      r = i[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
var P0e = ["anchor", "focus"];
function WB(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function S0e(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? WB(Object(n), !0).forEach(function(r) {
      Np(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : WB(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Yt = {
  edges(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, {
      anchor: r,
      focus: o
    } = e;
    return Yt.isBackward(e) === n ? [r, o] : [o, r];
  },
  end(e) {
    var [, t] = Yt.edges(e);
    return t;
  },
  equals(e, t) {
    return Rr.equals(e.anchor, t.anchor) && Rr.equals(e.focus, t.focus);
  },
  includes(e, t) {
    if (Yt.isRange(t)) {
      if (Yt.includes(e, t.anchor) || Yt.includes(e, t.focus))
        return !0;
      var [n, r] = Yt.edges(e), [o, i] = Yt.edges(t);
      return Rr.isBefore(n, o) && Rr.isAfter(r, i);
    }
    var [a, s] = Yt.edges(e), l = !1, u = !1;
    return Rr.isPoint(t) ? (l = Rr.compare(t, a) >= 0, u = Rr.compare(t, s) <= 0) : (l = Je.compare(t, a.path) >= 0, u = Je.compare(t, s.path) <= 0), l && u;
  },
  intersection(e, t) {
    var n = kh(e, P0e), [r, o] = Yt.edges(e), [i, a] = Yt.edges(t), s = Rr.isBefore(r, i) ? i : r, l = Rr.isBefore(o, a) ? o : a;
    return Rr.isBefore(l, s) ? null : S0e({
      anchor: s,
      focus: l
    }, n);
  },
  isBackward(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return Rr.isAfter(t, n);
  },
  isCollapsed(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return Rr.equals(t, n);
  },
  isExpanded(e) {
    return !Yt.isCollapsed(e);
  },
  isForward(e) {
    return !Yt.isBackward(e);
  },
  isRange(e) {
    return vi(e) && Rr.isPoint(e.anchor) && Rr.isPoint(e.focus);
  },
  *points(e) {
    yield [e.anchor, "anchor"], yield [e.focus, "focus"];
  },
  start(e) {
    var [t] = Yt.edges(e);
    return t;
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return tD(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "inward"
      } = n, i, a;
      if (o === "inward") {
        var s = Yt.isCollapsed(r);
        Yt.isForward(r) ? (i = "forward", a = s ? i : "backward") : (i = "backward", a = s ? i : "forward");
      } else o === "outward" ? Yt.isForward(r) ? (i = "backward", a = "forward") : (i = "forward", a = "backward") : (i = o, a = o);
      var l = Rr.transform(r.anchor, t, {
        affinity: i
      }), u = Rr.transform(r.focus, t, {
        affinity: a
      });
      if (!l || !u)
        return null;
      r.anchor = l, r.focus = u;
    });
  }
}, $B = (e) => vi(e) && jt.isNodeList(e.children) && !dr.isEditor(e), qa = {
  isAncestor(e) {
    return vi(e) && jt.isNodeList(e.children);
  },
  isElement: $B,
  isElementList(e) {
    return Array.isArray(e) && e.every((t) => qa.isElement(t));
  },
  isElementProps(e) {
    return e.children !== void 0;
  },
  isElementType: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "type";
    return $B(e) && e[n] === t;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "children" && e[n] !== t[n])
        return !1;
    return !0;
  }
}, M0e = ["children"], D0e = ["text"], VB = /* @__PURE__ */ new WeakMap(), jt = {
  ancestor(e, t) {
    var n = jt.get(e, t);
    if (To.isText(n))
      throw new Error("Cannot get the ancestor node at path [".concat(t, "] because it refers to a text node instead: ").concat(us.stringify(n)));
    return n;
  },
  ancestors(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of Je.ancestors(t, n)) {
        var o = jt.ancestor(e, r), i = [o, r];
        yield i;
      }
    }();
  },
  child(e, t) {
    if (To.isText(e))
      throw new Error("Cannot get the child of a text node: ".concat(us.stringify(e)));
    var n = e.children[t];
    if (n == null)
      throw new Error("Cannot get child at index `".concat(t, "` in node: ").concat(us.stringify(e)));
    return n;
  },
  children(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var {
        reverse: r = !1
      } = n, o = jt.ancestor(e, t), {
        children: i
      } = o, a = r ? i.length - 1 : 0; r ? a >= 0 : a < i.length; ) {
        var s = jt.child(o, a), l = t.concat(a);
        yield [s, l], a = r ? a - 1 : a + 1;
      }
    }();
  },
  common(e, t, n) {
    var r = Je.common(t, n), o = jt.get(e, r);
    return [o, r];
  },
  descendant(e, t) {
    var n = jt.get(e, t);
    if (dr.isEditor(n))
      throw new Error("Cannot get the descendant node at path [".concat(t, "] because it refers to the root editor node instead: ").concat(us.stringify(n)));
    return n;
  },
  descendants(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of jt.nodes(e, t))
        r.length !== 0 && (yield [n, r]);
    }();
  },
  elements(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of jt.nodes(e, t))
        qa.isElement(n) && (yield [n, r]);
    }();
  },
  extractProps(e) {
    if (qa.isAncestor(e)) {
      var t = kh(e, M0e);
      return t;
    } else {
      var t = kh(e, D0e);
      return t;
    }
  },
  first(e, t) {
    for (var n = t.slice(), r = jt.get(e, n); r && !(To.isText(r) || r.children.length === 0); )
      r = r.children[0], n.push(0);
    return [r, n];
  },
  fragment(e, t) {
    if (To.isText(e))
      throw new Error("Cannot get a fragment starting from a root text node: ".concat(us.stringify(e)));
    var n = tD({
      children: e.children
    }, (r) => {
      var [o, i] = Yt.edges(t), a = jt.nodes(r, {
        reverse: !0,
        pass: (d) => {
          var [, g] = d;
          return !Yt.includes(t, g);
        }
      });
      for (var [, s] of a) {
        if (!Yt.includes(t, s)) {
          var l = jt.parent(r, s), u = s[s.length - 1];
          l.children.splice(u, 1);
        }
        if (Je.equals(s, i.path)) {
          var c = jt.leaf(r, s);
          c.text = c.text.slice(0, i.offset);
        }
        if (Je.equals(s, o.path)) {
          var p = jt.leaf(r, s);
          p.text = p.text.slice(o.offset);
        }
      }
      dr.isEditor(r) && (r.selection = null);
    });
    return n.children;
  },
  get(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (To.isText(n) || !n.children[o])
        throw new Error("Cannot find a descendant at path [".concat(t, "] in node: ").concat(us.stringify(e)));
      n = n.children[o];
    }
    return n;
  },
  has(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (To.isText(n) || !n.children[o])
        return !1;
      n = n.children[o];
    }
    return !0;
  },
  isNode(e) {
    return To.isText(e) || qa.isElement(e) || dr.isEditor(e);
  },
  isNodeList(e) {
    if (!Array.isArray(e))
      return !1;
    var t = VB.get(e);
    if (t !== void 0)
      return t;
    var n = e.every((r) => jt.isNode(r));
    return VB.set(e, n), n;
  },
  last(e, t) {
    for (var n = t.slice(), r = jt.get(e, n); r && !(To.isText(r) || r.children.length === 0); ) {
      var o = r.children.length - 1;
      r = r.children[o], n.push(o);
    }
    return [r, n];
  },
  leaf(e, t) {
    var n = jt.get(e, t);
    if (!To.isText(n))
      throw new Error("Cannot get the leaf node at path [".concat(t, "] because it refers to a non-leaf node: ").concat(us.stringify(n)));
    return n;
  },
  levels(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of Je.levels(t, n)) {
        var o = jt.get(e, r);
        yield [o, r];
      }
    }();
  },
  matches(e, t) {
    return qa.isElement(e) && qa.isElementProps(t) && qa.matches(e, t) || To.isText(e) && To.isTextProps(t) && To.matches(e, t);
  },
  nodes(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var {
        pass: n,
        reverse: r = !1
      } = t, {
        from: o = [],
        to: i
      } = t, a = /* @__PURE__ */ new Set(), s = [], l = e; !(i && (r ? Je.isBefore(s, i) : Je.isAfter(s, i))); ) {
        if (a.has(l) || (yield [l, s]), !a.has(l) && !To.isText(l) && l.children.length !== 0 && (n == null || n([l, s]) === !1)) {
          a.add(l);
          var u = r ? l.children.length - 1 : 0;
          Je.isAncestor(s, o) && (u = o[s.length]), s = s.concat(u), l = jt.get(e, s);
          continue;
        }
        if (s.length === 0)
          break;
        if (!r) {
          var c = Je.next(s);
          if (jt.has(e, c)) {
            s = c, l = jt.get(e, s);
            continue;
          }
        }
        if (r && s[s.length - 1] !== 0) {
          var p = Je.previous(s);
          s = p, l = jt.get(e, s);
          continue;
        }
        s = Je.parent(s), l = jt.get(e, s), a.add(l);
      }
    }();
  },
  parent(e, t) {
    var n = Je.parent(t), r = jt.get(e, n);
    if (To.isText(r))
      throw new Error("Cannot get the parent of path [".concat(t, "] because it does not exist in the root."));
    return r;
  },
  string(e) {
    return To.isText(e) ? e.text : e.children.map(jt.string).join("");
  },
  texts(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of jt.nodes(e, t))
        To.isText(n) && (yield [n, r]);
    }();
  }
};
function ZB(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Wr(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? ZB(Object(n), !0).forEach(function(r) {
      Np(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : ZB(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var nf = {
  isNodeOperation(e) {
    return nf.isOperation(e) && e.type.endsWith("_node");
  },
  isOperation(e) {
    if (!vi(e))
      return !1;
    switch (e.type) {
      case "insert_node":
        return Je.isPath(e.path) && jt.isNode(e.node);
      case "insert_text":
        return typeof e.offset == "number" && typeof e.text == "string" && Je.isPath(e.path);
      case "merge_node":
        return typeof e.position == "number" && Je.isPath(e.path) && vi(e.properties);
      case "move_node":
        return Je.isPath(e.path) && Je.isPath(e.newPath);
      case "remove_node":
        return Je.isPath(e.path) && jt.isNode(e.node);
      case "remove_text":
        return typeof e.offset == "number" && typeof e.text == "string" && Je.isPath(e.path);
      case "set_node":
        return Je.isPath(e.path) && vi(e.properties) && vi(e.newProperties);
      case "set_selection":
        return e.properties === null && Yt.isRange(e.newProperties) || e.newProperties === null && Yt.isRange(e.properties) || vi(e.properties) && vi(e.newProperties);
      case "split_node":
        return Je.isPath(e.path) && typeof e.position == "number" && vi(e.properties);
      default:
        return !1;
    }
  },
  isOperationList(e) {
    return Array.isArray(e) && e.every((t) => nf.isOperation(t));
  },
  isSelectionOperation(e) {
    return nf.isOperation(e) && e.type.endsWith("_selection");
  },
  isTextOperation(e) {
    return nf.isOperation(e) && e.type.endsWith("_text");
  },
  inverse(e) {
    switch (e.type) {
      case "insert_node":
        return Wr(Wr({}, e), {}, {
          type: "remove_node"
        });
      case "insert_text":
        return Wr(Wr({}, e), {}, {
          type: "remove_text"
        });
      case "merge_node":
        return Wr(Wr({}, e), {}, {
          type: "split_node",
          path: Je.previous(e.path)
        });
      case "move_node": {
        var {
          newPath: t,
          path: n
        } = e;
        if (Je.equals(t, n))
          return e;
        if (Je.isSibling(n, t))
          return Wr(Wr({}, e), {}, {
            path: t,
            newPath: n
          });
        var r = Je.transform(n, e), o = Je.transform(Je.next(n), e);
        return Wr(Wr({}, e), {}, {
          path: r,
          newPath: o
        });
      }
      case "remove_node":
        return Wr(Wr({}, e), {}, {
          type: "insert_node"
        });
      case "remove_text":
        return Wr(Wr({}, e), {}, {
          type: "insert_text"
        });
      case "set_node": {
        var {
          properties: i,
          newProperties: a
        } = e;
        return Wr(Wr({}, e), {}, {
          properties: a,
          newProperties: i
        });
      }
      case "set_selection": {
        var {
          properties: s,
          newProperties: l
        } = e;
        return s == null ? Wr(Wr({}, e), {}, {
          properties: l,
          newProperties: null
        }) : l == null ? Wr(Wr({}, e), {}, {
          properties: null,
          newProperties: s
        }) : Wr(Wr({}, e), {}, {
          properties: l,
          newProperties: s
        });
      }
      case "split_node":
        return Wr(Wr({}, e), {}, {
          type: "merge_node",
          path: Je.next(e.path)
        });
    }
  }
}, qB = /* @__PURE__ */ new WeakMap(), T0e = (e) => {
  var t = qB.get(e);
  if (t !== void 0)
    return t;
  if (!vi(e))
    return !1;
  var n = typeof e.addMark == "function" && typeof e.apply == "function" && typeof e.deleteFragment == "function" && typeof e.insertBreak == "function" && typeof e.insertSoftBreak == "function" && typeof e.insertFragment == "function" && typeof e.insertNode == "function" && typeof e.insertText == "function" && typeof e.isElementReadOnly == "function" && typeof e.isInline == "function" && typeof e.isSelectable == "function" && typeof e.isVoid == "function" && typeof e.normalizeNode == "function" && typeof e.onChange == "function" && typeof e.removeMark == "function" && typeof e.getDirtyPaths == "function" && (e.marks === null || vi(e.marks)) && (e.selection === null || Yt.isRange(e.selection)) && jt.isNodeList(e.children) && nf.isOperationList(e.operations);
  return qB.set(e, n), n;
}, dr = {
  above(e, t) {
    return e.above(t);
  },
  addMark(e, t, n) {
    e.addMark(t, n);
  },
  after(e, t, n) {
    return e.after(t, n);
  },
  before(e, t, n) {
    return e.before(t, n);
  },
  deleteBackward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteBackward(n);
  },
  deleteForward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteForward(n);
  },
  deleteFragment(e, t) {
    e.deleteFragment(t);
  },
  edges(e, t) {
    return e.edges(t);
  },
  elementReadOnly(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return e.elementReadOnly(t);
  },
  end(e, t) {
    return e.end(t);
  },
  first(e, t) {
    return e.first(t);
  },
  fragment(e, t) {
    return e.fragment(t);
  },
  hasBlocks(e, t) {
    return e.hasBlocks(t);
  },
  hasInlines(e, t) {
    return e.hasInlines(t);
  },
  hasPath(e, t) {
    return e.hasPath(t);
  },
  hasTexts(e, t) {
    return e.hasTexts(t);
  },
  insertBreak(e) {
    e.insertBreak();
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertNode(e, t) {
    e.insertNode(t);
  },
  insertSoftBreak(e) {
    e.insertSoftBreak();
  },
  insertText(e, t) {
    e.insertText(t);
  },
  isBlock(e, t) {
    return e.isBlock(t);
  },
  isEdge(e, t, n) {
    return e.isEdge(t, n);
  },
  isEditor(e) {
    return T0e(e);
  },
  isElementReadOnly(e, t) {
    return e.isElementReadOnly(t);
  },
  isEmpty(e, t) {
    return e.isEmpty(t);
  },
  isEnd(e, t, n) {
    return e.isEnd(t, n);
  },
  isInline(e, t) {
    return e.isInline(t);
  },
  isNormalizing(e) {
    return e.isNormalizing();
  },
  isSelectable(e, t) {
    return e.isSelectable(t);
  },
  isStart(e, t, n) {
    return e.isStart(t, n);
  },
  isVoid(e, t) {
    return e.isVoid(t);
  },
  last(e, t) {
    return e.last(t);
  },
  leaf(e, t, n) {
    return e.leaf(t, n);
  },
  levels(e, t) {
    return e.levels(t);
  },
  marks(e) {
    return e.getMarks();
  },
  next(e, t) {
    return e.next(t);
  },
  node(e, t, n) {
    return e.node(t, n);
  },
  nodes(e, t) {
    return e.nodes(t);
  },
  normalize(e, t) {
    e.normalize(t);
  },
  parent(e, t, n) {
    return e.parent(t, n);
  },
  path(e, t, n) {
    return e.path(t, n);
  },
  pathRef(e, t, n) {
    return e.pathRef(t, n);
  },
  pathRefs(e) {
    return e.pathRefs();
  },
  point(e, t, n) {
    return e.point(t, n);
  },
  pointRef(e, t, n) {
    return e.pointRef(t, n);
  },
  pointRefs(e) {
    return e.pointRefs();
  },
  positions(e, t) {
    return e.positions(t);
  },
  previous(e, t) {
    return e.previous(t);
  },
  range(e, t, n) {
    return e.range(t, n);
  },
  rangeRef(e, t, n) {
    return e.rangeRef(t, n);
  },
  rangeRefs(e) {
    return e.rangeRefs();
  },
  removeMark(e, t) {
    e.removeMark(t);
  },
  setNormalizing(e, t) {
    e.setNormalizing(t);
  },
  start(e, t) {
    return e.start(t);
  },
  string(e, t, n) {
    return e.string(t, n);
  },
  unhangRange(e, t, n) {
    return e.unhangRange(t, n);
  },
  void(e, t) {
    return e.void(t);
  },
  withoutNormalizing(e, t) {
    e.withoutNormalizing(t);
  },
  shouldMergeNodesRemovePrevNode: (e, t, n) => e.shouldMergeNodesRemovePrevNode(t, n)
};
function GB(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function KB(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? GB(Object(n), !0).forEach(function(r) {
      Np(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : GB(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Rr = {
  compare(e, t) {
    var n = Je.compare(e.path, t.path);
    return n === 0 ? e.offset < t.offset ? -1 : e.offset > t.offset ? 1 : 0 : n;
  },
  isAfter(e, t) {
    return Rr.compare(e, t) === 1;
  },
  isBefore(e, t) {
    return Rr.compare(e, t) === -1;
  },
  equals(e, t) {
    return e.offset === t.offset && Je.equals(e.path, t.path);
  },
  isPoint(e) {
    return vi(e) && typeof e.offset == "number" && Je.isPath(e.path);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return tD(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "forward"
      } = n, {
        path: i,
        offset: a
      } = r;
      switch (t.type) {
        case "insert_node":
        case "move_node": {
          r.path = Je.transform(i, t, n);
          break;
        }
        case "insert_text": {
          Je.equals(t.path, i) && (t.offset < a || t.offset === a && o === "forward") && (r.offset += t.text.length);
          break;
        }
        case "merge_node": {
          Je.equals(t.path, i) && (r.offset += t.position), r.path = Je.transform(i, t, n);
          break;
        }
        case "remove_text": {
          Je.equals(t.path, i) && t.offset <= a && (r.offset -= Math.min(a - t.offset, t.text.length));
          break;
        }
        case "remove_node": {
          if (Je.equals(t.path, i) || Je.isAncestor(t.path, i))
            return null;
          r.path = Je.transform(i, t, n);
          break;
        }
        case "split_node": {
          if (Je.equals(t.path, i)) {
            if (t.position === a && o == null)
              return null;
            (t.position < a || t.position === a && o === "forward") && (r.offset -= t.position, r.path = Je.transform(i, t, KB(KB({}, n), {}, {
              affinity: "forward"
            })));
          } else
            r.path = Je.transform(i, t, n);
          break;
        }
      }
    });
  }
}, XB = void 0, us = {
  setScrubber(e) {
    XB = e;
  },
  stringify(e) {
    return JSON.stringify(e, XB);
  }
}, j0e = ["text"], A0e = ["anchor", "focus"];
function YB(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Ta(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? YB(Object(n), !0).forEach(function(r) {
      Np(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : YB(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var To = {
  equals(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      loose: r = !1
    } = n;
    function o(i) {
      var a = kh(i, j0e);
      return a;
    }
    return bJ(r ? o(e) : e, r ? o(t) : t);
  },
  isText(e) {
    return vi(e) && typeof e.text == "string";
  },
  isTextList(e) {
    return Array.isArray(e) && e.every((t) => To.isText(t));
  },
  isTextProps(e) {
    return e.text !== void 0;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "text" && (!e.hasOwnProperty(n) || e[n] !== t[n]))
        return !1;
    return !0;
  },
  decorations(e, t) {
    var n = [Ta({}, e)];
    for (var r of t) {
      var o = kh(r, A0e), [i, a] = Yt.edges(r), s = [], l = 0, u = i.offset, c = a.offset;
      for (var p of n) {
        var {
          length: d
        } = p.text, g = l;
        if (l += d, u <= g && l <= c) {
          Object.assign(p, o), s.push(p);
          continue;
        }
        if (u !== c && (u === l || c === g) || u > l || c < g || c === g && g !== 0) {
          s.push(p);
          continue;
        }
        var f = p, m = void 0, b = void 0;
        if (c < l) {
          var E = c - g;
          b = Ta(Ta({}, f), {}, {
            text: f.text.slice(E)
          }), f = Ta(Ta({}, f), {}, {
            text: f.text.slice(0, E)
          });
        }
        if (u > g) {
          var w = u - g;
          m = Ta(Ta({}, f), {}, {
            text: f.text.slice(0, w)
          }), f = Ta(Ta({}, f), {}, {
            text: f.text.slice(w)
          });
        }
        Object.assign(f, o), m && s.push(m), s.push(f), b && s.push(b);
      }
      n = s;
    }
    return n;
  }
}, R0e = (e) => e.selection ? e.selection : e.children.length > 0 ? dr.end(e, []) : [0], Pr;
(function(e) {
  e[e.None = 0] = "None", e[e.Extend = 1] = "Extend", e[e.ZWJ = 2] = "ZWJ", e[e.RI = 4] = "RI", e[e.Prepend = 8] = "Prepend", e[e.SpacingMark = 16] = "SpacingMark", e[e.L = 32] = "L", e[e.V = 64] = "V", e[e.T = 128] = "T", e[e.LV = 256] = "LV", e[e.LVT = 512] = "LVT", e[e.ExtPict = 1024] = "ExtPict", e[e.Any = 2048] = "Any";
})(Pr || (Pr = {}));
Pr.L, Pr.L | Pr.V | Pr.LV | Pr.LVT, Pr.LV | Pr.V, Pr.V | Pr.T, Pr.LVT | Pr.T, Pr.T, Pr.Any, Pr.Extend | Pr.ZWJ, Pr.Any, Pr.SpacingMark, Pr.Prepend, Pr.Any, Pr.ZWJ, Pr.ExtPict, Pr.RI, Pr.RI;
var I0e = {
  delete(e, t) {
    e.delete(t);
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertText(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    dr.withoutNormalizing(e, () => {
      var {
        voids: r = !1
      } = n, {
        at: o = R0e(e)
      } = n;
      if (Je.isPath(o) && (o = dr.range(e, o)), Yt.isRange(o))
        if (Yt.isCollapsed(o))
          o = o.anchor;
        else {
          var i = Yt.end(o);
          if (!r && dr.void(e, {
            at: i
          }))
            return;
          var a = Yt.start(o), s = dr.pointRef(e, a), l = dr.pointRef(e, i);
          kb.delete(e, {
            at: o,
            voids: r
          });
          var u = s.unref(), c = l.unref();
          o = u || c, kb.setSelection(e, {
            anchor: o,
            focus: o
          });
        }
      if (!(!r && dr.void(e, {
        at: o
      }) || dr.elementReadOnly(e, {
        at: o
      }))) {
        var {
          path: p,
          offset: d
        } = o;
        t.length > 0 && e.apply({
          type: "insert_text",
          path: p,
          offset: d,
          text: t
        });
      }
    });
  }
};
function JB(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Fm(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? JB(Object(n), !0).forEach(function(r) {
      Np(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : JB(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var kb = Fm(Fm(Fm(Fm({}, E0e), k0e), L0e), I0e), wJ = {}, nD = {}, rD = {}, op = {}, oD = {}, iD = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Doctype = e.CDATA = e.Tag = e.Style = e.Script = e.Comment = e.Directive = e.Text = e.Root = e.isTag = e.ElementType = void 0;
  var t;
  (function(r) {
    r.Root = "root", r.Text = "text", r.Directive = "directive", r.Comment = "comment", r.Script = "script", r.Style = "style", r.Tag = "tag", r.CDATA = "cdata", r.Doctype = "doctype";
  })(t = e.ElementType || (e.ElementType = {}));
  function n(r) {
    return r.type === t.Tag || r.type === t.Script || r.type === t.Style;
  }
  e.isTag = n, e.Root = t.Root, e.Text = t.Text, e.Directive = t.Directive, e.Comment = t.Comment, e.Script = t.Script, e.Style = t.Style, e.Tag = t.Tag, e.CDATA = t.CDATA, e.Doctype = t.Doctype;
})(iD);
var an = {}, Ou = wr && wr.__extends || /* @__PURE__ */ function() {
  var e = function(t, n) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, o) {
      r.__proto__ = o;
    } || function(r, o) {
      for (var i in o) Object.prototype.hasOwnProperty.call(o, i) && (r[i] = o[i]);
    }, e(t, n);
  };
  return function(t, n) {
    if (typeof n != "function" && n !== null)
      throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
    e(t, n);
    function r() {
      this.constructor = t;
    }
    t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
  };
}(), wf = wr && wr.__assign || function() {
  return wf = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) {
      t = arguments[n];
      for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
    }
    return e;
  }, wf.apply(this, arguments);
};
Object.defineProperty(an, "__esModule", { value: !0 });
an.cloneNode = an.hasChildren = an.isDocument = an.isDirective = an.isComment = an.isText = an.isCDATA = an.isTag = an.Element = an.Document = an.CDATA = an.NodeWithChildren = an.ProcessingInstruction = an.Comment = an.Text = an.DataNode = an.Node = void 0;
var ns = iD, sD = (
  /** @class */
  function() {
    function e() {
      this.parent = null, this.prev = null, this.next = null, this.startIndex = null, this.endIndex = null;
    }
    return Object.defineProperty(e.prototype, "parentNode", {
      // Read-write aliases for properties
      /**
       * Same as {@link parent}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.parent;
      },
      set: function(t) {
        this.parent = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "previousSibling", {
      /**
       * Same as {@link prev}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.prev;
      },
      set: function(t) {
        this.prev = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "nextSibling", {
      /**
       * Same as {@link next}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.next;
      },
      set: function(t) {
        this.next = t;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.cloneNode = function(t) {
      return t === void 0 && (t = !1), aD(this, t);
    }, e;
  }()
);
an.Node = sD;
var NC = (
  /** @class */
  function(e) {
    Ou(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.data = n, r;
    }
    return Object.defineProperty(t.prototype, "nodeValue", {
      /**
       * Same as {@link data}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.data;
      },
      set: function(n) {
        this.data = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(sD)
);
an.DataNode = NC;
var CJ = (
  /** @class */
  function(e) {
    Ou(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = ns.ElementType.Text, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 3;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(NC)
);
an.Text = CJ;
var OJ = (
  /** @class */
  function(e) {
    Ou(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = ns.ElementType.Comment, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 8;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(NC)
);
an.Comment = OJ;
var xJ = (
  /** @class */
  function(e) {
    Ou(t, e);
    function t(n, r) {
      var o = e.call(this, r) || this;
      return o.name = n, o.type = ns.ElementType.Directive, o;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(NC)
);
an.ProcessingInstruction = xJ;
var BC = (
  /** @class */
  function(e) {
    Ou(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.children = n, r;
    }
    return Object.defineProperty(t.prototype, "firstChild", {
      // Aliases
      /** First child of the node. */
      get: function() {
        var n;
        return (n = this.children[0]) !== null && n !== void 0 ? n : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "lastChild", {
      /** Last child of the node. */
      get: function() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "childNodes", {
      /**
       * Same as {@link children}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.children;
      },
      set: function(n) {
        this.children = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(sD)
);
an.NodeWithChildren = BC;
var EJ = (
  /** @class */
  function(e) {
    Ou(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = ns.ElementType.CDATA, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 4;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(BC)
);
an.CDATA = EJ;
var kJ = (
  /** @class */
  function(e) {
    Ou(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = ns.ElementType.Root, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 9;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(BC)
);
an.Document = kJ;
var LJ = (
  /** @class */
  function(e) {
    Ou(t, e);
    function t(n, r, o, i) {
      o === void 0 && (o = []), i === void 0 && (i = n === "script" ? ns.ElementType.Script : n === "style" ? ns.ElementType.Style : ns.ElementType.Tag);
      var a = e.call(this, o) || this;
      return a.name = n, a.attribs = r, a.type = i, a;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "tagName", {
      // DOM Level 1 aliases
      /**
       * Same as {@link name}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.name;
      },
      set: function(n) {
        this.name = n;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "attributes", {
      get: function() {
        var n = this;
        return Object.keys(this.attribs).map(function(r) {
          var o, i;
          return {
            name: r,
            value: n.attribs[r],
            namespace: (o = n["x-attribsNamespace"]) === null || o === void 0 ? void 0 : o[r],
            prefix: (i = n["x-attribsPrefix"]) === null || i === void 0 ? void 0 : i[r]
          };
        });
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(BC)
);
an.Element = LJ;
function _J(e) {
  return (0, ns.isTag)(e);
}
an.isTag = _J;
function PJ(e) {
  return e.type === ns.ElementType.CDATA;
}
an.isCDATA = PJ;
function SJ(e) {
  return e.type === ns.ElementType.Text;
}
an.isText = SJ;
function MJ(e) {
  return e.type === ns.ElementType.Comment;
}
an.isComment = MJ;
function DJ(e) {
  return e.type === ns.ElementType.Directive;
}
an.isDirective = DJ;
function TJ(e) {
  return e.type === ns.ElementType.Root;
}
an.isDocument = TJ;
function N0e(e) {
  return Object.prototype.hasOwnProperty.call(e, "children");
}
an.hasChildren = N0e;
function aD(e, t) {
  t === void 0 && (t = !1);
  var n;
  if (SJ(e))
    n = new CJ(e.data);
  else if (MJ(e))
    n = new OJ(e.data);
  else if (_J(e)) {
    var r = t ? Ux(e.children) : [], o = new LJ(e.name, wf({}, e.attribs), r);
    r.forEach(function(l) {
      return l.parent = o;
    }), e.namespace != null && (o.namespace = e.namespace), e["x-attribsNamespace"] && (o["x-attribsNamespace"] = wf({}, e["x-attribsNamespace"])), e["x-attribsPrefix"] && (o["x-attribsPrefix"] = wf({}, e["x-attribsPrefix"])), n = o;
  } else if (PJ(e)) {
    var r = t ? Ux(e.children) : [], i = new EJ(r);
    r.forEach(function(u) {
      return u.parent = i;
    }), n = i;
  } else if (TJ(e)) {
    var r = t ? Ux(e.children) : [], a = new kJ(r);
    r.forEach(function(u) {
      return u.parent = a;
    }), e["x-mode"] && (a["x-mode"] = e["x-mode"]), n = a;
  } else if (DJ(e)) {
    var s = new xJ(e.name, e.data);
    e["x-name"] != null && (s["x-name"] = e["x-name"], s["x-publicId"] = e["x-publicId"], s["x-systemId"] = e["x-systemId"]), n = s;
  } else
    throw new Error("Not implemented yet: ".concat(e.type));
  return n.startIndex = e.startIndex, n.endIndex = e.endIndex, e.sourceCodeLocation != null && (n.sourceCodeLocation = e.sourceCodeLocation), n;
}
an.cloneNode = aD;
function Ux(e) {
  for (var t = e.map(function(r) {
    return aD(r, !0);
  }), n = 1; n < t.length; n++)
    t[n].prev = t[n - 1], t[n - 1].next = t[n];
  return t;
}
(function(e) {
  var t = wr && wr.__createBinding || (Object.create ? function(s, l, u, c) {
    c === void 0 && (c = u);
    var p = Object.getOwnPropertyDescriptor(l, u);
    (!p || ("get" in p ? !l.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
      return l[u];
    } }), Object.defineProperty(s, c, p);
  } : function(s, l, u, c) {
    c === void 0 && (c = u), s[c] = l[u];
  }), n = wr && wr.__exportStar || function(s, l) {
    for (var u in s) u !== "default" && !Object.prototype.hasOwnProperty.call(l, u) && t(l, s, u);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.DomHandler = void 0;
  var r = iD, o = an;
  n(an, e);
  var i = {
    withStartIndices: !1,
    withEndIndices: !1,
    xmlMode: !1
  }, a = (
    /** @class */
    function() {
      function s(l, u, c) {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null, typeof u == "function" && (c = u, u = i), typeof l == "object" && (u = l, l = void 0), this.callback = l ?? null, this.options = u ?? i, this.elementCB = c ?? null;
      }
      return s.prototype.onparserinit = function(l) {
        this.parser = l;
      }, s.prototype.onreset = function() {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null;
      }, s.prototype.onend = function() {
        this.done || (this.done = !0, this.parser = null, this.handleCallback(null));
      }, s.prototype.onerror = function(l) {
        this.handleCallback(l);
      }, s.prototype.onclosetag = function() {
        this.lastNode = null;
        var l = this.tagStack.pop();
        this.options.withEndIndices && (l.endIndex = this.parser.endIndex), this.elementCB && this.elementCB(l);
      }, s.prototype.onopentag = function(l, u) {
        var c = this.options.xmlMode ? r.ElementType.Tag : void 0, p = new o.Element(l, u, void 0, c);
        this.addNode(p), this.tagStack.push(p);
      }, s.prototype.ontext = function(l) {
        var u = this.lastNode;
        if (u && u.type === r.ElementType.Text)
          u.data += l, this.options.withEndIndices && (u.endIndex = this.parser.endIndex);
        else {
          var c = new o.Text(l);
          this.addNode(c), this.lastNode = c;
        }
      }, s.prototype.oncomment = function(l) {
        if (this.lastNode && this.lastNode.type === r.ElementType.Comment) {
          this.lastNode.data += l;
          return;
        }
        var u = new o.Comment(l);
        this.addNode(u), this.lastNode = u;
      }, s.prototype.oncommentend = function() {
        this.lastNode = null;
      }, s.prototype.oncdatastart = function() {
        var l = new o.Text(""), u = new o.CDATA([l]);
        this.addNode(u), l.parent = u, this.lastNode = l;
      }, s.prototype.oncdataend = function() {
        this.lastNode = null;
      }, s.prototype.onprocessinginstruction = function(l, u) {
        var c = new o.ProcessingInstruction(l, u);
        this.addNode(c);
      }, s.prototype.handleCallback = function(l) {
        if (typeof this.callback == "function")
          this.callback(l, this.dom);
        else if (l)
          throw l;
      }, s.prototype.addNode = function(l) {
        var u = this.tagStack[this.tagStack.length - 1], c = u.children[u.children.length - 1];
        this.options.withStartIndices && (l.startIndex = this.parser.startIndex), this.options.withEndIndices && (l.endIndex = this.parser.endIndex), u.children.push(l), c && (l.prev = c, c.next = l), l.parent = u, this.lastNode = null;
      }, s;
    }()
  );
  e.DomHandler = a, e.default = a;
})(oD);
var jJ = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CARRIAGE_RETURN_PLACEHOLDER_REGEX = e.CARRIAGE_RETURN_PLACEHOLDER = e.CARRIAGE_RETURN_REGEX = e.CARRIAGE_RETURN = e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES = void 0, e.CASE_SENSITIVE_TAG_NAMES = [
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "linearGradient",
    "radialGradient",
    "textPath"
  ], e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES.reduce(function(t, n) {
    return t[n.toLowerCase()] = n, t;
  }, {}), e.CARRIAGE_RETURN = "\r", e.CARRIAGE_RETURN_REGEX = new RegExp(e.CARRIAGE_RETURN, "g"), e.CARRIAGE_RETURN_PLACEHOLDER = "__HTML_DOM_PARSER_CARRIAGE_RETURN_PLACEHOLDER_".concat(Date.now(), "__"), e.CARRIAGE_RETURN_PLACEHOLDER_REGEX = new RegExp(e.CARRIAGE_RETURN_PLACEHOLDER, "g");
})(jJ);
Object.defineProperty(op, "__esModule", { value: !0 });
op.formatAttributes = AJ;
op.escapeSpecialCharacters = z0e;
op.revertEscapedCharacters = RJ;
op.formatDOM = IJ;
var zm = oD, Lh = jJ;
function B0e(e) {
  return Lh.CASE_SENSITIVE_TAG_NAMES_MAP[e];
}
function AJ(e) {
  for (var t = {}, n = 0, r = e.length; n < r; n++) {
    var o = e[n];
    t[o.name] = o.value;
  }
  return t;
}
function F0e(e) {
  e = e.toLowerCase();
  var t = B0e(e);
  return t || e;
}
function z0e(e) {
  return e.replace(Lh.CARRIAGE_RETURN_REGEX, Lh.CARRIAGE_RETURN_PLACEHOLDER);
}
function RJ(e) {
  return e.replace(Lh.CARRIAGE_RETURN_PLACEHOLDER_REGEX, Lh.CARRIAGE_RETURN);
}
function IJ(e, t, n) {
  t === void 0 && (t = null);
  for (var r = [], o, i = 0, a = e.length; i < a; i++) {
    var s = e[i];
    switch (s.nodeType) {
      case 1: {
        var l = F0e(s.nodeName);
        o = new zm.Element(l, AJ(s.attributes)), o.children = IJ(
          // template children are on content
          l === "template" ? s.content.childNodes : s.childNodes,
          o
        );
        break;
      }
      case 3:
        o = new zm.Text(RJ(s.nodeValue));
        break;
      case 8:
        o = new zm.Comment(s.nodeValue);
        break;
      default:
        continue;
    }
    var u = r[i - 1] || null;
    u && (u.next = o), o.parent = t, o.prev = u, o.next = null, r.push(o);
  }
  return n && (o = new zm.ProcessingInstruction(n.substring(0, n.indexOf(" ")).toLowerCase(), n), o.next = r[0] || null, o.parent = t, r.unshift(o), r[1] && (r[1].prev = r[0])), r;
}
Object.defineProperty(rD, "__esModule", { value: !0 });
rD.default = V0e;
var U0e = op, QB = "html", eF = "head", Um = "body", H0e = /<([a-zA-Z]+[0-9]?)/, tF = /<head[^]*>/i, nF = /<body[^]*>/i, Lb = function(e, t) {
  throw new Error("This browser does not support `document.implementation.createHTMLDocument`");
}, E_ = function(e, t) {
  throw new Error("This browser does not support `DOMParser.prototype.parseFromString`");
}, rF = typeof window == "object" && window.DOMParser;
if (typeof rF == "function") {
  var W0e = new rF(), $0e = "text/html";
  E_ = function(e, t) {
    return t && (e = "<".concat(t, ">").concat(e, "</").concat(t, ">")), W0e.parseFromString(e, $0e);
  }, Lb = E_;
}
if (typeof document == "object" && document.implementation) {
  var Hm = document.implementation.createHTMLDocument();
  Lb = function(e, t) {
    if (t) {
      var n = Hm.documentElement.querySelector(t);
      return n && (n.innerHTML = e), Hm;
    }
    return Hm.documentElement.innerHTML = e, Hm;
  };
}
var Wm = typeof document == "object" && document.createElement("template"), k_;
Wm && Wm.content && (k_ = function(e) {
  return Wm.innerHTML = e, Wm.content.childNodes;
});
function V0e(e) {
  var t, n;
  e = (0, U0e.escapeSpecialCharacters)(e);
  var r = e.match(H0e), o = r && r[1] ? r[1].toLowerCase() : "";
  switch (o) {
    case QB: {
      var i = E_(e);
      if (!tF.test(e)) {
        var a = i.querySelector(eF);
        (t = a == null ? void 0 : a.parentNode) === null || t === void 0 || t.removeChild(a);
      }
      if (!nF.test(e)) {
        var a = i.querySelector(Um);
        (n = a == null ? void 0 : a.parentNode) === null || n === void 0 || n.removeChild(a);
      }
      return i.querySelectorAll(QB);
    }
    case eF:
    case Um: {
      var s = Lb(e).querySelectorAll(o);
      return nF.test(e) && tF.test(e) ? s[0].parentNode.childNodes : s;
    }
    default: {
      if (k_)
        return k_(e);
      var a = Lb(e, Um).querySelector(Um);
      return a.childNodes;
    }
  }
}
var Z0e = wr && wr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(nD, "__esModule", { value: !0 });
nD.default = X0e;
var q0e = Z0e(rD), G0e = op, K0e = /<(![a-zA-Z\s]+)>/;
function X0e(e) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e)
    return [];
  var t = e.match(K0e), n = t ? t[1] : void 0;
  return (0, G0e.formatDOM)((0, q0e.default)(e), null, n);
}
var FC = {}, Js = {}, zC = {}, Y0e = 0;
zC.SAME = Y0e;
var J0e = 1;
zC.CAMELCASE = J0e;
zC.possibleStandardNames = {
  accept: 0,
  acceptCharset: 1,
  "accept-charset": "acceptCharset",
  accessKey: 1,
  action: 0,
  allowFullScreen: 1,
  alt: 0,
  as: 0,
  async: 0,
  autoCapitalize: 1,
  autoComplete: 1,
  autoCorrect: 1,
  autoFocus: 1,
  autoPlay: 1,
  autoSave: 1,
  capture: 0,
  cellPadding: 1,
  cellSpacing: 1,
  challenge: 0,
  charSet: 1,
  checked: 0,
  children: 0,
  cite: 0,
  class: "className",
  classID: 1,
  className: 1,
  cols: 0,
  colSpan: 1,
  content: 0,
  contentEditable: 1,
  contextMenu: 1,
  controls: 0,
  controlsList: 1,
  coords: 0,
  crossOrigin: 1,
  dangerouslySetInnerHTML: 1,
  data: 0,
  dateTime: 1,
  default: 0,
  defaultChecked: 1,
  defaultValue: 1,
  defer: 0,
  dir: 0,
  disabled: 0,
  disablePictureInPicture: 1,
  disableRemotePlayback: 1,
  download: 0,
  draggable: 0,
  encType: 1,
  enterKeyHint: 1,
  for: "htmlFor",
  form: 0,
  formMethod: 1,
  formAction: 1,
  formEncType: 1,
  formNoValidate: 1,
  formTarget: 1,
  frameBorder: 1,
  headers: 0,
  height: 0,
  hidden: 0,
  high: 0,
  href: 0,
  hrefLang: 1,
  htmlFor: 1,
  httpEquiv: 1,
  "http-equiv": "httpEquiv",
  icon: 0,
  id: 0,
  innerHTML: 1,
  inputMode: 1,
  integrity: 0,
  is: 0,
  itemID: 1,
  itemProp: 1,
  itemRef: 1,
  itemScope: 1,
  itemType: 1,
  keyParams: 1,
  keyType: 1,
  kind: 0,
  label: 0,
  lang: 0,
  list: 0,
  loop: 0,
  low: 0,
  manifest: 0,
  marginWidth: 1,
  marginHeight: 1,
  max: 0,
  maxLength: 1,
  media: 0,
  mediaGroup: 1,
  method: 0,
  min: 0,
  minLength: 1,
  multiple: 0,
  muted: 0,
  name: 0,
  noModule: 1,
  nonce: 0,
  noValidate: 1,
  open: 0,
  optimum: 0,
  pattern: 0,
  placeholder: 0,
  playsInline: 1,
  poster: 0,
  preload: 0,
  profile: 0,
  radioGroup: 1,
  readOnly: 1,
  referrerPolicy: 1,
  rel: 0,
  required: 0,
  reversed: 0,
  role: 0,
  rows: 0,
  rowSpan: 1,
  sandbox: 0,
  scope: 0,
  scoped: 0,
  scrolling: 0,
  seamless: 0,
  selected: 0,
  shape: 0,
  size: 0,
  sizes: 0,
  span: 0,
  spellCheck: 1,
  src: 0,
  srcDoc: 1,
  srcLang: 1,
  srcSet: 1,
  start: 0,
  step: 0,
  style: 0,
  summary: 0,
  tabIndex: 1,
  target: 0,
  title: 0,
  type: 0,
  useMap: 1,
  value: 0,
  width: 0,
  wmode: 0,
  wrap: 0,
  about: 0,
  accentHeight: 1,
  "accent-height": "accentHeight",
  accumulate: 0,
  additive: 0,
  alignmentBaseline: 1,
  "alignment-baseline": "alignmentBaseline",
  allowReorder: 1,
  alphabetic: 0,
  amplitude: 0,
  arabicForm: 1,
  "arabic-form": "arabicForm",
  ascent: 0,
  attributeName: 1,
  attributeType: 1,
  autoReverse: 1,
  azimuth: 0,
  baseFrequency: 1,
  baselineShift: 1,
  "baseline-shift": "baselineShift",
  baseProfile: 1,
  bbox: 0,
  begin: 0,
  bias: 0,
  by: 0,
  calcMode: 1,
  capHeight: 1,
  "cap-height": "capHeight",
  clip: 0,
  clipPath: 1,
  "clip-path": "clipPath",
  clipPathUnits: 1,
  clipRule: 1,
  "clip-rule": "clipRule",
  color: 0,
  colorInterpolation: 1,
  "color-interpolation": "colorInterpolation",
  colorInterpolationFilters: 1,
  "color-interpolation-filters": "colorInterpolationFilters",
  colorProfile: 1,
  "color-profile": "colorProfile",
  colorRendering: 1,
  "color-rendering": "colorRendering",
  contentScriptType: 1,
  contentStyleType: 1,
  cursor: 0,
  cx: 0,
  cy: 0,
  d: 0,
  datatype: 0,
  decelerate: 0,
  descent: 0,
  diffuseConstant: 1,
  direction: 0,
  display: 0,
  divisor: 0,
  dominantBaseline: 1,
  "dominant-baseline": "dominantBaseline",
  dur: 0,
  dx: 0,
  dy: 0,
  edgeMode: 1,
  elevation: 0,
  enableBackground: 1,
  "enable-background": "enableBackground",
  end: 0,
  exponent: 0,
  externalResourcesRequired: 1,
  fill: 0,
  fillOpacity: 1,
  "fill-opacity": "fillOpacity",
  fillRule: 1,
  "fill-rule": "fillRule",
  filter: 0,
  filterRes: 1,
  filterUnits: 1,
  floodOpacity: 1,
  "flood-opacity": "floodOpacity",
  floodColor: 1,
  "flood-color": "floodColor",
  focusable: 0,
  fontFamily: 1,
  "font-family": "fontFamily",
  fontSize: 1,
  "font-size": "fontSize",
  fontSizeAdjust: 1,
  "font-size-adjust": "fontSizeAdjust",
  fontStretch: 1,
  "font-stretch": "fontStretch",
  fontStyle: 1,
  "font-style": "fontStyle",
  fontVariant: 1,
  "font-variant": "fontVariant",
  fontWeight: 1,
  "font-weight": "fontWeight",
  format: 0,
  from: 0,
  fx: 0,
  fy: 0,
  g1: 0,
  g2: 0,
  glyphName: 1,
  "glyph-name": "glyphName",
  glyphOrientationHorizontal: 1,
  "glyph-orientation-horizontal": "glyphOrientationHorizontal",
  glyphOrientationVertical: 1,
  "glyph-orientation-vertical": "glyphOrientationVertical",
  glyphRef: 1,
  gradientTransform: 1,
  gradientUnits: 1,
  hanging: 0,
  horizAdvX: 1,
  "horiz-adv-x": "horizAdvX",
  horizOriginX: 1,
  "horiz-origin-x": "horizOriginX",
  ideographic: 0,
  imageRendering: 1,
  "image-rendering": "imageRendering",
  in2: 0,
  in: 0,
  inlist: 0,
  intercept: 0,
  k1: 0,
  k2: 0,
  k3: 0,
  k4: 0,
  k: 0,
  kernelMatrix: 1,
  kernelUnitLength: 1,
  kerning: 0,
  keyPoints: 1,
  keySplines: 1,
  keyTimes: 1,
  lengthAdjust: 1,
  letterSpacing: 1,
  "letter-spacing": "letterSpacing",
  lightingColor: 1,
  "lighting-color": "lightingColor",
  limitingConeAngle: 1,
  local: 0,
  markerEnd: 1,
  "marker-end": "markerEnd",
  markerHeight: 1,
  markerMid: 1,
  "marker-mid": "markerMid",
  markerStart: 1,
  "marker-start": "markerStart",
  markerUnits: 1,
  markerWidth: 1,
  mask: 0,
  maskContentUnits: 1,
  maskUnits: 1,
  mathematical: 0,
  mode: 0,
  numOctaves: 1,
  offset: 0,
  opacity: 0,
  operator: 0,
  order: 0,
  orient: 0,
  orientation: 0,
  origin: 0,
  overflow: 0,
  overlinePosition: 1,
  "overline-position": "overlinePosition",
  overlineThickness: 1,
  "overline-thickness": "overlineThickness",
  paintOrder: 1,
  "paint-order": "paintOrder",
  panose1: 0,
  "panose-1": "panose1",
  pathLength: 1,
  patternContentUnits: 1,
  patternTransform: 1,
  patternUnits: 1,
  pointerEvents: 1,
  "pointer-events": "pointerEvents",
  points: 0,
  pointsAtX: 1,
  pointsAtY: 1,
  pointsAtZ: 1,
  prefix: 0,
  preserveAlpha: 1,
  preserveAspectRatio: 1,
  primitiveUnits: 1,
  property: 0,
  r: 0,
  radius: 0,
  refX: 1,
  refY: 1,
  renderingIntent: 1,
  "rendering-intent": "renderingIntent",
  repeatCount: 1,
  repeatDur: 1,
  requiredExtensions: 1,
  requiredFeatures: 1,
  resource: 0,
  restart: 0,
  result: 0,
  results: 0,
  rotate: 0,
  rx: 0,
  ry: 0,
  scale: 0,
  security: 0,
  seed: 0,
  shapeRendering: 1,
  "shape-rendering": "shapeRendering",
  slope: 0,
  spacing: 0,
  specularConstant: 1,
  specularExponent: 1,
  speed: 0,
  spreadMethod: 1,
  startOffset: 1,
  stdDeviation: 1,
  stemh: 0,
  stemv: 0,
  stitchTiles: 1,
  stopColor: 1,
  "stop-color": "stopColor",
  stopOpacity: 1,
  "stop-opacity": "stopOpacity",
  strikethroughPosition: 1,
  "strikethrough-position": "strikethroughPosition",
  strikethroughThickness: 1,
  "strikethrough-thickness": "strikethroughThickness",
  string: 0,
  stroke: 0,
  strokeDasharray: 1,
  "stroke-dasharray": "strokeDasharray",
  strokeDashoffset: 1,
  "stroke-dashoffset": "strokeDashoffset",
  strokeLinecap: 1,
  "stroke-linecap": "strokeLinecap",
  strokeLinejoin: 1,
  "stroke-linejoin": "strokeLinejoin",
  strokeMiterlimit: 1,
  "stroke-miterlimit": "strokeMiterlimit",
  strokeWidth: 1,
  "stroke-width": "strokeWidth",
  strokeOpacity: 1,
  "stroke-opacity": "strokeOpacity",
  suppressContentEditableWarning: 1,
  suppressHydrationWarning: 1,
  surfaceScale: 1,
  systemLanguage: 1,
  tableValues: 1,
  targetX: 1,
  targetY: 1,
  textAnchor: 1,
  "text-anchor": "textAnchor",
  textDecoration: 1,
  "text-decoration": "textDecoration",
  textLength: 1,
  textRendering: 1,
  "text-rendering": "textRendering",
  to: 0,
  transform: 0,
  typeof: 0,
  u1: 0,
  u2: 0,
  underlinePosition: 1,
  "underline-position": "underlinePosition",
  underlineThickness: 1,
  "underline-thickness": "underlineThickness",
  unicode: 0,
  unicodeBidi: 1,
  "unicode-bidi": "unicodeBidi",
  unicodeRange: 1,
  "unicode-range": "unicodeRange",
  unitsPerEm: 1,
  "units-per-em": "unitsPerEm",
  unselectable: 0,
  vAlphabetic: 1,
  "v-alphabetic": "vAlphabetic",
  values: 0,
  vectorEffect: 1,
  "vector-effect": "vectorEffect",
  version: 0,
  vertAdvY: 1,
  "vert-adv-y": "vertAdvY",
  vertOriginX: 1,
  "vert-origin-x": "vertOriginX",
  vertOriginY: 1,
  "vert-origin-y": "vertOriginY",
  vHanging: 1,
  "v-hanging": "vHanging",
  vIdeographic: 1,
  "v-ideographic": "vIdeographic",
  viewBox: 1,
  viewTarget: 1,
  visibility: 0,
  vMathematical: 1,
  "v-mathematical": "vMathematical",
  vocab: 0,
  widths: 0,
  wordSpacing: 1,
  "word-spacing": "wordSpacing",
  writingMode: 1,
  "writing-mode": "writingMode",
  x1: 0,
  x2: 0,
  x: 0,
  xChannelSelector: 1,
  xHeight: 1,
  "x-height": "xHeight",
  xlinkActuate: 1,
  "xlink:actuate": "xlinkActuate",
  xlinkArcrole: 1,
  "xlink:arcrole": "xlinkArcrole",
  xlinkHref: 1,
  "xlink:href": "xlinkHref",
  xlinkRole: 1,
  "xlink:role": "xlinkRole",
  xlinkShow: 1,
  "xlink:show": "xlinkShow",
  xlinkTitle: 1,
  "xlink:title": "xlinkTitle",
  xlinkType: 1,
  "xlink:type": "xlinkType",
  xmlBase: 1,
  "xml:base": "xmlBase",
  xmlLang: 1,
  "xml:lang": "xmlLang",
  xmlns: 0,
  "xml:space": "xmlSpace",
  xmlnsXlink: 1,
  "xmlns:xlink": "xmlnsXlink",
  xmlSpace: 1,
  y1: 0,
  y2: 0,
  y: 0,
  yChannelSelector: 1,
  z: 0,
  zoomAndPan: 1
};
const NJ = 0, xu = 1, UC = 2, HC = 3, lD = 4, BJ = 5, FJ = 6;
function Q0e(e) {
  return ci.hasOwnProperty(e) ? ci[e] : null;
}
function Bi(e, t, n, r, o, i, a) {
  this.acceptsBooleans = t === UC || t === HC || t === lD, this.attributeName = r, this.attributeNamespace = o, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = i, this.removeEmptyString = a;
}
const ci = {}, eCe = [
  "children",
  "dangerouslySetInnerHTML",
  // TODO: This prevents the assignment of defaultValue to regular
  // elements (not just inputs). Now that ReactDOMInput assigns to the
  // defaultValue property -- do we need this?
  "defaultValue",
  "defaultChecked",
  "innerHTML",
  "suppressContentEditableWarning",
  "suppressHydrationWarning",
  "style"
];
eCe.forEach((e) => {
  ci[e] = new Bi(
    e,
    NJ,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"]
].forEach(([e, t]) => {
  ci[e] = new Bi(
    e,
    xu,
    !1,
    // mustUseProperty
    t,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["contentEditable", "draggable", "spellCheck", "value"].forEach((e) => {
  ci[e] = new Bi(
    e,
    UC,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha"
].forEach((e) => {
  ci[e] = new Bi(
    e,
    UC,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "allowFullScreen",
  "async",
  // Note: there is a special case that prevents it from being written to the DOM
  // on the client side because the browsers are inconsistent. Instead we call focus().
  "autoFocus",
  "autoPlay",
  "controls",
  "default",
  "defer",
  "disabled",
  "disablePictureInPicture",
  "disableRemotePlayback",
  "formNoValidate",
  "hidden",
  "loop",
  "noModule",
  "noValidate",
  "open",
  "playsInline",
  "readOnly",
  "required",
  "reversed",
  "scoped",
  "seamless",
  // Microdata
  "itemScope"
].forEach((e) => {
  ci[e] = new Bi(
    e,
    HC,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "checked",
  // Note: `option.selected` is not updated if `select.multiple` is
  // disabled with `removeAttribute`. We have special logic for handling this.
  "multiple",
  "muted",
  "selected"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  ci[e] = new Bi(
    e,
    HC,
    !0,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "capture",
  "download"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  ci[e] = new Bi(
    e,
    lD,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "cols",
  "rows",
  "size",
  "span"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  ci[e] = new Bi(
    e,
    FJ,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["rowSpan", "start"].forEach((e) => {
  ci[e] = new Bi(
    e,
    BJ,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const uD = /[\-\:]([a-z])/g, cD = (e) => e[1].toUpperCase();
[
  "accent-height",
  "alignment-baseline",
  "arabic-form",
  "baseline-shift",
  "cap-height",
  "clip-path",
  "clip-rule",
  "color-interpolation",
  "color-interpolation-filters",
  "color-profile",
  "color-rendering",
  "dominant-baseline",
  "enable-background",
  "fill-opacity",
  "fill-rule",
  "flood-color",
  "flood-opacity",
  "font-family",
  "font-size",
  "font-size-adjust",
  "font-stretch",
  "font-style",
  "font-variant",
  "font-weight",
  "glyph-name",
  "glyph-orientation-horizontal",
  "glyph-orientation-vertical",
  "horiz-adv-x",
  "horiz-origin-x",
  "image-rendering",
  "letter-spacing",
  "lighting-color",
  "marker-end",
  "marker-mid",
  "marker-start",
  "overline-position",
  "overline-thickness",
  "paint-order",
  "panose-1",
  "pointer-events",
  "rendering-intent",
  "shape-rendering",
  "stop-color",
  "stop-opacity",
  "strikethrough-position",
  "strikethrough-thickness",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "text-anchor",
  "text-decoration",
  "text-rendering",
  "underline-position",
  "underline-thickness",
  "unicode-bidi",
  "unicode-range",
  "units-per-em",
  "v-alphabetic",
  "v-hanging",
  "v-ideographic",
  "v-mathematical",
  "vector-effect",
  "vert-adv-y",
  "vert-origin-x",
  "vert-origin-y",
  "word-spacing",
  "writing-mode",
  "xmlns:xlink",
  "x-height"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(uD, cD);
  ci[t] = new Bi(
    t,
    xu,
    !1,
    // mustUseProperty
    e,
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xlink:actuate",
  "xlink:arcrole",
  "xlink:role",
  "xlink:show",
  "xlink:title",
  "xlink:type"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(uD, cD);
  ci[t] = new Bi(
    t,
    xu,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/1999/xlink",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xml:base",
  "xml:lang",
  "xml:space"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(uD, cD);
  ci[t] = new Bi(
    t,
    xu,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/XML/1998/namespace",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["tabIndex", "crossOrigin"].forEach((e) => {
  ci[e] = new Bi(
    e,
    xu,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const tCe = "xlinkHref";
ci[tCe] = new Bi(
  "xlinkHref",
  xu,
  !1,
  // mustUseProperty
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  // sanitizeURL
  !1
  // removeEmptyString
);
["src", "href", "action", "formAction"].forEach((e) => {
  ci[e] = new Bi(
    e,
    xu,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !0,
    // sanitizeURL
    !0
    // removeEmptyString
  );
});
const {
  CAMELCASE: nCe,
  SAME: rCe,
  possibleStandardNames: oF
} = zC, oCe = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", iCe = oCe + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", sCe = RegExp.prototype.test.bind(
  // eslint-disable-next-line no-misleading-character-class
  new RegExp("^(data|aria)-[" + iCe + "]*$")
), aCe = Object.keys(
  oF
).reduce((e, t) => {
  const n = oF[t];
  return n === rCe ? e[t] = t : n === nCe ? e[t.toLowerCase()] = t : e[t] = n, e;
}, {});
Js.BOOLEAN = HC;
Js.BOOLEANISH_STRING = UC;
Js.NUMERIC = BJ;
Js.OVERLOADED_BOOLEAN = lD;
Js.POSITIVE_NUMERIC = FJ;
Js.RESERVED = NJ;
Js.STRING = xu;
Js.getPropertyInfo = Q0e;
Js.isCustomAttribute = sCe;
Js.possibleStandardNames = aCe;
var pD = {}, dD = {}, iF = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, lCe = /\n/g, uCe = /^\s*/, cCe = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, pCe = /^:\s*/, dCe = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, fCe = /^[;\s]*/, hCe = /^\s+|\s+$/g, gCe = `
`, sF = "/", aF = "*", dc = "", mCe = "comment", vCe = "declaration", yCe = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e) return [];
  t = t || {};
  var n = 1, r = 1;
  function o(f) {
    var m = f.match(lCe);
    m && (n += m.length);
    var b = f.lastIndexOf(gCe);
    r = ~b ? f.length - b : r + f.length;
  }
  function i() {
    var f = { line: n, column: r };
    return function(m) {
      return m.position = new a(f), u(), m;
    };
  }
  function a(f) {
    this.start = f, this.end = { line: n, column: r }, this.source = t.source;
  }
  a.prototype.content = e;
  function s(f) {
    var m = new Error(
      t.source + ":" + n + ":" + r + ": " + f
    );
    if (m.reason = f, m.filename = t.source, m.line = n, m.column = r, m.source = e, !t.silent) throw m;
  }
  function l(f) {
    var m = f.exec(e);
    if (m) {
      var b = m[0];
      return o(b), e = e.slice(b.length), m;
    }
  }
  function u() {
    l(uCe);
  }
  function c(f) {
    var m;
    for (f = f || []; m = p(); )
      m !== !1 && f.push(m);
    return f;
  }
  function p() {
    var f = i();
    if (!(sF != e.charAt(0) || aF != e.charAt(1))) {
      for (var m = 2; dc != e.charAt(m) && (aF != e.charAt(m) || sF != e.charAt(m + 1)); )
        ++m;
      if (m += 2, dc === e.charAt(m - 1))
        return s("End of comment missing");
      var b = e.slice(2, m - 2);
      return r += 2, o(b), e = e.slice(m), r += 2, f({
        type: mCe,
        comment: b
      });
    }
  }
  function d() {
    var f = i(), m = l(cCe);
    if (m) {
      if (p(), !l(pCe)) return s("property missing ':'");
      var b = l(dCe), E = f({
        type: vCe,
        property: lF(m[0].replace(iF, dc)),
        value: b ? lF(b[0].replace(iF, dc)) : dc
      });
      return l(fCe), E;
    }
  }
  function g() {
    var f = [];
    c(f);
    for (var m; m = d(); )
      m !== !1 && (f.push(m), c(f));
    return f;
  }
  return u(), g();
};
function lF(e) {
  return e ? e.replace(hCe, dc) : dc;
}
var bCe = wr && wr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(dD, "__esModule", { value: !0 });
dD.default = CCe;
var wCe = bCe(yCe);
function CCe(e, t) {
  var n = null;
  if (!e || typeof e != "string")
    return n;
  var r = (0, wCe.default)(e), o = typeof t == "function";
  return r.forEach(function(i) {
    if (i.type === "declaration") {
      var a = i.property, s = i.value;
      o ? t(a, s, i) : s && (n = n || {}, n[a] = s);
    }
  }), n;
}
var WC = {};
Object.defineProperty(WC, "__esModule", { value: !0 });
WC.camelCase = void 0;
var OCe = /^--[a-zA-Z0-9_-]+$/, xCe = /-([a-z])/g, ECe = /^[^-]+$/, kCe = /^-(webkit|moz|ms|o|khtml)-/, LCe = /^-(ms)-/, _Ce = function(e) {
  return !e || ECe.test(e) || OCe.test(e);
}, PCe = function(e, t) {
  return t.toUpperCase();
}, uF = function(e, t) {
  return "".concat(t, "-");
}, SCe = function(e, t) {
  return t === void 0 && (t = {}), _Ce(e) ? e : (e = e.toLowerCase(), t.reactCompat ? e = e.replace(LCe, uF) : e = e.replace(kCe, uF), e.replace(xCe, PCe));
};
WC.camelCase = SCe;
var MCe = wr && wr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
}, DCe = MCe(dD), TCe = WC;
function L_(e, t) {
  var n = {};
  return !e || typeof e != "string" || (0, DCe.default)(e, function(r, o) {
    r && o && (n[(0, TCe.camelCase)(r, t)] = o);
  }), n;
}
L_.default = L_;
var jCe = L_;
(function(e) {
  var t = wr && wr.__importDefault || function(c) {
    return c && c.__esModule ? c : { default: c };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.returnFirstArg = e.canTextBeChildOfNode = e.ELEMENTS_WITH_NO_TEXT_CHILDREN = e.PRESERVE_CUSTOM_ATTRIBUTES = void 0, e.isCustomComponent = i, e.setStyleProp = s;
  var n = be, r = t(jCe), o = /* @__PURE__ */ new Set([
    "annotation-xml",
    "color-profile",
    "font-face",
    "font-face-src",
    "font-face-uri",
    "font-face-format",
    "font-face-name",
    "missing-glyph"
  ]);
  function i(c, p) {
    return c.includes("-") ? !o.has(c) : !!(p && typeof p.is == "string");
  }
  var a = {
    reactCompat: !0
  };
  function s(c, p) {
    if (typeof c == "string") {
      if (!c.trim()) {
        p.style = {};
        return;
      }
      try {
        p.style = (0, r.default)(c, a);
      } catch {
        p.style = {};
      }
    }
  }
  e.PRESERVE_CUSTOM_ATTRIBUTES = Number(n.version.split(".")[0]) >= 16, e.ELEMENTS_WITH_NO_TEXT_CHILDREN = /* @__PURE__ */ new Set([
    "tr",
    "tbody",
    "thead",
    "tfoot",
    "colgroup",
    "table",
    "head",
    "html",
    "frameset"
  ]);
  var l = function(c) {
    return !e.ELEMENTS_WITH_NO_TEXT_CHILDREN.has(c.name);
  };
  e.canTextBeChildOfNode = l;
  var u = function(c) {
    return c;
  };
  e.returnFirstArg = u;
})(pD);
Object.defineProperty(FC, "__esModule", { value: !0 });
FC.default = NCe;
var rf = Js, cF = pD, ACe = ["checked", "value"], RCe = ["input", "select", "textarea"], ICe = {
  reset: !0,
  submit: !0
};
function NCe(e, t) {
  e === void 0 && (e = {});
  var n = {}, r = !!(e.type && ICe[e.type]);
  for (var o in e) {
    var i = e[o];
    if ((0, rf.isCustomAttribute)(o)) {
      n[o] = i;
      continue;
    }
    var a = o.toLowerCase(), s = pF(a);
    if (s) {
      var l = (0, rf.getPropertyInfo)(s);
      switch (ACe.includes(s) && RCe.includes(t) && !r && (s = pF("default" + a)), n[s] = i, l && l.type) {
        case rf.BOOLEAN:
          n[s] = !0;
          break;
        case rf.OVERLOADED_BOOLEAN:
          i === "" && (n[s] = !0);
          break;
      }
      continue;
    }
    cF.PRESERVE_CUSTOM_ATTRIBUTES && (n[o] = i);
  }
  return (0, cF.setStyleProp)(e.style, n), n;
}
function pF(e) {
  return rf.possibleStandardNames[e];
}
var fD = {}, BCe = wr && wr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(fD, "__esModule", { value: !0 });
fD.default = zJ;
var Hx = be, FCe = BCe(FC), Cf = pD, zCe = {
  cloneElement: Hx.cloneElement,
  createElement: Hx.createElement,
  isValidElement: Hx.isValidElement
};
function zJ(e, t) {
  t === void 0 && (t = {});
  for (var n = [], r = typeof t.replace == "function", o = t.transform || Cf.returnFirstArg, i = t.library || zCe, a = i.cloneElement, s = i.createElement, l = i.isValidElement, u = e.length, c = 0; c < u; c++) {
    var p = e[c];
    if (r) {
      var d = t.replace(p, c);
      if (l(d)) {
        u > 1 && (d = a(d, {
          key: d.key || c
        })), n.push(o(d, p, c));
        continue;
      }
    }
    if (p.type === "text") {
      var g = !p.data.trim().length;
      if (g && p.parent && !(0, Cf.canTextBeChildOfNode)(p.parent) || t.trim && g)
        continue;
      n.push(o(p.data, p, c));
      continue;
    }
    var f = p, m = {};
    UCe(f) ? ((0, Cf.setStyleProp)(f.attribs.style, f.attribs), m = f.attribs) : f.attribs && (m = (0, FCe.default)(f.attribs, f.name));
    var b = void 0;
    switch (p.type) {
      case "script":
      case "style":
        p.children[0] && (m.dangerouslySetInnerHTML = {
          __html: p.children[0].data
        });
        break;
      case "tag":
        p.name === "textarea" && p.children[0] ? m.defaultValue = p.children[0].data : p.children && p.children.length && (b = zJ(p.children, t));
        break;
      default:
        continue;
    }
    u > 1 && (m.key = c), n.push(o(s(p.name, m, b), p, c));
  }
  return n.length === 1 ? n[0] : n;
}
function UCe(e) {
  return Cf.PRESERVE_CUSTOM_ATTRIBUTES && e.type === "tag" && (0, Cf.isCustomComponent)(e.name, e.attribs);
}
(function(e) {
  var t = wr && wr.__importDefault || function(l) {
    return l && l.__esModule ? l : { default: l };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.htmlToDOM = e.domToReact = e.attributesToProps = e.Text = e.ProcessingInstruction = e.Element = e.Comment = void 0, e.default = s;
  var n = t(nD);
  e.htmlToDOM = n.default;
  var r = t(FC);
  e.attributesToProps = r.default;
  var o = t(fD);
  e.domToReact = o.default;
  var i = oD;
  Object.defineProperty(e, "Comment", { enumerable: !0, get: function() {
    return i.Comment;
  } }), Object.defineProperty(e, "Element", { enumerable: !0, get: function() {
    return i.Element;
  } }), Object.defineProperty(e, "ProcessingInstruction", { enumerable: !0, get: function() {
    return i.ProcessingInstruction;
  } }), Object.defineProperty(e, "Text", { enumerable: !0, get: function() {
    return i.Text;
  } });
  var a = { lowerCaseAttributeNames: !1 };
  function s(l, u) {
    if (typeof l != "string")
      throw new TypeError("First argument must be a string");
    return l ? (0, o.default)((0, n.default)(l, (u == null ? void 0 : u.htmlparser2) || a), u) : [];
  }
})(wJ);
const HCe = /* @__PURE__ */ a0e(wJ);
HCe.default;
$e({});
function WCe(e) {
  return e && e.replace(/[^0-9]/g, "");
}
const $Ce = {
  CNPJ: "99.999.999/9999-99"
};
WCe($Ce.CNPJ).length;
Cr((e, t) => /* @__PURE__ */ ni.jsx("input", { ref: t, ...e }));
function UJ(e) {
  return e && e.replace(/[^0-9]/g, "");
}
const HJ = {
  EIGTH: "(99) 9999-9999",
  NINE: "(99) 99999-9999"
};
function VCe(e, t) {
  let n = "", r = 0;
  for (let o = 0; o < t.length; o++)
    if (t[o] === "9")
      if (r < e.length)
        n += e[r], r++;
      else
        break;
    else if (r < e.length)
      n += t[o];
    else
      break;
  return n;
}
function ZCe(e) {
  return e.length > 10 ? "NINE" : "EIGTH";
}
const qCe = UJ(HJ.NINE).length, GCe = Cr((e, t) => /* @__PURE__ */ ni.jsx("input", { ref: t, ...e }));
Cr(
  (e, t) => {
    const { onFocus: n, onBlur: r, size: o, onChange: i, value: a, currentCountry: s, disabled: l } = e, [u, c] = k(!1);
    h(() => {
      u ? i(s.mask) : c(!0);
    }, [s]);
    const p = `phoneInputMask ${o}`;
    function d(g) {
      let f = UJ(g.target.value);
      const m = ZCe(f);
      f.length > qCe || (f = VCe(f, HJ[m]), g.target.value = f, i(f));
    }
    return s.code === "+55" ? /* @__PURE__ */ ni.jsx(
      "input",
      {
        value: a,
        onChange: d,
        className: p,
        onFocus: n,
        onBlur: r,
        disabled: l,
        ref: t
      }
    ) : /* @__PURE__ */ ni.jsx(
      ol,
      {
        value: a,
        onChange: (g) => i(g.target.value),
        className: p,
        component: GCe,
        onFocus: n,
        onBlur: r,
        disabled: l,
        mask: s.mask,
        showMask: !0,
        replacement: { _: /\d/ },
        ref: t
      }
    );
  }
);
$e({});
var sl = {};
Object.defineProperty(sl, "__esModule", {
  value: !0
});
var KCe = typeof window < "u" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform), Wx = {
  alt: "altKey",
  control: "ctrlKey",
  meta: "metaKey",
  shift: "shiftKey"
}, WJ = {
  add: "+",
  break: "pause",
  cmd: "meta",
  command: "meta",
  ctl: "control",
  ctrl: "control",
  del: "delete",
  down: "arrowdown",
  esc: "escape",
  ins: "insert",
  left: "arrowleft",
  mod: KCe ? "meta" : "control",
  opt: "alt",
  option: "alt",
  return: "enter",
  right: "arrowright",
  space: " ",
  spacebar: " ",
  up: "arrowup",
  win: "meta",
  windows: "meta"
}, hD = {
  backspace: 8,
  tab: 9,
  enter: 13,
  shift: 16,
  control: 17,
  alt: 18,
  pause: 19,
  capslock: 20,
  escape: 27,
  " ": 32,
  pageup: 33,
  pagedown: 34,
  end: 35,
  home: 36,
  arrowleft: 37,
  arrowup: 38,
  arrowright: 39,
  arrowdown: 40,
  insert: 45,
  delete: 46,
  meta: 91,
  numlock: 144,
  scrolllock: 145,
  ";": 186,
  "=": 187,
  ",": 188,
  "-": 189,
  ".": 190,
  "/": 191,
  "`": 192,
  "[": 219,
  "\\": 220,
  "]": 221,
  "'": 222
};
for (var $m = 1; $m < 20; $m++)
  hD["f" + $m] = 111 + $m;
function $C(e, t, n) {
  t && !("byKey" in t) && (n = t, t = null), Array.isArray(e) || (e = [e]);
  var r = e.map(function(a) {
    return $J(a, t);
  }), o = function(a) {
    return r.some(function(s) {
      return VJ(s, a);
    });
  }, i = n == null ? o : o(n);
  return i;
}
function XCe(e, t) {
  return $C(e, t);
}
function YCe(e, t) {
  return $C(e, { byKey: !0 }, t);
}
function $J(e, t) {
  var n = t && t.byKey, r = {};
  e = e.replace("++", "+add");
  var o = e.split("+"), i = o.length;
  for (var a in Wx)
    r[Wx[a]] = !1;
  var s = !0, l = !1, u = void 0;
  try {
    for (var c = o[Symbol.iterator](), p; !(s = (p = c.next()).done); s = !0) {
      var d = p.value, g = d.endsWith("?") && d.length > 1;
      g && (d = d.slice(0, -1));
      var f = gD(d), m = Wx[f];
      if (d.length > 1 && !m && !WJ[d] && !hD[f])
        throw new TypeError('Unknown modifier: "' + d + '"');
      (i === 1 || !m) && (n ? r.key = f : r.which = ZJ(d)), m && (r[m] = g ? null : !0);
    }
  } catch (b) {
    l = !0, u = b;
  } finally {
    try {
      !s && c.return && c.return();
    } finally {
      if (l)
        throw u;
    }
  }
  return r;
}
function VJ(e, t) {
  for (var n in e) {
    var r = e[n], o = void 0;
    if (r != null && (n === "key" && t.key != null ? o = t.key.toLowerCase() : n === "which" ? o = r === 91 && t.which === 93 ? 91 : t.which : o = t[n], !(o == null && r === !1) && o !== r))
      return !1;
  }
  return !0;
}
function ZJ(e) {
  e = gD(e);
  var t = hD[e] || e.toUpperCase().charCodeAt(0);
  return t;
}
function gD(e) {
  return e = e.toLowerCase(), e = WJ[e] || e, e;
}
sl.default = $C;
var $x = sl.isHotkey = $C;
sl.isCodeHotkey = XCe;
sl.isKeyHotkey = YCe;
sl.parseHotkey = $J;
sl.compareHotkey = VJ;
sl.toKeyCode = ZJ;
sl.toKeyName = gD;
var JCe = typeof wr == "object" && wr && wr.Object === Object && wr, QCe = JCe, eOe = QCe, tOe = typeof self == "object" && self && self.Object === Object && self, nOe = eOe || tOe || Function("return this")(), rOe = nOe, oOe = rOe, iOe = oOe.Symbol, qJ = iOe, dF = qJ;
dF && dF.toStringTag;
var fF = qJ;
fF && fF.toStringTag;
var hF;
(function(e) {
  e.BORDER_BOX = "border-box", e.CONTENT_BOX = "content-box", e.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(hF || (hF = {}));
var mD = function(e) {
  return Object.freeze(e);
}, sOe = /* @__PURE__ */ function() {
  function e(t, n) {
    this.inlineSize = t, this.blockSize = n, mD(this);
  }
  return e;
}(), aOe = function() {
  function e(t, n, r, o) {
    return this.x = t, this.y = n, this.width = r, this.height = o, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, mD(this);
  }
  return e.prototype.toJSON = function() {
    var t = this, n = t.x, r = t.y, o = t.top, i = t.right, a = t.bottom, s = t.left, l = t.width, u = t.height;
    return { x: n, y: r, top: o, right: i, bottom: a, left: s, width: l, height: u };
  }, e.fromRect = function(t) {
    return new e(t.x, t.y, t.width, t.height);
  }, e;
}(), gF = typeof window < "u" ? window : {};
/msie|trident/i.test(gF.navigator && gF.navigator.userAgent);
var Vx = function(e, t, n) {
  return e === void 0 && (e = 0), t === void 0 && (t = 0), n === void 0 && (n = !1), new sOe((n ? t : e) || 0, (n ? e : t) || 0);
};
mD({
  devicePixelContentBoxSize: Vx(),
  borderBoxSize: Vx(),
  contentBoxSize: Vx(),
  contentRect: new aOe(0, 0, 0, 0)
});
function _h(e) {
  "@babel/helpers - typeof";
  return _h = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, _h(e);
}
function lOe(e, t) {
  if (_h(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (_h(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function uOe(e) {
  var t = lOe(e, "string");
  return _h(t) === "symbol" ? t : String(t);
}
function Of(e, t, n) {
  return t = uOe(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
var cOe = /* @__PURE__ */ $e(null), Zx, qx;
parseInt(be.version.split(".")[0], 10);
var mF = typeof navigator < "u" && /Mac OS X/.test(navigator.userAgent), Gx = typeof navigator < "u" && /Android/.test(navigator.userAgent), Vm = typeof navigator < "u" && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent), pOe = typeof navigator < "u" && /Chrome/i.test(navigator.userAgent);
typeof navigator < "u" && /Safari/.test(navigator.userAgent) && /Version\/(\d+)/.test(navigator.userAgent) && (Zx = navigator.userAgent.match(/Version\/(\d+)/)) !== null && Zx !== void 0 && Zx[1] && parseInt((qx = navigator.userAgent.match(/Version\/(\d+)/)) === null || qx === void 0 ? void 0 : qx[1], 10) < 17;
var dOe = /* @__PURE__ */ new WeakMap(), fOe = /* @__PURE__ */ new WeakMap(), hOe = /* @__PURE__ */ new WeakMap(), gOe = /* @__PURE__ */ new WeakMap(), mOe = /* @__PURE__ */ new WeakMap(), vF = /* @__PURE__ */ new WeakMap(), vOe = /* @__PURE__ */ new WeakMap(), yF = /* @__PURE__ */ new WeakMap(), Zm = /* @__PURE__ */ new WeakMap(), yOe = /* @__PURE__ */ new WeakMap(), bOe = /* @__PURE__ */ new WeakMap(), wOe = /* @__PURE__ */ new WeakMap(), GJ = globalThis.Node, COe = globalThis.Text, KJ = (e) => e && e.ownerDocument && e.ownerDocument.defaultView || null, OOe = (e) => _b(e) && e.nodeType === 8, ua = (e) => _b(e) && e.nodeType === 1, _b = (e) => {
  var t = KJ(e);
  return !!t && e instanceof t.Node;
}, bF = (e) => {
  var t = e && e.anchorNode && KJ(e.anchorNode);
  return !!t && e instanceof t.Selection;
}, xOe = (e) => {
  var [t, n] = e;
  if (ua(t) && t.childNodes.length) {
    var r = n === t.childNodes.length, o = r ? n - 1 : n;
    for ([t, o] = XJ(t, o, r ? "backward" : "forward"), r = o < n; ua(t) && t.childNodes.length; ) {
      var i = r ? t.childNodes.length - 1 : 0;
      t = kOe(t, i, r ? "backward" : "forward");
    }
    n = r && t.textContent != null ? t.textContent.length : 0;
  }
  return [t, n];
}, EOe = (e) => {
  for (var t = e && e.parentNode; t; ) {
    if (t.toString() === "[object ShadowRoot]")
      return !0;
    t = t.parentNode;
  }
  return !1;
}, XJ = (e, t, n) => {
  for (var {
    childNodes: r
  } = e, o = r[t], i = t, a = !1, s = !1; (OOe(o) || ua(o) && o.childNodes.length === 0 || ua(o) && o.getAttribute("contenteditable") === "false") && !(a && s); ) {
    if (i >= r.length) {
      a = !0, i = t - 1, n = "backward";
      continue;
    }
    if (i < 0) {
      s = !0, i = t + 1, n = "forward";
      continue;
    }
    o = r[i], t = i, i += n === "forward" ? 1 : -1;
  }
  return [o, t];
}, kOe = (e, t, n) => {
  var [r] = XJ(e, t, n);
  return r;
}, wF = (e) => e.getSelection != null ? e.getSelection() : document.getSelection(), YJ = (e, t, n) => {
  var {
    target: r
  } = t;
  if (ua(r) && r.matches('[contentEditable="false"]'))
    return !1;
  var {
    document: o
  } = cn.getWindow(e);
  if (o.contains(r))
    return cn.hasDOMNode(e, r, {
      editable: !0
    });
  var i = n.find((a) => {
    var {
      addedNodes: s,
      removedNodes: l
    } = a;
    for (var u of s)
      if (u === r || u.contains(r))
        return !0;
    for (var c of l)
      if (c === r || c.contains(r))
        return !0;
  });
  return !i || i === t ? !1 : YJ(e, i, n);
}, CF = (e, t) => !!(e.compareDocumentPosition(t) & GJ.DOCUMENT_POSITION_PRECEDING), LOe = (e, t) => !!(e.compareDocumentPosition(t) & GJ.DOCUMENT_POSITION_FOLLOWING), _Oe = 0;
class POe {
  constructor() {
    Of(this, "id", void 0), this.id = "".concat(_Oe++);
  }
}
var cn = {
  androidPendingDiffs: (e) => wOe.get(e),
  androidScheduleFlush: (e) => {
    var t;
    (t = bOe.get(e)) === null || t === void 0 || t();
  },
  blur: (e) => {
    var t = cn.toDOMNode(e, e), n = cn.findDocumentOrShadowRoot(e);
    Zm.set(e, !1), n.activeElement === t && t.blur();
  },
  deselect: (e) => {
    var {
      selection: t
    } = e, n = cn.findDocumentOrShadowRoot(e), r = wF(n);
    r && r.rangeCount > 0 && r.removeAllRanges(), t && kb.deselect(e);
  },
  findDocumentOrShadowRoot: (e) => {
    var t = cn.toDOMNode(e, e), n = t.getRootNode();
    return n instanceof Document || n instanceof ShadowRoot ? n : t.ownerDocument;
  },
  findEventRange: (e, t) => {
    "nativeEvent" in t && (t = t.nativeEvent);
    var {
      clientX: n,
      clientY: r,
      target: o
    } = t;
    if (n == null || r == null)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var i = cn.toSlateNode(e, t.target), a = cn.findPath(e, i);
    if (qa.isElement(i) && dr.isVoid(e, i)) {
      var s = o.getBoundingClientRect(), l = e.isInline(i) ? n - s.left < s.left + s.width - n : r - s.top < s.top + s.height - r, u = dr.point(e, a, {
        edge: l ? "start" : "end"
      }), c = l ? dr.before(e, u) : dr.after(e, u);
      if (c) {
        var p = dr.range(e, c);
        return p;
      }
    }
    var d, {
      document: g
    } = cn.getWindow(e);
    if (g.caretRangeFromPoint)
      d = g.caretRangeFromPoint(n, r);
    else {
      var f = g.caretPositionFromPoint(n, r);
      f && (d = g.createRange(), d.setStart(f.offsetNode, f.offset), d.setEnd(f.offsetNode, f.offset));
    }
    if (!d)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var m = cn.toSlateRange(e, d, {
      exactMatch: !1,
      suppressThrow: !1
    });
    return m;
  },
  findKey: (e, t) => {
    var n = vF.get(t);
    return n || (n = new POe(), vF.set(t, n)), n;
  },
  findPath: (e, t) => {
    for (var n = [], r = t; ; ) {
      var o = fOe.get(r);
      if (o == null) {
        if (dr.isEditor(r))
          return n;
        break;
      }
      var i = dOe.get(r);
      if (i == null)
        break;
      n.unshift(i), r = o;
    }
    throw new Error("Unable to find the path for Slate node: ".concat(us.stringify(t)));
  },
  focus: function(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      retries: 5
    };
    if (!Zm.get(e)) {
      if (t.retries <= 0)
        throw new Error("Could not set focus, editor seems stuck with pending operations");
      if (e.operations.length > 0) {
        setTimeout(() => {
          cn.focus(e, {
            retries: t.retries - 1
          });
        }, 10);
        return;
      }
      var n = cn.toDOMNode(e, e), r = cn.findDocumentOrShadowRoot(e);
      if (r.activeElement !== n) {
        if (e.selection && r instanceof Document) {
          var o = wF(r), i = cn.toDOMRange(e, e.selection);
          o == null || o.removeAllRanges(), o == null || o.addRange(i);
        }
        e.selection || kb.select(e, dr.start(e, [])), Zm.set(e, !0), n.focus({
          preventScroll: !0
        });
      }
    }
  },
  getWindow: (e) => {
    var t = hOe.get(e);
    if (!t)
      throw new Error("Unable to find a host window element for this editor");
    return t;
  },
  hasDOMNode: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      editable: r = !1
    } = n, o = cn.toDOMNode(e, e), i;
    try {
      i = ua(t) ? t : t.parentElement;
    } catch (a) {
      if (a instanceof Error && !a.message.includes('Permission denied to access property "nodeType"'))
        throw a;
    }
    return i ? i.closest("[data-slate-editor]") === o && (!r || i.isContentEditable ? !0 : typeof i.isContentEditable == "boolean" && // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined
    // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable="false"(readOnly)
    i.closest('[contenteditable="false"]') === o || !!i.getAttribute("data-slate-zero-width")) : !1;
  },
  hasEditableTarget: (e, t) => _b(t) && cn.hasDOMNode(e, t, {
    editable: !0
  }),
  hasRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t;
    return dr.hasPath(e, n.path) && dr.hasPath(e, r.path);
  },
  hasSelectableTarget: (e, t) => cn.hasEditableTarget(e, t) || cn.isTargetInsideNonReadonlyVoid(e, t),
  hasTarget: (e, t) => _b(t) && cn.hasDOMNode(e, t),
  insertData: (e, t) => {
    e.insertData(t);
  },
  insertFragmentData: (e, t) => e.insertFragmentData(t),
  insertTextData: (e, t) => e.insertTextData(t),
  isComposing: (e) => !!yOe.get(e),
  isFocused: (e) => !!Zm.get(e),
  isReadOnly: (e) => !!yF.get(e),
  isTargetInsideNonReadonlyVoid: (e, t) => {
    if (yF.get(e)) return !1;
    var n = cn.hasTarget(e, t) && cn.toSlateNode(e, t);
    return qa.isElement(n) && dr.isVoid(e, n);
  },
  setFragmentData: (e, t, n) => e.setFragmentData(t, n),
  toDOMNode: (e, t) => {
    var n = vOe.get(e), r = dr.isEditor(t) ? gOe.get(e) : n == null ? void 0 : n.get(cn.findKey(e, t));
    if (!r)
      throw new Error("Cannot resolve a DOM node from Slate node: ".concat(us.stringify(t)));
    return r;
  },
  toDOMPoint: (e, t) => {
    var [n] = dr.node(e, t.path), r = cn.toDOMNode(e, n), o;
    dr.void(e, {
      at: t
    }) && (t = {
      path: t.path,
      offset: 0
    });
    for (var i = "[data-slate-string], [data-slate-zero-width]", a = Array.from(r.querySelectorAll(i)), s = 0, l = 0; l < a.length; l++) {
      var u = a[l], c = u.childNodes[0];
      if (!(c == null || c.textContent == null)) {
        var {
          length: p
        } = c.textContent, d = u.getAttribute("data-slate-length"), g = d == null ? p : parseInt(d, 10), f = s + g, m = a[l + 1];
        if (t.offset === f && m !== null && m !== void 0 && m.hasAttribute("data-slate-mark-placeholder")) {
          var b, E = m.childNodes[0];
          o = [
            // COMPAT: If we don't explicity set the dom point to be on the actual
            // dom text element, chrome will put the selection behind the actual dom
            // text element, causing domRange.getBoundingClientRect() calls on a collapsed
            // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)
            // which will cause issues when scrolling to it.
            E instanceof COe ? E : m,
            (b = m.textContent) !== null && b !== void 0 && b.startsWith("\uFEFF") ? 1 : 0
          ];
          break;
        }
        if (t.offset <= f) {
          var w = Math.min(p, Math.max(0, t.offset - s));
          o = [c, w];
          break;
        }
        s = f;
      }
    }
    if (!o)
      throw new Error("Cannot resolve a DOM point from Slate point: ".concat(us.stringify(t)));
    return o;
  },
  toDOMRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t, o = Yt.isBackward(t), i = cn.toDOMPoint(e, n), a = Yt.isCollapsed(t) ? i : cn.toDOMPoint(e, r), s = cn.getWindow(e), l = s.document.createRange(), [u, c] = o ? a : i, [p, d] = o ? i : a, g = ua(u) ? u : u.parentElement, f = !!g.getAttribute("data-slate-zero-width"), m = ua(p) ? p : p.parentElement, b = !!m.getAttribute("data-slate-zero-width");
    return l.setStart(u, f ? 1 : c), l.setEnd(p, b ? 1 : d), l;
  },
  toSlateNode: (e, t) => {
    var n = ua(t) ? t : t.parentElement;
    n && !n.hasAttribute("data-slate-node") && (n = n.closest("[data-slate-node]"));
    var r = n ? mOe.get(n) : null;
    if (!r)
      throw new Error("Cannot resolve a Slate node from DOM node: ".concat(n));
    return r;
  },
  toSlatePoint: (e, t, n) => {
    var {
      exactMatch: r,
      suppressThrow: o,
      searchDirection: i = "backward"
    } = n, [a, s] = r ? t : xOe(t), l = a.parentNode, u = null, c = 0;
    if (l) {
      var p, d, g = cn.toDOMNode(e, e), f = l.closest('[data-slate-void="true"]'), m = f && g.contains(f) ? f : null, b = l.closest('[contenteditable="false"]'), E = b && g.contains(b) ? b : null, w = l.closest("[data-slate-leaf]"), M = null;
      if (w) {
        if (u = w.closest('[data-slate-node="text"]'), u) {
          var x = cn.getWindow(e), v = x.document.createRange();
          v.setStart(u, 0), v.setEnd(a, s);
          var C = v.cloneContents(), P = [...Array.prototype.slice.call(C.querySelectorAll("[data-slate-zero-width]")), ...Array.prototype.slice.call(C.querySelectorAll("[contenteditable=false]"))];
          P.forEach((S) => {
            if (Gx && !r && S.hasAttribute("data-slate-zero-width") && S.textContent.length > 0 && S.textContext !== "\uFEFF") {
              S.textContent.startsWith("\uFEFF") && (S.textContent = S.textContent.slice(1));
              return;
            }
            S.parentNode.removeChild(S);
          }), c = C.textContent.length, M = u;
        }
      } else if (m) {
        for (var F = m.querySelectorAll("[data-slate-leaf]"), L = 0; L < F.length; L++) {
          var B = F[L];
          if (cn.hasDOMNode(e, B)) {
            w = B;
            break;
          }
        }
        w ? (u = w.closest('[data-slate-node="text"]'), M = w, c = M.textContent.length, M.querySelectorAll("[data-slate-zero-width]").forEach((S) => {
          c -= S.textContent.length;
        })) : c = 1;
      } else if (E) {
        var N = (S) => S ? S.querySelectorAll(
          // Exclude leaf nodes in nested editors
          "[data-slate-leaf]:not(:scope [data-slate-editor] [data-slate-leaf])"
        ) : [], $ = E.closest('[data-slate-node="element"]');
        if (i === "forward") {
          var V, H = [...N($), ...N($ == null ? void 0 : $.nextElementSibling)];
          w = (V = H.find((S) => LOe(E, S))) !== null && V !== void 0 ? V : null;
        } else {
          var Z, K = [...N($ == null ? void 0 : $.previousElementSibling), ...N($)];
          w = (Z = K.findLast((S) => CF(E, S))) !== null && Z !== void 0 ? Z : null;
        }
        w && (u = w.closest('[data-slate-node="text"]'), M = w, i === "forward" ? c = 0 : (c = M.textContent.length, M.querySelectorAll("[data-slate-zero-width]").forEach((S) => {
          c -= S.textContent.length;
        })));
      }
      M && c === M.textContent.length && // COMPAT: Android IMEs might remove the zero width space while composing,
      // and we don't add it for line-breaks.
      Gx && M.getAttribute("data-slate-zero-width") === "z" && (p = M.textContent) !== null && p !== void 0 && p.startsWith("\uFEFF") && // COMPAT: If the parent node is a Slate zero-width space, editor is
      // because the text node should have no characters. However, during IME
      // composition the ASCII characters will be prepended to the zero-width
      // space, so subtract 1 from the offset to account for the zero-width
      // space character.
      (l.hasAttribute("data-slate-zero-width") || // COMPAT: In Firefox, `range.cloneContents()` returns an extra trailing '\n'
      // when the document ends with a new-line character. This results in the offset
      // length being off by one, so we need to subtract one to account for this.
      Vm && (d = M.textContent) !== null && d !== void 0 && d.endsWith(`

`)) && c--;
    }
    if (Gx && !u && !r) {
      var Y = l.hasAttribute("data-slate-node") ? l : l.closest("[data-slate-node]");
      if (Y && cn.hasDOMNode(e, Y, {
        editable: !0
      })) {
        var Q = cn.toSlateNode(e, Y), {
          path: J,
          offset: _
        } = dr.start(e, cn.findPath(e, Q));
        return Y.querySelector("[data-slate-leaf]") || (_ = s), {
          path: J,
          offset: _
        };
      }
    }
    if (!u) {
      if (o)
        return null;
      throw new Error("Cannot resolve a Slate point from DOM point: ".concat(t));
    }
    var D = cn.toSlateNode(e, u), z = cn.findPath(e, D);
    return {
      path: z,
      offset: c
    };
  },
  toSlateRange: (e, t, n) => {
    var r, {
      exactMatch: o,
      suppressThrow: i
    } = n, a = bF(t) ? t.anchorNode : t.startContainer, s, l, u, c, p;
    if (a)
      if (bF(t)) {
        if (Vm && t.rangeCount > 1) {
          u = t.focusNode;
          var d = t.getRangeAt(0), g = t.getRangeAt(t.rangeCount - 1);
          if (u instanceof HTMLTableRowElement && d.startContainer instanceof HTMLTableRowElement && g.startContainer instanceof HTMLTableRowElement) {
            let C = function(P) {
              return P.childElementCount > 0 ? C(P.children[0]) : P;
            };
            var f = d.startContainer, m = g.startContainer, b = C(f.children[d.startOffset]), E = C(m.children[g.startOffset]);
            c = 0, E.childNodes.length > 0 ? s = E.childNodes[0] : s = E, b.childNodes.length > 0 ? u = b.childNodes[0] : u = b, E instanceof HTMLElement ? l = E.innerHTML.length : l = 0;
          } else
            d.startContainer === u ? (s = g.endContainer, l = g.endOffset, c = d.startOffset) : (s = d.startContainer, l = d.endOffset, c = g.startOffset);
        } else
          s = t.anchorNode, l = t.anchorOffset, u = t.focusNode, c = t.focusOffset;
        pOe && EOe(s) || Vm ? p = t.anchorNode === t.focusNode && t.anchorOffset === t.focusOffset : p = t.isCollapsed;
      } else
        s = t.startContainer, l = t.startOffset, u = t.endContainer, c = t.endOffset, p = t.collapsed;
    if (s == null || u == null || l == null || c == null)
      throw new Error("Cannot resolve a Slate range from DOM range: ".concat(t));
    Vm && (r = u.textContent) !== null && r !== void 0 && r.endsWith(`

`) && c === u.textContent.length && c--;
    var w = cn.toSlatePoint(e, [s, l], {
      exactMatch: o,
      suppressThrow: i
    });
    if (!w)
      return null;
    var M = CF(s, u) || s === u && c < l, x = p ? w : cn.toSlatePoint(e, [u, c], {
      exactMatch: o,
      suppressThrow: i,
      searchDirection: M ? "forward" : "backward"
    });
    if (!x)
      return null;
    var v = {
      anchor: w,
      focus: x
    };
    return Yt.isExpanded(v) && Yt.isForward(v) && ua(u) && dr.void(e, {
      at: v.focus,
      mode: "highest"
    }) && (v = dr.unhangRange(e, v, {
      voids: !0
    })), v;
  }
}, SOe = {
  bold: "mod+b",
  compose: ["down", "left", "right", "up", "backspace", "enter"],
  moveBackward: "left",
  moveForward: "right",
  moveWordBackward: "ctrl+left",
  moveWordForward: "ctrl+right",
  deleteBackward: "shift?+backspace",
  deleteForward: "shift?+delete",
  extendBackward: "shift+left",
  extendForward: "shift+right",
  italic: "mod+i",
  insertSoftBreak: "shift+enter",
  splitBlock: "enter",
  undo: "mod+z"
}, MOe = {
  moveLineBackward: "opt+up",
  moveLineForward: "opt+down",
  moveWordBackward: "opt+left",
  moveWordForward: "opt+right",
  deleteBackward: ["ctrl+backspace", "ctrl+h"],
  deleteForward: ["ctrl+delete", "ctrl+d"],
  deleteLineBackward: "cmd+shift?+backspace",
  deleteLineForward: ["cmd+shift?+delete", "ctrl+k"],
  deleteWordBackward: "opt+shift?+backspace",
  deleteWordForward: "opt+shift?+delete",
  extendLineBackward: "opt+shift+up",
  extendLineForward: "opt+shift+down",
  redo: "cmd+shift+z",
  transposeCharacter: "ctrl+t"
}, DOe = {
  deleteWordBackward: "ctrl+shift?+backspace",
  deleteWordForward: "ctrl+shift?+delete",
  redo: ["ctrl+y", "ctrl+shift+z"]
}, $r = (e) => {
  var t = SOe[e], n = MOe[e], r = DOe[e], o = t && $x(t), i = n && $x(n), a = r && $x(r);
  return (s) => !!(o && o(s) || mF && i && i(s) || !mF && a && a(s));
};
$r("bold"), $r("compose"), $r("moveBackward"), $r("moveForward"), $r("deleteBackward"), $r("deleteForward"), $r("deleteLineBackward"), $r("deleteLineForward"), $r("deleteWordBackward"), $r("deleteWordForward"), $r("extendBackward"), $r("extendForward"), $r("extendLineBackward"), $r("extendLineForward"), $r("italic"), $r("moveLineBackward"), $r("moveLineForward"), $r("moveWordBackward"), $r("moveWordForward"), $r("redo"), $r("insertSoftBreak"), $r("splitBlock"), $r("transposeCharacter"), $r("undo");
var TOe = (e, t) => {
  var n = [], r = () => {
    n = [];
  }, o = (a) => {
    if (t.current) {
      var s = a.filter((l) => YJ(e, l, a));
      n.push(...s);
    }
  };
  function i() {
    n.length > 0 && (n.reverse().forEach((a) => {
      a.type !== "characterData" && (a.removedNodes.forEach((s) => {
        a.target.insertBefore(s, a.nextSibling);
      }), a.addedNodes.forEach((s) => {
        a.target.removeChild(s);
      }));
    }), r());
  }
  return {
    registerMutations: o,
    restoreDOM: i,
    clear: r
  };
}, jOe = {
  subtree: !0,
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0
};
class AOe extends au {
  constructor() {
    super(...arguments), Of(this, "context", null), Of(this, "manager", null), Of(this, "mutationObserver", null);
  }
  observe() {
    var t, {
      node: n
    } = this.props;
    if (!n.current)
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    (t = this.mutationObserver) === null || t === void 0 || t.observe(n.current, jOe);
  }
  componentDidMount() {
    var {
      receivedUserInput: t
    } = this.props, n = this.context;
    this.manager = TOe(n, t), this.mutationObserver = new MutationObserver(this.manager.registerMutations), this.observe();
  }
  getSnapshotBeforeUpdate() {
    var t, n, r, o = (t = this.mutationObserver) === null || t === void 0 ? void 0 : t.takeRecords();
    if (o != null && o.length) {
      var i;
      (i = this.manager) === null || i === void 0 || i.registerMutations(o);
    }
    return (n = this.mutationObserver) === null || n === void 0 || n.disconnect(), (r = this.manager) === null || r === void 0 || r.restoreDOM(), null;
  }
  componentDidUpdate() {
    var t;
    (t = this.manager) === null || t === void 0 || t.clear(), this.observe();
  }
  componentWillUnmount() {
    var t;
    (t = this.mutationObserver) === null || t === void 0 || t.disconnect();
  }
  render() {
    return this.props.children;
  }
}
Of(AOe, "contextType", cOe);
$e({});
$e({});
$e({});
var jo = {}, vD = {}, qh = {}, Gh = {}, JJ = "Expected a function", OF = NaN, ROe = "[object Symbol]", IOe = /^\s+|\s+$/g, NOe = /^[-+]0x[0-9a-f]+$/i, BOe = /^0b[01]+$/i, FOe = /^0o[0-7]+$/i, zOe = parseInt, UOe = typeof wr == "object" && wr && wr.Object === Object && wr, HOe = typeof self == "object" && self && self.Object === Object && self, WOe = UOe || HOe || Function("return this")(), $Oe = Object.prototype, VOe = $Oe.toString, ZOe = Math.max, qOe = Math.min, Kx = function() {
  return WOe.Date.now();
};
function GOe(e, t, n) {
  var r, o, i, a, s, l, u = 0, c = !1, p = !1, d = !0;
  if (typeof e != "function")
    throw new TypeError(JJ);
  t = xF(t) || 0, Pb(n) && (c = !!n.leading, p = "maxWait" in n, i = p ? ZOe(xF(n.maxWait) || 0, t) : i, d = "trailing" in n ? !!n.trailing : d);
  function g(C) {
    var P = r, F = o;
    return r = o = void 0, u = C, a = e.apply(F, P), a;
  }
  function f(C) {
    return u = C, s = setTimeout(E, t), c ? g(C) : a;
  }
  function m(C) {
    var P = C - l, F = C - u, L = t - P;
    return p ? qOe(L, i - F) : L;
  }
  function b(C) {
    var P = C - l, F = C - u;
    return l === void 0 || P >= t || P < 0 || p && F >= i;
  }
  function E() {
    var C = Kx();
    if (b(C))
      return w(C);
    s = setTimeout(E, m(C));
  }
  function w(C) {
    return s = void 0, d && r ? g(C) : (r = o = void 0, a);
  }
  function M() {
    s !== void 0 && clearTimeout(s), u = 0, r = l = o = s = void 0;
  }
  function x() {
    return s === void 0 ? a : w(Kx());
  }
  function v() {
    var C = Kx(), P = b(C);
    if (r = arguments, o = this, l = C, P) {
      if (s === void 0)
        return f(l);
      if (p)
        return s = setTimeout(E, t), g(l);
    }
    return s === void 0 && (s = setTimeout(E, t)), a;
  }
  return v.cancel = M, v.flush = x, v;
}
function KOe(e, t, n) {
  var r = !0, o = !0;
  if (typeof e != "function")
    throw new TypeError(JJ);
  return Pb(n) && (r = "leading" in n ? !!n.leading : r, o = "trailing" in n ? !!n.trailing : o), GOe(e, t, {
    leading: r,
    maxWait: t,
    trailing: o
  });
}
function Pb(e) {
  var t = typeof e;
  return !!e && (t == "object" || t == "function");
}
function XOe(e) {
  return !!e && typeof e == "object";
}
function YOe(e) {
  return typeof e == "symbol" || XOe(e) && VOe.call(e) == ROe;
}
function xF(e) {
  if (typeof e == "number")
    return e;
  if (YOe(e))
    return OF;
  if (Pb(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = Pb(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = e.replace(IOe, "");
  var n = BOe.test(e);
  return n || FOe.test(e) ? zOe(e.slice(2), n ? 2 : 8) : NOe.test(e) ? OF : +e;
}
var JOe = KOe, Kh = {};
Object.defineProperty(Kh, "__esModule", {
  value: !0
});
Kh.addPassiveEventListener = function(e, t, n) {
  var r = n.name;
  r || (r = t, console.warn("Listener must be a named function.")), Ly.has(t) || Ly.set(t, /* @__PURE__ */ new Set());
  var o = Ly.get(t);
  if (!o.has(r)) {
    var i = function() {
      var a = !1;
      try {
        var s = Object.defineProperty({}, "passive", {
          get: function() {
            a = !0;
          }
        });
        window.addEventListener("test", null, s);
      } catch {
      }
      return a;
    }();
    e.addEventListener(t, n, i ? { passive: !0 } : !1), o.add(r);
  }
};
Kh.removePassiveEventListener = function(e, t, n) {
  e.removeEventListener(t, n), Ly.get(t).delete(n.name || t);
};
var Ly = /* @__PURE__ */ new Map();
Object.defineProperty(Gh, "__esModule", {
  value: !0
});
var QOe = JOe, exe = txe(QOe), EF = Kh;
function txe(e) {
  return e && e.__esModule ? e : { default: e };
}
var nxe = function(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 66;
  return (0, exe.default)(e, t);
}, uo = {
  spyCallbacks: [],
  spySetState: [],
  scrollSpyContainers: [],
  mount: function(e, t) {
    if (e) {
      var n = nxe(function(r) {
        uo.scrollHandler(e);
      }, t);
      return uo.scrollSpyContainers.push(e), (0, EF.addPassiveEventListener)(e, "scroll", n), function() {
        (0, EF.removePassiveEventListener)(e, "scroll", n), uo.scrollSpyContainers.splice(uo.scrollSpyContainers.indexOf(e), 1);
      };
    }
    return function() {
    };
  },
  isMounted: function(e) {
    return uo.scrollSpyContainers.indexOf(e) !== -1;
  },
  currentPositionX: function(e) {
    if (e === document) {
      var t = window.scrollY !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.scrollX : n ? document.documentElement.scrollLeft : document.body.scrollLeft;
    } else
      return e.scrollLeft;
  },
  currentPositionY: function(e) {
    if (e === document) {
      var t = window.scrollX !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.scrollY : n ? document.documentElement.scrollTop : document.body.scrollTop;
    } else
      return e.scrollTop;
  },
  scrollHandler: function(e) {
    var t = uo.scrollSpyContainers[uo.scrollSpyContainers.indexOf(e)].spyCallbacks || [];
    t.forEach(function(n) {
      return n(uo.currentPositionX(e), uo.currentPositionY(e));
    });
  },
  addStateHandler: function(e) {
    uo.spySetState.push(e);
  },
  addSpyHandler: function(e, t) {
    var n = uo.scrollSpyContainers[uo.scrollSpyContainers.indexOf(t)];
    n.spyCallbacks || (n.spyCallbacks = []), n.spyCallbacks.push(e);
  },
  updateStates: function() {
    uo.spySetState.forEach(function(e) {
      return e();
    });
  },
  unmount: function(e, t) {
    uo.scrollSpyContainers.forEach(function(n) {
      return n.spyCallbacks && n.spyCallbacks.length && n.spyCallbacks.indexOf(t) > -1 && n.spyCallbacks.splice(n.spyCallbacks.indexOf(t), 1);
    }), uo.spySetState && uo.spySetState.length && uo.spySetState.indexOf(e) > -1 && uo.spySetState.splice(uo.spySetState.indexOf(e), 1), document.removeEventListener("scroll", uo.scrollHandler);
  },
  update: function() {
    return uo.scrollSpyContainers.forEach(function(e) {
      return uo.scrollHandler(e);
    });
  }
};
Gh.default = uo;
var Bp = {}, Xh = {};
Object.defineProperty(Xh, "__esModule", {
  value: !0
});
var rxe = function(e, t) {
  var n = e.indexOf("#") === 0 ? e.substring(1) : e, r = n ? "#" + n : "", o = window && window.location, i = r ? o.pathname + o.search + r : o.pathname + o.search;
  t ? history.pushState(history.state, "", i) : history.replaceState(history.state, "", i);
}, oxe = function() {
  return window.location.hash.replace(/^#/, "");
}, ixe = function(e) {
  return function(t) {
    return e.contains ? e != t && e.contains(t) : !!(e.compareDocumentPosition(t) & 16);
  };
}, sxe = function(e) {
  return getComputedStyle(e).position !== "static";
}, Xx = function(e, t) {
  for (var n = e.offsetTop, r = e.offsetParent; r && !t(r); )
    n += r.offsetTop, r = r.offsetParent;
  return { offsetTop: n, offsetParent: r };
}, axe = function(e, t, n) {
  if (n)
    return e === document ? t.getBoundingClientRect().left + (window.scrollX || window.pageXOffset) : getComputedStyle(e).position !== "static" ? t.offsetLeft : t.offsetLeft - e.offsetLeft;
  if (e === document)
    return t.getBoundingClientRect().top + (window.scrollY || window.pageYOffset);
  if (sxe(e)) {
    if (t.offsetParent !== e) {
      var r = function(l) {
        return l === e || l === document;
      }, o = Xx(t, r), i = o.offsetTop, a = o.offsetParent;
      if (a !== e)
        throw new Error("Seems containerElement is not an ancestor of the Element");
      return i;
    }
    return t.offsetTop;
  }
  if (t.offsetParent === e.offsetParent)
    return t.offsetTop - e.offsetTop;
  var s = function(l) {
    return l === document;
  };
  return Xx(t, s).offsetTop - Xx(e, s).offsetTop;
};
Xh.default = {
  updateHash: rxe,
  getHash: oxe,
  filterElementInContainer: ixe,
  scrollOffset: axe
};
var VC = {}, yD = {};
Object.defineProperty(yD, "__esModule", {
  value: !0
});
yD.default = {
  /*
   * https://github.com/oblador/angular-scroll (duScrollDefaultEasing)
   */
  defaultEasing: function(e) {
    return e < 0.5 ? Math.pow(e * 2, 2) / 2 : 1 - Math.pow((1 - e) * 2, 2) / 2;
  },
  /*
   * https://gist.github.com/gre/1650294
   */
  // no easing, no acceleration
  linear: function(e) {
    return e;
  },
  // accelerating from zero velocity
  easeInQuad: function(e) {
    return e * e;
  },
  // decelerating to zero velocity
  easeOutQuad: function(e) {
    return e * (2 - e);
  },
  // acceleration until halfway, then deceleration
  easeInOutQuad: function(e) {
    return e < 0.5 ? 2 * e * e : -1 + (4 - 2 * e) * e;
  },
  // accelerating from zero velocity 
  easeInCubic: function(e) {
    return e * e * e;
  },
  // decelerating to zero velocity π
  easeOutCubic: function(e) {
    return --e * e * e + 1;
  },
  // acceleration until halfway, then deceleration 
  easeInOutCubic: function(e) {
    return e < 0.5 ? 4 * e * e * e : (e - 1) * (2 * e - 2) * (2 * e - 2) + 1;
  },
  // accelerating from zero velocity 
  easeInQuart: function(e) {
    return e * e * e * e;
  },
  // decelerating to zero velocity 
  easeOutQuart: function(e) {
    return 1 - --e * e * e * e;
  },
  // acceleration until halfway, then deceleration
  easeInOutQuart: function(e) {
    return e < 0.5 ? 8 * e * e * e * e : 1 - 8 * --e * e * e * e;
  },
  // accelerating from zero velocity
  easeInQuint: function(e) {
    return e * e * e * e * e;
  },
  // decelerating to zero velocity
  easeOutQuint: function(e) {
    return 1 + --e * e * e * e * e;
  },
  // acceleration until halfway, then deceleration 
  easeInOutQuint: function(e) {
    return e < 0.5 ? 16 * e * e * e * e * e : 1 + 16 * --e * e * e * e * e;
  }
};
var bD = {};
Object.defineProperty(bD, "__esModule", {
  value: !0
});
var lxe = Kh, uxe = ["mousedown", "wheel", "touchmove", "keydown"];
bD.default = {
  subscribe: function(e) {
    return typeof document < "u" && uxe.forEach(function(t) {
      return (0, lxe.addPassiveEventListener)(document, t, e);
    });
  }
};
var Yh = {};
Object.defineProperty(Yh, "__esModule", {
  value: !0
});
var __ = {
  registered: {},
  scrollEvent: {
    register: function(e, t) {
      __.registered[e] = t;
    },
    remove: function(e) {
      __.registered[e] = null;
    }
  }
};
Yh.default = __;
Object.defineProperty(VC, "__esModule", {
  value: !0
});
var cxe = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, pxe = Xh;
ZC(pxe);
var dxe = yD, kF = ZC(dxe), fxe = bD, hxe = ZC(fxe), gxe = Yh, ta = ZC(gxe);
function ZC(e) {
  return e && e.__esModule ? e : { default: e };
}
var QJ = function(e) {
  return kF.default[e.smooth] || kF.default.defaultEasing;
}, mxe = function(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}, vxe = function() {
  if (typeof window < "u")
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame;
}, P_ = function() {
  return vxe() || function(e, t, n) {
    window.setTimeout(e, n || 1e3 / 60, (/* @__PURE__ */ new Date()).getTime());
  };
}(), eQ = function() {
  return {
    currentPosition: 0,
    startPosition: 0,
    targetPosition: 0,
    progress: 0,
    duration: 0,
    cancel: !1,
    target: null,
    containerElement: null,
    to: null,
    start: null,
    delta: null,
    percent: null,
    delayTimeout: null
  };
}, tQ = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollLeft;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageXOffset : r ? document.documentElement.scrollLeft : document.body.scrollLeft;
}, nQ = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollTop;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageYOffset : r ? document.documentElement.scrollTop : document.body.scrollTop;
}, yxe = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollWidth - t.offsetWidth;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollWidth, n.offsetWidth, r.clientWidth, r.scrollWidth, r.offsetWidth);
}, bxe = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollHeight - t.offsetHeight;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollHeight, n.offsetHeight, r.clientHeight, r.scrollHeight, r.offsetHeight);
}, wxe = function e(t, n, r) {
  var o = n.data;
  if (!n.ignoreCancelEvents && o.cancel) {
    ta.default.registered.end && ta.default.registered.end(o.to, o.target, o.currentPositionY);
    return;
  }
  if (o.delta = Math.round(o.targetPosition - o.startPosition), o.start === null && (o.start = r), o.progress = r - o.start, o.percent = o.progress >= o.duration ? 1 : t(o.progress / o.duration), o.currentPosition = o.startPosition + Math.ceil(o.delta * o.percent), o.containerElement && o.containerElement !== document && o.containerElement !== document.body ? n.horizontal ? o.containerElement.scrollLeft = o.currentPosition : o.containerElement.scrollTop = o.currentPosition : n.horizontal ? window.scrollTo(o.currentPosition, 0) : window.scrollTo(0, o.currentPosition), o.percent < 1) {
    var i = e.bind(null, t, n);
    P_.call(window, i);
    return;
  }
  ta.default.registered.end && ta.default.registered.end(o.to, o.target, o.currentPosition);
}, wD = function(e) {
  e.data.containerElement = e ? e.containerId ? document.getElementById(e.containerId) : e.container && e.container.nodeType ? e.container : document : null;
}, Jh = function(e, t, n, r) {
  t.data = t.data || eQ(), window.clearTimeout(t.data.delayTimeout);
  var o = function() {
    t.data.cancel = !0;
  };
  if (hxe.default.subscribe(o), wD(t), t.data.start = null, t.data.cancel = !1, t.data.startPosition = t.horizontal ? tQ(t) : nQ(t), t.data.targetPosition = t.absolute ? e : e + t.data.startPosition, t.data.startPosition === t.data.targetPosition) {
    ta.default.registered.end && ta.default.registered.end(t.data.to, t.data.target, t.data.currentPosition);
    return;
  }
  t.data.delta = Math.round(t.data.targetPosition - t.data.startPosition), t.data.duration = mxe(t.duration)(t.data.delta), t.data.duration = isNaN(parseFloat(t.data.duration)) ? 1e3 : parseFloat(t.data.duration), t.data.to = n, t.data.target = r;
  var i = QJ(t), a = wxe.bind(null, i, t);
  if (t && t.delay > 0) {
    t.data.delayTimeout = window.setTimeout(function() {
      ta.default.registered.begin && ta.default.registered.begin(t.data.to, t.data.target), P_.call(window, a);
    }, t.delay);
    return;
  }
  ta.default.registered.begin && ta.default.registered.begin(t.data.to, t.data.target), P_.call(window, a);
}, qC = function(e) {
  return e = cxe({}, e), e.data = e.data || eQ(), e.absolute = !0, e;
}, Cxe = function(e) {
  Jh(0, qC(e));
}, Oxe = function(e, t) {
  Jh(e, qC(t));
}, xxe = function(e) {
  e = qC(e), wD(e), Jh(e.horizontal ? yxe(e) : bxe(e), e);
}, Exe = function(e, t) {
  t = qC(t), wD(t);
  var n = t.horizontal ? tQ(t) : nQ(t);
  Jh(e + n, t);
};
VC.default = {
  animateTopScroll: Jh,
  getAnimationType: QJ,
  scrollToTop: Cxe,
  scrollToBottom: xxe,
  scrollTo: Oxe,
  scrollMore: Exe
};
Object.defineProperty(Bp, "__esModule", {
  value: !0
});
var kxe = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, Lxe = Xh, _xe = CD(Lxe), Pxe = VC, Sxe = CD(Pxe), Mxe = Yh, qm = CD(Mxe);
function CD(e) {
  return e && e.__esModule ? e : { default: e };
}
var Gm = {}, LF = void 0;
Bp.default = {
  unmount: function() {
    Gm = {};
  },
  register: function(e, t) {
    Gm[e] = t;
  },
  unregister: function(e) {
    delete Gm[e];
  },
  get: function(e) {
    return Gm[e] || document.getElementById(e) || document.getElementsByName(e)[0] || document.getElementsByClassName(e)[0];
  },
  setActiveLink: function(e) {
    return LF = e;
  },
  getActiveLink: function() {
    return LF;
  },
  scrollTo: function(e, t) {
    var n = this.get(e);
    if (!n) {
      console.warn("target Element not found");
      return;
    }
    t = kxe({}, t, { absolute: !1 });
    var r = t.containerId, o = t.container, i = void 0;
    r ? i = document.getElementById(r) : o && o.nodeType ? i = o : i = document, t.absolute = !0;
    var a = t.horizontal, s = _xe.default.scrollOffset(i, n, a) + (t.offset || 0);
    if (!t.smooth) {
      qm.default.registered.begin && qm.default.registered.begin(e, n), i === document ? t.horizontal ? window.scrollTo(s, 0) : window.scrollTo(0, s) : i.scrollTop = s, qm.default.registered.end && qm.default.registered.end(e, n);
      return;
    }
    Sxe.default.animateTopScroll(s, t, e, n);
  }
};
var S_ = { exports: {} }, Yx = { exports: {} }, Wn = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var _F;
function Dxe() {
  if (_F) return Wn;
  _F = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, g = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, m = e ? Symbol.for("react.block") : 60121, b = e ? Symbol.for("react.fundamental") : 60117, E = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
  function M(v) {
    if (typeof v == "object" && v !== null) {
      var C = v.$$typeof;
      switch (C) {
        case t:
          switch (v = v.type, v) {
            case l:
            case u:
            case r:
            case i:
            case o:
            case p:
              return v;
            default:
              switch (v = v && v.$$typeof, v) {
                case s:
                case c:
                case f:
                case g:
                case a:
                  return v;
                default:
                  return C;
              }
          }
        case n:
          return C;
      }
    }
  }
  function x(v) {
    return M(v) === u;
  }
  return Wn.AsyncMode = l, Wn.ConcurrentMode = u, Wn.ContextConsumer = s, Wn.ContextProvider = a, Wn.Element = t, Wn.ForwardRef = c, Wn.Fragment = r, Wn.Lazy = f, Wn.Memo = g, Wn.Portal = n, Wn.Profiler = i, Wn.StrictMode = o, Wn.Suspense = p, Wn.isAsyncMode = function(v) {
    return x(v) || M(v) === l;
  }, Wn.isConcurrentMode = x, Wn.isContextConsumer = function(v) {
    return M(v) === s;
  }, Wn.isContextProvider = function(v) {
    return M(v) === a;
  }, Wn.isElement = function(v) {
    return typeof v == "object" && v !== null && v.$$typeof === t;
  }, Wn.isForwardRef = function(v) {
    return M(v) === c;
  }, Wn.isFragment = function(v) {
    return M(v) === r;
  }, Wn.isLazy = function(v) {
    return M(v) === f;
  }, Wn.isMemo = function(v) {
    return M(v) === g;
  }, Wn.isPortal = function(v) {
    return M(v) === n;
  }, Wn.isProfiler = function(v) {
    return M(v) === i;
  }, Wn.isStrictMode = function(v) {
    return M(v) === o;
  }, Wn.isSuspense = function(v) {
    return M(v) === p;
  }, Wn.isValidElementType = function(v) {
    return typeof v == "string" || typeof v == "function" || v === r || v === u || v === i || v === o || v === p || v === d || typeof v == "object" && v !== null && (v.$$typeof === f || v.$$typeof === g || v.$$typeof === a || v.$$typeof === s || v.$$typeof === c || v.$$typeof === b || v.$$typeof === E || v.$$typeof === w || v.$$typeof === m);
  }, Wn.typeOf = M, Wn;
}
var Qn = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var PF;
function Txe() {
  return PF || (PF = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, g = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, m = e ? Symbol.for("react.block") : 60121, b = e ? Symbol.for("react.fundamental") : 60117, E = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
    function M(I) {
      return typeof I == "string" || typeof I == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      I === r || I === u || I === i || I === o || I === p || I === d || typeof I == "object" && I !== null && (I.$$typeof === f || I.$$typeof === g || I.$$typeof === a || I.$$typeof === s || I.$$typeof === c || I.$$typeof === b || I.$$typeof === E || I.$$typeof === w || I.$$typeof === m);
    }
    function x(I) {
      if (typeof I == "object" && I !== null) {
        var le = I.$$typeof;
        switch (le) {
          case t:
            var he = I.type;
            switch (he) {
              case l:
              case u:
              case r:
              case i:
              case o:
              case p:
                return he;
              default:
                var oe = he && he.$$typeof;
                switch (oe) {
                  case s:
                  case c:
                  case f:
                  case g:
                  case a:
                    return oe;
                  default:
                    return le;
                }
            }
          case n:
            return le;
        }
      }
    }
    var v = l, C = u, P = s, F = a, L = t, B = c, N = r, $ = f, V = g, H = n, Z = i, K = o, Y = p, Q = !1;
    function J(I) {
      return Q || (Q = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), _(I) || x(I) === l;
    }
    function _(I) {
      return x(I) === u;
    }
    function D(I) {
      return x(I) === s;
    }
    function z(I) {
      return x(I) === a;
    }
    function S(I) {
      return typeof I == "object" && I !== null && I.$$typeof === t;
    }
    function W(I) {
      return x(I) === c;
    }
    function O(I) {
      return x(I) === r;
    }
    function j(I) {
      return x(I) === f;
    }
    function U(I) {
      return x(I) === g;
    }
    function T(I) {
      return x(I) === n;
    }
    function q(I) {
      return x(I) === i;
    }
    function A(I) {
      return x(I) === o;
    }
    function X(I) {
      return x(I) === p;
    }
    Qn.AsyncMode = v, Qn.ConcurrentMode = C, Qn.ContextConsumer = P, Qn.ContextProvider = F, Qn.Element = L, Qn.ForwardRef = B, Qn.Fragment = N, Qn.Lazy = $, Qn.Memo = V, Qn.Portal = H, Qn.Profiler = Z, Qn.StrictMode = K, Qn.Suspense = Y, Qn.isAsyncMode = J, Qn.isConcurrentMode = _, Qn.isContextConsumer = D, Qn.isContextProvider = z, Qn.isElement = S, Qn.isForwardRef = W, Qn.isFragment = O, Qn.isLazy = j, Qn.isMemo = U, Qn.isPortal = T, Qn.isProfiler = q, Qn.isStrictMode = A, Qn.isSuspense = X, Qn.isValidElementType = M, Qn.typeOf = x;
  }()), Qn;
}
var SF;
function rQ() {
  return SF || (SF = 1, process.env.NODE_ENV === "production" ? Yx.exports = Dxe() : Yx.exports = Txe()), Yx.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var Jx, MF;
function jxe() {
  if (MF) return Jx;
  MF = 1;
  var e = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, n = Object.prototype.propertyIsEnumerable;
  function r(i) {
    if (i == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(i);
  }
  function o() {
    try {
      if (!Object.assign)
        return !1;
      var i = new String("abc");
      if (i[5] = "de", Object.getOwnPropertyNames(i)[0] === "5")
        return !1;
      for (var a = {}, s = 0; s < 10; s++)
        a["_" + String.fromCharCode(s)] = s;
      var l = Object.getOwnPropertyNames(a).map(function(c) {
        return a[c];
      });
      if (l.join("") !== "0123456789")
        return !1;
      var u = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(c) {
        u[c] = c;
      }), Object.keys(Object.assign({}, u)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return Jx = o() ? Object.assign : function(i, a) {
    for (var s, l = r(i), u, c = 1; c < arguments.length; c++) {
      s = Object(arguments[c]);
      for (var p in s)
        t.call(s, p) && (l[p] = s[p]);
      if (e) {
        u = e(s);
        for (var d = 0; d < u.length; d++)
          n.call(s, u[d]) && (l[u[d]] = s[u[d]]);
      }
    }
    return l;
  }, Jx;
}
var Qx, DF;
function OD() {
  if (DF) return Qx;
  DF = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return Qx = e, Qx;
}
var TF, jF;
function oQ() {
  return jF || (jF = 1, TF = Function.call.bind(Object.prototype.hasOwnProperty)), TF;
}
var eE, AF;
function Axe() {
  if (AF) return eE;
  AF = 1;
  var e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = OD(), n = {}, r = oQ();
    e = function(i) {
      var a = "Warning: " + i;
      typeof console < "u" && console.error(a);
      try {
        throw new Error(a);
      } catch {
      }
    };
  }
  function o(i, a, s, l, u) {
    if (process.env.NODE_ENV !== "production") {
      for (var c in i)
        if (r(i, c)) {
          var p;
          try {
            if (typeof i[c] != "function") {
              var d = Error(
                (l || "React class") + ": " + s + " type `" + c + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof i[c] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw d.name = "Invariant Violation", d;
            }
            p = i[c](a, c, l, s, null, t);
          } catch (f) {
            p = f;
          }
          if (p && !(p instanceof Error) && e(
            (l || "React class") + ": type specification of " + s + " `" + c + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof p + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), p instanceof Error && !(p.message in n)) {
            n[p.message] = !0;
            var g = u ? u() : "";
            e(
              "Failed " + s + " type: " + p.message + (g ?? "")
            );
          }
        }
    }
  }
  return o.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (n = {});
  }, eE = o, eE;
}
var tE, RF;
function Rxe() {
  if (RF) return tE;
  RF = 1;
  var e = rQ(), t = jxe(), n = OD(), r = oQ(), o = Axe(), i = function() {
  };
  process.env.NODE_ENV !== "production" && (i = function(s) {
    var l = "Warning: " + s;
    typeof console < "u" && console.error(l);
    try {
      throw new Error(l);
    } catch {
    }
  });
  function a() {
    return null;
  }
  return tE = function(s, l) {
    var u = typeof Symbol == "function" && Symbol.iterator, c = "@@iterator";
    function p(_) {
      var D = _ && (u && _[u] || _[c]);
      if (typeof D == "function")
        return D;
    }
    var d = "<<anonymous>>", g = {
      array: E("array"),
      bigint: E("bigint"),
      bool: E("boolean"),
      func: E("function"),
      number: E("number"),
      object: E("object"),
      string: E("string"),
      symbol: E("symbol"),
      any: w(),
      arrayOf: M,
      element: x(),
      elementType: v(),
      instanceOf: C,
      node: B(),
      objectOf: F,
      oneOf: P,
      oneOfType: L,
      shape: $,
      exact: V
    };
    function f(_, D) {
      return _ === D ? _ !== 0 || 1 / _ === 1 / D : _ !== _ && D !== D;
    }
    function m(_, D) {
      this.message = _, this.data = D && typeof D == "object" ? D : {}, this.stack = "";
    }
    m.prototype = Error.prototype;
    function b(_) {
      if (process.env.NODE_ENV !== "production")
        var D = {}, z = 0;
      function S(O, j, U, T, q, A, X) {
        if (T = T || d, A = A || U, X !== n) {
          if (l) {
            var I = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw I.name = "Invariant Violation", I;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var le = T + ":" + U;
            !D[le] && // Avoid spamming the console because they are often not actionable except for lib authors
            z < 3 && (i(
              "You are manually calling a React.PropTypes validation function for the `" + A + "` prop on `" + T + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), D[le] = !0, z++);
          }
        }
        return j[U] == null ? O ? j[U] === null ? new m("The " + q + " `" + A + "` is marked as required " + ("in `" + T + "`, but its value is `null`.")) : new m("The " + q + " `" + A + "` is marked as required in " + ("`" + T + "`, but its value is `undefined`.")) : null : _(j, U, T, q, A);
      }
      var W = S.bind(null, !1);
      return W.isRequired = S.bind(null, !0), W;
    }
    function E(_) {
      function D(z, S, W, O, j, U) {
        var T = z[S], q = K(T);
        if (q !== _) {
          var A = Y(T);
          return new m(
            "Invalid " + O + " `" + j + "` of type " + ("`" + A + "` supplied to `" + W + "`, expected ") + ("`" + _ + "`."),
            { expectedType: _ }
          );
        }
        return null;
      }
      return b(D);
    }
    function w() {
      return b(a);
    }
    function M(_) {
      function D(z, S, W, O, j) {
        if (typeof _ != "function")
          return new m("Property `" + j + "` of component `" + W + "` has invalid PropType notation inside arrayOf.");
        var U = z[S];
        if (!Array.isArray(U)) {
          var T = K(U);
          return new m("Invalid " + O + " `" + j + "` of type " + ("`" + T + "` supplied to `" + W + "`, expected an array."));
        }
        for (var q = 0; q < U.length; q++) {
          var A = _(U, q, W, O, j + "[" + q + "]", n);
          if (A instanceof Error)
            return A;
        }
        return null;
      }
      return b(D);
    }
    function x() {
      function _(D, z, S, W, O) {
        var j = D[z];
        if (!s(j)) {
          var U = K(j);
          return new m("Invalid " + W + " `" + O + "` of type " + ("`" + U + "` supplied to `" + S + "`, expected a single ReactElement."));
        }
        return null;
      }
      return b(_);
    }
    function v() {
      function _(D, z, S, W, O) {
        var j = D[z];
        if (!e.isValidElementType(j)) {
          var U = K(j);
          return new m("Invalid " + W + " `" + O + "` of type " + ("`" + U + "` supplied to `" + S + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return b(_);
    }
    function C(_) {
      function D(z, S, W, O, j) {
        if (!(z[S] instanceof _)) {
          var U = _.name || d, T = J(z[S]);
          return new m("Invalid " + O + " `" + j + "` of type " + ("`" + T + "` supplied to `" + W + "`, expected ") + ("instance of `" + U + "`."));
        }
        return null;
      }
      return b(D);
    }
    function P(_) {
      if (!Array.isArray(_))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? i(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : i("Invalid argument supplied to oneOf, expected an array.")), a;
      function D(z, S, W, O, j) {
        for (var U = z[S], T = 0; T < _.length; T++)
          if (f(U, _[T]))
            return null;
        var q = JSON.stringify(_, function(A, X) {
          var I = Y(X);
          return I === "symbol" ? String(X) : X;
        });
        return new m("Invalid " + O + " `" + j + "` of value `" + String(U) + "` " + ("supplied to `" + W + "`, expected one of " + q + "."));
      }
      return b(D);
    }
    function F(_) {
      function D(z, S, W, O, j) {
        if (typeof _ != "function")
          return new m("Property `" + j + "` of component `" + W + "` has invalid PropType notation inside objectOf.");
        var U = z[S], T = K(U);
        if (T !== "object")
          return new m("Invalid " + O + " `" + j + "` of type " + ("`" + T + "` supplied to `" + W + "`, expected an object."));
        for (var q in U)
          if (r(U, q)) {
            var A = _(U, q, W, O, j + "." + q, n);
            if (A instanceof Error)
              return A;
          }
        return null;
      }
      return b(D);
    }
    function L(_) {
      if (!Array.isArray(_))
        return process.env.NODE_ENV !== "production" && i("Invalid argument supplied to oneOfType, expected an instance of array."), a;
      for (var D = 0; D < _.length; D++) {
        var z = _[D];
        if (typeof z != "function")
          return i(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + Q(z) + " at index " + D + "."
          ), a;
      }
      function S(W, O, j, U, T) {
        for (var q = [], A = 0; A < _.length; A++) {
          var X = _[A], I = X(W, O, j, U, T, n);
          if (I == null)
            return null;
          I.data && r(I.data, "expectedType") && q.push(I.data.expectedType);
        }
        var le = q.length > 0 ? ", expected one of type [" + q.join(", ") + "]" : "";
        return new m("Invalid " + U + " `" + T + "` supplied to " + ("`" + j + "`" + le + "."));
      }
      return b(S);
    }
    function B() {
      function _(D, z, S, W, O) {
        return H(D[z]) ? null : new m("Invalid " + W + " `" + O + "` supplied to " + ("`" + S + "`, expected a ReactNode."));
      }
      return b(_);
    }
    function N(_, D, z, S, W) {
      return new m(
        (_ || "React class") + ": " + D + " type `" + z + "." + S + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + W + "`."
      );
    }
    function $(_) {
      function D(z, S, W, O, j) {
        var U = z[S], T = K(U);
        if (T !== "object")
          return new m("Invalid " + O + " `" + j + "` of type `" + T + "` " + ("supplied to `" + W + "`, expected `object`."));
        for (var q in _) {
          var A = _[q];
          if (typeof A != "function")
            return N(W, O, j, q, Y(A));
          var X = A(U, q, W, O, j + "." + q, n);
          if (X)
            return X;
        }
        return null;
      }
      return b(D);
    }
    function V(_) {
      function D(z, S, W, O, j) {
        var U = z[S], T = K(U);
        if (T !== "object")
          return new m("Invalid " + O + " `" + j + "` of type `" + T + "` " + ("supplied to `" + W + "`, expected `object`."));
        var q = t({}, z[S], _);
        for (var A in q) {
          var X = _[A];
          if (r(_, A) && typeof X != "function")
            return N(W, O, j, A, Y(X));
          if (!X)
            return new m(
              "Invalid " + O + " `" + j + "` key `" + A + "` supplied to `" + W + "`.\nBad object: " + JSON.stringify(z[S], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(_), null, "  ")
            );
          var I = X(U, A, W, O, j + "." + A, n);
          if (I)
            return I;
        }
        return null;
      }
      return b(D);
    }
    function H(_) {
      switch (typeof _) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !_;
        case "object":
          if (Array.isArray(_))
            return _.every(H);
          if (_ === null || s(_))
            return !0;
          var D = p(_);
          if (D) {
            var z = D.call(_), S;
            if (D !== _.entries) {
              for (; !(S = z.next()).done; )
                if (!H(S.value))
                  return !1;
            } else
              for (; !(S = z.next()).done; ) {
                var W = S.value;
                if (W && !H(W[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function Z(_, D) {
      return _ === "symbol" ? !0 : D ? D["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && D instanceof Symbol : !1;
    }
    function K(_) {
      var D = typeof _;
      return Array.isArray(_) ? "array" : _ instanceof RegExp ? "object" : Z(D, _) ? "symbol" : D;
    }
    function Y(_) {
      if (typeof _ > "u" || _ === null)
        return "" + _;
      var D = K(_);
      if (D === "object") {
        if (_ instanceof Date)
          return "date";
        if (_ instanceof RegExp)
          return "regexp";
      }
      return D;
    }
    function Q(_) {
      var D = Y(_);
      switch (D) {
        case "array":
        case "object":
          return "an " + D;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + D;
        default:
          return D;
      }
    }
    function J(_) {
      return !_.constructor || !_.constructor.name ? d : _.constructor.name;
    }
    return g.checkPropTypes = o, g.resetWarningCache = o.resetWarningCache, g.PropTypes = g, g;
  }, tE;
}
var nE, IF;
function Ixe() {
  if (IF) return nE;
  IF = 1;
  var e = OD();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, nE = function() {
    function r(a, s, l, u, c, p) {
      if (p !== e) {
        var d = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw d.name = "Invariant Violation", d;
      }
    }
    r.isRequired = r;
    function o() {
      return r;
    }
    var i = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: o,
      element: r,
      elementType: r,
      instanceOf: o,
      node: r,
      objectOf: o,
      oneOf: o,
      oneOfType: o,
      shape: o,
      exact: o,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return i.PropTypes = i, i;
  }, nE;
}
if (process.env.NODE_ENV !== "production") {
  var Nxe = rQ(), Bxe = !0;
  S_.exports = Rxe()(Nxe.isElement, Bxe);
} else
  S_.exports = Ixe()();
var GC = S_.exports, KC = {};
Object.defineProperty(KC, "__esModule", {
  value: !0
});
var Fxe = Xh, rE = zxe(Fxe);
function zxe(e) {
  return e && e.__esModule ? e : { default: e };
}
var Uxe = {
  mountFlag: !1,
  initialized: !1,
  scroller: null,
  containers: {},
  mount: function(e) {
    this.scroller = e, this.handleHashChange = this.handleHashChange.bind(this), window.addEventListener("hashchange", this.handleHashChange), this.initStateFromHash(), this.mountFlag = !0;
  },
  mapContainer: function(e, t) {
    this.containers[e] = t;
  },
  isMounted: function() {
    return this.mountFlag;
  },
  isInitialized: function() {
    return this.initialized;
  },
  initStateFromHash: function() {
    var e = this, t = this.getHash();
    t ? window.setTimeout(function() {
      e.scrollTo(t, !0), e.initialized = !0;
    }, 10) : this.initialized = !0;
  },
  scrollTo: function(e, t) {
    var n = this.scroller, r = n.get(e);
    if (r && (t || e !== n.getActiveLink())) {
      var o = this.containers[e] || document;
      n.scrollTo(e, { container: o });
    }
  },
  getHash: function() {
    return rE.default.getHash();
  },
  changeHash: function(e, t) {
    this.isInitialized() && rE.default.getHash() !== e && rE.default.updateHash(e, t);
  },
  handleHashChange: function() {
    this.scrollTo(this.getHash());
  },
  unmount: function() {
    this.scroller = null, this.containers = null, window.removeEventListener("hashchange", this.handleHashChange);
  }
};
KC.default = Uxe;
Object.defineProperty(qh, "__esModule", {
  value: !0
});
var Km = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, Hxe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), Wxe = be, NF = Qh(Wxe), $xe = Gh, Xm = Qh($xe), Vxe = Bp, Zxe = Qh(Vxe), qxe = GC, Vr = Qh(qxe), Gxe = KC, hl = Qh(Gxe);
function Qh(e) {
  return e && e.__esModule ? e : { default: e };
}
function Kxe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Xxe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function Yxe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var BF = {
  to: Vr.default.string.isRequired,
  containerId: Vr.default.string,
  container: Vr.default.object,
  activeClass: Vr.default.string,
  activeStyle: Vr.default.object,
  spy: Vr.default.bool,
  horizontal: Vr.default.bool,
  smooth: Vr.default.oneOfType([Vr.default.bool, Vr.default.string]),
  offset: Vr.default.number,
  delay: Vr.default.number,
  isDynamic: Vr.default.bool,
  onClick: Vr.default.func,
  duration: Vr.default.oneOfType([Vr.default.number, Vr.default.func]),
  absolute: Vr.default.bool,
  onSetActive: Vr.default.func,
  onSetInactive: Vr.default.func,
  ignoreCancelEvents: Vr.default.bool,
  hashSpy: Vr.default.bool,
  saveHashHistory: Vr.default.bool,
  spyThrottle: Vr.default.number
};
qh.default = function(e, t) {
  var n = t || Zxe.default, r = function(i) {
    Yxe(a, i);
    function a(s) {
      Kxe(this, a);
      var l = Xxe(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
      return o.call(l), l.state = {
        active: !1
      }, l.beforeUnmountCallbacks = [], l;
    }
    return Hxe(a, [{
      key: "getScrollSpyContainer",
      value: function() {
        var s = this.props.containerId, l = this.props.container;
        return s && !l ? document.getElementById(s) : l && l.nodeType ? l : document;
      }
    }, {
      key: "componentDidMount",
      value: function() {
        if (this.props.spy || this.props.hashSpy) {
          var s = this.getScrollSpyContainer();
          if (!Xm.default.isMounted(s)) {
            var l = Xm.default.mount(s, this.props.spyThrottle);
            this.beforeUnmountCallbacks.push(l);
          }
          this.props.hashSpy && (hl.default.isMounted() || hl.default.mount(n), hl.default.mapContainer(this.props.to, s)), Xm.default.addSpyHandler(this.spyHandler, s), this.setState({
            container: s
          });
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        Xm.default.unmount(this.stateHandler, this.spyHandler), this.beforeUnmountCallbacks.forEach(function(s) {
          return s();
        });
      }
    }, {
      key: "render",
      value: function() {
        var s = "";
        this.state && this.state.active ? s = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : s = this.props.className;
        var l = {};
        this.state && this.state.active ? l = Km({}, this.props.style, this.props.activeStyle) : l = Km({}, this.props.style);
        var u = Km({}, this.props);
        for (var c in BF)
          u.hasOwnProperty(c) && delete u[c];
        return u.className = s, u.style = l, u.onClick = this.handleClick, NF.default.createElement(e, u);
      }
    }]), a;
  }(NF.default.PureComponent), o = function() {
    var i = this;
    this.scrollTo = function(a, s) {
      n.scrollTo(a, Km({}, i.state, s));
    }, this.handleClick = function(a) {
      i.props.onClick && i.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), i.scrollTo(i.props.to, i.props);
    }, this.spyHandler = function(a, s) {
      var l = i.getScrollSpyContainer();
      if (!(hl.default.isMounted() && !hl.default.isInitialized())) {
        var u = i.props.horizontal, c = i.props.to, p = null, d = void 0, g = void 0;
        if (u) {
          var f = 0, m = 0, b = 0;
          if (l.getBoundingClientRect) {
            var E = l.getBoundingClientRect();
            b = E.left;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var w = p.getBoundingClientRect();
            f = w.left - b + a, m = f + w.width;
          }
          var M = a - i.props.offset;
          d = M >= Math.floor(f) && M < Math.floor(m), g = M < Math.floor(f) || M >= Math.floor(m);
        } else {
          var x = 0, v = 0, C = 0;
          if (l.getBoundingClientRect) {
            var P = l.getBoundingClientRect();
            C = P.top;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var F = p.getBoundingClientRect();
            x = F.top - C + s, v = x + F.height;
          }
          var L = s - i.props.offset;
          d = L >= Math.floor(x) && L < Math.floor(v), g = L < Math.floor(x) || L >= Math.floor(v);
        }
        var B = n.getActiveLink();
        if (g) {
          if (c === B && n.setActiveLink(void 0), i.props.hashSpy && hl.default.getHash() === c) {
            var N = i.props.saveHashHistory, $ = N === void 0 ? !1 : N;
            hl.default.changeHash("", $);
          }
          i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive(c, p));
        }
        if (d && (B !== c || i.state.active === !1)) {
          n.setActiveLink(c);
          var V = i.props.saveHashHistory, H = V === void 0 ? !1 : V;
          i.props.hashSpy && hl.default.changeHash(c, H), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(c, p));
        }
      }
    };
  };
  return r.propTypes = BF, r.defaultProps = { offset: 0 }, r;
};
Object.defineProperty(vD, "__esModule", {
  value: !0
});
var Jxe = be, FF = iQ(Jxe), Qxe = qh, eEe = iQ(Qxe);
function iQ(e) {
  return e && e.__esModule ? e : { default: e };
}
function tEe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function zF(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function nEe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var rEe = function(e) {
  nEe(t, e);
  function t() {
    var n, r, o, i;
    tEe(this, t);
    for (var a = arguments.length, s = Array(a), l = 0; l < a; l++)
      s[l] = arguments[l];
    return i = (r = (o = zF(this, (n = t.__proto__ || Object.getPrototypeOf(t)).call.apply(n, [this].concat(s))), o), o.render = function() {
      return FF.default.createElement(
        "a",
        o.props,
        o.props.children
      );
    }, r), zF(o, i);
  }
  return t;
}(FF.default.Component);
vD.default = (0, eEe.default)(rEe);
var xD = {};
Object.defineProperty(xD, "__esModule", {
  value: !0
});
var oEe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), iEe = be, UF = sQ(iEe), sEe = qh, aEe = sQ(sEe);
function sQ(e) {
  return e && e.__esModule ? e : { default: e };
}
function lEe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function uEe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function cEe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var pEe = function(e) {
  cEe(t, e);
  function t() {
    return lEe(this, t), uEe(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return oEe(t, [{
    key: "render",
    value: function() {
      return UF.default.createElement(
        "button",
        this.props,
        this.props.children
      );
    }
  }]), t;
}(UF.default.Component);
xD.default = (0, aEe.default)(pEe);
var ED = {}, XC = {};
Object.defineProperty(XC, "__esModule", {
  value: !0
});
var dEe = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, fEe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), hEe = be, HF = YC(hEe), gEe = il;
YC(gEe);
var mEe = Bp, WF = YC(mEe), vEe = GC, $F = YC(vEe);
function YC(e) {
  return e && e.__esModule ? e : { default: e };
}
function yEe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function bEe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function wEe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
XC.default = function(e) {
  var t = function(n) {
    wEe(r, n);
    function r(o) {
      yEe(this, r);
      var i = bEe(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
      return i.childBindings = {
        domNode: null
      }, i;
    }
    return fEe(r, [{
      key: "componentDidMount",
      value: function() {
        if (typeof window > "u")
          return !1;
        this.registerElems(this.props.name);
      }
    }, {
      key: "componentDidUpdate",
      value: function(o) {
        this.props.name !== o.name && this.registerElems(this.props.name);
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        if (typeof window > "u")
          return !1;
        WF.default.unregister(this.props.name);
      }
    }, {
      key: "registerElems",
      value: function(o) {
        WF.default.register(o, this.childBindings.domNode);
      }
    }, {
      key: "render",
      value: function() {
        return HF.default.createElement(e, dEe({}, this.props, { parentBindings: this.childBindings }));
      }
    }]), r;
  }(HF.default.Component);
  return t.propTypes = {
    name: $F.default.string,
    id: $F.default.string
  }, t;
};
Object.defineProperty(ED, "__esModule", {
  value: !0
});
var VF = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, CEe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), OEe = be, ZF = kD(OEe), xEe = XC, EEe = kD(xEe), kEe = GC, qF = kD(kEe);
function kD(e) {
  return e && e.__esModule ? e : { default: e };
}
function LEe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function _Ee(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function PEe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var aQ = function(e) {
  PEe(t, e);
  function t() {
    return LEe(this, t), _Ee(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return CEe(t, [{
    key: "render",
    value: function() {
      var n = this, r = VF({}, this.props);
      return delete r.name, r.parentBindings && delete r.parentBindings, ZF.default.createElement(
        "div",
        VF({}, r, { ref: function(o) {
          n.props.parentBindings.domNode = o;
        } }),
        this.props.children
      );
    }
  }]), t;
}(ZF.default.Component);
aQ.propTypes = {
  name: qF.default.string,
  id: qF.default.string
};
ED.default = (0, EEe.default)(aQ);
var oE = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, GF = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}();
function KF(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function XF(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function YF(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var Ym = be, ju = Gh, iE = Bp, yo = GC, gl = KC, JF = {
  to: yo.string.isRequired,
  containerId: yo.string,
  container: yo.object,
  activeClass: yo.string,
  spy: yo.bool,
  smooth: yo.oneOfType([yo.bool, yo.string]),
  offset: yo.number,
  delay: yo.number,
  isDynamic: yo.bool,
  onClick: yo.func,
  duration: yo.oneOfType([yo.number, yo.func]),
  absolute: yo.bool,
  onSetActive: yo.func,
  onSetInactive: yo.func,
  ignoreCancelEvents: yo.bool,
  hashSpy: yo.bool,
  spyThrottle: yo.number
}, SEe = {
  Scroll: function(e, t) {
    console.warn("Helpers.Scroll is deprecated since v1.7.0");
    var n = t || iE, r = function(i) {
      YF(a, i);
      function a(s) {
        KF(this, a);
        var l = XF(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
        return o.call(l), l.state = {
          active: !1
        }, l;
      }
      return GF(a, [{
        key: "getScrollSpyContainer",
        value: function() {
          var s = this.props.containerId, l = this.props.container;
          return s ? document.getElementById(s) : l && l.nodeType ? l : document;
        }
      }, {
        key: "componentDidMount",
        value: function() {
          if (this.props.spy || this.props.hashSpy) {
            var s = this.getScrollSpyContainer();
            ju.isMounted(s) || ju.mount(s, this.props.spyThrottle), this.props.hashSpy && (gl.isMounted() || gl.mount(n), gl.mapContainer(this.props.to, s)), this.props.spy && ju.addStateHandler(this.stateHandler), ju.addSpyHandler(this.spyHandler, s), this.setState({
              container: s
            });
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          ju.unmount(this.stateHandler, this.spyHandler);
        }
      }, {
        key: "render",
        value: function() {
          var s = "";
          this.state && this.state.active ? s = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : s = this.props.className;
          var l = oE({}, this.props);
          for (var u in JF)
            l.hasOwnProperty(u) && delete l[u];
          return l.className = s, l.onClick = this.handleClick, Ym.createElement(e, l);
        }
      }]), a;
    }(Ym.Component), o = function() {
      var i = this;
      this.scrollTo = function(a, s) {
        n.scrollTo(a, oE({}, i.state, s));
      }, this.handleClick = function(a) {
        i.props.onClick && i.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), i.scrollTo(i.props.to, i.props);
      }, this.stateHandler = function() {
        n.getActiveLink() !== i.props.to && (i.state !== null && i.state.active && i.props.onSetInactive && i.props.onSetInactive(), i.setState({ active: !1 }));
      }, this.spyHandler = function(a) {
        var s = i.getScrollSpyContainer();
        if (!(gl.isMounted() && !gl.isInitialized())) {
          var l = i.props.to, u = null, c = 0, p = 0, d = 0;
          if (s.getBoundingClientRect) {
            var g = s.getBoundingClientRect();
            d = g.top;
          }
          if (!u || i.props.isDynamic) {
            if (u = n.get(l), !u)
              return;
            var f = u.getBoundingClientRect();
            c = f.top - d + a, p = c + f.height;
          }
          var m = a - i.props.offset, b = m >= Math.floor(c) && m < Math.floor(p), E = m < Math.floor(c) || m >= Math.floor(p), w = n.getActiveLink();
          if (E)
            return l === w && n.setActiveLink(void 0), i.props.hashSpy && gl.getHash() === l && gl.changeHash(), i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive()), ju.updateStates();
          if (b && w !== l)
            return n.setActiveLink(l), i.props.hashSpy && gl.changeHash(l), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(l)), ju.updateStates();
        }
      };
    };
    return r.propTypes = JF, r.defaultProps = { offset: 0 }, r;
  },
  Element: function(e) {
    console.warn("Helpers.Element is deprecated since v1.7.0");
    var t = function(n) {
      YF(r, n);
      function r(o) {
        KF(this, r);
        var i = XF(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
        return i.childBindings = {
          domNode: null
        }, i;
      }
      return GF(r, [{
        key: "componentDidMount",
        value: function() {
          if (typeof window > "u")
            return !1;
          this.registerElems(this.props.name);
        }
      }, {
        key: "componentDidUpdate",
        value: function(o) {
          this.props.name !== o.name && this.registerElems(this.props.name);
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          if (typeof window > "u")
            return !1;
          iE.unregister(this.props.name);
        }
      }, {
        key: "registerElems",
        value: function(o) {
          iE.register(o, this.childBindings.domNode);
        }
      }, {
        key: "render",
        value: function() {
          return Ym.createElement(e, oE({}, this.props, { parentBindings: this.childBindings }));
        }
      }]), r;
    }(Ym.Component);
    return t.propTypes = {
      name: yo.string,
      id: yo.string
    }, t;
  }
}, MEe = SEe;
Object.defineProperty(jo, "__esModule", {
  value: !0
});
jo.Helpers = jo.ScrollElement = jo.ScrollLink = jo.animateScroll = jo.scrollSpy = jo.Events = jo.scroller = jo.Element = jo.Button = jo.Link = void 0;
var DEe = vD, lQ = va(DEe), TEe = xD, uQ = va(TEe), jEe = ED, cQ = va(jEe), AEe = Bp, pQ = va(AEe), REe = Yh, dQ = va(REe), IEe = Gh, fQ = va(IEe), NEe = VC, hQ = va(NEe), BEe = qh, gQ = va(BEe), FEe = XC, mQ = va(FEe), zEe = MEe, vQ = va(zEe);
function va(e) {
  return e && e.__esModule ? e : { default: e };
}
jo.Link = lQ.default;
jo.Button = uQ.default;
jo.Element = cQ.default;
jo.scroller = pQ.default;
jo.Events = dQ.default;
jo.scrollSpy = fQ.default;
jo.animateScroll = hQ.default;
jo.ScrollLink = gQ.default;
jo.ScrollElement = mQ.default;
jo.Helpers = vQ.default;
jo.default = { Link: lQ.default, Button: uQ.default, Element: cQ.default, scroller: pQ.default, Events: dQ.default, scrollSpy: fQ.default, animateScroll: hQ.default, ScrollLink: gQ.default, ScrollElement: mQ.default, Helpers: vQ.default };
$e({});
$e({});
$e({});
function Ph(e) {
  "@babel/helpers - typeof";
  return Ph = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Ph(e);
}
function UEe(e, t) {
  if (Ph(e) != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (Ph(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function HEe(e) {
  var t = UEe(e, "string");
  return Ph(t) == "symbol" ? t : t + "";
}
function Le(e, t, n) {
  return (t = HEe(t)) in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function yQ(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var sE, QF;
function WEe() {
  if (QF) return sE;
  QF = 1;
  var e = process.env.NODE_ENV, t = function(n, r, o, i, a, s, l, u) {
    if (e !== "production" && r === void 0)
      throw new Error("invariant requires an error message argument");
    if (!n) {
      var c;
      if (r === void 0)
        c = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
      else {
        var p = [o, i, a, s, l, u], d = 0;
        c = new Error(r.replace(/%s/g, function() {
          return p[d++];
        })), c.name = "Invariant Violation";
      }
      throw c.framesToPop = 1, c;
    }
  };
  return sE = t, sE;
}
var $Ee = WEe(), Uo = /* @__PURE__ */ yQ($Ee), Rt = $e(null);
function VEe() {
  Uo(!!ge, "useGoogleMap is React hook and requires React version 16.8+");
  var e = ge(Rt);
  return Uo(!!e, "useGoogleMap needs a GoogleMap available up in the tree"), e;
}
function ZEe(e, t, n) {
  return Object.keys(e).reduce(function(r, o) {
    return t(r, e[o], o);
  }, n);
}
function qEe(e, t) {
  Object.keys(e).forEach((n) => t(e[n], n));
}
function GEe(e, t, n, r) {
  var o = {}, i = (a, s) => {
    var l = n[s];
    l !== t[s] && (o[s] = l, a(r, l));
  };
  return qEe(e, i), o;
}
function KEe(e, t, n) {
  var r = ZEe(n, function(o, i, a) {
    return typeof e[a] == "function" && o.push(google.maps.event.addListener(t, i, e[a])), o;
  }, []);
  return r;
}
function XEe(e) {
  google.maps.event.removeListener(e);
}
function En() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  e.forEach(XEe);
}
function vn(e) {
  var {
    updaterMap: t,
    eventMap: n,
    prevProps: r,
    nextProps: o,
    instance: i
  } = e, a = KEe(o, i, n);
  return GEe(t, r, o, i), a;
}
function YEe(e) {
  var {
    children: t,
    options: n,
    id: r,
    mapContainerStyle: o,
    mapContainerClassName: i,
    center: a,
    // clickableIcons,
    // extraMapTypes,
    // heading,
    // mapTypeId,
    onClick: s,
    onDblClick: l,
    onDrag: u,
    onDragEnd: c,
    onDragStart: p,
    onMouseMove: d,
    onMouseOut: g,
    onMouseOver: f,
    onMouseDown: m,
    onMouseUp: b,
    onRightClick: E,
    // onMapTypeIdChanged,
    // onTilesLoaded,
    // onBoundsChanged,
    onCenterChanged: w,
    // onHeadingChanged,
    // onIdle,
    // onProjectionChanged,
    // onResize,
    // onTiltChanged,
    // onZoomChanged,
    onLoad: M,
    onUnmount: x
  } = e, [v, C] = k(null), P = dt(null), [F, L] = k(null), [B, N] = k(null), [$, V] = k(null), [H, Z] = k(null), [K, Y] = k(null), [Q, J] = k(null), [_, D] = k(null), [z, S] = k(null), [W, O] = k(null), [j, U] = k(null), [T, q] = k(null), [A, X] = k(null);
  return h(() => {
    n && v !== null && v.setOptions(n);
  }, [v, n]), h(() => {
    v !== null && typeof a < "u" && v.setCenter(a);
  }, [v, a]), h(() => {
    v && l && (B !== null && google.maps.event.removeListener(B), N(google.maps.event.addListener(v, "dblclick", l)));
  }, [l]), h(() => {
    v && c && ($ !== null && google.maps.event.removeListener($), V(google.maps.event.addListener(v, "dragend", c)));
  }, [c]), h(() => {
    v && p && (H !== null && google.maps.event.removeListener(H), Z(google.maps.event.addListener(v, "dragstart", p)));
  }, [p]), h(() => {
    v && m && (K !== null && google.maps.event.removeListener(K), Y(google.maps.event.addListener(v, "mousedown", m)));
  }, [m]), h(() => {
    v && d && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(v, "mousemove", d)));
  }, [d]), h(() => {
    v && g && (_ !== null && google.maps.event.removeListener(_), D(google.maps.event.addListener(v, "mouseout", g)));
  }, [g]), h(() => {
    v && f && (z !== null && google.maps.event.removeListener(z), S(google.maps.event.addListener(v, "mouseover", f)));
  }, [f]), h(() => {
    v && b && (W !== null && google.maps.event.removeListener(W), O(google.maps.event.addListener(v, "mouseup", b)));
  }, [b]), h(() => {
    v && E && (j !== null && google.maps.event.removeListener(j), U(google.maps.event.addListener(v, "rightclick", E)));
  }, [E]), h(() => {
    v && s && (T !== null && google.maps.event.removeListener(T), q(google.maps.event.addListener(v, "click", s)));
  }, [s]), h(() => {
    v && u && (A !== null && google.maps.event.removeListener(A), X(google.maps.event.addListener(v, "drag", u)));
  }, [u]), h(() => {
    v && w && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(v, "center_changed", w)));
  }, [s]), h(() => {
    var I = P.current === null ? null : new google.maps.Map(P.current, n);
    return C(I), I !== null && M && M(I), () => {
      I !== null && x && x(I);
    };
  }, []), ni.jsx("div", {
    id: r,
    ref: P,
    style: o,
    className: i,
    children: ni.jsx(Rt.Provider, {
      value: v,
      children: v !== null ? t : null
    })
  });
}
me(YEe);
function ez(e, t, n, r, o, i, a) {
  try {
    var s = e[i](a), l = s.value;
  } catch (u) {
    return void n(u);
  }
  s.done ? t(l) : Promise.resolve(l).then(r, o);
}
function bQ(e) {
  return function() {
    var t = this, n = arguments;
    return new Promise(function(r, o) {
      var i = e.apply(t, n);
      function a(l) {
        ez(i, r, o, a, s, "next", l);
      }
      function s(l) {
        ez(i, r, o, a, s, "throw", l);
      }
      a(void 0);
    });
  };
}
function wQ(e) {
  var {
    googleMapsApiKey: t,
    googleMapsClientId: n,
    version: r = "weekly",
    language: o,
    region: i,
    libraries: a,
    channel: s,
    mapIds: l,
    authReferrerPolicy: u
  } = e, c = [];
  return Uo(t && n || !(t && n), "You need to specify either googleMapsApiKey or googleMapsClientId for @react-google-maps/api load script to work. You cannot use both at the same time."), t ? c.push("key=".concat(t)) : n && c.push("client=".concat(n)), r && c.push("v=".concat(r)), o && c.push("language=".concat(o)), i && c.push("region=".concat(i)), a && a.length && c.push("libraries=".concat(a.sort().join(","))), s && c.push("channel=".concat(s)), l && l.length && c.push("map_ids=".concat(l.join(","))), u && c.push("auth_referrer_policy=".concat(u)), c.push("loading=async"), c.push("callback=initMap"), "https://maps.googleapis.com/maps/api/js?".concat(c.join("&"));
}
var fc = typeof document < "u";
function CQ(e) {
  var {
    url: t,
    id: n,
    nonce: r
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } = e;
  return fc ? new Promise(function(o, i) {
    var a = document.getElementById(n), s = window;
    if (a) {
      var l = a.getAttribute("data-state");
      if (a.src === t && l !== "error") {
        if (l === "ready")
          return o(n);
        var u = s.initMap, c = a.onerror;
        s.initMap = function() {
          u && u(), o(n);
        }, a.onerror = function(d) {
          c && c(d), i(d);
        };
        return;
      } else
        a.remove();
    }
    var p = document.createElement("script");
    p.type = "text/javascript", p.src = t, p.id = n, p.async = !0, p.nonce = r || "", p.onerror = function(d) {
      p.setAttribute("data-state", "error"), i(d);
    }, s.initMap = function() {
      p.setAttribute("data-state", "ready"), o(n);
    }, document.head.appendChild(p);
  }).catch((o) => {
    throw console.error("injectScript error: ", o), o;
  }) : Promise.reject(new Error("document is undefined"));
}
function tz(e) {
  var t = e.href;
  return t && (t.indexOf("https://fonts.googleapis.com/css?family=Roboto") === 0 || t.indexOf("https://fonts.googleapis.com/css?family=Google+Sans+Text") === 0) ? !0 : (
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.styleSheet.cssText = "", !0) : (
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.innerHTML = "", !0) : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.innerHTML
      )
    )
  );
}
function OQ() {
  var e = document.getElementsByTagName("head")[0];
  if (e) {
    var t = e.insertBefore.bind(e);
    e.insertBefore = function(r, o) {
      return tz(r) || Reflect.apply(t, e, [r, o]), r;
    };
    var n = e.appendChild.bind(e);
    e.appendChild = function(r) {
      return tz(r) || Reflect.apply(n, e, [r]), r;
    };
  }
}
var vd = !1;
function xQ() {
  return ni.jsx("div", {
    children: "Loading..."
  });
}
var M_ = {
  id: "script-loader",
  version: "weekly"
};
class JEe extends pe {
  constructor() {
    super(...arguments), Le(this, "check", null), Le(this, "state", {
      loaded: !1
    }), Le(this, "cleanupCallback", () => {
      delete window.google.maps, this.injectScript();
    }), Le(this, "isCleaningUp", /* @__PURE__ */ bQ(function* () {
      function t(n) {
        if (!vd)
          n();
        else if (fc)
          var r = window.setInterval(function() {
            vd || (window.clearInterval(r), n());
          }, 1);
      }
      return new Promise(t);
    })), Le(this, "cleanup", () => {
      vd = !0;
      var t = document.getElementById(this.props.id);
      t && t.parentNode && t.parentNode.removeChild(t), Array.prototype.slice.call(document.getElementsByTagName("script")).filter(function(n) {
        return typeof n.src == "string" && n.src.includes("maps.googleapis");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("link")).filter(function(n) {
        return n.href === "https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Google+Sans";
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("style")).filter(function(n) {
        return n.innerText !== void 0 && n.innerText.length > 0 && n.innerText.includes(".gm-");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      });
    }), Le(this, "injectScript", () => {
      this.props.preventGoogleFontsLoading && OQ(), Uo(!!this.props.id, 'LoadScript requires "id" prop to be a string: %s', this.props.id);
      var t = {
        id: this.props.id,
        nonce: this.props.nonce,
        url: wQ(this.props)
      };
      CQ(t).then(() => {
        this.props.onLoad && this.props.onLoad(), this.setState(function() {
          return {
            loaded: !0
          };
        });
      }).catch((n) => {
        this.props.onError && this.props.onError(n), console.error(`
          There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(this.props.googleMapsApiKey || "-", ") or Client ID (").concat(this.props.googleMapsClientId || "-", `) to <LoadScript />
          Otherwise it is a Network issue.
        `));
      });
    }), Le(this, "getRef", (t) => {
      this.check = t;
    });
  }
  componentDidMount() {
    if (fc) {
      if (window.google && window.google.maps && !vd) {
        console.error("google api is already presented");
        return;
      }
      this.isCleaningUp().then(this.injectScript).catch(function(t) {
        console.error("Error at injecting script after cleaning up: ", t);
      });
    }
  }
  componentDidUpdate(t) {
    this.props.libraries !== t.libraries && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), fc && t.language !== this.props.language && (this.cleanup(), this.setState(function() {
      return {
        loaded: !1
      };
    }, this.cleanupCallback));
  }
  componentWillUnmount() {
    if (fc) {
      this.cleanup();
      var t = () => {
        this.check || (delete window.google, vd = !1);
      };
      window.setTimeout(t, 1), this.props.onUnmount && this.props.onUnmount();
    }
  }
  render() {
    return ni.jsxs(ni.Fragment, {
      children: [ni.jsx("div", {
        ref: this.getRef
      }), this.state.loaded ? this.props.children : this.props.loadingElement || ni.jsx(xQ, {})]
    });
  }
}
Le(JEe, "defaultProps", M_);
function QEe(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.includes(r)) continue;
    n[r] = e[r];
  }
  return n;
}
function LD(e, t) {
  if (e == null) return {};
  var n, r, o = QEe(e, t);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (r = 0; r < i.length; r++) n = i[r], t.includes(n) || {}.propertyIsEnumerable.call(e, n) && (o[n] = e[n]);
  }
  return o;
}
var nz;
function eke(e) {
  var {
    id: t = M_.id,
    version: n = M_.version,
    nonce: r,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    preventGoogleFontsLoading: u,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  } = e, g = dt(!1), [f, m] = k(!1), [b, E] = k(void 0);
  h(function() {
    return g.current = !0, () => {
      g.current = !1;
    };
  }, []), h(function() {
    fc && u && OQ();
  }, [u]), h(function() {
    f && Uo(!!window.google, "useLoadScript was marked as loaded, but window.google is not present. Something went wrong.");
  }, [f]);
  var w = wQ({
    version: n,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  });
  h(function() {
    if (!fc)
      return;
    function x() {
      g.current && (m(!0), nz = w);
    }
    if (window.google && window.google.maps && nz === w) {
      x();
      return;
    }
    CQ({
      id: t,
      url: w,
      nonce: r
    }).then(x).catch(function(v) {
      g.current && E(v), console.warn(`
        There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(o || "-", ") or Client ID (").concat(i || "-", `)
        Otherwise it is a Network issue.
      `)), console.error(v);
    });
  }, [t, w, r]);
  var M = dt(void 0);
  return h(function() {
    M.current && l !== M.current && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), M.current = l;
  }, [l]), {
    isLoaded: f,
    loadError: b,
    url: w
  };
}
var tke = ["loadingElement", "onLoad", "onError", "onUnmount", "children"], nke = ni.jsx(xQ, {});
function rke(e) {
  var {
    loadingElement: t,
    onLoad: n,
    onError: r,
    onUnmount: o,
    children: i
  } = e, a = LD(e, tke), {
    isLoaded: s,
    loadError: l
  } = eke(a);
  return h(function() {
    s && typeof n == "function" && n();
  }, [s, n]), h(function() {
    l && typeof r == "function" && r(l);
  }, [l, r]), h(function() {
    return () => {
      o && o();
    };
  }, [o]), s ? i : t || nke;
}
me(rke);
var rz;
(function(e) {
  e[e.INITIALIZED = 0] = "INITIALIZED", e[e.LOADING = 1] = "LOADING", e[e.SUCCESS = 2] = "SUCCESS", e[e.FAILURE = 3] = "FAILURE";
})(rz || (rz = {}));
function oz(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Sb(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? oz(Object(n), !0).forEach(function(r) {
      Le(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : oz(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var iz = {}, sz = {
  options(e, t) {
    e.setOptions(t);
  }
};
function oke(e) {
  var {
    options: t,
    onLoad: n,
    onUnmount: r
  } = e, o = ge(Rt), [i, a] = k(null);
  return h(() => {
    i !== null && i.setMap(o);
  }, [o]), h(() => {
    t && i !== null && i.setOptions(t);
  }, [i, t]), h(() => {
    var s = new google.maps.TrafficLayer(Sb(Sb({}, t), {}, {
      map: o
    }));
    return a(s), n && n(s), () => {
      i !== null && (r && r(i), i.setMap(null));
    };
  }, []), null;
}
me(oke);
class ike extends pe {
  constructor() {
    super(...arguments), Le(this, "state", {
      trafficLayer: null
    }), Le(this, "setTrafficLayerCallback", () => {
      this.state.trafficLayer !== null && this.props.onLoad && this.props.onLoad(this.state.trafficLayer);
    }), Le(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = new google.maps.TrafficLayer(Sb(Sb({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = vn({
      updaterMap: sz,
      eventMap: iz,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        trafficLayer: t
      };
    }, this.setTrafficLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.trafficLayer !== null && (En(this.registeredEvents), this.registeredEvents = vn({
      updaterMap: sz,
      eventMap: iz,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.trafficLayer
    }));
  }
  componentWillUnmount() {
    this.state.trafficLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.trafficLayer), En(this.registeredEvents), this.state.trafficLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Le(ike, "contextType", Rt);
function ske(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = ge(Rt), [o, i] = k(null);
  return h(() => {
    o !== null && o.setMap(r);
  }, [r]), h(() => {
    var a = new google.maps.BicyclingLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      a !== null && (n && n(a), a.setMap(null));
    };
  }, []), null;
}
me(ske);
class ake extends pe {
  constructor() {
    super(...arguments), Le(this, "state", {
      bicyclingLayer: null
    }), Le(this, "setBicyclingLayerCallback", () => {
      this.state.bicyclingLayer !== null && (this.state.bicyclingLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.bicyclingLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.BicyclingLayer();
    this.setState(() => ({
      bicyclingLayer: t
    }), this.setBicyclingLayerCallback);
  }
  componentWillUnmount() {
    this.state.bicyclingLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.bicyclingLayer), this.state.bicyclingLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Le(ake, "contextType", Rt);
function lke(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = ge(Rt), [o, i] = k(null);
  return h(() => {
    o !== null && o.setMap(r);
  }, [r]), h(() => {
    var a = new google.maps.TransitLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      o !== null && (n && n(o), o.setMap(null));
    };
  }, []), null;
}
me(lke);
class uke extends pe {
  constructor() {
    super(...arguments), Le(this, "state", {
      transitLayer: null
    }), Le(this, "setTransitLayerCallback", () => {
      this.state.transitLayer !== null && (this.state.transitLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.transitLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.TransitLayer();
    this.setState(function() {
      return {
        transitLayer: t
      };
    }, this.setTransitLayerCallback);
  }
  componentWillUnmount() {
    this.state.transitLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.transitLayer), this.state.transitLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Le(uke, "contextType", Rt);
function az(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Mb(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? az(Object(n), !0).forEach(function(r) {
      Le(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : az(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var lz = {
  onCircleComplete: "circlecomplete",
  onMarkerComplete: "markercomplete",
  onOverlayComplete: "overlaycomplete",
  onPolygonComplete: "polygoncomplete",
  onPolylineComplete: "polylinecomplete",
  onRectangleComplete: "rectanglecomplete"
}, uz = {
  drawingMode(e, t) {
    e.setDrawingMode(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function cke(e) {
  var {
    options: t,
    drawingMode: n,
    onCircleComplete: r,
    onMarkerComplete: o,
    onOverlayComplete: i,
    onPolygonComplete: a,
    onPolylineComplete: s,
    onRectangleComplete: l,
    onLoad: u,
    onUnmount: c
  } = e, p = ge(Rt), [d, g] = k(null), [f, m] = k(null), [b, E] = k(null), [w, M] = k(null), [x, v] = k(null), [C, P] = k(null), [F, L] = k(null);
  return h(() => {
    d !== null && d.setMap(p);
  }, [p]), h(() => {
    t && d !== null && d.setOptions(t);
  }, [d, t]), h(() => {
    d !== null && d.setDrawingMode(n ?? null);
  }, [d, n]), h(() => {
    d && r && (f !== null && google.maps.event.removeListener(f), m(google.maps.event.addListener(d, "circlecomplete", r)));
  }, [d, r]), h(() => {
    d && o && (b !== null && google.maps.event.removeListener(b), E(google.maps.event.addListener(d, "markercomplete", o)));
  }, [d, o]), h(() => {
    d && i && (w !== null && google.maps.event.removeListener(w), M(google.maps.event.addListener(d, "overlaycomplete", i)));
  }, [d, i]), h(() => {
    d && a && (x !== null && google.maps.event.removeListener(x), v(google.maps.event.addListener(d, "polygoncomplete", a)));
  }, [d, a]), h(() => {
    d && s && (C !== null && google.maps.event.removeListener(C), P(google.maps.event.addListener(d, "polylinecomplete", s)));
  }, [d, s]), h(() => {
    d && l && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(d, "rectanglecomplete", l)));
  }, [d, l]), h(() => {
    Uo(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
    var B = new google.maps.drawing.DrawingManager(Mb(Mb({}, t), {}, {
      map: p
    }));
    return n && B.setDrawingMode(n), r && m(google.maps.event.addListener(B, "circlecomplete", r)), o && E(google.maps.event.addListener(B, "markercomplete", o)), i && M(google.maps.event.addListener(B, "overlaycomplete", i)), a && v(google.maps.event.addListener(B, "polygoncomplete", a)), s && P(google.maps.event.addListener(B, "polylinecomplete", s)), l && L(google.maps.event.addListener(B, "rectanglecomplete", l)), g(B), u && u(B), () => {
      d !== null && (f && google.maps.event.removeListener(f), b && google.maps.event.removeListener(b), w && google.maps.event.removeListener(w), x && google.maps.event.removeListener(x), C && google.maps.event.removeListener(C), F && google.maps.event.removeListener(F), c && c(d), d.setMap(null));
    };
  }, []), null;
}
me(cke);
class pke extends pe {
  constructor(t) {
    super(t), Le(this, "registeredEvents", []), Le(this, "state", {
      drawingManager: null
    }), Le(this, "setDrawingManagerCallback", () => {
      this.state.drawingManager !== null && this.props.onLoad && this.props.onLoad(this.state.drawingManager);
    }), Uo(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
  }
  componentDidMount() {
    var t = new google.maps.drawing.DrawingManager(Mb(Mb({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = vn({
      updaterMap: uz,
      eventMap: lz,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        drawingManager: t
      };
    }, this.setDrawingManagerCallback);
  }
  componentDidUpdate(t) {
    this.state.drawingManager !== null && (En(this.registeredEvents), this.registeredEvents = vn({
      updaterMap: uz,
      eventMap: lz,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.drawingManager
    }));
  }
  componentWillUnmount() {
    this.state.drawingManager !== null && (this.props.onUnmount && this.props.onUnmount(this.state.drawingManager), En(this.registeredEvents), this.state.drawingManager.setMap(null));
  }
  render() {
    return null;
  }
}
Le(pke, "contextType", Rt);
function cz(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function cp(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? cz(Object(n), !0).forEach(function(r) {
      Le(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : cz(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var pz = {
  onAnimationChanged: "animation_changed",
  onClick: "click",
  onClickableChanged: "clickable_changed",
  onCursorChanged: "cursor_changed",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDraggableChanged: "draggable_changed",
  onDragStart: "dragstart",
  onFlatChanged: "flat_changed",
  onIconChanged: "icon_changed",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onPositionChanged: "position_changed",
  onRightClick: "rightclick",
  onShapeChanged: "shape_changed",
  onTitleChanged: "title_changed",
  onVisibleChanged: "visible_changed",
  onZindexChanged: "zindex_changed"
}, dz = {
  animation(e, t) {
    e.setAnimation(t);
  },
  clickable(e, t) {
    e.setClickable(t);
  },
  cursor(e, t) {
    e.setCursor(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  icon(e, t) {
    e.setIcon(t);
  },
  label(e, t) {
    e.setLabel(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  opacity(e, t) {
    e.setOpacity(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  shape(e, t) {
    e.setShape(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, Db = {};
function dke(e) {
  var {
    position: t,
    options: n,
    clusterer: r,
    noClustererRedraw: o,
    children: i,
    draggable: a,
    visible: s,
    animation: l,
    clickable: u,
    cursor: c,
    icon: p,
    label: d,
    opacity: g,
    shape: f,
    title: m,
    zIndex: b,
    onClick: E,
    onDblClick: w,
    onDrag: M,
    onDragEnd: x,
    onDragStart: v,
    onMouseOut: C,
    onMouseOver: P,
    onMouseUp: F,
    onMouseDown: L,
    onRightClick: B,
    onClickableChanged: N,
    onCursorChanged: $,
    onAnimationChanged: V,
    onDraggableChanged: H,
    onFlatChanged: Z,
    onIconChanged: K,
    onPositionChanged: Y,
    onShapeChanged: Q,
    onTitleChanged: J,
    onVisibleChanged: _,
    onZindexChanged: D,
    onLoad: z,
    onUnmount: S
  } = e, W = ge(Rt), [O, j] = k(null), [U, T] = k(null), [q, A] = k(null), [X, I] = k(null), [le, he] = k(null), [oe, Ae] = k(null), [Ue, He] = k(null), [Re, nt] = k(null), [Ve, we] = k(null), [et, lt] = k(null), [ye, ke] = k(null), [Qe, Fe] = k(null), [Ie, ot] = k(null), [Ee, wt] = k(null), [it, st] = k(null), [ut, Ct] = k(null), [ct, pt] = k(null), [rt, We] = k(null), [Ot, xt] = k(null), [gt, Ht] = k(null), [mt, Wt] = k(null), [vt, kt] = k(null);
  h(() => {
    O !== null && O.setMap(W);
  }, [W]), h(() => {
    typeof n < "u" && O !== null && O.setOptions(n);
  }, [O, n]), h(() => {
    typeof a < "u" && O !== null && O.setDraggable(a);
  }, [O, a]), h(() => {
    t && O !== null && O.setPosition(t);
  }, [O, t]), h(() => {
    typeof s < "u" && O !== null && O.setVisible(s);
  }, [O, s]), h(() => {
    O == null || O.setAnimation(l);
  }, [O, l]), h(() => {
    O && u !== void 0 && O.setClickable(u);
  }, [O, u]), h(() => {
    O && c !== void 0 && O.setCursor(c);
  }, [O, c]), h(() => {
    O && p !== void 0 && O.setIcon(p);
  }, [O, p]), h(() => {
    O && d !== void 0 && O.setLabel(d);
  }, [O, d]), h(() => {
    O && g !== void 0 && O.setOpacity(g);
  }, [O, g]), h(() => {
    O && f !== void 0 && O.setShape(f);
  }, [O, f]), h(() => {
    O && m !== void 0 && O.setTitle(m);
  }, [O, m]), h(() => {
    O && b !== void 0 && O.setZIndex(b);
  }, [O, b]), h(() => {
    O && w && (U !== null && google.maps.event.removeListener(U), T(google.maps.event.addListener(O, "dblclick", w)));
  }, [w]), h(() => {
    O && x && (q !== null && google.maps.event.removeListener(q), A(google.maps.event.addListener(O, "dragend", x)));
  }, [x]), h(() => {
    O && v && (X !== null && google.maps.event.removeListener(X), I(google.maps.event.addListener(O, "dragstart", v)));
  }, [v]), h(() => {
    O && L && (le !== null && google.maps.event.removeListener(le), he(google.maps.event.addListener(O, "mousedown", L)));
  }, [L]), h(() => {
    O && C && (oe !== null && google.maps.event.removeListener(oe), Ae(google.maps.event.addListener(O, "mouseout", C)));
  }, [C]), h(() => {
    O && P && (Ue !== null && google.maps.event.removeListener(Ue), He(google.maps.event.addListener(O, "mouseover", P)));
  }, [P]), h(() => {
    O && F && (Re !== null && google.maps.event.removeListener(Re), nt(google.maps.event.addListener(O, "mouseup", F)));
  }, [F]), h(() => {
    O && B && (Ve !== null && google.maps.event.removeListener(Ve), we(google.maps.event.addListener(O, "rightclick", B)));
  }, [B]), h(() => {
    O && E && (et !== null && google.maps.event.removeListener(et), lt(google.maps.event.addListener(O, "click", E)));
  }, [E]), h(() => {
    O && M && (ye !== null && google.maps.event.removeListener(ye), ke(google.maps.event.addListener(O, "drag", M)));
  }, [M]), h(() => {
    O && N && (Qe !== null && google.maps.event.removeListener(Qe), Fe(google.maps.event.addListener(O, "clickable_changed", N)));
  }, [N]), h(() => {
    O && $ && (Ie !== null && google.maps.event.removeListener(Ie), ot(google.maps.event.addListener(O, "cursor_changed", $)));
  }, [$]), h(() => {
    O && V && (Ee !== null && google.maps.event.removeListener(Ee), wt(google.maps.event.addListener(O, "animation_changed", V)));
  }, [V]), h(() => {
    O && H && (it !== null && google.maps.event.removeListener(it), st(google.maps.event.addListener(O, "draggable_changed", H)));
  }, [H]), h(() => {
    O && Z && (ut !== null && google.maps.event.removeListener(ut), Ct(google.maps.event.addListener(O, "flat_changed", Z)));
  }, [Z]), h(() => {
    O && K && (ct !== null && google.maps.event.removeListener(ct), pt(google.maps.event.addListener(O, "icon_changed", K)));
  }, [K]), h(() => {
    O && Y && (rt !== null && google.maps.event.removeListener(rt), We(google.maps.event.addListener(O, "position_changed", Y)));
  }, [Y]), h(() => {
    O && Q && (Ot !== null && google.maps.event.removeListener(Ot), xt(google.maps.event.addListener(O, "shape_changed", Q)));
  }, [Q]), h(() => {
    O && J && (gt !== null && google.maps.event.removeListener(gt), Ht(google.maps.event.addListener(O, "title_changed", J)));
  }, [J]), h(() => {
    O && _ && (mt !== null && google.maps.event.removeListener(mt), Wt(google.maps.event.addListener(O, "visible_changed", _)));
  }, [_]), h(() => {
    O && D && (vt !== null && google.maps.event.removeListener(vt), kt(google.maps.event.addListener(O, "zindex_changed", D)));
  }, [D]), h(() => {
    var yt = cp(cp(cp({}, n || Db), r ? Db : {
      map: W
    }), {}, {
      position: t
    }), re = new google.maps.Marker(yt);
    return r ? r.addMarker(re, !!o) : re.setMap(W), t && re.setPosition(t), typeof s < "u" && re.setVisible(s), typeof a < "u" && re.setDraggable(a), typeof u < "u" && re.setClickable(u), typeof c == "string" && re.setCursor(c), p && re.setIcon(p), typeof d < "u" && re.setLabel(d), typeof g < "u" && re.setOpacity(g), f && re.setShape(f), typeof m == "string" && re.setTitle(m), typeof b == "number" && re.setZIndex(b), w && T(google.maps.event.addListener(re, "dblclick", w)), x && A(google.maps.event.addListener(re, "dragend", x)), v && I(google.maps.event.addListener(re, "dragstart", v)), L && he(google.maps.event.addListener(re, "mousedown", L)), C && Ae(google.maps.event.addListener(re, "mouseout", C)), P && He(google.maps.event.addListener(re, "mouseover", P)), F && nt(google.maps.event.addListener(re, "mouseup", F)), B && we(google.maps.event.addListener(re, "rightclick", B)), E && lt(google.maps.event.addListener(re, "click", E)), M && ke(google.maps.event.addListener(re, "drag", M)), N && Fe(google.maps.event.addListener(re, "clickable_changed", N)), $ && ot(google.maps.event.addListener(re, "cursor_changed", $)), V && wt(google.maps.event.addListener(re, "animation_changed", V)), H && st(google.maps.event.addListener(re, "draggable_changed", H)), Z && Ct(google.maps.event.addListener(re, "flat_changed", Z)), K && pt(google.maps.event.addListener(re, "icon_changed", K)), Y && We(google.maps.event.addListener(re, "position_changed", Y)), Q && xt(google.maps.event.addListener(re, "shape_changed", Q)), J && Ht(google.maps.event.addListener(re, "title_changed", J)), _ && Wt(google.maps.event.addListener(re, "visible_changed", _)), D && kt(google.maps.event.addListener(re, "zindex_changed", D)), j(re), z && z(re), () => {
      U !== null && google.maps.event.removeListener(U), q !== null && google.maps.event.removeListener(q), X !== null && google.maps.event.removeListener(X), le !== null && google.maps.event.removeListener(le), oe !== null && google.maps.event.removeListener(oe), Ue !== null && google.maps.event.removeListener(Ue), Re !== null && google.maps.event.removeListener(Re), Ve !== null && google.maps.event.removeListener(Ve), et !== null && google.maps.event.removeListener(et), Qe !== null && google.maps.event.removeListener(Qe), Ie !== null && google.maps.event.removeListener(Ie), Ee !== null && google.maps.event.removeListener(Ee), it !== null && google.maps.event.removeListener(it), ut !== null && google.maps.event.removeListener(ut), ct !== null && google.maps.event.removeListener(ct), rt !== null && google.maps.event.removeListener(rt), gt !== null && google.maps.event.removeListener(gt), mt !== null && google.maps.event.removeListener(mt), vt !== null && google.maps.event.removeListener(vt), S && S(re), r ? r.removeMarker(re, !!o) : re && re.setMap(null);
    };
  }, []);
  var Un = ln(() => i ? at.map(i, (yt) => {
    if (!yi(yt))
      return yt;
    var re = yt;
    return bi(re, {
      anchor: O
    });
  }) : null, [i, O]);
  return ni.jsx(ni.Fragment, {
    children: Un
  }) || null;
}
me(dke);
class fke extends pe {
  constructor() {
    super(...arguments), Le(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this;
    return bQ(function* () {
      var n = cp(cp(cp({}, t.props.options || Db), t.props.clusterer ? Db : {
        map: t.context
      }), {}, {
        position: t.props.position
      });
      t.marker = new google.maps.Marker(n), t.props.clusterer ? t.props.clusterer.addMarker(t.marker, !!t.props.noClustererRedraw) : t.marker.setMap(t.context), t.registeredEvents = vn({
        updaterMap: dz,
        eventMap: pz,
        prevProps: {},
        nextProps: t.props,
        instance: t.marker
      }), t.props.onLoad && t.props.onLoad(t.marker);
    })();
  }
  componentDidUpdate(t) {
    this.marker && (En(this.registeredEvents), this.registeredEvents = vn({
      updaterMap: dz,
      eventMap: pz,
      prevProps: t,
      nextProps: this.props,
      instance: this.marker
    }));
  }
  componentWillUnmount() {
    this.marker && (this.props.onUnmount && this.props.onUnmount(this.marker), En(this.registeredEvents), this.props.clusterer ? this.props.clusterer.removeMarker(this.marker, !!this.props.noClustererRedraw) : this.marker && this.marker.setMap(null));
  }
  render() {
    var t = this.props.children ? at.map(this.props.children, (n) => {
      if (!yi(n))
        return n;
      var r = n;
      return bi(r, {
        anchor: this.marker
      });
    }) : null;
    return t || null;
  }
}
Le(fke, "contextType", Rt);
var hke = (
  /** @class */
  function() {
    function e(t, n) {
      t.getClusterer().extend(e, google.maps.OverlayView), this.cluster = t, this.clusterClassName = this.cluster.getClusterer().getClusterClass(), this.className = this.clusterClassName, this.styles = n, this.center = void 0, this.div = null, this.sums = null, this.visible = !1, this.boundsChangedListener = null, this.url = "", this.height = 0, this.width = 0, this.anchorText = [0, 0], this.anchorIcon = [0, 0], this.textColor = "black", this.textSize = 11, this.textDecoration = "none", this.fontWeight = "bold", this.fontStyle = "normal", this.fontFamily = "Arial,sans-serif", this.backgroundPosition = "0 0", this.cMouseDownInCluster = null, this.cDraggingMapByCluster = null, this.timeOut = null, this.setMap(t.getMap()), this.onBoundsChanged = this.onBoundsChanged.bind(this), this.onMouseDown = this.onMouseDown.bind(this), this.onClick = this.onClick.bind(this), this.onMouseOver = this.onMouseOver.bind(this), this.onMouseOut = this.onMouseOut.bind(this), this.onAdd = this.onAdd.bind(this), this.onRemove = this.onRemove.bind(this), this.draw = this.draw.bind(this), this.hide = this.hide.bind(this), this.show = this.show.bind(this), this.useStyle = this.useStyle.bind(this), this.setCenter = this.setCenter.bind(this), this.getPosFromLatLng = this.getPosFromLatLng.bind(this);
    }
    return e.prototype.onBoundsChanged = function() {
      this.cDraggingMapByCluster = this.cMouseDownInCluster;
    }, e.prototype.onMouseDown = function() {
      this.cMouseDownInCluster = !0, this.cDraggingMapByCluster = !1;
    }, e.prototype.onClick = function(t) {
      if (this.cMouseDownInCluster = !1, !this.cDraggingMapByCluster) {
        var n = this.cluster.getClusterer();
        if (google.maps.event.trigger(n, "click", this.cluster), google.maps.event.trigger(n, "clusterclick", this.cluster), n.getZoomOnClick()) {
          var r = n.getMaxZoom(), o = this.cluster.getBounds(), i = n.getMap();
          i !== null && "fitBounds" in i && i.fitBounds(o), this.timeOut = window.setTimeout(function() {
            var a = n.getMap();
            if (a !== null) {
              "fitBounds" in a && a.fitBounds(o);
              var s = a.getZoom() || 0;
              r !== null && s > r && a.setZoom(r + 1);
            }
          }, 100);
        }
        t.cancelBubble = !0, t.stopPropagation && t.stopPropagation();
      }
    }, e.prototype.onMouseOver = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseover", this.cluster);
    }, e.prototype.onMouseOut = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseout", this.cluster);
    }, e.prototype.onAdd = function() {
      var t;
      this.div = document.createElement("div"), this.div.className = this.className, this.visible && this.show(), (t = this.getPanes()) === null || t === void 0 || t.overlayMouseTarget.appendChild(this.div);
      var n = this.getMap();
      n !== null && (this.boundsChangedListener = google.maps.event.addListener(n, "bounds_changed", this.onBoundsChanged), this.div.addEventListener("mousedown", this.onMouseDown), this.div.addEventListener("click", this.onClick), this.div.addEventListener("mouseover", this.onMouseOver), this.div.addEventListener("mouseout", this.onMouseOut));
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.hide(), this.boundsChangedListener !== null && google.maps.event.removeListener(this.boundsChangedListener), this.div.removeEventListener("mousedown", this.onMouseDown), this.div.removeEventListener("click", this.onClick), this.div.removeEventListener("mouseover", this.onMouseOver), this.div.removeEventListener("mouseout", this.onMouseOut), this.div.parentNode.removeChild(this.div), this.timeOut !== null && (window.clearTimeout(this.timeOut), this.timeOut = null), this.div = null);
    }, e.prototype.draw = function() {
      if (this.visible && this.div !== null && this.center) {
        var t = this.getPosFromLatLng(this.center);
        this.div.style.top = t !== null ? "".concat(t.y, "px") : "0", this.div.style.left = t !== null ? "".concat(t.x, "px") : "0";
      }
    }, e.prototype.hide = function() {
      this.div && (this.div.style.display = "none"), this.visible = !1;
    }, e.prototype.show = function() {
      var t, n, r, o, i, a;
      if (this.div && this.center) {
        var s = this.sums === null || typeof this.sums.title > "u" || this.sums.title === "" ? this.cluster.getClusterer().getTitle() : this.sums.title, l = this.backgroundPosition.split(" "), u = parseInt(((t = l[0]) === null || t === void 0 ? void 0 : t.replace(/^\s+|\s+$/g, "")) || "0", 10), c = parseInt(((n = l[1]) === null || n === void 0 ? void 0 : n.replace(/^\s+|\s+$/g, "")) || "0", 10), p = this.getPosFromLatLng(this.center);
        this.div.className = this.className, this.div.setAttribute("style", "cursor: pointer; position: absolute; top: ".concat(p !== null ? "".concat(p.y, "px") : "0", "; left: ").concat(p !== null ? "".concat(p.x, "px") : "0", "; width: ").concat(this.width, "px; height: ").concat(this.height, "px; "));
        var d = document.createElement("img");
        d.alt = s, d.src = this.url, d.width = this.width, d.height = this.height, d.setAttribute("style", "position: absolute; top: ".concat(c, "px; left: ").concat(u, "px")), this.cluster.getClusterer().enableRetinaIcons || (d.style.clip = "rect(-".concat(c, "px, -").concat(u + this.width, "px, -").concat(c + this.height, ", -").concat(u, ")"));
        var g = document.createElement("div");
        g.setAttribute("style", "position: absolute; top: ".concat(this.anchorText[0], "px; left: ").concat(this.anchorText[1], "px; color: ").concat(this.textColor, "; font-size: ").concat(this.textSize, "px; font-family: ").concat(this.fontFamily, "; font-weight: ").concat(this.fontWeight, "; fontStyle: ").concat(this.fontStyle, "; text-decoration: ").concat(this.textDecoration, "; text-align: center; width: ").concat(this.width, "px; line-height: ").concat(this.height, "px")), !((r = this.sums) === null || r === void 0) && r.text && (g.innerText = "".concat((o = this.sums) === null || o === void 0 ? void 0 : o.text)), !((i = this.sums) === null || i === void 0) && i.html && (g.innerHTML = "".concat((a = this.sums) === null || a === void 0 ? void 0 : a.html)), this.div.innerHTML = "", this.div.appendChild(d), this.div.appendChild(g), this.div.title = s, this.div.style.display = "";
      }
      this.visible = !0;
    }, e.prototype.useStyle = function(t) {
      this.sums = t;
      var n = this.cluster.getClusterer().getStyles(), r = n[Math.min(n.length - 1, Math.max(0, t.index - 1))];
      r && (this.url = r.url, this.height = r.height, this.width = r.width, r.className && (this.className = "".concat(this.clusterClassName, " ").concat(r.className)), this.anchorText = r.anchorText || [0, 0], this.anchorIcon = r.anchorIcon || [this.height / 2, this.width / 2], this.textColor = r.textColor || "black", this.textSize = r.textSize || 11, this.textDecoration = r.textDecoration || "none", this.fontWeight = r.fontWeight || "bold", this.fontStyle = r.fontStyle || "normal", this.fontFamily = r.fontFamily || "Arial,sans-serif", this.backgroundPosition = r.backgroundPosition || "0 0");
    }, e.prototype.setCenter = function(t) {
      this.center = t;
    }, e.prototype.getPosFromLatLng = function(t) {
      var n = this.getProjection().fromLatLngToDivPixel(t);
      return n !== null && (n.x -= this.anchorIcon[1], n.y -= this.anchorIcon[0]), n;
    }, e;
  }()
), gke = (
  /** @class */
  function() {
    function e(t) {
      this.markerClusterer = t, this.map = this.markerClusterer.getMap(), this.gridSize = this.markerClusterer.getGridSize(), this.minClusterSize = this.markerClusterer.getMinimumClusterSize(), this.averageCenter = this.markerClusterer.getAverageCenter(), this.markers = [], this.center = void 0, this.bounds = null, this.clusterIcon = new hke(this, this.markerClusterer.getStyles()), this.getSize = this.getSize.bind(this), this.getMarkers = this.getMarkers.bind(this), this.getCenter = this.getCenter.bind(this), this.getMap = this.getMap.bind(this), this.getClusterer = this.getClusterer.bind(this), this.getBounds = this.getBounds.bind(this), this.remove = this.remove.bind(this), this.addMarker = this.addMarker.bind(this), this.isMarkerInClusterBounds = this.isMarkerInClusterBounds.bind(this), this.calculateBounds = this.calculateBounds.bind(this), this.updateIcon = this.updateIcon.bind(this), this.isMarkerAlreadyAdded = this.isMarkerAlreadyAdded.bind(this);
    }
    return e.prototype.getSize = function() {
      return this.markers.length;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getCenter = function() {
      return this.center;
    }, e.prototype.getMap = function() {
      return this.map;
    }, e.prototype.getClusterer = function() {
      return this.markerClusterer;
    }, e.prototype.getBounds = function() {
      for (var t = new google.maps.LatLngBounds(this.center, this.center), n = this.getMarkers(), r = 0, o = n; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && t.extend(a);
      }
      return t;
    }, e.prototype.remove = function() {
      this.clusterIcon.setMap(null), this.markers = [], delete this.markers;
    }, e.prototype.addMarker = function(t) {
      var n;
      if (this.isMarkerAlreadyAdded(t))
        return !1;
      if (this.center) {
        if (this.averageCenter) {
          var r = t.getPosition();
          if (r) {
            var o = this.markers.length + 1;
            this.center = new google.maps.LatLng((this.center.lat() * (o - 1) + r.lat()) / o, (this.center.lng() * (o - 1) + r.lng()) / o), this.calculateBounds();
          }
        }
      } else {
        var r = t.getPosition();
        r && (this.center = r, this.calculateBounds());
      }
      t.isAdded = !0, this.markers.push(t);
      var i = this.markers.length, a = this.markerClusterer.getMaxZoom(), s = (n = this.map) === null || n === void 0 ? void 0 : n.getZoom();
      if (a !== null && typeof s < "u" && s > a)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i < this.minClusterSize)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i === this.minClusterSize)
        for (var l = 0, u = this.markers; l < u.length; l++) {
          var c = u[l];
          c.setMap(null);
        }
      else
        t.setMap(null);
      return !0;
    }, e.prototype.isMarkerInClusterBounds = function(t) {
      if (this.bounds !== null) {
        var n = t.getPosition();
        if (n)
          return this.bounds.contains(n);
      }
      return !1;
    }, e.prototype.calculateBounds = function() {
      this.bounds = this.markerClusterer.getExtendedBounds(new google.maps.LatLngBounds(this.center, this.center));
    }, e.prototype.updateIcon = function() {
      var t, n = this.markers.length, r = this.markerClusterer.getMaxZoom(), o = (t = this.map) === null || t === void 0 ? void 0 : t.getZoom();
      if (r !== null && typeof o < "u" && o > r) {
        this.clusterIcon.hide();
        return;
      }
      if (n < this.minClusterSize) {
        this.clusterIcon.hide();
        return;
      }
      this.center && this.clusterIcon.setCenter(this.center), this.clusterIcon.useStyle(this.markerClusterer.getCalculator()(this.markers, this.markerClusterer.getStyles().length)), this.clusterIcon.show();
    }, e.prototype.isMarkerAlreadyAdded = function(t) {
      if (this.markers.includes)
        return this.markers.includes(t);
      for (var n = 0; n < this.markers.length; n++)
        if (t === this.markers[n])
          return !0;
      return !1;
    }, e;
  }()
);
function mke(e, t) {
  var n = e.length, r = n.toString().length, o = Math.min(r, t);
  return {
    text: n.toString(),
    index: o,
    title: ""
  };
}
var vke = 2e3, yke = 500, bke = "https://developers.google.com/maps/documentation/javascript/examples/markerclusterer/m", wke = "png", Cke = [53, 56, 66, 78, 90], Oke = "cluster", EQ = (
  /** @class */
  function() {
    function e(t, n, r) {
      n === void 0 && (n = []), r === void 0 && (r = {}), this.getMinimumClusterSize = this.getMinimumClusterSize.bind(this), this.setMinimumClusterSize = this.setMinimumClusterSize.bind(this), this.getEnableRetinaIcons = this.getEnableRetinaIcons.bind(this), this.setEnableRetinaIcons = this.setEnableRetinaIcons.bind(this), this.addToClosestCluster = this.addToClosestCluster.bind(this), this.getImageExtension = this.getImageExtension.bind(this), this.setImageExtension = this.setImageExtension.bind(this), this.getExtendedBounds = this.getExtendedBounds.bind(this), this.getAverageCenter = this.getAverageCenter.bind(this), this.setAverageCenter = this.setAverageCenter.bind(this), this.getTotalClusters = this.getTotalClusters.bind(this), this.fitMapToMarkers = this.fitMapToMarkers.bind(this), this.getIgnoreHidden = this.getIgnoreHidden.bind(this), this.setIgnoreHidden = this.setIgnoreHidden.bind(this), this.getClusterClass = this.getClusterClass.bind(this), this.setClusterClass = this.setClusterClass.bind(this), this.getTotalMarkers = this.getTotalMarkers.bind(this), this.getZoomOnClick = this.getZoomOnClick.bind(this), this.setZoomOnClick = this.setZoomOnClick.bind(this), this.getBatchSizeIE = this.getBatchSizeIE.bind(this), this.setBatchSizeIE = this.setBatchSizeIE.bind(this), this.createClusters = this.createClusters.bind(this), this.onZoomChanged = this.onZoomChanged.bind(this), this.getImageSizes = this.getImageSizes.bind(this), this.setImageSizes = this.setImageSizes.bind(this), this.getCalculator = this.getCalculator.bind(this), this.setCalculator = this.setCalculator.bind(this), this.removeMarkers = this.removeMarkers.bind(this), this.resetViewport = this.resetViewport.bind(this), this.getImagePath = this.getImagePath.bind(this), this.setImagePath = this.setImagePath.bind(this), this.pushMarkerTo = this.pushMarkerTo.bind(this), this.removeMarker = this.removeMarker.bind(this), this.clearMarkers = this.clearMarkers.bind(this), this.setupStyles = this.setupStyles.bind(this), this.getGridSize = this.getGridSize.bind(this), this.setGridSize = this.setGridSize.bind(this), this.getClusters = this.getClusters.bind(this), this.getMaxZoom = this.getMaxZoom.bind(this), this.setMaxZoom = this.setMaxZoom.bind(this), this.getMarkers = this.getMarkers.bind(this), this.addMarkers = this.addMarkers.bind(this), this.getStyles = this.getStyles.bind(this), this.setStyles = this.setStyles.bind(this), this.addMarker = this.addMarker.bind(this), this.onRemove = this.onRemove.bind(this), this.getTitle = this.getTitle.bind(this), this.setTitle = this.setTitle.bind(this), this.repaint = this.repaint.bind(this), this.onIdle = this.onIdle.bind(this), this.redraw = this.redraw.bind(this), this.onAdd = this.onAdd.bind(this), this.draw = this.draw.bind(this), this.extend = this.extend.bind(this), this.extend(e, google.maps.OverlayView), this.markers = [], this.clusters = [], this.listeners = [], this.activeMap = null, this.ready = !1, this.gridSize = r.gridSize || 60, this.minClusterSize = r.minimumClusterSize || 2, this.maxZoom = r.maxZoom || null, this.styles = r.styles || [], this.title = r.title || "", this.zoomOnClick = !0, r.zoomOnClick !== void 0 && (this.zoomOnClick = r.zoomOnClick), this.averageCenter = !1, r.averageCenter !== void 0 && (this.averageCenter = r.averageCenter), this.ignoreHidden = !1, r.ignoreHidden !== void 0 && (this.ignoreHidden = r.ignoreHidden), this.enableRetinaIcons = !1, r.enableRetinaIcons !== void 0 && (this.enableRetinaIcons = r.enableRetinaIcons), this.imagePath = r.imagePath || bke, this.imageExtension = r.imageExtension || wke, this.imageSizes = r.imageSizes || Cke, this.calculator = r.calculator || mke, this.batchSize = r.batchSize || vke, this.batchSizeIE = r.batchSizeIE || yke, this.clusterClass = r.clusterClass || Oke, navigator.userAgent.toLowerCase().indexOf("msie") !== -1 && (this.batchSize = this.batchSizeIE), this.timerRefStatic = null, this.setupStyles(), this.addMarkers(n, !0), this.setMap(t);
    }
    return e.prototype.onZoomChanged = function() {
      var t, n;
      this.resetViewport(!1), (((t = this.getMap()) === null || t === void 0 ? void 0 : t.getZoom()) === (this.get("minZoom") || 0) || ((n = this.getMap()) === null || n === void 0 ? void 0 : n.getZoom()) === this.get("maxZoom")) && google.maps.event.trigger(this, "idle");
    }, e.prototype.onIdle = function() {
      this.redraw();
    }, e.prototype.onAdd = function() {
      var t = this.getMap();
      this.activeMap = t, this.ready = !0, this.repaint(), t !== null && (this.listeners = [google.maps.event.addListener(t, "zoom_changed", this.onZoomChanged), google.maps.event.addListener(t, "idle", this.onIdle)]);
    }, e.prototype.onRemove = function() {
      for (var t = 0, n = this.markers; t < n.length; t++) {
        var r = n[t];
        r.getMap() !== this.activeMap && r.setMap(this.activeMap);
      }
      for (var o = 0, i = this.clusters; o < i.length; o++) {
        var a = i[o];
        a.remove();
      }
      this.clusters = [];
      for (var s = 0, l = this.listeners; s < l.length; s++) {
        var u = l[s];
        google.maps.event.removeListener(u);
      }
      this.listeners = [], this.activeMap = null, this.ready = !1;
    }, e.prototype.draw = function() {
    }, e.prototype.getMap = function() {
      return null;
    }, e.prototype.getPanes = function() {
      return null;
    }, e.prototype.getProjection = function() {
      return {
        fromContainerPixelToLatLng: function() {
          return null;
        },
        fromDivPixelToLatLng: function() {
          return null;
        },
        fromLatLngToContainerPixel: function() {
          return null;
        },
        fromLatLngToDivPixel: function() {
          return null;
        },
        getVisibleRegion: function() {
          return null;
        },
        getWorldWidth: function() {
          return 0;
        }
      };
    }, e.prototype.setMap = function() {
    }, e.prototype.addListener = function() {
      return {
        remove: function() {
        }
      };
    }, e.prototype.bindTo = function() {
    }, e.prototype.get = function() {
    }, e.prototype.notify = function() {
    }, e.prototype.set = function() {
    }, e.prototype.setValues = function() {
    }, e.prototype.unbind = function() {
    }, e.prototype.unbindAll = function() {
    }, e.prototype.setupStyles = function() {
      if (!(this.styles.length > 0))
        for (var t = 0; t < this.imageSizes.length; t++)
          this.styles.push({
            url: "".concat(this.imagePath + (t + 1), ".").concat(this.imageExtension),
            height: this.imageSizes[t] || 0,
            width: this.imageSizes[t] || 0
          });
    }, e.prototype.fitMapToMarkers = function() {
      for (var t = this.getMarkers(), n = new google.maps.LatLngBounds(), r = 0, o = t; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && n.extend(a);
      }
      var s = this.getMap();
      s !== null && "fitBounds" in s && s.fitBounds(n);
    }, e.prototype.getGridSize = function() {
      return this.gridSize;
    }, e.prototype.setGridSize = function(t) {
      this.gridSize = t;
    }, e.prototype.getMinimumClusterSize = function() {
      return this.minClusterSize;
    }, e.prototype.setMinimumClusterSize = function(t) {
      this.minClusterSize = t;
    }, e.prototype.getMaxZoom = function() {
      return this.maxZoom;
    }, e.prototype.setMaxZoom = function(t) {
      this.maxZoom = t;
    }, e.prototype.getStyles = function() {
      return this.styles;
    }, e.prototype.setStyles = function(t) {
      this.styles = t;
    }, e.prototype.getTitle = function() {
      return this.title;
    }, e.prototype.setTitle = function(t) {
      this.title = t;
    }, e.prototype.getZoomOnClick = function() {
      return this.zoomOnClick;
    }, e.prototype.setZoomOnClick = function(t) {
      this.zoomOnClick = t;
    }, e.prototype.getAverageCenter = function() {
      return this.averageCenter;
    }, e.prototype.setAverageCenter = function(t) {
      this.averageCenter = t;
    }, e.prototype.getIgnoreHidden = function() {
      return this.ignoreHidden;
    }, e.prototype.setIgnoreHidden = function(t) {
      this.ignoreHidden = t;
    }, e.prototype.getEnableRetinaIcons = function() {
      return this.enableRetinaIcons;
    }, e.prototype.setEnableRetinaIcons = function(t) {
      this.enableRetinaIcons = t;
    }, e.prototype.getImageExtension = function() {
      return this.imageExtension;
    }, e.prototype.setImageExtension = function(t) {
      this.imageExtension = t;
    }, e.prototype.getImagePath = function() {
      return this.imagePath;
    }, e.prototype.setImagePath = function(t) {
      this.imagePath = t;
    }, e.prototype.getImageSizes = function() {
      return this.imageSizes;
    }, e.prototype.setImageSizes = function(t) {
      this.imageSizes = t;
    }, e.prototype.getCalculator = function() {
      return this.calculator;
    }, e.prototype.setCalculator = function(t) {
      this.calculator = t;
    }, e.prototype.getBatchSizeIE = function() {
      return this.batchSizeIE;
    }, e.prototype.setBatchSizeIE = function(t) {
      this.batchSizeIE = t;
    }, e.prototype.getClusterClass = function() {
      return this.clusterClass;
    }, e.prototype.setClusterClass = function(t) {
      this.clusterClass = t;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getTotalMarkers = function() {
      return this.markers.length;
    }, e.prototype.getClusters = function() {
      return this.clusters;
    }, e.prototype.getTotalClusters = function() {
      return this.clusters.length;
    }, e.prototype.addMarker = function(t, n) {
      this.pushMarkerTo(t), n || this.redraw();
    }, e.prototype.addMarkers = function(t, n) {
      for (var r in t)
        if (Object.prototype.hasOwnProperty.call(t, r)) {
          var o = t[r];
          o && this.pushMarkerTo(o);
        }
      n || this.redraw();
    }, e.prototype.pushMarkerTo = function(t) {
      var n = this;
      t.getDraggable() && google.maps.event.addListener(t, "dragend", function() {
        n.ready && (t.isAdded = !1, n.repaint());
      }), t.isAdded = !1, this.markers.push(t);
    }, e.prototype.removeMarker_ = function(t) {
      var n = -1;
      if (this.markers.indexOf)
        n = this.markers.indexOf(t);
      else
        for (var r = 0; r < this.markers.length; r++)
          if (t === this.markers[r]) {
            n = r;
            break;
          }
      return n === -1 ? !1 : (t.setMap(null), this.markers.splice(n, 1), !0);
    }, e.prototype.removeMarker = function(t, n) {
      var r = this.removeMarker_(t);
      return !n && r && this.repaint(), r;
    }, e.prototype.removeMarkers = function(t, n) {
      for (var r = !1, o = 0, i = t; o < i.length; o++) {
        var a = i[o];
        r = r || this.removeMarker_(a);
      }
      return !n && r && this.repaint(), r;
    }, e.prototype.clearMarkers = function() {
      this.resetViewport(!0), this.markers = [];
    }, e.prototype.repaint = function() {
      var t = this.clusters.slice();
      this.clusters = [], this.resetViewport(!1), this.redraw(), setTimeout(function() {
        for (var n = 0, r = t; n < r.length; n++) {
          var o = r[n];
          o.remove();
        }
      }, 0);
    }, e.prototype.getExtendedBounds = function(t) {
      var n = this.getProjection(), r = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getNorthEast().lat(), t.getNorthEast().lng())
      );
      r !== null && (r.x += this.gridSize, r.y -= this.gridSize);
      var o = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getSouthWest().lat(), t.getSouthWest().lng())
      );
      if (o !== null && (o.x -= this.gridSize, o.y += this.gridSize), r !== null) {
        var i = n.fromDivPixelToLatLng(r);
        i !== null && t.extend(i);
      }
      if (o !== null) {
        var a = n.fromDivPixelToLatLng(o);
        a !== null && t.extend(a);
      }
      return t;
    }, e.prototype.redraw = function() {
      this.createClusters(0);
    }, e.prototype.resetViewport = function(t) {
      for (var n = 0, r = this.clusters; n < r.length; n++) {
        var o = r[n];
        o.remove();
      }
      this.clusters = [];
      for (var i = 0, a = this.markers; i < a.length; i++) {
        var s = a[i];
        s.isAdded = !1, t && s.setMap(null);
      }
    }, e.prototype.distanceBetweenPoints = function(t, n) {
      var r = 6371, o = (n.lat() - t.lat()) * Math.PI / 180, i = (n.lng() - t.lng()) * Math.PI / 180, a = Math.sin(o / 2) * Math.sin(o / 2) + Math.cos(t.lat() * Math.PI / 180) * Math.cos(n.lat() * Math.PI / 180) * Math.sin(i / 2) * Math.sin(i / 2);
      return r * (2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)));
    }, e.prototype.isMarkerInBounds = function(t, n) {
      var r = t.getPosition();
      return r ? n.contains(r) : !1;
    }, e.prototype.addToClosestCluster = function(t) {
      for (var n, r = 4e4, o = null, i = 0, a = this.clusters; i < a.length; i++) {
        var s = a[i];
        n = s;
        var l = n.getCenter(), u = t.getPosition();
        if (l && u) {
          var c = this.distanceBetweenPoints(l, u);
          c < r && (r = c, o = n);
        }
      }
      o && o.isMarkerInClusterBounds(t) ? o.addMarker(t) : (n = new gke(this), n.addMarker(t), this.clusters.push(n));
    }, e.prototype.createClusters = function(t) {
      var n = this;
      if (this.ready) {
        t === 0 && (google.maps.event.trigger(this, "clusteringbegin", this), this.timerRefStatic !== null && (window.clearTimeout(this.timerRefStatic), delete this.timerRefStatic));
        for (var r = this.getMap(), o = r !== null && ("getBounds" in r) ? r.getBounds() : null, i = (r == null ? void 0 : r.getZoom()) || 0, a = i > 3 ? new google.maps.LatLngBounds(o == null ? void 0 : o.getSouthWest(), o == null ? void 0 : o.getNorthEast()) : new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625)), s = this.getExtendedBounds(a), l = Math.min(t + this.batchSize, this.markers.length), u = t; u < l; u++) {
          var c = this.markers[u];
          c && !c.isAdded && this.isMarkerInBounds(c, s) && (!this.ignoreHidden || this.ignoreHidden && c.getVisible()) && this.addToClosestCluster(c);
        }
        if (l < this.markers.length)
          this.timerRefStatic = window.setTimeout(function() {
            n.createClusters(l);
          }, 0);
        else {
          this.timerRefStatic = null, google.maps.event.trigger(this, "clusteringend", this);
          for (var p = 0, d = this.clusters; p < d.length; p++) {
            var g = d[p];
            g.updateIcon();
          }
        }
      }
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype) {
          var i = o;
          this.prototype[i] = r.prototype[i];
        }
        return this;
      }).apply(t, [n]);
    }, e;
  }()
);
function fz(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function xke(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? fz(Object(n), !0).forEach(function(r) {
      Le(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : fz(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var As = {
  onClick: "click",
  onClusteringBegin: "clusteringbegin",
  onClusteringEnd: "clusteringend",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover"
}, Dn = {
  averageCenter(e, t) {
    e.setAverageCenter(t);
  },
  batchSizeIE(e, t) {
    e.setBatchSizeIE(t);
  },
  calculator(e, t) {
    e.setCalculator(t);
  },
  clusterClass(e, t) {
    e.setClusterClass(t);
  },
  enableRetinaIcons(e, t) {
    e.setEnableRetinaIcons(t);
  },
  gridSize(e, t) {
    e.setGridSize(t);
  },
  ignoreHidden(e, t) {
    e.setIgnoreHidden(t);
  },
  imageExtension(e, t) {
    e.setImageExtension(t);
  },
  imagePath(e, t) {
    e.setImagePath(t);
  },
  imageSizes(e, t) {
    e.setImageSizes(t);
  },
  maxZoom(e, t) {
    e.setMaxZoom(t);
  },
  minimumClusterSize(e, t) {
    e.setMinimumClusterSize(t);
  },
  styles(e, t) {
    e.setStyles(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  zoomOnClick(e, t) {
    e.setZoomOnClick(t);
  }
}, Eke = {};
function kke(e) {
  var {
    children: t,
    options: n,
    averageCenter: r,
    batchSizeIE: o,
    calculator: i,
    clusterClass: a,
    enableRetinaIcons: s,
    gridSize: l,
    ignoreHidden: u,
    imageExtension: c,
    imagePath: p,
    imageSizes: d,
    maxZoom: g,
    minimumClusterSize: f,
    styles: m,
    title: b,
    zoomOnClick: E,
    onClick: w,
    onClusteringBegin: M,
    onClusteringEnd: x,
    onMouseOver: v,
    onMouseOut: C,
    onLoad: P,
    onUnmount: F
  } = e, [L, B] = k(null), N = ge(Rt), [$, V] = k(null), [H, Z] = k(null), [K, Y] = k(null), [Q, J] = k(null), [_, D] = k(null);
  return h(() => {
    L && C && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(L, As.onMouseOut, C)));
  }, [C]), h(() => {
    L && v && (_ !== null && google.maps.event.removeListener(_), D(google.maps.event.addListener(L, As.onMouseOver, v)));
  }, [v]), h(() => {
    L && w && ($ !== null && google.maps.event.removeListener($), V(google.maps.event.addListener(L, As.onClick, w)));
  }, [w]), h(() => {
    L && M && (H !== null && google.maps.event.removeListener(H), Z(google.maps.event.addListener(L, As.onClusteringBegin, M)));
  }, [M]), h(() => {
    L && x && (K !== null && google.maps.event.removeListener(K), Z(google.maps.event.addListener(L, As.onClusteringEnd, x)));
  }, [x]), h(() => {
    typeof r < "u" && L !== null && Dn.averageCenter(L, r);
  }, [L, r]), h(() => {
    typeof o < "u" && L !== null && Dn.batchSizeIE(L, o);
  }, [L, o]), h(() => {
    typeof i < "u" && L !== null && Dn.calculator(L, i);
  }, [L, i]), h(() => {
    typeof a < "u" && L !== null && Dn.clusterClass(L, a);
  }, [L, a]), h(() => {
    typeof s < "u" && L !== null && Dn.enableRetinaIcons(L, s);
  }, [L, s]), h(() => {
    typeof l < "u" && L !== null && Dn.gridSize(L, l);
  }, [L, l]), h(() => {
    typeof u < "u" && L !== null && Dn.ignoreHidden(L, u);
  }, [L, u]), h(() => {
    typeof c < "u" && L !== null && Dn.imageExtension(L, c);
  }, [L, c]), h(() => {
    typeof p < "u" && L !== null && Dn.imagePath(L, p);
  }, [L, p]), h(() => {
    typeof d < "u" && L !== null && Dn.imageSizes(L, d);
  }, [L, d]), h(() => {
    typeof g < "u" && L !== null && Dn.maxZoom(L, g);
  }, [L, g]), h(() => {
    typeof f < "u" && L !== null && Dn.minimumClusterSize(L, f);
  }, [L, f]), h(() => {
    typeof m < "u" && L !== null && Dn.styles(L, m);
  }, [L, m]), h(() => {
    typeof b < "u" && L !== null && Dn.title(L, b);
  }, [L, b]), h(() => {
    typeof E < "u" && L !== null && Dn.zoomOnClick(L, E);
  }, [L, E]), h(() => {
    if (N) {
      var z = xke({}, n || Eke), S = new EQ(N, [], z);
      return r && Dn.averageCenter(S, r), o && Dn.batchSizeIE(S, o), i && Dn.calculator(S, i), a && Dn.clusterClass(S, a), s && Dn.enableRetinaIcons(S, s), l && Dn.gridSize(S, l), u && Dn.ignoreHidden(S, u), c && Dn.imageExtension(S, c), p && Dn.imagePath(S, p), d && Dn.imageSizes(S, d), g && Dn.maxZoom(S, g), f && Dn.minimumClusterSize(S, f), m && Dn.styles(S, m), b && Dn.title(S, b), E && Dn.zoomOnClick(S, E), C && J(google.maps.event.addListener(S, As.onMouseOut, C)), v && D(google.maps.event.addListener(S, As.onMouseOver, v)), w && V(google.maps.event.addListener(S, As.onClick, w)), M && Z(google.maps.event.addListener(S, As.onClusteringBegin, M)), x && Y(google.maps.event.addListener(S, As.onClusteringEnd, x)), B(S), P && P(S), () => {
        Q !== null && google.maps.event.removeListener(Q), _ !== null && google.maps.event.removeListener(_), $ !== null && google.maps.event.removeListener($), H !== null && google.maps.event.removeListener(H), K !== null && google.maps.event.removeListener(K), F && F(S);
      };
    }
  }, []), L !== null && t(L) || null;
}
me(kke);
class Lke extends pe {
  constructor() {
    super(...arguments), Le(this, "registeredEvents", []), Le(this, "state", {
      markerClusterer: null
    }), Le(this, "setClustererCallback", () => {
      this.state.markerClusterer !== null && this.props.onLoad && this.props.onLoad(this.state.markerClusterer);
    });
  }
  componentDidMount() {
    if (this.context) {
      var t = new EQ(this.context, [], this.props.options);
      this.registeredEvents = vn({
        updaterMap: Dn,
        eventMap: As,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        markerClusterer: t
      }), this.setClustererCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.markerClusterer && (En(this.registeredEvents), this.registeredEvents = vn({
      updaterMap: Dn,
      eventMap: As,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.markerClusterer
    }));
  }
  componentWillUnmount() {
    this.state.markerClusterer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.markerClusterer), En(this.registeredEvents), this.state.markerClusterer.setMap(null));
  }
  render() {
    return this.state.markerClusterer !== null ? this.props.children(this.state.markerClusterer) : null;
  }
}
Le(Lke, "contextType", Rt);
function hz(e) {
  e.cancelBubble = !0, e.stopPropagation && e.stopPropagation();
}
var kQ = (
  /** @class */
  function() {
    function e(t) {
      t === void 0 && (t = {}), this.getCloseClickHandler = this.getCloseClickHandler.bind(this), this.closeClickHandler = this.closeClickHandler.bind(this), this.createInfoBoxDiv = this.createInfoBoxDiv.bind(this), this.addClickHandler = this.addClickHandler.bind(this), this.getCloseBoxImg = this.getCloseBoxImg.bind(this), this.getBoxWidths = this.getBoxWidths.bind(this), this.setBoxStyle = this.setBoxStyle.bind(this), this.setPosition = this.setPosition.bind(this), this.getPosition = this.getPosition.bind(this), this.setOptions = this.setOptions.bind(this), this.setContent = this.setContent.bind(this), this.setVisible = this.setVisible.bind(this), this.getContent = this.getContent.bind(this), this.getVisible = this.getVisible.bind(this), this.setZIndex = this.setZIndex.bind(this), this.getZIndex = this.getZIndex.bind(this), this.onRemove = this.onRemove.bind(this), this.panBox = this.panBox.bind(this), this.extend = this.extend.bind(this), this.close = this.close.bind(this), this.draw = this.draw.bind(this), this.show = this.show.bind(this), this.hide = this.hide.bind(this), this.open = this.open.bind(this), this.extend(e, google.maps.OverlayView), this.content = t.content || "", this.disableAutoPan = t.disableAutoPan || !1, this.maxWidth = t.maxWidth || 0, this.pixelOffset = t.pixelOffset || new google.maps.Size(0, 0), this.position = t.position || new google.maps.LatLng(0, 0), this.zIndex = t.zIndex || null, this.boxClass = t.boxClass || "infoBox", this.boxStyle = t.boxStyle || {}, this.closeBoxMargin = t.closeBoxMargin || "2px", this.closeBoxURL = t.closeBoxURL || "http://www.google.com/intl/en_us/mapfiles/close.gif", t.closeBoxURL === "" && (this.closeBoxURL = ""), this.infoBoxClearance = t.infoBoxClearance || new google.maps.Size(1, 1), typeof t.visible > "u" && (typeof t.isHidden > "u" ? t.visible = !0 : t.visible = !t.isHidden), this.isHidden = !t.visible, this.alignBottom = t.alignBottom || !1, this.pane = t.pane || "floatPane", this.enableEventPropagation = t.enableEventPropagation || !1, this.div = null, this.closeListener = null, this.moveListener = null, this.mapListener = null, this.contextListener = null, this.eventListeners = null, this.fixedWidthSet = null;
    }
    return e.prototype.createInfoBoxDiv = function() {
      var t = this, n = function(u) {
        u.returnValue = !1, u.preventDefault && u.preventDefault(), t.enableEventPropagation || hz(u);
      };
      if (!this.div) {
        this.div = document.createElement("div"), this.setBoxStyle(), typeof this.content == "string" ? this.div.innerHTML = this.getCloseBoxImg() + this.content : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(this.content));
        var r = this.getPanes();
        if (r !== null && r[this.pane].appendChild(this.div), this.addClickHandler(), this.div.style.width)
          this.fixedWidthSet = !0;
        else if (this.maxWidth !== 0 && this.div.offsetWidth > this.maxWidth)
          this.div.style.width = this.maxWidth + "px", this.fixedWidthSet = !0;
        else {
          var o = this.getBoxWidths();
          this.div.style.width = this.div.offsetWidth - o.left - o.right + "px", this.fixedWidthSet = !1;
        }
        if (this.panBox(this.disableAutoPan), !this.enableEventPropagation) {
          this.eventListeners = [];
          for (var i = ["mousedown", "mouseover", "mouseout", "mouseup", "click", "dblclick", "touchstart", "touchend", "touchmove"], a = 0, s = i; a < s.length; a++) {
            var l = s[a];
            this.eventListeners.push(google.maps.event.addListener(this.div, l, hz));
          }
          this.eventListeners.push(google.maps.event.addListener(this.div, "mouseover", function() {
            t.div && (t.div.style.cursor = "default");
          }));
        }
        this.contextListener = google.maps.event.addListener(this.div, "contextmenu", n), google.maps.event.trigger(this, "domready");
      }
    }, e.prototype.getCloseBoxImg = function() {
      var t = "";
      return this.closeBoxURL !== "" && (t = '<img alt=""', t += ' aria-hidden="true"', t += " src='" + this.closeBoxURL + "'", t += " align=right", t += " style='", t += " position: relative;", t += " cursor: pointer;", t += " margin: " + this.closeBoxMargin + ";", t += "'>"), t;
    }, e.prototype.addClickHandler = function() {
      this.closeListener = this.div && this.div.firstChild && this.closeBoxURL !== "" ? google.maps.event.addListener(this.div.firstChild, "click", this.getCloseClickHandler()) : null;
    }, e.prototype.closeClickHandler = function(t) {
      t.cancelBubble = !0, t.stopPropagation && t.stopPropagation(), google.maps.event.trigger(this, "closeclick"), this.close();
    }, e.prototype.getCloseClickHandler = function() {
      return this.closeClickHandler;
    }, e.prototype.panBox = function(t) {
      if (this.div && !t) {
        var n = this.getMap();
        if (n instanceof google.maps.Map) {
          var r = 0, o = 0, i = n.getBounds();
          i && !i.contains(this.position) && n.setCenter(this.position);
          var a = n.getDiv(), s = a.offsetWidth, l = a.offsetHeight, u = this.pixelOffset.width, c = this.pixelOffset.height, p = this.div.offsetWidth, d = this.div.offsetHeight, g = this.infoBoxClearance.width, f = this.infoBoxClearance.height, m = this.getProjection(), b = m.fromLatLngToContainerPixel(this.position);
          b !== null && (b.x < -u + g ? r = b.x + u - g : b.x + p + u + g > s && (r = b.x + p + u + g - s), this.alignBottom ? b.y < -c + f + d ? o = b.y + c - f - d : b.y + c + f > l && (o = b.y + c + f - l) : b.y < -c + f ? o = b.y + c - f : b.y + d + c + f > l && (o = b.y + d + c + f - l)), r === 0 && o === 0 || n.panBy(r, o);
        }
      }
    }, e.prototype.setBoxStyle = function() {
      if (this.div) {
        this.div.className = this.boxClass, this.div.style.cssText = "";
        var t = this.boxStyle;
        for (var n in t)
          Object.prototype.hasOwnProperty.call(t, n) && (this.div.style[n] = t[n]);
        if (this.div.style.webkitTransform = "translateZ(0)", typeof this.div.style.opacity < "u" && this.div.style.opacity !== "") {
          var r = parseFloat(this.div.style.opacity || "");
          this.div.style.msFilter = '"progid:DXImageTransform.Microsoft.Alpha(Opacity=' + r * 100 + ')"', this.div.style.filter = "alpha(opacity=" + r * 100 + ")";
        }
        this.div.style.position = "absolute", this.div.style.visibility = "hidden", this.zIndex !== null && (this.div.style.zIndex = this.zIndex + ""), this.div.style.overflow || (this.div.style.overflow = "auto");
      }
    }, e.prototype.getBoxWidths = function() {
      var t = {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0
      };
      if (!this.div)
        return t;
      if (document.defaultView) {
        var n = this.div.ownerDocument, r = n && n.defaultView ? n.defaultView.getComputedStyle(this.div, "") : null;
        r && (t.top = parseInt(r.borderTopWidth || "", 10) || 0, t.bottom = parseInt(r.borderBottomWidth || "", 10) || 0, t.left = parseInt(r.borderLeftWidth || "", 10) || 0, t.right = parseInt(r.borderRightWidth || "", 10) || 0);
      } else if (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        document.documentElement.currentStyle
      ) {
        var o = this.div.currentStyle;
        o && (t.top = parseInt(o.borderTopWidth || "", 10) || 0, t.bottom = parseInt(o.borderBottomWidth || "", 10) || 0, t.left = parseInt(o.borderLeftWidth || "", 10) || 0, t.right = parseInt(o.borderRightWidth || "", 10) || 0);
      }
      return t;
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.div.parentNode.removeChild(this.div), this.div = null);
    }, e.prototype.draw = function() {
      if (this.createInfoBoxDiv(), this.div) {
        var t = this.getProjection(), n = t.fromLatLngToDivPixel(this.position);
        n !== null && (this.div.style.left = n.x + this.pixelOffset.width + "px", this.alignBottom ? this.div.style.bottom = -(n.y + this.pixelOffset.height) + "px" : this.div.style.top = n.y + this.pixelOffset.height + "px"), this.isHidden ? this.div.style.visibility = "hidden" : this.div.style.visibility = "visible";
      }
    }, e.prototype.setOptions = function(t) {
      t === void 0 && (t = {}), typeof t.boxClass < "u" && (this.boxClass = t.boxClass, this.setBoxStyle()), typeof t.boxStyle < "u" && (this.boxStyle = t.boxStyle, this.setBoxStyle()), typeof t.content < "u" && this.setContent(t.content), typeof t.disableAutoPan < "u" && (this.disableAutoPan = t.disableAutoPan), typeof t.maxWidth < "u" && (this.maxWidth = t.maxWidth), typeof t.pixelOffset < "u" && (this.pixelOffset = t.pixelOffset), typeof t.alignBottom < "u" && (this.alignBottom = t.alignBottom), typeof t.position < "u" && this.setPosition(t.position), typeof t.zIndex < "u" && this.setZIndex(t.zIndex), typeof t.closeBoxMargin < "u" && (this.closeBoxMargin = t.closeBoxMargin), typeof t.closeBoxURL < "u" && (this.closeBoxURL = t.closeBoxURL), typeof t.infoBoxClearance < "u" && (this.infoBoxClearance = t.infoBoxClearance), typeof t.isHidden < "u" && (this.isHidden = t.isHidden), typeof t.visible < "u" && (this.isHidden = !t.visible), typeof t.enableEventPropagation < "u" && (this.enableEventPropagation = t.enableEventPropagation), this.div && this.draw();
    }, e.prototype.setContent = function(t) {
      this.content = t, this.div && (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.fixedWidthSet || (this.div.style.width = ""), typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t)), this.fixedWidthSet || (this.div.style.width = this.div.offsetWidth + "px", typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t))), this.addClickHandler()), google.maps.event.trigger(this, "content_changed");
    }, e.prototype.setPosition = function(t) {
      this.position = t, this.div && this.draw(), google.maps.event.trigger(this, "position_changed");
    }, e.prototype.setVisible = function(t) {
      this.isHidden = !t, this.div && (this.div.style.visibility = this.isHidden ? "hidden" : "visible");
    }, e.prototype.setZIndex = function(t) {
      this.zIndex = t, this.div && (this.div.style.zIndex = t + ""), google.maps.event.trigger(this, "zindex_changed");
    }, e.prototype.getContent = function() {
      return this.content;
    }, e.prototype.getPosition = function() {
      return this.position;
    }, e.prototype.getZIndex = function() {
      return this.zIndex;
    }, e.prototype.getVisible = function() {
      var t = this.getMap();
      return typeof t > "u" || t === null ? !1 : !this.isHidden;
    }, e.prototype.show = function() {
      this.isHidden = !1, this.div && (this.div.style.visibility = "visible");
    }, e.prototype.hide = function() {
      this.isHidden = !0, this.div && (this.div.style.visibility = "hidden");
    }, e.prototype.open = function(t, n) {
      var r = this;
      n && (this.position = n.getPosition(), this.moveListener = google.maps.event.addListener(n, "position_changed", function() {
        var o = n.getPosition();
        r.setPosition(o);
      }), this.mapListener = google.maps.event.addListener(n, "map_changed", function() {
        r.setMap(n.map);
      })), this.setMap(t), this.div && this.panBox();
    }, e.prototype.close = function() {
      if (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.eventListeners) {
        for (var t = 0, n = this.eventListeners; t < n.length; t++) {
          var r = n[t];
          google.maps.event.removeListener(r);
        }
        this.eventListeners = null;
      }
      this.moveListener && (google.maps.event.removeListener(this.moveListener), this.moveListener = null), this.mapListener && (google.maps.event.removeListener(this.mapListener), this.mapListener = null), this.contextListener && (google.maps.event.removeListener(this.contextListener), this.contextListener = null), this.setMap(null);
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype)
          Object.prototype.hasOwnProperty.call(this, o) || (this.prototype[o] = r.prototype[o]);
        return this;
      }).apply(t, [n]);
    }, e;
  }()
), _ke = ["position"], Pke = ["position"];
function gz(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Tb(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? gz(Object(n), !0).forEach(function(r) {
      Le(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : gz(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var mz = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, vz = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    t instanceof google.maps.LatLng ? e.setPosition(t) : e.setPosition(new google.maps.LatLng(t.lat, t.lng));
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, Ske = {};
function Mke(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, g = ge(Rt), [f, m] = k(null), [b, E] = k(null), [w, M] = k(null), [x, v] = k(null), [C, P] = k(null), [F, L] = k(null), B = dt(null);
  return h(() => {
    g && f !== null && (f.close(), n ? f.open(g, n) : f.getPosition() && f.open(g));
  }, [g, f, n]), h(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), h(() => {
    if (o && f !== null) {
      var N = o instanceof google.maps.LatLng ? o : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        new google.maps.LatLng(o.lat, o.lng)
      );
      f.setPosition(N);
    }
  }, [o]), h(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), h(() => {
    f && a && (b !== null && google.maps.event.removeListener(b), E(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), h(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), M(google.maps.event.addListener(f, "domready", s)));
  }, [s]), h(() => {
    f && l && (x !== null && google.maps.event.removeListener(x), v(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), h(() => {
    f && u && (C !== null && google.maps.event.removeListener(C), P(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), h(() => {
    f && c && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), h(() => {
    if (g) {
      var N = r || Ske, {
        position: $
      } = N, V = LD(N, _ke), H;
      $ && !($ instanceof google.maps.LatLng) && (H = new google.maps.LatLng($.lat, $.lng));
      var Z = new kQ(Tb(Tb({}, V), H ? {
        position: H
      } : {}));
      B.current = document.createElement("div"), m(Z), a && E(google.maps.event.addListener(Z, "closeclick", a)), s && M(google.maps.event.addListener(Z, "domready", s)), l && v(google.maps.event.addListener(Z, "content_changed", l)), u && P(google.maps.event.addListener(Z, "position_changed", u)), c && L(google.maps.event.addListener(Z, "zindex_changed", c)), Z.setContent(B.current), n ? Z.open(g, n) : Z.getPosition() ? Z.open(g) : Uo(!1, "You must provide either an anchor or a position prop for <InfoBox>."), p && p(Z);
    }
    return () => {
      f !== null && (b && google.maps.event.removeListener(b), x && google.maps.event.removeListener(x), w && google.maps.event.removeListener(w), C && google.maps.event.removeListener(C), F && google.maps.event.removeListener(F), d && d(f), f.close());
    };
  }, []), B.current ? zn(at.only(t), B.current) : null;
}
me(Mke);
class Dke extends pe {
  constructor() {
    super(...arguments), Le(this, "registeredEvents", []), Le(this, "containerElement", null), Le(this, "state", {
      infoBox: null
    }), Le(this, "open", (t, n) => {
      n ? this.context !== null && t.open(this.context, n) : t.getPosition() ? this.context !== null && t.open(this.context) : Uo(!1, "You must provide either an anchor or a position prop for <InfoBox>.");
    }), Le(this, "setInfoBoxCallback", () => {
      this.state.infoBox !== null && this.containerElement !== null && (this.state.infoBox.setContent(this.containerElement), this.open(this.state.infoBox, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoBox));
    });
  }
  componentDidMount() {
    var t = this.props.options || {}, {
      position: n
    } = t, r = LD(t, Pke), o;
    n && !(n instanceof google.maps.LatLng) && (o = new google.maps.LatLng(n.lat, n.lng));
    var i = new kQ(Tb(Tb({}, r), o ? {
      position: o
    } : {}));
    this.containerElement = document.createElement("div"), this.registeredEvents = vn({
      updaterMap: vz,
      eventMap: mz,
      prevProps: {},
      nextProps: this.props,
      instance: i
    }), this.setState({
      infoBox: i
    }, this.setInfoBoxCallback);
  }
  componentDidUpdate(t) {
    var {
      infoBox: n
    } = this.state;
    n !== null && (En(this.registeredEvents), this.registeredEvents = vn({
      updaterMap: vz,
      eventMap: mz,
      prevProps: t,
      nextProps: this.props,
      instance: n
    }));
  }
  componentWillUnmount() {
    var {
      onUnmount: t
    } = this.props, {
      infoBox: n
    } = this.state;
    n !== null && (t && t(n), En(this.registeredEvents), n.close());
  }
  render() {
    return this.containerElement ? zn(at.only(this.props.children), this.containerElement) : null;
  }
}
Le(Dke, "contextType", Rt);
var yz, bz;
function Tke() {
  return bz || (bz = 1, yz = function e(t, n) {
    if (t === n) return !0;
    if (t && n && typeof t == "object" && typeof n == "object") {
      if (t.constructor !== n.constructor) return !1;
      var r, o, i;
      if (Array.isArray(t)) {
        if (r = t.length, r != n.length) return !1;
        for (o = r; o-- !== 0; ) if (!e(t[o], n[o])) return !1;
        return !0;
      }
      if (t.constructor === RegExp) return t.source === n.source && t.flags === n.flags;
      if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === n.valueOf();
      if (t.toString !== Object.prototype.toString) return t.toString() === n.toString();
      if (i = Object.keys(t), r = i.length, r !== Object.keys(n).length) return !1;
      for (o = r; o-- !== 0; ) if (!Object.prototype.hasOwnProperty.call(n, i[o])) return !1;
      for (o = r; o-- !== 0; ) {
        var a = i[o];
        if (!e(t[a], n[a])) return !1;
      }
      return !0;
    }
    return t !== t && n !== n;
  }), yz;
}
var jke = Tke(), wz = /* @__PURE__ */ yQ(jke), Cz = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array], aE = 1, yd = 8;
class _D {
  /**
   * Creates an index from raw `ArrayBuffer` data.
   * @param {ArrayBuffer} data
   */
  static from(t) {
    if (!(t instanceof ArrayBuffer))
      throw new Error("Data must be an instance of ArrayBuffer.");
    var [n, r] = new Uint8Array(t, 0, 2);
    if (n !== 219)
      throw new Error("Data does not appear to be in a KDBush format.");
    var o = r >> 4;
    if (o !== aE)
      throw new Error("Got v".concat(o, " data when expected v").concat(aE, "."));
    var i = Cz[r & 15];
    if (!i)
      throw new Error("Unrecognized array type.");
    var [a] = new Uint16Array(t, 2, 1), [s] = new Uint32Array(t, 4, 1);
    return new _D(s, a, i, t);
  }
  /**
   * Creates an index that will hold a given number of items.
   * @param {number} numItems
   * @param {number} [nodeSize=64] Size of the KD-tree node (64 by default).
   * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).
   * @param {ArrayBuffer} [data] (For internal use only)
   */
  constructor(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 64, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Float64Array, o = arguments.length > 3 ? arguments[3] : void 0;
    if (isNaN(t) || t < 0) throw new Error("Unpexpected numItems value: ".concat(t, "."));
    this.numItems = +t, this.nodeSize = Math.min(Math.max(+n, 2), 65535), this.ArrayType = r, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
    var i = Cz.indexOf(this.ArrayType), a = t * 2 * this.ArrayType.BYTES_PER_ELEMENT, s = t * this.IndexArrayType.BYTES_PER_ELEMENT, l = (8 - s % 8) % 8;
    if (i < 0)
      throw new Error("Unexpected typed array class: ".concat(r, "."));
    o && o instanceof ArrayBuffer ? (this.data = o, this.ids = new this.IndexArrayType(this.data, yd, t), this.coords = new this.ArrayType(this.data, yd + s + l, t * 2), this._pos = t * 2, this._finished = !0) : (this.data = new ArrayBuffer(yd + a + s + l), this.ids = new this.IndexArrayType(this.data, yd, t), this.coords = new this.ArrayType(this.data, yd + s + l, t * 2), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, (aE << 4) + i]), new Uint16Array(this.data, 2, 1)[0] = n, new Uint32Array(this.data, 4, 1)[0] = t);
  }
  /**
   * Add a point to the index.
   * @param {number} x
   * @param {number} y
   * @returns {number} An incremental index associated with the added item (starting from `0`).
   */
  add(t, n) {
    var r = this._pos >> 1;
    return this.ids[r] = r, this.coords[this._pos++] = t, this.coords[this._pos++] = n, r;
  }
  /**
   * Perform indexing of the added points.
   */
  finish() {
    var t = this._pos >> 1;
    if (t !== this.numItems)
      throw new Error("Added ".concat(t, " items when expected ").concat(this.numItems, "."));
    return D_(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
  }
  /**
   * Search the index for items within a given bounding box.
   * @param {number} minX
   * @param {number} minY
   * @param {number} maxX
   * @param {number} maxY
   * @returns {number[]} An array of indices correponding to the found items.
   */
  range(t, n, r, o) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: i,
      coords: a,
      nodeSize: s
    } = this, l = [0, i.length - 1, 0], u = []; l.length; ) {
      var c = l.pop() || 0, p = l.pop() || 0, d = l.pop() || 0;
      if (p - d <= s) {
        for (var g = d; g <= p; g++) {
          var f = a[2 * g], m = a[2 * g + 1];
          f >= t && f <= r && m >= n && m <= o && u.push(i[g]);
        }
        continue;
      }
      var b = d + p >> 1, E = a[2 * b], w = a[2 * b + 1];
      E >= t && E <= r && w >= n && w <= o && u.push(i[b]), (c === 0 ? t <= E : n <= w) && (l.push(d), l.push(b - 1), l.push(1 - c)), (c === 0 ? r >= E : o >= w) && (l.push(b + 1), l.push(p), l.push(1 - c));
    }
    return u;
  }
  /**
   * Search the index for items within a given radius.
   * @param {number} qx
   * @param {number} qy
   * @param {number} r Query radius.
   * @returns {number[]} An array of indices correponding to the found items.
   */
  within(t, n, r) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: o,
      coords: i,
      nodeSize: a
    } = this, s = [0, o.length - 1, 0], l = [], u = r * r; s.length; ) {
      var c = s.pop() || 0, p = s.pop() || 0, d = s.pop() || 0;
      if (p - d <= a) {
        for (var g = d; g <= p; g++)
          Oz(i[2 * g], i[2 * g + 1], t, n) <= u && l.push(o[g]);
        continue;
      }
      var f = d + p >> 1, m = i[2 * f], b = i[2 * f + 1];
      Oz(m, b, t, n) <= u && l.push(o[f]), (c === 0 ? t - r <= m : n - r <= b) && (s.push(d), s.push(f - 1), s.push(1 - c)), (c === 0 ? t + r >= m : n + r >= b) && (s.push(f + 1), s.push(p), s.push(1 - c));
    }
    return l;
  }
}
function D_(e, t, n, r, o, i) {
  if (!(o - r <= n)) {
    var a = r + o >> 1;
    LQ(e, t, a, r, o, i), D_(e, t, n, r, a - 1, 1 - i), D_(e, t, n, a + 1, o, 1 - i);
  }
}
function LQ(e, t, n, r, o, i) {
  for (; o > r; ) {
    if (o - r > 600) {
      var a = o - r + 1, s = n - r + 1, l = Math.log(a), u = 0.5 * Math.exp(2 * l / 3), c = 0.5 * Math.sqrt(l * u * (a - u) / a) * (s - a / 2 < 0 ? -1 : 1), p = Math.max(r, Math.floor(n - s * u / a + c)), d = Math.min(o, Math.floor(n + (a - s) * u / a + c));
      LQ(e, t, n, p, d, i);
    }
    var g = t[2 * n + i], f = r, m = o;
    for (bd(e, t, r, n), t[2 * o + i] > g && bd(e, t, r, o); f < m; ) {
      for (bd(e, t, f, m), f++, m--; t[2 * f + i] < g; ) f++;
      for (; t[2 * m + i] > g; ) m--;
    }
    t[2 * r + i] === g ? bd(e, t, r, m) : (m++, bd(e, t, m, o)), m <= n && (r = m + 1), n <= m && (o = m - 1);
  }
}
function bd(e, t, n, r) {
  lE(e, n, r), lE(t, 2 * n, 2 * r), lE(t, 2 * n + 1, 2 * r + 1);
}
function lE(e, t, n) {
  var r = e[t];
  e[t] = e[n], e[n] = r;
}
function Oz(e, t, n, r) {
  var o = e - n, i = t - r;
  return o * o + i * i;
}
var Ake = {
  minZoom: 0,
  // min zoom to generate clusters on
  maxZoom: 16,
  // max zoom level to cluster the points on
  minPoints: 2,
  // minimum points to form a cluster
  radius: 40,
  // cluster radius in pixels
  extent: 512,
  // tile extent (radius is calculated relative to it)
  nodeSize: 64,
  // size of the KD-tree leaf node, affects performance
  log: !1,
  // whether to log timing info
  // whether to generate numeric ids for input features (in vector tiles)
  generateId: !1,
  // a reduce function for calculating custom cluster properties
  reduce: null,
  // (accumulated, props) => { accumulated.sum += props.sum; }
  // properties to use for individual points when running the reducer
  map: (e) => e
  // props => ({sum: props.my_value})
}, xz = Math.fround || /* @__PURE__ */ ((e) => (t) => (e[0] = +t, e[0]))(new Float32Array(1)), Au = 2, Fl = 3, uE = 4, Dl = 5, _Q = 6;
class Rke {
  constructor(t) {
    this.options = Object.assign(Object.create(Ake), t), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
  }
  load(t) {
    var {
      log: n,
      minZoom: r,
      maxZoom: o
    } = this.options;
    n && console.time("total time");
    var i = "prepare ".concat(t.length, " points");
    n && console.time(i), this.points = t;
    for (var a = [], s = 0; s < t.length; s++) {
      var l = t[s];
      if (l.geometry) {
        var [u, c] = l.geometry.coordinates, p = xz(Jm(u)), d = xz(Qm(c));
        a.push(
          p,
          d,
          // projected point coordinates
          1 / 0,
          // the last zoom the point was processed at
          s,
          // index of the source feature in the original input array
          -1,
          // parent cluster id
          1
          // number of points in a cluster
        ), this.options.reduce && a.push(0);
      }
    }
    var g = this.trees[o + 1] = this._createTree(a);
    n && console.timeEnd(i);
    for (var f = o; f >= r; f--) {
      var m = +Date.now();
      g = this.trees[f] = this._createTree(this._cluster(g, f)), n && console.log("z%d: %d clusters in %dms", f, g.numItems, +Date.now() - m);
    }
    return n && console.timeEnd("total time"), this;
  }
  getClusters(t, n) {
    var r = ((t[0] + 180) % 360 + 360) % 360 - 180, o = Math.max(-90, Math.min(90, t[1])), i = t[2] === 180 ? 180 : ((t[2] + 180) % 360 + 360) % 360 - 180, a = Math.max(-90, Math.min(90, t[3]));
    if (t[2] - t[0] >= 360)
      r = -180, i = 180;
    else if (r > i) {
      var s = this.getClusters([r, o, 180, a], n), l = this.getClusters([-180, o, i, a], n);
      return s.concat(l);
    }
    var u = this.trees[this._limitZoom(n)], c = u.range(Jm(r), Qm(a), Jm(i), Qm(o)), p = u.data, d = [];
    for (var g of c) {
      var f = this.stride * g;
      d.push(p[f + Dl] > 1 ? Ez(p, f, this.clusterProps) : this.points[p[f + Fl]]);
    }
    return d;
  }
  getChildren(t) {
    var n = this._getOriginId(t), r = this._getOriginZoom(t), o = "No cluster with the specified id.", i = this.trees[r];
    if (!i) throw new Error(o);
    var a = i.data;
    if (n * this.stride >= a.length) throw new Error(o);
    var s = this.options.radius / (this.options.extent * Math.pow(2, r - 1)), l = a[n * this.stride], u = a[n * this.stride + 1], c = i.within(l, u, s), p = [];
    for (var d of c) {
      var g = d * this.stride;
      a[g + uE] === t && p.push(a[g + Dl] > 1 ? Ez(a, g, this.clusterProps) : this.points[a[g + Fl]]);
    }
    if (p.length === 0) throw new Error(o);
    return p;
  }
  getLeaves(t, n, r) {
    n = n || 10, r = r || 0;
    var o = [];
    return this._appendLeaves(o, t, n, r, 0), o;
  }
  getTile(t, n, r) {
    var o = this.trees[this._limitZoom(t)], i = Math.pow(2, t), {
      extent: a,
      radius: s
    } = this.options, l = s / a, u = (r - l) / i, c = (r + 1 + l) / i, p = {
      features: []
    };
    return this._addTileFeatures(o.range((n - l) / i, u, (n + 1 + l) / i, c), o.data, n, r, i, p), n === 0 && this._addTileFeatures(o.range(1 - l / i, u, 1, c), o.data, i, r, i, p), n === i - 1 && this._addTileFeatures(o.range(0, u, l / i, c), o.data, -1, r, i, p), p.features.length ? p : null;
  }
  getClusterExpansionZoom(t) {
    for (var n = this._getOriginZoom(t) - 1; n <= this.options.maxZoom; ) {
      var r = this.getChildren(t);
      if (n++, r.length !== 1) break;
      t = r[0].properties.cluster_id;
    }
    return n;
  }
  _appendLeaves(t, n, r, o, i) {
    var a = this.getChildren(n);
    for (var s of a) {
      var l = s.properties;
      if (l && l.cluster ? i + l.point_count <= o ? i += l.point_count : i = this._appendLeaves(t, l.cluster_id, r, o, i) : i < o ? i++ : t.push(s), t.length === r) break;
    }
    return i;
  }
  _createTree(t) {
    for (var n = new _D(t.length / this.stride | 0, this.options.nodeSize, Float32Array), r = 0; r < t.length; r += this.stride) n.add(t[r], t[r + 1]);
    return n.finish(), n.data = t, n;
  }
  _addTileFeatures(t, n, r, o, i, a) {
    for (var s of t) {
      var l = s * this.stride, u = n[l + Dl] > 1, c = void 0, p = void 0, d = void 0;
      if (u)
        c = PQ(n, l, this.clusterProps), p = n[l], d = n[l + 1];
      else {
        var g = this.points[n[l + Fl]];
        c = g.properties;
        var [f, m] = g.geometry.coordinates;
        p = Jm(f), d = Qm(m);
      }
      var b = {
        type: 1,
        geometry: [[Math.round(this.options.extent * (p * i - r)), Math.round(this.options.extent * (d * i - o))]],
        tags: c
      }, E = void 0;
      u || this.options.generateId ? E = n[l + Fl] : E = this.points[n[l + Fl]].id, E !== void 0 && (b.id = E), a.features.push(b);
    }
  }
  _limitZoom(t) {
    return Math.max(this.options.minZoom, Math.min(Math.floor(+t), this.options.maxZoom + 1));
  }
  _cluster(t, n) {
    for (var {
      radius: r,
      extent: o,
      reduce: i,
      minPoints: a
    } = this.options, s = r / (o * Math.pow(2, n)), l = t.data, u = [], c = this.stride, p = 0; p < l.length; p += c)
      if (!(l[p + Au] <= n)) {
        l[p + Au] = n;
        var d = l[p], g = l[p + 1], f = t.within(l[p], l[p + 1], s), m = l[p + Dl], b = m;
        for (var E of f) {
          var w = E * c;
          l[w + Au] > n && (b += l[w + Dl]);
        }
        if (b > m && b >= a) {
          var M = d * m, x = g * m, v = void 0, C = -1, P = ((p / c | 0) << 5) + (n + 1) + this.points.length;
          for (var F of f) {
            var L = F * c;
            if (!(l[L + Au] <= n)) {
              l[L + Au] = n;
              var B = l[L + Dl];
              M += l[L] * B, x += l[L + 1] * B, l[L + uE] = P, i && (v || (v = this._map(l, p, !0), C = this.clusterProps.length, this.clusterProps.push(v)), i(v, this._map(l, L)));
            }
          }
          l[p + uE] = P, u.push(M / b, x / b, 1 / 0, P, -1, b), i && u.push(C);
        } else {
          for (var N = 0; N < c; N++) u.push(l[p + N]);
          if (b > 1)
            for (var $ of f) {
              var V = $ * c;
              if (!(l[V + Au] <= n)) {
                l[V + Au] = n;
                for (var H = 0; H < c; H++) u.push(l[V + H]);
              }
            }
        }
      }
    return u;
  }
  // get index of the point from which the cluster originated
  _getOriginId(t) {
    return t - this.points.length >> 5;
  }
  // get zoom of the point from which the cluster originated
  _getOriginZoom(t) {
    return (t - this.points.length) % 32;
  }
  _map(t, n, r) {
    if (t[n + Dl] > 1) {
      var o = this.clusterProps[t[n + _Q]];
      return r ? Object.assign({}, o) : o;
    }
    var i = this.points[t[n + Fl]].properties, a = this.options.map(i);
    return r && a === i ? Object.assign({}, a) : a;
  }
}
function Ez(e, t, n) {
  return {
    type: "Feature",
    id: e[t + Fl],
    properties: PQ(e, t, n),
    geometry: {
      type: "Point",
      coordinates: [Ike(e[t]), Nke(e[t + 1])]
    }
  };
}
function PQ(e, t, n) {
  var r = e[t + Dl], o = r >= 1e4 ? "".concat(Math.round(r / 1e3), "k") : r >= 1e3 ? "".concat(Math.round(r / 100) / 10, "k") : r, i = e[t + _Q], a = i === -1 ? {} : Object.assign({}, n[i]);
  return Object.assign(a, {
    cluster: !0,
    cluster_id: e[t + Fl],
    point_count: r,
    point_count_abbreviated: o
  });
}
function Jm(e) {
  return e / 360 + 0.5;
}
function Qm(e) {
  var t = Math.sin(e * Math.PI / 180), n = 0.5 - 0.25 * Math.log((1 + t) / (1 - t)) / Math.PI;
  return n < 0 ? 0 : n > 1 ? 1 : n;
}
function Ike(e) {
  return (e - 0.5) * 360;
}
function Nke(e) {
  var t = (180 - e * 360) * Math.PI / 180;
  return 360 * Math.atan(Math.exp(t)) / Math.PI - 90;
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function Bke(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
    t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
  return n;
}
class cs {
  static isAdvancedMarkerAvailable(t) {
    return google.maps.marker && t.getMapCapabilities().isAdvancedMarkersAvailable === !0;
  }
  static isAdvancedMarker(t) {
    return google.maps.marker && t instanceof google.maps.marker.AdvancedMarkerElement;
  }
  static setMap(t, n) {
    this.isAdvancedMarker(t) ? t.map = n : t.setMap(n);
  }
  static getPosition(t) {
    if (this.isAdvancedMarker(t)) {
      if (t.position) {
        if (t.position instanceof google.maps.LatLng)
          return t.position;
        if (t.position.lat && t.position.lng)
          return new google.maps.LatLng(t.position.lat, t.position.lng);
      }
      return new google.maps.LatLng(null);
    }
    return t.getPosition();
  }
  static getVisible(t) {
    return this.isAdvancedMarker(t) ? !0 : t.getVisible();
  }
}
class T_ {
  constructor(t) {
    var {
      markers: n,
      position: r
    } = t;
    this.markers = n, r && (r instanceof google.maps.LatLng ? this._position = r : this._position = new google.maps.LatLng(r));
  }
  get bounds() {
    if (!(this.markers.length === 0 && !this._position)) {
      var t = new google.maps.LatLngBounds(this._position, this._position);
      for (var n of this.markers)
        t.extend(cs.getPosition(n));
      return t;
    }
  }
  get position() {
    return this._position || this.bounds.getCenter();
  }
  /**
   * Get the count of **visible** markers.
   */
  get count() {
    return this.markers.filter((t) => cs.getVisible(t)).length;
  }
  /**
   * Add a marker to the cluster.
   */
  push(t) {
    this.markers.push(t);
  }
  /**
   * Cleanup references and remove marker from map.
   */
  delete() {
    this.marker && (cs.setMap(this.marker, null), this.marker = void 0), this.markers.length = 0;
  }
}
let Fke = class {
  constructor(e) {
    var {
      maxZoom: t = 16
    } = e;
    this.maxZoom = t;
  }
  /**
   * Helper function to bypass clustering based upon some map state such as
   * zoom, number of markers, etc.
   *
   * ```typescript
   *  cluster({markers, map}: AlgorithmInput): Cluster[] {
   *    if (shouldBypassClustering(map)) {
   *      return this.noop({markers})
   *    }
   * }
   * ```
   */
  noop(e) {
    var {
      markers: t
    } = e;
    return zke(t);
  }
};
var zke = (e) => {
  var t = e.map((n) => new T_({
    position: cs.getPosition(n),
    markers: [n]
  }));
  return t;
};
class Uke extends Fke {
  constructor(t) {
    var {
      maxZoom: n,
      radius: r = 60
    } = t, o = Bke(t, ["maxZoom", "radius"]);
    super({
      maxZoom: n
    }), this.state = {
      zoom: -1
    }, this.superCluster = new Rke(Object.assign({
      maxZoom: this.maxZoom,
      radius: r
    }, o));
  }
  calculate(t) {
    var n = !1, r = {
      zoom: t.map.getZoom()
    };
    if (!wz(t.markers, this.markers)) {
      n = !0, this.markers = [...t.markers];
      var o = this.markers.map((i) => {
        var a = cs.getPosition(i), s = [a.lng(), a.lat()];
        return {
          type: "Feature",
          geometry: {
            type: "Point",
            coordinates: s
          },
          properties: {
            marker: i
          }
        };
      });
      this.superCluster.load(o);
    }
    return n || (this.state.zoom <= this.maxZoom || r.zoom <= this.maxZoom) && (n = !wz(this.state, r)), this.state = r, n && (this.clusters = this.cluster(t)), {
      clusters: this.clusters,
      changed: n
    };
  }
  cluster(t) {
    var {
      map: n
    } = t;
    return this.superCluster.getClusters([-180, -90, 180, 90], Math.round(n.getZoom())).map((r) => this.transformCluster(r));
  }
  transformCluster(t) {
    var {
      geometry: {
        coordinates: [n, r]
      },
      properties: o
    } = t;
    if (o.cluster)
      return new T_({
        markers: this.superCluster.getLeaves(o.cluster_id, 1 / 0).map((a) => a.properties.marker),
        position: {
          lat: r,
          lng: n
        }
      });
    var i = o.marker;
    return new T_({
      markers: [i],
      position: cs.getPosition(i)
    });
  }
}
class Hke {
  constructor(t, n) {
    this.markers = {
      sum: t.length
    };
    var r = n.map((i) => i.count), o = r.reduce((i, a) => i + a, 0);
    this.clusters = {
      count: n.length,
      markers: {
        mean: o / n.length,
        sum: o,
        min: Math.min(...r),
        max: Math.max(...r)
      }
    };
  }
}
class Wke {
  /**
   * The default render function for the library used by {@link MarkerClusterer}.
   *
   * Currently set to use the following:
   *
   * ```typescript
   * // change color if this cluster has more markers than the mean cluster
   * const color =
   *   count > Math.max(10, stats.clusters.markers.mean)
   *     ? "#ff0000"
   *     : "#0000ff";
   *
   * // create svg url with fill color
   * const svg = window.btoa(`
   * <svg fill="${color}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240">
   *   <circle cx="120" cy="120" opacity=".6" r="70" />
   *   <circle cx="120" cy="120" opacity=".3" r="90" />
   *   <circle cx="120" cy="120" opacity=".2" r="110" />
   *   <circle cx="120" cy="120" opacity=".1" r="130" />
   * </svg>`);
   *
   * // create marker using svg icon
   * return new google.maps.Marker({
   *   position,
   *   icon: {
   *     url: `data:image/svg+xml;base64,${svg}`,
   *     scaledSize: new google.maps.Size(45, 45),
   *   },
   *   label: {
   *     text: String(count),
   *     color: "rgba(255,255,255,0.9)",
   *     fontSize: "12px",
   *   },
   *   // adjust zIndex to be above other markers
   *   zIndex: 1000 + count,
   * });
   * ```
   */
  render(t, n, r) {
    var {
      count: o,
      position: i
    } = t, a = o > Math.max(10, n.clusters.markers.mean) ? "#ff0000" : "#0000ff", s = '<svg fill="'.concat(a, `" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" width="50" height="50">
<circle cx="120" cy="120" opacity=".6" r="70" />
<circle cx="120" cy="120" opacity=".3" r="90" />
<circle cx="120" cy="120" opacity=".2" r="110" />
<text x="50%" y="50%" style="fill:#fff" text-anchor="middle" font-size="50" dominant-baseline="middle" font-family="roboto,arial,sans-serif">`).concat(o, `</text>
</svg>`), l = "Cluster of ".concat(o, " markers"), u = Number(google.maps.Marker.MAX_ZINDEX) + o;
    if (cs.isAdvancedMarkerAvailable(r)) {
      var c = new DOMParser(), p = c.parseFromString(s, "image/svg+xml").documentElement;
      p.setAttribute("transform", "translate(0 25)");
      var d = {
        map: r,
        position: i,
        zIndex: u,
        title: l,
        content: p
      };
      return new google.maps.marker.AdvancedMarkerElement(d);
    }
    var g = {
      position: i,
      zIndex: u,
      title: l,
      icon: {
        url: "data:image/svg+xml;base64,".concat(btoa(s)),
        anchor: new google.maps.Point(25, 25)
      }
    };
    return new google.maps.Marker(g);
  }
}
function $ke(e, t) {
  for (var n in t.prototype)
    e.prototype[n] = t.prototype[n];
}
class PD {
  constructor() {
    $ke(PD, google.maps.OverlayView);
  }
}
var xf;
(function(e) {
  e.CLUSTERING_BEGIN = "clusteringbegin", e.CLUSTERING_END = "clusteringend", e.CLUSTER_CLICK = "click";
})(xf || (xf = {}));
var Vke = (e, t, n) => {
  n.fitBounds(t.bounds);
};
class Zke extends PD {
  constructor(t) {
    var {
      map: n,
      markers: r = [],
      algorithmOptions: o = {},
      algorithm: i = new Uke(o),
      renderer: a = new Wke(),
      onClusterClick: s = Vke
    } = t;
    super(), this.markers = [...r], this.clusters = [], this.algorithm = i, this.renderer = a, this.onClusterClick = s, n && this.setMap(n);
  }
  addMarker(t, n) {
    this.markers.includes(t) || (this.markers.push(t), n || this.render());
  }
  addMarkers(t, n) {
    t.forEach((r) => {
      this.addMarker(r, !0);
    }), n || this.render();
  }
  removeMarker(t, n) {
    var r = this.markers.indexOf(t);
    return r === -1 ? !1 : (cs.setMap(t, null), this.markers.splice(r, 1), n || this.render(), !0);
  }
  removeMarkers(t, n) {
    var r = !1;
    return t.forEach((o) => {
      r = this.removeMarker(o, !0) || r;
    }), r && !n && this.render(), r;
  }
  clearMarkers(t) {
    this.markers.length = 0, t || this.render();
  }
  /**
   * Recalculates and draws all the marker clusters.
   */
  render() {
    var t = this.getMap();
    if (t instanceof google.maps.Map && t.getProjection()) {
      google.maps.event.trigger(this, xf.CLUSTERING_BEGIN, this);
      var {
        clusters: n,
        changed: r
      } = this.algorithm.calculate({
        markers: this.markers,
        map: t,
        mapCanvasProjection: this.getProjection()
      });
      if (r || r == null) {
        var o = /* @__PURE__ */ new Set();
        for (var i of n)
          i.markers.length == 1 && o.add(i.markers[0]);
        var a = [];
        for (var s of this.clusters)
          s.marker != null && (s.markers.length == 1 ? o.has(s.marker) || cs.setMap(s.marker, null) : a.push(s.marker));
        this.clusters = n, this.renderClusters(), requestAnimationFrame(() => a.forEach((l) => cs.setMap(l, null)));
      }
      google.maps.event.trigger(this, xf.CLUSTERING_END, this);
    }
  }
  onAdd() {
    this.idleListener = this.getMap().addListener("idle", this.render.bind(this)), this.render();
  }
  onRemove() {
    google.maps.event.removeListener(this.idleListener), this.reset();
  }
  reset() {
    this.markers.forEach((t) => cs.setMap(t, null)), this.clusters.forEach((t) => t.delete()), this.clusters = [];
  }
  renderClusters() {
    var t = new Hke(this.markers, this.clusters), n = this.getMap();
    this.clusters.forEach((r) => {
      r.markers.length === 1 ? r.marker = r.markers[0] : (r.marker = this.renderer.render(r, t, n), r.markers.forEach((o) => cs.setMap(o, null)), this.onClusterClick && r.marker.addListener(
        "click",
        /* istanbul ignore next */
        (o) => {
          google.maps.event.trigger(this, xf.CLUSTER_CLICK, r), this.onClusterClick(o, r, n);
        }
      )), cs.setMap(r.marker, n);
    });
  }
}
function kz(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Lz(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? kz(Object(n), !0).forEach(function(r) {
      Le(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : kz(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function qke(e) {
  var t = VEe(), [n, r] = k(null);
  return h(() => {
    if (t && n === null) {
      var o = new Zke(Lz(Lz({}, e), {}, {
        map: t
      }));
      r(o);
    }
  }, [t]), n;
}
function Gke(e) {
  var {
    children: t,
    options: n
  } = e, r = qke(n);
  return r !== null ? t(r) : null;
}
me(Gke);
var _z = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, Pz = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
function Kke(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, g = ge(Rt), [f, m] = k(null), [b, E] = k(null), [w, M] = k(null), [x, v] = k(null), [C, P] = k(null), [F, L] = k(null), B = dt(null);
  return h(() => {
    f !== null && (f.close(), n ? f.open(g, n) : f.getPosition() && f.open(g));
  }, [g, f, n]), h(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), h(() => {
    o && f !== null && f.setPosition(o);
  }, [o]), h(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), h(() => {
    f && a && (b !== null && google.maps.event.removeListener(b), E(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), h(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), M(google.maps.event.addListener(f, "domready", s)));
  }, [s]), h(() => {
    f && l && (x !== null && google.maps.event.removeListener(x), v(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), h(() => {
    f && u && (C !== null && google.maps.event.removeListener(C), P(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), h(() => {
    f && c && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), h(() => {
    var N = new google.maps.InfoWindow(r);
    return m(N), B.current = document.createElement("div"), a && E(google.maps.event.addListener(N, "closeclick", a)), s && M(google.maps.event.addListener(N, "domready", s)), l && v(google.maps.event.addListener(N, "content_changed", l)), u && P(google.maps.event.addListener(N, "position_changed", u)), c && L(google.maps.event.addListener(N, "zindex_changed", c)), N.setContent(B.current), o && N.setPosition(o), i && N.setZIndex(i), n ? N.open(g, n) : N.getPosition() ? N.open(g) : Uo(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>."), p && p(N), () => {
      b && google.maps.event.removeListener(b), x && google.maps.event.removeListener(x), w && google.maps.event.removeListener(w), C && google.maps.event.removeListener(C), F && google.maps.event.removeListener(F), d && d(N), N.close();
    };
  }, []), B.current ? zn(at.only(t), B.current) : null;
}
me(Kke);
class Xke extends pe {
  constructor() {
    super(...arguments), Le(this, "registeredEvents", []), Le(this, "containerElement", null), Le(this, "state", {
      infoWindow: null
    }), Le(this, "open", (t, n) => {
      n ? t.open(this.context, n) : t.getPosition() ? t.open(this.context) : Uo(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>.");
    }), Le(this, "setInfoWindowCallback", () => {
      this.state.infoWindow !== null && this.containerElement !== null && (this.state.infoWindow.setContent(this.containerElement), this.open(this.state.infoWindow, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoWindow));
    });
  }
  componentDidMount() {
    var t = new google.maps.InfoWindow(this.props.options);
    this.containerElement = document.createElement("div"), this.registeredEvents = vn({
      updaterMap: Pz,
      eventMap: _z,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(() => ({
      infoWindow: t
    }), this.setInfoWindowCallback);
  }
  componentDidUpdate(t) {
    this.state.infoWindow !== null && (En(this.registeredEvents), this.registeredEvents = vn({
      updaterMap: Pz,
      eventMap: _z,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.infoWindow
    }));
  }
  componentWillUnmount() {
    this.state.infoWindow !== null && (En(this.registeredEvents), this.props.onUnmount && this.props.onUnmount(this.state.infoWindow), this.state.infoWindow.close());
  }
  render() {
    return this.containerElement ? zn(at.only(this.props.children), this.containerElement) : null;
  }
}
Le(Xke, "contextType", Rt);
function Sz(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function jb(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Sz(Object(n), !0).forEach(function(r) {
      Le(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Sz(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Mz = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, Dz = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, Yke = {};
function Jke(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: g,
    onRightClick: f,
    onClick: m,
    onDrag: b,
    onLoad: E,
    onUnmount: w
  } = e, M = ge(Rt), [x, v] = k(null), [C, P] = k(null), [F, L] = k(null), [B, N] = k(null), [$, V] = k(null), [H, Z] = k(null), [K, Y] = k(null), [Q, J] = k(null), [_, D] = k(null), [z, S] = k(null), [W, O] = k(null), [j, U] = k(null);
  return h(() => {
    x !== null && x.setMap(M);
  }, [M]), h(() => {
    typeof t < "u" && x !== null && x.setOptions(t);
  }, [x, t]), h(() => {
    typeof n < "u" && x !== null && x.setDraggable(n);
  }, [x, n]), h(() => {
    typeof r < "u" && x !== null && x.setEditable(r);
  }, [x, r]), h(() => {
    typeof o < "u" && x !== null && x.setVisible(o);
  }, [x, o]), h(() => {
    typeof i < "u" && x !== null && x.setPath(i);
  }, [x, i]), h(() => {
    x && a && (C !== null && google.maps.event.removeListener(C), P(google.maps.event.addListener(x, "dblclick", a)));
  }, [a]), h(() => {
    x && s && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(x, "dragend", s)));
  }, [s]), h(() => {
    x && l && (B !== null && google.maps.event.removeListener(B), N(google.maps.event.addListener(x, "dragstart", l)));
  }, [l]), h(() => {
    x && u && ($ !== null && google.maps.event.removeListener($), V(google.maps.event.addListener(x, "mousedown", u)));
  }, [u]), h(() => {
    x && c && (H !== null && google.maps.event.removeListener(H), Z(google.maps.event.addListener(x, "mousemove", c)));
  }, [c]), h(() => {
    x && p && (K !== null && google.maps.event.removeListener(K), Y(google.maps.event.addListener(x, "mouseout", p)));
  }, [p]), h(() => {
    x && d && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(x, "mouseover", d)));
  }, [d]), h(() => {
    x && g && (_ !== null && google.maps.event.removeListener(_), D(google.maps.event.addListener(x, "mouseup", g)));
  }, [g]), h(() => {
    x && f && (z !== null && google.maps.event.removeListener(z), S(google.maps.event.addListener(x, "rightclick", f)));
  }, [f]), h(() => {
    x && m && (W !== null && google.maps.event.removeListener(W), O(google.maps.event.addListener(x, "click", m)));
  }, [m]), h(() => {
    x && b && (j !== null && google.maps.event.removeListener(j), U(google.maps.event.addListener(x, "drag", b)));
  }, [b]), h(() => {
    var T = new google.maps.Polyline(jb(jb({}, t || Yke), {}, {
      map: M
    }));
    return i && T.setPath(i), typeof o < "u" && T.setVisible(o), typeof r < "u" && T.setEditable(r), typeof n < "u" && T.setDraggable(n), a && P(google.maps.event.addListener(T, "dblclick", a)), s && L(google.maps.event.addListener(T, "dragend", s)), l && N(google.maps.event.addListener(T, "dragstart", l)), u && V(google.maps.event.addListener(T, "mousedown", u)), c && Z(google.maps.event.addListener(T, "mousemove", c)), p && Y(google.maps.event.addListener(T, "mouseout", p)), d && J(google.maps.event.addListener(T, "mouseover", d)), g && D(google.maps.event.addListener(T, "mouseup", g)), f && S(google.maps.event.addListener(T, "rightclick", f)), m && O(google.maps.event.addListener(T, "click", m)), b && U(google.maps.event.addListener(T, "drag", b)), v(T), E && E(T), () => {
      C !== null && google.maps.event.removeListener(C), F !== null && google.maps.event.removeListener(F), B !== null && google.maps.event.removeListener(B), $ !== null && google.maps.event.removeListener($), H !== null && google.maps.event.removeListener(H), K !== null && google.maps.event.removeListener(K), Q !== null && google.maps.event.removeListener(Q), _ !== null && google.maps.event.removeListener(_), z !== null && google.maps.event.removeListener(z), W !== null && google.maps.event.removeListener(W), w && w(T), T.setMap(null);
    };
  }, []), null;
}
me(Jke);
class Qke extends pe {
  constructor() {
    super(...arguments), Le(this, "registeredEvents", []), Le(this, "state", {
      polyline: null
    }), Le(this, "setPolylineCallback", () => {
      this.state.polyline !== null && this.props.onLoad && this.props.onLoad(this.state.polyline);
    });
  }
  componentDidMount() {
    var t = new google.maps.Polyline(jb(jb({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = vn({
      updaterMap: Dz,
      eventMap: Mz,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        polyline: t
      };
    }, this.setPolylineCallback);
  }
  componentDidUpdate(t) {
    this.state.polyline !== null && (En(this.registeredEvents), this.registeredEvents = vn({
      updaterMap: Dz,
      eventMap: Mz,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.polyline
    }));
  }
  componentWillUnmount() {
    this.state.polyline !== null && (this.props.onUnmount && this.props.onUnmount(this.state.polyline), En(this.registeredEvents), this.state.polyline.setMap(null));
  }
  render() {
    return null;
  }
}
Le(Qke, "contextType", Rt);
function Tz(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function jz(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Tz(Object(n), !0).forEach(function(r) {
      Le(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Tz(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Az = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, Rz = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  paths(e, t) {
    e.setPaths(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function eLe(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    paths: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: g,
    onMouseUp: f,
    onRightClick: m,
    onClick: b,
    onDrag: E,
    onLoad: w,
    onUnmount: M,
    onEdit: x
  } = e, v = ge(Rt), [C, P] = k(null), [F, L] = k(null), [B, N] = k(null), [$, V] = k(null), [H, Z] = k(null), [K, Y] = k(null), [Q, J] = k(null), [_, D] = k(null), [z, S] = k(null), [W, O] = k(null), [j, U] = k(null), [T, q] = k(null);
  return h(() => {
    C !== null && C.setMap(v);
  }, [v]), h(() => {
    typeof t < "u" && C !== null && C.setOptions(t);
  }, [C, t]), h(() => {
    typeof n < "u" && C !== null && C.setDraggable(n);
  }, [C, n]), h(() => {
    typeof r < "u" && C !== null && C.setEditable(r);
  }, [C, r]), h(() => {
    typeof o < "u" && C !== null && C.setVisible(o);
  }, [C, o]), h(() => {
    typeof i < "u" && C !== null && C.setPath(i);
  }, [C, i]), h(() => {
    typeof a < "u" && C !== null && C.setPaths(a);
  }, [C, a]), h(() => {
    C && typeof s == "function" && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(C, "dblclick", s)));
  }, [s]), h(() => {
    C && (google.maps.event.addListener(C.getPath(), "insert_at", () => {
      x == null || x(C);
    }), google.maps.event.addListener(C.getPath(), "set_at", () => {
      x == null || x(C);
    }), google.maps.event.addListener(C.getPath(), "remove_at", () => {
      x == null || x(C);
    }));
  }, [C, x]), h(() => {
    C && typeof l == "function" && (B !== null && google.maps.event.removeListener(B), N(google.maps.event.addListener(C, "dragend", l)));
  }, [l]), h(() => {
    C && typeof u == "function" && ($ !== null && google.maps.event.removeListener($), V(google.maps.event.addListener(C, "dragstart", u)));
  }, [u]), h(() => {
    C && typeof c == "function" && (H !== null && google.maps.event.removeListener(H), Z(google.maps.event.addListener(C, "mousedown", c)));
  }, [c]), h(() => {
    C && typeof p == "function" && (K !== null && google.maps.event.removeListener(K), Y(google.maps.event.addListener(C, "mousemove", p)));
  }, [p]), h(() => {
    C && typeof d == "function" && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(C, "mouseout", d)));
  }, [d]), h(() => {
    C && typeof g == "function" && (_ !== null && google.maps.event.removeListener(_), D(google.maps.event.addListener(C, "mouseover", g)));
  }, [g]), h(() => {
    C && typeof f == "function" && (z !== null && google.maps.event.removeListener(z), S(google.maps.event.addListener(C, "mouseup", f)));
  }, [f]), h(() => {
    C && typeof m == "function" && (W !== null && google.maps.event.removeListener(W), O(google.maps.event.addListener(C, "rightclick", m)));
  }, [m]), h(() => {
    C && typeof b == "function" && (j !== null && google.maps.event.removeListener(j), U(google.maps.event.addListener(C, "click", b)));
  }, [b]), h(() => {
    C && typeof E == "function" && (T !== null && google.maps.event.removeListener(T), q(google.maps.event.addListener(C, "drag", E)));
  }, [E]), h(() => {
    var A = new google.maps.Polygon(jz(jz({}, t), {}, {
      map: v
    }));
    return i && A.setPath(i), a && A.setPaths(a), typeof o < "u" && A.setVisible(o), typeof r < "u" && A.setEditable(r), typeof n < "u" && A.setDraggable(n), s && L(google.maps.event.addListener(A, "dblclick", s)), l && N(google.maps.event.addListener(A, "dragend", l)), u && V(google.maps.event.addListener(A, "dragstart", u)), c && Z(google.maps.event.addListener(A, "mousedown", c)), p && Y(google.maps.event.addListener(A, "mousemove", p)), d && J(google.maps.event.addListener(A, "mouseout", d)), g && D(google.maps.event.addListener(A, "mouseover", g)), f && S(google.maps.event.addListener(A, "mouseup", f)), m && O(google.maps.event.addListener(A, "rightclick", m)), b && U(google.maps.event.addListener(A, "click", b)), E && q(google.maps.event.addListener(A, "drag", E)), P(A), w && w(A), () => {
      F !== null && google.maps.event.removeListener(F), B !== null && google.maps.event.removeListener(B), $ !== null && google.maps.event.removeListener($), H !== null && google.maps.event.removeListener(H), K !== null && google.maps.event.removeListener(K), Q !== null && google.maps.event.removeListener(Q), _ !== null && google.maps.event.removeListener(_), z !== null && google.maps.event.removeListener(z), W !== null && google.maps.event.removeListener(W), j !== null && google.maps.event.removeListener(j), M && M(A), A.setMap(null);
    };
  }, []), null;
}
me(eLe);
class tLe extends pe {
  constructor() {
    super(...arguments), Le(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this.props.options || {};
    this.polygon = new google.maps.Polygon(t), this.polygon.setMap(this.context), this.registeredEvents = vn({
      updaterMap: Rz,
      eventMap: Az,
      prevProps: {},
      nextProps: this.props,
      instance: this.polygon
    }), this.props.onLoad && this.props.onLoad(this.polygon);
  }
  componentDidUpdate(t) {
    this.polygon && (En(this.registeredEvents), this.registeredEvents = vn({
      updaterMap: Rz,
      eventMap: Az,
      prevProps: t,
      nextProps: this.props,
      instance: this.polygon
    }));
  }
  componentWillUnmount() {
    this.polygon && (this.props.onUnmount && this.props.onUnmount(this.polygon), En(this.registeredEvents), this.polygon && this.polygon.setMap(null));
  }
  render() {
    return null;
  }
}
Le(tLe, "contextType", Rt);
function Iz(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Ab(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Iz(Object(n), !0).forEach(function(r) {
      Le(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Iz(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Nz = {
  onBoundsChanged: "bounds_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, Bz = {
  bounds(e, t) {
    e.setBounds(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function nLe(e) {
  var {
    options: t,
    bounds: n,
    draggable: r,
    editable: o,
    visible: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: g,
    onRightClick: f,
    onClick: m,
    onDrag: b,
    onBoundsChanged: E,
    onLoad: w,
    onUnmount: M
  } = e, x = ge(Rt), [v, C] = k(null), [P, F] = k(null), [L, B] = k(null), [N, $] = k(null), [V, H] = k(null), [Z, K] = k(null), [Y, Q] = k(null), [J, _] = k(null), [D, z] = k(null), [S, W] = k(null), [O, j] = k(null), [U, T] = k(null), [q, A] = k(null);
  return h(() => {
    v !== null && v.setMap(x);
  }, [x]), h(() => {
    typeof t < "u" && v !== null && v.setOptions(t);
  }, [v, t]), h(() => {
    typeof r < "u" && v !== null && v.setDraggable(r);
  }, [v, r]), h(() => {
    typeof o < "u" && v !== null && v.setEditable(o);
  }, [v, o]), h(() => {
    typeof i < "u" && v !== null && v.setVisible(i);
  }, [v, i]), h(() => {
    typeof n < "u" && v !== null && v.setBounds(n);
  }, [v, n]), h(() => {
    v && a && (P !== null && google.maps.event.removeListener(P), F(google.maps.event.addListener(v, "dblclick", a)));
  }, [a]), h(() => {
    v && s && (L !== null && google.maps.event.removeListener(L), B(google.maps.event.addListener(v, "dragend", s)));
  }, [s]), h(() => {
    v && l && (N !== null && google.maps.event.removeListener(N), $(google.maps.event.addListener(v, "dragstart", l)));
  }, [l]), h(() => {
    v && u && (V !== null && google.maps.event.removeListener(V), H(google.maps.event.addListener(v, "mousedown", u)));
  }, [u]), h(() => {
    v && c && (Z !== null && google.maps.event.removeListener(Z), K(google.maps.event.addListener(v, "mousemove", c)));
  }, [c]), h(() => {
    v && p && (Y !== null && google.maps.event.removeListener(Y), Q(google.maps.event.addListener(v, "mouseout", p)));
  }, [p]), h(() => {
    v && d && (J !== null && google.maps.event.removeListener(J), _(google.maps.event.addListener(v, "mouseover", d)));
  }, [d]), h(() => {
    v && g && (D !== null && google.maps.event.removeListener(D), z(google.maps.event.addListener(v, "mouseup", g)));
  }, [g]), h(() => {
    v && f && (S !== null && google.maps.event.removeListener(S), W(google.maps.event.addListener(v, "rightclick", f)));
  }, [f]), h(() => {
    v && m && (O !== null && google.maps.event.removeListener(O), j(google.maps.event.addListener(v, "click", m)));
  }, [m]), h(() => {
    v && b && (U !== null && google.maps.event.removeListener(U), T(google.maps.event.addListener(v, "drag", b)));
  }, [b]), h(() => {
    v && E && (q !== null && google.maps.event.removeListener(q), A(google.maps.event.addListener(v, "bounds_changed", E)));
  }, [E]), h(() => {
    var X = new google.maps.Rectangle(Ab(Ab({}, t), {}, {
      map: x
    }));
    return typeof i < "u" && X.setVisible(i), typeof o < "u" && X.setEditable(o), typeof r < "u" && X.setDraggable(r), typeof n < "u" && X.setBounds(n), a && F(google.maps.event.addListener(X, "dblclick", a)), s && B(google.maps.event.addListener(X, "dragend", s)), l && $(google.maps.event.addListener(X, "dragstart", l)), u && H(google.maps.event.addListener(X, "mousedown", u)), c && K(google.maps.event.addListener(X, "mousemove", c)), p && Q(google.maps.event.addListener(X, "mouseout", p)), d && _(google.maps.event.addListener(X, "mouseover", d)), g && z(google.maps.event.addListener(X, "mouseup", g)), f && W(google.maps.event.addListener(X, "rightclick", f)), m && j(google.maps.event.addListener(X, "click", m)), b && T(google.maps.event.addListener(X, "drag", b)), E && A(google.maps.event.addListener(X, "bounds_changed", E)), C(X), w && w(X), () => {
      P !== null && google.maps.event.removeListener(P), L !== null && google.maps.event.removeListener(L), N !== null && google.maps.event.removeListener(N), V !== null && google.maps.event.removeListener(V), Z !== null && google.maps.event.removeListener(Z), Y !== null && google.maps.event.removeListener(Y), J !== null && google.maps.event.removeListener(J), D !== null && google.maps.event.removeListener(D), S !== null && google.maps.event.removeListener(S), O !== null && google.maps.event.removeListener(O), U !== null && google.maps.event.removeListener(U), q !== null && google.maps.event.removeListener(q), M && M(X), X.setMap(null);
    };
  }, []), null;
}
me(nLe);
class rLe extends pe {
  constructor() {
    super(...arguments), Le(this, "registeredEvents", []), Le(this, "state", {
      rectangle: null
    }), Le(this, "setRectangleCallback", () => {
      this.state.rectangle !== null && this.props.onLoad && this.props.onLoad(this.state.rectangle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Rectangle(Ab(Ab({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = vn({
      updaterMap: Bz,
      eventMap: Nz,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        rectangle: t
      };
    }, this.setRectangleCallback);
  }
  componentDidUpdate(t) {
    this.state.rectangle !== null && (En(this.registeredEvents), this.registeredEvents = vn({
      updaterMap: Bz,
      eventMap: Nz,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.rectangle
    }));
  }
  componentWillUnmount() {
    this.state.rectangle !== null && (this.props.onUnmount && this.props.onUnmount(this.state.rectangle), En(this.registeredEvents), this.state.rectangle.setMap(null));
  }
  render() {
    return null;
  }
}
Le(rLe, "contextType", Rt);
function Fz(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Rb(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Fz(Object(n), !0).forEach(function(r) {
      Le(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Fz(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var zz = {
  onCenterChanged: "center_changed",
  onRadiusChanged: "radius_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, Uz = {
  center(e, t) {
    e.setCenter(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  radius(e, t) {
    e.setRadius(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, oLe = {};
function iLe(e) {
  var {
    options: t,
    center: n,
    radius: r,
    draggable: o,
    editable: i,
    visible: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: g,
    onMouseUp: f,
    onRightClick: m,
    onClick: b,
    onDrag: E,
    onCenterChanged: w,
    onRadiusChanged: M,
    onLoad: x,
    onUnmount: v
  } = e, C = ge(Rt), [P, F] = k(null), [L, B] = k(null), [N, $] = k(null), [V, H] = k(null), [Z, K] = k(null), [Y, Q] = k(null), [J, _] = k(null), [D, z] = k(null), [S, W] = k(null), [O, j] = k(null), [U, T] = k(null), [q, A] = k(null), [X, I] = k(null), [le, he] = k(null);
  return h(() => {
    P !== null && P.setMap(C);
  }, [C]), h(() => {
    typeof t < "u" && P !== null && P.setOptions(t);
  }, [P, t]), h(() => {
    typeof o < "u" && P !== null && P.setDraggable(o);
  }, [P, o]), h(() => {
    typeof i < "u" && P !== null && P.setEditable(i);
  }, [P, i]), h(() => {
    typeof a < "u" && P !== null && P.setVisible(a);
  }, [P, a]), h(() => {
    typeof r == "number" && P !== null && P.setRadius(r);
  }, [P, r]), h(() => {
    typeof n < "u" && P !== null && P.setCenter(n);
  }, [P, n]), h(() => {
    P && s && (L !== null && google.maps.event.removeListener(L), B(google.maps.event.addListener(P, "dblclick", s)));
  }, [s]), h(() => {
    P && l && (N !== null && google.maps.event.removeListener(N), $(google.maps.event.addListener(P, "dragend", l)));
  }, [l]), h(() => {
    P && u && (V !== null && google.maps.event.removeListener(V), H(google.maps.event.addListener(P, "dragstart", u)));
  }, [u]), h(() => {
    P && c && (Z !== null && google.maps.event.removeListener(Z), K(google.maps.event.addListener(P, "mousedown", c)));
  }, [c]), h(() => {
    P && p && (Y !== null && google.maps.event.removeListener(Y), Q(google.maps.event.addListener(P, "mousemove", p)));
  }, [p]), h(() => {
    P && d && (J !== null && google.maps.event.removeListener(J), _(google.maps.event.addListener(P, "mouseout", d)));
  }, [d]), h(() => {
    P && g && (D !== null && google.maps.event.removeListener(D), z(google.maps.event.addListener(P, "mouseover", g)));
  }, [g]), h(() => {
    P && f && (S !== null && google.maps.event.removeListener(S), W(google.maps.event.addListener(P, "mouseup", f)));
  }, [f]), h(() => {
    P && m && (O !== null && google.maps.event.removeListener(O), j(google.maps.event.addListener(P, "rightclick", m)));
  }, [m]), h(() => {
    P && b && (U !== null && google.maps.event.removeListener(U), T(google.maps.event.addListener(P, "click", b)));
  }, [b]), h(() => {
    P && E && (q !== null && google.maps.event.removeListener(q), A(google.maps.event.addListener(P, "drag", E)));
  }, [E]), h(() => {
    P && w && (X !== null && google.maps.event.removeListener(X), I(google.maps.event.addListener(P, "center_changed", w)));
  }, [b]), h(() => {
    P && M && (le !== null && google.maps.event.removeListener(le), he(google.maps.event.addListener(P, "radius_changed", M)));
  }, [M]), h(() => {
    var oe = new google.maps.Circle(Rb(Rb({}, t || oLe), {}, {
      map: C
    }));
    return typeof r == "number" && oe.setRadius(r), typeof n < "u" && oe.setCenter(n), typeof r == "number" && oe.setRadius(r), typeof a < "u" && oe.setVisible(a), typeof i < "u" && oe.setEditable(i), typeof o < "u" && oe.setDraggable(o), s && B(google.maps.event.addListener(oe, "dblclick", s)), l && $(google.maps.event.addListener(oe, "dragend", l)), u && H(google.maps.event.addListener(oe, "dragstart", u)), c && K(google.maps.event.addListener(oe, "mousedown", c)), p && Q(google.maps.event.addListener(oe, "mousemove", p)), d && _(google.maps.event.addListener(oe, "mouseout", d)), g && z(google.maps.event.addListener(oe, "mouseover", g)), f && W(google.maps.event.addListener(oe, "mouseup", f)), m && j(google.maps.event.addListener(oe, "rightclick", m)), b && T(google.maps.event.addListener(oe, "click", b)), E && A(google.maps.event.addListener(oe, "drag", E)), w && I(google.maps.event.addListener(oe, "center_changed", w)), M && he(google.maps.event.addListener(oe, "radius_changed", M)), F(oe), x && x(oe), () => {
      L !== null && google.maps.event.removeListener(L), N !== null && google.maps.event.removeListener(N), V !== null && google.maps.event.removeListener(V), Z !== null && google.maps.event.removeListener(Z), Y !== null && google.maps.event.removeListener(Y), J !== null && google.maps.event.removeListener(J), D !== null && google.maps.event.removeListener(D), S !== null && google.maps.event.removeListener(S), O !== null && google.maps.event.removeListener(O), U !== null && google.maps.event.removeListener(U), X !== null && google.maps.event.removeListener(X), le !== null && google.maps.event.removeListener(le), v && v(oe), oe.setMap(null);
    };
  }, []), null;
}
me(iLe);
class sLe extends pe {
  constructor() {
    super(...arguments), Le(this, "registeredEvents", []), Le(this, "state", {
      circle: null
    }), Le(this, "setCircleCallback", () => {
      this.state.circle !== null && this.props.onLoad && this.props.onLoad(this.state.circle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Circle(Rb(Rb({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = vn({
      updaterMap: Uz,
      eventMap: zz,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        circle: t
      };
    }, this.setCircleCallback);
  }
  componentDidUpdate(t) {
    this.state.circle !== null && (En(this.registeredEvents), this.registeredEvents = vn({
      updaterMap: Uz,
      eventMap: zz,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.circle
    }));
  }
  componentWillUnmount() {
    if (this.state.circle !== null) {
      var t;
      this.props.onUnmount && this.props.onUnmount(this.state.circle), En(this.registeredEvents), (t = this.state.circle) === null || t === void 0 || t.setMap(null);
    }
  }
  render() {
    return null;
  }
}
Le(sLe, "contextType", Rt);
function Hz(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Ib(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Hz(Object(n), !0).forEach(function(r) {
      Le(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Hz(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Wz = {
  onClick: "click",
  onDblClick: "dblclick",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onAddFeature: "addfeature",
  onRemoveFeature: "removefeature",
  onRemoveProperty: "removeproperty",
  onSetGeometry: "setgeometry",
  onSetProperty: "setproperty"
}, $z = {
  add(e, t) {
    e.add(t);
  },
  addgeojson(e, t, n) {
    e.addGeoJson(t, n);
  },
  contains(e, t) {
    e.contains(t);
  },
  foreach(e, t) {
    e.forEach(t);
  },
  loadgeojson(e, t, n, r) {
    e.loadGeoJson(t, n, r);
  },
  overridestyle(e, t, n) {
    e.overrideStyle(t, n);
  },
  remove(e, t) {
    e.remove(t);
  },
  revertstyle(e, t) {
    e.revertStyle(t);
  },
  controlposition(e, t) {
    e.setControlPosition(t);
  },
  controls(e, t) {
    e.setControls(t);
  },
  drawingmode(e, t) {
    e.setDrawingMode(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  style(e, t) {
    e.setStyle(t);
  },
  togeojson(e, t) {
    e.toGeoJson(t);
  }
};
function aLe(e) {
  var {
    options: t,
    onClick: n,
    onDblClick: r,
    onMouseDown: o,
    onMouseMove: i,
    onMouseOut: a,
    onMouseOver: s,
    onMouseUp: l,
    onRightClick: u,
    onAddFeature: c,
    onRemoveFeature: p,
    onRemoveProperty: d,
    onSetGeometry: g,
    onSetProperty: f,
    onLoad: m,
    onUnmount: b
  } = e, E = ge(Rt), [w, M] = k(null), [x, v] = k(null), [C, P] = k(null), [F, L] = k(null), [B, N] = k(null), [$, V] = k(null), [H, Z] = k(null), [K, Y] = k(null), [Q, J] = k(null), [_, D] = k(null), [z, S] = k(null), [W, O] = k(null), [j, U] = k(null), [T, q] = k(null);
  return h(() => {
    w !== null && w.setMap(E);
  }, [E]), h(() => {
    w && r && (x !== null && google.maps.event.removeListener(x), v(google.maps.event.addListener(w, "dblclick", r)));
  }, [r]), h(() => {
    w && o && (C !== null && google.maps.event.removeListener(C), P(google.maps.event.addListener(w, "mousedown", o)));
  }, [o]), h(() => {
    w && i && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(w, "mousemove", i)));
  }, [i]), h(() => {
    w && a && (B !== null && google.maps.event.removeListener(B), N(google.maps.event.addListener(w, "mouseout", a)));
  }, [a]), h(() => {
    w && s && ($ !== null && google.maps.event.removeListener($), V(google.maps.event.addListener(w, "mouseover", s)));
  }, [s]), h(() => {
    w && l && (H !== null && google.maps.event.removeListener(H), Z(google.maps.event.addListener(w, "mouseup", l)));
  }, [l]), h(() => {
    w && u && (K !== null && google.maps.event.removeListener(K), Y(google.maps.event.addListener(w, "rightclick", u)));
  }, [u]), h(() => {
    w && n && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(w, "click", n)));
  }, [n]), h(() => {
    w && c && (_ !== null && google.maps.event.removeListener(_), D(google.maps.event.addListener(w, "addfeature", c)));
  }, [c]), h(() => {
    w && p && (z !== null && google.maps.event.removeListener(z), S(google.maps.event.addListener(w, "removefeature", p)));
  }, [p]), h(() => {
    w && d && (W !== null && google.maps.event.removeListener(W), O(google.maps.event.addListener(w, "removeproperty", d)));
  }, [d]), h(() => {
    w && g && (j !== null && google.maps.event.removeListener(j), U(google.maps.event.addListener(w, "setgeometry", g)));
  }, [g]), h(() => {
    w && f && (T !== null && google.maps.event.removeListener(T), q(google.maps.event.addListener(w, "setproperty", f)));
  }, [f]), h(() => {
    if (E !== null) {
      var A = new google.maps.Data(Ib(Ib({}, t), {}, {
        map: E
      }));
      r && v(google.maps.event.addListener(A, "dblclick", r)), o && P(google.maps.event.addListener(A, "mousedown", o)), i && L(google.maps.event.addListener(A, "mousemove", i)), a && N(google.maps.event.addListener(A, "mouseout", a)), s && V(google.maps.event.addListener(A, "mouseover", s)), l && Z(google.maps.event.addListener(A, "mouseup", l)), u && Y(google.maps.event.addListener(A, "rightclick", u)), n && J(google.maps.event.addListener(A, "click", n)), c && D(google.maps.event.addListener(A, "addfeature", c)), p && S(google.maps.event.addListener(A, "removefeature", p)), d && O(google.maps.event.addListener(A, "removeproperty", d)), g && U(google.maps.event.addListener(A, "setgeometry", g)), f && q(google.maps.event.addListener(A, "setproperty", f)), M(A), m && m(A);
    }
    return () => {
      w && (x !== null && google.maps.event.removeListener(x), C !== null && google.maps.event.removeListener(C), F !== null && google.maps.event.removeListener(F), B !== null && google.maps.event.removeListener(B), $ !== null && google.maps.event.removeListener($), H !== null && google.maps.event.removeListener(H), K !== null && google.maps.event.removeListener(K), Q !== null && google.maps.event.removeListener(Q), _ !== null && google.maps.event.removeListener(_), z !== null && google.maps.event.removeListener(z), W !== null && google.maps.event.removeListener(W), j !== null && google.maps.event.removeListener(j), T !== null && google.maps.event.removeListener(T), b && b(w), w.setMap(null));
    };
  }, []), null;
}
me(aLe);
class lLe extends pe {
  constructor() {
    super(...arguments), Le(this, "registeredEvents", []), Le(this, "state", {
      data: null
    }), Le(this, "setDataCallback", () => {
      this.state.data !== null && this.props.onLoad && this.props.onLoad(this.state.data);
    });
  }
  componentDidMount() {
    if (this.context !== null) {
      var t = new google.maps.Data(Ib(Ib({}, this.props.options), {}, {
        map: this.context
      }));
      this.registeredEvents = vn({
        updaterMap: $z,
        eventMap: Wz,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        data: t
      }), this.setDataCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.data !== null && (En(this.registeredEvents), this.registeredEvents = vn({
      updaterMap: $z,
      eventMap: Wz,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.data
    }));
  }
  componentWillUnmount() {
    this.state.data !== null && (this.props.onUnmount && this.props.onUnmount(this.state.data), En(this.registeredEvents), this.state.data && this.state.data.setMap(null));
  }
  render() {
    return null;
  }
}
Le(lLe, "contextType", Rt);
function Vz(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Zz(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Vz(Object(n), !0).forEach(function(r) {
      Le(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Vz(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var qz = {
  onClick: "click",
  onDefaultViewportChanged: "defaultviewport_changed",
  onStatusChanged: "status_changed"
}, Gz = {
  options(e, t) {
    e.setOptions(t);
  },
  url(e, t) {
    e.setUrl(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
class uLe extends pe {
  constructor() {
    super(...arguments), Le(this, "registeredEvents", []), Le(this, "state", {
      kmlLayer: null
    }), Le(this, "setKmlLayerCallback", () => {
      this.state.kmlLayer !== null && this.props.onLoad && this.props.onLoad(this.state.kmlLayer);
    });
  }
  componentDidMount() {
    var t = new google.maps.KmlLayer(Zz(Zz({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = vn({
      updaterMap: Gz,
      eventMap: qz,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        kmlLayer: t
      };
    }, this.setKmlLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.kmlLayer !== null && (En(this.registeredEvents), this.registeredEvents = vn({
      updaterMap: Gz,
      eventMap: qz,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.kmlLayer
    }));
  }
  componentWillUnmount() {
    this.state.kmlLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.kmlLayer), En(this.registeredEvents), this.state.kmlLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Le(uLe, "contextType", Rt);
function SQ(e, t) {
  return typeof t == "function" ? t(e.offsetWidth, e.offsetHeight) : {
    x: 0,
    y: 0
  };
}
function cLe(e, t) {
  return new t(e.lat, e.lng);
}
function pLe(e, t) {
  return new t(new google.maps.LatLng(e.ne.lat, e.ne.lng), new google.maps.LatLng(e.sw.lat, e.sw.lng));
}
function dLe(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function fLe(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function hLe(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n.getNorthEast()), o = e && e.fromLatLngToDivPixel(n.getSouthWest());
  return r && o ? {
    left: "".concat(o.x + t.x, "px"),
    top: "".concat(r.y + t.y, "px"),
    width: "".concat(r.x - o.x - t.x, "px"),
    height: "".concat(o.y - r.y - t.y, "px")
  } : {
    left: "-9999px",
    top: "-9999px"
  };
}
function gLe(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n);
  if (r) {
    var {
      x: o,
      y: i
    } = r;
    return {
      left: "".concat(o + t.x, "px"),
      top: "".concat(i + t.y, "px")
    };
  }
  return {
    left: "-9999px",
    top: "-9999px"
  };
}
function MQ(e, t, n, r) {
  return n !== void 0 ? hLe(e, t, fLe(n, google.maps.LatLngBounds, pLe)) : gLe(e, t, dLe(r, google.maps.LatLng, cLe));
}
function mLe(e, t) {
  return e.left === t.left && e.top === t.top && e.width === t.height && e.height === t.height;
}
function Kz(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function vLe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Kz(Object(n), !0).forEach(function(r) {
      Le(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Kz(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function yLe(e, t, n, r, o) {
  class i extends google.maps.OverlayView {
    constructor(s, l, u, c) {
      super(), this.container = s, this.pane = l, this.position = u, this.bounds = c;
    }
    onAdd() {
      var s, l = (s = this.getPanes()) === null || s === void 0 ? void 0 : s[this.pane];
      l == null || l.appendChild(this.container);
    }
    draw() {
      var s = this.getProjection(), l = vLe({}, this.container ? SQ(this.container, o) : {
        x: 0,
        y: 0
      }), u = MQ(s, l, this.bounds, this.position);
      for (var [c, p] of Object.entries(u))
        this.container.style[c] = p;
    }
    onRemove() {
      this.container.parentNode !== null && this.container.parentNode.removeChild(this.container);
    }
  }
  return new i(e, t, n, r);
}
function Xz(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function bLe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Xz(Object(n), !0).forEach(function(r) {
      Le(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Xz(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function Yz(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLng ? e : new google.maps.LatLng(e.lat, e.lng);
  return t + "";
}
function Jz(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLngBounds ? e : new google.maps.LatLngBounds(new google.maps.LatLng(e.south, e.east), new google.maps.LatLng(e.north, e.west));
  return t + "";
}
function wLe(e) {
  var {
    position: t,
    bounds: n,
    mapPaneName: r,
    zIndex: o,
    onLoad: i,
    onUnmount: a,
    getPixelPositionOffset: s,
    children: l
  } = e, u = ge(Rt), c = ln(() => {
    var d = document.createElement("div");
    return d.style.position = "absolute", d;
  }, []), p = ln(() => yLe(c, r, t, n, s), [c, r, t, n]);
  return h(() => (i == null || i(p), p == null || p.setMap(u), () => {
    a == null || a(p), p == null || p.setMap(null);
  }), [u, p]), h(() => {
    c.style.zIndex = "".concat(o);
  }, [o, c]), wi.createPortal(l, c);
}
me(wLe);
class Fp extends pe {
  constructor(t) {
    super(t), Le(this, "state", {
      paneEl: null,
      containerStyle: {
        // set initial position
        position: "absolute"
      }
    }), Le(this, "updatePane", () => {
      var r = this.props.mapPaneName, o = this.overlayView.getPanes();
      Uo(!!r, "OverlayView requires props.mapPaneName but got %s", r), o ? this.setState({
        paneEl: o[r]
      }) : this.setState({
        paneEl: null
      });
    }), Le(this, "onAdd", () => {
      var r, o;
      this.updatePane(), (r = (o = this.props).onLoad) === null || r === void 0 || r.call(o, this.overlayView);
    }), Le(this, "onPositionElement", () => {
      var r = this.overlayView.getProjection(), o = bLe({
        x: 0,
        y: 0
      }, this.containerRef.current ? SQ(this.containerRef.current, this.props.getPixelPositionOffset) : {}), i = MQ(r, o, this.props.bounds, this.props.position);
      if (!mLe(i, {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        left: this.state.containerStyle.left,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        top: this.state.containerStyle.top,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        width: this.state.containerStyle.width,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        height: this.state.containerStyle.height
      })) {
        var a, s, l, u;
        this.setState({
          containerStyle: {
            top: (a = i.top) !== null && a !== void 0 ? a : 0,
            left: (s = i.left) !== null && s !== void 0 ? s : 0,
            width: (l = i.width) !== null && l !== void 0 ? l : 0,
            height: (u = i.height) !== null && u !== void 0 ? u : 0,
            position: "absolute"
          }
        });
      }
    }), Le(this, "draw", () => {
      this.onPositionElement();
    }), Le(this, "onRemove", () => {
      var r, o;
      this.setState(() => ({
        paneEl: null
      })), (r = (o = this.props).onUnmount) === null || r === void 0 || r.call(o, this.overlayView);
    }), this.containerRef = so();
    var n = new google.maps.OverlayView();
    n.onAdd = this.onAdd, n.draw = this.draw, n.onRemove = this.onRemove, this.overlayView = n;
  }
  componentDidMount() {
    this.overlayView.setMap(this.context);
  }
  componentDidUpdate(t) {
    var n = Yz(t.position), r = Yz(this.props.position), o = Jz(t.bounds), i = Jz(this.props.bounds);
    (n !== r || o !== i) && this.overlayView.draw(), t.mapPaneName !== this.props.mapPaneName && this.updatePane();
  }
  componentWillUnmount() {
    this.overlayView.setMap(null);
  }
  render() {
    var t = this.state.paneEl;
    return t ? wi.createPortal(ni.jsx("div", {
      ref: this.containerRef,
      style: this.state.containerStyle,
      children: at.only(this.props.children)
    }), t) : null;
  }
}
Le(Fp, "FLOAT_PANE", "floatPane");
Le(Fp, "MAP_PANE", "mapPane");
Le(Fp, "MARKER_LAYER", "markerLayer");
Le(Fp, "OVERLAY_LAYER", "overlayLayer");
Le(Fp, "OVERLAY_MOUSE_TARGET", "overlayMouseTarget");
Le(Fp, "contextType", Rt);
function CLe() {
}
function Qz(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function e2(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Qz(Object(n), !0).forEach(function(r) {
      Le(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Qz(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var t2 = {
  onDblClick: "dblclick",
  onClick: "click"
}, n2 = {
  opacity(e, t) {
    e.setOpacity(t);
  }
};
function OLe(e) {
  var {
    url: t,
    bounds: n,
    options: r,
    visible: o
  } = e, i = ge(Rt), a = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east)), s = ln(() => new google.maps.GroundOverlay(t, a, r), []);
  return h(() => {
    s !== null && s.setMap(i);
  }, [i]), h(() => {
    typeof t < "u" && s !== null && (s.set("url", t), s.setMap(i));
  }, [s, t]), h(() => {
    typeof o < "u" && s !== null && s.setOpacity(o ? 1 : 0);
  }, [s, o]), h(() => {
    var l = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east));
    typeof n < "u" && s !== null && (s.set("bounds", l), s.setMap(i));
  }, [s, n]), null;
}
me(OLe);
class DQ extends pe {
  constructor() {
    super(...arguments), Le(this, "registeredEvents", []), Le(this, "state", {
      groundOverlay: null
    }), Le(this, "setGroundOverlayCallback", () => {
      this.state.groundOverlay !== null && this.props.onLoad && this.props.onLoad(this.state.groundOverlay);
    });
  }
  componentDidMount() {
    Uo(!!this.props.url || !!this.props.bounds, "For GroundOverlay, url and bounds are passed in to constructor and are immutable after instantiated. This is the behavior of Google Maps JavaScript API v3 ( See https://developers.google.com/maps/documentation/javascript/reference#GroundOverlay) Hence, use the corresponding two props provided by `react-google-maps-api`, url and bounds. In some cases, you'll need the GroundOverlay component to reflect the changes of url and bounds. You can leverage the React's key property to remount the component. Typically, just `key={url}` would serve your need. See https://github.com/tomchentw/react-google-maps/issues/655");
    var t = new google.maps.GroundOverlay(this.props.url, this.props.bounds, e2(e2({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = vn({
      updaterMap: n2,
      eventMap: t2,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        groundOverlay: t
      };
    }, this.setGroundOverlayCallback);
  }
  componentDidUpdate(t) {
    this.state.groundOverlay !== null && (En(this.registeredEvents), this.registeredEvents = vn({
      updaterMap: n2,
      eventMap: t2,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.groundOverlay
    }));
  }
  componentWillUnmount() {
    this.state.groundOverlay && (this.props.onUnmount && this.props.onUnmount(this.state.groundOverlay), this.state.groundOverlay.setMap(null));
  }
  render() {
    return null;
  }
}
Le(DQ, "defaultProps", {
  onLoad: CLe
});
Le(DQ, "contextType", Rt);
function r2(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Nb(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? r2(Object(n), !0).forEach(function(r) {
      Le(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : r2(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var o2 = {}, i2 = {
  data(e, t) {
    e.setData(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function xLe(e) {
  var {
    data: t,
    onLoad: n,
    onUnmount: r,
    options: o
  } = e, i = ge(Rt), [a, s] = k(null);
  return h(() => {
    google.maps.visualization || Uo(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} in useJsApiScript? %s', google.maps.visualization);
  }, []), h(() => {
    Uo(!!t, "data property is required in HeatmapLayer %s", t);
  }, [t]), h(() => {
    a !== null && a.setMap(i);
  }, [i]), h(() => {
    o && a !== null && a.setOptions(o);
  }, [a, o]), h(() => {
    var l = new google.maps.visualization.HeatmapLayer(Nb(Nb({}, o), {}, {
      data: t,
      map: i
    }));
    return s(l), n && n(l), () => {
      a !== null && (r && r(a), a.setMap(null));
    };
  }, []), null;
}
me(xLe);
class ELe extends pe {
  constructor() {
    super(...arguments), Le(this, "registeredEvents", []), Le(this, "state", {
      heatmapLayer: null
    }), Le(this, "setHeatmapLayerCallback", () => {
      this.state.heatmapLayer !== null && this.props.onLoad && this.props.onLoad(this.state.heatmapLayer);
    });
  }
  componentDidMount() {
    Uo(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} to <LoadScript />? %s', google.maps.visualization), Uo(!!this.props.data, "data property is required in HeatmapLayer %s", this.props.data);
    var t = new google.maps.visualization.HeatmapLayer(Nb(Nb({}, this.props.options), {}, {
      data: this.props.data,
      map: this.context
    }));
    this.registeredEvents = vn({
      updaterMap: i2,
      eventMap: o2,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        heatmapLayer: t
      };
    }, this.setHeatmapLayerCallback);
  }
  componentDidUpdate(t) {
    En(this.registeredEvents), this.registeredEvents = vn({
      updaterMap: i2,
      eventMap: o2,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.heatmapLayer
    });
  }
  componentWillUnmount() {
    this.state.heatmapLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.heatmapLayer), En(this.registeredEvents), this.state.heatmapLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Le(ELe, "contextType", Rt);
var s2 = {
  onCloseClick: "closeclick",
  onPanoChanged: "pano_changed",
  onPositionChanged: "position_changed",
  onPovChanged: "pov_changed",
  onResize: "resize",
  onStatusChanged: "status_changed",
  onVisibleChanged: "visible_changed",
  onZoomChanged: "zoom_changed"
}, a2 = {
  register(e, t, n) {
    e.registerPanoProvider(t, n);
  },
  links(e, t) {
    e.setLinks(t);
  },
  motionTracking(e, t) {
    e.setMotionTracking(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  pano(e, t) {
    e.setPano(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  pov(e, t) {
    e.setPov(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zoom(e, t) {
    e.setZoom(t);
  }
};
class kLe extends pe {
  constructor() {
    super(...arguments), Le(this, "registeredEvents", []), Le(this, "state", {
      streetViewPanorama: null
    }), Le(this, "setStreetViewPanoramaCallback", () => {
      this.state.streetViewPanorama !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewPanorama);
    });
  }
  componentDidMount() {
    var t, n, r = (t = (n = this.context) === null || n === void 0 ? void 0 : n.getStreetView()) !== null && t !== void 0 ? t : null;
    this.registeredEvents = vn({
      updaterMap: a2,
      eventMap: s2,
      prevProps: {},
      nextProps: this.props,
      instance: r
    }), this.setState(() => ({
      streetViewPanorama: r
    }), this.setStreetViewPanoramaCallback);
  }
  componentDidUpdate(t) {
    this.state.streetViewPanorama !== null && (En(this.registeredEvents), this.registeredEvents = vn({
      updaterMap: a2,
      eventMap: s2,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.streetViewPanorama
    }));
  }
  componentWillUnmount() {
    this.state.streetViewPanorama !== null && (this.props.onUnmount && this.props.onUnmount(this.state.streetViewPanorama), En(this.registeredEvents), this.state.streetViewPanorama.setVisible(!1));
  }
  render() {
    return null;
  }
}
Le(kLe, "contextType", Rt);
class LLe extends pe {
  constructor() {
    super(...arguments), Le(this, "state", {
      streetViewService: null
    }), Le(this, "setStreetViewServiceCallback", () => {
      this.state.streetViewService !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewService);
    });
  }
  componentDidMount() {
    var t = new google.maps.StreetViewService();
    this.setState(function() {
      return {
        streetViewService: t
      };
    }, this.setStreetViewServiceCallback);
  }
  componentWillUnmount() {
    this.state.streetViewService !== null && this.props.onUnmount && this.props.onUnmount(this.state.streetViewService);
  }
  render() {
    return null;
  }
}
Le(LLe, "contextType", Rt);
var l2 = {
  onDirectionsChanged: "directions_changed"
}, u2 = {
  directions(e, t) {
    e.setDirections(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  panel(e, t) {
    e.setPanel(t);
  },
  routeIndex(e, t) {
    e.setRouteIndex(t);
  }
};
class _Le extends pe {
  constructor() {
    super(...arguments), Le(this, "registeredEvents", []), Le(this, "state", {
      directionsRenderer: null
    }), Le(this, "setDirectionsRendererCallback", () => {
      this.state.directionsRenderer !== null && (this.state.directionsRenderer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.directionsRenderer));
    });
  }
  componentDidMount() {
    var t = new google.maps.DirectionsRenderer(this.props.options);
    this.registeredEvents = vn({
      updaterMap: u2,
      eventMap: l2,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        directionsRenderer: t
      };
    }, this.setDirectionsRendererCallback);
  }
  componentDidUpdate(t) {
    this.state.directionsRenderer !== null && (En(this.registeredEvents), this.registeredEvents = vn({
      updaterMap: u2,
      eventMap: l2,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.directionsRenderer
    }));
  }
  componentWillUnmount() {
    this.state.directionsRenderer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.directionsRenderer), En(this.registeredEvents), this.state.directionsRenderer && this.state.directionsRenderer.setMap(null));
  }
  render() {
    return null;
  }
}
Le(_Le, "contextType", Rt);
var c2 = {
  onPlacesChanged: "places_changed"
}, p2 = {
  bounds(e, t) {
    e.setBounds(t);
  }
};
class PLe extends pe {
  constructor() {
    super(...arguments), Le(this, "registeredEvents", []), Le(this, "containerElement", so()), Le(this, "state", {
      searchBox: null
    }), Le(this, "setSearchBoxCallback", () => {
      this.state.searchBox !== null && this.props.onLoad && this.props.onLoad(this.state.searchBox);
    });
  }
  componentDidMount() {
    if (Uo(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places), this.containerElement !== null && this.containerElement.current !== null) {
      var t = this.containerElement.current.querySelector("input");
      if (t !== null) {
        var n = new google.maps.places.SearchBox(t, this.props.options);
        this.registeredEvents = vn({
          updaterMap: p2,
          eventMap: c2,
          prevProps: {},
          nextProps: this.props,
          instance: n
        }), this.setState(function() {
          return {
            searchBox: n
          };
        }, this.setSearchBoxCallback);
      }
    }
  }
  componentDidUpdate(t) {
    this.state.searchBox !== null && (En(this.registeredEvents), this.registeredEvents = vn({
      updaterMap: p2,
      eventMap: c2,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.searchBox
    }));
  }
  componentWillUnmount() {
    this.state.searchBox !== null && (this.props.onUnmount && this.props.onUnmount(this.state.searchBox), En(this.registeredEvents));
  }
  render() {
    return ni.jsx("div", {
      ref: this.containerElement,
      children: at.only(this.props.children)
    });
  }
}
Le(PLe, "contextType", Rt);
var d2 = {
  onPlaceChanged: "place_changed"
}, f2 = {
  bounds(e, t) {
    e.setBounds(t);
  },
  restrictions(e, t) {
    e.setComponentRestrictions(t);
  },
  fields(e, t) {
    e.setFields(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  types(e, t) {
    e.setTypes(t);
  }
};
class TQ extends pe {
  constructor() {
    super(...arguments), Le(this, "registeredEvents", []), Le(this, "containerElement", so()), Le(this, "state", {
      autocomplete: null
    }), Le(this, "setAutocompleteCallback", () => {
      this.state.autocomplete !== null && this.props.onLoad && this.props.onLoad(this.state.autocomplete);
    });
  }
  componentDidMount() {
    var t;
    Uo(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places);
    var n = (t = this.containerElement.current) === null || t === void 0 ? void 0 : t.querySelector("input");
    if (n) {
      var r = new google.maps.places.Autocomplete(n, this.props.options);
      this.registeredEvents = vn({
        updaterMap: f2,
        eventMap: d2,
        prevProps: {},
        nextProps: this.props,
        instance: r
      }), this.setState(() => ({
        autocomplete: r
      }), this.setAutocompleteCallback);
    }
  }
  componentDidUpdate(t) {
    En(this.registeredEvents), this.registeredEvents = vn({
      updaterMap: f2,
      eventMap: d2,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.autocomplete
    });
  }
  componentWillUnmount() {
    this.state.autocomplete !== null && En(this.registeredEvents);
  }
  render() {
    return ni.jsx("div", {
      ref: this.containerElement,
      className: this.props.className,
      children: at.only(this.props.children)
    });
  }
}
Le(TQ, "defaultProps", {
  className: ""
});
Le(TQ, "contextType", Rt);
let SLe = { data: "" }, MLe = (e) => typeof window == "object" ? ((e ? e.querySelector("#_goober") : window._goober) || Object.assign((e || document.head).appendChild(document.createElement("style")), { innerHTML: " ", id: "_goober" })).firstChild : e || SLe, DLe = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g, TLe = /\/\*[^]*?\*\/|  +/g, h2 = /\n+/g, Kl = (e, t) => {
  let n = "", r = "", o = "";
  for (let i in e) {
    let a = e[i];
    i[0] == "@" ? i[1] == "i" ? n = i + " " + a + ";" : r += i[1] == "f" ? Kl(a, i) : i + "{" + Kl(a, i[1] == "k" ? "" : t) + "}" : typeof a == "object" ? r += Kl(a, t ? t.replace(/([^,])+/g, (s) => i.replace(/([^,]*:\S+\([^)]*\))|([^,])+/g, (l) => /&/.test(l) ? l.replace(/&/g, s) : s ? s + " " + l : l)) : i) : a != null && (i = /^--/.test(i) ? i : i.replace(/[A-Z]/g, "-$&").toLowerCase(), o += Kl.p ? Kl.p(i, a) : i + ":" + a + ";");
  }
  return n + (t && o ? t + "{" + o + "}" : o) + r;
}, ja = {}, jQ = (e) => {
  if (typeof e == "object") {
    let t = "";
    for (let n in e) t += n + jQ(e[n]);
    return t;
  }
  return e;
}, jLe = (e, t, n, r, o) => {
  let i = jQ(e), a = ja[i] || (ja[i] = ((l) => {
    let u = 0, c = 11;
    for (; u < l.length; ) c = 101 * c + l.charCodeAt(u++) >>> 0;
    return "go" + c;
  })(i));
  if (!ja[a]) {
    let l = i !== e ? e : ((u) => {
      let c, p, d = [{}];
      for (; c = DLe.exec(u.replace(TLe, "")); ) c[4] ? d.shift() : c[3] ? (p = c[3].replace(h2, " ").trim(), d.unshift(d[0][p] = d[0][p] || {})) : d[0][c[1]] = c[2].replace(h2, " ").trim();
      return d[0];
    })(e);
    ja[a] = Kl(o ? { ["@keyframes " + a]: l } : l, n ? "" : "." + a);
  }
  let s = n && ja.g ? ja.g : null;
  return n && (ja.g = ja[a]), ((l, u, c, p) => {
    p ? u.data = u.data.replace(p, l) : u.data.indexOf(l) === -1 && (u.data = c ? l + u.data : u.data + l);
  })(ja[a], t, r, s), a;
}, ALe = (e, t, n) => e.reduce((r, o, i) => {
  let a = t[i];
  if (a && a.call) {
    let s = a(n), l = s && s.props && s.props.className || /^go/.test(s) && s;
    a = l ? "." + l : s && typeof s == "object" ? s.props ? "" : Kl(s, "") : s === !1 ? "" : s;
  }
  return r + o + (a ?? "");
}, "");
function JC(e) {
  let t = this || {}, n = e.call ? e(t.p) : e;
  return jLe(n.unshift ? n.raw ? ALe(n, [].slice.call(arguments, 1), t.p) : n.reduce((r, o) => Object.assign(r, o && o.call ? o(t.p) : o), {}) : n, MLe(t.target), t.g, t.o, t.k);
}
let AQ, j_, A_;
JC.bind({ g: 1 });
let Xa = JC.bind({ k: 1 });
function RLe(e, t, n, r) {
  Kl.p = t, AQ = e, j_ = n, A_ = r;
}
function Eu(e, t) {
  let n = this || {};
  return function() {
    let r = arguments;
    function o(i, a) {
      let s = Object.assign({}, i), l = s.className || o.className;
      n.p = Object.assign({ theme: j_ && j_() }, s), n.o = / *go\d+/.test(l), s.className = JC.apply(n, r) + (l ? " " + l : "");
      let u = e;
      return e[0] && (u = s.as || e, delete s.as), A_ && u[0] && A_(s), AQ(u, s);
    }
    return o;
  };
}
var ILe = (e) => typeof e == "function", NLe = (e, t) => ILe(e) ? e(t) : e, BLe = /* @__PURE__ */ (() => {
  let e;
  return () => {
    if (e === void 0 && typeof window < "u") {
      let t = matchMedia("(prefers-reduced-motion: reduce)");
      e = !t || t.matches;
    }
    return e;
  };
})(), FLe = Xa`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`, zLe = Xa`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`, ULe = Xa`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`, HLe = Eu("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${FLe} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${zLe} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${(e) => e.secondary || "#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${ULe} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`, WLe = Xa`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, $Le = Eu("div")`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${(e) => e.secondary || "#e0e0e0"};
  border-right-color: ${(e) => e.primary || "#616161"};
  animation: ${WLe} 1s linear infinite;
`, VLe = Xa`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`, ZLe = Xa`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`, qLe = Eu("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${VLe} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${ZLe} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${(e) => e.secondary || "#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`, GLe = Eu("div")`
  position: absolute;
`, KLe = Eu("div")`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`, XLe = Xa`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`, YLe = Eu("div")`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${XLe} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`, JLe = ({ toast: e }) => {
  let { icon: t, type: n, iconTheme: r } = e;
  return t !== void 0 ? typeof t == "string" ? Ne.createElement(YLe, null, t) : t : n === "blank" ? null : Ne.createElement(KLe, null, Ne.createElement($Le, { ...r }), n !== "loading" && Ne.createElement(GLe, null, n === "error" ? Ne.createElement(HLe, { ...r }) : Ne.createElement(qLe, { ...r })));
}, QLe = (e) => `
0% {transform: translate3d(0,${e * -200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`, e1e = (e) => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${e * -150}%,-1px) scale(.6); opacity:0;}
`, t1e = "0%{opacity:0;} 100%{opacity:1;}", n1e = "0%{opacity:1;} 100%{opacity:0;}", r1e = Eu("div")`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`, o1e = Eu("div")`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`, i1e = (e, t) => {
  let n = e.includes("top") ? 1 : -1, [r, o] = BLe() ? [t1e, n1e] : [QLe(n), e1e(n)];
  return { animation: t ? `${Xa(r)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards` : `${Xa(o)} 0.4s forwards cubic-bezier(.06,.71,.55,1)` };
};
Ne.memo(({ toast: e, position: t, style: n, children: r }) => {
  let o = e.height ? i1e(e.position || t || "top-center", e.visible) : { opacity: 0 }, i = Ne.createElement(JLe, { toast: e }), a = Ne.createElement(o1e, { ...e.ariaProps }, NLe(e.message, e));
  return Ne.createElement(r1e, { className: e.className, style: { ...o, ...n, ...e.style } }, typeof r == "function" ? r({ icon: i, message: a }) : Ne.createElement(Ne.Fragment, null, i, a));
});
RLe(Ne.createElement);
JC`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`;
$e({});
function s1e(e) {
  return e && e.replace(/[^0-9]/g, "");
}
const a1e = {
  CNPJ: "99.999.999/9999-99"
};
s1e(a1e.CNPJ).length;
Cr((e, t) => /* @__PURE__ */ ti.jsx("input", { ref: t, ...e }));
function RQ(e) {
  return e && e.replace(/[^0-9]/g, "");
}
const IQ = {
  EIGTH: "(99) 9999-9999",
  NINE: "(99) 99999-9999"
};
function l1e(e, t) {
  let n = "", r = 0;
  for (let o = 0; o < t.length; o++)
    if (t[o] === "9")
      if (r < e.length)
        n += e[r], r++;
      else
        break;
    else if (r < e.length)
      n += t[o];
    else
      break;
  return n;
}
function u1e(e) {
  return e.length > 10 ? "NINE" : "EIGTH";
}
const c1e = RQ(IQ.NINE).length, p1e = Cr((e, t) => /* @__PURE__ */ ti.jsx("input", { ref: t, ...e }));
Cr(
  (e, t) => {
    const { onFocus: n, onBlur: r, size: o, onChange: i, value: a, currentCountry: s, disabled: l } = e, [u, c] = k(!1);
    h(() => {
      u ? i(s.mask) : c(!0);
    }, [s]);
    const p = `phoneInputMask ${o}`;
    function d(g) {
      let f = RQ(g.target.value);
      const m = u1e(f);
      f.length > c1e || (f = l1e(f, IQ[m]), g.target.value = f, i(f));
    }
    return s.code === "+55" ? /* @__PURE__ */ ti.jsx(
      "input",
      {
        value: a,
        onChange: d,
        className: p,
        onFocus: n,
        onBlur: r,
        disabled: l,
        ref: t
      }
    ) : /* @__PURE__ */ ti.jsx(
      ol,
      {
        value: a,
        onChange: (g) => i(g.target.value),
        className: p,
        component: p1e,
        onFocus: n,
        onBlur: r,
        disabled: l,
        mask: s.mask,
        showMask: !0,
        replacement: { _: /\d/ },
        ref: t
      }
    );
  }
);
$e({});
var al = {};
Object.defineProperty(al, "__esModule", {
  value: !0
});
var d1e = typeof window < "u" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform), cE = {
  alt: "altKey",
  control: "ctrlKey",
  meta: "metaKey",
  shift: "shiftKey"
}, NQ = {
  add: "+",
  break: "pause",
  cmd: "meta",
  command: "meta",
  ctl: "control",
  ctrl: "control",
  del: "delete",
  down: "arrowdown",
  esc: "escape",
  ins: "insert",
  left: "arrowleft",
  mod: d1e ? "meta" : "control",
  opt: "alt",
  option: "alt",
  return: "enter",
  right: "arrowright",
  space: " ",
  spacebar: " ",
  up: "arrowup",
  win: "meta",
  windows: "meta"
}, SD = {
  backspace: 8,
  tab: 9,
  enter: 13,
  shift: 16,
  control: 17,
  alt: 18,
  pause: 19,
  capslock: 20,
  escape: 27,
  " ": 32,
  pageup: 33,
  pagedown: 34,
  end: 35,
  home: 36,
  arrowleft: 37,
  arrowup: 38,
  arrowright: 39,
  arrowdown: 40,
  insert: 45,
  delete: 46,
  meta: 91,
  numlock: 144,
  scrolllock: 145,
  ";": 186,
  "=": 187,
  ",": 188,
  "-": 189,
  ".": 190,
  "/": 191,
  "`": 192,
  "[": 219,
  "\\": 220,
  "]": 221,
  "'": 222
};
for (var ev = 1; ev < 20; ev++)
  SD["f" + ev] = 111 + ev;
function QC(e, t, n) {
  t && !("byKey" in t) && (n = t, t = null), Array.isArray(e) || (e = [e]);
  var r = e.map(function(a) {
    return BQ(a, t);
  }), o = function(a) {
    return r.some(function(s) {
      return FQ(s, a);
    });
  }, i = n == null ? o : o(n);
  return i;
}
function f1e(e, t) {
  return QC(e, t);
}
function h1e(e, t) {
  return QC(e, { byKey: !0 }, t);
}
function BQ(e, t) {
  var n = t && t.byKey, r = {};
  e = e.replace("++", "+add");
  var o = e.split("+"), i = o.length;
  for (var a in cE)
    r[cE[a]] = !1;
  var s = !0, l = !1, u = void 0;
  try {
    for (var c = o[Symbol.iterator](), p; !(s = (p = c.next()).done); s = !0) {
      var d = p.value, g = d.endsWith("?") && d.length > 1;
      g && (d = d.slice(0, -1));
      var f = MD(d), m = cE[f];
      if (d.length > 1 && !m && !NQ[d] && !SD[f])
        throw new TypeError('Unknown modifier: "' + d + '"');
      (i === 1 || !m) && (n ? r.key = f : r.which = zQ(d)), m && (r[m] = g ? null : !0);
    }
  } catch (b) {
    l = !0, u = b;
  } finally {
    try {
      !s && c.return && c.return();
    } finally {
      if (l)
        throw u;
    }
  }
  return r;
}
function FQ(e, t) {
  for (var n in e) {
    var r = e[n], o = void 0;
    if (r != null && (n === "key" && t.key != null ? o = t.key.toLowerCase() : n === "which" ? o = r === 91 && t.which === 93 ? 91 : t.which : o = t[n], !(o == null && r === !1) && o !== r))
      return !1;
  }
  return !0;
}
function zQ(e) {
  e = MD(e);
  var t = SD[e] || e.toUpperCase().charCodeAt(0);
  return t;
}
function MD(e) {
  return e = e.toLowerCase(), e = NQ[e] || e, e;
}
al.default = QC;
var pE = al.isHotkey = QC;
al.isCodeHotkey = f1e;
al.isKeyHotkey = h1e;
al.parseHotkey = BQ;
al.compareHotkey = FQ;
al.toKeyCode = zQ;
al.toKeyName = MD;
var g1e = typeof br == "object" && br && br.Object === Object && br, m1e = g1e, v1e = m1e, y1e = typeof self == "object" && self && self.Object === Object && self, b1e = v1e || y1e || Function("return this")(), w1e = b1e, C1e = w1e, O1e = C1e.Symbol, UQ = O1e, g2 = UQ;
g2 && g2.toStringTag;
var m2 = UQ;
m2 && m2.toStringTag;
var v2;
(function(e) {
  e.BORDER_BOX = "border-box", e.CONTENT_BOX = "content-box", e.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(v2 || (v2 = {}));
var DD = function(e) {
  return Object.freeze(e);
}, x1e = /* @__PURE__ */ function() {
  function e(t, n) {
    this.inlineSize = t, this.blockSize = n, DD(this);
  }
  return e;
}(), E1e = function() {
  function e(t, n, r, o) {
    return this.x = t, this.y = n, this.width = r, this.height = o, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, DD(this);
  }
  return e.prototype.toJSON = function() {
    var t = this, n = t.x, r = t.y, o = t.top, i = t.right, a = t.bottom, s = t.left, l = t.width, u = t.height;
    return { x: n, y: r, top: o, right: i, bottom: a, left: s, width: l, height: u };
  }, e.fromRect = function(t) {
    return new e(t.x, t.y, t.width, t.height);
  }, e;
}(), y2 = typeof window < "u" ? window : {};
/msie|trident/i.test(y2.navigator && y2.navigator.userAgent);
var dE = function(e, t, n) {
  return e === void 0 && (e = 0), t === void 0 && (t = 0), n === void 0 && (n = !1), new x1e((n ? t : e) || 0, (n ? e : t) || 0);
};
DD({
  devicePixelContentBoxSize: dE(),
  borderBoxSize: dE(),
  contentBoxSize: dE(),
  contentRect: new E1e(0, 0, 0, 0)
});
function Sh(e) {
  "@babel/helpers - typeof";
  return Sh = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Sh(e);
}
function k1e(e, t) {
  if (Sh(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (Sh(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function L1e(e) {
  var t = k1e(e, "string");
  return Sh(t) === "symbol" ? t : String(t);
}
function Ef(e, t, n) {
  return t = L1e(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
var _1e = /* @__PURE__ */ $e(null), fE, hE;
parseInt(be.version.split(".")[0], 10);
var b2 = typeof navigator < "u" && /Mac OS X/.test(navigator.userAgent), gE = typeof navigator < "u" && /Android/.test(navigator.userAgent), tv = typeof navigator < "u" && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent), P1e = typeof navigator < "u" && /Chrome/i.test(navigator.userAgent);
typeof navigator < "u" && /Safari/.test(navigator.userAgent) && /Version\/(\d+)/.test(navigator.userAgent) && (fE = navigator.userAgent.match(/Version\/(\d+)/)) !== null && fE !== void 0 && fE[1] && parseInt((hE = navigator.userAgent.match(/Version\/(\d+)/)) === null || hE === void 0 ? void 0 : hE[1], 10) < 17;
var S1e = /* @__PURE__ */ new WeakMap(), M1e = /* @__PURE__ */ new WeakMap(), D1e = /* @__PURE__ */ new WeakMap(), T1e = /* @__PURE__ */ new WeakMap(), j1e = /* @__PURE__ */ new WeakMap(), w2 = /* @__PURE__ */ new WeakMap(), A1e = /* @__PURE__ */ new WeakMap(), C2 = /* @__PURE__ */ new WeakMap(), nv = /* @__PURE__ */ new WeakMap(), R1e = /* @__PURE__ */ new WeakMap(), I1e = /* @__PURE__ */ new WeakMap(), N1e = /* @__PURE__ */ new WeakMap(), HQ = globalThis.Node, B1e = globalThis.Text, WQ = (e) => e && e.ownerDocument && e.ownerDocument.defaultView || null, F1e = (e) => Bb(e) && e.nodeType === 8, ca = (e) => Bb(e) && e.nodeType === 1, Bb = (e) => {
  var t = WQ(e);
  return !!t && e instanceof t.Node;
}, O2 = (e) => {
  var t = e && e.anchorNode && WQ(e.anchorNode);
  return !!t && e instanceof t.Selection;
}, z1e = (e) => {
  var [t, n] = e;
  if (ca(t) && t.childNodes.length) {
    var r = n === t.childNodes.length, o = r ? n - 1 : n;
    for ([t, o] = $Q(t, o, r ? "backward" : "forward"), r = o < n; ca(t) && t.childNodes.length; ) {
      var i = r ? t.childNodes.length - 1 : 0;
      t = H1e(t, i, r ? "backward" : "forward");
    }
    n = r && t.textContent != null ? t.textContent.length : 0;
  }
  return [t, n];
}, U1e = (e) => {
  for (var t = e && e.parentNode; t; ) {
    if (t.toString() === "[object ShadowRoot]")
      return !0;
    t = t.parentNode;
  }
  return !1;
}, $Q = (e, t, n) => {
  for (var {
    childNodes: r
  } = e, o = r[t], i = t, a = !1, s = !1; (F1e(o) || ca(o) && o.childNodes.length === 0 || ca(o) && o.getAttribute("contenteditable") === "false") && !(a && s); ) {
    if (i >= r.length) {
      a = !0, i = t - 1, n = "backward";
      continue;
    }
    if (i < 0) {
      s = !0, i = t + 1, n = "forward";
      continue;
    }
    o = r[i], t = i, i += n === "forward" ? 1 : -1;
  }
  return [o, t];
}, H1e = (e, t, n) => {
  var [r] = $Q(e, t, n);
  return r;
}, x2 = (e) => e.getSelection != null ? e.getSelection() : document.getSelection(), VQ = (e, t, n) => {
  var {
    target: r
  } = t;
  if (ca(r) && r.matches('[contentEditable="false"]'))
    return !1;
  var {
    document: o
  } = pn.getWindow(e);
  if (o.contains(r))
    return pn.hasDOMNode(e, r, {
      editable: !0
    });
  var i = n.find((a) => {
    var {
      addedNodes: s,
      removedNodes: l
    } = a;
    for (var u of s)
      if (u === r || u.contains(r))
        return !0;
    for (var c of l)
      if (c === r || c.contains(r))
        return !0;
  });
  return !i || i === t ? !1 : VQ(e, i, n);
}, E2 = (e, t) => !!(e.compareDocumentPosition(t) & HQ.DOCUMENT_POSITION_PRECEDING), W1e = (e, t) => !!(e.compareDocumentPosition(t) & HQ.DOCUMENT_POSITION_FOLLOWING), $1e = 0;
class V1e {
  constructor() {
    Ef(this, "id", void 0), this.id = "".concat($1e++);
  }
}
var pn = {
  androidPendingDiffs: (e) => N1e.get(e),
  androidScheduleFlush: (e) => {
    var t;
    (t = I1e.get(e)) === null || t === void 0 || t();
  },
  blur: (e) => {
    var t = pn.toDOMNode(e, e), n = pn.findDocumentOrShadowRoot(e);
    nv.set(e, !1), n.activeElement === t && t.blur();
  },
  deselect: (e) => {
    var {
      selection: t
    } = e, n = pn.findDocumentOrShadowRoot(e), r = x2(n);
    r && r.rangeCount > 0 && r.removeAllRanges(), t && wb.deselect(e);
  },
  findDocumentOrShadowRoot: (e) => {
    var t = pn.toDOMNode(e, e), n = t.getRootNode();
    return n instanceof Document || n instanceof ShadowRoot ? n : t.ownerDocument;
  },
  findEventRange: (e, t) => {
    "nativeEvent" in t && (t = t.nativeEvent);
    var {
      clientX: n,
      clientY: r,
      target: o
    } = t;
    if (n == null || r == null)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var i = pn.toSlateNode(e, t.target), a = pn.findPath(e, i);
    if (Za.isElement(i) && pr.isVoid(e, i)) {
      var s = o.getBoundingClientRect(), l = e.isInline(i) ? n - s.left < s.left + s.width - n : r - s.top < s.top + s.height - r, u = pr.point(e, a, {
        edge: l ? "start" : "end"
      }), c = l ? pr.before(e, u) : pr.after(e, u);
      if (c) {
        var p = pr.range(e, c);
        return p;
      }
    }
    var d, {
      document: g
    } = pn.getWindow(e);
    if (g.caretRangeFromPoint)
      d = g.caretRangeFromPoint(n, r);
    else {
      var f = g.caretPositionFromPoint(n, r);
      f && (d = g.createRange(), d.setStart(f.offsetNode, f.offset), d.setEnd(f.offsetNode, f.offset));
    }
    if (!d)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var m = pn.toSlateRange(e, d, {
      exactMatch: !1,
      suppressThrow: !1
    });
    return m;
  },
  findKey: (e, t) => {
    var n = w2.get(t);
    return n || (n = new V1e(), w2.set(t, n)), n;
  },
  findPath: (e, t) => {
    for (var n = [], r = t; ; ) {
      var o = M1e.get(r);
      if (o == null) {
        if (pr.isEditor(r))
          return n;
        break;
      }
      var i = S1e.get(r);
      if (i == null)
        break;
      n.unshift(i), r = o;
    }
    throw new Error("Unable to find the path for Slate node: ".concat(ls.stringify(t)));
  },
  focus: function(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      retries: 5
    };
    if (!nv.get(e)) {
      if (t.retries <= 0)
        throw new Error("Could not set focus, editor seems stuck with pending operations");
      if (e.operations.length > 0) {
        setTimeout(() => {
          pn.focus(e, {
            retries: t.retries - 1
          });
        }, 10);
        return;
      }
      var n = pn.toDOMNode(e, e), r = pn.findDocumentOrShadowRoot(e);
      if (r.activeElement !== n) {
        if (e.selection && r instanceof Document) {
          var o = x2(r), i = pn.toDOMRange(e, e.selection);
          o == null || o.removeAllRanges(), o == null || o.addRange(i);
        }
        e.selection || wb.select(e, pr.start(e, [])), nv.set(e, !0), n.focus({
          preventScroll: !0
        });
      }
    }
  },
  getWindow: (e) => {
    var t = D1e.get(e);
    if (!t)
      throw new Error("Unable to find a host window element for this editor");
    return t;
  },
  hasDOMNode: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      editable: r = !1
    } = n, o = pn.toDOMNode(e, e), i;
    try {
      i = ca(t) ? t : t.parentElement;
    } catch (a) {
      if (a instanceof Error && !a.message.includes('Permission denied to access property "nodeType"'))
        throw a;
    }
    return i ? i.closest("[data-slate-editor]") === o && (!r || i.isContentEditable ? !0 : typeof i.isContentEditable == "boolean" && // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined
    // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable="false"(readOnly)
    i.closest('[contenteditable="false"]') === o || !!i.getAttribute("data-slate-zero-width")) : !1;
  },
  hasEditableTarget: (e, t) => Bb(t) && pn.hasDOMNode(e, t, {
    editable: !0
  }),
  hasRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t;
    return pr.hasPath(e, n.path) && pr.hasPath(e, r.path);
  },
  hasSelectableTarget: (e, t) => pn.hasEditableTarget(e, t) || pn.isTargetInsideNonReadonlyVoid(e, t),
  hasTarget: (e, t) => Bb(t) && pn.hasDOMNode(e, t),
  insertData: (e, t) => {
    e.insertData(t);
  },
  insertFragmentData: (e, t) => e.insertFragmentData(t),
  insertTextData: (e, t) => e.insertTextData(t),
  isComposing: (e) => !!R1e.get(e),
  isFocused: (e) => !!nv.get(e),
  isReadOnly: (e) => !!C2.get(e),
  isTargetInsideNonReadonlyVoid: (e, t) => {
    if (C2.get(e)) return !1;
    var n = pn.hasTarget(e, t) && pn.toSlateNode(e, t);
    return Za.isElement(n) && pr.isVoid(e, n);
  },
  setFragmentData: (e, t, n) => e.setFragmentData(t, n),
  toDOMNode: (e, t) => {
    var n = A1e.get(e), r = pr.isEditor(t) ? T1e.get(e) : n == null ? void 0 : n.get(pn.findKey(e, t));
    if (!r)
      throw new Error("Cannot resolve a DOM node from Slate node: ".concat(ls.stringify(t)));
    return r;
  },
  toDOMPoint: (e, t) => {
    var [n] = pr.node(e, t.path), r = pn.toDOMNode(e, n), o;
    pr.void(e, {
      at: t
    }) && (t = {
      path: t.path,
      offset: 0
    });
    for (var i = "[data-slate-string], [data-slate-zero-width]", a = Array.from(r.querySelectorAll(i)), s = 0, l = 0; l < a.length; l++) {
      var u = a[l], c = u.childNodes[0];
      if (!(c == null || c.textContent == null)) {
        var {
          length: p
        } = c.textContent, d = u.getAttribute("data-slate-length"), g = d == null ? p : parseInt(d, 10), f = s + g, m = a[l + 1];
        if (t.offset === f && m !== null && m !== void 0 && m.hasAttribute("data-slate-mark-placeholder")) {
          var b, E = m.childNodes[0];
          o = [
            // COMPAT: If we don't explicity set the dom point to be on the actual
            // dom text element, chrome will put the selection behind the actual dom
            // text element, causing domRange.getBoundingClientRect() calls on a collapsed
            // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)
            // which will cause issues when scrolling to it.
            E instanceof B1e ? E : m,
            (b = m.textContent) !== null && b !== void 0 && b.startsWith("\uFEFF") ? 1 : 0
          ];
          break;
        }
        if (t.offset <= f) {
          var w = Math.min(p, Math.max(0, t.offset - s));
          o = [c, w];
          break;
        }
        s = f;
      }
    }
    if (!o)
      throw new Error("Cannot resolve a DOM point from Slate point: ".concat(ls.stringify(t)));
    return o;
  },
  toDOMRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t, o = Xt.isBackward(t), i = pn.toDOMPoint(e, n), a = Xt.isCollapsed(t) ? i : pn.toDOMPoint(e, r), s = pn.getWindow(e), l = s.document.createRange(), [u, c] = o ? a : i, [p, d] = o ? i : a, g = ca(u) ? u : u.parentElement, f = !!g.getAttribute("data-slate-zero-width"), m = ca(p) ? p : p.parentElement, b = !!m.getAttribute("data-slate-zero-width");
    return l.setStart(u, f ? 1 : c), l.setEnd(p, b ? 1 : d), l;
  },
  toSlateNode: (e, t) => {
    var n = ca(t) ? t : t.parentElement;
    n && !n.hasAttribute("data-slate-node") && (n = n.closest("[data-slate-node]"));
    var r = n ? j1e.get(n) : null;
    if (!r)
      throw new Error("Cannot resolve a Slate node from DOM node: ".concat(n));
    return r;
  },
  toSlatePoint: (e, t, n) => {
    var {
      exactMatch: r,
      suppressThrow: o,
      searchDirection: i = "backward"
    } = n, [a, s] = r ? t : z1e(t), l = a.parentNode, u = null, c = 0;
    if (l) {
      var p, d, g = pn.toDOMNode(e, e), f = l.closest('[data-slate-void="true"]'), m = f && g.contains(f) ? f : null, b = l.closest('[contenteditable="false"]'), E = b && g.contains(b) ? b : null, w = l.closest("[data-slate-leaf]"), M = null;
      if (w) {
        if (u = w.closest('[data-slate-node="text"]'), u) {
          var x = pn.getWindow(e), v = x.document.createRange();
          v.setStart(u, 0), v.setEnd(a, s);
          var C = v.cloneContents(), P = [...Array.prototype.slice.call(C.querySelectorAll("[data-slate-zero-width]")), ...Array.prototype.slice.call(C.querySelectorAll("[contenteditable=false]"))];
          P.forEach((S) => {
            if (gE && !r && S.hasAttribute("data-slate-zero-width") && S.textContent.length > 0 && S.textContext !== "\uFEFF") {
              S.textContent.startsWith("\uFEFF") && (S.textContent = S.textContent.slice(1));
              return;
            }
            S.parentNode.removeChild(S);
          }), c = C.textContent.length, M = u;
        }
      } else if (m) {
        for (var F = m.querySelectorAll("[data-slate-leaf]"), L = 0; L < F.length; L++) {
          var B = F[L];
          if (pn.hasDOMNode(e, B)) {
            w = B;
            break;
          }
        }
        w ? (u = w.closest('[data-slate-node="text"]'), M = w, c = M.textContent.length, M.querySelectorAll("[data-slate-zero-width]").forEach((S) => {
          c -= S.textContent.length;
        })) : c = 1;
      } else if (E) {
        var N = (S) => S ? S.querySelectorAll(
          // Exclude leaf nodes in nested editors
          "[data-slate-leaf]:not(:scope [data-slate-editor] [data-slate-leaf])"
        ) : [], $ = E.closest('[data-slate-node="element"]');
        if (i === "forward") {
          var V, H = [...N($), ...N($ == null ? void 0 : $.nextElementSibling)];
          w = (V = H.find((S) => W1e(E, S))) !== null && V !== void 0 ? V : null;
        } else {
          var Z, K = [...N($ == null ? void 0 : $.previousElementSibling), ...N($)];
          w = (Z = K.findLast((S) => E2(E, S))) !== null && Z !== void 0 ? Z : null;
        }
        w && (u = w.closest('[data-slate-node="text"]'), M = w, i === "forward" ? c = 0 : (c = M.textContent.length, M.querySelectorAll("[data-slate-zero-width]").forEach((S) => {
          c -= S.textContent.length;
        })));
      }
      M && c === M.textContent.length && // COMPAT: Android IMEs might remove the zero width space while composing,
      // and we don't add it for line-breaks.
      gE && M.getAttribute("data-slate-zero-width") === "z" && (p = M.textContent) !== null && p !== void 0 && p.startsWith("\uFEFF") && // COMPAT: If the parent node is a Slate zero-width space, editor is
      // because the text node should have no characters. However, during IME
      // composition the ASCII characters will be prepended to the zero-width
      // space, so subtract 1 from the offset to account for the zero-width
      // space character.
      (l.hasAttribute("data-slate-zero-width") || // COMPAT: In Firefox, `range.cloneContents()` returns an extra trailing '\n'
      // when the document ends with a new-line character. This results in the offset
      // length being off by one, so we need to subtract one to account for this.
      tv && (d = M.textContent) !== null && d !== void 0 && d.endsWith(`

`)) && c--;
    }
    if (gE && !u && !r) {
      var Y = l.hasAttribute("data-slate-node") ? l : l.closest("[data-slate-node]");
      if (Y && pn.hasDOMNode(e, Y, {
        editable: !0
      })) {
        var Q = pn.toSlateNode(e, Y), {
          path: J,
          offset: _
        } = pr.start(e, pn.findPath(e, Q));
        return Y.querySelector("[data-slate-leaf]") || (_ = s), {
          path: J,
          offset: _
        };
      }
    }
    if (!u) {
      if (o)
        return null;
      throw new Error("Cannot resolve a Slate point from DOM point: ".concat(t));
    }
    var D = pn.toSlateNode(e, u), z = pn.findPath(e, D);
    return {
      path: z,
      offset: c
    };
  },
  toSlateRange: (e, t, n) => {
    var r, {
      exactMatch: o,
      suppressThrow: i
    } = n, a = O2(t) ? t.anchorNode : t.startContainer, s, l, u, c, p;
    if (a)
      if (O2(t)) {
        if (tv && t.rangeCount > 1) {
          u = t.focusNode;
          var d = t.getRangeAt(0), g = t.getRangeAt(t.rangeCount - 1);
          if (u instanceof HTMLTableRowElement && d.startContainer instanceof HTMLTableRowElement && g.startContainer instanceof HTMLTableRowElement) {
            let C = function(P) {
              return P.childElementCount > 0 ? C(P.children[0]) : P;
            };
            var f = d.startContainer, m = g.startContainer, b = C(f.children[d.startOffset]), E = C(m.children[g.startOffset]);
            c = 0, E.childNodes.length > 0 ? s = E.childNodes[0] : s = E, b.childNodes.length > 0 ? u = b.childNodes[0] : u = b, E instanceof HTMLElement ? l = E.innerHTML.length : l = 0;
          } else
            d.startContainer === u ? (s = g.endContainer, l = g.endOffset, c = d.startOffset) : (s = d.startContainer, l = d.endOffset, c = g.startOffset);
        } else
          s = t.anchorNode, l = t.anchorOffset, u = t.focusNode, c = t.focusOffset;
        P1e && U1e(s) || tv ? p = t.anchorNode === t.focusNode && t.anchorOffset === t.focusOffset : p = t.isCollapsed;
      } else
        s = t.startContainer, l = t.startOffset, u = t.endContainer, c = t.endOffset, p = t.collapsed;
    if (s == null || u == null || l == null || c == null)
      throw new Error("Cannot resolve a Slate range from DOM range: ".concat(t));
    tv && (r = u.textContent) !== null && r !== void 0 && r.endsWith(`

`) && c === u.textContent.length && c--;
    var w = pn.toSlatePoint(e, [s, l], {
      exactMatch: o,
      suppressThrow: i
    });
    if (!w)
      return null;
    var M = E2(s, u) || s === u && c < l, x = p ? w : pn.toSlatePoint(e, [u, c], {
      exactMatch: o,
      suppressThrow: i,
      searchDirection: M ? "forward" : "backward"
    });
    if (!x)
      return null;
    var v = {
      anchor: w,
      focus: x
    };
    return Xt.isExpanded(v) && Xt.isForward(v) && ca(u) && pr.void(e, {
      at: v.focus,
      mode: "highest"
    }) && (v = pr.unhangRange(e, v, {
      voids: !0
    })), v;
  }
}, Z1e = {
  bold: "mod+b",
  compose: ["down", "left", "right", "up", "backspace", "enter"],
  moveBackward: "left",
  moveForward: "right",
  moveWordBackward: "ctrl+left",
  moveWordForward: "ctrl+right",
  deleteBackward: "shift?+backspace",
  deleteForward: "shift?+delete",
  extendBackward: "shift+left",
  extendForward: "shift+right",
  italic: "mod+i",
  insertSoftBreak: "shift+enter",
  splitBlock: "enter",
  undo: "mod+z"
}, q1e = {
  moveLineBackward: "opt+up",
  moveLineForward: "opt+down",
  moveWordBackward: "opt+left",
  moveWordForward: "opt+right",
  deleteBackward: ["ctrl+backspace", "ctrl+h"],
  deleteForward: ["ctrl+delete", "ctrl+d"],
  deleteLineBackward: "cmd+shift?+backspace",
  deleteLineForward: ["cmd+shift?+delete", "ctrl+k"],
  deleteWordBackward: "opt+shift?+backspace",
  deleteWordForward: "opt+shift?+delete",
  extendLineBackward: "opt+shift+up",
  extendLineForward: "opt+shift+down",
  redo: "cmd+shift+z",
  transposeCharacter: "ctrl+t"
}, G1e = {
  deleteWordBackward: "ctrl+shift?+backspace",
  deleteWordForward: "ctrl+shift?+delete",
  redo: ["ctrl+y", "ctrl+shift+z"]
}, Zr = (e) => {
  var t = Z1e[e], n = q1e[e], r = G1e[e], o = t && pE(t), i = n && pE(n), a = r && pE(r);
  return (s) => !!(o && o(s) || b2 && i && i(s) || !b2 && a && a(s));
};
Zr("bold"), Zr("compose"), Zr("moveBackward"), Zr("moveForward"), Zr("deleteBackward"), Zr("deleteForward"), Zr("deleteLineBackward"), Zr("deleteLineForward"), Zr("deleteWordBackward"), Zr("deleteWordForward"), Zr("extendBackward"), Zr("extendForward"), Zr("extendLineBackward"), Zr("extendLineForward"), Zr("italic"), Zr("moveLineBackward"), Zr("moveLineForward"), Zr("moveWordBackward"), Zr("moveWordForward"), Zr("redo"), Zr("insertSoftBreak"), Zr("splitBlock"), Zr("transposeCharacter"), Zr("undo");
var K1e = (e, t) => {
  var n = [], r = () => {
    n = [];
  }, o = (a) => {
    if (t.current) {
      var s = a.filter((l) => VQ(e, l, a));
      n.push(...s);
    }
  };
  function i() {
    n.length > 0 && (n.reverse().forEach((a) => {
      a.type !== "characterData" && (a.removedNodes.forEach((s) => {
        a.target.insertBefore(s, a.nextSibling);
      }), a.addedNodes.forEach((s) => {
        a.target.removeChild(s);
      }));
    }), r());
  }
  return {
    registerMutations: o,
    restoreDOM: i,
    clear: r
  };
}, X1e = {
  subtree: !0,
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0
};
class Y1e extends au {
  constructor() {
    super(...arguments), Ef(this, "context", null), Ef(this, "manager", null), Ef(this, "mutationObserver", null);
  }
  observe() {
    var t, {
      node: n
    } = this.props;
    if (!n.current)
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    (t = this.mutationObserver) === null || t === void 0 || t.observe(n.current, X1e);
  }
  componentDidMount() {
    var {
      receivedUserInput: t
    } = this.props, n = this.context;
    this.manager = K1e(n, t), this.mutationObserver = new MutationObserver(this.manager.registerMutations), this.observe();
  }
  getSnapshotBeforeUpdate() {
    var t, n, r, o = (t = this.mutationObserver) === null || t === void 0 ? void 0 : t.takeRecords();
    if (o != null && o.length) {
      var i;
      (i = this.manager) === null || i === void 0 || i.registerMutations(o);
    }
    return (n = this.mutationObserver) === null || n === void 0 || n.disconnect(), (r = this.manager) === null || r === void 0 || r.restoreDOM(), null;
  }
  componentDidUpdate() {
    var t;
    (t = this.manager) === null || t === void 0 || t.clear(), this.observe();
  }
  componentWillUnmount() {
    var t;
    (t = this.mutationObserver) === null || t === void 0 || t.disconnect();
  }
  render() {
    return this.props.children;
  }
}
Ef(Y1e, "contextType", _1e);
$e({});
$e({});
$e({});
var Ao = {}, TD = {}, eg = {}, tg = {}, ZQ = "Expected a function", k2 = NaN, J1e = "[object Symbol]", Q1e = /^\s+|\s+$/g, e_e = /^[-+]0x[0-9a-f]+$/i, t_e = /^0b[01]+$/i, n_e = /^0o[0-7]+$/i, r_e = parseInt, o_e = typeof br == "object" && br && br.Object === Object && br, i_e = typeof self == "object" && self && self.Object === Object && self, s_e = o_e || i_e || Function("return this")(), a_e = Object.prototype, l_e = a_e.toString, u_e = Math.max, c_e = Math.min, mE = function() {
  return s_e.Date.now();
};
function p_e(e, t, n) {
  var r, o, i, a, s, l, u = 0, c = !1, p = !1, d = !0;
  if (typeof e != "function")
    throw new TypeError(ZQ);
  t = L2(t) || 0, Fb(n) && (c = !!n.leading, p = "maxWait" in n, i = p ? u_e(L2(n.maxWait) || 0, t) : i, d = "trailing" in n ? !!n.trailing : d);
  function g(C) {
    var P = r, F = o;
    return r = o = void 0, u = C, a = e.apply(F, P), a;
  }
  function f(C) {
    return u = C, s = setTimeout(E, t), c ? g(C) : a;
  }
  function m(C) {
    var P = C - l, F = C - u, L = t - P;
    return p ? c_e(L, i - F) : L;
  }
  function b(C) {
    var P = C - l, F = C - u;
    return l === void 0 || P >= t || P < 0 || p && F >= i;
  }
  function E() {
    var C = mE();
    if (b(C))
      return w(C);
    s = setTimeout(E, m(C));
  }
  function w(C) {
    return s = void 0, d && r ? g(C) : (r = o = void 0, a);
  }
  function M() {
    s !== void 0 && clearTimeout(s), u = 0, r = l = o = s = void 0;
  }
  function x() {
    return s === void 0 ? a : w(mE());
  }
  function v() {
    var C = mE(), P = b(C);
    if (r = arguments, o = this, l = C, P) {
      if (s === void 0)
        return f(l);
      if (p)
        return s = setTimeout(E, t), g(l);
    }
    return s === void 0 && (s = setTimeout(E, t)), a;
  }
  return v.cancel = M, v.flush = x, v;
}
function d_e(e, t, n) {
  var r = !0, o = !0;
  if (typeof e != "function")
    throw new TypeError(ZQ);
  return Fb(n) && (r = "leading" in n ? !!n.leading : r, o = "trailing" in n ? !!n.trailing : o), p_e(e, t, {
    leading: r,
    maxWait: t,
    trailing: o
  });
}
function Fb(e) {
  var t = typeof e;
  return !!e && (t == "object" || t == "function");
}
function f_e(e) {
  return !!e && typeof e == "object";
}
function h_e(e) {
  return typeof e == "symbol" || f_e(e) && l_e.call(e) == J1e;
}
function L2(e) {
  if (typeof e == "number")
    return e;
  if (h_e(e))
    return k2;
  if (Fb(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = Fb(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = e.replace(Q1e, "");
  var n = t_e.test(e);
  return n || n_e.test(e) ? r_e(e.slice(2), n ? 2 : 8) : e_e.test(e) ? k2 : +e;
}
var g_e = d_e, ng = {};
Object.defineProperty(ng, "__esModule", {
  value: !0
});
ng.addPassiveEventListener = function(e, t, n) {
  var r = n.name;
  r || (r = t, console.warn("Listener must be a named function.")), _y.has(t) || _y.set(t, /* @__PURE__ */ new Set());
  var o = _y.get(t);
  if (!o.has(r)) {
    var i = function() {
      var a = !1;
      try {
        var s = Object.defineProperty({}, "passive", {
          get: function() {
            a = !0;
          }
        });
        window.addEventListener("test", null, s);
      } catch {
      }
      return a;
    }();
    e.addEventListener(t, n, i ? { passive: !0 } : !1), o.add(r);
  }
};
ng.removePassiveEventListener = function(e, t, n) {
  e.removeEventListener(t, n), _y.get(t).delete(n.name || t);
};
var _y = /* @__PURE__ */ new Map();
Object.defineProperty(tg, "__esModule", {
  value: !0
});
var m_e = g_e, v_e = y_e(m_e), _2 = ng;
function y_e(e) {
  return e && e.__esModule ? e : { default: e };
}
var b_e = function(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 66;
  return (0, v_e.default)(e, t);
}, co = {
  spyCallbacks: [],
  spySetState: [],
  scrollSpyContainers: [],
  mount: function(e, t) {
    if (e) {
      var n = b_e(function(r) {
        co.scrollHandler(e);
      }, t);
      return co.scrollSpyContainers.push(e), (0, _2.addPassiveEventListener)(e, "scroll", n), function() {
        (0, _2.removePassiveEventListener)(e, "scroll", n), co.scrollSpyContainers.splice(co.scrollSpyContainers.indexOf(e), 1);
      };
    }
    return function() {
    };
  },
  isMounted: function(e) {
    return co.scrollSpyContainers.indexOf(e) !== -1;
  },
  currentPositionX: function(e) {
    if (e === document) {
      var t = window.scrollY !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.scrollX : n ? document.documentElement.scrollLeft : document.body.scrollLeft;
    } else
      return e.scrollLeft;
  },
  currentPositionY: function(e) {
    if (e === document) {
      var t = window.scrollX !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.scrollY : n ? document.documentElement.scrollTop : document.body.scrollTop;
    } else
      return e.scrollTop;
  },
  scrollHandler: function(e) {
    var t = co.scrollSpyContainers[co.scrollSpyContainers.indexOf(e)].spyCallbacks || [];
    t.forEach(function(n) {
      return n(co.currentPositionX(e), co.currentPositionY(e));
    });
  },
  addStateHandler: function(e) {
    co.spySetState.push(e);
  },
  addSpyHandler: function(e, t) {
    var n = co.scrollSpyContainers[co.scrollSpyContainers.indexOf(t)];
    n.spyCallbacks || (n.spyCallbacks = []), n.spyCallbacks.push(e);
  },
  updateStates: function() {
    co.spySetState.forEach(function(e) {
      return e();
    });
  },
  unmount: function(e, t) {
    co.scrollSpyContainers.forEach(function(n) {
      return n.spyCallbacks && n.spyCallbacks.length && n.spyCallbacks.indexOf(t) > -1 && n.spyCallbacks.splice(n.spyCallbacks.indexOf(t), 1);
    }), co.spySetState && co.spySetState.length && co.spySetState.indexOf(e) > -1 && co.spySetState.splice(co.spySetState.indexOf(e), 1), document.removeEventListener("scroll", co.scrollHandler);
  },
  update: function() {
    return co.scrollSpyContainers.forEach(function(e) {
      return co.scrollHandler(e);
    });
  }
};
tg.default = co;
var zp = {}, rg = {};
Object.defineProperty(rg, "__esModule", {
  value: !0
});
var w_e = function(e, t) {
  var n = e.indexOf("#") === 0 ? e.substring(1) : e, r = n ? "#" + n : "", o = window && window.location, i = r ? o.pathname + o.search + r : o.pathname + o.search;
  t ? history.pushState(history.state, "", i) : history.replaceState(history.state, "", i);
}, C_e = function() {
  return window.location.hash.replace(/^#/, "");
}, O_e = function(e) {
  return function(t) {
    return e.contains ? e != t && e.contains(t) : !!(e.compareDocumentPosition(t) & 16);
  };
}, x_e = function(e) {
  return getComputedStyle(e).position !== "static";
}, vE = function(e, t) {
  for (var n = e.offsetTop, r = e.offsetParent; r && !t(r); )
    n += r.offsetTop, r = r.offsetParent;
  return { offsetTop: n, offsetParent: r };
}, E_e = function(e, t, n) {
  if (n)
    return e === document ? t.getBoundingClientRect().left + (window.scrollX || window.pageXOffset) : getComputedStyle(e).position !== "static" ? t.offsetLeft : t.offsetLeft - e.offsetLeft;
  if (e === document)
    return t.getBoundingClientRect().top + (window.scrollY || window.pageYOffset);
  if (x_e(e)) {
    if (t.offsetParent !== e) {
      var r = function(l) {
        return l === e || l === document;
      }, o = vE(t, r), i = o.offsetTop, a = o.offsetParent;
      if (a !== e)
        throw new Error("Seems containerElement is not an ancestor of the Element");
      return i;
    }
    return t.offsetTop;
  }
  if (t.offsetParent === e.offsetParent)
    return t.offsetTop - e.offsetTop;
  var s = function(l) {
    return l === document;
  };
  return vE(t, s).offsetTop - vE(e, s).offsetTop;
};
rg.default = {
  updateHash: w_e,
  getHash: C_e,
  filterElementInContainer: O_e,
  scrollOffset: E_e
};
var eO = {}, jD = {};
Object.defineProperty(jD, "__esModule", {
  value: !0
});
jD.default = {
  /*
   * https://github.com/oblador/angular-scroll (duScrollDefaultEasing)
   */
  defaultEasing: function(e) {
    return e < 0.5 ? Math.pow(e * 2, 2) / 2 : 1 - Math.pow((1 - e) * 2, 2) / 2;
  },
  /*
   * https://gist.github.com/gre/1650294
   */
  // no easing, no acceleration
  linear: function(e) {
    return e;
  },
  // accelerating from zero velocity
  easeInQuad: function(e) {
    return e * e;
  },
  // decelerating to zero velocity
  easeOutQuad: function(e) {
    return e * (2 - e);
  },
  // acceleration until halfway, then deceleration
  easeInOutQuad: function(e) {
    return e < 0.5 ? 2 * e * e : -1 + (4 - 2 * e) * e;
  },
  // accelerating from zero velocity 
  easeInCubic: function(e) {
    return e * e * e;
  },
  // decelerating to zero velocity π
  easeOutCubic: function(e) {
    return --e * e * e + 1;
  },
  // acceleration until halfway, then deceleration 
  easeInOutCubic: function(e) {
    return e < 0.5 ? 4 * e * e * e : (e - 1) * (2 * e - 2) * (2 * e - 2) + 1;
  },
  // accelerating from zero velocity 
  easeInQuart: function(e) {
    return e * e * e * e;
  },
  // decelerating to zero velocity 
  easeOutQuart: function(e) {
    return 1 - --e * e * e * e;
  },
  // acceleration until halfway, then deceleration
  easeInOutQuart: function(e) {
    return e < 0.5 ? 8 * e * e * e * e : 1 - 8 * --e * e * e * e;
  },
  // accelerating from zero velocity
  easeInQuint: function(e) {
    return e * e * e * e * e;
  },
  // decelerating to zero velocity
  easeOutQuint: function(e) {
    return 1 + --e * e * e * e * e;
  },
  // acceleration until halfway, then deceleration 
  easeInOutQuint: function(e) {
    return e < 0.5 ? 16 * e * e * e * e * e : 1 + 16 * --e * e * e * e * e;
  }
};
var AD = {};
Object.defineProperty(AD, "__esModule", {
  value: !0
});
var k_e = ng, L_e = ["mousedown", "wheel", "touchmove", "keydown"];
AD.default = {
  subscribe: function(e) {
    return typeof document < "u" && L_e.forEach(function(t) {
      return (0, k_e.addPassiveEventListener)(document, t, e);
    });
  }
};
var og = {};
Object.defineProperty(og, "__esModule", {
  value: !0
});
var R_ = {
  registered: {},
  scrollEvent: {
    register: function(e, t) {
      R_.registered[e] = t;
    },
    remove: function(e) {
      R_.registered[e] = null;
    }
  }
};
og.default = R_;
Object.defineProperty(eO, "__esModule", {
  value: !0
});
var __e = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, P_e = rg;
tO(P_e);
var S_e = jD, P2 = tO(S_e), M_e = AD, D_e = tO(M_e), T_e = og, na = tO(T_e);
function tO(e) {
  return e && e.__esModule ? e : { default: e };
}
var qQ = function(e) {
  return P2.default[e.smooth] || P2.default.defaultEasing;
}, j_e = function(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}, A_e = function() {
  if (typeof window < "u")
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame;
}, I_ = function() {
  return A_e() || function(e, t, n) {
    window.setTimeout(e, n || 1e3 / 60, (/* @__PURE__ */ new Date()).getTime());
  };
}(), GQ = function() {
  return {
    currentPosition: 0,
    startPosition: 0,
    targetPosition: 0,
    progress: 0,
    duration: 0,
    cancel: !1,
    target: null,
    containerElement: null,
    to: null,
    start: null,
    delta: null,
    percent: null,
    delayTimeout: null
  };
}, KQ = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollLeft;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageXOffset : r ? document.documentElement.scrollLeft : document.body.scrollLeft;
}, XQ = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollTop;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageYOffset : r ? document.documentElement.scrollTop : document.body.scrollTop;
}, R_e = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollWidth - t.offsetWidth;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollWidth, n.offsetWidth, r.clientWidth, r.scrollWidth, r.offsetWidth);
}, I_e = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollHeight - t.offsetHeight;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollHeight, n.offsetHeight, r.clientHeight, r.scrollHeight, r.offsetHeight);
}, N_e = function e(t, n, r) {
  var o = n.data;
  if (!n.ignoreCancelEvents && o.cancel) {
    na.default.registered.end && na.default.registered.end(o.to, o.target, o.currentPositionY);
    return;
  }
  if (o.delta = Math.round(o.targetPosition - o.startPosition), o.start === null && (o.start = r), o.progress = r - o.start, o.percent = o.progress >= o.duration ? 1 : t(o.progress / o.duration), o.currentPosition = o.startPosition + Math.ceil(o.delta * o.percent), o.containerElement && o.containerElement !== document && o.containerElement !== document.body ? n.horizontal ? o.containerElement.scrollLeft = o.currentPosition : o.containerElement.scrollTop = o.currentPosition : n.horizontal ? window.scrollTo(o.currentPosition, 0) : window.scrollTo(0, o.currentPosition), o.percent < 1) {
    var i = e.bind(null, t, n);
    I_.call(window, i);
    return;
  }
  na.default.registered.end && na.default.registered.end(o.to, o.target, o.currentPosition);
}, RD = function(e) {
  e.data.containerElement = e ? e.containerId ? document.getElementById(e.containerId) : e.container && e.container.nodeType ? e.container : document : null;
}, ig = function(e, t, n, r) {
  t.data = t.data || GQ(), window.clearTimeout(t.data.delayTimeout);
  var o = function() {
    t.data.cancel = !0;
  };
  if (D_e.default.subscribe(o), RD(t), t.data.start = null, t.data.cancel = !1, t.data.startPosition = t.horizontal ? KQ(t) : XQ(t), t.data.targetPosition = t.absolute ? e : e + t.data.startPosition, t.data.startPosition === t.data.targetPosition) {
    na.default.registered.end && na.default.registered.end(t.data.to, t.data.target, t.data.currentPosition);
    return;
  }
  t.data.delta = Math.round(t.data.targetPosition - t.data.startPosition), t.data.duration = j_e(t.duration)(t.data.delta), t.data.duration = isNaN(parseFloat(t.data.duration)) ? 1e3 : parseFloat(t.data.duration), t.data.to = n, t.data.target = r;
  var i = qQ(t), a = N_e.bind(null, i, t);
  if (t && t.delay > 0) {
    t.data.delayTimeout = window.setTimeout(function() {
      na.default.registered.begin && na.default.registered.begin(t.data.to, t.data.target), I_.call(window, a);
    }, t.delay);
    return;
  }
  na.default.registered.begin && na.default.registered.begin(t.data.to, t.data.target), I_.call(window, a);
}, nO = function(e) {
  return e = __e({}, e), e.data = e.data || GQ(), e.absolute = !0, e;
}, B_e = function(e) {
  ig(0, nO(e));
}, F_e = function(e, t) {
  ig(e, nO(t));
}, z_e = function(e) {
  e = nO(e), RD(e), ig(e.horizontal ? R_e(e) : I_e(e), e);
}, U_e = function(e, t) {
  t = nO(t), RD(t);
  var n = t.horizontal ? KQ(t) : XQ(t);
  ig(e + n, t);
};
eO.default = {
  animateTopScroll: ig,
  getAnimationType: qQ,
  scrollToTop: B_e,
  scrollToBottom: z_e,
  scrollTo: F_e,
  scrollMore: U_e
};
Object.defineProperty(zp, "__esModule", {
  value: !0
});
var H_e = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, W_e = rg, $_e = ID(W_e), V_e = eO, Z_e = ID(V_e), q_e = og, rv = ID(q_e);
function ID(e) {
  return e && e.__esModule ? e : { default: e };
}
var ov = {}, S2 = void 0;
zp.default = {
  unmount: function() {
    ov = {};
  },
  register: function(e, t) {
    ov[e] = t;
  },
  unregister: function(e) {
    delete ov[e];
  },
  get: function(e) {
    return ov[e] || document.getElementById(e) || document.getElementsByName(e)[0] || document.getElementsByClassName(e)[0];
  },
  setActiveLink: function(e) {
    return S2 = e;
  },
  getActiveLink: function() {
    return S2;
  },
  scrollTo: function(e, t) {
    var n = this.get(e);
    if (!n) {
      console.warn("target Element not found");
      return;
    }
    t = H_e({}, t, { absolute: !1 });
    var r = t.containerId, o = t.container, i = void 0;
    r ? i = document.getElementById(r) : o && o.nodeType ? i = o : i = document, t.absolute = !0;
    var a = t.horizontal, s = $_e.default.scrollOffset(i, n, a) + (t.offset || 0);
    if (!t.smooth) {
      rv.default.registered.begin && rv.default.registered.begin(e, n), i === document ? t.horizontal ? window.scrollTo(s, 0) : window.scrollTo(0, s) : i.scrollTop = s, rv.default.registered.end && rv.default.registered.end(e, n);
      return;
    }
    Z_e.default.animateTopScroll(s, t, e, n);
  }
};
var N_ = { exports: {} }, yE = { exports: {} }, $n = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var M2;
function G_e() {
  if (M2) return $n;
  M2 = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, g = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, m = e ? Symbol.for("react.block") : 60121, b = e ? Symbol.for("react.fundamental") : 60117, E = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
  function M(v) {
    if (typeof v == "object" && v !== null) {
      var C = v.$$typeof;
      switch (C) {
        case t:
          switch (v = v.type, v) {
            case l:
            case u:
            case r:
            case i:
            case o:
            case p:
              return v;
            default:
              switch (v = v && v.$$typeof, v) {
                case s:
                case c:
                case f:
                case g:
                case a:
                  return v;
                default:
                  return C;
              }
          }
        case n:
          return C;
      }
    }
  }
  function x(v) {
    return M(v) === u;
  }
  return $n.AsyncMode = l, $n.ConcurrentMode = u, $n.ContextConsumer = s, $n.ContextProvider = a, $n.Element = t, $n.ForwardRef = c, $n.Fragment = r, $n.Lazy = f, $n.Memo = g, $n.Portal = n, $n.Profiler = i, $n.StrictMode = o, $n.Suspense = p, $n.isAsyncMode = function(v) {
    return x(v) || M(v) === l;
  }, $n.isConcurrentMode = x, $n.isContextConsumer = function(v) {
    return M(v) === s;
  }, $n.isContextProvider = function(v) {
    return M(v) === a;
  }, $n.isElement = function(v) {
    return typeof v == "object" && v !== null && v.$$typeof === t;
  }, $n.isForwardRef = function(v) {
    return M(v) === c;
  }, $n.isFragment = function(v) {
    return M(v) === r;
  }, $n.isLazy = function(v) {
    return M(v) === f;
  }, $n.isMemo = function(v) {
    return M(v) === g;
  }, $n.isPortal = function(v) {
    return M(v) === n;
  }, $n.isProfiler = function(v) {
    return M(v) === i;
  }, $n.isStrictMode = function(v) {
    return M(v) === o;
  }, $n.isSuspense = function(v) {
    return M(v) === p;
  }, $n.isValidElementType = function(v) {
    return typeof v == "string" || typeof v == "function" || v === r || v === u || v === i || v === o || v === p || v === d || typeof v == "object" && v !== null && (v.$$typeof === f || v.$$typeof === g || v.$$typeof === a || v.$$typeof === s || v.$$typeof === c || v.$$typeof === b || v.$$typeof === E || v.$$typeof === w || v.$$typeof === m);
  }, $n.typeOf = M, $n;
}
var er = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var D2;
function K_e() {
  return D2 || (D2 = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, g = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, m = e ? Symbol.for("react.block") : 60121, b = e ? Symbol.for("react.fundamental") : 60117, E = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
    function M(I) {
      return typeof I == "string" || typeof I == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      I === r || I === u || I === i || I === o || I === p || I === d || typeof I == "object" && I !== null && (I.$$typeof === f || I.$$typeof === g || I.$$typeof === a || I.$$typeof === s || I.$$typeof === c || I.$$typeof === b || I.$$typeof === E || I.$$typeof === w || I.$$typeof === m);
    }
    function x(I) {
      if (typeof I == "object" && I !== null) {
        var le = I.$$typeof;
        switch (le) {
          case t:
            var he = I.type;
            switch (he) {
              case l:
              case u:
              case r:
              case i:
              case o:
              case p:
                return he;
              default:
                var oe = he && he.$$typeof;
                switch (oe) {
                  case s:
                  case c:
                  case f:
                  case g:
                  case a:
                    return oe;
                  default:
                    return le;
                }
            }
          case n:
            return le;
        }
      }
    }
    var v = l, C = u, P = s, F = a, L = t, B = c, N = r, $ = f, V = g, H = n, Z = i, K = o, Y = p, Q = !1;
    function J(I) {
      return Q || (Q = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), _(I) || x(I) === l;
    }
    function _(I) {
      return x(I) === u;
    }
    function D(I) {
      return x(I) === s;
    }
    function z(I) {
      return x(I) === a;
    }
    function S(I) {
      return typeof I == "object" && I !== null && I.$$typeof === t;
    }
    function W(I) {
      return x(I) === c;
    }
    function O(I) {
      return x(I) === r;
    }
    function j(I) {
      return x(I) === f;
    }
    function U(I) {
      return x(I) === g;
    }
    function T(I) {
      return x(I) === n;
    }
    function q(I) {
      return x(I) === i;
    }
    function A(I) {
      return x(I) === o;
    }
    function X(I) {
      return x(I) === p;
    }
    er.AsyncMode = v, er.ConcurrentMode = C, er.ContextConsumer = P, er.ContextProvider = F, er.Element = L, er.ForwardRef = B, er.Fragment = N, er.Lazy = $, er.Memo = V, er.Portal = H, er.Profiler = Z, er.StrictMode = K, er.Suspense = Y, er.isAsyncMode = J, er.isConcurrentMode = _, er.isContextConsumer = D, er.isContextProvider = z, er.isElement = S, er.isForwardRef = W, er.isFragment = O, er.isLazy = j, er.isMemo = U, er.isPortal = T, er.isProfiler = q, er.isStrictMode = A, er.isSuspense = X, er.isValidElementType = M, er.typeOf = x;
  }()), er;
}
var T2;
function YQ() {
  return T2 || (T2 = 1, process.env.NODE_ENV === "production" ? yE.exports = G_e() : yE.exports = K_e()), yE.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var bE, j2;
function X_e() {
  if (j2) return bE;
  j2 = 1;
  var e = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, n = Object.prototype.propertyIsEnumerable;
  function r(i) {
    if (i == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(i);
  }
  function o() {
    try {
      if (!Object.assign)
        return !1;
      var i = new String("abc");
      if (i[5] = "de", Object.getOwnPropertyNames(i)[0] === "5")
        return !1;
      for (var a = {}, s = 0; s < 10; s++)
        a["_" + String.fromCharCode(s)] = s;
      var l = Object.getOwnPropertyNames(a).map(function(c) {
        return a[c];
      });
      if (l.join("") !== "0123456789")
        return !1;
      var u = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(c) {
        u[c] = c;
      }), Object.keys(Object.assign({}, u)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return bE = o() ? Object.assign : function(i, a) {
    for (var s, l = r(i), u, c = 1; c < arguments.length; c++) {
      s = Object(arguments[c]);
      for (var p in s)
        t.call(s, p) && (l[p] = s[p]);
      if (e) {
        u = e(s);
        for (var d = 0; d < u.length; d++)
          n.call(s, u[d]) && (l[u[d]] = s[u[d]]);
      }
    }
    return l;
  }, bE;
}
var wE, A2;
function ND() {
  if (A2) return wE;
  A2 = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return wE = e, wE;
}
var R2, I2;
function JQ() {
  return I2 || (I2 = 1, R2 = Function.call.bind(Object.prototype.hasOwnProperty)), R2;
}
var CE, N2;
function Y_e() {
  if (N2) return CE;
  N2 = 1;
  var e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = ND(), n = {}, r = JQ();
    e = function(i) {
      var a = "Warning: " + i;
      typeof console < "u" && console.error(a);
      try {
        throw new Error(a);
      } catch {
      }
    };
  }
  function o(i, a, s, l, u) {
    if (process.env.NODE_ENV !== "production") {
      for (var c in i)
        if (r(i, c)) {
          var p;
          try {
            if (typeof i[c] != "function") {
              var d = Error(
                (l || "React class") + ": " + s + " type `" + c + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof i[c] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw d.name = "Invariant Violation", d;
            }
            p = i[c](a, c, l, s, null, t);
          } catch (f) {
            p = f;
          }
          if (p && !(p instanceof Error) && e(
            (l || "React class") + ": type specification of " + s + " `" + c + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof p + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), p instanceof Error && !(p.message in n)) {
            n[p.message] = !0;
            var g = u ? u() : "";
            e(
              "Failed " + s + " type: " + p.message + (g ?? "")
            );
          }
        }
    }
  }
  return o.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (n = {});
  }, CE = o, CE;
}
var OE, B2;
function J_e() {
  if (B2) return OE;
  B2 = 1;
  var e = YQ(), t = X_e(), n = ND(), r = JQ(), o = Y_e(), i = function() {
  };
  process.env.NODE_ENV !== "production" && (i = function(s) {
    var l = "Warning: " + s;
    typeof console < "u" && console.error(l);
    try {
      throw new Error(l);
    } catch {
    }
  });
  function a() {
    return null;
  }
  return OE = function(s, l) {
    var u = typeof Symbol == "function" && Symbol.iterator, c = "@@iterator";
    function p(_) {
      var D = _ && (u && _[u] || _[c]);
      if (typeof D == "function")
        return D;
    }
    var d = "<<anonymous>>", g = {
      array: E("array"),
      bigint: E("bigint"),
      bool: E("boolean"),
      func: E("function"),
      number: E("number"),
      object: E("object"),
      string: E("string"),
      symbol: E("symbol"),
      any: w(),
      arrayOf: M,
      element: x(),
      elementType: v(),
      instanceOf: C,
      node: B(),
      objectOf: F,
      oneOf: P,
      oneOfType: L,
      shape: $,
      exact: V
    };
    function f(_, D) {
      return _ === D ? _ !== 0 || 1 / _ === 1 / D : _ !== _ && D !== D;
    }
    function m(_, D) {
      this.message = _, this.data = D && typeof D == "object" ? D : {}, this.stack = "";
    }
    m.prototype = Error.prototype;
    function b(_) {
      if (process.env.NODE_ENV !== "production")
        var D = {}, z = 0;
      function S(O, j, U, T, q, A, X) {
        if (T = T || d, A = A || U, X !== n) {
          if (l) {
            var I = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw I.name = "Invariant Violation", I;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var le = T + ":" + U;
            !D[le] && // Avoid spamming the console because they are often not actionable except for lib authors
            z < 3 && (i(
              "You are manually calling a React.PropTypes validation function for the `" + A + "` prop on `" + T + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), D[le] = !0, z++);
          }
        }
        return j[U] == null ? O ? j[U] === null ? new m("The " + q + " `" + A + "` is marked as required " + ("in `" + T + "`, but its value is `null`.")) : new m("The " + q + " `" + A + "` is marked as required in " + ("`" + T + "`, but its value is `undefined`.")) : null : _(j, U, T, q, A);
      }
      var W = S.bind(null, !1);
      return W.isRequired = S.bind(null, !0), W;
    }
    function E(_) {
      function D(z, S, W, O, j, U) {
        var T = z[S], q = K(T);
        if (q !== _) {
          var A = Y(T);
          return new m(
            "Invalid " + O + " `" + j + "` of type " + ("`" + A + "` supplied to `" + W + "`, expected ") + ("`" + _ + "`."),
            { expectedType: _ }
          );
        }
        return null;
      }
      return b(D);
    }
    function w() {
      return b(a);
    }
    function M(_) {
      function D(z, S, W, O, j) {
        if (typeof _ != "function")
          return new m("Property `" + j + "` of component `" + W + "` has invalid PropType notation inside arrayOf.");
        var U = z[S];
        if (!Array.isArray(U)) {
          var T = K(U);
          return new m("Invalid " + O + " `" + j + "` of type " + ("`" + T + "` supplied to `" + W + "`, expected an array."));
        }
        for (var q = 0; q < U.length; q++) {
          var A = _(U, q, W, O, j + "[" + q + "]", n);
          if (A instanceof Error)
            return A;
        }
        return null;
      }
      return b(D);
    }
    function x() {
      function _(D, z, S, W, O) {
        var j = D[z];
        if (!s(j)) {
          var U = K(j);
          return new m("Invalid " + W + " `" + O + "` of type " + ("`" + U + "` supplied to `" + S + "`, expected a single ReactElement."));
        }
        return null;
      }
      return b(_);
    }
    function v() {
      function _(D, z, S, W, O) {
        var j = D[z];
        if (!e.isValidElementType(j)) {
          var U = K(j);
          return new m("Invalid " + W + " `" + O + "` of type " + ("`" + U + "` supplied to `" + S + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return b(_);
    }
    function C(_) {
      function D(z, S, W, O, j) {
        if (!(z[S] instanceof _)) {
          var U = _.name || d, T = J(z[S]);
          return new m("Invalid " + O + " `" + j + "` of type " + ("`" + T + "` supplied to `" + W + "`, expected ") + ("instance of `" + U + "`."));
        }
        return null;
      }
      return b(D);
    }
    function P(_) {
      if (!Array.isArray(_))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? i(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : i("Invalid argument supplied to oneOf, expected an array.")), a;
      function D(z, S, W, O, j) {
        for (var U = z[S], T = 0; T < _.length; T++)
          if (f(U, _[T]))
            return null;
        var q = JSON.stringify(_, function(A, X) {
          var I = Y(X);
          return I === "symbol" ? String(X) : X;
        });
        return new m("Invalid " + O + " `" + j + "` of value `" + String(U) + "` " + ("supplied to `" + W + "`, expected one of " + q + "."));
      }
      return b(D);
    }
    function F(_) {
      function D(z, S, W, O, j) {
        if (typeof _ != "function")
          return new m("Property `" + j + "` of component `" + W + "` has invalid PropType notation inside objectOf.");
        var U = z[S], T = K(U);
        if (T !== "object")
          return new m("Invalid " + O + " `" + j + "` of type " + ("`" + T + "` supplied to `" + W + "`, expected an object."));
        for (var q in U)
          if (r(U, q)) {
            var A = _(U, q, W, O, j + "." + q, n);
            if (A instanceof Error)
              return A;
          }
        return null;
      }
      return b(D);
    }
    function L(_) {
      if (!Array.isArray(_))
        return process.env.NODE_ENV !== "production" && i("Invalid argument supplied to oneOfType, expected an instance of array."), a;
      for (var D = 0; D < _.length; D++) {
        var z = _[D];
        if (typeof z != "function")
          return i(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + Q(z) + " at index " + D + "."
          ), a;
      }
      function S(W, O, j, U, T) {
        for (var q = [], A = 0; A < _.length; A++) {
          var X = _[A], I = X(W, O, j, U, T, n);
          if (I == null)
            return null;
          I.data && r(I.data, "expectedType") && q.push(I.data.expectedType);
        }
        var le = q.length > 0 ? ", expected one of type [" + q.join(", ") + "]" : "";
        return new m("Invalid " + U + " `" + T + "` supplied to " + ("`" + j + "`" + le + "."));
      }
      return b(S);
    }
    function B() {
      function _(D, z, S, W, O) {
        return H(D[z]) ? null : new m("Invalid " + W + " `" + O + "` supplied to " + ("`" + S + "`, expected a ReactNode."));
      }
      return b(_);
    }
    function N(_, D, z, S, W) {
      return new m(
        (_ || "React class") + ": " + D + " type `" + z + "." + S + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + W + "`."
      );
    }
    function $(_) {
      function D(z, S, W, O, j) {
        var U = z[S], T = K(U);
        if (T !== "object")
          return new m("Invalid " + O + " `" + j + "` of type `" + T + "` " + ("supplied to `" + W + "`, expected `object`."));
        for (var q in _) {
          var A = _[q];
          if (typeof A != "function")
            return N(W, O, j, q, Y(A));
          var X = A(U, q, W, O, j + "." + q, n);
          if (X)
            return X;
        }
        return null;
      }
      return b(D);
    }
    function V(_) {
      function D(z, S, W, O, j) {
        var U = z[S], T = K(U);
        if (T !== "object")
          return new m("Invalid " + O + " `" + j + "` of type `" + T + "` " + ("supplied to `" + W + "`, expected `object`."));
        var q = t({}, z[S], _);
        for (var A in q) {
          var X = _[A];
          if (r(_, A) && typeof X != "function")
            return N(W, O, j, A, Y(X));
          if (!X)
            return new m(
              "Invalid " + O + " `" + j + "` key `" + A + "` supplied to `" + W + "`.\nBad object: " + JSON.stringify(z[S], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(_), null, "  ")
            );
          var I = X(U, A, W, O, j + "." + A, n);
          if (I)
            return I;
        }
        return null;
      }
      return b(D);
    }
    function H(_) {
      switch (typeof _) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !_;
        case "object":
          if (Array.isArray(_))
            return _.every(H);
          if (_ === null || s(_))
            return !0;
          var D = p(_);
          if (D) {
            var z = D.call(_), S;
            if (D !== _.entries) {
              for (; !(S = z.next()).done; )
                if (!H(S.value))
                  return !1;
            } else
              for (; !(S = z.next()).done; ) {
                var W = S.value;
                if (W && !H(W[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function Z(_, D) {
      return _ === "symbol" ? !0 : D ? D["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && D instanceof Symbol : !1;
    }
    function K(_) {
      var D = typeof _;
      return Array.isArray(_) ? "array" : _ instanceof RegExp ? "object" : Z(D, _) ? "symbol" : D;
    }
    function Y(_) {
      if (typeof _ > "u" || _ === null)
        return "" + _;
      var D = K(_);
      if (D === "object") {
        if (_ instanceof Date)
          return "date";
        if (_ instanceof RegExp)
          return "regexp";
      }
      return D;
    }
    function Q(_) {
      var D = Y(_);
      switch (D) {
        case "array":
        case "object":
          return "an " + D;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + D;
        default:
          return D;
      }
    }
    function J(_) {
      return !_.constructor || !_.constructor.name ? d : _.constructor.name;
    }
    return g.checkPropTypes = o, g.resetWarningCache = o.resetWarningCache, g.PropTypes = g, g;
  }, OE;
}
var xE, F2;
function Q_e() {
  if (F2) return xE;
  F2 = 1;
  var e = ND();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, xE = function() {
    function r(a, s, l, u, c, p) {
      if (p !== e) {
        var d = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw d.name = "Invariant Violation", d;
      }
    }
    r.isRequired = r;
    function o() {
      return r;
    }
    var i = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: o,
      element: r,
      elementType: r,
      instanceOf: o,
      node: r,
      objectOf: o,
      oneOf: o,
      oneOfType: o,
      shape: o,
      exact: o,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return i.PropTypes = i, i;
  }, xE;
}
if (process.env.NODE_ENV !== "production") {
  var ePe = YQ(), tPe = !0;
  N_.exports = J_e()(ePe.isElement, tPe);
} else
  N_.exports = Q_e()();
var rO = N_.exports, oO = {};
Object.defineProperty(oO, "__esModule", {
  value: !0
});
var nPe = rg, EE = rPe(nPe);
function rPe(e) {
  return e && e.__esModule ? e : { default: e };
}
var oPe = {
  mountFlag: !1,
  initialized: !1,
  scroller: null,
  containers: {},
  mount: function(e) {
    this.scroller = e, this.handleHashChange = this.handleHashChange.bind(this), window.addEventListener("hashchange", this.handleHashChange), this.initStateFromHash(), this.mountFlag = !0;
  },
  mapContainer: function(e, t) {
    this.containers[e] = t;
  },
  isMounted: function() {
    return this.mountFlag;
  },
  isInitialized: function() {
    return this.initialized;
  },
  initStateFromHash: function() {
    var e = this, t = this.getHash();
    t ? window.setTimeout(function() {
      e.scrollTo(t, !0), e.initialized = !0;
    }, 10) : this.initialized = !0;
  },
  scrollTo: function(e, t) {
    var n = this.scroller, r = n.get(e);
    if (r && (t || e !== n.getActiveLink())) {
      var o = this.containers[e] || document;
      n.scrollTo(e, { container: o });
    }
  },
  getHash: function() {
    return EE.default.getHash();
  },
  changeHash: function(e, t) {
    this.isInitialized() && EE.default.getHash() !== e && EE.default.updateHash(e, t);
  },
  handleHashChange: function() {
    this.scrollTo(this.getHash());
  },
  unmount: function() {
    this.scroller = null, this.containers = null, window.removeEventListener("hashchange", this.handleHashChange);
  }
};
oO.default = oPe;
Object.defineProperty(eg, "__esModule", {
  value: !0
});
var iv = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, iPe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), sPe = be, z2 = sg(sPe), aPe = tg, sv = sg(aPe), lPe = zp, uPe = sg(lPe), cPe = rO, qr = sg(cPe), pPe = oO, ml = sg(pPe);
function sg(e) {
  return e && e.__esModule ? e : { default: e };
}
function dPe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function fPe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function hPe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var U2 = {
  to: qr.default.string.isRequired,
  containerId: qr.default.string,
  container: qr.default.object,
  activeClass: qr.default.string,
  activeStyle: qr.default.object,
  spy: qr.default.bool,
  horizontal: qr.default.bool,
  smooth: qr.default.oneOfType([qr.default.bool, qr.default.string]),
  offset: qr.default.number,
  delay: qr.default.number,
  isDynamic: qr.default.bool,
  onClick: qr.default.func,
  duration: qr.default.oneOfType([qr.default.number, qr.default.func]),
  absolute: qr.default.bool,
  onSetActive: qr.default.func,
  onSetInactive: qr.default.func,
  ignoreCancelEvents: qr.default.bool,
  hashSpy: qr.default.bool,
  saveHashHistory: qr.default.bool,
  spyThrottle: qr.default.number
};
eg.default = function(e, t) {
  var n = t || uPe.default, r = function(i) {
    hPe(a, i);
    function a(s) {
      dPe(this, a);
      var l = fPe(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
      return o.call(l), l.state = {
        active: !1
      }, l.beforeUnmountCallbacks = [], l;
    }
    return iPe(a, [{
      key: "getScrollSpyContainer",
      value: function() {
        var s = this.props.containerId, l = this.props.container;
        return s && !l ? document.getElementById(s) : l && l.nodeType ? l : document;
      }
    }, {
      key: "componentDidMount",
      value: function() {
        if (this.props.spy || this.props.hashSpy) {
          var s = this.getScrollSpyContainer();
          if (!sv.default.isMounted(s)) {
            var l = sv.default.mount(s, this.props.spyThrottle);
            this.beforeUnmountCallbacks.push(l);
          }
          this.props.hashSpy && (ml.default.isMounted() || ml.default.mount(n), ml.default.mapContainer(this.props.to, s)), sv.default.addSpyHandler(this.spyHandler, s), this.setState({
            container: s
          });
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        sv.default.unmount(this.stateHandler, this.spyHandler), this.beforeUnmountCallbacks.forEach(function(s) {
          return s();
        });
      }
    }, {
      key: "render",
      value: function() {
        var s = "";
        this.state && this.state.active ? s = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : s = this.props.className;
        var l = {};
        this.state && this.state.active ? l = iv({}, this.props.style, this.props.activeStyle) : l = iv({}, this.props.style);
        var u = iv({}, this.props);
        for (var c in U2)
          u.hasOwnProperty(c) && delete u[c];
        return u.className = s, u.style = l, u.onClick = this.handleClick, z2.default.createElement(e, u);
      }
    }]), a;
  }(z2.default.PureComponent), o = function() {
    var i = this;
    this.scrollTo = function(a, s) {
      n.scrollTo(a, iv({}, i.state, s));
    }, this.handleClick = function(a) {
      i.props.onClick && i.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), i.scrollTo(i.props.to, i.props);
    }, this.spyHandler = function(a, s) {
      var l = i.getScrollSpyContainer();
      if (!(ml.default.isMounted() && !ml.default.isInitialized())) {
        var u = i.props.horizontal, c = i.props.to, p = null, d = void 0, g = void 0;
        if (u) {
          var f = 0, m = 0, b = 0;
          if (l.getBoundingClientRect) {
            var E = l.getBoundingClientRect();
            b = E.left;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var w = p.getBoundingClientRect();
            f = w.left - b + a, m = f + w.width;
          }
          var M = a - i.props.offset;
          d = M >= Math.floor(f) && M < Math.floor(m), g = M < Math.floor(f) || M >= Math.floor(m);
        } else {
          var x = 0, v = 0, C = 0;
          if (l.getBoundingClientRect) {
            var P = l.getBoundingClientRect();
            C = P.top;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var F = p.getBoundingClientRect();
            x = F.top - C + s, v = x + F.height;
          }
          var L = s - i.props.offset;
          d = L >= Math.floor(x) && L < Math.floor(v), g = L < Math.floor(x) || L >= Math.floor(v);
        }
        var B = n.getActiveLink();
        if (g) {
          if (c === B && n.setActiveLink(void 0), i.props.hashSpy && ml.default.getHash() === c) {
            var N = i.props.saveHashHistory, $ = N === void 0 ? !1 : N;
            ml.default.changeHash("", $);
          }
          i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive(c, p));
        }
        if (d && (B !== c || i.state.active === !1)) {
          n.setActiveLink(c);
          var V = i.props.saveHashHistory, H = V === void 0 ? !1 : V;
          i.props.hashSpy && ml.default.changeHash(c, H), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(c, p));
        }
      }
    };
  };
  return r.propTypes = U2, r.defaultProps = { offset: 0 }, r;
};
Object.defineProperty(TD, "__esModule", {
  value: !0
});
var gPe = be, H2 = QQ(gPe), mPe = eg, vPe = QQ(mPe);
function QQ(e) {
  return e && e.__esModule ? e : { default: e };
}
function yPe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function W2(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function bPe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var wPe = function(e) {
  bPe(t, e);
  function t() {
    var n, r, o, i;
    yPe(this, t);
    for (var a = arguments.length, s = Array(a), l = 0; l < a; l++)
      s[l] = arguments[l];
    return i = (r = (o = W2(this, (n = t.__proto__ || Object.getPrototypeOf(t)).call.apply(n, [this].concat(s))), o), o.render = function() {
      return H2.default.createElement(
        "a",
        o.props,
        o.props.children
      );
    }, r), W2(o, i);
  }
  return t;
}(H2.default.Component);
TD.default = (0, vPe.default)(wPe);
var BD = {};
Object.defineProperty(BD, "__esModule", {
  value: !0
});
var CPe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), OPe = be, $2 = eee(OPe), xPe = eg, EPe = eee(xPe);
function eee(e) {
  return e && e.__esModule ? e : { default: e };
}
function kPe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function LPe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function _Pe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var PPe = function(e) {
  _Pe(t, e);
  function t() {
    return kPe(this, t), LPe(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return CPe(t, [{
    key: "render",
    value: function() {
      return $2.default.createElement(
        "button",
        this.props,
        this.props.children
      );
    }
  }]), t;
}($2.default.Component);
BD.default = (0, EPe.default)(PPe);
var FD = {}, iO = {};
Object.defineProperty(iO, "__esModule", {
  value: !0
});
var SPe = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, MPe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), DPe = be, V2 = sO(DPe), TPe = il;
sO(TPe);
var jPe = zp, Z2 = sO(jPe), APe = rO, q2 = sO(APe);
function sO(e) {
  return e && e.__esModule ? e : { default: e };
}
function RPe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function IPe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function NPe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
iO.default = function(e) {
  var t = function(n) {
    NPe(r, n);
    function r(o) {
      RPe(this, r);
      var i = IPe(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
      return i.childBindings = {
        domNode: null
      }, i;
    }
    return MPe(r, [{
      key: "componentDidMount",
      value: function() {
        if (typeof window > "u")
          return !1;
        this.registerElems(this.props.name);
      }
    }, {
      key: "componentDidUpdate",
      value: function(o) {
        this.props.name !== o.name && this.registerElems(this.props.name);
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        if (typeof window > "u")
          return !1;
        Z2.default.unregister(this.props.name);
      }
    }, {
      key: "registerElems",
      value: function(o) {
        Z2.default.register(o, this.childBindings.domNode);
      }
    }, {
      key: "render",
      value: function() {
        return V2.default.createElement(e, SPe({}, this.props, { parentBindings: this.childBindings }));
      }
    }]), r;
  }(V2.default.Component);
  return t.propTypes = {
    name: q2.default.string,
    id: q2.default.string
  }, t;
};
Object.defineProperty(FD, "__esModule", {
  value: !0
});
var G2 = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, BPe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), FPe = be, K2 = zD(FPe), zPe = iO, UPe = zD(zPe), HPe = rO, X2 = zD(HPe);
function zD(e) {
  return e && e.__esModule ? e : { default: e };
}
function WPe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function $Pe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function VPe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var tee = function(e) {
  VPe(t, e);
  function t() {
    return WPe(this, t), $Pe(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return BPe(t, [{
    key: "render",
    value: function() {
      var n = this, r = G2({}, this.props);
      return delete r.name, r.parentBindings && delete r.parentBindings, K2.default.createElement(
        "div",
        G2({}, r, { ref: function(o) {
          n.props.parentBindings.domNode = o;
        } }),
        this.props.children
      );
    }
  }]), t;
}(K2.default.Component);
tee.propTypes = {
  name: X2.default.string,
  id: X2.default.string
};
FD.default = (0, UPe.default)(tee);
var kE = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, Y2 = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}();
function J2(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Q2(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function eU(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var av = be, Ru = tg, LE = zp, bo = rO, vl = oO, tU = {
  to: bo.string.isRequired,
  containerId: bo.string,
  container: bo.object,
  activeClass: bo.string,
  spy: bo.bool,
  smooth: bo.oneOfType([bo.bool, bo.string]),
  offset: bo.number,
  delay: bo.number,
  isDynamic: bo.bool,
  onClick: bo.func,
  duration: bo.oneOfType([bo.number, bo.func]),
  absolute: bo.bool,
  onSetActive: bo.func,
  onSetInactive: bo.func,
  ignoreCancelEvents: bo.bool,
  hashSpy: bo.bool,
  spyThrottle: bo.number
}, ZPe = {
  Scroll: function(e, t) {
    console.warn("Helpers.Scroll is deprecated since v1.7.0");
    var n = t || LE, r = function(i) {
      eU(a, i);
      function a(s) {
        J2(this, a);
        var l = Q2(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
        return o.call(l), l.state = {
          active: !1
        }, l;
      }
      return Y2(a, [{
        key: "getScrollSpyContainer",
        value: function() {
          var s = this.props.containerId, l = this.props.container;
          return s ? document.getElementById(s) : l && l.nodeType ? l : document;
        }
      }, {
        key: "componentDidMount",
        value: function() {
          if (this.props.spy || this.props.hashSpy) {
            var s = this.getScrollSpyContainer();
            Ru.isMounted(s) || Ru.mount(s, this.props.spyThrottle), this.props.hashSpy && (vl.isMounted() || vl.mount(n), vl.mapContainer(this.props.to, s)), this.props.spy && Ru.addStateHandler(this.stateHandler), Ru.addSpyHandler(this.spyHandler, s), this.setState({
              container: s
            });
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          Ru.unmount(this.stateHandler, this.spyHandler);
        }
      }, {
        key: "render",
        value: function() {
          var s = "";
          this.state && this.state.active ? s = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : s = this.props.className;
          var l = kE({}, this.props);
          for (var u in tU)
            l.hasOwnProperty(u) && delete l[u];
          return l.className = s, l.onClick = this.handleClick, av.createElement(e, l);
        }
      }]), a;
    }(av.Component), o = function() {
      var i = this;
      this.scrollTo = function(a, s) {
        n.scrollTo(a, kE({}, i.state, s));
      }, this.handleClick = function(a) {
        i.props.onClick && i.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), i.scrollTo(i.props.to, i.props);
      }, this.stateHandler = function() {
        n.getActiveLink() !== i.props.to && (i.state !== null && i.state.active && i.props.onSetInactive && i.props.onSetInactive(), i.setState({ active: !1 }));
      }, this.spyHandler = function(a) {
        var s = i.getScrollSpyContainer();
        if (!(vl.isMounted() && !vl.isInitialized())) {
          var l = i.props.to, u = null, c = 0, p = 0, d = 0;
          if (s.getBoundingClientRect) {
            var g = s.getBoundingClientRect();
            d = g.top;
          }
          if (!u || i.props.isDynamic) {
            if (u = n.get(l), !u)
              return;
            var f = u.getBoundingClientRect();
            c = f.top - d + a, p = c + f.height;
          }
          var m = a - i.props.offset, b = m >= Math.floor(c) && m < Math.floor(p), E = m < Math.floor(c) || m >= Math.floor(p), w = n.getActiveLink();
          if (E)
            return l === w && n.setActiveLink(void 0), i.props.hashSpy && vl.getHash() === l && vl.changeHash(), i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive()), Ru.updateStates();
          if (b && w !== l)
            return n.setActiveLink(l), i.props.hashSpy && vl.changeHash(l), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(l)), Ru.updateStates();
        }
      };
    };
    return r.propTypes = tU, r.defaultProps = { offset: 0 }, r;
  },
  Element: function(e) {
    console.warn("Helpers.Element is deprecated since v1.7.0");
    var t = function(n) {
      eU(r, n);
      function r(o) {
        J2(this, r);
        var i = Q2(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
        return i.childBindings = {
          domNode: null
        }, i;
      }
      return Y2(r, [{
        key: "componentDidMount",
        value: function() {
          if (typeof window > "u")
            return !1;
          this.registerElems(this.props.name);
        }
      }, {
        key: "componentDidUpdate",
        value: function(o) {
          this.props.name !== o.name && this.registerElems(this.props.name);
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          if (typeof window > "u")
            return !1;
          LE.unregister(this.props.name);
        }
      }, {
        key: "registerElems",
        value: function(o) {
          LE.register(o, this.childBindings.domNode);
        }
      }, {
        key: "render",
        value: function() {
          return av.createElement(e, kE({}, this.props, { parentBindings: this.childBindings }));
        }
      }]), r;
    }(av.Component);
    return t.propTypes = {
      name: bo.string,
      id: bo.string
    }, t;
  }
}, qPe = ZPe;
Object.defineProperty(Ao, "__esModule", {
  value: !0
});
Ao.Helpers = Ao.ScrollElement = Ao.ScrollLink = Ao.animateScroll = Ao.scrollSpy = Ao.Events = Ao.scroller = Ao.Element = Ao.Button = Ao.Link = void 0;
var GPe = TD, nee = ya(GPe), KPe = BD, ree = ya(KPe), XPe = FD, oee = ya(XPe), YPe = zp, iee = ya(YPe), JPe = og, see = ya(JPe), QPe = tg, aee = ya(QPe), eSe = eO, lee = ya(eSe), tSe = eg, uee = ya(tSe), nSe = iO, cee = ya(nSe), rSe = qPe, pee = ya(rSe);
function ya(e) {
  return e && e.__esModule ? e : { default: e };
}
Ao.Link = nee.default;
Ao.Button = ree.default;
Ao.Element = oee.default;
Ao.scroller = iee.default;
Ao.Events = see.default;
Ao.scrollSpy = aee.default;
Ao.animateScroll = lee.default;
Ao.ScrollLink = uee.default;
Ao.ScrollElement = cee.default;
Ao.Helpers = pee.default;
Ao.default = { Link: nee.default, Button: ree.default, Element: oee.default, scroller: iee.default, Events: see.default, scrollSpy: aee.default, animateScroll: lee.default, ScrollLink: uee.default, ScrollElement: cee.default, Helpers: pee.default };
$e({});
$e({});
$e({});
function Mh(e) {
  "@babel/helpers - typeof";
  return Mh = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Mh(e);
}
function oSe(e, t) {
  if (Mh(e) != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (Mh(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function iSe(e) {
  var t = oSe(e, "string");
  return Mh(t) == "symbol" ? t : t + "";
}
function _e(e, t, n) {
  return (t = iSe(t)) in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function dee(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var _E, nU;
function sSe() {
  if (nU) return _E;
  nU = 1;
  var e = process.env.NODE_ENV, t = function(n, r, o, i, a, s, l, u) {
    if (e !== "production" && r === void 0)
      throw new Error("invariant requires an error message argument");
    if (!n) {
      var c;
      if (r === void 0)
        c = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
      else {
        var p = [o, i, a, s, l, u], d = 0;
        c = new Error(r.replace(/%s/g, function() {
          return p[d++];
        })), c.name = "Invariant Violation";
      }
      throw c.framesToPop = 1, c;
    }
  };
  return _E = t, _E;
}
var aSe = sSe(), Ho = /* @__PURE__ */ dee(aSe), It = $e(null);
function lSe() {
  Ho(!!ge, "useGoogleMap is React hook and requires React version 16.8+");
  var e = ge(It);
  return Ho(!!e, "useGoogleMap needs a GoogleMap available up in the tree"), e;
}
function uSe(e, t, n) {
  return Object.keys(e).reduce(function(r, o) {
    return t(r, e[o], o);
  }, n);
}
function cSe(e, t) {
  Object.keys(e).forEach((n) => t(e[n], n));
}
function pSe(e, t, n, r) {
  var o = {}, i = (a, s) => {
    var l = n[s];
    l !== t[s] && (o[s] = l, a(r, l));
  };
  return cSe(e, i), o;
}
function dSe(e, t, n) {
  var r = uSe(n, function(o, i, a) {
    return typeof e[a] == "function" && o.push(google.maps.event.addListener(t, i, e[a])), o;
  }, []);
  return r;
}
function fSe(e) {
  google.maps.event.removeListener(e);
}
function kn() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  e.forEach(fSe);
}
function yn(e) {
  var {
    updaterMap: t,
    eventMap: n,
    prevProps: r,
    nextProps: o,
    instance: i
  } = e, a = dSe(o, i, n);
  return pSe(t, r, o, i), a;
}
function hSe(e) {
  var {
    children: t,
    options: n,
    id: r,
    mapContainerStyle: o,
    mapContainerClassName: i,
    center: a,
    // clickableIcons,
    // extraMapTypes,
    // heading,
    // mapTypeId,
    onClick: s,
    onDblClick: l,
    onDrag: u,
    onDragEnd: c,
    onDragStart: p,
    onMouseMove: d,
    onMouseOut: g,
    onMouseOver: f,
    onMouseDown: m,
    onMouseUp: b,
    onRightClick: E,
    // onMapTypeIdChanged,
    // onTilesLoaded,
    // onBoundsChanged,
    onCenterChanged: w,
    // onHeadingChanged,
    // onIdle,
    // onProjectionChanged,
    // onResize,
    // onTiltChanged,
    // onZoomChanged,
    onLoad: M,
    onUnmount: x
  } = e, [v, C] = k(null), P = dt(null), [F, L] = k(null), [B, N] = k(null), [$, V] = k(null), [H, Z] = k(null), [K, Y] = k(null), [Q, J] = k(null), [_, D] = k(null), [z, S] = k(null), [W, O] = k(null), [j, U] = k(null), [T, q] = k(null), [A, X] = k(null);
  return h(() => {
    n && v !== null && v.setOptions(n);
  }, [v, n]), h(() => {
    v !== null && typeof a < "u" && v.setCenter(a);
  }, [v, a]), h(() => {
    v && l && (B !== null && google.maps.event.removeListener(B), N(google.maps.event.addListener(v, "dblclick", l)));
  }, [l]), h(() => {
    v && c && ($ !== null && google.maps.event.removeListener($), V(google.maps.event.addListener(v, "dragend", c)));
  }, [c]), h(() => {
    v && p && (H !== null && google.maps.event.removeListener(H), Z(google.maps.event.addListener(v, "dragstart", p)));
  }, [p]), h(() => {
    v && m && (K !== null && google.maps.event.removeListener(K), Y(google.maps.event.addListener(v, "mousedown", m)));
  }, [m]), h(() => {
    v && d && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(v, "mousemove", d)));
  }, [d]), h(() => {
    v && g && (_ !== null && google.maps.event.removeListener(_), D(google.maps.event.addListener(v, "mouseout", g)));
  }, [g]), h(() => {
    v && f && (z !== null && google.maps.event.removeListener(z), S(google.maps.event.addListener(v, "mouseover", f)));
  }, [f]), h(() => {
    v && b && (W !== null && google.maps.event.removeListener(W), O(google.maps.event.addListener(v, "mouseup", b)));
  }, [b]), h(() => {
    v && E && (j !== null && google.maps.event.removeListener(j), U(google.maps.event.addListener(v, "rightclick", E)));
  }, [E]), h(() => {
    v && s && (T !== null && google.maps.event.removeListener(T), q(google.maps.event.addListener(v, "click", s)));
  }, [s]), h(() => {
    v && u && (A !== null && google.maps.event.removeListener(A), X(google.maps.event.addListener(v, "drag", u)));
  }, [u]), h(() => {
    v && w && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(v, "center_changed", w)));
  }, [s]), h(() => {
    var I = P.current === null ? null : new google.maps.Map(P.current, n);
    return C(I), I !== null && M && M(I), () => {
      I !== null && x && x(I);
    };
  }, []), ti.jsx("div", {
    id: r,
    ref: P,
    style: o,
    className: i,
    children: ti.jsx(It.Provider, {
      value: v,
      children: v !== null ? t : null
    })
  });
}
me(hSe);
function rU(e, t, n, r, o, i, a) {
  try {
    var s = e[i](a), l = s.value;
  } catch (u) {
    return void n(u);
  }
  s.done ? t(l) : Promise.resolve(l).then(r, o);
}
function fee(e) {
  return function() {
    var t = this, n = arguments;
    return new Promise(function(r, o) {
      var i = e.apply(t, n);
      function a(l) {
        rU(i, r, o, a, s, "next", l);
      }
      function s(l) {
        rU(i, r, o, a, s, "throw", l);
      }
      a(void 0);
    });
  };
}
function hee(e) {
  var {
    googleMapsApiKey: t,
    googleMapsClientId: n,
    version: r = "weekly",
    language: o,
    region: i,
    libraries: a,
    channel: s,
    mapIds: l,
    authReferrerPolicy: u
  } = e, c = [];
  return Ho(t && n || !(t && n), "You need to specify either googleMapsApiKey or googleMapsClientId for @react-google-maps/api load script to work. You cannot use both at the same time."), t ? c.push("key=".concat(t)) : n && c.push("client=".concat(n)), r && c.push("v=".concat(r)), o && c.push("language=".concat(o)), i && c.push("region=".concat(i)), a && a.length && c.push("libraries=".concat(a.sort().join(","))), s && c.push("channel=".concat(s)), l && l.length && c.push("map_ids=".concat(l.join(","))), u && c.push("auth_referrer_policy=".concat(u)), c.push("loading=async"), c.push("callback=initMap"), "https://maps.googleapis.com/maps/api/js?".concat(c.join("&"));
}
var hc = typeof document < "u";
function gee(e) {
  var {
    url: t,
    id: n,
    nonce: r
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } = e;
  return hc ? new Promise(function(o, i) {
    var a = document.getElementById(n), s = window;
    if (a) {
      var l = a.getAttribute("data-state");
      if (a.src === t && l !== "error") {
        if (l === "ready")
          return o(n);
        var u = s.initMap, c = a.onerror;
        s.initMap = function() {
          u && u(), o(n);
        }, a.onerror = function(d) {
          c && c(d), i(d);
        };
        return;
      } else
        a.remove();
    }
    var p = document.createElement("script");
    p.type = "text/javascript", p.src = t, p.id = n, p.async = !0, p.nonce = r || "", p.onerror = function(d) {
      p.setAttribute("data-state", "error"), i(d);
    }, s.initMap = function() {
      p.setAttribute("data-state", "ready"), o(n);
    }, document.head.appendChild(p);
  }).catch((o) => {
    throw console.error("injectScript error: ", o), o;
  }) : Promise.reject(new Error("document is undefined"));
}
function oU(e) {
  var t = e.href;
  return t && (t.indexOf("https://fonts.googleapis.com/css?family=Roboto") === 0 || t.indexOf("https://fonts.googleapis.com/css?family=Google+Sans+Text") === 0) ? !0 : (
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.styleSheet.cssText = "", !0) : (
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.innerHTML = "", !0) : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.innerHTML
      )
    )
  );
}
function mee() {
  var e = document.getElementsByTagName("head")[0];
  if (e) {
    var t = e.insertBefore.bind(e);
    e.insertBefore = function(r, o) {
      return oU(r) || Reflect.apply(t, e, [r, o]), r;
    };
    var n = e.appendChild.bind(e);
    e.appendChild = function(r) {
      return oU(r) || Reflect.apply(n, e, [r]), r;
    };
  }
}
var wd = !1;
function vee() {
  return ti.jsx("div", {
    children: "Loading..."
  });
}
var B_ = {
  id: "script-loader",
  version: "weekly"
};
class gSe extends pe {
  constructor() {
    super(...arguments), _e(this, "check", null), _e(this, "state", {
      loaded: !1
    }), _e(this, "cleanupCallback", () => {
      delete window.google.maps, this.injectScript();
    }), _e(this, "isCleaningUp", /* @__PURE__ */ fee(function* () {
      function t(n) {
        if (!wd)
          n();
        else if (hc)
          var r = window.setInterval(function() {
            wd || (window.clearInterval(r), n());
          }, 1);
      }
      return new Promise(t);
    })), _e(this, "cleanup", () => {
      wd = !0;
      var t = document.getElementById(this.props.id);
      t && t.parentNode && t.parentNode.removeChild(t), Array.prototype.slice.call(document.getElementsByTagName("script")).filter(function(n) {
        return typeof n.src == "string" && n.src.includes("maps.googleapis");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("link")).filter(function(n) {
        return n.href === "https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Google+Sans";
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("style")).filter(function(n) {
        return n.innerText !== void 0 && n.innerText.length > 0 && n.innerText.includes(".gm-");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      });
    }), _e(this, "injectScript", () => {
      this.props.preventGoogleFontsLoading && mee(), Ho(!!this.props.id, 'LoadScript requires "id" prop to be a string: %s', this.props.id);
      var t = {
        id: this.props.id,
        nonce: this.props.nonce,
        url: hee(this.props)
      };
      gee(t).then(() => {
        this.props.onLoad && this.props.onLoad(), this.setState(function() {
          return {
            loaded: !0
          };
        });
      }).catch((n) => {
        this.props.onError && this.props.onError(n), console.error(`
          There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(this.props.googleMapsApiKey || "-", ") or Client ID (").concat(this.props.googleMapsClientId || "-", `) to <LoadScript />
          Otherwise it is a Network issue.
        `));
      });
    }), _e(this, "getRef", (t) => {
      this.check = t;
    });
  }
  componentDidMount() {
    if (hc) {
      if (window.google && window.google.maps && !wd) {
        console.error("google api is already presented");
        return;
      }
      this.isCleaningUp().then(this.injectScript).catch(function(t) {
        console.error("Error at injecting script after cleaning up: ", t);
      });
    }
  }
  componentDidUpdate(t) {
    this.props.libraries !== t.libraries && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), hc && t.language !== this.props.language && (this.cleanup(), this.setState(function() {
      return {
        loaded: !1
      };
    }, this.cleanupCallback));
  }
  componentWillUnmount() {
    if (hc) {
      this.cleanup();
      var t = () => {
        this.check || (delete window.google, wd = !1);
      };
      window.setTimeout(t, 1), this.props.onUnmount && this.props.onUnmount();
    }
  }
  render() {
    return ti.jsxs(ti.Fragment, {
      children: [ti.jsx("div", {
        ref: this.getRef
      }), this.state.loaded ? this.props.children : this.props.loadingElement || ti.jsx(vee, {})]
    });
  }
}
_e(gSe, "defaultProps", B_);
function mSe(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.includes(r)) continue;
    n[r] = e[r];
  }
  return n;
}
function UD(e, t) {
  if (e == null) return {};
  var n, r, o = mSe(e, t);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (r = 0; r < i.length; r++) n = i[r], t.includes(n) || {}.propertyIsEnumerable.call(e, n) && (o[n] = e[n]);
  }
  return o;
}
var iU;
function vSe(e) {
  var {
    id: t = B_.id,
    version: n = B_.version,
    nonce: r,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    preventGoogleFontsLoading: u,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  } = e, g = dt(!1), [f, m] = k(!1), [b, E] = k(void 0);
  h(function() {
    return g.current = !0, () => {
      g.current = !1;
    };
  }, []), h(function() {
    hc && u && mee();
  }, [u]), h(function() {
    f && Ho(!!window.google, "useLoadScript was marked as loaded, but window.google is not present. Something went wrong.");
  }, [f]);
  var w = hee({
    version: n,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  });
  h(function() {
    if (!hc)
      return;
    function x() {
      g.current && (m(!0), iU = w);
    }
    if (window.google && window.google.maps && iU === w) {
      x();
      return;
    }
    gee({
      id: t,
      url: w,
      nonce: r
    }).then(x).catch(function(v) {
      g.current && E(v), console.warn(`
        There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(o || "-", ") or Client ID (").concat(i || "-", `)
        Otherwise it is a Network issue.
      `)), console.error(v);
    });
  }, [t, w, r]);
  var M = dt(void 0);
  return h(function() {
    M.current && l !== M.current && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), M.current = l;
  }, [l]), {
    isLoaded: f,
    loadError: b,
    url: w
  };
}
var ySe = ["loadingElement", "onLoad", "onError", "onUnmount", "children"], bSe = ti.jsx(vee, {});
function wSe(e) {
  var {
    loadingElement: t,
    onLoad: n,
    onError: r,
    onUnmount: o,
    children: i
  } = e, a = UD(e, ySe), {
    isLoaded: s,
    loadError: l
  } = vSe(a);
  return h(function() {
    s && typeof n == "function" && n();
  }, [s, n]), h(function() {
    l && typeof r == "function" && r(l);
  }, [l, r]), h(function() {
    return () => {
      o && o();
    };
  }, [o]), s ? i : t || bSe;
}
me(wSe);
var sU;
(function(e) {
  e[e.INITIALIZED = 0] = "INITIALIZED", e[e.LOADING = 1] = "LOADING", e[e.SUCCESS = 2] = "SUCCESS", e[e.FAILURE = 3] = "FAILURE";
})(sU || (sU = {}));
function aU(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function zb(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? aU(Object(n), !0).forEach(function(r) {
      _e(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : aU(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var lU = {}, uU = {
  options(e, t) {
    e.setOptions(t);
  }
};
function CSe(e) {
  var {
    options: t,
    onLoad: n,
    onUnmount: r
  } = e, o = ge(It), [i, a] = k(null);
  return h(() => {
    i !== null && i.setMap(o);
  }, [o]), h(() => {
    t && i !== null && i.setOptions(t);
  }, [i, t]), h(() => {
    var s = new google.maps.TrafficLayer(zb(zb({}, t), {}, {
      map: o
    }));
    return a(s), n && n(s), () => {
      i !== null && (r && r(i), i.setMap(null));
    };
  }, []), null;
}
me(CSe);
class OSe extends pe {
  constructor() {
    super(...arguments), _e(this, "state", {
      trafficLayer: null
    }), _e(this, "setTrafficLayerCallback", () => {
      this.state.trafficLayer !== null && this.props.onLoad && this.props.onLoad(this.state.trafficLayer);
    }), _e(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = new google.maps.TrafficLayer(zb(zb({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = yn({
      updaterMap: uU,
      eventMap: lU,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        trafficLayer: t
      };
    }, this.setTrafficLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.trafficLayer !== null && (kn(this.registeredEvents), this.registeredEvents = yn({
      updaterMap: uU,
      eventMap: lU,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.trafficLayer
    }));
  }
  componentWillUnmount() {
    this.state.trafficLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.trafficLayer), kn(this.registeredEvents), this.state.trafficLayer.setMap(null));
  }
  render() {
    return null;
  }
}
_e(OSe, "contextType", It);
function xSe(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = ge(It), [o, i] = k(null);
  return h(() => {
    o !== null && o.setMap(r);
  }, [r]), h(() => {
    var a = new google.maps.BicyclingLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      a !== null && (n && n(a), a.setMap(null));
    };
  }, []), null;
}
me(xSe);
class ESe extends pe {
  constructor() {
    super(...arguments), _e(this, "state", {
      bicyclingLayer: null
    }), _e(this, "setBicyclingLayerCallback", () => {
      this.state.bicyclingLayer !== null && (this.state.bicyclingLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.bicyclingLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.BicyclingLayer();
    this.setState(() => ({
      bicyclingLayer: t
    }), this.setBicyclingLayerCallback);
  }
  componentWillUnmount() {
    this.state.bicyclingLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.bicyclingLayer), this.state.bicyclingLayer.setMap(null));
  }
  render() {
    return null;
  }
}
_e(ESe, "contextType", It);
function kSe(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = ge(It), [o, i] = k(null);
  return h(() => {
    o !== null && o.setMap(r);
  }, [r]), h(() => {
    var a = new google.maps.TransitLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      o !== null && (n && n(o), o.setMap(null));
    };
  }, []), null;
}
me(kSe);
class LSe extends pe {
  constructor() {
    super(...arguments), _e(this, "state", {
      transitLayer: null
    }), _e(this, "setTransitLayerCallback", () => {
      this.state.transitLayer !== null && (this.state.transitLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.transitLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.TransitLayer();
    this.setState(function() {
      return {
        transitLayer: t
      };
    }, this.setTransitLayerCallback);
  }
  componentWillUnmount() {
    this.state.transitLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.transitLayer), this.state.transitLayer.setMap(null));
  }
  render() {
    return null;
  }
}
_e(LSe, "contextType", It);
function cU(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Ub(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? cU(Object(n), !0).forEach(function(r) {
      _e(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : cU(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var pU = {
  onCircleComplete: "circlecomplete",
  onMarkerComplete: "markercomplete",
  onOverlayComplete: "overlaycomplete",
  onPolygonComplete: "polygoncomplete",
  onPolylineComplete: "polylinecomplete",
  onRectangleComplete: "rectanglecomplete"
}, dU = {
  drawingMode(e, t) {
    e.setDrawingMode(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function _Se(e) {
  var {
    options: t,
    drawingMode: n,
    onCircleComplete: r,
    onMarkerComplete: o,
    onOverlayComplete: i,
    onPolygonComplete: a,
    onPolylineComplete: s,
    onRectangleComplete: l,
    onLoad: u,
    onUnmount: c
  } = e, p = ge(It), [d, g] = k(null), [f, m] = k(null), [b, E] = k(null), [w, M] = k(null), [x, v] = k(null), [C, P] = k(null), [F, L] = k(null);
  return h(() => {
    d !== null && d.setMap(p);
  }, [p]), h(() => {
    t && d !== null && d.setOptions(t);
  }, [d, t]), h(() => {
    d !== null && d.setDrawingMode(n ?? null);
  }, [d, n]), h(() => {
    d && r && (f !== null && google.maps.event.removeListener(f), m(google.maps.event.addListener(d, "circlecomplete", r)));
  }, [d, r]), h(() => {
    d && o && (b !== null && google.maps.event.removeListener(b), E(google.maps.event.addListener(d, "markercomplete", o)));
  }, [d, o]), h(() => {
    d && i && (w !== null && google.maps.event.removeListener(w), M(google.maps.event.addListener(d, "overlaycomplete", i)));
  }, [d, i]), h(() => {
    d && a && (x !== null && google.maps.event.removeListener(x), v(google.maps.event.addListener(d, "polygoncomplete", a)));
  }, [d, a]), h(() => {
    d && s && (C !== null && google.maps.event.removeListener(C), P(google.maps.event.addListener(d, "polylinecomplete", s)));
  }, [d, s]), h(() => {
    d && l && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(d, "rectanglecomplete", l)));
  }, [d, l]), h(() => {
    Ho(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
    var B = new google.maps.drawing.DrawingManager(Ub(Ub({}, t), {}, {
      map: p
    }));
    return n && B.setDrawingMode(n), r && m(google.maps.event.addListener(B, "circlecomplete", r)), o && E(google.maps.event.addListener(B, "markercomplete", o)), i && M(google.maps.event.addListener(B, "overlaycomplete", i)), a && v(google.maps.event.addListener(B, "polygoncomplete", a)), s && P(google.maps.event.addListener(B, "polylinecomplete", s)), l && L(google.maps.event.addListener(B, "rectanglecomplete", l)), g(B), u && u(B), () => {
      d !== null && (f && google.maps.event.removeListener(f), b && google.maps.event.removeListener(b), w && google.maps.event.removeListener(w), x && google.maps.event.removeListener(x), C && google.maps.event.removeListener(C), F && google.maps.event.removeListener(F), c && c(d), d.setMap(null));
    };
  }, []), null;
}
me(_Se);
class PSe extends pe {
  constructor(t) {
    super(t), _e(this, "registeredEvents", []), _e(this, "state", {
      drawingManager: null
    }), _e(this, "setDrawingManagerCallback", () => {
      this.state.drawingManager !== null && this.props.onLoad && this.props.onLoad(this.state.drawingManager);
    }), Ho(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
  }
  componentDidMount() {
    var t = new google.maps.drawing.DrawingManager(Ub(Ub({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = yn({
      updaterMap: dU,
      eventMap: pU,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        drawingManager: t
      };
    }, this.setDrawingManagerCallback);
  }
  componentDidUpdate(t) {
    this.state.drawingManager !== null && (kn(this.registeredEvents), this.registeredEvents = yn({
      updaterMap: dU,
      eventMap: pU,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.drawingManager
    }));
  }
  componentWillUnmount() {
    this.state.drawingManager !== null && (this.props.onUnmount && this.props.onUnmount(this.state.drawingManager), kn(this.registeredEvents), this.state.drawingManager.setMap(null));
  }
  render() {
    return null;
  }
}
_e(PSe, "contextType", It);
function fU(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function pp(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? fU(Object(n), !0).forEach(function(r) {
      _e(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : fU(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var hU = {
  onAnimationChanged: "animation_changed",
  onClick: "click",
  onClickableChanged: "clickable_changed",
  onCursorChanged: "cursor_changed",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDraggableChanged: "draggable_changed",
  onDragStart: "dragstart",
  onFlatChanged: "flat_changed",
  onIconChanged: "icon_changed",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onPositionChanged: "position_changed",
  onRightClick: "rightclick",
  onShapeChanged: "shape_changed",
  onTitleChanged: "title_changed",
  onVisibleChanged: "visible_changed",
  onZindexChanged: "zindex_changed"
}, gU = {
  animation(e, t) {
    e.setAnimation(t);
  },
  clickable(e, t) {
    e.setClickable(t);
  },
  cursor(e, t) {
    e.setCursor(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  icon(e, t) {
    e.setIcon(t);
  },
  label(e, t) {
    e.setLabel(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  opacity(e, t) {
    e.setOpacity(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  shape(e, t) {
    e.setShape(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, Hb = {};
function SSe(e) {
  var {
    position: t,
    options: n,
    clusterer: r,
    noClustererRedraw: o,
    children: i,
    draggable: a,
    visible: s,
    animation: l,
    clickable: u,
    cursor: c,
    icon: p,
    label: d,
    opacity: g,
    shape: f,
    title: m,
    zIndex: b,
    onClick: E,
    onDblClick: w,
    onDrag: M,
    onDragEnd: x,
    onDragStart: v,
    onMouseOut: C,
    onMouseOver: P,
    onMouseUp: F,
    onMouseDown: L,
    onRightClick: B,
    onClickableChanged: N,
    onCursorChanged: $,
    onAnimationChanged: V,
    onDraggableChanged: H,
    onFlatChanged: Z,
    onIconChanged: K,
    onPositionChanged: Y,
    onShapeChanged: Q,
    onTitleChanged: J,
    onVisibleChanged: _,
    onZindexChanged: D,
    onLoad: z,
    onUnmount: S
  } = e, W = ge(It), [O, j] = k(null), [U, T] = k(null), [q, A] = k(null), [X, I] = k(null), [le, he] = k(null), [oe, Ae] = k(null), [Ue, He] = k(null), [Re, nt] = k(null), [Ve, we] = k(null), [et, lt] = k(null), [ye, ke] = k(null), [Qe, Fe] = k(null), [Ie, ot] = k(null), [Ee, wt] = k(null), [it, st] = k(null), [ut, Ct] = k(null), [ct, pt] = k(null), [rt, We] = k(null), [Ot, xt] = k(null), [gt, Ht] = k(null), [mt, Wt] = k(null), [vt, kt] = k(null);
  h(() => {
    O !== null && O.setMap(W);
  }, [W]), h(() => {
    typeof n < "u" && O !== null && O.setOptions(n);
  }, [O, n]), h(() => {
    typeof a < "u" && O !== null && O.setDraggable(a);
  }, [O, a]), h(() => {
    t && O !== null && O.setPosition(t);
  }, [O, t]), h(() => {
    typeof s < "u" && O !== null && O.setVisible(s);
  }, [O, s]), h(() => {
    O == null || O.setAnimation(l);
  }, [O, l]), h(() => {
    O && u !== void 0 && O.setClickable(u);
  }, [O, u]), h(() => {
    O && c !== void 0 && O.setCursor(c);
  }, [O, c]), h(() => {
    O && p !== void 0 && O.setIcon(p);
  }, [O, p]), h(() => {
    O && d !== void 0 && O.setLabel(d);
  }, [O, d]), h(() => {
    O && g !== void 0 && O.setOpacity(g);
  }, [O, g]), h(() => {
    O && f !== void 0 && O.setShape(f);
  }, [O, f]), h(() => {
    O && m !== void 0 && O.setTitle(m);
  }, [O, m]), h(() => {
    O && b !== void 0 && O.setZIndex(b);
  }, [O, b]), h(() => {
    O && w && (U !== null && google.maps.event.removeListener(U), T(google.maps.event.addListener(O, "dblclick", w)));
  }, [w]), h(() => {
    O && x && (q !== null && google.maps.event.removeListener(q), A(google.maps.event.addListener(O, "dragend", x)));
  }, [x]), h(() => {
    O && v && (X !== null && google.maps.event.removeListener(X), I(google.maps.event.addListener(O, "dragstart", v)));
  }, [v]), h(() => {
    O && L && (le !== null && google.maps.event.removeListener(le), he(google.maps.event.addListener(O, "mousedown", L)));
  }, [L]), h(() => {
    O && C && (oe !== null && google.maps.event.removeListener(oe), Ae(google.maps.event.addListener(O, "mouseout", C)));
  }, [C]), h(() => {
    O && P && (Ue !== null && google.maps.event.removeListener(Ue), He(google.maps.event.addListener(O, "mouseover", P)));
  }, [P]), h(() => {
    O && F && (Re !== null && google.maps.event.removeListener(Re), nt(google.maps.event.addListener(O, "mouseup", F)));
  }, [F]), h(() => {
    O && B && (Ve !== null && google.maps.event.removeListener(Ve), we(google.maps.event.addListener(O, "rightclick", B)));
  }, [B]), h(() => {
    O && E && (et !== null && google.maps.event.removeListener(et), lt(google.maps.event.addListener(O, "click", E)));
  }, [E]), h(() => {
    O && M && (ye !== null && google.maps.event.removeListener(ye), ke(google.maps.event.addListener(O, "drag", M)));
  }, [M]), h(() => {
    O && N && (Qe !== null && google.maps.event.removeListener(Qe), Fe(google.maps.event.addListener(O, "clickable_changed", N)));
  }, [N]), h(() => {
    O && $ && (Ie !== null && google.maps.event.removeListener(Ie), ot(google.maps.event.addListener(O, "cursor_changed", $)));
  }, [$]), h(() => {
    O && V && (Ee !== null && google.maps.event.removeListener(Ee), wt(google.maps.event.addListener(O, "animation_changed", V)));
  }, [V]), h(() => {
    O && H && (it !== null && google.maps.event.removeListener(it), st(google.maps.event.addListener(O, "draggable_changed", H)));
  }, [H]), h(() => {
    O && Z && (ut !== null && google.maps.event.removeListener(ut), Ct(google.maps.event.addListener(O, "flat_changed", Z)));
  }, [Z]), h(() => {
    O && K && (ct !== null && google.maps.event.removeListener(ct), pt(google.maps.event.addListener(O, "icon_changed", K)));
  }, [K]), h(() => {
    O && Y && (rt !== null && google.maps.event.removeListener(rt), We(google.maps.event.addListener(O, "position_changed", Y)));
  }, [Y]), h(() => {
    O && Q && (Ot !== null && google.maps.event.removeListener(Ot), xt(google.maps.event.addListener(O, "shape_changed", Q)));
  }, [Q]), h(() => {
    O && J && (gt !== null && google.maps.event.removeListener(gt), Ht(google.maps.event.addListener(O, "title_changed", J)));
  }, [J]), h(() => {
    O && _ && (mt !== null && google.maps.event.removeListener(mt), Wt(google.maps.event.addListener(O, "visible_changed", _)));
  }, [_]), h(() => {
    O && D && (vt !== null && google.maps.event.removeListener(vt), kt(google.maps.event.addListener(O, "zindex_changed", D)));
  }, [D]), h(() => {
    var yt = pp(pp(pp({}, n || Hb), r ? Hb : {
      map: W
    }), {}, {
      position: t
    }), re = new google.maps.Marker(yt);
    return r ? r.addMarker(re, !!o) : re.setMap(W), t && re.setPosition(t), typeof s < "u" && re.setVisible(s), typeof a < "u" && re.setDraggable(a), typeof u < "u" && re.setClickable(u), typeof c == "string" && re.setCursor(c), p && re.setIcon(p), typeof d < "u" && re.setLabel(d), typeof g < "u" && re.setOpacity(g), f && re.setShape(f), typeof m == "string" && re.setTitle(m), typeof b == "number" && re.setZIndex(b), w && T(google.maps.event.addListener(re, "dblclick", w)), x && A(google.maps.event.addListener(re, "dragend", x)), v && I(google.maps.event.addListener(re, "dragstart", v)), L && he(google.maps.event.addListener(re, "mousedown", L)), C && Ae(google.maps.event.addListener(re, "mouseout", C)), P && He(google.maps.event.addListener(re, "mouseover", P)), F && nt(google.maps.event.addListener(re, "mouseup", F)), B && we(google.maps.event.addListener(re, "rightclick", B)), E && lt(google.maps.event.addListener(re, "click", E)), M && ke(google.maps.event.addListener(re, "drag", M)), N && Fe(google.maps.event.addListener(re, "clickable_changed", N)), $ && ot(google.maps.event.addListener(re, "cursor_changed", $)), V && wt(google.maps.event.addListener(re, "animation_changed", V)), H && st(google.maps.event.addListener(re, "draggable_changed", H)), Z && Ct(google.maps.event.addListener(re, "flat_changed", Z)), K && pt(google.maps.event.addListener(re, "icon_changed", K)), Y && We(google.maps.event.addListener(re, "position_changed", Y)), Q && xt(google.maps.event.addListener(re, "shape_changed", Q)), J && Ht(google.maps.event.addListener(re, "title_changed", J)), _ && Wt(google.maps.event.addListener(re, "visible_changed", _)), D && kt(google.maps.event.addListener(re, "zindex_changed", D)), j(re), z && z(re), () => {
      U !== null && google.maps.event.removeListener(U), q !== null && google.maps.event.removeListener(q), X !== null && google.maps.event.removeListener(X), le !== null && google.maps.event.removeListener(le), oe !== null && google.maps.event.removeListener(oe), Ue !== null && google.maps.event.removeListener(Ue), Re !== null && google.maps.event.removeListener(Re), Ve !== null && google.maps.event.removeListener(Ve), et !== null && google.maps.event.removeListener(et), Qe !== null && google.maps.event.removeListener(Qe), Ie !== null && google.maps.event.removeListener(Ie), Ee !== null && google.maps.event.removeListener(Ee), it !== null && google.maps.event.removeListener(it), ut !== null && google.maps.event.removeListener(ut), ct !== null && google.maps.event.removeListener(ct), rt !== null && google.maps.event.removeListener(rt), gt !== null && google.maps.event.removeListener(gt), mt !== null && google.maps.event.removeListener(mt), vt !== null && google.maps.event.removeListener(vt), S && S(re), r ? r.removeMarker(re, !!o) : re && re.setMap(null);
    };
  }, []);
  var Un = ln(() => i ? at.map(i, (yt) => {
    if (!yi(yt))
      return yt;
    var re = yt;
    return bi(re, {
      anchor: O
    });
  }) : null, [i, O]);
  return ti.jsx(ti.Fragment, {
    children: Un
  }) || null;
}
me(SSe);
class MSe extends pe {
  constructor() {
    super(...arguments), _e(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this;
    return fee(function* () {
      var n = pp(pp(pp({}, t.props.options || Hb), t.props.clusterer ? Hb : {
        map: t.context
      }), {}, {
        position: t.props.position
      });
      t.marker = new google.maps.Marker(n), t.props.clusterer ? t.props.clusterer.addMarker(t.marker, !!t.props.noClustererRedraw) : t.marker.setMap(t.context), t.registeredEvents = yn({
        updaterMap: gU,
        eventMap: hU,
        prevProps: {},
        nextProps: t.props,
        instance: t.marker
      }), t.props.onLoad && t.props.onLoad(t.marker);
    })();
  }
  componentDidUpdate(t) {
    this.marker && (kn(this.registeredEvents), this.registeredEvents = yn({
      updaterMap: gU,
      eventMap: hU,
      prevProps: t,
      nextProps: this.props,
      instance: this.marker
    }));
  }
  componentWillUnmount() {
    this.marker && (this.props.onUnmount && this.props.onUnmount(this.marker), kn(this.registeredEvents), this.props.clusterer ? this.props.clusterer.removeMarker(this.marker, !!this.props.noClustererRedraw) : this.marker && this.marker.setMap(null));
  }
  render() {
    var t = this.props.children ? at.map(this.props.children, (n) => {
      if (!yi(n))
        return n;
      var r = n;
      return bi(r, {
        anchor: this.marker
      });
    }) : null;
    return t || null;
  }
}
_e(MSe, "contextType", It);
var DSe = (
  /** @class */
  function() {
    function e(t, n) {
      t.getClusterer().extend(e, google.maps.OverlayView), this.cluster = t, this.clusterClassName = this.cluster.getClusterer().getClusterClass(), this.className = this.clusterClassName, this.styles = n, this.center = void 0, this.div = null, this.sums = null, this.visible = !1, this.boundsChangedListener = null, this.url = "", this.height = 0, this.width = 0, this.anchorText = [0, 0], this.anchorIcon = [0, 0], this.textColor = "black", this.textSize = 11, this.textDecoration = "none", this.fontWeight = "bold", this.fontStyle = "normal", this.fontFamily = "Arial,sans-serif", this.backgroundPosition = "0 0", this.cMouseDownInCluster = null, this.cDraggingMapByCluster = null, this.timeOut = null, this.setMap(t.getMap()), this.onBoundsChanged = this.onBoundsChanged.bind(this), this.onMouseDown = this.onMouseDown.bind(this), this.onClick = this.onClick.bind(this), this.onMouseOver = this.onMouseOver.bind(this), this.onMouseOut = this.onMouseOut.bind(this), this.onAdd = this.onAdd.bind(this), this.onRemove = this.onRemove.bind(this), this.draw = this.draw.bind(this), this.hide = this.hide.bind(this), this.show = this.show.bind(this), this.useStyle = this.useStyle.bind(this), this.setCenter = this.setCenter.bind(this), this.getPosFromLatLng = this.getPosFromLatLng.bind(this);
    }
    return e.prototype.onBoundsChanged = function() {
      this.cDraggingMapByCluster = this.cMouseDownInCluster;
    }, e.prototype.onMouseDown = function() {
      this.cMouseDownInCluster = !0, this.cDraggingMapByCluster = !1;
    }, e.prototype.onClick = function(t) {
      if (this.cMouseDownInCluster = !1, !this.cDraggingMapByCluster) {
        var n = this.cluster.getClusterer();
        if (google.maps.event.trigger(n, "click", this.cluster), google.maps.event.trigger(n, "clusterclick", this.cluster), n.getZoomOnClick()) {
          var r = n.getMaxZoom(), o = this.cluster.getBounds(), i = n.getMap();
          i !== null && "fitBounds" in i && i.fitBounds(o), this.timeOut = window.setTimeout(function() {
            var a = n.getMap();
            if (a !== null) {
              "fitBounds" in a && a.fitBounds(o);
              var s = a.getZoom() || 0;
              r !== null && s > r && a.setZoom(r + 1);
            }
          }, 100);
        }
        t.cancelBubble = !0, t.stopPropagation && t.stopPropagation();
      }
    }, e.prototype.onMouseOver = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseover", this.cluster);
    }, e.prototype.onMouseOut = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseout", this.cluster);
    }, e.prototype.onAdd = function() {
      var t;
      this.div = document.createElement("div"), this.div.className = this.className, this.visible && this.show(), (t = this.getPanes()) === null || t === void 0 || t.overlayMouseTarget.appendChild(this.div);
      var n = this.getMap();
      n !== null && (this.boundsChangedListener = google.maps.event.addListener(n, "bounds_changed", this.onBoundsChanged), this.div.addEventListener("mousedown", this.onMouseDown), this.div.addEventListener("click", this.onClick), this.div.addEventListener("mouseover", this.onMouseOver), this.div.addEventListener("mouseout", this.onMouseOut));
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.hide(), this.boundsChangedListener !== null && google.maps.event.removeListener(this.boundsChangedListener), this.div.removeEventListener("mousedown", this.onMouseDown), this.div.removeEventListener("click", this.onClick), this.div.removeEventListener("mouseover", this.onMouseOver), this.div.removeEventListener("mouseout", this.onMouseOut), this.div.parentNode.removeChild(this.div), this.timeOut !== null && (window.clearTimeout(this.timeOut), this.timeOut = null), this.div = null);
    }, e.prototype.draw = function() {
      if (this.visible && this.div !== null && this.center) {
        var t = this.getPosFromLatLng(this.center);
        this.div.style.top = t !== null ? "".concat(t.y, "px") : "0", this.div.style.left = t !== null ? "".concat(t.x, "px") : "0";
      }
    }, e.prototype.hide = function() {
      this.div && (this.div.style.display = "none"), this.visible = !1;
    }, e.prototype.show = function() {
      var t, n, r, o, i, a;
      if (this.div && this.center) {
        var s = this.sums === null || typeof this.sums.title > "u" || this.sums.title === "" ? this.cluster.getClusterer().getTitle() : this.sums.title, l = this.backgroundPosition.split(" "), u = parseInt(((t = l[0]) === null || t === void 0 ? void 0 : t.replace(/^\s+|\s+$/g, "")) || "0", 10), c = parseInt(((n = l[1]) === null || n === void 0 ? void 0 : n.replace(/^\s+|\s+$/g, "")) || "0", 10), p = this.getPosFromLatLng(this.center);
        this.div.className = this.className, this.div.setAttribute("style", "cursor: pointer; position: absolute; top: ".concat(p !== null ? "".concat(p.y, "px") : "0", "; left: ").concat(p !== null ? "".concat(p.x, "px") : "0", "; width: ").concat(this.width, "px; height: ").concat(this.height, "px; "));
        var d = document.createElement("img");
        d.alt = s, d.src = this.url, d.width = this.width, d.height = this.height, d.setAttribute("style", "position: absolute; top: ".concat(c, "px; left: ").concat(u, "px")), this.cluster.getClusterer().enableRetinaIcons || (d.style.clip = "rect(-".concat(c, "px, -").concat(u + this.width, "px, -").concat(c + this.height, ", -").concat(u, ")"));
        var g = document.createElement("div");
        g.setAttribute("style", "position: absolute; top: ".concat(this.anchorText[0], "px; left: ").concat(this.anchorText[1], "px; color: ").concat(this.textColor, "; font-size: ").concat(this.textSize, "px; font-family: ").concat(this.fontFamily, "; font-weight: ").concat(this.fontWeight, "; fontStyle: ").concat(this.fontStyle, "; text-decoration: ").concat(this.textDecoration, "; text-align: center; width: ").concat(this.width, "px; line-height: ").concat(this.height, "px")), !((r = this.sums) === null || r === void 0) && r.text && (g.innerText = "".concat((o = this.sums) === null || o === void 0 ? void 0 : o.text)), !((i = this.sums) === null || i === void 0) && i.html && (g.innerHTML = "".concat((a = this.sums) === null || a === void 0 ? void 0 : a.html)), this.div.innerHTML = "", this.div.appendChild(d), this.div.appendChild(g), this.div.title = s, this.div.style.display = "";
      }
      this.visible = !0;
    }, e.prototype.useStyle = function(t) {
      this.sums = t;
      var n = this.cluster.getClusterer().getStyles(), r = n[Math.min(n.length - 1, Math.max(0, t.index - 1))];
      r && (this.url = r.url, this.height = r.height, this.width = r.width, r.className && (this.className = "".concat(this.clusterClassName, " ").concat(r.className)), this.anchorText = r.anchorText || [0, 0], this.anchorIcon = r.anchorIcon || [this.height / 2, this.width / 2], this.textColor = r.textColor || "black", this.textSize = r.textSize || 11, this.textDecoration = r.textDecoration || "none", this.fontWeight = r.fontWeight || "bold", this.fontStyle = r.fontStyle || "normal", this.fontFamily = r.fontFamily || "Arial,sans-serif", this.backgroundPosition = r.backgroundPosition || "0 0");
    }, e.prototype.setCenter = function(t) {
      this.center = t;
    }, e.prototype.getPosFromLatLng = function(t) {
      var n = this.getProjection().fromLatLngToDivPixel(t);
      return n !== null && (n.x -= this.anchorIcon[1], n.y -= this.anchorIcon[0]), n;
    }, e;
  }()
), TSe = (
  /** @class */
  function() {
    function e(t) {
      this.markerClusterer = t, this.map = this.markerClusterer.getMap(), this.gridSize = this.markerClusterer.getGridSize(), this.minClusterSize = this.markerClusterer.getMinimumClusterSize(), this.averageCenter = this.markerClusterer.getAverageCenter(), this.markers = [], this.center = void 0, this.bounds = null, this.clusterIcon = new DSe(this, this.markerClusterer.getStyles()), this.getSize = this.getSize.bind(this), this.getMarkers = this.getMarkers.bind(this), this.getCenter = this.getCenter.bind(this), this.getMap = this.getMap.bind(this), this.getClusterer = this.getClusterer.bind(this), this.getBounds = this.getBounds.bind(this), this.remove = this.remove.bind(this), this.addMarker = this.addMarker.bind(this), this.isMarkerInClusterBounds = this.isMarkerInClusterBounds.bind(this), this.calculateBounds = this.calculateBounds.bind(this), this.updateIcon = this.updateIcon.bind(this), this.isMarkerAlreadyAdded = this.isMarkerAlreadyAdded.bind(this);
    }
    return e.prototype.getSize = function() {
      return this.markers.length;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getCenter = function() {
      return this.center;
    }, e.prototype.getMap = function() {
      return this.map;
    }, e.prototype.getClusterer = function() {
      return this.markerClusterer;
    }, e.prototype.getBounds = function() {
      for (var t = new google.maps.LatLngBounds(this.center, this.center), n = this.getMarkers(), r = 0, o = n; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && t.extend(a);
      }
      return t;
    }, e.prototype.remove = function() {
      this.clusterIcon.setMap(null), this.markers = [], delete this.markers;
    }, e.prototype.addMarker = function(t) {
      var n;
      if (this.isMarkerAlreadyAdded(t))
        return !1;
      if (this.center) {
        if (this.averageCenter) {
          var r = t.getPosition();
          if (r) {
            var o = this.markers.length + 1;
            this.center = new google.maps.LatLng((this.center.lat() * (o - 1) + r.lat()) / o, (this.center.lng() * (o - 1) + r.lng()) / o), this.calculateBounds();
          }
        }
      } else {
        var r = t.getPosition();
        r && (this.center = r, this.calculateBounds());
      }
      t.isAdded = !0, this.markers.push(t);
      var i = this.markers.length, a = this.markerClusterer.getMaxZoom(), s = (n = this.map) === null || n === void 0 ? void 0 : n.getZoom();
      if (a !== null && typeof s < "u" && s > a)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i < this.minClusterSize)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i === this.minClusterSize)
        for (var l = 0, u = this.markers; l < u.length; l++) {
          var c = u[l];
          c.setMap(null);
        }
      else
        t.setMap(null);
      return !0;
    }, e.prototype.isMarkerInClusterBounds = function(t) {
      if (this.bounds !== null) {
        var n = t.getPosition();
        if (n)
          return this.bounds.contains(n);
      }
      return !1;
    }, e.prototype.calculateBounds = function() {
      this.bounds = this.markerClusterer.getExtendedBounds(new google.maps.LatLngBounds(this.center, this.center));
    }, e.prototype.updateIcon = function() {
      var t, n = this.markers.length, r = this.markerClusterer.getMaxZoom(), o = (t = this.map) === null || t === void 0 ? void 0 : t.getZoom();
      if (r !== null && typeof o < "u" && o > r) {
        this.clusterIcon.hide();
        return;
      }
      if (n < this.minClusterSize) {
        this.clusterIcon.hide();
        return;
      }
      this.center && this.clusterIcon.setCenter(this.center), this.clusterIcon.useStyle(this.markerClusterer.getCalculator()(this.markers, this.markerClusterer.getStyles().length)), this.clusterIcon.show();
    }, e.prototype.isMarkerAlreadyAdded = function(t) {
      if (this.markers.includes)
        return this.markers.includes(t);
      for (var n = 0; n < this.markers.length; n++)
        if (t === this.markers[n])
          return !0;
      return !1;
    }, e;
  }()
);
function jSe(e, t) {
  var n = e.length, r = n.toString().length, o = Math.min(r, t);
  return {
    text: n.toString(),
    index: o,
    title: ""
  };
}
var ASe = 2e3, RSe = 500, ISe = "https://developers.google.com/maps/documentation/javascript/examples/markerclusterer/m", NSe = "png", BSe = [53, 56, 66, 78, 90], FSe = "cluster", yee = (
  /** @class */
  function() {
    function e(t, n, r) {
      n === void 0 && (n = []), r === void 0 && (r = {}), this.getMinimumClusterSize = this.getMinimumClusterSize.bind(this), this.setMinimumClusterSize = this.setMinimumClusterSize.bind(this), this.getEnableRetinaIcons = this.getEnableRetinaIcons.bind(this), this.setEnableRetinaIcons = this.setEnableRetinaIcons.bind(this), this.addToClosestCluster = this.addToClosestCluster.bind(this), this.getImageExtension = this.getImageExtension.bind(this), this.setImageExtension = this.setImageExtension.bind(this), this.getExtendedBounds = this.getExtendedBounds.bind(this), this.getAverageCenter = this.getAverageCenter.bind(this), this.setAverageCenter = this.setAverageCenter.bind(this), this.getTotalClusters = this.getTotalClusters.bind(this), this.fitMapToMarkers = this.fitMapToMarkers.bind(this), this.getIgnoreHidden = this.getIgnoreHidden.bind(this), this.setIgnoreHidden = this.setIgnoreHidden.bind(this), this.getClusterClass = this.getClusterClass.bind(this), this.setClusterClass = this.setClusterClass.bind(this), this.getTotalMarkers = this.getTotalMarkers.bind(this), this.getZoomOnClick = this.getZoomOnClick.bind(this), this.setZoomOnClick = this.setZoomOnClick.bind(this), this.getBatchSizeIE = this.getBatchSizeIE.bind(this), this.setBatchSizeIE = this.setBatchSizeIE.bind(this), this.createClusters = this.createClusters.bind(this), this.onZoomChanged = this.onZoomChanged.bind(this), this.getImageSizes = this.getImageSizes.bind(this), this.setImageSizes = this.setImageSizes.bind(this), this.getCalculator = this.getCalculator.bind(this), this.setCalculator = this.setCalculator.bind(this), this.removeMarkers = this.removeMarkers.bind(this), this.resetViewport = this.resetViewport.bind(this), this.getImagePath = this.getImagePath.bind(this), this.setImagePath = this.setImagePath.bind(this), this.pushMarkerTo = this.pushMarkerTo.bind(this), this.removeMarker = this.removeMarker.bind(this), this.clearMarkers = this.clearMarkers.bind(this), this.setupStyles = this.setupStyles.bind(this), this.getGridSize = this.getGridSize.bind(this), this.setGridSize = this.setGridSize.bind(this), this.getClusters = this.getClusters.bind(this), this.getMaxZoom = this.getMaxZoom.bind(this), this.setMaxZoom = this.setMaxZoom.bind(this), this.getMarkers = this.getMarkers.bind(this), this.addMarkers = this.addMarkers.bind(this), this.getStyles = this.getStyles.bind(this), this.setStyles = this.setStyles.bind(this), this.addMarker = this.addMarker.bind(this), this.onRemove = this.onRemove.bind(this), this.getTitle = this.getTitle.bind(this), this.setTitle = this.setTitle.bind(this), this.repaint = this.repaint.bind(this), this.onIdle = this.onIdle.bind(this), this.redraw = this.redraw.bind(this), this.onAdd = this.onAdd.bind(this), this.draw = this.draw.bind(this), this.extend = this.extend.bind(this), this.extend(e, google.maps.OverlayView), this.markers = [], this.clusters = [], this.listeners = [], this.activeMap = null, this.ready = !1, this.gridSize = r.gridSize || 60, this.minClusterSize = r.minimumClusterSize || 2, this.maxZoom = r.maxZoom || null, this.styles = r.styles || [], this.title = r.title || "", this.zoomOnClick = !0, r.zoomOnClick !== void 0 && (this.zoomOnClick = r.zoomOnClick), this.averageCenter = !1, r.averageCenter !== void 0 && (this.averageCenter = r.averageCenter), this.ignoreHidden = !1, r.ignoreHidden !== void 0 && (this.ignoreHidden = r.ignoreHidden), this.enableRetinaIcons = !1, r.enableRetinaIcons !== void 0 && (this.enableRetinaIcons = r.enableRetinaIcons), this.imagePath = r.imagePath || ISe, this.imageExtension = r.imageExtension || NSe, this.imageSizes = r.imageSizes || BSe, this.calculator = r.calculator || jSe, this.batchSize = r.batchSize || ASe, this.batchSizeIE = r.batchSizeIE || RSe, this.clusterClass = r.clusterClass || FSe, navigator.userAgent.toLowerCase().indexOf("msie") !== -1 && (this.batchSize = this.batchSizeIE), this.timerRefStatic = null, this.setupStyles(), this.addMarkers(n, !0), this.setMap(t);
    }
    return e.prototype.onZoomChanged = function() {
      var t, n;
      this.resetViewport(!1), (((t = this.getMap()) === null || t === void 0 ? void 0 : t.getZoom()) === (this.get("minZoom") || 0) || ((n = this.getMap()) === null || n === void 0 ? void 0 : n.getZoom()) === this.get("maxZoom")) && google.maps.event.trigger(this, "idle");
    }, e.prototype.onIdle = function() {
      this.redraw();
    }, e.prototype.onAdd = function() {
      var t = this.getMap();
      this.activeMap = t, this.ready = !0, this.repaint(), t !== null && (this.listeners = [google.maps.event.addListener(t, "zoom_changed", this.onZoomChanged), google.maps.event.addListener(t, "idle", this.onIdle)]);
    }, e.prototype.onRemove = function() {
      for (var t = 0, n = this.markers; t < n.length; t++) {
        var r = n[t];
        r.getMap() !== this.activeMap && r.setMap(this.activeMap);
      }
      for (var o = 0, i = this.clusters; o < i.length; o++) {
        var a = i[o];
        a.remove();
      }
      this.clusters = [];
      for (var s = 0, l = this.listeners; s < l.length; s++) {
        var u = l[s];
        google.maps.event.removeListener(u);
      }
      this.listeners = [], this.activeMap = null, this.ready = !1;
    }, e.prototype.draw = function() {
    }, e.prototype.getMap = function() {
      return null;
    }, e.prototype.getPanes = function() {
      return null;
    }, e.prototype.getProjection = function() {
      return {
        fromContainerPixelToLatLng: function() {
          return null;
        },
        fromDivPixelToLatLng: function() {
          return null;
        },
        fromLatLngToContainerPixel: function() {
          return null;
        },
        fromLatLngToDivPixel: function() {
          return null;
        },
        getVisibleRegion: function() {
          return null;
        },
        getWorldWidth: function() {
          return 0;
        }
      };
    }, e.prototype.setMap = function() {
    }, e.prototype.addListener = function() {
      return {
        remove: function() {
        }
      };
    }, e.prototype.bindTo = function() {
    }, e.prototype.get = function() {
    }, e.prototype.notify = function() {
    }, e.prototype.set = function() {
    }, e.prototype.setValues = function() {
    }, e.prototype.unbind = function() {
    }, e.prototype.unbindAll = function() {
    }, e.prototype.setupStyles = function() {
      if (!(this.styles.length > 0))
        for (var t = 0; t < this.imageSizes.length; t++)
          this.styles.push({
            url: "".concat(this.imagePath + (t + 1), ".").concat(this.imageExtension),
            height: this.imageSizes[t] || 0,
            width: this.imageSizes[t] || 0
          });
    }, e.prototype.fitMapToMarkers = function() {
      for (var t = this.getMarkers(), n = new google.maps.LatLngBounds(), r = 0, o = t; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && n.extend(a);
      }
      var s = this.getMap();
      s !== null && "fitBounds" in s && s.fitBounds(n);
    }, e.prototype.getGridSize = function() {
      return this.gridSize;
    }, e.prototype.setGridSize = function(t) {
      this.gridSize = t;
    }, e.prototype.getMinimumClusterSize = function() {
      return this.minClusterSize;
    }, e.prototype.setMinimumClusterSize = function(t) {
      this.minClusterSize = t;
    }, e.prototype.getMaxZoom = function() {
      return this.maxZoom;
    }, e.prototype.setMaxZoom = function(t) {
      this.maxZoom = t;
    }, e.prototype.getStyles = function() {
      return this.styles;
    }, e.prototype.setStyles = function(t) {
      this.styles = t;
    }, e.prototype.getTitle = function() {
      return this.title;
    }, e.prototype.setTitle = function(t) {
      this.title = t;
    }, e.prototype.getZoomOnClick = function() {
      return this.zoomOnClick;
    }, e.prototype.setZoomOnClick = function(t) {
      this.zoomOnClick = t;
    }, e.prototype.getAverageCenter = function() {
      return this.averageCenter;
    }, e.prototype.setAverageCenter = function(t) {
      this.averageCenter = t;
    }, e.prototype.getIgnoreHidden = function() {
      return this.ignoreHidden;
    }, e.prototype.setIgnoreHidden = function(t) {
      this.ignoreHidden = t;
    }, e.prototype.getEnableRetinaIcons = function() {
      return this.enableRetinaIcons;
    }, e.prototype.setEnableRetinaIcons = function(t) {
      this.enableRetinaIcons = t;
    }, e.prototype.getImageExtension = function() {
      return this.imageExtension;
    }, e.prototype.setImageExtension = function(t) {
      this.imageExtension = t;
    }, e.prototype.getImagePath = function() {
      return this.imagePath;
    }, e.prototype.setImagePath = function(t) {
      this.imagePath = t;
    }, e.prototype.getImageSizes = function() {
      return this.imageSizes;
    }, e.prototype.setImageSizes = function(t) {
      this.imageSizes = t;
    }, e.prototype.getCalculator = function() {
      return this.calculator;
    }, e.prototype.setCalculator = function(t) {
      this.calculator = t;
    }, e.prototype.getBatchSizeIE = function() {
      return this.batchSizeIE;
    }, e.prototype.setBatchSizeIE = function(t) {
      this.batchSizeIE = t;
    }, e.prototype.getClusterClass = function() {
      return this.clusterClass;
    }, e.prototype.setClusterClass = function(t) {
      this.clusterClass = t;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getTotalMarkers = function() {
      return this.markers.length;
    }, e.prototype.getClusters = function() {
      return this.clusters;
    }, e.prototype.getTotalClusters = function() {
      return this.clusters.length;
    }, e.prototype.addMarker = function(t, n) {
      this.pushMarkerTo(t), n || this.redraw();
    }, e.prototype.addMarkers = function(t, n) {
      for (var r in t)
        if (Object.prototype.hasOwnProperty.call(t, r)) {
          var o = t[r];
          o && this.pushMarkerTo(o);
        }
      n || this.redraw();
    }, e.prototype.pushMarkerTo = function(t) {
      var n = this;
      t.getDraggable() && google.maps.event.addListener(t, "dragend", function() {
        n.ready && (t.isAdded = !1, n.repaint());
      }), t.isAdded = !1, this.markers.push(t);
    }, e.prototype.removeMarker_ = function(t) {
      var n = -1;
      if (this.markers.indexOf)
        n = this.markers.indexOf(t);
      else
        for (var r = 0; r < this.markers.length; r++)
          if (t === this.markers[r]) {
            n = r;
            break;
          }
      return n === -1 ? !1 : (t.setMap(null), this.markers.splice(n, 1), !0);
    }, e.prototype.removeMarker = function(t, n) {
      var r = this.removeMarker_(t);
      return !n && r && this.repaint(), r;
    }, e.prototype.removeMarkers = function(t, n) {
      for (var r = !1, o = 0, i = t; o < i.length; o++) {
        var a = i[o];
        r = r || this.removeMarker_(a);
      }
      return !n && r && this.repaint(), r;
    }, e.prototype.clearMarkers = function() {
      this.resetViewport(!0), this.markers = [];
    }, e.prototype.repaint = function() {
      var t = this.clusters.slice();
      this.clusters = [], this.resetViewport(!1), this.redraw(), setTimeout(function() {
        for (var n = 0, r = t; n < r.length; n++) {
          var o = r[n];
          o.remove();
        }
      }, 0);
    }, e.prototype.getExtendedBounds = function(t) {
      var n = this.getProjection(), r = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getNorthEast().lat(), t.getNorthEast().lng())
      );
      r !== null && (r.x += this.gridSize, r.y -= this.gridSize);
      var o = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getSouthWest().lat(), t.getSouthWest().lng())
      );
      if (o !== null && (o.x -= this.gridSize, o.y += this.gridSize), r !== null) {
        var i = n.fromDivPixelToLatLng(r);
        i !== null && t.extend(i);
      }
      if (o !== null) {
        var a = n.fromDivPixelToLatLng(o);
        a !== null && t.extend(a);
      }
      return t;
    }, e.prototype.redraw = function() {
      this.createClusters(0);
    }, e.prototype.resetViewport = function(t) {
      for (var n = 0, r = this.clusters; n < r.length; n++) {
        var o = r[n];
        o.remove();
      }
      this.clusters = [];
      for (var i = 0, a = this.markers; i < a.length; i++) {
        var s = a[i];
        s.isAdded = !1, t && s.setMap(null);
      }
    }, e.prototype.distanceBetweenPoints = function(t, n) {
      var r = 6371, o = (n.lat() - t.lat()) * Math.PI / 180, i = (n.lng() - t.lng()) * Math.PI / 180, a = Math.sin(o / 2) * Math.sin(o / 2) + Math.cos(t.lat() * Math.PI / 180) * Math.cos(n.lat() * Math.PI / 180) * Math.sin(i / 2) * Math.sin(i / 2);
      return r * (2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)));
    }, e.prototype.isMarkerInBounds = function(t, n) {
      var r = t.getPosition();
      return r ? n.contains(r) : !1;
    }, e.prototype.addToClosestCluster = function(t) {
      for (var n, r = 4e4, o = null, i = 0, a = this.clusters; i < a.length; i++) {
        var s = a[i];
        n = s;
        var l = n.getCenter(), u = t.getPosition();
        if (l && u) {
          var c = this.distanceBetweenPoints(l, u);
          c < r && (r = c, o = n);
        }
      }
      o && o.isMarkerInClusterBounds(t) ? o.addMarker(t) : (n = new TSe(this), n.addMarker(t), this.clusters.push(n));
    }, e.prototype.createClusters = function(t) {
      var n = this;
      if (this.ready) {
        t === 0 && (google.maps.event.trigger(this, "clusteringbegin", this), this.timerRefStatic !== null && (window.clearTimeout(this.timerRefStatic), delete this.timerRefStatic));
        for (var r = this.getMap(), o = r !== null && ("getBounds" in r) ? r.getBounds() : null, i = (r == null ? void 0 : r.getZoom()) || 0, a = i > 3 ? new google.maps.LatLngBounds(o == null ? void 0 : o.getSouthWest(), o == null ? void 0 : o.getNorthEast()) : new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625)), s = this.getExtendedBounds(a), l = Math.min(t + this.batchSize, this.markers.length), u = t; u < l; u++) {
          var c = this.markers[u];
          c && !c.isAdded && this.isMarkerInBounds(c, s) && (!this.ignoreHidden || this.ignoreHidden && c.getVisible()) && this.addToClosestCluster(c);
        }
        if (l < this.markers.length)
          this.timerRefStatic = window.setTimeout(function() {
            n.createClusters(l);
          }, 0);
        else {
          this.timerRefStatic = null, google.maps.event.trigger(this, "clusteringend", this);
          for (var p = 0, d = this.clusters; p < d.length; p++) {
            var g = d[p];
            g.updateIcon();
          }
        }
      }
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype) {
          var i = o;
          this.prototype[i] = r.prototype[i];
        }
        return this;
      }).apply(t, [n]);
    }, e;
  }()
);
function mU(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function zSe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? mU(Object(n), !0).forEach(function(r) {
      _e(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : mU(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Rs = {
  onClick: "click",
  onClusteringBegin: "clusteringbegin",
  onClusteringEnd: "clusteringend",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover"
}, Tn = {
  averageCenter(e, t) {
    e.setAverageCenter(t);
  },
  batchSizeIE(e, t) {
    e.setBatchSizeIE(t);
  },
  calculator(e, t) {
    e.setCalculator(t);
  },
  clusterClass(e, t) {
    e.setClusterClass(t);
  },
  enableRetinaIcons(e, t) {
    e.setEnableRetinaIcons(t);
  },
  gridSize(e, t) {
    e.setGridSize(t);
  },
  ignoreHidden(e, t) {
    e.setIgnoreHidden(t);
  },
  imageExtension(e, t) {
    e.setImageExtension(t);
  },
  imagePath(e, t) {
    e.setImagePath(t);
  },
  imageSizes(e, t) {
    e.setImageSizes(t);
  },
  maxZoom(e, t) {
    e.setMaxZoom(t);
  },
  minimumClusterSize(e, t) {
    e.setMinimumClusterSize(t);
  },
  styles(e, t) {
    e.setStyles(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  zoomOnClick(e, t) {
    e.setZoomOnClick(t);
  }
}, USe = {};
function HSe(e) {
  var {
    children: t,
    options: n,
    averageCenter: r,
    batchSizeIE: o,
    calculator: i,
    clusterClass: a,
    enableRetinaIcons: s,
    gridSize: l,
    ignoreHidden: u,
    imageExtension: c,
    imagePath: p,
    imageSizes: d,
    maxZoom: g,
    minimumClusterSize: f,
    styles: m,
    title: b,
    zoomOnClick: E,
    onClick: w,
    onClusteringBegin: M,
    onClusteringEnd: x,
    onMouseOver: v,
    onMouseOut: C,
    onLoad: P,
    onUnmount: F
  } = e, [L, B] = k(null), N = ge(It), [$, V] = k(null), [H, Z] = k(null), [K, Y] = k(null), [Q, J] = k(null), [_, D] = k(null);
  return h(() => {
    L && C && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(L, Rs.onMouseOut, C)));
  }, [C]), h(() => {
    L && v && (_ !== null && google.maps.event.removeListener(_), D(google.maps.event.addListener(L, Rs.onMouseOver, v)));
  }, [v]), h(() => {
    L && w && ($ !== null && google.maps.event.removeListener($), V(google.maps.event.addListener(L, Rs.onClick, w)));
  }, [w]), h(() => {
    L && M && (H !== null && google.maps.event.removeListener(H), Z(google.maps.event.addListener(L, Rs.onClusteringBegin, M)));
  }, [M]), h(() => {
    L && x && (K !== null && google.maps.event.removeListener(K), Z(google.maps.event.addListener(L, Rs.onClusteringEnd, x)));
  }, [x]), h(() => {
    typeof r < "u" && L !== null && Tn.averageCenter(L, r);
  }, [L, r]), h(() => {
    typeof o < "u" && L !== null && Tn.batchSizeIE(L, o);
  }, [L, o]), h(() => {
    typeof i < "u" && L !== null && Tn.calculator(L, i);
  }, [L, i]), h(() => {
    typeof a < "u" && L !== null && Tn.clusterClass(L, a);
  }, [L, a]), h(() => {
    typeof s < "u" && L !== null && Tn.enableRetinaIcons(L, s);
  }, [L, s]), h(() => {
    typeof l < "u" && L !== null && Tn.gridSize(L, l);
  }, [L, l]), h(() => {
    typeof u < "u" && L !== null && Tn.ignoreHidden(L, u);
  }, [L, u]), h(() => {
    typeof c < "u" && L !== null && Tn.imageExtension(L, c);
  }, [L, c]), h(() => {
    typeof p < "u" && L !== null && Tn.imagePath(L, p);
  }, [L, p]), h(() => {
    typeof d < "u" && L !== null && Tn.imageSizes(L, d);
  }, [L, d]), h(() => {
    typeof g < "u" && L !== null && Tn.maxZoom(L, g);
  }, [L, g]), h(() => {
    typeof f < "u" && L !== null && Tn.minimumClusterSize(L, f);
  }, [L, f]), h(() => {
    typeof m < "u" && L !== null && Tn.styles(L, m);
  }, [L, m]), h(() => {
    typeof b < "u" && L !== null && Tn.title(L, b);
  }, [L, b]), h(() => {
    typeof E < "u" && L !== null && Tn.zoomOnClick(L, E);
  }, [L, E]), h(() => {
    if (N) {
      var z = zSe({}, n || USe), S = new yee(N, [], z);
      return r && Tn.averageCenter(S, r), o && Tn.batchSizeIE(S, o), i && Tn.calculator(S, i), a && Tn.clusterClass(S, a), s && Tn.enableRetinaIcons(S, s), l && Tn.gridSize(S, l), u && Tn.ignoreHidden(S, u), c && Tn.imageExtension(S, c), p && Tn.imagePath(S, p), d && Tn.imageSizes(S, d), g && Tn.maxZoom(S, g), f && Tn.minimumClusterSize(S, f), m && Tn.styles(S, m), b && Tn.title(S, b), E && Tn.zoomOnClick(S, E), C && J(google.maps.event.addListener(S, Rs.onMouseOut, C)), v && D(google.maps.event.addListener(S, Rs.onMouseOver, v)), w && V(google.maps.event.addListener(S, Rs.onClick, w)), M && Z(google.maps.event.addListener(S, Rs.onClusteringBegin, M)), x && Y(google.maps.event.addListener(S, Rs.onClusteringEnd, x)), B(S), P && P(S), () => {
        Q !== null && google.maps.event.removeListener(Q), _ !== null && google.maps.event.removeListener(_), $ !== null && google.maps.event.removeListener($), H !== null && google.maps.event.removeListener(H), K !== null && google.maps.event.removeListener(K), F && F(S);
      };
    }
  }, []), L !== null && t(L) || null;
}
me(HSe);
class WSe extends pe {
  constructor() {
    super(...arguments), _e(this, "registeredEvents", []), _e(this, "state", {
      markerClusterer: null
    }), _e(this, "setClustererCallback", () => {
      this.state.markerClusterer !== null && this.props.onLoad && this.props.onLoad(this.state.markerClusterer);
    });
  }
  componentDidMount() {
    if (this.context) {
      var t = new yee(this.context, [], this.props.options);
      this.registeredEvents = yn({
        updaterMap: Tn,
        eventMap: Rs,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        markerClusterer: t
      }), this.setClustererCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.markerClusterer && (kn(this.registeredEvents), this.registeredEvents = yn({
      updaterMap: Tn,
      eventMap: Rs,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.markerClusterer
    }));
  }
  componentWillUnmount() {
    this.state.markerClusterer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.markerClusterer), kn(this.registeredEvents), this.state.markerClusterer.setMap(null));
  }
  render() {
    return this.state.markerClusterer !== null ? this.props.children(this.state.markerClusterer) : null;
  }
}
_e(WSe, "contextType", It);
function vU(e) {
  e.cancelBubble = !0, e.stopPropagation && e.stopPropagation();
}
var bee = (
  /** @class */
  function() {
    function e(t) {
      t === void 0 && (t = {}), this.getCloseClickHandler = this.getCloseClickHandler.bind(this), this.closeClickHandler = this.closeClickHandler.bind(this), this.createInfoBoxDiv = this.createInfoBoxDiv.bind(this), this.addClickHandler = this.addClickHandler.bind(this), this.getCloseBoxImg = this.getCloseBoxImg.bind(this), this.getBoxWidths = this.getBoxWidths.bind(this), this.setBoxStyle = this.setBoxStyle.bind(this), this.setPosition = this.setPosition.bind(this), this.getPosition = this.getPosition.bind(this), this.setOptions = this.setOptions.bind(this), this.setContent = this.setContent.bind(this), this.setVisible = this.setVisible.bind(this), this.getContent = this.getContent.bind(this), this.getVisible = this.getVisible.bind(this), this.setZIndex = this.setZIndex.bind(this), this.getZIndex = this.getZIndex.bind(this), this.onRemove = this.onRemove.bind(this), this.panBox = this.panBox.bind(this), this.extend = this.extend.bind(this), this.close = this.close.bind(this), this.draw = this.draw.bind(this), this.show = this.show.bind(this), this.hide = this.hide.bind(this), this.open = this.open.bind(this), this.extend(e, google.maps.OverlayView), this.content = t.content || "", this.disableAutoPan = t.disableAutoPan || !1, this.maxWidth = t.maxWidth || 0, this.pixelOffset = t.pixelOffset || new google.maps.Size(0, 0), this.position = t.position || new google.maps.LatLng(0, 0), this.zIndex = t.zIndex || null, this.boxClass = t.boxClass || "infoBox", this.boxStyle = t.boxStyle || {}, this.closeBoxMargin = t.closeBoxMargin || "2px", this.closeBoxURL = t.closeBoxURL || "http://www.google.com/intl/en_us/mapfiles/close.gif", t.closeBoxURL === "" && (this.closeBoxURL = ""), this.infoBoxClearance = t.infoBoxClearance || new google.maps.Size(1, 1), typeof t.visible > "u" && (typeof t.isHidden > "u" ? t.visible = !0 : t.visible = !t.isHidden), this.isHidden = !t.visible, this.alignBottom = t.alignBottom || !1, this.pane = t.pane || "floatPane", this.enableEventPropagation = t.enableEventPropagation || !1, this.div = null, this.closeListener = null, this.moveListener = null, this.mapListener = null, this.contextListener = null, this.eventListeners = null, this.fixedWidthSet = null;
    }
    return e.prototype.createInfoBoxDiv = function() {
      var t = this, n = function(u) {
        u.returnValue = !1, u.preventDefault && u.preventDefault(), t.enableEventPropagation || vU(u);
      };
      if (!this.div) {
        this.div = document.createElement("div"), this.setBoxStyle(), typeof this.content == "string" ? this.div.innerHTML = this.getCloseBoxImg() + this.content : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(this.content));
        var r = this.getPanes();
        if (r !== null && r[this.pane].appendChild(this.div), this.addClickHandler(), this.div.style.width)
          this.fixedWidthSet = !0;
        else if (this.maxWidth !== 0 && this.div.offsetWidth > this.maxWidth)
          this.div.style.width = this.maxWidth + "px", this.fixedWidthSet = !0;
        else {
          var o = this.getBoxWidths();
          this.div.style.width = this.div.offsetWidth - o.left - o.right + "px", this.fixedWidthSet = !1;
        }
        if (this.panBox(this.disableAutoPan), !this.enableEventPropagation) {
          this.eventListeners = [];
          for (var i = ["mousedown", "mouseover", "mouseout", "mouseup", "click", "dblclick", "touchstart", "touchend", "touchmove"], a = 0, s = i; a < s.length; a++) {
            var l = s[a];
            this.eventListeners.push(google.maps.event.addListener(this.div, l, vU));
          }
          this.eventListeners.push(google.maps.event.addListener(this.div, "mouseover", function() {
            t.div && (t.div.style.cursor = "default");
          }));
        }
        this.contextListener = google.maps.event.addListener(this.div, "contextmenu", n), google.maps.event.trigger(this, "domready");
      }
    }, e.prototype.getCloseBoxImg = function() {
      var t = "";
      return this.closeBoxURL !== "" && (t = '<img alt=""', t += ' aria-hidden="true"', t += " src='" + this.closeBoxURL + "'", t += " align=right", t += " style='", t += " position: relative;", t += " cursor: pointer;", t += " margin: " + this.closeBoxMargin + ";", t += "'>"), t;
    }, e.prototype.addClickHandler = function() {
      this.closeListener = this.div && this.div.firstChild && this.closeBoxURL !== "" ? google.maps.event.addListener(this.div.firstChild, "click", this.getCloseClickHandler()) : null;
    }, e.prototype.closeClickHandler = function(t) {
      t.cancelBubble = !0, t.stopPropagation && t.stopPropagation(), google.maps.event.trigger(this, "closeclick"), this.close();
    }, e.prototype.getCloseClickHandler = function() {
      return this.closeClickHandler;
    }, e.prototype.panBox = function(t) {
      if (this.div && !t) {
        var n = this.getMap();
        if (n instanceof google.maps.Map) {
          var r = 0, o = 0, i = n.getBounds();
          i && !i.contains(this.position) && n.setCenter(this.position);
          var a = n.getDiv(), s = a.offsetWidth, l = a.offsetHeight, u = this.pixelOffset.width, c = this.pixelOffset.height, p = this.div.offsetWidth, d = this.div.offsetHeight, g = this.infoBoxClearance.width, f = this.infoBoxClearance.height, m = this.getProjection(), b = m.fromLatLngToContainerPixel(this.position);
          b !== null && (b.x < -u + g ? r = b.x + u - g : b.x + p + u + g > s && (r = b.x + p + u + g - s), this.alignBottom ? b.y < -c + f + d ? o = b.y + c - f - d : b.y + c + f > l && (o = b.y + c + f - l) : b.y < -c + f ? o = b.y + c - f : b.y + d + c + f > l && (o = b.y + d + c + f - l)), r === 0 && o === 0 || n.panBy(r, o);
        }
      }
    }, e.prototype.setBoxStyle = function() {
      if (this.div) {
        this.div.className = this.boxClass, this.div.style.cssText = "";
        var t = this.boxStyle;
        for (var n in t)
          Object.prototype.hasOwnProperty.call(t, n) && (this.div.style[n] = t[n]);
        if (this.div.style.webkitTransform = "translateZ(0)", typeof this.div.style.opacity < "u" && this.div.style.opacity !== "") {
          var r = parseFloat(this.div.style.opacity || "");
          this.div.style.msFilter = '"progid:DXImageTransform.Microsoft.Alpha(Opacity=' + r * 100 + ')"', this.div.style.filter = "alpha(opacity=" + r * 100 + ")";
        }
        this.div.style.position = "absolute", this.div.style.visibility = "hidden", this.zIndex !== null && (this.div.style.zIndex = this.zIndex + ""), this.div.style.overflow || (this.div.style.overflow = "auto");
      }
    }, e.prototype.getBoxWidths = function() {
      var t = {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0
      };
      if (!this.div)
        return t;
      if (document.defaultView) {
        var n = this.div.ownerDocument, r = n && n.defaultView ? n.defaultView.getComputedStyle(this.div, "") : null;
        r && (t.top = parseInt(r.borderTopWidth || "", 10) || 0, t.bottom = parseInt(r.borderBottomWidth || "", 10) || 0, t.left = parseInt(r.borderLeftWidth || "", 10) || 0, t.right = parseInt(r.borderRightWidth || "", 10) || 0);
      } else if (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        document.documentElement.currentStyle
      ) {
        var o = this.div.currentStyle;
        o && (t.top = parseInt(o.borderTopWidth || "", 10) || 0, t.bottom = parseInt(o.borderBottomWidth || "", 10) || 0, t.left = parseInt(o.borderLeftWidth || "", 10) || 0, t.right = parseInt(o.borderRightWidth || "", 10) || 0);
      }
      return t;
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.div.parentNode.removeChild(this.div), this.div = null);
    }, e.prototype.draw = function() {
      if (this.createInfoBoxDiv(), this.div) {
        var t = this.getProjection(), n = t.fromLatLngToDivPixel(this.position);
        n !== null && (this.div.style.left = n.x + this.pixelOffset.width + "px", this.alignBottom ? this.div.style.bottom = -(n.y + this.pixelOffset.height) + "px" : this.div.style.top = n.y + this.pixelOffset.height + "px"), this.isHidden ? this.div.style.visibility = "hidden" : this.div.style.visibility = "visible";
      }
    }, e.prototype.setOptions = function(t) {
      t === void 0 && (t = {}), typeof t.boxClass < "u" && (this.boxClass = t.boxClass, this.setBoxStyle()), typeof t.boxStyle < "u" && (this.boxStyle = t.boxStyle, this.setBoxStyle()), typeof t.content < "u" && this.setContent(t.content), typeof t.disableAutoPan < "u" && (this.disableAutoPan = t.disableAutoPan), typeof t.maxWidth < "u" && (this.maxWidth = t.maxWidth), typeof t.pixelOffset < "u" && (this.pixelOffset = t.pixelOffset), typeof t.alignBottom < "u" && (this.alignBottom = t.alignBottom), typeof t.position < "u" && this.setPosition(t.position), typeof t.zIndex < "u" && this.setZIndex(t.zIndex), typeof t.closeBoxMargin < "u" && (this.closeBoxMargin = t.closeBoxMargin), typeof t.closeBoxURL < "u" && (this.closeBoxURL = t.closeBoxURL), typeof t.infoBoxClearance < "u" && (this.infoBoxClearance = t.infoBoxClearance), typeof t.isHidden < "u" && (this.isHidden = t.isHidden), typeof t.visible < "u" && (this.isHidden = !t.visible), typeof t.enableEventPropagation < "u" && (this.enableEventPropagation = t.enableEventPropagation), this.div && this.draw();
    }, e.prototype.setContent = function(t) {
      this.content = t, this.div && (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.fixedWidthSet || (this.div.style.width = ""), typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t)), this.fixedWidthSet || (this.div.style.width = this.div.offsetWidth + "px", typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t))), this.addClickHandler()), google.maps.event.trigger(this, "content_changed");
    }, e.prototype.setPosition = function(t) {
      this.position = t, this.div && this.draw(), google.maps.event.trigger(this, "position_changed");
    }, e.prototype.setVisible = function(t) {
      this.isHidden = !t, this.div && (this.div.style.visibility = this.isHidden ? "hidden" : "visible");
    }, e.prototype.setZIndex = function(t) {
      this.zIndex = t, this.div && (this.div.style.zIndex = t + ""), google.maps.event.trigger(this, "zindex_changed");
    }, e.prototype.getContent = function() {
      return this.content;
    }, e.prototype.getPosition = function() {
      return this.position;
    }, e.prototype.getZIndex = function() {
      return this.zIndex;
    }, e.prototype.getVisible = function() {
      var t = this.getMap();
      return typeof t > "u" || t === null ? !1 : !this.isHidden;
    }, e.prototype.show = function() {
      this.isHidden = !1, this.div && (this.div.style.visibility = "visible");
    }, e.prototype.hide = function() {
      this.isHidden = !0, this.div && (this.div.style.visibility = "hidden");
    }, e.prototype.open = function(t, n) {
      var r = this;
      n && (this.position = n.getPosition(), this.moveListener = google.maps.event.addListener(n, "position_changed", function() {
        var o = n.getPosition();
        r.setPosition(o);
      }), this.mapListener = google.maps.event.addListener(n, "map_changed", function() {
        r.setMap(n.map);
      })), this.setMap(t), this.div && this.panBox();
    }, e.prototype.close = function() {
      if (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.eventListeners) {
        for (var t = 0, n = this.eventListeners; t < n.length; t++) {
          var r = n[t];
          google.maps.event.removeListener(r);
        }
        this.eventListeners = null;
      }
      this.moveListener && (google.maps.event.removeListener(this.moveListener), this.moveListener = null), this.mapListener && (google.maps.event.removeListener(this.mapListener), this.mapListener = null), this.contextListener && (google.maps.event.removeListener(this.contextListener), this.contextListener = null), this.setMap(null);
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype)
          Object.prototype.hasOwnProperty.call(this, o) || (this.prototype[o] = r.prototype[o]);
        return this;
      }).apply(t, [n]);
    }, e;
  }()
), $Se = ["position"], VSe = ["position"];
function yU(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Wb(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? yU(Object(n), !0).forEach(function(r) {
      _e(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : yU(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var bU = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, wU = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    t instanceof google.maps.LatLng ? e.setPosition(t) : e.setPosition(new google.maps.LatLng(t.lat, t.lng));
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, ZSe = {};
function qSe(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, g = ge(It), [f, m] = k(null), [b, E] = k(null), [w, M] = k(null), [x, v] = k(null), [C, P] = k(null), [F, L] = k(null), B = dt(null);
  return h(() => {
    g && f !== null && (f.close(), n ? f.open(g, n) : f.getPosition() && f.open(g));
  }, [g, f, n]), h(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), h(() => {
    if (o && f !== null) {
      var N = o instanceof google.maps.LatLng ? o : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        new google.maps.LatLng(o.lat, o.lng)
      );
      f.setPosition(N);
    }
  }, [o]), h(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), h(() => {
    f && a && (b !== null && google.maps.event.removeListener(b), E(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), h(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), M(google.maps.event.addListener(f, "domready", s)));
  }, [s]), h(() => {
    f && l && (x !== null && google.maps.event.removeListener(x), v(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), h(() => {
    f && u && (C !== null && google.maps.event.removeListener(C), P(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), h(() => {
    f && c && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), h(() => {
    if (g) {
      var N = r || ZSe, {
        position: $
      } = N, V = UD(N, $Se), H;
      $ && !($ instanceof google.maps.LatLng) && (H = new google.maps.LatLng($.lat, $.lng));
      var Z = new bee(Wb(Wb({}, V), H ? {
        position: H
      } : {}));
      B.current = document.createElement("div"), m(Z), a && E(google.maps.event.addListener(Z, "closeclick", a)), s && M(google.maps.event.addListener(Z, "domready", s)), l && v(google.maps.event.addListener(Z, "content_changed", l)), u && P(google.maps.event.addListener(Z, "position_changed", u)), c && L(google.maps.event.addListener(Z, "zindex_changed", c)), Z.setContent(B.current), n ? Z.open(g, n) : Z.getPosition() ? Z.open(g) : Ho(!1, "You must provide either an anchor or a position prop for <InfoBox>."), p && p(Z);
    }
    return () => {
      f !== null && (b && google.maps.event.removeListener(b), x && google.maps.event.removeListener(x), w && google.maps.event.removeListener(w), C && google.maps.event.removeListener(C), F && google.maps.event.removeListener(F), d && d(f), f.close());
    };
  }, []), B.current ? zn(at.only(t), B.current) : null;
}
me(qSe);
class GSe extends pe {
  constructor() {
    super(...arguments), _e(this, "registeredEvents", []), _e(this, "containerElement", null), _e(this, "state", {
      infoBox: null
    }), _e(this, "open", (t, n) => {
      n ? this.context !== null && t.open(this.context, n) : t.getPosition() ? this.context !== null && t.open(this.context) : Ho(!1, "You must provide either an anchor or a position prop for <InfoBox>.");
    }), _e(this, "setInfoBoxCallback", () => {
      this.state.infoBox !== null && this.containerElement !== null && (this.state.infoBox.setContent(this.containerElement), this.open(this.state.infoBox, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoBox));
    });
  }
  componentDidMount() {
    var t = this.props.options || {}, {
      position: n
    } = t, r = UD(t, VSe), o;
    n && !(n instanceof google.maps.LatLng) && (o = new google.maps.LatLng(n.lat, n.lng));
    var i = new bee(Wb(Wb({}, r), o ? {
      position: o
    } : {}));
    this.containerElement = document.createElement("div"), this.registeredEvents = yn({
      updaterMap: wU,
      eventMap: bU,
      prevProps: {},
      nextProps: this.props,
      instance: i
    }), this.setState({
      infoBox: i
    }, this.setInfoBoxCallback);
  }
  componentDidUpdate(t) {
    var {
      infoBox: n
    } = this.state;
    n !== null && (kn(this.registeredEvents), this.registeredEvents = yn({
      updaterMap: wU,
      eventMap: bU,
      prevProps: t,
      nextProps: this.props,
      instance: n
    }));
  }
  componentWillUnmount() {
    var {
      onUnmount: t
    } = this.props, {
      infoBox: n
    } = this.state;
    n !== null && (t && t(n), kn(this.registeredEvents), n.close());
  }
  render() {
    return this.containerElement ? zn(at.only(this.props.children), this.containerElement) : null;
  }
}
_e(GSe, "contextType", It);
var CU, OU;
function KSe() {
  return OU || (OU = 1, CU = function e(t, n) {
    if (t === n) return !0;
    if (t && n && typeof t == "object" && typeof n == "object") {
      if (t.constructor !== n.constructor) return !1;
      var r, o, i;
      if (Array.isArray(t)) {
        if (r = t.length, r != n.length) return !1;
        for (o = r; o-- !== 0; ) if (!e(t[o], n[o])) return !1;
        return !0;
      }
      if (t.constructor === RegExp) return t.source === n.source && t.flags === n.flags;
      if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === n.valueOf();
      if (t.toString !== Object.prototype.toString) return t.toString() === n.toString();
      if (i = Object.keys(t), r = i.length, r !== Object.keys(n).length) return !1;
      for (o = r; o-- !== 0; ) if (!Object.prototype.hasOwnProperty.call(n, i[o])) return !1;
      for (o = r; o-- !== 0; ) {
        var a = i[o];
        if (!e(t[a], n[a])) return !1;
      }
      return !0;
    }
    return t !== t && n !== n;
  }), CU;
}
var XSe = KSe(), xU = /* @__PURE__ */ dee(XSe), EU = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array], PE = 1, Cd = 8;
class HD {
  /**
   * Creates an index from raw `ArrayBuffer` data.
   * @param {ArrayBuffer} data
   */
  static from(t) {
    if (!(t instanceof ArrayBuffer))
      throw new Error("Data must be an instance of ArrayBuffer.");
    var [n, r] = new Uint8Array(t, 0, 2);
    if (n !== 219)
      throw new Error("Data does not appear to be in a KDBush format.");
    var o = r >> 4;
    if (o !== PE)
      throw new Error("Got v".concat(o, " data when expected v").concat(PE, "."));
    var i = EU[r & 15];
    if (!i)
      throw new Error("Unrecognized array type.");
    var [a] = new Uint16Array(t, 2, 1), [s] = new Uint32Array(t, 4, 1);
    return new HD(s, a, i, t);
  }
  /**
   * Creates an index that will hold a given number of items.
   * @param {number} numItems
   * @param {number} [nodeSize=64] Size of the KD-tree node (64 by default).
   * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).
   * @param {ArrayBuffer} [data] (For internal use only)
   */
  constructor(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 64, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Float64Array, o = arguments.length > 3 ? arguments[3] : void 0;
    if (isNaN(t) || t < 0) throw new Error("Unpexpected numItems value: ".concat(t, "."));
    this.numItems = +t, this.nodeSize = Math.min(Math.max(+n, 2), 65535), this.ArrayType = r, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
    var i = EU.indexOf(this.ArrayType), a = t * 2 * this.ArrayType.BYTES_PER_ELEMENT, s = t * this.IndexArrayType.BYTES_PER_ELEMENT, l = (8 - s % 8) % 8;
    if (i < 0)
      throw new Error("Unexpected typed array class: ".concat(r, "."));
    o && o instanceof ArrayBuffer ? (this.data = o, this.ids = new this.IndexArrayType(this.data, Cd, t), this.coords = new this.ArrayType(this.data, Cd + s + l, t * 2), this._pos = t * 2, this._finished = !0) : (this.data = new ArrayBuffer(Cd + a + s + l), this.ids = new this.IndexArrayType(this.data, Cd, t), this.coords = new this.ArrayType(this.data, Cd + s + l, t * 2), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, (PE << 4) + i]), new Uint16Array(this.data, 2, 1)[0] = n, new Uint32Array(this.data, 4, 1)[0] = t);
  }
  /**
   * Add a point to the index.
   * @param {number} x
   * @param {number} y
   * @returns {number} An incremental index associated with the added item (starting from `0`).
   */
  add(t, n) {
    var r = this._pos >> 1;
    return this.ids[r] = r, this.coords[this._pos++] = t, this.coords[this._pos++] = n, r;
  }
  /**
   * Perform indexing of the added points.
   */
  finish() {
    var t = this._pos >> 1;
    if (t !== this.numItems)
      throw new Error("Added ".concat(t, " items when expected ").concat(this.numItems, "."));
    return F_(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
  }
  /**
   * Search the index for items within a given bounding box.
   * @param {number} minX
   * @param {number} minY
   * @param {number} maxX
   * @param {number} maxY
   * @returns {number[]} An array of indices correponding to the found items.
   */
  range(t, n, r, o) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: i,
      coords: a,
      nodeSize: s
    } = this, l = [0, i.length - 1, 0], u = []; l.length; ) {
      var c = l.pop() || 0, p = l.pop() || 0, d = l.pop() || 0;
      if (p - d <= s) {
        for (var g = d; g <= p; g++) {
          var f = a[2 * g], m = a[2 * g + 1];
          f >= t && f <= r && m >= n && m <= o && u.push(i[g]);
        }
        continue;
      }
      var b = d + p >> 1, E = a[2 * b], w = a[2 * b + 1];
      E >= t && E <= r && w >= n && w <= o && u.push(i[b]), (c === 0 ? t <= E : n <= w) && (l.push(d), l.push(b - 1), l.push(1 - c)), (c === 0 ? r >= E : o >= w) && (l.push(b + 1), l.push(p), l.push(1 - c));
    }
    return u;
  }
  /**
   * Search the index for items within a given radius.
   * @param {number} qx
   * @param {number} qy
   * @param {number} r Query radius.
   * @returns {number[]} An array of indices correponding to the found items.
   */
  within(t, n, r) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: o,
      coords: i,
      nodeSize: a
    } = this, s = [0, o.length - 1, 0], l = [], u = r * r; s.length; ) {
      var c = s.pop() || 0, p = s.pop() || 0, d = s.pop() || 0;
      if (p - d <= a) {
        for (var g = d; g <= p; g++)
          kU(i[2 * g], i[2 * g + 1], t, n) <= u && l.push(o[g]);
        continue;
      }
      var f = d + p >> 1, m = i[2 * f], b = i[2 * f + 1];
      kU(m, b, t, n) <= u && l.push(o[f]), (c === 0 ? t - r <= m : n - r <= b) && (s.push(d), s.push(f - 1), s.push(1 - c)), (c === 0 ? t + r >= m : n + r >= b) && (s.push(f + 1), s.push(p), s.push(1 - c));
    }
    return l;
  }
}
function F_(e, t, n, r, o, i) {
  if (!(o - r <= n)) {
    var a = r + o >> 1;
    wee(e, t, a, r, o, i), F_(e, t, n, r, a - 1, 1 - i), F_(e, t, n, a + 1, o, 1 - i);
  }
}
function wee(e, t, n, r, o, i) {
  for (; o > r; ) {
    if (o - r > 600) {
      var a = o - r + 1, s = n - r + 1, l = Math.log(a), u = 0.5 * Math.exp(2 * l / 3), c = 0.5 * Math.sqrt(l * u * (a - u) / a) * (s - a / 2 < 0 ? -1 : 1), p = Math.max(r, Math.floor(n - s * u / a + c)), d = Math.min(o, Math.floor(n + (a - s) * u / a + c));
      wee(e, t, n, p, d, i);
    }
    var g = t[2 * n + i], f = r, m = o;
    for (Od(e, t, r, n), t[2 * o + i] > g && Od(e, t, r, o); f < m; ) {
      for (Od(e, t, f, m), f++, m--; t[2 * f + i] < g; ) f++;
      for (; t[2 * m + i] > g; ) m--;
    }
    t[2 * r + i] === g ? Od(e, t, r, m) : (m++, Od(e, t, m, o)), m <= n && (r = m + 1), n <= m && (o = m - 1);
  }
}
function Od(e, t, n, r) {
  SE(e, n, r), SE(t, 2 * n, 2 * r), SE(t, 2 * n + 1, 2 * r + 1);
}
function SE(e, t, n) {
  var r = e[t];
  e[t] = e[n], e[n] = r;
}
function kU(e, t, n, r) {
  var o = e - n, i = t - r;
  return o * o + i * i;
}
var YSe = {
  minZoom: 0,
  // min zoom to generate clusters on
  maxZoom: 16,
  // max zoom level to cluster the points on
  minPoints: 2,
  // minimum points to form a cluster
  radius: 40,
  // cluster radius in pixels
  extent: 512,
  // tile extent (radius is calculated relative to it)
  nodeSize: 64,
  // size of the KD-tree leaf node, affects performance
  log: !1,
  // whether to log timing info
  // whether to generate numeric ids for input features (in vector tiles)
  generateId: !1,
  // a reduce function for calculating custom cluster properties
  reduce: null,
  // (accumulated, props) => { accumulated.sum += props.sum; }
  // properties to use for individual points when running the reducer
  map: (e) => e
  // props => ({sum: props.my_value})
}, LU = Math.fround || /* @__PURE__ */ ((e) => (t) => (e[0] = +t, e[0]))(new Float32Array(1)), Iu = 2, zl = 3, ME = 4, Tl = 5, Cee = 6;
class JSe {
  constructor(t) {
    this.options = Object.assign(Object.create(YSe), t), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
  }
  load(t) {
    var {
      log: n,
      minZoom: r,
      maxZoom: o
    } = this.options;
    n && console.time("total time");
    var i = "prepare ".concat(t.length, " points");
    n && console.time(i), this.points = t;
    for (var a = [], s = 0; s < t.length; s++) {
      var l = t[s];
      if (l.geometry) {
        var [u, c] = l.geometry.coordinates, p = LU(lv(u)), d = LU(uv(c));
        a.push(
          p,
          d,
          // projected point coordinates
          1 / 0,
          // the last zoom the point was processed at
          s,
          // index of the source feature in the original input array
          -1,
          // parent cluster id
          1
          // number of points in a cluster
        ), this.options.reduce && a.push(0);
      }
    }
    var g = this.trees[o + 1] = this._createTree(a);
    n && console.timeEnd(i);
    for (var f = o; f >= r; f--) {
      var m = +Date.now();
      g = this.trees[f] = this._createTree(this._cluster(g, f)), n && console.log("z%d: %d clusters in %dms", f, g.numItems, +Date.now() - m);
    }
    return n && console.timeEnd("total time"), this;
  }
  getClusters(t, n) {
    var r = ((t[0] + 180) % 360 + 360) % 360 - 180, o = Math.max(-90, Math.min(90, t[1])), i = t[2] === 180 ? 180 : ((t[2] + 180) % 360 + 360) % 360 - 180, a = Math.max(-90, Math.min(90, t[3]));
    if (t[2] - t[0] >= 360)
      r = -180, i = 180;
    else if (r > i) {
      var s = this.getClusters([r, o, 180, a], n), l = this.getClusters([-180, o, i, a], n);
      return s.concat(l);
    }
    var u = this.trees[this._limitZoom(n)], c = u.range(lv(r), uv(a), lv(i), uv(o)), p = u.data, d = [];
    for (var g of c) {
      var f = this.stride * g;
      d.push(p[f + Tl] > 1 ? _U(p, f, this.clusterProps) : this.points[p[f + zl]]);
    }
    return d;
  }
  getChildren(t) {
    var n = this._getOriginId(t), r = this._getOriginZoom(t), o = "No cluster with the specified id.", i = this.trees[r];
    if (!i) throw new Error(o);
    var a = i.data;
    if (n * this.stride >= a.length) throw new Error(o);
    var s = this.options.radius / (this.options.extent * Math.pow(2, r - 1)), l = a[n * this.stride], u = a[n * this.stride + 1], c = i.within(l, u, s), p = [];
    for (var d of c) {
      var g = d * this.stride;
      a[g + ME] === t && p.push(a[g + Tl] > 1 ? _U(a, g, this.clusterProps) : this.points[a[g + zl]]);
    }
    if (p.length === 0) throw new Error(o);
    return p;
  }
  getLeaves(t, n, r) {
    n = n || 10, r = r || 0;
    var o = [];
    return this._appendLeaves(o, t, n, r, 0), o;
  }
  getTile(t, n, r) {
    var o = this.trees[this._limitZoom(t)], i = Math.pow(2, t), {
      extent: a,
      radius: s
    } = this.options, l = s / a, u = (r - l) / i, c = (r + 1 + l) / i, p = {
      features: []
    };
    return this._addTileFeatures(o.range((n - l) / i, u, (n + 1 + l) / i, c), o.data, n, r, i, p), n === 0 && this._addTileFeatures(o.range(1 - l / i, u, 1, c), o.data, i, r, i, p), n === i - 1 && this._addTileFeatures(o.range(0, u, l / i, c), o.data, -1, r, i, p), p.features.length ? p : null;
  }
  getClusterExpansionZoom(t) {
    for (var n = this._getOriginZoom(t) - 1; n <= this.options.maxZoom; ) {
      var r = this.getChildren(t);
      if (n++, r.length !== 1) break;
      t = r[0].properties.cluster_id;
    }
    return n;
  }
  _appendLeaves(t, n, r, o, i) {
    var a = this.getChildren(n);
    for (var s of a) {
      var l = s.properties;
      if (l && l.cluster ? i + l.point_count <= o ? i += l.point_count : i = this._appendLeaves(t, l.cluster_id, r, o, i) : i < o ? i++ : t.push(s), t.length === r) break;
    }
    return i;
  }
  _createTree(t) {
    for (var n = new HD(t.length / this.stride | 0, this.options.nodeSize, Float32Array), r = 0; r < t.length; r += this.stride) n.add(t[r], t[r + 1]);
    return n.finish(), n.data = t, n;
  }
  _addTileFeatures(t, n, r, o, i, a) {
    for (var s of t) {
      var l = s * this.stride, u = n[l + Tl] > 1, c = void 0, p = void 0, d = void 0;
      if (u)
        c = Oee(n, l, this.clusterProps), p = n[l], d = n[l + 1];
      else {
        var g = this.points[n[l + zl]];
        c = g.properties;
        var [f, m] = g.geometry.coordinates;
        p = lv(f), d = uv(m);
      }
      var b = {
        type: 1,
        geometry: [[Math.round(this.options.extent * (p * i - r)), Math.round(this.options.extent * (d * i - o))]],
        tags: c
      }, E = void 0;
      u || this.options.generateId ? E = n[l + zl] : E = this.points[n[l + zl]].id, E !== void 0 && (b.id = E), a.features.push(b);
    }
  }
  _limitZoom(t) {
    return Math.max(this.options.minZoom, Math.min(Math.floor(+t), this.options.maxZoom + 1));
  }
  _cluster(t, n) {
    for (var {
      radius: r,
      extent: o,
      reduce: i,
      minPoints: a
    } = this.options, s = r / (o * Math.pow(2, n)), l = t.data, u = [], c = this.stride, p = 0; p < l.length; p += c)
      if (!(l[p + Iu] <= n)) {
        l[p + Iu] = n;
        var d = l[p], g = l[p + 1], f = t.within(l[p], l[p + 1], s), m = l[p + Tl], b = m;
        for (var E of f) {
          var w = E * c;
          l[w + Iu] > n && (b += l[w + Tl]);
        }
        if (b > m && b >= a) {
          var M = d * m, x = g * m, v = void 0, C = -1, P = ((p / c | 0) << 5) + (n + 1) + this.points.length;
          for (var F of f) {
            var L = F * c;
            if (!(l[L + Iu] <= n)) {
              l[L + Iu] = n;
              var B = l[L + Tl];
              M += l[L] * B, x += l[L + 1] * B, l[L + ME] = P, i && (v || (v = this._map(l, p, !0), C = this.clusterProps.length, this.clusterProps.push(v)), i(v, this._map(l, L)));
            }
          }
          l[p + ME] = P, u.push(M / b, x / b, 1 / 0, P, -1, b), i && u.push(C);
        } else {
          for (var N = 0; N < c; N++) u.push(l[p + N]);
          if (b > 1)
            for (var $ of f) {
              var V = $ * c;
              if (!(l[V + Iu] <= n)) {
                l[V + Iu] = n;
                for (var H = 0; H < c; H++) u.push(l[V + H]);
              }
            }
        }
      }
    return u;
  }
  // get index of the point from which the cluster originated
  _getOriginId(t) {
    return t - this.points.length >> 5;
  }
  // get zoom of the point from which the cluster originated
  _getOriginZoom(t) {
    return (t - this.points.length) % 32;
  }
  _map(t, n, r) {
    if (t[n + Tl] > 1) {
      var o = this.clusterProps[t[n + Cee]];
      return r ? Object.assign({}, o) : o;
    }
    var i = this.points[t[n + zl]].properties, a = this.options.map(i);
    return r && a === i ? Object.assign({}, a) : a;
  }
}
function _U(e, t, n) {
  return {
    type: "Feature",
    id: e[t + zl],
    properties: Oee(e, t, n),
    geometry: {
      type: "Point",
      coordinates: [QSe(e[t]), eMe(e[t + 1])]
    }
  };
}
function Oee(e, t, n) {
  var r = e[t + Tl], o = r >= 1e4 ? "".concat(Math.round(r / 1e3), "k") : r >= 1e3 ? "".concat(Math.round(r / 100) / 10, "k") : r, i = e[t + Cee], a = i === -1 ? {} : Object.assign({}, n[i]);
  return Object.assign(a, {
    cluster: !0,
    cluster_id: e[t + zl],
    point_count: r,
    point_count_abbreviated: o
  });
}
function lv(e) {
  return e / 360 + 0.5;
}
function uv(e) {
  var t = Math.sin(e * Math.PI / 180), n = 0.5 - 0.25 * Math.log((1 + t) / (1 - t)) / Math.PI;
  return n < 0 ? 0 : n > 1 ? 1 : n;
}
function QSe(e) {
  return (e - 0.5) * 360;
}
function eMe(e) {
  var t = (180 - e * 360) * Math.PI / 180;
  return 360 * Math.atan(Math.exp(t)) / Math.PI - 90;
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function tMe(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
    t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
  return n;
}
class ps {
  static isAdvancedMarkerAvailable(t) {
    return google.maps.marker && t.getMapCapabilities().isAdvancedMarkersAvailable === !0;
  }
  static isAdvancedMarker(t) {
    return google.maps.marker && t instanceof google.maps.marker.AdvancedMarkerElement;
  }
  static setMap(t, n) {
    this.isAdvancedMarker(t) ? t.map = n : t.setMap(n);
  }
  static getPosition(t) {
    if (this.isAdvancedMarker(t)) {
      if (t.position) {
        if (t.position instanceof google.maps.LatLng)
          return t.position;
        if (t.position.lat && t.position.lng)
          return new google.maps.LatLng(t.position.lat, t.position.lng);
      }
      return new google.maps.LatLng(null);
    }
    return t.getPosition();
  }
  static getVisible(t) {
    return this.isAdvancedMarker(t) ? !0 : t.getVisible();
  }
}
class z_ {
  constructor(t) {
    var {
      markers: n,
      position: r
    } = t;
    this.markers = n, r && (r instanceof google.maps.LatLng ? this._position = r : this._position = new google.maps.LatLng(r));
  }
  get bounds() {
    if (!(this.markers.length === 0 && !this._position)) {
      var t = new google.maps.LatLngBounds(this._position, this._position);
      for (var n of this.markers)
        t.extend(ps.getPosition(n));
      return t;
    }
  }
  get position() {
    return this._position || this.bounds.getCenter();
  }
  /**
   * Get the count of **visible** markers.
   */
  get count() {
    return this.markers.filter((t) => ps.getVisible(t)).length;
  }
  /**
   * Add a marker to the cluster.
   */
  push(t) {
    this.markers.push(t);
  }
  /**
   * Cleanup references and remove marker from map.
   */
  delete() {
    this.marker && (ps.setMap(this.marker, null), this.marker = void 0), this.markers.length = 0;
  }
}
class nMe {
  constructor(t) {
    var {
      maxZoom: n = 16
    } = t;
    this.maxZoom = n;
  }
  /**
   * Helper function to bypass clustering based upon some map state such as
   * zoom, number of markers, etc.
   *
   * ```typescript
   *  cluster({markers, map}: AlgorithmInput): Cluster[] {
   *    if (shouldBypassClustering(map)) {
   *      return this.noop({markers})
   *    }
   * }
   * ```
   */
  noop(t) {
    var {
      markers: n
    } = t;
    return rMe(n);
  }
}
var rMe = (e) => {
  var t = e.map((n) => new z_({
    position: ps.getPosition(n),
    markers: [n]
  }));
  return t;
};
class oMe extends nMe {
  constructor(t) {
    var {
      maxZoom: n,
      radius: r = 60
    } = t, o = tMe(t, ["maxZoom", "radius"]);
    super({
      maxZoom: n
    }), this.state = {
      zoom: -1
    }, this.superCluster = new JSe(Object.assign({
      maxZoom: this.maxZoom,
      radius: r
    }, o));
  }
  calculate(t) {
    var n = !1, r = {
      zoom: t.map.getZoom()
    };
    if (!xU(t.markers, this.markers)) {
      n = !0, this.markers = [...t.markers];
      var o = this.markers.map((i) => {
        var a = ps.getPosition(i), s = [a.lng(), a.lat()];
        return {
          type: "Feature",
          geometry: {
            type: "Point",
            coordinates: s
          },
          properties: {
            marker: i
          }
        };
      });
      this.superCluster.load(o);
    }
    return n || (this.state.zoom <= this.maxZoom || r.zoom <= this.maxZoom) && (n = !xU(this.state, r)), this.state = r, n && (this.clusters = this.cluster(t)), {
      clusters: this.clusters,
      changed: n
    };
  }
  cluster(t) {
    var {
      map: n
    } = t;
    return this.superCluster.getClusters([-180, -90, 180, 90], Math.round(n.getZoom())).map((r) => this.transformCluster(r));
  }
  transformCluster(t) {
    var {
      geometry: {
        coordinates: [n, r]
      },
      properties: o
    } = t;
    if (o.cluster)
      return new z_({
        markers: this.superCluster.getLeaves(o.cluster_id, 1 / 0).map((a) => a.properties.marker),
        position: {
          lat: r,
          lng: n
        }
      });
    var i = o.marker;
    return new z_({
      markers: [i],
      position: ps.getPosition(i)
    });
  }
}
class iMe {
  constructor(t, n) {
    this.markers = {
      sum: t.length
    };
    var r = n.map((i) => i.count), o = r.reduce((i, a) => i + a, 0);
    this.clusters = {
      count: n.length,
      markers: {
        mean: o / n.length,
        sum: o,
        min: Math.min(...r),
        max: Math.max(...r)
      }
    };
  }
}
class sMe {
  /**
   * The default render function for the library used by {@link MarkerClusterer}.
   *
   * Currently set to use the following:
   *
   * ```typescript
   * // change color if this cluster has more markers than the mean cluster
   * const color =
   *   count > Math.max(10, stats.clusters.markers.mean)
   *     ? "#ff0000"
   *     : "#0000ff";
   *
   * // create svg url with fill color
   * const svg = window.btoa(`
   * <svg fill="${color}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240">
   *   <circle cx="120" cy="120" opacity=".6" r="70" />
   *   <circle cx="120" cy="120" opacity=".3" r="90" />
   *   <circle cx="120" cy="120" opacity=".2" r="110" />
   *   <circle cx="120" cy="120" opacity=".1" r="130" />
   * </svg>`);
   *
   * // create marker using svg icon
   * return new google.maps.Marker({
   *   position,
   *   icon: {
   *     url: `data:image/svg+xml;base64,${svg}`,
   *     scaledSize: new google.maps.Size(45, 45),
   *   },
   *   label: {
   *     text: String(count),
   *     color: "rgba(255,255,255,0.9)",
   *     fontSize: "12px",
   *   },
   *   // adjust zIndex to be above other markers
   *   zIndex: 1000 + count,
   * });
   * ```
   */
  render(t, n, r) {
    var {
      count: o,
      position: i
    } = t, a = o > Math.max(10, n.clusters.markers.mean) ? "#ff0000" : "#0000ff", s = '<svg fill="'.concat(a, `" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" width="50" height="50">
<circle cx="120" cy="120" opacity=".6" r="70" />
<circle cx="120" cy="120" opacity=".3" r="90" />
<circle cx="120" cy="120" opacity=".2" r="110" />
<text x="50%" y="50%" style="fill:#fff" text-anchor="middle" font-size="50" dominant-baseline="middle" font-family="roboto,arial,sans-serif">`).concat(o, `</text>
</svg>`), l = "Cluster of ".concat(o, " markers"), u = Number(google.maps.Marker.MAX_ZINDEX) + o;
    if (ps.isAdvancedMarkerAvailable(r)) {
      var c = new DOMParser(), p = c.parseFromString(s, "image/svg+xml").documentElement;
      p.setAttribute("transform", "translate(0 25)");
      var d = {
        map: r,
        position: i,
        zIndex: u,
        title: l,
        content: p
      };
      return new google.maps.marker.AdvancedMarkerElement(d);
    }
    var g = {
      position: i,
      zIndex: u,
      title: l,
      icon: {
        url: "data:image/svg+xml;base64,".concat(btoa(s)),
        anchor: new google.maps.Point(25, 25)
      }
    };
    return new google.maps.Marker(g);
  }
}
function aMe(e, t) {
  for (var n in t.prototype)
    e.prototype[n] = t.prototype[n];
}
class WD {
  constructor() {
    aMe(WD, google.maps.OverlayView);
  }
}
var kf;
(function(e) {
  e.CLUSTERING_BEGIN = "clusteringbegin", e.CLUSTERING_END = "clusteringend", e.CLUSTER_CLICK = "click";
})(kf || (kf = {}));
var lMe = (e, t, n) => {
  n.fitBounds(t.bounds);
};
class uMe extends WD {
  constructor(t) {
    var {
      map: n,
      markers: r = [],
      algorithmOptions: o = {},
      algorithm: i = new oMe(o),
      renderer: a = new sMe(),
      onClusterClick: s = lMe
    } = t;
    super(), this.markers = [...r], this.clusters = [], this.algorithm = i, this.renderer = a, this.onClusterClick = s, n && this.setMap(n);
  }
  addMarker(t, n) {
    this.markers.includes(t) || (this.markers.push(t), n || this.render());
  }
  addMarkers(t, n) {
    t.forEach((r) => {
      this.addMarker(r, !0);
    }), n || this.render();
  }
  removeMarker(t, n) {
    var r = this.markers.indexOf(t);
    return r === -1 ? !1 : (ps.setMap(t, null), this.markers.splice(r, 1), n || this.render(), !0);
  }
  removeMarkers(t, n) {
    var r = !1;
    return t.forEach((o) => {
      r = this.removeMarker(o, !0) || r;
    }), r && !n && this.render(), r;
  }
  clearMarkers(t) {
    this.markers.length = 0, t || this.render();
  }
  /**
   * Recalculates and draws all the marker clusters.
   */
  render() {
    var t = this.getMap();
    if (t instanceof google.maps.Map && t.getProjection()) {
      google.maps.event.trigger(this, kf.CLUSTERING_BEGIN, this);
      var {
        clusters: n,
        changed: r
      } = this.algorithm.calculate({
        markers: this.markers,
        map: t,
        mapCanvasProjection: this.getProjection()
      });
      if (r || r == null) {
        var o = /* @__PURE__ */ new Set();
        for (var i of n)
          i.markers.length == 1 && o.add(i.markers[0]);
        var a = [];
        for (var s of this.clusters)
          s.marker != null && (s.markers.length == 1 ? o.has(s.marker) || ps.setMap(s.marker, null) : a.push(s.marker));
        this.clusters = n, this.renderClusters(), requestAnimationFrame(() => a.forEach((l) => ps.setMap(l, null)));
      }
      google.maps.event.trigger(this, kf.CLUSTERING_END, this);
    }
  }
  onAdd() {
    this.idleListener = this.getMap().addListener("idle", this.render.bind(this)), this.render();
  }
  onRemove() {
    google.maps.event.removeListener(this.idleListener), this.reset();
  }
  reset() {
    this.markers.forEach((t) => ps.setMap(t, null)), this.clusters.forEach((t) => t.delete()), this.clusters = [];
  }
  renderClusters() {
    var t = new iMe(this.markers, this.clusters), n = this.getMap();
    this.clusters.forEach((r) => {
      r.markers.length === 1 ? r.marker = r.markers[0] : (r.marker = this.renderer.render(r, t, n), r.markers.forEach((o) => ps.setMap(o, null)), this.onClusterClick && r.marker.addListener(
        "click",
        /* istanbul ignore next */
        (o) => {
          google.maps.event.trigger(this, kf.CLUSTER_CLICK, r), this.onClusterClick(o, r, n);
        }
      )), ps.setMap(r.marker, n);
    });
  }
}
function PU(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function SU(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? PU(Object(n), !0).forEach(function(r) {
      _e(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : PU(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function cMe(e) {
  var t = lSe(), [n, r] = k(null);
  return h(() => {
    if (t && n === null) {
      var o = new uMe(SU(SU({}, e), {}, {
        map: t
      }));
      r(o);
    }
  }, [t]), n;
}
function pMe(e) {
  var {
    children: t,
    options: n
  } = e, r = cMe(n);
  return r !== null ? t(r) : null;
}
me(pMe);
var MU = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, DU = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
function dMe(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, g = ge(It), [f, m] = k(null), [b, E] = k(null), [w, M] = k(null), [x, v] = k(null), [C, P] = k(null), [F, L] = k(null), B = dt(null);
  return h(() => {
    f !== null && (f.close(), n ? f.open(g, n) : f.getPosition() && f.open(g));
  }, [g, f, n]), h(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), h(() => {
    o && f !== null && f.setPosition(o);
  }, [o]), h(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), h(() => {
    f && a && (b !== null && google.maps.event.removeListener(b), E(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), h(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), M(google.maps.event.addListener(f, "domready", s)));
  }, [s]), h(() => {
    f && l && (x !== null && google.maps.event.removeListener(x), v(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), h(() => {
    f && u && (C !== null && google.maps.event.removeListener(C), P(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), h(() => {
    f && c && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), h(() => {
    var N = new google.maps.InfoWindow(r);
    return m(N), B.current = document.createElement("div"), a && E(google.maps.event.addListener(N, "closeclick", a)), s && M(google.maps.event.addListener(N, "domready", s)), l && v(google.maps.event.addListener(N, "content_changed", l)), u && P(google.maps.event.addListener(N, "position_changed", u)), c && L(google.maps.event.addListener(N, "zindex_changed", c)), N.setContent(B.current), o && N.setPosition(o), i && N.setZIndex(i), n ? N.open(g, n) : N.getPosition() ? N.open(g) : Ho(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>."), p && p(N), () => {
      b && google.maps.event.removeListener(b), x && google.maps.event.removeListener(x), w && google.maps.event.removeListener(w), C && google.maps.event.removeListener(C), F && google.maps.event.removeListener(F), d && d(N), N.close();
    };
  }, []), B.current ? zn(at.only(t), B.current) : null;
}
me(dMe);
class fMe extends pe {
  constructor() {
    super(...arguments), _e(this, "registeredEvents", []), _e(this, "containerElement", null), _e(this, "state", {
      infoWindow: null
    }), _e(this, "open", (t, n) => {
      n ? t.open(this.context, n) : t.getPosition() ? t.open(this.context) : Ho(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>.");
    }), _e(this, "setInfoWindowCallback", () => {
      this.state.infoWindow !== null && this.containerElement !== null && (this.state.infoWindow.setContent(this.containerElement), this.open(this.state.infoWindow, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoWindow));
    });
  }
  componentDidMount() {
    var t = new google.maps.InfoWindow(this.props.options);
    this.containerElement = document.createElement("div"), this.registeredEvents = yn({
      updaterMap: DU,
      eventMap: MU,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(() => ({
      infoWindow: t
    }), this.setInfoWindowCallback);
  }
  componentDidUpdate(t) {
    this.state.infoWindow !== null && (kn(this.registeredEvents), this.registeredEvents = yn({
      updaterMap: DU,
      eventMap: MU,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.infoWindow
    }));
  }
  componentWillUnmount() {
    this.state.infoWindow !== null && (kn(this.registeredEvents), this.props.onUnmount && this.props.onUnmount(this.state.infoWindow), this.state.infoWindow.close());
  }
  render() {
    return this.containerElement ? zn(at.only(this.props.children), this.containerElement) : null;
  }
}
_e(fMe, "contextType", It);
function TU(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function $b(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? TU(Object(n), !0).forEach(function(r) {
      _e(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : TU(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var jU = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, AU = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, hMe = {};
function gMe(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: g,
    onRightClick: f,
    onClick: m,
    onDrag: b,
    onLoad: E,
    onUnmount: w
  } = e, M = ge(It), [x, v] = k(null), [C, P] = k(null), [F, L] = k(null), [B, N] = k(null), [$, V] = k(null), [H, Z] = k(null), [K, Y] = k(null), [Q, J] = k(null), [_, D] = k(null), [z, S] = k(null), [W, O] = k(null), [j, U] = k(null);
  return h(() => {
    x !== null && x.setMap(M);
  }, [M]), h(() => {
    typeof t < "u" && x !== null && x.setOptions(t);
  }, [x, t]), h(() => {
    typeof n < "u" && x !== null && x.setDraggable(n);
  }, [x, n]), h(() => {
    typeof r < "u" && x !== null && x.setEditable(r);
  }, [x, r]), h(() => {
    typeof o < "u" && x !== null && x.setVisible(o);
  }, [x, o]), h(() => {
    typeof i < "u" && x !== null && x.setPath(i);
  }, [x, i]), h(() => {
    x && a && (C !== null && google.maps.event.removeListener(C), P(google.maps.event.addListener(x, "dblclick", a)));
  }, [a]), h(() => {
    x && s && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(x, "dragend", s)));
  }, [s]), h(() => {
    x && l && (B !== null && google.maps.event.removeListener(B), N(google.maps.event.addListener(x, "dragstart", l)));
  }, [l]), h(() => {
    x && u && ($ !== null && google.maps.event.removeListener($), V(google.maps.event.addListener(x, "mousedown", u)));
  }, [u]), h(() => {
    x && c && (H !== null && google.maps.event.removeListener(H), Z(google.maps.event.addListener(x, "mousemove", c)));
  }, [c]), h(() => {
    x && p && (K !== null && google.maps.event.removeListener(K), Y(google.maps.event.addListener(x, "mouseout", p)));
  }, [p]), h(() => {
    x && d && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(x, "mouseover", d)));
  }, [d]), h(() => {
    x && g && (_ !== null && google.maps.event.removeListener(_), D(google.maps.event.addListener(x, "mouseup", g)));
  }, [g]), h(() => {
    x && f && (z !== null && google.maps.event.removeListener(z), S(google.maps.event.addListener(x, "rightclick", f)));
  }, [f]), h(() => {
    x && m && (W !== null && google.maps.event.removeListener(W), O(google.maps.event.addListener(x, "click", m)));
  }, [m]), h(() => {
    x && b && (j !== null && google.maps.event.removeListener(j), U(google.maps.event.addListener(x, "drag", b)));
  }, [b]), h(() => {
    var T = new google.maps.Polyline($b($b({}, t || hMe), {}, {
      map: M
    }));
    return i && T.setPath(i), typeof o < "u" && T.setVisible(o), typeof r < "u" && T.setEditable(r), typeof n < "u" && T.setDraggable(n), a && P(google.maps.event.addListener(T, "dblclick", a)), s && L(google.maps.event.addListener(T, "dragend", s)), l && N(google.maps.event.addListener(T, "dragstart", l)), u && V(google.maps.event.addListener(T, "mousedown", u)), c && Z(google.maps.event.addListener(T, "mousemove", c)), p && Y(google.maps.event.addListener(T, "mouseout", p)), d && J(google.maps.event.addListener(T, "mouseover", d)), g && D(google.maps.event.addListener(T, "mouseup", g)), f && S(google.maps.event.addListener(T, "rightclick", f)), m && O(google.maps.event.addListener(T, "click", m)), b && U(google.maps.event.addListener(T, "drag", b)), v(T), E && E(T), () => {
      C !== null && google.maps.event.removeListener(C), F !== null && google.maps.event.removeListener(F), B !== null && google.maps.event.removeListener(B), $ !== null && google.maps.event.removeListener($), H !== null && google.maps.event.removeListener(H), K !== null && google.maps.event.removeListener(K), Q !== null && google.maps.event.removeListener(Q), _ !== null && google.maps.event.removeListener(_), z !== null && google.maps.event.removeListener(z), W !== null && google.maps.event.removeListener(W), w && w(T), T.setMap(null);
    };
  }, []), null;
}
me(gMe);
class mMe extends pe {
  constructor() {
    super(...arguments), _e(this, "registeredEvents", []), _e(this, "state", {
      polyline: null
    }), _e(this, "setPolylineCallback", () => {
      this.state.polyline !== null && this.props.onLoad && this.props.onLoad(this.state.polyline);
    });
  }
  componentDidMount() {
    var t = new google.maps.Polyline($b($b({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = yn({
      updaterMap: AU,
      eventMap: jU,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        polyline: t
      };
    }, this.setPolylineCallback);
  }
  componentDidUpdate(t) {
    this.state.polyline !== null && (kn(this.registeredEvents), this.registeredEvents = yn({
      updaterMap: AU,
      eventMap: jU,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.polyline
    }));
  }
  componentWillUnmount() {
    this.state.polyline !== null && (this.props.onUnmount && this.props.onUnmount(this.state.polyline), kn(this.registeredEvents), this.state.polyline.setMap(null));
  }
  render() {
    return null;
  }
}
_e(mMe, "contextType", It);
function RU(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function IU(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? RU(Object(n), !0).forEach(function(r) {
      _e(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : RU(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var NU = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, BU = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  paths(e, t) {
    e.setPaths(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function vMe(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    paths: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: g,
    onMouseUp: f,
    onRightClick: m,
    onClick: b,
    onDrag: E,
    onLoad: w,
    onUnmount: M,
    onEdit: x
  } = e, v = ge(It), [C, P] = k(null), [F, L] = k(null), [B, N] = k(null), [$, V] = k(null), [H, Z] = k(null), [K, Y] = k(null), [Q, J] = k(null), [_, D] = k(null), [z, S] = k(null), [W, O] = k(null), [j, U] = k(null), [T, q] = k(null);
  return h(() => {
    C !== null && C.setMap(v);
  }, [v]), h(() => {
    typeof t < "u" && C !== null && C.setOptions(t);
  }, [C, t]), h(() => {
    typeof n < "u" && C !== null && C.setDraggable(n);
  }, [C, n]), h(() => {
    typeof r < "u" && C !== null && C.setEditable(r);
  }, [C, r]), h(() => {
    typeof o < "u" && C !== null && C.setVisible(o);
  }, [C, o]), h(() => {
    typeof i < "u" && C !== null && C.setPath(i);
  }, [C, i]), h(() => {
    typeof a < "u" && C !== null && C.setPaths(a);
  }, [C, a]), h(() => {
    C && typeof s == "function" && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(C, "dblclick", s)));
  }, [s]), h(() => {
    C && (google.maps.event.addListener(C.getPath(), "insert_at", () => {
      x == null || x(C);
    }), google.maps.event.addListener(C.getPath(), "set_at", () => {
      x == null || x(C);
    }), google.maps.event.addListener(C.getPath(), "remove_at", () => {
      x == null || x(C);
    }));
  }, [C, x]), h(() => {
    C && typeof l == "function" && (B !== null && google.maps.event.removeListener(B), N(google.maps.event.addListener(C, "dragend", l)));
  }, [l]), h(() => {
    C && typeof u == "function" && ($ !== null && google.maps.event.removeListener($), V(google.maps.event.addListener(C, "dragstart", u)));
  }, [u]), h(() => {
    C && typeof c == "function" && (H !== null && google.maps.event.removeListener(H), Z(google.maps.event.addListener(C, "mousedown", c)));
  }, [c]), h(() => {
    C && typeof p == "function" && (K !== null && google.maps.event.removeListener(K), Y(google.maps.event.addListener(C, "mousemove", p)));
  }, [p]), h(() => {
    C && typeof d == "function" && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(C, "mouseout", d)));
  }, [d]), h(() => {
    C && typeof g == "function" && (_ !== null && google.maps.event.removeListener(_), D(google.maps.event.addListener(C, "mouseover", g)));
  }, [g]), h(() => {
    C && typeof f == "function" && (z !== null && google.maps.event.removeListener(z), S(google.maps.event.addListener(C, "mouseup", f)));
  }, [f]), h(() => {
    C && typeof m == "function" && (W !== null && google.maps.event.removeListener(W), O(google.maps.event.addListener(C, "rightclick", m)));
  }, [m]), h(() => {
    C && typeof b == "function" && (j !== null && google.maps.event.removeListener(j), U(google.maps.event.addListener(C, "click", b)));
  }, [b]), h(() => {
    C && typeof E == "function" && (T !== null && google.maps.event.removeListener(T), q(google.maps.event.addListener(C, "drag", E)));
  }, [E]), h(() => {
    var A = new google.maps.Polygon(IU(IU({}, t), {}, {
      map: v
    }));
    return i && A.setPath(i), a && A.setPaths(a), typeof o < "u" && A.setVisible(o), typeof r < "u" && A.setEditable(r), typeof n < "u" && A.setDraggable(n), s && L(google.maps.event.addListener(A, "dblclick", s)), l && N(google.maps.event.addListener(A, "dragend", l)), u && V(google.maps.event.addListener(A, "dragstart", u)), c && Z(google.maps.event.addListener(A, "mousedown", c)), p && Y(google.maps.event.addListener(A, "mousemove", p)), d && J(google.maps.event.addListener(A, "mouseout", d)), g && D(google.maps.event.addListener(A, "mouseover", g)), f && S(google.maps.event.addListener(A, "mouseup", f)), m && O(google.maps.event.addListener(A, "rightclick", m)), b && U(google.maps.event.addListener(A, "click", b)), E && q(google.maps.event.addListener(A, "drag", E)), P(A), w && w(A), () => {
      F !== null && google.maps.event.removeListener(F), B !== null && google.maps.event.removeListener(B), $ !== null && google.maps.event.removeListener($), H !== null && google.maps.event.removeListener(H), K !== null && google.maps.event.removeListener(K), Q !== null && google.maps.event.removeListener(Q), _ !== null && google.maps.event.removeListener(_), z !== null && google.maps.event.removeListener(z), W !== null && google.maps.event.removeListener(W), j !== null && google.maps.event.removeListener(j), M && M(A), A.setMap(null);
    };
  }, []), null;
}
me(vMe);
class yMe extends pe {
  constructor() {
    super(...arguments), _e(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this.props.options || {};
    this.polygon = new google.maps.Polygon(t), this.polygon.setMap(this.context), this.registeredEvents = yn({
      updaterMap: BU,
      eventMap: NU,
      prevProps: {},
      nextProps: this.props,
      instance: this.polygon
    }), this.props.onLoad && this.props.onLoad(this.polygon);
  }
  componentDidUpdate(t) {
    this.polygon && (kn(this.registeredEvents), this.registeredEvents = yn({
      updaterMap: BU,
      eventMap: NU,
      prevProps: t,
      nextProps: this.props,
      instance: this.polygon
    }));
  }
  componentWillUnmount() {
    this.polygon && (this.props.onUnmount && this.props.onUnmount(this.polygon), kn(this.registeredEvents), this.polygon && this.polygon.setMap(null));
  }
  render() {
    return null;
  }
}
_e(yMe, "contextType", It);
function FU(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Vb(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? FU(Object(n), !0).forEach(function(r) {
      _e(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : FU(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var zU = {
  onBoundsChanged: "bounds_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, UU = {
  bounds(e, t) {
    e.setBounds(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function bMe(e) {
  var {
    options: t,
    bounds: n,
    draggable: r,
    editable: o,
    visible: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: g,
    onRightClick: f,
    onClick: m,
    onDrag: b,
    onBoundsChanged: E,
    onLoad: w,
    onUnmount: M
  } = e, x = ge(It), [v, C] = k(null), [P, F] = k(null), [L, B] = k(null), [N, $] = k(null), [V, H] = k(null), [Z, K] = k(null), [Y, Q] = k(null), [J, _] = k(null), [D, z] = k(null), [S, W] = k(null), [O, j] = k(null), [U, T] = k(null), [q, A] = k(null);
  return h(() => {
    v !== null && v.setMap(x);
  }, [x]), h(() => {
    typeof t < "u" && v !== null && v.setOptions(t);
  }, [v, t]), h(() => {
    typeof r < "u" && v !== null && v.setDraggable(r);
  }, [v, r]), h(() => {
    typeof o < "u" && v !== null && v.setEditable(o);
  }, [v, o]), h(() => {
    typeof i < "u" && v !== null && v.setVisible(i);
  }, [v, i]), h(() => {
    typeof n < "u" && v !== null && v.setBounds(n);
  }, [v, n]), h(() => {
    v && a && (P !== null && google.maps.event.removeListener(P), F(google.maps.event.addListener(v, "dblclick", a)));
  }, [a]), h(() => {
    v && s && (L !== null && google.maps.event.removeListener(L), B(google.maps.event.addListener(v, "dragend", s)));
  }, [s]), h(() => {
    v && l && (N !== null && google.maps.event.removeListener(N), $(google.maps.event.addListener(v, "dragstart", l)));
  }, [l]), h(() => {
    v && u && (V !== null && google.maps.event.removeListener(V), H(google.maps.event.addListener(v, "mousedown", u)));
  }, [u]), h(() => {
    v && c && (Z !== null && google.maps.event.removeListener(Z), K(google.maps.event.addListener(v, "mousemove", c)));
  }, [c]), h(() => {
    v && p && (Y !== null && google.maps.event.removeListener(Y), Q(google.maps.event.addListener(v, "mouseout", p)));
  }, [p]), h(() => {
    v && d && (J !== null && google.maps.event.removeListener(J), _(google.maps.event.addListener(v, "mouseover", d)));
  }, [d]), h(() => {
    v && g && (D !== null && google.maps.event.removeListener(D), z(google.maps.event.addListener(v, "mouseup", g)));
  }, [g]), h(() => {
    v && f && (S !== null && google.maps.event.removeListener(S), W(google.maps.event.addListener(v, "rightclick", f)));
  }, [f]), h(() => {
    v && m && (O !== null && google.maps.event.removeListener(O), j(google.maps.event.addListener(v, "click", m)));
  }, [m]), h(() => {
    v && b && (U !== null && google.maps.event.removeListener(U), T(google.maps.event.addListener(v, "drag", b)));
  }, [b]), h(() => {
    v && E && (q !== null && google.maps.event.removeListener(q), A(google.maps.event.addListener(v, "bounds_changed", E)));
  }, [E]), h(() => {
    var X = new google.maps.Rectangle(Vb(Vb({}, t), {}, {
      map: x
    }));
    return typeof i < "u" && X.setVisible(i), typeof o < "u" && X.setEditable(o), typeof r < "u" && X.setDraggable(r), typeof n < "u" && X.setBounds(n), a && F(google.maps.event.addListener(X, "dblclick", a)), s && B(google.maps.event.addListener(X, "dragend", s)), l && $(google.maps.event.addListener(X, "dragstart", l)), u && H(google.maps.event.addListener(X, "mousedown", u)), c && K(google.maps.event.addListener(X, "mousemove", c)), p && Q(google.maps.event.addListener(X, "mouseout", p)), d && _(google.maps.event.addListener(X, "mouseover", d)), g && z(google.maps.event.addListener(X, "mouseup", g)), f && W(google.maps.event.addListener(X, "rightclick", f)), m && j(google.maps.event.addListener(X, "click", m)), b && T(google.maps.event.addListener(X, "drag", b)), E && A(google.maps.event.addListener(X, "bounds_changed", E)), C(X), w && w(X), () => {
      P !== null && google.maps.event.removeListener(P), L !== null && google.maps.event.removeListener(L), N !== null && google.maps.event.removeListener(N), V !== null && google.maps.event.removeListener(V), Z !== null && google.maps.event.removeListener(Z), Y !== null && google.maps.event.removeListener(Y), J !== null && google.maps.event.removeListener(J), D !== null && google.maps.event.removeListener(D), S !== null && google.maps.event.removeListener(S), O !== null && google.maps.event.removeListener(O), U !== null && google.maps.event.removeListener(U), q !== null && google.maps.event.removeListener(q), M && M(X), X.setMap(null);
    };
  }, []), null;
}
me(bMe);
class wMe extends pe {
  constructor() {
    super(...arguments), _e(this, "registeredEvents", []), _e(this, "state", {
      rectangle: null
    }), _e(this, "setRectangleCallback", () => {
      this.state.rectangle !== null && this.props.onLoad && this.props.onLoad(this.state.rectangle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Rectangle(Vb(Vb({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = yn({
      updaterMap: UU,
      eventMap: zU,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        rectangle: t
      };
    }, this.setRectangleCallback);
  }
  componentDidUpdate(t) {
    this.state.rectangle !== null && (kn(this.registeredEvents), this.registeredEvents = yn({
      updaterMap: UU,
      eventMap: zU,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.rectangle
    }));
  }
  componentWillUnmount() {
    this.state.rectangle !== null && (this.props.onUnmount && this.props.onUnmount(this.state.rectangle), kn(this.registeredEvents), this.state.rectangle.setMap(null));
  }
  render() {
    return null;
  }
}
_e(wMe, "contextType", It);
function HU(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Zb(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? HU(Object(n), !0).forEach(function(r) {
      _e(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : HU(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var WU = {
  onCenterChanged: "center_changed",
  onRadiusChanged: "radius_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, $U = {
  center(e, t) {
    e.setCenter(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  radius(e, t) {
    e.setRadius(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, CMe = {};
function OMe(e) {
  var {
    options: t,
    center: n,
    radius: r,
    draggable: o,
    editable: i,
    visible: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: g,
    onMouseUp: f,
    onRightClick: m,
    onClick: b,
    onDrag: E,
    onCenterChanged: w,
    onRadiusChanged: M,
    onLoad: x,
    onUnmount: v
  } = e, C = ge(It), [P, F] = k(null), [L, B] = k(null), [N, $] = k(null), [V, H] = k(null), [Z, K] = k(null), [Y, Q] = k(null), [J, _] = k(null), [D, z] = k(null), [S, W] = k(null), [O, j] = k(null), [U, T] = k(null), [q, A] = k(null), [X, I] = k(null), [le, he] = k(null);
  return h(() => {
    P !== null && P.setMap(C);
  }, [C]), h(() => {
    typeof t < "u" && P !== null && P.setOptions(t);
  }, [P, t]), h(() => {
    typeof o < "u" && P !== null && P.setDraggable(o);
  }, [P, o]), h(() => {
    typeof i < "u" && P !== null && P.setEditable(i);
  }, [P, i]), h(() => {
    typeof a < "u" && P !== null && P.setVisible(a);
  }, [P, a]), h(() => {
    typeof r == "number" && P !== null && P.setRadius(r);
  }, [P, r]), h(() => {
    typeof n < "u" && P !== null && P.setCenter(n);
  }, [P, n]), h(() => {
    P && s && (L !== null && google.maps.event.removeListener(L), B(google.maps.event.addListener(P, "dblclick", s)));
  }, [s]), h(() => {
    P && l && (N !== null && google.maps.event.removeListener(N), $(google.maps.event.addListener(P, "dragend", l)));
  }, [l]), h(() => {
    P && u && (V !== null && google.maps.event.removeListener(V), H(google.maps.event.addListener(P, "dragstart", u)));
  }, [u]), h(() => {
    P && c && (Z !== null && google.maps.event.removeListener(Z), K(google.maps.event.addListener(P, "mousedown", c)));
  }, [c]), h(() => {
    P && p && (Y !== null && google.maps.event.removeListener(Y), Q(google.maps.event.addListener(P, "mousemove", p)));
  }, [p]), h(() => {
    P && d && (J !== null && google.maps.event.removeListener(J), _(google.maps.event.addListener(P, "mouseout", d)));
  }, [d]), h(() => {
    P && g && (D !== null && google.maps.event.removeListener(D), z(google.maps.event.addListener(P, "mouseover", g)));
  }, [g]), h(() => {
    P && f && (S !== null && google.maps.event.removeListener(S), W(google.maps.event.addListener(P, "mouseup", f)));
  }, [f]), h(() => {
    P && m && (O !== null && google.maps.event.removeListener(O), j(google.maps.event.addListener(P, "rightclick", m)));
  }, [m]), h(() => {
    P && b && (U !== null && google.maps.event.removeListener(U), T(google.maps.event.addListener(P, "click", b)));
  }, [b]), h(() => {
    P && E && (q !== null && google.maps.event.removeListener(q), A(google.maps.event.addListener(P, "drag", E)));
  }, [E]), h(() => {
    P && w && (X !== null && google.maps.event.removeListener(X), I(google.maps.event.addListener(P, "center_changed", w)));
  }, [b]), h(() => {
    P && M && (le !== null && google.maps.event.removeListener(le), he(google.maps.event.addListener(P, "radius_changed", M)));
  }, [M]), h(() => {
    var oe = new google.maps.Circle(Zb(Zb({}, t || CMe), {}, {
      map: C
    }));
    return typeof r == "number" && oe.setRadius(r), typeof n < "u" && oe.setCenter(n), typeof r == "number" && oe.setRadius(r), typeof a < "u" && oe.setVisible(a), typeof i < "u" && oe.setEditable(i), typeof o < "u" && oe.setDraggable(o), s && B(google.maps.event.addListener(oe, "dblclick", s)), l && $(google.maps.event.addListener(oe, "dragend", l)), u && H(google.maps.event.addListener(oe, "dragstart", u)), c && K(google.maps.event.addListener(oe, "mousedown", c)), p && Q(google.maps.event.addListener(oe, "mousemove", p)), d && _(google.maps.event.addListener(oe, "mouseout", d)), g && z(google.maps.event.addListener(oe, "mouseover", g)), f && W(google.maps.event.addListener(oe, "mouseup", f)), m && j(google.maps.event.addListener(oe, "rightclick", m)), b && T(google.maps.event.addListener(oe, "click", b)), E && A(google.maps.event.addListener(oe, "drag", E)), w && I(google.maps.event.addListener(oe, "center_changed", w)), M && he(google.maps.event.addListener(oe, "radius_changed", M)), F(oe), x && x(oe), () => {
      L !== null && google.maps.event.removeListener(L), N !== null && google.maps.event.removeListener(N), V !== null && google.maps.event.removeListener(V), Z !== null && google.maps.event.removeListener(Z), Y !== null && google.maps.event.removeListener(Y), J !== null && google.maps.event.removeListener(J), D !== null && google.maps.event.removeListener(D), S !== null && google.maps.event.removeListener(S), O !== null && google.maps.event.removeListener(O), U !== null && google.maps.event.removeListener(U), X !== null && google.maps.event.removeListener(X), le !== null && google.maps.event.removeListener(le), v && v(oe), oe.setMap(null);
    };
  }, []), null;
}
me(OMe);
class xMe extends pe {
  constructor() {
    super(...arguments), _e(this, "registeredEvents", []), _e(this, "state", {
      circle: null
    }), _e(this, "setCircleCallback", () => {
      this.state.circle !== null && this.props.onLoad && this.props.onLoad(this.state.circle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Circle(Zb(Zb({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = yn({
      updaterMap: $U,
      eventMap: WU,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        circle: t
      };
    }, this.setCircleCallback);
  }
  componentDidUpdate(t) {
    this.state.circle !== null && (kn(this.registeredEvents), this.registeredEvents = yn({
      updaterMap: $U,
      eventMap: WU,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.circle
    }));
  }
  componentWillUnmount() {
    if (this.state.circle !== null) {
      var t;
      this.props.onUnmount && this.props.onUnmount(this.state.circle), kn(this.registeredEvents), (t = this.state.circle) === null || t === void 0 || t.setMap(null);
    }
  }
  render() {
    return null;
  }
}
_e(xMe, "contextType", It);
function VU(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function qb(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? VU(Object(n), !0).forEach(function(r) {
      _e(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : VU(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var ZU = {
  onClick: "click",
  onDblClick: "dblclick",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onAddFeature: "addfeature",
  onRemoveFeature: "removefeature",
  onRemoveProperty: "removeproperty",
  onSetGeometry: "setgeometry",
  onSetProperty: "setproperty"
}, qU = {
  add(e, t) {
    e.add(t);
  },
  addgeojson(e, t, n) {
    e.addGeoJson(t, n);
  },
  contains(e, t) {
    e.contains(t);
  },
  foreach(e, t) {
    e.forEach(t);
  },
  loadgeojson(e, t, n, r) {
    e.loadGeoJson(t, n, r);
  },
  overridestyle(e, t, n) {
    e.overrideStyle(t, n);
  },
  remove(e, t) {
    e.remove(t);
  },
  revertstyle(e, t) {
    e.revertStyle(t);
  },
  controlposition(e, t) {
    e.setControlPosition(t);
  },
  controls(e, t) {
    e.setControls(t);
  },
  drawingmode(e, t) {
    e.setDrawingMode(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  style(e, t) {
    e.setStyle(t);
  },
  togeojson(e, t) {
    e.toGeoJson(t);
  }
};
function EMe(e) {
  var {
    options: t,
    onClick: n,
    onDblClick: r,
    onMouseDown: o,
    onMouseMove: i,
    onMouseOut: a,
    onMouseOver: s,
    onMouseUp: l,
    onRightClick: u,
    onAddFeature: c,
    onRemoveFeature: p,
    onRemoveProperty: d,
    onSetGeometry: g,
    onSetProperty: f,
    onLoad: m,
    onUnmount: b
  } = e, E = ge(It), [w, M] = k(null), [x, v] = k(null), [C, P] = k(null), [F, L] = k(null), [B, N] = k(null), [$, V] = k(null), [H, Z] = k(null), [K, Y] = k(null), [Q, J] = k(null), [_, D] = k(null), [z, S] = k(null), [W, O] = k(null), [j, U] = k(null), [T, q] = k(null);
  return h(() => {
    w !== null && w.setMap(E);
  }, [E]), h(() => {
    w && r && (x !== null && google.maps.event.removeListener(x), v(google.maps.event.addListener(w, "dblclick", r)));
  }, [r]), h(() => {
    w && o && (C !== null && google.maps.event.removeListener(C), P(google.maps.event.addListener(w, "mousedown", o)));
  }, [o]), h(() => {
    w && i && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(w, "mousemove", i)));
  }, [i]), h(() => {
    w && a && (B !== null && google.maps.event.removeListener(B), N(google.maps.event.addListener(w, "mouseout", a)));
  }, [a]), h(() => {
    w && s && ($ !== null && google.maps.event.removeListener($), V(google.maps.event.addListener(w, "mouseover", s)));
  }, [s]), h(() => {
    w && l && (H !== null && google.maps.event.removeListener(H), Z(google.maps.event.addListener(w, "mouseup", l)));
  }, [l]), h(() => {
    w && u && (K !== null && google.maps.event.removeListener(K), Y(google.maps.event.addListener(w, "rightclick", u)));
  }, [u]), h(() => {
    w && n && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(w, "click", n)));
  }, [n]), h(() => {
    w && c && (_ !== null && google.maps.event.removeListener(_), D(google.maps.event.addListener(w, "addfeature", c)));
  }, [c]), h(() => {
    w && p && (z !== null && google.maps.event.removeListener(z), S(google.maps.event.addListener(w, "removefeature", p)));
  }, [p]), h(() => {
    w && d && (W !== null && google.maps.event.removeListener(W), O(google.maps.event.addListener(w, "removeproperty", d)));
  }, [d]), h(() => {
    w && g && (j !== null && google.maps.event.removeListener(j), U(google.maps.event.addListener(w, "setgeometry", g)));
  }, [g]), h(() => {
    w && f && (T !== null && google.maps.event.removeListener(T), q(google.maps.event.addListener(w, "setproperty", f)));
  }, [f]), h(() => {
    if (E !== null) {
      var A = new google.maps.Data(qb(qb({}, t), {}, {
        map: E
      }));
      r && v(google.maps.event.addListener(A, "dblclick", r)), o && P(google.maps.event.addListener(A, "mousedown", o)), i && L(google.maps.event.addListener(A, "mousemove", i)), a && N(google.maps.event.addListener(A, "mouseout", a)), s && V(google.maps.event.addListener(A, "mouseover", s)), l && Z(google.maps.event.addListener(A, "mouseup", l)), u && Y(google.maps.event.addListener(A, "rightclick", u)), n && J(google.maps.event.addListener(A, "click", n)), c && D(google.maps.event.addListener(A, "addfeature", c)), p && S(google.maps.event.addListener(A, "removefeature", p)), d && O(google.maps.event.addListener(A, "removeproperty", d)), g && U(google.maps.event.addListener(A, "setgeometry", g)), f && q(google.maps.event.addListener(A, "setproperty", f)), M(A), m && m(A);
    }
    return () => {
      w && (x !== null && google.maps.event.removeListener(x), C !== null && google.maps.event.removeListener(C), F !== null && google.maps.event.removeListener(F), B !== null && google.maps.event.removeListener(B), $ !== null && google.maps.event.removeListener($), H !== null && google.maps.event.removeListener(H), K !== null && google.maps.event.removeListener(K), Q !== null && google.maps.event.removeListener(Q), _ !== null && google.maps.event.removeListener(_), z !== null && google.maps.event.removeListener(z), W !== null && google.maps.event.removeListener(W), j !== null && google.maps.event.removeListener(j), T !== null && google.maps.event.removeListener(T), b && b(w), w.setMap(null));
    };
  }, []), null;
}
me(EMe);
class kMe extends pe {
  constructor() {
    super(...arguments), _e(this, "registeredEvents", []), _e(this, "state", {
      data: null
    }), _e(this, "setDataCallback", () => {
      this.state.data !== null && this.props.onLoad && this.props.onLoad(this.state.data);
    });
  }
  componentDidMount() {
    if (this.context !== null) {
      var t = new google.maps.Data(qb(qb({}, this.props.options), {}, {
        map: this.context
      }));
      this.registeredEvents = yn({
        updaterMap: qU,
        eventMap: ZU,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        data: t
      }), this.setDataCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.data !== null && (kn(this.registeredEvents), this.registeredEvents = yn({
      updaterMap: qU,
      eventMap: ZU,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.data
    }));
  }
  componentWillUnmount() {
    this.state.data !== null && (this.props.onUnmount && this.props.onUnmount(this.state.data), kn(this.registeredEvents), this.state.data && this.state.data.setMap(null));
  }
  render() {
    return null;
  }
}
_e(kMe, "contextType", It);
function GU(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function KU(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? GU(Object(n), !0).forEach(function(r) {
      _e(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : GU(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var XU = {
  onClick: "click",
  onDefaultViewportChanged: "defaultviewport_changed",
  onStatusChanged: "status_changed"
}, YU = {
  options(e, t) {
    e.setOptions(t);
  },
  url(e, t) {
    e.setUrl(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
class LMe extends pe {
  constructor() {
    super(...arguments), _e(this, "registeredEvents", []), _e(this, "state", {
      kmlLayer: null
    }), _e(this, "setKmlLayerCallback", () => {
      this.state.kmlLayer !== null && this.props.onLoad && this.props.onLoad(this.state.kmlLayer);
    });
  }
  componentDidMount() {
    var t = new google.maps.KmlLayer(KU(KU({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = yn({
      updaterMap: YU,
      eventMap: XU,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        kmlLayer: t
      };
    }, this.setKmlLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.kmlLayer !== null && (kn(this.registeredEvents), this.registeredEvents = yn({
      updaterMap: YU,
      eventMap: XU,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.kmlLayer
    }));
  }
  componentWillUnmount() {
    this.state.kmlLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.kmlLayer), kn(this.registeredEvents), this.state.kmlLayer.setMap(null));
  }
  render() {
    return null;
  }
}
_e(LMe, "contextType", It);
function xee(e, t) {
  return typeof t == "function" ? t(e.offsetWidth, e.offsetHeight) : {
    x: 0,
    y: 0
  };
}
function _Me(e, t) {
  return new t(e.lat, e.lng);
}
function PMe(e, t) {
  return new t(new google.maps.LatLng(e.ne.lat, e.ne.lng), new google.maps.LatLng(e.sw.lat, e.sw.lng));
}
function SMe(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function MMe(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function DMe(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n.getNorthEast()), o = e && e.fromLatLngToDivPixel(n.getSouthWest());
  return r && o ? {
    left: "".concat(o.x + t.x, "px"),
    top: "".concat(r.y + t.y, "px"),
    width: "".concat(r.x - o.x - t.x, "px"),
    height: "".concat(o.y - r.y - t.y, "px")
  } : {
    left: "-9999px",
    top: "-9999px"
  };
}
function TMe(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n);
  if (r) {
    var {
      x: o,
      y: i
    } = r;
    return {
      left: "".concat(o + t.x, "px"),
      top: "".concat(i + t.y, "px")
    };
  }
  return {
    left: "-9999px",
    top: "-9999px"
  };
}
function Eee(e, t, n, r) {
  return n !== void 0 ? DMe(e, t, MMe(n, google.maps.LatLngBounds, PMe)) : TMe(e, t, SMe(r, google.maps.LatLng, _Me));
}
function jMe(e, t) {
  return e.left === t.left && e.top === t.top && e.width === t.height && e.height === t.height;
}
function JU(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function AMe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? JU(Object(n), !0).forEach(function(r) {
      _e(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : JU(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function RMe(e, t, n, r, o) {
  class i extends google.maps.OverlayView {
    constructor(s, l, u, c) {
      super(), this.container = s, this.pane = l, this.position = u, this.bounds = c;
    }
    onAdd() {
      var s, l = (s = this.getPanes()) === null || s === void 0 ? void 0 : s[this.pane];
      l == null || l.appendChild(this.container);
    }
    draw() {
      var s = this.getProjection(), l = AMe({}, this.container ? xee(this.container, o) : {
        x: 0,
        y: 0
      }), u = Eee(s, l, this.bounds, this.position);
      for (var [c, p] of Object.entries(u))
        this.container.style[c] = p;
    }
    onRemove() {
      this.container.parentNode !== null && this.container.parentNode.removeChild(this.container);
    }
  }
  return new i(e, t, n, r);
}
function QU(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function IMe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? QU(Object(n), !0).forEach(function(r) {
      _e(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : QU(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function eH(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLng ? e : new google.maps.LatLng(e.lat, e.lng);
  return t + "";
}
function tH(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLngBounds ? e : new google.maps.LatLngBounds(new google.maps.LatLng(e.south, e.east), new google.maps.LatLng(e.north, e.west));
  return t + "";
}
function NMe(e) {
  var {
    position: t,
    bounds: n,
    mapPaneName: r,
    zIndex: o,
    onLoad: i,
    onUnmount: a,
    getPixelPositionOffset: s,
    children: l
  } = e, u = ge(It), c = ln(() => {
    var d = document.createElement("div");
    return d.style.position = "absolute", d;
  }, []), p = ln(() => RMe(c, r, t, n, s), [c, r, t, n]);
  return h(() => (i == null || i(p), p == null || p.setMap(u), () => {
    a == null || a(p), p == null || p.setMap(null);
  }), [u, p]), h(() => {
    c.style.zIndex = "".concat(o);
  }, [o, c]), wi.createPortal(l, c);
}
me(NMe);
class Up extends pe {
  constructor(t) {
    super(t), _e(this, "state", {
      paneEl: null,
      containerStyle: {
        // set initial position
        position: "absolute"
      }
    }), _e(this, "updatePane", () => {
      var r = this.props.mapPaneName, o = this.overlayView.getPanes();
      Ho(!!r, "OverlayView requires props.mapPaneName but got %s", r), o ? this.setState({
        paneEl: o[r]
      }) : this.setState({
        paneEl: null
      });
    }), _e(this, "onAdd", () => {
      var r, o;
      this.updatePane(), (r = (o = this.props).onLoad) === null || r === void 0 || r.call(o, this.overlayView);
    }), _e(this, "onPositionElement", () => {
      var r = this.overlayView.getProjection(), o = IMe({
        x: 0,
        y: 0
      }, this.containerRef.current ? xee(this.containerRef.current, this.props.getPixelPositionOffset) : {}), i = Eee(r, o, this.props.bounds, this.props.position);
      if (!jMe(i, {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        left: this.state.containerStyle.left,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        top: this.state.containerStyle.top,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        width: this.state.containerStyle.width,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        height: this.state.containerStyle.height
      })) {
        var a, s, l, u;
        this.setState({
          containerStyle: {
            top: (a = i.top) !== null && a !== void 0 ? a : 0,
            left: (s = i.left) !== null && s !== void 0 ? s : 0,
            width: (l = i.width) !== null && l !== void 0 ? l : 0,
            height: (u = i.height) !== null && u !== void 0 ? u : 0,
            position: "absolute"
          }
        });
      }
    }), _e(this, "draw", () => {
      this.onPositionElement();
    }), _e(this, "onRemove", () => {
      var r, o;
      this.setState(() => ({
        paneEl: null
      })), (r = (o = this.props).onUnmount) === null || r === void 0 || r.call(o, this.overlayView);
    }), this.containerRef = so();
    var n = new google.maps.OverlayView();
    n.onAdd = this.onAdd, n.draw = this.draw, n.onRemove = this.onRemove, this.overlayView = n;
  }
  componentDidMount() {
    this.overlayView.setMap(this.context);
  }
  componentDidUpdate(t) {
    var n = eH(t.position), r = eH(this.props.position), o = tH(t.bounds), i = tH(this.props.bounds);
    (n !== r || o !== i) && this.overlayView.draw(), t.mapPaneName !== this.props.mapPaneName && this.updatePane();
  }
  componentWillUnmount() {
    this.overlayView.setMap(null);
  }
  render() {
    var t = this.state.paneEl;
    return t ? wi.createPortal(ti.jsx("div", {
      ref: this.containerRef,
      style: this.state.containerStyle,
      children: at.only(this.props.children)
    }), t) : null;
  }
}
_e(Up, "FLOAT_PANE", "floatPane");
_e(Up, "MAP_PANE", "mapPane");
_e(Up, "MARKER_LAYER", "markerLayer");
_e(Up, "OVERLAY_LAYER", "overlayLayer");
_e(Up, "OVERLAY_MOUSE_TARGET", "overlayMouseTarget");
_e(Up, "contextType", It);
function BMe() {
}
function nH(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function rH(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? nH(Object(n), !0).forEach(function(r) {
      _e(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : nH(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var oH = {
  onDblClick: "dblclick",
  onClick: "click"
}, iH = {
  opacity(e, t) {
    e.setOpacity(t);
  }
};
function FMe(e) {
  var {
    url: t,
    bounds: n,
    options: r,
    visible: o
  } = e, i = ge(It), a = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east)), s = ln(() => new google.maps.GroundOverlay(t, a, r), []);
  return h(() => {
    s !== null && s.setMap(i);
  }, [i]), h(() => {
    typeof t < "u" && s !== null && (s.set("url", t), s.setMap(i));
  }, [s, t]), h(() => {
    typeof o < "u" && s !== null && s.setOpacity(o ? 1 : 0);
  }, [s, o]), h(() => {
    var l = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east));
    typeof n < "u" && s !== null && (s.set("bounds", l), s.setMap(i));
  }, [s, n]), null;
}
me(FMe);
class kee extends pe {
  constructor() {
    super(...arguments), _e(this, "registeredEvents", []), _e(this, "state", {
      groundOverlay: null
    }), _e(this, "setGroundOverlayCallback", () => {
      this.state.groundOverlay !== null && this.props.onLoad && this.props.onLoad(this.state.groundOverlay);
    });
  }
  componentDidMount() {
    Ho(!!this.props.url || !!this.props.bounds, "For GroundOverlay, url and bounds are passed in to constructor and are immutable after instantiated. This is the behavior of Google Maps JavaScript API v3 ( See https://developers.google.com/maps/documentation/javascript/reference#GroundOverlay) Hence, use the corresponding two props provided by `react-google-maps-api`, url and bounds. In some cases, you'll need the GroundOverlay component to reflect the changes of url and bounds. You can leverage the React's key property to remount the component. Typically, just `key={url}` would serve your need. See https://github.com/tomchentw/react-google-maps/issues/655");
    var t = new google.maps.GroundOverlay(this.props.url, this.props.bounds, rH(rH({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = yn({
      updaterMap: iH,
      eventMap: oH,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        groundOverlay: t
      };
    }, this.setGroundOverlayCallback);
  }
  componentDidUpdate(t) {
    this.state.groundOverlay !== null && (kn(this.registeredEvents), this.registeredEvents = yn({
      updaterMap: iH,
      eventMap: oH,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.groundOverlay
    }));
  }
  componentWillUnmount() {
    this.state.groundOverlay && (this.props.onUnmount && this.props.onUnmount(this.state.groundOverlay), this.state.groundOverlay.setMap(null));
  }
  render() {
    return null;
  }
}
_e(kee, "defaultProps", {
  onLoad: BMe
});
_e(kee, "contextType", It);
function sH(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Gb(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? sH(Object(n), !0).forEach(function(r) {
      _e(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : sH(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var aH = {}, lH = {
  data(e, t) {
    e.setData(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function zMe(e) {
  var {
    data: t,
    onLoad: n,
    onUnmount: r,
    options: o
  } = e, i = ge(It), [a, s] = k(null);
  return h(() => {
    google.maps.visualization || Ho(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} in useJsApiScript? %s', google.maps.visualization);
  }, []), h(() => {
    Ho(!!t, "data property is required in HeatmapLayer %s", t);
  }, [t]), h(() => {
    a !== null && a.setMap(i);
  }, [i]), h(() => {
    o && a !== null && a.setOptions(o);
  }, [a, o]), h(() => {
    var l = new google.maps.visualization.HeatmapLayer(Gb(Gb({}, o), {}, {
      data: t,
      map: i
    }));
    return s(l), n && n(l), () => {
      a !== null && (r && r(a), a.setMap(null));
    };
  }, []), null;
}
me(zMe);
class UMe extends pe {
  constructor() {
    super(...arguments), _e(this, "registeredEvents", []), _e(this, "state", {
      heatmapLayer: null
    }), _e(this, "setHeatmapLayerCallback", () => {
      this.state.heatmapLayer !== null && this.props.onLoad && this.props.onLoad(this.state.heatmapLayer);
    });
  }
  componentDidMount() {
    Ho(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} to <LoadScript />? %s', google.maps.visualization), Ho(!!this.props.data, "data property is required in HeatmapLayer %s", this.props.data);
    var t = new google.maps.visualization.HeatmapLayer(Gb(Gb({}, this.props.options), {}, {
      data: this.props.data,
      map: this.context
    }));
    this.registeredEvents = yn({
      updaterMap: lH,
      eventMap: aH,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        heatmapLayer: t
      };
    }, this.setHeatmapLayerCallback);
  }
  componentDidUpdate(t) {
    kn(this.registeredEvents), this.registeredEvents = yn({
      updaterMap: lH,
      eventMap: aH,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.heatmapLayer
    });
  }
  componentWillUnmount() {
    this.state.heatmapLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.heatmapLayer), kn(this.registeredEvents), this.state.heatmapLayer.setMap(null));
  }
  render() {
    return null;
  }
}
_e(UMe, "contextType", It);
var uH = {
  onCloseClick: "closeclick",
  onPanoChanged: "pano_changed",
  onPositionChanged: "position_changed",
  onPovChanged: "pov_changed",
  onResize: "resize",
  onStatusChanged: "status_changed",
  onVisibleChanged: "visible_changed",
  onZoomChanged: "zoom_changed"
}, cH = {
  register(e, t, n) {
    e.registerPanoProvider(t, n);
  },
  links(e, t) {
    e.setLinks(t);
  },
  motionTracking(e, t) {
    e.setMotionTracking(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  pano(e, t) {
    e.setPano(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  pov(e, t) {
    e.setPov(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zoom(e, t) {
    e.setZoom(t);
  }
};
class HMe extends pe {
  constructor() {
    super(...arguments), _e(this, "registeredEvents", []), _e(this, "state", {
      streetViewPanorama: null
    }), _e(this, "setStreetViewPanoramaCallback", () => {
      this.state.streetViewPanorama !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewPanorama);
    });
  }
  componentDidMount() {
    var t, n, r = (t = (n = this.context) === null || n === void 0 ? void 0 : n.getStreetView()) !== null && t !== void 0 ? t : null;
    this.registeredEvents = yn({
      updaterMap: cH,
      eventMap: uH,
      prevProps: {},
      nextProps: this.props,
      instance: r
    }), this.setState(() => ({
      streetViewPanorama: r
    }), this.setStreetViewPanoramaCallback);
  }
  componentDidUpdate(t) {
    this.state.streetViewPanorama !== null && (kn(this.registeredEvents), this.registeredEvents = yn({
      updaterMap: cH,
      eventMap: uH,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.streetViewPanorama
    }));
  }
  componentWillUnmount() {
    this.state.streetViewPanorama !== null && (this.props.onUnmount && this.props.onUnmount(this.state.streetViewPanorama), kn(this.registeredEvents), this.state.streetViewPanorama.setVisible(!1));
  }
  render() {
    return null;
  }
}
_e(HMe, "contextType", It);
class WMe extends pe {
  constructor() {
    super(...arguments), _e(this, "state", {
      streetViewService: null
    }), _e(this, "setStreetViewServiceCallback", () => {
      this.state.streetViewService !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewService);
    });
  }
  componentDidMount() {
    var t = new google.maps.StreetViewService();
    this.setState(function() {
      return {
        streetViewService: t
      };
    }, this.setStreetViewServiceCallback);
  }
  componentWillUnmount() {
    this.state.streetViewService !== null && this.props.onUnmount && this.props.onUnmount(this.state.streetViewService);
  }
  render() {
    return null;
  }
}
_e(WMe, "contextType", It);
var pH = {
  onDirectionsChanged: "directions_changed"
}, dH = {
  directions(e, t) {
    e.setDirections(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  panel(e, t) {
    e.setPanel(t);
  },
  routeIndex(e, t) {
    e.setRouteIndex(t);
  }
};
class $Me extends pe {
  constructor() {
    super(...arguments), _e(this, "registeredEvents", []), _e(this, "state", {
      directionsRenderer: null
    }), _e(this, "setDirectionsRendererCallback", () => {
      this.state.directionsRenderer !== null && (this.state.directionsRenderer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.directionsRenderer));
    });
  }
  componentDidMount() {
    var t = new google.maps.DirectionsRenderer(this.props.options);
    this.registeredEvents = yn({
      updaterMap: dH,
      eventMap: pH,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        directionsRenderer: t
      };
    }, this.setDirectionsRendererCallback);
  }
  componentDidUpdate(t) {
    this.state.directionsRenderer !== null && (kn(this.registeredEvents), this.registeredEvents = yn({
      updaterMap: dH,
      eventMap: pH,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.directionsRenderer
    }));
  }
  componentWillUnmount() {
    this.state.directionsRenderer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.directionsRenderer), kn(this.registeredEvents), this.state.directionsRenderer && this.state.directionsRenderer.setMap(null));
  }
  render() {
    return null;
  }
}
_e($Me, "contextType", It);
var fH = {
  onPlacesChanged: "places_changed"
}, hH = {
  bounds(e, t) {
    e.setBounds(t);
  }
};
class VMe extends pe {
  constructor() {
    super(...arguments), _e(this, "registeredEvents", []), _e(this, "containerElement", so()), _e(this, "state", {
      searchBox: null
    }), _e(this, "setSearchBoxCallback", () => {
      this.state.searchBox !== null && this.props.onLoad && this.props.onLoad(this.state.searchBox);
    });
  }
  componentDidMount() {
    if (Ho(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places), this.containerElement !== null && this.containerElement.current !== null) {
      var t = this.containerElement.current.querySelector("input");
      if (t !== null) {
        var n = new google.maps.places.SearchBox(t, this.props.options);
        this.registeredEvents = yn({
          updaterMap: hH,
          eventMap: fH,
          prevProps: {},
          nextProps: this.props,
          instance: n
        }), this.setState(function() {
          return {
            searchBox: n
          };
        }, this.setSearchBoxCallback);
      }
    }
  }
  componentDidUpdate(t) {
    this.state.searchBox !== null && (kn(this.registeredEvents), this.registeredEvents = yn({
      updaterMap: hH,
      eventMap: fH,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.searchBox
    }));
  }
  componentWillUnmount() {
    this.state.searchBox !== null && (this.props.onUnmount && this.props.onUnmount(this.state.searchBox), kn(this.registeredEvents));
  }
  render() {
    return ti.jsx("div", {
      ref: this.containerElement,
      children: at.only(this.props.children)
    });
  }
}
_e(VMe, "contextType", It);
var gH = {
  onPlaceChanged: "place_changed"
}, mH = {
  bounds(e, t) {
    e.setBounds(t);
  },
  restrictions(e, t) {
    e.setComponentRestrictions(t);
  },
  fields(e, t) {
    e.setFields(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  types(e, t) {
    e.setTypes(t);
  }
};
class Lee extends pe {
  constructor() {
    super(...arguments), _e(this, "registeredEvents", []), _e(this, "containerElement", so()), _e(this, "state", {
      autocomplete: null
    }), _e(this, "setAutocompleteCallback", () => {
      this.state.autocomplete !== null && this.props.onLoad && this.props.onLoad(this.state.autocomplete);
    });
  }
  componentDidMount() {
    var t;
    Ho(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places);
    var n = (t = this.containerElement.current) === null || t === void 0 ? void 0 : t.querySelector("input");
    if (n) {
      var r = new google.maps.places.Autocomplete(n, this.props.options);
      this.registeredEvents = yn({
        updaterMap: mH,
        eventMap: gH,
        prevProps: {},
        nextProps: this.props,
        instance: r
      }), this.setState(() => ({
        autocomplete: r
      }), this.setAutocompleteCallback);
    }
  }
  componentDidUpdate(t) {
    kn(this.registeredEvents), this.registeredEvents = yn({
      updaterMap: mH,
      eventMap: gH,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.autocomplete
    });
  }
  componentWillUnmount() {
    this.state.autocomplete !== null && kn(this.registeredEvents);
  }
  render() {
    return ti.jsx("div", {
      ref: this.containerElement,
      className: this.props.className,
      children: at.only(this.props.children)
    });
  }
}
_e(Lee, "defaultProps", {
  className: ""
});
_e(Lee, "contextType", It);
let ZMe = { data: "" }, qMe = (e) => typeof window == "object" ? ((e ? e.querySelector("#_goober") : window._goober) || Object.assign((e || document.head).appendChild(document.createElement("style")), { innerHTML: " ", id: "_goober" })).firstChild : e || ZMe, GMe = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g, KMe = /\/\*[^]*?\*\/|  +/g, vH = /\n+/g, Xl = (e, t) => {
  let n = "", r = "", o = "";
  for (let i in e) {
    let a = e[i];
    i[0] == "@" ? i[1] == "i" ? n = i + " " + a + ";" : r += i[1] == "f" ? Xl(a, i) : i + "{" + Xl(a, i[1] == "k" ? "" : t) + "}" : typeof a == "object" ? r += Xl(a, t ? t.replace(/([^,])+/g, (s) => i.replace(/([^,]*:\S+\([^)]*\))|([^,])+/g, (l) => /&/.test(l) ? l.replace(/&/g, s) : s ? s + " " + l : l)) : i) : a != null && (i = /^--/.test(i) ? i : i.replace(/[A-Z]/g, "-$&").toLowerCase(), o += Xl.p ? Xl.p(i, a) : i + ":" + a + ";");
  }
  return n + (t && o ? t + "{" + o + "}" : o) + r;
}, Aa = {}, _ee = (e) => {
  if (typeof e == "object") {
    let t = "";
    for (let n in e) t += n + _ee(e[n]);
    return t;
  }
  return e;
}, XMe = (e, t, n, r, o) => {
  let i = _ee(e), a = Aa[i] || (Aa[i] = ((l) => {
    let u = 0, c = 11;
    for (; u < l.length; ) c = 101 * c + l.charCodeAt(u++) >>> 0;
    return "go" + c;
  })(i));
  if (!Aa[a]) {
    let l = i !== e ? e : ((u) => {
      let c, p, d = [{}];
      for (; c = GMe.exec(u.replace(KMe, "")); ) c[4] ? d.shift() : c[3] ? (p = c[3].replace(vH, " ").trim(), d.unshift(d[0][p] = d[0][p] || {})) : d[0][c[1]] = c[2].replace(vH, " ").trim();
      return d[0];
    })(e);
    Aa[a] = Xl(o ? { ["@keyframes " + a]: l } : l, n ? "" : "." + a);
  }
  let s = n && Aa.g ? Aa.g : null;
  return n && (Aa.g = Aa[a]), ((l, u, c, p) => {
    p ? u.data = u.data.replace(p, l) : u.data.indexOf(l) === -1 && (u.data = c ? l + u.data : u.data + l);
  })(Aa[a], t, r, s), a;
}, YMe = (e, t, n) => e.reduce((r, o, i) => {
  let a = t[i];
  if (a && a.call) {
    let s = a(n), l = s && s.props && s.props.className || /^go/.test(s) && s;
    a = l ? "." + l : s && typeof s == "object" ? s.props ? "" : Xl(s, "") : s === !1 ? "" : s;
  }
  return r + o + (a ?? "");
}, "");
function aO(e) {
  let t = this || {}, n = e.call ? e(t.p) : e;
  return XMe(n.unshift ? n.raw ? YMe(n, [].slice.call(arguments, 1), t.p) : n.reduce((r, o) => Object.assign(r, o && o.call ? o(t.p) : o), {}) : n, qMe(t.target), t.g, t.o, t.k);
}
let Pee, U_, H_;
aO.bind({ g: 1 });
let Ya = aO.bind({ k: 1 });
function JMe(e, t, n, r) {
  Xl.p = t, Pee = e, U_ = n, H_ = r;
}
function ku(e, t) {
  let n = this || {};
  return function() {
    let r = arguments;
    function o(i, a) {
      let s = Object.assign({}, i), l = s.className || o.className;
      n.p = Object.assign({ theme: U_ && U_() }, s), n.o = / *go\d+/.test(l), s.className = aO.apply(n, r) + (l ? " " + l : "");
      let u = e;
      return e[0] && (u = s.as || e, delete s.as), H_ && u[0] && H_(s), Pee(u, s);
    }
    return o;
  };
}
var QMe = (e) => typeof e == "function", eDe = (e, t) => QMe(e) ? e(t) : e, tDe = /* @__PURE__ */ (() => {
  let e;
  return () => {
    if (e === void 0 && typeof window < "u") {
      let t = matchMedia("(prefers-reduced-motion: reduce)");
      e = !t || t.matches;
    }
    return e;
  };
})(), nDe = Ya`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`, rDe = Ya`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`, oDe = Ya`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`, iDe = ku("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${nDe} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${rDe} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${(e) => e.secondary || "#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${oDe} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`, sDe = Ya`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, aDe = ku("div")`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${(e) => e.secondary || "#e0e0e0"};
  border-right-color: ${(e) => e.primary || "#616161"};
  animation: ${sDe} 1s linear infinite;
`, lDe = Ya`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`, uDe = Ya`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`, cDe = ku("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${lDe} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${uDe} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${(e) => e.secondary || "#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`, pDe = ku("div")`
  position: absolute;
`, dDe = ku("div")`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`, fDe = Ya`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`, hDe = ku("div")`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${fDe} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`, gDe = ({ toast: e }) => {
  let { icon: t, type: n, iconTheme: r } = e;
  return t !== void 0 ? typeof t == "string" ? Ne.createElement(hDe, null, t) : t : n === "blank" ? null : Ne.createElement(dDe, null, Ne.createElement(aDe, { ...r }), n !== "loading" && Ne.createElement(pDe, null, n === "error" ? Ne.createElement(iDe, { ...r }) : Ne.createElement(cDe, { ...r })));
}, mDe = (e) => `
0% {transform: translate3d(0,${e * -200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`, vDe = (e) => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${e * -150}%,-1px) scale(.6); opacity:0;}
`, yDe = "0%{opacity:0;} 100%{opacity:1;}", bDe = "0%{opacity:1;} 100%{opacity:0;}", wDe = ku("div")`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`, CDe = ku("div")`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`, ODe = (e, t) => {
  let n = e.includes("top") ? 1 : -1, [r, o] = tDe() ? [yDe, bDe] : [mDe(n), vDe(n)];
  return { animation: t ? `${Ya(r)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards` : `${Ya(o)} 0.4s forwards cubic-bezier(.06,.71,.55,1)` };
};
Ne.memo(({ toast: e, position: t, style: n, children: r }) => {
  let o = e.height ? ODe(e.position || t || "top-center", e.visible) : { opacity: 0 }, i = Ne.createElement(gDe, { toast: e }), a = Ne.createElement(CDe, { ...e.ariaProps }, eDe(e.message, e));
  return Ne.createElement(wDe, { className: e.className, style: { ...o, ...n, ...e.style } }, typeof r == "function" ? r({ icon: i, message: a }) : Ne.createElement(Ne.Fragment, null, i, a));
});
JMe(Ne.createElement);
aO`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`;
$e({});
function xDe(e) {
  return e && e.replace(/[^0-9]/g, "");
}
const EDe = {
  CNPJ: "99.999.999/9999-99"
};
xDe(EDe.CNPJ).length;
Cr((e, t) => /* @__PURE__ */ ei.jsx("input", { ref: t, ...e }));
function See(e) {
  return e && e.replace(/[^0-9]/g, "");
}
const Mee = {
  EIGTH: "(99) 9999-9999",
  NINE: "(99) 99999-9999"
};
function kDe(e, t) {
  let n = "", r = 0;
  for (let o = 0; o < t.length; o++)
    if (t[o] === "9")
      if (r < e.length)
        n += e[r], r++;
      else
        break;
    else if (r < e.length)
      n += t[o];
    else
      break;
  return n;
}
function LDe(e) {
  return e.length > 10 ? "NINE" : "EIGTH";
}
const _De = See(Mee.NINE).length, PDe = Cr((e, t) => /* @__PURE__ */ ei.jsx("input", { ref: t, ...e }));
Cr(
  (e, t) => {
    const { onFocus: n, onBlur: r, size: o, onChange: i, value: a, currentCountry: s, disabled: l } = e, [u, c] = k(!1);
    h(() => {
      u ? i(s.mask) : c(!0);
    }, [s]);
    const p = `phoneInputMask ${o}`;
    function d(g) {
      let f = See(g.target.value);
      const m = LDe(f);
      f.length > _De || (f = kDe(f, Mee[m]), g.target.value = f, i(f));
    }
    return s.code === "+55" ? /* @__PURE__ */ ei.jsx(
      "input",
      {
        value: a,
        onChange: d,
        className: p,
        onFocus: n,
        onBlur: r,
        disabled: l,
        ref: t
      }
    ) : /* @__PURE__ */ ei.jsx(
      ol,
      {
        value: a,
        onChange: (g) => i(g.target.value),
        className: p,
        component: PDe,
        onFocus: n,
        onBlur: r,
        disabled: l,
        mask: s.mask,
        showMask: !0,
        replacement: { _: /\d/ },
        ref: t
      }
    );
  }
);
$e({});
var ll = {};
Object.defineProperty(ll, "__esModule", {
  value: !0
});
var SDe = typeof window < "u" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform), DE = {
  alt: "altKey",
  control: "ctrlKey",
  meta: "metaKey",
  shift: "shiftKey"
}, Dee = {
  add: "+",
  break: "pause",
  cmd: "meta",
  command: "meta",
  ctl: "control",
  ctrl: "control",
  del: "delete",
  down: "arrowdown",
  esc: "escape",
  ins: "insert",
  left: "arrowleft",
  mod: SDe ? "meta" : "control",
  opt: "alt",
  option: "alt",
  return: "enter",
  right: "arrowright",
  space: " ",
  spacebar: " ",
  up: "arrowup",
  win: "meta",
  windows: "meta"
}, $D = {
  backspace: 8,
  tab: 9,
  enter: 13,
  shift: 16,
  control: 17,
  alt: 18,
  pause: 19,
  capslock: 20,
  escape: 27,
  " ": 32,
  pageup: 33,
  pagedown: 34,
  end: 35,
  home: 36,
  arrowleft: 37,
  arrowup: 38,
  arrowright: 39,
  arrowdown: 40,
  insert: 45,
  delete: 46,
  meta: 91,
  numlock: 144,
  scrolllock: 145,
  ";": 186,
  "=": 187,
  ",": 188,
  "-": 189,
  ".": 190,
  "/": 191,
  "`": 192,
  "[": 219,
  "\\": 220,
  "]": 221,
  "'": 222
};
for (var cv = 1; cv < 20; cv++)
  $D["f" + cv] = 111 + cv;
function lO(e, t, n) {
  t && !("byKey" in t) && (n = t, t = null), Array.isArray(e) || (e = [e]);
  var r = e.map(function(a) {
    return Tee(a, t);
  }), o = function(a) {
    return r.some(function(s) {
      return jee(s, a);
    });
  }, i = n == null ? o : o(n);
  return i;
}
function MDe(e, t) {
  return lO(e, t);
}
function DDe(e, t) {
  return lO(e, { byKey: !0 }, t);
}
function Tee(e, t) {
  var n = t && t.byKey, r = {};
  e = e.replace("++", "+add");
  var o = e.split("+"), i = o.length;
  for (var a in DE)
    r[DE[a]] = !1;
  var s = !0, l = !1, u = void 0;
  try {
    for (var c = o[Symbol.iterator](), p; !(s = (p = c.next()).done); s = !0) {
      var d = p.value, g = d.endsWith("?") && d.length > 1;
      g && (d = d.slice(0, -1));
      var f = VD(d), m = DE[f];
      if (d.length > 1 && !m && !Dee[d] && !$D[f])
        throw new TypeError('Unknown modifier: "' + d + '"');
      (i === 1 || !m) && (n ? r.key = f : r.which = Aee(d)), m && (r[m] = g ? null : !0);
    }
  } catch (b) {
    l = !0, u = b;
  } finally {
    try {
      !s && c.return && c.return();
    } finally {
      if (l)
        throw u;
    }
  }
  return r;
}
function jee(e, t) {
  for (var n in e) {
    var r = e[n], o = void 0;
    if (r != null && (n === "key" && t.key != null ? o = t.key.toLowerCase() : n === "which" ? o = r === 91 && t.which === 93 ? 91 : t.which : o = t[n], !(o == null && r === !1) && o !== r))
      return !1;
  }
  return !0;
}
function Aee(e) {
  e = VD(e);
  var t = $D[e] || e.toUpperCase().charCodeAt(0);
  return t;
}
function VD(e) {
  return e = e.toLowerCase(), e = Dee[e] || e, e;
}
ll.default = lO;
var TE = ll.isHotkey = lO;
ll.isCodeHotkey = MDe;
ll.isKeyHotkey = DDe;
ll.parseHotkey = Tee;
ll.compareHotkey = jee;
ll.toKeyCode = Aee;
ll.toKeyName = VD;
var TDe = typeof yr == "object" && yr && yr.Object === Object && yr, jDe = TDe, ADe = jDe, RDe = typeof self == "object" && self && self.Object === Object && self, IDe = ADe || RDe || Function("return this")(), NDe = IDe, BDe = NDe, FDe = BDe.Symbol, Ree = FDe, yH = Ree;
yH && yH.toStringTag;
var bH = Ree;
bH && bH.toStringTag;
var wH;
(function(e) {
  e.BORDER_BOX = "border-box", e.CONTENT_BOX = "content-box", e.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(wH || (wH = {}));
var ZD = function(e) {
  return Object.freeze(e);
}, zDe = /* @__PURE__ */ function() {
  function e(t, n) {
    this.inlineSize = t, this.blockSize = n, ZD(this);
  }
  return e;
}(), UDe = function() {
  function e(t, n, r, o) {
    return this.x = t, this.y = n, this.width = r, this.height = o, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, ZD(this);
  }
  return e.prototype.toJSON = function() {
    var t = this, n = t.x, r = t.y, o = t.top, i = t.right, a = t.bottom, s = t.left, l = t.width, u = t.height;
    return { x: n, y: r, top: o, right: i, bottom: a, left: s, width: l, height: u };
  }, e.fromRect = function(t) {
    return new e(t.x, t.y, t.width, t.height);
  }, e;
}(), CH = typeof window < "u" ? window : {};
/msie|trident/i.test(CH.navigator && CH.navigator.userAgent);
var jE = function(e, t, n) {
  return e === void 0 && (e = 0), t === void 0 && (t = 0), n === void 0 && (n = !1), new zDe((n ? t : e) || 0, (n ? e : t) || 0);
};
ZD({
  devicePixelContentBoxSize: jE(),
  borderBoxSize: jE(),
  contentBoxSize: jE(),
  contentRect: new UDe(0, 0, 0, 0)
});
function Dh(e) {
  "@babel/helpers - typeof";
  return Dh = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Dh(e);
}
function HDe(e, t) {
  if (Dh(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (Dh(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function WDe(e) {
  var t = HDe(e, "string");
  return Dh(t) === "symbol" ? t : String(t);
}
function Lf(e, t, n) {
  return t = WDe(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
var $De = /* @__PURE__ */ $e(null), AE, RE;
parseInt(be.version.split(".")[0], 10);
var OH = typeof navigator < "u" && /Mac OS X/.test(navigator.userAgent), IE = typeof navigator < "u" && /Android/.test(navigator.userAgent), pv = typeof navigator < "u" && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent), VDe = typeof navigator < "u" && /Chrome/i.test(navigator.userAgent);
typeof navigator < "u" && /Safari/.test(navigator.userAgent) && /Version\/(\d+)/.test(navigator.userAgent) && (AE = navigator.userAgent.match(/Version\/(\d+)/)) !== null && AE !== void 0 && AE[1] && parseInt((RE = navigator.userAgent.match(/Version\/(\d+)/)) === null || RE === void 0 ? void 0 : RE[1], 10) < 17;
var ZDe = /* @__PURE__ */ new WeakMap(), qDe = /* @__PURE__ */ new WeakMap(), GDe = /* @__PURE__ */ new WeakMap(), KDe = /* @__PURE__ */ new WeakMap(), XDe = /* @__PURE__ */ new WeakMap(), xH = /* @__PURE__ */ new WeakMap(), YDe = /* @__PURE__ */ new WeakMap(), EH = /* @__PURE__ */ new WeakMap(), dv = /* @__PURE__ */ new WeakMap(), JDe = /* @__PURE__ */ new WeakMap(), QDe = /* @__PURE__ */ new WeakMap(), eTe = /* @__PURE__ */ new WeakMap(), Iee = globalThis.Node, tTe = globalThis.Text, Nee = (e) => e && e.ownerDocument && e.ownerDocument.defaultView || null, nTe = (e) => Kb(e) && e.nodeType === 8, pa = (e) => Kb(e) && e.nodeType === 1, Kb = (e) => {
  var t = Nee(e);
  return !!t && e instanceof t.Node;
}, kH = (e) => {
  var t = e && e.anchorNode && Nee(e.anchorNode);
  return !!t && e instanceof t.Selection;
}, rTe = (e) => {
  var [t, n] = e;
  if (pa(t) && t.childNodes.length) {
    var r = n === t.childNodes.length, o = r ? n - 1 : n;
    for ([t, o] = Bee(t, o, r ? "backward" : "forward"), r = o < n; pa(t) && t.childNodes.length; ) {
      var i = r ? t.childNodes.length - 1 : 0;
      t = iTe(t, i, r ? "backward" : "forward");
    }
    n = r && t.textContent != null ? t.textContent.length : 0;
  }
  return [t, n];
}, oTe = (e) => {
  for (var t = e && e.parentNode; t; ) {
    if (t.toString() === "[object ShadowRoot]")
      return !0;
    t = t.parentNode;
  }
  return !1;
}, Bee = (e, t, n) => {
  for (var {
    childNodes: r
  } = e, o = r[t], i = t, a = !1, s = !1; (nTe(o) || pa(o) && o.childNodes.length === 0 || pa(o) && o.getAttribute("contenteditable") === "false") && !(a && s); ) {
    if (i >= r.length) {
      a = !0, i = t - 1, n = "backward";
      continue;
    }
    if (i < 0) {
      s = !0, i = t + 1, n = "forward";
      continue;
    }
    o = r[i], t = i, i += n === "forward" ? 1 : -1;
  }
  return [o, t];
}, iTe = (e, t, n) => {
  var [r] = Bee(e, t, n);
  return r;
}, LH = (e) => e.getSelection != null ? e.getSelection() : document.getSelection(), Fee = (e, t, n) => {
  var {
    target: r
  } = t;
  if (pa(r) && r.matches('[contentEditable="false"]'))
    return !1;
  var {
    document: o
  } = dn.getWindow(e);
  if (o.contains(r))
    return dn.hasDOMNode(e, r, {
      editable: !0
    });
  var i = n.find((a) => {
    var {
      addedNodes: s,
      removedNodes: l
    } = a;
    for (var u of s)
      if (u === r || u.contains(r))
        return !0;
    for (var c of l)
      if (c === r || c.contains(r))
        return !0;
  });
  return !i || i === t ? !1 : Fee(e, i, n);
}, _H = (e, t) => !!(e.compareDocumentPosition(t) & Iee.DOCUMENT_POSITION_PRECEDING), sTe = (e, t) => !!(e.compareDocumentPosition(t) & Iee.DOCUMENT_POSITION_FOLLOWING), aTe = 0;
class lTe {
  constructor() {
    Lf(this, "id", void 0), this.id = "".concat(aTe++);
  }
}
var dn = {
  androidPendingDiffs: (e) => eTe.get(e),
  androidScheduleFlush: (e) => {
    var t;
    (t = QDe.get(e)) === null || t === void 0 || t();
  },
  blur: (e) => {
    var t = dn.toDOMNode(e, e), n = dn.findDocumentOrShadowRoot(e);
    dv.set(e, !1), n.activeElement === t && t.blur();
  },
  deselect: (e) => {
    var {
      selection: t
    } = e, n = dn.findDocumentOrShadowRoot(e), r = LH(n);
    r && r.rangeCount > 0 && r.removeAllRanges(), t && gb.deselect(e);
  },
  findDocumentOrShadowRoot: (e) => {
    var t = dn.toDOMNode(e, e), n = t.getRootNode();
    return n instanceof Document || n instanceof ShadowRoot ? n : t.ownerDocument;
  },
  findEventRange: (e, t) => {
    "nativeEvent" in t && (t = t.nativeEvent);
    var {
      clientX: n,
      clientY: r,
      target: o
    } = t;
    if (n == null || r == null)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var i = dn.toSlateNode(e, t.target), a = dn.findPath(e, i);
    if (Va.isElement(i) && cr.isVoid(e, i)) {
      var s = o.getBoundingClientRect(), l = e.isInline(i) ? n - s.left < s.left + s.width - n : r - s.top < s.top + s.height - r, u = cr.point(e, a, {
        edge: l ? "start" : "end"
      }), c = l ? cr.before(e, u) : cr.after(e, u);
      if (c) {
        var p = cr.range(e, c);
        return p;
      }
    }
    var d, {
      document: g
    } = dn.getWindow(e);
    if (g.caretRangeFromPoint)
      d = g.caretRangeFromPoint(n, r);
    else {
      var f = g.caretPositionFromPoint(n, r);
      f && (d = g.createRange(), d.setStart(f.offsetNode, f.offset), d.setEnd(f.offsetNode, f.offset));
    }
    if (!d)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var m = dn.toSlateRange(e, d, {
      exactMatch: !1,
      suppressThrow: !1
    });
    return m;
  },
  findKey: (e, t) => {
    var n = xH.get(t);
    return n || (n = new lTe(), xH.set(t, n)), n;
  },
  findPath: (e, t) => {
    for (var n = [], r = t; ; ) {
      var o = qDe.get(r);
      if (o == null) {
        if (cr.isEditor(r))
          return n;
        break;
      }
      var i = ZDe.get(r);
      if (i == null)
        break;
      n.unshift(i), r = o;
    }
    throw new Error("Unable to find the path for Slate node: ".concat(as.stringify(t)));
  },
  focus: function(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      retries: 5
    };
    if (!dv.get(e)) {
      if (t.retries <= 0)
        throw new Error("Could not set focus, editor seems stuck with pending operations");
      if (e.operations.length > 0) {
        setTimeout(() => {
          dn.focus(e, {
            retries: t.retries - 1
          });
        }, 10);
        return;
      }
      var n = dn.toDOMNode(e, e), r = dn.findDocumentOrShadowRoot(e);
      if (r.activeElement !== n) {
        if (e.selection && r instanceof Document) {
          var o = LH(r), i = dn.toDOMRange(e, e.selection);
          o == null || o.removeAllRanges(), o == null || o.addRange(i);
        }
        e.selection || gb.select(e, cr.start(e, [])), dv.set(e, !0), n.focus({
          preventScroll: !0
        });
      }
    }
  },
  getWindow: (e) => {
    var t = GDe.get(e);
    if (!t)
      throw new Error("Unable to find a host window element for this editor");
    return t;
  },
  hasDOMNode: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      editable: r = !1
    } = n, o = dn.toDOMNode(e, e), i;
    try {
      i = pa(t) ? t : t.parentElement;
    } catch (a) {
      if (a instanceof Error && !a.message.includes('Permission denied to access property "nodeType"'))
        throw a;
    }
    return i ? i.closest("[data-slate-editor]") === o && (!r || i.isContentEditable ? !0 : typeof i.isContentEditable == "boolean" && // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined
    // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable="false"(readOnly)
    i.closest('[contenteditable="false"]') === o || !!i.getAttribute("data-slate-zero-width")) : !1;
  },
  hasEditableTarget: (e, t) => Kb(t) && dn.hasDOMNode(e, t, {
    editable: !0
  }),
  hasRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t;
    return cr.hasPath(e, n.path) && cr.hasPath(e, r.path);
  },
  hasSelectableTarget: (e, t) => dn.hasEditableTarget(e, t) || dn.isTargetInsideNonReadonlyVoid(e, t),
  hasTarget: (e, t) => Kb(t) && dn.hasDOMNode(e, t),
  insertData: (e, t) => {
    e.insertData(t);
  },
  insertFragmentData: (e, t) => e.insertFragmentData(t),
  insertTextData: (e, t) => e.insertTextData(t),
  isComposing: (e) => !!JDe.get(e),
  isFocused: (e) => !!dv.get(e),
  isReadOnly: (e) => !!EH.get(e),
  isTargetInsideNonReadonlyVoid: (e, t) => {
    if (EH.get(e)) return !1;
    var n = dn.hasTarget(e, t) && dn.toSlateNode(e, t);
    return Va.isElement(n) && cr.isVoid(e, n);
  },
  setFragmentData: (e, t, n) => e.setFragmentData(t, n),
  toDOMNode: (e, t) => {
    var n = YDe.get(e), r = cr.isEditor(t) ? KDe.get(e) : n == null ? void 0 : n.get(dn.findKey(e, t));
    if (!r)
      throw new Error("Cannot resolve a DOM node from Slate node: ".concat(as.stringify(t)));
    return r;
  },
  toDOMPoint: (e, t) => {
    var [n] = cr.node(e, t.path), r = dn.toDOMNode(e, n), o;
    cr.void(e, {
      at: t
    }) && (t = {
      path: t.path,
      offset: 0
    });
    for (var i = "[data-slate-string], [data-slate-zero-width]", a = Array.from(r.querySelectorAll(i)), s = 0, l = 0; l < a.length; l++) {
      var u = a[l], c = u.childNodes[0];
      if (!(c == null || c.textContent == null)) {
        var {
          length: p
        } = c.textContent, d = u.getAttribute("data-slate-length"), g = d == null ? p : parseInt(d, 10), f = s + g, m = a[l + 1];
        if (t.offset === f && m !== null && m !== void 0 && m.hasAttribute("data-slate-mark-placeholder")) {
          var b, E = m.childNodes[0];
          o = [
            // COMPAT: If we don't explicity set the dom point to be on the actual
            // dom text element, chrome will put the selection behind the actual dom
            // text element, causing domRange.getBoundingClientRect() calls on a collapsed
            // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)
            // which will cause issues when scrolling to it.
            E instanceof tTe ? E : m,
            (b = m.textContent) !== null && b !== void 0 && b.startsWith("\uFEFF") ? 1 : 0
          ];
          break;
        }
        if (t.offset <= f) {
          var w = Math.min(p, Math.max(0, t.offset - s));
          o = [c, w];
          break;
        }
        s = f;
      }
    }
    if (!o)
      throw new Error("Cannot resolve a DOM point from Slate point: ".concat(as.stringify(t)));
    return o;
  },
  toDOMRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t, o = Kt.isBackward(t), i = dn.toDOMPoint(e, n), a = Kt.isCollapsed(t) ? i : dn.toDOMPoint(e, r), s = dn.getWindow(e), l = s.document.createRange(), [u, c] = o ? a : i, [p, d] = o ? i : a, g = pa(u) ? u : u.parentElement, f = !!g.getAttribute("data-slate-zero-width"), m = pa(p) ? p : p.parentElement, b = !!m.getAttribute("data-slate-zero-width");
    return l.setStart(u, f ? 1 : c), l.setEnd(p, b ? 1 : d), l;
  },
  toSlateNode: (e, t) => {
    var n = pa(t) ? t : t.parentElement;
    n && !n.hasAttribute("data-slate-node") && (n = n.closest("[data-slate-node]"));
    var r = n ? XDe.get(n) : null;
    if (!r)
      throw new Error("Cannot resolve a Slate node from DOM node: ".concat(n));
    return r;
  },
  toSlatePoint: (e, t, n) => {
    var {
      exactMatch: r,
      suppressThrow: o,
      searchDirection: i = "backward"
    } = n, [a, s] = r ? t : rTe(t), l = a.parentNode, u = null, c = 0;
    if (l) {
      var p, d, g = dn.toDOMNode(e, e), f = l.closest('[data-slate-void="true"]'), m = f && g.contains(f) ? f : null, b = l.closest('[contenteditable="false"]'), E = b && g.contains(b) ? b : null, w = l.closest("[data-slate-leaf]"), M = null;
      if (w) {
        if (u = w.closest('[data-slate-node="text"]'), u) {
          var x = dn.getWindow(e), v = x.document.createRange();
          v.setStart(u, 0), v.setEnd(a, s);
          var C = v.cloneContents(), P = [...Array.prototype.slice.call(C.querySelectorAll("[data-slate-zero-width]")), ...Array.prototype.slice.call(C.querySelectorAll("[contenteditable=false]"))];
          P.forEach((S) => {
            if (IE && !r && S.hasAttribute("data-slate-zero-width") && S.textContent.length > 0 && S.textContext !== "\uFEFF") {
              S.textContent.startsWith("\uFEFF") && (S.textContent = S.textContent.slice(1));
              return;
            }
            S.parentNode.removeChild(S);
          }), c = C.textContent.length, M = u;
        }
      } else if (m) {
        for (var F = m.querySelectorAll("[data-slate-leaf]"), L = 0; L < F.length; L++) {
          var B = F[L];
          if (dn.hasDOMNode(e, B)) {
            w = B;
            break;
          }
        }
        w ? (u = w.closest('[data-slate-node="text"]'), M = w, c = M.textContent.length, M.querySelectorAll("[data-slate-zero-width]").forEach((S) => {
          c -= S.textContent.length;
        })) : c = 1;
      } else if (E) {
        var N = (S) => S ? S.querySelectorAll(
          // Exclude leaf nodes in nested editors
          "[data-slate-leaf]:not(:scope [data-slate-editor] [data-slate-leaf])"
        ) : [], $ = E.closest('[data-slate-node="element"]');
        if (i === "forward") {
          var V, H = [...N($), ...N($ == null ? void 0 : $.nextElementSibling)];
          w = (V = H.find((S) => sTe(E, S))) !== null && V !== void 0 ? V : null;
        } else {
          var Z, K = [...N($ == null ? void 0 : $.previousElementSibling), ...N($)];
          w = (Z = K.findLast((S) => _H(E, S))) !== null && Z !== void 0 ? Z : null;
        }
        w && (u = w.closest('[data-slate-node="text"]'), M = w, i === "forward" ? c = 0 : (c = M.textContent.length, M.querySelectorAll("[data-slate-zero-width]").forEach((S) => {
          c -= S.textContent.length;
        })));
      }
      M && c === M.textContent.length && // COMPAT: Android IMEs might remove the zero width space while composing,
      // and we don't add it for line-breaks.
      IE && M.getAttribute("data-slate-zero-width") === "z" && (p = M.textContent) !== null && p !== void 0 && p.startsWith("\uFEFF") && // COMPAT: If the parent node is a Slate zero-width space, editor is
      // because the text node should have no characters. However, during IME
      // composition the ASCII characters will be prepended to the zero-width
      // space, so subtract 1 from the offset to account for the zero-width
      // space character.
      (l.hasAttribute("data-slate-zero-width") || // COMPAT: In Firefox, `range.cloneContents()` returns an extra trailing '\n'
      // when the document ends with a new-line character. This results in the offset
      // length being off by one, so we need to subtract one to account for this.
      pv && (d = M.textContent) !== null && d !== void 0 && d.endsWith(`

`)) && c--;
    }
    if (IE && !u && !r) {
      var Y = l.hasAttribute("data-slate-node") ? l : l.closest("[data-slate-node]");
      if (Y && dn.hasDOMNode(e, Y, {
        editable: !0
      })) {
        var Q = dn.toSlateNode(e, Y), {
          path: J,
          offset: _
        } = cr.start(e, dn.findPath(e, Q));
        return Y.querySelector("[data-slate-leaf]") || (_ = s), {
          path: J,
          offset: _
        };
      }
    }
    if (!u) {
      if (o)
        return null;
      throw new Error("Cannot resolve a Slate point from DOM point: ".concat(t));
    }
    var D = dn.toSlateNode(e, u), z = dn.findPath(e, D);
    return {
      path: z,
      offset: c
    };
  },
  toSlateRange: (e, t, n) => {
    var r, {
      exactMatch: o,
      suppressThrow: i
    } = n, a = kH(t) ? t.anchorNode : t.startContainer, s, l, u, c, p;
    if (a)
      if (kH(t)) {
        if (pv && t.rangeCount > 1) {
          u = t.focusNode;
          var d = t.getRangeAt(0), g = t.getRangeAt(t.rangeCount - 1);
          if (u instanceof HTMLTableRowElement && d.startContainer instanceof HTMLTableRowElement && g.startContainer instanceof HTMLTableRowElement) {
            let C = function(P) {
              return P.childElementCount > 0 ? C(P.children[0]) : P;
            };
            var f = d.startContainer, m = g.startContainer, b = C(f.children[d.startOffset]), E = C(m.children[g.startOffset]);
            c = 0, E.childNodes.length > 0 ? s = E.childNodes[0] : s = E, b.childNodes.length > 0 ? u = b.childNodes[0] : u = b, E instanceof HTMLElement ? l = E.innerHTML.length : l = 0;
          } else
            d.startContainer === u ? (s = g.endContainer, l = g.endOffset, c = d.startOffset) : (s = d.startContainer, l = d.endOffset, c = g.startOffset);
        } else
          s = t.anchorNode, l = t.anchorOffset, u = t.focusNode, c = t.focusOffset;
        VDe && oTe(s) || pv ? p = t.anchorNode === t.focusNode && t.anchorOffset === t.focusOffset : p = t.isCollapsed;
      } else
        s = t.startContainer, l = t.startOffset, u = t.endContainer, c = t.endOffset, p = t.collapsed;
    if (s == null || u == null || l == null || c == null)
      throw new Error("Cannot resolve a Slate range from DOM range: ".concat(t));
    pv && (r = u.textContent) !== null && r !== void 0 && r.endsWith(`

`) && c === u.textContent.length && c--;
    var w = dn.toSlatePoint(e, [s, l], {
      exactMatch: o,
      suppressThrow: i
    });
    if (!w)
      return null;
    var M = _H(s, u) || s === u && c < l, x = p ? w : dn.toSlatePoint(e, [u, c], {
      exactMatch: o,
      suppressThrow: i,
      searchDirection: M ? "forward" : "backward"
    });
    if (!x)
      return null;
    var v = {
      anchor: w,
      focus: x
    };
    return Kt.isExpanded(v) && Kt.isForward(v) && pa(u) && cr.void(e, {
      at: v.focus,
      mode: "highest"
    }) && (v = cr.unhangRange(e, v, {
      voids: !0
    })), v;
  }
}, uTe = {
  bold: "mod+b",
  compose: ["down", "left", "right", "up", "backspace", "enter"],
  moveBackward: "left",
  moveForward: "right",
  moveWordBackward: "ctrl+left",
  moveWordForward: "ctrl+right",
  deleteBackward: "shift?+backspace",
  deleteForward: "shift?+delete",
  extendBackward: "shift+left",
  extendForward: "shift+right",
  italic: "mod+i",
  insertSoftBreak: "shift+enter",
  splitBlock: "enter",
  undo: "mod+z"
}, cTe = {
  moveLineBackward: "opt+up",
  moveLineForward: "opt+down",
  moveWordBackward: "opt+left",
  moveWordForward: "opt+right",
  deleteBackward: ["ctrl+backspace", "ctrl+h"],
  deleteForward: ["ctrl+delete", "ctrl+d"],
  deleteLineBackward: "cmd+shift?+backspace",
  deleteLineForward: ["cmd+shift?+delete", "ctrl+k"],
  deleteWordBackward: "opt+shift?+backspace",
  deleteWordForward: "opt+shift?+delete",
  extendLineBackward: "opt+shift+up",
  extendLineForward: "opt+shift+down",
  redo: "cmd+shift+z",
  transposeCharacter: "ctrl+t"
}, pTe = {
  deleteWordBackward: "ctrl+shift?+backspace",
  deleteWordForward: "ctrl+shift?+delete",
  redo: ["ctrl+y", "ctrl+shift+z"]
}, Gr = (e) => {
  var t = uTe[e], n = cTe[e], r = pTe[e], o = t && TE(t), i = n && TE(n), a = r && TE(r);
  return (s) => !!(o && o(s) || OH && i && i(s) || !OH && a && a(s));
};
Gr("bold"), Gr("compose"), Gr("moveBackward"), Gr("moveForward"), Gr("deleteBackward"), Gr("deleteForward"), Gr("deleteLineBackward"), Gr("deleteLineForward"), Gr("deleteWordBackward"), Gr("deleteWordForward"), Gr("extendBackward"), Gr("extendForward"), Gr("extendLineBackward"), Gr("extendLineForward"), Gr("italic"), Gr("moveLineBackward"), Gr("moveLineForward"), Gr("moveWordBackward"), Gr("moveWordForward"), Gr("redo"), Gr("insertSoftBreak"), Gr("splitBlock"), Gr("transposeCharacter"), Gr("undo");
var dTe = (e, t) => {
  var n = [], r = () => {
    n = [];
  }, o = (a) => {
    if (t.current) {
      var s = a.filter((l) => Fee(e, l, a));
      n.push(...s);
    }
  };
  function i() {
    n.length > 0 && (n.reverse().forEach((a) => {
      a.type !== "characterData" && (a.removedNodes.forEach((s) => {
        a.target.insertBefore(s, a.nextSibling);
      }), a.addedNodes.forEach((s) => {
        a.target.removeChild(s);
      }));
    }), r());
  }
  return {
    registerMutations: o,
    restoreDOM: i,
    clear: r
  };
}, fTe = {
  subtree: !0,
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0
};
class hTe extends au {
  constructor() {
    super(...arguments), Lf(this, "context", null), Lf(this, "manager", null), Lf(this, "mutationObserver", null);
  }
  observe() {
    var t, {
      node: n
    } = this.props;
    if (!n.current)
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    (t = this.mutationObserver) === null || t === void 0 || t.observe(n.current, fTe);
  }
  componentDidMount() {
    var {
      receivedUserInput: t
    } = this.props, n = this.context;
    this.manager = dTe(n, t), this.mutationObserver = new MutationObserver(this.manager.registerMutations), this.observe();
  }
  getSnapshotBeforeUpdate() {
    var t, n, r, o = (t = this.mutationObserver) === null || t === void 0 ? void 0 : t.takeRecords();
    if (o != null && o.length) {
      var i;
      (i = this.manager) === null || i === void 0 || i.registerMutations(o);
    }
    return (n = this.mutationObserver) === null || n === void 0 || n.disconnect(), (r = this.manager) === null || r === void 0 || r.restoreDOM(), null;
  }
  componentDidUpdate() {
    var t;
    (t = this.manager) === null || t === void 0 || t.clear(), this.observe();
  }
  componentWillUnmount() {
    var t;
    (t = this.mutationObserver) === null || t === void 0 || t.disconnect();
  }
  render() {
    return this.props.children;
  }
}
Lf(hTe, "contextType", $De);
$e({});
$e({});
$e({});
var Ro = {}, qD = {}, ag = {}, lg = {}, zee = "Expected a function", PH = NaN, gTe = "[object Symbol]", mTe = /^\s+|\s+$/g, vTe = /^[-+]0x[0-9a-f]+$/i, yTe = /^0b[01]+$/i, bTe = /^0o[0-7]+$/i, wTe = parseInt, CTe = typeof yr == "object" && yr && yr.Object === Object && yr, OTe = typeof self == "object" && self && self.Object === Object && self, xTe = CTe || OTe || Function("return this")(), ETe = Object.prototype, kTe = ETe.toString, LTe = Math.max, _Te = Math.min, NE = function() {
  return xTe.Date.now();
};
function PTe(e, t, n) {
  var r, o, i, a, s, l, u = 0, c = !1, p = !1, d = !0;
  if (typeof e != "function")
    throw new TypeError(zee);
  t = SH(t) || 0, Xb(n) && (c = !!n.leading, p = "maxWait" in n, i = p ? LTe(SH(n.maxWait) || 0, t) : i, d = "trailing" in n ? !!n.trailing : d);
  function g(C) {
    var P = r, F = o;
    return r = o = void 0, u = C, a = e.apply(F, P), a;
  }
  function f(C) {
    return u = C, s = setTimeout(E, t), c ? g(C) : a;
  }
  function m(C) {
    var P = C - l, F = C - u, L = t - P;
    return p ? _Te(L, i - F) : L;
  }
  function b(C) {
    var P = C - l, F = C - u;
    return l === void 0 || P >= t || P < 0 || p && F >= i;
  }
  function E() {
    var C = NE();
    if (b(C))
      return w(C);
    s = setTimeout(E, m(C));
  }
  function w(C) {
    return s = void 0, d && r ? g(C) : (r = o = void 0, a);
  }
  function M() {
    s !== void 0 && clearTimeout(s), u = 0, r = l = o = s = void 0;
  }
  function x() {
    return s === void 0 ? a : w(NE());
  }
  function v() {
    var C = NE(), P = b(C);
    if (r = arguments, o = this, l = C, P) {
      if (s === void 0)
        return f(l);
      if (p)
        return s = setTimeout(E, t), g(l);
    }
    return s === void 0 && (s = setTimeout(E, t)), a;
  }
  return v.cancel = M, v.flush = x, v;
}
function STe(e, t, n) {
  var r = !0, o = !0;
  if (typeof e != "function")
    throw new TypeError(zee);
  return Xb(n) && (r = "leading" in n ? !!n.leading : r, o = "trailing" in n ? !!n.trailing : o), PTe(e, t, {
    leading: r,
    maxWait: t,
    trailing: o
  });
}
function Xb(e) {
  var t = typeof e;
  return !!e && (t == "object" || t == "function");
}
function MTe(e) {
  return !!e && typeof e == "object";
}
function DTe(e) {
  return typeof e == "symbol" || MTe(e) && kTe.call(e) == gTe;
}
function SH(e) {
  if (typeof e == "number")
    return e;
  if (DTe(e))
    return PH;
  if (Xb(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = Xb(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = e.replace(mTe, "");
  var n = yTe.test(e);
  return n || bTe.test(e) ? wTe(e.slice(2), n ? 2 : 8) : vTe.test(e) ? PH : +e;
}
var TTe = STe, ug = {};
Object.defineProperty(ug, "__esModule", {
  value: !0
});
ug.addPassiveEventListener = function(e, t, n) {
  var r = n.name;
  r || (r = t, console.warn("Listener must be a named function.")), Py.has(t) || Py.set(t, /* @__PURE__ */ new Set());
  var o = Py.get(t);
  if (!o.has(r)) {
    var i = function() {
      var a = !1;
      try {
        var s = Object.defineProperty({}, "passive", {
          get: function() {
            a = !0;
          }
        });
        window.addEventListener("test", null, s);
      } catch {
      }
      return a;
    }();
    e.addEventListener(t, n, i ? { passive: !0 } : !1), o.add(r);
  }
};
ug.removePassiveEventListener = function(e, t, n) {
  e.removeEventListener(t, n), Py.get(t).delete(n.name || t);
};
var Py = /* @__PURE__ */ new Map();
Object.defineProperty(lg, "__esModule", {
  value: !0
});
var jTe = TTe, ATe = RTe(jTe), MH = ug;
function RTe(e) {
  return e && e.__esModule ? e : { default: e };
}
var ITe = function(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 66;
  return (0, ATe.default)(e, t);
}, po = {
  spyCallbacks: [],
  spySetState: [],
  scrollSpyContainers: [],
  mount: function(e, t) {
    if (e) {
      var n = ITe(function(r) {
        po.scrollHandler(e);
      }, t);
      return po.scrollSpyContainers.push(e), (0, MH.addPassiveEventListener)(e, "scroll", n), function() {
        (0, MH.removePassiveEventListener)(e, "scroll", n), po.scrollSpyContainers.splice(po.scrollSpyContainers.indexOf(e), 1);
      };
    }
    return function() {
    };
  },
  isMounted: function(e) {
    return po.scrollSpyContainers.indexOf(e) !== -1;
  },
  currentPositionX: function(e) {
    if (e === document) {
      var t = window.scrollY !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.scrollX : n ? document.documentElement.scrollLeft : document.body.scrollLeft;
    } else
      return e.scrollLeft;
  },
  currentPositionY: function(e) {
    if (e === document) {
      var t = window.scrollX !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.scrollY : n ? document.documentElement.scrollTop : document.body.scrollTop;
    } else
      return e.scrollTop;
  },
  scrollHandler: function(e) {
    var t = po.scrollSpyContainers[po.scrollSpyContainers.indexOf(e)].spyCallbacks || [];
    t.forEach(function(n) {
      return n(po.currentPositionX(e), po.currentPositionY(e));
    });
  },
  addStateHandler: function(e) {
    po.spySetState.push(e);
  },
  addSpyHandler: function(e, t) {
    var n = po.scrollSpyContainers[po.scrollSpyContainers.indexOf(t)];
    n.spyCallbacks || (n.spyCallbacks = []), n.spyCallbacks.push(e);
  },
  updateStates: function() {
    po.spySetState.forEach(function(e) {
      return e();
    });
  },
  unmount: function(e, t) {
    po.scrollSpyContainers.forEach(function(n) {
      return n.spyCallbacks && n.spyCallbacks.length && n.spyCallbacks.indexOf(t) > -1 && n.spyCallbacks.splice(n.spyCallbacks.indexOf(t), 1);
    }), po.spySetState && po.spySetState.length && po.spySetState.indexOf(e) > -1 && po.spySetState.splice(po.spySetState.indexOf(e), 1), document.removeEventListener("scroll", po.scrollHandler);
  },
  update: function() {
    return po.scrollSpyContainers.forEach(function(e) {
      return po.scrollHandler(e);
    });
  }
};
lg.default = po;
var Hp = {}, cg = {};
Object.defineProperty(cg, "__esModule", {
  value: !0
});
var NTe = function(e, t) {
  var n = e.indexOf("#") === 0 ? e.substring(1) : e, r = n ? "#" + n : "", o = window && window.location, i = r ? o.pathname + o.search + r : o.pathname + o.search;
  t ? history.pushState(history.state, "", i) : history.replaceState(history.state, "", i);
}, BTe = function() {
  return window.location.hash.replace(/^#/, "");
}, FTe = function(e) {
  return function(t) {
    return e.contains ? e != t && e.contains(t) : !!(e.compareDocumentPosition(t) & 16);
  };
}, zTe = function(e) {
  return getComputedStyle(e).position !== "static";
}, BE = function(e, t) {
  for (var n = e.offsetTop, r = e.offsetParent; r && !t(r); )
    n += r.offsetTop, r = r.offsetParent;
  return { offsetTop: n, offsetParent: r };
}, UTe = function(e, t, n) {
  if (n)
    return e === document ? t.getBoundingClientRect().left + (window.scrollX || window.pageXOffset) : getComputedStyle(e).position !== "static" ? t.offsetLeft : t.offsetLeft - e.offsetLeft;
  if (e === document)
    return t.getBoundingClientRect().top + (window.scrollY || window.pageYOffset);
  if (zTe(e)) {
    if (t.offsetParent !== e) {
      var r = function(l) {
        return l === e || l === document;
      }, o = BE(t, r), i = o.offsetTop, a = o.offsetParent;
      if (a !== e)
        throw new Error("Seems containerElement is not an ancestor of the Element");
      return i;
    }
    return t.offsetTop;
  }
  if (t.offsetParent === e.offsetParent)
    return t.offsetTop - e.offsetTop;
  var s = function(l) {
    return l === document;
  };
  return BE(t, s).offsetTop - BE(e, s).offsetTop;
};
cg.default = {
  updateHash: NTe,
  getHash: BTe,
  filterElementInContainer: FTe,
  scrollOffset: UTe
};
var uO = {}, GD = {};
Object.defineProperty(GD, "__esModule", {
  value: !0
});
GD.default = {
  /*
   * https://github.com/oblador/angular-scroll (duScrollDefaultEasing)
   */
  defaultEasing: function(e) {
    return e < 0.5 ? Math.pow(e * 2, 2) / 2 : 1 - Math.pow((1 - e) * 2, 2) / 2;
  },
  /*
   * https://gist.github.com/gre/1650294
   */
  // no easing, no acceleration
  linear: function(e) {
    return e;
  },
  // accelerating from zero velocity
  easeInQuad: function(e) {
    return e * e;
  },
  // decelerating to zero velocity
  easeOutQuad: function(e) {
    return e * (2 - e);
  },
  // acceleration until halfway, then deceleration
  easeInOutQuad: function(e) {
    return e < 0.5 ? 2 * e * e : -1 + (4 - 2 * e) * e;
  },
  // accelerating from zero velocity 
  easeInCubic: function(e) {
    return e * e * e;
  },
  // decelerating to zero velocity π
  easeOutCubic: function(e) {
    return --e * e * e + 1;
  },
  // acceleration until halfway, then deceleration 
  easeInOutCubic: function(e) {
    return e < 0.5 ? 4 * e * e * e : (e - 1) * (2 * e - 2) * (2 * e - 2) + 1;
  },
  // accelerating from zero velocity 
  easeInQuart: function(e) {
    return e * e * e * e;
  },
  // decelerating to zero velocity 
  easeOutQuart: function(e) {
    return 1 - --e * e * e * e;
  },
  // acceleration until halfway, then deceleration
  easeInOutQuart: function(e) {
    return e < 0.5 ? 8 * e * e * e * e : 1 - 8 * --e * e * e * e;
  },
  // accelerating from zero velocity
  easeInQuint: function(e) {
    return e * e * e * e * e;
  },
  // decelerating to zero velocity
  easeOutQuint: function(e) {
    return 1 + --e * e * e * e * e;
  },
  // acceleration until halfway, then deceleration 
  easeInOutQuint: function(e) {
    return e < 0.5 ? 16 * e * e * e * e * e : 1 + 16 * --e * e * e * e * e;
  }
};
var KD = {};
Object.defineProperty(KD, "__esModule", {
  value: !0
});
var HTe = ug, WTe = ["mousedown", "wheel", "touchmove", "keydown"];
KD.default = {
  subscribe: function(e) {
    return typeof document < "u" && WTe.forEach(function(t) {
      return (0, HTe.addPassiveEventListener)(document, t, e);
    });
  }
};
var pg = {};
Object.defineProperty(pg, "__esModule", {
  value: !0
});
var W_ = {
  registered: {},
  scrollEvent: {
    register: function(e, t) {
      W_.registered[e] = t;
    },
    remove: function(e) {
      W_.registered[e] = null;
    }
  }
};
pg.default = W_;
Object.defineProperty(uO, "__esModule", {
  value: !0
});
var $Te = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, VTe = cg;
cO(VTe);
var ZTe = GD, DH = cO(ZTe), qTe = KD, GTe = cO(qTe), KTe = pg, ra = cO(KTe);
function cO(e) {
  return e && e.__esModule ? e : { default: e };
}
var Uee = function(e) {
  return DH.default[e.smooth] || DH.default.defaultEasing;
}, XTe = function(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}, YTe = function() {
  if (typeof window < "u")
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame;
}, $_ = function() {
  return YTe() || function(e, t, n) {
    window.setTimeout(e, n || 1e3 / 60, (/* @__PURE__ */ new Date()).getTime());
  };
}(), Hee = function() {
  return {
    currentPosition: 0,
    startPosition: 0,
    targetPosition: 0,
    progress: 0,
    duration: 0,
    cancel: !1,
    target: null,
    containerElement: null,
    to: null,
    start: null,
    delta: null,
    percent: null,
    delayTimeout: null
  };
}, Wee = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollLeft;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageXOffset : r ? document.documentElement.scrollLeft : document.body.scrollLeft;
}, $ee = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollTop;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageYOffset : r ? document.documentElement.scrollTop : document.body.scrollTop;
}, JTe = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollWidth - t.offsetWidth;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollWidth, n.offsetWidth, r.clientWidth, r.scrollWidth, r.offsetWidth);
}, QTe = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollHeight - t.offsetHeight;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollHeight, n.offsetHeight, r.clientHeight, r.scrollHeight, r.offsetHeight);
}, eje = function e(t, n, r) {
  var o = n.data;
  if (!n.ignoreCancelEvents && o.cancel) {
    ra.default.registered.end && ra.default.registered.end(o.to, o.target, o.currentPositionY);
    return;
  }
  if (o.delta = Math.round(o.targetPosition - o.startPosition), o.start === null && (o.start = r), o.progress = r - o.start, o.percent = o.progress >= o.duration ? 1 : t(o.progress / o.duration), o.currentPosition = o.startPosition + Math.ceil(o.delta * o.percent), o.containerElement && o.containerElement !== document && o.containerElement !== document.body ? n.horizontal ? o.containerElement.scrollLeft = o.currentPosition : o.containerElement.scrollTop = o.currentPosition : n.horizontal ? window.scrollTo(o.currentPosition, 0) : window.scrollTo(0, o.currentPosition), o.percent < 1) {
    var i = e.bind(null, t, n);
    $_.call(window, i);
    return;
  }
  ra.default.registered.end && ra.default.registered.end(o.to, o.target, o.currentPosition);
}, XD = function(e) {
  e.data.containerElement = e ? e.containerId ? document.getElementById(e.containerId) : e.container && e.container.nodeType ? e.container : document : null;
}, dg = function(e, t, n, r) {
  t.data = t.data || Hee(), window.clearTimeout(t.data.delayTimeout);
  var o = function() {
    t.data.cancel = !0;
  };
  if (GTe.default.subscribe(o), XD(t), t.data.start = null, t.data.cancel = !1, t.data.startPosition = t.horizontal ? Wee(t) : $ee(t), t.data.targetPosition = t.absolute ? e : e + t.data.startPosition, t.data.startPosition === t.data.targetPosition) {
    ra.default.registered.end && ra.default.registered.end(t.data.to, t.data.target, t.data.currentPosition);
    return;
  }
  t.data.delta = Math.round(t.data.targetPosition - t.data.startPosition), t.data.duration = XTe(t.duration)(t.data.delta), t.data.duration = isNaN(parseFloat(t.data.duration)) ? 1e3 : parseFloat(t.data.duration), t.data.to = n, t.data.target = r;
  var i = Uee(t), a = eje.bind(null, i, t);
  if (t && t.delay > 0) {
    t.data.delayTimeout = window.setTimeout(function() {
      ra.default.registered.begin && ra.default.registered.begin(t.data.to, t.data.target), $_.call(window, a);
    }, t.delay);
    return;
  }
  ra.default.registered.begin && ra.default.registered.begin(t.data.to, t.data.target), $_.call(window, a);
}, pO = function(e) {
  return e = $Te({}, e), e.data = e.data || Hee(), e.absolute = !0, e;
}, tje = function(e) {
  dg(0, pO(e));
}, nje = function(e, t) {
  dg(e, pO(t));
}, rje = function(e) {
  e = pO(e), XD(e), dg(e.horizontal ? JTe(e) : QTe(e), e);
}, oje = function(e, t) {
  t = pO(t), XD(t);
  var n = t.horizontal ? Wee(t) : $ee(t);
  dg(e + n, t);
};
uO.default = {
  animateTopScroll: dg,
  getAnimationType: Uee,
  scrollToTop: tje,
  scrollToBottom: rje,
  scrollTo: nje,
  scrollMore: oje
};
Object.defineProperty(Hp, "__esModule", {
  value: !0
});
var ije = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, sje = cg, aje = YD(sje), lje = uO, uje = YD(lje), cje = pg, fv = YD(cje);
function YD(e) {
  return e && e.__esModule ? e : { default: e };
}
var hv = {}, TH = void 0;
Hp.default = {
  unmount: function() {
    hv = {};
  },
  register: function(e, t) {
    hv[e] = t;
  },
  unregister: function(e) {
    delete hv[e];
  },
  get: function(e) {
    return hv[e] || document.getElementById(e) || document.getElementsByName(e)[0] || document.getElementsByClassName(e)[0];
  },
  setActiveLink: function(e) {
    return TH = e;
  },
  getActiveLink: function() {
    return TH;
  },
  scrollTo: function(e, t) {
    var n = this.get(e);
    if (!n) {
      console.warn("target Element not found");
      return;
    }
    t = ije({}, t, { absolute: !1 });
    var r = t.containerId, o = t.container, i = void 0;
    r ? i = document.getElementById(r) : o && o.nodeType ? i = o : i = document, t.absolute = !0;
    var a = t.horizontal, s = aje.default.scrollOffset(i, n, a) + (t.offset || 0);
    if (!t.smooth) {
      fv.default.registered.begin && fv.default.registered.begin(e, n), i === document ? t.horizontal ? window.scrollTo(s, 0) : window.scrollTo(0, s) : i.scrollTop = s, fv.default.registered.end && fv.default.registered.end(e, n);
      return;
    }
    uje.default.animateTopScroll(s, t, e, n);
  }
};
var V_ = { exports: {} }, FE = { exports: {} }, Vn = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var jH;
function pje() {
  if (jH) return Vn;
  jH = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, g = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, m = e ? Symbol.for("react.block") : 60121, b = e ? Symbol.for("react.fundamental") : 60117, E = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
  function M(v) {
    if (typeof v == "object" && v !== null) {
      var C = v.$$typeof;
      switch (C) {
        case t:
          switch (v = v.type, v) {
            case l:
            case u:
            case r:
            case i:
            case o:
            case p:
              return v;
            default:
              switch (v = v && v.$$typeof, v) {
                case s:
                case c:
                case f:
                case g:
                case a:
                  return v;
                default:
                  return C;
              }
          }
        case n:
          return C;
      }
    }
  }
  function x(v) {
    return M(v) === u;
  }
  return Vn.AsyncMode = l, Vn.ConcurrentMode = u, Vn.ContextConsumer = s, Vn.ContextProvider = a, Vn.Element = t, Vn.ForwardRef = c, Vn.Fragment = r, Vn.Lazy = f, Vn.Memo = g, Vn.Portal = n, Vn.Profiler = i, Vn.StrictMode = o, Vn.Suspense = p, Vn.isAsyncMode = function(v) {
    return x(v) || M(v) === l;
  }, Vn.isConcurrentMode = x, Vn.isContextConsumer = function(v) {
    return M(v) === s;
  }, Vn.isContextProvider = function(v) {
    return M(v) === a;
  }, Vn.isElement = function(v) {
    return typeof v == "object" && v !== null && v.$$typeof === t;
  }, Vn.isForwardRef = function(v) {
    return M(v) === c;
  }, Vn.isFragment = function(v) {
    return M(v) === r;
  }, Vn.isLazy = function(v) {
    return M(v) === f;
  }, Vn.isMemo = function(v) {
    return M(v) === g;
  }, Vn.isPortal = function(v) {
    return M(v) === n;
  }, Vn.isProfiler = function(v) {
    return M(v) === i;
  }, Vn.isStrictMode = function(v) {
    return M(v) === o;
  }, Vn.isSuspense = function(v) {
    return M(v) === p;
  }, Vn.isValidElementType = function(v) {
    return typeof v == "string" || typeof v == "function" || v === r || v === u || v === i || v === o || v === p || v === d || typeof v == "object" && v !== null && (v.$$typeof === f || v.$$typeof === g || v.$$typeof === a || v.$$typeof === s || v.$$typeof === c || v.$$typeof === b || v.$$typeof === E || v.$$typeof === w || v.$$typeof === m);
  }, Vn.typeOf = M, Vn;
}
var tr = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var AH;
function dje() {
  return AH || (AH = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, g = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, m = e ? Symbol.for("react.block") : 60121, b = e ? Symbol.for("react.fundamental") : 60117, E = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
    function M(I) {
      return typeof I == "string" || typeof I == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      I === r || I === u || I === i || I === o || I === p || I === d || typeof I == "object" && I !== null && (I.$$typeof === f || I.$$typeof === g || I.$$typeof === a || I.$$typeof === s || I.$$typeof === c || I.$$typeof === b || I.$$typeof === E || I.$$typeof === w || I.$$typeof === m);
    }
    function x(I) {
      if (typeof I == "object" && I !== null) {
        var le = I.$$typeof;
        switch (le) {
          case t:
            var he = I.type;
            switch (he) {
              case l:
              case u:
              case r:
              case i:
              case o:
              case p:
                return he;
              default:
                var oe = he && he.$$typeof;
                switch (oe) {
                  case s:
                  case c:
                  case f:
                  case g:
                  case a:
                    return oe;
                  default:
                    return le;
                }
            }
          case n:
            return le;
        }
      }
    }
    var v = l, C = u, P = s, F = a, L = t, B = c, N = r, $ = f, V = g, H = n, Z = i, K = o, Y = p, Q = !1;
    function J(I) {
      return Q || (Q = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), _(I) || x(I) === l;
    }
    function _(I) {
      return x(I) === u;
    }
    function D(I) {
      return x(I) === s;
    }
    function z(I) {
      return x(I) === a;
    }
    function S(I) {
      return typeof I == "object" && I !== null && I.$$typeof === t;
    }
    function W(I) {
      return x(I) === c;
    }
    function O(I) {
      return x(I) === r;
    }
    function j(I) {
      return x(I) === f;
    }
    function U(I) {
      return x(I) === g;
    }
    function T(I) {
      return x(I) === n;
    }
    function q(I) {
      return x(I) === i;
    }
    function A(I) {
      return x(I) === o;
    }
    function X(I) {
      return x(I) === p;
    }
    tr.AsyncMode = v, tr.ConcurrentMode = C, tr.ContextConsumer = P, tr.ContextProvider = F, tr.Element = L, tr.ForwardRef = B, tr.Fragment = N, tr.Lazy = $, tr.Memo = V, tr.Portal = H, tr.Profiler = Z, tr.StrictMode = K, tr.Suspense = Y, tr.isAsyncMode = J, tr.isConcurrentMode = _, tr.isContextConsumer = D, tr.isContextProvider = z, tr.isElement = S, tr.isForwardRef = W, tr.isFragment = O, tr.isLazy = j, tr.isMemo = U, tr.isPortal = T, tr.isProfiler = q, tr.isStrictMode = A, tr.isSuspense = X, tr.isValidElementType = M, tr.typeOf = x;
  }()), tr;
}
var RH;
function Vee() {
  return RH || (RH = 1, process.env.NODE_ENV === "production" ? FE.exports = pje() : FE.exports = dje()), FE.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var zE, IH;
function fje() {
  if (IH) return zE;
  IH = 1;
  var e = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, n = Object.prototype.propertyIsEnumerable;
  function r(i) {
    if (i == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(i);
  }
  function o() {
    try {
      if (!Object.assign)
        return !1;
      var i = new String("abc");
      if (i[5] = "de", Object.getOwnPropertyNames(i)[0] === "5")
        return !1;
      for (var a = {}, s = 0; s < 10; s++)
        a["_" + String.fromCharCode(s)] = s;
      var l = Object.getOwnPropertyNames(a).map(function(c) {
        return a[c];
      });
      if (l.join("") !== "0123456789")
        return !1;
      var u = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(c) {
        u[c] = c;
      }), Object.keys(Object.assign({}, u)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return zE = o() ? Object.assign : function(i, a) {
    for (var s, l = r(i), u, c = 1; c < arguments.length; c++) {
      s = Object(arguments[c]);
      for (var p in s)
        t.call(s, p) && (l[p] = s[p]);
      if (e) {
        u = e(s);
        for (var d = 0; d < u.length; d++)
          n.call(s, u[d]) && (l[u[d]] = s[u[d]]);
      }
    }
    return l;
  }, zE;
}
var UE, NH;
function JD() {
  if (NH) return UE;
  NH = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return UE = e, UE;
}
var BH, FH;
function Zee() {
  return FH || (FH = 1, BH = Function.call.bind(Object.prototype.hasOwnProperty)), BH;
}
var HE, zH;
function hje() {
  if (zH) return HE;
  zH = 1;
  var e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = JD(), n = {}, r = Zee();
    e = function(i) {
      var a = "Warning: " + i;
      typeof console < "u" && console.error(a);
      try {
        throw new Error(a);
      } catch {
      }
    };
  }
  function o(i, a, s, l, u) {
    if (process.env.NODE_ENV !== "production") {
      for (var c in i)
        if (r(i, c)) {
          var p;
          try {
            if (typeof i[c] != "function") {
              var d = Error(
                (l || "React class") + ": " + s + " type `" + c + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof i[c] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw d.name = "Invariant Violation", d;
            }
            p = i[c](a, c, l, s, null, t);
          } catch (f) {
            p = f;
          }
          if (p && !(p instanceof Error) && e(
            (l || "React class") + ": type specification of " + s + " `" + c + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof p + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), p instanceof Error && !(p.message in n)) {
            n[p.message] = !0;
            var g = u ? u() : "";
            e(
              "Failed " + s + " type: " + p.message + (g ?? "")
            );
          }
        }
    }
  }
  return o.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (n = {});
  }, HE = o, HE;
}
var WE, UH;
function gje() {
  if (UH) return WE;
  UH = 1;
  var e = Vee(), t = fje(), n = JD(), r = Zee(), o = hje(), i = function() {
  };
  process.env.NODE_ENV !== "production" && (i = function(s) {
    var l = "Warning: " + s;
    typeof console < "u" && console.error(l);
    try {
      throw new Error(l);
    } catch {
    }
  });
  function a() {
    return null;
  }
  return WE = function(s, l) {
    var u = typeof Symbol == "function" && Symbol.iterator, c = "@@iterator";
    function p(_) {
      var D = _ && (u && _[u] || _[c]);
      if (typeof D == "function")
        return D;
    }
    var d = "<<anonymous>>", g = {
      array: E("array"),
      bigint: E("bigint"),
      bool: E("boolean"),
      func: E("function"),
      number: E("number"),
      object: E("object"),
      string: E("string"),
      symbol: E("symbol"),
      any: w(),
      arrayOf: M,
      element: x(),
      elementType: v(),
      instanceOf: C,
      node: B(),
      objectOf: F,
      oneOf: P,
      oneOfType: L,
      shape: $,
      exact: V
    };
    function f(_, D) {
      return _ === D ? _ !== 0 || 1 / _ === 1 / D : _ !== _ && D !== D;
    }
    function m(_, D) {
      this.message = _, this.data = D && typeof D == "object" ? D : {}, this.stack = "";
    }
    m.prototype = Error.prototype;
    function b(_) {
      if (process.env.NODE_ENV !== "production")
        var D = {}, z = 0;
      function S(O, j, U, T, q, A, X) {
        if (T = T || d, A = A || U, X !== n) {
          if (l) {
            var I = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw I.name = "Invariant Violation", I;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var le = T + ":" + U;
            !D[le] && // Avoid spamming the console because they are often not actionable except for lib authors
            z < 3 && (i(
              "You are manually calling a React.PropTypes validation function for the `" + A + "` prop on `" + T + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), D[le] = !0, z++);
          }
        }
        return j[U] == null ? O ? j[U] === null ? new m("The " + q + " `" + A + "` is marked as required " + ("in `" + T + "`, but its value is `null`.")) : new m("The " + q + " `" + A + "` is marked as required in " + ("`" + T + "`, but its value is `undefined`.")) : null : _(j, U, T, q, A);
      }
      var W = S.bind(null, !1);
      return W.isRequired = S.bind(null, !0), W;
    }
    function E(_) {
      function D(z, S, W, O, j, U) {
        var T = z[S], q = K(T);
        if (q !== _) {
          var A = Y(T);
          return new m(
            "Invalid " + O + " `" + j + "` of type " + ("`" + A + "` supplied to `" + W + "`, expected ") + ("`" + _ + "`."),
            { expectedType: _ }
          );
        }
        return null;
      }
      return b(D);
    }
    function w() {
      return b(a);
    }
    function M(_) {
      function D(z, S, W, O, j) {
        if (typeof _ != "function")
          return new m("Property `" + j + "` of component `" + W + "` has invalid PropType notation inside arrayOf.");
        var U = z[S];
        if (!Array.isArray(U)) {
          var T = K(U);
          return new m("Invalid " + O + " `" + j + "` of type " + ("`" + T + "` supplied to `" + W + "`, expected an array."));
        }
        for (var q = 0; q < U.length; q++) {
          var A = _(U, q, W, O, j + "[" + q + "]", n);
          if (A instanceof Error)
            return A;
        }
        return null;
      }
      return b(D);
    }
    function x() {
      function _(D, z, S, W, O) {
        var j = D[z];
        if (!s(j)) {
          var U = K(j);
          return new m("Invalid " + W + " `" + O + "` of type " + ("`" + U + "` supplied to `" + S + "`, expected a single ReactElement."));
        }
        return null;
      }
      return b(_);
    }
    function v() {
      function _(D, z, S, W, O) {
        var j = D[z];
        if (!e.isValidElementType(j)) {
          var U = K(j);
          return new m("Invalid " + W + " `" + O + "` of type " + ("`" + U + "` supplied to `" + S + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return b(_);
    }
    function C(_) {
      function D(z, S, W, O, j) {
        if (!(z[S] instanceof _)) {
          var U = _.name || d, T = J(z[S]);
          return new m("Invalid " + O + " `" + j + "` of type " + ("`" + T + "` supplied to `" + W + "`, expected ") + ("instance of `" + U + "`."));
        }
        return null;
      }
      return b(D);
    }
    function P(_) {
      if (!Array.isArray(_))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? i(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : i("Invalid argument supplied to oneOf, expected an array.")), a;
      function D(z, S, W, O, j) {
        for (var U = z[S], T = 0; T < _.length; T++)
          if (f(U, _[T]))
            return null;
        var q = JSON.stringify(_, function(A, X) {
          var I = Y(X);
          return I === "symbol" ? String(X) : X;
        });
        return new m("Invalid " + O + " `" + j + "` of value `" + String(U) + "` " + ("supplied to `" + W + "`, expected one of " + q + "."));
      }
      return b(D);
    }
    function F(_) {
      function D(z, S, W, O, j) {
        if (typeof _ != "function")
          return new m("Property `" + j + "` of component `" + W + "` has invalid PropType notation inside objectOf.");
        var U = z[S], T = K(U);
        if (T !== "object")
          return new m("Invalid " + O + " `" + j + "` of type " + ("`" + T + "` supplied to `" + W + "`, expected an object."));
        for (var q in U)
          if (r(U, q)) {
            var A = _(U, q, W, O, j + "." + q, n);
            if (A instanceof Error)
              return A;
          }
        return null;
      }
      return b(D);
    }
    function L(_) {
      if (!Array.isArray(_))
        return process.env.NODE_ENV !== "production" && i("Invalid argument supplied to oneOfType, expected an instance of array."), a;
      for (var D = 0; D < _.length; D++) {
        var z = _[D];
        if (typeof z != "function")
          return i(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + Q(z) + " at index " + D + "."
          ), a;
      }
      function S(W, O, j, U, T) {
        for (var q = [], A = 0; A < _.length; A++) {
          var X = _[A], I = X(W, O, j, U, T, n);
          if (I == null)
            return null;
          I.data && r(I.data, "expectedType") && q.push(I.data.expectedType);
        }
        var le = q.length > 0 ? ", expected one of type [" + q.join(", ") + "]" : "";
        return new m("Invalid " + U + " `" + T + "` supplied to " + ("`" + j + "`" + le + "."));
      }
      return b(S);
    }
    function B() {
      function _(D, z, S, W, O) {
        return H(D[z]) ? null : new m("Invalid " + W + " `" + O + "` supplied to " + ("`" + S + "`, expected a ReactNode."));
      }
      return b(_);
    }
    function N(_, D, z, S, W) {
      return new m(
        (_ || "React class") + ": " + D + " type `" + z + "." + S + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + W + "`."
      );
    }
    function $(_) {
      function D(z, S, W, O, j) {
        var U = z[S], T = K(U);
        if (T !== "object")
          return new m("Invalid " + O + " `" + j + "` of type `" + T + "` " + ("supplied to `" + W + "`, expected `object`."));
        for (var q in _) {
          var A = _[q];
          if (typeof A != "function")
            return N(W, O, j, q, Y(A));
          var X = A(U, q, W, O, j + "." + q, n);
          if (X)
            return X;
        }
        return null;
      }
      return b(D);
    }
    function V(_) {
      function D(z, S, W, O, j) {
        var U = z[S], T = K(U);
        if (T !== "object")
          return new m("Invalid " + O + " `" + j + "` of type `" + T + "` " + ("supplied to `" + W + "`, expected `object`."));
        var q = t({}, z[S], _);
        for (var A in q) {
          var X = _[A];
          if (r(_, A) && typeof X != "function")
            return N(W, O, j, A, Y(X));
          if (!X)
            return new m(
              "Invalid " + O + " `" + j + "` key `" + A + "` supplied to `" + W + "`.\nBad object: " + JSON.stringify(z[S], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(_), null, "  ")
            );
          var I = X(U, A, W, O, j + "." + A, n);
          if (I)
            return I;
        }
        return null;
      }
      return b(D);
    }
    function H(_) {
      switch (typeof _) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !_;
        case "object":
          if (Array.isArray(_))
            return _.every(H);
          if (_ === null || s(_))
            return !0;
          var D = p(_);
          if (D) {
            var z = D.call(_), S;
            if (D !== _.entries) {
              for (; !(S = z.next()).done; )
                if (!H(S.value))
                  return !1;
            } else
              for (; !(S = z.next()).done; ) {
                var W = S.value;
                if (W && !H(W[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function Z(_, D) {
      return _ === "symbol" ? !0 : D ? D["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && D instanceof Symbol : !1;
    }
    function K(_) {
      var D = typeof _;
      return Array.isArray(_) ? "array" : _ instanceof RegExp ? "object" : Z(D, _) ? "symbol" : D;
    }
    function Y(_) {
      if (typeof _ > "u" || _ === null)
        return "" + _;
      var D = K(_);
      if (D === "object") {
        if (_ instanceof Date)
          return "date";
        if (_ instanceof RegExp)
          return "regexp";
      }
      return D;
    }
    function Q(_) {
      var D = Y(_);
      switch (D) {
        case "array":
        case "object":
          return "an " + D;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + D;
        default:
          return D;
      }
    }
    function J(_) {
      return !_.constructor || !_.constructor.name ? d : _.constructor.name;
    }
    return g.checkPropTypes = o, g.resetWarningCache = o.resetWarningCache, g.PropTypes = g, g;
  }, WE;
}
var $E, HH;
function mje() {
  if (HH) return $E;
  HH = 1;
  var e = JD();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, $E = function() {
    function r(a, s, l, u, c, p) {
      if (p !== e) {
        var d = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw d.name = "Invariant Violation", d;
      }
    }
    r.isRequired = r;
    function o() {
      return r;
    }
    var i = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: o,
      element: r,
      elementType: r,
      instanceOf: o,
      node: r,
      objectOf: o,
      oneOf: o,
      oneOfType: o,
      shape: o,
      exact: o,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return i.PropTypes = i, i;
  }, $E;
}
if (process.env.NODE_ENV !== "production") {
  var vje = Vee(), yje = !0;
  V_.exports = gje()(vje.isElement, yje);
} else
  V_.exports = mje()();
var dO = V_.exports, fO = {};
Object.defineProperty(fO, "__esModule", {
  value: !0
});
var bje = cg, VE = wje(bje);
function wje(e) {
  return e && e.__esModule ? e : { default: e };
}
var Cje = {
  mountFlag: !1,
  initialized: !1,
  scroller: null,
  containers: {},
  mount: function(e) {
    this.scroller = e, this.handleHashChange = this.handleHashChange.bind(this), window.addEventListener("hashchange", this.handleHashChange), this.initStateFromHash(), this.mountFlag = !0;
  },
  mapContainer: function(e, t) {
    this.containers[e] = t;
  },
  isMounted: function() {
    return this.mountFlag;
  },
  isInitialized: function() {
    return this.initialized;
  },
  initStateFromHash: function() {
    var e = this, t = this.getHash();
    t ? window.setTimeout(function() {
      e.scrollTo(t, !0), e.initialized = !0;
    }, 10) : this.initialized = !0;
  },
  scrollTo: function(e, t) {
    var n = this.scroller, r = n.get(e);
    if (r && (t || e !== n.getActiveLink())) {
      var o = this.containers[e] || document;
      n.scrollTo(e, { container: o });
    }
  },
  getHash: function() {
    return VE.default.getHash();
  },
  changeHash: function(e, t) {
    this.isInitialized() && VE.default.getHash() !== e && VE.default.updateHash(e, t);
  },
  handleHashChange: function() {
    this.scrollTo(this.getHash());
  },
  unmount: function() {
    this.scroller = null, this.containers = null, window.removeEventListener("hashchange", this.handleHashChange);
  }
};
fO.default = Cje;
Object.defineProperty(ag, "__esModule", {
  value: !0
});
var gv = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, Oje = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), xje = be, WH = fg(xje), Eje = lg, mv = fg(Eje), kje = Hp, Lje = fg(kje), _je = dO, Kr = fg(_je), Pje = fO, yl = fg(Pje);
function fg(e) {
  return e && e.__esModule ? e : { default: e };
}
function Sje(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Mje(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function Dje(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var $H = {
  to: Kr.default.string.isRequired,
  containerId: Kr.default.string,
  container: Kr.default.object,
  activeClass: Kr.default.string,
  activeStyle: Kr.default.object,
  spy: Kr.default.bool,
  horizontal: Kr.default.bool,
  smooth: Kr.default.oneOfType([Kr.default.bool, Kr.default.string]),
  offset: Kr.default.number,
  delay: Kr.default.number,
  isDynamic: Kr.default.bool,
  onClick: Kr.default.func,
  duration: Kr.default.oneOfType([Kr.default.number, Kr.default.func]),
  absolute: Kr.default.bool,
  onSetActive: Kr.default.func,
  onSetInactive: Kr.default.func,
  ignoreCancelEvents: Kr.default.bool,
  hashSpy: Kr.default.bool,
  saveHashHistory: Kr.default.bool,
  spyThrottle: Kr.default.number
};
ag.default = function(e, t) {
  var n = t || Lje.default, r = function(i) {
    Dje(a, i);
    function a(s) {
      Sje(this, a);
      var l = Mje(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
      return o.call(l), l.state = {
        active: !1
      }, l.beforeUnmountCallbacks = [], l;
    }
    return Oje(a, [{
      key: "getScrollSpyContainer",
      value: function() {
        var s = this.props.containerId, l = this.props.container;
        return s && !l ? document.getElementById(s) : l && l.nodeType ? l : document;
      }
    }, {
      key: "componentDidMount",
      value: function() {
        if (this.props.spy || this.props.hashSpy) {
          var s = this.getScrollSpyContainer();
          if (!mv.default.isMounted(s)) {
            var l = mv.default.mount(s, this.props.spyThrottle);
            this.beforeUnmountCallbacks.push(l);
          }
          this.props.hashSpy && (yl.default.isMounted() || yl.default.mount(n), yl.default.mapContainer(this.props.to, s)), mv.default.addSpyHandler(this.spyHandler, s), this.setState({
            container: s
          });
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        mv.default.unmount(this.stateHandler, this.spyHandler), this.beforeUnmountCallbacks.forEach(function(s) {
          return s();
        });
      }
    }, {
      key: "render",
      value: function() {
        var s = "";
        this.state && this.state.active ? s = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : s = this.props.className;
        var l = {};
        this.state && this.state.active ? l = gv({}, this.props.style, this.props.activeStyle) : l = gv({}, this.props.style);
        var u = gv({}, this.props);
        for (var c in $H)
          u.hasOwnProperty(c) && delete u[c];
        return u.className = s, u.style = l, u.onClick = this.handleClick, WH.default.createElement(e, u);
      }
    }]), a;
  }(WH.default.PureComponent), o = function() {
    var i = this;
    this.scrollTo = function(a, s) {
      n.scrollTo(a, gv({}, i.state, s));
    }, this.handleClick = function(a) {
      i.props.onClick && i.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), i.scrollTo(i.props.to, i.props);
    }, this.spyHandler = function(a, s) {
      var l = i.getScrollSpyContainer();
      if (!(yl.default.isMounted() && !yl.default.isInitialized())) {
        var u = i.props.horizontal, c = i.props.to, p = null, d = void 0, g = void 0;
        if (u) {
          var f = 0, m = 0, b = 0;
          if (l.getBoundingClientRect) {
            var E = l.getBoundingClientRect();
            b = E.left;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var w = p.getBoundingClientRect();
            f = w.left - b + a, m = f + w.width;
          }
          var M = a - i.props.offset;
          d = M >= Math.floor(f) && M < Math.floor(m), g = M < Math.floor(f) || M >= Math.floor(m);
        } else {
          var x = 0, v = 0, C = 0;
          if (l.getBoundingClientRect) {
            var P = l.getBoundingClientRect();
            C = P.top;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var F = p.getBoundingClientRect();
            x = F.top - C + s, v = x + F.height;
          }
          var L = s - i.props.offset;
          d = L >= Math.floor(x) && L < Math.floor(v), g = L < Math.floor(x) || L >= Math.floor(v);
        }
        var B = n.getActiveLink();
        if (g) {
          if (c === B && n.setActiveLink(void 0), i.props.hashSpy && yl.default.getHash() === c) {
            var N = i.props.saveHashHistory, $ = N === void 0 ? !1 : N;
            yl.default.changeHash("", $);
          }
          i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive(c, p));
        }
        if (d && (B !== c || i.state.active === !1)) {
          n.setActiveLink(c);
          var V = i.props.saveHashHistory, H = V === void 0 ? !1 : V;
          i.props.hashSpy && yl.default.changeHash(c, H), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(c, p));
        }
      }
    };
  };
  return r.propTypes = $H, r.defaultProps = { offset: 0 }, r;
};
Object.defineProperty(qD, "__esModule", {
  value: !0
});
var Tje = be, VH = qee(Tje), jje = ag, Aje = qee(jje);
function qee(e) {
  return e && e.__esModule ? e : { default: e };
}
function Rje(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function ZH(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function Ije(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var Nje = function(e) {
  Ije(t, e);
  function t() {
    var n, r, o, i;
    Rje(this, t);
    for (var a = arguments.length, s = Array(a), l = 0; l < a; l++)
      s[l] = arguments[l];
    return i = (r = (o = ZH(this, (n = t.__proto__ || Object.getPrototypeOf(t)).call.apply(n, [this].concat(s))), o), o.render = function() {
      return VH.default.createElement(
        "a",
        o.props,
        o.props.children
      );
    }, r), ZH(o, i);
  }
  return t;
}(VH.default.Component);
qD.default = (0, Aje.default)(Nje);
var QD = {};
Object.defineProperty(QD, "__esModule", {
  value: !0
});
var Bje = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), Fje = be, qH = Gee(Fje), zje = ag, Uje = Gee(zje);
function Gee(e) {
  return e && e.__esModule ? e : { default: e };
}
function Hje(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Wje(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function $je(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var Vje = function(e) {
  $je(t, e);
  function t() {
    return Hje(this, t), Wje(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return Bje(t, [{
    key: "render",
    value: function() {
      return qH.default.createElement(
        "button",
        this.props,
        this.props.children
      );
    }
  }]), t;
}(qH.default.Component);
QD.default = (0, Uje.default)(Vje);
var eT = {}, hO = {};
Object.defineProperty(hO, "__esModule", {
  value: !0
});
var Zje = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, qje = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), Gje = be, GH = gO(Gje), Kje = il;
gO(Kje);
var Xje = Hp, KH = gO(Xje), Yje = dO, XH = gO(Yje);
function gO(e) {
  return e && e.__esModule ? e : { default: e };
}
function Jje(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Qje(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function eAe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
hO.default = function(e) {
  var t = function(n) {
    eAe(r, n);
    function r(o) {
      Jje(this, r);
      var i = Qje(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
      return i.childBindings = {
        domNode: null
      }, i;
    }
    return qje(r, [{
      key: "componentDidMount",
      value: function() {
        if (typeof window > "u")
          return !1;
        this.registerElems(this.props.name);
      }
    }, {
      key: "componentDidUpdate",
      value: function(o) {
        this.props.name !== o.name && this.registerElems(this.props.name);
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        if (typeof window > "u")
          return !1;
        KH.default.unregister(this.props.name);
      }
    }, {
      key: "registerElems",
      value: function(o) {
        KH.default.register(o, this.childBindings.domNode);
      }
    }, {
      key: "render",
      value: function() {
        return GH.default.createElement(e, Zje({}, this.props, { parentBindings: this.childBindings }));
      }
    }]), r;
  }(GH.default.Component);
  return t.propTypes = {
    name: XH.default.string,
    id: XH.default.string
  }, t;
};
Object.defineProperty(eT, "__esModule", {
  value: !0
});
var YH = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, tAe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), nAe = be, JH = tT(nAe), rAe = hO, oAe = tT(rAe), iAe = dO, QH = tT(iAe);
function tT(e) {
  return e && e.__esModule ? e : { default: e };
}
function sAe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function aAe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function lAe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var Kee = function(e) {
  lAe(t, e);
  function t() {
    return sAe(this, t), aAe(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return tAe(t, [{
    key: "render",
    value: function() {
      var n = this, r = YH({}, this.props);
      return delete r.name, r.parentBindings && delete r.parentBindings, JH.default.createElement(
        "div",
        YH({}, r, { ref: function(o) {
          n.props.parentBindings.domNode = o;
        } }),
        this.props.children
      );
    }
  }]), t;
}(JH.default.Component);
Kee.propTypes = {
  name: QH.default.string,
  id: QH.default.string
};
eT.default = (0, oAe.default)(Kee);
var ZE = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, eW = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}();
function tW(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function nW(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function rW(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var vv = be, Nu = lg, qE = Hp, wo = dO, bl = fO, oW = {
  to: wo.string.isRequired,
  containerId: wo.string,
  container: wo.object,
  activeClass: wo.string,
  spy: wo.bool,
  smooth: wo.oneOfType([wo.bool, wo.string]),
  offset: wo.number,
  delay: wo.number,
  isDynamic: wo.bool,
  onClick: wo.func,
  duration: wo.oneOfType([wo.number, wo.func]),
  absolute: wo.bool,
  onSetActive: wo.func,
  onSetInactive: wo.func,
  ignoreCancelEvents: wo.bool,
  hashSpy: wo.bool,
  spyThrottle: wo.number
}, uAe = {
  Scroll: function(e, t) {
    console.warn("Helpers.Scroll is deprecated since v1.7.0");
    var n = t || qE, r = function(i) {
      rW(a, i);
      function a(s) {
        tW(this, a);
        var l = nW(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
        return o.call(l), l.state = {
          active: !1
        }, l;
      }
      return eW(a, [{
        key: "getScrollSpyContainer",
        value: function() {
          var s = this.props.containerId, l = this.props.container;
          return s ? document.getElementById(s) : l && l.nodeType ? l : document;
        }
      }, {
        key: "componentDidMount",
        value: function() {
          if (this.props.spy || this.props.hashSpy) {
            var s = this.getScrollSpyContainer();
            Nu.isMounted(s) || Nu.mount(s, this.props.spyThrottle), this.props.hashSpy && (bl.isMounted() || bl.mount(n), bl.mapContainer(this.props.to, s)), this.props.spy && Nu.addStateHandler(this.stateHandler), Nu.addSpyHandler(this.spyHandler, s), this.setState({
              container: s
            });
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          Nu.unmount(this.stateHandler, this.spyHandler);
        }
      }, {
        key: "render",
        value: function() {
          var s = "";
          this.state && this.state.active ? s = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : s = this.props.className;
          var l = ZE({}, this.props);
          for (var u in oW)
            l.hasOwnProperty(u) && delete l[u];
          return l.className = s, l.onClick = this.handleClick, vv.createElement(e, l);
        }
      }]), a;
    }(vv.Component), o = function() {
      var i = this;
      this.scrollTo = function(a, s) {
        n.scrollTo(a, ZE({}, i.state, s));
      }, this.handleClick = function(a) {
        i.props.onClick && i.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), i.scrollTo(i.props.to, i.props);
      }, this.stateHandler = function() {
        n.getActiveLink() !== i.props.to && (i.state !== null && i.state.active && i.props.onSetInactive && i.props.onSetInactive(), i.setState({ active: !1 }));
      }, this.spyHandler = function(a) {
        var s = i.getScrollSpyContainer();
        if (!(bl.isMounted() && !bl.isInitialized())) {
          var l = i.props.to, u = null, c = 0, p = 0, d = 0;
          if (s.getBoundingClientRect) {
            var g = s.getBoundingClientRect();
            d = g.top;
          }
          if (!u || i.props.isDynamic) {
            if (u = n.get(l), !u)
              return;
            var f = u.getBoundingClientRect();
            c = f.top - d + a, p = c + f.height;
          }
          var m = a - i.props.offset, b = m >= Math.floor(c) && m < Math.floor(p), E = m < Math.floor(c) || m >= Math.floor(p), w = n.getActiveLink();
          if (E)
            return l === w && n.setActiveLink(void 0), i.props.hashSpy && bl.getHash() === l && bl.changeHash(), i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive()), Nu.updateStates();
          if (b && w !== l)
            return n.setActiveLink(l), i.props.hashSpy && bl.changeHash(l), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(l)), Nu.updateStates();
        }
      };
    };
    return r.propTypes = oW, r.defaultProps = { offset: 0 }, r;
  },
  Element: function(e) {
    console.warn("Helpers.Element is deprecated since v1.7.0");
    var t = function(n) {
      rW(r, n);
      function r(o) {
        tW(this, r);
        var i = nW(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
        return i.childBindings = {
          domNode: null
        }, i;
      }
      return eW(r, [{
        key: "componentDidMount",
        value: function() {
          if (typeof window > "u")
            return !1;
          this.registerElems(this.props.name);
        }
      }, {
        key: "componentDidUpdate",
        value: function(o) {
          this.props.name !== o.name && this.registerElems(this.props.name);
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          if (typeof window > "u")
            return !1;
          qE.unregister(this.props.name);
        }
      }, {
        key: "registerElems",
        value: function(o) {
          qE.register(o, this.childBindings.domNode);
        }
      }, {
        key: "render",
        value: function() {
          return vv.createElement(e, ZE({}, this.props, { parentBindings: this.childBindings }));
        }
      }]), r;
    }(vv.Component);
    return t.propTypes = {
      name: wo.string,
      id: wo.string
    }, t;
  }
}, cAe = uAe;
Object.defineProperty(Ro, "__esModule", {
  value: !0
});
Ro.Helpers = Ro.ScrollElement = Ro.ScrollLink = Ro.animateScroll = Ro.scrollSpy = Ro.Events = Ro.scroller = Ro.Element = Ro.Button = Ro.Link = void 0;
var pAe = qD, Xee = ba(pAe), dAe = QD, Yee = ba(dAe), fAe = eT, Jee = ba(fAe), hAe = Hp, Qee = ba(hAe), gAe = pg, ete = ba(gAe), mAe = lg, tte = ba(mAe), vAe = uO, nte = ba(vAe), yAe = ag, rte = ba(yAe), bAe = hO, ote = ba(bAe), wAe = cAe, ite = ba(wAe);
function ba(e) {
  return e && e.__esModule ? e : { default: e };
}
Ro.Link = Xee.default;
Ro.Button = Yee.default;
Ro.Element = Jee.default;
Ro.scroller = Qee.default;
Ro.Events = ete.default;
Ro.scrollSpy = tte.default;
Ro.animateScroll = nte.default;
Ro.ScrollLink = rte.default;
Ro.ScrollElement = ote.default;
Ro.Helpers = ite.default;
Ro.default = { Link: Xee.default, Button: Yee.default, Element: Jee.default, scroller: Qee.default, Events: ete.default, scrollSpy: tte.default, animateScroll: nte.default, ScrollLink: rte.default, ScrollElement: ote.default, Helpers: ite.default };
$e({});
$e({});
$e({});
function Th(e) {
  "@babel/helpers - typeof";
  return Th = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Th(e);
}
function CAe(e, t) {
  if (Th(e) != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (Th(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function OAe(e) {
  var t = CAe(e, "string");
  return Th(t) == "symbol" ? t : t + "";
}
function Pe(e, t, n) {
  return (t = OAe(t)) in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function ste(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var GE, iW;
function xAe() {
  if (iW) return GE;
  iW = 1;
  var e = process.env.NODE_ENV, t = function(n, r, o, i, a, s, l, u) {
    if (e !== "production" && r === void 0)
      throw new Error("invariant requires an error message argument");
    if (!n) {
      var c;
      if (r === void 0)
        c = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
      else {
        var p = [o, i, a, s, l, u], d = 0;
        c = new Error(r.replace(/%s/g, function() {
          return p[d++];
        })), c.name = "Invariant Violation";
      }
      throw c.framesToPop = 1, c;
    }
  };
  return GE = t, GE;
}
var EAe = xAe(), Wo = /* @__PURE__ */ ste(EAe), Nt = $e(null);
function kAe() {
  Wo(!!ge, "useGoogleMap is React hook and requires React version 16.8+");
  var e = ge(Nt);
  return Wo(!!e, "useGoogleMap needs a GoogleMap available up in the tree"), e;
}
function LAe(e, t, n) {
  return Object.keys(e).reduce(function(r, o) {
    return t(r, e[o], o);
  }, n);
}
function _Ae(e, t) {
  Object.keys(e).forEach((n) => t(e[n], n));
}
function PAe(e, t, n, r) {
  var o = {}, i = (a, s) => {
    var l = n[s];
    l !== t[s] && (o[s] = l, a(r, l));
  };
  return _Ae(e, i), o;
}
function SAe(e, t, n) {
  var r = LAe(n, function(o, i, a) {
    return typeof e[a] == "function" && o.push(google.maps.event.addListener(t, i, e[a])), o;
  }, []);
  return r;
}
function MAe(e) {
  google.maps.event.removeListener(e);
}
function Ln() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  e.forEach(MAe);
}
function bn(e) {
  var {
    updaterMap: t,
    eventMap: n,
    prevProps: r,
    nextProps: o,
    instance: i
  } = e, a = SAe(o, i, n);
  return PAe(t, r, o, i), a;
}
function DAe(e) {
  var {
    children: t,
    options: n,
    id: r,
    mapContainerStyle: o,
    mapContainerClassName: i,
    center: a,
    // clickableIcons,
    // extraMapTypes,
    // heading,
    // mapTypeId,
    onClick: s,
    onDblClick: l,
    onDrag: u,
    onDragEnd: c,
    onDragStart: p,
    onMouseMove: d,
    onMouseOut: g,
    onMouseOver: f,
    onMouseDown: m,
    onMouseUp: b,
    onRightClick: E,
    // onMapTypeIdChanged,
    // onTilesLoaded,
    // onBoundsChanged,
    onCenterChanged: w,
    // onHeadingChanged,
    // onIdle,
    // onProjectionChanged,
    // onResize,
    // onTiltChanged,
    // onZoomChanged,
    onLoad: M,
    onUnmount: x
  } = e, [v, C] = k(null), P = dt(null), [F, L] = k(null), [B, N] = k(null), [$, V] = k(null), [H, Z] = k(null), [K, Y] = k(null), [Q, J] = k(null), [_, D] = k(null), [z, S] = k(null), [W, O] = k(null), [j, U] = k(null), [T, q] = k(null), [A, X] = k(null);
  return h(() => {
    n && v !== null && v.setOptions(n);
  }, [v, n]), h(() => {
    v !== null && typeof a < "u" && v.setCenter(a);
  }, [v, a]), h(() => {
    v && l && (B !== null && google.maps.event.removeListener(B), N(google.maps.event.addListener(v, "dblclick", l)));
  }, [l]), h(() => {
    v && c && ($ !== null && google.maps.event.removeListener($), V(google.maps.event.addListener(v, "dragend", c)));
  }, [c]), h(() => {
    v && p && (H !== null && google.maps.event.removeListener(H), Z(google.maps.event.addListener(v, "dragstart", p)));
  }, [p]), h(() => {
    v && m && (K !== null && google.maps.event.removeListener(K), Y(google.maps.event.addListener(v, "mousedown", m)));
  }, [m]), h(() => {
    v && d && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(v, "mousemove", d)));
  }, [d]), h(() => {
    v && g && (_ !== null && google.maps.event.removeListener(_), D(google.maps.event.addListener(v, "mouseout", g)));
  }, [g]), h(() => {
    v && f && (z !== null && google.maps.event.removeListener(z), S(google.maps.event.addListener(v, "mouseover", f)));
  }, [f]), h(() => {
    v && b && (W !== null && google.maps.event.removeListener(W), O(google.maps.event.addListener(v, "mouseup", b)));
  }, [b]), h(() => {
    v && E && (j !== null && google.maps.event.removeListener(j), U(google.maps.event.addListener(v, "rightclick", E)));
  }, [E]), h(() => {
    v && s && (T !== null && google.maps.event.removeListener(T), q(google.maps.event.addListener(v, "click", s)));
  }, [s]), h(() => {
    v && u && (A !== null && google.maps.event.removeListener(A), X(google.maps.event.addListener(v, "drag", u)));
  }, [u]), h(() => {
    v && w && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(v, "center_changed", w)));
  }, [s]), h(() => {
    var I = P.current === null ? null : new google.maps.Map(P.current, n);
    return C(I), I !== null && M && M(I), () => {
      I !== null && x && x(I);
    };
  }, []), ei.jsx("div", {
    id: r,
    ref: P,
    style: o,
    className: i,
    children: ei.jsx(Nt.Provider, {
      value: v,
      children: v !== null ? t : null
    })
  });
}
me(DAe);
function sW(e, t, n, r, o, i, a) {
  try {
    var s = e[i](a), l = s.value;
  } catch (u) {
    return void n(u);
  }
  s.done ? t(l) : Promise.resolve(l).then(r, o);
}
function ate(e) {
  return function() {
    var t = this, n = arguments;
    return new Promise(function(r, o) {
      var i = e.apply(t, n);
      function a(l) {
        sW(i, r, o, a, s, "next", l);
      }
      function s(l) {
        sW(i, r, o, a, s, "throw", l);
      }
      a(void 0);
    });
  };
}
function lte(e) {
  var {
    googleMapsApiKey: t,
    googleMapsClientId: n,
    version: r = "weekly",
    language: o,
    region: i,
    libraries: a,
    channel: s,
    mapIds: l,
    authReferrerPolicy: u
  } = e, c = [];
  return Wo(t && n || !(t && n), "You need to specify either googleMapsApiKey or googleMapsClientId for @react-google-maps/api load script to work. You cannot use both at the same time."), t ? c.push("key=".concat(t)) : n && c.push("client=".concat(n)), r && c.push("v=".concat(r)), o && c.push("language=".concat(o)), i && c.push("region=".concat(i)), a && a.length && c.push("libraries=".concat(a.sort().join(","))), s && c.push("channel=".concat(s)), l && l.length && c.push("map_ids=".concat(l.join(","))), u && c.push("auth_referrer_policy=".concat(u)), c.push("loading=async"), c.push("callback=initMap"), "https://maps.googleapis.com/maps/api/js?".concat(c.join("&"));
}
var gc = typeof document < "u";
function ute(e) {
  var {
    url: t,
    id: n,
    nonce: r
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } = e;
  return gc ? new Promise(function(o, i) {
    var a = document.getElementById(n), s = window;
    if (a) {
      var l = a.getAttribute("data-state");
      if (a.src === t && l !== "error") {
        if (l === "ready")
          return o(n);
        var u = s.initMap, c = a.onerror;
        s.initMap = function() {
          u && u(), o(n);
        }, a.onerror = function(d) {
          c && c(d), i(d);
        };
        return;
      } else
        a.remove();
    }
    var p = document.createElement("script");
    p.type = "text/javascript", p.src = t, p.id = n, p.async = !0, p.nonce = r || "", p.onerror = function(d) {
      p.setAttribute("data-state", "error"), i(d);
    }, s.initMap = function() {
      p.setAttribute("data-state", "ready"), o(n);
    }, document.head.appendChild(p);
  }).catch((o) => {
    throw console.error("injectScript error: ", o), o;
  }) : Promise.reject(new Error("document is undefined"));
}
function aW(e) {
  var t = e.href;
  return t && (t.indexOf("https://fonts.googleapis.com/css?family=Roboto") === 0 || t.indexOf("https://fonts.googleapis.com/css?family=Google+Sans+Text") === 0) ? !0 : (
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.styleSheet.cssText = "", !0) : (
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.innerHTML = "", !0) : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.innerHTML
      )
    )
  );
}
function cte() {
  var e = document.getElementsByTagName("head")[0];
  if (e) {
    var t = e.insertBefore.bind(e);
    e.insertBefore = function(r, o) {
      return aW(r) || Reflect.apply(t, e, [r, o]), r;
    };
    var n = e.appendChild.bind(e);
    e.appendChild = function(r) {
      return aW(r) || Reflect.apply(n, e, [r]), r;
    };
  }
}
var xd = !1;
function pte() {
  return ei.jsx("div", {
    children: "Loading..."
  });
}
var Z_ = {
  id: "script-loader",
  version: "weekly"
};
class TAe extends pe {
  constructor() {
    super(...arguments), Pe(this, "check", null), Pe(this, "state", {
      loaded: !1
    }), Pe(this, "cleanupCallback", () => {
      delete window.google.maps, this.injectScript();
    }), Pe(this, "isCleaningUp", /* @__PURE__ */ ate(function* () {
      function t(n) {
        if (!xd)
          n();
        else if (gc)
          var r = window.setInterval(function() {
            xd || (window.clearInterval(r), n());
          }, 1);
      }
      return new Promise(t);
    })), Pe(this, "cleanup", () => {
      xd = !0;
      var t = document.getElementById(this.props.id);
      t && t.parentNode && t.parentNode.removeChild(t), Array.prototype.slice.call(document.getElementsByTagName("script")).filter(function(n) {
        return typeof n.src == "string" && n.src.includes("maps.googleapis");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("link")).filter(function(n) {
        return n.href === "https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Google+Sans";
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("style")).filter(function(n) {
        return n.innerText !== void 0 && n.innerText.length > 0 && n.innerText.includes(".gm-");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      });
    }), Pe(this, "injectScript", () => {
      this.props.preventGoogleFontsLoading && cte(), Wo(!!this.props.id, 'LoadScript requires "id" prop to be a string: %s', this.props.id);
      var t = {
        id: this.props.id,
        nonce: this.props.nonce,
        url: lte(this.props)
      };
      ute(t).then(() => {
        this.props.onLoad && this.props.onLoad(), this.setState(function() {
          return {
            loaded: !0
          };
        });
      }).catch((n) => {
        this.props.onError && this.props.onError(n), console.error(`
          There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(this.props.googleMapsApiKey || "-", ") or Client ID (").concat(this.props.googleMapsClientId || "-", `) to <LoadScript />
          Otherwise it is a Network issue.
        `));
      });
    }), Pe(this, "getRef", (t) => {
      this.check = t;
    });
  }
  componentDidMount() {
    if (gc) {
      if (window.google && window.google.maps && !xd) {
        console.error("google api is already presented");
        return;
      }
      this.isCleaningUp().then(this.injectScript).catch(function(t) {
        console.error("Error at injecting script after cleaning up: ", t);
      });
    }
  }
  componentDidUpdate(t) {
    this.props.libraries !== t.libraries && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), gc && t.language !== this.props.language && (this.cleanup(), this.setState(function() {
      return {
        loaded: !1
      };
    }, this.cleanupCallback));
  }
  componentWillUnmount() {
    if (gc) {
      this.cleanup();
      var t = () => {
        this.check || (delete window.google, xd = !1);
      };
      window.setTimeout(t, 1), this.props.onUnmount && this.props.onUnmount();
    }
  }
  render() {
    return ei.jsxs(ei.Fragment, {
      children: [ei.jsx("div", {
        ref: this.getRef
      }), this.state.loaded ? this.props.children : this.props.loadingElement || ei.jsx(pte, {})]
    });
  }
}
Pe(TAe, "defaultProps", Z_);
function jAe(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.includes(r)) continue;
    n[r] = e[r];
  }
  return n;
}
function nT(e, t) {
  if (e == null) return {};
  var n, r, o = jAe(e, t);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (r = 0; r < i.length; r++) n = i[r], t.includes(n) || {}.propertyIsEnumerable.call(e, n) && (o[n] = e[n]);
  }
  return o;
}
var lW;
function AAe(e) {
  var {
    id: t = Z_.id,
    version: n = Z_.version,
    nonce: r,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    preventGoogleFontsLoading: u,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  } = e, g = dt(!1), [f, m] = k(!1), [b, E] = k(void 0);
  h(function() {
    return g.current = !0, () => {
      g.current = !1;
    };
  }, []), h(function() {
    gc && u && cte();
  }, [u]), h(function() {
    f && Wo(!!window.google, "useLoadScript was marked as loaded, but window.google is not present. Something went wrong.");
  }, [f]);
  var w = lte({
    version: n,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  });
  h(function() {
    if (!gc)
      return;
    function x() {
      g.current && (m(!0), lW = w);
    }
    if (window.google && window.google.maps && lW === w) {
      x();
      return;
    }
    ute({
      id: t,
      url: w,
      nonce: r
    }).then(x).catch(function(v) {
      g.current && E(v), console.warn(`
        There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(o || "-", ") or Client ID (").concat(i || "-", `)
        Otherwise it is a Network issue.
      `)), console.error(v);
    });
  }, [t, w, r]);
  var M = dt(void 0);
  return h(function() {
    M.current && l !== M.current && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), M.current = l;
  }, [l]), {
    isLoaded: f,
    loadError: b,
    url: w
  };
}
var RAe = ["loadingElement", "onLoad", "onError", "onUnmount", "children"], IAe = ei.jsx(pte, {});
function NAe(e) {
  var {
    loadingElement: t,
    onLoad: n,
    onError: r,
    onUnmount: o,
    children: i
  } = e, a = nT(e, RAe), {
    isLoaded: s,
    loadError: l
  } = AAe(a);
  return h(function() {
    s && typeof n == "function" && n();
  }, [s, n]), h(function() {
    l && typeof r == "function" && r(l);
  }, [l, r]), h(function() {
    return () => {
      o && o();
    };
  }, [o]), s ? i : t || IAe;
}
me(NAe);
var uW;
(function(e) {
  e[e.INITIALIZED = 0] = "INITIALIZED", e[e.LOADING = 1] = "LOADING", e[e.SUCCESS = 2] = "SUCCESS", e[e.FAILURE = 3] = "FAILURE";
})(uW || (uW = {}));
function cW(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Yb(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? cW(Object(n), !0).forEach(function(r) {
      Pe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : cW(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var pW = {}, dW = {
  options(e, t) {
    e.setOptions(t);
  }
};
function BAe(e) {
  var {
    options: t,
    onLoad: n,
    onUnmount: r
  } = e, o = ge(Nt), [i, a] = k(null);
  return h(() => {
    i !== null && i.setMap(o);
  }, [o]), h(() => {
    t && i !== null && i.setOptions(t);
  }, [i, t]), h(() => {
    var s = new google.maps.TrafficLayer(Yb(Yb({}, t), {}, {
      map: o
    }));
    return a(s), n && n(s), () => {
      i !== null && (r && r(i), i.setMap(null));
    };
  }, []), null;
}
me(BAe);
class FAe extends pe {
  constructor() {
    super(...arguments), Pe(this, "state", {
      trafficLayer: null
    }), Pe(this, "setTrafficLayerCallback", () => {
      this.state.trafficLayer !== null && this.props.onLoad && this.props.onLoad(this.state.trafficLayer);
    }), Pe(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = new google.maps.TrafficLayer(Yb(Yb({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = bn({
      updaterMap: dW,
      eventMap: pW,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        trafficLayer: t
      };
    }, this.setTrafficLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.trafficLayer !== null && (Ln(this.registeredEvents), this.registeredEvents = bn({
      updaterMap: dW,
      eventMap: pW,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.trafficLayer
    }));
  }
  componentWillUnmount() {
    this.state.trafficLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.trafficLayer), Ln(this.registeredEvents), this.state.trafficLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Pe(FAe, "contextType", Nt);
function zAe(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = ge(Nt), [o, i] = k(null);
  return h(() => {
    o !== null && o.setMap(r);
  }, [r]), h(() => {
    var a = new google.maps.BicyclingLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      a !== null && (n && n(a), a.setMap(null));
    };
  }, []), null;
}
me(zAe);
class UAe extends pe {
  constructor() {
    super(...arguments), Pe(this, "state", {
      bicyclingLayer: null
    }), Pe(this, "setBicyclingLayerCallback", () => {
      this.state.bicyclingLayer !== null && (this.state.bicyclingLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.bicyclingLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.BicyclingLayer();
    this.setState(() => ({
      bicyclingLayer: t
    }), this.setBicyclingLayerCallback);
  }
  componentWillUnmount() {
    this.state.bicyclingLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.bicyclingLayer), this.state.bicyclingLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Pe(UAe, "contextType", Nt);
function HAe(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = ge(Nt), [o, i] = k(null);
  return h(() => {
    o !== null && o.setMap(r);
  }, [r]), h(() => {
    var a = new google.maps.TransitLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      o !== null && (n && n(o), o.setMap(null));
    };
  }, []), null;
}
me(HAe);
class WAe extends pe {
  constructor() {
    super(...arguments), Pe(this, "state", {
      transitLayer: null
    }), Pe(this, "setTransitLayerCallback", () => {
      this.state.transitLayer !== null && (this.state.transitLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.transitLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.TransitLayer();
    this.setState(function() {
      return {
        transitLayer: t
      };
    }, this.setTransitLayerCallback);
  }
  componentWillUnmount() {
    this.state.transitLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.transitLayer), this.state.transitLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Pe(WAe, "contextType", Nt);
function fW(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Jb(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? fW(Object(n), !0).forEach(function(r) {
      Pe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : fW(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var hW = {
  onCircleComplete: "circlecomplete",
  onMarkerComplete: "markercomplete",
  onOverlayComplete: "overlaycomplete",
  onPolygonComplete: "polygoncomplete",
  onPolylineComplete: "polylinecomplete",
  onRectangleComplete: "rectanglecomplete"
}, gW = {
  drawingMode(e, t) {
    e.setDrawingMode(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function $Ae(e) {
  var {
    options: t,
    drawingMode: n,
    onCircleComplete: r,
    onMarkerComplete: o,
    onOverlayComplete: i,
    onPolygonComplete: a,
    onPolylineComplete: s,
    onRectangleComplete: l,
    onLoad: u,
    onUnmount: c
  } = e, p = ge(Nt), [d, g] = k(null), [f, m] = k(null), [b, E] = k(null), [w, M] = k(null), [x, v] = k(null), [C, P] = k(null), [F, L] = k(null);
  return h(() => {
    d !== null && d.setMap(p);
  }, [p]), h(() => {
    t && d !== null && d.setOptions(t);
  }, [d, t]), h(() => {
    d !== null && d.setDrawingMode(n ?? null);
  }, [d, n]), h(() => {
    d && r && (f !== null && google.maps.event.removeListener(f), m(google.maps.event.addListener(d, "circlecomplete", r)));
  }, [d, r]), h(() => {
    d && o && (b !== null && google.maps.event.removeListener(b), E(google.maps.event.addListener(d, "markercomplete", o)));
  }, [d, o]), h(() => {
    d && i && (w !== null && google.maps.event.removeListener(w), M(google.maps.event.addListener(d, "overlaycomplete", i)));
  }, [d, i]), h(() => {
    d && a && (x !== null && google.maps.event.removeListener(x), v(google.maps.event.addListener(d, "polygoncomplete", a)));
  }, [d, a]), h(() => {
    d && s && (C !== null && google.maps.event.removeListener(C), P(google.maps.event.addListener(d, "polylinecomplete", s)));
  }, [d, s]), h(() => {
    d && l && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(d, "rectanglecomplete", l)));
  }, [d, l]), h(() => {
    Wo(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
    var B = new google.maps.drawing.DrawingManager(Jb(Jb({}, t), {}, {
      map: p
    }));
    return n && B.setDrawingMode(n), r && m(google.maps.event.addListener(B, "circlecomplete", r)), o && E(google.maps.event.addListener(B, "markercomplete", o)), i && M(google.maps.event.addListener(B, "overlaycomplete", i)), a && v(google.maps.event.addListener(B, "polygoncomplete", a)), s && P(google.maps.event.addListener(B, "polylinecomplete", s)), l && L(google.maps.event.addListener(B, "rectanglecomplete", l)), g(B), u && u(B), () => {
      d !== null && (f && google.maps.event.removeListener(f), b && google.maps.event.removeListener(b), w && google.maps.event.removeListener(w), x && google.maps.event.removeListener(x), C && google.maps.event.removeListener(C), F && google.maps.event.removeListener(F), c && c(d), d.setMap(null));
    };
  }, []), null;
}
me($Ae);
class VAe extends pe {
  constructor(t) {
    super(t), Pe(this, "registeredEvents", []), Pe(this, "state", {
      drawingManager: null
    }), Pe(this, "setDrawingManagerCallback", () => {
      this.state.drawingManager !== null && this.props.onLoad && this.props.onLoad(this.state.drawingManager);
    }), Wo(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
  }
  componentDidMount() {
    var t = new google.maps.drawing.DrawingManager(Jb(Jb({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = bn({
      updaterMap: gW,
      eventMap: hW,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        drawingManager: t
      };
    }, this.setDrawingManagerCallback);
  }
  componentDidUpdate(t) {
    this.state.drawingManager !== null && (Ln(this.registeredEvents), this.registeredEvents = bn({
      updaterMap: gW,
      eventMap: hW,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.drawingManager
    }));
  }
  componentWillUnmount() {
    this.state.drawingManager !== null && (this.props.onUnmount && this.props.onUnmount(this.state.drawingManager), Ln(this.registeredEvents), this.state.drawingManager.setMap(null));
  }
  render() {
    return null;
  }
}
Pe(VAe, "contextType", Nt);
function mW(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function dp(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? mW(Object(n), !0).forEach(function(r) {
      Pe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : mW(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var vW = {
  onAnimationChanged: "animation_changed",
  onClick: "click",
  onClickableChanged: "clickable_changed",
  onCursorChanged: "cursor_changed",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDraggableChanged: "draggable_changed",
  onDragStart: "dragstart",
  onFlatChanged: "flat_changed",
  onIconChanged: "icon_changed",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onPositionChanged: "position_changed",
  onRightClick: "rightclick",
  onShapeChanged: "shape_changed",
  onTitleChanged: "title_changed",
  onVisibleChanged: "visible_changed",
  onZindexChanged: "zindex_changed"
}, yW = {
  animation(e, t) {
    e.setAnimation(t);
  },
  clickable(e, t) {
    e.setClickable(t);
  },
  cursor(e, t) {
    e.setCursor(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  icon(e, t) {
    e.setIcon(t);
  },
  label(e, t) {
    e.setLabel(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  opacity(e, t) {
    e.setOpacity(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  shape(e, t) {
    e.setShape(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, Qb = {};
function ZAe(e) {
  var {
    position: t,
    options: n,
    clusterer: r,
    noClustererRedraw: o,
    children: i,
    draggable: a,
    visible: s,
    animation: l,
    clickable: u,
    cursor: c,
    icon: p,
    label: d,
    opacity: g,
    shape: f,
    title: m,
    zIndex: b,
    onClick: E,
    onDblClick: w,
    onDrag: M,
    onDragEnd: x,
    onDragStart: v,
    onMouseOut: C,
    onMouseOver: P,
    onMouseUp: F,
    onMouseDown: L,
    onRightClick: B,
    onClickableChanged: N,
    onCursorChanged: $,
    onAnimationChanged: V,
    onDraggableChanged: H,
    onFlatChanged: Z,
    onIconChanged: K,
    onPositionChanged: Y,
    onShapeChanged: Q,
    onTitleChanged: J,
    onVisibleChanged: _,
    onZindexChanged: D,
    onLoad: z,
    onUnmount: S
  } = e, W = ge(Nt), [O, j] = k(null), [U, T] = k(null), [q, A] = k(null), [X, I] = k(null), [le, he] = k(null), [oe, Ae] = k(null), [Ue, He] = k(null), [Re, nt] = k(null), [Ve, we] = k(null), [et, lt] = k(null), [ye, ke] = k(null), [Qe, Fe] = k(null), [Ie, ot] = k(null), [Ee, wt] = k(null), [it, st] = k(null), [ut, Ct] = k(null), [ct, pt] = k(null), [rt, We] = k(null), [Ot, xt] = k(null), [gt, Ht] = k(null), [mt, Wt] = k(null), [vt, kt] = k(null);
  h(() => {
    O !== null && O.setMap(W);
  }, [W]), h(() => {
    typeof n < "u" && O !== null && O.setOptions(n);
  }, [O, n]), h(() => {
    typeof a < "u" && O !== null && O.setDraggable(a);
  }, [O, a]), h(() => {
    t && O !== null && O.setPosition(t);
  }, [O, t]), h(() => {
    typeof s < "u" && O !== null && O.setVisible(s);
  }, [O, s]), h(() => {
    O == null || O.setAnimation(l);
  }, [O, l]), h(() => {
    O && u !== void 0 && O.setClickable(u);
  }, [O, u]), h(() => {
    O && c !== void 0 && O.setCursor(c);
  }, [O, c]), h(() => {
    O && p !== void 0 && O.setIcon(p);
  }, [O, p]), h(() => {
    O && d !== void 0 && O.setLabel(d);
  }, [O, d]), h(() => {
    O && g !== void 0 && O.setOpacity(g);
  }, [O, g]), h(() => {
    O && f !== void 0 && O.setShape(f);
  }, [O, f]), h(() => {
    O && m !== void 0 && O.setTitle(m);
  }, [O, m]), h(() => {
    O && b !== void 0 && O.setZIndex(b);
  }, [O, b]), h(() => {
    O && w && (U !== null && google.maps.event.removeListener(U), T(google.maps.event.addListener(O, "dblclick", w)));
  }, [w]), h(() => {
    O && x && (q !== null && google.maps.event.removeListener(q), A(google.maps.event.addListener(O, "dragend", x)));
  }, [x]), h(() => {
    O && v && (X !== null && google.maps.event.removeListener(X), I(google.maps.event.addListener(O, "dragstart", v)));
  }, [v]), h(() => {
    O && L && (le !== null && google.maps.event.removeListener(le), he(google.maps.event.addListener(O, "mousedown", L)));
  }, [L]), h(() => {
    O && C && (oe !== null && google.maps.event.removeListener(oe), Ae(google.maps.event.addListener(O, "mouseout", C)));
  }, [C]), h(() => {
    O && P && (Ue !== null && google.maps.event.removeListener(Ue), He(google.maps.event.addListener(O, "mouseover", P)));
  }, [P]), h(() => {
    O && F && (Re !== null && google.maps.event.removeListener(Re), nt(google.maps.event.addListener(O, "mouseup", F)));
  }, [F]), h(() => {
    O && B && (Ve !== null && google.maps.event.removeListener(Ve), we(google.maps.event.addListener(O, "rightclick", B)));
  }, [B]), h(() => {
    O && E && (et !== null && google.maps.event.removeListener(et), lt(google.maps.event.addListener(O, "click", E)));
  }, [E]), h(() => {
    O && M && (ye !== null && google.maps.event.removeListener(ye), ke(google.maps.event.addListener(O, "drag", M)));
  }, [M]), h(() => {
    O && N && (Qe !== null && google.maps.event.removeListener(Qe), Fe(google.maps.event.addListener(O, "clickable_changed", N)));
  }, [N]), h(() => {
    O && $ && (Ie !== null && google.maps.event.removeListener(Ie), ot(google.maps.event.addListener(O, "cursor_changed", $)));
  }, [$]), h(() => {
    O && V && (Ee !== null && google.maps.event.removeListener(Ee), wt(google.maps.event.addListener(O, "animation_changed", V)));
  }, [V]), h(() => {
    O && H && (it !== null && google.maps.event.removeListener(it), st(google.maps.event.addListener(O, "draggable_changed", H)));
  }, [H]), h(() => {
    O && Z && (ut !== null && google.maps.event.removeListener(ut), Ct(google.maps.event.addListener(O, "flat_changed", Z)));
  }, [Z]), h(() => {
    O && K && (ct !== null && google.maps.event.removeListener(ct), pt(google.maps.event.addListener(O, "icon_changed", K)));
  }, [K]), h(() => {
    O && Y && (rt !== null && google.maps.event.removeListener(rt), We(google.maps.event.addListener(O, "position_changed", Y)));
  }, [Y]), h(() => {
    O && Q && (Ot !== null && google.maps.event.removeListener(Ot), xt(google.maps.event.addListener(O, "shape_changed", Q)));
  }, [Q]), h(() => {
    O && J && (gt !== null && google.maps.event.removeListener(gt), Ht(google.maps.event.addListener(O, "title_changed", J)));
  }, [J]), h(() => {
    O && _ && (mt !== null && google.maps.event.removeListener(mt), Wt(google.maps.event.addListener(O, "visible_changed", _)));
  }, [_]), h(() => {
    O && D && (vt !== null && google.maps.event.removeListener(vt), kt(google.maps.event.addListener(O, "zindex_changed", D)));
  }, [D]), h(() => {
    var yt = dp(dp(dp({}, n || Qb), r ? Qb : {
      map: W
    }), {}, {
      position: t
    }), re = new google.maps.Marker(yt);
    return r ? r.addMarker(re, !!o) : re.setMap(W), t && re.setPosition(t), typeof s < "u" && re.setVisible(s), typeof a < "u" && re.setDraggable(a), typeof u < "u" && re.setClickable(u), typeof c == "string" && re.setCursor(c), p && re.setIcon(p), typeof d < "u" && re.setLabel(d), typeof g < "u" && re.setOpacity(g), f && re.setShape(f), typeof m == "string" && re.setTitle(m), typeof b == "number" && re.setZIndex(b), w && T(google.maps.event.addListener(re, "dblclick", w)), x && A(google.maps.event.addListener(re, "dragend", x)), v && I(google.maps.event.addListener(re, "dragstart", v)), L && he(google.maps.event.addListener(re, "mousedown", L)), C && Ae(google.maps.event.addListener(re, "mouseout", C)), P && He(google.maps.event.addListener(re, "mouseover", P)), F && nt(google.maps.event.addListener(re, "mouseup", F)), B && we(google.maps.event.addListener(re, "rightclick", B)), E && lt(google.maps.event.addListener(re, "click", E)), M && ke(google.maps.event.addListener(re, "drag", M)), N && Fe(google.maps.event.addListener(re, "clickable_changed", N)), $ && ot(google.maps.event.addListener(re, "cursor_changed", $)), V && wt(google.maps.event.addListener(re, "animation_changed", V)), H && st(google.maps.event.addListener(re, "draggable_changed", H)), Z && Ct(google.maps.event.addListener(re, "flat_changed", Z)), K && pt(google.maps.event.addListener(re, "icon_changed", K)), Y && We(google.maps.event.addListener(re, "position_changed", Y)), Q && xt(google.maps.event.addListener(re, "shape_changed", Q)), J && Ht(google.maps.event.addListener(re, "title_changed", J)), _ && Wt(google.maps.event.addListener(re, "visible_changed", _)), D && kt(google.maps.event.addListener(re, "zindex_changed", D)), j(re), z && z(re), () => {
      U !== null && google.maps.event.removeListener(U), q !== null && google.maps.event.removeListener(q), X !== null && google.maps.event.removeListener(X), le !== null && google.maps.event.removeListener(le), oe !== null && google.maps.event.removeListener(oe), Ue !== null && google.maps.event.removeListener(Ue), Re !== null && google.maps.event.removeListener(Re), Ve !== null && google.maps.event.removeListener(Ve), et !== null && google.maps.event.removeListener(et), Qe !== null && google.maps.event.removeListener(Qe), Ie !== null && google.maps.event.removeListener(Ie), Ee !== null && google.maps.event.removeListener(Ee), it !== null && google.maps.event.removeListener(it), ut !== null && google.maps.event.removeListener(ut), ct !== null && google.maps.event.removeListener(ct), rt !== null && google.maps.event.removeListener(rt), gt !== null && google.maps.event.removeListener(gt), mt !== null && google.maps.event.removeListener(mt), vt !== null && google.maps.event.removeListener(vt), S && S(re), r ? r.removeMarker(re, !!o) : re && re.setMap(null);
    };
  }, []);
  var Un = ln(() => i ? at.map(i, (yt) => {
    if (!yi(yt))
      return yt;
    var re = yt;
    return bi(re, {
      anchor: O
    });
  }) : null, [i, O]);
  return ei.jsx(ei.Fragment, {
    children: Un
  }) || null;
}
me(ZAe);
class qAe extends pe {
  constructor() {
    super(...arguments), Pe(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this;
    return ate(function* () {
      var n = dp(dp(dp({}, t.props.options || Qb), t.props.clusterer ? Qb : {
        map: t.context
      }), {}, {
        position: t.props.position
      });
      t.marker = new google.maps.Marker(n), t.props.clusterer ? t.props.clusterer.addMarker(t.marker, !!t.props.noClustererRedraw) : t.marker.setMap(t.context), t.registeredEvents = bn({
        updaterMap: yW,
        eventMap: vW,
        prevProps: {},
        nextProps: t.props,
        instance: t.marker
      }), t.props.onLoad && t.props.onLoad(t.marker);
    })();
  }
  componentDidUpdate(t) {
    this.marker && (Ln(this.registeredEvents), this.registeredEvents = bn({
      updaterMap: yW,
      eventMap: vW,
      prevProps: t,
      nextProps: this.props,
      instance: this.marker
    }));
  }
  componentWillUnmount() {
    this.marker && (this.props.onUnmount && this.props.onUnmount(this.marker), Ln(this.registeredEvents), this.props.clusterer ? this.props.clusterer.removeMarker(this.marker, !!this.props.noClustererRedraw) : this.marker && this.marker.setMap(null));
  }
  render() {
    var t = this.props.children ? at.map(this.props.children, (n) => {
      if (!yi(n))
        return n;
      var r = n;
      return bi(r, {
        anchor: this.marker
      });
    }) : null;
    return t || null;
  }
}
Pe(qAe, "contextType", Nt);
var GAe = (
  /** @class */
  function() {
    function e(t, n) {
      t.getClusterer().extend(e, google.maps.OverlayView), this.cluster = t, this.clusterClassName = this.cluster.getClusterer().getClusterClass(), this.className = this.clusterClassName, this.styles = n, this.center = void 0, this.div = null, this.sums = null, this.visible = !1, this.boundsChangedListener = null, this.url = "", this.height = 0, this.width = 0, this.anchorText = [0, 0], this.anchorIcon = [0, 0], this.textColor = "black", this.textSize = 11, this.textDecoration = "none", this.fontWeight = "bold", this.fontStyle = "normal", this.fontFamily = "Arial,sans-serif", this.backgroundPosition = "0 0", this.cMouseDownInCluster = null, this.cDraggingMapByCluster = null, this.timeOut = null, this.setMap(t.getMap()), this.onBoundsChanged = this.onBoundsChanged.bind(this), this.onMouseDown = this.onMouseDown.bind(this), this.onClick = this.onClick.bind(this), this.onMouseOver = this.onMouseOver.bind(this), this.onMouseOut = this.onMouseOut.bind(this), this.onAdd = this.onAdd.bind(this), this.onRemove = this.onRemove.bind(this), this.draw = this.draw.bind(this), this.hide = this.hide.bind(this), this.show = this.show.bind(this), this.useStyle = this.useStyle.bind(this), this.setCenter = this.setCenter.bind(this), this.getPosFromLatLng = this.getPosFromLatLng.bind(this);
    }
    return e.prototype.onBoundsChanged = function() {
      this.cDraggingMapByCluster = this.cMouseDownInCluster;
    }, e.prototype.onMouseDown = function() {
      this.cMouseDownInCluster = !0, this.cDraggingMapByCluster = !1;
    }, e.prototype.onClick = function(t) {
      if (this.cMouseDownInCluster = !1, !this.cDraggingMapByCluster) {
        var n = this.cluster.getClusterer();
        if (google.maps.event.trigger(n, "click", this.cluster), google.maps.event.trigger(n, "clusterclick", this.cluster), n.getZoomOnClick()) {
          var r = n.getMaxZoom(), o = this.cluster.getBounds(), i = n.getMap();
          i !== null && "fitBounds" in i && i.fitBounds(o), this.timeOut = window.setTimeout(function() {
            var a = n.getMap();
            if (a !== null) {
              "fitBounds" in a && a.fitBounds(o);
              var s = a.getZoom() || 0;
              r !== null && s > r && a.setZoom(r + 1);
            }
          }, 100);
        }
        t.cancelBubble = !0, t.stopPropagation && t.stopPropagation();
      }
    }, e.prototype.onMouseOver = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseover", this.cluster);
    }, e.prototype.onMouseOut = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseout", this.cluster);
    }, e.prototype.onAdd = function() {
      var t;
      this.div = document.createElement("div"), this.div.className = this.className, this.visible && this.show(), (t = this.getPanes()) === null || t === void 0 || t.overlayMouseTarget.appendChild(this.div);
      var n = this.getMap();
      n !== null && (this.boundsChangedListener = google.maps.event.addListener(n, "bounds_changed", this.onBoundsChanged), this.div.addEventListener("mousedown", this.onMouseDown), this.div.addEventListener("click", this.onClick), this.div.addEventListener("mouseover", this.onMouseOver), this.div.addEventListener("mouseout", this.onMouseOut));
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.hide(), this.boundsChangedListener !== null && google.maps.event.removeListener(this.boundsChangedListener), this.div.removeEventListener("mousedown", this.onMouseDown), this.div.removeEventListener("click", this.onClick), this.div.removeEventListener("mouseover", this.onMouseOver), this.div.removeEventListener("mouseout", this.onMouseOut), this.div.parentNode.removeChild(this.div), this.timeOut !== null && (window.clearTimeout(this.timeOut), this.timeOut = null), this.div = null);
    }, e.prototype.draw = function() {
      if (this.visible && this.div !== null && this.center) {
        var t = this.getPosFromLatLng(this.center);
        this.div.style.top = t !== null ? "".concat(t.y, "px") : "0", this.div.style.left = t !== null ? "".concat(t.x, "px") : "0";
      }
    }, e.prototype.hide = function() {
      this.div && (this.div.style.display = "none"), this.visible = !1;
    }, e.prototype.show = function() {
      var t, n, r, o, i, a;
      if (this.div && this.center) {
        var s = this.sums === null || typeof this.sums.title > "u" || this.sums.title === "" ? this.cluster.getClusterer().getTitle() : this.sums.title, l = this.backgroundPosition.split(" "), u = parseInt(((t = l[0]) === null || t === void 0 ? void 0 : t.replace(/^\s+|\s+$/g, "")) || "0", 10), c = parseInt(((n = l[1]) === null || n === void 0 ? void 0 : n.replace(/^\s+|\s+$/g, "")) || "0", 10), p = this.getPosFromLatLng(this.center);
        this.div.className = this.className, this.div.setAttribute("style", "cursor: pointer; position: absolute; top: ".concat(p !== null ? "".concat(p.y, "px") : "0", "; left: ").concat(p !== null ? "".concat(p.x, "px") : "0", "; width: ").concat(this.width, "px; height: ").concat(this.height, "px; "));
        var d = document.createElement("img");
        d.alt = s, d.src = this.url, d.width = this.width, d.height = this.height, d.setAttribute("style", "position: absolute; top: ".concat(c, "px; left: ").concat(u, "px")), this.cluster.getClusterer().enableRetinaIcons || (d.style.clip = "rect(-".concat(c, "px, -").concat(u + this.width, "px, -").concat(c + this.height, ", -").concat(u, ")"));
        var g = document.createElement("div");
        g.setAttribute("style", "position: absolute; top: ".concat(this.anchorText[0], "px; left: ").concat(this.anchorText[1], "px; color: ").concat(this.textColor, "; font-size: ").concat(this.textSize, "px; font-family: ").concat(this.fontFamily, "; font-weight: ").concat(this.fontWeight, "; fontStyle: ").concat(this.fontStyle, "; text-decoration: ").concat(this.textDecoration, "; text-align: center; width: ").concat(this.width, "px; line-height: ").concat(this.height, "px")), !((r = this.sums) === null || r === void 0) && r.text && (g.innerText = "".concat((o = this.sums) === null || o === void 0 ? void 0 : o.text)), !((i = this.sums) === null || i === void 0) && i.html && (g.innerHTML = "".concat((a = this.sums) === null || a === void 0 ? void 0 : a.html)), this.div.innerHTML = "", this.div.appendChild(d), this.div.appendChild(g), this.div.title = s, this.div.style.display = "";
      }
      this.visible = !0;
    }, e.prototype.useStyle = function(t) {
      this.sums = t;
      var n = this.cluster.getClusterer().getStyles(), r = n[Math.min(n.length - 1, Math.max(0, t.index - 1))];
      r && (this.url = r.url, this.height = r.height, this.width = r.width, r.className && (this.className = "".concat(this.clusterClassName, " ").concat(r.className)), this.anchorText = r.anchorText || [0, 0], this.anchorIcon = r.anchorIcon || [this.height / 2, this.width / 2], this.textColor = r.textColor || "black", this.textSize = r.textSize || 11, this.textDecoration = r.textDecoration || "none", this.fontWeight = r.fontWeight || "bold", this.fontStyle = r.fontStyle || "normal", this.fontFamily = r.fontFamily || "Arial,sans-serif", this.backgroundPosition = r.backgroundPosition || "0 0");
    }, e.prototype.setCenter = function(t) {
      this.center = t;
    }, e.prototype.getPosFromLatLng = function(t) {
      var n = this.getProjection().fromLatLngToDivPixel(t);
      return n !== null && (n.x -= this.anchorIcon[1], n.y -= this.anchorIcon[0]), n;
    }, e;
  }()
), KAe = (
  /** @class */
  function() {
    function e(t) {
      this.markerClusterer = t, this.map = this.markerClusterer.getMap(), this.gridSize = this.markerClusterer.getGridSize(), this.minClusterSize = this.markerClusterer.getMinimumClusterSize(), this.averageCenter = this.markerClusterer.getAverageCenter(), this.markers = [], this.center = void 0, this.bounds = null, this.clusterIcon = new GAe(this, this.markerClusterer.getStyles()), this.getSize = this.getSize.bind(this), this.getMarkers = this.getMarkers.bind(this), this.getCenter = this.getCenter.bind(this), this.getMap = this.getMap.bind(this), this.getClusterer = this.getClusterer.bind(this), this.getBounds = this.getBounds.bind(this), this.remove = this.remove.bind(this), this.addMarker = this.addMarker.bind(this), this.isMarkerInClusterBounds = this.isMarkerInClusterBounds.bind(this), this.calculateBounds = this.calculateBounds.bind(this), this.updateIcon = this.updateIcon.bind(this), this.isMarkerAlreadyAdded = this.isMarkerAlreadyAdded.bind(this);
    }
    return e.prototype.getSize = function() {
      return this.markers.length;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getCenter = function() {
      return this.center;
    }, e.prototype.getMap = function() {
      return this.map;
    }, e.prototype.getClusterer = function() {
      return this.markerClusterer;
    }, e.prototype.getBounds = function() {
      for (var t = new google.maps.LatLngBounds(this.center, this.center), n = this.getMarkers(), r = 0, o = n; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && t.extend(a);
      }
      return t;
    }, e.prototype.remove = function() {
      this.clusterIcon.setMap(null), this.markers = [], delete this.markers;
    }, e.prototype.addMarker = function(t) {
      var n;
      if (this.isMarkerAlreadyAdded(t))
        return !1;
      if (this.center) {
        if (this.averageCenter) {
          var r = t.getPosition();
          if (r) {
            var o = this.markers.length + 1;
            this.center = new google.maps.LatLng((this.center.lat() * (o - 1) + r.lat()) / o, (this.center.lng() * (o - 1) + r.lng()) / o), this.calculateBounds();
          }
        }
      } else {
        var r = t.getPosition();
        r && (this.center = r, this.calculateBounds());
      }
      t.isAdded = !0, this.markers.push(t);
      var i = this.markers.length, a = this.markerClusterer.getMaxZoom(), s = (n = this.map) === null || n === void 0 ? void 0 : n.getZoom();
      if (a !== null && typeof s < "u" && s > a)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i < this.minClusterSize)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i === this.minClusterSize)
        for (var l = 0, u = this.markers; l < u.length; l++) {
          var c = u[l];
          c.setMap(null);
        }
      else
        t.setMap(null);
      return !0;
    }, e.prototype.isMarkerInClusterBounds = function(t) {
      if (this.bounds !== null) {
        var n = t.getPosition();
        if (n)
          return this.bounds.contains(n);
      }
      return !1;
    }, e.prototype.calculateBounds = function() {
      this.bounds = this.markerClusterer.getExtendedBounds(new google.maps.LatLngBounds(this.center, this.center));
    }, e.prototype.updateIcon = function() {
      var t, n = this.markers.length, r = this.markerClusterer.getMaxZoom(), o = (t = this.map) === null || t === void 0 ? void 0 : t.getZoom();
      if (r !== null && typeof o < "u" && o > r) {
        this.clusterIcon.hide();
        return;
      }
      if (n < this.minClusterSize) {
        this.clusterIcon.hide();
        return;
      }
      this.center && this.clusterIcon.setCenter(this.center), this.clusterIcon.useStyle(this.markerClusterer.getCalculator()(this.markers, this.markerClusterer.getStyles().length)), this.clusterIcon.show();
    }, e.prototype.isMarkerAlreadyAdded = function(t) {
      if (this.markers.includes)
        return this.markers.includes(t);
      for (var n = 0; n < this.markers.length; n++)
        if (t === this.markers[n])
          return !0;
      return !1;
    }, e;
  }()
);
function XAe(e, t) {
  var n = e.length, r = n.toString().length, o = Math.min(r, t);
  return {
    text: n.toString(),
    index: o,
    title: ""
  };
}
var YAe = 2e3, JAe = 500, QAe = "https://developers.google.com/maps/documentation/javascript/examples/markerclusterer/m", eRe = "png", tRe = [53, 56, 66, 78, 90], nRe = "cluster", dte = (
  /** @class */
  function() {
    function e(t, n, r) {
      n === void 0 && (n = []), r === void 0 && (r = {}), this.getMinimumClusterSize = this.getMinimumClusterSize.bind(this), this.setMinimumClusterSize = this.setMinimumClusterSize.bind(this), this.getEnableRetinaIcons = this.getEnableRetinaIcons.bind(this), this.setEnableRetinaIcons = this.setEnableRetinaIcons.bind(this), this.addToClosestCluster = this.addToClosestCluster.bind(this), this.getImageExtension = this.getImageExtension.bind(this), this.setImageExtension = this.setImageExtension.bind(this), this.getExtendedBounds = this.getExtendedBounds.bind(this), this.getAverageCenter = this.getAverageCenter.bind(this), this.setAverageCenter = this.setAverageCenter.bind(this), this.getTotalClusters = this.getTotalClusters.bind(this), this.fitMapToMarkers = this.fitMapToMarkers.bind(this), this.getIgnoreHidden = this.getIgnoreHidden.bind(this), this.setIgnoreHidden = this.setIgnoreHidden.bind(this), this.getClusterClass = this.getClusterClass.bind(this), this.setClusterClass = this.setClusterClass.bind(this), this.getTotalMarkers = this.getTotalMarkers.bind(this), this.getZoomOnClick = this.getZoomOnClick.bind(this), this.setZoomOnClick = this.setZoomOnClick.bind(this), this.getBatchSizeIE = this.getBatchSizeIE.bind(this), this.setBatchSizeIE = this.setBatchSizeIE.bind(this), this.createClusters = this.createClusters.bind(this), this.onZoomChanged = this.onZoomChanged.bind(this), this.getImageSizes = this.getImageSizes.bind(this), this.setImageSizes = this.setImageSizes.bind(this), this.getCalculator = this.getCalculator.bind(this), this.setCalculator = this.setCalculator.bind(this), this.removeMarkers = this.removeMarkers.bind(this), this.resetViewport = this.resetViewport.bind(this), this.getImagePath = this.getImagePath.bind(this), this.setImagePath = this.setImagePath.bind(this), this.pushMarkerTo = this.pushMarkerTo.bind(this), this.removeMarker = this.removeMarker.bind(this), this.clearMarkers = this.clearMarkers.bind(this), this.setupStyles = this.setupStyles.bind(this), this.getGridSize = this.getGridSize.bind(this), this.setGridSize = this.setGridSize.bind(this), this.getClusters = this.getClusters.bind(this), this.getMaxZoom = this.getMaxZoom.bind(this), this.setMaxZoom = this.setMaxZoom.bind(this), this.getMarkers = this.getMarkers.bind(this), this.addMarkers = this.addMarkers.bind(this), this.getStyles = this.getStyles.bind(this), this.setStyles = this.setStyles.bind(this), this.addMarker = this.addMarker.bind(this), this.onRemove = this.onRemove.bind(this), this.getTitle = this.getTitle.bind(this), this.setTitle = this.setTitle.bind(this), this.repaint = this.repaint.bind(this), this.onIdle = this.onIdle.bind(this), this.redraw = this.redraw.bind(this), this.onAdd = this.onAdd.bind(this), this.draw = this.draw.bind(this), this.extend = this.extend.bind(this), this.extend(e, google.maps.OverlayView), this.markers = [], this.clusters = [], this.listeners = [], this.activeMap = null, this.ready = !1, this.gridSize = r.gridSize || 60, this.minClusterSize = r.minimumClusterSize || 2, this.maxZoom = r.maxZoom || null, this.styles = r.styles || [], this.title = r.title || "", this.zoomOnClick = !0, r.zoomOnClick !== void 0 && (this.zoomOnClick = r.zoomOnClick), this.averageCenter = !1, r.averageCenter !== void 0 && (this.averageCenter = r.averageCenter), this.ignoreHidden = !1, r.ignoreHidden !== void 0 && (this.ignoreHidden = r.ignoreHidden), this.enableRetinaIcons = !1, r.enableRetinaIcons !== void 0 && (this.enableRetinaIcons = r.enableRetinaIcons), this.imagePath = r.imagePath || QAe, this.imageExtension = r.imageExtension || eRe, this.imageSizes = r.imageSizes || tRe, this.calculator = r.calculator || XAe, this.batchSize = r.batchSize || YAe, this.batchSizeIE = r.batchSizeIE || JAe, this.clusterClass = r.clusterClass || nRe, navigator.userAgent.toLowerCase().indexOf("msie") !== -1 && (this.batchSize = this.batchSizeIE), this.timerRefStatic = null, this.setupStyles(), this.addMarkers(n, !0), this.setMap(t);
    }
    return e.prototype.onZoomChanged = function() {
      var t, n;
      this.resetViewport(!1), (((t = this.getMap()) === null || t === void 0 ? void 0 : t.getZoom()) === (this.get("minZoom") || 0) || ((n = this.getMap()) === null || n === void 0 ? void 0 : n.getZoom()) === this.get("maxZoom")) && google.maps.event.trigger(this, "idle");
    }, e.prototype.onIdle = function() {
      this.redraw();
    }, e.prototype.onAdd = function() {
      var t = this.getMap();
      this.activeMap = t, this.ready = !0, this.repaint(), t !== null && (this.listeners = [google.maps.event.addListener(t, "zoom_changed", this.onZoomChanged), google.maps.event.addListener(t, "idle", this.onIdle)]);
    }, e.prototype.onRemove = function() {
      for (var t = 0, n = this.markers; t < n.length; t++) {
        var r = n[t];
        r.getMap() !== this.activeMap && r.setMap(this.activeMap);
      }
      for (var o = 0, i = this.clusters; o < i.length; o++) {
        var a = i[o];
        a.remove();
      }
      this.clusters = [];
      for (var s = 0, l = this.listeners; s < l.length; s++) {
        var u = l[s];
        google.maps.event.removeListener(u);
      }
      this.listeners = [], this.activeMap = null, this.ready = !1;
    }, e.prototype.draw = function() {
    }, e.prototype.getMap = function() {
      return null;
    }, e.prototype.getPanes = function() {
      return null;
    }, e.prototype.getProjection = function() {
      return {
        fromContainerPixelToLatLng: function() {
          return null;
        },
        fromDivPixelToLatLng: function() {
          return null;
        },
        fromLatLngToContainerPixel: function() {
          return null;
        },
        fromLatLngToDivPixel: function() {
          return null;
        },
        getVisibleRegion: function() {
          return null;
        },
        getWorldWidth: function() {
          return 0;
        }
      };
    }, e.prototype.setMap = function() {
    }, e.prototype.addListener = function() {
      return {
        remove: function() {
        }
      };
    }, e.prototype.bindTo = function() {
    }, e.prototype.get = function() {
    }, e.prototype.notify = function() {
    }, e.prototype.set = function() {
    }, e.prototype.setValues = function() {
    }, e.prototype.unbind = function() {
    }, e.prototype.unbindAll = function() {
    }, e.prototype.setupStyles = function() {
      if (!(this.styles.length > 0))
        for (var t = 0; t < this.imageSizes.length; t++)
          this.styles.push({
            url: "".concat(this.imagePath + (t + 1), ".").concat(this.imageExtension),
            height: this.imageSizes[t] || 0,
            width: this.imageSizes[t] || 0
          });
    }, e.prototype.fitMapToMarkers = function() {
      for (var t = this.getMarkers(), n = new google.maps.LatLngBounds(), r = 0, o = t; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && n.extend(a);
      }
      var s = this.getMap();
      s !== null && "fitBounds" in s && s.fitBounds(n);
    }, e.prototype.getGridSize = function() {
      return this.gridSize;
    }, e.prototype.setGridSize = function(t) {
      this.gridSize = t;
    }, e.prototype.getMinimumClusterSize = function() {
      return this.minClusterSize;
    }, e.prototype.setMinimumClusterSize = function(t) {
      this.minClusterSize = t;
    }, e.prototype.getMaxZoom = function() {
      return this.maxZoom;
    }, e.prototype.setMaxZoom = function(t) {
      this.maxZoom = t;
    }, e.prototype.getStyles = function() {
      return this.styles;
    }, e.prototype.setStyles = function(t) {
      this.styles = t;
    }, e.prototype.getTitle = function() {
      return this.title;
    }, e.prototype.setTitle = function(t) {
      this.title = t;
    }, e.prototype.getZoomOnClick = function() {
      return this.zoomOnClick;
    }, e.prototype.setZoomOnClick = function(t) {
      this.zoomOnClick = t;
    }, e.prototype.getAverageCenter = function() {
      return this.averageCenter;
    }, e.prototype.setAverageCenter = function(t) {
      this.averageCenter = t;
    }, e.prototype.getIgnoreHidden = function() {
      return this.ignoreHidden;
    }, e.prototype.setIgnoreHidden = function(t) {
      this.ignoreHidden = t;
    }, e.prototype.getEnableRetinaIcons = function() {
      return this.enableRetinaIcons;
    }, e.prototype.setEnableRetinaIcons = function(t) {
      this.enableRetinaIcons = t;
    }, e.prototype.getImageExtension = function() {
      return this.imageExtension;
    }, e.prototype.setImageExtension = function(t) {
      this.imageExtension = t;
    }, e.prototype.getImagePath = function() {
      return this.imagePath;
    }, e.prototype.setImagePath = function(t) {
      this.imagePath = t;
    }, e.prototype.getImageSizes = function() {
      return this.imageSizes;
    }, e.prototype.setImageSizes = function(t) {
      this.imageSizes = t;
    }, e.prototype.getCalculator = function() {
      return this.calculator;
    }, e.prototype.setCalculator = function(t) {
      this.calculator = t;
    }, e.prototype.getBatchSizeIE = function() {
      return this.batchSizeIE;
    }, e.prototype.setBatchSizeIE = function(t) {
      this.batchSizeIE = t;
    }, e.prototype.getClusterClass = function() {
      return this.clusterClass;
    }, e.prototype.setClusterClass = function(t) {
      this.clusterClass = t;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getTotalMarkers = function() {
      return this.markers.length;
    }, e.prototype.getClusters = function() {
      return this.clusters;
    }, e.prototype.getTotalClusters = function() {
      return this.clusters.length;
    }, e.prototype.addMarker = function(t, n) {
      this.pushMarkerTo(t), n || this.redraw();
    }, e.prototype.addMarkers = function(t, n) {
      for (var r in t)
        if (Object.prototype.hasOwnProperty.call(t, r)) {
          var o = t[r];
          o && this.pushMarkerTo(o);
        }
      n || this.redraw();
    }, e.prototype.pushMarkerTo = function(t) {
      var n = this;
      t.getDraggable() && google.maps.event.addListener(t, "dragend", function() {
        n.ready && (t.isAdded = !1, n.repaint());
      }), t.isAdded = !1, this.markers.push(t);
    }, e.prototype.removeMarker_ = function(t) {
      var n = -1;
      if (this.markers.indexOf)
        n = this.markers.indexOf(t);
      else
        for (var r = 0; r < this.markers.length; r++)
          if (t === this.markers[r]) {
            n = r;
            break;
          }
      return n === -1 ? !1 : (t.setMap(null), this.markers.splice(n, 1), !0);
    }, e.prototype.removeMarker = function(t, n) {
      var r = this.removeMarker_(t);
      return !n && r && this.repaint(), r;
    }, e.prototype.removeMarkers = function(t, n) {
      for (var r = !1, o = 0, i = t; o < i.length; o++) {
        var a = i[o];
        r = r || this.removeMarker_(a);
      }
      return !n && r && this.repaint(), r;
    }, e.prototype.clearMarkers = function() {
      this.resetViewport(!0), this.markers = [];
    }, e.prototype.repaint = function() {
      var t = this.clusters.slice();
      this.clusters = [], this.resetViewport(!1), this.redraw(), setTimeout(function() {
        for (var n = 0, r = t; n < r.length; n++) {
          var o = r[n];
          o.remove();
        }
      }, 0);
    }, e.prototype.getExtendedBounds = function(t) {
      var n = this.getProjection(), r = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getNorthEast().lat(), t.getNorthEast().lng())
      );
      r !== null && (r.x += this.gridSize, r.y -= this.gridSize);
      var o = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getSouthWest().lat(), t.getSouthWest().lng())
      );
      if (o !== null && (o.x -= this.gridSize, o.y += this.gridSize), r !== null) {
        var i = n.fromDivPixelToLatLng(r);
        i !== null && t.extend(i);
      }
      if (o !== null) {
        var a = n.fromDivPixelToLatLng(o);
        a !== null && t.extend(a);
      }
      return t;
    }, e.prototype.redraw = function() {
      this.createClusters(0);
    }, e.prototype.resetViewport = function(t) {
      for (var n = 0, r = this.clusters; n < r.length; n++) {
        var o = r[n];
        o.remove();
      }
      this.clusters = [];
      for (var i = 0, a = this.markers; i < a.length; i++) {
        var s = a[i];
        s.isAdded = !1, t && s.setMap(null);
      }
    }, e.prototype.distanceBetweenPoints = function(t, n) {
      var r = 6371, o = (n.lat() - t.lat()) * Math.PI / 180, i = (n.lng() - t.lng()) * Math.PI / 180, a = Math.sin(o / 2) * Math.sin(o / 2) + Math.cos(t.lat() * Math.PI / 180) * Math.cos(n.lat() * Math.PI / 180) * Math.sin(i / 2) * Math.sin(i / 2);
      return r * (2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)));
    }, e.prototype.isMarkerInBounds = function(t, n) {
      var r = t.getPosition();
      return r ? n.contains(r) : !1;
    }, e.prototype.addToClosestCluster = function(t) {
      for (var n, r = 4e4, o = null, i = 0, a = this.clusters; i < a.length; i++) {
        var s = a[i];
        n = s;
        var l = n.getCenter(), u = t.getPosition();
        if (l && u) {
          var c = this.distanceBetweenPoints(l, u);
          c < r && (r = c, o = n);
        }
      }
      o && o.isMarkerInClusterBounds(t) ? o.addMarker(t) : (n = new KAe(this), n.addMarker(t), this.clusters.push(n));
    }, e.prototype.createClusters = function(t) {
      var n = this;
      if (this.ready) {
        t === 0 && (google.maps.event.trigger(this, "clusteringbegin", this), this.timerRefStatic !== null && (window.clearTimeout(this.timerRefStatic), delete this.timerRefStatic));
        for (var r = this.getMap(), o = r !== null && ("getBounds" in r) ? r.getBounds() : null, i = (r == null ? void 0 : r.getZoom()) || 0, a = i > 3 ? new google.maps.LatLngBounds(o == null ? void 0 : o.getSouthWest(), o == null ? void 0 : o.getNorthEast()) : new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625)), s = this.getExtendedBounds(a), l = Math.min(t + this.batchSize, this.markers.length), u = t; u < l; u++) {
          var c = this.markers[u];
          c && !c.isAdded && this.isMarkerInBounds(c, s) && (!this.ignoreHidden || this.ignoreHidden && c.getVisible()) && this.addToClosestCluster(c);
        }
        if (l < this.markers.length)
          this.timerRefStatic = window.setTimeout(function() {
            n.createClusters(l);
          }, 0);
        else {
          this.timerRefStatic = null, google.maps.event.trigger(this, "clusteringend", this);
          for (var p = 0, d = this.clusters; p < d.length; p++) {
            var g = d[p];
            g.updateIcon();
          }
        }
      }
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype) {
          var i = o;
          this.prototype[i] = r.prototype[i];
        }
        return this;
      }).apply(t, [n]);
    }, e;
  }()
);
function bW(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function rRe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? bW(Object(n), !0).forEach(function(r) {
      Pe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : bW(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Is = {
  onClick: "click",
  onClusteringBegin: "clusteringbegin",
  onClusteringEnd: "clusteringend",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover"
}, jn = {
  averageCenter(e, t) {
    e.setAverageCenter(t);
  },
  batchSizeIE(e, t) {
    e.setBatchSizeIE(t);
  },
  calculator(e, t) {
    e.setCalculator(t);
  },
  clusterClass(e, t) {
    e.setClusterClass(t);
  },
  enableRetinaIcons(e, t) {
    e.setEnableRetinaIcons(t);
  },
  gridSize(e, t) {
    e.setGridSize(t);
  },
  ignoreHidden(e, t) {
    e.setIgnoreHidden(t);
  },
  imageExtension(e, t) {
    e.setImageExtension(t);
  },
  imagePath(e, t) {
    e.setImagePath(t);
  },
  imageSizes(e, t) {
    e.setImageSizes(t);
  },
  maxZoom(e, t) {
    e.setMaxZoom(t);
  },
  minimumClusterSize(e, t) {
    e.setMinimumClusterSize(t);
  },
  styles(e, t) {
    e.setStyles(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  zoomOnClick(e, t) {
    e.setZoomOnClick(t);
  }
}, oRe = {};
function iRe(e) {
  var {
    children: t,
    options: n,
    averageCenter: r,
    batchSizeIE: o,
    calculator: i,
    clusterClass: a,
    enableRetinaIcons: s,
    gridSize: l,
    ignoreHidden: u,
    imageExtension: c,
    imagePath: p,
    imageSizes: d,
    maxZoom: g,
    minimumClusterSize: f,
    styles: m,
    title: b,
    zoomOnClick: E,
    onClick: w,
    onClusteringBegin: M,
    onClusteringEnd: x,
    onMouseOver: v,
    onMouseOut: C,
    onLoad: P,
    onUnmount: F
  } = e, [L, B] = k(null), N = ge(Nt), [$, V] = k(null), [H, Z] = k(null), [K, Y] = k(null), [Q, J] = k(null), [_, D] = k(null);
  return h(() => {
    L && C && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(L, Is.onMouseOut, C)));
  }, [C]), h(() => {
    L && v && (_ !== null && google.maps.event.removeListener(_), D(google.maps.event.addListener(L, Is.onMouseOver, v)));
  }, [v]), h(() => {
    L && w && ($ !== null && google.maps.event.removeListener($), V(google.maps.event.addListener(L, Is.onClick, w)));
  }, [w]), h(() => {
    L && M && (H !== null && google.maps.event.removeListener(H), Z(google.maps.event.addListener(L, Is.onClusteringBegin, M)));
  }, [M]), h(() => {
    L && x && (K !== null && google.maps.event.removeListener(K), Z(google.maps.event.addListener(L, Is.onClusteringEnd, x)));
  }, [x]), h(() => {
    typeof r < "u" && L !== null && jn.averageCenter(L, r);
  }, [L, r]), h(() => {
    typeof o < "u" && L !== null && jn.batchSizeIE(L, o);
  }, [L, o]), h(() => {
    typeof i < "u" && L !== null && jn.calculator(L, i);
  }, [L, i]), h(() => {
    typeof a < "u" && L !== null && jn.clusterClass(L, a);
  }, [L, a]), h(() => {
    typeof s < "u" && L !== null && jn.enableRetinaIcons(L, s);
  }, [L, s]), h(() => {
    typeof l < "u" && L !== null && jn.gridSize(L, l);
  }, [L, l]), h(() => {
    typeof u < "u" && L !== null && jn.ignoreHidden(L, u);
  }, [L, u]), h(() => {
    typeof c < "u" && L !== null && jn.imageExtension(L, c);
  }, [L, c]), h(() => {
    typeof p < "u" && L !== null && jn.imagePath(L, p);
  }, [L, p]), h(() => {
    typeof d < "u" && L !== null && jn.imageSizes(L, d);
  }, [L, d]), h(() => {
    typeof g < "u" && L !== null && jn.maxZoom(L, g);
  }, [L, g]), h(() => {
    typeof f < "u" && L !== null && jn.minimumClusterSize(L, f);
  }, [L, f]), h(() => {
    typeof m < "u" && L !== null && jn.styles(L, m);
  }, [L, m]), h(() => {
    typeof b < "u" && L !== null && jn.title(L, b);
  }, [L, b]), h(() => {
    typeof E < "u" && L !== null && jn.zoomOnClick(L, E);
  }, [L, E]), h(() => {
    if (N) {
      var z = rRe({}, n || oRe), S = new dte(N, [], z);
      return r && jn.averageCenter(S, r), o && jn.batchSizeIE(S, o), i && jn.calculator(S, i), a && jn.clusterClass(S, a), s && jn.enableRetinaIcons(S, s), l && jn.gridSize(S, l), u && jn.ignoreHidden(S, u), c && jn.imageExtension(S, c), p && jn.imagePath(S, p), d && jn.imageSizes(S, d), g && jn.maxZoom(S, g), f && jn.minimumClusterSize(S, f), m && jn.styles(S, m), b && jn.title(S, b), E && jn.zoomOnClick(S, E), C && J(google.maps.event.addListener(S, Is.onMouseOut, C)), v && D(google.maps.event.addListener(S, Is.onMouseOver, v)), w && V(google.maps.event.addListener(S, Is.onClick, w)), M && Z(google.maps.event.addListener(S, Is.onClusteringBegin, M)), x && Y(google.maps.event.addListener(S, Is.onClusteringEnd, x)), B(S), P && P(S), () => {
        Q !== null && google.maps.event.removeListener(Q), _ !== null && google.maps.event.removeListener(_), $ !== null && google.maps.event.removeListener($), H !== null && google.maps.event.removeListener(H), K !== null && google.maps.event.removeListener(K), F && F(S);
      };
    }
  }, []), L !== null && t(L) || null;
}
me(iRe);
class sRe extends pe {
  constructor() {
    super(...arguments), Pe(this, "registeredEvents", []), Pe(this, "state", {
      markerClusterer: null
    }), Pe(this, "setClustererCallback", () => {
      this.state.markerClusterer !== null && this.props.onLoad && this.props.onLoad(this.state.markerClusterer);
    });
  }
  componentDidMount() {
    if (this.context) {
      var t = new dte(this.context, [], this.props.options);
      this.registeredEvents = bn({
        updaterMap: jn,
        eventMap: Is,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        markerClusterer: t
      }), this.setClustererCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.markerClusterer && (Ln(this.registeredEvents), this.registeredEvents = bn({
      updaterMap: jn,
      eventMap: Is,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.markerClusterer
    }));
  }
  componentWillUnmount() {
    this.state.markerClusterer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.markerClusterer), Ln(this.registeredEvents), this.state.markerClusterer.setMap(null));
  }
  render() {
    return this.state.markerClusterer !== null ? this.props.children(this.state.markerClusterer) : null;
  }
}
Pe(sRe, "contextType", Nt);
function wW(e) {
  e.cancelBubble = !0, e.stopPropagation && e.stopPropagation();
}
var fte = (
  /** @class */
  function() {
    function e(t) {
      t === void 0 && (t = {}), this.getCloseClickHandler = this.getCloseClickHandler.bind(this), this.closeClickHandler = this.closeClickHandler.bind(this), this.createInfoBoxDiv = this.createInfoBoxDiv.bind(this), this.addClickHandler = this.addClickHandler.bind(this), this.getCloseBoxImg = this.getCloseBoxImg.bind(this), this.getBoxWidths = this.getBoxWidths.bind(this), this.setBoxStyle = this.setBoxStyle.bind(this), this.setPosition = this.setPosition.bind(this), this.getPosition = this.getPosition.bind(this), this.setOptions = this.setOptions.bind(this), this.setContent = this.setContent.bind(this), this.setVisible = this.setVisible.bind(this), this.getContent = this.getContent.bind(this), this.getVisible = this.getVisible.bind(this), this.setZIndex = this.setZIndex.bind(this), this.getZIndex = this.getZIndex.bind(this), this.onRemove = this.onRemove.bind(this), this.panBox = this.panBox.bind(this), this.extend = this.extend.bind(this), this.close = this.close.bind(this), this.draw = this.draw.bind(this), this.show = this.show.bind(this), this.hide = this.hide.bind(this), this.open = this.open.bind(this), this.extend(e, google.maps.OverlayView), this.content = t.content || "", this.disableAutoPan = t.disableAutoPan || !1, this.maxWidth = t.maxWidth || 0, this.pixelOffset = t.pixelOffset || new google.maps.Size(0, 0), this.position = t.position || new google.maps.LatLng(0, 0), this.zIndex = t.zIndex || null, this.boxClass = t.boxClass || "infoBox", this.boxStyle = t.boxStyle || {}, this.closeBoxMargin = t.closeBoxMargin || "2px", this.closeBoxURL = t.closeBoxURL || "http://www.google.com/intl/en_us/mapfiles/close.gif", t.closeBoxURL === "" && (this.closeBoxURL = ""), this.infoBoxClearance = t.infoBoxClearance || new google.maps.Size(1, 1), typeof t.visible > "u" && (typeof t.isHidden > "u" ? t.visible = !0 : t.visible = !t.isHidden), this.isHidden = !t.visible, this.alignBottom = t.alignBottom || !1, this.pane = t.pane || "floatPane", this.enableEventPropagation = t.enableEventPropagation || !1, this.div = null, this.closeListener = null, this.moveListener = null, this.mapListener = null, this.contextListener = null, this.eventListeners = null, this.fixedWidthSet = null;
    }
    return e.prototype.createInfoBoxDiv = function() {
      var t = this, n = function(u) {
        u.returnValue = !1, u.preventDefault && u.preventDefault(), t.enableEventPropagation || wW(u);
      };
      if (!this.div) {
        this.div = document.createElement("div"), this.setBoxStyle(), typeof this.content == "string" ? this.div.innerHTML = this.getCloseBoxImg() + this.content : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(this.content));
        var r = this.getPanes();
        if (r !== null && r[this.pane].appendChild(this.div), this.addClickHandler(), this.div.style.width)
          this.fixedWidthSet = !0;
        else if (this.maxWidth !== 0 && this.div.offsetWidth > this.maxWidth)
          this.div.style.width = this.maxWidth + "px", this.fixedWidthSet = !0;
        else {
          var o = this.getBoxWidths();
          this.div.style.width = this.div.offsetWidth - o.left - o.right + "px", this.fixedWidthSet = !1;
        }
        if (this.panBox(this.disableAutoPan), !this.enableEventPropagation) {
          this.eventListeners = [];
          for (var i = ["mousedown", "mouseover", "mouseout", "mouseup", "click", "dblclick", "touchstart", "touchend", "touchmove"], a = 0, s = i; a < s.length; a++) {
            var l = s[a];
            this.eventListeners.push(google.maps.event.addListener(this.div, l, wW));
          }
          this.eventListeners.push(google.maps.event.addListener(this.div, "mouseover", function() {
            t.div && (t.div.style.cursor = "default");
          }));
        }
        this.contextListener = google.maps.event.addListener(this.div, "contextmenu", n), google.maps.event.trigger(this, "domready");
      }
    }, e.prototype.getCloseBoxImg = function() {
      var t = "";
      return this.closeBoxURL !== "" && (t = '<img alt=""', t += ' aria-hidden="true"', t += " src='" + this.closeBoxURL + "'", t += " align=right", t += " style='", t += " position: relative;", t += " cursor: pointer;", t += " margin: " + this.closeBoxMargin + ";", t += "'>"), t;
    }, e.prototype.addClickHandler = function() {
      this.closeListener = this.div && this.div.firstChild && this.closeBoxURL !== "" ? google.maps.event.addListener(this.div.firstChild, "click", this.getCloseClickHandler()) : null;
    }, e.prototype.closeClickHandler = function(t) {
      t.cancelBubble = !0, t.stopPropagation && t.stopPropagation(), google.maps.event.trigger(this, "closeclick"), this.close();
    }, e.prototype.getCloseClickHandler = function() {
      return this.closeClickHandler;
    }, e.prototype.panBox = function(t) {
      if (this.div && !t) {
        var n = this.getMap();
        if (n instanceof google.maps.Map) {
          var r = 0, o = 0, i = n.getBounds();
          i && !i.contains(this.position) && n.setCenter(this.position);
          var a = n.getDiv(), s = a.offsetWidth, l = a.offsetHeight, u = this.pixelOffset.width, c = this.pixelOffset.height, p = this.div.offsetWidth, d = this.div.offsetHeight, g = this.infoBoxClearance.width, f = this.infoBoxClearance.height, m = this.getProjection(), b = m.fromLatLngToContainerPixel(this.position);
          b !== null && (b.x < -u + g ? r = b.x + u - g : b.x + p + u + g > s && (r = b.x + p + u + g - s), this.alignBottom ? b.y < -c + f + d ? o = b.y + c - f - d : b.y + c + f > l && (o = b.y + c + f - l) : b.y < -c + f ? o = b.y + c - f : b.y + d + c + f > l && (o = b.y + d + c + f - l)), r === 0 && o === 0 || n.panBy(r, o);
        }
      }
    }, e.prototype.setBoxStyle = function() {
      if (this.div) {
        this.div.className = this.boxClass, this.div.style.cssText = "";
        var t = this.boxStyle;
        for (var n in t)
          Object.prototype.hasOwnProperty.call(t, n) && (this.div.style[n] = t[n]);
        if (this.div.style.webkitTransform = "translateZ(0)", typeof this.div.style.opacity < "u" && this.div.style.opacity !== "") {
          var r = parseFloat(this.div.style.opacity || "");
          this.div.style.msFilter = '"progid:DXImageTransform.Microsoft.Alpha(Opacity=' + r * 100 + ')"', this.div.style.filter = "alpha(opacity=" + r * 100 + ")";
        }
        this.div.style.position = "absolute", this.div.style.visibility = "hidden", this.zIndex !== null && (this.div.style.zIndex = this.zIndex + ""), this.div.style.overflow || (this.div.style.overflow = "auto");
      }
    }, e.prototype.getBoxWidths = function() {
      var t = {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0
      };
      if (!this.div)
        return t;
      if (document.defaultView) {
        var n = this.div.ownerDocument, r = n && n.defaultView ? n.defaultView.getComputedStyle(this.div, "") : null;
        r && (t.top = parseInt(r.borderTopWidth || "", 10) || 0, t.bottom = parseInt(r.borderBottomWidth || "", 10) || 0, t.left = parseInt(r.borderLeftWidth || "", 10) || 0, t.right = parseInt(r.borderRightWidth || "", 10) || 0);
      } else if (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        document.documentElement.currentStyle
      ) {
        var o = this.div.currentStyle;
        o && (t.top = parseInt(o.borderTopWidth || "", 10) || 0, t.bottom = parseInt(o.borderBottomWidth || "", 10) || 0, t.left = parseInt(o.borderLeftWidth || "", 10) || 0, t.right = parseInt(o.borderRightWidth || "", 10) || 0);
      }
      return t;
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.div.parentNode.removeChild(this.div), this.div = null);
    }, e.prototype.draw = function() {
      if (this.createInfoBoxDiv(), this.div) {
        var t = this.getProjection(), n = t.fromLatLngToDivPixel(this.position);
        n !== null && (this.div.style.left = n.x + this.pixelOffset.width + "px", this.alignBottom ? this.div.style.bottom = -(n.y + this.pixelOffset.height) + "px" : this.div.style.top = n.y + this.pixelOffset.height + "px"), this.isHidden ? this.div.style.visibility = "hidden" : this.div.style.visibility = "visible";
      }
    }, e.prototype.setOptions = function(t) {
      t === void 0 && (t = {}), typeof t.boxClass < "u" && (this.boxClass = t.boxClass, this.setBoxStyle()), typeof t.boxStyle < "u" && (this.boxStyle = t.boxStyle, this.setBoxStyle()), typeof t.content < "u" && this.setContent(t.content), typeof t.disableAutoPan < "u" && (this.disableAutoPan = t.disableAutoPan), typeof t.maxWidth < "u" && (this.maxWidth = t.maxWidth), typeof t.pixelOffset < "u" && (this.pixelOffset = t.pixelOffset), typeof t.alignBottom < "u" && (this.alignBottom = t.alignBottom), typeof t.position < "u" && this.setPosition(t.position), typeof t.zIndex < "u" && this.setZIndex(t.zIndex), typeof t.closeBoxMargin < "u" && (this.closeBoxMargin = t.closeBoxMargin), typeof t.closeBoxURL < "u" && (this.closeBoxURL = t.closeBoxURL), typeof t.infoBoxClearance < "u" && (this.infoBoxClearance = t.infoBoxClearance), typeof t.isHidden < "u" && (this.isHidden = t.isHidden), typeof t.visible < "u" && (this.isHidden = !t.visible), typeof t.enableEventPropagation < "u" && (this.enableEventPropagation = t.enableEventPropagation), this.div && this.draw();
    }, e.prototype.setContent = function(t) {
      this.content = t, this.div && (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.fixedWidthSet || (this.div.style.width = ""), typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t)), this.fixedWidthSet || (this.div.style.width = this.div.offsetWidth + "px", typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t))), this.addClickHandler()), google.maps.event.trigger(this, "content_changed");
    }, e.prototype.setPosition = function(t) {
      this.position = t, this.div && this.draw(), google.maps.event.trigger(this, "position_changed");
    }, e.prototype.setVisible = function(t) {
      this.isHidden = !t, this.div && (this.div.style.visibility = this.isHidden ? "hidden" : "visible");
    }, e.prototype.setZIndex = function(t) {
      this.zIndex = t, this.div && (this.div.style.zIndex = t + ""), google.maps.event.trigger(this, "zindex_changed");
    }, e.prototype.getContent = function() {
      return this.content;
    }, e.prototype.getPosition = function() {
      return this.position;
    }, e.prototype.getZIndex = function() {
      return this.zIndex;
    }, e.prototype.getVisible = function() {
      var t = this.getMap();
      return typeof t > "u" || t === null ? !1 : !this.isHidden;
    }, e.prototype.show = function() {
      this.isHidden = !1, this.div && (this.div.style.visibility = "visible");
    }, e.prototype.hide = function() {
      this.isHidden = !0, this.div && (this.div.style.visibility = "hidden");
    }, e.prototype.open = function(t, n) {
      var r = this;
      n && (this.position = n.getPosition(), this.moveListener = google.maps.event.addListener(n, "position_changed", function() {
        var o = n.getPosition();
        r.setPosition(o);
      }), this.mapListener = google.maps.event.addListener(n, "map_changed", function() {
        r.setMap(n.map);
      })), this.setMap(t), this.div && this.panBox();
    }, e.prototype.close = function() {
      if (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.eventListeners) {
        for (var t = 0, n = this.eventListeners; t < n.length; t++) {
          var r = n[t];
          google.maps.event.removeListener(r);
        }
        this.eventListeners = null;
      }
      this.moveListener && (google.maps.event.removeListener(this.moveListener), this.moveListener = null), this.mapListener && (google.maps.event.removeListener(this.mapListener), this.mapListener = null), this.contextListener && (google.maps.event.removeListener(this.contextListener), this.contextListener = null), this.setMap(null);
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype)
          Object.prototype.hasOwnProperty.call(this, o) || (this.prototype[o] = r.prototype[o]);
        return this;
      }).apply(t, [n]);
    }, e;
  }()
), aRe = ["position"], lRe = ["position"];
function CW(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ew(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? CW(Object(n), !0).forEach(function(r) {
      Pe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : CW(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var OW = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, xW = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    t instanceof google.maps.LatLng ? e.setPosition(t) : e.setPosition(new google.maps.LatLng(t.lat, t.lng));
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, uRe = {};
function cRe(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, g = ge(Nt), [f, m] = k(null), [b, E] = k(null), [w, M] = k(null), [x, v] = k(null), [C, P] = k(null), [F, L] = k(null), B = dt(null);
  return h(() => {
    g && f !== null && (f.close(), n ? f.open(g, n) : f.getPosition() && f.open(g));
  }, [g, f, n]), h(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), h(() => {
    if (o && f !== null) {
      var N = o instanceof google.maps.LatLng ? o : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        new google.maps.LatLng(o.lat, o.lng)
      );
      f.setPosition(N);
    }
  }, [o]), h(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), h(() => {
    f && a && (b !== null && google.maps.event.removeListener(b), E(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), h(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), M(google.maps.event.addListener(f, "domready", s)));
  }, [s]), h(() => {
    f && l && (x !== null && google.maps.event.removeListener(x), v(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), h(() => {
    f && u && (C !== null && google.maps.event.removeListener(C), P(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), h(() => {
    f && c && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), h(() => {
    if (g) {
      var N = r || uRe, {
        position: $
      } = N, V = nT(N, aRe), H;
      $ && !($ instanceof google.maps.LatLng) && (H = new google.maps.LatLng($.lat, $.lng));
      var Z = new fte(ew(ew({}, V), H ? {
        position: H
      } : {}));
      B.current = document.createElement("div"), m(Z), a && E(google.maps.event.addListener(Z, "closeclick", a)), s && M(google.maps.event.addListener(Z, "domready", s)), l && v(google.maps.event.addListener(Z, "content_changed", l)), u && P(google.maps.event.addListener(Z, "position_changed", u)), c && L(google.maps.event.addListener(Z, "zindex_changed", c)), Z.setContent(B.current), n ? Z.open(g, n) : Z.getPosition() ? Z.open(g) : Wo(!1, "You must provide either an anchor or a position prop for <InfoBox>."), p && p(Z);
    }
    return () => {
      f !== null && (b && google.maps.event.removeListener(b), x && google.maps.event.removeListener(x), w && google.maps.event.removeListener(w), C && google.maps.event.removeListener(C), F && google.maps.event.removeListener(F), d && d(f), f.close());
    };
  }, []), B.current ? zn(at.only(t), B.current) : null;
}
me(cRe);
class pRe extends pe {
  constructor() {
    super(...arguments), Pe(this, "registeredEvents", []), Pe(this, "containerElement", null), Pe(this, "state", {
      infoBox: null
    }), Pe(this, "open", (t, n) => {
      n ? this.context !== null && t.open(this.context, n) : t.getPosition() ? this.context !== null && t.open(this.context) : Wo(!1, "You must provide either an anchor or a position prop for <InfoBox>.");
    }), Pe(this, "setInfoBoxCallback", () => {
      this.state.infoBox !== null && this.containerElement !== null && (this.state.infoBox.setContent(this.containerElement), this.open(this.state.infoBox, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoBox));
    });
  }
  componentDidMount() {
    var t = this.props.options || {}, {
      position: n
    } = t, r = nT(t, lRe), o;
    n && !(n instanceof google.maps.LatLng) && (o = new google.maps.LatLng(n.lat, n.lng));
    var i = new fte(ew(ew({}, r), o ? {
      position: o
    } : {}));
    this.containerElement = document.createElement("div"), this.registeredEvents = bn({
      updaterMap: xW,
      eventMap: OW,
      prevProps: {},
      nextProps: this.props,
      instance: i
    }), this.setState({
      infoBox: i
    }, this.setInfoBoxCallback);
  }
  componentDidUpdate(t) {
    var {
      infoBox: n
    } = this.state;
    n !== null && (Ln(this.registeredEvents), this.registeredEvents = bn({
      updaterMap: xW,
      eventMap: OW,
      prevProps: t,
      nextProps: this.props,
      instance: n
    }));
  }
  componentWillUnmount() {
    var {
      onUnmount: t
    } = this.props, {
      infoBox: n
    } = this.state;
    n !== null && (t && t(n), Ln(this.registeredEvents), n.close());
  }
  render() {
    return this.containerElement ? zn(at.only(this.props.children), this.containerElement) : null;
  }
}
Pe(pRe, "contextType", Nt);
var EW, kW;
function dRe() {
  return kW || (kW = 1, EW = function e(t, n) {
    if (t === n) return !0;
    if (t && n && typeof t == "object" && typeof n == "object") {
      if (t.constructor !== n.constructor) return !1;
      var r, o, i;
      if (Array.isArray(t)) {
        if (r = t.length, r != n.length) return !1;
        for (o = r; o-- !== 0; ) if (!e(t[o], n[o])) return !1;
        return !0;
      }
      if (t.constructor === RegExp) return t.source === n.source && t.flags === n.flags;
      if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === n.valueOf();
      if (t.toString !== Object.prototype.toString) return t.toString() === n.toString();
      if (i = Object.keys(t), r = i.length, r !== Object.keys(n).length) return !1;
      for (o = r; o-- !== 0; ) if (!Object.prototype.hasOwnProperty.call(n, i[o])) return !1;
      for (o = r; o-- !== 0; ) {
        var a = i[o];
        if (!e(t[a], n[a])) return !1;
      }
      return !0;
    }
    return t !== t && n !== n;
  }), EW;
}
var fRe = dRe(), LW = /* @__PURE__ */ ste(fRe), _W = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array], KE = 1, Ed = 8;
class rT {
  /**
   * Creates an index from raw `ArrayBuffer` data.
   * @param {ArrayBuffer} data
   */
  static from(t) {
    if (!(t instanceof ArrayBuffer))
      throw new Error("Data must be an instance of ArrayBuffer.");
    var [n, r] = new Uint8Array(t, 0, 2);
    if (n !== 219)
      throw new Error("Data does not appear to be in a KDBush format.");
    var o = r >> 4;
    if (o !== KE)
      throw new Error("Got v".concat(o, " data when expected v").concat(KE, "."));
    var i = _W[r & 15];
    if (!i)
      throw new Error("Unrecognized array type.");
    var [a] = new Uint16Array(t, 2, 1), [s] = new Uint32Array(t, 4, 1);
    return new rT(s, a, i, t);
  }
  /**
   * Creates an index that will hold a given number of items.
   * @param {number} numItems
   * @param {number} [nodeSize=64] Size of the KD-tree node (64 by default).
   * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).
   * @param {ArrayBuffer} [data] (For internal use only)
   */
  constructor(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 64, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Float64Array, o = arguments.length > 3 ? arguments[3] : void 0;
    if (isNaN(t) || t < 0) throw new Error("Unpexpected numItems value: ".concat(t, "."));
    this.numItems = +t, this.nodeSize = Math.min(Math.max(+n, 2), 65535), this.ArrayType = r, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
    var i = _W.indexOf(this.ArrayType), a = t * 2 * this.ArrayType.BYTES_PER_ELEMENT, s = t * this.IndexArrayType.BYTES_PER_ELEMENT, l = (8 - s % 8) % 8;
    if (i < 0)
      throw new Error("Unexpected typed array class: ".concat(r, "."));
    o && o instanceof ArrayBuffer ? (this.data = o, this.ids = new this.IndexArrayType(this.data, Ed, t), this.coords = new this.ArrayType(this.data, Ed + s + l, t * 2), this._pos = t * 2, this._finished = !0) : (this.data = new ArrayBuffer(Ed + a + s + l), this.ids = new this.IndexArrayType(this.data, Ed, t), this.coords = new this.ArrayType(this.data, Ed + s + l, t * 2), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, (KE << 4) + i]), new Uint16Array(this.data, 2, 1)[0] = n, new Uint32Array(this.data, 4, 1)[0] = t);
  }
  /**
   * Add a point to the index.
   * @param {number} x
   * @param {number} y
   * @returns {number} An incremental index associated with the added item (starting from `0`).
   */
  add(t, n) {
    var r = this._pos >> 1;
    return this.ids[r] = r, this.coords[this._pos++] = t, this.coords[this._pos++] = n, r;
  }
  /**
   * Perform indexing of the added points.
   */
  finish() {
    var t = this._pos >> 1;
    if (t !== this.numItems)
      throw new Error("Added ".concat(t, " items when expected ").concat(this.numItems, "."));
    return q_(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
  }
  /**
   * Search the index for items within a given bounding box.
   * @param {number} minX
   * @param {number} minY
   * @param {number} maxX
   * @param {number} maxY
   * @returns {number[]} An array of indices correponding to the found items.
   */
  range(t, n, r, o) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: i,
      coords: a,
      nodeSize: s
    } = this, l = [0, i.length - 1, 0], u = []; l.length; ) {
      var c = l.pop() || 0, p = l.pop() || 0, d = l.pop() || 0;
      if (p - d <= s) {
        for (var g = d; g <= p; g++) {
          var f = a[2 * g], m = a[2 * g + 1];
          f >= t && f <= r && m >= n && m <= o && u.push(i[g]);
        }
        continue;
      }
      var b = d + p >> 1, E = a[2 * b], w = a[2 * b + 1];
      E >= t && E <= r && w >= n && w <= o && u.push(i[b]), (c === 0 ? t <= E : n <= w) && (l.push(d), l.push(b - 1), l.push(1 - c)), (c === 0 ? r >= E : o >= w) && (l.push(b + 1), l.push(p), l.push(1 - c));
    }
    return u;
  }
  /**
   * Search the index for items within a given radius.
   * @param {number} qx
   * @param {number} qy
   * @param {number} r Query radius.
   * @returns {number[]} An array of indices correponding to the found items.
   */
  within(t, n, r) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: o,
      coords: i,
      nodeSize: a
    } = this, s = [0, o.length - 1, 0], l = [], u = r * r; s.length; ) {
      var c = s.pop() || 0, p = s.pop() || 0, d = s.pop() || 0;
      if (p - d <= a) {
        for (var g = d; g <= p; g++)
          PW(i[2 * g], i[2 * g + 1], t, n) <= u && l.push(o[g]);
        continue;
      }
      var f = d + p >> 1, m = i[2 * f], b = i[2 * f + 1];
      PW(m, b, t, n) <= u && l.push(o[f]), (c === 0 ? t - r <= m : n - r <= b) && (s.push(d), s.push(f - 1), s.push(1 - c)), (c === 0 ? t + r >= m : n + r >= b) && (s.push(f + 1), s.push(p), s.push(1 - c));
    }
    return l;
  }
}
function q_(e, t, n, r, o, i) {
  if (!(o - r <= n)) {
    var a = r + o >> 1;
    hte(e, t, a, r, o, i), q_(e, t, n, r, a - 1, 1 - i), q_(e, t, n, a + 1, o, 1 - i);
  }
}
function hte(e, t, n, r, o, i) {
  for (; o > r; ) {
    if (o - r > 600) {
      var a = o - r + 1, s = n - r + 1, l = Math.log(a), u = 0.5 * Math.exp(2 * l / 3), c = 0.5 * Math.sqrt(l * u * (a - u) / a) * (s - a / 2 < 0 ? -1 : 1), p = Math.max(r, Math.floor(n - s * u / a + c)), d = Math.min(o, Math.floor(n + (a - s) * u / a + c));
      hte(e, t, n, p, d, i);
    }
    var g = t[2 * n + i], f = r, m = o;
    for (kd(e, t, r, n), t[2 * o + i] > g && kd(e, t, r, o); f < m; ) {
      for (kd(e, t, f, m), f++, m--; t[2 * f + i] < g; ) f++;
      for (; t[2 * m + i] > g; ) m--;
    }
    t[2 * r + i] === g ? kd(e, t, r, m) : (m++, kd(e, t, m, o)), m <= n && (r = m + 1), n <= m && (o = m - 1);
  }
}
function kd(e, t, n, r) {
  XE(e, n, r), XE(t, 2 * n, 2 * r), XE(t, 2 * n + 1, 2 * r + 1);
}
function XE(e, t, n) {
  var r = e[t];
  e[t] = e[n], e[n] = r;
}
function PW(e, t, n, r) {
  var o = e - n, i = t - r;
  return o * o + i * i;
}
var hRe = {
  minZoom: 0,
  // min zoom to generate clusters on
  maxZoom: 16,
  // max zoom level to cluster the points on
  minPoints: 2,
  // minimum points to form a cluster
  radius: 40,
  // cluster radius in pixels
  extent: 512,
  // tile extent (radius is calculated relative to it)
  nodeSize: 64,
  // size of the KD-tree leaf node, affects performance
  log: !1,
  // whether to log timing info
  // whether to generate numeric ids for input features (in vector tiles)
  generateId: !1,
  // a reduce function for calculating custom cluster properties
  reduce: null,
  // (accumulated, props) => { accumulated.sum += props.sum; }
  // properties to use for individual points when running the reducer
  map: (e) => e
  // props => ({sum: props.my_value})
}, SW = Math.fround || /* @__PURE__ */ ((e) => (t) => (e[0] = +t, e[0]))(new Float32Array(1)), Bu = 2, Ul = 3, YE = 4, jl = 5, gte = 6;
class gRe {
  constructor(t) {
    this.options = Object.assign(Object.create(hRe), t), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
  }
  load(t) {
    var {
      log: n,
      minZoom: r,
      maxZoom: o
    } = this.options;
    n && console.time("total time");
    var i = "prepare ".concat(t.length, " points");
    n && console.time(i), this.points = t;
    for (var a = [], s = 0; s < t.length; s++) {
      var l = t[s];
      if (l.geometry) {
        var [u, c] = l.geometry.coordinates, p = SW(yv(u)), d = SW(bv(c));
        a.push(
          p,
          d,
          // projected point coordinates
          1 / 0,
          // the last zoom the point was processed at
          s,
          // index of the source feature in the original input array
          -1,
          // parent cluster id
          1
          // number of points in a cluster
        ), this.options.reduce && a.push(0);
      }
    }
    var g = this.trees[o + 1] = this._createTree(a);
    n && console.timeEnd(i);
    for (var f = o; f >= r; f--) {
      var m = +Date.now();
      g = this.trees[f] = this._createTree(this._cluster(g, f)), n && console.log("z%d: %d clusters in %dms", f, g.numItems, +Date.now() - m);
    }
    return n && console.timeEnd("total time"), this;
  }
  getClusters(t, n) {
    var r = ((t[0] + 180) % 360 + 360) % 360 - 180, o = Math.max(-90, Math.min(90, t[1])), i = t[2] === 180 ? 180 : ((t[2] + 180) % 360 + 360) % 360 - 180, a = Math.max(-90, Math.min(90, t[3]));
    if (t[2] - t[0] >= 360)
      r = -180, i = 180;
    else if (r > i) {
      var s = this.getClusters([r, o, 180, a], n), l = this.getClusters([-180, o, i, a], n);
      return s.concat(l);
    }
    var u = this.trees[this._limitZoom(n)], c = u.range(yv(r), bv(a), yv(i), bv(o)), p = u.data, d = [];
    for (var g of c) {
      var f = this.stride * g;
      d.push(p[f + jl] > 1 ? MW(p, f, this.clusterProps) : this.points[p[f + Ul]]);
    }
    return d;
  }
  getChildren(t) {
    var n = this._getOriginId(t), r = this._getOriginZoom(t), o = "No cluster with the specified id.", i = this.trees[r];
    if (!i) throw new Error(o);
    var a = i.data;
    if (n * this.stride >= a.length) throw new Error(o);
    var s = this.options.radius / (this.options.extent * Math.pow(2, r - 1)), l = a[n * this.stride], u = a[n * this.stride + 1], c = i.within(l, u, s), p = [];
    for (var d of c) {
      var g = d * this.stride;
      a[g + YE] === t && p.push(a[g + jl] > 1 ? MW(a, g, this.clusterProps) : this.points[a[g + Ul]]);
    }
    if (p.length === 0) throw new Error(o);
    return p;
  }
  getLeaves(t, n, r) {
    n = n || 10, r = r || 0;
    var o = [];
    return this._appendLeaves(o, t, n, r, 0), o;
  }
  getTile(t, n, r) {
    var o = this.trees[this._limitZoom(t)], i = Math.pow(2, t), {
      extent: a,
      radius: s
    } = this.options, l = s / a, u = (r - l) / i, c = (r + 1 + l) / i, p = {
      features: []
    };
    return this._addTileFeatures(o.range((n - l) / i, u, (n + 1 + l) / i, c), o.data, n, r, i, p), n === 0 && this._addTileFeatures(o.range(1 - l / i, u, 1, c), o.data, i, r, i, p), n === i - 1 && this._addTileFeatures(o.range(0, u, l / i, c), o.data, -1, r, i, p), p.features.length ? p : null;
  }
  getClusterExpansionZoom(t) {
    for (var n = this._getOriginZoom(t) - 1; n <= this.options.maxZoom; ) {
      var r = this.getChildren(t);
      if (n++, r.length !== 1) break;
      t = r[0].properties.cluster_id;
    }
    return n;
  }
  _appendLeaves(t, n, r, o, i) {
    var a = this.getChildren(n);
    for (var s of a) {
      var l = s.properties;
      if (l && l.cluster ? i + l.point_count <= o ? i += l.point_count : i = this._appendLeaves(t, l.cluster_id, r, o, i) : i < o ? i++ : t.push(s), t.length === r) break;
    }
    return i;
  }
  _createTree(t) {
    for (var n = new rT(t.length / this.stride | 0, this.options.nodeSize, Float32Array), r = 0; r < t.length; r += this.stride) n.add(t[r], t[r + 1]);
    return n.finish(), n.data = t, n;
  }
  _addTileFeatures(t, n, r, o, i, a) {
    for (var s of t) {
      var l = s * this.stride, u = n[l + jl] > 1, c = void 0, p = void 0, d = void 0;
      if (u)
        c = mte(n, l, this.clusterProps), p = n[l], d = n[l + 1];
      else {
        var g = this.points[n[l + Ul]];
        c = g.properties;
        var [f, m] = g.geometry.coordinates;
        p = yv(f), d = bv(m);
      }
      var b = {
        type: 1,
        geometry: [[Math.round(this.options.extent * (p * i - r)), Math.round(this.options.extent * (d * i - o))]],
        tags: c
      }, E = void 0;
      u || this.options.generateId ? E = n[l + Ul] : E = this.points[n[l + Ul]].id, E !== void 0 && (b.id = E), a.features.push(b);
    }
  }
  _limitZoom(t) {
    return Math.max(this.options.minZoom, Math.min(Math.floor(+t), this.options.maxZoom + 1));
  }
  _cluster(t, n) {
    for (var {
      radius: r,
      extent: o,
      reduce: i,
      minPoints: a
    } = this.options, s = r / (o * Math.pow(2, n)), l = t.data, u = [], c = this.stride, p = 0; p < l.length; p += c)
      if (!(l[p + Bu] <= n)) {
        l[p + Bu] = n;
        var d = l[p], g = l[p + 1], f = t.within(l[p], l[p + 1], s), m = l[p + jl], b = m;
        for (var E of f) {
          var w = E * c;
          l[w + Bu] > n && (b += l[w + jl]);
        }
        if (b > m && b >= a) {
          var M = d * m, x = g * m, v = void 0, C = -1, P = ((p / c | 0) << 5) + (n + 1) + this.points.length;
          for (var F of f) {
            var L = F * c;
            if (!(l[L + Bu] <= n)) {
              l[L + Bu] = n;
              var B = l[L + jl];
              M += l[L] * B, x += l[L + 1] * B, l[L + YE] = P, i && (v || (v = this._map(l, p, !0), C = this.clusterProps.length, this.clusterProps.push(v)), i(v, this._map(l, L)));
            }
          }
          l[p + YE] = P, u.push(M / b, x / b, 1 / 0, P, -1, b), i && u.push(C);
        } else {
          for (var N = 0; N < c; N++) u.push(l[p + N]);
          if (b > 1)
            for (var $ of f) {
              var V = $ * c;
              if (!(l[V + Bu] <= n)) {
                l[V + Bu] = n;
                for (var H = 0; H < c; H++) u.push(l[V + H]);
              }
            }
        }
      }
    return u;
  }
  // get index of the point from which the cluster originated
  _getOriginId(t) {
    return t - this.points.length >> 5;
  }
  // get zoom of the point from which the cluster originated
  _getOriginZoom(t) {
    return (t - this.points.length) % 32;
  }
  _map(t, n, r) {
    if (t[n + jl] > 1) {
      var o = this.clusterProps[t[n + gte]];
      return r ? Object.assign({}, o) : o;
    }
    var i = this.points[t[n + Ul]].properties, a = this.options.map(i);
    return r && a === i ? Object.assign({}, a) : a;
  }
}
function MW(e, t, n) {
  return {
    type: "Feature",
    id: e[t + Ul],
    properties: mte(e, t, n),
    geometry: {
      type: "Point",
      coordinates: [mRe(e[t]), vRe(e[t + 1])]
    }
  };
}
function mte(e, t, n) {
  var r = e[t + jl], o = r >= 1e4 ? "".concat(Math.round(r / 1e3), "k") : r >= 1e3 ? "".concat(Math.round(r / 100) / 10, "k") : r, i = e[t + gte], a = i === -1 ? {} : Object.assign({}, n[i]);
  return Object.assign(a, {
    cluster: !0,
    cluster_id: e[t + Ul],
    point_count: r,
    point_count_abbreviated: o
  });
}
function yv(e) {
  return e / 360 + 0.5;
}
function bv(e) {
  var t = Math.sin(e * Math.PI / 180), n = 0.5 - 0.25 * Math.log((1 + t) / (1 - t)) / Math.PI;
  return n < 0 ? 0 : n > 1 ? 1 : n;
}
function mRe(e) {
  return (e - 0.5) * 360;
}
function vRe(e) {
  var t = (180 - e * 360) * Math.PI / 180;
  return 360 * Math.atan(Math.exp(t)) / Math.PI - 90;
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function yRe(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
    t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
  return n;
}
class ds {
  static isAdvancedMarkerAvailable(t) {
    return google.maps.marker && t.getMapCapabilities().isAdvancedMarkersAvailable === !0;
  }
  static isAdvancedMarker(t) {
    return google.maps.marker && t instanceof google.maps.marker.AdvancedMarkerElement;
  }
  static setMap(t, n) {
    this.isAdvancedMarker(t) ? t.map = n : t.setMap(n);
  }
  static getPosition(t) {
    if (this.isAdvancedMarker(t)) {
      if (t.position) {
        if (t.position instanceof google.maps.LatLng)
          return t.position;
        if (t.position.lat && t.position.lng)
          return new google.maps.LatLng(t.position.lat, t.position.lng);
      }
      return new google.maps.LatLng(null);
    }
    return t.getPosition();
  }
  static getVisible(t) {
    return this.isAdvancedMarker(t) ? !0 : t.getVisible();
  }
}
class G_ {
  constructor(t) {
    var {
      markers: n,
      position: r
    } = t;
    this.markers = n, r && (r instanceof google.maps.LatLng ? this._position = r : this._position = new google.maps.LatLng(r));
  }
  get bounds() {
    if (!(this.markers.length === 0 && !this._position)) {
      var t = new google.maps.LatLngBounds(this._position, this._position);
      for (var n of this.markers)
        t.extend(ds.getPosition(n));
      return t;
    }
  }
  get position() {
    return this._position || this.bounds.getCenter();
  }
  /**
   * Get the count of **visible** markers.
   */
  get count() {
    return this.markers.filter((t) => ds.getVisible(t)).length;
  }
  /**
   * Add a marker to the cluster.
   */
  push(t) {
    this.markers.push(t);
  }
  /**
   * Cleanup references and remove marker from map.
   */
  delete() {
    this.marker && (ds.setMap(this.marker, null), this.marker = void 0), this.markers.length = 0;
  }
}
class bRe {
  constructor(t) {
    var {
      maxZoom: n = 16
    } = t;
    this.maxZoom = n;
  }
  /**
   * Helper function to bypass clustering based upon some map state such as
   * zoom, number of markers, etc.
   *
   * ```typescript
   *  cluster({markers, map}: AlgorithmInput): Cluster[] {
   *    if (shouldBypassClustering(map)) {
   *      return this.noop({markers})
   *    }
   * }
   * ```
   */
  noop(t) {
    var {
      markers: n
    } = t;
    return wRe(n);
  }
}
var wRe = (e) => {
  var t = e.map((n) => new G_({
    position: ds.getPosition(n),
    markers: [n]
  }));
  return t;
};
class CRe extends bRe {
  constructor(t) {
    var {
      maxZoom: n,
      radius: r = 60
    } = t, o = yRe(t, ["maxZoom", "radius"]);
    super({
      maxZoom: n
    }), this.state = {
      zoom: -1
    }, this.superCluster = new gRe(Object.assign({
      maxZoom: this.maxZoom,
      radius: r
    }, o));
  }
  calculate(t) {
    var n = !1, r = {
      zoom: t.map.getZoom()
    };
    if (!LW(t.markers, this.markers)) {
      n = !0, this.markers = [...t.markers];
      var o = this.markers.map((i) => {
        var a = ds.getPosition(i), s = [a.lng(), a.lat()];
        return {
          type: "Feature",
          geometry: {
            type: "Point",
            coordinates: s
          },
          properties: {
            marker: i
          }
        };
      });
      this.superCluster.load(o);
    }
    return n || (this.state.zoom <= this.maxZoom || r.zoom <= this.maxZoom) && (n = !LW(this.state, r)), this.state = r, n && (this.clusters = this.cluster(t)), {
      clusters: this.clusters,
      changed: n
    };
  }
  cluster(t) {
    var {
      map: n
    } = t;
    return this.superCluster.getClusters([-180, -90, 180, 90], Math.round(n.getZoom())).map((r) => this.transformCluster(r));
  }
  transformCluster(t) {
    var {
      geometry: {
        coordinates: [n, r]
      },
      properties: o
    } = t;
    if (o.cluster)
      return new G_({
        markers: this.superCluster.getLeaves(o.cluster_id, 1 / 0).map((a) => a.properties.marker),
        position: {
          lat: r,
          lng: n
        }
      });
    var i = o.marker;
    return new G_({
      markers: [i],
      position: ds.getPosition(i)
    });
  }
}
class ORe {
  constructor(t, n) {
    this.markers = {
      sum: t.length
    };
    var r = n.map((i) => i.count), o = r.reduce((i, a) => i + a, 0);
    this.clusters = {
      count: n.length,
      markers: {
        mean: o / n.length,
        sum: o,
        min: Math.min(...r),
        max: Math.max(...r)
      }
    };
  }
}
class xRe {
  /**
   * The default render function for the library used by {@link MarkerClusterer}.
   *
   * Currently set to use the following:
   *
   * ```typescript
   * // change color if this cluster has more markers than the mean cluster
   * const color =
   *   count > Math.max(10, stats.clusters.markers.mean)
   *     ? "#ff0000"
   *     : "#0000ff";
   *
   * // create svg url with fill color
   * const svg = window.btoa(`
   * <svg fill="${color}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240">
   *   <circle cx="120" cy="120" opacity=".6" r="70" />
   *   <circle cx="120" cy="120" opacity=".3" r="90" />
   *   <circle cx="120" cy="120" opacity=".2" r="110" />
   *   <circle cx="120" cy="120" opacity=".1" r="130" />
   * </svg>`);
   *
   * // create marker using svg icon
   * return new google.maps.Marker({
   *   position,
   *   icon: {
   *     url: `data:image/svg+xml;base64,${svg}`,
   *     scaledSize: new google.maps.Size(45, 45),
   *   },
   *   label: {
   *     text: String(count),
   *     color: "rgba(255,255,255,0.9)",
   *     fontSize: "12px",
   *   },
   *   // adjust zIndex to be above other markers
   *   zIndex: 1000 + count,
   * });
   * ```
   */
  render(t, n, r) {
    var {
      count: o,
      position: i
    } = t, a = o > Math.max(10, n.clusters.markers.mean) ? "#ff0000" : "#0000ff", s = '<svg fill="'.concat(a, `" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" width="50" height="50">
<circle cx="120" cy="120" opacity=".6" r="70" />
<circle cx="120" cy="120" opacity=".3" r="90" />
<circle cx="120" cy="120" opacity=".2" r="110" />
<text x="50%" y="50%" style="fill:#fff" text-anchor="middle" font-size="50" dominant-baseline="middle" font-family="roboto,arial,sans-serif">`).concat(o, `</text>
</svg>`), l = "Cluster of ".concat(o, " markers"), u = Number(google.maps.Marker.MAX_ZINDEX) + o;
    if (ds.isAdvancedMarkerAvailable(r)) {
      var c = new DOMParser(), p = c.parseFromString(s, "image/svg+xml").documentElement;
      p.setAttribute("transform", "translate(0 25)");
      var d = {
        map: r,
        position: i,
        zIndex: u,
        title: l,
        content: p
      };
      return new google.maps.marker.AdvancedMarkerElement(d);
    }
    var g = {
      position: i,
      zIndex: u,
      title: l,
      icon: {
        url: "data:image/svg+xml;base64,".concat(btoa(s)),
        anchor: new google.maps.Point(25, 25)
      }
    };
    return new google.maps.Marker(g);
  }
}
function ERe(e, t) {
  for (var n in t.prototype)
    e.prototype[n] = t.prototype[n];
}
class oT {
  constructor() {
    ERe(oT, google.maps.OverlayView);
  }
}
var _f;
(function(e) {
  e.CLUSTERING_BEGIN = "clusteringbegin", e.CLUSTERING_END = "clusteringend", e.CLUSTER_CLICK = "click";
})(_f || (_f = {}));
var kRe = (e, t, n) => {
  n.fitBounds(t.bounds);
};
class LRe extends oT {
  constructor(t) {
    var {
      map: n,
      markers: r = [],
      algorithmOptions: o = {},
      algorithm: i = new CRe(o),
      renderer: a = new xRe(),
      onClusterClick: s = kRe
    } = t;
    super(), this.markers = [...r], this.clusters = [], this.algorithm = i, this.renderer = a, this.onClusterClick = s, n && this.setMap(n);
  }
  addMarker(t, n) {
    this.markers.includes(t) || (this.markers.push(t), n || this.render());
  }
  addMarkers(t, n) {
    t.forEach((r) => {
      this.addMarker(r, !0);
    }), n || this.render();
  }
  removeMarker(t, n) {
    var r = this.markers.indexOf(t);
    return r === -1 ? !1 : (ds.setMap(t, null), this.markers.splice(r, 1), n || this.render(), !0);
  }
  removeMarkers(t, n) {
    var r = !1;
    return t.forEach((o) => {
      r = this.removeMarker(o, !0) || r;
    }), r && !n && this.render(), r;
  }
  clearMarkers(t) {
    this.markers.length = 0, t || this.render();
  }
  /**
   * Recalculates and draws all the marker clusters.
   */
  render() {
    var t = this.getMap();
    if (t instanceof google.maps.Map && t.getProjection()) {
      google.maps.event.trigger(this, _f.CLUSTERING_BEGIN, this);
      var {
        clusters: n,
        changed: r
      } = this.algorithm.calculate({
        markers: this.markers,
        map: t,
        mapCanvasProjection: this.getProjection()
      });
      if (r || r == null) {
        var o = /* @__PURE__ */ new Set();
        for (var i of n)
          i.markers.length == 1 && o.add(i.markers[0]);
        var a = [];
        for (var s of this.clusters)
          s.marker != null && (s.markers.length == 1 ? o.has(s.marker) || ds.setMap(s.marker, null) : a.push(s.marker));
        this.clusters = n, this.renderClusters(), requestAnimationFrame(() => a.forEach((l) => ds.setMap(l, null)));
      }
      google.maps.event.trigger(this, _f.CLUSTERING_END, this);
    }
  }
  onAdd() {
    this.idleListener = this.getMap().addListener("idle", this.render.bind(this)), this.render();
  }
  onRemove() {
    google.maps.event.removeListener(this.idleListener), this.reset();
  }
  reset() {
    this.markers.forEach((t) => ds.setMap(t, null)), this.clusters.forEach((t) => t.delete()), this.clusters = [];
  }
  renderClusters() {
    var t = new ORe(this.markers, this.clusters), n = this.getMap();
    this.clusters.forEach((r) => {
      r.markers.length === 1 ? r.marker = r.markers[0] : (r.marker = this.renderer.render(r, t, n), r.markers.forEach((o) => ds.setMap(o, null)), this.onClusterClick && r.marker.addListener(
        "click",
        /* istanbul ignore next */
        (o) => {
          google.maps.event.trigger(this, _f.CLUSTER_CLICK, r), this.onClusterClick(o, r, n);
        }
      )), ds.setMap(r.marker, n);
    });
  }
}
function DW(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function TW(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? DW(Object(n), !0).forEach(function(r) {
      Pe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : DW(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function _Re(e) {
  var t = kAe(), [n, r] = k(null);
  return h(() => {
    if (t && n === null) {
      var o = new LRe(TW(TW({}, e), {}, {
        map: t
      }));
      r(o);
    }
  }, [t]), n;
}
function PRe(e) {
  var {
    children: t,
    options: n
  } = e, r = _Re(n);
  return r !== null ? t(r) : null;
}
me(PRe);
var jW = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, AW = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
function SRe(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, g = ge(Nt), [f, m] = k(null), [b, E] = k(null), [w, M] = k(null), [x, v] = k(null), [C, P] = k(null), [F, L] = k(null), B = dt(null);
  return h(() => {
    f !== null && (f.close(), n ? f.open(g, n) : f.getPosition() && f.open(g));
  }, [g, f, n]), h(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), h(() => {
    o && f !== null && f.setPosition(o);
  }, [o]), h(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), h(() => {
    f && a && (b !== null && google.maps.event.removeListener(b), E(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), h(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), M(google.maps.event.addListener(f, "domready", s)));
  }, [s]), h(() => {
    f && l && (x !== null && google.maps.event.removeListener(x), v(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), h(() => {
    f && u && (C !== null && google.maps.event.removeListener(C), P(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), h(() => {
    f && c && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), h(() => {
    var N = new google.maps.InfoWindow(r);
    return m(N), B.current = document.createElement("div"), a && E(google.maps.event.addListener(N, "closeclick", a)), s && M(google.maps.event.addListener(N, "domready", s)), l && v(google.maps.event.addListener(N, "content_changed", l)), u && P(google.maps.event.addListener(N, "position_changed", u)), c && L(google.maps.event.addListener(N, "zindex_changed", c)), N.setContent(B.current), o && N.setPosition(o), i && N.setZIndex(i), n ? N.open(g, n) : N.getPosition() ? N.open(g) : Wo(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>."), p && p(N), () => {
      b && google.maps.event.removeListener(b), x && google.maps.event.removeListener(x), w && google.maps.event.removeListener(w), C && google.maps.event.removeListener(C), F && google.maps.event.removeListener(F), d && d(N), N.close();
    };
  }, []), B.current ? zn(at.only(t), B.current) : null;
}
me(SRe);
class MRe extends pe {
  constructor() {
    super(...arguments), Pe(this, "registeredEvents", []), Pe(this, "containerElement", null), Pe(this, "state", {
      infoWindow: null
    }), Pe(this, "open", (t, n) => {
      n ? t.open(this.context, n) : t.getPosition() ? t.open(this.context) : Wo(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>.");
    }), Pe(this, "setInfoWindowCallback", () => {
      this.state.infoWindow !== null && this.containerElement !== null && (this.state.infoWindow.setContent(this.containerElement), this.open(this.state.infoWindow, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoWindow));
    });
  }
  componentDidMount() {
    var t = new google.maps.InfoWindow(this.props.options);
    this.containerElement = document.createElement("div"), this.registeredEvents = bn({
      updaterMap: AW,
      eventMap: jW,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(() => ({
      infoWindow: t
    }), this.setInfoWindowCallback);
  }
  componentDidUpdate(t) {
    this.state.infoWindow !== null && (Ln(this.registeredEvents), this.registeredEvents = bn({
      updaterMap: AW,
      eventMap: jW,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.infoWindow
    }));
  }
  componentWillUnmount() {
    this.state.infoWindow !== null && (Ln(this.registeredEvents), this.props.onUnmount && this.props.onUnmount(this.state.infoWindow), this.state.infoWindow.close());
  }
  render() {
    return this.containerElement ? zn(at.only(this.props.children), this.containerElement) : null;
  }
}
Pe(MRe, "contextType", Nt);
function RW(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function tw(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? RW(Object(n), !0).forEach(function(r) {
      Pe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : RW(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var IW = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, NW = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, DRe = {};
function TRe(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: g,
    onRightClick: f,
    onClick: m,
    onDrag: b,
    onLoad: E,
    onUnmount: w
  } = e, M = ge(Nt), [x, v] = k(null), [C, P] = k(null), [F, L] = k(null), [B, N] = k(null), [$, V] = k(null), [H, Z] = k(null), [K, Y] = k(null), [Q, J] = k(null), [_, D] = k(null), [z, S] = k(null), [W, O] = k(null), [j, U] = k(null);
  return h(() => {
    x !== null && x.setMap(M);
  }, [M]), h(() => {
    typeof t < "u" && x !== null && x.setOptions(t);
  }, [x, t]), h(() => {
    typeof n < "u" && x !== null && x.setDraggable(n);
  }, [x, n]), h(() => {
    typeof r < "u" && x !== null && x.setEditable(r);
  }, [x, r]), h(() => {
    typeof o < "u" && x !== null && x.setVisible(o);
  }, [x, o]), h(() => {
    typeof i < "u" && x !== null && x.setPath(i);
  }, [x, i]), h(() => {
    x && a && (C !== null && google.maps.event.removeListener(C), P(google.maps.event.addListener(x, "dblclick", a)));
  }, [a]), h(() => {
    x && s && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(x, "dragend", s)));
  }, [s]), h(() => {
    x && l && (B !== null && google.maps.event.removeListener(B), N(google.maps.event.addListener(x, "dragstart", l)));
  }, [l]), h(() => {
    x && u && ($ !== null && google.maps.event.removeListener($), V(google.maps.event.addListener(x, "mousedown", u)));
  }, [u]), h(() => {
    x && c && (H !== null && google.maps.event.removeListener(H), Z(google.maps.event.addListener(x, "mousemove", c)));
  }, [c]), h(() => {
    x && p && (K !== null && google.maps.event.removeListener(K), Y(google.maps.event.addListener(x, "mouseout", p)));
  }, [p]), h(() => {
    x && d && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(x, "mouseover", d)));
  }, [d]), h(() => {
    x && g && (_ !== null && google.maps.event.removeListener(_), D(google.maps.event.addListener(x, "mouseup", g)));
  }, [g]), h(() => {
    x && f && (z !== null && google.maps.event.removeListener(z), S(google.maps.event.addListener(x, "rightclick", f)));
  }, [f]), h(() => {
    x && m && (W !== null && google.maps.event.removeListener(W), O(google.maps.event.addListener(x, "click", m)));
  }, [m]), h(() => {
    x && b && (j !== null && google.maps.event.removeListener(j), U(google.maps.event.addListener(x, "drag", b)));
  }, [b]), h(() => {
    var T = new google.maps.Polyline(tw(tw({}, t || DRe), {}, {
      map: M
    }));
    return i && T.setPath(i), typeof o < "u" && T.setVisible(o), typeof r < "u" && T.setEditable(r), typeof n < "u" && T.setDraggable(n), a && P(google.maps.event.addListener(T, "dblclick", a)), s && L(google.maps.event.addListener(T, "dragend", s)), l && N(google.maps.event.addListener(T, "dragstart", l)), u && V(google.maps.event.addListener(T, "mousedown", u)), c && Z(google.maps.event.addListener(T, "mousemove", c)), p && Y(google.maps.event.addListener(T, "mouseout", p)), d && J(google.maps.event.addListener(T, "mouseover", d)), g && D(google.maps.event.addListener(T, "mouseup", g)), f && S(google.maps.event.addListener(T, "rightclick", f)), m && O(google.maps.event.addListener(T, "click", m)), b && U(google.maps.event.addListener(T, "drag", b)), v(T), E && E(T), () => {
      C !== null && google.maps.event.removeListener(C), F !== null && google.maps.event.removeListener(F), B !== null && google.maps.event.removeListener(B), $ !== null && google.maps.event.removeListener($), H !== null && google.maps.event.removeListener(H), K !== null && google.maps.event.removeListener(K), Q !== null && google.maps.event.removeListener(Q), _ !== null && google.maps.event.removeListener(_), z !== null && google.maps.event.removeListener(z), W !== null && google.maps.event.removeListener(W), w && w(T), T.setMap(null);
    };
  }, []), null;
}
me(TRe);
class jRe extends pe {
  constructor() {
    super(...arguments), Pe(this, "registeredEvents", []), Pe(this, "state", {
      polyline: null
    }), Pe(this, "setPolylineCallback", () => {
      this.state.polyline !== null && this.props.onLoad && this.props.onLoad(this.state.polyline);
    });
  }
  componentDidMount() {
    var t = new google.maps.Polyline(tw(tw({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = bn({
      updaterMap: NW,
      eventMap: IW,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        polyline: t
      };
    }, this.setPolylineCallback);
  }
  componentDidUpdate(t) {
    this.state.polyline !== null && (Ln(this.registeredEvents), this.registeredEvents = bn({
      updaterMap: NW,
      eventMap: IW,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.polyline
    }));
  }
  componentWillUnmount() {
    this.state.polyline !== null && (this.props.onUnmount && this.props.onUnmount(this.state.polyline), Ln(this.registeredEvents), this.state.polyline.setMap(null));
  }
  render() {
    return null;
  }
}
Pe(jRe, "contextType", Nt);
function BW(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function FW(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? BW(Object(n), !0).forEach(function(r) {
      Pe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : BW(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var zW = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, UW = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  paths(e, t) {
    e.setPaths(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function ARe(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    paths: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: g,
    onMouseUp: f,
    onRightClick: m,
    onClick: b,
    onDrag: E,
    onLoad: w,
    onUnmount: M,
    onEdit: x
  } = e, v = ge(Nt), [C, P] = k(null), [F, L] = k(null), [B, N] = k(null), [$, V] = k(null), [H, Z] = k(null), [K, Y] = k(null), [Q, J] = k(null), [_, D] = k(null), [z, S] = k(null), [W, O] = k(null), [j, U] = k(null), [T, q] = k(null);
  return h(() => {
    C !== null && C.setMap(v);
  }, [v]), h(() => {
    typeof t < "u" && C !== null && C.setOptions(t);
  }, [C, t]), h(() => {
    typeof n < "u" && C !== null && C.setDraggable(n);
  }, [C, n]), h(() => {
    typeof r < "u" && C !== null && C.setEditable(r);
  }, [C, r]), h(() => {
    typeof o < "u" && C !== null && C.setVisible(o);
  }, [C, o]), h(() => {
    typeof i < "u" && C !== null && C.setPath(i);
  }, [C, i]), h(() => {
    typeof a < "u" && C !== null && C.setPaths(a);
  }, [C, a]), h(() => {
    C && typeof s == "function" && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(C, "dblclick", s)));
  }, [s]), h(() => {
    C && (google.maps.event.addListener(C.getPath(), "insert_at", () => {
      x == null || x(C);
    }), google.maps.event.addListener(C.getPath(), "set_at", () => {
      x == null || x(C);
    }), google.maps.event.addListener(C.getPath(), "remove_at", () => {
      x == null || x(C);
    }));
  }, [C, x]), h(() => {
    C && typeof l == "function" && (B !== null && google.maps.event.removeListener(B), N(google.maps.event.addListener(C, "dragend", l)));
  }, [l]), h(() => {
    C && typeof u == "function" && ($ !== null && google.maps.event.removeListener($), V(google.maps.event.addListener(C, "dragstart", u)));
  }, [u]), h(() => {
    C && typeof c == "function" && (H !== null && google.maps.event.removeListener(H), Z(google.maps.event.addListener(C, "mousedown", c)));
  }, [c]), h(() => {
    C && typeof p == "function" && (K !== null && google.maps.event.removeListener(K), Y(google.maps.event.addListener(C, "mousemove", p)));
  }, [p]), h(() => {
    C && typeof d == "function" && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(C, "mouseout", d)));
  }, [d]), h(() => {
    C && typeof g == "function" && (_ !== null && google.maps.event.removeListener(_), D(google.maps.event.addListener(C, "mouseover", g)));
  }, [g]), h(() => {
    C && typeof f == "function" && (z !== null && google.maps.event.removeListener(z), S(google.maps.event.addListener(C, "mouseup", f)));
  }, [f]), h(() => {
    C && typeof m == "function" && (W !== null && google.maps.event.removeListener(W), O(google.maps.event.addListener(C, "rightclick", m)));
  }, [m]), h(() => {
    C && typeof b == "function" && (j !== null && google.maps.event.removeListener(j), U(google.maps.event.addListener(C, "click", b)));
  }, [b]), h(() => {
    C && typeof E == "function" && (T !== null && google.maps.event.removeListener(T), q(google.maps.event.addListener(C, "drag", E)));
  }, [E]), h(() => {
    var A = new google.maps.Polygon(FW(FW({}, t), {}, {
      map: v
    }));
    return i && A.setPath(i), a && A.setPaths(a), typeof o < "u" && A.setVisible(o), typeof r < "u" && A.setEditable(r), typeof n < "u" && A.setDraggable(n), s && L(google.maps.event.addListener(A, "dblclick", s)), l && N(google.maps.event.addListener(A, "dragend", l)), u && V(google.maps.event.addListener(A, "dragstart", u)), c && Z(google.maps.event.addListener(A, "mousedown", c)), p && Y(google.maps.event.addListener(A, "mousemove", p)), d && J(google.maps.event.addListener(A, "mouseout", d)), g && D(google.maps.event.addListener(A, "mouseover", g)), f && S(google.maps.event.addListener(A, "mouseup", f)), m && O(google.maps.event.addListener(A, "rightclick", m)), b && U(google.maps.event.addListener(A, "click", b)), E && q(google.maps.event.addListener(A, "drag", E)), P(A), w && w(A), () => {
      F !== null && google.maps.event.removeListener(F), B !== null && google.maps.event.removeListener(B), $ !== null && google.maps.event.removeListener($), H !== null && google.maps.event.removeListener(H), K !== null && google.maps.event.removeListener(K), Q !== null && google.maps.event.removeListener(Q), _ !== null && google.maps.event.removeListener(_), z !== null && google.maps.event.removeListener(z), W !== null && google.maps.event.removeListener(W), j !== null && google.maps.event.removeListener(j), M && M(A), A.setMap(null);
    };
  }, []), null;
}
me(ARe);
class RRe extends pe {
  constructor() {
    super(...arguments), Pe(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this.props.options || {};
    this.polygon = new google.maps.Polygon(t), this.polygon.setMap(this.context), this.registeredEvents = bn({
      updaterMap: UW,
      eventMap: zW,
      prevProps: {},
      nextProps: this.props,
      instance: this.polygon
    }), this.props.onLoad && this.props.onLoad(this.polygon);
  }
  componentDidUpdate(t) {
    this.polygon && (Ln(this.registeredEvents), this.registeredEvents = bn({
      updaterMap: UW,
      eventMap: zW,
      prevProps: t,
      nextProps: this.props,
      instance: this.polygon
    }));
  }
  componentWillUnmount() {
    this.polygon && (this.props.onUnmount && this.props.onUnmount(this.polygon), Ln(this.registeredEvents), this.polygon && this.polygon.setMap(null));
  }
  render() {
    return null;
  }
}
Pe(RRe, "contextType", Nt);
function HW(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function nw(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? HW(Object(n), !0).forEach(function(r) {
      Pe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : HW(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var WW = {
  onBoundsChanged: "bounds_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, $W = {
  bounds(e, t) {
    e.setBounds(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function IRe(e) {
  var {
    options: t,
    bounds: n,
    draggable: r,
    editable: o,
    visible: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: g,
    onRightClick: f,
    onClick: m,
    onDrag: b,
    onBoundsChanged: E,
    onLoad: w,
    onUnmount: M
  } = e, x = ge(Nt), [v, C] = k(null), [P, F] = k(null), [L, B] = k(null), [N, $] = k(null), [V, H] = k(null), [Z, K] = k(null), [Y, Q] = k(null), [J, _] = k(null), [D, z] = k(null), [S, W] = k(null), [O, j] = k(null), [U, T] = k(null), [q, A] = k(null);
  return h(() => {
    v !== null && v.setMap(x);
  }, [x]), h(() => {
    typeof t < "u" && v !== null && v.setOptions(t);
  }, [v, t]), h(() => {
    typeof r < "u" && v !== null && v.setDraggable(r);
  }, [v, r]), h(() => {
    typeof o < "u" && v !== null && v.setEditable(o);
  }, [v, o]), h(() => {
    typeof i < "u" && v !== null && v.setVisible(i);
  }, [v, i]), h(() => {
    typeof n < "u" && v !== null && v.setBounds(n);
  }, [v, n]), h(() => {
    v && a && (P !== null && google.maps.event.removeListener(P), F(google.maps.event.addListener(v, "dblclick", a)));
  }, [a]), h(() => {
    v && s && (L !== null && google.maps.event.removeListener(L), B(google.maps.event.addListener(v, "dragend", s)));
  }, [s]), h(() => {
    v && l && (N !== null && google.maps.event.removeListener(N), $(google.maps.event.addListener(v, "dragstart", l)));
  }, [l]), h(() => {
    v && u && (V !== null && google.maps.event.removeListener(V), H(google.maps.event.addListener(v, "mousedown", u)));
  }, [u]), h(() => {
    v && c && (Z !== null && google.maps.event.removeListener(Z), K(google.maps.event.addListener(v, "mousemove", c)));
  }, [c]), h(() => {
    v && p && (Y !== null && google.maps.event.removeListener(Y), Q(google.maps.event.addListener(v, "mouseout", p)));
  }, [p]), h(() => {
    v && d && (J !== null && google.maps.event.removeListener(J), _(google.maps.event.addListener(v, "mouseover", d)));
  }, [d]), h(() => {
    v && g && (D !== null && google.maps.event.removeListener(D), z(google.maps.event.addListener(v, "mouseup", g)));
  }, [g]), h(() => {
    v && f && (S !== null && google.maps.event.removeListener(S), W(google.maps.event.addListener(v, "rightclick", f)));
  }, [f]), h(() => {
    v && m && (O !== null && google.maps.event.removeListener(O), j(google.maps.event.addListener(v, "click", m)));
  }, [m]), h(() => {
    v && b && (U !== null && google.maps.event.removeListener(U), T(google.maps.event.addListener(v, "drag", b)));
  }, [b]), h(() => {
    v && E && (q !== null && google.maps.event.removeListener(q), A(google.maps.event.addListener(v, "bounds_changed", E)));
  }, [E]), h(() => {
    var X = new google.maps.Rectangle(nw(nw({}, t), {}, {
      map: x
    }));
    return typeof i < "u" && X.setVisible(i), typeof o < "u" && X.setEditable(o), typeof r < "u" && X.setDraggable(r), typeof n < "u" && X.setBounds(n), a && F(google.maps.event.addListener(X, "dblclick", a)), s && B(google.maps.event.addListener(X, "dragend", s)), l && $(google.maps.event.addListener(X, "dragstart", l)), u && H(google.maps.event.addListener(X, "mousedown", u)), c && K(google.maps.event.addListener(X, "mousemove", c)), p && Q(google.maps.event.addListener(X, "mouseout", p)), d && _(google.maps.event.addListener(X, "mouseover", d)), g && z(google.maps.event.addListener(X, "mouseup", g)), f && W(google.maps.event.addListener(X, "rightclick", f)), m && j(google.maps.event.addListener(X, "click", m)), b && T(google.maps.event.addListener(X, "drag", b)), E && A(google.maps.event.addListener(X, "bounds_changed", E)), C(X), w && w(X), () => {
      P !== null && google.maps.event.removeListener(P), L !== null && google.maps.event.removeListener(L), N !== null && google.maps.event.removeListener(N), V !== null && google.maps.event.removeListener(V), Z !== null && google.maps.event.removeListener(Z), Y !== null && google.maps.event.removeListener(Y), J !== null && google.maps.event.removeListener(J), D !== null && google.maps.event.removeListener(D), S !== null && google.maps.event.removeListener(S), O !== null && google.maps.event.removeListener(O), U !== null && google.maps.event.removeListener(U), q !== null && google.maps.event.removeListener(q), M && M(X), X.setMap(null);
    };
  }, []), null;
}
me(IRe);
class NRe extends pe {
  constructor() {
    super(...arguments), Pe(this, "registeredEvents", []), Pe(this, "state", {
      rectangle: null
    }), Pe(this, "setRectangleCallback", () => {
      this.state.rectangle !== null && this.props.onLoad && this.props.onLoad(this.state.rectangle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Rectangle(nw(nw({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = bn({
      updaterMap: $W,
      eventMap: WW,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        rectangle: t
      };
    }, this.setRectangleCallback);
  }
  componentDidUpdate(t) {
    this.state.rectangle !== null && (Ln(this.registeredEvents), this.registeredEvents = bn({
      updaterMap: $W,
      eventMap: WW,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.rectangle
    }));
  }
  componentWillUnmount() {
    this.state.rectangle !== null && (this.props.onUnmount && this.props.onUnmount(this.state.rectangle), Ln(this.registeredEvents), this.state.rectangle.setMap(null));
  }
  render() {
    return null;
  }
}
Pe(NRe, "contextType", Nt);
function VW(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function rw(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? VW(Object(n), !0).forEach(function(r) {
      Pe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : VW(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var ZW = {
  onCenterChanged: "center_changed",
  onRadiusChanged: "radius_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, qW = {
  center(e, t) {
    e.setCenter(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  radius(e, t) {
    e.setRadius(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, BRe = {};
function FRe(e) {
  var {
    options: t,
    center: n,
    radius: r,
    draggable: o,
    editable: i,
    visible: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: g,
    onMouseUp: f,
    onRightClick: m,
    onClick: b,
    onDrag: E,
    onCenterChanged: w,
    onRadiusChanged: M,
    onLoad: x,
    onUnmount: v
  } = e, C = ge(Nt), [P, F] = k(null), [L, B] = k(null), [N, $] = k(null), [V, H] = k(null), [Z, K] = k(null), [Y, Q] = k(null), [J, _] = k(null), [D, z] = k(null), [S, W] = k(null), [O, j] = k(null), [U, T] = k(null), [q, A] = k(null), [X, I] = k(null), [le, he] = k(null);
  return h(() => {
    P !== null && P.setMap(C);
  }, [C]), h(() => {
    typeof t < "u" && P !== null && P.setOptions(t);
  }, [P, t]), h(() => {
    typeof o < "u" && P !== null && P.setDraggable(o);
  }, [P, o]), h(() => {
    typeof i < "u" && P !== null && P.setEditable(i);
  }, [P, i]), h(() => {
    typeof a < "u" && P !== null && P.setVisible(a);
  }, [P, a]), h(() => {
    typeof r == "number" && P !== null && P.setRadius(r);
  }, [P, r]), h(() => {
    typeof n < "u" && P !== null && P.setCenter(n);
  }, [P, n]), h(() => {
    P && s && (L !== null && google.maps.event.removeListener(L), B(google.maps.event.addListener(P, "dblclick", s)));
  }, [s]), h(() => {
    P && l && (N !== null && google.maps.event.removeListener(N), $(google.maps.event.addListener(P, "dragend", l)));
  }, [l]), h(() => {
    P && u && (V !== null && google.maps.event.removeListener(V), H(google.maps.event.addListener(P, "dragstart", u)));
  }, [u]), h(() => {
    P && c && (Z !== null && google.maps.event.removeListener(Z), K(google.maps.event.addListener(P, "mousedown", c)));
  }, [c]), h(() => {
    P && p && (Y !== null && google.maps.event.removeListener(Y), Q(google.maps.event.addListener(P, "mousemove", p)));
  }, [p]), h(() => {
    P && d && (J !== null && google.maps.event.removeListener(J), _(google.maps.event.addListener(P, "mouseout", d)));
  }, [d]), h(() => {
    P && g && (D !== null && google.maps.event.removeListener(D), z(google.maps.event.addListener(P, "mouseover", g)));
  }, [g]), h(() => {
    P && f && (S !== null && google.maps.event.removeListener(S), W(google.maps.event.addListener(P, "mouseup", f)));
  }, [f]), h(() => {
    P && m && (O !== null && google.maps.event.removeListener(O), j(google.maps.event.addListener(P, "rightclick", m)));
  }, [m]), h(() => {
    P && b && (U !== null && google.maps.event.removeListener(U), T(google.maps.event.addListener(P, "click", b)));
  }, [b]), h(() => {
    P && E && (q !== null && google.maps.event.removeListener(q), A(google.maps.event.addListener(P, "drag", E)));
  }, [E]), h(() => {
    P && w && (X !== null && google.maps.event.removeListener(X), I(google.maps.event.addListener(P, "center_changed", w)));
  }, [b]), h(() => {
    P && M && (le !== null && google.maps.event.removeListener(le), he(google.maps.event.addListener(P, "radius_changed", M)));
  }, [M]), h(() => {
    var oe = new google.maps.Circle(rw(rw({}, t || BRe), {}, {
      map: C
    }));
    return typeof r == "number" && oe.setRadius(r), typeof n < "u" && oe.setCenter(n), typeof r == "number" && oe.setRadius(r), typeof a < "u" && oe.setVisible(a), typeof i < "u" && oe.setEditable(i), typeof o < "u" && oe.setDraggable(o), s && B(google.maps.event.addListener(oe, "dblclick", s)), l && $(google.maps.event.addListener(oe, "dragend", l)), u && H(google.maps.event.addListener(oe, "dragstart", u)), c && K(google.maps.event.addListener(oe, "mousedown", c)), p && Q(google.maps.event.addListener(oe, "mousemove", p)), d && _(google.maps.event.addListener(oe, "mouseout", d)), g && z(google.maps.event.addListener(oe, "mouseover", g)), f && W(google.maps.event.addListener(oe, "mouseup", f)), m && j(google.maps.event.addListener(oe, "rightclick", m)), b && T(google.maps.event.addListener(oe, "click", b)), E && A(google.maps.event.addListener(oe, "drag", E)), w && I(google.maps.event.addListener(oe, "center_changed", w)), M && he(google.maps.event.addListener(oe, "radius_changed", M)), F(oe), x && x(oe), () => {
      L !== null && google.maps.event.removeListener(L), N !== null && google.maps.event.removeListener(N), V !== null && google.maps.event.removeListener(V), Z !== null && google.maps.event.removeListener(Z), Y !== null && google.maps.event.removeListener(Y), J !== null && google.maps.event.removeListener(J), D !== null && google.maps.event.removeListener(D), S !== null && google.maps.event.removeListener(S), O !== null && google.maps.event.removeListener(O), U !== null && google.maps.event.removeListener(U), X !== null && google.maps.event.removeListener(X), le !== null && google.maps.event.removeListener(le), v && v(oe), oe.setMap(null);
    };
  }, []), null;
}
me(FRe);
class zRe extends pe {
  constructor() {
    super(...arguments), Pe(this, "registeredEvents", []), Pe(this, "state", {
      circle: null
    }), Pe(this, "setCircleCallback", () => {
      this.state.circle !== null && this.props.onLoad && this.props.onLoad(this.state.circle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Circle(rw(rw({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = bn({
      updaterMap: qW,
      eventMap: ZW,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        circle: t
      };
    }, this.setCircleCallback);
  }
  componentDidUpdate(t) {
    this.state.circle !== null && (Ln(this.registeredEvents), this.registeredEvents = bn({
      updaterMap: qW,
      eventMap: ZW,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.circle
    }));
  }
  componentWillUnmount() {
    if (this.state.circle !== null) {
      var t;
      this.props.onUnmount && this.props.onUnmount(this.state.circle), Ln(this.registeredEvents), (t = this.state.circle) === null || t === void 0 || t.setMap(null);
    }
  }
  render() {
    return null;
  }
}
Pe(zRe, "contextType", Nt);
function GW(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ow(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? GW(Object(n), !0).forEach(function(r) {
      Pe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : GW(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var KW = {
  onClick: "click",
  onDblClick: "dblclick",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onAddFeature: "addfeature",
  onRemoveFeature: "removefeature",
  onRemoveProperty: "removeproperty",
  onSetGeometry: "setgeometry",
  onSetProperty: "setproperty"
}, XW = {
  add(e, t) {
    e.add(t);
  },
  addgeojson(e, t, n) {
    e.addGeoJson(t, n);
  },
  contains(e, t) {
    e.contains(t);
  },
  foreach(e, t) {
    e.forEach(t);
  },
  loadgeojson(e, t, n, r) {
    e.loadGeoJson(t, n, r);
  },
  overridestyle(e, t, n) {
    e.overrideStyle(t, n);
  },
  remove(e, t) {
    e.remove(t);
  },
  revertstyle(e, t) {
    e.revertStyle(t);
  },
  controlposition(e, t) {
    e.setControlPosition(t);
  },
  controls(e, t) {
    e.setControls(t);
  },
  drawingmode(e, t) {
    e.setDrawingMode(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  style(e, t) {
    e.setStyle(t);
  },
  togeojson(e, t) {
    e.toGeoJson(t);
  }
};
function URe(e) {
  var {
    options: t,
    onClick: n,
    onDblClick: r,
    onMouseDown: o,
    onMouseMove: i,
    onMouseOut: a,
    onMouseOver: s,
    onMouseUp: l,
    onRightClick: u,
    onAddFeature: c,
    onRemoveFeature: p,
    onRemoveProperty: d,
    onSetGeometry: g,
    onSetProperty: f,
    onLoad: m,
    onUnmount: b
  } = e, E = ge(Nt), [w, M] = k(null), [x, v] = k(null), [C, P] = k(null), [F, L] = k(null), [B, N] = k(null), [$, V] = k(null), [H, Z] = k(null), [K, Y] = k(null), [Q, J] = k(null), [_, D] = k(null), [z, S] = k(null), [W, O] = k(null), [j, U] = k(null), [T, q] = k(null);
  return h(() => {
    w !== null && w.setMap(E);
  }, [E]), h(() => {
    w && r && (x !== null && google.maps.event.removeListener(x), v(google.maps.event.addListener(w, "dblclick", r)));
  }, [r]), h(() => {
    w && o && (C !== null && google.maps.event.removeListener(C), P(google.maps.event.addListener(w, "mousedown", o)));
  }, [o]), h(() => {
    w && i && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(w, "mousemove", i)));
  }, [i]), h(() => {
    w && a && (B !== null && google.maps.event.removeListener(B), N(google.maps.event.addListener(w, "mouseout", a)));
  }, [a]), h(() => {
    w && s && ($ !== null && google.maps.event.removeListener($), V(google.maps.event.addListener(w, "mouseover", s)));
  }, [s]), h(() => {
    w && l && (H !== null && google.maps.event.removeListener(H), Z(google.maps.event.addListener(w, "mouseup", l)));
  }, [l]), h(() => {
    w && u && (K !== null && google.maps.event.removeListener(K), Y(google.maps.event.addListener(w, "rightclick", u)));
  }, [u]), h(() => {
    w && n && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(w, "click", n)));
  }, [n]), h(() => {
    w && c && (_ !== null && google.maps.event.removeListener(_), D(google.maps.event.addListener(w, "addfeature", c)));
  }, [c]), h(() => {
    w && p && (z !== null && google.maps.event.removeListener(z), S(google.maps.event.addListener(w, "removefeature", p)));
  }, [p]), h(() => {
    w && d && (W !== null && google.maps.event.removeListener(W), O(google.maps.event.addListener(w, "removeproperty", d)));
  }, [d]), h(() => {
    w && g && (j !== null && google.maps.event.removeListener(j), U(google.maps.event.addListener(w, "setgeometry", g)));
  }, [g]), h(() => {
    w && f && (T !== null && google.maps.event.removeListener(T), q(google.maps.event.addListener(w, "setproperty", f)));
  }, [f]), h(() => {
    if (E !== null) {
      var A = new google.maps.Data(ow(ow({}, t), {}, {
        map: E
      }));
      r && v(google.maps.event.addListener(A, "dblclick", r)), o && P(google.maps.event.addListener(A, "mousedown", o)), i && L(google.maps.event.addListener(A, "mousemove", i)), a && N(google.maps.event.addListener(A, "mouseout", a)), s && V(google.maps.event.addListener(A, "mouseover", s)), l && Z(google.maps.event.addListener(A, "mouseup", l)), u && Y(google.maps.event.addListener(A, "rightclick", u)), n && J(google.maps.event.addListener(A, "click", n)), c && D(google.maps.event.addListener(A, "addfeature", c)), p && S(google.maps.event.addListener(A, "removefeature", p)), d && O(google.maps.event.addListener(A, "removeproperty", d)), g && U(google.maps.event.addListener(A, "setgeometry", g)), f && q(google.maps.event.addListener(A, "setproperty", f)), M(A), m && m(A);
    }
    return () => {
      w && (x !== null && google.maps.event.removeListener(x), C !== null && google.maps.event.removeListener(C), F !== null && google.maps.event.removeListener(F), B !== null && google.maps.event.removeListener(B), $ !== null && google.maps.event.removeListener($), H !== null && google.maps.event.removeListener(H), K !== null && google.maps.event.removeListener(K), Q !== null && google.maps.event.removeListener(Q), _ !== null && google.maps.event.removeListener(_), z !== null && google.maps.event.removeListener(z), W !== null && google.maps.event.removeListener(W), j !== null && google.maps.event.removeListener(j), T !== null && google.maps.event.removeListener(T), b && b(w), w.setMap(null));
    };
  }, []), null;
}
me(URe);
class HRe extends pe {
  constructor() {
    super(...arguments), Pe(this, "registeredEvents", []), Pe(this, "state", {
      data: null
    }), Pe(this, "setDataCallback", () => {
      this.state.data !== null && this.props.onLoad && this.props.onLoad(this.state.data);
    });
  }
  componentDidMount() {
    if (this.context !== null) {
      var t = new google.maps.Data(ow(ow({}, this.props.options), {}, {
        map: this.context
      }));
      this.registeredEvents = bn({
        updaterMap: XW,
        eventMap: KW,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        data: t
      }), this.setDataCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.data !== null && (Ln(this.registeredEvents), this.registeredEvents = bn({
      updaterMap: XW,
      eventMap: KW,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.data
    }));
  }
  componentWillUnmount() {
    this.state.data !== null && (this.props.onUnmount && this.props.onUnmount(this.state.data), Ln(this.registeredEvents), this.state.data && this.state.data.setMap(null));
  }
  render() {
    return null;
  }
}
Pe(HRe, "contextType", Nt);
function YW(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function JW(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? YW(Object(n), !0).forEach(function(r) {
      Pe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : YW(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var QW = {
  onClick: "click",
  onDefaultViewportChanged: "defaultviewport_changed",
  onStatusChanged: "status_changed"
}, e$ = {
  options(e, t) {
    e.setOptions(t);
  },
  url(e, t) {
    e.setUrl(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
class WRe extends pe {
  constructor() {
    super(...arguments), Pe(this, "registeredEvents", []), Pe(this, "state", {
      kmlLayer: null
    }), Pe(this, "setKmlLayerCallback", () => {
      this.state.kmlLayer !== null && this.props.onLoad && this.props.onLoad(this.state.kmlLayer);
    });
  }
  componentDidMount() {
    var t = new google.maps.KmlLayer(JW(JW({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = bn({
      updaterMap: e$,
      eventMap: QW,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        kmlLayer: t
      };
    }, this.setKmlLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.kmlLayer !== null && (Ln(this.registeredEvents), this.registeredEvents = bn({
      updaterMap: e$,
      eventMap: QW,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.kmlLayer
    }));
  }
  componentWillUnmount() {
    this.state.kmlLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.kmlLayer), Ln(this.registeredEvents), this.state.kmlLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Pe(WRe, "contextType", Nt);
function vte(e, t) {
  return typeof t == "function" ? t(e.offsetWidth, e.offsetHeight) : {
    x: 0,
    y: 0
  };
}
function $Re(e, t) {
  return new t(e.lat, e.lng);
}
function VRe(e, t) {
  return new t(new google.maps.LatLng(e.ne.lat, e.ne.lng), new google.maps.LatLng(e.sw.lat, e.sw.lng));
}
function ZRe(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function qRe(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function GRe(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n.getNorthEast()), o = e && e.fromLatLngToDivPixel(n.getSouthWest());
  return r && o ? {
    left: "".concat(o.x + t.x, "px"),
    top: "".concat(r.y + t.y, "px"),
    width: "".concat(r.x - o.x - t.x, "px"),
    height: "".concat(o.y - r.y - t.y, "px")
  } : {
    left: "-9999px",
    top: "-9999px"
  };
}
function KRe(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n);
  if (r) {
    var {
      x: o,
      y: i
    } = r;
    return {
      left: "".concat(o + t.x, "px"),
      top: "".concat(i + t.y, "px")
    };
  }
  return {
    left: "-9999px",
    top: "-9999px"
  };
}
function yte(e, t, n, r) {
  return n !== void 0 ? GRe(e, t, qRe(n, google.maps.LatLngBounds, VRe)) : KRe(e, t, ZRe(r, google.maps.LatLng, $Re));
}
function XRe(e, t) {
  return e.left === t.left && e.top === t.top && e.width === t.height && e.height === t.height;
}
function t$(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function YRe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? t$(Object(n), !0).forEach(function(r) {
      Pe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : t$(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function JRe(e, t, n, r, o) {
  class i extends google.maps.OverlayView {
    constructor(s, l, u, c) {
      super(), this.container = s, this.pane = l, this.position = u, this.bounds = c;
    }
    onAdd() {
      var s, l = (s = this.getPanes()) === null || s === void 0 ? void 0 : s[this.pane];
      l == null || l.appendChild(this.container);
    }
    draw() {
      var s = this.getProjection(), l = YRe({}, this.container ? vte(this.container, o) : {
        x: 0,
        y: 0
      }), u = yte(s, l, this.bounds, this.position);
      for (var [c, p] of Object.entries(u))
        this.container.style[c] = p;
    }
    onRemove() {
      this.container.parentNode !== null && this.container.parentNode.removeChild(this.container);
    }
  }
  return new i(e, t, n, r);
}
function n$(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function QRe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? n$(Object(n), !0).forEach(function(r) {
      Pe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : n$(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function r$(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLng ? e : new google.maps.LatLng(e.lat, e.lng);
  return t + "";
}
function o$(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLngBounds ? e : new google.maps.LatLngBounds(new google.maps.LatLng(e.south, e.east), new google.maps.LatLng(e.north, e.west));
  return t + "";
}
function eIe(e) {
  var {
    position: t,
    bounds: n,
    mapPaneName: r,
    zIndex: o,
    onLoad: i,
    onUnmount: a,
    getPixelPositionOffset: s,
    children: l
  } = e, u = ge(Nt), c = ln(() => {
    var d = document.createElement("div");
    return d.style.position = "absolute", d;
  }, []), p = ln(() => JRe(c, r, t, n, s), [c, r, t, n]);
  return h(() => (i == null || i(p), p == null || p.setMap(u), () => {
    a == null || a(p), p == null || p.setMap(null);
  }), [u, p]), h(() => {
    c.style.zIndex = "".concat(o);
  }, [o, c]), wi.createPortal(l, c);
}
me(eIe);
class Wp extends pe {
  constructor(t) {
    super(t), Pe(this, "state", {
      paneEl: null,
      containerStyle: {
        // set initial position
        position: "absolute"
      }
    }), Pe(this, "updatePane", () => {
      var r = this.props.mapPaneName, o = this.overlayView.getPanes();
      Wo(!!r, "OverlayView requires props.mapPaneName but got %s", r), o ? this.setState({
        paneEl: o[r]
      }) : this.setState({
        paneEl: null
      });
    }), Pe(this, "onAdd", () => {
      var r, o;
      this.updatePane(), (r = (o = this.props).onLoad) === null || r === void 0 || r.call(o, this.overlayView);
    }), Pe(this, "onPositionElement", () => {
      var r = this.overlayView.getProjection(), o = QRe({
        x: 0,
        y: 0
      }, this.containerRef.current ? vte(this.containerRef.current, this.props.getPixelPositionOffset) : {}), i = yte(r, o, this.props.bounds, this.props.position);
      if (!XRe(i, {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        left: this.state.containerStyle.left,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        top: this.state.containerStyle.top,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        width: this.state.containerStyle.width,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        height: this.state.containerStyle.height
      })) {
        var a, s, l, u;
        this.setState({
          containerStyle: {
            top: (a = i.top) !== null && a !== void 0 ? a : 0,
            left: (s = i.left) !== null && s !== void 0 ? s : 0,
            width: (l = i.width) !== null && l !== void 0 ? l : 0,
            height: (u = i.height) !== null && u !== void 0 ? u : 0,
            position: "absolute"
          }
        });
      }
    }), Pe(this, "draw", () => {
      this.onPositionElement();
    }), Pe(this, "onRemove", () => {
      var r, o;
      this.setState(() => ({
        paneEl: null
      })), (r = (o = this.props).onUnmount) === null || r === void 0 || r.call(o, this.overlayView);
    }), this.containerRef = so();
    var n = new google.maps.OverlayView();
    n.onAdd = this.onAdd, n.draw = this.draw, n.onRemove = this.onRemove, this.overlayView = n;
  }
  componentDidMount() {
    this.overlayView.setMap(this.context);
  }
  componentDidUpdate(t) {
    var n = r$(t.position), r = r$(this.props.position), o = o$(t.bounds), i = o$(this.props.bounds);
    (n !== r || o !== i) && this.overlayView.draw(), t.mapPaneName !== this.props.mapPaneName && this.updatePane();
  }
  componentWillUnmount() {
    this.overlayView.setMap(null);
  }
  render() {
    var t = this.state.paneEl;
    return t ? wi.createPortal(ei.jsx("div", {
      ref: this.containerRef,
      style: this.state.containerStyle,
      children: at.only(this.props.children)
    }), t) : null;
  }
}
Pe(Wp, "FLOAT_PANE", "floatPane");
Pe(Wp, "MAP_PANE", "mapPane");
Pe(Wp, "MARKER_LAYER", "markerLayer");
Pe(Wp, "OVERLAY_LAYER", "overlayLayer");
Pe(Wp, "OVERLAY_MOUSE_TARGET", "overlayMouseTarget");
Pe(Wp, "contextType", Nt);
function tIe() {
}
function i$(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function s$(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? i$(Object(n), !0).forEach(function(r) {
      Pe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : i$(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var a$ = {
  onDblClick: "dblclick",
  onClick: "click"
}, l$ = {
  opacity(e, t) {
    e.setOpacity(t);
  }
};
function nIe(e) {
  var {
    url: t,
    bounds: n,
    options: r,
    visible: o
  } = e, i = ge(Nt), a = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east)), s = ln(() => new google.maps.GroundOverlay(t, a, r), []);
  return h(() => {
    s !== null && s.setMap(i);
  }, [i]), h(() => {
    typeof t < "u" && s !== null && (s.set("url", t), s.setMap(i));
  }, [s, t]), h(() => {
    typeof o < "u" && s !== null && s.setOpacity(o ? 1 : 0);
  }, [s, o]), h(() => {
    var l = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east));
    typeof n < "u" && s !== null && (s.set("bounds", l), s.setMap(i));
  }, [s, n]), null;
}
me(nIe);
class bte extends pe {
  constructor() {
    super(...arguments), Pe(this, "registeredEvents", []), Pe(this, "state", {
      groundOverlay: null
    }), Pe(this, "setGroundOverlayCallback", () => {
      this.state.groundOverlay !== null && this.props.onLoad && this.props.onLoad(this.state.groundOverlay);
    });
  }
  componentDidMount() {
    Wo(!!this.props.url || !!this.props.bounds, "For GroundOverlay, url and bounds are passed in to constructor and are immutable after instantiated. This is the behavior of Google Maps JavaScript API v3 ( See https://developers.google.com/maps/documentation/javascript/reference#GroundOverlay) Hence, use the corresponding two props provided by `react-google-maps-api`, url and bounds. In some cases, you'll need the GroundOverlay component to reflect the changes of url and bounds. You can leverage the React's key property to remount the component. Typically, just `key={url}` would serve your need. See https://github.com/tomchentw/react-google-maps/issues/655");
    var t = new google.maps.GroundOverlay(this.props.url, this.props.bounds, s$(s$({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = bn({
      updaterMap: l$,
      eventMap: a$,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        groundOverlay: t
      };
    }, this.setGroundOverlayCallback);
  }
  componentDidUpdate(t) {
    this.state.groundOverlay !== null && (Ln(this.registeredEvents), this.registeredEvents = bn({
      updaterMap: l$,
      eventMap: a$,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.groundOverlay
    }));
  }
  componentWillUnmount() {
    this.state.groundOverlay && (this.props.onUnmount && this.props.onUnmount(this.state.groundOverlay), this.state.groundOverlay.setMap(null));
  }
  render() {
    return null;
  }
}
Pe(bte, "defaultProps", {
  onLoad: tIe
});
Pe(bte, "contextType", Nt);
function u$(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function iw(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? u$(Object(n), !0).forEach(function(r) {
      Pe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : u$(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var c$ = {}, p$ = {
  data(e, t) {
    e.setData(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function rIe(e) {
  var {
    data: t,
    onLoad: n,
    onUnmount: r,
    options: o
  } = e, i = ge(Nt), [a, s] = k(null);
  return h(() => {
    google.maps.visualization || Wo(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} in useJsApiScript? %s', google.maps.visualization);
  }, []), h(() => {
    Wo(!!t, "data property is required in HeatmapLayer %s", t);
  }, [t]), h(() => {
    a !== null && a.setMap(i);
  }, [i]), h(() => {
    o && a !== null && a.setOptions(o);
  }, [a, o]), h(() => {
    var l = new google.maps.visualization.HeatmapLayer(iw(iw({}, o), {}, {
      data: t,
      map: i
    }));
    return s(l), n && n(l), () => {
      a !== null && (r && r(a), a.setMap(null));
    };
  }, []), null;
}
me(rIe);
class oIe extends pe {
  constructor() {
    super(...arguments), Pe(this, "registeredEvents", []), Pe(this, "state", {
      heatmapLayer: null
    }), Pe(this, "setHeatmapLayerCallback", () => {
      this.state.heatmapLayer !== null && this.props.onLoad && this.props.onLoad(this.state.heatmapLayer);
    });
  }
  componentDidMount() {
    Wo(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} to <LoadScript />? %s', google.maps.visualization), Wo(!!this.props.data, "data property is required in HeatmapLayer %s", this.props.data);
    var t = new google.maps.visualization.HeatmapLayer(iw(iw({}, this.props.options), {}, {
      data: this.props.data,
      map: this.context
    }));
    this.registeredEvents = bn({
      updaterMap: p$,
      eventMap: c$,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        heatmapLayer: t
      };
    }, this.setHeatmapLayerCallback);
  }
  componentDidUpdate(t) {
    Ln(this.registeredEvents), this.registeredEvents = bn({
      updaterMap: p$,
      eventMap: c$,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.heatmapLayer
    });
  }
  componentWillUnmount() {
    this.state.heatmapLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.heatmapLayer), Ln(this.registeredEvents), this.state.heatmapLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Pe(oIe, "contextType", Nt);
var d$ = {
  onCloseClick: "closeclick",
  onPanoChanged: "pano_changed",
  onPositionChanged: "position_changed",
  onPovChanged: "pov_changed",
  onResize: "resize",
  onStatusChanged: "status_changed",
  onVisibleChanged: "visible_changed",
  onZoomChanged: "zoom_changed"
}, f$ = {
  register(e, t, n) {
    e.registerPanoProvider(t, n);
  },
  links(e, t) {
    e.setLinks(t);
  },
  motionTracking(e, t) {
    e.setMotionTracking(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  pano(e, t) {
    e.setPano(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  pov(e, t) {
    e.setPov(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zoom(e, t) {
    e.setZoom(t);
  }
};
class iIe extends pe {
  constructor() {
    super(...arguments), Pe(this, "registeredEvents", []), Pe(this, "state", {
      streetViewPanorama: null
    }), Pe(this, "setStreetViewPanoramaCallback", () => {
      this.state.streetViewPanorama !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewPanorama);
    });
  }
  componentDidMount() {
    var t, n, r = (t = (n = this.context) === null || n === void 0 ? void 0 : n.getStreetView()) !== null && t !== void 0 ? t : null;
    this.registeredEvents = bn({
      updaterMap: f$,
      eventMap: d$,
      prevProps: {},
      nextProps: this.props,
      instance: r
    }), this.setState(() => ({
      streetViewPanorama: r
    }), this.setStreetViewPanoramaCallback);
  }
  componentDidUpdate(t) {
    this.state.streetViewPanorama !== null && (Ln(this.registeredEvents), this.registeredEvents = bn({
      updaterMap: f$,
      eventMap: d$,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.streetViewPanorama
    }));
  }
  componentWillUnmount() {
    this.state.streetViewPanorama !== null && (this.props.onUnmount && this.props.onUnmount(this.state.streetViewPanorama), Ln(this.registeredEvents), this.state.streetViewPanorama.setVisible(!1));
  }
  render() {
    return null;
  }
}
Pe(iIe, "contextType", Nt);
class sIe extends pe {
  constructor() {
    super(...arguments), Pe(this, "state", {
      streetViewService: null
    }), Pe(this, "setStreetViewServiceCallback", () => {
      this.state.streetViewService !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewService);
    });
  }
  componentDidMount() {
    var t = new google.maps.StreetViewService();
    this.setState(function() {
      return {
        streetViewService: t
      };
    }, this.setStreetViewServiceCallback);
  }
  componentWillUnmount() {
    this.state.streetViewService !== null && this.props.onUnmount && this.props.onUnmount(this.state.streetViewService);
  }
  render() {
    return null;
  }
}
Pe(sIe, "contextType", Nt);
var h$ = {
  onDirectionsChanged: "directions_changed"
}, g$ = {
  directions(e, t) {
    e.setDirections(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  panel(e, t) {
    e.setPanel(t);
  },
  routeIndex(e, t) {
    e.setRouteIndex(t);
  }
};
class aIe extends pe {
  constructor() {
    super(...arguments), Pe(this, "registeredEvents", []), Pe(this, "state", {
      directionsRenderer: null
    }), Pe(this, "setDirectionsRendererCallback", () => {
      this.state.directionsRenderer !== null && (this.state.directionsRenderer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.directionsRenderer));
    });
  }
  componentDidMount() {
    var t = new google.maps.DirectionsRenderer(this.props.options);
    this.registeredEvents = bn({
      updaterMap: g$,
      eventMap: h$,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        directionsRenderer: t
      };
    }, this.setDirectionsRendererCallback);
  }
  componentDidUpdate(t) {
    this.state.directionsRenderer !== null && (Ln(this.registeredEvents), this.registeredEvents = bn({
      updaterMap: g$,
      eventMap: h$,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.directionsRenderer
    }));
  }
  componentWillUnmount() {
    this.state.directionsRenderer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.directionsRenderer), Ln(this.registeredEvents), this.state.directionsRenderer && this.state.directionsRenderer.setMap(null));
  }
  render() {
    return null;
  }
}
Pe(aIe, "contextType", Nt);
var m$ = {
  onPlacesChanged: "places_changed"
}, v$ = {
  bounds(e, t) {
    e.setBounds(t);
  }
};
class lIe extends pe {
  constructor() {
    super(...arguments), Pe(this, "registeredEvents", []), Pe(this, "containerElement", so()), Pe(this, "state", {
      searchBox: null
    }), Pe(this, "setSearchBoxCallback", () => {
      this.state.searchBox !== null && this.props.onLoad && this.props.onLoad(this.state.searchBox);
    });
  }
  componentDidMount() {
    if (Wo(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places), this.containerElement !== null && this.containerElement.current !== null) {
      var t = this.containerElement.current.querySelector("input");
      if (t !== null) {
        var n = new google.maps.places.SearchBox(t, this.props.options);
        this.registeredEvents = bn({
          updaterMap: v$,
          eventMap: m$,
          prevProps: {},
          nextProps: this.props,
          instance: n
        }), this.setState(function() {
          return {
            searchBox: n
          };
        }, this.setSearchBoxCallback);
      }
    }
  }
  componentDidUpdate(t) {
    this.state.searchBox !== null && (Ln(this.registeredEvents), this.registeredEvents = bn({
      updaterMap: v$,
      eventMap: m$,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.searchBox
    }));
  }
  componentWillUnmount() {
    this.state.searchBox !== null && (this.props.onUnmount && this.props.onUnmount(this.state.searchBox), Ln(this.registeredEvents));
  }
  render() {
    return ei.jsx("div", {
      ref: this.containerElement,
      children: at.only(this.props.children)
    });
  }
}
Pe(lIe, "contextType", Nt);
var y$ = {
  onPlaceChanged: "place_changed"
}, b$ = {
  bounds(e, t) {
    e.setBounds(t);
  },
  restrictions(e, t) {
    e.setComponentRestrictions(t);
  },
  fields(e, t) {
    e.setFields(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  types(e, t) {
    e.setTypes(t);
  }
};
class wte extends pe {
  constructor() {
    super(...arguments), Pe(this, "registeredEvents", []), Pe(this, "containerElement", so()), Pe(this, "state", {
      autocomplete: null
    }), Pe(this, "setAutocompleteCallback", () => {
      this.state.autocomplete !== null && this.props.onLoad && this.props.onLoad(this.state.autocomplete);
    });
  }
  componentDidMount() {
    var t;
    Wo(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places);
    var n = (t = this.containerElement.current) === null || t === void 0 ? void 0 : t.querySelector("input");
    if (n) {
      var r = new google.maps.places.Autocomplete(n, this.props.options);
      this.registeredEvents = bn({
        updaterMap: b$,
        eventMap: y$,
        prevProps: {},
        nextProps: this.props,
        instance: r
      }), this.setState(() => ({
        autocomplete: r
      }), this.setAutocompleteCallback);
    }
  }
  componentDidUpdate(t) {
    Ln(this.registeredEvents), this.registeredEvents = bn({
      updaterMap: b$,
      eventMap: y$,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.autocomplete
    });
  }
  componentWillUnmount() {
    this.state.autocomplete !== null && Ln(this.registeredEvents);
  }
  render() {
    return ei.jsx("div", {
      ref: this.containerElement,
      className: this.props.className,
      children: at.only(this.props.children)
    });
  }
}
Pe(wte, "defaultProps", {
  className: ""
});
Pe(wte, "contextType", Nt);
let uIe = { data: "" }, cIe = (e) => typeof window == "object" ? ((e ? e.querySelector("#_goober") : window._goober) || Object.assign((e || document.head).appendChild(document.createElement("style")), { innerHTML: " ", id: "_goober" })).firstChild : e || uIe, pIe = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g, dIe = /\/\*[^]*?\*\/|  +/g, w$ = /\n+/g, Yl = (e, t) => {
  let n = "", r = "", o = "";
  for (let i in e) {
    let a = e[i];
    i[0] == "@" ? i[1] == "i" ? n = i + " " + a + ";" : r += i[1] == "f" ? Yl(a, i) : i + "{" + Yl(a, i[1] == "k" ? "" : t) + "}" : typeof a == "object" ? r += Yl(a, t ? t.replace(/([^,])+/g, (s) => i.replace(/([^,]*:\S+\([^)]*\))|([^,])+/g, (l) => /&/.test(l) ? l.replace(/&/g, s) : s ? s + " " + l : l)) : i) : a != null && (i = /^--/.test(i) ? i : i.replace(/[A-Z]/g, "-$&").toLowerCase(), o += Yl.p ? Yl.p(i, a) : i + ":" + a + ";");
  }
  return n + (t && o ? t + "{" + o + "}" : o) + r;
}, Ra = {}, Cte = (e) => {
  if (typeof e == "object") {
    let t = "";
    for (let n in e) t += n + Cte(e[n]);
    return t;
  }
  return e;
}, fIe = (e, t, n, r, o) => {
  let i = Cte(e), a = Ra[i] || (Ra[i] = ((l) => {
    let u = 0, c = 11;
    for (; u < l.length; ) c = 101 * c + l.charCodeAt(u++) >>> 0;
    return "go" + c;
  })(i));
  if (!Ra[a]) {
    let l = i !== e ? e : ((u) => {
      let c, p, d = [{}];
      for (; c = pIe.exec(u.replace(dIe, "")); ) c[4] ? d.shift() : c[3] ? (p = c[3].replace(w$, " ").trim(), d.unshift(d[0][p] = d[0][p] || {})) : d[0][c[1]] = c[2].replace(w$, " ").trim();
      return d[0];
    })(e);
    Ra[a] = Yl(o ? { ["@keyframes " + a]: l } : l, n ? "" : "." + a);
  }
  let s = n && Ra.g ? Ra.g : null;
  return n && (Ra.g = Ra[a]), ((l, u, c, p) => {
    p ? u.data = u.data.replace(p, l) : u.data.indexOf(l) === -1 && (u.data = c ? l + u.data : u.data + l);
  })(Ra[a], t, r, s), a;
}, hIe = (e, t, n) => e.reduce((r, o, i) => {
  let a = t[i];
  if (a && a.call) {
    let s = a(n), l = s && s.props && s.props.className || /^go/.test(s) && s;
    a = l ? "." + l : s && typeof s == "object" ? s.props ? "" : Yl(s, "") : s === !1 ? "" : s;
  }
  return r + o + (a ?? "");
}, "");
function mO(e) {
  let t = this || {}, n = e.call ? e(t.p) : e;
  return fIe(n.unshift ? n.raw ? hIe(n, [].slice.call(arguments, 1), t.p) : n.reduce((r, o) => Object.assign(r, o && o.call ? o(t.p) : o), {}) : n, cIe(t.target), t.g, t.o, t.k);
}
let Ote, K_, X_;
mO.bind({ g: 1 });
let Ja = mO.bind({ k: 1 });
function gIe(e, t, n, r) {
  Yl.p = t, Ote = e, K_ = n, X_ = r;
}
function Lu(e, t) {
  let n = this || {};
  return function() {
    let r = arguments;
    function o(i, a) {
      let s = Object.assign({}, i), l = s.className || o.className;
      n.p = Object.assign({ theme: K_ && K_() }, s), n.o = / *go\d+/.test(l), s.className = mO.apply(n, r) + (l ? " " + l : "");
      let u = e;
      return e[0] && (u = s.as || e, delete s.as), X_ && u[0] && X_(s), Ote(u, s);
    }
    return o;
  };
}
var mIe = (e) => typeof e == "function", vIe = (e, t) => mIe(e) ? e(t) : e, yIe = /* @__PURE__ */ (() => {
  let e;
  return () => {
    if (e === void 0 && typeof window < "u") {
      let t = matchMedia("(prefers-reduced-motion: reduce)");
      e = !t || t.matches;
    }
    return e;
  };
})(), bIe = Ja`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`, wIe = Ja`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`, CIe = Ja`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`, OIe = Lu("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${bIe} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${wIe} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${(e) => e.secondary || "#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${CIe} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`, xIe = Ja`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, EIe = Lu("div")`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${(e) => e.secondary || "#e0e0e0"};
  border-right-color: ${(e) => e.primary || "#616161"};
  animation: ${xIe} 1s linear infinite;
`, kIe = Ja`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`, LIe = Ja`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`, _Ie = Lu("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${kIe} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${LIe} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${(e) => e.secondary || "#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`, PIe = Lu("div")`
  position: absolute;
`, SIe = Lu("div")`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`, MIe = Ja`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`, DIe = Lu("div")`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${MIe} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`, TIe = ({ toast: e }) => {
  let { icon: t, type: n, iconTheme: r } = e;
  return t !== void 0 ? typeof t == "string" ? Ne.createElement(DIe, null, t) : t : n === "blank" ? null : Ne.createElement(SIe, null, Ne.createElement(EIe, { ...r }), n !== "loading" && Ne.createElement(PIe, null, n === "error" ? Ne.createElement(OIe, { ...r }) : Ne.createElement(_Ie, { ...r })));
}, jIe = (e) => `
0% {transform: translate3d(0,${e * -200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`, AIe = (e) => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${e * -150}%,-1px) scale(.6); opacity:0;}
`, RIe = "0%{opacity:0;} 100%{opacity:1;}", IIe = "0%{opacity:1;} 100%{opacity:0;}", NIe = Lu("div")`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`, BIe = Lu("div")`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`, FIe = (e, t) => {
  let n = e.includes("top") ? 1 : -1, [r, o] = yIe() ? [RIe, IIe] : [jIe(n), AIe(n)];
  return { animation: t ? `${Ja(r)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards` : `${Ja(o)} 0.4s forwards cubic-bezier(.06,.71,.55,1)` };
};
Ne.memo(({ toast: e, position: t, style: n, children: r }) => {
  let o = e.height ? FIe(e.position || t || "top-center", e.visible) : { opacity: 0 }, i = Ne.createElement(TIe, { toast: e }), a = Ne.createElement(BIe, { ...e.ariaProps }, vIe(e.message, e));
  return Ne.createElement(NIe, { className: e.className, style: { ...o, ...n, ...e.style } }, typeof r == "function" ? r({ icon: i, message: a }) : Ne.createElement(Ne.Fragment, null, i, a));
});
gIe(Ne.createElement);
mO`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`;
$e({});
function zIe(e) {
  return e && e.replace(/[^0-9]/g, "");
}
const UIe = {
  CNPJ: "99.999.999/9999-99"
};
zIe(UIe.CNPJ).length;
Cr((e, t) => /* @__PURE__ */ Qo.jsx("input", { ref: t, ...e }));
function xte(e) {
  return e && e.replace(/[^0-9]/g, "");
}
const Ete = {
  EIGTH: "(99) 9999-9999",
  NINE: "(99) 99999-9999"
};
function HIe(e, t) {
  let n = "", r = 0;
  for (let o = 0; o < t.length; o++)
    if (t[o] === "9")
      if (r < e.length)
        n += e[r], r++;
      else
        break;
    else if (r < e.length)
      n += t[o];
    else
      break;
  return n;
}
function WIe(e) {
  return e.length > 10 ? "NINE" : "EIGTH";
}
const $Ie = xte(Ete.NINE).length, VIe = Cr((e, t) => /* @__PURE__ */ Qo.jsx("input", { ref: t, ...e }));
Cr(
  (e, t) => {
    const { onFocus: n, onBlur: r, size: o, onChange: i, value: a, currentCountry: s, disabled: l } = e, [u, c] = k(!1);
    h(() => {
      u ? i(s.mask) : c(!0);
    }, [s]);
    const p = `phoneInputMask ${o}`;
    function d(g) {
      let f = xte(g.target.value);
      const m = WIe(f);
      f.length > $Ie || (f = HIe(f, Ete[m]), g.target.value = f, i(f));
    }
    return s.code === "+55" ? /* @__PURE__ */ Qo.jsx(
      "input",
      {
        value: a,
        onChange: d,
        className: p,
        onFocus: n,
        onBlur: r,
        disabled: l,
        ref: t
      }
    ) : /* @__PURE__ */ Qo.jsx(
      ol,
      {
        value: a,
        onChange: (g) => i(g.target.value),
        className: p,
        component: VIe,
        onFocus: n,
        onBlur: r,
        disabled: l,
        mask: s.mask,
        showMask: !0,
        replacement: { _: /\d/ },
        ref: t
      }
    );
  }
);
$e({});
var ul = {};
Object.defineProperty(ul, "__esModule", {
  value: !0
});
var ZIe = typeof window < "u" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform), JE = {
  alt: "altKey",
  control: "ctrlKey",
  meta: "metaKey",
  shift: "shiftKey"
}, kte = {
  add: "+",
  break: "pause",
  cmd: "meta",
  command: "meta",
  ctl: "control",
  ctrl: "control",
  del: "delete",
  down: "arrowdown",
  esc: "escape",
  ins: "insert",
  left: "arrowleft",
  mod: ZIe ? "meta" : "control",
  opt: "alt",
  option: "alt",
  return: "enter",
  right: "arrowright",
  space: " ",
  spacebar: " ",
  up: "arrowup",
  win: "meta",
  windows: "meta"
}, iT = {
  backspace: 8,
  tab: 9,
  enter: 13,
  shift: 16,
  control: 17,
  alt: 18,
  pause: 19,
  capslock: 20,
  escape: 27,
  " ": 32,
  pageup: 33,
  pagedown: 34,
  end: 35,
  home: 36,
  arrowleft: 37,
  arrowup: 38,
  arrowright: 39,
  arrowdown: 40,
  insert: 45,
  delete: 46,
  meta: 91,
  numlock: 144,
  scrolllock: 145,
  ";": 186,
  "=": 187,
  ",": 188,
  "-": 189,
  ".": 190,
  "/": 191,
  "`": 192,
  "[": 219,
  "\\": 220,
  "]": 221,
  "'": 222
};
for (var wv = 1; wv < 20; wv++)
  iT["f" + wv] = 111 + wv;
function vO(e, t, n) {
  t && !("byKey" in t) && (n = t, t = null), Array.isArray(e) || (e = [e]);
  var r = e.map(function(a) {
    return Lte(a, t);
  }), o = function(a) {
    return r.some(function(s) {
      return _te(s, a);
    });
  }, i = n == null ? o : o(n);
  return i;
}
function qIe(e, t) {
  return vO(e, t);
}
function GIe(e, t) {
  return vO(e, { byKey: !0 }, t);
}
function Lte(e, t) {
  var n = t && t.byKey, r = {};
  e = e.replace("++", "+add");
  var o = e.split("+"), i = o.length;
  for (var a in JE)
    r[JE[a]] = !1;
  var s = !0, l = !1, u = void 0;
  try {
    for (var c = o[Symbol.iterator](), p; !(s = (p = c.next()).done); s = !0) {
      var d = p.value, g = d.endsWith("?") && d.length > 1;
      g && (d = d.slice(0, -1));
      var f = sT(d), m = JE[f];
      if (d.length > 1 && !m && !kte[d] && !iT[f])
        throw new TypeError('Unknown modifier: "' + d + '"');
      (i === 1 || !m) && (n ? r.key = f : r.which = Pte(d)), m && (r[m] = g ? null : !0);
    }
  } catch (b) {
    l = !0, u = b;
  } finally {
    try {
      !s && c.return && c.return();
    } finally {
      if (l)
        throw u;
    }
  }
  return r;
}
function _te(e, t) {
  for (var n in e) {
    var r = e[n], o = void 0;
    if (r != null && (n === "key" && t.key != null ? o = t.key.toLowerCase() : n === "which" ? o = r === 91 && t.which === 93 ? 91 : t.which : o = t[n], !(o == null && r === !1) && o !== r))
      return !1;
  }
  return !0;
}
function Pte(e) {
  e = sT(e);
  var t = iT[e] || e.toUpperCase().charCodeAt(0);
  return t;
}
function sT(e) {
  return e = e.toLowerCase(), e = kte[e] || e, e;
}
ul.default = vO;
var QE = ul.isHotkey = vO;
ul.isCodeHotkey = qIe;
ul.isKeyHotkey = GIe;
ul.parseHotkey = Lte;
ul.compareHotkey = _te;
ul.toKeyCode = Pte;
ul.toKeyName = sT;
var KIe = typeof vr == "object" && vr && vr.Object === Object && vr, XIe = KIe, YIe = XIe, JIe = typeof self == "object" && self && self.Object === Object && self, QIe = YIe || JIe || Function("return this")(), eNe = QIe, tNe = eNe, nNe = tNe.Symbol, Ste = nNe, C$ = Ste;
C$ && C$.toStringTag;
var O$ = Ste;
O$ && O$.toStringTag;
var x$;
(function(e) {
  e.BORDER_BOX = "border-box", e.CONTENT_BOX = "content-box", e.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(x$ || (x$ = {}));
var aT = function(e) {
  return Object.freeze(e);
}, rNe = /* @__PURE__ */ function() {
  function e(t, n) {
    this.inlineSize = t, this.blockSize = n, aT(this);
  }
  return e;
}(), oNe = function() {
  function e(t, n, r, o) {
    return this.x = t, this.y = n, this.width = r, this.height = o, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, aT(this);
  }
  return e.prototype.toJSON = function() {
    var t = this, n = t.x, r = t.y, o = t.top, i = t.right, a = t.bottom, s = t.left, l = t.width, u = t.height;
    return { x: n, y: r, top: o, right: i, bottom: a, left: s, width: l, height: u };
  }, e.fromRect = function(t) {
    return new e(t.x, t.y, t.width, t.height);
  }, e;
}(), E$ = typeof window < "u" ? window : {};
/msie|trident/i.test(E$.navigator && E$.navigator.userAgent);
var ek = function(e, t, n) {
  return e === void 0 && (e = 0), t === void 0 && (t = 0), n === void 0 && (n = !1), new rNe((n ? t : e) || 0, (n ? e : t) || 0);
};
aT({
  devicePixelContentBoxSize: ek(),
  borderBoxSize: ek(),
  contentBoxSize: ek(),
  contentRect: new oNe(0, 0, 0, 0)
});
function jh(e) {
  "@babel/helpers - typeof";
  return jh = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, jh(e);
}
function iNe(e, t) {
  if (jh(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (jh(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function sNe(e) {
  var t = iNe(e, "string");
  return jh(t) === "symbol" ? t : String(t);
}
function Pf(e, t, n) {
  return t = sNe(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
var aNe = /* @__PURE__ */ $e(null), tk, nk;
parseInt(be.version.split(".")[0], 10);
var k$ = typeof navigator < "u" && /Mac OS X/.test(navigator.userAgent), rk = typeof navigator < "u" && /Android/.test(navigator.userAgent), Cv = typeof navigator < "u" && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent), lNe = typeof navigator < "u" && /Chrome/i.test(navigator.userAgent);
typeof navigator < "u" && /Safari/.test(navigator.userAgent) && /Version\/(\d+)/.test(navigator.userAgent) && (tk = navigator.userAgent.match(/Version\/(\d+)/)) !== null && tk !== void 0 && tk[1] && parseInt((nk = navigator.userAgent.match(/Version\/(\d+)/)) === null || nk === void 0 ? void 0 : nk[1], 10) < 17;
var uNe = /* @__PURE__ */ new WeakMap(), cNe = /* @__PURE__ */ new WeakMap(), pNe = /* @__PURE__ */ new WeakMap(), dNe = /* @__PURE__ */ new WeakMap(), fNe = /* @__PURE__ */ new WeakMap(), L$ = /* @__PURE__ */ new WeakMap(), hNe = /* @__PURE__ */ new WeakMap(), _$ = /* @__PURE__ */ new WeakMap(), Ov = /* @__PURE__ */ new WeakMap(), gNe = /* @__PURE__ */ new WeakMap(), mNe = /* @__PURE__ */ new WeakMap(), vNe = /* @__PURE__ */ new WeakMap(), Mte = globalThis.Node, yNe = globalThis.Text, Dte = (e) => e && e.ownerDocument && e.ownerDocument.defaultView || null, bNe = (e) => sw(e) && e.nodeType === 8, da = (e) => sw(e) && e.nodeType === 1, sw = (e) => {
  var t = Dte(e);
  return !!t && e instanceof t.Node;
}, P$ = (e) => {
  var t = e && e.anchorNode && Dte(e.anchorNode);
  return !!t && e instanceof t.Selection;
}, wNe = (e) => {
  var [t, n] = e;
  if (da(t) && t.childNodes.length) {
    var r = n === t.childNodes.length, o = r ? n - 1 : n;
    for ([t, o] = Tte(t, o, r ? "backward" : "forward"), r = o < n; da(t) && t.childNodes.length; ) {
      var i = r ? t.childNodes.length - 1 : 0;
      t = ONe(t, i, r ? "backward" : "forward");
    }
    n = r && t.textContent != null ? t.textContent.length : 0;
  }
  return [t, n];
}, CNe = (e) => {
  for (var t = e && e.parentNode; t; ) {
    if (t.toString() === "[object ShadowRoot]")
      return !0;
    t = t.parentNode;
  }
  return !1;
}, Tte = (e, t, n) => {
  for (var {
    childNodes: r
  } = e, o = r[t], i = t, a = !1, s = !1; (bNe(o) || da(o) && o.childNodes.length === 0 || da(o) && o.getAttribute("contenteditable") === "false") && !(a && s); ) {
    if (i >= r.length) {
      a = !0, i = t - 1, n = "backward";
      continue;
    }
    if (i < 0) {
      s = !0, i = t + 1, n = "forward";
      continue;
    }
    o = r[i], t = i, i += n === "forward" ? 1 : -1;
  }
  return [o, t];
}, ONe = (e, t, n) => {
  var [r] = Tte(e, t, n);
  return r;
}, S$ = (e) => e.getSelection != null ? e.getSelection() : document.getSelection(), jte = (e, t, n) => {
  var {
    target: r
  } = t;
  if (da(r) && r.matches('[contentEditable="false"]'))
    return !1;
  var {
    document: o
  } = fn.getWindow(e);
  if (o.contains(r))
    return fn.hasDOMNode(e, r, {
      editable: !0
    });
  var i = n.find((a) => {
    var {
      addedNodes: s,
      removedNodes: l
    } = a;
    for (var u of s)
      if (u === r || u.contains(r))
        return !0;
    for (var c of l)
      if (c === r || c.contains(r))
        return !0;
  });
  return !i || i === t ? !1 : jte(e, i, n);
}, M$ = (e, t) => !!(e.compareDocumentPosition(t) & Mte.DOCUMENT_POSITION_PRECEDING), xNe = (e, t) => !!(e.compareDocumentPosition(t) & Mte.DOCUMENT_POSITION_FOLLOWING), ENe = 0;
class kNe {
  constructor() {
    Pf(this, "id", void 0), this.id = "".concat(ENe++);
  }
}
var fn = {
  androidPendingDiffs: (e) => vNe.get(e),
  androidScheduleFlush: (e) => {
    var t;
    (t = mNe.get(e)) === null || t === void 0 || t();
  },
  blur: (e) => {
    var t = fn.toDOMNode(e, e), n = fn.findDocumentOrShadowRoot(e);
    Ov.set(e, !1), n.activeElement === t && t.blur();
  },
  deselect: (e) => {
    var {
      selection: t
    } = e, n = fn.findDocumentOrShadowRoot(e), r = S$(n);
    r && r.rangeCount > 0 && r.removeAllRanges(), t && cb.deselect(e);
  },
  findDocumentOrShadowRoot: (e) => {
    var t = fn.toDOMNode(e, e), n = t.getRootNode();
    return n instanceof Document || n instanceof ShadowRoot ? n : t.ownerDocument;
  },
  findEventRange: (e, t) => {
    "nativeEvent" in t && (t = t.nativeEvent);
    var {
      clientX: n,
      clientY: r,
      target: o
    } = t;
    if (n == null || r == null)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var i = fn.toSlateNode(e, t.target), a = fn.findPath(e, i);
    if ($a.isElement(i) && ur.isVoid(e, i)) {
      var s = o.getBoundingClientRect(), l = e.isInline(i) ? n - s.left < s.left + s.width - n : r - s.top < s.top + s.height - r, u = ur.point(e, a, {
        edge: l ? "start" : "end"
      }), c = l ? ur.before(e, u) : ur.after(e, u);
      if (c) {
        var p = ur.range(e, c);
        return p;
      }
    }
    var d, {
      document: g
    } = fn.getWindow(e);
    if (g.caretRangeFromPoint)
      d = g.caretRangeFromPoint(n, r);
    else {
      var f = g.caretPositionFromPoint(n, r);
      f && (d = g.createRange(), d.setStart(f.offsetNode, f.offset), d.setEnd(f.offsetNode, f.offset));
    }
    if (!d)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var m = fn.toSlateRange(e, d, {
      exactMatch: !1,
      suppressThrow: !1
    });
    return m;
  },
  findKey: (e, t) => {
    var n = L$.get(t);
    return n || (n = new kNe(), L$.set(t, n)), n;
  },
  findPath: (e, t) => {
    for (var n = [], r = t; ; ) {
      var o = cNe.get(r);
      if (o == null) {
        if (ur.isEditor(r))
          return n;
        break;
      }
      var i = uNe.get(r);
      if (i == null)
        break;
      n.unshift(i), r = o;
    }
    throw new Error("Unable to find the path for Slate node: ".concat(ss.stringify(t)));
  },
  focus: function(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      retries: 5
    };
    if (!Ov.get(e)) {
      if (t.retries <= 0)
        throw new Error("Could not set focus, editor seems stuck with pending operations");
      if (e.operations.length > 0) {
        setTimeout(() => {
          fn.focus(e, {
            retries: t.retries - 1
          });
        }, 10);
        return;
      }
      var n = fn.toDOMNode(e, e), r = fn.findDocumentOrShadowRoot(e);
      if (r.activeElement !== n) {
        if (e.selection && r instanceof Document) {
          var o = S$(r), i = fn.toDOMRange(e, e.selection);
          o == null || o.removeAllRanges(), o == null || o.addRange(i);
        }
        e.selection || cb.select(e, ur.start(e, [])), Ov.set(e, !0), n.focus({
          preventScroll: !0
        });
      }
    }
  },
  getWindow: (e) => {
    var t = pNe.get(e);
    if (!t)
      throw new Error("Unable to find a host window element for this editor");
    return t;
  },
  hasDOMNode: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      editable: r = !1
    } = n, o = fn.toDOMNode(e, e), i;
    try {
      i = da(t) ? t : t.parentElement;
    } catch (a) {
      if (a instanceof Error && !a.message.includes('Permission denied to access property "nodeType"'))
        throw a;
    }
    return i ? i.closest("[data-slate-editor]") === o && (!r || i.isContentEditable ? !0 : typeof i.isContentEditable == "boolean" && // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined
    // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable="false"(readOnly)
    i.closest('[contenteditable="false"]') === o || !!i.getAttribute("data-slate-zero-width")) : !1;
  },
  hasEditableTarget: (e, t) => sw(t) && fn.hasDOMNode(e, t, {
    editable: !0
  }),
  hasRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t;
    return ur.hasPath(e, n.path) && ur.hasPath(e, r.path);
  },
  hasSelectableTarget: (e, t) => fn.hasEditableTarget(e, t) || fn.isTargetInsideNonReadonlyVoid(e, t),
  hasTarget: (e, t) => sw(t) && fn.hasDOMNode(e, t),
  insertData: (e, t) => {
    e.insertData(t);
  },
  insertFragmentData: (e, t) => e.insertFragmentData(t),
  insertTextData: (e, t) => e.insertTextData(t),
  isComposing: (e) => !!gNe.get(e),
  isFocused: (e) => !!Ov.get(e),
  isReadOnly: (e) => !!_$.get(e),
  isTargetInsideNonReadonlyVoid: (e, t) => {
    if (_$.get(e)) return !1;
    var n = fn.hasTarget(e, t) && fn.toSlateNode(e, t);
    return $a.isElement(n) && ur.isVoid(e, n);
  },
  setFragmentData: (e, t, n) => e.setFragmentData(t, n),
  toDOMNode: (e, t) => {
    var n = hNe.get(e), r = ur.isEditor(t) ? dNe.get(e) : n == null ? void 0 : n.get(fn.findKey(e, t));
    if (!r)
      throw new Error("Cannot resolve a DOM node from Slate node: ".concat(ss.stringify(t)));
    return r;
  },
  toDOMPoint: (e, t) => {
    var [n] = ur.node(e, t.path), r = fn.toDOMNode(e, n), o;
    ur.void(e, {
      at: t
    }) && (t = {
      path: t.path,
      offset: 0
    });
    for (var i = "[data-slate-string], [data-slate-zero-width]", a = Array.from(r.querySelectorAll(i)), s = 0, l = 0; l < a.length; l++) {
      var u = a[l], c = u.childNodes[0];
      if (!(c == null || c.textContent == null)) {
        var {
          length: p
        } = c.textContent, d = u.getAttribute("data-slate-length"), g = d == null ? p : parseInt(d, 10), f = s + g, m = a[l + 1];
        if (t.offset === f && m !== null && m !== void 0 && m.hasAttribute("data-slate-mark-placeholder")) {
          var b, E = m.childNodes[0];
          o = [
            // COMPAT: If we don't explicity set the dom point to be on the actual
            // dom text element, chrome will put the selection behind the actual dom
            // text element, causing domRange.getBoundingClientRect() calls on a collapsed
            // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)
            // which will cause issues when scrolling to it.
            E instanceof yNe ? E : m,
            (b = m.textContent) !== null && b !== void 0 && b.startsWith("\uFEFF") ? 1 : 0
          ];
          break;
        }
        if (t.offset <= f) {
          var w = Math.min(p, Math.max(0, t.offset - s));
          o = [c, w];
          break;
        }
        s = f;
      }
    }
    if (!o)
      throw new Error("Cannot resolve a DOM point from Slate point: ".concat(ss.stringify(t)));
    return o;
  },
  toDOMRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t, o = Gt.isBackward(t), i = fn.toDOMPoint(e, n), a = Gt.isCollapsed(t) ? i : fn.toDOMPoint(e, r), s = fn.getWindow(e), l = s.document.createRange(), [u, c] = o ? a : i, [p, d] = o ? i : a, g = da(u) ? u : u.parentElement, f = !!g.getAttribute("data-slate-zero-width"), m = da(p) ? p : p.parentElement, b = !!m.getAttribute("data-slate-zero-width");
    return l.setStart(u, f ? 1 : c), l.setEnd(p, b ? 1 : d), l;
  },
  toSlateNode: (e, t) => {
    var n = da(t) ? t : t.parentElement;
    n && !n.hasAttribute("data-slate-node") && (n = n.closest("[data-slate-node]"));
    var r = n ? fNe.get(n) : null;
    if (!r)
      throw new Error("Cannot resolve a Slate node from DOM node: ".concat(n));
    return r;
  },
  toSlatePoint: (e, t, n) => {
    var {
      exactMatch: r,
      suppressThrow: o,
      searchDirection: i = "backward"
    } = n, [a, s] = r ? t : wNe(t), l = a.parentNode, u = null, c = 0;
    if (l) {
      var p, d, g = fn.toDOMNode(e, e), f = l.closest('[data-slate-void="true"]'), m = f && g.contains(f) ? f : null, b = l.closest('[contenteditable="false"]'), E = b && g.contains(b) ? b : null, w = l.closest("[data-slate-leaf]"), M = null;
      if (w) {
        if (u = w.closest('[data-slate-node="text"]'), u) {
          var x = fn.getWindow(e), v = x.document.createRange();
          v.setStart(u, 0), v.setEnd(a, s);
          var C = v.cloneContents(), P = [...Array.prototype.slice.call(C.querySelectorAll("[data-slate-zero-width]")), ...Array.prototype.slice.call(C.querySelectorAll("[contenteditable=false]"))];
          P.forEach((S) => {
            if (rk && !r && S.hasAttribute("data-slate-zero-width") && S.textContent.length > 0 && S.textContext !== "\uFEFF") {
              S.textContent.startsWith("\uFEFF") && (S.textContent = S.textContent.slice(1));
              return;
            }
            S.parentNode.removeChild(S);
          }), c = C.textContent.length, M = u;
        }
      } else if (m) {
        for (var F = m.querySelectorAll("[data-slate-leaf]"), L = 0; L < F.length; L++) {
          var B = F[L];
          if (fn.hasDOMNode(e, B)) {
            w = B;
            break;
          }
        }
        w ? (u = w.closest('[data-slate-node="text"]'), M = w, c = M.textContent.length, M.querySelectorAll("[data-slate-zero-width]").forEach((S) => {
          c -= S.textContent.length;
        })) : c = 1;
      } else if (E) {
        var N = (S) => S ? S.querySelectorAll(
          // Exclude leaf nodes in nested editors
          "[data-slate-leaf]:not(:scope [data-slate-editor] [data-slate-leaf])"
        ) : [], $ = E.closest('[data-slate-node="element"]');
        if (i === "forward") {
          var V, H = [...N($), ...N($ == null ? void 0 : $.nextElementSibling)];
          w = (V = H.find((S) => xNe(E, S))) !== null && V !== void 0 ? V : null;
        } else {
          var Z, K = [...N($ == null ? void 0 : $.previousElementSibling), ...N($)];
          w = (Z = K.findLast((S) => M$(E, S))) !== null && Z !== void 0 ? Z : null;
        }
        w && (u = w.closest('[data-slate-node="text"]'), M = w, i === "forward" ? c = 0 : (c = M.textContent.length, M.querySelectorAll("[data-slate-zero-width]").forEach((S) => {
          c -= S.textContent.length;
        })));
      }
      M && c === M.textContent.length && // COMPAT: Android IMEs might remove the zero width space while composing,
      // and we don't add it for line-breaks.
      rk && M.getAttribute("data-slate-zero-width") === "z" && (p = M.textContent) !== null && p !== void 0 && p.startsWith("\uFEFF") && // COMPAT: If the parent node is a Slate zero-width space, editor is
      // because the text node should have no characters. However, during IME
      // composition the ASCII characters will be prepended to the zero-width
      // space, so subtract 1 from the offset to account for the zero-width
      // space character.
      (l.hasAttribute("data-slate-zero-width") || // COMPAT: In Firefox, `range.cloneContents()` returns an extra trailing '\n'
      // when the document ends with a new-line character. This results in the offset
      // length being off by one, so we need to subtract one to account for this.
      Cv && (d = M.textContent) !== null && d !== void 0 && d.endsWith(`

`)) && c--;
    }
    if (rk && !u && !r) {
      var Y = l.hasAttribute("data-slate-node") ? l : l.closest("[data-slate-node]");
      if (Y && fn.hasDOMNode(e, Y, {
        editable: !0
      })) {
        var Q = fn.toSlateNode(e, Y), {
          path: J,
          offset: _
        } = ur.start(e, fn.findPath(e, Q));
        return Y.querySelector("[data-slate-leaf]") || (_ = s), {
          path: J,
          offset: _
        };
      }
    }
    if (!u) {
      if (o)
        return null;
      throw new Error("Cannot resolve a Slate point from DOM point: ".concat(t));
    }
    var D = fn.toSlateNode(e, u), z = fn.findPath(e, D);
    return {
      path: z,
      offset: c
    };
  },
  toSlateRange: (e, t, n) => {
    var r, {
      exactMatch: o,
      suppressThrow: i
    } = n, a = P$(t) ? t.anchorNode : t.startContainer, s, l, u, c, p;
    if (a)
      if (P$(t)) {
        if (Cv && t.rangeCount > 1) {
          u = t.focusNode;
          var d = t.getRangeAt(0), g = t.getRangeAt(t.rangeCount - 1);
          if (u instanceof HTMLTableRowElement && d.startContainer instanceof HTMLTableRowElement && g.startContainer instanceof HTMLTableRowElement) {
            let C = function(P) {
              return P.childElementCount > 0 ? C(P.children[0]) : P;
            };
            var f = d.startContainer, m = g.startContainer, b = C(f.children[d.startOffset]), E = C(m.children[g.startOffset]);
            c = 0, E.childNodes.length > 0 ? s = E.childNodes[0] : s = E, b.childNodes.length > 0 ? u = b.childNodes[0] : u = b, E instanceof HTMLElement ? l = E.innerHTML.length : l = 0;
          } else
            d.startContainer === u ? (s = g.endContainer, l = g.endOffset, c = d.startOffset) : (s = d.startContainer, l = d.endOffset, c = g.startOffset);
        } else
          s = t.anchorNode, l = t.anchorOffset, u = t.focusNode, c = t.focusOffset;
        lNe && CNe(s) || Cv ? p = t.anchorNode === t.focusNode && t.anchorOffset === t.focusOffset : p = t.isCollapsed;
      } else
        s = t.startContainer, l = t.startOffset, u = t.endContainer, c = t.endOffset, p = t.collapsed;
    if (s == null || u == null || l == null || c == null)
      throw new Error("Cannot resolve a Slate range from DOM range: ".concat(t));
    Cv && (r = u.textContent) !== null && r !== void 0 && r.endsWith(`

`) && c === u.textContent.length && c--;
    var w = fn.toSlatePoint(e, [s, l], {
      exactMatch: o,
      suppressThrow: i
    });
    if (!w)
      return null;
    var M = M$(s, u) || s === u && c < l, x = p ? w : fn.toSlatePoint(e, [u, c], {
      exactMatch: o,
      suppressThrow: i,
      searchDirection: M ? "forward" : "backward"
    });
    if (!x)
      return null;
    var v = {
      anchor: w,
      focus: x
    };
    return Gt.isExpanded(v) && Gt.isForward(v) && da(u) && ur.void(e, {
      at: v.focus,
      mode: "highest"
    }) && (v = ur.unhangRange(e, v, {
      voids: !0
    })), v;
  }
}, LNe = {
  bold: "mod+b",
  compose: ["down", "left", "right", "up", "backspace", "enter"],
  moveBackward: "left",
  moveForward: "right",
  moveWordBackward: "ctrl+left",
  moveWordForward: "ctrl+right",
  deleteBackward: "shift?+backspace",
  deleteForward: "shift?+delete",
  extendBackward: "shift+left",
  extendForward: "shift+right",
  italic: "mod+i",
  insertSoftBreak: "shift+enter",
  splitBlock: "enter",
  undo: "mod+z"
}, _Ne = {
  moveLineBackward: "opt+up",
  moveLineForward: "opt+down",
  moveWordBackward: "opt+left",
  moveWordForward: "opt+right",
  deleteBackward: ["ctrl+backspace", "ctrl+h"],
  deleteForward: ["ctrl+delete", "ctrl+d"],
  deleteLineBackward: "cmd+shift?+backspace",
  deleteLineForward: ["cmd+shift?+delete", "ctrl+k"],
  deleteWordBackward: "opt+shift?+backspace",
  deleteWordForward: "opt+shift?+delete",
  extendLineBackward: "opt+shift+up",
  extendLineForward: "opt+shift+down",
  redo: "cmd+shift+z",
  transposeCharacter: "ctrl+t"
}, PNe = {
  deleteWordBackward: "ctrl+shift?+backspace",
  deleteWordForward: "ctrl+shift?+delete",
  redo: ["ctrl+y", "ctrl+shift+z"]
}, Xr = (e) => {
  var t = LNe[e], n = _Ne[e], r = PNe[e], o = t && QE(t), i = n && QE(n), a = r && QE(r);
  return (s) => !!(o && o(s) || k$ && i && i(s) || !k$ && a && a(s));
};
Xr("bold"), Xr("compose"), Xr("moveBackward"), Xr("moveForward"), Xr("deleteBackward"), Xr("deleteForward"), Xr("deleteLineBackward"), Xr("deleteLineForward"), Xr("deleteWordBackward"), Xr("deleteWordForward"), Xr("extendBackward"), Xr("extendForward"), Xr("extendLineBackward"), Xr("extendLineForward"), Xr("italic"), Xr("moveLineBackward"), Xr("moveLineForward"), Xr("moveWordBackward"), Xr("moveWordForward"), Xr("redo"), Xr("insertSoftBreak"), Xr("splitBlock"), Xr("transposeCharacter"), Xr("undo");
var SNe = (e, t) => {
  var n = [], r = () => {
    n = [];
  }, o = (a) => {
    if (t.current) {
      var s = a.filter((l) => jte(e, l, a));
      n.push(...s);
    }
  };
  function i() {
    n.length > 0 && (n.reverse().forEach((a) => {
      a.type !== "characterData" && (a.removedNodes.forEach((s) => {
        a.target.insertBefore(s, a.nextSibling);
      }), a.addedNodes.forEach((s) => {
        a.target.removeChild(s);
      }));
    }), r());
  }
  return {
    registerMutations: o,
    restoreDOM: i,
    clear: r
  };
}, MNe = {
  subtree: !0,
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0
};
class DNe extends au {
  constructor() {
    super(...arguments), Pf(this, "context", null), Pf(this, "manager", null), Pf(this, "mutationObserver", null);
  }
  observe() {
    var t, {
      node: n
    } = this.props;
    if (!n.current)
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    (t = this.mutationObserver) === null || t === void 0 || t.observe(n.current, MNe);
  }
  componentDidMount() {
    var {
      receivedUserInput: t
    } = this.props, n = this.context;
    this.manager = SNe(n, t), this.mutationObserver = new MutationObserver(this.manager.registerMutations), this.observe();
  }
  getSnapshotBeforeUpdate() {
    var t, n, r, o = (t = this.mutationObserver) === null || t === void 0 ? void 0 : t.takeRecords();
    if (o != null && o.length) {
      var i;
      (i = this.manager) === null || i === void 0 || i.registerMutations(o);
    }
    return (n = this.mutationObserver) === null || n === void 0 || n.disconnect(), (r = this.manager) === null || r === void 0 || r.restoreDOM(), null;
  }
  componentDidUpdate() {
    var t;
    (t = this.manager) === null || t === void 0 || t.clear(), this.observe();
  }
  componentWillUnmount() {
    var t;
    (t = this.mutationObserver) === null || t === void 0 || t.disconnect();
  }
  render() {
    return this.props.children;
  }
}
Pf(DNe, "contextType", aNe);
$e({});
$e({});
$e({});
var Io = {}, lT = {}, hg = {}, gg = {}, Ate = "Expected a function", D$ = NaN, TNe = "[object Symbol]", jNe = /^\s+|\s+$/g, ANe = /^[-+]0x[0-9a-f]+$/i, RNe = /^0b[01]+$/i, INe = /^0o[0-7]+$/i, NNe = parseInt, BNe = typeof vr == "object" && vr && vr.Object === Object && vr, FNe = typeof self == "object" && self && self.Object === Object && self, zNe = BNe || FNe || Function("return this")(), UNe = Object.prototype, HNe = UNe.toString, WNe = Math.max, $Ne = Math.min, ok = function() {
  return zNe.Date.now();
};
function VNe(e, t, n) {
  var r, o, i, a, s, l, u = 0, c = !1, p = !1, d = !0;
  if (typeof e != "function")
    throw new TypeError(Ate);
  t = T$(t) || 0, aw(n) && (c = !!n.leading, p = "maxWait" in n, i = p ? WNe(T$(n.maxWait) || 0, t) : i, d = "trailing" in n ? !!n.trailing : d);
  function g(C) {
    var P = r, F = o;
    return r = o = void 0, u = C, a = e.apply(F, P), a;
  }
  function f(C) {
    return u = C, s = setTimeout(E, t), c ? g(C) : a;
  }
  function m(C) {
    var P = C - l, F = C - u, L = t - P;
    return p ? $Ne(L, i - F) : L;
  }
  function b(C) {
    var P = C - l, F = C - u;
    return l === void 0 || P >= t || P < 0 || p && F >= i;
  }
  function E() {
    var C = ok();
    if (b(C))
      return w(C);
    s = setTimeout(E, m(C));
  }
  function w(C) {
    return s = void 0, d && r ? g(C) : (r = o = void 0, a);
  }
  function M() {
    s !== void 0 && clearTimeout(s), u = 0, r = l = o = s = void 0;
  }
  function x() {
    return s === void 0 ? a : w(ok());
  }
  function v() {
    var C = ok(), P = b(C);
    if (r = arguments, o = this, l = C, P) {
      if (s === void 0)
        return f(l);
      if (p)
        return s = setTimeout(E, t), g(l);
    }
    return s === void 0 && (s = setTimeout(E, t)), a;
  }
  return v.cancel = M, v.flush = x, v;
}
function ZNe(e, t, n) {
  var r = !0, o = !0;
  if (typeof e != "function")
    throw new TypeError(Ate);
  return aw(n) && (r = "leading" in n ? !!n.leading : r, o = "trailing" in n ? !!n.trailing : o), VNe(e, t, {
    leading: r,
    maxWait: t,
    trailing: o
  });
}
function aw(e) {
  var t = typeof e;
  return !!e && (t == "object" || t == "function");
}
function qNe(e) {
  return !!e && typeof e == "object";
}
function GNe(e) {
  return typeof e == "symbol" || qNe(e) && HNe.call(e) == TNe;
}
function T$(e) {
  if (typeof e == "number")
    return e;
  if (GNe(e))
    return D$;
  if (aw(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = aw(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = e.replace(jNe, "");
  var n = RNe.test(e);
  return n || INe.test(e) ? NNe(e.slice(2), n ? 2 : 8) : ANe.test(e) ? D$ : +e;
}
var KNe = ZNe, mg = {};
Object.defineProperty(mg, "__esModule", {
  value: !0
});
mg.addPassiveEventListener = function(e, t, n) {
  var r = n.name;
  r || (r = t, console.warn("Listener must be a named function.")), Sy.has(t) || Sy.set(t, /* @__PURE__ */ new Set());
  var o = Sy.get(t);
  if (!o.has(r)) {
    var i = function() {
      var a = !1;
      try {
        var s = Object.defineProperty({}, "passive", {
          get: function() {
            a = !0;
          }
        });
        window.addEventListener("test", null, s);
      } catch {
      }
      return a;
    }();
    e.addEventListener(t, n, i ? { passive: !0 } : !1), o.add(r);
  }
};
mg.removePassiveEventListener = function(e, t, n) {
  e.removeEventListener(t, n), Sy.get(t).delete(n.name || t);
};
var Sy = /* @__PURE__ */ new Map();
Object.defineProperty(gg, "__esModule", {
  value: !0
});
var XNe = KNe, YNe = JNe(XNe), j$ = mg;
function JNe(e) {
  return e && e.__esModule ? e : { default: e };
}
var QNe = function(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 66;
  return (0, YNe.default)(e, t);
}, fo = {
  spyCallbacks: [],
  spySetState: [],
  scrollSpyContainers: [],
  mount: function(e, t) {
    if (e) {
      var n = QNe(function(r) {
        fo.scrollHandler(e);
      }, t);
      return fo.scrollSpyContainers.push(e), (0, j$.addPassiveEventListener)(e, "scroll", n), function() {
        (0, j$.removePassiveEventListener)(e, "scroll", n), fo.scrollSpyContainers.splice(fo.scrollSpyContainers.indexOf(e), 1);
      };
    }
    return function() {
    };
  },
  isMounted: function(e) {
    return fo.scrollSpyContainers.indexOf(e) !== -1;
  },
  currentPositionX: function(e) {
    if (e === document) {
      var t = window.scrollY !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.scrollX : n ? document.documentElement.scrollLeft : document.body.scrollLeft;
    } else
      return e.scrollLeft;
  },
  currentPositionY: function(e) {
    if (e === document) {
      var t = window.scrollX !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.scrollY : n ? document.documentElement.scrollTop : document.body.scrollTop;
    } else
      return e.scrollTop;
  },
  scrollHandler: function(e) {
    var t = fo.scrollSpyContainers[fo.scrollSpyContainers.indexOf(e)].spyCallbacks || [];
    t.forEach(function(n) {
      return n(fo.currentPositionX(e), fo.currentPositionY(e));
    });
  },
  addStateHandler: function(e) {
    fo.spySetState.push(e);
  },
  addSpyHandler: function(e, t) {
    var n = fo.scrollSpyContainers[fo.scrollSpyContainers.indexOf(t)];
    n.spyCallbacks || (n.spyCallbacks = []), n.spyCallbacks.push(e);
  },
  updateStates: function() {
    fo.spySetState.forEach(function(e) {
      return e();
    });
  },
  unmount: function(e, t) {
    fo.scrollSpyContainers.forEach(function(n) {
      return n.spyCallbacks && n.spyCallbacks.length && n.spyCallbacks.indexOf(t) > -1 && n.spyCallbacks.splice(n.spyCallbacks.indexOf(t), 1);
    }), fo.spySetState && fo.spySetState.length && fo.spySetState.indexOf(e) > -1 && fo.spySetState.splice(fo.spySetState.indexOf(e), 1), document.removeEventListener("scroll", fo.scrollHandler);
  },
  update: function() {
    return fo.scrollSpyContainers.forEach(function(e) {
      return fo.scrollHandler(e);
    });
  }
};
gg.default = fo;
var $p = {}, vg = {};
Object.defineProperty(vg, "__esModule", {
  value: !0
});
var eBe = function(e, t) {
  var n = e.indexOf("#") === 0 ? e.substring(1) : e, r = n ? "#" + n : "", o = window && window.location, i = r ? o.pathname + o.search + r : o.pathname + o.search;
  t ? history.pushState(history.state, "", i) : history.replaceState(history.state, "", i);
}, tBe = function() {
  return window.location.hash.replace(/^#/, "");
}, nBe = function(e) {
  return function(t) {
    return e.contains ? e != t && e.contains(t) : !!(e.compareDocumentPosition(t) & 16);
  };
}, rBe = function(e) {
  return getComputedStyle(e).position !== "static";
}, ik = function(e, t) {
  for (var n = e.offsetTop, r = e.offsetParent; r && !t(r); )
    n += r.offsetTop, r = r.offsetParent;
  return { offsetTop: n, offsetParent: r };
}, oBe = function(e, t, n) {
  if (n)
    return e === document ? t.getBoundingClientRect().left + (window.scrollX || window.pageXOffset) : getComputedStyle(e).position !== "static" ? t.offsetLeft : t.offsetLeft - e.offsetLeft;
  if (e === document)
    return t.getBoundingClientRect().top + (window.scrollY || window.pageYOffset);
  if (rBe(e)) {
    if (t.offsetParent !== e) {
      var r = function(l) {
        return l === e || l === document;
      }, o = ik(t, r), i = o.offsetTop, a = o.offsetParent;
      if (a !== e)
        throw new Error("Seems containerElement is not an ancestor of the Element");
      return i;
    }
    return t.offsetTop;
  }
  if (t.offsetParent === e.offsetParent)
    return t.offsetTop - e.offsetTop;
  var s = function(l) {
    return l === document;
  };
  return ik(t, s).offsetTop - ik(e, s).offsetTop;
};
vg.default = {
  updateHash: eBe,
  getHash: tBe,
  filterElementInContainer: nBe,
  scrollOffset: oBe
};
var yO = {}, uT = {};
Object.defineProperty(uT, "__esModule", {
  value: !0
});
uT.default = {
  /*
   * https://github.com/oblador/angular-scroll (duScrollDefaultEasing)
   */
  defaultEasing: function(e) {
    return e < 0.5 ? Math.pow(e * 2, 2) / 2 : 1 - Math.pow((1 - e) * 2, 2) / 2;
  },
  /*
   * https://gist.github.com/gre/1650294
   */
  // no easing, no acceleration
  linear: function(e) {
    return e;
  },
  // accelerating from zero velocity
  easeInQuad: function(e) {
    return e * e;
  },
  // decelerating to zero velocity
  easeOutQuad: function(e) {
    return e * (2 - e);
  },
  // acceleration until halfway, then deceleration
  easeInOutQuad: function(e) {
    return e < 0.5 ? 2 * e * e : -1 + (4 - 2 * e) * e;
  },
  // accelerating from zero velocity 
  easeInCubic: function(e) {
    return e * e * e;
  },
  // decelerating to zero velocity π
  easeOutCubic: function(e) {
    return --e * e * e + 1;
  },
  // acceleration until halfway, then deceleration 
  easeInOutCubic: function(e) {
    return e < 0.5 ? 4 * e * e * e : (e - 1) * (2 * e - 2) * (2 * e - 2) + 1;
  },
  // accelerating from zero velocity 
  easeInQuart: function(e) {
    return e * e * e * e;
  },
  // decelerating to zero velocity 
  easeOutQuart: function(e) {
    return 1 - --e * e * e * e;
  },
  // acceleration until halfway, then deceleration
  easeInOutQuart: function(e) {
    return e < 0.5 ? 8 * e * e * e * e : 1 - 8 * --e * e * e * e;
  },
  // accelerating from zero velocity
  easeInQuint: function(e) {
    return e * e * e * e * e;
  },
  // decelerating to zero velocity
  easeOutQuint: function(e) {
    return 1 + --e * e * e * e * e;
  },
  // acceleration until halfway, then deceleration 
  easeInOutQuint: function(e) {
    return e < 0.5 ? 16 * e * e * e * e * e : 1 + 16 * --e * e * e * e * e;
  }
};
var cT = {};
Object.defineProperty(cT, "__esModule", {
  value: !0
});
var iBe = mg, sBe = ["mousedown", "wheel", "touchmove", "keydown"];
cT.default = {
  subscribe: function(e) {
    return typeof document < "u" && sBe.forEach(function(t) {
      return (0, iBe.addPassiveEventListener)(document, t, e);
    });
  }
};
var yg = {};
Object.defineProperty(yg, "__esModule", {
  value: !0
});
var Y_ = {
  registered: {},
  scrollEvent: {
    register: function(e, t) {
      Y_.registered[e] = t;
    },
    remove: function(e) {
      Y_.registered[e] = null;
    }
  }
};
yg.default = Y_;
Object.defineProperty(yO, "__esModule", {
  value: !0
});
var aBe = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, lBe = vg;
bO(lBe);
var uBe = uT, A$ = bO(uBe), cBe = cT, pBe = bO(cBe), dBe = yg, oa = bO(dBe);
function bO(e) {
  return e && e.__esModule ? e : { default: e };
}
var Rte = function(e) {
  return A$.default[e.smooth] || A$.default.defaultEasing;
}, fBe = function(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}, hBe = function() {
  if (typeof window < "u")
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame;
}, J_ = function() {
  return hBe() || function(e, t, n) {
    window.setTimeout(e, n || 1e3 / 60, (/* @__PURE__ */ new Date()).getTime());
  };
}(), Ite = function() {
  return {
    currentPosition: 0,
    startPosition: 0,
    targetPosition: 0,
    progress: 0,
    duration: 0,
    cancel: !1,
    target: null,
    containerElement: null,
    to: null,
    start: null,
    delta: null,
    percent: null,
    delayTimeout: null
  };
}, Nte = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollLeft;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageXOffset : r ? document.documentElement.scrollLeft : document.body.scrollLeft;
}, Bte = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollTop;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageYOffset : r ? document.documentElement.scrollTop : document.body.scrollTop;
}, gBe = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollWidth - t.offsetWidth;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollWidth, n.offsetWidth, r.clientWidth, r.scrollWidth, r.offsetWidth);
}, mBe = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollHeight - t.offsetHeight;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollHeight, n.offsetHeight, r.clientHeight, r.scrollHeight, r.offsetHeight);
}, vBe = function e(t, n, r) {
  var o = n.data;
  if (!n.ignoreCancelEvents && o.cancel) {
    oa.default.registered.end && oa.default.registered.end(o.to, o.target, o.currentPositionY);
    return;
  }
  if (o.delta = Math.round(o.targetPosition - o.startPosition), o.start === null && (o.start = r), o.progress = r - o.start, o.percent = o.progress >= o.duration ? 1 : t(o.progress / o.duration), o.currentPosition = o.startPosition + Math.ceil(o.delta * o.percent), o.containerElement && o.containerElement !== document && o.containerElement !== document.body ? n.horizontal ? o.containerElement.scrollLeft = o.currentPosition : o.containerElement.scrollTop = o.currentPosition : n.horizontal ? window.scrollTo(o.currentPosition, 0) : window.scrollTo(0, o.currentPosition), o.percent < 1) {
    var i = e.bind(null, t, n);
    J_.call(window, i);
    return;
  }
  oa.default.registered.end && oa.default.registered.end(o.to, o.target, o.currentPosition);
}, pT = function(e) {
  e.data.containerElement = e ? e.containerId ? document.getElementById(e.containerId) : e.container && e.container.nodeType ? e.container : document : null;
}, bg = function(e, t, n, r) {
  t.data = t.data || Ite(), window.clearTimeout(t.data.delayTimeout);
  var o = function() {
    t.data.cancel = !0;
  };
  if (pBe.default.subscribe(o), pT(t), t.data.start = null, t.data.cancel = !1, t.data.startPosition = t.horizontal ? Nte(t) : Bte(t), t.data.targetPosition = t.absolute ? e : e + t.data.startPosition, t.data.startPosition === t.data.targetPosition) {
    oa.default.registered.end && oa.default.registered.end(t.data.to, t.data.target, t.data.currentPosition);
    return;
  }
  t.data.delta = Math.round(t.data.targetPosition - t.data.startPosition), t.data.duration = fBe(t.duration)(t.data.delta), t.data.duration = isNaN(parseFloat(t.data.duration)) ? 1e3 : parseFloat(t.data.duration), t.data.to = n, t.data.target = r;
  var i = Rte(t), a = vBe.bind(null, i, t);
  if (t && t.delay > 0) {
    t.data.delayTimeout = window.setTimeout(function() {
      oa.default.registered.begin && oa.default.registered.begin(t.data.to, t.data.target), J_.call(window, a);
    }, t.delay);
    return;
  }
  oa.default.registered.begin && oa.default.registered.begin(t.data.to, t.data.target), J_.call(window, a);
}, wO = function(e) {
  return e = aBe({}, e), e.data = e.data || Ite(), e.absolute = !0, e;
}, yBe = function(e) {
  bg(0, wO(e));
}, bBe = function(e, t) {
  bg(e, wO(t));
}, wBe = function(e) {
  e = wO(e), pT(e), bg(e.horizontal ? gBe(e) : mBe(e), e);
}, CBe = function(e, t) {
  t = wO(t), pT(t);
  var n = t.horizontal ? Nte(t) : Bte(t);
  bg(e + n, t);
};
yO.default = {
  animateTopScroll: bg,
  getAnimationType: Rte,
  scrollToTop: yBe,
  scrollToBottom: wBe,
  scrollTo: bBe,
  scrollMore: CBe
};
Object.defineProperty($p, "__esModule", {
  value: !0
});
var OBe = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, xBe = vg, EBe = dT(xBe), kBe = yO, LBe = dT(kBe), _Be = yg, xv = dT(_Be);
function dT(e) {
  return e && e.__esModule ? e : { default: e };
}
var Ev = {}, R$ = void 0;
$p.default = {
  unmount: function() {
    Ev = {};
  },
  register: function(e, t) {
    Ev[e] = t;
  },
  unregister: function(e) {
    delete Ev[e];
  },
  get: function(e) {
    return Ev[e] || document.getElementById(e) || document.getElementsByName(e)[0] || document.getElementsByClassName(e)[0];
  },
  setActiveLink: function(e) {
    return R$ = e;
  },
  getActiveLink: function() {
    return R$;
  },
  scrollTo: function(e, t) {
    var n = this.get(e);
    if (!n) {
      console.warn("target Element not found");
      return;
    }
    t = OBe({}, t, { absolute: !1 });
    var r = t.containerId, o = t.container, i = void 0;
    r ? i = document.getElementById(r) : o && o.nodeType ? i = o : i = document, t.absolute = !0;
    var a = t.horizontal, s = EBe.default.scrollOffset(i, n, a) + (t.offset || 0);
    if (!t.smooth) {
      xv.default.registered.begin && xv.default.registered.begin(e, n), i === document ? t.horizontal ? window.scrollTo(s, 0) : window.scrollTo(0, s) : i.scrollTop = s, xv.default.registered.end && xv.default.registered.end(e, n);
      return;
    }
    LBe.default.animateTopScroll(s, t, e, n);
  }
};
var Q_ = { exports: {} }, sk = { exports: {} }, Zn = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var I$;
function PBe() {
  if (I$) return Zn;
  I$ = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, g = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, m = e ? Symbol.for("react.block") : 60121, b = e ? Symbol.for("react.fundamental") : 60117, E = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
  function M(v) {
    if (typeof v == "object" && v !== null) {
      var C = v.$$typeof;
      switch (C) {
        case t:
          switch (v = v.type, v) {
            case l:
            case u:
            case r:
            case i:
            case o:
            case p:
              return v;
            default:
              switch (v = v && v.$$typeof, v) {
                case s:
                case c:
                case f:
                case g:
                case a:
                  return v;
                default:
                  return C;
              }
          }
        case n:
          return C;
      }
    }
  }
  function x(v) {
    return M(v) === u;
  }
  return Zn.AsyncMode = l, Zn.ConcurrentMode = u, Zn.ContextConsumer = s, Zn.ContextProvider = a, Zn.Element = t, Zn.ForwardRef = c, Zn.Fragment = r, Zn.Lazy = f, Zn.Memo = g, Zn.Portal = n, Zn.Profiler = i, Zn.StrictMode = o, Zn.Suspense = p, Zn.isAsyncMode = function(v) {
    return x(v) || M(v) === l;
  }, Zn.isConcurrentMode = x, Zn.isContextConsumer = function(v) {
    return M(v) === s;
  }, Zn.isContextProvider = function(v) {
    return M(v) === a;
  }, Zn.isElement = function(v) {
    return typeof v == "object" && v !== null && v.$$typeof === t;
  }, Zn.isForwardRef = function(v) {
    return M(v) === c;
  }, Zn.isFragment = function(v) {
    return M(v) === r;
  }, Zn.isLazy = function(v) {
    return M(v) === f;
  }, Zn.isMemo = function(v) {
    return M(v) === g;
  }, Zn.isPortal = function(v) {
    return M(v) === n;
  }, Zn.isProfiler = function(v) {
    return M(v) === i;
  }, Zn.isStrictMode = function(v) {
    return M(v) === o;
  }, Zn.isSuspense = function(v) {
    return M(v) === p;
  }, Zn.isValidElementType = function(v) {
    return typeof v == "string" || typeof v == "function" || v === r || v === u || v === i || v === o || v === p || v === d || typeof v == "object" && v !== null && (v.$$typeof === f || v.$$typeof === g || v.$$typeof === a || v.$$typeof === s || v.$$typeof === c || v.$$typeof === b || v.$$typeof === E || v.$$typeof === w || v.$$typeof === m);
  }, Zn.typeOf = M, Zn;
}
var nr = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var N$;
function SBe() {
  return N$ || (N$ = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, g = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, m = e ? Symbol.for("react.block") : 60121, b = e ? Symbol.for("react.fundamental") : 60117, E = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
    function M(I) {
      return typeof I == "string" || typeof I == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      I === r || I === u || I === i || I === o || I === p || I === d || typeof I == "object" && I !== null && (I.$$typeof === f || I.$$typeof === g || I.$$typeof === a || I.$$typeof === s || I.$$typeof === c || I.$$typeof === b || I.$$typeof === E || I.$$typeof === w || I.$$typeof === m);
    }
    function x(I) {
      if (typeof I == "object" && I !== null) {
        var le = I.$$typeof;
        switch (le) {
          case t:
            var he = I.type;
            switch (he) {
              case l:
              case u:
              case r:
              case i:
              case o:
              case p:
                return he;
              default:
                var oe = he && he.$$typeof;
                switch (oe) {
                  case s:
                  case c:
                  case f:
                  case g:
                  case a:
                    return oe;
                  default:
                    return le;
                }
            }
          case n:
            return le;
        }
      }
    }
    var v = l, C = u, P = s, F = a, L = t, B = c, N = r, $ = f, V = g, H = n, Z = i, K = o, Y = p, Q = !1;
    function J(I) {
      return Q || (Q = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), _(I) || x(I) === l;
    }
    function _(I) {
      return x(I) === u;
    }
    function D(I) {
      return x(I) === s;
    }
    function z(I) {
      return x(I) === a;
    }
    function S(I) {
      return typeof I == "object" && I !== null && I.$$typeof === t;
    }
    function W(I) {
      return x(I) === c;
    }
    function O(I) {
      return x(I) === r;
    }
    function j(I) {
      return x(I) === f;
    }
    function U(I) {
      return x(I) === g;
    }
    function T(I) {
      return x(I) === n;
    }
    function q(I) {
      return x(I) === i;
    }
    function A(I) {
      return x(I) === o;
    }
    function X(I) {
      return x(I) === p;
    }
    nr.AsyncMode = v, nr.ConcurrentMode = C, nr.ContextConsumer = P, nr.ContextProvider = F, nr.Element = L, nr.ForwardRef = B, nr.Fragment = N, nr.Lazy = $, nr.Memo = V, nr.Portal = H, nr.Profiler = Z, nr.StrictMode = K, nr.Suspense = Y, nr.isAsyncMode = J, nr.isConcurrentMode = _, nr.isContextConsumer = D, nr.isContextProvider = z, nr.isElement = S, nr.isForwardRef = W, nr.isFragment = O, nr.isLazy = j, nr.isMemo = U, nr.isPortal = T, nr.isProfiler = q, nr.isStrictMode = A, nr.isSuspense = X, nr.isValidElementType = M, nr.typeOf = x;
  }()), nr;
}
var B$;
function Fte() {
  return B$ || (B$ = 1, process.env.NODE_ENV === "production" ? sk.exports = PBe() : sk.exports = SBe()), sk.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var ak, F$;
function MBe() {
  if (F$) return ak;
  F$ = 1;
  var e = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, n = Object.prototype.propertyIsEnumerable;
  function r(i) {
    if (i == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(i);
  }
  function o() {
    try {
      if (!Object.assign)
        return !1;
      var i = new String("abc");
      if (i[5] = "de", Object.getOwnPropertyNames(i)[0] === "5")
        return !1;
      for (var a = {}, s = 0; s < 10; s++)
        a["_" + String.fromCharCode(s)] = s;
      var l = Object.getOwnPropertyNames(a).map(function(c) {
        return a[c];
      });
      if (l.join("") !== "0123456789")
        return !1;
      var u = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(c) {
        u[c] = c;
      }), Object.keys(Object.assign({}, u)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return ak = o() ? Object.assign : function(i, a) {
    for (var s, l = r(i), u, c = 1; c < arguments.length; c++) {
      s = Object(arguments[c]);
      for (var p in s)
        t.call(s, p) && (l[p] = s[p]);
      if (e) {
        u = e(s);
        for (var d = 0; d < u.length; d++)
          n.call(s, u[d]) && (l[u[d]] = s[u[d]]);
      }
    }
    return l;
  }, ak;
}
var lk, z$;
function fT() {
  if (z$) return lk;
  z$ = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return lk = e, lk;
}
var U$, H$;
function zte() {
  return H$ || (H$ = 1, U$ = Function.call.bind(Object.prototype.hasOwnProperty)), U$;
}
var uk, W$;
function DBe() {
  if (W$) return uk;
  W$ = 1;
  var e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = fT(), n = {}, r = zte();
    e = function(i) {
      var a = "Warning: " + i;
      typeof console < "u" && console.error(a);
      try {
        throw new Error(a);
      } catch {
      }
    };
  }
  function o(i, a, s, l, u) {
    if (process.env.NODE_ENV !== "production") {
      for (var c in i)
        if (r(i, c)) {
          var p;
          try {
            if (typeof i[c] != "function") {
              var d = Error(
                (l || "React class") + ": " + s + " type `" + c + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof i[c] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw d.name = "Invariant Violation", d;
            }
            p = i[c](a, c, l, s, null, t);
          } catch (f) {
            p = f;
          }
          if (p && !(p instanceof Error) && e(
            (l || "React class") + ": type specification of " + s + " `" + c + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof p + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), p instanceof Error && !(p.message in n)) {
            n[p.message] = !0;
            var g = u ? u() : "";
            e(
              "Failed " + s + " type: " + p.message + (g ?? "")
            );
          }
        }
    }
  }
  return o.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (n = {});
  }, uk = o, uk;
}
var ck, $$;
function TBe() {
  if ($$) return ck;
  $$ = 1;
  var e = Fte(), t = MBe(), n = fT(), r = zte(), o = DBe(), i = function() {
  };
  process.env.NODE_ENV !== "production" && (i = function(s) {
    var l = "Warning: " + s;
    typeof console < "u" && console.error(l);
    try {
      throw new Error(l);
    } catch {
    }
  });
  function a() {
    return null;
  }
  return ck = function(s, l) {
    var u = typeof Symbol == "function" && Symbol.iterator, c = "@@iterator";
    function p(_) {
      var D = _ && (u && _[u] || _[c]);
      if (typeof D == "function")
        return D;
    }
    var d = "<<anonymous>>", g = {
      array: E("array"),
      bigint: E("bigint"),
      bool: E("boolean"),
      func: E("function"),
      number: E("number"),
      object: E("object"),
      string: E("string"),
      symbol: E("symbol"),
      any: w(),
      arrayOf: M,
      element: x(),
      elementType: v(),
      instanceOf: C,
      node: B(),
      objectOf: F,
      oneOf: P,
      oneOfType: L,
      shape: $,
      exact: V
    };
    function f(_, D) {
      return _ === D ? _ !== 0 || 1 / _ === 1 / D : _ !== _ && D !== D;
    }
    function m(_, D) {
      this.message = _, this.data = D && typeof D == "object" ? D : {}, this.stack = "";
    }
    m.prototype = Error.prototype;
    function b(_) {
      if (process.env.NODE_ENV !== "production")
        var D = {}, z = 0;
      function S(O, j, U, T, q, A, X) {
        if (T = T || d, A = A || U, X !== n) {
          if (l) {
            var I = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw I.name = "Invariant Violation", I;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var le = T + ":" + U;
            !D[le] && // Avoid spamming the console because they are often not actionable except for lib authors
            z < 3 && (i(
              "You are manually calling a React.PropTypes validation function for the `" + A + "` prop on `" + T + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), D[le] = !0, z++);
          }
        }
        return j[U] == null ? O ? j[U] === null ? new m("The " + q + " `" + A + "` is marked as required " + ("in `" + T + "`, but its value is `null`.")) : new m("The " + q + " `" + A + "` is marked as required in " + ("`" + T + "`, but its value is `undefined`.")) : null : _(j, U, T, q, A);
      }
      var W = S.bind(null, !1);
      return W.isRequired = S.bind(null, !0), W;
    }
    function E(_) {
      function D(z, S, W, O, j, U) {
        var T = z[S], q = K(T);
        if (q !== _) {
          var A = Y(T);
          return new m(
            "Invalid " + O + " `" + j + "` of type " + ("`" + A + "` supplied to `" + W + "`, expected ") + ("`" + _ + "`."),
            { expectedType: _ }
          );
        }
        return null;
      }
      return b(D);
    }
    function w() {
      return b(a);
    }
    function M(_) {
      function D(z, S, W, O, j) {
        if (typeof _ != "function")
          return new m("Property `" + j + "` of component `" + W + "` has invalid PropType notation inside arrayOf.");
        var U = z[S];
        if (!Array.isArray(U)) {
          var T = K(U);
          return new m("Invalid " + O + " `" + j + "` of type " + ("`" + T + "` supplied to `" + W + "`, expected an array."));
        }
        for (var q = 0; q < U.length; q++) {
          var A = _(U, q, W, O, j + "[" + q + "]", n);
          if (A instanceof Error)
            return A;
        }
        return null;
      }
      return b(D);
    }
    function x() {
      function _(D, z, S, W, O) {
        var j = D[z];
        if (!s(j)) {
          var U = K(j);
          return new m("Invalid " + W + " `" + O + "` of type " + ("`" + U + "` supplied to `" + S + "`, expected a single ReactElement."));
        }
        return null;
      }
      return b(_);
    }
    function v() {
      function _(D, z, S, W, O) {
        var j = D[z];
        if (!e.isValidElementType(j)) {
          var U = K(j);
          return new m("Invalid " + W + " `" + O + "` of type " + ("`" + U + "` supplied to `" + S + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return b(_);
    }
    function C(_) {
      function D(z, S, W, O, j) {
        if (!(z[S] instanceof _)) {
          var U = _.name || d, T = J(z[S]);
          return new m("Invalid " + O + " `" + j + "` of type " + ("`" + T + "` supplied to `" + W + "`, expected ") + ("instance of `" + U + "`."));
        }
        return null;
      }
      return b(D);
    }
    function P(_) {
      if (!Array.isArray(_))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? i(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : i("Invalid argument supplied to oneOf, expected an array.")), a;
      function D(z, S, W, O, j) {
        for (var U = z[S], T = 0; T < _.length; T++)
          if (f(U, _[T]))
            return null;
        var q = JSON.stringify(_, function(A, X) {
          var I = Y(X);
          return I === "symbol" ? String(X) : X;
        });
        return new m("Invalid " + O + " `" + j + "` of value `" + String(U) + "` " + ("supplied to `" + W + "`, expected one of " + q + "."));
      }
      return b(D);
    }
    function F(_) {
      function D(z, S, W, O, j) {
        if (typeof _ != "function")
          return new m("Property `" + j + "` of component `" + W + "` has invalid PropType notation inside objectOf.");
        var U = z[S], T = K(U);
        if (T !== "object")
          return new m("Invalid " + O + " `" + j + "` of type " + ("`" + T + "` supplied to `" + W + "`, expected an object."));
        for (var q in U)
          if (r(U, q)) {
            var A = _(U, q, W, O, j + "." + q, n);
            if (A instanceof Error)
              return A;
          }
        return null;
      }
      return b(D);
    }
    function L(_) {
      if (!Array.isArray(_))
        return process.env.NODE_ENV !== "production" && i("Invalid argument supplied to oneOfType, expected an instance of array."), a;
      for (var D = 0; D < _.length; D++) {
        var z = _[D];
        if (typeof z != "function")
          return i(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + Q(z) + " at index " + D + "."
          ), a;
      }
      function S(W, O, j, U, T) {
        for (var q = [], A = 0; A < _.length; A++) {
          var X = _[A], I = X(W, O, j, U, T, n);
          if (I == null)
            return null;
          I.data && r(I.data, "expectedType") && q.push(I.data.expectedType);
        }
        var le = q.length > 0 ? ", expected one of type [" + q.join(", ") + "]" : "";
        return new m("Invalid " + U + " `" + T + "` supplied to " + ("`" + j + "`" + le + "."));
      }
      return b(S);
    }
    function B() {
      function _(D, z, S, W, O) {
        return H(D[z]) ? null : new m("Invalid " + W + " `" + O + "` supplied to " + ("`" + S + "`, expected a ReactNode."));
      }
      return b(_);
    }
    function N(_, D, z, S, W) {
      return new m(
        (_ || "React class") + ": " + D + " type `" + z + "." + S + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + W + "`."
      );
    }
    function $(_) {
      function D(z, S, W, O, j) {
        var U = z[S], T = K(U);
        if (T !== "object")
          return new m("Invalid " + O + " `" + j + "` of type `" + T + "` " + ("supplied to `" + W + "`, expected `object`."));
        for (var q in _) {
          var A = _[q];
          if (typeof A != "function")
            return N(W, O, j, q, Y(A));
          var X = A(U, q, W, O, j + "." + q, n);
          if (X)
            return X;
        }
        return null;
      }
      return b(D);
    }
    function V(_) {
      function D(z, S, W, O, j) {
        var U = z[S], T = K(U);
        if (T !== "object")
          return new m("Invalid " + O + " `" + j + "` of type `" + T + "` " + ("supplied to `" + W + "`, expected `object`."));
        var q = t({}, z[S], _);
        for (var A in q) {
          var X = _[A];
          if (r(_, A) && typeof X != "function")
            return N(W, O, j, A, Y(X));
          if (!X)
            return new m(
              "Invalid " + O + " `" + j + "` key `" + A + "` supplied to `" + W + "`.\nBad object: " + JSON.stringify(z[S], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(_), null, "  ")
            );
          var I = X(U, A, W, O, j + "." + A, n);
          if (I)
            return I;
        }
        return null;
      }
      return b(D);
    }
    function H(_) {
      switch (typeof _) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !_;
        case "object":
          if (Array.isArray(_))
            return _.every(H);
          if (_ === null || s(_))
            return !0;
          var D = p(_);
          if (D) {
            var z = D.call(_), S;
            if (D !== _.entries) {
              for (; !(S = z.next()).done; )
                if (!H(S.value))
                  return !1;
            } else
              for (; !(S = z.next()).done; ) {
                var W = S.value;
                if (W && !H(W[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function Z(_, D) {
      return _ === "symbol" ? !0 : D ? D["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && D instanceof Symbol : !1;
    }
    function K(_) {
      var D = typeof _;
      return Array.isArray(_) ? "array" : _ instanceof RegExp ? "object" : Z(D, _) ? "symbol" : D;
    }
    function Y(_) {
      if (typeof _ > "u" || _ === null)
        return "" + _;
      var D = K(_);
      if (D === "object") {
        if (_ instanceof Date)
          return "date";
        if (_ instanceof RegExp)
          return "regexp";
      }
      return D;
    }
    function Q(_) {
      var D = Y(_);
      switch (D) {
        case "array":
        case "object":
          return "an " + D;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + D;
        default:
          return D;
      }
    }
    function J(_) {
      return !_.constructor || !_.constructor.name ? d : _.constructor.name;
    }
    return g.checkPropTypes = o, g.resetWarningCache = o.resetWarningCache, g.PropTypes = g, g;
  }, ck;
}
var pk, V$;
function jBe() {
  if (V$) return pk;
  V$ = 1;
  var e = fT();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, pk = function() {
    function r(a, s, l, u, c, p) {
      if (p !== e) {
        var d = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw d.name = "Invariant Violation", d;
      }
    }
    r.isRequired = r;
    function o() {
      return r;
    }
    var i = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: o,
      element: r,
      elementType: r,
      instanceOf: o,
      node: r,
      objectOf: o,
      oneOf: o,
      oneOfType: o,
      shape: o,
      exact: o,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return i.PropTypes = i, i;
  }, pk;
}
if (process.env.NODE_ENV !== "production") {
  var ABe = Fte(), RBe = !0;
  Q_.exports = TBe()(ABe.isElement, RBe);
} else
  Q_.exports = jBe()();
var CO = Q_.exports, OO = {};
Object.defineProperty(OO, "__esModule", {
  value: !0
});
var IBe = vg, dk = NBe(IBe);
function NBe(e) {
  return e && e.__esModule ? e : { default: e };
}
var BBe = {
  mountFlag: !1,
  initialized: !1,
  scroller: null,
  containers: {},
  mount: function(e) {
    this.scroller = e, this.handleHashChange = this.handleHashChange.bind(this), window.addEventListener("hashchange", this.handleHashChange), this.initStateFromHash(), this.mountFlag = !0;
  },
  mapContainer: function(e, t) {
    this.containers[e] = t;
  },
  isMounted: function() {
    return this.mountFlag;
  },
  isInitialized: function() {
    return this.initialized;
  },
  initStateFromHash: function() {
    var e = this, t = this.getHash();
    t ? window.setTimeout(function() {
      e.scrollTo(t, !0), e.initialized = !0;
    }, 10) : this.initialized = !0;
  },
  scrollTo: function(e, t) {
    var n = this.scroller, r = n.get(e);
    if (r && (t || e !== n.getActiveLink())) {
      var o = this.containers[e] || document;
      n.scrollTo(e, { container: o });
    }
  },
  getHash: function() {
    return dk.default.getHash();
  },
  changeHash: function(e, t) {
    this.isInitialized() && dk.default.getHash() !== e && dk.default.updateHash(e, t);
  },
  handleHashChange: function() {
    this.scrollTo(this.getHash());
  },
  unmount: function() {
    this.scroller = null, this.containers = null, window.removeEventListener("hashchange", this.handleHashChange);
  }
};
OO.default = BBe;
Object.defineProperty(hg, "__esModule", {
  value: !0
});
var kv = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, FBe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), zBe = be, Z$ = wg(zBe), UBe = gg, Lv = wg(UBe), HBe = $p, WBe = wg(HBe), $Be = CO, Yr = wg($Be), VBe = OO, wl = wg(VBe);
function wg(e) {
  return e && e.__esModule ? e : { default: e };
}
function ZBe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function qBe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function GBe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var q$ = {
  to: Yr.default.string.isRequired,
  containerId: Yr.default.string,
  container: Yr.default.object,
  activeClass: Yr.default.string,
  activeStyle: Yr.default.object,
  spy: Yr.default.bool,
  horizontal: Yr.default.bool,
  smooth: Yr.default.oneOfType([Yr.default.bool, Yr.default.string]),
  offset: Yr.default.number,
  delay: Yr.default.number,
  isDynamic: Yr.default.bool,
  onClick: Yr.default.func,
  duration: Yr.default.oneOfType([Yr.default.number, Yr.default.func]),
  absolute: Yr.default.bool,
  onSetActive: Yr.default.func,
  onSetInactive: Yr.default.func,
  ignoreCancelEvents: Yr.default.bool,
  hashSpy: Yr.default.bool,
  saveHashHistory: Yr.default.bool,
  spyThrottle: Yr.default.number
};
hg.default = function(e, t) {
  var n = t || WBe.default, r = function(i) {
    GBe(a, i);
    function a(s) {
      ZBe(this, a);
      var l = qBe(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
      return o.call(l), l.state = {
        active: !1
      }, l.beforeUnmountCallbacks = [], l;
    }
    return FBe(a, [{
      key: "getScrollSpyContainer",
      value: function() {
        var s = this.props.containerId, l = this.props.container;
        return s && !l ? document.getElementById(s) : l && l.nodeType ? l : document;
      }
    }, {
      key: "componentDidMount",
      value: function() {
        if (this.props.spy || this.props.hashSpy) {
          var s = this.getScrollSpyContainer();
          if (!Lv.default.isMounted(s)) {
            var l = Lv.default.mount(s, this.props.spyThrottle);
            this.beforeUnmountCallbacks.push(l);
          }
          this.props.hashSpy && (wl.default.isMounted() || wl.default.mount(n), wl.default.mapContainer(this.props.to, s)), Lv.default.addSpyHandler(this.spyHandler, s), this.setState({
            container: s
          });
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        Lv.default.unmount(this.stateHandler, this.spyHandler), this.beforeUnmountCallbacks.forEach(function(s) {
          return s();
        });
      }
    }, {
      key: "render",
      value: function() {
        var s = "";
        this.state && this.state.active ? s = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : s = this.props.className;
        var l = {};
        this.state && this.state.active ? l = kv({}, this.props.style, this.props.activeStyle) : l = kv({}, this.props.style);
        var u = kv({}, this.props);
        for (var c in q$)
          u.hasOwnProperty(c) && delete u[c];
        return u.className = s, u.style = l, u.onClick = this.handleClick, Z$.default.createElement(e, u);
      }
    }]), a;
  }(Z$.default.PureComponent), o = function() {
    var i = this;
    this.scrollTo = function(a, s) {
      n.scrollTo(a, kv({}, i.state, s));
    }, this.handleClick = function(a) {
      i.props.onClick && i.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), i.scrollTo(i.props.to, i.props);
    }, this.spyHandler = function(a, s) {
      var l = i.getScrollSpyContainer();
      if (!(wl.default.isMounted() && !wl.default.isInitialized())) {
        var u = i.props.horizontal, c = i.props.to, p = null, d = void 0, g = void 0;
        if (u) {
          var f = 0, m = 0, b = 0;
          if (l.getBoundingClientRect) {
            var E = l.getBoundingClientRect();
            b = E.left;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var w = p.getBoundingClientRect();
            f = w.left - b + a, m = f + w.width;
          }
          var M = a - i.props.offset;
          d = M >= Math.floor(f) && M < Math.floor(m), g = M < Math.floor(f) || M >= Math.floor(m);
        } else {
          var x = 0, v = 0, C = 0;
          if (l.getBoundingClientRect) {
            var P = l.getBoundingClientRect();
            C = P.top;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var F = p.getBoundingClientRect();
            x = F.top - C + s, v = x + F.height;
          }
          var L = s - i.props.offset;
          d = L >= Math.floor(x) && L < Math.floor(v), g = L < Math.floor(x) || L >= Math.floor(v);
        }
        var B = n.getActiveLink();
        if (g) {
          if (c === B && n.setActiveLink(void 0), i.props.hashSpy && wl.default.getHash() === c) {
            var N = i.props.saveHashHistory, $ = N === void 0 ? !1 : N;
            wl.default.changeHash("", $);
          }
          i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive(c, p));
        }
        if (d && (B !== c || i.state.active === !1)) {
          n.setActiveLink(c);
          var V = i.props.saveHashHistory, H = V === void 0 ? !1 : V;
          i.props.hashSpy && wl.default.changeHash(c, H), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(c, p));
        }
      }
    };
  };
  return r.propTypes = q$, r.defaultProps = { offset: 0 }, r;
};
Object.defineProperty(lT, "__esModule", {
  value: !0
});
var KBe = be, G$ = Ute(KBe), XBe = hg, YBe = Ute(XBe);
function Ute(e) {
  return e && e.__esModule ? e : { default: e };
}
function JBe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function K$(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function QBe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var eFe = function(e) {
  QBe(t, e);
  function t() {
    var n, r, o, i;
    JBe(this, t);
    for (var a = arguments.length, s = Array(a), l = 0; l < a; l++)
      s[l] = arguments[l];
    return i = (r = (o = K$(this, (n = t.__proto__ || Object.getPrototypeOf(t)).call.apply(n, [this].concat(s))), o), o.render = function() {
      return G$.default.createElement(
        "a",
        o.props,
        o.props.children
      );
    }, r), K$(o, i);
  }
  return t;
}(G$.default.Component);
lT.default = (0, YBe.default)(eFe);
var hT = {};
Object.defineProperty(hT, "__esModule", {
  value: !0
});
var tFe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), nFe = be, X$ = Hte(nFe), rFe = hg, oFe = Hte(rFe);
function Hte(e) {
  return e && e.__esModule ? e : { default: e };
}
function iFe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function sFe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function aFe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var lFe = function(e) {
  aFe(t, e);
  function t() {
    return iFe(this, t), sFe(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return tFe(t, [{
    key: "render",
    value: function() {
      return X$.default.createElement(
        "button",
        this.props,
        this.props.children
      );
    }
  }]), t;
}(X$.default.Component);
hT.default = (0, oFe.default)(lFe);
var gT = {}, xO = {};
Object.defineProperty(xO, "__esModule", {
  value: !0
});
var uFe = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, cFe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), pFe = be, Y$ = EO(pFe), dFe = il;
EO(dFe);
var fFe = $p, J$ = EO(fFe), hFe = CO, Q$ = EO(hFe);
function EO(e) {
  return e && e.__esModule ? e : { default: e };
}
function gFe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function mFe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function vFe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
xO.default = function(e) {
  var t = function(n) {
    vFe(r, n);
    function r(o) {
      gFe(this, r);
      var i = mFe(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
      return i.childBindings = {
        domNode: null
      }, i;
    }
    return cFe(r, [{
      key: "componentDidMount",
      value: function() {
        if (typeof window > "u")
          return !1;
        this.registerElems(this.props.name);
      }
    }, {
      key: "componentDidUpdate",
      value: function(o) {
        this.props.name !== o.name && this.registerElems(this.props.name);
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        if (typeof window > "u")
          return !1;
        J$.default.unregister(this.props.name);
      }
    }, {
      key: "registerElems",
      value: function(o) {
        J$.default.register(o, this.childBindings.domNode);
      }
    }, {
      key: "render",
      value: function() {
        return Y$.default.createElement(e, uFe({}, this.props, { parentBindings: this.childBindings }));
      }
    }]), r;
  }(Y$.default.Component);
  return t.propTypes = {
    name: Q$.default.string,
    id: Q$.default.string
  }, t;
};
Object.defineProperty(gT, "__esModule", {
  value: !0
});
var e3 = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, yFe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), bFe = be, t3 = mT(bFe), wFe = xO, CFe = mT(wFe), OFe = CO, n3 = mT(OFe);
function mT(e) {
  return e && e.__esModule ? e : { default: e };
}
function xFe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function EFe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function kFe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var Wte = function(e) {
  kFe(t, e);
  function t() {
    return xFe(this, t), EFe(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return yFe(t, [{
    key: "render",
    value: function() {
      var n = this, r = e3({}, this.props);
      return delete r.name, r.parentBindings && delete r.parentBindings, t3.default.createElement(
        "div",
        e3({}, r, { ref: function(o) {
          n.props.parentBindings.domNode = o;
        } }),
        this.props.children
      );
    }
  }]), t;
}(t3.default.Component);
Wte.propTypes = {
  name: n3.default.string,
  id: n3.default.string
};
gT.default = (0, CFe.default)(Wte);
var fk = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, r3 = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}();
function o3(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function i3(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function s3(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var _v = be, Fu = gg, hk = $p, Co = CO, Cl = OO, a3 = {
  to: Co.string.isRequired,
  containerId: Co.string,
  container: Co.object,
  activeClass: Co.string,
  spy: Co.bool,
  smooth: Co.oneOfType([Co.bool, Co.string]),
  offset: Co.number,
  delay: Co.number,
  isDynamic: Co.bool,
  onClick: Co.func,
  duration: Co.oneOfType([Co.number, Co.func]),
  absolute: Co.bool,
  onSetActive: Co.func,
  onSetInactive: Co.func,
  ignoreCancelEvents: Co.bool,
  hashSpy: Co.bool,
  spyThrottle: Co.number
}, LFe = {
  Scroll: function(e, t) {
    console.warn("Helpers.Scroll is deprecated since v1.7.0");
    var n = t || hk, r = function(i) {
      s3(a, i);
      function a(s) {
        o3(this, a);
        var l = i3(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
        return o.call(l), l.state = {
          active: !1
        }, l;
      }
      return r3(a, [{
        key: "getScrollSpyContainer",
        value: function() {
          var s = this.props.containerId, l = this.props.container;
          return s ? document.getElementById(s) : l && l.nodeType ? l : document;
        }
      }, {
        key: "componentDidMount",
        value: function() {
          if (this.props.spy || this.props.hashSpy) {
            var s = this.getScrollSpyContainer();
            Fu.isMounted(s) || Fu.mount(s, this.props.spyThrottle), this.props.hashSpy && (Cl.isMounted() || Cl.mount(n), Cl.mapContainer(this.props.to, s)), this.props.spy && Fu.addStateHandler(this.stateHandler), Fu.addSpyHandler(this.spyHandler, s), this.setState({
              container: s
            });
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          Fu.unmount(this.stateHandler, this.spyHandler);
        }
      }, {
        key: "render",
        value: function() {
          var s = "";
          this.state && this.state.active ? s = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : s = this.props.className;
          var l = fk({}, this.props);
          for (var u in a3)
            l.hasOwnProperty(u) && delete l[u];
          return l.className = s, l.onClick = this.handleClick, _v.createElement(e, l);
        }
      }]), a;
    }(_v.Component), o = function() {
      var i = this;
      this.scrollTo = function(a, s) {
        n.scrollTo(a, fk({}, i.state, s));
      }, this.handleClick = function(a) {
        i.props.onClick && i.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), i.scrollTo(i.props.to, i.props);
      }, this.stateHandler = function() {
        n.getActiveLink() !== i.props.to && (i.state !== null && i.state.active && i.props.onSetInactive && i.props.onSetInactive(), i.setState({ active: !1 }));
      }, this.spyHandler = function(a) {
        var s = i.getScrollSpyContainer();
        if (!(Cl.isMounted() && !Cl.isInitialized())) {
          var l = i.props.to, u = null, c = 0, p = 0, d = 0;
          if (s.getBoundingClientRect) {
            var g = s.getBoundingClientRect();
            d = g.top;
          }
          if (!u || i.props.isDynamic) {
            if (u = n.get(l), !u)
              return;
            var f = u.getBoundingClientRect();
            c = f.top - d + a, p = c + f.height;
          }
          var m = a - i.props.offset, b = m >= Math.floor(c) && m < Math.floor(p), E = m < Math.floor(c) || m >= Math.floor(p), w = n.getActiveLink();
          if (E)
            return l === w && n.setActiveLink(void 0), i.props.hashSpy && Cl.getHash() === l && Cl.changeHash(), i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive()), Fu.updateStates();
          if (b && w !== l)
            return n.setActiveLink(l), i.props.hashSpy && Cl.changeHash(l), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(l)), Fu.updateStates();
        }
      };
    };
    return r.propTypes = a3, r.defaultProps = { offset: 0 }, r;
  },
  Element: function(e) {
    console.warn("Helpers.Element is deprecated since v1.7.0");
    var t = function(n) {
      s3(r, n);
      function r(o) {
        o3(this, r);
        var i = i3(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
        return i.childBindings = {
          domNode: null
        }, i;
      }
      return r3(r, [{
        key: "componentDidMount",
        value: function() {
          if (typeof window > "u")
            return !1;
          this.registerElems(this.props.name);
        }
      }, {
        key: "componentDidUpdate",
        value: function(o) {
          this.props.name !== o.name && this.registerElems(this.props.name);
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          if (typeof window > "u")
            return !1;
          hk.unregister(this.props.name);
        }
      }, {
        key: "registerElems",
        value: function(o) {
          hk.register(o, this.childBindings.domNode);
        }
      }, {
        key: "render",
        value: function() {
          return _v.createElement(e, fk({}, this.props, { parentBindings: this.childBindings }));
        }
      }]), r;
    }(_v.Component);
    return t.propTypes = {
      name: Co.string,
      id: Co.string
    }, t;
  }
}, _Fe = LFe;
Object.defineProperty(Io, "__esModule", {
  value: !0
});
Io.Helpers = Io.ScrollElement = Io.ScrollLink = Io.animateScroll = Io.scrollSpy = Io.Events = Io.scroller = Io.Element = Io.Button = Io.Link = void 0;
var PFe = lT, $te = wa(PFe), SFe = hT, Vte = wa(SFe), MFe = gT, Zte = wa(MFe), DFe = $p, qte = wa(DFe), TFe = yg, Gte = wa(TFe), jFe = gg, Kte = wa(jFe), AFe = yO, Xte = wa(AFe), RFe = hg, Yte = wa(RFe), IFe = xO, Jte = wa(IFe), NFe = _Fe, Qte = wa(NFe);
function wa(e) {
  return e && e.__esModule ? e : { default: e };
}
Io.Link = $te.default;
Io.Button = Vte.default;
Io.Element = Zte.default;
Io.scroller = qte.default;
Io.Events = Gte.default;
Io.scrollSpy = Kte.default;
Io.animateScroll = Xte.default;
Io.ScrollLink = Yte.default;
Io.ScrollElement = Jte.default;
Io.Helpers = Qte.default;
Io.default = { Link: $te.default, Button: Vte.default, Element: Zte.default, scroller: qte.default, Events: Gte.default, scrollSpy: Kte.default, animateScroll: Xte.default, ScrollLink: Yte.default, ScrollElement: Jte.default, Helpers: Qte.default };
$e({});
$e({});
$e({});
function Ah(e) {
  "@babel/helpers - typeof";
  return Ah = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Ah(e);
}
function BFe(e, t) {
  if (Ah(e) != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (Ah(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function FFe(e) {
  var t = BFe(e, "string");
  return Ah(t) == "symbol" ? t : t + "";
}
function Se(e, t, n) {
  return (t = FFe(t)) in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function ene(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var gk, l3;
function zFe() {
  if (l3) return gk;
  l3 = 1;
  var e = process.env.NODE_ENV, t = function(n, r, o, i, a, s, l, u) {
    if (e !== "production" && r === void 0)
      throw new Error("invariant requires an error message argument");
    if (!n) {
      var c;
      if (r === void 0)
        c = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
      else {
        var p = [o, i, a, s, l, u], d = 0;
        c = new Error(r.replace(/%s/g, function() {
          return p[d++];
        })), c.name = "Invariant Violation";
      }
      throw c.framesToPop = 1, c;
    }
  };
  return gk = t, gk;
}
var UFe = zFe(), $o = /* @__PURE__ */ ene(UFe), Bt = $e(null);
function HFe() {
  $o(!!ge, "useGoogleMap is React hook and requires React version 16.8+");
  var e = ge(Bt);
  return $o(!!e, "useGoogleMap needs a GoogleMap available up in the tree"), e;
}
function WFe(e, t, n) {
  return Object.keys(e).reduce(function(r, o) {
    return t(r, e[o], o);
  }, n);
}
function $Fe(e, t) {
  Object.keys(e).forEach((n) => t(e[n], n));
}
function VFe(e, t, n, r) {
  var o = {}, i = (a, s) => {
    var l = n[s];
    l !== t[s] && (o[s] = l, a(r, l));
  };
  return $Fe(e, i), o;
}
function ZFe(e, t, n) {
  var r = WFe(n, function(o, i, a) {
    return typeof e[a] == "function" && o.push(google.maps.event.addListener(t, i, e[a])), o;
  }, []);
  return r;
}
function qFe(e) {
  google.maps.event.removeListener(e);
}
function _n() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  e.forEach(qFe);
}
function wn(e) {
  var {
    updaterMap: t,
    eventMap: n,
    prevProps: r,
    nextProps: o,
    instance: i
  } = e, a = ZFe(o, i, n);
  return VFe(t, r, o, i), a;
}
function GFe(e) {
  var {
    children: t,
    options: n,
    id: r,
    mapContainerStyle: o,
    mapContainerClassName: i,
    center: a,
    // clickableIcons,
    // extraMapTypes,
    // heading,
    // mapTypeId,
    onClick: s,
    onDblClick: l,
    onDrag: u,
    onDragEnd: c,
    onDragStart: p,
    onMouseMove: d,
    onMouseOut: g,
    onMouseOver: f,
    onMouseDown: m,
    onMouseUp: b,
    onRightClick: E,
    // onMapTypeIdChanged,
    // onTilesLoaded,
    // onBoundsChanged,
    onCenterChanged: w,
    // onHeadingChanged,
    // onIdle,
    // onProjectionChanged,
    // onResize,
    // onTiltChanged,
    // onZoomChanged,
    onLoad: M,
    onUnmount: x
  } = e, [v, C] = k(null), P = dt(null), [F, L] = k(null), [B, N] = k(null), [$, V] = k(null), [H, Z] = k(null), [K, Y] = k(null), [Q, J] = k(null), [_, D] = k(null), [z, S] = k(null), [W, O] = k(null), [j, U] = k(null), [T, q] = k(null), [A, X] = k(null);
  return h(() => {
    n && v !== null && v.setOptions(n);
  }, [v, n]), h(() => {
    v !== null && typeof a < "u" && v.setCenter(a);
  }, [v, a]), h(() => {
    v && l && (B !== null && google.maps.event.removeListener(B), N(google.maps.event.addListener(v, "dblclick", l)));
  }, [l]), h(() => {
    v && c && ($ !== null && google.maps.event.removeListener($), V(google.maps.event.addListener(v, "dragend", c)));
  }, [c]), h(() => {
    v && p && (H !== null && google.maps.event.removeListener(H), Z(google.maps.event.addListener(v, "dragstart", p)));
  }, [p]), h(() => {
    v && m && (K !== null && google.maps.event.removeListener(K), Y(google.maps.event.addListener(v, "mousedown", m)));
  }, [m]), h(() => {
    v && d && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(v, "mousemove", d)));
  }, [d]), h(() => {
    v && g && (_ !== null && google.maps.event.removeListener(_), D(google.maps.event.addListener(v, "mouseout", g)));
  }, [g]), h(() => {
    v && f && (z !== null && google.maps.event.removeListener(z), S(google.maps.event.addListener(v, "mouseover", f)));
  }, [f]), h(() => {
    v && b && (W !== null && google.maps.event.removeListener(W), O(google.maps.event.addListener(v, "mouseup", b)));
  }, [b]), h(() => {
    v && E && (j !== null && google.maps.event.removeListener(j), U(google.maps.event.addListener(v, "rightclick", E)));
  }, [E]), h(() => {
    v && s && (T !== null && google.maps.event.removeListener(T), q(google.maps.event.addListener(v, "click", s)));
  }, [s]), h(() => {
    v && u && (A !== null && google.maps.event.removeListener(A), X(google.maps.event.addListener(v, "drag", u)));
  }, [u]), h(() => {
    v && w && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(v, "center_changed", w)));
  }, [s]), h(() => {
    var I = P.current === null ? null : new google.maps.Map(P.current, n);
    return C(I), I !== null && M && M(I), () => {
      I !== null && x && x(I);
    };
  }, []), Qo.jsx("div", {
    id: r,
    ref: P,
    style: o,
    className: i,
    children: Qo.jsx(Bt.Provider, {
      value: v,
      children: v !== null ? t : null
    })
  });
}
me(GFe);
function u3(e, t, n, r, o, i, a) {
  try {
    var s = e[i](a), l = s.value;
  } catch (u) {
    return void n(u);
  }
  s.done ? t(l) : Promise.resolve(l).then(r, o);
}
function tne(e) {
  return function() {
    var t = this, n = arguments;
    return new Promise(function(r, o) {
      var i = e.apply(t, n);
      function a(l) {
        u3(i, r, o, a, s, "next", l);
      }
      function s(l) {
        u3(i, r, o, a, s, "throw", l);
      }
      a(void 0);
    });
  };
}
function nne(e) {
  var {
    googleMapsApiKey: t,
    googleMapsClientId: n,
    version: r = "weekly",
    language: o,
    region: i,
    libraries: a,
    channel: s,
    mapIds: l,
    authReferrerPolicy: u
  } = e, c = [];
  return $o(t && n || !(t && n), "You need to specify either googleMapsApiKey or googleMapsClientId for @react-google-maps/api load script to work. You cannot use both at the same time."), t ? c.push("key=".concat(t)) : n && c.push("client=".concat(n)), r && c.push("v=".concat(r)), o && c.push("language=".concat(o)), i && c.push("region=".concat(i)), a && a.length && c.push("libraries=".concat(a.sort().join(","))), s && c.push("channel=".concat(s)), l && l.length && c.push("map_ids=".concat(l.join(","))), u && c.push("auth_referrer_policy=".concat(u)), c.push("loading=async"), c.push("callback=initMap"), "https://maps.googleapis.com/maps/api/js?".concat(c.join("&"));
}
var mc = typeof document < "u";
function rne(e) {
  var {
    url: t,
    id: n,
    nonce: r
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } = e;
  return mc ? new Promise(function(o, i) {
    var a = document.getElementById(n), s = window;
    if (a) {
      var l = a.getAttribute("data-state");
      if (a.src === t && l !== "error") {
        if (l === "ready")
          return o(n);
        var u = s.initMap, c = a.onerror;
        s.initMap = function() {
          u && u(), o(n);
        }, a.onerror = function(d) {
          c && c(d), i(d);
        };
        return;
      } else
        a.remove();
    }
    var p = document.createElement("script");
    p.type = "text/javascript", p.src = t, p.id = n, p.async = !0, p.nonce = r || "", p.onerror = function(d) {
      p.setAttribute("data-state", "error"), i(d);
    }, s.initMap = function() {
      p.setAttribute("data-state", "ready"), o(n);
    }, document.head.appendChild(p);
  }).catch((o) => {
    throw console.error("injectScript error: ", o), o;
  }) : Promise.reject(new Error("document is undefined"));
}
function c3(e) {
  var t = e.href;
  return t && (t.indexOf("https://fonts.googleapis.com/css?family=Roboto") === 0 || t.indexOf("https://fonts.googleapis.com/css?family=Google+Sans+Text") === 0) ? !0 : (
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.styleSheet.cssText = "", !0) : (
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.innerHTML = "", !0) : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.innerHTML
      )
    )
  );
}
function one() {
  var e = document.getElementsByTagName("head")[0];
  if (e) {
    var t = e.insertBefore.bind(e);
    e.insertBefore = function(r, o) {
      return c3(r) || Reflect.apply(t, e, [r, o]), r;
    };
    var n = e.appendChild.bind(e);
    e.appendChild = function(r) {
      return c3(r) || Reflect.apply(n, e, [r]), r;
    };
  }
}
var Ld = !1;
function ine() {
  return Qo.jsx("div", {
    children: "Loading..."
  });
}
var eP = {
  id: "script-loader",
  version: "weekly"
};
class KFe extends pe {
  constructor() {
    super(...arguments), Se(this, "check", null), Se(this, "state", {
      loaded: !1
    }), Se(this, "cleanupCallback", () => {
      delete window.google.maps, this.injectScript();
    }), Se(this, "isCleaningUp", /* @__PURE__ */ tne(function* () {
      function t(n) {
        if (!Ld)
          n();
        else if (mc)
          var r = window.setInterval(function() {
            Ld || (window.clearInterval(r), n());
          }, 1);
      }
      return new Promise(t);
    })), Se(this, "cleanup", () => {
      Ld = !0;
      var t = document.getElementById(this.props.id);
      t && t.parentNode && t.parentNode.removeChild(t), Array.prototype.slice.call(document.getElementsByTagName("script")).filter(function(n) {
        return typeof n.src == "string" && n.src.includes("maps.googleapis");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("link")).filter(function(n) {
        return n.href === "https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Google+Sans";
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("style")).filter(function(n) {
        return n.innerText !== void 0 && n.innerText.length > 0 && n.innerText.includes(".gm-");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      });
    }), Se(this, "injectScript", () => {
      this.props.preventGoogleFontsLoading && one(), $o(!!this.props.id, 'LoadScript requires "id" prop to be a string: %s', this.props.id);
      var t = {
        id: this.props.id,
        nonce: this.props.nonce,
        url: nne(this.props)
      };
      rne(t).then(() => {
        this.props.onLoad && this.props.onLoad(), this.setState(function() {
          return {
            loaded: !0
          };
        });
      }).catch((n) => {
        this.props.onError && this.props.onError(n), console.error(`
          There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(this.props.googleMapsApiKey || "-", ") or Client ID (").concat(this.props.googleMapsClientId || "-", `) to <LoadScript />
          Otherwise it is a Network issue.
        `));
      });
    }), Se(this, "getRef", (t) => {
      this.check = t;
    });
  }
  componentDidMount() {
    if (mc) {
      if (window.google && window.google.maps && !Ld) {
        console.error("google api is already presented");
        return;
      }
      this.isCleaningUp().then(this.injectScript).catch(function(t) {
        console.error("Error at injecting script after cleaning up: ", t);
      });
    }
  }
  componentDidUpdate(t) {
    this.props.libraries !== t.libraries && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), mc && t.language !== this.props.language && (this.cleanup(), this.setState(function() {
      return {
        loaded: !1
      };
    }, this.cleanupCallback));
  }
  componentWillUnmount() {
    if (mc) {
      this.cleanup();
      var t = () => {
        this.check || (delete window.google, Ld = !1);
      };
      window.setTimeout(t, 1), this.props.onUnmount && this.props.onUnmount();
    }
  }
  render() {
    return Qo.jsxs(Qo.Fragment, {
      children: [Qo.jsx("div", {
        ref: this.getRef
      }), this.state.loaded ? this.props.children : this.props.loadingElement || Qo.jsx(ine, {})]
    });
  }
}
Se(KFe, "defaultProps", eP);
function XFe(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.includes(r)) continue;
    n[r] = e[r];
  }
  return n;
}
function vT(e, t) {
  if (e == null) return {};
  var n, r, o = XFe(e, t);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (r = 0; r < i.length; r++) n = i[r], t.includes(n) || {}.propertyIsEnumerable.call(e, n) && (o[n] = e[n]);
  }
  return o;
}
var p3;
function YFe(e) {
  var {
    id: t = eP.id,
    version: n = eP.version,
    nonce: r,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    preventGoogleFontsLoading: u,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  } = e, g = dt(!1), [f, m] = k(!1), [b, E] = k(void 0);
  h(function() {
    return g.current = !0, () => {
      g.current = !1;
    };
  }, []), h(function() {
    mc && u && one();
  }, [u]), h(function() {
    f && $o(!!window.google, "useLoadScript was marked as loaded, but window.google is not present. Something went wrong.");
  }, [f]);
  var w = nne({
    version: n,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  });
  h(function() {
    if (!mc)
      return;
    function x() {
      g.current && (m(!0), p3 = w);
    }
    if (window.google && window.google.maps && p3 === w) {
      x();
      return;
    }
    rne({
      id: t,
      url: w,
      nonce: r
    }).then(x).catch(function(v) {
      g.current && E(v), console.warn(`
        There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(o || "-", ") or Client ID (").concat(i || "-", `)
        Otherwise it is a Network issue.
      `)), console.error(v);
    });
  }, [t, w, r]);
  var M = dt(void 0);
  return h(function() {
    M.current && l !== M.current && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), M.current = l;
  }, [l]), {
    isLoaded: f,
    loadError: b,
    url: w
  };
}
var JFe = ["loadingElement", "onLoad", "onError", "onUnmount", "children"], QFe = Qo.jsx(ine, {});
function eze(e) {
  var {
    loadingElement: t,
    onLoad: n,
    onError: r,
    onUnmount: o,
    children: i
  } = e, a = vT(e, JFe), {
    isLoaded: s,
    loadError: l
  } = YFe(a);
  return h(function() {
    s && typeof n == "function" && n();
  }, [s, n]), h(function() {
    l && typeof r == "function" && r(l);
  }, [l, r]), h(function() {
    return () => {
      o && o();
    };
  }, [o]), s ? i : t || QFe;
}
me(eze);
var d3;
(function(e) {
  e[e.INITIALIZED = 0] = "INITIALIZED", e[e.LOADING = 1] = "LOADING", e[e.SUCCESS = 2] = "SUCCESS", e[e.FAILURE = 3] = "FAILURE";
})(d3 || (d3 = {}));
function f3(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function lw(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? f3(Object(n), !0).forEach(function(r) {
      Se(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : f3(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var h3 = {}, g3 = {
  options(e, t) {
    e.setOptions(t);
  }
};
function tze(e) {
  var {
    options: t,
    onLoad: n,
    onUnmount: r
  } = e, o = ge(Bt), [i, a] = k(null);
  return h(() => {
    i !== null && i.setMap(o);
  }, [o]), h(() => {
    t && i !== null && i.setOptions(t);
  }, [i, t]), h(() => {
    var s = new google.maps.TrafficLayer(lw(lw({}, t), {}, {
      map: o
    }));
    return a(s), n && n(s), () => {
      i !== null && (r && r(i), i.setMap(null));
    };
  }, []), null;
}
me(tze);
class nze extends pe {
  constructor() {
    super(...arguments), Se(this, "state", {
      trafficLayer: null
    }), Se(this, "setTrafficLayerCallback", () => {
      this.state.trafficLayer !== null && this.props.onLoad && this.props.onLoad(this.state.trafficLayer);
    }), Se(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = new google.maps.TrafficLayer(lw(lw({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = wn({
      updaterMap: g3,
      eventMap: h3,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        trafficLayer: t
      };
    }, this.setTrafficLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.trafficLayer !== null && (_n(this.registeredEvents), this.registeredEvents = wn({
      updaterMap: g3,
      eventMap: h3,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.trafficLayer
    }));
  }
  componentWillUnmount() {
    this.state.trafficLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.trafficLayer), _n(this.registeredEvents), this.state.trafficLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Se(nze, "contextType", Bt);
function rze(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = ge(Bt), [o, i] = k(null);
  return h(() => {
    o !== null && o.setMap(r);
  }, [r]), h(() => {
    var a = new google.maps.BicyclingLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      a !== null && (n && n(a), a.setMap(null));
    };
  }, []), null;
}
me(rze);
class oze extends pe {
  constructor() {
    super(...arguments), Se(this, "state", {
      bicyclingLayer: null
    }), Se(this, "setBicyclingLayerCallback", () => {
      this.state.bicyclingLayer !== null && (this.state.bicyclingLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.bicyclingLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.BicyclingLayer();
    this.setState(() => ({
      bicyclingLayer: t
    }), this.setBicyclingLayerCallback);
  }
  componentWillUnmount() {
    this.state.bicyclingLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.bicyclingLayer), this.state.bicyclingLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Se(oze, "contextType", Bt);
function ize(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = ge(Bt), [o, i] = k(null);
  return h(() => {
    o !== null && o.setMap(r);
  }, [r]), h(() => {
    var a = new google.maps.TransitLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      o !== null && (n && n(o), o.setMap(null));
    };
  }, []), null;
}
me(ize);
class sze extends pe {
  constructor() {
    super(...arguments), Se(this, "state", {
      transitLayer: null
    }), Se(this, "setTransitLayerCallback", () => {
      this.state.transitLayer !== null && (this.state.transitLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.transitLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.TransitLayer();
    this.setState(function() {
      return {
        transitLayer: t
      };
    }, this.setTransitLayerCallback);
  }
  componentWillUnmount() {
    this.state.transitLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.transitLayer), this.state.transitLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Se(sze, "contextType", Bt);
function m3(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function uw(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? m3(Object(n), !0).forEach(function(r) {
      Se(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : m3(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var v3 = {
  onCircleComplete: "circlecomplete",
  onMarkerComplete: "markercomplete",
  onOverlayComplete: "overlaycomplete",
  onPolygonComplete: "polygoncomplete",
  onPolylineComplete: "polylinecomplete",
  onRectangleComplete: "rectanglecomplete"
}, y3 = {
  drawingMode(e, t) {
    e.setDrawingMode(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function aze(e) {
  var {
    options: t,
    drawingMode: n,
    onCircleComplete: r,
    onMarkerComplete: o,
    onOverlayComplete: i,
    onPolygonComplete: a,
    onPolylineComplete: s,
    onRectangleComplete: l,
    onLoad: u,
    onUnmount: c
  } = e, p = ge(Bt), [d, g] = k(null), [f, m] = k(null), [b, E] = k(null), [w, M] = k(null), [x, v] = k(null), [C, P] = k(null), [F, L] = k(null);
  return h(() => {
    d !== null && d.setMap(p);
  }, [p]), h(() => {
    t && d !== null && d.setOptions(t);
  }, [d, t]), h(() => {
    d !== null && d.setDrawingMode(n ?? null);
  }, [d, n]), h(() => {
    d && r && (f !== null && google.maps.event.removeListener(f), m(google.maps.event.addListener(d, "circlecomplete", r)));
  }, [d, r]), h(() => {
    d && o && (b !== null && google.maps.event.removeListener(b), E(google.maps.event.addListener(d, "markercomplete", o)));
  }, [d, o]), h(() => {
    d && i && (w !== null && google.maps.event.removeListener(w), M(google.maps.event.addListener(d, "overlaycomplete", i)));
  }, [d, i]), h(() => {
    d && a && (x !== null && google.maps.event.removeListener(x), v(google.maps.event.addListener(d, "polygoncomplete", a)));
  }, [d, a]), h(() => {
    d && s && (C !== null && google.maps.event.removeListener(C), P(google.maps.event.addListener(d, "polylinecomplete", s)));
  }, [d, s]), h(() => {
    d && l && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(d, "rectanglecomplete", l)));
  }, [d, l]), h(() => {
    $o(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
    var B = new google.maps.drawing.DrawingManager(uw(uw({}, t), {}, {
      map: p
    }));
    return n && B.setDrawingMode(n), r && m(google.maps.event.addListener(B, "circlecomplete", r)), o && E(google.maps.event.addListener(B, "markercomplete", o)), i && M(google.maps.event.addListener(B, "overlaycomplete", i)), a && v(google.maps.event.addListener(B, "polygoncomplete", a)), s && P(google.maps.event.addListener(B, "polylinecomplete", s)), l && L(google.maps.event.addListener(B, "rectanglecomplete", l)), g(B), u && u(B), () => {
      d !== null && (f && google.maps.event.removeListener(f), b && google.maps.event.removeListener(b), w && google.maps.event.removeListener(w), x && google.maps.event.removeListener(x), C && google.maps.event.removeListener(C), F && google.maps.event.removeListener(F), c && c(d), d.setMap(null));
    };
  }, []), null;
}
me(aze);
class lze extends pe {
  constructor(t) {
    super(t), Se(this, "registeredEvents", []), Se(this, "state", {
      drawingManager: null
    }), Se(this, "setDrawingManagerCallback", () => {
      this.state.drawingManager !== null && this.props.onLoad && this.props.onLoad(this.state.drawingManager);
    }), $o(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
  }
  componentDidMount() {
    var t = new google.maps.drawing.DrawingManager(uw(uw({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = wn({
      updaterMap: y3,
      eventMap: v3,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        drawingManager: t
      };
    }, this.setDrawingManagerCallback);
  }
  componentDidUpdate(t) {
    this.state.drawingManager !== null && (_n(this.registeredEvents), this.registeredEvents = wn({
      updaterMap: y3,
      eventMap: v3,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.drawingManager
    }));
  }
  componentWillUnmount() {
    this.state.drawingManager !== null && (this.props.onUnmount && this.props.onUnmount(this.state.drawingManager), _n(this.registeredEvents), this.state.drawingManager.setMap(null));
  }
  render() {
    return null;
  }
}
Se(lze, "contextType", Bt);
function b3(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function fp(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? b3(Object(n), !0).forEach(function(r) {
      Se(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : b3(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var w3 = {
  onAnimationChanged: "animation_changed",
  onClick: "click",
  onClickableChanged: "clickable_changed",
  onCursorChanged: "cursor_changed",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDraggableChanged: "draggable_changed",
  onDragStart: "dragstart",
  onFlatChanged: "flat_changed",
  onIconChanged: "icon_changed",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onPositionChanged: "position_changed",
  onRightClick: "rightclick",
  onShapeChanged: "shape_changed",
  onTitleChanged: "title_changed",
  onVisibleChanged: "visible_changed",
  onZindexChanged: "zindex_changed"
}, C3 = {
  animation(e, t) {
    e.setAnimation(t);
  },
  clickable(e, t) {
    e.setClickable(t);
  },
  cursor(e, t) {
    e.setCursor(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  icon(e, t) {
    e.setIcon(t);
  },
  label(e, t) {
    e.setLabel(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  opacity(e, t) {
    e.setOpacity(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  shape(e, t) {
    e.setShape(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, cw = {};
function uze(e) {
  var {
    position: t,
    options: n,
    clusterer: r,
    noClustererRedraw: o,
    children: i,
    draggable: a,
    visible: s,
    animation: l,
    clickable: u,
    cursor: c,
    icon: p,
    label: d,
    opacity: g,
    shape: f,
    title: m,
    zIndex: b,
    onClick: E,
    onDblClick: w,
    onDrag: M,
    onDragEnd: x,
    onDragStart: v,
    onMouseOut: C,
    onMouseOver: P,
    onMouseUp: F,
    onMouseDown: L,
    onRightClick: B,
    onClickableChanged: N,
    onCursorChanged: $,
    onAnimationChanged: V,
    onDraggableChanged: H,
    onFlatChanged: Z,
    onIconChanged: K,
    onPositionChanged: Y,
    onShapeChanged: Q,
    onTitleChanged: J,
    onVisibleChanged: _,
    onZindexChanged: D,
    onLoad: z,
    onUnmount: S
  } = e, W = ge(Bt), [O, j] = k(null), [U, T] = k(null), [q, A] = k(null), [X, I] = k(null), [le, he] = k(null), [oe, Ae] = k(null), [Ue, He] = k(null), [Re, nt] = k(null), [Ve, we] = k(null), [et, lt] = k(null), [ye, ke] = k(null), [Qe, Fe] = k(null), [Ie, ot] = k(null), [Ee, wt] = k(null), [it, st] = k(null), [ut, Ct] = k(null), [ct, pt] = k(null), [rt, We] = k(null), [Ot, xt] = k(null), [gt, Ht] = k(null), [mt, Wt] = k(null), [vt, kt] = k(null);
  h(() => {
    O !== null && O.setMap(W);
  }, [W]), h(() => {
    typeof n < "u" && O !== null && O.setOptions(n);
  }, [O, n]), h(() => {
    typeof a < "u" && O !== null && O.setDraggable(a);
  }, [O, a]), h(() => {
    t && O !== null && O.setPosition(t);
  }, [O, t]), h(() => {
    typeof s < "u" && O !== null && O.setVisible(s);
  }, [O, s]), h(() => {
    O == null || O.setAnimation(l);
  }, [O, l]), h(() => {
    O && u !== void 0 && O.setClickable(u);
  }, [O, u]), h(() => {
    O && c !== void 0 && O.setCursor(c);
  }, [O, c]), h(() => {
    O && p !== void 0 && O.setIcon(p);
  }, [O, p]), h(() => {
    O && d !== void 0 && O.setLabel(d);
  }, [O, d]), h(() => {
    O && g !== void 0 && O.setOpacity(g);
  }, [O, g]), h(() => {
    O && f !== void 0 && O.setShape(f);
  }, [O, f]), h(() => {
    O && m !== void 0 && O.setTitle(m);
  }, [O, m]), h(() => {
    O && b !== void 0 && O.setZIndex(b);
  }, [O, b]), h(() => {
    O && w && (U !== null && google.maps.event.removeListener(U), T(google.maps.event.addListener(O, "dblclick", w)));
  }, [w]), h(() => {
    O && x && (q !== null && google.maps.event.removeListener(q), A(google.maps.event.addListener(O, "dragend", x)));
  }, [x]), h(() => {
    O && v && (X !== null && google.maps.event.removeListener(X), I(google.maps.event.addListener(O, "dragstart", v)));
  }, [v]), h(() => {
    O && L && (le !== null && google.maps.event.removeListener(le), he(google.maps.event.addListener(O, "mousedown", L)));
  }, [L]), h(() => {
    O && C && (oe !== null && google.maps.event.removeListener(oe), Ae(google.maps.event.addListener(O, "mouseout", C)));
  }, [C]), h(() => {
    O && P && (Ue !== null && google.maps.event.removeListener(Ue), He(google.maps.event.addListener(O, "mouseover", P)));
  }, [P]), h(() => {
    O && F && (Re !== null && google.maps.event.removeListener(Re), nt(google.maps.event.addListener(O, "mouseup", F)));
  }, [F]), h(() => {
    O && B && (Ve !== null && google.maps.event.removeListener(Ve), we(google.maps.event.addListener(O, "rightclick", B)));
  }, [B]), h(() => {
    O && E && (et !== null && google.maps.event.removeListener(et), lt(google.maps.event.addListener(O, "click", E)));
  }, [E]), h(() => {
    O && M && (ye !== null && google.maps.event.removeListener(ye), ke(google.maps.event.addListener(O, "drag", M)));
  }, [M]), h(() => {
    O && N && (Qe !== null && google.maps.event.removeListener(Qe), Fe(google.maps.event.addListener(O, "clickable_changed", N)));
  }, [N]), h(() => {
    O && $ && (Ie !== null && google.maps.event.removeListener(Ie), ot(google.maps.event.addListener(O, "cursor_changed", $)));
  }, [$]), h(() => {
    O && V && (Ee !== null && google.maps.event.removeListener(Ee), wt(google.maps.event.addListener(O, "animation_changed", V)));
  }, [V]), h(() => {
    O && H && (it !== null && google.maps.event.removeListener(it), st(google.maps.event.addListener(O, "draggable_changed", H)));
  }, [H]), h(() => {
    O && Z && (ut !== null && google.maps.event.removeListener(ut), Ct(google.maps.event.addListener(O, "flat_changed", Z)));
  }, [Z]), h(() => {
    O && K && (ct !== null && google.maps.event.removeListener(ct), pt(google.maps.event.addListener(O, "icon_changed", K)));
  }, [K]), h(() => {
    O && Y && (rt !== null && google.maps.event.removeListener(rt), We(google.maps.event.addListener(O, "position_changed", Y)));
  }, [Y]), h(() => {
    O && Q && (Ot !== null && google.maps.event.removeListener(Ot), xt(google.maps.event.addListener(O, "shape_changed", Q)));
  }, [Q]), h(() => {
    O && J && (gt !== null && google.maps.event.removeListener(gt), Ht(google.maps.event.addListener(O, "title_changed", J)));
  }, [J]), h(() => {
    O && _ && (mt !== null && google.maps.event.removeListener(mt), Wt(google.maps.event.addListener(O, "visible_changed", _)));
  }, [_]), h(() => {
    O && D && (vt !== null && google.maps.event.removeListener(vt), kt(google.maps.event.addListener(O, "zindex_changed", D)));
  }, [D]), h(() => {
    var yt = fp(fp(fp({}, n || cw), r ? cw : {
      map: W
    }), {}, {
      position: t
    }), re = new google.maps.Marker(yt);
    return r ? r.addMarker(re, !!o) : re.setMap(W), t && re.setPosition(t), typeof s < "u" && re.setVisible(s), typeof a < "u" && re.setDraggable(a), typeof u < "u" && re.setClickable(u), typeof c == "string" && re.setCursor(c), p && re.setIcon(p), typeof d < "u" && re.setLabel(d), typeof g < "u" && re.setOpacity(g), f && re.setShape(f), typeof m == "string" && re.setTitle(m), typeof b == "number" && re.setZIndex(b), w && T(google.maps.event.addListener(re, "dblclick", w)), x && A(google.maps.event.addListener(re, "dragend", x)), v && I(google.maps.event.addListener(re, "dragstart", v)), L && he(google.maps.event.addListener(re, "mousedown", L)), C && Ae(google.maps.event.addListener(re, "mouseout", C)), P && He(google.maps.event.addListener(re, "mouseover", P)), F && nt(google.maps.event.addListener(re, "mouseup", F)), B && we(google.maps.event.addListener(re, "rightclick", B)), E && lt(google.maps.event.addListener(re, "click", E)), M && ke(google.maps.event.addListener(re, "drag", M)), N && Fe(google.maps.event.addListener(re, "clickable_changed", N)), $ && ot(google.maps.event.addListener(re, "cursor_changed", $)), V && wt(google.maps.event.addListener(re, "animation_changed", V)), H && st(google.maps.event.addListener(re, "draggable_changed", H)), Z && Ct(google.maps.event.addListener(re, "flat_changed", Z)), K && pt(google.maps.event.addListener(re, "icon_changed", K)), Y && We(google.maps.event.addListener(re, "position_changed", Y)), Q && xt(google.maps.event.addListener(re, "shape_changed", Q)), J && Ht(google.maps.event.addListener(re, "title_changed", J)), _ && Wt(google.maps.event.addListener(re, "visible_changed", _)), D && kt(google.maps.event.addListener(re, "zindex_changed", D)), j(re), z && z(re), () => {
      U !== null && google.maps.event.removeListener(U), q !== null && google.maps.event.removeListener(q), X !== null && google.maps.event.removeListener(X), le !== null && google.maps.event.removeListener(le), oe !== null && google.maps.event.removeListener(oe), Ue !== null && google.maps.event.removeListener(Ue), Re !== null && google.maps.event.removeListener(Re), Ve !== null && google.maps.event.removeListener(Ve), et !== null && google.maps.event.removeListener(et), Qe !== null && google.maps.event.removeListener(Qe), Ie !== null && google.maps.event.removeListener(Ie), Ee !== null && google.maps.event.removeListener(Ee), it !== null && google.maps.event.removeListener(it), ut !== null && google.maps.event.removeListener(ut), ct !== null && google.maps.event.removeListener(ct), rt !== null && google.maps.event.removeListener(rt), gt !== null && google.maps.event.removeListener(gt), mt !== null && google.maps.event.removeListener(mt), vt !== null && google.maps.event.removeListener(vt), S && S(re), r ? r.removeMarker(re, !!o) : re && re.setMap(null);
    };
  }, []);
  var Un = ln(() => i ? at.map(i, (yt) => {
    if (!yi(yt))
      return yt;
    var re = yt;
    return bi(re, {
      anchor: O
    });
  }) : null, [i, O]);
  return Qo.jsx(Qo.Fragment, {
    children: Un
  }) || null;
}
me(uze);
class cze extends pe {
  constructor() {
    super(...arguments), Se(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this;
    return tne(function* () {
      var n = fp(fp(fp({}, t.props.options || cw), t.props.clusterer ? cw : {
        map: t.context
      }), {}, {
        position: t.props.position
      });
      t.marker = new google.maps.Marker(n), t.props.clusterer ? t.props.clusterer.addMarker(t.marker, !!t.props.noClustererRedraw) : t.marker.setMap(t.context), t.registeredEvents = wn({
        updaterMap: C3,
        eventMap: w3,
        prevProps: {},
        nextProps: t.props,
        instance: t.marker
      }), t.props.onLoad && t.props.onLoad(t.marker);
    })();
  }
  componentDidUpdate(t) {
    this.marker && (_n(this.registeredEvents), this.registeredEvents = wn({
      updaterMap: C3,
      eventMap: w3,
      prevProps: t,
      nextProps: this.props,
      instance: this.marker
    }));
  }
  componentWillUnmount() {
    this.marker && (this.props.onUnmount && this.props.onUnmount(this.marker), _n(this.registeredEvents), this.props.clusterer ? this.props.clusterer.removeMarker(this.marker, !!this.props.noClustererRedraw) : this.marker && this.marker.setMap(null));
  }
  render() {
    var t = this.props.children ? at.map(this.props.children, (n) => {
      if (!yi(n))
        return n;
      var r = n;
      return bi(r, {
        anchor: this.marker
      });
    }) : null;
    return t || null;
  }
}
Se(cze, "contextType", Bt);
var pze = (
  /** @class */
  function() {
    function e(t, n) {
      t.getClusterer().extend(e, google.maps.OverlayView), this.cluster = t, this.clusterClassName = this.cluster.getClusterer().getClusterClass(), this.className = this.clusterClassName, this.styles = n, this.center = void 0, this.div = null, this.sums = null, this.visible = !1, this.boundsChangedListener = null, this.url = "", this.height = 0, this.width = 0, this.anchorText = [0, 0], this.anchorIcon = [0, 0], this.textColor = "black", this.textSize = 11, this.textDecoration = "none", this.fontWeight = "bold", this.fontStyle = "normal", this.fontFamily = "Arial,sans-serif", this.backgroundPosition = "0 0", this.cMouseDownInCluster = null, this.cDraggingMapByCluster = null, this.timeOut = null, this.setMap(t.getMap()), this.onBoundsChanged = this.onBoundsChanged.bind(this), this.onMouseDown = this.onMouseDown.bind(this), this.onClick = this.onClick.bind(this), this.onMouseOver = this.onMouseOver.bind(this), this.onMouseOut = this.onMouseOut.bind(this), this.onAdd = this.onAdd.bind(this), this.onRemove = this.onRemove.bind(this), this.draw = this.draw.bind(this), this.hide = this.hide.bind(this), this.show = this.show.bind(this), this.useStyle = this.useStyle.bind(this), this.setCenter = this.setCenter.bind(this), this.getPosFromLatLng = this.getPosFromLatLng.bind(this);
    }
    return e.prototype.onBoundsChanged = function() {
      this.cDraggingMapByCluster = this.cMouseDownInCluster;
    }, e.prototype.onMouseDown = function() {
      this.cMouseDownInCluster = !0, this.cDraggingMapByCluster = !1;
    }, e.prototype.onClick = function(t) {
      if (this.cMouseDownInCluster = !1, !this.cDraggingMapByCluster) {
        var n = this.cluster.getClusterer();
        if (google.maps.event.trigger(n, "click", this.cluster), google.maps.event.trigger(n, "clusterclick", this.cluster), n.getZoomOnClick()) {
          var r = n.getMaxZoom(), o = this.cluster.getBounds(), i = n.getMap();
          i !== null && "fitBounds" in i && i.fitBounds(o), this.timeOut = window.setTimeout(function() {
            var a = n.getMap();
            if (a !== null) {
              "fitBounds" in a && a.fitBounds(o);
              var s = a.getZoom() || 0;
              r !== null && s > r && a.setZoom(r + 1);
            }
          }, 100);
        }
        t.cancelBubble = !0, t.stopPropagation && t.stopPropagation();
      }
    }, e.prototype.onMouseOver = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseover", this.cluster);
    }, e.prototype.onMouseOut = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseout", this.cluster);
    }, e.prototype.onAdd = function() {
      var t;
      this.div = document.createElement("div"), this.div.className = this.className, this.visible && this.show(), (t = this.getPanes()) === null || t === void 0 || t.overlayMouseTarget.appendChild(this.div);
      var n = this.getMap();
      n !== null && (this.boundsChangedListener = google.maps.event.addListener(n, "bounds_changed", this.onBoundsChanged), this.div.addEventListener("mousedown", this.onMouseDown), this.div.addEventListener("click", this.onClick), this.div.addEventListener("mouseover", this.onMouseOver), this.div.addEventListener("mouseout", this.onMouseOut));
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.hide(), this.boundsChangedListener !== null && google.maps.event.removeListener(this.boundsChangedListener), this.div.removeEventListener("mousedown", this.onMouseDown), this.div.removeEventListener("click", this.onClick), this.div.removeEventListener("mouseover", this.onMouseOver), this.div.removeEventListener("mouseout", this.onMouseOut), this.div.parentNode.removeChild(this.div), this.timeOut !== null && (window.clearTimeout(this.timeOut), this.timeOut = null), this.div = null);
    }, e.prototype.draw = function() {
      if (this.visible && this.div !== null && this.center) {
        var t = this.getPosFromLatLng(this.center);
        this.div.style.top = t !== null ? "".concat(t.y, "px") : "0", this.div.style.left = t !== null ? "".concat(t.x, "px") : "0";
      }
    }, e.prototype.hide = function() {
      this.div && (this.div.style.display = "none"), this.visible = !1;
    }, e.prototype.show = function() {
      var t, n, r, o, i, a;
      if (this.div && this.center) {
        var s = this.sums === null || typeof this.sums.title > "u" || this.sums.title === "" ? this.cluster.getClusterer().getTitle() : this.sums.title, l = this.backgroundPosition.split(" "), u = parseInt(((t = l[0]) === null || t === void 0 ? void 0 : t.replace(/^\s+|\s+$/g, "")) || "0", 10), c = parseInt(((n = l[1]) === null || n === void 0 ? void 0 : n.replace(/^\s+|\s+$/g, "")) || "0", 10), p = this.getPosFromLatLng(this.center);
        this.div.className = this.className, this.div.setAttribute("style", "cursor: pointer; position: absolute; top: ".concat(p !== null ? "".concat(p.y, "px") : "0", "; left: ").concat(p !== null ? "".concat(p.x, "px") : "0", "; width: ").concat(this.width, "px; height: ").concat(this.height, "px; "));
        var d = document.createElement("img");
        d.alt = s, d.src = this.url, d.width = this.width, d.height = this.height, d.setAttribute("style", "position: absolute; top: ".concat(c, "px; left: ").concat(u, "px")), this.cluster.getClusterer().enableRetinaIcons || (d.style.clip = "rect(-".concat(c, "px, -").concat(u + this.width, "px, -").concat(c + this.height, ", -").concat(u, ")"));
        var g = document.createElement("div");
        g.setAttribute("style", "position: absolute; top: ".concat(this.anchorText[0], "px; left: ").concat(this.anchorText[1], "px; color: ").concat(this.textColor, "; font-size: ").concat(this.textSize, "px; font-family: ").concat(this.fontFamily, "; font-weight: ").concat(this.fontWeight, "; fontStyle: ").concat(this.fontStyle, "; text-decoration: ").concat(this.textDecoration, "; text-align: center; width: ").concat(this.width, "px; line-height: ").concat(this.height, "px")), !((r = this.sums) === null || r === void 0) && r.text && (g.innerText = "".concat((o = this.sums) === null || o === void 0 ? void 0 : o.text)), !((i = this.sums) === null || i === void 0) && i.html && (g.innerHTML = "".concat((a = this.sums) === null || a === void 0 ? void 0 : a.html)), this.div.innerHTML = "", this.div.appendChild(d), this.div.appendChild(g), this.div.title = s, this.div.style.display = "";
      }
      this.visible = !0;
    }, e.prototype.useStyle = function(t) {
      this.sums = t;
      var n = this.cluster.getClusterer().getStyles(), r = n[Math.min(n.length - 1, Math.max(0, t.index - 1))];
      r && (this.url = r.url, this.height = r.height, this.width = r.width, r.className && (this.className = "".concat(this.clusterClassName, " ").concat(r.className)), this.anchorText = r.anchorText || [0, 0], this.anchorIcon = r.anchorIcon || [this.height / 2, this.width / 2], this.textColor = r.textColor || "black", this.textSize = r.textSize || 11, this.textDecoration = r.textDecoration || "none", this.fontWeight = r.fontWeight || "bold", this.fontStyle = r.fontStyle || "normal", this.fontFamily = r.fontFamily || "Arial,sans-serif", this.backgroundPosition = r.backgroundPosition || "0 0");
    }, e.prototype.setCenter = function(t) {
      this.center = t;
    }, e.prototype.getPosFromLatLng = function(t) {
      var n = this.getProjection().fromLatLngToDivPixel(t);
      return n !== null && (n.x -= this.anchorIcon[1], n.y -= this.anchorIcon[0]), n;
    }, e;
  }()
), dze = (
  /** @class */
  function() {
    function e(t) {
      this.markerClusterer = t, this.map = this.markerClusterer.getMap(), this.gridSize = this.markerClusterer.getGridSize(), this.minClusterSize = this.markerClusterer.getMinimumClusterSize(), this.averageCenter = this.markerClusterer.getAverageCenter(), this.markers = [], this.center = void 0, this.bounds = null, this.clusterIcon = new pze(this, this.markerClusterer.getStyles()), this.getSize = this.getSize.bind(this), this.getMarkers = this.getMarkers.bind(this), this.getCenter = this.getCenter.bind(this), this.getMap = this.getMap.bind(this), this.getClusterer = this.getClusterer.bind(this), this.getBounds = this.getBounds.bind(this), this.remove = this.remove.bind(this), this.addMarker = this.addMarker.bind(this), this.isMarkerInClusterBounds = this.isMarkerInClusterBounds.bind(this), this.calculateBounds = this.calculateBounds.bind(this), this.updateIcon = this.updateIcon.bind(this), this.isMarkerAlreadyAdded = this.isMarkerAlreadyAdded.bind(this);
    }
    return e.prototype.getSize = function() {
      return this.markers.length;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getCenter = function() {
      return this.center;
    }, e.prototype.getMap = function() {
      return this.map;
    }, e.prototype.getClusterer = function() {
      return this.markerClusterer;
    }, e.prototype.getBounds = function() {
      for (var t = new google.maps.LatLngBounds(this.center, this.center), n = this.getMarkers(), r = 0, o = n; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && t.extend(a);
      }
      return t;
    }, e.prototype.remove = function() {
      this.clusterIcon.setMap(null), this.markers = [], delete this.markers;
    }, e.prototype.addMarker = function(t) {
      var n;
      if (this.isMarkerAlreadyAdded(t))
        return !1;
      if (this.center) {
        if (this.averageCenter) {
          var r = t.getPosition();
          if (r) {
            var o = this.markers.length + 1;
            this.center = new google.maps.LatLng((this.center.lat() * (o - 1) + r.lat()) / o, (this.center.lng() * (o - 1) + r.lng()) / o), this.calculateBounds();
          }
        }
      } else {
        var r = t.getPosition();
        r && (this.center = r, this.calculateBounds());
      }
      t.isAdded = !0, this.markers.push(t);
      var i = this.markers.length, a = this.markerClusterer.getMaxZoom(), s = (n = this.map) === null || n === void 0 ? void 0 : n.getZoom();
      if (a !== null && typeof s < "u" && s > a)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i < this.minClusterSize)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i === this.minClusterSize)
        for (var l = 0, u = this.markers; l < u.length; l++) {
          var c = u[l];
          c.setMap(null);
        }
      else
        t.setMap(null);
      return !0;
    }, e.prototype.isMarkerInClusterBounds = function(t) {
      if (this.bounds !== null) {
        var n = t.getPosition();
        if (n)
          return this.bounds.contains(n);
      }
      return !1;
    }, e.prototype.calculateBounds = function() {
      this.bounds = this.markerClusterer.getExtendedBounds(new google.maps.LatLngBounds(this.center, this.center));
    }, e.prototype.updateIcon = function() {
      var t, n = this.markers.length, r = this.markerClusterer.getMaxZoom(), o = (t = this.map) === null || t === void 0 ? void 0 : t.getZoom();
      if (r !== null && typeof o < "u" && o > r) {
        this.clusterIcon.hide();
        return;
      }
      if (n < this.minClusterSize) {
        this.clusterIcon.hide();
        return;
      }
      this.center && this.clusterIcon.setCenter(this.center), this.clusterIcon.useStyle(this.markerClusterer.getCalculator()(this.markers, this.markerClusterer.getStyles().length)), this.clusterIcon.show();
    }, e.prototype.isMarkerAlreadyAdded = function(t) {
      if (this.markers.includes)
        return this.markers.includes(t);
      for (var n = 0; n < this.markers.length; n++)
        if (t === this.markers[n])
          return !0;
      return !1;
    }, e;
  }()
);
function fze(e, t) {
  var n = e.length, r = n.toString().length, o = Math.min(r, t);
  return {
    text: n.toString(),
    index: o,
    title: ""
  };
}
var hze = 2e3, gze = 500, mze = "https://developers.google.com/maps/documentation/javascript/examples/markerclusterer/m", vze = "png", yze = [53, 56, 66, 78, 90], bze = "cluster", sne = (
  /** @class */
  function() {
    function e(t, n, r) {
      n === void 0 && (n = []), r === void 0 && (r = {}), this.getMinimumClusterSize = this.getMinimumClusterSize.bind(this), this.setMinimumClusterSize = this.setMinimumClusterSize.bind(this), this.getEnableRetinaIcons = this.getEnableRetinaIcons.bind(this), this.setEnableRetinaIcons = this.setEnableRetinaIcons.bind(this), this.addToClosestCluster = this.addToClosestCluster.bind(this), this.getImageExtension = this.getImageExtension.bind(this), this.setImageExtension = this.setImageExtension.bind(this), this.getExtendedBounds = this.getExtendedBounds.bind(this), this.getAverageCenter = this.getAverageCenter.bind(this), this.setAverageCenter = this.setAverageCenter.bind(this), this.getTotalClusters = this.getTotalClusters.bind(this), this.fitMapToMarkers = this.fitMapToMarkers.bind(this), this.getIgnoreHidden = this.getIgnoreHidden.bind(this), this.setIgnoreHidden = this.setIgnoreHidden.bind(this), this.getClusterClass = this.getClusterClass.bind(this), this.setClusterClass = this.setClusterClass.bind(this), this.getTotalMarkers = this.getTotalMarkers.bind(this), this.getZoomOnClick = this.getZoomOnClick.bind(this), this.setZoomOnClick = this.setZoomOnClick.bind(this), this.getBatchSizeIE = this.getBatchSizeIE.bind(this), this.setBatchSizeIE = this.setBatchSizeIE.bind(this), this.createClusters = this.createClusters.bind(this), this.onZoomChanged = this.onZoomChanged.bind(this), this.getImageSizes = this.getImageSizes.bind(this), this.setImageSizes = this.setImageSizes.bind(this), this.getCalculator = this.getCalculator.bind(this), this.setCalculator = this.setCalculator.bind(this), this.removeMarkers = this.removeMarkers.bind(this), this.resetViewport = this.resetViewport.bind(this), this.getImagePath = this.getImagePath.bind(this), this.setImagePath = this.setImagePath.bind(this), this.pushMarkerTo = this.pushMarkerTo.bind(this), this.removeMarker = this.removeMarker.bind(this), this.clearMarkers = this.clearMarkers.bind(this), this.setupStyles = this.setupStyles.bind(this), this.getGridSize = this.getGridSize.bind(this), this.setGridSize = this.setGridSize.bind(this), this.getClusters = this.getClusters.bind(this), this.getMaxZoom = this.getMaxZoom.bind(this), this.setMaxZoom = this.setMaxZoom.bind(this), this.getMarkers = this.getMarkers.bind(this), this.addMarkers = this.addMarkers.bind(this), this.getStyles = this.getStyles.bind(this), this.setStyles = this.setStyles.bind(this), this.addMarker = this.addMarker.bind(this), this.onRemove = this.onRemove.bind(this), this.getTitle = this.getTitle.bind(this), this.setTitle = this.setTitle.bind(this), this.repaint = this.repaint.bind(this), this.onIdle = this.onIdle.bind(this), this.redraw = this.redraw.bind(this), this.onAdd = this.onAdd.bind(this), this.draw = this.draw.bind(this), this.extend = this.extend.bind(this), this.extend(e, google.maps.OverlayView), this.markers = [], this.clusters = [], this.listeners = [], this.activeMap = null, this.ready = !1, this.gridSize = r.gridSize || 60, this.minClusterSize = r.minimumClusterSize || 2, this.maxZoom = r.maxZoom || null, this.styles = r.styles || [], this.title = r.title || "", this.zoomOnClick = !0, r.zoomOnClick !== void 0 && (this.zoomOnClick = r.zoomOnClick), this.averageCenter = !1, r.averageCenter !== void 0 && (this.averageCenter = r.averageCenter), this.ignoreHidden = !1, r.ignoreHidden !== void 0 && (this.ignoreHidden = r.ignoreHidden), this.enableRetinaIcons = !1, r.enableRetinaIcons !== void 0 && (this.enableRetinaIcons = r.enableRetinaIcons), this.imagePath = r.imagePath || mze, this.imageExtension = r.imageExtension || vze, this.imageSizes = r.imageSizes || yze, this.calculator = r.calculator || fze, this.batchSize = r.batchSize || hze, this.batchSizeIE = r.batchSizeIE || gze, this.clusterClass = r.clusterClass || bze, navigator.userAgent.toLowerCase().indexOf("msie") !== -1 && (this.batchSize = this.batchSizeIE), this.timerRefStatic = null, this.setupStyles(), this.addMarkers(n, !0), this.setMap(t);
    }
    return e.prototype.onZoomChanged = function() {
      var t, n;
      this.resetViewport(!1), (((t = this.getMap()) === null || t === void 0 ? void 0 : t.getZoom()) === (this.get("minZoom") || 0) || ((n = this.getMap()) === null || n === void 0 ? void 0 : n.getZoom()) === this.get("maxZoom")) && google.maps.event.trigger(this, "idle");
    }, e.prototype.onIdle = function() {
      this.redraw();
    }, e.prototype.onAdd = function() {
      var t = this.getMap();
      this.activeMap = t, this.ready = !0, this.repaint(), t !== null && (this.listeners = [google.maps.event.addListener(t, "zoom_changed", this.onZoomChanged), google.maps.event.addListener(t, "idle", this.onIdle)]);
    }, e.prototype.onRemove = function() {
      for (var t = 0, n = this.markers; t < n.length; t++) {
        var r = n[t];
        r.getMap() !== this.activeMap && r.setMap(this.activeMap);
      }
      for (var o = 0, i = this.clusters; o < i.length; o++) {
        var a = i[o];
        a.remove();
      }
      this.clusters = [];
      for (var s = 0, l = this.listeners; s < l.length; s++) {
        var u = l[s];
        google.maps.event.removeListener(u);
      }
      this.listeners = [], this.activeMap = null, this.ready = !1;
    }, e.prototype.draw = function() {
    }, e.prototype.getMap = function() {
      return null;
    }, e.prototype.getPanes = function() {
      return null;
    }, e.prototype.getProjection = function() {
      return {
        fromContainerPixelToLatLng: function() {
          return null;
        },
        fromDivPixelToLatLng: function() {
          return null;
        },
        fromLatLngToContainerPixel: function() {
          return null;
        },
        fromLatLngToDivPixel: function() {
          return null;
        },
        getVisibleRegion: function() {
          return null;
        },
        getWorldWidth: function() {
          return 0;
        }
      };
    }, e.prototype.setMap = function() {
    }, e.prototype.addListener = function() {
      return {
        remove: function() {
        }
      };
    }, e.prototype.bindTo = function() {
    }, e.prototype.get = function() {
    }, e.prototype.notify = function() {
    }, e.prototype.set = function() {
    }, e.prototype.setValues = function() {
    }, e.prototype.unbind = function() {
    }, e.prototype.unbindAll = function() {
    }, e.prototype.setupStyles = function() {
      if (!(this.styles.length > 0))
        for (var t = 0; t < this.imageSizes.length; t++)
          this.styles.push({
            url: "".concat(this.imagePath + (t + 1), ".").concat(this.imageExtension),
            height: this.imageSizes[t] || 0,
            width: this.imageSizes[t] || 0
          });
    }, e.prototype.fitMapToMarkers = function() {
      for (var t = this.getMarkers(), n = new google.maps.LatLngBounds(), r = 0, o = t; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && n.extend(a);
      }
      var s = this.getMap();
      s !== null && "fitBounds" in s && s.fitBounds(n);
    }, e.prototype.getGridSize = function() {
      return this.gridSize;
    }, e.prototype.setGridSize = function(t) {
      this.gridSize = t;
    }, e.prototype.getMinimumClusterSize = function() {
      return this.minClusterSize;
    }, e.prototype.setMinimumClusterSize = function(t) {
      this.minClusterSize = t;
    }, e.prototype.getMaxZoom = function() {
      return this.maxZoom;
    }, e.prototype.setMaxZoom = function(t) {
      this.maxZoom = t;
    }, e.prototype.getStyles = function() {
      return this.styles;
    }, e.prototype.setStyles = function(t) {
      this.styles = t;
    }, e.prototype.getTitle = function() {
      return this.title;
    }, e.prototype.setTitle = function(t) {
      this.title = t;
    }, e.prototype.getZoomOnClick = function() {
      return this.zoomOnClick;
    }, e.prototype.setZoomOnClick = function(t) {
      this.zoomOnClick = t;
    }, e.prototype.getAverageCenter = function() {
      return this.averageCenter;
    }, e.prototype.setAverageCenter = function(t) {
      this.averageCenter = t;
    }, e.prototype.getIgnoreHidden = function() {
      return this.ignoreHidden;
    }, e.prototype.setIgnoreHidden = function(t) {
      this.ignoreHidden = t;
    }, e.prototype.getEnableRetinaIcons = function() {
      return this.enableRetinaIcons;
    }, e.prototype.setEnableRetinaIcons = function(t) {
      this.enableRetinaIcons = t;
    }, e.prototype.getImageExtension = function() {
      return this.imageExtension;
    }, e.prototype.setImageExtension = function(t) {
      this.imageExtension = t;
    }, e.prototype.getImagePath = function() {
      return this.imagePath;
    }, e.prototype.setImagePath = function(t) {
      this.imagePath = t;
    }, e.prototype.getImageSizes = function() {
      return this.imageSizes;
    }, e.prototype.setImageSizes = function(t) {
      this.imageSizes = t;
    }, e.prototype.getCalculator = function() {
      return this.calculator;
    }, e.prototype.setCalculator = function(t) {
      this.calculator = t;
    }, e.prototype.getBatchSizeIE = function() {
      return this.batchSizeIE;
    }, e.prototype.setBatchSizeIE = function(t) {
      this.batchSizeIE = t;
    }, e.prototype.getClusterClass = function() {
      return this.clusterClass;
    }, e.prototype.setClusterClass = function(t) {
      this.clusterClass = t;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getTotalMarkers = function() {
      return this.markers.length;
    }, e.prototype.getClusters = function() {
      return this.clusters;
    }, e.prototype.getTotalClusters = function() {
      return this.clusters.length;
    }, e.prototype.addMarker = function(t, n) {
      this.pushMarkerTo(t), n || this.redraw();
    }, e.prototype.addMarkers = function(t, n) {
      for (var r in t)
        if (Object.prototype.hasOwnProperty.call(t, r)) {
          var o = t[r];
          o && this.pushMarkerTo(o);
        }
      n || this.redraw();
    }, e.prototype.pushMarkerTo = function(t) {
      var n = this;
      t.getDraggable() && google.maps.event.addListener(t, "dragend", function() {
        n.ready && (t.isAdded = !1, n.repaint());
      }), t.isAdded = !1, this.markers.push(t);
    }, e.prototype.removeMarker_ = function(t) {
      var n = -1;
      if (this.markers.indexOf)
        n = this.markers.indexOf(t);
      else
        for (var r = 0; r < this.markers.length; r++)
          if (t === this.markers[r]) {
            n = r;
            break;
          }
      return n === -1 ? !1 : (t.setMap(null), this.markers.splice(n, 1), !0);
    }, e.prototype.removeMarker = function(t, n) {
      var r = this.removeMarker_(t);
      return !n && r && this.repaint(), r;
    }, e.prototype.removeMarkers = function(t, n) {
      for (var r = !1, o = 0, i = t; o < i.length; o++) {
        var a = i[o];
        r = r || this.removeMarker_(a);
      }
      return !n && r && this.repaint(), r;
    }, e.prototype.clearMarkers = function() {
      this.resetViewport(!0), this.markers = [];
    }, e.prototype.repaint = function() {
      var t = this.clusters.slice();
      this.clusters = [], this.resetViewport(!1), this.redraw(), setTimeout(function() {
        for (var n = 0, r = t; n < r.length; n++) {
          var o = r[n];
          o.remove();
        }
      }, 0);
    }, e.prototype.getExtendedBounds = function(t) {
      var n = this.getProjection(), r = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getNorthEast().lat(), t.getNorthEast().lng())
      );
      r !== null && (r.x += this.gridSize, r.y -= this.gridSize);
      var o = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getSouthWest().lat(), t.getSouthWest().lng())
      );
      if (o !== null && (o.x -= this.gridSize, o.y += this.gridSize), r !== null) {
        var i = n.fromDivPixelToLatLng(r);
        i !== null && t.extend(i);
      }
      if (o !== null) {
        var a = n.fromDivPixelToLatLng(o);
        a !== null && t.extend(a);
      }
      return t;
    }, e.prototype.redraw = function() {
      this.createClusters(0);
    }, e.prototype.resetViewport = function(t) {
      for (var n = 0, r = this.clusters; n < r.length; n++) {
        var o = r[n];
        o.remove();
      }
      this.clusters = [];
      for (var i = 0, a = this.markers; i < a.length; i++) {
        var s = a[i];
        s.isAdded = !1, t && s.setMap(null);
      }
    }, e.prototype.distanceBetweenPoints = function(t, n) {
      var r = 6371, o = (n.lat() - t.lat()) * Math.PI / 180, i = (n.lng() - t.lng()) * Math.PI / 180, a = Math.sin(o / 2) * Math.sin(o / 2) + Math.cos(t.lat() * Math.PI / 180) * Math.cos(n.lat() * Math.PI / 180) * Math.sin(i / 2) * Math.sin(i / 2);
      return r * (2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)));
    }, e.prototype.isMarkerInBounds = function(t, n) {
      var r = t.getPosition();
      return r ? n.contains(r) : !1;
    }, e.prototype.addToClosestCluster = function(t) {
      for (var n, r = 4e4, o = null, i = 0, a = this.clusters; i < a.length; i++) {
        var s = a[i];
        n = s;
        var l = n.getCenter(), u = t.getPosition();
        if (l && u) {
          var c = this.distanceBetweenPoints(l, u);
          c < r && (r = c, o = n);
        }
      }
      o && o.isMarkerInClusterBounds(t) ? o.addMarker(t) : (n = new dze(this), n.addMarker(t), this.clusters.push(n));
    }, e.prototype.createClusters = function(t) {
      var n = this;
      if (this.ready) {
        t === 0 && (google.maps.event.trigger(this, "clusteringbegin", this), this.timerRefStatic !== null && (window.clearTimeout(this.timerRefStatic), delete this.timerRefStatic));
        for (var r = this.getMap(), o = r !== null && ("getBounds" in r) ? r.getBounds() : null, i = (r == null ? void 0 : r.getZoom()) || 0, a = i > 3 ? new google.maps.LatLngBounds(o == null ? void 0 : o.getSouthWest(), o == null ? void 0 : o.getNorthEast()) : new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625)), s = this.getExtendedBounds(a), l = Math.min(t + this.batchSize, this.markers.length), u = t; u < l; u++) {
          var c = this.markers[u];
          c && !c.isAdded && this.isMarkerInBounds(c, s) && (!this.ignoreHidden || this.ignoreHidden && c.getVisible()) && this.addToClosestCluster(c);
        }
        if (l < this.markers.length)
          this.timerRefStatic = window.setTimeout(function() {
            n.createClusters(l);
          }, 0);
        else {
          this.timerRefStatic = null, google.maps.event.trigger(this, "clusteringend", this);
          for (var p = 0, d = this.clusters; p < d.length; p++) {
            var g = d[p];
            g.updateIcon();
          }
        }
      }
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype) {
          var i = o;
          this.prototype[i] = r.prototype[i];
        }
        return this;
      }).apply(t, [n]);
    }, e;
  }()
);
function O3(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function wze(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? O3(Object(n), !0).forEach(function(r) {
      Se(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : O3(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Ns = {
  onClick: "click",
  onClusteringBegin: "clusteringbegin",
  onClusteringEnd: "clusteringend",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover"
}, An = {
  averageCenter(e, t) {
    e.setAverageCenter(t);
  },
  batchSizeIE(e, t) {
    e.setBatchSizeIE(t);
  },
  calculator(e, t) {
    e.setCalculator(t);
  },
  clusterClass(e, t) {
    e.setClusterClass(t);
  },
  enableRetinaIcons(e, t) {
    e.setEnableRetinaIcons(t);
  },
  gridSize(e, t) {
    e.setGridSize(t);
  },
  ignoreHidden(e, t) {
    e.setIgnoreHidden(t);
  },
  imageExtension(e, t) {
    e.setImageExtension(t);
  },
  imagePath(e, t) {
    e.setImagePath(t);
  },
  imageSizes(e, t) {
    e.setImageSizes(t);
  },
  maxZoom(e, t) {
    e.setMaxZoom(t);
  },
  minimumClusterSize(e, t) {
    e.setMinimumClusterSize(t);
  },
  styles(e, t) {
    e.setStyles(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  zoomOnClick(e, t) {
    e.setZoomOnClick(t);
  }
}, Cze = {};
function Oze(e) {
  var {
    children: t,
    options: n,
    averageCenter: r,
    batchSizeIE: o,
    calculator: i,
    clusterClass: a,
    enableRetinaIcons: s,
    gridSize: l,
    ignoreHidden: u,
    imageExtension: c,
    imagePath: p,
    imageSizes: d,
    maxZoom: g,
    minimumClusterSize: f,
    styles: m,
    title: b,
    zoomOnClick: E,
    onClick: w,
    onClusteringBegin: M,
    onClusteringEnd: x,
    onMouseOver: v,
    onMouseOut: C,
    onLoad: P,
    onUnmount: F
  } = e, [L, B] = k(null), N = ge(Bt), [$, V] = k(null), [H, Z] = k(null), [K, Y] = k(null), [Q, J] = k(null), [_, D] = k(null);
  return h(() => {
    L && C && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(L, Ns.onMouseOut, C)));
  }, [C]), h(() => {
    L && v && (_ !== null && google.maps.event.removeListener(_), D(google.maps.event.addListener(L, Ns.onMouseOver, v)));
  }, [v]), h(() => {
    L && w && ($ !== null && google.maps.event.removeListener($), V(google.maps.event.addListener(L, Ns.onClick, w)));
  }, [w]), h(() => {
    L && M && (H !== null && google.maps.event.removeListener(H), Z(google.maps.event.addListener(L, Ns.onClusteringBegin, M)));
  }, [M]), h(() => {
    L && x && (K !== null && google.maps.event.removeListener(K), Z(google.maps.event.addListener(L, Ns.onClusteringEnd, x)));
  }, [x]), h(() => {
    typeof r < "u" && L !== null && An.averageCenter(L, r);
  }, [L, r]), h(() => {
    typeof o < "u" && L !== null && An.batchSizeIE(L, o);
  }, [L, o]), h(() => {
    typeof i < "u" && L !== null && An.calculator(L, i);
  }, [L, i]), h(() => {
    typeof a < "u" && L !== null && An.clusterClass(L, a);
  }, [L, a]), h(() => {
    typeof s < "u" && L !== null && An.enableRetinaIcons(L, s);
  }, [L, s]), h(() => {
    typeof l < "u" && L !== null && An.gridSize(L, l);
  }, [L, l]), h(() => {
    typeof u < "u" && L !== null && An.ignoreHidden(L, u);
  }, [L, u]), h(() => {
    typeof c < "u" && L !== null && An.imageExtension(L, c);
  }, [L, c]), h(() => {
    typeof p < "u" && L !== null && An.imagePath(L, p);
  }, [L, p]), h(() => {
    typeof d < "u" && L !== null && An.imageSizes(L, d);
  }, [L, d]), h(() => {
    typeof g < "u" && L !== null && An.maxZoom(L, g);
  }, [L, g]), h(() => {
    typeof f < "u" && L !== null && An.minimumClusterSize(L, f);
  }, [L, f]), h(() => {
    typeof m < "u" && L !== null && An.styles(L, m);
  }, [L, m]), h(() => {
    typeof b < "u" && L !== null && An.title(L, b);
  }, [L, b]), h(() => {
    typeof E < "u" && L !== null && An.zoomOnClick(L, E);
  }, [L, E]), h(() => {
    if (N) {
      var z = wze({}, n || Cze), S = new sne(N, [], z);
      return r && An.averageCenter(S, r), o && An.batchSizeIE(S, o), i && An.calculator(S, i), a && An.clusterClass(S, a), s && An.enableRetinaIcons(S, s), l && An.gridSize(S, l), u && An.ignoreHidden(S, u), c && An.imageExtension(S, c), p && An.imagePath(S, p), d && An.imageSizes(S, d), g && An.maxZoom(S, g), f && An.minimumClusterSize(S, f), m && An.styles(S, m), b && An.title(S, b), E && An.zoomOnClick(S, E), C && J(google.maps.event.addListener(S, Ns.onMouseOut, C)), v && D(google.maps.event.addListener(S, Ns.onMouseOver, v)), w && V(google.maps.event.addListener(S, Ns.onClick, w)), M && Z(google.maps.event.addListener(S, Ns.onClusteringBegin, M)), x && Y(google.maps.event.addListener(S, Ns.onClusteringEnd, x)), B(S), P && P(S), () => {
        Q !== null && google.maps.event.removeListener(Q), _ !== null && google.maps.event.removeListener(_), $ !== null && google.maps.event.removeListener($), H !== null && google.maps.event.removeListener(H), K !== null && google.maps.event.removeListener(K), F && F(S);
      };
    }
  }, []), L !== null && t(L) || null;
}
me(Oze);
class xze extends pe {
  constructor() {
    super(...arguments), Se(this, "registeredEvents", []), Se(this, "state", {
      markerClusterer: null
    }), Se(this, "setClustererCallback", () => {
      this.state.markerClusterer !== null && this.props.onLoad && this.props.onLoad(this.state.markerClusterer);
    });
  }
  componentDidMount() {
    if (this.context) {
      var t = new sne(this.context, [], this.props.options);
      this.registeredEvents = wn({
        updaterMap: An,
        eventMap: Ns,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        markerClusterer: t
      }), this.setClustererCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.markerClusterer && (_n(this.registeredEvents), this.registeredEvents = wn({
      updaterMap: An,
      eventMap: Ns,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.markerClusterer
    }));
  }
  componentWillUnmount() {
    this.state.markerClusterer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.markerClusterer), _n(this.registeredEvents), this.state.markerClusterer.setMap(null));
  }
  render() {
    return this.state.markerClusterer !== null ? this.props.children(this.state.markerClusterer) : null;
  }
}
Se(xze, "contextType", Bt);
function x3(e) {
  e.cancelBubble = !0, e.stopPropagation && e.stopPropagation();
}
var ane = (
  /** @class */
  function() {
    function e(t) {
      t === void 0 && (t = {}), this.getCloseClickHandler = this.getCloseClickHandler.bind(this), this.closeClickHandler = this.closeClickHandler.bind(this), this.createInfoBoxDiv = this.createInfoBoxDiv.bind(this), this.addClickHandler = this.addClickHandler.bind(this), this.getCloseBoxImg = this.getCloseBoxImg.bind(this), this.getBoxWidths = this.getBoxWidths.bind(this), this.setBoxStyle = this.setBoxStyle.bind(this), this.setPosition = this.setPosition.bind(this), this.getPosition = this.getPosition.bind(this), this.setOptions = this.setOptions.bind(this), this.setContent = this.setContent.bind(this), this.setVisible = this.setVisible.bind(this), this.getContent = this.getContent.bind(this), this.getVisible = this.getVisible.bind(this), this.setZIndex = this.setZIndex.bind(this), this.getZIndex = this.getZIndex.bind(this), this.onRemove = this.onRemove.bind(this), this.panBox = this.panBox.bind(this), this.extend = this.extend.bind(this), this.close = this.close.bind(this), this.draw = this.draw.bind(this), this.show = this.show.bind(this), this.hide = this.hide.bind(this), this.open = this.open.bind(this), this.extend(e, google.maps.OverlayView), this.content = t.content || "", this.disableAutoPan = t.disableAutoPan || !1, this.maxWidth = t.maxWidth || 0, this.pixelOffset = t.pixelOffset || new google.maps.Size(0, 0), this.position = t.position || new google.maps.LatLng(0, 0), this.zIndex = t.zIndex || null, this.boxClass = t.boxClass || "infoBox", this.boxStyle = t.boxStyle || {}, this.closeBoxMargin = t.closeBoxMargin || "2px", this.closeBoxURL = t.closeBoxURL || "http://www.google.com/intl/en_us/mapfiles/close.gif", t.closeBoxURL === "" && (this.closeBoxURL = ""), this.infoBoxClearance = t.infoBoxClearance || new google.maps.Size(1, 1), typeof t.visible > "u" && (typeof t.isHidden > "u" ? t.visible = !0 : t.visible = !t.isHidden), this.isHidden = !t.visible, this.alignBottom = t.alignBottom || !1, this.pane = t.pane || "floatPane", this.enableEventPropagation = t.enableEventPropagation || !1, this.div = null, this.closeListener = null, this.moveListener = null, this.mapListener = null, this.contextListener = null, this.eventListeners = null, this.fixedWidthSet = null;
    }
    return e.prototype.createInfoBoxDiv = function() {
      var t = this, n = function(u) {
        u.returnValue = !1, u.preventDefault && u.preventDefault(), t.enableEventPropagation || x3(u);
      };
      if (!this.div) {
        this.div = document.createElement("div"), this.setBoxStyle(), typeof this.content == "string" ? this.div.innerHTML = this.getCloseBoxImg() + this.content : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(this.content));
        var r = this.getPanes();
        if (r !== null && r[this.pane].appendChild(this.div), this.addClickHandler(), this.div.style.width)
          this.fixedWidthSet = !0;
        else if (this.maxWidth !== 0 && this.div.offsetWidth > this.maxWidth)
          this.div.style.width = this.maxWidth + "px", this.fixedWidthSet = !0;
        else {
          var o = this.getBoxWidths();
          this.div.style.width = this.div.offsetWidth - o.left - o.right + "px", this.fixedWidthSet = !1;
        }
        if (this.panBox(this.disableAutoPan), !this.enableEventPropagation) {
          this.eventListeners = [];
          for (var i = ["mousedown", "mouseover", "mouseout", "mouseup", "click", "dblclick", "touchstart", "touchend", "touchmove"], a = 0, s = i; a < s.length; a++) {
            var l = s[a];
            this.eventListeners.push(google.maps.event.addListener(this.div, l, x3));
          }
          this.eventListeners.push(google.maps.event.addListener(this.div, "mouseover", function() {
            t.div && (t.div.style.cursor = "default");
          }));
        }
        this.contextListener = google.maps.event.addListener(this.div, "contextmenu", n), google.maps.event.trigger(this, "domready");
      }
    }, e.prototype.getCloseBoxImg = function() {
      var t = "";
      return this.closeBoxURL !== "" && (t = '<img alt=""', t += ' aria-hidden="true"', t += " src='" + this.closeBoxURL + "'", t += " align=right", t += " style='", t += " position: relative;", t += " cursor: pointer;", t += " margin: " + this.closeBoxMargin + ";", t += "'>"), t;
    }, e.prototype.addClickHandler = function() {
      this.closeListener = this.div && this.div.firstChild && this.closeBoxURL !== "" ? google.maps.event.addListener(this.div.firstChild, "click", this.getCloseClickHandler()) : null;
    }, e.prototype.closeClickHandler = function(t) {
      t.cancelBubble = !0, t.stopPropagation && t.stopPropagation(), google.maps.event.trigger(this, "closeclick"), this.close();
    }, e.prototype.getCloseClickHandler = function() {
      return this.closeClickHandler;
    }, e.prototype.panBox = function(t) {
      if (this.div && !t) {
        var n = this.getMap();
        if (n instanceof google.maps.Map) {
          var r = 0, o = 0, i = n.getBounds();
          i && !i.contains(this.position) && n.setCenter(this.position);
          var a = n.getDiv(), s = a.offsetWidth, l = a.offsetHeight, u = this.pixelOffset.width, c = this.pixelOffset.height, p = this.div.offsetWidth, d = this.div.offsetHeight, g = this.infoBoxClearance.width, f = this.infoBoxClearance.height, m = this.getProjection(), b = m.fromLatLngToContainerPixel(this.position);
          b !== null && (b.x < -u + g ? r = b.x + u - g : b.x + p + u + g > s && (r = b.x + p + u + g - s), this.alignBottom ? b.y < -c + f + d ? o = b.y + c - f - d : b.y + c + f > l && (o = b.y + c + f - l) : b.y < -c + f ? o = b.y + c - f : b.y + d + c + f > l && (o = b.y + d + c + f - l)), r === 0 && o === 0 || n.panBy(r, o);
        }
      }
    }, e.prototype.setBoxStyle = function() {
      if (this.div) {
        this.div.className = this.boxClass, this.div.style.cssText = "";
        var t = this.boxStyle;
        for (var n in t)
          Object.prototype.hasOwnProperty.call(t, n) && (this.div.style[n] = t[n]);
        if (this.div.style.webkitTransform = "translateZ(0)", typeof this.div.style.opacity < "u" && this.div.style.opacity !== "") {
          var r = parseFloat(this.div.style.opacity || "");
          this.div.style.msFilter = '"progid:DXImageTransform.Microsoft.Alpha(Opacity=' + r * 100 + ')"', this.div.style.filter = "alpha(opacity=" + r * 100 + ")";
        }
        this.div.style.position = "absolute", this.div.style.visibility = "hidden", this.zIndex !== null && (this.div.style.zIndex = this.zIndex + ""), this.div.style.overflow || (this.div.style.overflow = "auto");
      }
    }, e.prototype.getBoxWidths = function() {
      var t = {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0
      };
      if (!this.div)
        return t;
      if (document.defaultView) {
        var n = this.div.ownerDocument, r = n && n.defaultView ? n.defaultView.getComputedStyle(this.div, "") : null;
        r && (t.top = parseInt(r.borderTopWidth || "", 10) || 0, t.bottom = parseInt(r.borderBottomWidth || "", 10) || 0, t.left = parseInt(r.borderLeftWidth || "", 10) || 0, t.right = parseInt(r.borderRightWidth || "", 10) || 0);
      } else if (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        document.documentElement.currentStyle
      ) {
        var o = this.div.currentStyle;
        o && (t.top = parseInt(o.borderTopWidth || "", 10) || 0, t.bottom = parseInt(o.borderBottomWidth || "", 10) || 0, t.left = parseInt(o.borderLeftWidth || "", 10) || 0, t.right = parseInt(o.borderRightWidth || "", 10) || 0);
      }
      return t;
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.div.parentNode.removeChild(this.div), this.div = null);
    }, e.prototype.draw = function() {
      if (this.createInfoBoxDiv(), this.div) {
        var t = this.getProjection(), n = t.fromLatLngToDivPixel(this.position);
        n !== null && (this.div.style.left = n.x + this.pixelOffset.width + "px", this.alignBottom ? this.div.style.bottom = -(n.y + this.pixelOffset.height) + "px" : this.div.style.top = n.y + this.pixelOffset.height + "px"), this.isHidden ? this.div.style.visibility = "hidden" : this.div.style.visibility = "visible";
      }
    }, e.prototype.setOptions = function(t) {
      t === void 0 && (t = {}), typeof t.boxClass < "u" && (this.boxClass = t.boxClass, this.setBoxStyle()), typeof t.boxStyle < "u" && (this.boxStyle = t.boxStyle, this.setBoxStyle()), typeof t.content < "u" && this.setContent(t.content), typeof t.disableAutoPan < "u" && (this.disableAutoPan = t.disableAutoPan), typeof t.maxWidth < "u" && (this.maxWidth = t.maxWidth), typeof t.pixelOffset < "u" && (this.pixelOffset = t.pixelOffset), typeof t.alignBottom < "u" && (this.alignBottom = t.alignBottom), typeof t.position < "u" && this.setPosition(t.position), typeof t.zIndex < "u" && this.setZIndex(t.zIndex), typeof t.closeBoxMargin < "u" && (this.closeBoxMargin = t.closeBoxMargin), typeof t.closeBoxURL < "u" && (this.closeBoxURL = t.closeBoxURL), typeof t.infoBoxClearance < "u" && (this.infoBoxClearance = t.infoBoxClearance), typeof t.isHidden < "u" && (this.isHidden = t.isHidden), typeof t.visible < "u" && (this.isHidden = !t.visible), typeof t.enableEventPropagation < "u" && (this.enableEventPropagation = t.enableEventPropagation), this.div && this.draw();
    }, e.prototype.setContent = function(t) {
      this.content = t, this.div && (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.fixedWidthSet || (this.div.style.width = ""), typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t)), this.fixedWidthSet || (this.div.style.width = this.div.offsetWidth + "px", typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t))), this.addClickHandler()), google.maps.event.trigger(this, "content_changed");
    }, e.prototype.setPosition = function(t) {
      this.position = t, this.div && this.draw(), google.maps.event.trigger(this, "position_changed");
    }, e.prototype.setVisible = function(t) {
      this.isHidden = !t, this.div && (this.div.style.visibility = this.isHidden ? "hidden" : "visible");
    }, e.prototype.setZIndex = function(t) {
      this.zIndex = t, this.div && (this.div.style.zIndex = t + ""), google.maps.event.trigger(this, "zindex_changed");
    }, e.prototype.getContent = function() {
      return this.content;
    }, e.prototype.getPosition = function() {
      return this.position;
    }, e.prototype.getZIndex = function() {
      return this.zIndex;
    }, e.prototype.getVisible = function() {
      var t = this.getMap();
      return typeof t > "u" || t === null ? !1 : !this.isHidden;
    }, e.prototype.show = function() {
      this.isHidden = !1, this.div && (this.div.style.visibility = "visible");
    }, e.prototype.hide = function() {
      this.isHidden = !0, this.div && (this.div.style.visibility = "hidden");
    }, e.prototype.open = function(t, n) {
      var r = this;
      n && (this.position = n.getPosition(), this.moveListener = google.maps.event.addListener(n, "position_changed", function() {
        var o = n.getPosition();
        r.setPosition(o);
      }), this.mapListener = google.maps.event.addListener(n, "map_changed", function() {
        r.setMap(n.map);
      })), this.setMap(t), this.div && this.panBox();
    }, e.prototype.close = function() {
      if (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.eventListeners) {
        for (var t = 0, n = this.eventListeners; t < n.length; t++) {
          var r = n[t];
          google.maps.event.removeListener(r);
        }
        this.eventListeners = null;
      }
      this.moveListener && (google.maps.event.removeListener(this.moveListener), this.moveListener = null), this.mapListener && (google.maps.event.removeListener(this.mapListener), this.mapListener = null), this.contextListener && (google.maps.event.removeListener(this.contextListener), this.contextListener = null), this.setMap(null);
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype)
          Object.prototype.hasOwnProperty.call(this, o) || (this.prototype[o] = r.prototype[o]);
        return this;
      }).apply(t, [n]);
    }, e;
  }()
), Eze = ["position"], kze = ["position"];
function E3(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function pw(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? E3(Object(n), !0).forEach(function(r) {
      Se(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : E3(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var k3 = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, L3 = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    t instanceof google.maps.LatLng ? e.setPosition(t) : e.setPosition(new google.maps.LatLng(t.lat, t.lng));
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, Lze = {};
function _ze(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, g = ge(Bt), [f, m] = k(null), [b, E] = k(null), [w, M] = k(null), [x, v] = k(null), [C, P] = k(null), [F, L] = k(null), B = dt(null);
  return h(() => {
    g && f !== null && (f.close(), n ? f.open(g, n) : f.getPosition() && f.open(g));
  }, [g, f, n]), h(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), h(() => {
    if (o && f !== null) {
      var N = o instanceof google.maps.LatLng ? o : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        new google.maps.LatLng(o.lat, o.lng)
      );
      f.setPosition(N);
    }
  }, [o]), h(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), h(() => {
    f && a && (b !== null && google.maps.event.removeListener(b), E(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), h(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), M(google.maps.event.addListener(f, "domready", s)));
  }, [s]), h(() => {
    f && l && (x !== null && google.maps.event.removeListener(x), v(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), h(() => {
    f && u && (C !== null && google.maps.event.removeListener(C), P(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), h(() => {
    f && c && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), h(() => {
    if (g) {
      var N = r || Lze, {
        position: $
      } = N, V = vT(N, Eze), H;
      $ && !($ instanceof google.maps.LatLng) && (H = new google.maps.LatLng($.lat, $.lng));
      var Z = new ane(pw(pw({}, V), H ? {
        position: H
      } : {}));
      B.current = document.createElement("div"), m(Z), a && E(google.maps.event.addListener(Z, "closeclick", a)), s && M(google.maps.event.addListener(Z, "domready", s)), l && v(google.maps.event.addListener(Z, "content_changed", l)), u && P(google.maps.event.addListener(Z, "position_changed", u)), c && L(google.maps.event.addListener(Z, "zindex_changed", c)), Z.setContent(B.current), n ? Z.open(g, n) : Z.getPosition() ? Z.open(g) : $o(!1, "You must provide either an anchor or a position prop for <InfoBox>."), p && p(Z);
    }
    return () => {
      f !== null && (b && google.maps.event.removeListener(b), x && google.maps.event.removeListener(x), w && google.maps.event.removeListener(w), C && google.maps.event.removeListener(C), F && google.maps.event.removeListener(F), d && d(f), f.close());
    };
  }, []), B.current ? zn(at.only(t), B.current) : null;
}
me(_ze);
class Pze extends pe {
  constructor() {
    super(...arguments), Se(this, "registeredEvents", []), Se(this, "containerElement", null), Se(this, "state", {
      infoBox: null
    }), Se(this, "open", (t, n) => {
      n ? this.context !== null && t.open(this.context, n) : t.getPosition() ? this.context !== null && t.open(this.context) : $o(!1, "You must provide either an anchor or a position prop for <InfoBox>.");
    }), Se(this, "setInfoBoxCallback", () => {
      this.state.infoBox !== null && this.containerElement !== null && (this.state.infoBox.setContent(this.containerElement), this.open(this.state.infoBox, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoBox));
    });
  }
  componentDidMount() {
    var t = this.props.options || {}, {
      position: n
    } = t, r = vT(t, kze), o;
    n && !(n instanceof google.maps.LatLng) && (o = new google.maps.LatLng(n.lat, n.lng));
    var i = new ane(pw(pw({}, r), o ? {
      position: o
    } : {}));
    this.containerElement = document.createElement("div"), this.registeredEvents = wn({
      updaterMap: L3,
      eventMap: k3,
      prevProps: {},
      nextProps: this.props,
      instance: i
    }), this.setState({
      infoBox: i
    }, this.setInfoBoxCallback);
  }
  componentDidUpdate(t) {
    var {
      infoBox: n
    } = this.state;
    n !== null && (_n(this.registeredEvents), this.registeredEvents = wn({
      updaterMap: L3,
      eventMap: k3,
      prevProps: t,
      nextProps: this.props,
      instance: n
    }));
  }
  componentWillUnmount() {
    var {
      onUnmount: t
    } = this.props, {
      infoBox: n
    } = this.state;
    n !== null && (t && t(n), _n(this.registeredEvents), n.close());
  }
  render() {
    return this.containerElement ? zn(at.only(this.props.children), this.containerElement) : null;
  }
}
Se(Pze, "contextType", Bt);
var _3, P3;
function Sze() {
  return P3 || (P3 = 1, _3 = function e(t, n) {
    if (t === n) return !0;
    if (t && n && typeof t == "object" && typeof n == "object") {
      if (t.constructor !== n.constructor) return !1;
      var r, o, i;
      if (Array.isArray(t)) {
        if (r = t.length, r != n.length) return !1;
        for (o = r; o-- !== 0; ) if (!e(t[o], n[o])) return !1;
        return !0;
      }
      if (t.constructor === RegExp) return t.source === n.source && t.flags === n.flags;
      if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === n.valueOf();
      if (t.toString !== Object.prototype.toString) return t.toString() === n.toString();
      if (i = Object.keys(t), r = i.length, r !== Object.keys(n).length) return !1;
      for (o = r; o-- !== 0; ) if (!Object.prototype.hasOwnProperty.call(n, i[o])) return !1;
      for (o = r; o-- !== 0; ) {
        var a = i[o];
        if (!e(t[a], n[a])) return !1;
      }
      return !0;
    }
    return t !== t && n !== n;
  }), _3;
}
var Mze = Sze(), S3 = /* @__PURE__ */ ene(Mze), M3 = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array], mk = 1, _d = 8;
class yT {
  /**
   * Creates an index from raw `ArrayBuffer` data.
   * @param {ArrayBuffer} data
   */
  static from(t) {
    if (!(t instanceof ArrayBuffer))
      throw new Error("Data must be an instance of ArrayBuffer.");
    var [n, r] = new Uint8Array(t, 0, 2);
    if (n !== 219)
      throw new Error("Data does not appear to be in a KDBush format.");
    var o = r >> 4;
    if (o !== mk)
      throw new Error("Got v".concat(o, " data when expected v").concat(mk, "."));
    var i = M3[r & 15];
    if (!i)
      throw new Error("Unrecognized array type.");
    var [a] = new Uint16Array(t, 2, 1), [s] = new Uint32Array(t, 4, 1);
    return new yT(s, a, i, t);
  }
  /**
   * Creates an index that will hold a given number of items.
   * @param {number} numItems
   * @param {number} [nodeSize=64] Size of the KD-tree node (64 by default).
   * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).
   * @param {ArrayBuffer} [data] (For internal use only)
   */
  constructor(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 64, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Float64Array, o = arguments.length > 3 ? arguments[3] : void 0;
    if (isNaN(t) || t < 0) throw new Error("Unpexpected numItems value: ".concat(t, "."));
    this.numItems = +t, this.nodeSize = Math.min(Math.max(+n, 2), 65535), this.ArrayType = r, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
    var i = M3.indexOf(this.ArrayType), a = t * 2 * this.ArrayType.BYTES_PER_ELEMENT, s = t * this.IndexArrayType.BYTES_PER_ELEMENT, l = (8 - s % 8) % 8;
    if (i < 0)
      throw new Error("Unexpected typed array class: ".concat(r, "."));
    o && o instanceof ArrayBuffer ? (this.data = o, this.ids = new this.IndexArrayType(this.data, _d, t), this.coords = new this.ArrayType(this.data, _d + s + l, t * 2), this._pos = t * 2, this._finished = !0) : (this.data = new ArrayBuffer(_d + a + s + l), this.ids = new this.IndexArrayType(this.data, _d, t), this.coords = new this.ArrayType(this.data, _d + s + l, t * 2), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, (mk << 4) + i]), new Uint16Array(this.data, 2, 1)[0] = n, new Uint32Array(this.data, 4, 1)[0] = t);
  }
  /**
   * Add a point to the index.
   * @param {number} x
   * @param {number} y
   * @returns {number} An incremental index associated with the added item (starting from `0`).
   */
  add(t, n) {
    var r = this._pos >> 1;
    return this.ids[r] = r, this.coords[this._pos++] = t, this.coords[this._pos++] = n, r;
  }
  /**
   * Perform indexing of the added points.
   */
  finish() {
    var t = this._pos >> 1;
    if (t !== this.numItems)
      throw new Error("Added ".concat(t, " items when expected ").concat(this.numItems, "."));
    return tP(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
  }
  /**
   * Search the index for items within a given bounding box.
   * @param {number} minX
   * @param {number} minY
   * @param {number} maxX
   * @param {number} maxY
   * @returns {number[]} An array of indices correponding to the found items.
   */
  range(t, n, r, o) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: i,
      coords: a,
      nodeSize: s
    } = this, l = [0, i.length - 1, 0], u = []; l.length; ) {
      var c = l.pop() || 0, p = l.pop() || 0, d = l.pop() || 0;
      if (p - d <= s) {
        for (var g = d; g <= p; g++) {
          var f = a[2 * g], m = a[2 * g + 1];
          f >= t && f <= r && m >= n && m <= o && u.push(i[g]);
        }
        continue;
      }
      var b = d + p >> 1, E = a[2 * b], w = a[2 * b + 1];
      E >= t && E <= r && w >= n && w <= o && u.push(i[b]), (c === 0 ? t <= E : n <= w) && (l.push(d), l.push(b - 1), l.push(1 - c)), (c === 0 ? r >= E : o >= w) && (l.push(b + 1), l.push(p), l.push(1 - c));
    }
    return u;
  }
  /**
   * Search the index for items within a given radius.
   * @param {number} qx
   * @param {number} qy
   * @param {number} r Query radius.
   * @returns {number[]} An array of indices correponding to the found items.
   */
  within(t, n, r) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: o,
      coords: i,
      nodeSize: a
    } = this, s = [0, o.length - 1, 0], l = [], u = r * r; s.length; ) {
      var c = s.pop() || 0, p = s.pop() || 0, d = s.pop() || 0;
      if (p - d <= a) {
        for (var g = d; g <= p; g++)
          D3(i[2 * g], i[2 * g + 1], t, n) <= u && l.push(o[g]);
        continue;
      }
      var f = d + p >> 1, m = i[2 * f], b = i[2 * f + 1];
      D3(m, b, t, n) <= u && l.push(o[f]), (c === 0 ? t - r <= m : n - r <= b) && (s.push(d), s.push(f - 1), s.push(1 - c)), (c === 0 ? t + r >= m : n + r >= b) && (s.push(f + 1), s.push(p), s.push(1 - c));
    }
    return l;
  }
}
function tP(e, t, n, r, o, i) {
  if (!(o - r <= n)) {
    var a = r + o >> 1;
    lne(e, t, a, r, o, i), tP(e, t, n, r, a - 1, 1 - i), tP(e, t, n, a + 1, o, 1 - i);
  }
}
function lne(e, t, n, r, o, i) {
  for (; o > r; ) {
    if (o - r > 600) {
      var a = o - r + 1, s = n - r + 1, l = Math.log(a), u = 0.5 * Math.exp(2 * l / 3), c = 0.5 * Math.sqrt(l * u * (a - u) / a) * (s - a / 2 < 0 ? -1 : 1), p = Math.max(r, Math.floor(n - s * u / a + c)), d = Math.min(o, Math.floor(n + (a - s) * u / a + c));
      lne(e, t, n, p, d, i);
    }
    var g = t[2 * n + i], f = r, m = o;
    for (Pd(e, t, r, n), t[2 * o + i] > g && Pd(e, t, r, o); f < m; ) {
      for (Pd(e, t, f, m), f++, m--; t[2 * f + i] < g; ) f++;
      for (; t[2 * m + i] > g; ) m--;
    }
    t[2 * r + i] === g ? Pd(e, t, r, m) : (m++, Pd(e, t, m, o)), m <= n && (r = m + 1), n <= m && (o = m - 1);
  }
}
function Pd(e, t, n, r) {
  vk(e, n, r), vk(t, 2 * n, 2 * r), vk(t, 2 * n + 1, 2 * r + 1);
}
function vk(e, t, n) {
  var r = e[t];
  e[t] = e[n], e[n] = r;
}
function D3(e, t, n, r) {
  var o = e - n, i = t - r;
  return o * o + i * i;
}
var Dze = {
  minZoom: 0,
  // min zoom to generate clusters on
  maxZoom: 16,
  // max zoom level to cluster the points on
  minPoints: 2,
  // minimum points to form a cluster
  radius: 40,
  // cluster radius in pixels
  extent: 512,
  // tile extent (radius is calculated relative to it)
  nodeSize: 64,
  // size of the KD-tree leaf node, affects performance
  log: !1,
  // whether to log timing info
  // whether to generate numeric ids for input features (in vector tiles)
  generateId: !1,
  // a reduce function for calculating custom cluster properties
  reduce: null,
  // (accumulated, props) => { accumulated.sum += props.sum; }
  // properties to use for individual points when running the reducer
  map: (e) => e
  // props => ({sum: props.my_value})
}, T3 = Math.fround || /* @__PURE__ */ ((e) => (t) => (e[0] = +t, e[0]))(new Float32Array(1)), zu = 2, Hl = 3, yk = 4, Al = 5, une = 6;
class Tze {
  constructor(t) {
    this.options = Object.assign(Object.create(Dze), t), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
  }
  load(t) {
    var {
      log: n,
      minZoom: r,
      maxZoom: o
    } = this.options;
    n && console.time("total time");
    var i = "prepare ".concat(t.length, " points");
    n && console.time(i), this.points = t;
    for (var a = [], s = 0; s < t.length; s++) {
      var l = t[s];
      if (l.geometry) {
        var [u, c] = l.geometry.coordinates, p = T3(Pv(u)), d = T3(Sv(c));
        a.push(
          p,
          d,
          // projected point coordinates
          1 / 0,
          // the last zoom the point was processed at
          s,
          // index of the source feature in the original input array
          -1,
          // parent cluster id
          1
          // number of points in a cluster
        ), this.options.reduce && a.push(0);
      }
    }
    var g = this.trees[o + 1] = this._createTree(a);
    n && console.timeEnd(i);
    for (var f = o; f >= r; f--) {
      var m = +Date.now();
      g = this.trees[f] = this._createTree(this._cluster(g, f)), n && console.log("z%d: %d clusters in %dms", f, g.numItems, +Date.now() - m);
    }
    return n && console.timeEnd("total time"), this;
  }
  getClusters(t, n) {
    var r = ((t[0] + 180) % 360 + 360) % 360 - 180, o = Math.max(-90, Math.min(90, t[1])), i = t[2] === 180 ? 180 : ((t[2] + 180) % 360 + 360) % 360 - 180, a = Math.max(-90, Math.min(90, t[3]));
    if (t[2] - t[0] >= 360)
      r = -180, i = 180;
    else if (r > i) {
      var s = this.getClusters([r, o, 180, a], n), l = this.getClusters([-180, o, i, a], n);
      return s.concat(l);
    }
    var u = this.trees[this._limitZoom(n)], c = u.range(Pv(r), Sv(a), Pv(i), Sv(o)), p = u.data, d = [];
    for (var g of c) {
      var f = this.stride * g;
      d.push(p[f + Al] > 1 ? j3(p, f, this.clusterProps) : this.points[p[f + Hl]]);
    }
    return d;
  }
  getChildren(t) {
    var n = this._getOriginId(t), r = this._getOriginZoom(t), o = "No cluster with the specified id.", i = this.trees[r];
    if (!i) throw new Error(o);
    var a = i.data;
    if (n * this.stride >= a.length) throw new Error(o);
    var s = this.options.radius / (this.options.extent * Math.pow(2, r - 1)), l = a[n * this.stride], u = a[n * this.stride + 1], c = i.within(l, u, s), p = [];
    for (var d of c) {
      var g = d * this.stride;
      a[g + yk] === t && p.push(a[g + Al] > 1 ? j3(a, g, this.clusterProps) : this.points[a[g + Hl]]);
    }
    if (p.length === 0) throw new Error(o);
    return p;
  }
  getLeaves(t, n, r) {
    n = n || 10, r = r || 0;
    var o = [];
    return this._appendLeaves(o, t, n, r, 0), o;
  }
  getTile(t, n, r) {
    var o = this.trees[this._limitZoom(t)], i = Math.pow(2, t), {
      extent: a,
      radius: s
    } = this.options, l = s / a, u = (r - l) / i, c = (r + 1 + l) / i, p = {
      features: []
    };
    return this._addTileFeatures(o.range((n - l) / i, u, (n + 1 + l) / i, c), o.data, n, r, i, p), n === 0 && this._addTileFeatures(o.range(1 - l / i, u, 1, c), o.data, i, r, i, p), n === i - 1 && this._addTileFeatures(o.range(0, u, l / i, c), o.data, -1, r, i, p), p.features.length ? p : null;
  }
  getClusterExpansionZoom(t) {
    for (var n = this._getOriginZoom(t) - 1; n <= this.options.maxZoom; ) {
      var r = this.getChildren(t);
      if (n++, r.length !== 1) break;
      t = r[0].properties.cluster_id;
    }
    return n;
  }
  _appendLeaves(t, n, r, o, i) {
    var a = this.getChildren(n);
    for (var s of a) {
      var l = s.properties;
      if (l && l.cluster ? i + l.point_count <= o ? i += l.point_count : i = this._appendLeaves(t, l.cluster_id, r, o, i) : i < o ? i++ : t.push(s), t.length === r) break;
    }
    return i;
  }
  _createTree(t) {
    for (var n = new yT(t.length / this.stride | 0, this.options.nodeSize, Float32Array), r = 0; r < t.length; r += this.stride) n.add(t[r], t[r + 1]);
    return n.finish(), n.data = t, n;
  }
  _addTileFeatures(t, n, r, o, i, a) {
    for (var s of t) {
      var l = s * this.stride, u = n[l + Al] > 1, c = void 0, p = void 0, d = void 0;
      if (u)
        c = cne(n, l, this.clusterProps), p = n[l], d = n[l + 1];
      else {
        var g = this.points[n[l + Hl]];
        c = g.properties;
        var [f, m] = g.geometry.coordinates;
        p = Pv(f), d = Sv(m);
      }
      var b = {
        type: 1,
        geometry: [[Math.round(this.options.extent * (p * i - r)), Math.round(this.options.extent * (d * i - o))]],
        tags: c
      }, E = void 0;
      u || this.options.generateId ? E = n[l + Hl] : E = this.points[n[l + Hl]].id, E !== void 0 && (b.id = E), a.features.push(b);
    }
  }
  _limitZoom(t) {
    return Math.max(this.options.minZoom, Math.min(Math.floor(+t), this.options.maxZoom + 1));
  }
  _cluster(t, n) {
    for (var {
      radius: r,
      extent: o,
      reduce: i,
      minPoints: a
    } = this.options, s = r / (o * Math.pow(2, n)), l = t.data, u = [], c = this.stride, p = 0; p < l.length; p += c)
      if (!(l[p + zu] <= n)) {
        l[p + zu] = n;
        var d = l[p], g = l[p + 1], f = t.within(l[p], l[p + 1], s), m = l[p + Al], b = m;
        for (var E of f) {
          var w = E * c;
          l[w + zu] > n && (b += l[w + Al]);
        }
        if (b > m && b >= a) {
          var M = d * m, x = g * m, v = void 0, C = -1, P = ((p / c | 0) << 5) + (n + 1) + this.points.length;
          for (var F of f) {
            var L = F * c;
            if (!(l[L + zu] <= n)) {
              l[L + zu] = n;
              var B = l[L + Al];
              M += l[L] * B, x += l[L + 1] * B, l[L + yk] = P, i && (v || (v = this._map(l, p, !0), C = this.clusterProps.length, this.clusterProps.push(v)), i(v, this._map(l, L)));
            }
          }
          l[p + yk] = P, u.push(M / b, x / b, 1 / 0, P, -1, b), i && u.push(C);
        } else {
          for (var N = 0; N < c; N++) u.push(l[p + N]);
          if (b > 1)
            for (var $ of f) {
              var V = $ * c;
              if (!(l[V + zu] <= n)) {
                l[V + zu] = n;
                for (var H = 0; H < c; H++) u.push(l[V + H]);
              }
            }
        }
      }
    return u;
  }
  // get index of the point from which the cluster originated
  _getOriginId(t) {
    return t - this.points.length >> 5;
  }
  // get zoom of the point from which the cluster originated
  _getOriginZoom(t) {
    return (t - this.points.length) % 32;
  }
  _map(t, n, r) {
    if (t[n + Al] > 1) {
      var o = this.clusterProps[t[n + une]];
      return r ? Object.assign({}, o) : o;
    }
    var i = this.points[t[n + Hl]].properties, a = this.options.map(i);
    return r && a === i ? Object.assign({}, a) : a;
  }
}
function j3(e, t, n) {
  return {
    type: "Feature",
    id: e[t + Hl],
    properties: cne(e, t, n),
    geometry: {
      type: "Point",
      coordinates: [jze(e[t]), Aze(e[t + 1])]
    }
  };
}
function cne(e, t, n) {
  var r = e[t + Al], o = r >= 1e4 ? "".concat(Math.round(r / 1e3), "k") : r >= 1e3 ? "".concat(Math.round(r / 100) / 10, "k") : r, i = e[t + une], a = i === -1 ? {} : Object.assign({}, n[i]);
  return Object.assign(a, {
    cluster: !0,
    cluster_id: e[t + Hl],
    point_count: r,
    point_count_abbreviated: o
  });
}
function Pv(e) {
  return e / 360 + 0.5;
}
function Sv(e) {
  var t = Math.sin(e * Math.PI / 180), n = 0.5 - 0.25 * Math.log((1 + t) / (1 - t)) / Math.PI;
  return n < 0 ? 0 : n > 1 ? 1 : n;
}
function jze(e) {
  return (e - 0.5) * 360;
}
function Aze(e) {
  var t = (180 - e * 360) * Math.PI / 180;
  return 360 * Math.atan(Math.exp(t)) / Math.PI - 90;
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function Rze(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
    t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
  return n;
}
class fs {
  static isAdvancedMarkerAvailable(t) {
    return google.maps.marker && t.getMapCapabilities().isAdvancedMarkersAvailable === !0;
  }
  static isAdvancedMarker(t) {
    return google.maps.marker && t instanceof google.maps.marker.AdvancedMarkerElement;
  }
  static setMap(t, n) {
    this.isAdvancedMarker(t) ? t.map = n : t.setMap(n);
  }
  static getPosition(t) {
    if (this.isAdvancedMarker(t)) {
      if (t.position) {
        if (t.position instanceof google.maps.LatLng)
          return t.position;
        if (t.position.lat && t.position.lng)
          return new google.maps.LatLng(t.position.lat, t.position.lng);
      }
      return new google.maps.LatLng(null);
    }
    return t.getPosition();
  }
  static getVisible(t) {
    return this.isAdvancedMarker(t) ? !0 : t.getVisible();
  }
}
class nP {
  constructor(t) {
    var {
      markers: n,
      position: r
    } = t;
    this.markers = n, r && (r instanceof google.maps.LatLng ? this._position = r : this._position = new google.maps.LatLng(r));
  }
  get bounds() {
    if (!(this.markers.length === 0 && !this._position)) {
      var t = new google.maps.LatLngBounds(this._position, this._position);
      for (var n of this.markers)
        t.extend(fs.getPosition(n));
      return t;
    }
  }
  get position() {
    return this._position || this.bounds.getCenter();
  }
  /**
   * Get the count of **visible** markers.
   */
  get count() {
    return this.markers.filter((t) => fs.getVisible(t)).length;
  }
  /**
   * Add a marker to the cluster.
   */
  push(t) {
    this.markers.push(t);
  }
  /**
   * Cleanup references and remove marker from map.
   */
  delete() {
    this.marker && (fs.setMap(this.marker, null), this.marker = void 0), this.markers.length = 0;
  }
}
class Ize {
  constructor(t) {
    var {
      maxZoom: n = 16
    } = t;
    this.maxZoom = n;
  }
  /**
   * Helper function to bypass clustering based upon some map state such as
   * zoom, number of markers, etc.
   *
   * ```typescript
   *  cluster({markers, map}: AlgorithmInput): Cluster[] {
   *    if (shouldBypassClustering(map)) {
   *      return this.noop({markers})
   *    }
   * }
   * ```
   */
  noop(t) {
    var {
      markers: n
    } = t;
    return Nze(n);
  }
}
var Nze = (e) => {
  var t = e.map((n) => new nP({
    position: fs.getPosition(n),
    markers: [n]
  }));
  return t;
};
class Bze extends Ize {
  constructor(t) {
    var {
      maxZoom: n,
      radius: r = 60
    } = t, o = Rze(t, ["maxZoom", "radius"]);
    super({
      maxZoom: n
    }), this.state = {
      zoom: -1
    }, this.superCluster = new Tze(Object.assign({
      maxZoom: this.maxZoom,
      radius: r
    }, o));
  }
  calculate(t) {
    var n = !1, r = {
      zoom: t.map.getZoom()
    };
    if (!S3(t.markers, this.markers)) {
      n = !0, this.markers = [...t.markers];
      var o = this.markers.map((i) => {
        var a = fs.getPosition(i), s = [a.lng(), a.lat()];
        return {
          type: "Feature",
          geometry: {
            type: "Point",
            coordinates: s
          },
          properties: {
            marker: i
          }
        };
      });
      this.superCluster.load(o);
    }
    return n || (this.state.zoom <= this.maxZoom || r.zoom <= this.maxZoom) && (n = !S3(this.state, r)), this.state = r, n && (this.clusters = this.cluster(t)), {
      clusters: this.clusters,
      changed: n
    };
  }
  cluster(t) {
    var {
      map: n
    } = t;
    return this.superCluster.getClusters([-180, -90, 180, 90], Math.round(n.getZoom())).map((r) => this.transformCluster(r));
  }
  transformCluster(t) {
    var {
      geometry: {
        coordinates: [n, r]
      },
      properties: o
    } = t;
    if (o.cluster)
      return new nP({
        markers: this.superCluster.getLeaves(o.cluster_id, 1 / 0).map((a) => a.properties.marker),
        position: {
          lat: r,
          lng: n
        }
      });
    var i = o.marker;
    return new nP({
      markers: [i],
      position: fs.getPosition(i)
    });
  }
}
class Fze {
  constructor(t, n) {
    this.markers = {
      sum: t.length
    };
    var r = n.map((i) => i.count), o = r.reduce((i, a) => i + a, 0);
    this.clusters = {
      count: n.length,
      markers: {
        mean: o / n.length,
        sum: o,
        min: Math.min(...r),
        max: Math.max(...r)
      }
    };
  }
}
class zze {
  /**
   * The default render function for the library used by {@link MarkerClusterer}.
   *
   * Currently set to use the following:
   *
   * ```typescript
   * // change color if this cluster has more markers than the mean cluster
   * const color =
   *   count > Math.max(10, stats.clusters.markers.mean)
   *     ? "#ff0000"
   *     : "#0000ff";
   *
   * // create svg url with fill color
   * const svg = window.btoa(`
   * <svg fill="${color}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240">
   *   <circle cx="120" cy="120" opacity=".6" r="70" />
   *   <circle cx="120" cy="120" opacity=".3" r="90" />
   *   <circle cx="120" cy="120" opacity=".2" r="110" />
   *   <circle cx="120" cy="120" opacity=".1" r="130" />
   * </svg>`);
   *
   * // create marker using svg icon
   * return new google.maps.Marker({
   *   position,
   *   icon: {
   *     url: `data:image/svg+xml;base64,${svg}`,
   *     scaledSize: new google.maps.Size(45, 45),
   *   },
   *   label: {
   *     text: String(count),
   *     color: "rgba(255,255,255,0.9)",
   *     fontSize: "12px",
   *   },
   *   // adjust zIndex to be above other markers
   *   zIndex: 1000 + count,
   * });
   * ```
   */
  render(t, n, r) {
    var {
      count: o,
      position: i
    } = t, a = o > Math.max(10, n.clusters.markers.mean) ? "#ff0000" : "#0000ff", s = '<svg fill="'.concat(a, `" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" width="50" height="50">
<circle cx="120" cy="120" opacity=".6" r="70" />
<circle cx="120" cy="120" opacity=".3" r="90" />
<circle cx="120" cy="120" opacity=".2" r="110" />
<text x="50%" y="50%" style="fill:#fff" text-anchor="middle" font-size="50" dominant-baseline="middle" font-family="roboto,arial,sans-serif">`).concat(o, `</text>
</svg>`), l = "Cluster of ".concat(o, " markers"), u = Number(google.maps.Marker.MAX_ZINDEX) + o;
    if (fs.isAdvancedMarkerAvailable(r)) {
      var c = new DOMParser(), p = c.parseFromString(s, "image/svg+xml").documentElement;
      p.setAttribute("transform", "translate(0 25)");
      var d = {
        map: r,
        position: i,
        zIndex: u,
        title: l,
        content: p
      };
      return new google.maps.marker.AdvancedMarkerElement(d);
    }
    var g = {
      position: i,
      zIndex: u,
      title: l,
      icon: {
        url: "data:image/svg+xml;base64,".concat(btoa(s)),
        anchor: new google.maps.Point(25, 25)
      }
    };
    return new google.maps.Marker(g);
  }
}
function Uze(e, t) {
  for (var n in t.prototype)
    e.prototype[n] = t.prototype[n];
}
class bT {
  constructor() {
    Uze(bT, google.maps.OverlayView);
  }
}
var Sf;
(function(e) {
  e.CLUSTERING_BEGIN = "clusteringbegin", e.CLUSTERING_END = "clusteringend", e.CLUSTER_CLICK = "click";
})(Sf || (Sf = {}));
var Hze = (e, t, n) => {
  n.fitBounds(t.bounds);
};
class Wze extends bT {
  constructor(t) {
    var {
      map: n,
      markers: r = [],
      algorithmOptions: o = {},
      algorithm: i = new Bze(o),
      renderer: a = new zze(),
      onClusterClick: s = Hze
    } = t;
    super(), this.markers = [...r], this.clusters = [], this.algorithm = i, this.renderer = a, this.onClusterClick = s, n && this.setMap(n);
  }
  addMarker(t, n) {
    this.markers.includes(t) || (this.markers.push(t), n || this.render());
  }
  addMarkers(t, n) {
    t.forEach((r) => {
      this.addMarker(r, !0);
    }), n || this.render();
  }
  removeMarker(t, n) {
    var r = this.markers.indexOf(t);
    return r === -1 ? !1 : (fs.setMap(t, null), this.markers.splice(r, 1), n || this.render(), !0);
  }
  removeMarkers(t, n) {
    var r = !1;
    return t.forEach((o) => {
      r = this.removeMarker(o, !0) || r;
    }), r && !n && this.render(), r;
  }
  clearMarkers(t) {
    this.markers.length = 0, t || this.render();
  }
  /**
   * Recalculates and draws all the marker clusters.
   */
  render() {
    var t = this.getMap();
    if (t instanceof google.maps.Map && t.getProjection()) {
      google.maps.event.trigger(this, Sf.CLUSTERING_BEGIN, this);
      var {
        clusters: n,
        changed: r
      } = this.algorithm.calculate({
        markers: this.markers,
        map: t,
        mapCanvasProjection: this.getProjection()
      });
      if (r || r == null) {
        var o = /* @__PURE__ */ new Set();
        for (var i of n)
          i.markers.length == 1 && o.add(i.markers[0]);
        var a = [];
        for (var s of this.clusters)
          s.marker != null && (s.markers.length == 1 ? o.has(s.marker) || fs.setMap(s.marker, null) : a.push(s.marker));
        this.clusters = n, this.renderClusters(), requestAnimationFrame(() => a.forEach((l) => fs.setMap(l, null)));
      }
      google.maps.event.trigger(this, Sf.CLUSTERING_END, this);
    }
  }
  onAdd() {
    this.idleListener = this.getMap().addListener("idle", this.render.bind(this)), this.render();
  }
  onRemove() {
    google.maps.event.removeListener(this.idleListener), this.reset();
  }
  reset() {
    this.markers.forEach((t) => fs.setMap(t, null)), this.clusters.forEach((t) => t.delete()), this.clusters = [];
  }
  renderClusters() {
    var t = new Fze(this.markers, this.clusters), n = this.getMap();
    this.clusters.forEach((r) => {
      r.markers.length === 1 ? r.marker = r.markers[0] : (r.marker = this.renderer.render(r, t, n), r.markers.forEach((o) => fs.setMap(o, null)), this.onClusterClick && r.marker.addListener(
        "click",
        /* istanbul ignore next */
        (o) => {
          google.maps.event.trigger(this, Sf.CLUSTER_CLICK, r), this.onClusterClick(o, r, n);
        }
      )), fs.setMap(r.marker, n);
    });
  }
}
function A3(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function R3(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? A3(Object(n), !0).forEach(function(r) {
      Se(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : A3(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function $ze(e) {
  var t = HFe(), [n, r] = k(null);
  return h(() => {
    if (t && n === null) {
      var o = new Wze(R3(R3({}, e), {}, {
        map: t
      }));
      r(o);
    }
  }, [t]), n;
}
function Vze(e) {
  var {
    children: t,
    options: n
  } = e, r = $ze(n);
  return r !== null ? t(r) : null;
}
me(Vze);
var I3 = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, N3 = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
function Zze(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, g = ge(Bt), [f, m] = k(null), [b, E] = k(null), [w, M] = k(null), [x, v] = k(null), [C, P] = k(null), [F, L] = k(null), B = dt(null);
  return h(() => {
    f !== null && (f.close(), n ? f.open(g, n) : f.getPosition() && f.open(g));
  }, [g, f, n]), h(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), h(() => {
    o && f !== null && f.setPosition(o);
  }, [o]), h(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), h(() => {
    f && a && (b !== null && google.maps.event.removeListener(b), E(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), h(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), M(google.maps.event.addListener(f, "domready", s)));
  }, [s]), h(() => {
    f && l && (x !== null && google.maps.event.removeListener(x), v(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), h(() => {
    f && u && (C !== null && google.maps.event.removeListener(C), P(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), h(() => {
    f && c && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), h(() => {
    var N = new google.maps.InfoWindow(r);
    return m(N), B.current = document.createElement("div"), a && E(google.maps.event.addListener(N, "closeclick", a)), s && M(google.maps.event.addListener(N, "domready", s)), l && v(google.maps.event.addListener(N, "content_changed", l)), u && P(google.maps.event.addListener(N, "position_changed", u)), c && L(google.maps.event.addListener(N, "zindex_changed", c)), N.setContent(B.current), o && N.setPosition(o), i && N.setZIndex(i), n ? N.open(g, n) : N.getPosition() ? N.open(g) : $o(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>."), p && p(N), () => {
      b && google.maps.event.removeListener(b), x && google.maps.event.removeListener(x), w && google.maps.event.removeListener(w), C && google.maps.event.removeListener(C), F && google.maps.event.removeListener(F), d && d(N), N.close();
    };
  }, []), B.current ? zn(at.only(t), B.current) : null;
}
me(Zze);
class qze extends pe {
  constructor() {
    super(...arguments), Se(this, "registeredEvents", []), Se(this, "containerElement", null), Se(this, "state", {
      infoWindow: null
    }), Se(this, "open", (t, n) => {
      n ? t.open(this.context, n) : t.getPosition() ? t.open(this.context) : $o(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>.");
    }), Se(this, "setInfoWindowCallback", () => {
      this.state.infoWindow !== null && this.containerElement !== null && (this.state.infoWindow.setContent(this.containerElement), this.open(this.state.infoWindow, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoWindow));
    });
  }
  componentDidMount() {
    var t = new google.maps.InfoWindow(this.props.options);
    this.containerElement = document.createElement("div"), this.registeredEvents = wn({
      updaterMap: N3,
      eventMap: I3,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(() => ({
      infoWindow: t
    }), this.setInfoWindowCallback);
  }
  componentDidUpdate(t) {
    this.state.infoWindow !== null && (_n(this.registeredEvents), this.registeredEvents = wn({
      updaterMap: N3,
      eventMap: I3,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.infoWindow
    }));
  }
  componentWillUnmount() {
    this.state.infoWindow !== null && (_n(this.registeredEvents), this.props.onUnmount && this.props.onUnmount(this.state.infoWindow), this.state.infoWindow.close());
  }
  render() {
    return this.containerElement ? zn(at.only(this.props.children), this.containerElement) : null;
  }
}
Se(qze, "contextType", Bt);
function B3(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function dw(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? B3(Object(n), !0).forEach(function(r) {
      Se(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : B3(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var F3 = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, z3 = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, Gze = {};
function Kze(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: g,
    onRightClick: f,
    onClick: m,
    onDrag: b,
    onLoad: E,
    onUnmount: w
  } = e, M = ge(Bt), [x, v] = k(null), [C, P] = k(null), [F, L] = k(null), [B, N] = k(null), [$, V] = k(null), [H, Z] = k(null), [K, Y] = k(null), [Q, J] = k(null), [_, D] = k(null), [z, S] = k(null), [W, O] = k(null), [j, U] = k(null);
  return h(() => {
    x !== null && x.setMap(M);
  }, [M]), h(() => {
    typeof t < "u" && x !== null && x.setOptions(t);
  }, [x, t]), h(() => {
    typeof n < "u" && x !== null && x.setDraggable(n);
  }, [x, n]), h(() => {
    typeof r < "u" && x !== null && x.setEditable(r);
  }, [x, r]), h(() => {
    typeof o < "u" && x !== null && x.setVisible(o);
  }, [x, o]), h(() => {
    typeof i < "u" && x !== null && x.setPath(i);
  }, [x, i]), h(() => {
    x && a && (C !== null && google.maps.event.removeListener(C), P(google.maps.event.addListener(x, "dblclick", a)));
  }, [a]), h(() => {
    x && s && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(x, "dragend", s)));
  }, [s]), h(() => {
    x && l && (B !== null && google.maps.event.removeListener(B), N(google.maps.event.addListener(x, "dragstart", l)));
  }, [l]), h(() => {
    x && u && ($ !== null && google.maps.event.removeListener($), V(google.maps.event.addListener(x, "mousedown", u)));
  }, [u]), h(() => {
    x && c && (H !== null && google.maps.event.removeListener(H), Z(google.maps.event.addListener(x, "mousemove", c)));
  }, [c]), h(() => {
    x && p && (K !== null && google.maps.event.removeListener(K), Y(google.maps.event.addListener(x, "mouseout", p)));
  }, [p]), h(() => {
    x && d && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(x, "mouseover", d)));
  }, [d]), h(() => {
    x && g && (_ !== null && google.maps.event.removeListener(_), D(google.maps.event.addListener(x, "mouseup", g)));
  }, [g]), h(() => {
    x && f && (z !== null && google.maps.event.removeListener(z), S(google.maps.event.addListener(x, "rightclick", f)));
  }, [f]), h(() => {
    x && m && (W !== null && google.maps.event.removeListener(W), O(google.maps.event.addListener(x, "click", m)));
  }, [m]), h(() => {
    x && b && (j !== null && google.maps.event.removeListener(j), U(google.maps.event.addListener(x, "drag", b)));
  }, [b]), h(() => {
    var T = new google.maps.Polyline(dw(dw({}, t || Gze), {}, {
      map: M
    }));
    return i && T.setPath(i), typeof o < "u" && T.setVisible(o), typeof r < "u" && T.setEditable(r), typeof n < "u" && T.setDraggable(n), a && P(google.maps.event.addListener(T, "dblclick", a)), s && L(google.maps.event.addListener(T, "dragend", s)), l && N(google.maps.event.addListener(T, "dragstart", l)), u && V(google.maps.event.addListener(T, "mousedown", u)), c && Z(google.maps.event.addListener(T, "mousemove", c)), p && Y(google.maps.event.addListener(T, "mouseout", p)), d && J(google.maps.event.addListener(T, "mouseover", d)), g && D(google.maps.event.addListener(T, "mouseup", g)), f && S(google.maps.event.addListener(T, "rightclick", f)), m && O(google.maps.event.addListener(T, "click", m)), b && U(google.maps.event.addListener(T, "drag", b)), v(T), E && E(T), () => {
      C !== null && google.maps.event.removeListener(C), F !== null && google.maps.event.removeListener(F), B !== null && google.maps.event.removeListener(B), $ !== null && google.maps.event.removeListener($), H !== null && google.maps.event.removeListener(H), K !== null && google.maps.event.removeListener(K), Q !== null && google.maps.event.removeListener(Q), _ !== null && google.maps.event.removeListener(_), z !== null && google.maps.event.removeListener(z), W !== null && google.maps.event.removeListener(W), w && w(T), T.setMap(null);
    };
  }, []), null;
}
me(Kze);
class Xze extends pe {
  constructor() {
    super(...arguments), Se(this, "registeredEvents", []), Se(this, "state", {
      polyline: null
    }), Se(this, "setPolylineCallback", () => {
      this.state.polyline !== null && this.props.onLoad && this.props.onLoad(this.state.polyline);
    });
  }
  componentDidMount() {
    var t = new google.maps.Polyline(dw(dw({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = wn({
      updaterMap: z3,
      eventMap: F3,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        polyline: t
      };
    }, this.setPolylineCallback);
  }
  componentDidUpdate(t) {
    this.state.polyline !== null && (_n(this.registeredEvents), this.registeredEvents = wn({
      updaterMap: z3,
      eventMap: F3,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.polyline
    }));
  }
  componentWillUnmount() {
    this.state.polyline !== null && (this.props.onUnmount && this.props.onUnmount(this.state.polyline), _n(this.registeredEvents), this.state.polyline.setMap(null));
  }
  render() {
    return null;
  }
}
Se(Xze, "contextType", Bt);
function U3(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function H3(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? U3(Object(n), !0).forEach(function(r) {
      Se(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : U3(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var W3 = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, $3 = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  paths(e, t) {
    e.setPaths(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function Yze(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    paths: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: g,
    onMouseUp: f,
    onRightClick: m,
    onClick: b,
    onDrag: E,
    onLoad: w,
    onUnmount: M,
    onEdit: x
  } = e, v = ge(Bt), [C, P] = k(null), [F, L] = k(null), [B, N] = k(null), [$, V] = k(null), [H, Z] = k(null), [K, Y] = k(null), [Q, J] = k(null), [_, D] = k(null), [z, S] = k(null), [W, O] = k(null), [j, U] = k(null), [T, q] = k(null);
  return h(() => {
    C !== null && C.setMap(v);
  }, [v]), h(() => {
    typeof t < "u" && C !== null && C.setOptions(t);
  }, [C, t]), h(() => {
    typeof n < "u" && C !== null && C.setDraggable(n);
  }, [C, n]), h(() => {
    typeof r < "u" && C !== null && C.setEditable(r);
  }, [C, r]), h(() => {
    typeof o < "u" && C !== null && C.setVisible(o);
  }, [C, o]), h(() => {
    typeof i < "u" && C !== null && C.setPath(i);
  }, [C, i]), h(() => {
    typeof a < "u" && C !== null && C.setPaths(a);
  }, [C, a]), h(() => {
    C && typeof s == "function" && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(C, "dblclick", s)));
  }, [s]), h(() => {
    C && (google.maps.event.addListener(C.getPath(), "insert_at", () => {
      x == null || x(C);
    }), google.maps.event.addListener(C.getPath(), "set_at", () => {
      x == null || x(C);
    }), google.maps.event.addListener(C.getPath(), "remove_at", () => {
      x == null || x(C);
    }));
  }, [C, x]), h(() => {
    C && typeof l == "function" && (B !== null && google.maps.event.removeListener(B), N(google.maps.event.addListener(C, "dragend", l)));
  }, [l]), h(() => {
    C && typeof u == "function" && ($ !== null && google.maps.event.removeListener($), V(google.maps.event.addListener(C, "dragstart", u)));
  }, [u]), h(() => {
    C && typeof c == "function" && (H !== null && google.maps.event.removeListener(H), Z(google.maps.event.addListener(C, "mousedown", c)));
  }, [c]), h(() => {
    C && typeof p == "function" && (K !== null && google.maps.event.removeListener(K), Y(google.maps.event.addListener(C, "mousemove", p)));
  }, [p]), h(() => {
    C && typeof d == "function" && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(C, "mouseout", d)));
  }, [d]), h(() => {
    C && typeof g == "function" && (_ !== null && google.maps.event.removeListener(_), D(google.maps.event.addListener(C, "mouseover", g)));
  }, [g]), h(() => {
    C && typeof f == "function" && (z !== null && google.maps.event.removeListener(z), S(google.maps.event.addListener(C, "mouseup", f)));
  }, [f]), h(() => {
    C && typeof m == "function" && (W !== null && google.maps.event.removeListener(W), O(google.maps.event.addListener(C, "rightclick", m)));
  }, [m]), h(() => {
    C && typeof b == "function" && (j !== null && google.maps.event.removeListener(j), U(google.maps.event.addListener(C, "click", b)));
  }, [b]), h(() => {
    C && typeof E == "function" && (T !== null && google.maps.event.removeListener(T), q(google.maps.event.addListener(C, "drag", E)));
  }, [E]), h(() => {
    var A = new google.maps.Polygon(H3(H3({}, t), {}, {
      map: v
    }));
    return i && A.setPath(i), a && A.setPaths(a), typeof o < "u" && A.setVisible(o), typeof r < "u" && A.setEditable(r), typeof n < "u" && A.setDraggable(n), s && L(google.maps.event.addListener(A, "dblclick", s)), l && N(google.maps.event.addListener(A, "dragend", l)), u && V(google.maps.event.addListener(A, "dragstart", u)), c && Z(google.maps.event.addListener(A, "mousedown", c)), p && Y(google.maps.event.addListener(A, "mousemove", p)), d && J(google.maps.event.addListener(A, "mouseout", d)), g && D(google.maps.event.addListener(A, "mouseover", g)), f && S(google.maps.event.addListener(A, "mouseup", f)), m && O(google.maps.event.addListener(A, "rightclick", m)), b && U(google.maps.event.addListener(A, "click", b)), E && q(google.maps.event.addListener(A, "drag", E)), P(A), w && w(A), () => {
      F !== null && google.maps.event.removeListener(F), B !== null && google.maps.event.removeListener(B), $ !== null && google.maps.event.removeListener($), H !== null && google.maps.event.removeListener(H), K !== null && google.maps.event.removeListener(K), Q !== null && google.maps.event.removeListener(Q), _ !== null && google.maps.event.removeListener(_), z !== null && google.maps.event.removeListener(z), W !== null && google.maps.event.removeListener(W), j !== null && google.maps.event.removeListener(j), M && M(A), A.setMap(null);
    };
  }, []), null;
}
me(Yze);
class Jze extends pe {
  constructor() {
    super(...arguments), Se(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this.props.options || {};
    this.polygon = new google.maps.Polygon(t), this.polygon.setMap(this.context), this.registeredEvents = wn({
      updaterMap: $3,
      eventMap: W3,
      prevProps: {},
      nextProps: this.props,
      instance: this.polygon
    }), this.props.onLoad && this.props.onLoad(this.polygon);
  }
  componentDidUpdate(t) {
    this.polygon && (_n(this.registeredEvents), this.registeredEvents = wn({
      updaterMap: $3,
      eventMap: W3,
      prevProps: t,
      nextProps: this.props,
      instance: this.polygon
    }));
  }
  componentWillUnmount() {
    this.polygon && (this.props.onUnmount && this.props.onUnmount(this.polygon), _n(this.registeredEvents), this.polygon && this.polygon.setMap(null));
  }
  render() {
    return null;
  }
}
Se(Jze, "contextType", Bt);
function V3(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function fw(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? V3(Object(n), !0).forEach(function(r) {
      Se(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : V3(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Z3 = {
  onBoundsChanged: "bounds_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, q3 = {
  bounds(e, t) {
    e.setBounds(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function Qze(e) {
  var {
    options: t,
    bounds: n,
    draggable: r,
    editable: o,
    visible: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: g,
    onRightClick: f,
    onClick: m,
    onDrag: b,
    onBoundsChanged: E,
    onLoad: w,
    onUnmount: M
  } = e, x = ge(Bt), [v, C] = k(null), [P, F] = k(null), [L, B] = k(null), [N, $] = k(null), [V, H] = k(null), [Z, K] = k(null), [Y, Q] = k(null), [J, _] = k(null), [D, z] = k(null), [S, W] = k(null), [O, j] = k(null), [U, T] = k(null), [q, A] = k(null);
  return h(() => {
    v !== null && v.setMap(x);
  }, [x]), h(() => {
    typeof t < "u" && v !== null && v.setOptions(t);
  }, [v, t]), h(() => {
    typeof r < "u" && v !== null && v.setDraggable(r);
  }, [v, r]), h(() => {
    typeof o < "u" && v !== null && v.setEditable(o);
  }, [v, o]), h(() => {
    typeof i < "u" && v !== null && v.setVisible(i);
  }, [v, i]), h(() => {
    typeof n < "u" && v !== null && v.setBounds(n);
  }, [v, n]), h(() => {
    v && a && (P !== null && google.maps.event.removeListener(P), F(google.maps.event.addListener(v, "dblclick", a)));
  }, [a]), h(() => {
    v && s && (L !== null && google.maps.event.removeListener(L), B(google.maps.event.addListener(v, "dragend", s)));
  }, [s]), h(() => {
    v && l && (N !== null && google.maps.event.removeListener(N), $(google.maps.event.addListener(v, "dragstart", l)));
  }, [l]), h(() => {
    v && u && (V !== null && google.maps.event.removeListener(V), H(google.maps.event.addListener(v, "mousedown", u)));
  }, [u]), h(() => {
    v && c && (Z !== null && google.maps.event.removeListener(Z), K(google.maps.event.addListener(v, "mousemove", c)));
  }, [c]), h(() => {
    v && p && (Y !== null && google.maps.event.removeListener(Y), Q(google.maps.event.addListener(v, "mouseout", p)));
  }, [p]), h(() => {
    v && d && (J !== null && google.maps.event.removeListener(J), _(google.maps.event.addListener(v, "mouseover", d)));
  }, [d]), h(() => {
    v && g && (D !== null && google.maps.event.removeListener(D), z(google.maps.event.addListener(v, "mouseup", g)));
  }, [g]), h(() => {
    v && f && (S !== null && google.maps.event.removeListener(S), W(google.maps.event.addListener(v, "rightclick", f)));
  }, [f]), h(() => {
    v && m && (O !== null && google.maps.event.removeListener(O), j(google.maps.event.addListener(v, "click", m)));
  }, [m]), h(() => {
    v && b && (U !== null && google.maps.event.removeListener(U), T(google.maps.event.addListener(v, "drag", b)));
  }, [b]), h(() => {
    v && E && (q !== null && google.maps.event.removeListener(q), A(google.maps.event.addListener(v, "bounds_changed", E)));
  }, [E]), h(() => {
    var X = new google.maps.Rectangle(fw(fw({}, t), {}, {
      map: x
    }));
    return typeof i < "u" && X.setVisible(i), typeof o < "u" && X.setEditable(o), typeof r < "u" && X.setDraggable(r), typeof n < "u" && X.setBounds(n), a && F(google.maps.event.addListener(X, "dblclick", a)), s && B(google.maps.event.addListener(X, "dragend", s)), l && $(google.maps.event.addListener(X, "dragstart", l)), u && H(google.maps.event.addListener(X, "mousedown", u)), c && K(google.maps.event.addListener(X, "mousemove", c)), p && Q(google.maps.event.addListener(X, "mouseout", p)), d && _(google.maps.event.addListener(X, "mouseover", d)), g && z(google.maps.event.addListener(X, "mouseup", g)), f && W(google.maps.event.addListener(X, "rightclick", f)), m && j(google.maps.event.addListener(X, "click", m)), b && T(google.maps.event.addListener(X, "drag", b)), E && A(google.maps.event.addListener(X, "bounds_changed", E)), C(X), w && w(X), () => {
      P !== null && google.maps.event.removeListener(P), L !== null && google.maps.event.removeListener(L), N !== null && google.maps.event.removeListener(N), V !== null && google.maps.event.removeListener(V), Z !== null && google.maps.event.removeListener(Z), Y !== null && google.maps.event.removeListener(Y), J !== null && google.maps.event.removeListener(J), D !== null && google.maps.event.removeListener(D), S !== null && google.maps.event.removeListener(S), O !== null && google.maps.event.removeListener(O), U !== null && google.maps.event.removeListener(U), q !== null && google.maps.event.removeListener(q), M && M(X), X.setMap(null);
    };
  }, []), null;
}
me(Qze);
class e2e extends pe {
  constructor() {
    super(...arguments), Se(this, "registeredEvents", []), Se(this, "state", {
      rectangle: null
    }), Se(this, "setRectangleCallback", () => {
      this.state.rectangle !== null && this.props.onLoad && this.props.onLoad(this.state.rectangle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Rectangle(fw(fw({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = wn({
      updaterMap: q3,
      eventMap: Z3,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        rectangle: t
      };
    }, this.setRectangleCallback);
  }
  componentDidUpdate(t) {
    this.state.rectangle !== null && (_n(this.registeredEvents), this.registeredEvents = wn({
      updaterMap: q3,
      eventMap: Z3,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.rectangle
    }));
  }
  componentWillUnmount() {
    this.state.rectangle !== null && (this.props.onUnmount && this.props.onUnmount(this.state.rectangle), _n(this.registeredEvents), this.state.rectangle.setMap(null));
  }
  render() {
    return null;
  }
}
Se(e2e, "contextType", Bt);
function G3(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function hw(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? G3(Object(n), !0).forEach(function(r) {
      Se(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : G3(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var K3 = {
  onCenterChanged: "center_changed",
  onRadiusChanged: "radius_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, X3 = {
  center(e, t) {
    e.setCenter(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  radius(e, t) {
    e.setRadius(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, t2e = {};
function n2e(e) {
  var {
    options: t,
    center: n,
    radius: r,
    draggable: o,
    editable: i,
    visible: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: g,
    onMouseUp: f,
    onRightClick: m,
    onClick: b,
    onDrag: E,
    onCenterChanged: w,
    onRadiusChanged: M,
    onLoad: x,
    onUnmount: v
  } = e, C = ge(Bt), [P, F] = k(null), [L, B] = k(null), [N, $] = k(null), [V, H] = k(null), [Z, K] = k(null), [Y, Q] = k(null), [J, _] = k(null), [D, z] = k(null), [S, W] = k(null), [O, j] = k(null), [U, T] = k(null), [q, A] = k(null), [X, I] = k(null), [le, he] = k(null);
  return h(() => {
    P !== null && P.setMap(C);
  }, [C]), h(() => {
    typeof t < "u" && P !== null && P.setOptions(t);
  }, [P, t]), h(() => {
    typeof o < "u" && P !== null && P.setDraggable(o);
  }, [P, o]), h(() => {
    typeof i < "u" && P !== null && P.setEditable(i);
  }, [P, i]), h(() => {
    typeof a < "u" && P !== null && P.setVisible(a);
  }, [P, a]), h(() => {
    typeof r == "number" && P !== null && P.setRadius(r);
  }, [P, r]), h(() => {
    typeof n < "u" && P !== null && P.setCenter(n);
  }, [P, n]), h(() => {
    P && s && (L !== null && google.maps.event.removeListener(L), B(google.maps.event.addListener(P, "dblclick", s)));
  }, [s]), h(() => {
    P && l && (N !== null && google.maps.event.removeListener(N), $(google.maps.event.addListener(P, "dragend", l)));
  }, [l]), h(() => {
    P && u && (V !== null && google.maps.event.removeListener(V), H(google.maps.event.addListener(P, "dragstart", u)));
  }, [u]), h(() => {
    P && c && (Z !== null && google.maps.event.removeListener(Z), K(google.maps.event.addListener(P, "mousedown", c)));
  }, [c]), h(() => {
    P && p && (Y !== null && google.maps.event.removeListener(Y), Q(google.maps.event.addListener(P, "mousemove", p)));
  }, [p]), h(() => {
    P && d && (J !== null && google.maps.event.removeListener(J), _(google.maps.event.addListener(P, "mouseout", d)));
  }, [d]), h(() => {
    P && g && (D !== null && google.maps.event.removeListener(D), z(google.maps.event.addListener(P, "mouseover", g)));
  }, [g]), h(() => {
    P && f && (S !== null && google.maps.event.removeListener(S), W(google.maps.event.addListener(P, "mouseup", f)));
  }, [f]), h(() => {
    P && m && (O !== null && google.maps.event.removeListener(O), j(google.maps.event.addListener(P, "rightclick", m)));
  }, [m]), h(() => {
    P && b && (U !== null && google.maps.event.removeListener(U), T(google.maps.event.addListener(P, "click", b)));
  }, [b]), h(() => {
    P && E && (q !== null && google.maps.event.removeListener(q), A(google.maps.event.addListener(P, "drag", E)));
  }, [E]), h(() => {
    P && w && (X !== null && google.maps.event.removeListener(X), I(google.maps.event.addListener(P, "center_changed", w)));
  }, [b]), h(() => {
    P && M && (le !== null && google.maps.event.removeListener(le), he(google.maps.event.addListener(P, "radius_changed", M)));
  }, [M]), h(() => {
    var oe = new google.maps.Circle(hw(hw({}, t || t2e), {}, {
      map: C
    }));
    return typeof r == "number" && oe.setRadius(r), typeof n < "u" && oe.setCenter(n), typeof r == "number" && oe.setRadius(r), typeof a < "u" && oe.setVisible(a), typeof i < "u" && oe.setEditable(i), typeof o < "u" && oe.setDraggable(o), s && B(google.maps.event.addListener(oe, "dblclick", s)), l && $(google.maps.event.addListener(oe, "dragend", l)), u && H(google.maps.event.addListener(oe, "dragstart", u)), c && K(google.maps.event.addListener(oe, "mousedown", c)), p && Q(google.maps.event.addListener(oe, "mousemove", p)), d && _(google.maps.event.addListener(oe, "mouseout", d)), g && z(google.maps.event.addListener(oe, "mouseover", g)), f && W(google.maps.event.addListener(oe, "mouseup", f)), m && j(google.maps.event.addListener(oe, "rightclick", m)), b && T(google.maps.event.addListener(oe, "click", b)), E && A(google.maps.event.addListener(oe, "drag", E)), w && I(google.maps.event.addListener(oe, "center_changed", w)), M && he(google.maps.event.addListener(oe, "radius_changed", M)), F(oe), x && x(oe), () => {
      L !== null && google.maps.event.removeListener(L), N !== null && google.maps.event.removeListener(N), V !== null && google.maps.event.removeListener(V), Z !== null && google.maps.event.removeListener(Z), Y !== null && google.maps.event.removeListener(Y), J !== null && google.maps.event.removeListener(J), D !== null && google.maps.event.removeListener(D), S !== null && google.maps.event.removeListener(S), O !== null && google.maps.event.removeListener(O), U !== null && google.maps.event.removeListener(U), X !== null && google.maps.event.removeListener(X), le !== null && google.maps.event.removeListener(le), v && v(oe), oe.setMap(null);
    };
  }, []), null;
}
me(n2e);
class r2e extends pe {
  constructor() {
    super(...arguments), Se(this, "registeredEvents", []), Se(this, "state", {
      circle: null
    }), Se(this, "setCircleCallback", () => {
      this.state.circle !== null && this.props.onLoad && this.props.onLoad(this.state.circle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Circle(hw(hw({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = wn({
      updaterMap: X3,
      eventMap: K3,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        circle: t
      };
    }, this.setCircleCallback);
  }
  componentDidUpdate(t) {
    this.state.circle !== null && (_n(this.registeredEvents), this.registeredEvents = wn({
      updaterMap: X3,
      eventMap: K3,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.circle
    }));
  }
  componentWillUnmount() {
    if (this.state.circle !== null) {
      var t;
      this.props.onUnmount && this.props.onUnmount(this.state.circle), _n(this.registeredEvents), (t = this.state.circle) === null || t === void 0 || t.setMap(null);
    }
  }
  render() {
    return null;
  }
}
Se(r2e, "contextType", Bt);
function Y3(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function gw(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Y3(Object(n), !0).forEach(function(r) {
      Se(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Y3(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var J3 = {
  onClick: "click",
  onDblClick: "dblclick",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onAddFeature: "addfeature",
  onRemoveFeature: "removefeature",
  onRemoveProperty: "removeproperty",
  onSetGeometry: "setgeometry",
  onSetProperty: "setproperty"
}, Q3 = {
  add(e, t) {
    e.add(t);
  },
  addgeojson(e, t, n) {
    e.addGeoJson(t, n);
  },
  contains(e, t) {
    e.contains(t);
  },
  foreach(e, t) {
    e.forEach(t);
  },
  loadgeojson(e, t, n, r) {
    e.loadGeoJson(t, n, r);
  },
  overridestyle(e, t, n) {
    e.overrideStyle(t, n);
  },
  remove(e, t) {
    e.remove(t);
  },
  revertstyle(e, t) {
    e.revertStyle(t);
  },
  controlposition(e, t) {
    e.setControlPosition(t);
  },
  controls(e, t) {
    e.setControls(t);
  },
  drawingmode(e, t) {
    e.setDrawingMode(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  style(e, t) {
    e.setStyle(t);
  },
  togeojson(e, t) {
    e.toGeoJson(t);
  }
};
function o2e(e) {
  var {
    options: t,
    onClick: n,
    onDblClick: r,
    onMouseDown: o,
    onMouseMove: i,
    onMouseOut: a,
    onMouseOver: s,
    onMouseUp: l,
    onRightClick: u,
    onAddFeature: c,
    onRemoveFeature: p,
    onRemoveProperty: d,
    onSetGeometry: g,
    onSetProperty: f,
    onLoad: m,
    onUnmount: b
  } = e, E = ge(Bt), [w, M] = k(null), [x, v] = k(null), [C, P] = k(null), [F, L] = k(null), [B, N] = k(null), [$, V] = k(null), [H, Z] = k(null), [K, Y] = k(null), [Q, J] = k(null), [_, D] = k(null), [z, S] = k(null), [W, O] = k(null), [j, U] = k(null), [T, q] = k(null);
  return h(() => {
    w !== null && w.setMap(E);
  }, [E]), h(() => {
    w && r && (x !== null && google.maps.event.removeListener(x), v(google.maps.event.addListener(w, "dblclick", r)));
  }, [r]), h(() => {
    w && o && (C !== null && google.maps.event.removeListener(C), P(google.maps.event.addListener(w, "mousedown", o)));
  }, [o]), h(() => {
    w && i && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(w, "mousemove", i)));
  }, [i]), h(() => {
    w && a && (B !== null && google.maps.event.removeListener(B), N(google.maps.event.addListener(w, "mouseout", a)));
  }, [a]), h(() => {
    w && s && ($ !== null && google.maps.event.removeListener($), V(google.maps.event.addListener(w, "mouseover", s)));
  }, [s]), h(() => {
    w && l && (H !== null && google.maps.event.removeListener(H), Z(google.maps.event.addListener(w, "mouseup", l)));
  }, [l]), h(() => {
    w && u && (K !== null && google.maps.event.removeListener(K), Y(google.maps.event.addListener(w, "rightclick", u)));
  }, [u]), h(() => {
    w && n && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(w, "click", n)));
  }, [n]), h(() => {
    w && c && (_ !== null && google.maps.event.removeListener(_), D(google.maps.event.addListener(w, "addfeature", c)));
  }, [c]), h(() => {
    w && p && (z !== null && google.maps.event.removeListener(z), S(google.maps.event.addListener(w, "removefeature", p)));
  }, [p]), h(() => {
    w && d && (W !== null && google.maps.event.removeListener(W), O(google.maps.event.addListener(w, "removeproperty", d)));
  }, [d]), h(() => {
    w && g && (j !== null && google.maps.event.removeListener(j), U(google.maps.event.addListener(w, "setgeometry", g)));
  }, [g]), h(() => {
    w && f && (T !== null && google.maps.event.removeListener(T), q(google.maps.event.addListener(w, "setproperty", f)));
  }, [f]), h(() => {
    if (E !== null) {
      var A = new google.maps.Data(gw(gw({}, t), {}, {
        map: E
      }));
      r && v(google.maps.event.addListener(A, "dblclick", r)), o && P(google.maps.event.addListener(A, "mousedown", o)), i && L(google.maps.event.addListener(A, "mousemove", i)), a && N(google.maps.event.addListener(A, "mouseout", a)), s && V(google.maps.event.addListener(A, "mouseover", s)), l && Z(google.maps.event.addListener(A, "mouseup", l)), u && Y(google.maps.event.addListener(A, "rightclick", u)), n && J(google.maps.event.addListener(A, "click", n)), c && D(google.maps.event.addListener(A, "addfeature", c)), p && S(google.maps.event.addListener(A, "removefeature", p)), d && O(google.maps.event.addListener(A, "removeproperty", d)), g && U(google.maps.event.addListener(A, "setgeometry", g)), f && q(google.maps.event.addListener(A, "setproperty", f)), M(A), m && m(A);
    }
    return () => {
      w && (x !== null && google.maps.event.removeListener(x), C !== null && google.maps.event.removeListener(C), F !== null && google.maps.event.removeListener(F), B !== null && google.maps.event.removeListener(B), $ !== null && google.maps.event.removeListener($), H !== null && google.maps.event.removeListener(H), K !== null && google.maps.event.removeListener(K), Q !== null && google.maps.event.removeListener(Q), _ !== null && google.maps.event.removeListener(_), z !== null && google.maps.event.removeListener(z), W !== null && google.maps.event.removeListener(W), j !== null && google.maps.event.removeListener(j), T !== null && google.maps.event.removeListener(T), b && b(w), w.setMap(null));
    };
  }, []), null;
}
me(o2e);
class i2e extends pe {
  constructor() {
    super(...arguments), Se(this, "registeredEvents", []), Se(this, "state", {
      data: null
    }), Se(this, "setDataCallback", () => {
      this.state.data !== null && this.props.onLoad && this.props.onLoad(this.state.data);
    });
  }
  componentDidMount() {
    if (this.context !== null) {
      var t = new google.maps.Data(gw(gw({}, this.props.options), {}, {
        map: this.context
      }));
      this.registeredEvents = wn({
        updaterMap: Q3,
        eventMap: J3,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        data: t
      }), this.setDataCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.data !== null && (_n(this.registeredEvents), this.registeredEvents = wn({
      updaterMap: Q3,
      eventMap: J3,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.data
    }));
  }
  componentWillUnmount() {
    this.state.data !== null && (this.props.onUnmount && this.props.onUnmount(this.state.data), _n(this.registeredEvents), this.state.data && this.state.data.setMap(null));
  }
  render() {
    return null;
  }
}
Se(i2e, "contextType", Bt);
function eV(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function tV(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? eV(Object(n), !0).forEach(function(r) {
      Se(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : eV(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var nV = {
  onClick: "click",
  onDefaultViewportChanged: "defaultviewport_changed",
  onStatusChanged: "status_changed"
}, rV = {
  options(e, t) {
    e.setOptions(t);
  },
  url(e, t) {
    e.setUrl(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
class s2e extends pe {
  constructor() {
    super(...arguments), Se(this, "registeredEvents", []), Se(this, "state", {
      kmlLayer: null
    }), Se(this, "setKmlLayerCallback", () => {
      this.state.kmlLayer !== null && this.props.onLoad && this.props.onLoad(this.state.kmlLayer);
    });
  }
  componentDidMount() {
    var t = new google.maps.KmlLayer(tV(tV({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = wn({
      updaterMap: rV,
      eventMap: nV,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        kmlLayer: t
      };
    }, this.setKmlLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.kmlLayer !== null && (_n(this.registeredEvents), this.registeredEvents = wn({
      updaterMap: rV,
      eventMap: nV,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.kmlLayer
    }));
  }
  componentWillUnmount() {
    this.state.kmlLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.kmlLayer), _n(this.registeredEvents), this.state.kmlLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Se(s2e, "contextType", Bt);
function pne(e, t) {
  return typeof t == "function" ? t(e.offsetWidth, e.offsetHeight) : {
    x: 0,
    y: 0
  };
}
function a2e(e, t) {
  return new t(e.lat, e.lng);
}
function l2e(e, t) {
  return new t(new google.maps.LatLng(e.ne.lat, e.ne.lng), new google.maps.LatLng(e.sw.lat, e.sw.lng));
}
function u2e(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function c2e(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function p2e(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n.getNorthEast()), o = e && e.fromLatLngToDivPixel(n.getSouthWest());
  return r && o ? {
    left: "".concat(o.x + t.x, "px"),
    top: "".concat(r.y + t.y, "px"),
    width: "".concat(r.x - o.x - t.x, "px"),
    height: "".concat(o.y - r.y - t.y, "px")
  } : {
    left: "-9999px",
    top: "-9999px"
  };
}
function d2e(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n);
  if (r) {
    var {
      x: o,
      y: i
    } = r;
    return {
      left: "".concat(o + t.x, "px"),
      top: "".concat(i + t.y, "px")
    };
  }
  return {
    left: "-9999px",
    top: "-9999px"
  };
}
function dne(e, t, n, r) {
  return n !== void 0 ? p2e(e, t, c2e(n, google.maps.LatLngBounds, l2e)) : d2e(e, t, u2e(r, google.maps.LatLng, a2e));
}
function f2e(e, t) {
  return e.left === t.left && e.top === t.top && e.width === t.height && e.height === t.height;
}
function oV(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function h2e(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? oV(Object(n), !0).forEach(function(r) {
      Se(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : oV(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function g2e(e, t, n, r, o) {
  class i extends google.maps.OverlayView {
    constructor(s, l, u, c) {
      super(), this.container = s, this.pane = l, this.position = u, this.bounds = c;
    }
    onAdd() {
      var s, l = (s = this.getPanes()) === null || s === void 0 ? void 0 : s[this.pane];
      l == null || l.appendChild(this.container);
    }
    draw() {
      var s = this.getProjection(), l = h2e({}, this.container ? pne(this.container, o) : {
        x: 0,
        y: 0
      }), u = dne(s, l, this.bounds, this.position);
      for (var [c, p] of Object.entries(u))
        this.container.style[c] = p;
    }
    onRemove() {
      this.container.parentNode !== null && this.container.parentNode.removeChild(this.container);
    }
  }
  return new i(e, t, n, r);
}
function iV(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function m2e(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? iV(Object(n), !0).forEach(function(r) {
      Se(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : iV(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function sV(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLng ? e : new google.maps.LatLng(e.lat, e.lng);
  return t + "";
}
function aV(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLngBounds ? e : new google.maps.LatLngBounds(new google.maps.LatLng(e.south, e.east), new google.maps.LatLng(e.north, e.west));
  return t + "";
}
function v2e(e) {
  var {
    position: t,
    bounds: n,
    mapPaneName: r,
    zIndex: o,
    onLoad: i,
    onUnmount: a,
    getPixelPositionOffset: s,
    children: l
  } = e, u = ge(Bt), c = ln(() => {
    var d = document.createElement("div");
    return d.style.position = "absolute", d;
  }, []), p = ln(() => g2e(c, r, t, n, s), [c, r, t, n]);
  return h(() => (i == null || i(p), p == null || p.setMap(u), () => {
    a == null || a(p), p == null || p.setMap(null);
  }), [u, p]), h(() => {
    c.style.zIndex = "".concat(o);
  }, [o, c]), wi.createPortal(l, c);
}
me(v2e);
class Vp extends pe {
  constructor(t) {
    super(t), Se(this, "state", {
      paneEl: null,
      containerStyle: {
        // set initial position
        position: "absolute"
      }
    }), Se(this, "updatePane", () => {
      var r = this.props.mapPaneName, o = this.overlayView.getPanes();
      $o(!!r, "OverlayView requires props.mapPaneName but got %s", r), o ? this.setState({
        paneEl: o[r]
      }) : this.setState({
        paneEl: null
      });
    }), Se(this, "onAdd", () => {
      var r, o;
      this.updatePane(), (r = (o = this.props).onLoad) === null || r === void 0 || r.call(o, this.overlayView);
    }), Se(this, "onPositionElement", () => {
      var r = this.overlayView.getProjection(), o = m2e({
        x: 0,
        y: 0
      }, this.containerRef.current ? pne(this.containerRef.current, this.props.getPixelPositionOffset) : {}), i = dne(r, o, this.props.bounds, this.props.position);
      if (!f2e(i, {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        left: this.state.containerStyle.left,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        top: this.state.containerStyle.top,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        width: this.state.containerStyle.width,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        height: this.state.containerStyle.height
      })) {
        var a, s, l, u;
        this.setState({
          containerStyle: {
            top: (a = i.top) !== null && a !== void 0 ? a : 0,
            left: (s = i.left) !== null && s !== void 0 ? s : 0,
            width: (l = i.width) !== null && l !== void 0 ? l : 0,
            height: (u = i.height) !== null && u !== void 0 ? u : 0,
            position: "absolute"
          }
        });
      }
    }), Se(this, "draw", () => {
      this.onPositionElement();
    }), Se(this, "onRemove", () => {
      var r, o;
      this.setState(() => ({
        paneEl: null
      })), (r = (o = this.props).onUnmount) === null || r === void 0 || r.call(o, this.overlayView);
    }), this.containerRef = so();
    var n = new google.maps.OverlayView();
    n.onAdd = this.onAdd, n.draw = this.draw, n.onRemove = this.onRemove, this.overlayView = n;
  }
  componentDidMount() {
    this.overlayView.setMap(this.context);
  }
  componentDidUpdate(t) {
    var n = sV(t.position), r = sV(this.props.position), o = aV(t.bounds), i = aV(this.props.bounds);
    (n !== r || o !== i) && this.overlayView.draw(), t.mapPaneName !== this.props.mapPaneName && this.updatePane();
  }
  componentWillUnmount() {
    this.overlayView.setMap(null);
  }
  render() {
    var t = this.state.paneEl;
    return t ? wi.createPortal(Qo.jsx("div", {
      ref: this.containerRef,
      style: this.state.containerStyle,
      children: at.only(this.props.children)
    }), t) : null;
  }
}
Se(Vp, "FLOAT_PANE", "floatPane");
Se(Vp, "MAP_PANE", "mapPane");
Se(Vp, "MARKER_LAYER", "markerLayer");
Se(Vp, "OVERLAY_LAYER", "overlayLayer");
Se(Vp, "OVERLAY_MOUSE_TARGET", "overlayMouseTarget");
Se(Vp, "contextType", Bt);
function y2e() {
}
function lV(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function uV(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? lV(Object(n), !0).forEach(function(r) {
      Se(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : lV(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var cV = {
  onDblClick: "dblclick",
  onClick: "click"
}, pV = {
  opacity(e, t) {
    e.setOpacity(t);
  }
};
function b2e(e) {
  var {
    url: t,
    bounds: n,
    options: r,
    visible: o
  } = e, i = ge(Bt), a = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east)), s = ln(() => new google.maps.GroundOverlay(t, a, r), []);
  return h(() => {
    s !== null && s.setMap(i);
  }, [i]), h(() => {
    typeof t < "u" && s !== null && (s.set("url", t), s.setMap(i));
  }, [s, t]), h(() => {
    typeof o < "u" && s !== null && s.setOpacity(o ? 1 : 0);
  }, [s, o]), h(() => {
    var l = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east));
    typeof n < "u" && s !== null && (s.set("bounds", l), s.setMap(i));
  }, [s, n]), null;
}
me(b2e);
class fne extends pe {
  constructor() {
    super(...arguments), Se(this, "registeredEvents", []), Se(this, "state", {
      groundOverlay: null
    }), Se(this, "setGroundOverlayCallback", () => {
      this.state.groundOverlay !== null && this.props.onLoad && this.props.onLoad(this.state.groundOverlay);
    });
  }
  componentDidMount() {
    $o(!!this.props.url || !!this.props.bounds, "For GroundOverlay, url and bounds are passed in to constructor and are immutable after instantiated. This is the behavior of Google Maps JavaScript API v3 ( See https://developers.google.com/maps/documentation/javascript/reference#GroundOverlay) Hence, use the corresponding two props provided by `react-google-maps-api`, url and bounds. In some cases, you'll need the GroundOverlay component to reflect the changes of url and bounds. You can leverage the React's key property to remount the component. Typically, just `key={url}` would serve your need. See https://github.com/tomchentw/react-google-maps/issues/655");
    var t = new google.maps.GroundOverlay(this.props.url, this.props.bounds, uV(uV({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = wn({
      updaterMap: pV,
      eventMap: cV,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        groundOverlay: t
      };
    }, this.setGroundOverlayCallback);
  }
  componentDidUpdate(t) {
    this.state.groundOverlay !== null && (_n(this.registeredEvents), this.registeredEvents = wn({
      updaterMap: pV,
      eventMap: cV,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.groundOverlay
    }));
  }
  componentWillUnmount() {
    this.state.groundOverlay && (this.props.onUnmount && this.props.onUnmount(this.state.groundOverlay), this.state.groundOverlay.setMap(null));
  }
  render() {
    return null;
  }
}
Se(fne, "defaultProps", {
  onLoad: y2e
});
Se(fne, "contextType", Bt);
function dV(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function mw(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? dV(Object(n), !0).forEach(function(r) {
      Se(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : dV(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var fV = {}, hV = {
  data(e, t) {
    e.setData(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function w2e(e) {
  var {
    data: t,
    onLoad: n,
    onUnmount: r,
    options: o
  } = e, i = ge(Bt), [a, s] = k(null);
  return h(() => {
    google.maps.visualization || $o(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} in useJsApiScript? %s', google.maps.visualization);
  }, []), h(() => {
    $o(!!t, "data property is required in HeatmapLayer %s", t);
  }, [t]), h(() => {
    a !== null && a.setMap(i);
  }, [i]), h(() => {
    o && a !== null && a.setOptions(o);
  }, [a, o]), h(() => {
    var l = new google.maps.visualization.HeatmapLayer(mw(mw({}, o), {}, {
      data: t,
      map: i
    }));
    return s(l), n && n(l), () => {
      a !== null && (r && r(a), a.setMap(null));
    };
  }, []), null;
}
me(w2e);
class C2e extends pe {
  constructor() {
    super(...arguments), Se(this, "registeredEvents", []), Se(this, "state", {
      heatmapLayer: null
    }), Se(this, "setHeatmapLayerCallback", () => {
      this.state.heatmapLayer !== null && this.props.onLoad && this.props.onLoad(this.state.heatmapLayer);
    });
  }
  componentDidMount() {
    $o(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} to <LoadScript />? %s', google.maps.visualization), $o(!!this.props.data, "data property is required in HeatmapLayer %s", this.props.data);
    var t = new google.maps.visualization.HeatmapLayer(mw(mw({}, this.props.options), {}, {
      data: this.props.data,
      map: this.context
    }));
    this.registeredEvents = wn({
      updaterMap: hV,
      eventMap: fV,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        heatmapLayer: t
      };
    }, this.setHeatmapLayerCallback);
  }
  componentDidUpdate(t) {
    _n(this.registeredEvents), this.registeredEvents = wn({
      updaterMap: hV,
      eventMap: fV,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.heatmapLayer
    });
  }
  componentWillUnmount() {
    this.state.heatmapLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.heatmapLayer), _n(this.registeredEvents), this.state.heatmapLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Se(C2e, "contextType", Bt);
var gV = {
  onCloseClick: "closeclick",
  onPanoChanged: "pano_changed",
  onPositionChanged: "position_changed",
  onPovChanged: "pov_changed",
  onResize: "resize",
  onStatusChanged: "status_changed",
  onVisibleChanged: "visible_changed",
  onZoomChanged: "zoom_changed"
}, mV = {
  register(e, t, n) {
    e.registerPanoProvider(t, n);
  },
  links(e, t) {
    e.setLinks(t);
  },
  motionTracking(e, t) {
    e.setMotionTracking(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  pano(e, t) {
    e.setPano(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  pov(e, t) {
    e.setPov(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zoom(e, t) {
    e.setZoom(t);
  }
};
class O2e extends pe {
  constructor() {
    super(...arguments), Se(this, "registeredEvents", []), Se(this, "state", {
      streetViewPanorama: null
    }), Se(this, "setStreetViewPanoramaCallback", () => {
      this.state.streetViewPanorama !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewPanorama);
    });
  }
  componentDidMount() {
    var t, n, r = (t = (n = this.context) === null || n === void 0 ? void 0 : n.getStreetView()) !== null && t !== void 0 ? t : null;
    this.registeredEvents = wn({
      updaterMap: mV,
      eventMap: gV,
      prevProps: {},
      nextProps: this.props,
      instance: r
    }), this.setState(() => ({
      streetViewPanorama: r
    }), this.setStreetViewPanoramaCallback);
  }
  componentDidUpdate(t) {
    this.state.streetViewPanorama !== null && (_n(this.registeredEvents), this.registeredEvents = wn({
      updaterMap: mV,
      eventMap: gV,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.streetViewPanorama
    }));
  }
  componentWillUnmount() {
    this.state.streetViewPanorama !== null && (this.props.onUnmount && this.props.onUnmount(this.state.streetViewPanorama), _n(this.registeredEvents), this.state.streetViewPanorama.setVisible(!1));
  }
  render() {
    return null;
  }
}
Se(O2e, "contextType", Bt);
class x2e extends pe {
  constructor() {
    super(...arguments), Se(this, "state", {
      streetViewService: null
    }), Se(this, "setStreetViewServiceCallback", () => {
      this.state.streetViewService !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewService);
    });
  }
  componentDidMount() {
    var t = new google.maps.StreetViewService();
    this.setState(function() {
      return {
        streetViewService: t
      };
    }, this.setStreetViewServiceCallback);
  }
  componentWillUnmount() {
    this.state.streetViewService !== null && this.props.onUnmount && this.props.onUnmount(this.state.streetViewService);
  }
  render() {
    return null;
  }
}
Se(x2e, "contextType", Bt);
var vV = {
  onDirectionsChanged: "directions_changed"
}, yV = {
  directions(e, t) {
    e.setDirections(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  panel(e, t) {
    e.setPanel(t);
  },
  routeIndex(e, t) {
    e.setRouteIndex(t);
  }
};
class E2e extends pe {
  constructor() {
    super(...arguments), Se(this, "registeredEvents", []), Se(this, "state", {
      directionsRenderer: null
    }), Se(this, "setDirectionsRendererCallback", () => {
      this.state.directionsRenderer !== null && (this.state.directionsRenderer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.directionsRenderer));
    });
  }
  componentDidMount() {
    var t = new google.maps.DirectionsRenderer(this.props.options);
    this.registeredEvents = wn({
      updaterMap: yV,
      eventMap: vV,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        directionsRenderer: t
      };
    }, this.setDirectionsRendererCallback);
  }
  componentDidUpdate(t) {
    this.state.directionsRenderer !== null && (_n(this.registeredEvents), this.registeredEvents = wn({
      updaterMap: yV,
      eventMap: vV,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.directionsRenderer
    }));
  }
  componentWillUnmount() {
    this.state.directionsRenderer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.directionsRenderer), _n(this.registeredEvents), this.state.directionsRenderer && this.state.directionsRenderer.setMap(null));
  }
  render() {
    return null;
  }
}
Se(E2e, "contextType", Bt);
var bV = {
  onPlacesChanged: "places_changed"
}, wV = {
  bounds(e, t) {
    e.setBounds(t);
  }
};
class k2e extends pe {
  constructor() {
    super(...arguments), Se(this, "registeredEvents", []), Se(this, "containerElement", so()), Se(this, "state", {
      searchBox: null
    }), Se(this, "setSearchBoxCallback", () => {
      this.state.searchBox !== null && this.props.onLoad && this.props.onLoad(this.state.searchBox);
    });
  }
  componentDidMount() {
    if ($o(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places), this.containerElement !== null && this.containerElement.current !== null) {
      var t = this.containerElement.current.querySelector("input");
      if (t !== null) {
        var n = new google.maps.places.SearchBox(t, this.props.options);
        this.registeredEvents = wn({
          updaterMap: wV,
          eventMap: bV,
          prevProps: {},
          nextProps: this.props,
          instance: n
        }), this.setState(function() {
          return {
            searchBox: n
          };
        }, this.setSearchBoxCallback);
      }
    }
  }
  componentDidUpdate(t) {
    this.state.searchBox !== null && (_n(this.registeredEvents), this.registeredEvents = wn({
      updaterMap: wV,
      eventMap: bV,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.searchBox
    }));
  }
  componentWillUnmount() {
    this.state.searchBox !== null && (this.props.onUnmount && this.props.onUnmount(this.state.searchBox), _n(this.registeredEvents));
  }
  render() {
    return Qo.jsx("div", {
      ref: this.containerElement,
      children: at.only(this.props.children)
    });
  }
}
Se(k2e, "contextType", Bt);
var CV = {
  onPlaceChanged: "place_changed"
}, OV = {
  bounds(e, t) {
    e.setBounds(t);
  },
  restrictions(e, t) {
    e.setComponentRestrictions(t);
  },
  fields(e, t) {
    e.setFields(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  types(e, t) {
    e.setTypes(t);
  }
};
class hne extends pe {
  constructor() {
    super(...arguments), Se(this, "registeredEvents", []), Se(this, "containerElement", so()), Se(this, "state", {
      autocomplete: null
    }), Se(this, "setAutocompleteCallback", () => {
      this.state.autocomplete !== null && this.props.onLoad && this.props.onLoad(this.state.autocomplete);
    });
  }
  componentDidMount() {
    var t;
    $o(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places);
    var n = (t = this.containerElement.current) === null || t === void 0 ? void 0 : t.querySelector("input");
    if (n) {
      var r = new google.maps.places.Autocomplete(n, this.props.options);
      this.registeredEvents = wn({
        updaterMap: OV,
        eventMap: CV,
        prevProps: {},
        nextProps: this.props,
        instance: r
      }), this.setState(() => ({
        autocomplete: r
      }), this.setAutocompleteCallback);
    }
  }
  componentDidUpdate(t) {
    _n(this.registeredEvents), this.registeredEvents = wn({
      updaterMap: OV,
      eventMap: CV,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.autocomplete
    });
  }
  componentWillUnmount() {
    this.state.autocomplete !== null && _n(this.registeredEvents);
  }
  render() {
    return Qo.jsx("div", {
      ref: this.containerElement,
      className: this.props.className,
      children: at.only(this.props.children)
    });
  }
}
Se(hne, "defaultProps", {
  className: ""
});
Se(hne, "contextType", Bt);
let L2e = { data: "" }, _2e = (e) => typeof window == "object" ? ((e ? e.querySelector("#_goober") : window._goober) || Object.assign((e || document.head).appendChild(document.createElement("style")), { innerHTML: " ", id: "_goober" })).firstChild : e || L2e, P2e = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g, S2e = /\/\*[^]*?\*\/|  +/g, xV = /\n+/g, Jl = (e, t) => {
  let n = "", r = "", o = "";
  for (let i in e) {
    let a = e[i];
    i[0] == "@" ? i[1] == "i" ? n = i + " " + a + ";" : r += i[1] == "f" ? Jl(a, i) : i + "{" + Jl(a, i[1] == "k" ? "" : t) + "}" : typeof a == "object" ? r += Jl(a, t ? t.replace(/([^,])+/g, (s) => i.replace(/([^,]*:\S+\([^)]*\))|([^,])+/g, (l) => /&/.test(l) ? l.replace(/&/g, s) : s ? s + " " + l : l)) : i) : a != null && (i = /^--/.test(i) ? i : i.replace(/[A-Z]/g, "-$&").toLowerCase(), o += Jl.p ? Jl.p(i, a) : i + ":" + a + ";");
  }
  return n + (t && o ? t + "{" + o + "}" : o) + r;
}, Ia = {}, gne = (e) => {
  if (typeof e == "object") {
    let t = "";
    for (let n in e) t += n + gne(e[n]);
    return t;
  }
  return e;
}, M2e = (e, t, n, r, o) => {
  let i = gne(e), a = Ia[i] || (Ia[i] = ((l) => {
    let u = 0, c = 11;
    for (; u < l.length; ) c = 101 * c + l.charCodeAt(u++) >>> 0;
    return "go" + c;
  })(i));
  if (!Ia[a]) {
    let l = i !== e ? e : ((u) => {
      let c, p, d = [{}];
      for (; c = P2e.exec(u.replace(S2e, "")); ) c[4] ? d.shift() : c[3] ? (p = c[3].replace(xV, " ").trim(), d.unshift(d[0][p] = d[0][p] || {})) : d[0][c[1]] = c[2].replace(xV, " ").trim();
      return d[0];
    })(e);
    Ia[a] = Jl(o ? { ["@keyframes " + a]: l } : l, n ? "" : "." + a);
  }
  let s = n && Ia.g ? Ia.g : null;
  return n && (Ia.g = Ia[a]), ((l, u, c, p) => {
    p ? u.data = u.data.replace(p, l) : u.data.indexOf(l) === -1 && (u.data = c ? l + u.data : u.data + l);
  })(Ia[a], t, r, s), a;
}, D2e = (e, t, n) => e.reduce((r, o, i) => {
  let a = t[i];
  if (a && a.call) {
    let s = a(n), l = s && s.props && s.props.className || /^go/.test(s) && s;
    a = l ? "." + l : s && typeof s == "object" ? s.props ? "" : Jl(s, "") : s === !1 ? "" : s;
  }
  return r + o + (a ?? "");
}, "");
function kO(e) {
  let t = this || {}, n = e.call ? e(t.p) : e;
  return M2e(n.unshift ? n.raw ? D2e(n, [].slice.call(arguments, 1), t.p) : n.reduce((r, o) => Object.assign(r, o && o.call ? o(t.p) : o), {}) : n, _2e(t.target), t.g, t.o, t.k);
}
let mne, rP, oP;
kO.bind({ g: 1 });
let Qa = kO.bind({ k: 1 });
function T2e(e, t, n, r) {
  Jl.p = t, mne = e, rP = n, oP = r;
}
function _u(e, t) {
  let n = this || {};
  return function() {
    let r = arguments;
    function o(i, a) {
      let s = Object.assign({}, i), l = s.className || o.className;
      n.p = Object.assign({ theme: rP && rP() }, s), n.o = / *go\d+/.test(l), s.className = kO.apply(n, r) + (l ? " " + l : "");
      let u = e;
      return e[0] && (u = s.as || e, delete s.as), oP && u[0] && oP(s), mne(u, s);
    }
    return o;
  };
}
var j2e = (e) => typeof e == "function", A2e = (e, t) => j2e(e) ? e(t) : e, R2e = /* @__PURE__ */ (() => {
  let e;
  return () => {
    if (e === void 0 && typeof window < "u") {
      let t = matchMedia("(prefers-reduced-motion: reduce)");
      e = !t || t.matches;
    }
    return e;
  };
})(), I2e = Qa`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`, N2e = Qa`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`, B2e = Qa`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`, F2e = _u("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${I2e} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${N2e} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${(e) => e.secondary || "#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${B2e} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`, z2e = Qa`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, U2e = _u("div")`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${(e) => e.secondary || "#e0e0e0"};
  border-right-color: ${(e) => e.primary || "#616161"};
  animation: ${z2e} 1s linear infinite;
`, H2e = Qa`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`, W2e = Qa`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`, $2e = _u("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${H2e} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${W2e} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${(e) => e.secondary || "#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`, V2e = _u("div")`
  position: absolute;
`, Z2e = _u("div")`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`, q2e = Qa`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`, G2e = _u("div")`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${q2e} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`, K2e = ({ toast: e }) => {
  let { icon: t, type: n, iconTheme: r } = e;
  return t !== void 0 ? typeof t == "string" ? Ne.createElement(G2e, null, t) : t : n === "blank" ? null : Ne.createElement(Z2e, null, Ne.createElement(U2e, { ...r }), n !== "loading" && Ne.createElement(V2e, null, n === "error" ? Ne.createElement(F2e, { ...r }) : Ne.createElement($2e, { ...r })));
}, X2e = (e) => `
0% {transform: translate3d(0,${e * -200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`, Y2e = (e) => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${e * -150}%,-1px) scale(.6); opacity:0;}
`, J2e = "0%{opacity:0;} 100%{opacity:1;}", Q2e = "0%{opacity:1;} 100%{opacity:0;}", eUe = _u("div")`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`, tUe = _u("div")`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`, nUe = (e, t) => {
  let n = e.includes("top") ? 1 : -1, [r, o] = R2e() ? [J2e, Q2e] : [X2e(n), Y2e(n)];
  return { animation: t ? `${Qa(r)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards` : `${Qa(o)} 0.4s forwards cubic-bezier(.06,.71,.55,1)` };
};
Ne.memo(({ toast: e, position: t, style: n, children: r }) => {
  let o = e.height ? nUe(e.position || t || "top-center", e.visible) : { opacity: 0 }, i = Ne.createElement(K2e, { toast: e }), a = Ne.createElement(tUe, { ...e.ariaProps }, A2e(e.message, e));
  return Ne.createElement(eUe, { className: e.className, style: { ...o, ...n, ...e.style } }, typeof r == "function" ? r({ icon: i, message: a }) : Ne.createElement(Ne.Fragment, null, i, a));
});
T2e(Ne.createElement);
kO`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`;
$e({});
function rUe(e) {
  return e && e.replace(/[^0-9]/g, "");
}
const oUe = {
  CNPJ: "99.999.999/9999-99"
};
rUe(oUe.CNPJ).length;
Cr((e, t) => /* @__PURE__ */ Jo.jsx("input", { ref: t, ...e }));
function vne(e) {
  return e && e.replace(/[^0-9]/g, "");
}
const yne = {
  EIGTH: "(99) 9999-9999",
  NINE: "(99) 99999-9999"
};
function iUe(e, t) {
  let n = "", r = 0;
  for (let o = 0; o < t.length; o++)
    if (t[o] === "9")
      if (r < e.length)
        n += e[r], r++;
      else
        break;
    else if (r < e.length)
      n += t[o];
    else
      break;
  return n;
}
function sUe(e) {
  return e.length > 10 ? "NINE" : "EIGTH";
}
const aUe = vne(yne.NINE).length, lUe = Cr((e, t) => /* @__PURE__ */ Jo.jsx("input", { ref: t, ...e }));
Cr(
  (e, t) => {
    const { onFocus: n, onBlur: r, size: o, onChange: i, value: a, currentCountry: s, disabled: l } = e, [u, c] = k(!1);
    h(() => {
      u ? i(s.mask) : c(!0);
    }, [s]);
    const p = `phoneInputMask ${o}`;
    function d(g) {
      let f = vne(g.target.value);
      const m = sUe(f);
      f.length > aUe || (f = iUe(f, yne[m]), g.target.value = f, i(f));
    }
    return s.code === "+55" ? /* @__PURE__ */ Jo.jsx(
      "input",
      {
        value: a,
        onChange: d,
        className: p,
        onFocus: n,
        onBlur: r,
        disabled: l,
        ref: t
      }
    ) : /* @__PURE__ */ Jo.jsx(
      ol,
      {
        value: a,
        onChange: (g) => i(g.target.value),
        className: p,
        component: lUe,
        onFocus: n,
        onBlur: r,
        disabled: l,
        mask: s.mask,
        showMask: !0,
        replacement: { _: /\d/ },
        ref: t
      }
    );
  }
);
$e({});
var cl = {};
Object.defineProperty(cl, "__esModule", {
  value: !0
});
var uUe = typeof window < "u" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform), bk = {
  alt: "altKey",
  control: "ctrlKey",
  meta: "metaKey",
  shift: "shiftKey"
}, bne = {
  add: "+",
  break: "pause",
  cmd: "meta",
  command: "meta",
  ctl: "control",
  ctrl: "control",
  del: "delete",
  down: "arrowdown",
  esc: "escape",
  ins: "insert",
  left: "arrowleft",
  mod: uUe ? "meta" : "control",
  opt: "alt",
  option: "alt",
  return: "enter",
  right: "arrowright",
  space: " ",
  spacebar: " ",
  up: "arrowup",
  win: "meta",
  windows: "meta"
}, wT = {
  backspace: 8,
  tab: 9,
  enter: 13,
  shift: 16,
  control: 17,
  alt: 18,
  pause: 19,
  capslock: 20,
  escape: 27,
  " ": 32,
  pageup: 33,
  pagedown: 34,
  end: 35,
  home: 36,
  arrowleft: 37,
  arrowup: 38,
  arrowright: 39,
  arrowdown: 40,
  insert: 45,
  delete: 46,
  meta: 91,
  numlock: 144,
  scrolllock: 145,
  ";": 186,
  "=": 187,
  ",": 188,
  "-": 189,
  ".": 190,
  "/": 191,
  "`": 192,
  "[": 219,
  "\\": 220,
  "]": 221,
  "'": 222
};
for (var Mv = 1; Mv < 20; Mv++)
  wT["f" + Mv] = 111 + Mv;
function LO(e, t, n) {
  t && !("byKey" in t) && (n = t, t = null), Array.isArray(e) || (e = [e]);
  var r = e.map(function(a) {
    return wne(a, t);
  }), o = function(a) {
    return r.some(function(s) {
      return Cne(s, a);
    });
  }, i = n == null ? o : o(n);
  return i;
}
function cUe(e, t) {
  return LO(e, t);
}
function pUe(e, t) {
  return LO(e, { byKey: !0 }, t);
}
function wne(e, t) {
  var n = t && t.byKey, r = {};
  e = e.replace("++", "+add");
  var o = e.split("+"), i = o.length;
  for (var a in bk)
    r[bk[a]] = !1;
  var s = !0, l = !1, u = void 0;
  try {
    for (var c = o[Symbol.iterator](), p; !(s = (p = c.next()).done); s = !0) {
      var d = p.value, g = d.endsWith("?") && d.length > 1;
      g && (d = d.slice(0, -1));
      var f = CT(d), m = bk[f];
      if (d.length > 1 && !m && !bne[d] && !wT[f])
        throw new TypeError('Unknown modifier: "' + d + '"');
      (i === 1 || !m) && (n ? r.key = f : r.which = One(d)), m && (r[m] = g ? null : !0);
    }
  } catch (b) {
    l = !0, u = b;
  } finally {
    try {
      !s && c.return && c.return();
    } finally {
      if (l)
        throw u;
    }
  }
  return r;
}
function Cne(e, t) {
  for (var n in e) {
    var r = e[n], o = void 0;
    if (r != null && (n === "key" && t.key != null ? o = t.key.toLowerCase() : n === "which" ? o = r === 91 && t.which === 93 ? 91 : t.which : o = t[n], !(o == null && r === !1) && o !== r))
      return !1;
  }
  return !0;
}
function One(e) {
  e = CT(e);
  var t = wT[e] || e.toUpperCase().charCodeAt(0);
  return t;
}
function CT(e) {
  return e = e.toLowerCase(), e = bne[e] || e, e;
}
cl.default = LO;
var wk = cl.isHotkey = LO;
cl.isCodeHotkey = cUe;
cl.isKeyHotkey = pUe;
cl.parseHotkey = wne;
cl.compareHotkey = Cne;
cl.toKeyCode = One;
cl.toKeyName = CT;
var dUe = typeof mr == "object" && mr && mr.Object === Object && mr, fUe = dUe, hUe = fUe, gUe = typeof self == "object" && self && self.Object === Object && self, mUe = hUe || gUe || Function("return this")(), vUe = mUe, yUe = vUe, bUe = yUe.Symbol, xne = bUe, EV = xne;
EV && EV.toStringTag;
var kV = xne;
kV && kV.toStringTag;
var LV;
(function(e) {
  e.BORDER_BOX = "border-box", e.CONTENT_BOX = "content-box", e.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(LV || (LV = {}));
var OT = function(e) {
  return Object.freeze(e);
}, wUe = /* @__PURE__ */ function() {
  function e(t, n) {
    this.inlineSize = t, this.blockSize = n, OT(this);
  }
  return e;
}(), CUe = function() {
  function e(t, n, r, o) {
    return this.x = t, this.y = n, this.width = r, this.height = o, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, OT(this);
  }
  return e.prototype.toJSON = function() {
    var t = this, n = t.x, r = t.y, o = t.top, i = t.right, a = t.bottom, s = t.left, l = t.width, u = t.height;
    return { x: n, y: r, top: o, right: i, bottom: a, left: s, width: l, height: u };
  }, e.fromRect = function(t) {
    return new e(t.x, t.y, t.width, t.height);
  }, e;
}(), _V = typeof window < "u" ? window : {};
/msie|trident/i.test(_V.navigator && _V.navigator.userAgent);
var Ck = function(e, t, n) {
  return e === void 0 && (e = 0), t === void 0 && (t = 0), n === void 0 && (n = !1), new wUe((n ? t : e) || 0, (n ? e : t) || 0);
};
OT({
  devicePixelContentBoxSize: Ck(),
  borderBoxSize: Ck(),
  contentBoxSize: Ck(),
  contentRect: new CUe(0, 0, 0, 0)
});
function Rh(e) {
  "@babel/helpers - typeof";
  return Rh = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Rh(e);
}
function OUe(e, t) {
  if (Rh(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (Rh(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function xUe(e) {
  var t = OUe(e, "string");
  return Rh(t) === "symbol" ? t : String(t);
}
function Mf(e, t, n) {
  return t = xUe(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
var EUe = /* @__PURE__ */ $e(null), Ok, xk;
parseInt(be.version.split(".")[0], 10);
var PV = typeof navigator < "u" && /Mac OS X/.test(navigator.userAgent), Ek = typeof navigator < "u" && /Android/.test(navigator.userAgent), Dv = typeof navigator < "u" && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent), kUe = typeof navigator < "u" && /Chrome/i.test(navigator.userAgent);
typeof navigator < "u" && /Safari/.test(navigator.userAgent) && /Version\/(\d+)/.test(navigator.userAgent) && (Ok = navigator.userAgent.match(/Version\/(\d+)/)) !== null && Ok !== void 0 && Ok[1] && parseInt((xk = navigator.userAgent.match(/Version\/(\d+)/)) === null || xk === void 0 ? void 0 : xk[1], 10) < 17;
var LUe = /* @__PURE__ */ new WeakMap(), _Ue = /* @__PURE__ */ new WeakMap(), PUe = /* @__PURE__ */ new WeakMap(), SUe = /* @__PURE__ */ new WeakMap(), MUe = /* @__PURE__ */ new WeakMap(), SV = /* @__PURE__ */ new WeakMap(), DUe = /* @__PURE__ */ new WeakMap(), MV = /* @__PURE__ */ new WeakMap(), Tv = /* @__PURE__ */ new WeakMap(), TUe = /* @__PURE__ */ new WeakMap(), jUe = /* @__PURE__ */ new WeakMap(), AUe = /* @__PURE__ */ new WeakMap(), Ene = globalThis.Node, RUe = globalThis.Text, kne = (e) => e && e.ownerDocument && e.ownerDocument.defaultView || null, IUe = (e) => vw(e) && e.nodeType === 8, fa = (e) => vw(e) && e.nodeType === 1, vw = (e) => {
  var t = kne(e);
  return !!t && e instanceof t.Node;
}, DV = (e) => {
  var t = e && e.anchorNode && kne(e.anchorNode);
  return !!t && e instanceof t.Selection;
}, NUe = (e) => {
  var [t, n] = e;
  if (fa(t) && t.childNodes.length) {
    var r = n === t.childNodes.length, o = r ? n - 1 : n;
    for ([t, o] = Lne(t, o, r ? "backward" : "forward"), r = o < n; fa(t) && t.childNodes.length; ) {
      var i = r ? t.childNodes.length - 1 : 0;
      t = FUe(t, i, r ? "backward" : "forward");
    }
    n = r && t.textContent != null ? t.textContent.length : 0;
  }
  return [t, n];
}, BUe = (e) => {
  for (var t = e && e.parentNode; t; ) {
    if (t.toString() === "[object ShadowRoot]")
      return !0;
    t = t.parentNode;
  }
  return !1;
}, Lne = (e, t, n) => {
  for (var {
    childNodes: r
  } = e, o = r[t], i = t, a = !1, s = !1; (IUe(o) || fa(o) && o.childNodes.length === 0 || fa(o) && o.getAttribute("contenteditable") === "false") && !(a && s); ) {
    if (i >= r.length) {
      a = !0, i = t - 1, n = "backward";
      continue;
    }
    if (i < 0) {
      s = !0, i = t + 1, n = "forward";
      continue;
    }
    o = r[i], t = i, i += n === "forward" ? 1 : -1;
  }
  return [o, t];
}, FUe = (e, t, n) => {
  var [r] = Lne(e, t, n);
  return r;
}, TV = (e) => e.getSelection != null ? e.getSelection() : document.getSelection(), _ne = (e, t, n) => {
  var {
    target: r
  } = t;
  if (fa(r) && r.matches('[contentEditable="false"]'))
    return !1;
  var {
    document: o
  } = hn.getWindow(e);
  if (o.contains(r))
    return hn.hasDOMNode(e, r, {
      editable: !0
    });
  var i = n.find((a) => {
    var {
      addedNodes: s,
      removedNodes: l
    } = a;
    for (var u of s)
      if (u === r || u.contains(r))
        return !0;
    for (var c of l)
      if (c === r || c.contains(r))
        return !0;
  });
  return !i || i === t ? !1 : _ne(e, i, n);
}, jV = (e, t) => !!(e.compareDocumentPosition(t) & Ene.DOCUMENT_POSITION_PRECEDING), zUe = (e, t) => !!(e.compareDocumentPosition(t) & Ene.DOCUMENT_POSITION_FOLLOWING), UUe = 0;
class HUe {
  constructor() {
    Mf(this, "id", void 0), this.id = "".concat(UUe++);
  }
}
var hn = {
  androidPendingDiffs: (e) => AUe.get(e),
  androidScheduleFlush: (e) => {
    var t;
    (t = jUe.get(e)) === null || t === void 0 || t();
  },
  blur: (e) => {
    var t = hn.toDOMNode(e, e), n = hn.findDocumentOrShadowRoot(e);
    Tv.set(e, !1), n.activeElement === t && t.blur();
  },
  deselect: (e) => {
    var {
      selection: t
    } = e, n = hn.findDocumentOrShadowRoot(e), r = TV(n);
    r && r.rangeCount > 0 && r.removeAllRanges(), t && ib.deselect(e);
  },
  findDocumentOrShadowRoot: (e) => {
    var t = hn.toDOMNode(e, e), n = t.getRootNode();
    return n instanceof Document || n instanceof ShadowRoot ? n : t.ownerDocument;
  },
  findEventRange: (e, t) => {
    "nativeEvent" in t && (t = t.nativeEvent);
    var {
      clientX: n,
      clientY: r,
      target: o
    } = t;
    if (n == null || r == null)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var i = hn.toSlateNode(e, t.target), a = hn.findPath(e, i);
    if (Wa.isElement(i) && lr.isVoid(e, i)) {
      var s = o.getBoundingClientRect(), l = e.isInline(i) ? n - s.left < s.left + s.width - n : r - s.top < s.top + s.height - r, u = lr.point(e, a, {
        edge: l ? "start" : "end"
      }), c = l ? lr.before(e, u) : lr.after(e, u);
      if (c) {
        var p = lr.range(e, c);
        return p;
      }
    }
    var d, {
      document: g
    } = hn.getWindow(e);
    if (g.caretRangeFromPoint)
      d = g.caretRangeFromPoint(n, r);
    else {
      var f = g.caretPositionFromPoint(n, r);
      f && (d = g.createRange(), d.setStart(f.offsetNode, f.offset), d.setEnd(f.offsetNode, f.offset));
    }
    if (!d)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var m = hn.toSlateRange(e, d, {
      exactMatch: !1,
      suppressThrow: !1
    });
    return m;
  },
  findKey: (e, t) => {
    var n = SV.get(t);
    return n || (n = new HUe(), SV.set(t, n)), n;
  },
  findPath: (e, t) => {
    for (var n = [], r = t; ; ) {
      var o = _Ue.get(r);
      if (o == null) {
        if (lr.isEditor(r))
          return n;
        break;
      }
      var i = LUe.get(r);
      if (i == null)
        break;
      n.unshift(i), r = o;
    }
    throw new Error("Unable to find the path for Slate node: ".concat(is.stringify(t)));
  },
  focus: function(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      retries: 5
    };
    if (!Tv.get(e)) {
      if (t.retries <= 0)
        throw new Error("Could not set focus, editor seems stuck with pending operations");
      if (e.operations.length > 0) {
        setTimeout(() => {
          hn.focus(e, {
            retries: t.retries - 1
          });
        }, 10);
        return;
      }
      var n = hn.toDOMNode(e, e), r = hn.findDocumentOrShadowRoot(e);
      if (r.activeElement !== n) {
        if (e.selection && r instanceof Document) {
          var o = TV(r), i = hn.toDOMRange(e, e.selection);
          o == null || o.removeAllRanges(), o == null || o.addRange(i);
        }
        e.selection || ib.select(e, lr.start(e, [])), Tv.set(e, !0), n.focus({
          preventScroll: !0
        });
      }
    }
  },
  getWindow: (e) => {
    var t = PUe.get(e);
    if (!t)
      throw new Error("Unable to find a host window element for this editor");
    return t;
  },
  hasDOMNode: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      editable: r = !1
    } = n, o = hn.toDOMNode(e, e), i;
    try {
      i = fa(t) ? t : t.parentElement;
    } catch (a) {
      if (a instanceof Error && !a.message.includes('Permission denied to access property "nodeType"'))
        throw a;
    }
    return i ? i.closest("[data-slate-editor]") === o && (!r || i.isContentEditable ? !0 : typeof i.isContentEditable == "boolean" && // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined
    // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable="false"(readOnly)
    i.closest('[contenteditable="false"]') === o || !!i.getAttribute("data-slate-zero-width")) : !1;
  },
  hasEditableTarget: (e, t) => vw(t) && hn.hasDOMNode(e, t, {
    editable: !0
  }),
  hasRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t;
    return lr.hasPath(e, n.path) && lr.hasPath(e, r.path);
  },
  hasSelectableTarget: (e, t) => hn.hasEditableTarget(e, t) || hn.isTargetInsideNonReadonlyVoid(e, t),
  hasTarget: (e, t) => vw(t) && hn.hasDOMNode(e, t),
  insertData: (e, t) => {
    e.insertData(t);
  },
  insertFragmentData: (e, t) => e.insertFragmentData(t),
  insertTextData: (e, t) => e.insertTextData(t),
  isComposing: (e) => !!TUe.get(e),
  isFocused: (e) => !!Tv.get(e),
  isReadOnly: (e) => !!MV.get(e),
  isTargetInsideNonReadonlyVoid: (e, t) => {
    if (MV.get(e)) return !1;
    var n = hn.hasTarget(e, t) && hn.toSlateNode(e, t);
    return Wa.isElement(n) && lr.isVoid(e, n);
  },
  setFragmentData: (e, t, n) => e.setFragmentData(t, n),
  toDOMNode: (e, t) => {
    var n = DUe.get(e), r = lr.isEditor(t) ? SUe.get(e) : n == null ? void 0 : n.get(hn.findKey(e, t));
    if (!r)
      throw new Error("Cannot resolve a DOM node from Slate node: ".concat(is.stringify(t)));
    return r;
  },
  toDOMPoint: (e, t) => {
    var [n] = lr.node(e, t.path), r = hn.toDOMNode(e, n), o;
    lr.void(e, {
      at: t
    }) && (t = {
      path: t.path,
      offset: 0
    });
    for (var i = "[data-slate-string], [data-slate-zero-width]", a = Array.from(r.querySelectorAll(i)), s = 0, l = 0; l < a.length; l++) {
      var u = a[l], c = u.childNodes[0];
      if (!(c == null || c.textContent == null)) {
        var {
          length: p
        } = c.textContent, d = u.getAttribute("data-slate-length"), g = d == null ? p : parseInt(d, 10), f = s + g, m = a[l + 1];
        if (t.offset === f && m !== null && m !== void 0 && m.hasAttribute("data-slate-mark-placeholder")) {
          var b, E = m.childNodes[0];
          o = [
            // COMPAT: If we don't explicity set the dom point to be on the actual
            // dom text element, chrome will put the selection behind the actual dom
            // text element, causing domRange.getBoundingClientRect() calls on a collapsed
            // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)
            // which will cause issues when scrolling to it.
            E instanceof RUe ? E : m,
            (b = m.textContent) !== null && b !== void 0 && b.startsWith("\uFEFF") ? 1 : 0
          ];
          break;
        }
        if (t.offset <= f) {
          var w = Math.min(p, Math.max(0, t.offset - s));
          o = [c, w];
          break;
        }
        s = f;
      }
    }
    if (!o)
      throw new Error("Cannot resolve a DOM point from Slate point: ".concat(is.stringify(t)));
    return o;
  },
  toDOMRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t, o = qt.isBackward(t), i = hn.toDOMPoint(e, n), a = qt.isCollapsed(t) ? i : hn.toDOMPoint(e, r), s = hn.getWindow(e), l = s.document.createRange(), [u, c] = o ? a : i, [p, d] = o ? i : a, g = fa(u) ? u : u.parentElement, f = !!g.getAttribute("data-slate-zero-width"), m = fa(p) ? p : p.parentElement, b = !!m.getAttribute("data-slate-zero-width");
    return l.setStart(u, f ? 1 : c), l.setEnd(p, b ? 1 : d), l;
  },
  toSlateNode: (e, t) => {
    var n = fa(t) ? t : t.parentElement;
    n && !n.hasAttribute("data-slate-node") && (n = n.closest("[data-slate-node]"));
    var r = n ? MUe.get(n) : null;
    if (!r)
      throw new Error("Cannot resolve a Slate node from DOM node: ".concat(n));
    return r;
  },
  toSlatePoint: (e, t, n) => {
    var {
      exactMatch: r,
      suppressThrow: o,
      searchDirection: i = "backward"
    } = n, [a, s] = r ? t : NUe(t), l = a.parentNode, u = null, c = 0;
    if (l) {
      var p, d, g = hn.toDOMNode(e, e), f = l.closest('[data-slate-void="true"]'), m = f && g.contains(f) ? f : null, b = l.closest('[contenteditable="false"]'), E = b && g.contains(b) ? b : null, w = l.closest("[data-slate-leaf]"), M = null;
      if (w) {
        if (u = w.closest('[data-slate-node="text"]'), u) {
          var x = hn.getWindow(e), v = x.document.createRange();
          v.setStart(u, 0), v.setEnd(a, s);
          var C = v.cloneContents(), P = [...Array.prototype.slice.call(C.querySelectorAll("[data-slate-zero-width]")), ...Array.prototype.slice.call(C.querySelectorAll("[contenteditable=false]"))];
          P.forEach((S) => {
            if (Ek && !r && S.hasAttribute("data-slate-zero-width") && S.textContent.length > 0 && S.textContext !== "\uFEFF") {
              S.textContent.startsWith("\uFEFF") && (S.textContent = S.textContent.slice(1));
              return;
            }
            S.parentNode.removeChild(S);
          }), c = C.textContent.length, M = u;
        }
      } else if (m) {
        for (var F = m.querySelectorAll("[data-slate-leaf]"), L = 0; L < F.length; L++) {
          var B = F[L];
          if (hn.hasDOMNode(e, B)) {
            w = B;
            break;
          }
        }
        w ? (u = w.closest('[data-slate-node="text"]'), M = w, c = M.textContent.length, M.querySelectorAll("[data-slate-zero-width]").forEach((S) => {
          c -= S.textContent.length;
        })) : c = 1;
      } else if (E) {
        var N = (S) => S ? S.querySelectorAll(
          // Exclude leaf nodes in nested editors
          "[data-slate-leaf]:not(:scope [data-slate-editor] [data-slate-leaf])"
        ) : [], $ = E.closest('[data-slate-node="element"]');
        if (i === "forward") {
          var V, H = [...N($), ...N($ == null ? void 0 : $.nextElementSibling)];
          w = (V = H.find((S) => zUe(E, S))) !== null && V !== void 0 ? V : null;
        } else {
          var Z, K = [...N($ == null ? void 0 : $.previousElementSibling), ...N($)];
          w = (Z = K.findLast((S) => jV(E, S))) !== null && Z !== void 0 ? Z : null;
        }
        w && (u = w.closest('[data-slate-node="text"]'), M = w, i === "forward" ? c = 0 : (c = M.textContent.length, M.querySelectorAll("[data-slate-zero-width]").forEach((S) => {
          c -= S.textContent.length;
        })));
      }
      M && c === M.textContent.length && // COMPAT: Android IMEs might remove the zero width space while composing,
      // and we don't add it for line-breaks.
      Ek && M.getAttribute("data-slate-zero-width") === "z" && (p = M.textContent) !== null && p !== void 0 && p.startsWith("\uFEFF") && // COMPAT: If the parent node is a Slate zero-width space, editor is
      // because the text node should have no characters. However, during IME
      // composition the ASCII characters will be prepended to the zero-width
      // space, so subtract 1 from the offset to account for the zero-width
      // space character.
      (l.hasAttribute("data-slate-zero-width") || // COMPAT: In Firefox, `range.cloneContents()` returns an extra trailing '\n'
      // when the document ends with a new-line character. This results in the offset
      // length being off by one, so we need to subtract one to account for this.
      Dv && (d = M.textContent) !== null && d !== void 0 && d.endsWith(`

`)) && c--;
    }
    if (Ek && !u && !r) {
      var Y = l.hasAttribute("data-slate-node") ? l : l.closest("[data-slate-node]");
      if (Y && hn.hasDOMNode(e, Y, {
        editable: !0
      })) {
        var Q = hn.toSlateNode(e, Y), {
          path: J,
          offset: _
        } = lr.start(e, hn.findPath(e, Q));
        return Y.querySelector("[data-slate-leaf]") || (_ = s), {
          path: J,
          offset: _
        };
      }
    }
    if (!u) {
      if (o)
        return null;
      throw new Error("Cannot resolve a Slate point from DOM point: ".concat(t));
    }
    var D = hn.toSlateNode(e, u), z = hn.findPath(e, D);
    return {
      path: z,
      offset: c
    };
  },
  toSlateRange: (e, t, n) => {
    var r, {
      exactMatch: o,
      suppressThrow: i
    } = n, a = DV(t) ? t.anchorNode : t.startContainer, s, l, u, c, p;
    if (a)
      if (DV(t)) {
        if (Dv && t.rangeCount > 1) {
          u = t.focusNode;
          var d = t.getRangeAt(0), g = t.getRangeAt(t.rangeCount - 1);
          if (u instanceof HTMLTableRowElement && d.startContainer instanceof HTMLTableRowElement && g.startContainer instanceof HTMLTableRowElement) {
            let C = function(P) {
              return P.childElementCount > 0 ? C(P.children[0]) : P;
            };
            var f = d.startContainer, m = g.startContainer, b = C(f.children[d.startOffset]), E = C(m.children[g.startOffset]);
            c = 0, E.childNodes.length > 0 ? s = E.childNodes[0] : s = E, b.childNodes.length > 0 ? u = b.childNodes[0] : u = b, E instanceof HTMLElement ? l = E.innerHTML.length : l = 0;
          } else
            d.startContainer === u ? (s = g.endContainer, l = g.endOffset, c = d.startOffset) : (s = d.startContainer, l = d.endOffset, c = g.startOffset);
        } else
          s = t.anchorNode, l = t.anchorOffset, u = t.focusNode, c = t.focusOffset;
        kUe && BUe(s) || Dv ? p = t.anchorNode === t.focusNode && t.anchorOffset === t.focusOffset : p = t.isCollapsed;
      } else
        s = t.startContainer, l = t.startOffset, u = t.endContainer, c = t.endOffset, p = t.collapsed;
    if (s == null || u == null || l == null || c == null)
      throw new Error("Cannot resolve a Slate range from DOM range: ".concat(t));
    Dv && (r = u.textContent) !== null && r !== void 0 && r.endsWith(`

`) && c === u.textContent.length && c--;
    var w = hn.toSlatePoint(e, [s, l], {
      exactMatch: o,
      suppressThrow: i
    });
    if (!w)
      return null;
    var M = jV(s, u) || s === u && c < l, x = p ? w : hn.toSlatePoint(e, [u, c], {
      exactMatch: o,
      suppressThrow: i,
      searchDirection: M ? "forward" : "backward"
    });
    if (!x)
      return null;
    var v = {
      anchor: w,
      focus: x
    };
    return qt.isExpanded(v) && qt.isForward(v) && fa(u) && lr.void(e, {
      at: v.focus,
      mode: "highest"
    }) && (v = lr.unhangRange(e, v, {
      voids: !0
    })), v;
  }
}, WUe = {
  bold: "mod+b",
  compose: ["down", "left", "right", "up", "backspace", "enter"],
  moveBackward: "left",
  moveForward: "right",
  moveWordBackward: "ctrl+left",
  moveWordForward: "ctrl+right",
  deleteBackward: "shift?+backspace",
  deleteForward: "shift?+delete",
  extendBackward: "shift+left",
  extendForward: "shift+right",
  italic: "mod+i",
  insertSoftBreak: "shift+enter",
  splitBlock: "enter",
  undo: "mod+z"
}, $Ue = {
  moveLineBackward: "opt+up",
  moveLineForward: "opt+down",
  moveWordBackward: "opt+left",
  moveWordForward: "opt+right",
  deleteBackward: ["ctrl+backspace", "ctrl+h"],
  deleteForward: ["ctrl+delete", "ctrl+d"],
  deleteLineBackward: "cmd+shift?+backspace",
  deleteLineForward: ["cmd+shift?+delete", "ctrl+k"],
  deleteWordBackward: "opt+shift?+backspace",
  deleteWordForward: "opt+shift?+delete",
  extendLineBackward: "opt+shift+up",
  extendLineForward: "opt+shift+down",
  redo: "cmd+shift+z",
  transposeCharacter: "ctrl+t"
}, VUe = {
  deleteWordBackward: "ctrl+shift?+backspace",
  deleteWordForward: "ctrl+shift?+delete",
  redo: ["ctrl+y", "ctrl+shift+z"]
}, Jr = (e) => {
  var t = WUe[e], n = $Ue[e], r = VUe[e], o = t && wk(t), i = n && wk(n), a = r && wk(r);
  return (s) => !!(o && o(s) || PV && i && i(s) || !PV && a && a(s));
};
Jr("bold"), Jr("compose"), Jr("moveBackward"), Jr("moveForward"), Jr("deleteBackward"), Jr("deleteForward"), Jr("deleteLineBackward"), Jr("deleteLineForward"), Jr("deleteWordBackward"), Jr("deleteWordForward"), Jr("extendBackward"), Jr("extendForward"), Jr("extendLineBackward"), Jr("extendLineForward"), Jr("italic"), Jr("moveLineBackward"), Jr("moveLineForward"), Jr("moveWordBackward"), Jr("moveWordForward"), Jr("redo"), Jr("insertSoftBreak"), Jr("splitBlock"), Jr("transposeCharacter"), Jr("undo");
var ZUe = (e, t) => {
  var n = [], r = () => {
    n = [];
  }, o = (a) => {
    if (t.current) {
      var s = a.filter((l) => _ne(e, l, a));
      n.push(...s);
    }
  };
  function i() {
    n.length > 0 && (n.reverse().forEach((a) => {
      a.type !== "characterData" && (a.removedNodes.forEach((s) => {
        a.target.insertBefore(s, a.nextSibling);
      }), a.addedNodes.forEach((s) => {
        a.target.removeChild(s);
      }));
    }), r());
  }
  return {
    registerMutations: o,
    restoreDOM: i,
    clear: r
  };
}, qUe = {
  subtree: !0,
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0
};
class GUe extends au {
  constructor() {
    super(...arguments), Mf(this, "context", null), Mf(this, "manager", null), Mf(this, "mutationObserver", null);
  }
  observe() {
    var t, {
      node: n
    } = this.props;
    if (!n.current)
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    (t = this.mutationObserver) === null || t === void 0 || t.observe(n.current, qUe);
  }
  componentDidMount() {
    var {
      receivedUserInput: t
    } = this.props, n = this.context;
    this.manager = ZUe(n, t), this.mutationObserver = new MutationObserver(this.manager.registerMutations), this.observe();
  }
  getSnapshotBeforeUpdate() {
    var t, n, r, o = (t = this.mutationObserver) === null || t === void 0 ? void 0 : t.takeRecords();
    if (o != null && o.length) {
      var i;
      (i = this.manager) === null || i === void 0 || i.registerMutations(o);
    }
    return (n = this.mutationObserver) === null || n === void 0 || n.disconnect(), (r = this.manager) === null || r === void 0 || r.restoreDOM(), null;
  }
  componentDidUpdate() {
    var t;
    (t = this.manager) === null || t === void 0 || t.clear(), this.observe();
  }
  componentWillUnmount() {
    var t;
    (t = this.mutationObserver) === null || t === void 0 || t.disconnect();
  }
  render() {
    return this.props.children;
  }
}
Mf(GUe, "contextType", EUe);
$e({});
$e({});
$e({});
var No = {}, xT = {}, Cg = {}, Og = {}, Pne = "Expected a function", AV = NaN, KUe = "[object Symbol]", XUe = /^\s+|\s+$/g, YUe = /^[-+]0x[0-9a-f]+$/i, JUe = /^0b[01]+$/i, QUe = /^0o[0-7]+$/i, eHe = parseInt, tHe = typeof mr == "object" && mr && mr.Object === Object && mr, nHe = typeof self == "object" && self && self.Object === Object && self, rHe = tHe || nHe || Function("return this")(), oHe = Object.prototype, iHe = oHe.toString, sHe = Math.max, aHe = Math.min, kk = function() {
  return rHe.Date.now();
};
function lHe(e, t, n) {
  var r, o, i, a, s, l, u = 0, c = !1, p = !1, d = !0;
  if (typeof e != "function")
    throw new TypeError(Pne);
  t = RV(t) || 0, yw(n) && (c = !!n.leading, p = "maxWait" in n, i = p ? sHe(RV(n.maxWait) || 0, t) : i, d = "trailing" in n ? !!n.trailing : d);
  function g(C) {
    var P = r, F = o;
    return r = o = void 0, u = C, a = e.apply(F, P), a;
  }
  function f(C) {
    return u = C, s = setTimeout(E, t), c ? g(C) : a;
  }
  function m(C) {
    var P = C - l, F = C - u, L = t - P;
    return p ? aHe(L, i - F) : L;
  }
  function b(C) {
    var P = C - l, F = C - u;
    return l === void 0 || P >= t || P < 0 || p && F >= i;
  }
  function E() {
    var C = kk();
    if (b(C))
      return w(C);
    s = setTimeout(E, m(C));
  }
  function w(C) {
    return s = void 0, d && r ? g(C) : (r = o = void 0, a);
  }
  function M() {
    s !== void 0 && clearTimeout(s), u = 0, r = l = o = s = void 0;
  }
  function x() {
    return s === void 0 ? a : w(kk());
  }
  function v() {
    var C = kk(), P = b(C);
    if (r = arguments, o = this, l = C, P) {
      if (s === void 0)
        return f(l);
      if (p)
        return s = setTimeout(E, t), g(l);
    }
    return s === void 0 && (s = setTimeout(E, t)), a;
  }
  return v.cancel = M, v.flush = x, v;
}
function uHe(e, t, n) {
  var r = !0, o = !0;
  if (typeof e != "function")
    throw new TypeError(Pne);
  return yw(n) && (r = "leading" in n ? !!n.leading : r, o = "trailing" in n ? !!n.trailing : o), lHe(e, t, {
    leading: r,
    maxWait: t,
    trailing: o
  });
}
function yw(e) {
  var t = typeof e;
  return !!e && (t == "object" || t == "function");
}
function cHe(e) {
  return !!e && typeof e == "object";
}
function pHe(e) {
  return typeof e == "symbol" || cHe(e) && iHe.call(e) == KUe;
}
function RV(e) {
  if (typeof e == "number")
    return e;
  if (pHe(e))
    return AV;
  if (yw(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = yw(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = e.replace(XUe, "");
  var n = JUe.test(e);
  return n || QUe.test(e) ? eHe(e.slice(2), n ? 2 : 8) : YUe.test(e) ? AV : +e;
}
var dHe = uHe, xg = {};
Object.defineProperty(xg, "__esModule", {
  value: !0
});
xg.addPassiveEventListener = function(e, t, n) {
  var r = n.name;
  r || (r = t, console.warn("Listener must be a named function.")), My.has(t) || My.set(t, /* @__PURE__ */ new Set());
  var o = My.get(t);
  if (!o.has(r)) {
    var i = function() {
      var a = !1;
      try {
        var s = Object.defineProperty({}, "passive", {
          get: function() {
            a = !0;
          }
        });
        window.addEventListener("test", null, s);
      } catch {
      }
      return a;
    }();
    e.addEventListener(t, n, i ? { passive: !0 } : !1), o.add(r);
  }
};
xg.removePassiveEventListener = function(e, t, n) {
  e.removeEventListener(t, n), My.get(t).delete(n.name || t);
};
var My = /* @__PURE__ */ new Map();
Object.defineProperty(Og, "__esModule", {
  value: !0
});
var fHe = dHe, hHe = gHe(fHe), IV = xg;
function gHe(e) {
  return e && e.__esModule ? e : { default: e };
}
var mHe = function(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 66;
  return (0, hHe.default)(e, t);
}, ho = {
  spyCallbacks: [],
  spySetState: [],
  scrollSpyContainers: [],
  mount: function(e, t) {
    if (e) {
      var n = mHe(function(r) {
        ho.scrollHandler(e);
      }, t);
      return ho.scrollSpyContainers.push(e), (0, IV.addPassiveEventListener)(e, "scroll", n), function() {
        (0, IV.removePassiveEventListener)(e, "scroll", n), ho.scrollSpyContainers.splice(ho.scrollSpyContainers.indexOf(e), 1);
      };
    }
    return function() {
    };
  },
  isMounted: function(e) {
    return ho.scrollSpyContainers.indexOf(e) !== -1;
  },
  currentPositionX: function(e) {
    if (e === document) {
      var t = window.scrollY !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.scrollX : n ? document.documentElement.scrollLeft : document.body.scrollLeft;
    } else
      return e.scrollLeft;
  },
  currentPositionY: function(e) {
    if (e === document) {
      var t = window.scrollX !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.scrollY : n ? document.documentElement.scrollTop : document.body.scrollTop;
    } else
      return e.scrollTop;
  },
  scrollHandler: function(e) {
    var t = ho.scrollSpyContainers[ho.scrollSpyContainers.indexOf(e)].spyCallbacks || [];
    t.forEach(function(n) {
      return n(ho.currentPositionX(e), ho.currentPositionY(e));
    });
  },
  addStateHandler: function(e) {
    ho.spySetState.push(e);
  },
  addSpyHandler: function(e, t) {
    var n = ho.scrollSpyContainers[ho.scrollSpyContainers.indexOf(t)];
    n.spyCallbacks || (n.spyCallbacks = []), n.spyCallbacks.push(e);
  },
  updateStates: function() {
    ho.spySetState.forEach(function(e) {
      return e();
    });
  },
  unmount: function(e, t) {
    ho.scrollSpyContainers.forEach(function(n) {
      return n.spyCallbacks && n.spyCallbacks.length && n.spyCallbacks.indexOf(t) > -1 && n.spyCallbacks.splice(n.spyCallbacks.indexOf(t), 1);
    }), ho.spySetState && ho.spySetState.length && ho.spySetState.indexOf(e) > -1 && ho.spySetState.splice(ho.spySetState.indexOf(e), 1), document.removeEventListener("scroll", ho.scrollHandler);
  },
  update: function() {
    return ho.scrollSpyContainers.forEach(function(e) {
      return ho.scrollHandler(e);
    });
  }
};
Og.default = ho;
var Zp = {}, Eg = {};
Object.defineProperty(Eg, "__esModule", {
  value: !0
});
var vHe = function(e, t) {
  var n = e.indexOf("#") === 0 ? e.substring(1) : e, r = n ? "#" + n : "", o = window && window.location, i = r ? o.pathname + o.search + r : o.pathname + o.search;
  t ? history.pushState(history.state, "", i) : history.replaceState(history.state, "", i);
}, yHe = function() {
  return window.location.hash.replace(/^#/, "");
}, bHe = function(e) {
  return function(t) {
    return e.contains ? e != t && e.contains(t) : !!(e.compareDocumentPosition(t) & 16);
  };
}, wHe = function(e) {
  return getComputedStyle(e).position !== "static";
}, Lk = function(e, t) {
  for (var n = e.offsetTop, r = e.offsetParent; r && !t(r); )
    n += r.offsetTop, r = r.offsetParent;
  return { offsetTop: n, offsetParent: r };
}, CHe = function(e, t, n) {
  if (n)
    return e === document ? t.getBoundingClientRect().left + (window.scrollX || window.pageXOffset) : getComputedStyle(e).position !== "static" ? t.offsetLeft : t.offsetLeft - e.offsetLeft;
  if (e === document)
    return t.getBoundingClientRect().top + (window.scrollY || window.pageYOffset);
  if (wHe(e)) {
    if (t.offsetParent !== e) {
      var r = function(l) {
        return l === e || l === document;
      }, o = Lk(t, r), i = o.offsetTop, a = o.offsetParent;
      if (a !== e)
        throw new Error("Seems containerElement is not an ancestor of the Element");
      return i;
    }
    return t.offsetTop;
  }
  if (t.offsetParent === e.offsetParent)
    return t.offsetTop - e.offsetTop;
  var s = function(l) {
    return l === document;
  };
  return Lk(t, s).offsetTop - Lk(e, s).offsetTop;
};
Eg.default = {
  updateHash: vHe,
  getHash: yHe,
  filterElementInContainer: bHe,
  scrollOffset: CHe
};
var _O = {}, ET = {};
Object.defineProperty(ET, "__esModule", {
  value: !0
});
ET.default = {
  /*
   * https://github.com/oblador/angular-scroll (duScrollDefaultEasing)
   */
  defaultEasing: function(e) {
    return e < 0.5 ? Math.pow(e * 2, 2) / 2 : 1 - Math.pow((1 - e) * 2, 2) / 2;
  },
  /*
   * https://gist.github.com/gre/1650294
   */
  // no easing, no acceleration
  linear: function(e) {
    return e;
  },
  // accelerating from zero velocity
  easeInQuad: function(e) {
    return e * e;
  },
  // decelerating to zero velocity
  easeOutQuad: function(e) {
    return e * (2 - e);
  },
  // acceleration until halfway, then deceleration
  easeInOutQuad: function(e) {
    return e < 0.5 ? 2 * e * e : -1 + (4 - 2 * e) * e;
  },
  // accelerating from zero velocity 
  easeInCubic: function(e) {
    return e * e * e;
  },
  // decelerating to zero velocity π
  easeOutCubic: function(e) {
    return --e * e * e + 1;
  },
  // acceleration until halfway, then deceleration 
  easeInOutCubic: function(e) {
    return e < 0.5 ? 4 * e * e * e : (e - 1) * (2 * e - 2) * (2 * e - 2) + 1;
  },
  // accelerating from zero velocity 
  easeInQuart: function(e) {
    return e * e * e * e;
  },
  // decelerating to zero velocity 
  easeOutQuart: function(e) {
    return 1 - --e * e * e * e;
  },
  // acceleration until halfway, then deceleration
  easeInOutQuart: function(e) {
    return e < 0.5 ? 8 * e * e * e * e : 1 - 8 * --e * e * e * e;
  },
  // accelerating from zero velocity
  easeInQuint: function(e) {
    return e * e * e * e * e;
  },
  // decelerating to zero velocity
  easeOutQuint: function(e) {
    return 1 + --e * e * e * e * e;
  },
  // acceleration until halfway, then deceleration 
  easeInOutQuint: function(e) {
    return e < 0.5 ? 16 * e * e * e * e * e : 1 + 16 * --e * e * e * e * e;
  }
};
var kT = {};
Object.defineProperty(kT, "__esModule", {
  value: !0
});
var OHe = xg, xHe = ["mousedown", "wheel", "touchmove", "keydown"];
kT.default = {
  subscribe: function(e) {
    return typeof document < "u" && xHe.forEach(function(t) {
      return (0, OHe.addPassiveEventListener)(document, t, e);
    });
  }
};
var kg = {};
Object.defineProperty(kg, "__esModule", {
  value: !0
});
var iP = {
  registered: {},
  scrollEvent: {
    register: function(e, t) {
      iP.registered[e] = t;
    },
    remove: function(e) {
      iP.registered[e] = null;
    }
  }
};
kg.default = iP;
Object.defineProperty(_O, "__esModule", {
  value: !0
});
var EHe = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, kHe = Eg;
PO(kHe);
var LHe = ET, NV = PO(LHe), _He = kT, PHe = PO(_He), SHe = kg, ia = PO(SHe);
function PO(e) {
  return e && e.__esModule ? e : { default: e };
}
var Sne = function(e) {
  return NV.default[e.smooth] || NV.default.defaultEasing;
}, MHe = function(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}, DHe = function() {
  if (typeof window < "u")
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame;
}, sP = function() {
  return DHe() || function(e, t, n) {
    window.setTimeout(e, n || 1e3 / 60, (/* @__PURE__ */ new Date()).getTime());
  };
}(), Mne = function() {
  return {
    currentPosition: 0,
    startPosition: 0,
    targetPosition: 0,
    progress: 0,
    duration: 0,
    cancel: !1,
    target: null,
    containerElement: null,
    to: null,
    start: null,
    delta: null,
    percent: null,
    delayTimeout: null
  };
}, Dne = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollLeft;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageXOffset : r ? document.documentElement.scrollLeft : document.body.scrollLeft;
}, Tne = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollTop;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageYOffset : r ? document.documentElement.scrollTop : document.body.scrollTop;
}, THe = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollWidth - t.offsetWidth;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollWidth, n.offsetWidth, r.clientWidth, r.scrollWidth, r.offsetWidth);
}, jHe = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollHeight - t.offsetHeight;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollHeight, n.offsetHeight, r.clientHeight, r.scrollHeight, r.offsetHeight);
}, AHe = function e(t, n, r) {
  var o = n.data;
  if (!n.ignoreCancelEvents && o.cancel) {
    ia.default.registered.end && ia.default.registered.end(o.to, o.target, o.currentPositionY);
    return;
  }
  if (o.delta = Math.round(o.targetPosition - o.startPosition), o.start === null && (o.start = r), o.progress = r - o.start, o.percent = o.progress >= o.duration ? 1 : t(o.progress / o.duration), o.currentPosition = o.startPosition + Math.ceil(o.delta * o.percent), o.containerElement && o.containerElement !== document && o.containerElement !== document.body ? n.horizontal ? o.containerElement.scrollLeft = o.currentPosition : o.containerElement.scrollTop = o.currentPosition : n.horizontal ? window.scrollTo(o.currentPosition, 0) : window.scrollTo(0, o.currentPosition), o.percent < 1) {
    var i = e.bind(null, t, n);
    sP.call(window, i);
    return;
  }
  ia.default.registered.end && ia.default.registered.end(o.to, o.target, o.currentPosition);
}, LT = function(e) {
  e.data.containerElement = e ? e.containerId ? document.getElementById(e.containerId) : e.container && e.container.nodeType ? e.container : document : null;
}, Lg = function(e, t, n, r) {
  t.data = t.data || Mne(), window.clearTimeout(t.data.delayTimeout);
  var o = function() {
    t.data.cancel = !0;
  };
  if (PHe.default.subscribe(o), LT(t), t.data.start = null, t.data.cancel = !1, t.data.startPosition = t.horizontal ? Dne(t) : Tne(t), t.data.targetPosition = t.absolute ? e : e + t.data.startPosition, t.data.startPosition === t.data.targetPosition) {
    ia.default.registered.end && ia.default.registered.end(t.data.to, t.data.target, t.data.currentPosition);
    return;
  }
  t.data.delta = Math.round(t.data.targetPosition - t.data.startPosition), t.data.duration = MHe(t.duration)(t.data.delta), t.data.duration = isNaN(parseFloat(t.data.duration)) ? 1e3 : parseFloat(t.data.duration), t.data.to = n, t.data.target = r;
  var i = Sne(t), a = AHe.bind(null, i, t);
  if (t && t.delay > 0) {
    t.data.delayTimeout = window.setTimeout(function() {
      ia.default.registered.begin && ia.default.registered.begin(t.data.to, t.data.target), sP.call(window, a);
    }, t.delay);
    return;
  }
  ia.default.registered.begin && ia.default.registered.begin(t.data.to, t.data.target), sP.call(window, a);
}, SO = function(e) {
  return e = EHe({}, e), e.data = e.data || Mne(), e.absolute = !0, e;
}, RHe = function(e) {
  Lg(0, SO(e));
}, IHe = function(e, t) {
  Lg(e, SO(t));
}, NHe = function(e) {
  e = SO(e), LT(e), Lg(e.horizontal ? THe(e) : jHe(e), e);
}, BHe = function(e, t) {
  t = SO(t), LT(t);
  var n = t.horizontal ? Dne(t) : Tne(t);
  Lg(e + n, t);
};
_O.default = {
  animateTopScroll: Lg,
  getAnimationType: Sne,
  scrollToTop: RHe,
  scrollToBottom: NHe,
  scrollTo: IHe,
  scrollMore: BHe
};
Object.defineProperty(Zp, "__esModule", {
  value: !0
});
var FHe = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, zHe = Eg, UHe = _T(zHe), HHe = _O, WHe = _T(HHe), $He = kg, jv = _T($He);
function _T(e) {
  return e && e.__esModule ? e : { default: e };
}
var Av = {}, BV = void 0;
Zp.default = {
  unmount: function() {
    Av = {};
  },
  register: function(e, t) {
    Av[e] = t;
  },
  unregister: function(e) {
    delete Av[e];
  },
  get: function(e) {
    return Av[e] || document.getElementById(e) || document.getElementsByName(e)[0] || document.getElementsByClassName(e)[0];
  },
  setActiveLink: function(e) {
    return BV = e;
  },
  getActiveLink: function() {
    return BV;
  },
  scrollTo: function(e, t) {
    var n = this.get(e);
    if (!n) {
      console.warn("target Element not found");
      return;
    }
    t = FHe({}, t, { absolute: !1 });
    var r = t.containerId, o = t.container, i = void 0;
    r ? i = document.getElementById(r) : o && o.nodeType ? i = o : i = document, t.absolute = !0;
    var a = t.horizontal, s = UHe.default.scrollOffset(i, n, a) + (t.offset || 0);
    if (!t.smooth) {
      jv.default.registered.begin && jv.default.registered.begin(e, n), i === document ? t.horizontal ? window.scrollTo(s, 0) : window.scrollTo(0, s) : i.scrollTop = s, jv.default.registered.end && jv.default.registered.end(e, n);
      return;
    }
    WHe.default.animateTopScroll(s, t, e, n);
  }
};
var aP = { exports: {} }, _k = { exports: {} }, qn = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var FV;
function VHe() {
  if (FV) return qn;
  FV = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, g = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, m = e ? Symbol.for("react.block") : 60121, b = e ? Symbol.for("react.fundamental") : 60117, E = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
  function M(v) {
    if (typeof v == "object" && v !== null) {
      var C = v.$$typeof;
      switch (C) {
        case t:
          switch (v = v.type, v) {
            case l:
            case u:
            case r:
            case i:
            case o:
            case p:
              return v;
            default:
              switch (v = v && v.$$typeof, v) {
                case s:
                case c:
                case f:
                case g:
                case a:
                  return v;
                default:
                  return C;
              }
          }
        case n:
          return C;
      }
    }
  }
  function x(v) {
    return M(v) === u;
  }
  return qn.AsyncMode = l, qn.ConcurrentMode = u, qn.ContextConsumer = s, qn.ContextProvider = a, qn.Element = t, qn.ForwardRef = c, qn.Fragment = r, qn.Lazy = f, qn.Memo = g, qn.Portal = n, qn.Profiler = i, qn.StrictMode = o, qn.Suspense = p, qn.isAsyncMode = function(v) {
    return x(v) || M(v) === l;
  }, qn.isConcurrentMode = x, qn.isContextConsumer = function(v) {
    return M(v) === s;
  }, qn.isContextProvider = function(v) {
    return M(v) === a;
  }, qn.isElement = function(v) {
    return typeof v == "object" && v !== null && v.$$typeof === t;
  }, qn.isForwardRef = function(v) {
    return M(v) === c;
  }, qn.isFragment = function(v) {
    return M(v) === r;
  }, qn.isLazy = function(v) {
    return M(v) === f;
  }, qn.isMemo = function(v) {
    return M(v) === g;
  }, qn.isPortal = function(v) {
    return M(v) === n;
  }, qn.isProfiler = function(v) {
    return M(v) === i;
  }, qn.isStrictMode = function(v) {
    return M(v) === o;
  }, qn.isSuspense = function(v) {
    return M(v) === p;
  }, qn.isValidElementType = function(v) {
    return typeof v == "string" || typeof v == "function" || v === r || v === u || v === i || v === o || v === p || v === d || typeof v == "object" && v !== null && (v.$$typeof === f || v.$$typeof === g || v.$$typeof === a || v.$$typeof === s || v.$$typeof === c || v.$$typeof === b || v.$$typeof === E || v.$$typeof === w || v.$$typeof === m);
  }, qn.typeOf = M, qn;
}
var rr = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var zV;
function ZHe() {
  return zV || (zV = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, g = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, m = e ? Symbol.for("react.block") : 60121, b = e ? Symbol.for("react.fundamental") : 60117, E = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
    function M(I) {
      return typeof I == "string" || typeof I == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      I === r || I === u || I === i || I === o || I === p || I === d || typeof I == "object" && I !== null && (I.$$typeof === f || I.$$typeof === g || I.$$typeof === a || I.$$typeof === s || I.$$typeof === c || I.$$typeof === b || I.$$typeof === E || I.$$typeof === w || I.$$typeof === m);
    }
    function x(I) {
      if (typeof I == "object" && I !== null) {
        var le = I.$$typeof;
        switch (le) {
          case t:
            var he = I.type;
            switch (he) {
              case l:
              case u:
              case r:
              case i:
              case o:
              case p:
                return he;
              default:
                var oe = he && he.$$typeof;
                switch (oe) {
                  case s:
                  case c:
                  case f:
                  case g:
                  case a:
                    return oe;
                  default:
                    return le;
                }
            }
          case n:
            return le;
        }
      }
    }
    var v = l, C = u, P = s, F = a, L = t, B = c, N = r, $ = f, V = g, H = n, Z = i, K = o, Y = p, Q = !1;
    function J(I) {
      return Q || (Q = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), _(I) || x(I) === l;
    }
    function _(I) {
      return x(I) === u;
    }
    function D(I) {
      return x(I) === s;
    }
    function z(I) {
      return x(I) === a;
    }
    function S(I) {
      return typeof I == "object" && I !== null && I.$$typeof === t;
    }
    function W(I) {
      return x(I) === c;
    }
    function O(I) {
      return x(I) === r;
    }
    function j(I) {
      return x(I) === f;
    }
    function U(I) {
      return x(I) === g;
    }
    function T(I) {
      return x(I) === n;
    }
    function q(I) {
      return x(I) === i;
    }
    function A(I) {
      return x(I) === o;
    }
    function X(I) {
      return x(I) === p;
    }
    rr.AsyncMode = v, rr.ConcurrentMode = C, rr.ContextConsumer = P, rr.ContextProvider = F, rr.Element = L, rr.ForwardRef = B, rr.Fragment = N, rr.Lazy = $, rr.Memo = V, rr.Portal = H, rr.Profiler = Z, rr.StrictMode = K, rr.Suspense = Y, rr.isAsyncMode = J, rr.isConcurrentMode = _, rr.isContextConsumer = D, rr.isContextProvider = z, rr.isElement = S, rr.isForwardRef = W, rr.isFragment = O, rr.isLazy = j, rr.isMemo = U, rr.isPortal = T, rr.isProfiler = q, rr.isStrictMode = A, rr.isSuspense = X, rr.isValidElementType = M, rr.typeOf = x;
  }()), rr;
}
var UV;
function jne() {
  return UV || (UV = 1, process.env.NODE_ENV === "production" ? _k.exports = VHe() : _k.exports = ZHe()), _k.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var Pk, HV;
function qHe() {
  if (HV) return Pk;
  HV = 1;
  var e = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, n = Object.prototype.propertyIsEnumerable;
  function r(i) {
    if (i == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(i);
  }
  function o() {
    try {
      if (!Object.assign)
        return !1;
      var i = new String("abc");
      if (i[5] = "de", Object.getOwnPropertyNames(i)[0] === "5")
        return !1;
      for (var a = {}, s = 0; s < 10; s++)
        a["_" + String.fromCharCode(s)] = s;
      var l = Object.getOwnPropertyNames(a).map(function(c) {
        return a[c];
      });
      if (l.join("") !== "0123456789")
        return !1;
      var u = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(c) {
        u[c] = c;
      }), Object.keys(Object.assign({}, u)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return Pk = o() ? Object.assign : function(i, a) {
    for (var s, l = r(i), u, c = 1; c < arguments.length; c++) {
      s = Object(arguments[c]);
      for (var p in s)
        t.call(s, p) && (l[p] = s[p]);
      if (e) {
        u = e(s);
        for (var d = 0; d < u.length; d++)
          n.call(s, u[d]) && (l[u[d]] = s[u[d]]);
      }
    }
    return l;
  }, Pk;
}
var Sk, WV;
function PT() {
  if (WV) return Sk;
  WV = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return Sk = e, Sk;
}
var $V, VV;
function Ane() {
  return VV || (VV = 1, $V = Function.call.bind(Object.prototype.hasOwnProperty)), $V;
}
var Mk, ZV;
function GHe() {
  if (ZV) return Mk;
  ZV = 1;
  var e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = PT(), n = {}, r = Ane();
    e = function(i) {
      var a = "Warning: " + i;
      typeof console < "u" && console.error(a);
      try {
        throw new Error(a);
      } catch {
      }
    };
  }
  function o(i, a, s, l, u) {
    if (process.env.NODE_ENV !== "production") {
      for (var c in i)
        if (r(i, c)) {
          var p;
          try {
            if (typeof i[c] != "function") {
              var d = Error(
                (l || "React class") + ": " + s + " type `" + c + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof i[c] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw d.name = "Invariant Violation", d;
            }
            p = i[c](a, c, l, s, null, t);
          } catch (f) {
            p = f;
          }
          if (p && !(p instanceof Error) && e(
            (l || "React class") + ": type specification of " + s + " `" + c + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof p + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), p instanceof Error && !(p.message in n)) {
            n[p.message] = !0;
            var g = u ? u() : "";
            e(
              "Failed " + s + " type: " + p.message + (g ?? "")
            );
          }
        }
    }
  }
  return o.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (n = {});
  }, Mk = o, Mk;
}
var Dk, qV;
function KHe() {
  if (qV) return Dk;
  qV = 1;
  var e = jne(), t = qHe(), n = PT(), r = Ane(), o = GHe(), i = function() {
  };
  process.env.NODE_ENV !== "production" && (i = function(s) {
    var l = "Warning: " + s;
    typeof console < "u" && console.error(l);
    try {
      throw new Error(l);
    } catch {
    }
  });
  function a() {
    return null;
  }
  return Dk = function(s, l) {
    var u = typeof Symbol == "function" && Symbol.iterator, c = "@@iterator";
    function p(_) {
      var D = _ && (u && _[u] || _[c]);
      if (typeof D == "function")
        return D;
    }
    var d = "<<anonymous>>", g = {
      array: E("array"),
      bigint: E("bigint"),
      bool: E("boolean"),
      func: E("function"),
      number: E("number"),
      object: E("object"),
      string: E("string"),
      symbol: E("symbol"),
      any: w(),
      arrayOf: M,
      element: x(),
      elementType: v(),
      instanceOf: C,
      node: B(),
      objectOf: F,
      oneOf: P,
      oneOfType: L,
      shape: $,
      exact: V
    };
    function f(_, D) {
      return _ === D ? _ !== 0 || 1 / _ === 1 / D : _ !== _ && D !== D;
    }
    function m(_, D) {
      this.message = _, this.data = D && typeof D == "object" ? D : {}, this.stack = "";
    }
    m.prototype = Error.prototype;
    function b(_) {
      if (process.env.NODE_ENV !== "production")
        var D = {}, z = 0;
      function S(O, j, U, T, q, A, X) {
        if (T = T || d, A = A || U, X !== n) {
          if (l) {
            var I = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw I.name = "Invariant Violation", I;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var le = T + ":" + U;
            !D[le] && // Avoid spamming the console because they are often not actionable except for lib authors
            z < 3 && (i(
              "You are manually calling a React.PropTypes validation function for the `" + A + "` prop on `" + T + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), D[le] = !0, z++);
          }
        }
        return j[U] == null ? O ? j[U] === null ? new m("The " + q + " `" + A + "` is marked as required " + ("in `" + T + "`, but its value is `null`.")) : new m("The " + q + " `" + A + "` is marked as required in " + ("`" + T + "`, but its value is `undefined`.")) : null : _(j, U, T, q, A);
      }
      var W = S.bind(null, !1);
      return W.isRequired = S.bind(null, !0), W;
    }
    function E(_) {
      function D(z, S, W, O, j, U) {
        var T = z[S], q = K(T);
        if (q !== _) {
          var A = Y(T);
          return new m(
            "Invalid " + O + " `" + j + "` of type " + ("`" + A + "` supplied to `" + W + "`, expected ") + ("`" + _ + "`."),
            { expectedType: _ }
          );
        }
        return null;
      }
      return b(D);
    }
    function w() {
      return b(a);
    }
    function M(_) {
      function D(z, S, W, O, j) {
        if (typeof _ != "function")
          return new m("Property `" + j + "` of component `" + W + "` has invalid PropType notation inside arrayOf.");
        var U = z[S];
        if (!Array.isArray(U)) {
          var T = K(U);
          return new m("Invalid " + O + " `" + j + "` of type " + ("`" + T + "` supplied to `" + W + "`, expected an array."));
        }
        for (var q = 0; q < U.length; q++) {
          var A = _(U, q, W, O, j + "[" + q + "]", n);
          if (A instanceof Error)
            return A;
        }
        return null;
      }
      return b(D);
    }
    function x() {
      function _(D, z, S, W, O) {
        var j = D[z];
        if (!s(j)) {
          var U = K(j);
          return new m("Invalid " + W + " `" + O + "` of type " + ("`" + U + "` supplied to `" + S + "`, expected a single ReactElement."));
        }
        return null;
      }
      return b(_);
    }
    function v() {
      function _(D, z, S, W, O) {
        var j = D[z];
        if (!e.isValidElementType(j)) {
          var U = K(j);
          return new m("Invalid " + W + " `" + O + "` of type " + ("`" + U + "` supplied to `" + S + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return b(_);
    }
    function C(_) {
      function D(z, S, W, O, j) {
        if (!(z[S] instanceof _)) {
          var U = _.name || d, T = J(z[S]);
          return new m("Invalid " + O + " `" + j + "` of type " + ("`" + T + "` supplied to `" + W + "`, expected ") + ("instance of `" + U + "`."));
        }
        return null;
      }
      return b(D);
    }
    function P(_) {
      if (!Array.isArray(_))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? i(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : i("Invalid argument supplied to oneOf, expected an array.")), a;
      function D(z, S, W, O, j) {
        for (var U = z[S], T = 0; T < _.length; T++)
          if (f(U, _[T]))
            return null;
        var q = JSON.stringify(_, function(A, X) {
          var I = Y(X);
          return I === "symbol" ? String(X) : X;
        });
        return new m("Invalid " + O + " `" + j + "` of value `" + String(U) + "` " + ("supplied to `" + W + "`, expected one of " + q + "."));
      }
      return b(D);
    }
    function F(_) {
      function D(z, S, W, O, j) {
        if (typeof _ != "function")
          return new m("Property `" + j + "` of component `" + W + "` has invalid PropType notation inside objectOf.");
        var U = z[S], T = K(U);
        if (T !== "object")
          return new m("Invalid " + O + " `" + j + "` of type " + ("`" + T + "` supplied to `" + W + "`, expected an object."));
        for (var q in U)
          if (r(U, q)) {
            var A = _(U, q, W, O, j + "." + q, n);
            if (A instanceof Error)
              return A;
          }
        return null;
      }
      return b(D);
    }
    function L(_) {
      if (!Array.isArray(_))
        return process.env.NODE_ENV !== "production" && i("Invalid argument supplied to oneOfType, expected an instance of array."), a;
      for (var D = 0; D < _.length; D++) {
        var z = _[D];
        if (typeof z != "function")
          return i(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + Q(z) + " at index " + D + "."
          ), a;
      }
      function S(W, O, j, U, T) {
        for (var q = [], A = 0; A < _.length; A++) {
          var X = _[A], I = X(W, O, j, U, T, n);
          if (I == null)
            return null;
          I.data && r(I.data, "expectedType") && q.push(I.data.expectedType);
        }
        var le = q.length > 0 ? ", expected one of type [" + q.join(", ") + "]" : "";
        return new m("Invalid " + U + " `" + T + "` supplied to " + ("`" + j + "`" + le + "."));
      }
      return b(S);
    }
    function B() {
      function _(D, z, S, W, O) {
        return H(D[z]) ? null : new m("Invalid " + W + " `" + O + "` supplied to " + ("`" + S + "`, expected a ReactNode."));
      }
      return b(_);
    }
    function N(_, D, z, S, W) {
      return new m(
        (_ || "React class") + ": " + D + " type `" + z + "." + S + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + W + "`."
      );
    }
    function $(_) {
      function D(z, S, W, O, j) {
        var U = z[S], T = K(U);
        if (T !== "object")
          return new m("Invalid " + O + " `" + j + "` of type `" + T + "` " + ("supplied to `" + W + "`, expected `object`."));
        for (var q in _) {
          var A = _[q];
          if (typeof A != "function")
            return N(W, O, j, q, Y(A));
          var X = A(U, q, W, O, j + "." + q, n);
          if (X)
            return X;
        }
        return null;
      }
      return b(D);
    }
    function V(_) {
      function D(z, S, W, O, j) {
        var U = z[S], T = K(U);
        if (T !== "object")
          return new m("Invalid " + O + " `" + j + "` of type `" + T + "` " + ("supplied to `" + W + "`, expected `object`."));
        var q = t({}, z[S], _);
        for (var A in q) {
          var X = _[A];
          if (r(_, A) && typeof X != "function")
            return N(W, O, j, A, Y(X));
          if (!X)
            return new m(
              "Invalid " + O + " `" + j + "` key `" + A + "` supplied to `" + W + "`.\nBad object: " + JSON.stringify(z[S], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(_), null, "  ")
            );
          var I = X(U, A, W, O, j + "." + A, n);
          if (I)
            return I;
        }
        return null;
      }
      return b(D);
    }
    function H(_) {
      switch (typeof _) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !_;
        case "object":
          if (Array.isArray(_))
            return _.every(H);
          if (_ === null || s(_))
            return !0;
          var D = p(_);
          if (D) {
            var z = D.call(_), S;
            if (D !== _.entries) {
              for (; !(S = z.next()).done; )
                if (!H(S.value))
                  return !1;
            } else
              for (; !(S = z.next()).done; ) {
                var W = S.value;
                if (W && !H(W[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function Z(_, D) {
      return _ === "symbol" ? !0 : D ? D["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && D instanceof Symbol : !1;
    }
    function K(_) {
      var D = typeof _;
      return Array.isArray(_) ? "array" : _ instanceof RegExp ? "object" : Z(D, _) ? "symbol" : D;
    }
    function Y(_) {
      if (typeof _ > "u" || _ === null)
        return "" + _;
      var D = K(_);
      if (D === "object") {
        if (_ instanceof Date)
          return "date";
        if (_ instanceof RegExp)
          return "regexp";
      }
      return D;
    }
    function Q(_) {
      var D = Y(_);
      switch (D) {
        case "array":
        case "object":
          return "an " + D;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + D;
        default:
          return D;
      }
    }
    function J(_) {
      return !_.constructor || !_.constructor.name ? d : _.constructor.name;
    }
    return g.checkPropTypes = o, g.resetWarningCache = o.resetWarningCache, g.PropTypes = g, g;
  }, Dk;
}
var Tk, GV;
function XHe() {
  if (GV) return Tk;
  GV = 1;
  var e = PT();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, Tk = function() {
    function r(a, s, l, u, c, p) {
      if (p !== e) {
        var d = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw d.name = "Invariant Violation", d;
      }
    }
    r.isRequired = r;
    function o() {
      return r;
    }
    var i = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: o,
      element: r,
      elementType: r,
      instanceOf: o,
      node: r,
      objectOf: o,
      oneOf: o,
      oneOfType: o,
      shape: o,
      exact: o,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return i.PropTypes = i, i;
  }, Tk;
}
if (process.env.NODE_ENV !== "production") {
  var YHe = jne(), JHe = !0;
  aP.exports = KHe()(YHe.isElement, JHe);
} else
  aP.exports = XHe()();
var MO = aP.exports, DO = {};
Object.defineProperty(DO, "__esModule", {
  value: !0
});
var QHe = Eg, jk = eWe(QHe);
function eWe(e) {
  return e && e.__esModule ? e : { default: e };
}
var tWe = {
  mountFlag: !1,
  initialized: !1,
  scroller: null,
  containers: {},
  mount: function(e) {
    this.scroller = e, this.handleHashChange = this.handleHashChange.bind(this), window.addEventListener("hashchange", this.handleHashChange), this.initStateFromHash(), this.mountFlag = !0;
  },
  mapContainer: function(e, t) {
    this.containers[e] = t;
  },
  isMounted: function() {
    return this.mountFlag;
  },
  isInitialized: function() {
    return this.initialized;
  },
  initStateFromHash: function() {
    var e = this, t = this.getHash();
    t ? window.setTimeout(function() {
      e.scrollTo(t, !0), e.initialized = !0;
    }, 10) : this.initialized = !0;
  },
  scrollTo: function(e, t) {
    var n = this.scroller, r = n.get(e);
    if (r && (t || e !== n.getActiveLink())) {
      var o = this.containers[e] || document;
      n.scrollTo(e, { container: o });
    }
  },
  getHash: function() {
    return jk.default.getHash();
  },
  changeHash: function(e, t) {
    this.isInitialized() && jk.default.getHash() !== e && jk.default.updateHash(e, t);
  },
  handleHashChange: function() {
    this.scrollTo(this.getHash());
  },
  unmount: function() {
    this.scroller = null, this.containers = null, window.removeEventListener("hashchange", this.handleHashChange);
  }
};
DO.default = tWe;
Object.defineProperty(Cg, "__esModule", {
  value: !0
});
var Rv = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, nWe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), rWe = be, KV = _g(rWe), oWe = Og, Iv = _g(oWe), iWe = Zp, sWe = _g(iWe), aWe = MO, Qr = _g(aWe), lWe = DO, Ol = _g(lWe);
function _g(e) {
  return e && e.__esModule ? e : { default: e };
}
function uWe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function cWe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function pWe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var XV = {
  to: Qr.default.string.isRequired,
  containerId: Qr.default.string,
  container: Qr.default.object,
  activeClass: Qr.default.string,
  activeStyle: Qr.default.object,
  spy: Qr.default.bool,
  horizontal: Qr.default.bool,
  smooth: Qr.default.oneOfType([Qr.default.bool, Qr.default.string]),
  offset: Qr.default.number,
  delay: Qr.default.number,
  isDynamic: Qr.default.bool,
  onClick: Qr.default.func,
  duration: Qr.default.oneOfType([Qr.default.number, Qr.default.func]),
  absolute: Qr.default.bool,
  onSetActive: Qr.default.func,
  onSetInactive: Qr.default.func,
  ignoreCancelEvents: Qr.default.bool,
  hashSpy: Qr.default.bool,
  saveHashHistory: Qr.default.bool,
  spyThrottle: Qr.default.number
};
Cg.default = function(e, t) {
  var n = t || sWe.default, r = function(i) {
    pWe(a, i);
    function a(s) {
      uWe(this, a);
      var l = cWe(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
      return o.call(l), l.state = {
        active: !1
      }, l.beforeUnmountCallbacks = [], l;
    }
    return nWe(a, [{
      key: "getScrollSpyContainer",
      value: function() {
        var s = this.props.containerId, l = this.props.container;
        return s && !l ? document.getElementById(s) : l && l.nodeType ? l : document;
      }
    }, {
      key: "componentDidMount",
      value: function() {
        if (this.props.spy || this.props.hashSpy) {
          var s = this.getScrollSpyContainer();
          if (!Iv.default.isMounted(s)) {
            var l = Iv.default.mount(s, this.props.spyThrottle);
            this.beforeUnmountCallbacks.push(l);
          }
          this.props.hashSpy && (Ol.default.isMounted() || Ol.default.mount(n), Ol.default.mapContainer(this.props.to, s)), Iv.default.addSpyHandler(this.spyHandler, s), this.setState({
            container: s
          });
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        Iv.default.unmount(this.stateHandler, this.spyHandler), this.beforeUnmountCallbacks.forEach(function(s) {
          return s();
        });
      }
    }, {
      key: "render",
      value: function() {
        var s = "";
        this.state && this.state.active ? s = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : s = this.props.className;
        var l = {};
        this.state && this.state.active ? l = Rv({}, this.props.style, this.props.activeStyle) : l = Rv({}, this.props.style);
        var u = Rv({}, this.props);
        for (var c in XV)
          u.hasOwnProperty(c) && delete u[c];
        return u.className = s, u.style = l, u.onClick = this.handleClick, KV.default.createElement(e, u);
      }
    }]), a;
  }(KV.default.PureComponent), o = function() {
    var i = this;
    this.scrollTo = function(a, s) {
      n.scrollTo(a, Rv({}, i.state, s));
    }, this.handleClick = function(a) {
      i.props.onClick && i.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), i.scrollTo(i.props.to, i.props);
    }, this.spyHandler = function(a, s) {
      var l = i.getScrollSpyContainer();
      if (!(Ol.default.isMounted() && !Ol.default.isInitialized())) {
        var u = i.props.horizontal, c = i.props.to, p = null, d = void 0, g = void 0;
        if (u) {
          var f = 0, m = 0, b = 0;
          if (l.getBoundingClientRect) {
            var E = l.getBoundingClientRect();
            b = E.left;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var w = p.getBoundingClientRect();
            f = w.left - b + a, m = f + w.width;
          }
          var M = a - i.props.offset;
          d = M >= Math.floor(f) && M < Math.floor(m), g = M < Math.floor(f) || M >= Math.floor(m);
        } else {
          var x = 0, v = 0, C = 0;
          if (l.getBoundingClientRect) {
            var P = l.getBoundingClientRect();
            C = P.top;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var F = p.getBoundingClientRect();
            x = F.top - C + s, v = x + F.height;
          }
          var L = s - i.props.offset;
          d = L >= Math.floor(x) && L < Math.floor(v), g = L < Math.floor(x) || L >= Math.floor(v);
        }
        var B = n.getActiveLink();
        if (g) {
          if (c === B && n.setActiveLink(void 0), i.props.hashSpy && Ol.default.getHash() === c) {
            var N = i.props.saveHashHistory, $ = N === void 0 ? !1 : N;
            Ol.default.changeHash("", $);
          }
          i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive(c, p));
        }
        if (d && (B !== c || i.state.active === !1)) {
          n.setActiveLink(c);
          var V = i.props.saveHashHistory, H = V === void 0 ? !1 : V;
          i.props.hashSpy && Ol.default.changeHash(c, H), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(c, p));
        }
      }
    };
  };
  return r.propTypes = XV, r.defaultProps = { offset: 0 }, r;
};
Object.defineProperty(xT, "__esModule", {
  value: !0
});
var dWe = be, YV = Rne(dWe), fWe = Cg, hWe = Rne(fWe);
function Rne(e) {
  return e && e.__esModule ? e : { default: e };
}
function gWe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function JV(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function mWe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var vWe = function(e) {
  mWe(t, e);
  function t() {
    var n, r, o, i;
    gWe(this, t);
    for (var a = arguments.length, s = Array(a), l = 0; l < a; l++)
      s[l] = arguments[l];
    return i = (r = (o = JV(this, (n = t.__proto__ || Object.getPrototypeOf(t)).call.apply(n, [this].concat(s))), o), o.render = function() {
      return YV.default.createElement(
        "a",
        o.props,
        o.props.children
      );
    }, r), JV(o, i);
  }
  return t;
}(YV.default.Component);
xT.default = (0, hWe.default)(vWe);
var ST = {};
Object.defineProperty(ST, "__esModule", {
  value: !0
});
var yWe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), bWe = be, QV = Ine(bWe), wWe = Cg, CWe = Ine(wWe);
function Ine(e) {
  return e && e.__esModule ? e : { default: e };
}
function OWe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function xWe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function EWe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var kWe = function(e) {
  EWe(t, e);
  function t() {
    return OWe(this, t), xWe(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return yWe(t, [{
    key: "render",
    value: function() {
      return QV.default.createElement(
        "button",
        this.props,
        this.props.children
      );
    }
  }]), t;
}(QV.default.Component);
ST.default = (0, CWe.default)(kWe);
var MT = {}, TO = {};
Object.defineProperty(TO, "__esModule", {
  value: !0
});
var LWe = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, _We = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), PWe = be, e9 = jO(PWe), SWe = il;
jO(SWe);
var MWe = Zp, t9 = jO(MWe), DWe = MO, n9 = jO(DWe);
function jO(e) {
  return e && e.__esModule ? e : { default: e };
}
function TWe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function jWe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function AWe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
TO.default = function(e) {
  var t = function(n) {
    AWe(r, n);
    function r(o) {
      TWe(this, r);
      var i = jWe(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
      return i.childBindings = {
        domNode: null
      }, i;
    }
    return _We(r, [{
      key: "componentDidMount",
      value: function() {
        if (typeof window > "u")
          return !1;
        this.registerElems(this.props.name);
      }
    }, {
      key: "componentDidUpdate",
      value: function(o) {
        this.props.name !== o.name && this.registerElems(this.props.name);
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        if (typeof window > "u")
          return !1;
        t9.default.unregister(this.props.name);
      }
    }, {
      key: "registerElems",
      value: function(o) {
        t9.default.register(o, this.childBindings.domNode);
      }
    }, {
      key: "render",
      value: function() {
        return e9.default.createElement(e, LWe({}, this.props, { parentBindings: this.childBindings }));
      }
    }]), r;
  }(e9.default.Component);
  return t.propTypes = {
    name: n9.default.string,
    id: n9.default.string
  }, t;
};
Object.defineProperty(MT, "__esModule", {
  value: !0
});
var r9 = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, RWe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), IWe = be, o9 = DT(IWe), NWe = TO, BWe = DT(NWe), FWe = MO, i9 = DT(FWe);
function DT(e) {
  return e && e.__esModule ? e : { default: e };
}
function zWe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function UWe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function HWe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var Nne = function(e) {
  HWe(t, e);
  function t() {
    return zWe(this, t), UWe(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return RWe(t, [{
    key: "render",
    value: function() {
      var n = this, r = r9({}, this.props);
      return delete r.name, r.parentBindings && delete r.parentBindings, o9.default.createElement(
        "div",
        r9({}, r, { ref: function(o) {
          n.props.parentBindings.domNode = o;
        } }),
        this.props.children
      );
    }
  }]), t;
}(o9.default.Component);
Nne.propTypes = {
  name: i9.default.string,
  id: i9.default.string
};
MT.default = (0, BWe.default)(Nne);
var Ak = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, s9 = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}();
function a9(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function l9(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function u9(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var Nv = be, Uu = Og, Rk = Zp, Oo = MO, xl = DO, c9 = {
  to: Oo.string.isRequired,
  containerId: Oo.string,
  container: Oo.object,
  activeClass: Oo.string,
  spy: Oo.bool,
  smooth: Oo.oneOfType([Oo.bool, Oo.string]),
  offset: Oo.number,
  delay: Oo.number,
  isDynamic: Oo.bool,
  onClick: Oo.func,
  duration: Oo.oneOfType([Oo.number, Oo.func]),
  absolute: Oo.bool,
  onSetActive: Oo.func,
  onSetInactive: Oo.func,
  ignoreCancelEvents: Oo.bool,
  hashSpy: Oo.bool,
  spyThrottle: Oo.number
}, WWe = {
  Scroll: function(e, t) {
    console.warn("Helpers.Scroll is deprecated since v1.7.0");
    var n = t || Rk, r = function(i) {
      u9(a, i);
      function a(s) {
        a9(this, a);
        var l = l9(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
        return o.call(l), l.state = {
          active: !1
        }, l;
      }
      return s9(a, [{
        key: "getScrollSpyContainer",
        value: function() {
          var s = this.props.containerId, l = this.props.container;
          return s ? document.getElementById(s) : l && l.nodeType ? l : document;
        }
      }, {
        key: "componentDidMount",
        value: function() {
          if (this.props.spy || this.props.hashSpy) {
            var s = this.getScrollSpyContainer();
            Uu.isMounted(s) || Uu.mount(s, this.props.spyThrottle), this.props.hashSpy && (xl.isMounted() || xl.mount(n), xl.mapContainer(this.props.to, s)), this.props.spy && Uu.addStateHandler(this.stateHandler), Uu.addSpyHandler(this.spyHandler, s), this.setState({
              container: s
            });
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          Uu.unmount(this.stateHandler, this.spyHandler);
        }
      }, {
        key: "render",
        value: function() {
          var s = "";
          this.state && this.state.active ? s = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : s = this.props.className;
          var l = Ak({}, this.props);
          for (var u in c9)
            l.hasOwnProperty(u) && delete l[u];
          return l.className = s, l.onClick = this.handleClick, Nv.createElement(e, l);
        }
      }]), a;
    }(Nv.Component), o = function() {
      var i = this;
      this.scrollTo = function(a, s) {
        n.scrollTo(a, Ak({}, i.state, s));
      }, this.handleClick = function(a) {
        i.props.onClick && i.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), i.scrollTo(i.props.to, i.props);
      }, this.stateHandler = function() {
        n.getActiveLink() !== i.props.to && (i.state !== null && i.state.active && i.props.onSetInactive && i.props.onSetInactive(), i.setState({ active: !1 }));
      }, this.spyHandler = function(a) {
        var s = i.getScrollSpyContainer();
        if (!(xl.isMounted() && !xl.isInitialized())) {
          var l = i.props.to, u = null, c = 0, p = 0, d = 0;
          if (s.getBoundingClientRect) {
            var g = s.getBoundingClientRect();
            d = g.top;
          }
          if (!u || i.props.isDynamic) {
            if (u = n.get(l), !u)
              return;
            var f = u.getBoundingClientRect();
            c = f.top - d + a, p = c + f.height;
          }
          var m = a - i.props.offset, b = m >= Math.floor(c) && m < Math.floor(p), E = m < Math.floor(c) || m >= Math.floor(p), w = n.getActiveLink();
          if (E)
            return l === w && n.setActiveLink(void 0), i.props.hashSpy && xl.getHash() === l && xl.changeHash(), i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive()), Uu.updateStates();
          if (b && w !== l)
            return n.setActiveLink(l), i.props.hashSpy && xl.changeHash(l), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(l)), Uu.updateStates();
        }
      };
    };
    return r.propTypes = c9, r.defaultProps = { offset: 0 }, r;
  },
  Element: function(e) {
    console.warn("Helpers.Element is deprecated since v1.7.0");
    var t = function(n) {
      u9(r, n);
      function r(o) {
        a9(this, r);
        var i = l9(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
        return i.childBindings = {
          domNode: null
        }, i;
      }
      return s9(r, [{
        key: "componentDidMount",
        value: function() {
          if (typeof window > "u")
            return !1;
          this.registerElems(this.props.name);
        }
      }, {
        key: "componentDidUpdate",
        value: function(o) {
          this.props.name !== o.name && this.registerElems(this.props.name);
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          if (typeof window > "u")
            return !1;
          Rk.unregister(this.props.name);
        }
      }, {
        key: "registerElems",
        value: function(o) {
          Rk.register(o, this.childBindings.domNode);
        }
      }, {
        key: "render",
        value: function() {
          return Nv.createElement(e, Ak({}, this.props, { parentBindings: this.childBindings }));
        }
      }]), r;
    }(Nv.Component);
    return t.propTypes = {
      name: Oo.string,
      id: Oo.string
    }, t;
  }
}, $We = WWe;
Object.defineProperty(No, "__esModule", {
  value: !0
});
No.Helpers = No.ScrollElement = No.ScrollLink = No.animateScroll = No.scrollSpy = No.Events = No.scroller = No.Element = No.Button = No.Link = void 0;
var VWe = xT, Bne = Ca(VWe), ZWe = ST, Fne = Ca(ZWe), qWe = MT, zne = Ca(qWe), GWe = Zp, Une = Ca(GWe), KWe = kg, Hne = Ca(KWe), XWe = Og, Wne = Ca(XWe), YWe = _O, $ne = Ca(YWe), JWe = Cg, Vne = Ca(JWe), QWe = TO, Zne = Ca(QWe), e$e = $We, qne = Ca(e$e);
function Ca(e) {
  return e && e.__esModule ? e : { default: e };
}
No.Link = Bne.default;
No.Button = Fne.default;
No.Element = zne.default;
No.scroller = Une.default;
No.Events = Hne.default;
No.scrollSpy = Wne.default;
No.animateScroll = $ne.default;
No.ScrollLink = Vne.default;
No.ScrollElement = Zne.default;
No.Helpers = qne.default;
No.default = { Link: Bne.default, Button: Fne.default, Element: zne.default, scroller: Une.default, Events: Hne.default, scrollSpy: Wne.default, animateScroll: $ne.default, ScrollLink: Vne.default, ScrollElement: Zne.default, Helpers: qne.default };
$e({});
$e({});
$e({});
function Ih(e) {
  "@babel/helpers - typeof";
  return Ih = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Ih(e);
}
function t$e(e, t) {
  if (Ih(e) != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (Ih(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function n$e(e) {
  var t = t$e(e, "string");
  return Ih(t) == "symbol" ? t : t + "";
}
function Me(e, t, n) {
  return (t = n$e(t)) in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function Gne(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var Ik, p9;
function r$e() {
  if (p9) return Ik;
  p9 = 1;
  var e = process.env.NODE_ENV, t = function(n, r, o, i, a, s, l, u) {
    if (e !== "production" && r === void 0)
      throw new Error("invariant requires an error message argument");
    if (!n) {
      var c;
      if (r === void 0)
        c = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
      else {
        var p = [o, i, a, s, l, u], d = 0;
        c = new Error(r.replace(/%s/g, function() {
          return p[d++];
        })), c.name = "Invariant Violation";
      }
      throw c.framesToPop = 1, c;
    }
  };
  return Ik = t, Ik;
}
var o$e = r$e(), Vo = /* @__PURE__ */ Gne(o$e), Ft = $e(null);
function i$e() {
  Vo(!!ge, "useGoogleMap is React hook and requires React version 16.8+");
  var e = ge(Ft);
  return Vo(!!e, "useGoogleMap needs a GoogleMap available up in the tree"), e;
}
function s$e(e, t, n) {
  return Object.keys(e).reduce(function(r, o) {
    return t(r, e[o], o);
  }, n);
}
function a$e(e, t) {
  Object.keys(e).forEach((n) => t(e[n], n));
}
function l$e(e, t, n, r) {
  var o = {}, i = (a, s) => {
    var l = n[s];
    l !== t[s] && (o[s] = l, a(r, l));
  };
  return a$e(e, i), o;
}
function u$e(e, t, n) {
  var r = s$e(n, function(o, i, a) {
    return typeof e[a] == "function" && o.push(google.maps.event.addListener(t, i, e[a])), o;
  }, []);
  return r;
}
function c$e(e) {
  google.maps.event.removeListener(e);
}
function Pn() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  e.forEach(c$e);
}
function Cn(e) {
  var {
    updaterMap: t,
    eventMap: n,
    prevProps: r,
    nextProps: o,
    instance: i
  } = e, a = u$e(o, i, n);
  return l$e(t, r, o, i), a;
}
function p$e(e) {
  var {
    children: t,
    options: n,
    id: r,
    mapContainerStyle: o,
    mapContainerClassName: i,
    center: a,
    // clickableIcons,
    // extraMapTypes,
    // heading,
    // mapTypeId,
    onClick: s,
    onDblClick: l,
    onDrag: u,
    onDragEnd: c,
    onDragStart: p,
    onMouseMove: d,
    onMouseOut: g,
    onMouseOver: f,
    onMouseDown: m,
    onMouseUp: b,
    onRightClick: E,
    // onMapTypeIdChanged,
    // onTilesLoaded,
    // onBoundsChanged,
    onCenterChanged: w,
    // onHeadingChanged,
    // onIdle,
    // onProjectionChanged,
    // onResize,
    // onTiltChanged,
    // onZoomChanged,
    onLoad: M,
    onUnmount: x
  } = e, [v, C] = k(null), P = dt(null), [F, L] = k(null), [B, N] = k(null), [$, V] = k(null), [H, Z] = k(null), [K, Y] = k(null), [Q, J] = k(null), [_, D] = k(null), [z, S] = k(null), [W, O] = k(null), [j, U] = k(null), [T, q] = k(null), [A, X] = k(null);
  return h(() => {
    n && v !== null && v.setOptions(n);
  }, [v, n]), h(() => {
    v !== null && typeof a < "u" && v.setCenter(a);
  }, [v, a]), h(() => {
    v && l && (B !== null && google.maps.event.removeListener(B), N(google.maps.event.addListener(v, "dblclick", l)));
  }, [l]), h(() => {
    v && c && ($ !== null && google.maps.event.removeListener($), V(google.maps.event.addListener(v, "dragend", c)));
  }, [c]), h(() => {
    v && p && (H !== null && google.maps.event.removeListener(H), Z(google.maps.event.addListener(v, "dragstart", p)));
  }, [p]), h(() => {
    v && m && (K !== null && google.maps.event.removeListener(K), Y(google.maps.event.addListener(v, "mousedown", m)));
  }, [m]), h(() => {
    v && d && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(v, "mousemove", d)));
  }, [d]), h(() => {
    v && g && (_ !== null && google.maps.event.removeListener(_), D(google.maps.event.addListener(v, "mouseout", g)));
  }, [g]), h(() => {
    v && f && (z !== null && google.maps.event.removeListener(z), S(google.maps.event.addListener(v, "mouseover", f)));
  }, [f]), h(() => {
    v && b && (W !== null && google.maps.event.removeListener(W), O(google.maps.event.addListener(v, "mouseup", b)));
  }, [b]), h(() => {
    v && E && (j !== null && google.maps.event.removeListener(j), U(google.maps.event.addListener(v, "rightclick", E)));
  }, [E]), h(() => {
    v && s && (T !== null && google.maps.event.removeListener(T), q(google.maps.event.addListener(v, "click", s)));
  }, [s]), h(() => {
    v && u && (A !== null && google.maps.event.removeListener(A), X(google.maps.event.addListener(v, "drag", u)));
  }, [u]), h(() => {
    v && w && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(v, "center_changed", w)));
  }, [s]), h(() => {
    var I = P.current === null ? null : new google.maps.Map(P.current, n);
    return C(I), I !== null && M && M(I), () => {
      I !== null && x && x(I);
    };
  }, []), Jo.jsx("div", {
    id: r,
    ref: P,
    style: o,
    className: i,
    children: Jo.jsx(Ft.Provider, {
      value: v,
      children: v !== null ? t : null
    })
  });
}
me(p$e);
function d9(e, t, n, r, o, i, a) {
  try {
    var s = e[i](a), l = s.value;
  } catch (u) {
    return void n(u);
  }
  s.done ? t(l) : Promise.resolve(l).then(r, o);
}
function Kne(e) {
  return function() {
    var t = this, n = arguments;
    return new Promise(function(r, o) {
      var i = e.apply(t, n);
      function a(l) {
        d9(i, r, o, a, s, "next", l);
      }
      function s(l) {
        d9(i, r, o, a, s, "throw", l);
      }
      a(void 0);
    });
  };
}
function Xne(e) {
  var {
    googleMapsApiKey: t,
    googleMapsClientId: n,
    version: r = "weekly",
    language: o,
    region: i,
    libraries: a,
    channel: s,
    mapIds: l,
    authReferrerPolicy: u
  } = e, c = [];
  return Vo(t && n || !(t && n), "You need to specify either googleMapsApiKey or googleMapsClientId for @react-google-maps/api load script to work. You cannot use both at the same time."), t ? c.push("key=".concat(t)) : n && c.push("client=".concat(n)), r && c.push("v=".concat(r)), o && c.push("language=".concat(o)), i && c.push("region=".concat(i)), a && a.length && c.push("libraries=".concat(a.sort().join(","))), s && c.push("channel=".concat(s)), l && l.length && c.push("map_ids=".concat(l.join(","))), u && c.push("auth_referrer_policy=".concat(u)), c.push("loading=async"), c.push("callback=initMap"), "https://maps.googleapis.com/maps/api/js?".concat(c.join("&"));
}
var vc = typeof document < "u";
function Yne(e) {
  var {
    url: t,
    id: n,
    nonce: r
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } = e;
  return vc ? new Promise(function(o, i) {
    var a = document.getElementById(n), s = window;
    if (a) {
      var l = a.getAttribute("data-state");
      if (a.src === t && l !== "error") {
        if (l === "ready")
          return o(n);
        var u = s.initMap, c = a.onerror;
        s.initMap = function() {
          u && u(), o(n);
        }, a.onerror = function(d) {
          c && c(d), i(d);
        };
        return;
      } else
        a.remove();
    }
    var p = document.createElement("script");
    p.type = "text/javascript", p.src = t, p.id = n, p.async = !0, p.nonce = r || "", p.onerror = function(d) {
      p.setAttribute("data-state", "error"), i(d);
    }, s.initMap = function() {
      p.setAttribute("data-state", "ready"), o(n);
    }, document.head.appendChild(p);
  }).catch((o) => {
    throw console.error("injectScript error: ", o), o;
  }) : Promise.reject(new Error("document is undefined"));
}
function f9(e) {
  var t = e.href;
  return t && (t.indexOf("https://fonts.googleapis.com/css?family=Roboto") === 0 || t.indexOf("https://fonts.googleapis.com/css?family=Google+Sans+Text") === 0) ? !0 : (
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.styleSheet.cssText = "", !0) : (
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.innerHTML = "", !0) : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.innerHTML
      )
    )
  );
}
function Jne() {
  var e = document.getElementsByTagName("head")[0];
  if (e) {
    var t = e.insertBefore.bind(e);
    e.insertBefore = function(r, o) {
      return f9(r) || Reflect.apply(t, e, [r, o]), r;
    };
    var n = e.appendChild.bind(e);
    e.appendChild = function(r) {
      return f9(r) || Reflect.apply(n, e, [r]), r;
    };
  }
}
var Sd = !1;
function Qne() {
  return Jo.jsx("div", {
    children: "Loading..."
  });
}
var lP = {
  id: "script-loader",
  version: "weekly"
};
class d$e extends pe {
  constructor() {
    super(...arguments), Me(this, "check", null), Me(this, "state", {
      loaded: !1
    }), Me(this, "cleanupCallback", () => {
      delete window.google.maps, this.injectScript();
    }), Me(this, "isCleaningUp", /* @__PURE__ */ Kne(function* () {
      function t(n) {
        if (!Sd)
          n();
        else if (vc)
          var r = window.setInterval(function() {
            Sd || (window.clearInterval(r), n());
          }, 1);
      }
      return new Promise(t);
    })), Me(this, "cleanup", () => {
      Sd = !0;
      var t = document.getElementById(this.props.id);
      t && t.parentNode && t.parentNode.removeChild(t), Array.prototype.slice.call(document.getElementsByTagName("script")).filter(function(n) {
        return typeof n.src == "string" && n.src.includes("maps.googleapis");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("link")).filter(function(n) {
        return n.href === "https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Google+Sans";
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("style")).filter(function(n) {
        return n.innerText !== void 0 && n.innerText.length > 0 && n.innerText.includes(".gm-");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      });
    }), Me(this, "injectScript", () => {
      this.props.preventGoogleFontsLoading && Jne(), Vo(!!this.props.id, 'LoadScript requires "id" prop to be a string: %s', this.props.id);
      var t = {
        id: this.props.id,
        nonce: this.props.nonce,
        url: Xne(this.props)
      };
      Yne(t).then(() => {
        this.props.onLoad && this.props.onLoad(), this.setState(function() {
          return {
            loaded: !0
          };
        });
      }).catch((n) => {
        this.props.onError && this.props.onError(n), console.error(`
          There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(this.props.googleMapsApiKey || "-", ") or Client ID (").concat(this.props.googleMapsClientId || "-", `) to <LoadScript />
          Otherwise it is a Network issue.
        `));
      });
    }), Me(this, "getRef", (t) => {
      this.check = t;
    });
  }
  componentDidMount() {
    if (vc) {
      if (window.google && window.google.maps && !Sd) {
        console.error("google api is already presented");
        return;
      }
      this.isCleaningUp().then(this.injectScript).catch(function(t) {
        console.error("Error at injecting script after cleaning up: ", t);
      });
    }
  }
  componentDidUpdate(t) {
    this.props.libraries !== t.libraries && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), vc && t.language !== this.props.language && (this.cleanup(), this.setState(function() {
      return {
        loaded: !1
      };
    }, this.cleanupCallback));
  }
  componentWillUnmount() {
    if (vc) {
      this.cleanup();
      var t = () => {
        this.check || (delete window.google, Sd = !1);
      };
      window.setTimeout(t, 1), this.props.onUnmount && this.props.onUnmount();
    }
  }
  render() {
    return Jo.jsxs(Jo.Fragment, {
      children: [Jo.jsx("div", {
        ref: this.getRef
      }), this.state.loaded ? this.props.children : this.props.loadingElement || Jo.jsx(Qne, {})]
    });
  }
}
Me(d$e, "defaultProps", lP);
function f$e(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.includes(r)) continue;
    n[r] = e[r];
  }
  return n;
}
function TT(e, t) {
  if (e == null) return {};
  var n, r, o = f$e(e, t);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (r = 0; r < i.length; r++) n = i[r], t.includes(n) || {}.propertyIsEnumerable.call(e, n) && (o[n] = e[n]);
  }
  return o;
}
var h9;
function h$e(e) {
  var {
    id: t = lP.id,
    version: n = lP.version,
    nonce: r,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    preventGoogleFontsLoading: u,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  } = e, g = dt(!1), [f, m] = k(!1), [b, E] = k(void 0);
  h(function() {
    return g.current = !0, () => {
      g.current = !1;
    };
  }, []), h(function() {
    vc && u && Jne();
  }, [u]), h(function() {
    f && Vo(!!window.google, "useLoadScript was marked as loaded, but window.google is not present. Something went wrong.");
  }, [f]);
  var w = Xne({
    version: n,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  });
  h(function() {
    if (!vc)
      return;
    function x() {
      g.current && (m(!0), h9 = w);
    }
    if (window.google && window.google.maps && h9 === w) {
      x();
      return;
    }
    Yne({
      id: t,
      url: w,
      nonce: r
    }).then(x).catch(function(v) {
      g.current && E(v), console.warn(`
        There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(o || "-", ") or Client ID (").concat(i || "-", `)
        Otherwise it is a Network issue.
      `)), console.error(v);
    });
  }, [t, w, r]);
  var M = dt(void 0);
  return h(function() {
    M.current && l !== M.current && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), M.current = l;
  }, [l]), {
    isLoaded: f,
    loadError: b,
    url: w
  };
}
var g$e = ["loadingElement", "onLoad", "onError", "onUnmount", "children"], m$e = Jo.jsx(Qne, {});
function v$e(e) {
  var {
    loadingElement: t,
    onLoad: n,
    onError: r,
    onUnmount: o,
    children: i
  } = e, a = TT(e, g$e), {
    isLoaded: s,
    loadError: l
  } = h$e(a);
  return h(function() {
    s && typeof n == "function" && n();
  }, [s, n]), h(function() {
    l && typeof r == "function" && r(l);
  }, [l, r]), h(function() {
    return () => {
      o && o();
    };
  }, [o]), s ? i : t || m$e;
}
me(v$e);
var g9;
(function(e) {
  e[e.INITIALIZED = 0] = "INITIALIZED", e[e.LOADING = 1] = "LOADING", e[e.SUCCESS = 2] = "SUCCESS", e[e.FAILURE = 3] = "FAILURE";
})(g9 || (g9 = {}));
function m9(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function bw(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? m9(Object(n), !0).forEach(function(r) {
      Me(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : m9(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var v9 = {}, y9 = {
  options(e, t) {
    e.setOptions(t);
  }
};
function y$e(e) {
  var {
    options: t,
    onLoad: n,
    onUnmount: r
  } = e, o = ge(Ft), [i, a] = k(null);
  return h(() => {
    i !== null && i.setMap(o);
  }, [o]), h(() => {
    t && i !== null && i.setOptions(t);
  }, [i, t]), h(() => {
    var s = new google.maps.TrafficLayer(bw(bw({}, t), {}, {
      map: o
    }));
    return a(s), n && n(s), () => {
      i !== null && (r && r(i), i.setMap(null));
    };
  }, []), null;
}
me(y$e);
class b$e extends pe {
  constructor() {
    super(...arguments), Me(this, "state", {
      trafficLayer: null
    }), Me(this, "setTrafficLayerCallback", () => {
      this.state.trafficLayer !== null && this.props.onLoad && this.props.onLoad(this.state.trafficLayer);
    }), Me(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = new google.maps.TrafficLayer(bw(bw({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Cn({
      updaterMap: y9,
      eventMap: v9,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        trafficLayer: t
      };
    }, this.setTrafficLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.trafficLayer !== null && (Pn(this.registeredEvents), this.registeredEvents = Cn({
      updaterMap: y9,
      eventMap: v9,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.trafficLayer
    }));
  }
  componentWillUnmount() {
    this.state.trafficLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.trafficLayer), Pn(this.registeredEvents), this.state.trafficLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Me(b$e, "contextType", Ft);
function w$e(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = ge(Ft), [o, i] = k(null);
  return h(() => {
    o !== null && o.setMap(r);
  }, [r]), h(() => {
    var a = new google.maps.BicyclingLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      a !== null && (n && n(a), a.setMap(null));
    };
  }, []), null;
}
me(w$e);
class C$e extends pe {
  constructor() {
    super(...arguments), Me(this, "state", {
      bicyclingLayer: null
    }), Me(this, "setBicyclingLayerCallback", () => {
      this.state.bicyclingLayer !== null && (this.state.bicyclingLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.bicyclingLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.BicyclingLayer();
    this.setState(() => ({
      bicyclingLayer: t
    }), this.setBicyclingLayerCallback);
  }
  componentWillUnmount() {
    this.state.bicyclingLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.bicyclingLayer), this.state.bicyclingLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Me(C$e, "contextType", Ft);
function O$e(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = ge(Ft), [o, i] = k(null);
  return h(() => {
    o !== null && o.setMap(r);
  }, [r]), h(() => {
    var a = new google.maps.TransitLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      o !== null && (n && n(o), o.setMap(null));
    };
  }, []), null;
}
me(O$e);
class x$e extends pe {
  constructor() {
    super(...arguments), Me(this, "state", {
      transitLayer: null
    }), Me(this, "setTransitLayerCallback", () => {
      this.state.transitLayer !== null && (this.state.transitLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.transitLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.TransitLayer();
    this.setState(function() {
      return {
        transitLayer: t
      };
    }, this.setTransitLayerCallback);
  }
  componentWillUnmount() {
    this.state.transitLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.transitLayer), this.state.transitLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Me(x$e, "contextType", Ft);
function b9(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ww(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? b9(Object(n), !0).forEach(function(r) {
      Me(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : b9(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var w9 = {
  onCircleComplete: "circlecomplete",
  onMarkerComplete: "markercomplete",
  onOverlayComplete: "overlaycomplete",
  onPolygonComplete: "polygoncomplete",
  onPolylineComplete: "polylinecomplete",
  onRectangleComplete: "rectanglecomplete"
}, C9 = {
  drawingMode(e, t) {
    e.setDrawingMode(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function E$e(e) {
  var {
    options: t,
    drawingMode: n,
    onCircleComplete: r,
    onMarkerComplete: o,
    onOverlayComplete: i,
    onPolygonComplete: a,
    onPolylineComplete: s,
    onRectangleComplete: l,
    onLoad: u,
    onUnmount: c
  } = e, p = ge(Ft), [d, g] = k(null), [f, m] = k(null), [b, E] = k(null), [w, M] = k(null), [x, v] = k(null), [C, P] = k(null), [F, L] = k(null);
  return h(() => {
    d !== null && d.setMap(p);
  }, [p]), h(() => {
    t && d !== null && d.setOptions(t);
  }, [d, t]), h(() => {
    d !== null && d.setDrawingMode(n ?? null);
  }, [d, n]), h(() => {
    d && r && (f !== null && google.maps.event.removeListener(f), m(google.maps.event.addListener(d, "circlecomplete", r)));
  }, [d, r]), h(() => {
    d && o && (b !== null && google.maps.event.removeListener(b), E(google.maps.event.addListener(d, "markercomplete", o)));
  }, [d, o]), h(() => {
    d && i && (w !== null && google.maps.event.removeListener(w), M(google.maps.event.addListener(d, "overlaycomplete", i)));
  }, [d, i]), h(() => {
    d && a && (x !== null && google.maps.event.removeListener(x), v(google.maps.event.addListener(d, "polygoncomplete", a)));
  }, [d, a]), h(() => {
    d && s && (C !== null && google.maps.event.removeListener(C), P(google.maps.event.addListener(d, "polylinecomplete", s)));
  }, [d, s]), h(() => {
    d && l && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(d, "rectanglecomplete", l)));
  }, [d, l]), h(() => {
    Vo(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
    var B = new google.maps.drawing.DrawingManager(ww(ww({}, t), {}, {
      map: p
    }));
    return n && B.setDrawingMode(n), r && m(google.maps.event.addListener(B, "circlecomplete", r)), o && E(google.maps.event.addListener(B, "markercomplete", o)), i && M(google.maps.event.addListener(B, "overlaycomplete", i)), a && v(google.maps.event.addListener(B, "polygoncomplete", a)), s && P(google.maps.event.addListener(B, "polylinecomplete", s)), l && L(google.maps.event.addListener(B, "rectanglecomplete", l)), g(B), u && u(B), () => {
      d !== null && (f && google.maps.event.removeListener(f), b && google.maps.event.removeListener(b), w && google.maps.event.removeListener(w), x && google.maps.event.removeListener(x), C && google.maps.event.removeListener(C), F && google.maps.event.removeListener(F), c && c(d), d.setMap(null));
    };
  }, []), null;
}
me(E$e);
class k$e extends pe {
  constructor(t) {
    super(t), Me(this, "registeredEvents", []), Me(this, "state", {
      drawingManager: null
    }), Me(this, "setDrawingManagerCallback", () => {
      this.state.drawingManager !== null && this.props.onLoad && this.props.onLoad(this.state.drawingManager);
    }), Vo(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
  }
  componentDidMount() {
    var t = new google.maps.drawing.DrawingManager(ww(ww({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Cn({
      updaterMap: C9,
      eventMap: w9,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        drawingManager: t
      };
    }, this.setDrawingManagerCallback);
  }
  componentDidUpdate(t) {
    this.state.drawingManager !== null && (Pn(this.registeredEvents), this.registeredEvents = Cn({
      updaterMap: C9,
      eventMap: w9,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.drawingManager
    }));
  }
  componentWillUnmount() {
    this.state.drawingManager !== null && (this.props.onUnmount && this.props.onUnmount(this.state.drawingManager), Pn(this.registeredEvents), this.state.drawingManager.setMap(null));
  }
  render() {
    return null;
  }
}
Me(k$e, "contextType", Ft);
function O9(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function hp(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? O9(Object(n), !0).forEach(function(r) {
      Me(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : O9(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var x9 = {
  onAnimationChanged: "animation_changed",
  onClick: "click",
  onClickableChanged: "clickable_changed",
  onCursorChanged: "cursor_changed",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDraggableChanged: "draggable_changed",
  onDragStart: "dragstart",
  onFlatChanged: "flat_changed",
  onIconChanged: "icon_changed",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onPositionChanged: "position_changed",
  onRightClick: "rightclick",
  onShapeChanged: "shape_changed",
  onTitleChanged: "title_changed",
  onVisibleChanged: "visible_changed",
  onZindexChanged: "zindex_changed"
}, E9 = {
  animation(e, t) {
    e.setAnimation(t);
  },
  clickable(e, t) {
    e.setClickable(t);
  },
  cursor(e, t) {
    e.setCursor(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  icon(e, t) {
    e.setIcon(t);
  },
  label(e, t) {
    e.setLabel(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  opacity(e, t) {
    e.setOpacity(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  shape(e, t) {
    e.setShape(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, Cw = {};
function L$e(e) {
  var {
    position: t,
    options: n,
    clusterer: r,
    noClustererRedraw: o,
    children: i,
    draggable: a,
    visible: s,
    animation: l,
    clickable: u,
    cursor: c,
    icon: p,
    label: d,
    opacity: g,
    shape: f,
    title: m,
    zIndex: b,
    onClick: E,
    onDblClick: w,
    onDrag: M,
    onDragEnd: x,
    onDragStart: v,
    onMouseOut: C,
    onMouseOver: P,
    onMouseUp: F,
    onMouseDown: L,
    onRightClick: B,
    onClickableChanged: N,
    onCursorChanged: $,
    onAnimationChanged: V,
    onDraggableChanged: H,
    onFlatChanged: Z,
    onIconChanged: K,
    onPositionChanged: Y,
    onShapeChanged: Q,
    onTitleChanged: J,
    onVisibleChanged: _,
    onZindexChanged: D,
    onLoad: z,
    onUnmount: S
  } = e, W = ge(Ft), [O, j] = k(null), [U, T] = k(null), [q, A] = k(null), [X, I] = k(null), [le, he] = k(null), [oe, Ae] = k(null), [Ue, He] = k(null), [Re, nt] = k(null), [Ve, we] = k(null), [et, lt] = k(null), [ye, ke] = k(null), [Qe, Fe] = k(null), [Ie, ot] = k(null), [Ee, wt] = k(null), [it, st] = k(null), [ut, Ct] = k(null), [ct, pt] = k(null), [rt, We] = k(null), [Ot, xt] = k(null), [gt, Ht] = k(null), [mt, Wt] = k(null), [vt, kt] = k(null);
  h(() => {
    O !== null && O.setMap(W);
  }, [W]), h(() => {
    typeof n < "u" && O !== null && O.setOptions(n);
  }, [O, n]), h(() => {
    typeof a < "u" && O !== null && O.setDraggable(a);
  }, [O, a]), h(() => {
    t && O !== null && O.setPosition(t);
  }, [O, t]), h(() => {
    typeof s < "u" && O !== null && O.setVisible(s);
  }, [O, s]), h(() => {
    O == null || O.setAnimation(l);
  }, [O, l]), h(() => {
    O && u !== void 0 && O.setClickable(u);
  }, [O, u]), h(() => {
    O && c !== void 0 && O.setCursor(c);
  }, [O, c]), h(() => {
    O && p !== void 0 && O.setIcon(p);
  }, [O, p]), h(() => {
    O && d !== void 0 && O.setLabel(d);
  }, [O, d]), h(() => {
    O && g !== void 0 && O.setOpacity(g);
  }, [O, g]), h(() => {
    O && f !== void 0 && O.setShape(f);
  }, [O, f]), h(() => {
    O && m !== void 0 && O.setTitle(m);
  }, [O, m]), h(() => {
    O && b !== void 0 && O.setZIndex(b);
  }, [O, b]), h(() => {
    O && w && (U !== null && google.maps.event.removeListener(U), T(google.maps.event.addListener(O, "dblclick", w)));
  }, [w]), h(() => {
    O && x && (q !== null && google.maps.event.removeListener(q), A(google.maps.event.addListener(O, "dragend", x)));
  }, [x]), h(() => {
    O && v && (X !== null && google.maps.event.removeListener(X), I(google.maps.event.addListener(O, "dragstart", v)));
  }, [v]), h(() => {
    O && L && (le !== null && google.maps.event.removeListener(le), he(google.maps.event.addListener(O, "mousedown", L)));
  }, [L]), h(() => {
    O && C && (oe !== null && google.maps.event.removeListener(oe), Ae(google.maps.event.addListener(O, "mouseout", C)));
  }, [C]), h(() => {
    O && P && (Ue !== null && google.maps.event.removeListener(Ue), He(google.maps.event.addListener(O, "mouseover", P)));
  }, [P]), h(() => {
    O && F && (Re !== null && google.maps.event.removeListener(Re), nt(google.maps.event.addListener(O, "mouseup", F)));
  }, [F]), h(() => {
    O && B && (Ve !== null && google.maps.event.removeListener(Ve), we(google.maps.event.addListener(O, "rightclick", B)));
  }, [B]), h(() => {
    O && E && (et !== null && google.maps.event.removeListener(et), lt(google.maps.event.addListener(O, "click", E)));
  }, [E]), h(() => {
    O && M && (ye !== null && google.maps.event.removeListener(ye), ke(google.maps.event.addListener(O, "drag", M)));
  }, [M]), h(() => {
    O && N && (Qe !== null && google.maps.event.removeListener(Qe), Fe(google.maps.event.addListener(O, "clickable_changed", N)));
  }, [N]), h(() => {
    O && $ && (Ie !== null && google.maps.event.removeListener(Ie), ot(google.maps.event.addListener(O, "cursor_changed", $)));
  }, [$]), h(() => {
    O && V && (Ee !== null && google.maps.event.removeListener(Ee), wt(google.maps.event.addListener(O, "animation_changed", V)));
  }, [V]), h(() => {
    O && H && (it !== null && google.maps.event.removeListener(it), st(google.maps.event.addListener(O, "draggable_changed", H)));
  }, [H]), h(() => {
    O && Z && (ut !== null && google.maps.event.removeListener(ut), Ct(google.maps.event.addListener(O, "flat_changed", Z)));
  }, [Z]), h(() => {
    O && K && (ct !== null && google.maps.event.removeListener(ct), pt(google.maps.event.addListener(O, "icon_changed", K)));
  }, [K]), h(() => {
    O && Y && (rt !== null && google.maps.event.removeListener(rt), We(google.maps.event.addListener(O, "position_changed", Y)));
  }, [Y]), h(() => {
    O && Q && (Ot !== null && google.maps.event.removeListener(Ot), xt(google.maps.event.addListener(O, "shape_changed", Q)));
  }, [Q]), h(() => {
    O && J && (gt !== null && google.maps.event.removeListener(gt), Ht(google.maps.event.addListener(O, "title_changed", J)));
  }, [J]), h(() => {
    O && _ && (mt !== null && google.maps.event.removeListener(mt), Wt(google.maps.event.addListener(O, "visible_changed", _)));
  }, [_]), h(() => {
    O && D && (vt !== null && google.maps.event.removeListener(vt), kt(google.maps.event.addListener(O, "zindex_changed", D)));
  }, [D]), h(() => {
    var yt = hp(hp(hp({}, n || Cw), r ? Cw : {
      map: W
    }), {}, {
      position: t
    }), re = new google.maps.Marker(yt);
    return r ? r.addMarker(re, !!o) : re.setMap(W), t && re.setPosition(t), typeof s < "u" && re.setVisible(s), typeof a < "u" && re.setDraggable(a), typeof u < "u" && re.setClickable(u), typeof c == "string" && re.setCursor(c), p && re.setIcon(p), typeof d < "u" && re.setLabel(d), typeof g < "u" && re.setOpacity(g), f && re.setShape(f), typeof m == "string" && re.setTitle(m), typeof b == "number" && re.setZIndex(b), w && T(google.maps.event.addListener(re, "dblclick", w)), x && A(google.maps.event.addListener(re, "dragend", x)), v && I(google.maps.event.addListener(re, "dragstart", v)), L && he(google.maps.event.addListener(re, "mousedown", L)), C && Ae(google.maps.event.addListener(re, "mouseout", C)), P && He(google.maps.event.addListener(re, "mouseover", P)), F && nt(google.maps.event.addListener(re, "mouseup", F)), B && we(google.maps.event.addListener(re, "rightclick", B)), E && lt(google.maps.event.addListener(re, "click", E)), M && ke(google.maps.event.addListener(re, "drag", M)), N && Fe(google.maps.event.addListener(re, "clickable_changed", N)), $ && ot(google.maps.event.addListener(re, "cursor_changed", $)), V && wt(google.maps.event.addListener(re, "animation_changed", V)), H && st(google.maps.event.addListener(re, "draggable_changed", H)), Z && Ct(google.maps.event.addListener(re, "flat_changed", Z)), K && pt(google.maps.event.addListener(re, "icon_changed", K)), Y && We(google.maps.event.addListener(re, "position_changed", Y)), Q && xt(google.maps.event.addListener(re, "shape_changed", Q)), J && Ht(google.maps.event.addListener(re, "title_changed", J)), _ && Wt(google.maps.event.addListener(re, "visible_changed", _)), D && kt(google.maps.event.addListener(re, "zindex_changed", D)), j(re), z && z(re), () => {
      U !== null && google.maps.event.removeListener(U), q !== null && google.maps.event.removeListener(q), X !== null && google.maps.event.removeListener(X), le !== null && google.maps.event.removeListener(le), oe !== null && google.maps.event.removeListener(oe), Ue !== null && google.maps.event.removeListener(Ue), Re !== null && google.maps.event.removeListener(Re), Ve !== null && google.maps.event.removeListener(Ve), et !== null && google.maps.event.removeListener(et), Qe !== null && google.maps.event.removeListener(Qe), Ie !== null && google.maps.event.removeListener(Ie), Ee !== null && google.maps.event.removeListener(Ee), it !== null && google.maps.event.removeListener(it), ut !== null && google.maps.event.removeListener(ut), ct !== null && google.maps.event.removeListener(ct), rt !== null && google.maps.event.removeListener(rt), gt !== null && google.maps.event.removeListener(gt), mt !== null && google.maps.event.removeListener(mt), vt !== null && google.maps.event.removeListener(vt), S && S(re), r ? r.removeMarker(re, !!o) : re && re.setMap(null);
    };
  }, []);
  var Un = ln(() => i ? at.map(i, (yt) => {
    if (!yi(yt))
      return yt;
    var re = yt;
    return bi(re, {
      anchor: O
    });
  }) : null, [i, O]);
  return Jo.jsx(Jo.Fragment, {
    children: Un
  }) || null;
}
me(L$e);
class _$e extends pe {
  constructor() {
    super(...arguments), Me(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this;
    return Kne(function* () {
      var n = hp(hp(hp({}, t.props.options || Cw), t.props.clusterer ? Cw : {
        map: t.context
      }), {}, {
        position: t.props.position
      });
      t.marker = new google.maps.Marker(n), t.props.clusterer ? t.props.clusterer.addMarker(t.marker, !!t.props.noClustererRedraw) : t.marker.setMap(t.context), t.registeredEvents = Cn({
        updaterMap: E9,
        eventMap: x9,
        prevProps: {},
        nextProps: t.props,
        instance: t.marker
      }), t.props.onLoad && t.props.onLoad(t.marker);
    })();
  }
  componentDidUpdate(t) {
    this.marker && (Pn(this.registeredEvents), this.registeredEvents = Cn({
      updaterMap: E9,
      eventMap: x9,
      prevProps: t,
      nextProps: this.props,
      instance: this.marker
    }));
  }
  componentWillUnmount() {
    this.marker && (this.props.onUnmount && this.props.onUnmount(this.marker), Pn(this.registeredEvents), this.props.clusterer ? this.props.clusterer.removeMarker(this.marker, !!this.props.noClustererRedraw) : this.marker && this.marker.setMap(null));
  }
  render() {
    var t = this.props.children ? at.map(this.props.children, (n) => {
      if (!yi(n))
        return n;
      var r = n;
      return bi(r, {
        anchor: this.marker
      });
    }) : null;
    return t || null;
  }
}
Me(_$e, "contextType", Ft);
var P$e = (
  /** @class */
  function() {
    function e(t, n) {
      t.getClusterer().extend(e, google.maps.OverlayView), this.cluster = t, this.clusterClassName = this.cluster.getClusterer().getClusterClass(), this.className = this.clusterClassName, this.styles = n, this.center = void 0, this.div = null, this.sums = null, this.visible = !1, this.boundsChangedListener = null, this.url = "", this.height = 0, this.width = 0, this.anchorText = [0, 0], this.anchorIcon = [0, 0], this.textColor = "black", this.textSize = 11, this.textDecoration = "none", this.fontWeight = "bold", this.fontStyle = "normal", this.fontFamily = "Arial,sans-serif", this.backgroundPosition = "0 0", this.cMouseDownInCluster = null, this.cDraggingMapByCluster = null, this.timeOut = null, this.setMap(t.getMap()), this.onBoundsChanged = this.onBoundsChanged.bind(this), this.onMouseDown = this.onMouseDown.bind(this), this.onClick = this.onClick.bind(this), this.onMouseOver = this.onMouseOver.bind(this), this.onMouseOut = this.onMouseOut.bind(this), this.onAdd = this.onAdd.bind(this), this.onRemove = this.onRemove.bind(this), this.draw = this.draw.bind(this), this.hide = this.hide.bind(this), this.show = this.show.bind(this), this.useStyle = this.useStyle.bind(this), this.setCenter = this.setCenter.bind(this), this.getPosFromLatLng = this.getPosFromLatLng.bind(this);
    }
    return e.prototype.onBoundsChanged = function() {
      this.cDraggingMapByCluster = this.cMouseDownInCluster;
    }, e.prototype.onMouseDown = function() {
      this.cMouseDownInCluster = !0, this.cDraggingMapByCluster = !1;
    }, e.prototype.onClick = function(t) {
      if (this.cMouseDownInCluster = !1, !this.cDraggingMapByCluster) {
        var n = this.cluster.getClusterer();
        if (google.maps.event.trigger(n, "click", this.cluster), google.maps.event.trigger(n, "clusterclick", this.cluster), n.getZoomOnClick()) {
          var r = n.getMaxZoom(), o = this.cluster.getBounds(), i = n.getMap();
          i !== null && "fitBounds" in i && i.fitBounds(o), this.timeOut = window.setTimeout(function() {
            var a = n.getMap();
            if (a !== null) {
              "fitBounds" in a && a.fitBounds(o);
              var s = a.getZoom() || 0;
              r !== null && s > r && a.setZoom(r + 1);
            }
          }, 100);
        }
        t.cancelBubble = !0, t.stopPropagation && t.stopPropagation();
      }
    }, e.prototype.onMouseOver = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseover", this.cluster);
    }, e.prototype.onMouseOut = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseout", this.cluster);
    }, e.prototype.onAdd = function() {
      var t;
      this.div = document.createElement("div"), this.div.className = this.className, this.visible && this.show(), (t = this.getPanes()) === null || t === void 0 || t.overlayMouseTarget.appendChild(this.div);
      var n = this.getMap();
      n !== null && (this.boundsChangedListener = google.maps.event.addListener(n, "bounds_changed", this.onBoundsChanged), this.div.addEventListener("mousedown", this.onMouseDown), this.div.addEventListener("click", this.onClick), this.div.addEventListener("mouseover", this.onMouseOver), this.div.addEventListener("mouseout", this.onMouseOut));
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.hide(), this.boundsChangedListener !== null && google.maps.event.removeListener(this.boundsChangedListener), this.div.removeEventListener("mousedown", this.onMouseDown), this.div.removeEventListener("click", this.onClick), this.div.removeEventListener("mouseover", this.onMouseOver), this.div.removeEventListener("mouseout", this.onMouseOut), this.div.parentNode.removeChild(this.div), this.timeOut !== null && (window.clearTimeout(this.timeOut), this.timeOut = null), this.div = null);
    }, e.prototype.draw = function() {
      if (this.visible && this.div !== null && this.center) {
        var t = this.getPosFromLatLng(this.center);
        this.div.style.top = t !== null ? "".concat(t.y, "px") : "0", this.div.style.left = t !== null ? "".concat(t.x, "px") : "0";
      }
    }, e.prototype.hide = function() {
      this.div && (this.div.style.display = "none"), this.visible = !1;
    }, e.prototype.show = function() {
      var t, n, r, o, i, a;
      if (this.div && this.center) {
        var s = this.sums === null || typeof this.sums.title > "u" || this.sums.title === "" ? this.cluster.getClusterer().getTitle() : this.sums.title, l = this.backgroundPosition.split(" "), u = parseInt(((t = l[0]) === null || t === void 0 ? void 0 : t.replace(/^\s+|\s+$/g, "")) || "0", 10), c = parseInt(((n = l[1]) === null || n === void 0 ? void 0 : n.replace(/^\s+|\s+$/g, "")) || "0", 10), p = this.getPosFromLatLng(this.center);
        this.div.className = this.className, this.div.setAttribute("style", "cursor: pointer; position: absolute; top: ".concat(p !== null ? "".concat(p.y, "px") : "0", "; left: ").concat(p !== null ? "".concat(p.x, "px") : "0", "; width: ").concat(this.width, "px; height: ").concat(this.height, "px; "));
        var d = document.createElement("img");
        d.alt = s, d.src = this.url, d.width = this.width, d.height = this.height, d.setAttribute("style", "position: absolute; top: ".concat(c, "px; left: ").concat(u, "px")), this.cluster.getClusterer().enableRetinaIcons || (d.style.clip = "rect(-".concat(c, "px, -").concat(u + this.width, "px, -").concat(c + this.height, ", -").concat(u, ")"));
        var g = document.createElement("div");
        g.setAttribute("style", "position: absolute; top: ".concat(this.anchorText[0], "px; left: ").concat(this.anchorText[1], "px; color: ").concat(this.textColor, "; font-size: ").concat(this.textSize, "px; font-family: ").concat(this.fontFamily, "; font-weight: ").concat(this.fontWeight, "; fontStyle: ").concat(this.fontStyle, "; text-decoration: ").concat(this.textDecoration, "; text-align: center; width: ").concat(this.width, "px; line-height: ").concat(this.height, "px")), !((r = this.sums) === null || r === void 0) && r.text && (g.innerText = "".concat((o = this.sums) === null || o === void 0 ? void 0 : o.text)), !((i = this.sums) === null || i === void 0) && i.html && (g.innerHTML = "".concat((a = this.sums) === null || a === void 0 ? void 0 : a.html)), this.div.innerHTML = "", this.div.appendChild(d), this.div.appendChild(g), this.div.title = s, this.div.style.display = "";
      }
      this.visible = !0;
    }, e.prototype.useStyle = function(t) {
      this.sums = t;
      var n = this.cluster.getClusterer().getStyles(), r = n[Math.min(n.length - 1, Math.max(0, t.index - 1))];
      r && (this.url = r.url, this.height = r.height, this.width = r.width, r.className && (this.className = "".concat(this.clusterClassName, " ").concat(r.className)), this.anchorText = r.anchorText || [0, 0], this.anchorIcon = r.anchorIcon || [this.height / 2, this.width / 2], this.textColor = r.textColor || "black", this.textSize = r.textSize || 11, this.textDecoration = r.textDecoration || "none", this.fontWeight = r.fontWeight || "bold", this.fontStyle = r.fontStyle || "normal", this.fontFamily = r.fontFamily || "Arial,sans-serif", this.backgroundPosition = r.backgroundPosition || "0 0");
    }, e.prototype.setCenter = function(t) {
      this.center = t;
    }, e.prototype.getPosFromLatLng = function(t) {
      var n = this.getProjection().fromLatLngToDivPixel(t);
      return n !== null && (n.x -= this.anchorIcon[1], n.y -= this.anchorIcon[0]), n;
    }, e;
  }()
), S$e = (
  /** @class */
  function() {
    function e(t) {
      this.markerClusterer = t, this.map = this.markerClusterer.getMap(), this.gridSize = this.markerClusterer.getGridSize(), this.minClusterSize = this.markerClusterer.getMinimumClusterSize(), this.averageCenter = this.markerClusterer.getAverageCenter(), this.markers = [], this.center = void 0, this.bounds = null, this.clusterIcon = new P$e(this, this.markerClusterer.getStyles()), this.getSize = this.getSize.bind(this), this.getMarkers = this.getMarkers.bind(this), this.getCenter = this.getCenter.bind(this), this.getMap = this.getMap.bind(this), this.getClusterer = this.getClusterer.bind(this), this.getBounds = this.getBounds.bind(this), this.remove = this.remove.bind(this), this.addMarker = this.addMarker.bind(this), this.isMarkerInClusterBounds = this.isMarkerInClusterBounds.bind(this), this.calculateBounds = this.calculateBounds.bind(this), this.updateIcon = this.updateIcon.bind(this), this.isMarkerAlreadyAdded = this.isMarkerAlreadyAdded.bind(this);
    }
    return e.prototype.getSize = function() {
      return this.markers.length;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getCenter = function() {
      return this.center;
    }, e.prototype.getMap = function() {
      return this.map;
    }, e.prototype.getClusterer = function() {
      return this.markerClusterer;
    }, e.prototype.getBounds = function() {
      for (var t = new google.maps.LatLngBounds(this.center, this.center), n = this.getMarkers(), r = 0, o = n; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && t.extend(a);
      }
      return t;
    }, e.prototype.remove = function() {
      this.clusterIcon.setMap(null), this.markers = [], delete this.markers;
    }, e.prototype.addMarker = function(t) {
      var n;
      if (this.isMarkerAlreadyAdded(t))
        return !1;
      if (this.center) {
        if (this.averageCenter) {
          var r = t.getPosition();
          if (r) {
            var o = this.markers.length + 1;
            this.center = new google.maps.LatLng((this.center.lat() * (o - 1) + r.lat()) / o, (this.center.lng() * (o - 1) + r.lng()) / o), this.calculateBounds();
          }
        }
      } else {
        var r = t.getPosition();
        r && (this.center = r, this.calculateBounds());
      }
      t.isAdded = !0, this.markers.push(t);
      var i = this.markers.length, a = this.markerClusterer.getMaxZoom(), s = (n = this.map) === null || n === void 0 ? void 0 : n.getZoom();
      if (a !== null && typeof s < "u" && s > a)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i < this.minClusterSize)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i === this.minClusterSize)
        for (var l = 0, u = this.markers; l < u.length; l++) {
          var c = u[l];
          c.setMap(null);
        }
      else
        t.setMap(null);
      return !0;
    }, e.prototype.isMarkerInClusterBounds = function(t) {
      if (this.bounds !== null) {
        var n = t.getPosition();
        if (n)
          return this.bounds.contains(n);
      }
      return !1;
    }, e.prototype.calculateBounds = function() {
      this.bounds = this.markerClusterer.getExtendedBounds(new google.maps.LatLngBounds(this.center, this.center));
    }, e.prototype.updateIcon = function() {
      var t, n = this.markers.length, r = this.markerClusterer.getMaxZoom(), o = (t = this.map) === null || t === void 0 ? void 0 : t.getZoom();
      if (r !== null && typeof o < "u" && o > r) {
        this.clusterIcon.hide();
        return;
      }
      if (n < this.minClusterSize) {
        this.clusterIcon.hide();
        return;
      }
      this.center && this.clusterIcon.setCenter(this.center), this.clusterIcon.useStyle(this.markerClusterer.getCalculator()(this.markers, this.markerClusterer.getStyles().length)), this.clusterIcon.show();
    }, e.prototype.isMarkerAlreadyAdded = function(t) {
      if (this.markers.includes)
        return this.markers.includes(t);
      for (var n = 0; n < this.markers.length; n++)
        if (t === this.markers[n])
          return !0;
      return !1;
    }, e;
  }()
);
function M$e(e, t) {
  var n = e.length, r = n.toString().length, o = Math.min(r, t);
  return {
    text: n.toString(),
    index: o,
    title: ""
  };
}
var D$e = 2e3, T$e = 500, j$e = "https://developers.google.com/maps/documentation/javascript/examples/markerclusterer/m", A$e = "png", R$e = [53, 56, 66, 78, 90], I$e = "cluster", ere = (
  /** @class */
  function() {
    function e(t, n, r) {
      n === void 0 && (n = []), r === void 0 && (r = {}), this.getMinimumClusterSize = this.getMinimumClusterSize.bind(this), this.setMinimumClusterSize = this.setMinimumClusterSize.bind(this), this.getEnableRetinaIcons = this.getEnableRetinaIcons.bind(this), this.setEnableRetinaIcons = this.setEnableRetinaIcons.bind(this), this.addToClosestCluster = this.addToClosestCluster.bind(this), this.getImageExtension = this.getImageExtension.bind(this), this.setImageExtension = this.setImageExtension.bind(this), this.getExtendedBounds = this.getExtendedBounds.bind(this), this.getAverageCenter = this.getAverageCenter.bind(this), this.setAverageCenter = this.setAverageCenter.bind(this), this.getTotalClusters = this.getTotalClusters.bind(this), this.fitMapToMarkers = this.fitMapToMarkers.bind(this), this.getIgnoreHidden = this.getIgnoreHidden.bind(this), this.setIgnoreHidden = this.setIgnoreHidden.bind(this), this.getClusterClass = this.getClusterClass.bind(this), this.setClusterClass = this.setClusterClass.bind(this), this.getTotalMarkers = this.getTotalMarkers.bind(this), this.getZoomOnClick = this.getZoomOnClick.bind(this), this.setZoomOnClick = this.setZoomOnClick.bind(this), this.getBatchSizeIE = this.getBatchSizeIE.bind(this), this.setBatchSizeIE = this.setBatchSizeIE.bind(this), this.createClusters = this.createClusters.bind(this), this.onZoomChanged = this.onZoomChanged.bind(this), this.getImageSizes = this.getImageSizes.bind(this), this.setImageSizes = this.setImageSizes.bind(this), this.getCalculator = this.getCalculator.bind(this), this.setCalculator = this.setCalculator.bind(this), this.removeMarkers = this.removeMarkers.bind(this), this.resetViewport = this.resetViewport.bind(this), this.getImagePath = this.getImagePath.bind(this), this.setImagePath = this.setImagePath.bind(this), this.pushMarkerTo = this.pushMarkerTo.bind(this), this.removeMarker = this.removeMarker.bind(this), this.clearMarkers = this.clearMarkers.bind(this), this.setupStyles = this.setupStyles.bind(this), this.getGridSize = this.getGridSize.bind(this), this.setGridSize = this.setGridSize.bind(this), this.getClusters = this.getClusters.bind(this), this.getMaxZoom = this.getMaxZoom.bind(this), this.setMaxZoom = this.setMaxZoom.bind(this), this.getMarkers = this.getMarkers.bind(this), this.addMarkers = this.addMarkers.bind(this), this.getStyles = this.getStyles.bind(this), this.setStyles = this.setStyles.bind(this), this.addMarker = this.addMarker.bind(this), this.onRemove = this.onRemove.bind(this), this.getTitle = this.getTitle.bind(this), this.setTitle = this.setTitle.bind(this), this.repaint = this.repaint.bind(this), this.onIdle = this.onIdle.bind(this), this.redraw = this.redraw.bind(this), this.onAdd = this.onAdd.bind(this), this.draw = this.draw.bind(this), this.extend = this.extend.bind(this), this.extend(e, google.maps.OverlayView), this.markers = [], this.clusters = [], this.listeners = [], this.activeMap = null, this.ready = !1, this.gridSize = r.gridSize || 60, this.minClusterSize = r.minimumClusterSize || 2, this.maxZoom = r.maxZoom || null, this.styles = r.styles || [], this.title = r.title || "", this.zoomOnClick = !0, r.zoomOnClick !== void 0 && (this.zoomOnClick = r.zoomOnClick), this.averageCenter = !1, r.averageCenter !== void 0 && (this.averageCenter = r.averageCenter), this.ignoreHidden = !1, r.ignoreHidden !== void 0 && (this.ignoreHidden = r.ignoreHidden), this.enableRetinaIcons = !1, r.enableRetinaIcons !== void 0 && (this.enableRetinaIcons = r.enableRetinaIcons), this.imagePath = r.imagePath || j$e, this.imageExtension = r.imageExtension || A$e, this.imageSizes = r.imageSizes || R$e, this.calculator = r.calculator || M$e, this.batchSize = r.batchSize || D$e, this.batchSizeIE = r.batchSizeIE || T$e, this.clusterClass = r.clusterClass || I$e, navigator.userAgent.toLowerCase().indexOf("msie") !== -1 && (this.batchSize = this.batchSizeIE), this.timerRefStatic = null, this.setupStyles(), this.addMarkers(n, !0), this.setMap(t);
    }
    return e.prototype.onZoomChanged = function() {
      var t, n;
      this.resetViewport(!1), (((t = this.getMap()) === null || t === void 0 ? void 0 : t.getZoom()) === (this.get("minZoom") || 0) || ((n = this.getMap()) === null || n === void 0 ? void 0 : n.getZoom()) === this.get("maxZoom")) && google.maps.event.trigger(this, "idle");
    }, e.prototype.onIdle = function() {
      this.redraw();
    }, e.prototype.onAdd = function() {
      var t = this.getMap();
      this.activeMap = t, this.ready = !0, this.repaint(), t !== null && (this.listeners = [google.maps.event.addListener(t, "zoom_changed", this.onZoomChanged), google.maps.event.addListener(t, "idle", this.onIdle)]);
    }, e.prototype.onRemove = function() {
      for (var t = 0, n = this.markers; t < n.length; t++) {
        var r = n[t];
        r.getMap() !== this.activeMap && r.setMap(this.activeMap);
      }
      for (var o = 0, i = this.clusters; o < i.length; o++) {
        var a = i[o];
        a.remove();
      }
      this.clusters = [];
      for (var s = 0, l = this.listeners; s < l.length; s++) {
        var u = l[s];
        google.maps.event.removeListener(u);
      }
      this.listeners = [], this.activeMap = null, this.ready = !1;
    }, e.prototype.draw = function() {
    }, e.prototype.getMap = function() {
      return null;
    }, e.prototype.getPanes = function() {
      return null;
    }, e.prototype.getProjection = function() {
      return {
        fromContainerPixelToLatLng: function() {
          return null;
        },
        fromDivPixelToLatLng: function() {
          return null;
        },
        fromLatLngToContainerPixel: function() {
          return null;
        },
        fromLatLngToDivPixel: function() {
          return null;
        },
        getVisibleRegion: function() {
          return null;
        },
        getWorldWidth: function() {
          return 0;
        }
      };
    }, e.prototype.setMap = function() {
    }, e.prototype.addListener = function() {
      return {
        remove: function() {
        }
      };
    }, e.prototype.bindTo = function() {
    }, e.prototype.get = function() {
    }, e.prototype.notify = function() {
    }, e.prototype.set = function() {
    }, e.prototype.setValues = function() {
    }, e.prototype.unbind = function() {
    }, e.prototype.unbindAll = function() {
    }, e.prototype.setupStyles = function() {
      if (!(this.styles.length > 0))
        for (var t = 0; t < this.imageSizes.length; t++)
          this.styles.push({
            url: "".concat(this.imagePath + (t + 1), ".").concat(this.imageExtension),
            height: this.imageSizes[t] || 0,
            width: this.imageSizes[t] || 0
          });
    }, e.prototype.fitMapToMarkers = function() {
      for (var t = this.getMarkers(), n = new google.maps.LatLngBounds(), r = 0, o = t; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && n.extend(a);
      }
      var s = this.getMap();
      s !== null && "fitBounds" in s && s.fitBounds(n);
    }, e.prototype.getGridSize = function() {
      return this.gridSize;
    }, e.prototype.setGridSize = function(t) {
      this.gridSize = t;
    }, e.prototype.getMinimumClusterSize = function() {
      return this.minClusterSize;
    }, e.prototype.setMinimumClusterSize = function(t) {
      this.minClusterSize = t;
    }, e.prototype.getMaxZoom = function() {
      return this.maxZoom;
    }, e.prototype.setMaxZoom = function(t) {
      this.maxZoom = t;
    }, e.prototype.getStyles = function() {
      return this.styles;
    }, e.prototype.setStyles = function(t) {
      this.styles = t;
    }, e.prototype.getTitle = function() {
      return this.title;
    }, e.prototype.setTitle = function(t) {
      this.title = t;
    }, e.prototype.getZoomOnClick = function() {
      return this.zoomOnClick;
    }, e.prototype.setZoomOnClick = function(t) {
      this.zoomOnClick = t;
    }, e.prototype.getAverageCenter = function() {
      return this.averageCenter;
    }, e.prototype.setAverageCenter = function(t) {
      this.averageCenter = t;
    }, e.prototype.getIgnoreHidden = function() {
      return this.ignoreHidden;
    }, e.prototype.setIgnoreHidden = function(t) {
      this.ignoreHidden = t;
    }, e.prototype.getEnableRetinaIcons = function() {
      return this.enableRetinaIcons;
    }, e.prototype.setEnableRetinaIcons = function(t) {
      this.enableRetinaIcons = t;
    }, e.prototype.getImageExtension = function() {
      return this.imageExtension;
    }, e.prototype.setImageExtension = function(t) {
      this.imageExtension = t;
    }, e.prototype.getImagePath = function() {
      return this.imagePath;
    }, e.prototype.setImagePath = function(t) {
      this.imagePath = t;
    }, e.prototype.getImageSizes = function() {
      return this.imageSizes;
    }, e.prototype.setImageSizes = function(t) {
      this.imageSizes = t;
    }, e.prototype.getCalculator = function() {
      return this.calculator;
    }, e.prototype.setCalculator = function(t) {
      this.calculator = t;
    }, e.prototype.getBatchSizeIE = function() {
      return this.batchSizeIE;
    }, e.prototype.setBatchSizeIE = function(t) {
      this.batchSizeIE = t;
    }, e.prototype.getClusterClass = function() {
      return this.clusterClass;
    }, e.prototype.setClusterClass = function(t) {
      this.clusterClass = t;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getTotalMarkers = function() {
      return this.markers.length;
    }, e.prototype.getClusters = function() {
      return this.clusters;
    }, e.prototype.getTotalClusters = function() {
      return this.clusters.length;
    }, e.prototype.addMarker = function(t, n) {
      this.pushMarkerTo(t), n || this.redraw();
    }, e.prototype.addMarkers = function(t, n) {
      for (var r in t)
        if (Object.prototype.hasOwnProperty.call(t, r)) {
          var o = t[r];
          o && this.pushMarkerTo(o);
        }
      n || this.redraw();
    }, e.prototype.pushMarkerTo = function(t) {
      var n = this;
      t.getDraggable() && google.maps.event.addListener(t, "dragend", function() {
        n.ready && (t.isAdded = !1, n.repaint());
      }), t.isAdded = !1, this.markers.push(t);
    }, e.prototype.removeMarker_ = function(t) {
      var n = -1;
      if (this.markers.indexOf)
        n = this.markers.indexOf(t);
      else
        for (var r = 0; r < this.markers.length; r++)
          if (t === this.markers[r]) {
            n = r;
            break;
          }
      return n === -1 ? !1 : (t.setMap(null), this.markers.splice(n, 1), !0);
    }, e.prototype.removeMarker = function(t, n) {
      var r = this.removeMarker_(t);
      return !n && r && this.repaint(), r;
    }, e.prototype.removeMarkers = function(t, n) {
      for (var r = !1, o = 0, i = t; o < i.length; o++) {
        var a = i[o];
        r = r || this.removeMarker_(a);
      }
      return !n && r && this.repaint(), r;
    }, e.prototype.clearMarkers = function() {
      this.resetViewport(!0), this.markers = [];
    }, e.prototype.repaint = function() {
      var t = this.clusters.slice();
      this.clusters = [], this.resetViewport(!1), this.redraw(), setTimeout(function() {
        for (var n = 0, r = t; n < r.length; n++) {
          var o = r[n];
          o.remove();
        }
      }, 0);
    }, e.prototype.getExtendedBounds = function(t) {
      var n = this.getProjection(), r = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getNorthEast().lat(), t.getNorthEast().lng())
      );
      r !== null && (r.x += this.gridSize, r.y -= this.gridSize);
      var o = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getSouthWest().lat(), t.getSouthWest().lng())
      );
      if (o !== null && (o.x -= this.gridSize, o.y += this.gridSize), r !== null) {
        var i = n.fromDivPixelToLatLng(r);
        i !== null && t.extend(i);
      }
      if (o !== null) {
        var a = n.fromDivPixelToLatLng(o);
        a !== null && t.extend(a);
      }
      return t;
    }, e.prototype.redraw = function() {
      this.createClusters(0);
    }, e.prototype.resetViewport = function(t) {
      for (var n = 0, r = this.clusters; n < r.length; n++) {
        var o = r[n];
        o.remove();
      }
      this.clusters = [];
      for (var i = 0, a = this.markers; i < a.length; i++) {
        var s = a[i];
        s.isAdded = !1, t && s.setMap(null);
      }
    }, e.prototype.distanceBetweenPoints = function(t, n) {
      var r = 6371, o = (n.lat() - t.lat()) * Math.PI / 180, i = (n.lng() - t.lng()) * Math.PI / 180, a = Math.sin(o / 2) * Math.sin(o / 2) + Math.cos(t.lat() * Math.PI / 180) * Math.cos(n.lat() * Math.PI / 180) * Math.sin(i / 2) * Math.sin(i / 2);
      return r * (2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)));
    }, e.prototype.isMarkerInBounds = function(t, n) {
      var r = t.getPosition();
      return r ? n.contains(r) : !1;
    }, e.prototype.addToClosestCluster = function(t) {
      for (var n, r = 4e4, o = null, i = 0, a = this.clusters; i < a.length; i++) {
        var s = a[i];
        n = s;
        var l = n.getCenter(), u = t.getPosition();
        if (l && u) {
          var c = this.distanceBetweenPoints(l, u);
          c < r && (r = c, o = n);
        }
      }
      o && o.isMarkerInClusterBounds(t) ? o.addMarker(t) : (n = new S$e(this), n.addMarker(t), this.clusters.push(n));
    }, e.prototype.createClusters = function(t) {
      var n = this;
      if (this.ready) {
        t === 0 && (google.maps.event.trigger(this, "clusteringbegin", this), this.timerRefStatic !== null && (window.clearTimeout(this.timerRefStatic), delete this.timerRefStatic));
        for (var r = this.getMap(), o = r !== null && ("getBounds" in r) ? r.getBounds() : null, i = (r == null ? void 0 : r.getZoom()) || 0, a = i > 3 ? new google.maps.LatLngBounds(o == null ? void 0 : o.getSouthWest(), o == null ? void 0 : o.getNorthEast()) : new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625)), s = this.getExtendedBounds(a), l = Math.min(t + this.batchSize, this.markers.length), u = t; u < l; u++) {
          var c = this.markers[u];
          c && !c.isAdded && this.isMarkerInBounds(c, s) && (!this.ignoreHidden || this.ignoreHidden && c.getVisible()) && this.addToClosestCluster(c);
        }
        if (l < this.markers.length)
          this.timerRefStatic = window.setTimeout(function() {
            n.createClusters(l);
          }, 0);
        else {
          this.timerRefStatic = null, google.maps.event.trigger(this, "clusteringend", this);
          for (var p = 0, d = this.clusters; p < d.length; p++) {
            var g = d[p];
            g.updateIcon();
          }
        }
      }
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype) {
          var i = o;
          this.prototype[i] = r.prototype[i];
        }
        return this;
      }).apply(t, [n]);
    }, e;
  }()
);
function k9(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function N$e(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? k9(Object(n), !0).forEach(function(r) {
      Me(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : k9(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Bs = {
  onClick: "click",
  onClusteringBegin: "clusteringbegin",
  onClusteringEnd: "clusteringend",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover"
}, Rn = {
  averageCenter(e, t) {
    e.setAverageCenter(t);
  },
  batchSizeIE(e, t) {
    e.setBatchSizeIE(t);
  },
  calculator(e, t) {
    e.setCalculator(t);
  },
  clusterClass(e, t) {
    e.setClusterClass(t);
  },
  enableRetinaIcons(e, t) {
    e.setEnableRetinaIcons(t);
  },
  gridSize(e, t) {
    e.setGridSize(t);
  },
  ignoreHidden(e, t) {
    e.setIgnoreHidden(t);
  },
  imageExtension(e, t) {
    e.setImageExtension(t);
  },
  imagePath(e, t) {
    e.setImagePath(t);
  },
  imageSizes(e, t) {
    e.setImageSizes(t);
  },
  maxZoom(e, t) {
    e.setMaxZoom(t);
  },
  minimumClusterSize(e, t) {
    e.setMinimumClusterSize(t);
  },
  styles(e, t) {
    e.setStyles(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  zoomOnClick(e, t) {
    e.setZoomOnClick(t);
  }
}, B$e = {};
function F$e(e) {
  var {
    children: t,
    options: n,
    averageCenter: r,
    batchSizeIE: o,
    calculator: i,
    clusterClass: a,
    enableRetinaIcons: s,
    gridSize: l,
    ignoreHidden: u,
    imageExtension: c,
    imagePath: p,
    imageSizes: d,
    maxZoom: g,
    minimumClusterSize: f,
    styles: m,
    title: b,
    zoomOnClick: E,
    onClick: w,
    onClusteringBegin: M,
    onClusteringEnd: x,
    onMouseOver: v,
    onMouseOut: C,
    onLoad: P,
    onUnmount: F
  } = e, [L, B] = k(null), N = ge(Ft), [$, V] = k(null), [H, Z] = k(null), [K, Y] = k(null), [Q, J] = k(null), [_, D] = k(null);
  return h(() => {
    L && C && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(L, Bs.onMouseOut, C)));
  }, [C]), h(() => {
    L && v && (_ !== null && google.maps.event.removeListener(_), D(google.maps.event.addListener(L, Bs.onMouseOver, v)));
  }, [v]), h(() => {
    L && w && ($ !== null && google.maps.event.removeListener($), V(google.maps.event.addListener(L, Bs.onClick, w)));
  }, [w]), h(() => {
    L && M && (H !== null && google.maps.event.removeListener(H), Z(google.maps.event.addListener(L, Bs.onClusteringBegin, M)));
  }, [M]), h(() => {
    L && x && (K !== null && google.maps.event.removeListener(K), Z(google.maps.event.addListener(L, Bs.onClusteringEnd, x)));
  }, [x]), h(() => {
    typeof r < "u" && L !== null && Rn.averageCenter(L, r);
  }, [L, r]), h(() => {
    typeof o < "u" && L !== null && Rn.batchSizeIE(L, o);
  }, [L, o]), h(() => {
    typeof i < "u" && L !== null && Rn.calculator(L, i);
  }, [L, i]), h(() => {
    typeof a < "u" && L !== null && Rn.clusterClass(L, a);
  }, [L, a]), h(() => {
    typeof s < "u" && L !== null && Rn.enableRetinaIcons(L, s);
  }, [L, s]), h(() => {
    typeof l < "u" && L !== null && Rn.gridSize(L, l);
  }, [L, l]), h(() => {
    typeof u < "u" && L !== null && Rn.ignoreHidden(L, u);
  }, [L, u]), h(() => {
    typeof c < "u" && L !== null && Rn.imageExtension(L, c);
  }, [L, c]), h(() => {
    typeof p < "u" && L !== null && Rn.imagePath(L, p);
  }, [L, p]), h(() => {
    typeof d < "u" && L !== null && Rn.imageSizes(L, d);
  }, [L, d]), h(() => {
    typeof g < "u" && L !== null && Rn.maxZoom(L, g);
  }, [L, g]), h(() => {
    typeof f < "u" && L !== null && Rn.minimumClusterSize(L, f);
  }, [L, f]), h(() => {
    typeof m < "u" && L !== null && Rn.styles(L, m);
  }, [L, m]), h(() => {
    typeof b < "u" && L !== null && Rn.title(L, b);
  }, [L, b]), h(() => {
    typeof E < "u" && L !== null && Rn.zoomOnClick(L, E);
  }, [L, E]), h(() => {
    if (N) {
      var z = N$e({}, n || B$e), S = new ere(N, [], z);
      return r && Rn.averageCenter(S, r), o && Rn.batchSizeIE(S, o), i && Rn.calculator(S, i), a && Rn.clusterClass(S, a), s && Rn.enableRetinaIcons(S, s), l && Rn.gridSize(S, l), u && Rn.ignoreHidden(S, u), c && Rn.imageExtension(S, c), p && Rn.imagePath(S, p), d && Rn.imageSizes(S, d), g && Rn.maxZoom(S, g), f && Rn.minimumClusterSize(S, f), m && Rn.styles(S, m), b && Rn.title(S, b), E && Rn.zoomOnClick(S, E), C && J(google.maps.event.addListener(S, Bs.onMouseOut, C)), v && D(google.maps.event.addListener(S, Bs.onMouseOver, v)), w && V(google.maps.event.addListener(S, Bs.onClick, w)), M && Z(google.maps.event.addListener(S, Bs.onClusteringBegin, M)), x && Y(google.maps.event.addListener(S, Bs.onClusteringEnd, x)), B(S), P && P(S), () => {
        Q !== null && google.maps.event.removeListener(Q), _ !== null && google.maps.event.removeListener(_), $ !== null && google.maps.event.removeListener($), H !== null && google.maps.event.removeListener(H), K !== null && google.maps.event.removeListener(K), F && F(S);
      };
    }
  }, []), L !== null && t(L) || null;
}
me(F$e);
class z$e extends pe {
  constructor() {
    super(...arguments), Me(this, "registeredEvents", []), Me(this, "state", {
      markerClusterer: null
    }), Me(this, "setClustererCallback", () => {
      this.state.markerClusterer !== null && this.props.onLoad && this.props.onLoad(this.state.markerClusterer);
    });
  }
  componentDidMount() {
    if (this.context) {
      var t = new ere(this.context, [], this.props.options);
      this.registeredEvents = Cn({
        updaterMap: Rn,
        eventMap: Bs,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        markerClusterer: t
      }), this.setClustererCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.markerClusterer && (Pn(this.registeredEvents), this.registeredEvents = Cn({
      updaterMap: Rn,
      eventMap: Bs,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.markerClusterer
    }));
  }
  componentWillUnmount() {
    this.state.markerClusterer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.markerClusterer), Pn(this.registeredEvents), this.state.markerClusterer.setMap(null));
  }
  render() {
    return this.state.markerClusterer !== null ? this.props.children(this.state.markerClusterer) : null;
  }
}
Me(z$e, "contextType", Ft);
function L9(e) {
  e.cancelBubble = !0, e.stopPropagation && e.stopPropagation();
}
var tre = (
  /** @class */
  function() {
    function e(t) {
      t === void 0 && (t = {}), this.getCloseClickHandler = this.getCloseClickHandler.bind(this), this.closeClickHandler = this.closeClickHandler.bind(this), this.createInfoBoxDiv = this.createInfoBoxDiv.bind(this), this.addClickHandler = this.addClickHandler.bind(this), this.getCloseBoxImg = this.getCloseBoxImg.bind(this), this.getBoxWidths = this.getBoxWidths.bind(this), this.setBoxStyle = this.setBoxStyle.bind(this), this.setPosition = this.setPosition.bind(this), this.getPosition = this.getPosition.bind(this), this.setOptions = this.setOptions.bind(this), this.setContent = this.setContent.bind(this), this.setVisible = this.setVisible.bind(this), this.getContent = this.getContent.bind(this), this.getVisible = this.getVisible.bind(this), this.setZIndex = this.setZIndex.bind(this), this.getZIndex = this.getZIndex.bind(this), this.onRemove = this.onRemove.bind(this), this.panBox = this.panBox.bind(this), this.extend = this.extend.bind(this), this.close = this.close.bind(this), this.draw = this.draw.bind(this), this.show = this.show.bind(this), this.hide = this.hide.bind(this), this.open = this.open.bind(this), this.extend(e, google.maps.OverlayView), this.content = t.content || "", this.disableAutoPan = t.disableAutoPan || !1, this.maxWidth = t.maxWidth || 0, this.pixelOffset = t.pixelOffset || new google.maps.Size(0, 0), this.position = t.position || new google.maps.LatLng(0, 0), this.zIndex = t.zIndex || null, this.boxClass = t.boxClass || "infoBox", this.boxStyle = t.boxStyle || {}, this.closeBoxMargin = t.closeBoxMargin || "2px", this.closeBoxURL = t.closeBoxURL || "http://www.google.com/intl/en_us/mapfiles/close.gif", t.closeBoxURL === "" && (this.closeBoxURL = ""), this.infoBoxClearance = t.infoBoxClearance || new google.maps.Size(1, 1), typeof t.visible > "u" && (typeof t.isHidden > "u" ? t.visible = !0 : t.visible = !t.isHidden), this.isHidden = !t.visible, this.alignBottom = t.alignBottom || !1, this.pane = t.pane || "floatPane", this.enableEventPropagation = t.enableEventPropagation || !1, this.div = null, this.closeListener = null, this.moveListener = null, this.mapListener = null, this.contextListener = null, this.eventListeners = null, this.fixedWidthSet = null;
    }
    return e.prototype.createInfoBoxDiv = function() {
      var t = this, n = function(u) {
        u.returnValue = !1, u.preventDefault && u.preventDefault(), t.enableEventPropagation || L9(u);
      };
      if (!this.div) {
        this.div = document.createElement("div"), this.setBoxStyle(), typeof this.content == "string" ? this.div.innerHTML = this.getCloseBoxImg() + this.content : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(this.content));
        var r = this.getPanes();
        if (r !== null && r[this.pane].appendChild(this.div), this.addClickHandler(), this.div.style.width)
          this.fixedWidthSet = !0;
        else if (this.maxWidth !== 0 && this.div.offsetWidth > this.maxWidth)
          this.div.style.width = this.maxWidth + "px", this.fixedWidthSet = !0;
        else {
          var o = this.getBoxWidths();
          this.div.style.width = this.div.offsetWidth - o.left - o.right + "px", this.fixedWidthSet = !1;
        }
        if (this.panBox(this.disableAutoPan), !this.enableEventPropagation) {
          this.eventListeners = [];
          for (var i = ["mousedown", "mouseover", "mouseout", "mouseup", "click", "dblclick", "touchstart", "touchend", "touchmove"], a = 0, s = i; a < s.length; a++) {
            var l = s[a];
            this.eventListeners.push(google.maps.event.addListener(this.div, l, L9));
          }
          this.eventListeners.push(google.maps.event.addListener(this.div, "mouseover", function() {
            t.div && (t.div.style.cursor = "default");
          }));
        }
        this.contextListener = google.maps.event.addListener(this.div, "contextmenu", n), google.maps.event.trigger(this, "domready");
      }
    }, e.prototype.getCloseBoxImg = function() {
      var t = "";
      return this.closeBoxURL !== "" && (t = '<img alt=""', t += ' aria-hidden="true"', t += " src='" + this.closeBoxURL + "'", t += " align=right", t += " style='", t += " position: relative;", t += " cursor: pointer;", t += " margin: " + this.closeBoxMargin + ";", t += "'>"), t;
    }, e.prototype.addClickHandler = function() {
      this.closeListener = this.div && this.div.firstChild && this.closeBoxURL !== "" ? google.maps.event.addListener(this.div.firstChild, "click", this.getCloseClickHandler()) : null;
    }, e.prototype.closeClickHandler = function(t) {
      t.cancelBubble = !0, t.stopPropagation && t.stopPropagation(), google.maps.event.trigger(this, "closeclick"), this.close();
    }, e.prototype.getCloseClickHandler = function() {
      return this.closeClickHandler;
    }, e.prototype.panBox = function(t) {
      if (this.div && !t) {
        var n = this.getMap();
        if (n instanceof google.maps.Map) {
          var r = 0, o = 0, i = n.getBounds();
          i && !i.contains(this.position) && n.setCenter(this.position);
          var a = n.getDiv(), s = a.offsetWidth, l = a.offsetHeight, u = this.pixelOffset.width, c = this.pixelOffset.height, p = this.div.offsetWidth, d = this.div.offsetHeight, g = this.infoBoxClearance.width, f = this.infoBoxClearance.height, m = this.getProjection(), b = m.fromLatLngToContainerPixel(this.position);
          b !== null && (b.x < -u + g ? r = b.x + u - g : b.x + p + u + g > s && (r = b.x + p + u + g - s), this.alignBottom ? b.y < -c + f + d ? o = b.y + c - f - d : b.y + c + f > l && (o = b.y + c + f - l) : b.y < -c + f ? o = b.y + c - f : b.y + d + c + f > l && (o = b.y + d + c + f - l)), r === 0 && o === 0 || n.panBy(r, o);
        }
      }
    }, e.prototype.setBoxStyle = function() {
      if (this.div) {
        this.div.className = this.boxClass, this.div.style.cssText = "";
        var t = this.boxStyle;
        for (var n in t)
          Object.prototype.hasOwnProperty.call(t, n) && (this.div.style[n] = t[n]);
        if (this.div.style.webkitTransform = "translateZ(0)", typeof this.div.style.opacity < "u" && this.div.style.opacity !== "") {
          var r = parseFloat(this.div.style.opacity || "");
          this.div.style.msFilter = '"progid:DXImageTransform.Microsoft.Alpha(Opacity=' + r * 100 + ')"', this.div.style.filter = "alpha(opacity=" + r * 100 + ")";
        }
        this.div.style.position = "absolute", this.div.style.visibility = "hidden", this.zIndex !== null && (this.div.style.zIndex = this.zIndex + ""), this.div.style.overflow || (this.div.style.overflow = "auto");
      }
    }, e.prototype.getBoxWidths = function() {
      var t = {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0
      };
      if (!this.div)
        return t;
      if (document.defaultView) {
        var n = this.div.ownerDocument, r = n && n.defaultView ? n.defaultView.getComputedStyle(this.div, "") : null;
        r && (t.top = parseInt(r.borderTopWidth || "", 10) || 0, t.bottom = parseInt(r.borderBottomWidth || "", 10) || 0, t.left = parseInt(r.borderLeftWidth || "", 10) || 0, t.right = parseInt(r.borderRightWidth || "", 10) || 0);
      } else if (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        document.documentElement.currentStyle
      ) {
        var o = this.div.currentStyle;
        o && (t.top = parseInt(o.borderTopWidth || "", 10) || 0, t.bottom = parseInt(o.borderBottomWidth || "", 10) || 0, t.left = parseInt(o.borderLeftWidth || "", 10) || 0, t.right = parseInt(o.borderRightWidth || "", 10) || 0);
      }
      return t;
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.div.parentNode.removeChild(this.div), this.div = null);
    }, e.prototype.draw = function() {
      if (this.createInfoBoxDiv(), this.div) {
        var t = this.getProjection(), n = t.fromLatLngToDivPixel(this.position);
        n !== null && (this.div.style.left = n.x + this.pixelOffset.width + "px", this.alignBottom ? this.div.style.bottom = -(n.y + this.pixelOffset.height) + "px" : this.div.style.top = n.y + this.pixelOffset.height + "px"), this.isHidden ? this.div.style.visibility = "hidden" : this.div.style.visibility = "visible";
      }
    }, e.prototype.setOptions = function(t) {
      t === void 0 && (t = {}), typeof t.boxClass < "u" && (this.boxClass = t.boxClass, this.setBoxStyle()), typeof t.boxStyle < "u" && (this.boxStyle = t.boxStyle, this.setBoxStyle()), typeof t.content < "u" && this.setContent(t.content), typeof t.disableAutoPan < "u" && (this.disableAutoPan = t.disableAutoPan), typeof t.maxWidth < "u" && (this.maxWidth = t.maxWidth), typeof t.pixelOffset < "u" && (this.pixelOffset = t.pixelOffset), typeof t.alignBottom < "u" && (this.alignBottom = t.alignBottom), typeof t.position < "u" && this.setPosition(t.position), typeof t.zIndex < "u" && this.setZIndex(t.zIndex), typeof t.closeBoxMargin < "u" && (this.closeBoxMargin = t.closeBoxMargin), typeof t.closeBoxURL < "u" && (this.closeBoxURL = t.closeBoxURL), typeof t.infoBoxClearance < "u" && (this.infoBoxClearance = t.infoBoxClearance), typeof t.isHidden < "u" && (this.isHidden = t.isHidden), typeof t.visible < "u" && (this.isHidden = !t.visible), typeof t.enableEventPropagation < "u" && (this.enableEventPropagation = t.enableEventPropagation), this.div && this.draw();
    }, e.prototype.setContent = function(t) {
      this.content = t, this.div && (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.fixedWidthSet || (this.div.style.width = ""), typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t)), this.fixedWidthSet || (this.div.style.width = this.div.offsetWidth + "px", typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t))), this.addClickHandler()), google.maps.event.trigger(this, "content_changed");
    }, e.prototype.setPosition = function(t) {
      this.position = t, this.div && this.draw(), google.maps.event.trigger(this, "position_changed");
    }, e.prototype.setVisible = function(t) {
      this.isHidden = !t, this.div && (this.div.style.visibility = this.isHidden ? "hidden" : "visible");
    }, e.prototype.setZIndex = function(t) {
      this.zIndex = t, this.div && (this.div.style.zIndex = t + ""), google.maps.event.trigger(this, "zindex_changed");
    }, e.prototype.getContent = function() {
      return this.content;
    }, e.prototype.getPosition = function() {
      return this.position;
    }, e.prototype.getZIndex = function() {
      return this.zIndex;
    }, e.prototype.getVisible = function() {
      var t = this.getMap();
      return typeof t > "u" || t === null ? !1 : !this.isHidden;
    }, e.prototype.show = function() {
      this.isHidden = !1, this.div && (this.div.style.visibility = "visible");
    }, e.prototype.hide = function() {
      this.isHidden = !0, this.div && (this.div.style.visibility = "hidden");
    }, e.prototype.open = function(t, n) {
      var r = this;
      n && (this.position = n.getPosition(), this.moveListener = google.maps.event.addListener(n, "position_changed", function() {
        var o = n.getPosition();
        r.setPosition(o);
      }), this.mapListener = google.maps.event.addListener(n, "map_changed", function() {
        r.setMap(n.map);
      })), this.setMap(t), this.div && this.panBox();
    }, e.prototype.close = function() {
      if (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.eventListeners) {
        for (var t = 0, n = this.eventListeners; t < n.length; t++) {
          var r = n[t];
          google.maps.event.removeListener(r);
        }
        this.eventListeners = null;
      }
      this.moveListener && (google.maps.event.removeListener(this.moveListener), this.moveListener = null), this.mapListener && (google.maps.event.removeListener(this.mapListener), this.mapListener = null), this.contextListener && (google.maps.event.removeListener(this.contextListener), this.contextListener = null), this.setMap(null);
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype)
          Object.prototype.hasOwnProperty.call(this, o) || (this.prototype[o] = r.prototype[o]);
        return this;
      }).apply(t, [n]);
    }, e;
  }()
), U$e = ["position"], H$e = ["position"];
function _9(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Ow(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? _9(Object(n), !0).forEach(function(r) {
      Me(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : _9(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var P9 = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, S9 = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    t instanceof google.maps.LatLng ? e.setPosition(t) : e.setPosition(new google.maps.LatLng(t.lat, t.lng));
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, W$e = {};
function $$e(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, g = ge(Ft), [f, m] = k(null), [b, E] = k(null), [w, M] = k(null), [x, v] = k(null), [C, P] = k(null), [F, L] = k(null), B = dt(null);
  return h(() => {
    g && f !== null && (f.close(), n ? f.open(g, n) : f.getPosition() && f.open(g));
  }, [g, f, n]), h(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), h(() => {
    if (o && f !== null) {
      var N = o instanceof google.maps.LatLng ? o : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        new google.maps.LatLng(o.lat, o.lng)
      );
      f.setPosition(N);
    }
  }, [o]), h(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), h(() => {
    f && a && (b !== null && google.maps.event.removeListener(b), E(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), h(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), M(google.maps.event.addListener(f, "domready", s)));
  }, [s]), h(() => {
    f && l && (x !== null && google.maps.event.removeListener(x), v(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), h(() => {
    f && u && (C !== null && google.maps.event.removeListener(C), P(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), h(() => {
    f && c && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), h(() => {
    if (g) {
      var N = r || W$e, {
        position: $
      } = N, V = TT(N, U$e), H;
      $ && !($ instanceof google.maps.LatLng) && (H = new google.maps.LatLng($.lat, $.lng));
      var Z = new tre(Ow(Ow({}, V), H ? {
        position: H
      } : {}));
      B.current = document.createElement("div"), m(Z), a && E(google.maps.event.addListener(Z, "closeclick", a)), s && M(google.maps.event.addListener(Z, "domready", s)), l && v(google.maps.event.addListener(Z, "content_changed", l)), u && P(google.maps.event.addListener(Z, "position_changed", u)), c && L(google.maps.event.addListener(Z, "zindex_changed", c)), Z.setContent(B.current), n ? Z.open(g, n) : Z.getPosition() ? Z.open(g) : Vo(!1, "You must provide either an anchor or a position prop for <InfoBox>."), p && p(Z);
    }
    return () => {
      f !== null && (b && google.maps.event.removeListener(b), x && google.maps.event.removeListener(x), w && google.maps.event.removeListener(w), C && google.maps.event.removeListener(C), F && google.maps.event.removeListener(F), d && d(f), f.close());
    };
  }, []), B.current ? zn(at.only(t), B.current) : null;
}
me($$e);
class V$e extends pe {
  constructor() {
    super(...arguments), Me(this, "registeredEvents", []), Me(this, "containerElement", null), Me(this, "state", {
      infoBox: null
    }), Me(this, "open", (t, n) => {
      n ? this.context !== null && t.open(this.context, n) : t.getPosition() ? this.context !== null && t.open(this.context) : Vo(!1, "You must provide either an anchor or a position prop for <InfoBox>.");
    }), Me(this, "setInfoBoxCallback", () => {
      this.state.infoBox !== null && this.containerElement !== null && (this.state.infoBox.setContent(this.containerElement), this.open(this.state.infoBox, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoBox));
    });
  }
  componentDidMount() {
    var t = this.props.options || {}, {
      position: n
    } = t, r = TT(t, H$e), o;
    n && !(n instanceof google.maps.LatLng) && (o = new google.maps.LatLng(n.lat, n.lng));
    var i = new tre(Ow(Ow({}, r), o ? {
      position: o
    } : {}));
    this.containerElement = document.createElement("div"), this.registeredEvents = Cn({
      updaterMap: S9,
      eventMap: P9,
      prevProps: {},
      nextProps: this.props,
      instance: i
    }), this.setState({
      infoBox: i
    }, this.setInfoBoxCallback);
  }
  componentDidUpdate(t) {
    var {
      infoBox: n
    } = this.state;
    n !== null && (Pn(this.registeredEvents), this.registeredEvents = Cn({
      updaterMap: S9,
      eventMap: P9,
      prevProps: t,
      nextProps: this.props,
      instance: n
    }));
  }
  componentWillUnmount() {
    var {
      onUnmount: t
    } = this.props, {
      infoBox: n
    } = this.state;
    n !== null && (t && t(n), Pn(this.registeredEvents), n.close());
  }
  render() {
    return this.containerElement ? zn(at.only(this.props.children), this.containerElement) : null;
  }
}
Me(V$e, "contextType", Ft);
var M9, D9;
function Z$e() {
  return D9 || (D9 = 1, M9 = function e(t, n) {
    if (t === n) return !0;
    if (t && n && typeof t == "object" && typeof n == "object") {
      if (t.constructor !== n.constructor) return !1;
      var r, o, i;
      if (Array.isArray(t)) {
        if (r = t.length, r != n.length) return !1;
        for (o = r; o-- !== 0; ) if (!e(t[o], n[o])) return !1;
        return !0;
      }
      if (t.constructor === RegExp) return t.source === n.source && t.flags === n.flags;
      if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === n.valueOf();
      if (t.toString !== Object.prototype.toString) return t.toString() === n.toString();
      if (i = Object.keys(t), r = i.length, r !== Object.keys(n).length) return !1;
      for (o = r; o-- !== 0; ) if (!Object.prototype.hasOwnProperty.call(n, i[o])) return !1;
      for (o = r; o-- !== 0; ) {
        var a = i[o];
        if (!e(t[a], n[a])) return !1;
      }
      return !0;
    }
    return t !== t && n !== n;
  }), M9;
}
var q$e = Z$e(), T9 = /* @__PURE__ */ Gne(q$e), j9 = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array], Nk = 1, Md = 8;
class jT {
  /**
   * Creates an index from raw `ArrayBuffer` data.
   * @param {ArrayBuffer} data
   */
  static from(t) {
    if (!(t instanceof ArrayBuffer))
      throw new Error("Data must be an instance of ArrayBuffer.");
    var [n, r] = new Uint8Array(t, 0, 2);
    if (n !== 219)
      throw new Error("Data does not appear to be in a KDBush format.");
    var o = r >> 4;
    if (o !== Nk)
      throw new Error("Got v".concat(o, " data when expected v").concat(Nk, "."));
    var i = j9[r & 15];
    if (!i)
      throw new Error("Unrecognized array type.");
    var [a] = new Uint16Array(t, 2, 1), [s] = new Uint32Array(t, 4, 1);
    return new jT(s, a, i, t);
  }
  /**
   * Creates an index that will hold a given number of items.
   * @param {number} numItems
   * @param {number} [nodeSize=64] Size of the KD-tree node (64 by default).
   * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).
   * @param {ArrayBuffer} [data] (For internal use only)
   */
  constructor(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 64, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Float64Array, o = arguments.length > 3 ? arguments[3] : void 0;
    if (isNaN(t) || t < 0) throw new Error("Unpexpected numItems value: ".concat(t, "."));
    this.numItems = +t, this.nodeSize = Math.min(Math.max(+n, 2), 65535), this.ArrayType = r, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
    var i = j9.indexOf(this.ArrayType), a = t * 2 * this.ArrayType.BYTES_PER_ELEMENT, s = t * this.IndexArrayType.BYTES_PER_ELEMENT, l = (8 - s % 8) % 8;
    if (i < 0)
      throw new Error("Unexpected typed array class: ".concat(r, "."));
    o && o instanceof ArrayBuffer ? (this.data = o, this.ids = new this.IndexArrayType(this.data, Md, t), this.coords = new this.ArrayType(this.data, Md + s + l, t * 2), this._pos = t * 2, this._finished = !0) : (this.data = new ArrayBuffer(Md + a + s + l), this.ids = new this.IndexArrayType(this.data, Md, t), this.coords = new this.ArrayType(this.data, Md + s + l, t * 2), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, (Nk << 4) + i]), new Uint16Array(this.data, 2, 1)[0] = n, new Uint32Array(this.data, 4, 1)[0] = t);
  }
  /**
   * Add a point to the index.
   * @param {number} x
   * @param {number} y
   * @returns {number} An incremental index associated with the added item (starting from `0`).
   */
  add(t, n) {
    var r = this._pos >> 1;
    return this.ids[r] = r, this.coords[this._pos++] = t, this.coords[this._pos++] = n, r;
  }
  /**
   * Perform indexing of the added points.
   */
  finish() {
    var t = this._pos >> 1;
    if (t !== this.numItems)
      throw new Error("Added ".concat(t, " items when expected ").concat(this.numItems, "."));
    return uP(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
  }
  /**
   * Search the index for items within a given bounding box.
   * @param {number} minX
   * @param {number} minY
   * @param {number} maxX
   * @param {number} maxY
   * @returns {number[]} An array of indices correponding to the found items.
   */
  range(t, n, r, o) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: i,
      coords: a,
      nodeSize: s
    } = this, l = [0, i.length - 1, 0], u = []; l.length; ) {
      var c = l.pop() || 0, p = l.pop() || 0, d = l.pop() || 0;
      if (p - d <= s) {
        for (var g = d; g <= p; g++) {
          var f = a[2 * g], m = a[2 * g + 1];
          f >= t && f <= r && m >= n && m <= o && u.push(i[g]);
        }
        continue;
      }
      var b = d + p >> 1, E = a[2 * b], w = a[2 * b + 1];
      E >= t && E <= r && w >= n && w <= o && u.push(i[b]), (c === 0 ? t <= E : n <= w) && (l.push(d), l.push(b - 1), l.push(1 - c)), (c === 0 ? r >= E : o >= w) && (l.push(b + 1), l.push(p), l.push(1 - c));
    }
    return u;
  }
  /**
   * Search the index for items within a given radius.
   * @param {number} qx
   * @param {number} qy
   * @param {number} r Query radius.
   * @returns {number[]} An array of indices correponding to the found items.
   */
  within(t, n, r) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: o,
      coords: i,
      nodeSize: a
    } = this, s = [0, o.length - 1, 0], l = [], u = r * r; s.length; ) {
      var c = s.pop() || 0, p = s.pop() || 0, d = s.pop() || 0;
      if (p - d <= a) {
        for (var g = d; g <= p; g++)
          A9(i[2 * g], i[2 * g + 1], t, n) <= u && l.push(o[g]);
        continue;
      }
      var f = d + p >> 1, m = i[2 * f], b = i[2 * f + 1];
      A9(m, b, t, n) <= u && l.push(o[f]), (c === 0 ? t - r <= m : n - r <= b) && (s.push(d), s.push(f - 1), s.push(1 - c)), (c === 0 ? t + r >= m : n + r >= b) && (s.push(f + 1), s.push(p), s.push(1 - c));
    }
    return l;
  }
}
function uP(e, t, n, r, o, i) {
  if (!(o - r <= n)) {
    var a = r + o >> 1;
    nre(e, t, a, r, o, i), uP(e, t, n, r, a - 1, 1 - i), uP(e, t, n, a + 1, o, 1 - i);
  }
}
function nre(e, t, n, r, o, i) {
  for (; o > r; ) {
    if (o - r > 600) {
      var a = o - r + 1, s = n - r + 1, l = Math.log(a), u = 0.5 * Math.exp(2 * l / 3), c = 0.5 * Math.sqrt(l * u * (a - u) / a) * (s - a / 2 < 0 ? -1 : 1), p = Math.max(r, Math.floor(n - s * u / a + c)), d = Math.min(o, Math.floor(n + (a - s) * u / a + c));
      nre(e, t, n, p, d, i);
    }
    var g = t[2 * n + i], f = r, m = o;
    for (Dd(e, t, r, n), t[2 * o + i] > g && Dd(e, t, r, o); f < m; ) {
      for (Dd(e, t, f, m), f++, m--; t[2 * f + i] < g; ) f++;
      for (; t[2 * m + i] > g; ) m--;
    }
    t[2 * r + i] === g ? Dd(e, t, r, m) : (m++, Dd(e, t, m, o)), m <= n && (r = m + 1), n <= m && (o = m - 1);
  }
}
function Dd(e, t, n, r) {
  Bk(e, n, r), Bk(t, 2 * n, 2 * r), Bk(t, 2 * n + 1, 2 * r + 1);
}
function Bk(e, t, n) {
  var r = e[t];
  e[t] = e[n], e[n] = r;
}
function A9(e, t, n, r) {
  var o = e - n, i = t - r;
  return o * o + i * i;
}
var G$e = {
  minZoom: 0,
  // min zoom to generate clusters on
  maxZoom: 16,
  // max zoom level to cluster the points on
  minPoints: 2,
  // minimum points to form a cluster
  radius: 40,
  // cluster radius in pixels
  extent: 512,
  // tile extent (radius is calculated relative to it)
  nodeSize: 64,
  // size of the KD-tree leaf node, affects performance
  log: !1,
  // whether to log timing info
  // whether to generate numeric ids for input features (in vector tiles)
  generateId: !1,
  // a reduce function for calculating custom cluster properties
  reduce: null,
  // (accumulated, props) => { accumulated.sum += props.sum; }
  // properties to use for individual points when running the reducer
  map: (e) => e
  // props => ({sum: props.my_value})
}, R9 = Math.fround || /* @__PURE__ */ ((e) => (t) => (e[0] = +t, e[0]))(new Float32Array(1)), Hu = 2, Wl = 3, Fk = 4, Rl = 5, rre = 6;
class K$e {
  constructor(t) {
    this.options = Object.assign(Object.create(G$e), t), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
  }
  load(t) {
    var {
      log: n,
      minZoom: r,
      maxZoom: o
    } = this.options;
    n && console.time("total time");
    var i = "prepare ".concat(t.length, " points");
    n && console.time(i), this.points = t;
    for (var a = [], s = 0; s < t.length; s++) {
      var l = t[s];
      if (l.geometry) {
        var [u, c] = l.geometry.coordinates, p = R9(Bv(u)), d = R9(Fv(c));
        a.push(
          p,
          d,
          // projected point coordinates
          1 / 0,
          // the last zoom the point was processed at
          s,
          // index of the source feature in the original input array
          -1,
          // parent cluster id
          1
          // number of points in a cluster
        ), this.options.reduce && a.push(0);
      }
    }
    var g = this.trees[o + 1] = this._createTree(a);
    n && console.timeEnd(i);
    for (var f = o; f >= r; f--) {
      var m = +Date.now();
      g = this.trees[f] = this._createTree(this._cluster(g, f)), n && console.log("z%d: %d clusters in %dms", f, g.numItems, +Date.now() - m);
    }
    return n && console.timeEnd("total time"), this;
  }
  getClusters(t, n) {
    var r = ((t[0] + 180) % 360 + 360) % 360 - 180, o = Math.max(-90, Math.min(90, t[1])), i = t[2] === 180 ? 180 : ((t[2] + 180) % 360 + 360) % 360 - 180, a = Math.max(-90, Math.min(90, t[3]));
    if (t[2] - t[0] >= 360)
      r = -180, i = 180;
    else if (r > i) {
      var s = this.getClusters([r, o, 180, a], n), l = this.getClusters([-180, o, i, a], n);
      return s.concat(l);
    }
    var u = this.trees[this._limitZoom(n)], c = u.range(Bv(r), Fv(a), Bv(i), Fv(o)), p = u.data, d = [];
    for (var g of c) {
      var f = this.stride * g;
      d.push(p[f + Rl] > 1 ? I9(p, f, this.clusterProps) : this.points[p[f + Wl]]);
    }
    return d;
  }
  getChildren(t) {
    var n = this._getOriginId(t), r = this._getOriginZoom(t), o = "No cluster with the specified id.", i = this.trees[r];
    if (!i) throw new Error(o);
    var a = i.data;
    if (n * this.stride >= a.length) throw new Error(o);
    var s = this.options.radius / (this.options.extent * Math.pow(2, r - 1)), l = a[n * this.stride], u = a[n * this.stride + 1], c = i.within(l, u, s), p = [];
    for (var d of c) {
      var g = d * this.stride;
      a[g + Fk] === t && p.push(a[g + Rl] > 1 ? I9(a, g, this.clusterProps) : this.points[a[g + Wl]]);
    }
    if (p.length === 0) throw new Error(o);
    return p;
  }
  getLeaves(t, n, r) {
    n = n || 10, r = r || 0;
    var o = [];
    return this._appendLeaves(o, t, n, r, 0), o;
  }
  getTile(t, n, r) {
    var o = this.trees[this._limitZoom(t)], i = Math.pow(2, t), {
      extent: a,
      radius: s
    } = this.options, l = s / a, u = (r - l) / i, c = (r + 1 + l) / i, p = {
      features: []
    };
    return this._addTileFeatures(o.range((n - l) / i, u, (n + 1 + l) / i, c), o.data, n, r, i, p), n === 0 && this._addTileFeatures(o.range(1 - l / i, u, 1, c), o.data, i, r, i, p), n === i - 1 && this._addTileFeatures(o.range(0, u, l / i, c), o.data, -1, r, i, p), p.features.length ? p : null;
  }
  getClusterExpansionZoom(t) {
    for (var n = this._getOriginZoom(t) - 1; n <= this.options.maxZoom; ) {
      var r = this.getChildren(t);
      if (n++, r.length !== 1) break;
      t = r[0].properties.cluster_id;
    }
    return n;
  }
  _appendLeaves(t, n, r, o, i) {
    var a = this.getChildren(n);
    for (var s of a) {
      var l = s.properties;
      if (l && l.cluster ? i + l.point_count <= o ? i += l.point_count : i = this._appendLeaves(t, l.cluster_id, r, o, i) : i < o ? i++ : t.push(s), t.length === r) break;
    }
    return i;
  }
  _createTree(t) {
    for (var n = new jT(t.length / this.stride | 0, this.options.nodeSize, Float32Array), r = 0; r < t.length; r += this.stride) n.add(t[r], t[r + 1]);
    return n.finish(), n.data = t, n;
  }
  _addTileFeatures(t, n, r, o, i, a) {
    for (var s of t) {
      var l = s * this.stride, u = n[l + Rl] > 1, c = void 0, p = void 0, d = void 0;
      if (u)
        c = ore(n, l, this.clusterProps), p = n[l], d = n[l + 1];
      else {
        var g = this.points[n[l + Wl]];
        c = g.properties;
        var [f, m] = g.geometry.coordinates;
        p = Bv(f), d = Fv(m);
      }
      var b = {
        type: 1,
        geometry: [[Math.round(this.options.extent * (p * i - r)), Math.round(this.options.extent * (d * i - o))]],
        tags: c
      }, E = void 0;
      u || this.options.generateId ? E = n[l + Wl] : E = this.points[n[l + Wl]].id, E !== void 0 && (b.id = E), a.features.push(b);
    }
  }
  _limitZoom(t) {
    return Math.max(this.options.minZoom, Math.min(Math.floor(+t), this.options.maxZoom + 1));
  }
  _cluster(t, n) {
    for (var {
      radius: r,
      extent: o,
      reduce: i,
      minPoints: a
    } = this.options, s = r / (o * Math.pow(2, n)), l = t.data, u = [], c = this.stride, p = 0; p < l.length; p += c)
      if (!(l[p + Hu] <= n)) {
        l[p + Hu] = n;
        var d = l[p], g = l[p + 1], f = t.within(l[p], l[p + 1], s), m = l[p + Rl], b = m;
        for (var E of f) {
          var w = E * c;
          l[w + Hu] > n && (b += l[w + Rl]);
        }
        if (b > m && b >= a) {
          var M = d * m, x = g * m, v = void 0, C = -1, P = ((p / c | 0) << 5) + (n + 1) + this.points.length;
          for (var F of f) {
            var L = F * c;
            if (!(l[L + Hu] <= n)) {
              l[L + Hu] = n;
              var B = l[L + Rl];
              M += l[L] * B, x += l[L + 1] * B, l[L + Fk] = P, i && (v || (v = this._map(l, p, !0), C = this.clusterProps.length, this.clusterProps.push(v)), i(v, this._map(l, L)));
            }
          }
          l[p + Fk] = P, u.push(M / b, x / b, 1 / 0, P, -1, b), i && u.push(C);
        } else {
          for (var N = 0; N < c; N++) u.push(l[p + N]);
          if (b > 1)
            for (var $ of f) {
              var V = $ * c;
              if (!(l[V + Hu] <= n)) {
                l[V + Hu] = n;
                for (var H = 0; H < c; H++) u.push(l[V + H]);
              }
            }
        }
      }
    return u;
  }
  // get index of the point from which the cluster originated
  _getOriginId(t) {
    return t - this.points.length >> 5;
  }
  // get zoom of the point from which the cluster originated
  _getOriginZoom(t) {
    return (t - this.points.length) % 32;
  }
  _map(t, n, r) {
    if (t[n + Rl] > 1) {
      var o = this.clusterProps[t[n + rre]];
      return r ? Object.assign({}, o) : o;
    }
    var i = this.points[t[n + Wl]].properties, a = this.options.map(i);
    return r && a === i ? Object.assign({}, a) : a;
  }
}
function I9(e, t, n) {
  return {
    type: "Feature",
    id: e[t + Wl],
    properties: ore(e, t, n),
    geometry: {
      type: "Point",
      coordinates: [X$e(e[t]), Y$e(e[t + 1])]
    }
  };
}
function ore(e, t, n) {
  var r = e[t + Rl], o = r >= 1e4 ? "".concat(Math.round(r / 1e3), "k") : r >= 1e3 ? "".concat(Math.round(r / 100) / 10, "k") : r, i = e[t + rre], a = i === -1 ? {} : Object.assign({}, n[i]);
  return Object.assign(a, {
    cluster: !0,
    cluster_id: e[t + Wl],
    point_count: r,
    point_count_abbreviated: o
  });
}
function Bv(e) {
  return e / 360 + 0.5;
}
function Fv(e) {
  var t = Math.sin(e * Math.PI / 180), n = 0.5 - 0.25 * Math.log((1 + t) / (1 - t)) / Math.PI;
  return n < 0 ? 0 : n > 1 ? 1 : n;
}
function X$e(e) {
  return (e - 0.5) * 360;
}
function Y$e(e) {
  var t = (180 - e * 360) * Math.PI / 180;
  return 360 * Math.atan(Math.exp(t)) / Math.PI - 90;
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function J$e(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
    t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
  return n;
}
class hs {
  static isAdvancedMarkerAvailable(t) {
    return google.maps.marker && t.getMapCapabilities().isAdvancedMarkersAvailable === !0;
  }
  static isAdvancedMarker(t) {
    return google.maps.marker && t instanceof google.maps.marker.AdvancedMarkerElement;
  }
  static setMap(t, n) {
    this.isAdvancedMarker(t) ? t.map = n : t.setMap(n);
  }
  static getPosition(t) {
    if (this.isAdvancedMarker(t)) {
      if (t.position) {
        if (t.position instanceof google.maps.LatLng)
          return t.position;
        if (t.position.lat && t.position.lng)
          return new google.maps.LatLng(t.position.lat, t.position.lng);
      }
      return new google.maps.LatLng(null);
    }
    return t.getPosition();
  }
  static getVisible(t) {
    return this.isAdvancedMarker(t) ? !0 : t.getVisible();
  }
}
class cP {
  constructor(t) {
    var {
      markers: n,
      position: r
    } = t;
    this.markers = n, r && (r instanceof google.maps.LatLng ? this._position = r : this._position = new google.maps.LatLng(r));
  }
  get bounds() {
    if (!(this.markers.length === 0 && !this._position)) {
      var t = new google.maps.LatLngBounds(this._position, this._position);
      for (var n of this.markers)
        t.extend(hs.getPosition(n));
      return t;
    }
  }
  get position() {
    return this._position || this.bounds.getCenter();
  }
  /**
   * Get the count of **visible** markers.
   */
  get count() {
    return this.markers.filter((t) => hs.getVisible(t)).length;
  }
  /**
   * Add a marker to the cluster.
   */
  push(t) {
    this.markers.push(t);
  }
  /**
   * Cleanup references and remove marker from map.
   */
  delete() {
    this.marker && (hs.setMap(this.marker, null), this.marker = void 0), this.markers.length = 0;
  }
}
class Q$e {
  constructor(t) {
    var {
      maxZoom: n = 16
    } = t;
    this.maxZoom = n;
  }
  /**
   * Helper function to bypass clustering based upon some map state such as
   * zoom, number of markers, etc.
   *
   * ```typescript
   *  cluster({markers, map}: AlgorithmInput): Cluster[] {
   *    if (shouldBypassClustering(map)) {
   *      return this.noop({markers})
   *    }
   * }
   * ```
   */
  noop(t) {
    var {
      markers: n
    } = t;
    return e3e(n);
  }
}
var e3e = (e) => {
  var t = e.map((n) => new cP({
    position: hs.getPosition(n),
    markers: [n]
  }));
  return t;
};
class t3e extends Q$e {
  constructor(t) {
    var {
      maxZoom: n,
      radius: r = 60
    } = t, o = J$e(t, ["maxZoom", "radius"]);
    super({
      maxZoom: n
    }), this.state = {
      zoom: -1
    }, this.superCluster = new K$e(Object.assign({
      maxZoom: this.maxZoom,
      radius: r
    }, o));
  }
  calculate(t) {
    var n = !1, r = {
      zoom: t.map.getZoom()
    };
    if (!T9(t.markers, this.markers)) {
      n = !0, this.markers = [...t.markers];
      var o = this.markers.map((i) => {
        var a = hs.getPosition(i), s = [a.lng(), a.lat()];
        return {
          type: "Feature",
          geometry: {
            type: "Point",
            coordinates: s
          },
          properties: {
            marker: i
          }
        };
      });
      this.superCluster.load(o);
    }
    return n || (this.state.zoom <= this.maxZoom || r.zoom <= this.maxZoom) && (n = !T9(this.state, r)), this.state = r, n && (this.clusters = this.cluster(t)), {
      clusters: this.clusters,
      changed: n
    };
  }
  cluster(t) {
    var {
      map: n
    } = t;
    return this.superCluster.getClusters([-180, -90, 180, 90], Math.round(n.getZoom())).map((r) => this.transformCluster(r));
  }
  transformCluster(t) {
    var {
      geometry: {
        coordinates: [n, r]
      },
      properties: o
    } = t;
    if (o.cluster)
      return new cP({
        markers: this.superCluster.getLeaves(o.cluster_id, 1 / 0).map((a) => a.properties.marker),
        position: {
          lat: r,
          lng: n
        }
      });
    var i = o.marker;
    return new cP({
      markers: [i],
      position: hs.getPosition(i)
    });
  }
}
class n3e {
  constructor(t, n) {
    this.markers = {
      sum: t.length
    };
    var r = n.map((i) => i.count), o = r.reduce((i, a) => i + a, 0);
    this.clusters = {
      count: n.length,
      markers: {
        mean: o / n.length,
        sum: o,
        min: Math.min(...r),
        max: Math.max(...r)
      }
    };
  }
}
class r3e {
  /**
   * The default render function for the library used by {@link MarkerClusterer}.
   *
   * Currently set to use the following:
   *
   * ```typescript
   * // change color if this cluster has more markers than the mean cluster
   * const color =
   *   count > Math.max(10, stats.clusters.markers.mean)
   *     ? "#ff0000"
   *     : "#0000ff";
   *
   * // create svg url with fill color
   * const svg = window.btoa(`
   * <svg fill="${color}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240">
   *   <circle cx="120" cy="120" opacity=".6" r="70" />
   *   <circle cx="120" cy="120" opacity=".3" r="90" />
   *   <circle cx="120" cy="120" opacity=".2" r="110" />
   *   <circle cx="120" cy="120" opacity=".1" r="130" />
   * </svg>`);
   *
   * // create marker using svg icon
   * return new google.maps.Marker({
   *   position,
   *   icon: {
   *     url: `data:image/svg+xml;base64,${svg}`,
   *     scaledSize: new google.maps.Size(45, 45),
   *   },
   *   label: {
   *     text: String(count),
   *     color: "rgba(255,255,255,0.9)",
   *     fontSize: "12px",
   *   },
   *   // adjust zIndex to be above other markers
   *   zIndex: 1000 + count,
   * });
   * ```
   */
  render(t, n, r) {
    var {
      count: o,
      position: i
    } = t, a = o > Math.max(10, n.clusters.markers.mean) ? "#ff0000" : "#0000ff", s = '<svg fill="'.concat(a, `" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" width="50" height="50">
<circle cx="120" cy="120" opacity=".6" r="70" />
<circle cx="120" cy="120" opacity=".3" r="90" />
<circle cx="120" cy="120" opacity=".2" r="110" />
<text x="50%" y="50%" style="fill:#fff" text-anchor="middle" font-size="50" dominant-baseline="middle" font-family="roboto,arial,sans-serif">`).concat(o, `</text>
</svg>`), l = "Cluster of ".concat(o, " markers"), u = Number(google.maps.Marker.MAX_ZINDEX) + o;
    if (hs.isAdvancedMarkerAvailable(r)) {
      var c = new DOMParser(), p = c.parseFromString(s, "image/svg+xml").documentElement;
      p.setAttribute("transform", "translate(0 25)");
      var d = {
        map: r,
        position: i,
        zIndex: u,
        title: l,
        content: p
      };
      return new google.maps.marker.AdvancedMarkerElement(d);
    }
    var g = {
      position: i,
      zIndex: u,
      title: l,
      icon: {
        url: "data:image/svg+xml;base64,".concat(btoa(s)),
        anchor: new google.maps.Point(25, 25)
      }
    };
    return new google.maps.Marker(g);
  }
}
function o3e(e, t) {
  for (var n in t.prototype)
    e.prototype[n] = t.prototype[n];
}
class AT {
  constructor() {
    o3e(AT, google.maps.OverlayView);
  }
}
var Df;
(function(e) {
  e.CLUSTERING_BEGIN = "clusteringbegin", e.CLUSTERING_END = "clusteringend", e.CLUSTER_CLICK = "click";
})(Df || (Df = {}));
var i3e = (e, t, n) => {
  n.fitBounds(t.bounds);
};
class s3e extends AT {
  constructor(t) {
    var {
      map: n,
      markers: r = [],
      algorithmOptions: o = {},
      algorithm: i = new t3e(o),
      renderer: a = new r3e(),
      onClusterClick: s = i3e
    } = t;
    super(), this.markers = [...r], this.clusters = [], this.algorithm = i, this.renderer = a, this.onClusterClick = s, n && this.setMap(n);
  }
  addMarker(t, n) {
    this.markers.includes(t) || (this.markers.push(t), n || this.render());
  }
  addMarkers(t, n) {
    t.forEach((r) => {
      this.addMarker(r, !0);
    }), n || this.render();
  }
  removeMarker(t, n) {
    var r = this.markers.indexOf(t);
    return r === -1 ? !1 : (hs.setMap(t, null), this.markers.splice(r, 1), n || this.render(), !0);
  }
  removeMarkers(t, n) {
    var r = !1;
    return t.forEach((o) => {
      r = this.removeMarker(o, !0) || r;
    }), r && !n && this.render(), r;
  }
  clearMarkers(t) {
    this.markers.length = 0, t || this.render();
  }
  /**
   * Recalculates and draws all the marker clusters.
   */
  render() {
    var t = this.getMap();
    if (t instanceof google.maps.Map && t.getProjection()) {
      google.maps.event.trigger(this, Df.CLUSTERING_BEGIN, this);
      var {
        clusters: n,
        changed: r
      } = this.algorithm.calculate({
        markers: this.markers,
        map: t,
        mapCanvasProjection: this.getProjection()
      });
      if (r || r == null) {
        var o = /* @__PURE__ */ new Set();
        for (var i of n)
          i.markers.length == 1 && o.add(i.markers[0]);
        var a = [];
        for (var s of this.clusters)
          s.marker != null && (s.markers.length == 1 ? o.has(s.marker) || hs.setMap(s.marker, null) : a.push(s.marker));
        this.clusters = n, this.renderClusters(), requestAnimationFrame(() => a.forEach((l) => hs.setMap(l, null)));
      }
      google.maps.event.trigger(this, Df.CLUSTERING_END, this);
    }
  }
  onAdd() {
    this.idleListener = this.getMap().addListener("idle", this.render.bind(this)), this.render();
  }
  onRemove() {
    google.maps.event.removeListener(this.idleListener), this.reset();
  }
  reset() {
    this.markers.forEach((t) => hs.setMap(t, null)), this.clusters.forEach((t) => t.delete()), this.clusters = [];
  }
  renderClusters() {
    var t = new n3e(this.markers, this.clusters), n = this.getMap();
    this.clusters.forEach((r) => {
      r.markers.length === 1 ? r.marker = r.markers[0] : (r.marker = this.renderer.render(r, t, n), r.markers.forEach((o) => hs.setMap(o, null)), this.onClusterClick && r.marker.addListener(
        "click",
        /* istanbul ignore next */
        (o) => {
          google.maps.event.trigger(this, Df.CLUSTER_CLICK, r), this.onClusterClick(o, r, n);
        }
      )), hs.setMap(r.marker, n);
    });
  }
}
function N9(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function B9(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? N9(Object(n), !0).forEach(function(r) {
      Me(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : N9(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function a3e(e) {
  var t = i$e(), [n, r] = k(null);
  return h(() => {
    if (t && n === null) {
      var o = new s3e(B9(B9({}, e), {}, {
        map: t
      }));
      r(o);
    }
  }, [t]), n;
}
function l3e(e) {
  var {
    children: t,
    options: n
  } = e, r = a3e(n);
  return r !== null ? t(r) : null;
}
me(l3e);
var F9 = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, z9 = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
function u3e(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, g = ge(Ft), [f, m] = k(null), [b, E] = k(null), [w, M] = k(null), [x, v] = k(null), [C, P] = k(null), [F, L] = k(null), B = dt(null);
  return h(() => {
    f !== null && (f.close(), n ? f.open(g, n) : f.getPosition() && f.open(g));
  }, [g, f, n]), h(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), h(() => {
    o && f !== null && f.setPosition(o);
  }, [o]), h(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), h(() => {
    f && a && (b !== null && google.maps.event.removeListener(b), E(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), h(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), M(google.maps.event.addListener(f, "domready", s)));
  }, [s]), h(() => {
    f && l && (x !== null && google.maps.event.removeListener(x), v(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), h(() => {
    f && u && (C !== null && google.maps.event.removeListener(C), P(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), h(() => {
    f && c && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), h(() => {
    var N = new google.maps.InfoWindow(r);
    return m(N), B.current = document.createElement("div"), a && E(google.maps.event.addListener(N, "closeclick", a)), s && M(google.maps.event.addListener(N, "domready", s)), l && v(google.maps.event.addListener(N, "content_changed", l)), u && P(google.maps.event.addListener(N, "position_changed", u)), c && L(google.maps.event.addListener(N, "zindex_changed", c)), N.setContent(B.current), o && N.setPosition(o), i && N.setZIndex(i), n ? N.open(g, n) : N.getPosition() ? N.open(g) : Vo(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>."), p && p(N), () => {
      b && google.maps.event.removeListener(b), x && google.maps.event.removeListener(x), w && google.maps.event.removeListener(w), C && google.maps.event.removeListener(C), F && google.maps.event.removeListener(F), d && d(N), N.close();
    };
  }, []), B.current ? zn(at.only(t), B.current) : null;
}
me(u3e);
class c3e extends pe {
  constructor() {
    super(...arguments), Me(this, "registeredEvents", []), Me(this, "containerElement", null), Me(this, "state", {
      infoWindow: null
    }), Me(this, "open", (t, n) => {
      n ? t.open(this.context, n) : t.getPosition() ? t.open(this.context) : Vo(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>.");
    }), Me(this, "setInfoWindowCallback", () => {
      this.state.infoWindow !== null && this.containerElement !== null && (this.state.infoWindow.setContent(this.containerElement), this.open(this.state.infoWindow, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoWindow));
    });
  }
  componentDidMount() {
    var t = new google.maps.InfoWindow(this.props.options);
    this.containerElement = document.createElement("div"), this.registeredEvents = Cn({
      updaterMap: z9,
      eventMap: F9,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(() => ({
      infoWindow: t
    }), this.setInfoWindowCallback);
  }
  componentDidUpdate(t) {
    this.state.infoWindow !== null && (Pn(this.registeredEvents), this.registeredEvents = Cn({
      updaterMap: z9,
      eventMap: F9,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.infoWindow
    }));
  }
  componentWillUnmount() {
    this.state.infoWindow !== null && (Pn(this.registeredEvents), this.props.onUnmount && this.props.onUnmount(this.state.infoWindow), this.state.infoWindow.close());
  }
  render() {
    return this.containerElement ? zn(at.only(this.props.children), this.containerElement) : null;
  }
}
Me(c3e, "contextType", Ft);
function U9(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function xw(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? U9(Object(n), !0).forEach(function(r) {
      Me(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : U9(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var H9 = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, W9 = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, p3e = {};
function d3e(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: g,
    onRightClick: f,
    onClick: m,
    onDrag: b,
    onLoad: E,
    onUnmount: w
  } = e, M = ge(Ft), [x, v] = k(null), [C, P] = k(null), [F, L] = k(null), [B, N] = k(null), [$, V] = k(null), [H, Z] = k(null), [K, Y] = k(null), [Q, J] = k(null), [_, D] = k(null), [z, S] = k(null), [W, O] = k(null), [j, U] = k(null);
  return h(() => {
    x !== null && x.setMap(M);
  }, [M]), h(() => {
    typeof t < "u" && x !== null && x.setOptions(t);
  }, [x, t]), h(() => {
    typeof n < "u" && x !== null && x.setDraggable(n);
  }, [x, n]), h(() => {
    typeof r < "u" && x !== null && x.setEditable(r);
  }, [x, r]), h(() => {
    typeof o < "u" && x !== null && x.setVisible(o);
  }, [x, o]), h(() => {
    typeof i < "u" && x !== null && x.setPath(i);
  }, [x, i]), h(() => {
    x && a && (C !== null && google.maps.event.removeListener(C), P(google.maps.event.addListener(x, "dblclick", a)));
  }, [a]), h(() => {
    x && s && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(x, "dragend", s)));
  }, [s]), h(() => {
    x && l && (B !== null && google.maps.event.removeListener(B), N(google.maps.event.addListener(x, "dragstart", l)));
  }, [l]), h(() => {
    x && u && ($ !== null && google.maps.event.removeListener($), V(google.maps.event.addListener(x, "mousedown", u)));
  }, [u]), h(() => {
    x && c && (H !== null && google.maps.event.removeListener(H), Z(google.maps.event.addListener(x, "mousemove", c)));
  }, [c]), h(() => {
    x && p && (K !== null && google.maps.event.removeListener(K), Y(google.maps.event.addListener(x, "mouseout", p)));
  }, [p]), h(() => {
    x && d && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(x, "mouseover", d)));
  }, [d]), h(() => {
    x && g && (_ !== null && google.maps.event.removeListener(_), D(google.maps.event.addListener(x, "mouseup", g)));
  }, [g]), h(() => {
    x && f && (z !== null && google.maps.event.removeListener(z), S(google.maps.event.addListener(x, "rightclick", f)));
  }, [f]), h(() => {
    x && m && (W !== null && google.maps.event.removeListener(W), O(google.maps.event.addListener(x, "click", m)));
  }, [m]), h(() => {
    x && b && (j !== null && google.maps.event.removeListener(j), U(google.maps.event.addListener(x, "drag", b)));
  }, [b]), h(() => {
    var T = new google.maps.Polyline(xw(xw({}, t || p3e), {}, {
      map: M
    }));
    return i && T.setPath(i), typeof o < "u" && T.setVisible(o), typeof r < "u" && T.setEditable(r), typeof n < "u" && T.setDraggable(n), a && P(google.maps.event.addListener(T, "dblclick", a)), s && L(google.maps.event.addListener(T, "dragend", s)), l && N(google.maps.event.addListener(T, "dragstart", l)), u && V(google.maps.event.addListener(T, "mousedown", u)), c && Z(google.maps.event.addListener(T, "mousemove", c)), p && Y(google.maps.event.addListener(T, "mouseout", p)), d && J(google.maps.event.addListener(T, "mouseover", d)), g && D(google.maps.event.addListener(T, "mouseup", g)), f && S(google.maps.event.addListener(T, "rightclick", f)), m && O(google.maps.event.addListener(T, "click", m)), b && U(google.maps.event.addListener(T, "drag", b)), v(T), E && E(T), () => {
      C !== null && google.maps.event.removeListener(C), F !== null && google.maps.event.removeListener(F), B !== null && google.maps.event.removeListener(B), $ !== null && google.maps.event.removeListener($), H !== null && google.maps.event.removeListener(H), K !== null && google.maps.event.removeListener(K), Q !== null && google.maps.event.removeListener(Q), _ !== null && google.maps.event.removeListener(_), z !== null && google.maps.event.removeListener(z), W !== null && google.maps.event.removeListener(W), w && w(T), T.setMap(null);
    };
  }, []), null;
}
me(d3e);
class f3e extends pe {
  constructor() {
    super(...arguments), Me(this, "registeredEvents", []), Me(this, "state", {
      polyline: null
    }), Me(this, "setPolylineCallback", () => {
      this.state.polyline !== null && this.props.onLoad && this.props.onLoad(this.state.polyline);
    });
  }
  componentDidMount() {
    var t = new google.maps.Polyline(xw(xw({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Cn({
      updaterMap: W9,
      eventMap: H9,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        polyline: t
      };
    }, this.setPolylineCallback);
  }
  componentDidUpdate(t) {
    this.state.polyline !== null && (Pn(this.registeredEvents), this.registeredEvents = Cn({
      updaterMap: W9,
      eventMap: H9,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.polyline
    }));
  }
  componentWillUnmount() {
    this.state.polyline !== null && (this.props.onUnmount && this.props.onUnmount(this.state.polyline), Pn(this.registeredEvents), this.state.polyline.setMap(null));
  }
  render() {
    return null;
  }
}
Me(f3e, "contextType", Ft);
function $9(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function V9(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? $9(Object(n), !0).forEach(function(r) {
      Me(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : $9(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Z9 = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, q9 = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  paths(e, t) {
    e.setPaths(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function h3e(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    paths: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: g,
    onMouseUp: f,
    onRightClick: m,
    onClick: b,
    onDrag: E,
    onLoad: w,
    onUnmount: M,
    onEdit: x
  } = e, v = ge(Ft), [C, P] = k(null), [F, L] = k(null), [B, N] = k(null), [$, V] = k(null), [H, Z] = k(null), [K, Y] = k(null), [Q, J] = k(null), [_, D] = k(null), [z, S] = k(null), [W, O] = k(null), [j, U] = k(null), [T, q] = k(null);
  return h(() => {
    C !== null && C.setMap(v);
  }, [v]), h(() => {
    typeof t < "u" && C !== null && C.setOptions(t);
  }, [C, t]), h(() => {
    typeof n < "u" && C !== null && C.setDraggable(n);
  }, [C, n]), h(() => {
    typeof r < "u" && C !== null && C.setEditable(r);
  }, [C, r]), h(() => {
    typeof o < "u" && C !== null && C.setVisible(o);
  }, [C, o]), h(() => {
    typeof i < "u" && C !== null && C.setPath(i);
  }, [C, i]), h(() => {
    typeof a < "u" && C !== null && C.setPaths(a);
  }, [C, a]), h(() => {
    C && typeof s == "function" && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(C, "dblclick", s)));
  }, [s]), h(() => {
    C && (google.maps.event.addListener(C.getPath(), "insert_at", () => {
      x == null || x(C);
    }), google.maps.event.addListener(C.getPath(), "set_at", () => {
      x == null || x(C);
    }), google.maps.event.addListener(C.getPath(), "remove_at", () => {
      x == null || x(C);
    }));
  }, [C, x]), h(() => {
    C && typeof l == "function" && (B !== null && google.maps.event.removeListener(B), N(google.maps.event.addListener(C, "dragend", l)));
  }, [l]), h(() => {
    C && typeof u == "function" && ($ !== null && google.maps.event.removeListener($), V(google.maps.event.addListener(C, "dragstart", u)));
  }, [u]), h(() => {
    C && typeof c == "function" && (H !== null && google.maps.event.removeListener(H), Z(google.maps.event.addListener(C, "mousedown", c)));
  }, [c]), h(() => {
    C && typeof p == "function" && (K !== null && google.maps.event.removeListener(K), Y(google.maps.event.addListener(C, "mousemove", p)));
  }, [p]), h(() => {
    C && typeof d == "function" && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(C, "mouseout", d)));
  }, [d]), h(() => {
    C && typeof g == "function" && (_ !== null && google.maps.event.removeListener(_), D(google.maps.event.addListener(C, "mouseover", g)));
  }, [g]), h(() => {
    C && typeof f == "function" && (z !== null && google.maps.event.removeListener(z), S(google.maps.event.addListener(C, "mouseup", f)));
  }, [f]), h(() => {
    C && typeof m == "function" && (W !== null && google.maps.event.removeListener(W), O(google.maps.event.addListener(C, "rightclick", m)));
  }, [m]), h(() => {
    C && typeof b == "function" && (j !== null && google.maps.event.removeListener(j), U(google.maps.event.addListener(C, "click", b)));
  }, [b]), h(() => {
    C && typeof E == "function" && (T !== null && google.maps.event.removeListener(T), q(google.maps.event.addListener(C, "drag", E)));
  }, [E]), h(() => {
    var A = new google.maps.Polygon(V9(V9({}, t), {}, {
      map: v
    }));
    return i && A.setPath(i), a && A.setPaths(a), typeof o < "u" && A.setVisible(o), typeof r < "u" && A.setEditable(r), typeof n < "u" && A.setDraggable(n), s && L(google.maps.event.addListener(A, "dblclick", s)), l && N(google.maps.event.addListener(A, "dragend", l)), u && V(google.maps.event.addListener(A, "dragstart", u)), c && Z(google.maps.event.addListener(A, "mousedown", c)), p && Y(google.maps.event.addListener(A, "mousemove", p)), d && J(google.maps.event.addListener(A, "mouseout", d)), g && D(google.maps.event.addListener(A, "mouseover", g)), f && S(google.maps.event.addListener(A, "mouseup", f)), m && O(google.maps.event.addListener(A, "rightclick", m)), b && U(google.maps.event.addListener(A, "click", b)), E && q(google.maps.event.addListener(A, "drag", E)), P(A), w && w(A), () => {
      F !== null && google.maps.event.removeListener(F), B !== null && google.maps.event.removeListener(B), $ !== null && google.maps.event.removeListener($), H !== null && google.maps.event.removeListener(H), K !== null && google.maps.event.removeListener(K), Q !== null && google.maps.event.removeListener(Q), _ !== null && google.maps.event.removeListener(_), z !== null && google.maps.event.removeListener(z), W !== null && google.maps.event.removeListener(W), j !== null && google.maps.event.removeListener(j), M && M(A), A.setMap(null);
    };
  }, []), null;
}
me(h3e);
class g3e extends pe {
  constructor() {
    super(...arguments), Me(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this.props.options || {};
    this.polygon = new google.maps.Polygon(t), this.polygon.setMap(this.context), this.registeredEvents = Cn({
      updaterMap: q9,
      eventMap: Z9,
      prevProps: {},
      nextProps: this.props,
      instance: this.polygon
    }), this.props.onLoad && this.props.onLoad(this.polygon);
  }
  componentDidUpdate(t) {
    this.polygon && (Pn(this.registeredEvents), this.registeredEvents = Cn({
      updaterMap: q9,
      eventMap: Z9,
      prevProps: t,
      nextProps: this.props,
      instance: this.polygon
    }));
  }
  componentWillUnmount() {
    this.polygon && (this.props.onUnmount && this.props.onUnmount(this.polygon), Pn(this.registeredEvents), this.polygon && this.polygon.setMap(null));
  }
  render() {
    return null;
  }
}
Me(g3e, "contextType", Ft);
function G9(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Ew(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? G9(Object(n), !0).forEach(function(r) {
      Me(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : G9(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var K9 = {
  onBoundsChanged: "bounds_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, X9 = {
  bounds(e, t) {
    e.setBounds(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function m3e(e) {
  var {
    options: t,
    bounds: n,
    draggable: r,
    editable: o,
    visible: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: g,
    onRightClick: f,
    onClick: m,
    onDrag: b,
    onBoundsChanged: E,
    onLoad: w,
    onUnmount: M
  } = e, x = ge(Ft), [v, C] = k(null), [P, F] = k(null), [L, B] = k(null), [N, $] = k(null), [V, H] = k(null), [Z, K] = k(null), [Y, Q] = k(null), [J, _] = k(null), [D, z] = k(null), [S, W] = k(null), [O, j] = k(null), [U, T] = k(null), [q, A] = k(null);
  return h(() => {
    v !== null && v.setMap(x);
  }, [x]), h(() => {
    typeof t < "u" && v !== null && v.setOptions(t);
  }, [v, t]), h(() => {
    typeof r < "u" && v !== null && v.setDraggable(r);
  }, [v, r]), h(() => {
    typeof o < "u" && v !== null && v.setEditable(o);
  }, [v, o]), h(() => {
    typeof i < "u" && v !== null && v.setVisible(i);
  }, [v, i]), h(() => {
    typeof n < "u" && v !== null && v.setBounds(n);
  }, [v, n]), h(() => {
    v && a && (P !== null && google.maps.event.removeListener(P), F(google.maps.event.addListener(v, "dblclick", a)));
  }, [a]), h(() => {
    v && s && (L !== null && google.maps.event.removeListener(L), B(google.maps.event.addListener(v, "dragend", s)));
  }, [s]), h(() => {
    v && l && (N !== null && google.maps.event.removeListener(N), $(google.maps.event.addListener(v, "dragstart", l)));
  }, [l]), h(() => {
    v && u && (V !== null && google.maps.event.removeListener(V), H(google.maps.event.addListener(v, "mousedown", u)));
  }, [u]), h(() => {
    v && c && (Z !== null && google.maps.event.removeListener(Z), K(google.maps.event.addListener(v, "mousemove", c)));
  }, [c]), h(() => {
    v && p && (Y !== null && google.maps.event.removeListener(Y), Q(google.maps.event.addListener(v, "mouseout", p)));
  }, [p]), h(() => {
    v && d && (J !== null && google.maps.event.removeListener(J), _(google.maps.event.addListener(v, "mouseover", d)));
  }, [d]), h(() => {
    v && g && (D !== null && google.maps.event.removeListener(D), z(google.maps.event.addListener(v, "mouseup", g)));
  }, [g]), h(() => {
    v && f && (S !== null && google.maps.event.removeListener(S), W(google.maps.event.addListener(v, "rightclick", f)));
  }, [f]), h(() => {
    v && m && (O !== null && google.maps.event.removeListener(O), j(google.maps.event.addListener(v, "click", m)));
  }, [m]), h(() => {
    v && b && (U !== null && google.maps.event.removeListener(U), T(google.maps.event.addListener(v, "drag", b)));
  }, [b]), h(() => {
    v && E && (q !== null && google.maps.event.removeListener(q), A(google.maps.event.addListener(v, "bounds_changed", E)));
  }, [E]), h(() => {
    var X = new google.maps.Rectangle(Ew(Ew({}, t), {}, {
      map: x
    }));
    return typeof i < "u" && X.setVisible(i), typeof o < "u" && X.setEditable(o), typeof r < "u" && X.setDraggable(r), typeof n < "u" && X.setBounds(n), a && F(google.maps.event.addListener(X, "dblclick", a)), s && B(google.maps.event.addListener(X, "dragend", s)), l && $(google.maps.event.addListener(X, "dragstart", l)), u && H(google.maps.event.addListener(X, "mousedown", u)), c && K(google.maps.event.addListener(X, "mousemove", c)), p && Q(google.maps.event.addListener(X, "mouseout", p)), d && _(google.maps.event.addListener(X, "mouseover", d)), g && z(google.maps.event.addListener(X, "mouseup", g)), f && W(google.maps.event.addListener(X, "rightclick", f)), m && j(google.maps.event.addListener(X, "click", m)), b && T(google.maps.event.addListener(X, "drag", b)), E && A(google.maps.event.addListener(X, "bounds_changed", E)), C(X), w && w(X), () => {
      P !== null && google.maps.event.removeListener(P), L !== null && google.maps.event.removeListener(L), N !== null && google.maps.event.removeListener(N), V !== null && google.maps.event.removeListener(V), Z !== null && google.maps.event.removeListener(Z), Y !== null && google.maps.event.removeListener(Y), J !== null && google.maps.event.removeListener(J), D !== null && google.maps.event.removeListener(D), S !== null && google.maps.event.removeListener(S), O !== null && google.maps.event.removeListener(O), U !== null && google.maps.event.removeListener(U), q !== null && google.maps.event.removeListener(q), M && M(X), X.setMap(null);
    };
  }, []), null;
}
me(m3e);
class v3e extends pe {
  constructor() {
    super(...arguments), Me(this, "registeredEvents", []), Me(this, "state", {
      rectangle: null
    }), Me(this, "setRectangleCallback", () => {
      this.state.rectangle !== null && this.props.onLoad && this.props.onLoad(this.state.rectangle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Rectangle(Ew(Ew({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Cn({
      updaterMap: X9,
      eventMap: K9,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        rectangle: t
      };
    }, this.setRectangleCallback);
  }
  componentDidUpdate(t) {
    this.state.rectangle !== null && (Pn(this.registeredEvents), this.registeredEvents = Cn({
      updaterMap: X9,
      eventMap: K9,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.rectangle
    }));
  }
  componentWillUnmount() {
    this.state.rectangle !== null && (this.props.onUnmount && this.props.onUnmount(this.state.rectangle), Pn(this.registeredEvents), this.state.rectangle.setMap(null));
  }
  render() {
    return null;
  }
}
Me(v3e, "contextType", Ft);
function Y9(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function kw(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Y9(Object(n), !0).forEach(function(r) {
      Me(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Y9(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var J9 = {
  onCenterChanged: "center_changed",
  onRadiusChanged: "radius_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, Q9 = {
  center(e, t) {
    e.setCenter(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  radius(e, t) {
    e.setRadius(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, y3e = {};
function b3e(e) {
  var {
    options: t,
    center: n,
    radius: r,
    draggable: o,
    editable: i,
    visible: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: g,
    onMouseUp: f,
    onRightClick: m,
    onClick: b,
    onDrag: E,
    onCenterChanged: w,
    onRadiusChanged: M,
    onLoad: x,
    onUnmount: v
  } = e, C = ge(Ft), [P, F] = k(null), [L, B] = k(null), [N, $] = k(null), [V, H] = k(null), [Z, K] = k(null), [Y, Q] = k(null), [J, _] = k(null), [D, z] = k(null), [S, W] = k(null), [O, j] = k(null), [U, T] = k(null), [q, A] = k(null), [X, I] = k(null), [le, he] = k(null);
  return h(() => {
    P !== null && P.setMap(C);
  }, [C]), h(() => {
    typeof t < "u" && P !== null && P.setOptions(t);
  }, [P, t]), h(() => {
    typeof o < "u" && P !== null && P.setDraggable(o);
  }, [P, o]), h(() => {
    typeof i < "u" && P !== null && P.setEditable(i);
  }, [P, i]), h(() => {
    typeof a < "u" && P !== null && P.setVisible(a);
  }, [P, a]), h(() => {
    typeof r == "number" && P !== null && P.setRadius(r);
  }, [P, r]), h(() => {
    typeof n < "u" && P !== null && P.setCenter(n);
  }, [P, n]), h(() => {
    P && s && (L !== null && google.maps.event.removeListener(L), B(google.maps.event.addListener(P, "dblclick", s)));
  }, [s]), h(() => {
    P && l && (N !== null && google.maps.event.removeListener(N), $(google.maps.event.addListener(P, "dragend", l)));
  }, [l]), h(() => {
    P && u && (V !== null && google.maps.event.removeListener(V), H(google.maps.event.addListener(P, "dragstart", u)));
  }, [u]), h(() => {
    P && c && (Z !== null && google.maps.event.removeListener(Z), K(google.maps.event.addListener(P, "mousedown", c)));
  }, [c]), h(() => {
    P && p && (Y !== null && google.maps.event.removeListener(Y), Q(google.maps.event.addListener(P, "mousemove", p)));
  }, [p]), h(() => {
    P && d && (J !== null && google.maps.event.removeListener(J), _(google.maps.event.addListener(P, "mouseout", d)));
  }, [d]), h(() => {
    P && g && (D !== null && google.maps.event.removeListener(D), z(google.maps.event.addListener(P, "mouseover", g)));
  }, [g]), h(() => {
    P && f && (S !== null && google.maps.event.removeListener(S), W(google.maps.event.addListener(P, "mouseup", f)));
  }, [f]), h(() => {
    P && m && (O !== null && google.maps.event.removeListener(O), j(google.maps.event.addListener(P, "rightclick", m)));
  }, [m]), h(() => {
    P && b && (U !== null && google.maps.event.removeListener(U), T(google.maps.event.addListener(P, "click", b)));
  }, [b]), h(() => {
    P && E && (q !== null && google.maps.event.removeListener(q), A(google.maps.event.addListener(P, "drag", E)));
  }, [E]), h(() => {
    P && w && (X !== null && google.maps.event.removeListener(X), I(google.maps.event.addListener(P, "center_changed", w)));
  }, [b]), h(() => {
    P && M && (le !== null && google.maps.event.removeListener(le), he(google.maps.event.addListener(P, "radius_changed", M)));
  }, [M]), h(() => {
    var oe = new google.maps.Circle(kw(kw({}, t || y3e), {}, {
      map: C
    }));
    return typeof r == "number" && oe.setRadius(r), typeof n < "u" && oe.setCenter(n), typeof r == "number" && oe.setRadius(r), typeof a < "u" && oe.setVisible(a), typeof i < "u" && oe.setEditable(i), typeof o < "u" && oe.setDraggable(o), s && B(google.maps.event.addListener(oe, "dblclick", s)), l && $(google.maps.event.addListener(oe, "dragend", l)), u && H(google.maps.event.addListener(oe, "dragstart", u)), c && K(google.maps.event.addListener(oe, "mousedown", c)), p && Q(google.maps.event.addListener(oe, "mousemove", p)), d && _(google.maps.event.addListener(oe, "mouseout", d)), g && z(google.maps.event.addListener(oe, "mouseover", g)), f && W(google.maps.event.addListener(oe, "mouseup", f)), m && j(google.maps.event.addListener(oe, "rightclick", m)), b && T(google.maps.event.addListener(oe, "click", b)), E && A(google.maps.event.addListener(oe, "drag", E)), w && I(google.maps.event.addListener(oe, "center_changed", w)), M && he(google.maps.event.addListener(oe, "radius_changed", M)), F(oe), x && x(oe), () => {
      L !== null && google.maps.event.removeListener(L), N !== null && google.maps.event.removeListener(N), V !== null && google.maps.event.removeListener(V), Z !== null && google.maps.event.removeListener(Z), Y !== null && google.maps.event.removeListener(Y), J !== null && google.maps.event.removeListener(J), D !== null && google.maps.event.removeListener(D), S !== null && google.maps.event.removeListener(S), O !== null && google.maps.event.removeListener(O), U !== null && google.maps.event.removeListener(U), X !== null && google.maps.event.removeListener(X), le !== null && google.maps.event.removeListener(le), v && v(oe), oe.setMap(null);
    };
  }, []), null;
}
me(b3e);
class w3e extends pe {
  constructor() {
    super(...arguments), Me(this, "registeredEvents", []), Me(this, "state", {
      circle: null
    }), Me(this, "setCircleCallback", () => {
      this.state.circle !== null && this.props.onLoad && this.props.onLoad(this.state.circle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Circle(kw(kw({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Cn({
      updaterMap: Q9,
      eventMap: J9,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        circle: t
      };
    }, this.setCircleCallback);
  }
  componentDidUpdate(t) {
    this.state.circle !== null && (Pn(this.registeredEvents), this.registeredEvents = Cn({
      updaterMap: Q9,
      eventMap: J9,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.circle
    }));
  }
  componentWillUnmount() {
    if (this.state.circle !== null) {
      var t;
      this.props.onUnmount && this.props.onUnmount(this.state.circle), Pn(this.registeredEvents), (t = this.state.circle) === null || t === void 0 || t.setMap(null);
    }
  }
  render() {
    return null;
  }
}
Me(w3e, "contextType", Ft);
function e6(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Lw(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? e6(Object(n), !0).forEach(function(r) {
      Me(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : e6(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var t6 = {
  onClick: "click",
  onDblClick: "dblclick",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onAddFeature: "addfeature",
  onRemoveFeature: "removefeature",
  onRemoveProperty: "removeproperty",
  onSetGeometry: "setgeometry",
  onSetProperty: "setproperty"
}, n6 = {
  add(e, t) {
    e.add(t);
  },
  addgeojson(e, t, n) {
    e.addGeoJson(t, n);
  },
  contains(e, t) {
    e.contains(t);
  },
  foreach(e, t) {
    e.forEach(t);
  },
  loadgeojson(e, t, n, r) {
    e.loadGeoJson(t, n, r);
  },
  overridestyle(e, t, n) {
    e.overrideStyle(t, n);
  },
  remove(e, t) {
    e.remove(t);
  },
  revertstyle(e, t) {
    e.revertStyle(t);
  },
  controlposition(e, t) {
    e.setControlPosition(t);
  },
  controls(e, t) {
    e.setControls(t);
  },
  drawingmode(e, t) {
    e.setDrawingMode(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  style(e, t) {
    e.setStyle(t);
  },
  togeojson(e, t) {
    e.toGeoJson(t);
  }
};
function C3e(e) {
  var {
    options: t,
    onClick: n,
    onDblClick: r,
    onMouseDown: o,
    onMouseMove: i,
    onMouseOut: a,
    onMouseOver: s,
    onMouseUp: l,
    onRightClick: u,
    onAddFeature: c,
    onRemoveFeature: p,
    onRemoveProperty: d,
    onSetGeometry: g,
    onSetProperty: f,
    onLoad: m,
    onUnmount: b
  } = e, E = ge(Ft), [w, M] = k(null), [x, v] = k(null), [C, P] = k(null), [F, L] = k(null), [B, N] = k(null), [$, V] = k(null), [H, Z] = k(null), [K, Y] = k(null), [Q, J] = k(null), [_, D] = k(null), [z, S] = k(null), [W, O] = k(null), [j, U] = k(null), [T, q] = k(null);
  return h(() => {
    w !== null && w.setMap(E);
  }, [E]), h(() => {
    w && r && (x !== null && google.maps.event.removeListener(x), v(google.maps.event.addListener(w, "dblclick", r)));
  }, [r]), h(() => {
    w && o && (C !== null && google.maps.event.removeListener(C), P(google.maps.event.addListener(w, "mousedown", o)));
  }, [o]), h(() => {
    w && i && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(w, "mousemove", i)));
  }, [i]), h(() => {
    w && a && (B !== null && google.maps.event.removeListener(B), N(google.maps.event.addListener(w, "mouseout", a)));
  }, [a]), h(() => {
    w && s && ($ !== null && google.maps.event.removeListener($), V(google.maps.event.addListener(w, "mouseover", s)));
  }, [s]), h(() => {
    w && l && (H !== null && google.maps.event.removeListener(H), Z(google.maps.event.addListener(w, "mouseup", l)));
  }, [l]), h(() => {
    w && u && (K !== null && google.maps.event.removeListener(K), Y(google.maps.event.addListener(w, "rightclick", u)));
  }, [u]), h(() => {
    w && n && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(w, "click", n)));
  }, [n]), h(() => {
    w && c && (_ !== null && google.maps.event.removeListener(_), D(google.maps.event.addListener(w, "addfeature", c)));
  }, [c]), h(() => {
    w && p && (z !== null && google.maps.event.removeListener(z), S(google.maps.event.addListener(w, "removefeature", p)));
  }, [p]), h(() => {
    w && d && (W !== null && google.maps.event.removeListener(W), O(google.maps.event.addListener(w, "removeproperty", d)));
  }, [d]), h(() => {
    w && g && (j !== null && google.maps.event.removeListener(j), U(google.maps.event.addListener(w, "setgeometry", g)));
  }, [g]), h(() => {
    w && f && (T !== null && google.maps.event.removeListener(T), q(google.maps.event.addListener(w, "setproperty", f)));
  }, [f]), h(() => {
    if (E !== null) {
      var A = new google.maps.Data(Lw(Lw({}, t), {}, {
        map: E
      }));
      r && v(google.maps.event.addListener(A, "dblclick", r)), o && P(google.maps.event.addListener(A, "mousedown", o)), i && L(google.maps.event.addListener(A, "mousemove", i)), a && N(google.maps.event.addListener(A, "mouseout", a)), s && V(google.maps.event.addListener(A, "mouseover", s)), l && Z(google.maps.event.addListener(A, "mouseup", l)), u && Y(google.maps.event.addListener(A, "rightclick", u)), n && J(google.maps.event.addListener(A, "click", n)), c && D(google.maps.event.addListener(A, "addfeature", c)), p && S(google.maps.event.addListener(A, "removefeature", p)), d && O(google.maps.event.addListener(A, "removeproperty", d)), g && U(google.maps.event.addListener(A, "setgeometry", g)), f && q(google.maps.event.addListener(A, "setproperty", f)), M(A), m && m(A);
    }
    return () => {
      w && (x !== null && google.maps.event.removeListener(x), C !== null && google.maps.event.removeListener(C), F !== null && google.maps.event.removeListener(F), B !== null && google.maps.event.removeListener(B), $ !== null && google.maps.event.removeListener($), H !== null && google.maps.event.removeListener(H), K !== null && google.maps.event.removeListener(K), Q !== null && google.maps.event.removeListener(Q), _ !== null && google.maps.event.removeListener(_), z !== null && google.maps.event.removeListener(z), W !== null && google.maps.event.removeListener(W), j !== null && google.maps.event.removeListener(j), T !== null && google.maps.event.removeListener(T), b && b(w), w.setMap(null));
    };
  }, []), null;
}
me(C3e);
class O3e extends pe {
  constructor() {
    super(...arguments), Me(this, "registeredEvents", []), Me(this, "state", {
      data: null
    }), Me(this, "setDataCallback", () => {
      this.state.data !== null && this.props.onLoad && this.props.onLoad(this.state.data);
    });
  }
  componentDidMount() {
    if (this.context !== null) {
      var t = new google.maps.Data(Lw(Lw({}, this.props.options), {}, {
        map: this.context
      }));
      this.registeredEvents = Cn({
        updaterMap: n6,
        eventMap: t6,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        data: t
      }), this.setDataCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.data !== null && (Pn(this.registeredEvents), this.registeredEvents = Cn({
      updaterMap: n6,
      eventMap: t6,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.data
    }));
  }
  componentWillUnmount() {
    this.state.data !== null && (this.props.onUnmount && this.props.onUnmount(this.state.data), Pn(this.registeredEvents), this.state.data && this.state.data.setMap(null));
  }
  render() {
    return null;
  }
}
Me(O3e, "contextType", Ft);
function r6(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function o6(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? r6(Object(n), !0).forEach(function(r) {
      Me(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : r6(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var i6 = {
  onClick: "click",
  onDefaultViewportChanged: "defaultviewport_changed",
  onStatusChanged: "status_changed"
}, s6 = {
  options(e, t) {
    e.setOptions(t);
  },
  url(e, t) {
    e.setUrl(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
class x3e extends pe {
  constructor() {
    super(...arguments), Me(this, "registeredEvents", []), Me(this, "state", {
      kmlLayer: null
    }), Me(this, "setKmlLayerCallback", () => {
      this.state.kmlLayer !== null && this.props.onLoad && this.props.onLoad(this.state.kmlLayer);
    });
  }
  componentDidMount() {
    var t = new google.maps.KmlLayer(o6(o6({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Cn({
      updaterMap: s6,
      eventMap: i6,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        kmlLayer: t
      };
    }, this.setKmlLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.kmlLayer !== null && (Pn(this.registeredEvents), this.registeredEvents = Cn({
      updaterMap: s6,
      eventMap: i6,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.kmlLayer
    }));
  }
  componentWillUnmount() {
    this.state.kmlLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.kmlLayer), Pn(this.registeredEvents), this.state.kmlLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Me(x3e, "contextType", Ft);
function ire(e, t) {
  return typeof t == "function" ? t(e.offsetWidth, e.offsetHeight) : {
    x: 0,
    y: 0
  };
}
function E3e(e, t) {
  return new t(e.lat, e.lng);
}
function k3e(e, t) {
  return new t(new google.maps.LatLng(e.ne.lat, e.ne.lng), new google.maps.LatLng(e.sw.lat, e.sw.lng));
}
function L3e(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function _3e(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function P3e(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n.getNorthEast()), o = e && e.fromLatLngToDivPixel(n.getSouthWest());
  return r && o ? {
    left: "".concat(o.x + t.x, "px"),
    top: "".concat(r.y + t.y, "px"),
    width: "".concat(r.x - o.x - t.x, "px"),
    height: "".concat(o.y - r.y - t.y, "px")
  } : {
    left: "-9999px",
    top: "-9999px"
  };
}
function S3e(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n);
  if (r) {
    var {
      x: o,
      y: i
    } = r;
    return {
      left: "".concat(o + t.x, "px"),
      top: "".concat(i + t.y, "px")
    };
  }
  return {
    left: "-9999px",
    top: "-9999px"
  };
}
function sre(e, t, n, r) {
  return n !== void 0 ? P3e(e, t, _3e(n, google.maps.LatLngBounds, k3e)) : S3e(e, t, L3e(r, google.maps.LatLng, E3e));
}
function M3e(e, t) {
  return e.left === t.left && e.top === t.top && e.width === t.height && e.height === t.height;
}
function a6(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function D3e(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? a6(Object(n), !0).forEach(function(r) {
      Me(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : a6(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function T3e(e, t, n, r, o) {
  class i extends google.maps.OverlayView {
    constructor(s, l, u, c) {
      super(), this.container = s, this.pane = l, this.position = u, this.bounds = c;
    }
    onAdd() {
      var s, l = (s = this.getPanes()) === null || s === void 0 ? void 0 : s[this.pane];
      l == null || l.appendChild(this.container);
    }
    draw() {
      var s = this.getProjection(), l = D3e({}, this.container ? ire(this.container, o) : {
        x: 0,
        y: 0
      }), u = sre(s, l, this.bounds, this.position);
      for (var [c, p] of Object.entries(u))
        this.container.style[c] = p;
    }
    onRemove() {
      this.container.parentNode !== null && this.container.parentNode.removeChild(this.container);
    }
  }
  return new i(e, t, n, r);
}
function l6(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function j3e(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? l6(Object(n), !0).forEach(function(r) {
      Me(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : l6(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function u6(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLng ? e : new google.maps.LatLng(e.lat, e.lng);
  return t + "";
}
function c6(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLngBounds ? e : new google.maps.LatLngBounds(new google.maps.LatLng(e.south, e.east), new google.maps.LatLng(e.north, e.west));
  return t + "";
}
function A3e(e) {
  var {
    position: t,
    bounds: n,
    mapPaneName: r,
    zIndex: o,
    onLoad: i,
    onUnmount: a,
    getPixelPositionOffset: s,
    children: l
  } = e, u = ge(Ft), c = ln(() => {
    var d = document.createElement("div");
    return d.style.position = "absolute", d;
  }, []), p = ln(() => T3e(c, r, t, n, s), [c, r, t, n]);
  return h(() => (i == null || i(p), p == null || p.setMap(u), () => {
    a == null || a(p), p == null || p.setMap(null);
  }), [u, p]), h(() => {
    c.style.zIndex = "".concat(o);
  }, [o, c]), wi.createPortal(l, c);
}
me(A3e);
class qp extends pe {
  constructor(t) {
    super(t), Me(this, "state", {
      paneEl: null,
      containerStyle: {
        // set initial position
        position: "absolute"
      }
    }), Me(this, "updatePane", () => {
      var r = this.props.mapPaneName, o = this.overlayView.getPanes();
      Vo(!!r, "OverlayView requires props.mapPaneName but got %s", r), o ? this.setState({
        paneEl: o[r]
      }) : this.setState({
        paneEl: null
      });
    }), Me(this, "onAdd", () => {
      var r, o;
      this.updatePane(), (r = (o = this.props).onLoad) === null || r === void 0 || r.call(o, this.overlayView);
    }), Me(this, "onPositionElement", () => {
      var r = this.overlayView.getProjection(), o = j3e({
        x: 0,
        y: 0
      }, this.containerRef.current ? ire(this.containerRef.current, this.props.getPixelPositionOffset) : {}), i = sre(r, o, this.props.bounds, this.props.position);
      if (!M3e(i, {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        left: this.state.containerStyle.left,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        top: this.state.containerStyle.top,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        width: this.state.containerStyle.width,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        height: this.state.containerStyle.height
      })) {
        var a, s, l, u;
        this.setState({
          containerStyle: {
            top: (a = i.top) !== null && a !== void 0 ? a : 0,
            left: (s = i.left) !== null && s !== void 0 ? s : 0,
            width: (l = i.width) !== null && l !== void 0 ? l : 0,
            height: (u = i.height) !== null && u !== void 0 ? u : 0,
            position: "absolute"
          }
        });
      }
    }), Me(this, "draw", () => {
      this.onPositionElement();
    }), Me(this, "onRemove", () => {
      var r, o;
      this.setState(() => ({
        paneEl: null
      })), (r = (o = this.props).onUnmount) === null || r === void 0 || r.call(o, this.overlayView);
    }), this.containerRef = so();
    var n = new google.maps.OverlayView();
    n.onAdd = this.onAdd, n.draw = this.draw, n.onRemove = this.onRemove, this.overlayView = n;
  }
  componentDidMount() {
    this.overlayView.setMap(this.context);
  }
  componentDidUpdate(t) {
    var n = u6(t.position), r = u6(this.props.position), o = c6(t.bounds), i = c6(this.props.bounds);
    (n !== r || o !== i) && this.overlayView.draw(), t.mapPaneName !== this.props.mapPaneName && this.updatePane();
  }
  componentWillUnmount() {
    this.overlayView.setMap(null);
  }
  render() {
    var t = this.state.paneEl;
    return t ? wi.createPortal(Jo.jsx("div", {
      ref: this.containerRef,
      style: this.state.containerStyle,
      children: at.only(this.props.children)
    }), t) : null;
  }
}
Me(qp, "FLOAT_PANE", "floatPane");
Me(qp, "MAP_PANE", "mapPane");
Me(qp, "MARKER_LAYER", "markerLayer");
Me(qp, "OVERLAY_LAYER", "overlayLayer");
Me(qp, "OVERLAY_MOUSE_TARGET", "overlayMouseTarget");
Me(qp, "contextType", Ft);
function R3e() {
}
function p6(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function d6(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? p6(Object(n), !0).forEach(function(r) {
      Me(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : p6(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var f6 = {
  onDblClick: "dblclick",
  onClick: "click"
}, h6 = {
  opacity(e, t) {
    e.setOpacity(t);
  }
};
function I3e(e) {
  var {
    url: t,
    bounds: n,
    options: r,
    visible: o
  } = e, i = ge(Ft), a = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east)), s = ln(() => new google.maps.GroundOverlay(t, a, r), []);
  return h(() => {
    s !== null && s.setMap(i);
  }, [i]), h(() => {
    typeof t < "u" && s !== null && (s.set("url", t), s.setMap(i));
  }, [s, t]), h(() => {
    typeof o < "u" && s !== null && s.setOpacity(o ? 1 : 0);
  }, [s, o]), h(() => {
    var l = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east));
    typeof n < "u" && s !== null && (s.set("bounds", l), s.setMap(i));
  }, [s, n]), null;
}
me(I3e);
class are extends pe {
  constructor() {
    super(...arguments), Me(this, "registeredEvents", []), Me(this, "state", {
      groundOverlay: null
    }), Me(this, "setGroundOverlayCallback", () => {
      this.state.groundOverlay !== null && this.props.onLoad && this.props.onLoad(this.state.groundOverlay);
    });
  }
  componentDidMount() {
    Vo(!!this.props.url || !!this.props.bounds, "For GroundOverlay, url and bounds are passed in to constructor and are immutable after instantiated. This is the behavior of Google Maps JavaScript API v3 ( See https://developers.google.com/maps/documentation/javascript/reference#GroundOverlay) Hence, use the corresponding two props provided by `react-google-maps-api`, url and bounds. In some cases, you'll need the GroundOverlay component to reflect the changes of url and bounds. You can leverage the React's key property to remount the component. Typically, just `key={url}` would serve your need. See https://github.com/tomchentw/react-google-maps/issues/655");
    var t = new google.maps.GroundOverlay(this.props.url, this.props.bounds, d6(d6({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Cn({
      updaterMap: h6,
      eventMap: f6,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        groundOverlay: t
      };
    }, this.setGroundOverlayCallback);
  }
  componentDidUpdate(t) {
    this.state.groundOverlay !== null && (Pn(this.registeredEvents), this.registeredEvents = Cn({
      updaterMap: h6,
      eventMap: f6,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.groundOverlay
    }));
  }
  componentWillUnmount() {
    this.state.groundOverlay && (this.props.onUnmount && this.props.onUnmount(this.state.groundOverlay), this.state.groundOverlay.setMap(null));
  }
  render() {
    return null;
  }
}
Me(are, "defaultProps", {
  onLoad: R3e
});
Me(are, "contextType", Ft);
function g6(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function _w(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? g6(Object(n), !0).forEach(function(r) {
      Me(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : g6(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var m6 = {}, v6 = {
  data(e, t) {
    e.setData(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function N3e(e) {
  var {
    data: t,
    onLoad: n,
    onUnmount: r,
    options: o
  } = e, i = ge(Ft), [a, s] = k(null);
  return h(() => {
    google.maps.visualization || Vo(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} in useJsApiScript? %s', google.maps.visualization);
  }, []), h(() => {
    Vo(!!t, "data property is required in HeatmapLayer %s", t);
  }, [t]), h(() => {
    a !== null && a.setMap(i);
  }, [i]), h(() => {
    o && a !== null && a.setOptions(o);
  }, [a, o]), h(() => {
    var l = new google.maps.visualization.HeatmapLayer(_w(_w({}, o), {}, {
      data: t,
      map: i
    }));
    return s(l), n && n(l), () => {
      a !== null && (r && r(a), a.setMap(null));
    };
  }, []), null;
}
me(N3e);
class B3e extends pe {
  constructor() {
    super(...arguments), Me(this, "registeredEvents", []), Me(this, "state", {
      heatmapLayer: null
    }), Me(this, "setHeatmapLayerCallback", () => {
      this.state.heatmapLayer !== null && this.props.onLoad && this.props.onLoad(this.state.heatmapLayer);
    });
  }
  componentDidMount() {
    Vo(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} to <LoadScript />? %s', google.maps.visualization), Vo(!!this.props.data, "data property is required in HeatmapLayer %s", this.props.data);
    var t = new google.maps.visualization.HeatmapLayer(_w(_w({}, this.props.options), {}, {
      data: this.props.data,
      map: this.context
    }));
    this.registeredEvents = Cn({
      updaterMap: v6,
      eventMap: m6,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        heatmapLayer: t
      };
    }, this.setHeatmapLayerCallback);
  }
  componentDidUpdate(t) {
    Pn(this.registeredEvents), this.registeredEvents = Cn({
      updaterMap: v6,
      eventMap: m6,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.heatmapLayer
    });
  }
  componentWillUnmount() {
    this.state.heatmapLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.heatmapLayer), Pn(this.registeredEvents), this.state.heatmapLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Me(B3e, "contextType", Ft);
var y6 = {
  onCloseClick: "closeclick",
  onPanoChanged: "pano_changed",
  onPositionChanged: "position_changed",
  onPovChanged: "pov_changed",
  onResize: "resize",
  onStatusChanged: "status_changed",
  onVisibleChanged: "visible_changed",
  onZoomChanged: "zoom_changed"
}, b6 = {
  register(e, t, n) {
    e.registerPanoProvider(t, n);
  },
  links(e, t) {
    e.setLinks(t);
  },
  motionTracking(e, t) {
    e.setMotionTracking(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  pano(e, t) {
    e.setPano(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  pov(e, t) {
    e.setPov(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zoom(e, t) {
    e.setZoom(t);
  }
};
class F3e extends pe {
  constructor() {
    super(...arguments), Me(this, "registeredEvents", []), Me(this, "state", {
      streetViewPanorama: null
    }), Me(this, "setStreetViewPanoramaCallback", () => {
      this.state.streetViewPanorama !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewPanorama);
    });
  }
  componentDidMount() {
    var t, n, r = (t = (n = this.context) === null || n === void 0 ? void 0 : n.getStreetView()) !== null && t !== void 0 ? t : null;
    this.registeredEvents = Cn({
      updaterMap: b6,
      eventMap: y6,
      prevProps: {},
      nextProps: this.props,
      instance: r
    }), this.setState(() => ({
      streetViewPanorama: r
    }), this.setStreetViewPanoramaCallback);
  }
  componentDidUpdate(t) {
    this.state.streetViewPanorama !== null && (Pn(this.registeredEvents), this.registeredEvents = Cn({
      updaterMap: b6,
      eventMap: y6,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.streetViewPanorama
    }));
  }
  componentWillUnmount() {
    this.state.streetViewPanorama !== null && (this.props.onUnmount && this.props.onUnmount(this.state.streetViewPanorama), Pn(this.registeredEvents), this.state.streetViewPanorama.setVisible(!1));
  }
  render() {
    return null;
  }
}
Me(F3e, "contextType", Ft);
class z3e extends pe {
  constructor() {
    super(...arguments), Me(this, "state", {
      streetViewService: null
    }), Me(this, "setStreetViewServiceCallback", () => {
      this.state.streetViewService !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewService);
    });
  }
  componentDidMount() {
    var t = new google.maps.StreetViewService();
    this.setState(function() {
      return {
        streetViewService: t
      };
    }, this.setStreetViewServiceCallback);
  }
  componentWillUnmount() {
    this.state.streetViewService !== null && this.props.onUnmount && this.props.onUnmount(this.state.streetViewService);
  }
  render() {
    return null;
  }
}
Me(z3e, "contextType", Ft);
var w6 = {
  onDirectionsChanged: "directions_changed"
}, C6 = {
  directions(e, t) {
    e.setDirections(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  panel(e, t) {
    e.setPanel(t);
  },
  routeIndex(e, t) {
    e.setRouteIndex(t);
  }
};
class U3e extends pe {
  constructor() {
    super(...arguments), Me(this, "registeredEvents", []), Me(this, "state", {
      directionsRenderer: null
    }), Me(this, "setDirectionsRendererCallback", () => {
      this.state.directionsRenderer !== null && (this.state.directionsRenderer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.directionsRenderer));
    });
  }
  componentDidMount() {
    var t = new google.maps.DirectionsRenderer(this.props.options);
    this.registeredEvents = Cn({
      updaterMap: C6,
      eventMap: w6,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        directionsRenderer: t
      };
    }, this.setDirectionsRendererCallback);
  }
  componentDidUpdate(t) {
    this.state.directionsRenderer !== null && (Pn(this.registeredEvents), this.registeredEvents = Cn({
      updaterMap: C6,
      eventMap: w6,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.directionsRenderer
    }));
  }
  componentWillUnmount() {
    this.state.directionsRenderer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.directionsRenderer), Pn(this.registeredEvents), this.state.directionsRenderer && this.state.directionsRenderer.setMap(null));
  }
  render() {
    return null;
  }
}
Me(U3e, "contextType", Ft);
var O6 = {
  onPlacesChanged: "places_changed"
}, x6 = {
  bounds(e, t) {
    e.setBounds(t);
  }
};
class H3e extends pe {
  constructor() {
    super(...arguments), Me(this, "registeredEvents", []), Me(this, "containerElement", so()), Me(this, "state", {
      searchBox: null
    }), Me(this, "setSearchBoxCallback", () => {
      this.state.searchBox !== null && this.props.onLoad && this.props.onLoad(this.state.searchBox);
    });
  }
  componentDidMount() {
    if (Vo(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places), this.containerElement !== null && this.containerElement.current !== null) {
      var t = this.containerElement.current.querySelector("input");
      if (t !== null) {
        var n = new google.maps.places.SearchBox(t, this.props.options);
        this.registeredEvents = Cn({
          updaterMap: x6,
          eventMap: O6,
          prevProps: {},
          nextProps: this.props,
          instance: n
        }), this.setState(function() {
          return {
            searchBox: n
          };
        }, this.setSearchBoxCallback);
      }
    }
  }
  componentDidUpdate(t) {
    this.state.searchBox !== null && (Pn(this.registeredEvents), this.registeredEvents = Cn({
      updaterMap: x6,
      eventMap: O6,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.searchBox
    }));
  }
  componentWillUnmount() {
    this.state.searchBox !== null && (this.props.onUnmount && this.props.onUnmount(this.state.searchBox), Pn(this.registeredEvents));
  }
  render() {
    return Jo.jsx("div", {
      ref: this.containerElement,
      children: at.only(this.props.children)
    });
  }
}
Me(H3e, "contextType", Ft);
var E6 = {
  onPlaceChanged: "place_changed"
}, k6 = {
  bounds(e, t) {
    e.setBounds(t);
  },
  restrictions(e, t) {
    e.setComponentRestrictions(t);
  },
  fields(e, t) {
    e.setFields(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  types(e, t) {
    e.setTypes(t);
  }
};
class lre extends pe {
  constructor() {
    super(...arguments), Me(this, "registeredEvents", []), Me(this, "containerElement", so()), Me(this, "state", {
      autocomplete: null
    }), Me(this, "setAutocompleteCallback", () => {
      this.state.autocomplete !== null && this.props.onLoad && this.props.onLoad(this.state.autocomplete);
    });
  }
  componentDidMount() {
    var t;
    Vo(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places);
    var n = (t = this.containerElement.current) === null || t === void 0 ? void 0 : t.querySelector("input");
    if (n) {
      var r = new google.maps.places.Autocomplete(n, this.props.options);
      this.registeredEvents = Cn({
        updaterMap: k6,
        eventMap: E6,
        prevProps: {},
        nextProps: this.props,
        instance: r
      }), this.setState(() => ({
        autocomplete: r
      }), this.setAutocompleteCallback);
    }
  }
  componentDidUpdate(t) {
    Pn(this.registeredEvents), this.registeredEvents = Cn({
      updaterMap: k6,
      eventMap: E6,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.autocomplete
    });
  }
  componentWillUnmount() {
    this.state.autocomplete !== null && Pn(this.registeredEvents);
  }
  render() {
    return Jo.jsx("div", {
      ref: this.containerElement,
      className: this.props.className,
      children: at.only(this.props.children)
    });
  }
}
Me(lre, "defaultProps", {
  className: ""
});
Me(lre, "contextType", Ft);
let W3e = { data: "" }, $3e = (e) => typeof window == "object" ? ((e ? e.querySelector("#_goober") : window._goober) || Object.assign((e || document.head).appendChild(document.createElement("style")), { innerHTML: " ", id: "_goober" })).firstChild : e || W3e, V3e = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g, Z3e = /\/\*[^]*?\*\/|  +/g, L6 = /\n+/g, Ql = (e, t) => {
  let n = "", r = "", o = "";
  for (let i in e) {
    let a = e[i];
    i[0] == "@" ? i[1] == "i" ? n = i + " " + a + ";" : r += i[1] == "f" ? Ql(a, i) : i + "{" + Ql(a, i[1] == "k" ? "" : t) + "}" : typeof a == "object" ? r += Ql(a, t ? t.replace(/([^,])+/g, (s) => i.replace(/([^,]*:\S+\([^)]*\))|([^,])+/g, (l) => /&/.test(l) ? l.replace(/&/g, s) : s ? s + " " + l : l)) : i) : a != null && (i = /^--/.test(i) ? i : i.replace(/[A-Z]/g, "-$&").toLowerCase(), o += Ql.p ? Ql.p(i, a) : i + ":" + a + ";");
  }
  return n + (t && o ? t + "{" + o + "}" : o) + r;
}, Na = {}, ure = (e) => {
  if (typeof e == "object") {
    let t = "";
    for (let n in e) t += n + ure(e[n]);
    return t;
  }
  return e;
}, q3e = (e, t, n, r, o) => {
  let i = ure(e), a = Na[i] || (Na[i] = ((l) => {
    let u = 0, c = 11;
    for (; u < l.length; ) c = 101 * c + l.charCodeAt(u++) >>> 0;
    return "go" + c;
  })(i));
  if (!Na[a]) {
    let l = i !== e ? e : ((u) => {
      let c, p, d = [{}];
      for (; c = V3e.exec(u.replace(Z3e, "")); ) c[4] ? d.shift() : c[3] ? (p = c[3].replace(L6, " ").trim(), d.unshift(d[0][p] = d[0][p] || {})) : d[0][c[1]] = c[2].replace(L6, " ").trim();
      return d[0];
    })(e);
    Na[a] = Ql(o ? { ["@keyframes " + a]: l } : l, n ? "" : "." + a);
  }
  let s = n && Na.g ? Na.g : null;
  return n && (Na.g = Na[a]), ((l, u, c, p) => {
    p ? u.data = u.data.replace(p, l) : u.data.indexOf(l) === -1 && (u.data = c ? l + u.data : u.data + l);
  })(Na[a], t, r, s), a;
}, G3e = (e, t, n) => e.reduce((r, o, i) => {
  let a = t[i];
  if (a && a.call) {
    let s = a(n), l = s && s.props && s.props.className || /^go/.test(s) && s;
    a = l ? "." + l : s && typeof s == "object" ? s.props ? "" : Ql(s, "") : s === !1 ? "" : s;
  }
  return r + o + (a ?? "");
}, "");
function AO(e) {
  let t = this || {}, n = e.call ? e(t.p) : e;
  return q3e(n.unshift ? n.raw ? G3e(n, [].slice.call(arguments, 1), t.p) : n.reduce((r, o) => Object.assign(r, o && o.call ? o(t.p) : o), {}) : n, $3e(t.target), t.g, t.o, t.k);
}
let cre, pP, dP;
AO.bind({ g: 1 });
let el = AO.bind({ k: 1 });
function K3e(e, t, n, r) {
  Ql.p = t, cre = e, pP = n, dP = r;
}
function Pu(e, t) {
  let n = this || {};
  return function() {
    let r = arguments;
    function o(i, a) {
      let s = Object.assign({}, i), l = s.className || o.className;
      n.p = Object.assign({ theme: pP && pP() }, s), n.o = / *go\d+/.test(l), s.className = AO.apply(n, r) + (l ? " " + l : "");
      let u = e;
      return e[0] && (u = s.as || e, delete s.as), dP && u[0] && dP(s), cre(u, s);
    }
    return o;
  };
}
var X3e = (e) => typeof e == "function", Y3e = (e, t) => X3e(e) ? e(t) : e, J3e = /* @__PURE__ */ (() => {
  let e;
  return () => {
    if (e === void 0 && typeof window < "u") {
      let t = matchMedia("(prefers-reduced-motion: reduce)");
      e = !t || t.matches;
    }
    return e;
  };
})(), Q3e = el`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`, eVe = el`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`, tVe = el`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`, nVe = Pu("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${Q3e} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${eVe} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${(e) => e.secondary || "#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${tVe} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`, rVe = el`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, oVe = Pu("div")`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${(e) => e.secondary || "#e0e0e0"};
  border-right-color: ${(e) => e.primary || "#616161"};
  animation: ${rVe} 1s linear infinite;
`, iVe = el`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`, sVe = el`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`, aVe = Pu("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${iVe} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${sVe} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${(e) => e.secondary || "#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`, lVe = Pu("div")`
  position: absolute;
`, uVe = Pu("div")`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`, cVe = el`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`, pVe = Pu("div")`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${cVe} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`, dVe = ({ toast: e }) => {
  let { icon: t, type: n, iconTheme: r } = e;
  return t !== void 0 ? typeof t == "string" ? Ne.createElement(pVe, null, t) : t : n === "blank" ? null : Ne.createElement(uVe, null, Ne.createElement(oVe, { ...r }), n !== "loading" && Ne.createElement(lVe, null, n === "error" ? Ne.createElement(nVe, { ...r }) : Ne.createElement(aVe, { ...r })));
}, fVe = (e) => `
0% {transform: translate3d(0,${e * -200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`, hVe = (e) => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${e * -150}%,-1px) scale(.6); opacity:0;}
`, gVe = "0%{opacity:0;} 100%{opacity:1;}", mVe = "0%{opacity:1;} 100%{opacity:0;}", vVe = Pu("div")`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`, yVe = Pu("div")`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`, bVe = (e, t) => {
  let n = e.includes("top") ? 1 : -1, [r, o] = J3e() ? [gVe, mVe] : [fVe(n), hVe(n)];
  return { animation: t ? `${el(r)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards` : `${el(o)} 0.4s forwards cubic-bezier(.06,.71,.55,1)` };
};
Ne.memo(({ toast: e, position: t, style: n, children: r }) => {
  let o = e.height ? bVe(e.position || t || "top-center", e.visible) : { opacity: 0 }, i = Ne.createElement(dVe, { toast: e }), a = Ne.createElement(yVe, { ...e.ariaProps }, Y3e(e.message, e));
  return Ne.createElement(vVe, { className: e.className, style: { ...o, ...n, ...e.style } }, typeof r == "function" ? r({ icon: i, message: a }) : Ne.createElement(Ne.Fragment, null, i, a));
});
K3e(Ne.createElement);
AO`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`;
$e({});
function wVe(e) {
  return e && e.replace(/[^0-9]/g, "");
}
const CVe = {
  CNPJ: "99.999.999/9999-99"
};
wVe(CVe.CNPJ).length;
Cr((e, t) => /* @__PURE__ */ Yo.jsx("input", { ref: t, ...e }));
function pre(e) {
  return e && e.replace(/[^0-9]/g, "");
}
const dre = {
  EIGTH: "(99) 9999-9999",
  NINE: "(99) 99999-9999"
};
function OVe(e, t) {
  let n = "", r = 0;
  for (let o = 0; o < t.length; o++)
    if (t[o] === "9")
      if (r < e.length)
        n += e[r], r++;
      else
        break;
    else if (r < e.length)
      n += t[o];
    else
      break;
  return n;
}
function xVe(e) {
  return e.length > 10 ? "NINE" : "EIGTH";
}
const EVe = pre(dre.NINE).length, kVe = Cr((e, t) => /* @__PURE__ */ Yo.jsx("input", { ref: t, ...e }));
Cr(
  (e, t) => {
    const { onFocus: n, onBlur: r, size: o, onChange: i, value: a, currentCountry: s, disabled: l } = e, [u, c] = k(!1);
    h(() => {
      u ? i(s.mask) : c(!0);
    }, [s]);
    const p = `phoneInputMask ${o}`;
    function d(g) {
      let f = pre(g.target.value);
      const m = xVe(f);
      f.length > EVe || (f = OVe(f, dre[m]), g.target.value = f, i(f));
    }
    return s.code === "+55" ? /* @__PURE__ */ Yo.jsx(
      "input",
      {
        value: a,
        onChange: d,
        className: p,
        onFocus: n,
        onBlur: r,
        disabled: l,
        ref: t
      }
    ) : /* @__PURE__ */ Yo.jsx(
      ol,
      {
        value: a,
        onChange: (g) => i(g.target.value),
        className: p,
        component: kVe,
        onFocus: n,
        onBlur: r,
        disabled: l,
        mask: s.mask,
        showMask: !0,
        replacement: { _: /\d/ },
        ref: t
      }
    );
  }
);
$e({});
var pl = {};
Object.defineProperty(pl, "__esModule", {
  value: !0
});
var LVe = typeof window < "u" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform), zk = {
  alt: "altKey",
  control: "ctrlKey",
  meta: "metaKey",
  shift: "shiftKey"
}, fre = {
  add: "+",
  break: "pause",
  cmd: "meta",
  command: "meta",
  ctl: "control",
  ctrl: "control",
  del: "delete",
  down: "arrowdown",
  esc: "escape",
  ins: "insert",
  left: "arrowleft",
  mod: LVe ? "meta" : "control",
  opt: "alt",
  option: "alt",
  return: "enter",
  right: "arrowright",
  space: " ",
  spacebar: " ",
  up: "arrowup",
  win: "meta",
  windows: "meta"
}, RT = {
  backspace: 8,
  tab: 9,
  enter: 13,
  shift: 16,
  control: 17,
  alt: 18,
  pause: 19,
  capslock: 20,
  escape: 27,
  " ": 32,
  pageup: 33,
  pagedown: 34,
  end: 35,
  home: 36,
  arrowleft: 37,
  arrowup: 38,
  arrowright: 39,
  arrowdown: 40,
  insert: 45,
  delete: 46,
  meta: 91,
  numlock: 144,
  scrolllock: 145,
  ";": 186,
  "=": 187,
  ",": 188,
  "-": 189,
  ".": 190,
  "/": 191,
  "`": 192,
  "[": 219,
  "\\": 220,
  "]": 221,
  "'": 222
};
for (var zv = 1; zv < 20; zv++)
  RT["f" + zv] = 111 + zv;
function RO(e, t, n) {
  t && !("byKey" in t) && (n = t, t = null), Array.isArray(e) || (e = [e]);
  var r = e.map(function(a) {
    return hre(a, t);
  }), o = function(a) {
    return r.some(function(s) {
      return gre(s, a);
    });
  }, i = n == null ? o : o(n);
  return i;
}
function _Ve(e, t) {
  return RO(e, t);
}
function PVe(e, t) {
  return RO(e, { byKey: !0 }, t);
}
function hre(e, t) {
  var n = t && t.byKey, r = {};
  e = e.replace("++", "+add");
  var o = e.split("+"), i = o.length;
  for (var a in zk)
    r[zk[a]] = !1;
  var s = !0, l = !1, u = void 0;
  try {
    for (var c = o[Symbol.iterator](), p; !(s = (p = c.next()).done); s = !0) {
      var d = p.value, g = d.endsWith("?") && d.length > 1;
      g && (d = d.slice(0, -1));
      var f = IT(d), m = zk[f];
      if (d.length > 1 && !m && !fre[d] && !RT[f])
        throw new TypeError('Unknown modifier: "' + d + '"');
      (i === 1 || !m) && (n ? r.key = f : r.which = mre(d)), m && (r[m] = g ? null : !0);
    }
  } catch (b) {
    l = !0, u = b;
  } finally {
    try {
      !s && c.return && c.return();
    } finally {
      if (l)
        throw u;
    }
  }
  return r;
}
function gre(e, t) {
  for (var n in e) {
    var r = e[n], o = void 0;
    if (r != null && (n === "key" && t.key != null ? o = t.key.toLowerCase() : n === "which" ? o = r === 91 && t.which === 93 ? 91 : t.which : o = t[n], !(o == null && r === !1) && o !== r))
      return !1;
  }
  return !0;
}
function mre(e) {
  e = IT(e);
  var t = RT[e] || e.toUpperCase().charCodeAt(0);
  return t;
}
function IT(e) {
  return e = e.toLowerCase(), e = fre[e] || e, e;
}
pl.default = RO;
var Uk = pl.isHotkey = RO;
pl.isCodeHotkey = _Ve;
pl.isKeyHotkey = PVe;
pl.parseHotkey = hre;
pl.compareHotkey = gre;
pl.toKeyCode = mre;
pl.toKeyName = IT;
var SVe = typeof gr == "object" && gr && gr.Object === Object && gr, MVe = SVe, DVe = MVe, TVe = typeof self == "object" && self && self.Object === Object && self, jVe = DVe || TVe || Function("return this")(), AVe = jVe, RVe = AVe, IVe = RVe.Symbol, vre = IVe, _6 = vre;
_6 && _6.toStringTag;
var P6 = vre;
P6 && P6.toStringTag;
var S6;
(function(e) {
  e.BORDER_BOX = "border-box", e.CONTENT_BOX = "content-box", e.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(S6 || (S6 = {}));
var NT = function(e) {
  return Object.freeze(e);
}, NVe = /* @__PURE__ */ function() {
  function e(t, n) {
    this.inlineSize = t, this.blockSize = n, NT(this);
  }
  return e;
}(), BVe = function() {
  function e(t, n, r, o) {
    return this.x = t, this.y = n, this.width = r, this.height = o, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, NT(this);
  }
  return e.prototype.toJSON = function() {
    var t = this, n = t.x, r = t.y, o = t.top, i = t.right, a = t.bottom, s = t.left, l = t.width, u = t.height;
    return { x: n, y: r, top: o, right: i, bottom: a, left: s, width: l, height: u };
  }, e.fromRect = function(t) {
    return new e(t.x, t.y, t.width, t.height);
  }, e;
}(), M6 = typeof window < "u" ? window : {};
/msie|trident/i.test(M6.navigator && M6.navigator.userAgent);
var Hk = function(e, t, n) {
  return e === void 0 && (e = 0), t === void 0 && (t = 0), n === void 0 && (n = !1), new NVe((n ? t : e) || 0, (n ? e : t) || 0);
};
NT({
  devicePixelContentBoxSize: Hk(),
  borderBoxSize: Hk(),
  contentBoxSize: Hk(),
  contentRect: new BVe(0, 0, 0, 0)
});
function Nh(e) {
  "@babel/helpers - typeof";
  return Nh = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Nh(e);
}
function FVe(e, t) {
  if (Nh(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (Nh(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function zVe(e) {
  var t = FVe(e, "string");
  return Nh(t) === "symbol" ? t : String(t);
}
function Tf(e, t, n) {
  return t = zVe(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
var UVe = /* @__PURE__ */ $e(null), Wk, $k;
parseInt(be.version.split(".")[0], 10);
var D6 = typeof navigator < "u" && /Mac OS X/.test(navigator.userAgent), Vk = typeof navigator < "u" && /Android/.test(navigator.userAgent), Uv = typeof navigator < "u" && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent), HVe = typeof navigator < "u" && /Chrome/i.test(navigator.userAgent);
typeof navigator < "u" && /Safari/.test(navigator.userAgent) && /Version\/(\d+)/.test(navigator.userAgent) && (Wk = navigator.userAgent.match(/Version\/(\d+)/)) !== null && Wk !== void 0 && Wk[1] && parseInt(($k = navigator.userAgent.match(/Version\/(\d+)/)) === null || $k === void 0 ? void 0 : $k[1], 10) < 17;
var WVe = /* @__PURE__ */ new WeakMap(), $Ve = /* @__PURE__ */ new WeakMap(), VVe = /* @__PURE__ */ new WeakMap(), ZVe = /* @__PURE__ */ new WeakMap(), qVe = /* @__PURE__ */ new WeakMap(), T6 = /* @__PURE__ */ new WeakMap(), GVe = /* @__PURE__ */ new WeakMap(), j6 = /* @__PURE__ */ new WeakMap(), Hv = /* @__PURE__ */ new WeakMap(), KVe = /* @__PURE__ */ new WeakMap(), XVe = /* @__PURE__ */ new WeakMap(), YVe = /* @__PURE__ */ new WeakMap(), yre = globalThis.Node, JVe = globalThis.Text, bre = (e) => e && e.ownerDocument && e.ownerDocument.defaultView || null, QVe = (e) => Pw(e) && e.nodeType === 8, ha = (e) => Pw(e) && e.nodeType === 1, Pw = (e) => {
  var t = bre(e);
  return !!t && e instanceof t.Node;
}, A6 = (e) => {
  var t = e && e.anchorNode && bre(e.anchorNode);
  return !!t && e instanceof t.Selection;
}, e9e = (e) => {
  var [t, n] = e;
  if (ha(t) && t.childNodes.length) {
    var r = n === t.childNodes.length, o = r ? n - 1 : n;
    for ([t, o] = wre(t, o, r ? "backward" : "forward"), r = o < n; ha(t) && t.childNodes.length; ) {
      var i = r ? t.childNodes.length - 1 : 0;
      t = n9e(t, i, r ? "backward" : "forward");
    }
    n = r && t.textContent != null ? t.textContent.length : 0;
  }
  return [t, n];
}, t9e = (e) => {
  for (var t = e && e.parentNode; t; ) {
    if (t.toString() === "[object ShadowRoot]")
      return !0;
    t = t.parentNode;
  }
  return !1;
}, wre = (e, t, n) => {
  for (var {
    childNodes: r
  } = e, o = r[t], i = t, a = !1, s = !1; (QVe(o) || ha(o) && o.childNodes.length === 0 || ha(o) && o.getAttribute("contenteditable") === "false") && !(a && s); ) {
    if (i >= r.length) {
      a = !0, i = t - 1, n = "backward";
      continue;
    }
    if (i < 0) {
      s = !0, i = t + 1, n = "forward";
      continue;
    }
    o = r[i], t = i, i += n === "forward" ? 1 : -1;
  }
  return [o, t];
}, n9e = (e, t, n) => {
  var [r] = wre(e, t, n);
  return r;
}, R6 = (e) => e.getSelection != null ? e.getSelection() : document.getSelection(), Cre = (e, t, n) => {
  var {
    target: r
  } = t;
  if (ha(r) && r.matches('[contentEditable="false"]'))
    return !1;
  var {
    document: o
  } = gn.getWindow(e);
  if (o.contains(r))
    return gn.hasDOMNode(e, r, {
      editable: !0
    });
  var i = n.find((a) => {
    var {
      addedNodes: s,
      removedNodes: l
    } = a;
    for (var u of s)
      if (u === r || u.contains(r))
        return !0;
    for (var c of l)
      if (c === r || c.contains(r))
        return !0;
  });
  return !i || i === t ? !1 : Cre(e, i, n);
}, I6 = (e, t) => !!(e.compareDocumentPosition(t) & yre.DOCUMENT_POSITION_PRECEDING), r9e = (e, t) => !!(e.compareDocumentPosition(t) & yre.DOCUMENT_POSITION_FOLLOWING), o9e = 0;
class i9e {
  constructor() {
    Tf(this, "id", void 0), this.id = "".concat(o9e++);
  }
}
var gn = {
  androidPendingDiffs: (e) => YVe.get(e),
  androidScheduleFlush: (e) => {
    var t;
    (t = XVe.get(e)) === null || t === void 0 || t();
  },
  blur: (e) => {
    var t = gn.toDOMNode(e, e), n = gn.findDocumentOrShadowRoot(e);
    Hv.set(e, !1), n.activeElement === t && t.blur();
  },
  deselect: (e) => {
    var {
      selection: t
    } = e, n = gn.findDocumentOrShadowRoot(e), r = R6(n);
    r && r.rangeCount > 0 && r.removeAllRanges(), t && eb.deselect(e);
  },
  findDocumentOrShadowRoot: (e) => {
    var t = gn.toDOMNode(e, e), n = t.getRootNode();
    return n instanceof Document || n instanceof ShadowRoot ? n : t.ownerDocument;
  },
  findEventRange: (e, t) => {
    "nativeEvent" in t && (t = t.nativeEvent);
    var {
      clientX: n,
      clientY: r,
      target: o
    } = t;
    if (n == null || r == null)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var i = gn.toSlateNode(e, t.target), a = gn.findPath(e, i);
    if (Ha.isElement(i) && ar.isVoid(e, i)) {
      var s = o.getBoundingClientRect(), l = e.isInline(i) ? n - s.left < s.left + s.width - n : r - s.top < s.top + s.height - r, u = ar.point(e, a, {
        edge: l ? "start" : "end"
      }), c = l ? ar.before(e, u) : ar.after(e, u);
      if (c) {
        var p = ar.range(e, c);
        return p;
      }
    }
    var d, {
      document: g
    } = gn.getWindow(e);
    if (g.caretRangeFromPoint)
      d = g.caretRangeFromPoint(n, r);
    else {
      var f = g.caretPositionFromPoint(n, r);
      f && (d = g.createRange(), d.setStart(f.offsetNode, f.offset), d.setEnd(f.offsetNode, f.offset));
    }
    if (!d)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var m = gn.toSlateRange(e, d, {
      exactMatch: !1,
      suppressThrow: !1
    });
    return m;
  },
  findKey: (e, t) => {
    var n = T6.get(t);
    return n || (n = new i9e(), T6.set(t, n)), n;
  },
  findPath: (e, t) => {
    for (var n = [], r = t; ; ) {
      var o = $Ve.get(r);
      if (o == null) {
        if (ar.isEditor(r))
          return n;
        break;
      }
      var i = WVe.get(r);
      if (i == null)
        break;
      n.unshift(i), r = o;
    }
    throw new Error("Unable to find the path for Slate node: ".concat(os.stringify(t)));
  },
  focus: function(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      retries: 5
    };
    if (!Hv.get(e)) {
      if (t.retries <= 0)
        throw new Error("Could not set focus, editor seems stuck with pending operations");
      if (e.operations.length > 0) {
        setTimeout(() => {
          gn.focus(e, {
            retries: t.retries - 1
          });
        }, 10);
        return;
      }
      var n = gn.toDOMNode(e, e), r = gn.findDocumentOrShadowRoot(e);
      if (r.activeElement !== n) {
        if (e.selection && r instanceof Document) {
          var o = R6(r), i = gn.toDOMRange(e, e.selection);
          o == null || o.removeAllRanges(), o == null || o.addRange(i);
        }
        e.selection || eb.select(e, ar.start(e, [])), Hv.set(e, !0), n.focus({
          preventScroll: !0
        });
      }
    }
  },
  getWindow: (e) => {
    var t = VVe.get(e);
    if (!t)
      throw new Error("Unable to find a host window element for this editor");
    return t;
  },
  hasDOMNode: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      editable: r = !1
    } = n, o = gn.toDOMNode(e, e), i;
    try {
      i = ha(t) ? t : t.parentElement;
    } catch (a) {
      if (a instanceof Error && !a.message.includes('Permission denied to access property "nodeType"'))
        throw a;
    }
    return i ? i.closest("[data-slate-editor]") === o && (!r || i.isContentEditable ? !0 : typeof i.isContentEditable == "boolean" && // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined
    // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable="false"(readOnly)
    i.closest('[contenteditable="false"]') === o || !!i.getAttribute("data-slate-zero-width")) : !1;
  },
  hasEditableTarget: (e, t) => Pw(t) && gn.hasDOMNode(e, t, {
    editable: !0
  }),
  hasRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t;
    return ar.hasPath(e, n.path) && ar.hasPath(e, r.path);
  },
  hasSelectableTarget: (e, t) => gn.hasEditableTarget(e, t) || gn.isTargetInsideNonReadonlyVoid(e, t),
  hasTarget: (e, t) => Pw(t) && gn.hasDOMNode(e, t),
  insertData: (e, t) => {
    e.insertData(t);
  },
  insertFragmentData: (e, t) => e.insertFragmentData(t),
  insertTextData: (e, t) => e.insertTextData(t),
  isComposing: (e) => !!KVe.get(e),
  isFocused: (e) => !!Hv.get(e),
  isReadOnly: (e) => !!j6.get(e),
  isTargetInsideNonReadonlyVoid: (e, t) => {
    if (j6.get(e)) return !1;
    var n = gn.hasTarget(e, t) && gn.toSlateNode(e, t);
    return Ha.isElement(n) && ar.isVoid(e, n);
  },
  setFragmentData: (e, t, n) => e.setFragmentData(t, n),
  toDOMNode: (e, t) => {
    var n = GVe.get(e), r = ar.isEditor(t) ? ZVe.get(e) : n == null ? void 0 : n.get(gn.findKey(e, t));
    if (!r)
      throw new Error("Cannot resolve a DOM node from Slate node: ".concat(os.stringify(t)));
    return r;
  },
  toDOMPoint: (e, t) => {
    var [n] = ar.node(e, t.path), r = gn.toDOMNode(e, n), o;
    ar.void(e, {
      at: t
    }) && (t = {
      path: t.path,
      offset: 0
    });
    for (var i = "[data-slate-string], [data-slate-zero-width]", a = Array.from(r.querySelectorAll(i)), s = 0, l = 0; l < a.length; l++) {
      var u = a[l], c = u.childNodes[0];
      if (!(c == null || c.textContent == null)) {
        var {
          length: p
        } = c.textContent, d = u.getAttribute("data-slate-length"), g = d == null ? p : parseInt(d, 10), f = s + g, m = a[l + 1];
        if (t.offset === f && m !== null && m !== void 0 && m.hasAttribute("data-slate-mark-placeholder")) {
          var b, E = m.childNodes[0];
          o = [
            // COMPAT: If we don't explicity set the dom point to be on the actual
            // dom text element, chrome will put the selection behind the actual dom
            // text element, causing domRange.getBoundingClientRect() calls on a collapsed
            // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)
            // which will cause issues when scrolling to it.
            E instanceof JVe ? E : m,
            (b = m.textContent) !== null && b !== void 0 && b.startsWith("\uFEFF") ? 1 : 0
          ];
          break;
        }
        if (t.offset <= f) {
          var w = Math.min(p, Math.max(0, t.offset - s));
          o = [c, w];
          break;
        }
        s = f;
      }
    }
    if (!o)
      throw new Error("Cannot resolve a DOM point from Slate point: ".concat(os.stringify(t)));
    return o;
  },
  toDOMRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t, o = Zt.isBackward(t), i = gn.toDOMPoint(e, n), a = Zt.isCollapsed(t) ? i : gn.toDOMPoint(e, r), s = gn.getWindow(e), l = s.document.createRange(), [u, c] = o ? a : i, [p, d] = o ? i : a, g = ha(u) ? u : u.parentElement, f = !!g.getAttribute("data-slate-zero-width"), m = ha(p) ? p : p.parentElement, b = !!m.getAttribute("data-slate-zero-width");
    return l.setStart(u, f ? 1 : c), l.setEnd(p, b ? 1 : d), l;
  },
  toSlateNode: (e, t) => {
    var n = ha(t) ? t : t.parentElement;
    n && !n.hasAttribute("data-slate-node") && (n = n.closest("[data-slate-node]"));
    var r = n ? qVe.get(n) : null;
    if (!r)
      throw new Error("Cannot resolve a Slate node from DOM node: ".concat(n));
    return r;
  },
  toSlatePoint: (e, t, n) => {
    var {
      exactMatch: r,
      suppressThrow: o,
      searchDirection: i = "backward"
    } = n, [a, s] = r ? t : e9e(t), l = a.parentNode, u = null, c = 0;
    if (l) {
      var p, d, g = gn.toDOMNode(e, e), f = l.closest('[data-slate-void="true"]'), m = f && g.contains(f) ? f : null, b = l.closest('[contenteditable="false"]'), E = b && g.contains(b) ? b : null, w = l.closest("[data-slate-leaf]"), M = null;
      if (w) {
        if (u = w.closest('[data-slate-node="text"]'), u) {
          var x = gn.getWindow(e), v = x.document.createRange();
          v.setStart(u, 0), v.setEnd(a, s);
          var C = v.cloneContents(), P = [...Array.prototype.slice.call(C.querySelectorAll("[data-slate-zero-width]")), ...Array.prototype.slice.call(C.querySelectorAll("[contenteditable=false]"))];
          P.forEach((S) => {
            if (Vk && !r && S.hasAttribute("data-slate-zero-width") && S.textContent.length > 0 && S.textContext !== "\uFEFF") {
              S.textContent.startsWith("\uFEFF") && (S.textContent = S.textContent.slice(1));
              return;
            }
            S.parentNode.removeChild(S);
          }), c = C.textContent.length, M = u;
        }
      } else if (m) {
        for (var F = m.querySelectorAll("[data-slate-leaf]"), L = 0; L < F.length; L++) {
          var B = F[L];
          if (gn.hasDOMNode(e, B)) {
            w = B;
            break;
          }
        }
        w ? (u = w.closest('[data-slate-node="text"]'), M = w, c = M.textContent.length, M.querySelectorAll("[data-slate-zero-width]").forEach((S) => {
          c -= S.textContent.length;
        })) : c = 1;
      } else if (E) {
        var N = (S) => S ? S.querySelectorAll(
          // Exclude leaf nodes in nested editors
          "[data-slate-leaf]:not(:scope [data-slate-editor] [data-slate-leaf])"
        ) : [], $ = E.closest('[data-slate-node="element"]');
        if (i === "forward") {
          var V, H = [...N($), ...N($ == null ? void 0 : $.nextElementSibling)];
          w = (V = H.find((S) => r9e(E, S))) !== null && V !== void 0 ? V : null;
        } else {
          var Z, K = [...N($ == null ? void 0 : $.previousElementSibling), ...N($)];
          w = (Z = K.findLast((S) => I6(E, S))) !== null && Z !== void 0 ? Z : null;
        }
        w && (u = w.closest('[data-slate-node="text"]'), M = w, i === "forward" ? c = 0 : (c = M.textContent.length, M.querySelectorAll("[data-slate-zero-width]").forEach((S) => {
          c -= S.textContent.length;
        })));
      }
      M && c === M.textContent.length && // COMPAT: Android IMEs might remove the zero width space while composing,
      // and we don't add it for line-breaks.
      Vk && M.getAttribute("data-slate-zero-width") === "z" && (p = M.textContent) !== null && p !== void 0 && p.startsWith("\uFEFF") && // COMPAT: If the parent node is a Slate zero-width space, editor is
      // because the text node should have no characters. However, during IME
      // composition the ASCII characters will be prepended to the zero-width
      // space, so subtract 1 from the offset to account for the zero-width
      // space character.
      (l.hasAttribute("data-slate-zero-width") || // COMPAT: In Firefox, `range.cloneContents()` returns an extra trailing '\n'
      // when the document ends with a new-line character. This results in the offset
      // length being off by one, so we need to subtract one to account for this.
      Uv && (d = M.textContent) !== null && d !== void 0 && d.endsWith(`

`)) && c--;
    }
    if (Vk && !u && !r) {
      var Y = l.hasAttribute("data-slate-node") ? l : l.closest("[data-slate-node]");
      if (Y && gn.hasDOMNode(e, Y, {
        editable: !0
      })) {
        var Q = gn.toSlateNode(e, Y), {
          path: J,
          offset: _
        } = ar.start(e, gn.findPath(e, Q));
        return Y.querySelector("[data-slate-leaf]") || (_ = s), {
          path: J,
          offset: _
        };
      }
    }
    if (!u) {
      if (o)
        return null;
      throw new Error("Cannot resolve a Slate point from DOM point: ".concat(t));
    }
    var D = gn.toSlateNode(e, u), z = gn.findPath(e, D);
    return {
      path: z,
      offset: c
    };
  },
  toSlateRange: (e, t, n) => {
    var r, {
      exactMatch: o,
      suppressThrow: i
    } = n, a = A6(t) ? t.anchorNode : t.startContainer, s, l, u, c, p;
    if (a)
      if (A6(t)) {
        if (Uv && t.rangeCount > 1) {
          u = t.focusNode;
          var d = t.getRangeAt(0), g = t.getRangeAt(t.rangeCount - 1);
          if (u instanceof HTMLTableRowElement && d.startContainer instanceof HTMLTableRowElement && g.startContainer instanceof HTMLTableRowElement) {
            let C = function(P) {
              return P.childElementCount > 0 ? C(P.children[0]) : P;
            };
            var f = d.startContainer, m = g.startContainer, b = C(f.children[d.startOffset]), E = C(m.children[g.startOffset]);
            c = 0, E.childNodes.length > 0 ? s = E.childNodes[0] : s = E, b.childNodes.length > 0 ? u = b.childNodes[0] : u = b, E instanceof HTMLElement ? l = E.innerHTML.length : l = 0;
          } else
            d.startContainer === u ? (s = g.endContainer, l = g.endOffset, c = d.startOffset) : (s = d.startContainer, l = d.endOffset, c = g.startOffset);
        } else
          s = t.anchorNode, l = t.anchorOffset, u = t.focusNode, c = t.focusOffset;
        HVe && t9e(s) || Uv ? p = t.anchorNode === t.focusNode && t.anchorOffset === t.focusOffset : p = t.isCollapsed;
      } else
        s = t.startContainer, l = t.startOffset, u = t.endContainer, c = t.endOffset, p = t.collapsed;
    if (s == null || u == null || l == null || c == null)
      throw new Error("Cannot resolve a Slate range from DOM range: ".concat(t));
    Uv && (r = u.textContent) !== null && r !== void 0 && r.endsWith(`

`) && c === u.textContent.length && c--;
    var w = gn.toSlatePoint(e, [s, l], {
      exactMatch: o,
      suppressThrow: i
    });
    if (!w)
      return null;
    var M = I6(s, u) || s === u && c < l, x = p ? w : gn.toSlatePoint(e, [u, c], {
      exactMatch: o,
      suppressThrow: i,
      searchDirection: M ? "forward" : "backward"
    });
    if (!x)
      return null;
    var v = {
      anchor: w,
      focus: x
    };
    return Zt.isExpanded(v) && Zt.isForward(v) && ha(u) && ar.void(e, {
      at: v.focus,
      mode: "highest"
    }) && (v = ar.unhangRange(e, v, {
      voids: !0
    })), v;
  }
}, s9e = {
  bold: "mod+b",
  compose: ["down", "left", "right", "up", "backspace", "enter"],
  moveBackward: "left",
  moveForward: "right",
  moveWordBackward: "ctrl+left",
  moveWordForward: "ctrl+right",
  deleteBackward: "shift?+backspace",
  deleteForward: "shift?+delete",
  extendBackward: "shift+left",
  extendForward: "shift+right",
  italic: "mod+i",
  insertSoftBreak: "shift+enter",
  splitBlock: "enter",
  undo: "mod+z"
}, a9e = {
  moveLineBackward: "opt+up",
  moveLineForward: "opt+down",
  moveWordBackward: "opt+left",
  moveWordForward: "opt+right",
  deleteBackward: ["ctrl+backspace", "ctrl+h"],
  deleteForward: ["ctrl+delete", "ctrl+d"],
  deleteLineBackward: "cmd+shift?+backspace",
  deleteLineForward: ["cmd+shift?+delete", "ctrl+k"],
  deleteWordBackward: "opt+shift?+backspace",
  deleteWordForward: "opt+shift?+delete",
  extendLineBackward: "opt+shift+up",
  extendLineForward: "opt+shift+down",
  redo: "cmd+shift+z",
  transposeCharacter: "ctrl+t"
}, l9e = {
  deleteWordBackward: "ctrl+shift?+backspace",
  deleteWordForward: "ctrl+shift?+delete",
  redo: ["ctrl+y", "ctrl+shift+z"]
}, eo = (e) => {
  var t = s9e[e], n = a9e[e], r = l9e[e], o = t && Uk(t), i = n && Uk(n), a = r && Uk(r);
  return (s) => !!(o && o(s) || D6 && i && i(s) || !D6 && a && a(s));
};
eo("bold"), eo("compose"), eo("moveBackward"), eo("moveForward"), eo("deleteBackward"), eo("deleteForward"), eo("deleteLineBackward"), eo("deleteLineForward"), eo("deleteWordBackward"), eo("deleteWordForward"), eo("extendBackward"), eo("extendForward"), eo("extendLineBackward"), eo("extendLineForward"), eo("italic"), eo("moveLineBackward"), eo("moveLineForward"), eo("moveWordBackward"), eo("moveWordForward"), eo("redo"), eo("insertSoftBreak"), eo("splitBlock"), eo("transposeCharacter"), eo("undo");
var u9e = (e, t) => {
  var n = [], r = () => {
    n = [];
  }, o = (a) => {
    if (t.current) {
      var s = a.filter((l) => Cre(e, l, a));
      n.push(...s);
    }
  };
  function i() {
    n.length > 0 && (n.reverse().forEach((a) => {
      a.type !== "characterData" && (a.removedNodes.forEach((s) => {
        a.target.insertBefore(s, a.nextSibling);
      }), a.addedNodes.forEach((s) => {
        a.target.removeChild(s);
      }));
    }), r());
  }
  return {
    registerMutations: o,
    restoreDOM: i,
    clear: r
  };
}, c9e = {
  subtree: !0,
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0
};
class p9e extends au {
  constructor() {
    super(...arguments), Tf(this, "context", null), Tf(this, "manager", null), Tf(this, "mutationObserver", null);
  }
  observe() {
    var t, {
      node: n
    } = this.props;
    if (!n.current)
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    (t = this.mutationObserver) === null || t === void 0 || t.observe(n.current, c9e);
  }
  componentDidMount() {
    var {
      receivedUserInput: t
    } = this.props, n = this.context;
    this.manager = u9e(n, t), this.mutationObserver = new MutationObserver(this.manager.registerMutations), this.observe();
  }
  getSnapshotBeforeUpdate() {
    var t, n, r, o = (t = this.mutationObserver) === null || t === void 0 ? void 0 : t.takeRecords();
    if (o != null && o.length) {
      var i;
      (i = this.manager) === null || i === void 0 || i.registerMutations(o);
    }
    return (n = this.mutationObserver) === null || n === void 0 || n.disconnect(), (r = this.manager) === null || r === void 0 || r.restoreDOM(), null;
  }
  componentDidUpdate() {
    var t;
    (t = this.manager) === null || t === void 0 || t.clear(), this.observe();
  }
  componentWillUnmount() {
    var t;
    (t = this.mutationObserver) === null || t === void 0 || t.disconnect();
  }
  render() {
    return this.props.children;
  }
}
Tf(p9e, "contextType", UVe);
$e({});
$e({});
$e({});
var Bo = {}, BT = {}, Pg = {}, Sg = {}, Ore = "Expected a function", N6 = NaN, d9e = "[object Symbol]", f9e = /^\s+|\s+$/g, h9e = /^[-+]0x[0-9a-f]+$/i, g9e = /^0b[01]+$/i, m9e = /^0o[0-7]+$/i, v9e = parseInt, y9e = typeof gr == "object" && gr && gr.Object === Object && gr, b9e = typeof self == "object" && self && self.Object === Object && self, w9e = y9e || b9e || Function("return this")(), C9e = Object.prototype, O9e = C9e.toString, x9e = Math.max, E9e = Math.min, Zk = function() {
  return w9e.Date.now();
};
function k9e(e, t, n) {
  var r, o, i, a, s, l, u = 0, c = !1, p = !1, d = !0;
  if (typeof e != "function")
    throw new TypeError(Ore);
  t = B6(t) || 0, Sw(n) && (c = !!n.leading, p = "maxWait" in n, i = p ? x9e(B6(n.maxWait) || 0, t) : i, d = "trailing" in n ? !!n.trailing : d);
  function g(C) {
    var P = r, F = o;
    return r = o = void 0, u = C, a = e.apply(F, P), a;
  }
  function f(C) {
    return u = C, s = setTimeout(E, t), c ? g(C) : a;
  }
  function m(C) {
    var P = C - l, F = C - u, L = t - P;
    return p ? E9e(L, i - F) : L;
  }
  function b(C) {
    var P = C - l, F = C - u;
    return l === void 0 || P >= t || P < 0 || p && F >= i;
  }
  function E() {
    var C = Zk();
    if (b(C))
      return w(C);
    s = setTimeout(E, m(C));
  }
  function w(C) {
    return s = void 0, d && r ? g(C) : (r = o = void 0, a);
  }
  function M() {
    s !== void 0 && clearTimeout(s), u = 0, r = l = o = s = void 0;
  }
  function x() {
    return s === void 0 ? a : w(Zk());
  }
  function v() {
    var C = Zk(), P = b(C);
    if (r = arguments, o = this, l = C, P) {
      if (s === void 0)
        return f(l);
      if (p)
        return s = setTimeout(E, t), g(l);
    }
    return s === void 0 && (s = setTimeout(E, t)), a;
  }
  return v.cancel = M, v.flush = x, v;
}
function L9e(e, t, n) {
  var r = !0, o = !0;
  if (typeof e != "function")
    throw new TypeError(Ore);
  return Sw(n) && (r = "leading" in n ? !!n.leading : r, o = "trailing" in n ? !!n.trailing : o), k9e(e, t, {
    leading: r,
    maxWait: t,
    trailing: o
  });
}
function Sw(e) {
  var t = typeof e;
  return !!e && (t == "object" || t == "function");
}
function _9e(e) {
  return !!e && typeof e == "object";
}
function P9e(e) {
  return typeof e == "symbol" || _9e(e) && O9e.call(e) == d9e;
}
function B6(e) {
  if (typeof e == "number")
    return e;
  if (P9e(e))
    return N6;
  if (Sw(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = Sw(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = e.replace(f9e, "");
  var n = g9e.test(e);
  return n || m9e.test(e) ? v9e(e.slice(2), n ? 2 : 8) : h9e.test(e) ? N6 : +e;
}
var S9e = L9e, Mg = {};
Object.defineProperty(Mg, "__esModule", {
  value: !0
});
Mg.addPassiveEventListener = function(e, t, n) {
  var r = n.name;
  r || (r = t, console.warn("Listener must be a named function.")), Dy.has(t) || Dy.set(t, /* @__PURE__ */ new Set());
  var o = Dy.get(t);
  if (!o.has(r)) {
    var i = function() {
      var a = !1;
      try {
        var s = Object.defineProperty({}, "passive", {
          get: function() {
            a = !0;
          }
        });
        window.addEventListener("test", null, s);
      } catch {
      }
      return a;
    }();
    e.addEventListener(t, n, i ? { passive: !0 } : !1), o.add(r);
  }
};
Mg.removePassiveEventListener = function(e, t, n) {
  e.removeEventListener(t, n), Dy.get(t).delete(n.name || t);
};
var Dy = /* @__PURE__ */ new Map();
Object.defineProperty(Sg, "__esModule", {
  value: !0
});
var M9e = S9e, D9e = T9e(M9e), F6 = Mg;
function T9e(e) {
  return e && e.__esModule ? e : { default: e };
}
var j9e = function(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 66;
  return (0, D9e.default)(e, t);
}, go = {
  spyCallbacks: [],
  spySetState: [],
  scrollSpyContainers: [],
  mount: function(e, t) {
    if (e) {
      var n = j9e(function(r) {
        go.scrollHandler(e);
      }, t);
      return go.scrollSpyContainers.push(e), (0, F6.addPassiveEventListener)(e, "scroll", n), function() {
        (0, F6.removePassiveEventListener)(e, "scroll", n), go.scrollSpyContainers.splice(go.scrollSpyContainers.indexOf(e), 1);
      };
    }
    return function() {
    };
  },
  isMounted: function(e) {
    return go.scrollSpyContainers.indexOf(e) !== -1;
  },
  currentPositionX: function(e) {
    if (e === document) {
      var t = window.scrollY !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.scrollX : n ? document.documentElement.scrollLeft : document.body.scrollLeft;
    } else
      return e.scrollLeft;
  },
  currentPositionY: function(e) {
    if (e === document) {
      var t = window.scrollX !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.scrollY : n ? document.documentElement.scrollTop : document.body.scrollTop;
    } else
      return e.scrollTop;
  },
  scrollHandler: function(e) {
    var t = go.scrollSpyContainers[go.scrollSpyContainers.indexOf(e)].spyCallbacks || [];
    t.forEach(function(n) {
      return n(go.currentPositionX(e), go.currentPositionY(e));
    });
  },
  addStateHandler: function(e) {
    go.spySetState.push(e);
  },
  addSpyHandler: function(e, t) {
    var n = go.scrollSpyContainers[go.scrollSpyContainers.indexOf(t)];
    n.spyCallbacks || (n.spyCallbacks = []), n.spyCallbacks.push(e);
  },
  updateStates: function() {
    go.spySetState.forEach(function(e) {
      return e();
    });
  },
  unmount: function(e, t) {
    go.scrollSpyContainers.forEach(function(n) {
      return n.spyCallbacks && n.spyCallbacks.length && n.spyCallbacks.indexOf(t) > -1 && n.spyCallbacks.splice(n.spyCallbacks.indexOf(t), 1);
    }), go.spySetState && go.spySetState.length && go.spySetState.indexOf(e) > -1 && go.spySetState.splice(go.spySetState.indexOf(e), 1), document.removeEventListener("scroll", go.scrollHandler);
  },
  update: function() {
    return go.scrollSpyContainers.forEach(function(e) {
      return go.scrollHandler(e);
    });
  }
};
Sg.default = go;
var Gp = {}, Dg = {};
Object.defineProperty(Dg, "__esModule", {
  value: !0
});
var A9e = function(e, t) {
  var n = e.indexOf("#") === 0 ? e.substring(1) : e, r = n ? "#" + n : "", o = window && window.location, i = r ? o.pathname + o.search + r : o.pathname + o.search;
  t ? history.pushState(history.state, "", i) : history.replaceState(history.state, "", i);
}, R9e = function() {
  return window.location.hash.replace(/^#/, "");
}, I9e = function(e) {
  return function(t) {
    return e.contains ? e != t && e.contains(t) : !!(e.compareDocumentPosition(t) & 16);
  };
}, N9e = function(e) {
  return getComputedStyle(e).position !== "static";
}, qk = function(e, t) {
  for (var n = e.offsetTop, r = e.offsetParent; r && !t(r); )
    n += r.offsetTop, r = r.offsetParent;
  return { offsetTop: n, offsetParent: r };
}, B9e = function(e, t, n) {
  if (n)
    return e === document ? t.getBoundingClientRect().left + (window.scrollX || window.pageXOffset) : getComputedStyle(e).position !== "static" ? t.offsetLeft : t.offsetLeft - e.offsetLeft;
  if (e === document)
    return t.getBoundingClientRect().top + (window.scrollY || window.pageYOffset);
  if (N9e(e)) {
    if (t.offsetParent !== e) {
      var r = function(l) {
        return l === e || l === document;
      }, o = qk(t, r), i = o.offsetTop, a = o.offsetParent;
      if (a !== e)
        throw new Error("Seems containerElement is not an ancestor of the Element");
      return i;
    }
    return t.offsetTop;
  }
  if (t.offsetParent === e.offsetParent)
    return t.offsetTop - e.offsetTop;
  var s = function(l) {
    return l === document;
  };
  return qk(t, s).offsetTop - qk(e, s).offsetTop;
};
Dg.default = {
  updateHash: A9e,
  getHash: R9e,
  filterElementInContainer: I9e,
  scrollOffset: B9e
};
var IO = {}, FT = {};
Object.defineProperty(FT, "__esModule", {
  value: !0
});
FT.default = {
  /*
   * https://github.com/oblador/angular-scroll (duScrollDefaultEasing)
   */
  defaultEasing: function(e) {
    return e < 0.5 ? Math.pow(e * 2, 2) / 2 : 1 - Math.pow((1 - e) * 2, 2) / 2;
  },
  /*
   * https://gist.github.com/gre/1650294
   */
  // no easing, no acceleration
  linear: function(e) {
    return e;
  },
  // accelerating from zero velocity
  easeInQuad: function(e) {
    return e * e;
  },
  // decelerating to zero velocity
  easeOutQuad: function(e) {
    return e * (2 - e);
  },
  // acceleration until halfway, then deceleration
  easeInOutQuad: function(e) {
    return e < 0.5 ? 2 * e * e : -1 + (4 - 2 * e) * e;
  },
  // accelerating from zero velocity 
  easeInCubic: function(e) {
    return e * e * e;
  },
  // decelerating to zero velocity π
  easeOutCubic: function(e) {
    return --e * e * e + 1;
  },
  // acceleration until halfway, then deceleration 
  easeInOutCubic: function(e) {
    return e < 0.5 ? 4 * e * e * e : (e - 1) * (2 * e - 2) * (2 * e - 2) + 1;
  },
  // accelerating from zero velocity 
  easeInQuart: function(e) {
    return e * e * e * e;
  },
  // decelerating to zero velocity 
  easeOutQuart: function(e) {
    return 1 - --e * e * e * e;
  },
  // acceleration until halfway, then deceleration
  easeInOutQuart: function(e) {
    return e < 0.5 ? 8 * e * e * e * e : 1 - 8 * --e * e * e * e;
  },
  // accelerating from zero velocity
  easeInQuint: function(e) {
    return e * e * e * e * e;
  },
  // decelerating to zero velocity
  easeOutQuint: function(e) {
    return 1 + --e * e * e * e * e;
  },
  // acceleration until halfway, then deceleration 
  easeInOutQuint: function(e) {
    return e < 0.5 ? 16 * e * e * e * e * e : 1 + 16 * --e * e * e * e * e;
  }
};
var zT = {};
Object.defineProperty(zT, "__esModule", {
  value: !0
});
var F9e = Mg, z9e = ["mousedown", "wheel", "touchmove", "keydown"];
zT.default = {
  subscribe: function(e) {
    return typeof document < "u" && z9e.forEach(function(t) {
      return (0, F9e.addPassiveEventListener)(document, t, e);
    });
  }
};
var Tg = {};
Object.defineProperty(Tg, "__esModule", {
  value: !0
});
var fP = {
  registered: {},
  scrollEvent: {
    register: function(e, t) {
      fP.registered[e] = t;
    },
    remove: function(e) {
      fP.registered[e] = null;
    }
  }
};
Tg.default = fP;
Object.defineProperty(IO, "__esModule", {
  value: !0
});
var U9e = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, H9e = Dg;
NO(H9e);
var W9e = FT, z6 = NO(W9e), $9e = zT, V9e = NO($9e), Z9e = Tg, sa = NO(Z9e);
function NO(e) {
  return e && e.__esModule ? e : { default: e };
}
var xre = function(e) {
  return z6.default[e.smooth] || z6.default.defaultEasing;
}, q9e = function(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}, G9e = function() {
  if (typeof window < "u")
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame;
}, hP = function() {
  return G9e() || function(e, t, n) {
    window.setTimeout(e, n || 1e3 / 60, (/* @__PURE__ */ new Date()).getTime());
  };
}(), Ere = function() {
  return {
    currentPosition: 0,
    startPosition: 0,
    targetPosition: 0,
    progress: 0,
    duration: 0,
    cancel: !1,
    target: null,
    containerElement: null,
    to: null,
    start: null,
    delta: null,
    percent: null,
    delayTimeout: null
  };
}, kre = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollLeft;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageXOffset : r ? document.documentElement.scrollLeft : document.body.scrollLeft;
}, Lre = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollTop;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageYOffset : r ? document.documentElement.scrollTop : document.body.scrollTop;
}, K9e = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollWidth - t.offsetWidth;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollWidth, n.offsetWidth, r.clientWidth, r.scrollWidth, r.offsetWidth);
}, X9e = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollHeight - t.offsetHeight;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollHeight, n.offsetHeight, r.clientHeight, r.scrollHeight, r.offsetHeight);
}, Y9e = function e(t, n, r) {
  var o = n.data;
  if (!n.ignoreCancelEvents && o.cancel) {
    sa.default.registered.end && sa.default.registered.end(o.to, o.target, o.currentPositionY);
    return;
  }
  if (o.delta = Math.round(o.targetPosition - o.startPosition), o.start === null && (o.start = r), o.progress = r - o.start, o.percent = o.progress >= o.duration ? 1 : t(o.progress / o.duration), o.currentPosition = o.startPosition + Math.ceil(o.delta * o.percent), o.containerElement && o.containerElement !== document && o.containerElement !== document.body ? n.horizontal ? o.containerElement.scrollLeft = o.currentPosition : o.containerElement.scrollTop = o.currentPosition : n.horizontal ? window.scrollTo(o.currentPosition, 0) : window.scrollTo(0, o.currentPosition), o.percent < 1) {
    var i = e.bind(null, t, n);
    hP.call(window, i);
    return;
  }
  sa.default.registered.end && sa.default.registered.end(o.to, o.target, o.currentPosition);
}, UT = function(e) {
  e.data.containerElement = e ? e.containerId ? document.getElementById(e.containerId) : e.container && e.container.nodeType ? e.container : document : null;
}, jg = function(e, t, n, r) {
  t.data = t.data || Ere(), window.clearTimeout(t.data.delayTimeout);
  var o = function() {
    t.data.cancel = !0;
  };
  if (V9e.default.subscribe(o), UT(t), t.data.start = null, t.data.cancel = !1, t.data.startPosition = t.horizontal ? kre(t) : Lre(t), t.data.targetPosition = t.absolute ? e : e + t.data.startPosition, t.data.startPosition === t.data.targetPosition) {
    sa.default.registered.end && sa.default.registered.end(t.data.to, t.data.target, t.data.currentPosition);
    return;
  }
  t.data.delta = Math.round(t.data.targetPosition - t.data.startPosition), t.data.duration = q9e(t.duration)(t.data.delta), t.data.duration = isNaN(parseFloat(t.data.duration)) ? 1e3 : parseFloat(t.data.duration), t.data.to = n, t.data.target = r;
  var i = xre(t), a = Y9e.bind(null, i, t);
  if (t && t.delay > 0) {
    t.data.delayTimeout = window.setTimeout(function() {
      sa.default.registered.begin && sa.default.registered.begin(t.data.to, t.data.target), hP.call(window, a);
    }, t.delay);
    return;
  }
  sa.default.registered.begin && sa.default.registered.begin(t.data.to, t.data.target), hP.call(window, a);
}, BO = function(e) {
  return e = U9e({}, e), e.data = e.data || Ere(), e.absolute = !0, e;
}, J9e = function(e) {
  jg(0, BO(e));
}, Q9e = function(e, t) {
  jg(e, BO(t));
}, e6e = function(e) {
  e = BO(e), UT(e), jg(e.horizontal ? K9e(e) : X9e(e), e);
}, t6e = function(e, t) {
  t = BO(t), UT(t);
  var n = t.horizontal ? kre(t) : Lre(t);
  jg(e + n, t);
};
IO.default = {
  animateTopScroll: jg,
  getAnimationType: xre,
  scrollToTop: J9e,
  scrollToBottom: e6e,
  scrollTo: Q9e,
  scrollMore: t6e
};
Object.defineProperty(Gp, "__esModule", {
  value: !0
});
var n6e = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, r6e = Dg, o6e = HT(r6e), i6e = IO, s6e = HT(i6e), a6e = Tg, Wv = HT(a6e);
function HT(e) {
  return e && e.__esModule ? e : { default: e };
}
var $v = {}, U6 = void 0;
Gp.default = {
  unmount: function() {
    $v = {};
  },
  register: function(e, t) {
    $v[e] = t;
  },
  unregister: function(e) {
    delete $v[e];
  },
  get: function(e) {
    return $v[e] || document.getElementById(e) || document.getElementsByName(e)[0] || document.getElementsByClassName(e)[0];
  },
  setActiveLink: function(e) {
    return U6 = e;
  },
  getActiveLink: function() {
    return U6;
  },
  scrollTo: function(e, t) {
    var n = this.get(e);
    if (!n) {
      console.warn("target Element not found");
      return;
    }
    t = n6e({}, t, { absolute: !1 });
    var r = t.containerId, o = t.container, i = void 0;
    r ? i = document.getElementById(r) : o && o.nodeType ? i = o : i = document, t.absolute = !0;
    var a = t.horizontal, s = o6e.default.scrollOffset(i, n, a) + (t.offset || 0);
    if (!t.smooth) {
      Wv.default.registered.begin && Wv.default.registered.begin(e, n), i === document ? t.horizontal ? window.scrollTo(s, 0) : window.scrollTo(0, s) : i.scrollTop = s, Wv.default.registered.end && Wv.default.registered.end(e, n);
      return;
    }
    s6e.default.animateTopScroll(s, t, e, n);
  }
};
var gP = { exports: {} }, Gk = { exports: {} }, Gn = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var H6;
function l6e() {
  if (H6) return Gn;
  H6 = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, g = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, m = e ? Symbol.for("react.block") : 60121, b = e ? Symbol.for("react.fundamental") : 60117, E = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
  function M(v) {
    if (typeof v == "object" && v !== null) {
      var C = v.$$typeof;
      switch (C) {
        case t:
          switch (v = v.type, v) {
            case l:
            case u:
            case r:
            case i:
            case o:
            case p:
              return v;
            default:
              switch (v = v && v.$$typeof, v) {
                case s:
                case c:
                case f:
                case g:
                case a:
                  return v;
                default:
                  return C;
              }
          }
        case n:
          return C;
      }
    }
  }
  function x(v) {
    return M(v) === u;
  }
  return Gn.AsyncMode = l, Gn.ConcurrentMode = u, Gn.ContextConsumer = s, Gn.ContextProvider = a, Gn.Element = t, Gn.ForwardRef = c, Gn.Fragment = r, Gn.Lazy = f, Gn.Memo = g, Gn.Portal = n, Gn.Profiler = i, Gn.StrictMode = o, Gn.Suspense = p, Gn.isAsyncMode = function(v) {
    return x(v) || M(v) === l;
  }, Gn.isConcurrentMode = x, Gn.isContextConsumer = function(v) {
    return M(v) === s;
  }, Gn.isContextProvider = function(v) {
    return M(v) === a;
  }, Gn.isElement = function(v) {
    return typeof v == "object" && v !== null && v.$$typeof === t;
  }, Gn.isForwardRef = function(v) {
    return M(v) === c;
  }, Gn.isFragment = function(v) {
    return M(v) === r;
  }, Gn.isLazy = function(v) {
    return M(v) === f;
  }, Gn.isMemo = function(v) {
    return M(v) === g;
  }, Gn.isPortal = function(v) {
    return M(v) === n;
  }, Gn.isProfiler = function(v) {
    return M(v) === i;
  }, Gn.isStrictMode = function(v) {
    return M(v) === o;
  }, Gn.isSuspense = function(v) {
    return M(v) === p;
  }, Gn.isValidElementType = function(v) {
    return typeof v == "string" || typeof v == "function" || v === r || v === u || v === i || v === o || v === p || v === d || typeof v == "object" && v !== null && (v.$$typeof === f || v.$$typeof === g || v.$$typeof === a || v.$$typeof === s || v.$$typeof === c || v.$$typeof === b || v.$$typeof === E || v.$$typeof === w || v.$$typeof === m);
  }, Gn.typeOf = M, Gn;
}
var or = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var W6;
function u6e() {
  return W6 || (W6 = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, g = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, m = e ? Symbol.for("react.block") : 60121, b = e ? Symbol.for("react.fundamental") : 60117, E = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
    function M(I) {
      return typeof I == "string" || typeof I == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      I === r || I === u || I === i || I === o || I === p || I === d || typeof I == "object" && I !== null && (I.$$typeof === f || I.$$typeof === g || I.$$typeof === a || I.$$typeof === s || I.$$typeof === c || I.$$typeof === b || I.$$typeof === E || I.$$typeof === w || I.$$typeof === m);
    }
    function x(I) {
      if (typeof I == "object" && I !== null) {
        var le = I.$$typeof;
        switch (le) {
          case t:
            var he = I.type;
            switch (he) {
              case l:
              case u:
              case r:
              case i:
              case o:
              case p:
                return he;
              default:
                var oe = he && he.$$typeof;
                switch (oe) {
                  case s:
                  case c:
                  case f:
                  case g:
                  case a:
                    return oe;
                  default:
                    return le;
                }
            }
          case n:
            return le;
        }
      }
    }
    var v = l, C = u, P = s, F = a, L = t, B = c, N = r, $ = f, V = g, H = n, Z = i, K = o, Y = p, Q = !1;
    function J(I) {
      return Q || (Q = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), _(I) || x(I) === l;
    }
    function _(I) {
      return x(I) === u;
    }
    function D(I) {
      return x(I) === s;
    }
    function z(I) {
      return x(I) === a;
    }
    function S(I) {
      return typeof I == "object" && I !== null && I.$$typeof === t;
    }
    function W(I) {
      return x(I) === c;
    }
    function O(I) {
      return x(I) === r;
    }
    function j(I) {
      return x(I) === f;
    }
    function U(I) {
      return x(I) === g;
    }
    function T(I) {
      return x(I) === n;
    }
    function q(I) {
      return x(I) === i;
    }
    function A(I) {
      return x(I) === o;
    }
    function X(I) {
      return x(I) === p;
    }
    or.AsyncMode = v, or.ConcurrentMode = C, or.ContextConsumer = P, or.ContextProvider = F, or.Element = L, or.ForwardRef = B, or.Fragment = N, or.Lazy = $, or.Memo = V, or.Portal = H, or.Profiler = Z, or.StrictMode = K, or.Suspense = Y, or.isAsyncMode = J, or.isConcurrentMode = _, or.isContextConsumer = D, or.isContextProvider = z, or.isElement = S, or.isForwardRef = W, or.isFragment = O, or.isLazy = j, or.isMemo = U, or.isPortal = T, or.isProfiler = q, or.isStrictMode = A, or.isSuspense = X, or.isValidElementType = M, or.typeOf = x;
  }()), or;
}
var $6;
function _re() {
  return $6 || ($6 = 1, process.env.NODE_ENV === "production" ? Gk.exports = l6e() : Gk.exports = u6e()), Gk.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var Kk, V6;
function c6e() {
  if (V6) return Kk;
  V6 = 1;
  var e = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, n = Object.prototype.propertyIsEnumerable;
  function r(i) {
    if (i == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(i);
  }
  function o() {
    try {
      if (!Object.assign)
        return !1;
      var i = new String("abc");
      if (i[5] = "de", Object.getOwnPropertyNames(i)[0] === "5")
        return !1;
      for (var a = {}, s = 0; s < 10; s++)
        a["_" + String.fromCharCode(s)] = s;
      var l = Object.getOwnPropertyNames(a).map(function(c) {
        return a[c];
      });
      if (l.join("") !== "0123456789")
        return !1;
      var u = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(c) {
        u[c] = c;
      }), Object.keys(Object.assign({}, u)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return Kk = o() ? Object.assign : function(i, a) {
    for (var s, l = r(i), u, c = 1; c < arguments.length; c++) {
      s = Object(arguments[c]);
      for (var p in s)
        t.call(s, p) && (l[p] = s[p]);
      if (e) {
        u = e(s);
        for (var d = 0; d < u.length; d++)
          n.call(s, u[d]) && (l[u[d]] = s[u[d]]);
      }
    }
    return l;
  }, Kk;
}
var Xk, Z6;
function WT() {
  if (Z6) return Xk;
  Z6 = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return Xk = e, Xk;
}
var q6, G6;
function Pre() {
  return G6 || (G6 = 1, q6 = Function.call.bind(Object.prototype.hasOwnProperty)), q6;
}
var Yk, K6;
function p6e() {
  if (K6) return Yk;
  K6 = 1;
  var e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = WT(), n = {}, r = Pre();
    e = function(i) {
      var a = "Warning: " + i;
      typeof console < "u" && console.error(a);
      try {
        throw new Error(a);
      } catch {
      }
    };
  }
  function o(i, a, s, l, u) {
    if (process.env.NODE_ENV !== "production") {
      for (var c in i)
        if (r(i, c)) {
          var p;
          try {
            if (typeof i[c] != "function") {
              var d = Error(
                (l || "React class") + ": " + s + " type `" + c + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof i[c] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw d.name = "Invariant Violation", d;
            }
            p = i[c](a, c, l, s, null, t);
          } catch (f) {
            p = f;
          }
          if (p && !(p instanceof Error) && e(
            (l || "React class") + ": type specification of " + s + " `" + c + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof p + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), p instanceof Error && !(p.message in n)) {
            n[p.message] = !0;
            var g = u ? u() : "";
            e(
              "Failed " + s + " type: " + p.message + (g ?? "")
            );
          }
        }
    }
  }
  return o.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (n = {});
  }, Yk = o, Yk;
}
var Jk, X6;
function d6e() {
  if (X6) return Jk;
  X6 = 1;
  var e = _re(), t = c6e(), n = WT(), r = Pre(), o = p6e(), i = function() {
  };
  process.env.NODE_ENV !== "production" && (i = function(s) {
    var l = "Warning: " + s;
    typeof console < "u" && console.error(l);
    try {
      throw new Error(l);
    } catch {
    }
  });
  function a() {
    return null;
  }
  return Jk = function(s, l) {
    var u = typeof Symbol == "function" && Symbol.iterator, c = "@@iterator";
    function p(_) {
      var D = _ && (u && _[u] || _[c]);
      if (typeof D == "function")
        return D;
    }
    var d = "<<anonymous>>", g = {
      array: E("array"),
      bigint: E("bigint"),
      bool: E("boolean"),
      func: E("function"),
      number: E("number"),
      object: E("object"),
      string: E("string"),
      symbol: E("symbol"),
      any: w(),
      arrayOf: M,
      element: x(),
      elementType: v(),
      instanceOf: C,
      node: B(),
      objectOf: F,
      oneOf: P,
      oneOfType: L,
      shape: $,
      exact: V
    };
    function f(_, D) {
      return _ === D ? _ !== 0 || 1 / _ === 1 / D : _ !== _ && D !== D;
    }
    function m(_, D) {
      this.message = _, this.data = D && typeof D == "object" ? D : {}, this.stack = "";
    }
    m.prototype = Error.prototype;
    function b(_) {
      if (process.env.NODE_ENV !== "production")
        var D = {}, z = 0;
      function S(O, j, U, T, q, A, X) {
        if (T = T || d, A = A || U, X !== n) {
          if (l) {
            var I = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw I.name = "Invariant Violation", I;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var le = T + ":" + U;
            !D[le] && // Avoid spamming the console because they are often not actionable except for lib authors
            z < 3 && (i(
              "You are manually calling a React.PropTypes validation function for the `" + A + "` prop on `" + T + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), D[le] = !0, z++);
          }
        }
        return j[U] == null ? O ? j[U] === null ? new m("The " + q + " `" + A + "` is marked as required " + ("in `" + T + "`, but its value is `null`.")) : new m("The " + q + " `" + A + "` is marked as required in " + ("`" + T + "`, but its value is `undefined`.")) : null : _(j, U, T, q, A);
      }
      var W = S.bind(null, !1);
      return W.isRequired = S.bind(null, !0), W;
    }
    function E(_) {
      function D(z, S, W, O, j, U) {
        var T = z[S], q = K(T);
        if (q !== _) {
          var A = Y(T);
          return new m(
            "Invalid " + O + " `" + j + "` of type " + ("`" + A + "` supplied to `" + W + "`, expected ") + ("`" + _ + "`."),
            { expectedType: _ }
          );
        }
        return null;
      }
      return b(D);
    }
    function w() {
      return b(a);
    }
    function M(_) {
      function D(z, S, W, O, j) {
        if (typeof _ != "function")
          return new m("Property `" + j + "` of component `" + W + "` has invalid PropType notation inside arrayOf.");
        var U = z[S];
        if (!Array.isArray(U)) {
          var T = K(U);
          return new m("Invalid " + O + " `" + j + "` of type " + ("`" + T + "` supplied to `" + W + "`, expected an array."));
        }
        for (var q = 0; q < U.length; q++) {
          var A = _(U, q, W, O, j + "[" + q + "]", n);
          if (A instanceof Error)
            return A;
        }
        return null;
      }
      return b(D);
    }
    function x() {
      function _(D, z, S, W, O) {
        var j = D[z];
        if (!s(j)) {
          var U = K(j);
          return new m("Invalid " + W + " `" + O + "` of type " + ("`" + U + "` supplied to `" + S + "`, expected a single ReactElement."));
        }
        return null;
      }
      return b(_);
    }
    function v() {
      function _(D, z, S, W, O) {
        var j = D[z];
        if (!e.isValidElementType(j)) {
          var U = K(j);
          return new m("Invalid " + W + " `" + O + "` of type " + ("`" + U + "` supplied to `" + S + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return b(_);
    }
    function C(_) {
      function D(z, S, W, O, j) {
        if (!(z[S] instanceof _)) {
          var U = _.name || d, T = J(z[S]);
          return new m("Invalid " + O + " `" + j + "` of type " + ("`" + T + "` supplied to `" + W + "`, expected ") + ("instance of `" + U + "`."));
        }
        return null;
      }
      return b(D);
    }
    function P(_) {
      if (!Array.isArray(_))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? i(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : i("Invalid argument supplied to oneOf, expected an array.")), a;
      function D(z, S, W, O, j) {
        for (var U = z[S], T = 0; T < _.length; T++)
          if (f(U, _[T]))
            return null;
        var q = JSON.stringify(_, function(A, X) {
          var I = Y(X);
          return I === "symbol" ? String(X) : X;
        });
        return new m("Invalid " + O + " `" + j + "` of value `" + String(U) + "` " + ("supplied to `" + W + "`, expected one of " + q + "."));
      }
      return b(D);
    }
    function F(_) {
      function D(z, S, W, O, j) {
        if (typeof _ != "function")
          return new m("Property `" + j + "` of component `" + W + "` has invalid PropType notation inside objectOf.");
        var U = z[S], T = K(U);
        if (T !== "object")
          return new m("Invalid " + O + " `" + j + "` of type " + ("`" + T + "` supplied to `" + W + "`, expected an object."));
        for (var q in U)
          if (r(U, q)) {
            var A = _(U, q, W, O, j + "." + q, n);
            if (A instanceof Error)
              return A;
          }
        return null;
      }
      return b(D);
    }
    function L(_) {
      if (!Array.isArray(_))
        return process.env.NODE_ENV !== "production" && i("Invalid argument supplied to oneOfType, expected an instance of array."), a;
      for (var D = 0; D < _.length; D++) {
        var z = _[D];
        if (typeof z != "function")
          return i(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + Q(z) + " at index " + D + "."
          ), a;
      }
      function S(W, O, j, U, T) {
        for (var q = [], A = 0; A < _.length; A++) {
          var X = _[A], I = X(W, O, j, U, T, n);
          if (I == null)
            return null;
          I.data && r(I.data, "expectedType") && q.push(I.data.expectedType);
        }
        var le = q.length > 0 ? ", expected one of type [" + q.join(", ") + "]" : "";
        return new m("Invalid " + U + " `" + T + "` supplied to " + ("`" + j + "`" + le + "."));
      }
      return b(S);
    }
    function B() {
      function _(D, z, S, W, O) {
        return H(D[z]) ? null : new m("Invalid " + W + " `" + O + "` supplied to " + ("`" + S + "`, expected a ReactNode."));
      }
      return b(_);
    }
    function N(_, D, z, S, W) {
      return new m(
        (_ || "React class") + ": " + D + " type `" + z + "." + S + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + W + "`."
      );
    }
    function $(_) {
      function D(z, S, W, O, j) {
        var U = z[S], T = K(U);
        if (T !== "object")
          return new m("Invalid " + O + " `" + j + "` of type `" + T + "` " + ("supplied to `" + W + "`, expected `object`."));
        for (var q in _) {
          var A = _[q];
          if (typeof A != "function")
            return N(W, O, j, q, Y(A));
          var X = A(U, q, W, O, j + "." + q, n);
          if (X)
            return X;
        }
        return null;
      }
      return b(D);
    }
    function V(_) {
      function D(z, S, W, O, j) {
        var U = z[S], T = K(U);
        if (T !== "object")
          return new m("Invalid " + O + " `" + j + "` of type `" + T + "` " + ("supplied to `" + W + "`, expected `object`."));
        var q = t({}, z[S], _);
        for (var A in q) {
          var X = _[A];
          if (r(_, A) && typeof X != "function")
            return N(W, O, j, A, Y(X));
          if (!X)
            return new m(
              "Invalid " + O + " `" + j + "` key `" + A + "` supplied to `" + W + "`.\nBad object: " + JSON.stringify(z[S], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(_), null, "  ")
            );
          var I = X(U, A, W, O, j + "." + A, n);
          if (I)
            return I;
        }
        return null;
      }
      return b(D);
    }
    function H(_) {
      switch (typeof _) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !_;
        case "object":
          if (Array.isArray(_))
            return _.every(H);
          if (_ === null || s(_))
            return !0;
          var D = p(_);
          if (D) {
            var z = D.call(_), S;
            if (D !== _.entries) {
              for (; !(S = z.next()).done; )
                if (!H(S.value))
                  return !1;
            } else
              for (; !(S = z.next()).done; ) {
                var W = S.value;
                if (W && !H(W[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function Z(_, D) {
      return _ === "symbol" ? !0 : D ? D["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && D instanceof Symbol : !1;
    }
    function K(_) {
      var D = typeof _;
      return Array.isArray(_) ? "array" : _ instanceof RegExp ? "object" : Z(D, _) ? "symbol" : D;
    }
    function Y(_) {
      if (typeof _ > "u" || _ === null)
        return "" + _;
      var D = K(_);
      if (D === "object") {
        if (_ instanceof Date)
          return "date";
        if (_ instanceof RegExp)
          return "regexp";
      }
      return D;
    }
    function Q(_) {
      var D = Y(_);
      switch (D) {
        case "array":
        case "object":
          return "an " + D;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + D;
        default:
          return D;
      }
    }
    function J(_) {
      return !_.constructor || !_.constructor.name ? d : _.constructor.name;
    }
    return g.checkPropTypes = o, g.resetWarningCache = o.resetWarningCache, g.PropTypes = g, g;
  }, Jk;
}
var Qk, Y6;
function f6e() {
  if (Y6) return Qk;
  Y6 = 1;
  var e = WT();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, Qk = function() {
    function r(a, s, l, u, c, p) {
      if (p !== e) {
        var d = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw d.name = "Invariant Violation", d;
      }
    }
    r.isRequired = r;
    function o() {
      return r;
    }
    var i = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: o,
      element: r,
      elementType: r,
      instanceOf: o,
      node: r,
      objectOf: o,
      oneOf: o,
      oneOfType: o,
      shape: o,
      exact: o,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return i.PropTypes = i, i;
  }, Qk;
}
if (process.env.NODE_ENV !== "production") {
  var h6e = _re(), g6e = !0;
  gP.exports = d6e()(h6e.isElement, g6e);
} else
  gP.exports = f6e()();
var FO = gP.exports, zO = {};
Object.defineProperty(zO, "__esModule", {
  value: !0
});
var m6e = Dg, eL = v6e(m6e);
function v6e(e) {
  return e && e.__esModule ? e : { default: e };
}
var y6e = {
  mountFlag: !1,
  initialized: !1,
  scroller: null,
  containers: {},
  mount: function(e) {
    this.scroller = e, this.handleHashChange = this.handleHashChange.bind(this), window.addEventListener("hashchange", this.handleHashChange), this.initStateFromHash(), this.mountFlag = !0;
  },
  mapContainer: function(e, t) {
    this.containers[e] = t;
  },
  isMounted: function() {
    return this.mountFlag;
  },
  isInitialized: function() {
    return this.initialized;
  },
  initStateFromHash: function() {
    var e = this, t = this.getHash();
    t ? window.setTimeout(function() {
      e.scrollTo(t, !0), e.initialized = !0;
    }, 10) : this.initialized = !0;
  },
  scrollTo: function(e, t) {
    var n = this.scroller, r = n.get(e);
    if (r && (t || e !== n.getActiveLink())) {
      var o = this.containers[e] || document;
      n.scrollTo(e, { container: o });
    }
  },
  getHash: function() {
    return eL.default.getHash();
  },
  changeHash: function(e, t) {
    this.isInitialized() && eL.default.getHash() !== e && eL.default.updateHash(e, t);
  },
  handleHashChange: function() {
    this.scrollTo(this.getHash());
  },
  unmount: function() {
    this.scroller = null, this.containers = null, window.removeEventListener("hashchange", this.handleHashChange);
  }
};
zO.default = y6e;
Object.defineProperty(Pg, "__esModule", {
  value: !0
});
var Vv = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, b6e = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), w6e = be, J6 = Ag(w6e), C6e = Sg, Zv = Ag(C6e), O6e = Gp, x6e = Ag(O6e), E6e = FO, to = Ag(E6e), k6e = zO, El = Ag(k6e);
function Ag(e) {
  return e && e.__esModule ? e : { default: e };
}
function L6e(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function _6e(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function P6e(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var Q6 = {
  to: to.default.string.isRequired,
  containerId: to.default.string,
  container: to.default.object,
  activeClass: to.default.string,
  activeStyle: to.default.object,
  spy: to.default.bool,
  horizontal: to.default.bool,
  smooth: to.default.oneOfType([to.default.bool, to.default.string]),
  offset: to.default.number,
  delay: to.default.number,
  isDynamic: to.default.bool,
  onClick: to.default.func,
  duration: to.default.oneOfType([to.default.number, to.default.func]),
  absolute: to.default.bool,
  onSetActive: to.default.func,
  onSetInactive: to.default.func,
  ignoreCancelEvents: to.default.bool,
  hashSpy: to.default.bool,
  saveHashHistory: to.default.bool,
  spyThrottle: to.default.number
};
Pg.default = function(e, t) {
  var n = t || x6e.default, r = function(i) {
    P6e(a, i);
    function a(s) {
      L6e(this, a);
      var l = _6e(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
      return o.call(l), l.state = {
        active: !1
      }, l.beforeUnmountCallbacks = [], l;
    }
    return b6e(a, [{
      key: "getScrollSpyContainer",
      value: function() {
        var s = this.props.containerId, l = this.props.container;
        return s && !l ? document.getElementById(s) : l && l.nodeType ? l : document;
      }
    }, {
      key: "componentDidMount",
      value: function() {
        if (this.props.spy || this.props.hashSpy) {
          var s = this.getScrollSpyContainer();
          if (!Zv.default.isMounted(s)) {
            var l = Zv.default.mount(s, this.props.spyThrottle);
            this.beforeUnmountCallbacks.push(l);
          }
          this.props.hashSpy && (El.default.isMounted() || El.default.mount(n), El.default.mapContainer(this.props.to, s)), Zv.default.addSpyHandler(this.spyHandler, s), this.setState({
            container: s
          });
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        Zv.default.unmount(this.stateHandler, this.spyHandler), this.beforeUnmountCallbacks.forEach(function(s) {
          return s();
        });
      }
    }, {
      key: "render",
      value: function() {
        var s = "";
        this.state && this.state.active ? s = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : s = this.props.className;
        var l = {};
        this.state && this.state.active ? l = Vv({}, this.props.style, this.props.activeStyle) : l = Vv({}, this.props.style);
        var u = Vv({}, this.props);
        for (var c in Q6)
          u.hasOwnProperty(c) && delete u[c];
        return u.className = s, u.style = l, u.onClick = this.handleClick, J6.default.createElement(e, u);
      }
    }]), a;
  }(J6.default.PureComponent), o = function() {
    var i = this;
    this.scrollTo = function(a, s) {
      n.scrollTo(a, Vv({}, i.state, s));
    }, this.handleClick = function(a) {
      i.props.onClick && i.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), i.scrollTo(i.props.to, i.props);
    }, this.spyHandler = function(a, s) {
      var l = i.getScrollSpyContainer();
      if (!(El.default.isMounted() && !El.default.isInitialized())) {
        var u = i.props.horizontal, c = i.props.to, p = null, d = void 0, g = void 0;
        if (u) {
          var f = 0, m = 0, b = 0;
          if (l.getBoundingClientRect) {
            var E = l.getBoundingClientRect();
            b = E.left;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var w = p.getBoundingClientRect();
            f = w.left - b + a, m = f + w.width;
          }
          var M = a - i.props.offset;
          d = M >= Math.floor(f) && M < Math.floor(m), g = M < Math.floor(f) || M >= Math.floor(m);
        } else {
          var x = 0, v = 0, C = 0;
          if (l.getBoundingClientRect) {
            var P = l.getBoundingClientRect();
            C = P.top;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var F = p.getBoundingClientRect();
            x = F.top - C + s, v = x + F.height;
          }
          var L = s - i.props.offset;
          d = L >= Math.floor(x) && L < Math.floor(v), g = L < Math.floor(x) || L >= Math.floor(v);
        }
        var B = n.getActiveLink();
        if (g) {
          if (c === B && n.setActiveLink(void 0), i.props.hashSpy && El.default.getHash() === c) {
            var N = i.props.saveHashHistory, $ = N === void 0 ? !1 : N;
            El.default.changeHash("", $);
          }
          i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive(c, p));
        }
        if (d && (B !== c || i.state.active === !1)) {
          n.setActiveLink(c);
          var V = i.props.saveHashHistory, H = V === void 0 ? !1 : V;
          i.props.hashSpy && El.default.changeHash(c, H), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(c, p));
        }
      }
    };
  };
  return r.propTypes = Q6, r.defaultProps = { offset: 0 }, r;
};
Object.defineProperty(BT, "__esModule", {
  value: !0
});
var S6e = be, e8 = Sre(S6e), M6e = Pg, D6e = Sre(M6e);
function Sre(e) {
  return e && e.__esModule ? e : { default: e };
}
function T6e(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function t8(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function j6e(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var A6e = function(e) {
  j6e(t, e);
  function t() {
    var n, r, o, i;
    T6e(this, t);
    for (var a = arguments.length, s = Array(a), l = 0; l < a; l++)
      s[l] = arguments[l];
    return i = (r = (o = t8(this, (n = t.__proto__ || Object.getPrototypeOf(t)).call.apply(n, [this].concat(s))), o), o.render = function() {
      return e8.default.createElement(
        "a",
        o.props,
        o.props.children
      );
    }, r), t8(o, i);
  }
  return t;
}(e8.default.Component);
BT.default = (0, D6e.default)(A6e);
var $T = {};
Object.defineProperty($T, "__esModule", {
  value: !0
});
var R6e = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), I6e = be, n8 = Mre(I6e), N6e = Pg, B6e = Mre(N6e);
function Mre(e) {
  return e && e.__esModule ? e : { default: e };
}
function F6e(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function z6e(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function U6e(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var H6e = function(e) {
  U6e(t, e);
  function t() {
    return F6e(this, t), z6e(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return R6e(t, [{
    key: "render",
    value: function() {
      return n8.default.createElement(
        "button",
        this.props,
        this.props.children
      );
    }
  }]), t;
}(n8.default.Component);
$T.default = (0, B6e.default)(H6e);
var VT = {}, UO = {};
Object.defineProperty(UO, "__esModule", {
  value: !0
});
var W6e = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, $6e = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), V6e = be, r8 = HO(V6e), Z6e = il;
HO(Z6e);
var q6e = Gp, o8 = HO(q6e), G6e = FO, i8 = HO(G6e);
function HO(e) {
  return e && e.__esModule ? e : { default: e };
}
function K6e(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function X6e(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function Y6e(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
UO.default = function(e) {
  var t = function(n) {
    Y6e(r, n);
    function r(o) {
      K6e(this, r);
      var i = X6e(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
      return i.childBindings = {
        domNode: null
      }, i;
    }
    return $6e(r, [{
      key: "componentDidMount",
      value: function() {
        if (typeof window > "u")
          return !1;
        this.registerElems(this.props.name);
      }
    }, {
      key: "componentDidUpdate",
      value: function(o) {
        this.props.name !== o.name && this.registerElems(this.props.name);
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        if (typeof window > "u")
          return !1;
        o8.default.unregister(this.props.name);
      }
    }, {
      key: "registerElems",
      value: function(o) {
        o8.default.register(o, this.childBindings.domNode);
      }
    }, {
      key: "render",
      value: function() {
        return r8.default.createElement(e, W6e({}, this.props, { parentBindings: this.childBindings }));
      }
    }]), r;
  }(r8.default.Component);
  return t.propTypes = {
    name: i8.default.string,
    id: i8.default.string
  }, t;
};
Object.defineProperty(VT, "__esModule", {
  value: !0
});
var s8 = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, J6e = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), Q6e = be, a8 = ZT(Q6e), e8e = UO, t8e = ZT(e8e), n8e = FO, l8 = ZT(n8e);
function ZT(e) {
  return e && e.__esModule ? e : { default: e };
}
function r8e(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function o8e(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function i8e(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var Dre = function(e) {
  i8e(t, e);
  function t() {
    return r8e(this, t), o8e(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return J6e(t, [{
    key: "render",
    value: function() {
      var n = this, r = s8({}, this.props);
      return delete r.name, r.parentBindings && delete r.parentBindings, a8.default.createElement(
        "div",
        s8({}, r, { ref: function(o) {
          n.props.parentBindings.domNode = o;
        } }),
        this.props.children
      );
    }
  }]), t;
}(a8.default.Component);
Dre.propTypes = {
  name: l8.default.string,
  id: l8.default.string
};
VT.default = (0, t8e.default)(Dre);
var tL = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, u8 = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}();
function c8(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function p8(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function d8(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var qv = be, Wu = Sg, nL = Gp, xo = FO, kl = zO, f8 = {
  to: xo.string.isRequired,
  containerId: xo.string,
  container: xo.object,
  activeClass: xo.string,
  spy: xo.bool,
  smooth: xo.oneOfType([xo.bool, xo.string]),
  offset: xo.number,
  delay: xo.number,
  isDynamic: xo.bool,
  onClick: xo.func,
  duration: xo.oneOfType([xo.number, xo.func]),
  absolute: xo.bool,
  onSetActive: xo.func,
  onSetInactive: xo.func,
  ignoreCancelEvents: xo.bool,
  hashSpy: xo.bool,
  spyThrottle: xo.number
}, s8e = {
  Scroll: function(e, t) {
    console.warn("Helpers.Scroll is deprecated since v1.7.0");
    var n = t || nL, r = function(i) {
      d8(a, i);
      function a(s) {
        c8(this, a);
        var l = p8(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
        return o.call(l), l.state = {
          active: !1
        }, l;
      }
      return u8(a, [{
        key: "getScrollSpyContainer",
        value: function() {
          var s = this.props.containerId, l = this.props.container;
          return s ? document.getElementById(s) : l && l.nodeType ? l : document;
        }
      }, {
        key: "componentDidMount",
        value: function() {
          if (this.props.spy || this.props.hashSpy) {
            var s = this.getScrollSpyContainer();
            Wu.isMounted(s) || Wu.mount(s, this.props.spyThrottle), this.props.hashSpy && (kl.isMounted() || kl.mount(n), kl.mapContainer(this.props.to, s)), this.props.spy && Wu.addStateHandler(this.stateHandler), Wu.addSpyHandler(this.spyHandler, s), this.setState({
              container: s
            });
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          Wu.unmount(this.stateHandler, this.spyHandler);
        }
      }, {
        key: "render",
        value: function() {
          var s = "";
          this.state && this.state.active ? s = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : s = this.props.className;
          var l = tL({}, this.props);
          for (var u in f8)
            l.hasOwnProperty(u) && delete l[u];
          return l.className = s, l.onClick = this.handleClick, qv.createElement(e, l);
        }
      }]), a;
    }(qv.Component), o = function() {
      var i = this;
      this.scrollTo = function(a, s) {
        n.scrollTo(a, tL({}, i.state, s));
      }, this.handleClick = function(a) {
        i.props.onClick && i.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), i.scrollTo(i.props.to, i.props);
      }, this.stateHandler = function() {
        n.getActiveLink() !== i.props.to && (i.state !== null && i.state.active && i.props.onSetInactive && i.props.onSetInactive(), i.setState({ active: !1 }));
      }, this.spyHandler = function(a) {
        var s = i.getScrollSpyContainer();
        if (!(kl.isMounted() && !kl.isInitialized())) {
          var l = i.props.to, u = null, c = 0, p = 0, d = 0;
          if (s.getBoundingClientRect) {
            var g = s.getBoundingClientRect();
            d = g.top;
          }
          if (!u || i.props.isDynamic) {
            if (u = n.get(l), !u)
              return;
            var f = u.getBoundingClientRect();
            c = f.top - d + a, p = c + f.height;
          }
          var m = a - i.props.offset, b = m >= Math.floor(c) && m < Math.floor(p), E = m < Math.floor(c) || m >= Math.floor(p), w = n.getActiveLink();
          if (E)
            return l === w && n.setActiveLink(void 0), i.props.hashSpy && kl.getHash() === l && kl.changeHash(), i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive()), Wu.updateStates();
          if (b && w !== l)
            return n.setActiveLink(l), i.props.hashSpy && kl.changeHash(l), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(l)), Wu.updateStates();
        }
      };
    };
    return r.propTypes = f8, r.defaultProps = { offset: 0 }, r;
  },
  Element: function(e) {
    console.warn("Helpers.Element is deprecated since v1.7.0");
    var t = function(n) {
      d8(r, n);
      function r(o) {
        c8(this, r);
        var i = p8(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
        return i.childBindings = {
          domNode: null
        }, i;
      }
      return u8(r, [{
        key: "componentDidMount",
        value: function() {
          if (typeof window > "u")
            return !1;
          this.registerElems(this.props.name);
        }
      }, {
        key: "componentDidUpdate",
        value: function(o) {
          this.props.name !== o.name && this.registerElems(this.props.name);
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          if (typeof window > "u")
            return !1;
          nL.unregister(this.props.name);
        }
      }, {
        key: "registerElems",
        value: function(o) {
          nL.register(o, this.childBindings.domNode);
        }
      }, {
        key: "render",
        value: function() {
          return qv.createElement(e, tL({}, this.props, { parentBindings: this.childBindings }));
        }
      }]), r;
    }(qv.Component);
    return t.propTypes = {
      name: xo.string,
      id: xo.string
    }, t;
  }
}, a8e = s8e;
Object.defineProperty(Bo, "__esModule", {
  value: !0
});
Bo.Helpers = Bo.ScrollElement = Bo.ScrollLink = Bo.animateScroll = Bo.scrollSpy = Bo.Events = Bo.scroller = Bo.Element = Bo.Button = Bo.Link = void 0;
var l8e = BT, Tre = Oa(l8e), u8e = $T, jre = Oa(u8e), c8e = VT, Are = Oa(c8e), p8e = Gp, Rre = Oa(p8e), d8e = Tg, Ire = Oa(d8e), f8e = Sg, Nre = Oa(f8e), h8e = IO, Bre = Oa(h8e), g8e = Pg, Fre = Oa(g8e), m8e = UO, zre = Oa(m8e), v8e = a8e, Ure = Oa(v8e);
function Oa(e) {
  return e && e.__esModule ? e : { default: e };
}
Bo.Link = Tre.default;
Bo.Button = jre.default;
Bo.Element = Are.default;
Bo.scroller = Rre.default;
Bo.Events = Ire.default;
Bo.scrollSpy = Nre.default;
Bo.animateScroll = Bre.default;
Bo.ScrollLink = Fre.default;
Bo.ScrollElement = zre.default;
Bo.Helpers = Ure.default;
Bo.default = { Link: Tre.default, Button: jre.default, Element: Are.default, scroller: Rre.default, Events: Ire.default, scrollSpy: Nre.default, animateScroll: Bre.default, ScrollLink: Fre.default, ScrollElement: zre.default, Helpers: Ure.default };
$e({});
$e({});
$e({});
function Bh(e) {
  "@babel/helpers - typeof";
  return Bh = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Bh(e);
}
function y8e(e, t) {
  if (Bh(e) != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (Bh(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function b8e(e) {
  var t = y8e(e, "string");
  return Bh(t) == "symbol" ? t : t + "";
}
function De(e, t, n) {
  return (t = b8e(t)) in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function Hre(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var rL, h8;
function w8e() {
  if (h8) return rL;
  h8 = 1;
  var e = process.env.NODE_ENV, t = function(n, r, o, i, a, s, l, u) {
    if (e !== "production" && r === void 0)
      throw new Error("invariant requires an error message argument");
    if (!n) {
      var c;
      if (r === void 0)
        c = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
      else {
        var p = [o, i, a, s, l, u], d = 0;
        c = new Error(r.replace(/%s/g, function() {
          return p[d++];
        })), c.name = "Invariant Violation";
      }
      throw c.framesToPop = 1, c;
    }
  };
  return rL = t, rL;
}
var C8e = w8e(), Zo = /* @__PURE__ */ Hre(C8e), zt = $e(null);
function O8e() {
  Zo(!!ge, "useGoogleMap is React hook and requires React version 16.8+");
  var e = ge(zt);
  return Zo(!!e, "useGoogleMap needs a GoogleMap available up in the tree"), e;
}
function x8e(e, t, n) {
  return Object.keys(e).reduce(function(r, o) {
    return t(r, e[o], o);
  }, n);
}
function E8e(e, t) {
  Object.keys(e).forEach((n) => t(e[n], n));
}
function k8e(e, t, n, r) {
  var o = {}, i = (a, s) => {
    var l = n[s];
    l !== t[s] && (o[s] = l, a(r, l));
  };
  return E8e(e, i), o;
}
function L8e(e, t, n) {
  var r = x8e(n, function(o, i, a) {
    return typeof e[a] == "function" && o.push(google.maps.event.addListener(t, i, e[a])), o;
  }, []);
  return r;
}
function _8e(e) {
  google.maps.event.removeListener(e);
}
function Sn() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  e.forEach(_8e);
}
function On(e) {
  var {
    updaterMap: t,
    eventMap: n,
    prevProps: r,
    nextProps: o,
    instance: i
  } = e, a = L8e(o, i, n);
  return k8e(t, r, o, i), a;
}
function P8e(e) {
  var {
    children: t,
    options: n,
    id: r,
    mapContainerStyle: o,
    mapContainerClassName: i,
    center: a,
    // clickableIcons,
    // extraMapTypes,
    // heading,
    // mapTypeId,
    onClick: s,
    onDblClick: l,
    onDrag: u,
    onDragEnd: c,
    onDragStart: p,
    onMouseMove: d,
    onMouseOut: g,
    onMouseOver: f,
    onMouseDown: m,
    onMouseUp: b,
    onRightClick: E,
    // onMapTypeIdChanged,
    // onTilesLoaded,
    // onBoundsChanged,
    onCenterChanged: w,
    // onHeadingChanged,
    // onIdle,
    // onProjectionChanged,
    // onResize,
    // onTiltChanged,
    // onZoomChanged,
    onLoad: M,
    onUnmount: x
  } = e, [v, C] = k(null), P = dt(null), [F, L] = k(null), [B, N] = k(null), [$, V] = k(null), [H, Z] = k(null), [K, Y] = k(null), [Q, J] = k(null), [_, D] = k(null), [z, S] = k(null), [W, O] = k(null), [j, U] = k(null), [T, q] = k(null), [A, X] = k(null);
  return h(() => {
    n && v !== null && v.setOptions(n);
  }, [v, n]), h(() => {
    v !== null && typeof a < "u" && v.setCenter(a);
  }, [v, a]), h(() => {
    v && l && (B !== null && google.maps.event.removeListener(B), N(google.maps.event.addListener(v, "dblclick", l)));
  }, [l]), h(() => {
    v && c && ($ !== null && google.maps.event.removeListener($), V(google.maps.event.addListener(v, "dragend", c)));
  }, [c]), h(() => {
    v && p && (H !== null && google.maps.event.removeListener(H), Z(google.maps.event.addListener(v, "dragstart", p)));
  }, [p]), h(() => {
    v && m && (K !== null && google.maps.event.removeListener(K), Y(google.maps.event.addListener(v, "mousedown", m)));
  }, [m]), h(() => {
    v && d && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(v, "mousemove", d)));
  }, [d]), h(() => {
    v && g && (_ !== null && google.maps.event.removeListener(_), D(google.maps.event.addListener(v, "mouseout", g)));
  }, [g]), h(() => {
    v && f && (z !== null && google.maps.event.removeListener(z), S(google.maps.event.addListener(v, "mouseover", f)));
  }, [f]), h(() => {
    v && b && (W !== null && google.maps.event.removeListener(W), O(google.maps.event.addListener(v, "mouseup", b)));
  }, [b]), h(() => {
    v && E && (j !== null && google.maps.event.removeListener(j), U(google.maps.event.addListener(v, "rightclick", E)));
  }, [E]), h(() => {
    v && s && (T !== null && google.maps.event.removeListener(T), q(google.maps.event.addListener(v, "click", s)));
  }, [s]), h(() => {
    v && u && (A !== null && google.maps.event.removeListener(A), X(google.maps.event.addListener(v, "drag", u)));
  }, [u]), h(() => {
    v && w && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(v, "center_changed", w)));
  }, [s]), h(() => {
    var I = P.current === null ? null : new google.maps.Map(P.current, n);
    return C(I), I !== null && M && M(I), () => {
      I !== null && x && x(I);
    };
  }, []), Yo.jsx("div", {
    id: r,
    ref: P,
    style: o,
    className: i,
    children: Yo.jsx(zt.Provider, {
      value: v,
      children: v !== null ? t : null
    })
  });
}
me(P8e);
function g8(e, t, n, r, o, i, a) {
  try {
    var s = e[i](a), l = s.value;
  } catch (u) {
    return void n(u);
  }
  s.done ? t(l) : Promise.resolve(l).then(r, o);
}
function Wre(e) {
  return function() {
    var t = this, n = arguments;
    return new Promise(function(r, o) {
      var i = e.apply(t, n);
      function a(l) {
        g8(i, r, o, a, s, "next", l);
      }
      function s(l) {
        g8(i, r, o, a, s, "throw", l);
      }
      a(void 0);
    });
  };
}
function $re(e) {
  var {
    googleMapsApiKey: t,
    googleMapsClientId: n,
    version: r = "weekly",
    language: o,
    region: i,
    libraries: a,
    channel: s,
    mapIds: l,
    authReferrerPolicy: u
  } = e, c = [];
  return Zo(t && n || !(t && n), "You need to specify either googleMapsApiKey or googleMapsClientId for @react-google-maps/api load script to work. You cannot use both at the same time."), t ? c.push("key=".concat(t)) : n && c.push("client=".concat(n)), r && c.push("v=".concat(r)), o && c.push("language=".concat(o)), i && c.push("region=".concat(i)), a && a.length && c.push("libraries=".concat(a.sort().join(","))), s && c.push("channel=".concat(s)), l && l.length && c.push("map_ids=".concat(l.join(","))), u && c.push("auth_referrer_policy=".concat(u)), c.push("loading=async"), c.push("callback=initMap"), "https://maps.googleapis.com/maps/api/js?".concat(c.join("&"));
}
var yc = typeof document < "u";
function Vre(e) {
  var {
    url: t,
    id: n,
    nonce: r
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } = e;
  return yc ? new Promise(function(o, i) {
    var a = document.getElementById(n), s = window;
    if (a) {
      var l = a.getAttribute("data-state");
      if (a.src === t && l !== "error") {
        if (l === "ready")
          return o(n);
        var u = s.initMap, c = a.onerror;
        s.initMap = function() {
          u && u(), o(n);
        }, a.onerror = function(d) {
          c && c(d), i(d);
        };
        return;
      } else
        a.remove();
    }
    var p = document.createElement("script");
    p.type = "text/javascript", p.src = t, p.id = n, p.async = !0, p.nonce = r || "", p.onerror = function(d) {
      p.setAttribute("data-state", "error"), i(d);
    }, s.initMap = function() {
      p.setAttribute("data-state", "ready"), o(n);
    }, document.head.appendChild(p);
  }).catch((o) => {
    throw console.error("injectScript error: ", o), o;
  }) : Promise.reject(new Error("document is undefined"));
}
function m8(e) {
  var t = e.href;
  return t && (t.indexOf("https://fonts.googleapis.com/css?family=Roboto") === 0 || t.indexOf("https://fonts.googleapis.com/css?family=Google+Sans+Text") === 0) ? !0 : (
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.styleSheet.cssText = "", !0) : (
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.innerHTML = "", !0) : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.innerHTML
      )
    )
  );
}
function Zre() {
  var e = document.getElementsByTagName("head")[0];
  if (e) {
    var t = e.insertBefore.bind(e);
    e.insertBefore = function(r, o) {
      return m8(r) || Reflect.apply(t, e, [r, o]), r;
    };
    var n = e.appendChild.bind(e);
    e.appendChild = function(r) {
      return m8(r) || Reflect.apply(n, e, [r]), r;
    };
  }
}
var Td = !1;
function qre() {
  return Yo.jsx("div", {
    children: "Loading..."
  });
}
var mP = {
  id: "script-loader",
  version: "weekly"
};
class S8e extends pe {
  constructor() {
    super(...arguments), De(this, "check", null), De(this, "state", {
      loaded: !1
    }), De(this, "cleanupCallback", () => {
      delete window.google.maps, this.injectScript();
    }), De(this, "isCleaningUp", /* @__PURE__ */ Wre(function* () {
      function t(n) {
        if (!Td)
          n();
        else if (yc)
          var r = window.setInterval(function() {
            Td || (window.clearInterval(r), n());
          }, 1);
      }
      return new Promise(t);
    })), De(this, "cleanup", () => {
      Td = !0;
      var t = document.getElementById(this.props.id);
      t && t.parentNode && t.parentNode.removeChild(t), Array.prototype.slice.call(document.getElementsByTagName("script")).filter(function(n) {
        return typeof n.src == "string" && n.src.includes("maps.googleapis");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("link")).filter(function(n) {
        return n.href === "https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Google+Sans";
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("style")).filter(function(n) {
        return n.innerText !== void 0 && n.innerText.length > 0 && n.innerText.includes(".gm-");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      });
    }), De(this, "injectScript", () => {
      this.props.preventGoogleFontsLoading && Zre(), Zo(!!this.props.id, 'LoadScript requires "id" prop to be a string: %s', this.props.id);
      var t = {
        id: this.props.id,
        nonce: this.props.nonce,
        url: $re(this.props)
      };
      Vre(t).then(() => {
        this.props.onLoad && this.props.onLoad(), this.setState(function() {
          return {
            loaded: !0
          };
        });
      }).catch((n) => {
        this.props.onError && this.props.onError(n), console.error(`
          There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(this.props.googleMapsApiKey || "-", ") or Client ID (").concat(this.props.googleMapsClientId || "-", `) to <LoadScript />
          Otherwise it is a Network issue.
        `));
      });
    }), De(this, "getRef", (t) => {
      this.check = t;
    });
  }
  componentDidMount() {
    if (yc) {
      if (window.google && window.google.maps && !Td) {
        console.error("google api is already presented");
        return;
      }
      this.isCleaningUp().then(this.injectScript).catch(function(t) {
        console.error("Error at injecting script after cleaning up: ", t);
      });
    }
  }
  componentDidUpdate(t) {
    this.props.libraries !== t.libraries && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), yc && t.language !== this.props.language && (this.cleanup(), this.setState(function() {
      return {
        loaded: !1
      };
    }, this.cleanupCallback));
  }
  componentWillUnmount() {
    if (yc) {
      this.cleanup();
      var t = () => {
        this.check || (delete window.google, Td = !1);
      };
      window.setTimeout(t, 1), this.props.onUnmount && this.props.onUnmount();
    }
  }
  render() {
    return Yo.jsxs(Yo.Fragment, {
      children: [Yo.jsx("div", {
        ref: this.getRef
      }), this.state.loaded ? this.props.children : this.props.loadingElement || Yo.jsx(qre, {})]
    });
  }
}
De(S8e, "defaultProps", mP);
function M8e(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.includes(r)) continue;
    n[r] = e[r];
  }
  return n;
}
function qT(e, t) {
  if (e == null) return {};
  var n, r, o = M8e(e, t);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (r = 0; r < i.length; r++) n = i[r], t.includes(n) || {}.propertyIsEnumerable.call(e, n) && (o[n] = e[n]);
  }
  return o;
}
var v8;
function D8e(e) {
  var {
    id: t = mP.id,
    version: n = mP.version,
    nonce: r,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    preventGoogleFontsLoading: u,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  } = e, g = dt(!1), [f, m] = k(!1), [b, E] = k(void 0);
  h(function() {
    return g.current = !0, () => {
      g.current = !1;
    };
  }, []), h(function() {
    yc && u && Zre();
  }, [u]), h(function() {
    f && Zo(!!window.google, "useLoadScript was marked as loaded, but window.google is not present. Something went wrong.");
  }, [f]);
  var w = $re({
    version: n,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  });
  h(function() {
    if (!yc)
      return;
    function x() {
      g.current && (m(!0), v8 = w);
    }
    if (window.google && window.google.maps && v8 === w) {
      x();
      return;
    }
    Vre({
      id: t,
      url: w,
      nonce: r
    }).then(x).catch(function(v) {
      g.current && E(v), console.warn(`
        There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(o || "-", ") or Client ID (").concat(i || "-", `)
        Otherwise it is a Network issue.
      `)), console.error(v);
    });
  }, [t, w, r]);
  var M = dt(void 0);
  return h(function() {
    M.current && l !== M.current && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), M.current = l;
  }, [l]), {
    isLoaded: f,
    loadError: b,
    url: w
  };
}
var T8e = ["loadingElement", "onLoad", "onError", "onUnmount", "children"], j8e = Yo.jsx(qre, {});
function A8e(e) {
  var {
    loadingElement: t,
    onLoad: n,
    onError: r,
    onUnmount: o,
    children: i
  } = e, a = qT(e, T8e), {
    isLoaded: s,
    loadError: l
  } = D8e(a);
  return h(function() {
    s && typeof n == "function" && n();
  }, [s, n]), h(function() {
    l && typeof r == "function" && r(l);
  }, [l, r]), h(function() {
    return () => {
      o && o();
    };
  }, [o]), s ? i : t || j8e;
}
me(A8e);
var y8;
(function(e) {
  e[e.INITIALIZED = 0] = "INITIALIZED", e[e.LOADING = 1] = "LOADING", e[e.SUCCESS = 2] = "SUCCESS", e[e.FAILURE = 3] = "FAILURE";
})(y8 || (y8 = {}));
function b8(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Mw(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? b8(Object(n), !0).forEach(function(r) {
      De(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : b8(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var w8 = {}, C8 = {
  options(e, t) {
    e.setOptions(t);
  }
};
function R8e(e) {
  var {
    options: t,
    onLoad: n,
    onUnmount: r
  } = e, o = ge(zt), [i, a] = k(null);
  return h(() => {
    i !== null && i.setMap(o);
  }, [o]), h(() => {
    t && i !== null && i.setOptions(t);
  }, [i, t]), h(() => {
    var s = new google.maps.TrafficLayer(Mw(Mw({}, t), {}, {
      map: o
    }));
    return a(s), n && n(s), () => {
      i !== null && (r && r(i), i.setMap(null));
    };
  }, []), null;
}
me(R8e);
class I8e extends pe {
  constructor() {
    super(...arguments), De(this, "state", {
      trafficLayer: null
    }), De(this, "setTrafficLayerCallback", () => {
      this.state.trafficLayer !== null && this.props.onLoad && this.props.onLoad(this.state.trafficLayer);
    }), De(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = new google.maps.TrafficLayer(Mw(Mw({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = On({
      updaterMap: C8,
      eventMap: w8,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        trafficLayer: t
      };
    }, this.setTrafficLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.trafficLayer !== null && (Sn(this.registeredEvents), this.registeredEvents = On({
      updaterMap: C8,
      eventMap: w8,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.trafficLayer
    }));
  }
  componentWillUnmount() {
    this.state.trafficLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.trafficLayer), Sn(this.registeredEvents), this.state.trafficLayer.setMap(null));
  }
  render() {
    return null;
  }
}
De(I8e, "contextType", zt);
function N8e(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = ge(zt), [o, i] = k(null);
  return h(() => {
    o !== null && o.setMap(r);
  }, [r]), h(() => {
    var a = new google.maps.BicyclingLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      a !== null && (n && n(a), a.setMap(null));
    };
  }, []), null;
}
me(N8e);
class B8e extends pe {
  constructor() {
    super(...arguments), De(this, "state", {
      bicyclingLayer: null
    }), De(this, "setBicyclingLayerCallback", () => {
      this.state.bicyclingLayer !== null && (this.state.bicyclingLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.bicyclingLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.BicyclingLayer();
    this.setState(() => ({
      bicyclingLayer: t
    }), this.setBicyclingLayerCallback);
  }
  componentWillUnmount() {
    this.state.bicyclingLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.bicyclingLayer), this.state.bicyclingLayer.setMap(null));
  }
  render() {
    return null;
  }
}
De(B8e, "contextType", zt);
function F8e(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = ge(zt), [o, i] = k(null);
  return h(() => {
    o !== null && o.setMap(r);
  }, [r]), h(() => {
    var a = new google.maps.TransitLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      o !== null && (n && n(o), o.setMap(null));
    };
  }, []), null;
}
me(F8e);
class z8e extends pe {
  constructor() {
    super(...arguments), De(this, "state", {
      transitLayer: null
    }), De(this, "setTransitLayerCallback", () => {
      this.state.transitLayer !== null && (this.state.transitLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.transitLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.TransitLayer();
    this.setState(function() {
      return {
        transitLayer: t
      };
    }, this.setTransitLayerCallback);
  }
  componentWillUnmount() {
    this.state.transitLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.transitLayer), this.state.transitLayer.setMap(null));
  }
  render() {
    return null;
  }
}
De(z8e, "contextType", zt);
function O8(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Dw(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? O8(Object(n), !0).forEach(function(r) {
      De(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : O8(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var x8 = {
  onCircleComplete: "circlecomplete",
  onMarkerComplete: "markercomplete",
  onOverlayComplete: "overlaycomplete",
  onPolygonComplete: "polygoncomplete",
  onPolylineComplete: "polylinecomplete",
  onRectangleComplete: "rectanglecomplete"
}, E8 = {
  drawingMode(e, t) {
    e.setDrawingMode(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function U8e(e) {
  var {
    options: t,
    drawingMode: n,
    onCircleComplete: r,
    onMarkerComplete: o,
    onOverlayComplete: i,
    onPolygonComplete: a,
    onPolylineComplete: s,
    onRectangleComplete: l,
    onLoad: u,
    onUnmount: c
  } = e, p = ge(zt), [d, g] = k(null), [f, m] = k(null), [b, E] = k(null), [w, M] = k(null), [x, v] = k(null), [C, P] = k(null), [F, L] = k(null);
  return h(() => {
    d !== null && d.setMap(p);
  }, [p]), h(() => {
    t && d !== null && d.setOptions(t);
  }, [d, t]), h(() => {
    d !== null && d.setDrawingMode(n ?? null);
  }, [d, n]), h(() => {
    d && r && (f !== null && google.maps.event.removeListener(f), m(google.maps.event.addListener(d, "circlecomplete", r)));
  }, [d, r]), h(() => {
    d && o && (b !== null && google.maps.event.removeListener(b), E(google.maps.event.addListener(d, "markercomplete", o)));
  }, [d, o]), h(() => {
    d && i && (w !== null && google.maps.event.removeListener(w), M(google.maps.event.addListener(d, "overlaycomplete", i)));
  }, [d, i]), h(() => {
    d && a && (x !== null && google.maps.event.removeListener(x), v(google.maps.event.addListener(d, "polygoncomplete", a)));
  }, [d, a]), h(() => {
    d && s && (C !== null && google.maps.event.removeListener(C), P(google.maps.event.addListener(d, "polylinecomplete", s)));
  }, [d, s]), h(() => {
    d && l && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(d, "rectanglecomplete", l)));
  }, [d, l]), h(() => {
    Zo(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
    var B = new google.maps.drawing.DrawingManager(Dw(Dw({}, t), {}, {
      map: p
    }));
    return n && B.setDrawingMode(n), r && m(google.maps.event.addListener(B, "circlecomplete", r)), o && E(google.maps.event.addListener(B, "markercomplete", o)), i && M(google.maps.event.addListener(B, "overlaycomplete", i)), a && v(google.maps.event.addListener(B, "polygoncomplete", a)), s && P(google.maps.event.addListener(B, "polylinecomplete", s)), l && L(google.maps.event.addListener(B, "rectanglecomplete", l)), g(B), u && u(B), () => {
      d !== null && (f && google.maps.event.removeListener(f), b && google.maps.event.removeListener(b), w && google.maps.event.removeListener(w), x && google.maps.event.removeListener(x), C && google.maps.event.removeListener(C), F && google.maps.event.removeListener(F), c && c(d), d.setMap(null));
    };
  }, []), null;
}
me(U8e);
class H8e extends pe {
  constructor(t) {
    super(t), De(this, "registeredEvents", []), De(this, "state", {
      drawingManager: null
    }), De(this, "setDrawingManagerCallback", () => {
      this.state.drawingManager !== null && this.props.onLoad && this.props.onLoad(this.state.drawingManager);
    }), Zo(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
  }
  componentDidMount() {
    var t = new google.maps.drawing.DrawingManager(Dw(Dw({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = On({
      updaterMap: E8,
      eventMap: x8,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        drawingManager: t
      };
    }, this.setDrawingManagerCallback);
  }
  componentDidUpdate(t) {
    this.state.drawingManager !== null && (Sn(this.registeredEvents), this.registeredEvents = On({
      updaterMap: E8,
      eventMap: x8,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.drawingManager
    }));
  }
  componentWillUnmount() {
    this.state.drawingManager !== null && (this.props.onUnmount && this.props.onUnmount(this.state.drawingManager), Sn(this.registeredEvents), this.state.drawingManager.setMap(null));
  }
  render() {
    return null;
  }
}
De(H8e, "contextType", zt);
function k8(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function gp(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? k8(Object(n), !0).forEach(function(r) {
      De(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : k8(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var L8 = {
  onAnimationChanged: "animation_changed",
  onClick: "click",
  onClickableChanged: "clickable_changed",
  onCursorChanged: "cursor_changed",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDraggableChanged: "draggable_changed",
  onDragStart: "dragstart",
  onFlatChanged: "flat_changed",
  onIconChanged: "icon_changed",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onPositionChanged: "position_changed",
  onRightClick: "rightclick",
  onShapeChanged: "shape_changed",
  onTitleChanged: "title_changed",
  onVisibleChanged: "visible_changed",
  onZindexChanged: "zindex_changed"
}, _8 = {
  animation(e, t) {
    e.setAnimation(t);
  },
  clickable(e, t) {
    e.setClickable(t);
  },
  cursor(e, t) {
    e.setCursor(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  icon(e, t) {
    e.setIcon(t);
  },
  label(e, t) {
    e.setLabel(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  opacity(e, t) {
    e.setOpacity(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  shape(e, t) {
    e.setShape(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, Tw = {};
function W8e(e) {
  var {
    position: t,
    options: n,
    clusterer: r,
    noClustererRedraw: o,
    children: i,
    draggable: a,
    visible: s,
    animation: l,
    clickable: u,
    cursor: c,
    icon: p,
    label: d,
    opacity: g,
    shape: f,
    title: m,
    zIndex: b,
    onClick: E,
    onDblClick: w,
    onDrag: M,
    onDragEnd: x,
    onDragStart: v,
    onMouseOut: C,
    onMouseOver: P,
    onMouseUp: F,
    onMouseDown: L,
    onRightClick: B,
    onClickableChanged: N,
    onCursorChanged: $,
    onAnimationChanged: V,
    onDraggableChanged: H,
    onFlatChanged: Z,
    onIconChanged: K,
    onPositionChanged: Y,
    onShapeChanged: Q,
    onTitleChanged: J,
    onVisibleChanged: _,
    onZindexChanged: D,
    onLoad: z,
    onUnmount: S
  } = e, W = ge(zt), [O, j] = k(null), [U, T] = k(null), [q, A] = k(null), [X, I] = k(null), [le, he] = k(null), [oe, Ae] = k(null), [Ue, He] = k(null), [Re, nt] = k(null), [Ve, we] = k(null), [et, lt] = k(null), [ye, ke] = k(null), [Qe, Fe] = k(null), [Ie, ot] = k(null), [Ee, wt] = k(null), [it, st] = k(null), [ut, Ct] = k(null), [ct, pt] = k(null), [rt, We] = k(null), [Ot, xt] = k(null), [gt, Ht] = k(null), [mt, Wt] = k(null), [vt, kt] = k(null);
  h(() => {
    O !== null && O.setMap(W);
  }, [W]), h(() => {
    typeof n < "u" && O !== null && O.setOptions(n);
  }, [O, n]), h(() => {
    typeof a < "u" && O !== null && O.setDraggable(a);
  }, [O, a]), h(() => {
    t && O !== null && O.setPosition(t);
  }, [O, t]), h(() => {
    typeof s < "u" && O !== null && O.setVisible(s);
  }, [O, s]), h(() => {
    O == null || O.setAnimation(l);
  }, [O, l]), h(() => {
    O && u !== void 0 && O.setClickable(u);
  }, [O, u]), h(() => {
    O && c !== void 0 && O.setCursor(c);
  }, [O, c]), h(() => {
    O && p !== void 0 && O.setIcon(p);
  }, [O, p]), h(() => {
    O && d !== void 0 && O.setLabel(d);
  }, [O, d]), h(() => {
    O && g !== void 0 && O.setOpacity(g);
  }, [O, g]), h(() => {
    O && f !== void 0 && O.setShape(f);
  }, [O, f]), h(() => {
    O && m !== void 0 && O.setTitle(m);
  }, [O, m]), h(() => {
    O && b !== void 0 && O.setZIndex(b);
  }, [O, b]), h(() => {
    O && w && (U !== null && google.maps.event.removeListener(U), T(google.maps.event.addListener(O, "dblclick", w)));
  }, [w]), h(() => {
    O && x && (q !== null && google.maps.event.removeListener(q), A(google.maps.event.addListener(O, "dragend", x)));
  }, [x]), h(() => {
    O && v && (X !== null && google.maps.event.removeListener(X), I(google.maps.event.addListener(O, "dragstart", v)));
  }, [v]), h(() => {
    O && L && (le !== null && google.maps.event.removeListener(le), he(google.maps.event.addListener(O, "mousedown", L)));
  }, [L]), h(() => {
    O && C && (oe !== null && google.maps.event.removeListener(oe), Ae(google.maps.event.addListener(O, "mouseout", C)));
  }, [C]), h(() => {
    O && P && (Ue !== null && google.maps.event.removeListener(Ue), He(google.maps.event.addListener(O, "mouseover", P)));
  }, [P]), h(() => {
    O && F && (Re !== null && google.maps.event.removeListener(Re), nt(google.maps.event.addListener(O, "mouseup", F)));
  }, [F]), h(() => {
    O && B && (Ve !== null && google.maps.event.removeListener(Ve), we(google.maps.event.addListener(O, "rightclick", B)));
  }, [B]), h(() => {
    O && E && (et !== null && google.maps.event.removeListener(et), lt(google.maps.event.addListener(O, "click", E)));
  }, [E]), h(() => {
    O && M && (ye !== null && google.maps.event.removeListener(ye), ke(google.maps.event.addListener(O, "drag", M)));
  }, [M]), h(() => {
    O && N && (Qe !== null && google.maps.event.removeListener(Qe), Fe(google.maps.event.addListener(O, "clickable_changed", N)));
  }, [N]), h(() => {
    O && $ && (Ie !== null && google.maps.event.removeListener(Ie), ot(google.maps.event.addListener(O, "cursor_changed", $)));
  }, [$]), h(() => {
    O && V && (Ee !== null && google.maps.event.removeListener(Ee), wt(google.maps.event.addListener(O, "animation_changed", V)));
  }, [V]), h(() => {
    O && H && (it !== null && google.maps.event.removeListener(it), st(google.maps.event.addListener(O, "draggable_changed", H)));
  }, [H]), h(() => {
    O && Z && (ut !== null && google.maps.event.removeListener(ut), Ct(google.maps.event.addListener(O, "flat_changed", Z)));
  }, [Z]), h(() => {
    O && K && (ct !== null && google.maps.event.removeListener(ct), pt(google.maps.event.addListener(O, "icon_changed", K)));
  }, [K]), h(() => {
    O && Y && (rt !== null && google.maps.event.removeListener(rt), We(google.maps.event.addListener(O, "position_changed", Y)));
  }, [Y]), h(() => {
    O && Q && (Ot !== null && google.maps.event.removeListener(Ot), xt(google.maps.event.addListener(O, "shape_changed", Q)));
  }, [Q]), h(() => {
    O && J && (gt !== null && google.maps.event.removeListener(gt), Ht(google.maps.event.addListener(O, "title_changed", J)));
  }, [J]), h(() => {
    O && _ && (mt !== null && google.maps.event.removeListener(mt), Wt(google.maps.event.addListener(O, "visible_changed", _)));
  }, [_]), h(() => {
    O && D && (vt !== null && google.maps.event.removeListener(vt), kt(google.maps.event.addListener(O, "zindex_changed", D)));
  }, [D]), h(() => {
    var yt = gp(gp(gp({}, n || Tw), r ? Tw : {
      map: W
    }), {}, {
      position: t
    }), re = new google.maps.Marker(yt);
    return r ? r.addMarker(re, !!o) : re.setMap(W), t && re.setPosition(t), typeof s < "u" && re.setVisible(s), typeof a < "u" && re.setDraggable(a), typeof u < "u" && re.setClickable(u), typeof c == "string" && re.setCursor(c), p && re.setIcon(p), typeof d < "u" && re.setLabel(d), typeof g < "u" && re.setOpacity(g), f && re.setShape(f), typeof m == "string" && re.setTitle(m), typeof b == "number" && re.setZIndex(b), w && T(google.maps.event.addListener(re, "dblclick", w)), x && A(google.maps.event.addListener(re, "dragend", x)), v && I(google.maps.event.addListener(re, "dragstart", v)), L && he(google.maps.event.addListener(re, "mousedown", L)), C && Ae(google.maps.event.addListener(re, "mouseout", C)), P && He(google.maps.event.addListener(re, "mouseover", P)), F && nt(google.maps.event.addListener(re, "mouseup", F)), B && we(google.maps.event.addListener(re, "rightclick", B)), E && lt(google.maps.event.addListener(re, "click", E)), M && ke(google.maps.event.addListener(re, "drag", M)), N && Fe(google.maps.event.addListener(re, "clickable_changed", N)), $ && ot(google.maps.event.addListener(re, "cursor_changed", $)), V && wt(google.maps.event.addListener(re, "animation_changed", V)), H && st(google.maps.event.addListener(re, "draggable_changed", H)), Z && Ct(google.maps.event.addListener(re, "flat_changed", Z)), K && pt(google.maps.event.addListener(re, "icon_changed", K)), Y && We(google.maps.event.addListener(re, "position_changed", Y)), Q && xt(google.maps.event.addListener(re, "shape_changed", Q)), J && Ht(google.maps.event.addListener(re, "title_changed", J)), _ && Wt(google.maps.event.addListener(re, "visible_changed", _)), D && kt(google.maps.event.addListener(re, "zindex_changed", D)), j(re), z && z(re), () => {
      U !== null && google.maps.event.removeListener(U), q !== null && google.maps.event.removeListener(q), X !== null && google.maps.event.removeListener(X), le !== null && google.maps.event.removeListener(le), oe !== null && google.maps.event.removeListener(oe), Ue !== null && google.maps.event.removeListener(Ue), Re !== null && google.maps.event.removeListener(Re), Ve !== null && google.maps.event.removeListener(Ve), et !== null && google.maps.event.removeListener(et), Qe !== null && google.maps.event.removeListener(Qe), Ie !== null && google.maps.event.removeListener(Ie), Ee !== null && google.maps.event.removeListener(Ee), it !== null && google.maps.event.removeListener(it), ut !== null && google.maps.event.removeListener(ut), ct !== null && google.maps.event.removeListener(ct), rt !== null && google.maps.event.removeListener(rt), gt !== null && google.maps.event.removeListener(gt), mt !== null && google.maps.event.removeListener(mt), vt !== null && google.maps.event.removeListener(vt), S && S(re), r ? r.removeMarker(re, !!o) : re && re.setMap(null);
    };
  }, []);
  var Un = ln(() => i ? at.map(i, (yt) => {
    if (!yi(yt))
      return yt;
    var re = yt;
    return bi(re, {
      anchor: O
    });
  }) : null, [i, O]);
  return Yo.jsx(Yo.Fragment, {
    children: Un
  }) || null;
}
me(W8e);
class $8e extends pe {
  constructor() {
    super(...arguments), De(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this;
    return Wre(function* () {
      var n = gp(gp(gp({}, t.props.options || Tw), t.props.clusterer ? Tw : {
        map: t.context
      }), {}, {
        position: t.props.position
      });
      t.marker = new google.maps.Marker(n), t.props.clusterer ? t.props.clusterer.addMarker(t.marker, !!t.props.noClustererRedraw) : t.marker.setMap(t.context), t.registeredEvents = On({
        updaterMap: _8,
        eventMap: L8,
        prevProps: {},
        nextProps: t.props,
        instance: t.marker
      }), t.props.onLoad && t.props.onLoad(t.marker);
    })();
  }
  componentDidUpdate(t) {
    this.marker && (Sn(this.registeredEvents), this.registeredEvents = On({
      updaterMap: _8,
      eventMap: L8,
      prevProps: t,
      nextProps: this.props,
      instance: this.marker
    }));
  }
  componentWillUnmount() {
    this.marker && (this.props.onUnmount && this.props.onUnmount(this.marker), Sn(this.registeredEvents), this.props.clusterer ? this.props.clusterer.removeMarker(this.marker, !!this.props.noClustererRedraw) : this.marker && this.marker.setMap(null));
  }
  render() {
    var t = this.props.children ? at.map(this.props.children, (n) => {
      if (!yi(n))
        return n;
      var r = n;
      return bi(r, {
        anchor: this.marker
      });
    }) : null;
    return t || null;
  }
}
De($8e, "contextType", zt);
var V8e = (
  /** @class */
  function() {
    function e(t, n) {
      t.getClusterer().extend(e, google.maps.OverlayView), this.cluster = t, this.clusterClassName = this.cluster.getClusterer().getClusterClass(), this.className = this.clusterClassName, this.styles = n, this.center = void 0, this.div = null, this.sums = null, this.visible = !1, this.boundsChangedListener = null, this.url = "", this.height = 0, this.width = 0, this.anchorText = [0, 0], this.anchorIcon = [0, 0], this.textColor = "black", this.textSize = 11, this.textDecoration = "none", this.fontWeight = "bold", this.fontStyle = "normal", this.fontFamily = "Arial,sans-serif", this.backgroundPosition = "0 0", this.cMouseDownInCluster = null, this.cDraggingMapByCluster = null, this.timeOut = null, this.setMap(t.getMap()), this.onBoundsChanged = this.onBoundsChanged.bind(this), this.onMouseDown = this.onMouseDown.bind(this), this.onClick = this.onClick.bind(this), this.onMouseOver = this.onMouseOver.bind(this), this.onMouseOut = this.onMouseOut.bind(this), this.onAdd = this.onAdd.bind(this), this.onRemove = this.onRemove.bind(this), this.draw = this.draw.bind(this), this.hide = this.hide.bind(this), this.show = this.show.bind(this), this.useStyle = this.useStyle.bind(this), this.setCenter = this.setCenter.bind(this), this.getPosFromLatLng = this.getPosFromLatLng.bind(this);
    }
    return e.prototype.onBoundsChanged = function() {
      this.cDraggingMapByCluster = this.cMouseDownInCluster;
    }, e.prototype.onMouseDown = function() {
      this.cMouseDownInCluster = !0, this.cDraggingMapByCluster = !1;
    }, e.prototype.onClick = function(t) {
      if (this.cMouseDownInCluster = !1, !this.cDraggingMapByCluster) {
        var n = this.cluster.getClusterer();
        if (google.maps.event.trigger(n, "click", this.cluster), google.maps.event.trigger(n, "clusterclick", this.cluster), n.getZoomOnClick()) {
          var r = n.getMaxZoom(), o = this.cluster.getBounds(), i = n.getMap();
          i !== null && "fitBounds" in i && i.fitBounds(o), this.timeOut = window.setTimeout(function() {
            var a = n.getMap();
            if (a !== null) {
              "fitBounds" in a && a.fitBounds(o);
              var s = a.getZoom() || 0;
              r !== null && s > r && a.setZoom(r + 1);
            }
          }, 100);
        }
        t.cancelBubble = !0, t.stopPropagation && t.stopPropagation();
      }
    }, e.prototype.onMouseOver = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseover", this.cluster);
    }, e.prototype.onMouseOut = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseout", this.cluster);
    }, e.prototype.onAdd = function() {
      var t;
      this.div = document.createElement("div"), this.div.className = this.className, this.visible && this.show(), (t = this.getPanes()) === null || t === void 0 || t.overlayMouseTarget.appendChild(this.div);
      var n = this.getMap();
      n !== null && (this.boundsChangedListener = google.maps.event.addListener(n, "bounds_changed", this.onBoundsChanged), this.div.addEventListener("mousedown", this.onMouseDown), this.div.addEventListener("click", this.onClick), this.div.addEventListener("mouseover", this.onMouseOver), this.div.addEventListener("mouseout", this.onMouseOut));
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.hide(), this.boundsChangedListener !== null && google.maps.event.removeListener(this.boundsChangedListener), this.div.removeEventListener("mousedown", this.onMouseDown), this.div.removeEventListener("click", this.onClick), this.div.removeEventListener("mouseover", this.onMouseOver), this.div.removeEventListener("mouseout", this.onMouseOut), this.div.parentNode.removeChild(this.div), this.timeOut !== null && (window.clearTimeout(this.timeOut), this.timeOut = null), this.div = null);
    }, e.prototype.draw = function() {
      if (this.visible && this.div !== null && this.center) {
        var t = this.getPosFromLatLng(this.center);
        this.div.style.top = t !== null ? "".concat(t.y, "px") : "0", this.div.style.left = t !== null ? "".concat(t.x, "px") : "0";
      }
    }, e.prototype.hide = function() {
      this.div && (this.div.style.display = "none"), this.visible = !1;
    }, e.prototype.show = function() {
      var t, n, r, o, i, a;
      if (this.div && this.center) {
        var s = this.sums === null || typeof this.sums.title > "u" || this.sums.title === "" ? this.cluster.getClusterer().getTitle() : this.sums.title, l = this.backgroundPosition.split(" "), u = parseInt(((t = l[0]) === null || t === void 0 ? void 0 : t.replace(/^\s+|\s+$/g, "")) || "0", 10), c = parseInt(((n = l[1]) === null || n === void 0 ? void 0 : n.replace(/^\s+|\s+$/g, "")) || "0", 10), p = this.getPosFromLatLng(this.center);
        this.div.className = this.className, this.div.setAttribute("style", "cursor: pointer; position: absolute; top: ".concat(p !== null ? "".concat(p.y, "px") : "0", "; left: ").concat(p !== null ? "".concat(p.x, "px") : "0", "; width: ").concat(this.width, "px; height: ").concat(this.height, "px; "));
        var d = document.createElement("img");
        d.alt = s, d.src = this.url, d.width = this.width, d.height = this.height, d.setAttribute("style", "position: absolute; top: ".concat(c, "px; left: ").concat(u, "px")), this.cluster.getClusterer().enableRetinaIcons || (d.style.clip = "rect(-".concat(c, "px, -").concat(u + this.width, "px, -").concat(c + this.height, ", -").concat(u, ")"));
        var g = document.createElement("div");
        g.setAttribute("style", "position: absolute; top: ".concat(this.anchorText[0], "px; left: ").concat(this.anchorText[1], "px; color: ").concat(this.textColor, "; font-size: ").concat(this.textSize, "px; font-family: ").concat(this.fontFamily, "; font-weight: ").concat(this.fontWeight, "; fontStyle: ").concat(this.fontStyle, "; text-decoration: ").concat(this.textDecoration, "; text-align: center; width: ").concat(this.width, "px; line-height: ").concat(this.height, "px")), !((r = this.sums) === null || r === void 0) && r.text && (g.innerText = "".concat((o = this.sums) === null || o === void 0 ? void 0 : o.text)), !((i = this.sums) === null || i === void 0) && i.html && (g.innerHTML = "".concat((a = this.sums) === null || a === void 0 ? void 0 : a.html)), this.div.innerHTML = "", this.div.appendChild(d), this.div.appendChild(g), this.div.title = s, this.div.style.display = "";
      }
      this.visible = !0;
    }, e.prototype.useStyle = function(t) {
      this.sums = t;
      var n = this.cluster.getClusterer().getStyles(), r = n[Math.min(n.length - 1, Math.max(0, t.index - 1))];
      r && (this.url = r.url, this.height = r.height, this.width = r.width, r.className && (this.className = "".concat(this.clusterClassName, " ").concat(r.className)), this.anchorText = r.anchorText || [0, 0], this.anchorIcon = r.anchorIcon || [this.height / 2, this.width / 2], this.textColor = r.textColor || "black", this.textSize = r.textSize || 11, this.textDecoration = r.textDecoration || "none", this.fontWeight = r.fontWeight || "bold", this.fontStyle = r.fontStyle || "normal", this.fontFamily = r.fontFamily || "Arial,sans-serif", this.backgroundPosition = r.backgroundPosition || "0 0");
    }, e.prototype.setCenter = function(t) {
      this.center = t;
    }, e.prototype.getPosFromLatLng = function(t) {
      var n = this.getProjection().fromLatLngToDivPixel(t);
      return n !== null && (n.x -= this.anchorIcon[1], n.y -= this.anchorIcon[0]), n;
    }, e;
  }()
), Z8e = (
  /** @class */
  function() {
    function e(t) {
      this.markerClusterer = t, this.map = this.markerClusterer.getMap(), this.gridSize = this.markerClusterer.getGridSize(), this.minClusterSize = this.markerClusterer.getMinimumClusterSize(), this.averageCenter = this.markerClusterer.getAverageCenter(), this.markers = [], this.center = void 0, this.bounds = null, this.clusterIcon = new V8e(this, this.markerClusterer.getStyles()), this.getSize = this.getSize.bind(this), this.getMarkers = this.getMarkers.bind(this), this.getCenter = this.getCenter.bind(this), this.getMap = this.getMap.bind(this), this.getClusterer = this.getClusterer.bind(this), this.getBounds = this.getBounds.bind(this), this.remove = this.remove.bind(this), this.addMarker = this.addMarker.bind(this), this.isMarkerInClusterBounds = this.isMarkerInClusterBounds.bind(this), this.calculateBounds = this.calculateBounds.bind(this), this.updateIcon = this.updateIcon.bind(this), this.isMarkerAlreadyAdded = this.isMarkerAlreadyAdded.bind(this);
    }
    return e.prototype.getSize = function() {
      return this.markers.length;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getCenter = function() {
      return this.center;
    }, e.prototype.getMap = function() {
      return this.map;
    }, e.prototype.getClusterer = function() {
      return this.markerClusterer;
    }, e.prototype.getBounds = function() {
      for (var t = new google.maps.LatLngBounds(this.center, this.center), n = this.getMarkers(), r = 0, o = n; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && t.extend(a);
      }
      return t;
    }, e.prototype.remove = function() {
      this.clusterIcon.setMap(null), this.markers = [], delete this.markers;
    }, e.prototype.addMarker = function(t) {
      var n;
      if (this.isMarkerAlreadyAdded(t))
        return !1;
      if (this.center) {
        if (this.averageCenter) {
          var r = t.getPosition();
          if (r) {
            var o = this.markers.length + 1;
            this.center = new google.maps.LatLng((this.center.lat() * (o - 1) + r.lat()) / o, (this.center.lng() * (o - 1) + r.lng()) / o), this.calculateBounds();
          }
        }
      } else {
        var r = t.getPosition();
        r && (this.center = r, this.calculateBounds());
      }
      t.isAdded = !0, this.markers.push(t);
      var i = this.markers.length, a = this.markerClusterer.getMaxZoom(), s = (n = this.map) === null || n === void 0 ? void 0 : n.getZoom();
      if (a !== null && typeof s < "u" && s > a)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i < this.minClusterSize)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i === this.minClusterSize)
        for (var l = 0, u = this.markers; l < u.length; l++) {
          var c = u[l];
          c.setMap(null);
        }
      else
        t.setMap(null);
      return !0;
    }, e.prototype.isMarkerInClusterBounds = function(t) {
      if (this.bounds !== null) {
        var n = t.getPosition();
        if (n)
          return this.bounds.contains(n);
      }
      return !1;
    }, e.prototype.calculateBounds = function() {
      this.bounds = this.markerClusterer.getExtendedBounds(new google.maps.LatLngBounds(this.center, this.center));
    }, e.prototype.updateIcon = function() {
      var t, n = this.markers.length, r = this.markerClusterer.getMaxZoom(), o = (t = this.map) === null || t === void 0 ? void 0 : t.getZoom();
      if (r !== null && typeof o < "u" && o > r) {
        this.clusterIcon.hide();
        return;
      }
      if (n < this.minClusterSize) {
        this.clusterIcon.hide();
        return;
      }
      this.center && this.clusterIcon.setCenter(this.center), this.clusterIcon.useStyle(this.markerClusterer.getCalculator()(this.markers, this.markerClusterer.getStyles().length)), this.clusterIcon.show();
    }, e.prototype.isMarkerAlreadyAdded = function(t) {
      if (this.markers.includes)
        return this.markers.includes(t);
      for (var n = 0; n < this.markers.length; n++)
        if (t === this.markers[n])
          return !0;
      return !1;
    }, e;
  }()
);
function q8e(e, t) {
  var n = e.length, r = n.toString().length, o = Math.min(r, t);
  return {
    text: n.toString(),
    index: o,
    title: ""
  };
}
var G8e = 2e3, K8e = 500, X8e = "https://developers.google.com/maps/documentation/javascript/examples/markerclusterer/m", Y8e = "png", J8e = [53, 56, 66, 78, 90], Q8e = "cluster", Gre = (
  /** @class */
  function() {
    function e(t, n, r) {
      n === void 0 && (n = []), r === void 0 && (r = {}), this.getMinimumClusterSize = this.getMinimumClusterSize.bind(this), this.setMinimumClusterSize = this.setMinimumClusterSize.bind(this), this.getEnableRetinaIcons = this.getEnableRetinaIcons.bind(this), this.setEnableRetinaIcons = this.setEnableRetinaIcons.bind(this), this.addToClosestCluster = this.addToClosestCluster.bind(this), this.getImageExtension = this.getImageExtension.bind(this), this.setImageExtension = this.setImageExtension.bind(this), this.getExtendedBounds = this.getExtendedBounds.bind(this), this.getAverageCenter = this.getAverageCenter.bind(this), this.setAverageCenter = this.setAverageCenter.bind(this), this.getTotalClusters = this.getTotalClusters.bind(this), this.fitMapToMarkers = this.fitMapToMarkers.bind(this), this.getIgnoreHidden = this.getIgnoreHidden.bind(this), this.setIgnoreHidden = this.setIgnoreHidden.bind(this), this.getClusterClass = this.getClusterClass.bind(this), this.setClusterClass = this.setClusterClass.bind(this), this.getTotalMarkers = this.getTotalMarkers.bind(this), this.getZoomOnClick = this.getZoomOnClick.bind(this), this.setZoomOnClick = this.setZoomOnClick.bind(this), this.getBatchSizeIE = this.getBatchSizeIE.bind(this), this.setBatchSizeIE = this.setBatchSizeIE.bind(this), this.createClusters = this.createClusters.bind(this), this.onZoomChanged = this.onZoomChanged.bind(this), this.getImageSizes = this.getImageSizes.bind(this), this.setImageSizes = this.setImageSizes.bind(this), this.getCalculator = this.getCalculator.bind(this), this.setCalculator = this.setCalculator.bind(this), this.removeMarkers = this.removeMarkers.bind(this), this.resetViewport = this.resetViewport.bind(this), this.getImagePath = this.getImagePath.bind(this), this.setImagePath = this.setImagePath.bind(this), this.pushMarkerTo = this.pushMarkerTo.bind(this), this.removeMarker = this.removeMarker.bind(this), this.clearMarkers = this.clearMarkers.bind(this), this.setupStyles = this.setupStyles.bind(this), this.getGridSize = this.getGridSize.bind(this), this.setGridSize = this.setGridSize.bind(this), this.getClusters = this.getClusters.bind(this), this.getMaxZoom = this.getMaxZoom.bind(this), this.setMaxZoom = this.setMaxZoom.bind(this), this.getMarkers = this.getMarkers.bind(this), this.addMarkers = this.addMarkers.bind(this), this.getStyles = this.getStyles.bind(this), this.setStyles = this.setStyles.bind(this), this.addMarker = this.addMarker.bind(this), this.onRemove = this.onRemove.bind(this), this.getTitle = this.getTitle.bind(this), this.setTitle = this.setTitle.bind(this), this.repaint = this.repaint.bind(this), this.onIdle = this.onIdle.bind(this), this.redraw = this.redraw.bind(this), this.onAdd = this.onAdd.bind(this), this.draw = this.draw.bind(this), this.extend = this.extend.bind(this), this.extend(e, google.maps.OverlayView), this.markers = [], this.clusters = [], this.listeners = [], this.activeMap = null, this.ready = !1, this.gridSize = r.gridSize || 60, this.minClusterSize = r.minimumClusterSize || 2, this.maxZoom = r.maxZoom || null, this.styles = r.styles || [], this.title = r.title || "", this.zoomOnClick = !0, r.zoomOnClick !== void 0 && (this.zoomOnClick = r.zoomOnClick), this.averageCenter = !1, r.averageCenter !== void 0 && (this.averageCenter = r.averageCenter), this.ignoreHidden = !1, r.ignoreHidden !== void 0 && (this.ignoreHidden = r.ignoreHidden), this.enableRetinaIcons = !1, r.enableRetinaIcons !== void 0 && (this.enableRetinaIcons = r.enableRetinaIcons), this.imagePath = r.imagePath || X8e, this.imageExtension = r.imageExtension || Y8e, this.imageSizes = r.imageSizes || J8e, this.calculator = r.calculator || q8e, this.batchSize = r.batchSize || G8e, this.batchSizeIE = r.batchSizeIE || K8e, this.clusterClass = r.clusterClass || Q8e, navigator.userAgent.toLowerCase().indexOf("msie") !== -1 && (this.batchSize = this.batchSizeIE), this.timerRefStatic = null, this.setupStyles(), this.addMarkers(n, !0), this.setMap(t);
    }
    return e.prototype.onZoomChanged = function() {
      var t, n;
      this.resetViewport(!1), (((t = this.getMap()) === null || t === void 0 ? void 0 : t.getZoom()) === (this.get("minZoom") || 0) || ((n = this.getMap()) === null || n === void 0 ? void 0 : n.getZoom()) === this.get("maxZoom")) && google.maps.event.trigger(this, "idle");
    }, e.prototype.onIdle = function() {
      this.redraw();
    }, e.prototype.onAdd = function() {
      var t = this.getMap();
      this.activeMap = t, this.ready = !0, this.repaint(), t !== null && (this.listeners = [google.maps.event.addListener(t, "zoom_changed", this.onZoomChanged), google.maps.event.addListener(t, "idle", this.onIdle)]);
    }, e.prototype.onRemove = function() {
      for (var t = 0, n = this.markers; t < n.length; t++) {
        var r = n[t];
        r.getMap() !== this.activeMap && r.setMap(this.activeMap);
      }
      for (var o = 0, i = this.clusters; o < i.length; o++) {
        var a = i[o];
        a.remove();
      }
      this.clusters = [];
      for (var s = 0, l = this.listeners; s < l.length; s++) {
        var u = l[s];
        google.maps.event.removeListener(u);
      }
      this.listeners = [], this.activeMap = null, this.ready = !1;
    }, e.prototype.draw = function() {
    }, e.prototype.getMap = function() {
      return null;
    }, e.prototype.getPanes = function() {
      return null;
    }, e.prototype.getProjection = function() {
      return {
        fromContainerPixelToLatLng: function() {
          return null;
        },
        fromDivPixelToLatLng: function() {
          return null;
        },
        fromLatLngToContainerPixel: function() {
          return null;
        },
        fromLatLngToDivPixel: function() {
          return null;
        },
        getVisibleRegion: function() {
          return null;
        },
        getWorldWidth: function() {
          return 0;
        }
      };
    }, e.prototype.setMap = function() {
    }, e.prototype.addListener = function() {
      return {
        remove: function() {
        }
      };
    }, e.prototype.bindTo = function() {
    }, e.prototype.get = function() {
    }, e.prototype.notify = function() {
    }, e.prototype.set = function() {
    }, e.prototype.setValues = function() {
    }, e.prototype.unbind = function() {
    }, e.prototype.unbindAll = function() {
    }, e.prototype.setupStyles = function() {
      if (!(this.styles.length > 0))
        for (var t = 0; t < this.imageSizes.length; t++)
          this.styles.push({
            url: "".concat(this.imagePath + (t + 1), ".").concat(this.imageExtension),
            height: this.imageSizes[t] || 0,
            width: this.imageSizes[t] || 0
          });
    }, e.prototype.fitMapToMarkers = function() {
      for (var t = this.getMarkers(), n = new google.maps.LatLngBounds(), r = 0, o = t; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && n.extend(a);
      }
      var s = this.getMap();
      s !== null && "fitBounds" in s && s.fitBounds(n);
    }, e.prototype.getGridSize = function() {
      return this.gridSize;
    }, e.prototype.setGridSize = function(t) {
      this.gridSize = t;
    }, e.prototype.getMinimumClusterSize = function() {
      return this.minClusterSize;
    }, e.prototype.setMinimumClusterSize = function(t) {
      this.minClusterSize = t;
    }, e.prototype.getMaxZoom = function() {
      return this.maxZoom;
    }, e.prototype.setMaxZoom = function(t) {
      this.maxZoom = t;
    }, e.prototype.getStyles = function() {
      return this.styles;
    }, e.prototype.setStyles = function(t) {
      this.styles = t;
    }, e.prototype.getTitle = function() {
      return this.title;
    }, e.prototype.setTitle = function(t) {
      this.title = t;
    }, e.prototype.getZoomOnClick = function() {
      return this.zoomOnClick;
    }, e.prototype.setZoomOnClick = function(t) {
      this.zoomOnClick = t;
    }, e.prototype.getAverageCenter = function() {
      return this.averageCenter;
    }, e.prototype.setAverageCenter = function(t) {
      this.averageCenter = t;
    }, e.prototype.getIgnoreHidden = function() {
      return this.ignoreHidden;
    }, e.prototype.setIgnoreHidden = function(t) {
      this.ignoreHidden = t;
    }, e.prototype.getEnableRetinaIcons = function() {
      return this.enableRetinaIcons;
    }, e.prototype.setEnableRetinaIcons = function(t) {
      this.enableRetinaIcons = t;
    }, e.prototype.getImageExtension = function() {
      return this.imageExtension;
    }, e.prototype.setImageExtension = function(t) {
      this.imageExtension = t;
    }, e.prototype.getImagePath = function() {
      return this.imagePath;
    }, e.prototype.setImagePath = function(t) {
      this.imagePath = t;
    }, e.prototype.getImageSizes = function() {
      return this.imageSizes;
    }, e.prototype.setImageSizes = function(t) {
      this.imageSizes = t;
    }, e.prototype.getCalculator = function() {
      return this.calculator;
    }, e.prototype.setCalculator = function(t) {
      this.calculator = t;
    }, e.prototype.getBatchSizeIE = function() {
      return this.batchSizeIE;
    }, e.prototype.setBatchSizeIE = function(t) {
      this.batchSizeIE = t;
    }, e.prototype.getClusterClass = function() {
      return this.clusterClass;
    }, e.prototype.setClusterClass = function(t) {
      this.clusterClass = t;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getTotalMarkers = function() {
      return this.markers.length;
    }, e.prototype.getClusters = function() {
      return this.clusters;
    }, e.prototype.getTotalClusters = function() {
      return this.clusters.length;
    }, e.prototype.addMarker = function(t, n) {
      this.pushMarkerTo(t), n || this.redraw();
    }, e.prototype.addMarkers = function(t, n) {
      for (var r in t)
        if (Object.prototype.hasOwnProperty.call(t, r)) {
          var o = t[r];
          o && this.pushMarkerTo(o);
        }
      n || this.redraw();
    }, e.prototype.pushMarkerTo = function(t) {
      var n = this;
      t.getDraggable() && google.maps.event.addListener(t, "dragend", function() {
        n.ready && (t.isAdded = !1, n.repaint());
      }), t.isAdded = !1, this.markers.push(t);
    }, e.prototype.removeMarker_ = function(t) {
      var n = -1;
      if (this.markers.indexOf)
        n = this.markers.indexOf(t);
      else
        for (var r = 0; r < this.markers.length; r++)
          if (t === this.markers[r]) {
            n = r;
            break;
          }
      return n === -1 ? !1 : (t.setMap(null), this.markers.splice(n, 1), !0);
    }, e.prototype.removeMarker = function(t, n) {
      var r = this.removeMarker_(t);
      return !n && r && this.repaint(), r;
    }, e.prototype.removeMarkers = function(t, n) {
      for (var r = !1, o = 0, i = t; o < i.length; o++) {
        var a = i[o];
        r = r || this.removeMarker_(a);
      }
      return !n && r && this.repaint(), r;
    }, e.prototype.clearMarkers = function() {
      this.resetViewport(!0), this.markers = [];
    }, e.prototype.repaint = function() {
      var t = this.clusters.slice();
      this.clusters = [], this.resetViewport(!1), this.redraw(), setTimeout(function() {
        for (var n = 0, r = t; n < r.length; n++) {
          var o = r[n];
          o.remove();
        }
      }, 0);
    }, e.prototype.getExtendedBounds = function(t) {
      var n = this.getProjection(), r = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getNorthEast().lat(), t.getNorthEast().lng())
      );
      r !== null && (r.x += this.gridSize, r.y -= this.gridSize);
      var o = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getSouthWest().lat(), t.getSouthWest().lng())
      );
      if (o !== null && (o.x -= this.gridSize, o.y += this.gridSize), r !== null) {
        var i = n.fromDivPixelToLatLng(r);
        i !== null && t.extend(i);
      }
      if (o !== null) {
        var a = n.fromDivPixelToLatLng(o);
        a !== null && t.extend(a);
      }
      return t;
    }, e.prototype.redraw = function() {
      this.createClusters(0);
    }, e.prototype.resetViewport = function(t) {
      for (var n = 0, r = this.clusters; n < r.length; n++) {
        var o = r[n];
        o.remove();
      }
      this.clusters = [];
      for (var i = 0, a = this.markers; i < a.length; i++) {
        var s = a[i];
        s.isAdded = !1, t && s.setMap(null);
      }
    }, e.prototype.distanceBetweenPoints = function(t, n) {
      var r = 6371, o = (n.lat() - t.lat()) * Math.PI / 180, i = (n.lng() - t.lng()) * Math.PI / 180, a = Math.sin(o / 2) * Math.sin(o / 2) + Math.cos(t.lat() * Math.PI / 180) * Math.cos(n.lat() * Math.PI / 180) * Math.sin(i / 2) * Math.sin(i / 2);
      return r * (2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)));
    }, e.prototype.isMarkerInBounds = function(t, n) {
      var r = t.getPosition();
      return r ? n.contains(r) : !1;
    }, e.prototype.addToClosestCluster = function(t) {
      for (var n, r = 4e4, o = null, i = 0, a = this.clusters; i < a.length; i++) {
        var s = a[i];
        n = s;
        var l = n.getCenter(), u = t.getPosition();
        if (l && u) {
          var c = this.distanceBetweenPoints(l, u);
          c < r && (r = c, o = n);
        }
      }
      o && o.isMarkerInClusterBounds(t) ? o.addMarker(t) : (n = new Z8e(this), n.addMarker(t), this.clusters.push(n));
    }, e.prototype.createClusters = function(t) {
      var n = this;
      if (this.ready) {
        t === 0 && (google.maps.event.trigger(this, "clusteringbegin", this), this.timerRefStatic !== null && (window.clearTimeout(this.timerRefStatic), delete this.timerRefStatic));
        for (var r = this.getMap(), o = r !== null && ("getBounds" in r) ? r.getBounds() : null, i = (r == null ? void 0 : r.getZoom()) || 0, a = i > 3 ? new google.maps.LatLngBounds(o == null ? void 0 : o.getSouthWest(), o == null ? void 0 : o.getNorthEast()) : new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625)), s = this.getExtendedBounds(a), l = Math.min(t + this.batchSize, this.markers.length), u = t; u < l; u++) {
          var c = this.markers[u];
          c && !c.isAdded && this.isMarkerInBounds(c, s) && (!this.ignoreHidden || this.ignoreHidden && c.getVisible()) && this.addToClosestCluster(c);
        }
        if (l < this.markers.length)
          this.timerRefStatic = window.setTimeout(function() {
            n.createClusters(l);
          }, 0);
        else {
          this.timerRefStatic = null, google.maps.event.trigger(this, "clusteringend", this);
          for (var p = 0, d = this.clusters; p < d.length; p++) {
            var g = d[p];
            g.updateIcon();
          }
        }
      }
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype) {
          var i = o;
          this.prototype[i] = r.prototype[i];
        }
        return this;
      }).apply(t, [n]);
    }, e;
  }()
);
function P8(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function e5e(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? P8(Object(n), !0).forEach(function(r) {
      De(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : P8(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Fs = {
  onClick: "click",
  onClusteringBegin: "clusteringbegin",
  onClusteringEnd: "clusteringend",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover"
}, In = {
  averageCenter(e, t) {
    e.setAverageCenter(t);
  },
  batchSizeIE(e, t) {
    e.setBatchSizeIE(t);
  },
  calculator(e, t) {
    e.setCalculator(t);
  },
  clusterClass(e, t) {
    e.setClusterClass(t);
  },
  enableRetinaIcons(e, t) {
    e.setEnableRetinaIcons(t);
  },
  gridSize(e, t) {
    e.setGridSize(t);
  },
  ignoreHidden(e, t) {
    e.setIgnoreHidden(t);
  },
  imageExtension(e, t) {
    e.setImageExtension(t);
  },
  imagePath(e, t) {
    e.setImagePath(t);
  },
  imageSizes(e, t) {
    e.setImageSizes(t);
  },
  maxZoom(e, t) {
    e.setMaxZoom(t);
  },
  minimumClusterSize(e, t) {
    e.setMinimumClusterSize(t);
  },
  styles(e, t) {
    e.setStyles(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  zoomOnClick(e, t) {
    e.setZoomOnClick(t);
  }
}, t5e = {};
function n5e(e) {
  var {
    children: t,
    options: n,
    averageCenter: r,
    batchSizeIE: o,
    calculator: i,
    clusterClass: a,
    enableRetinaIcons: s,
    gridSize: l,
    ignoreHidden: u,
    imageExtension: c,
    imagePath: p,
    imageSizes: d,
    maxZoom: g,
    minimumClusterSize: f,
    styles: m,
    title: b,
    zoomOnClick: E,
    onClick: w,
    onClusteringBegin: M,
    onClusteringEnd: x,
    onMouseOver: v,
    onMouseOut: C,
    onLoad: P,
    onUnmount: F
  } = e, [L, B] = k(null), N = ge(zt), [$, V] = k(null), [H, Z] = k(null), [K, Y] = k(null), [Q, J] = k(null), [_, D] = k(null);
  return h(() => {
    L && C && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(L, Fs.onMouseOut, C)));
  }, [C]), h(() => {
    L && v && (_ !== null && google.maps.event.removeListener(_), D(google.maps.event.addListener(L, Fs.onMouseOver, v)));
  }, [v]), h(() => {
    L && w && ($ !== null && google.maps.event.removeListener($), V(google.maps.event.addListener(L, Fs.onClick, w)));
  }, [w]), h(() => {
    L && M && (H !== null && google.maps.event.removeListener(H), Z(google.maps.event.addListener(L, Fs.onClusteringBegin, M)));
  }, [M]), h(() => {
    L && x && (K !== null && google.maps.event.removeListener(K), Z(google.maps.event.addListener(L, Fs.onClusteringEnd, x)));
  }, [x]), h(() => {
    typeof r < "u" && L !== null && In.averageCenter(L, r);
  }, [L, r]), h(() => {
    typeof o < "u" && L !== null && In.batchSizeIE(L, o);
  }, [L, o]), h(() => {
    typeof i < "u" && L !== null && In.calculator(L, i);
  }, [L, i]), h(() => {
    typeof a < "u" && L !== null && In.clusterClass(L, a);
  }, [L, a]), h(() => {
    typeof s < "u" && L !== null && In.enableRetinaIcons(L, s);
  }, [L, s]), h(() => {
    typeof l < "u" && L !== null && In.gridSize(L, l);
  }, [L, l]), h(() => {
    typeof u < "u" && L !== null && In.ignoreHidden(L, u);
  }, [L, u]), h(() => {
    typeof c < "u" && L !== null && In.imageExtension(L, c);
  }, [L, c]), h(() => {
    typeof p < "u" && L !== null && In.imagePath(L, p);
  }, [L, p]), h(() => {
    typeof d < "u" && L !== null && In.imageSizes(L, d);
  }, [L, d]), h(() => {
    typeof g < "u" && L !== null && In.maxZoom(L, g);
  }, [L, g]), h(() => {
    typeof f < "u" && L !== null && In.minimumClusterSize(L, f);
  }, [L, f]), h(() => {
    typeof m < "u" && L !== null && In.styles(L, m);
  }, [L, m]), h(() => {
    typeof b < "u" && L !== null && In.title(L, b);
  }, [L, b]), h(() => {
    typeof E < "u" && L !== null && In.zoomOnClick(L, E);
  }, [L, E]), h(() => {
    if (N) {
      var z = e5e({}, n || t5e), S = new Gre(N, [], z);
      return r && In.averageCenter(S, r), o && In.batchSizeIE(S, o), i && In.calculator(S, i), a && In.clusterClass(S, a), s && In.enableRetinaIcons(S, s), l && In.gridSize(S, l), u && In.ignoreHidden(S, u), c && In.imageExtension(S, c), p && In.imagePath(S, p), d && In.imageSizes(S, d), g && In.maxZoom(S, g), f && In.minimumClusterSize(S, f), m && In.styles(S, m), b && In.title(S, b), E && In.zoomOnClick(S, E), C && J(google.maps.event.addListener(S, Fs.onMouseOut, C)), v && D(google.maps.event.addListener(S, Fs.onMouseOver, v)), w && V(google.maps.event.addListener(S, Fs.onClick, w)), M && Z(google.maps.event.addListener(S, Fs.onClusteringBegin, M)), x && Y(google.maps.event.addListener(S, Fs.onClusteringEnd, x)), B(S), P && P(S), () => {
        Q !== null && google.maps.event.removeListener(Q), _ !== null && google.maps.event.removeListener(_), $ !== null && google.maps.event.removeListener($), H !== null && google.maps.event.removeListener(H), K !== null && google.maps.event.removeListener(K), F && F(S);
      };
    }
  }, []), L !== null && t(L) || null;
}
me(n5e);
class r5e extends pe {
  constructor() {
    super(...arguments), De(this, "registeredEvents", []), De(this, "state", {
      markerClusterer: null
    }), De(this, "setClustererCallback", () => {
      this.state.markerClusterer !== null && this.props.onLoad && this.props.onLoad(this.state.markerClusterer);
    });
  }
  componentDidMount() {
    if (this.context) {
      var t = new Gre(this.context, [], this.props.options);
      this.registeredEvents = On({
        updaterMap: In,
        eventMap: Fs,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        markerClusterer: t
      }), this.setClustererCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.markerClusterer && (Sn(this.registeredEvents), this.registeredEvents = On({
      updaterMap: In,
      eventMap: Fs,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.markerClusterer
    }));
  }
  componentWillUnmount() {
    this.state.markerClusterer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.markerClusterer), Sn(this.registeredEvents), this.state.markerClusterer.setMap(null));
  }
  render() {
    return this.state.markerClusterer !== null ? this.props.children(this.state.markerClusterer) : null;
  }
}
De(r5e, "contextType", zt);
function S8(e) {
  e.cancelBubble = !0, e.stopPropagation && e.stopPropagation();
}
var Kre = (
  /** @class */
  function() {
    function e(t) {
      t === void 0 && (t = {}), this.getCloseClickHandler = this.getCloseClickHandler.bind(this), this.closeClickHandler = this.closeClickHandler.bind(this), this.createInfoBoxDiv = this.createInfoBoxDiv.bind(this), this.addClickHandler = this.addClickHandler.bind(this), this.getCloseBoxImg = this.getCloseBoxImg.bind(this), this.getBoxWidths = this.getBoxWidths.bind(this), this.setBoxStyle = this.setBoxStyle.bind(this), this.setPosition = this.setPosition.bind(this), this.getPosition = this.getPosition.bind(this), this.setOptions = this.setOptions.bind(this), this.setContent = this.setContent.bind(this), this.setVisible = this.setVisible.bind(this), this.getContent = this.getContent.bind(this), this.getVisible = this.getVisible.bind(this), this.setZIndex = this.setZIndex.bind(this), this.getZIndex = this.getZIndex.bind(this), this.onRemove = this.onRemove.bind(this), this.panBox = this.panBox.bind(this), this.extend = this.extend.bind(this), this.close = this.close.bind(this), this.draw = this.draw.bind(this), this.show = this.show.bind(this), this.hide = this.hide.bind(this), this.open = this.open.bind(this), this.extend(e, google.maps.OverlayView), this.content = t.content || "", this.disableAutoPan = t.disableAutoPan || !1, this.maxWidth = t.maxWidth || 0, this.pixelOffset = t.pixelOffset || new google.maps.Size(0, 0), this.position = t.position || new google.maps.LatLng(0, 0), this.zIndex = t.zIndex || null, this.boxClass = t.boxClass || "infoBox", this.boxStyle = t.boxStyle || {}, this.closeBoxMargin = t.closeBoxMargin || "2px", this.closeBoxURL = t.closeBoxURL || "http://www.google.com/intl/en_us/mapfiles/close.gif", t.closeBoxURL === "" && (this.closeBoxURL = ""), this.infoBoxClearance = t.infoBoxClearance || new google.maps.Size(1, 1), typeof t.visible > "u" && (typeof t.isHidden > "u" ? t.visible = !0 : t.visible = !t.isHidden), this.isHidden = !t.visible, this.alignBottom = t.alignBottom || !1, this.pane = t.pane || "floatPane", this.enableEventPropagation = t.enableEventPropagation || !1, this.div = null, this.closeListener = null, this.moveListener = null, this.mapListener = null, this.contextListener = null, this.eventListeners = null, this.fixedWidthSet = null;
    }
    return e.prototype.createInfoBoxDiv = function() {
      var t = this, n = function(u) {
        u.returnValue = !1, u.preventDefault && u.preventDefault(), t.enableEventPropagation || S8(u);
      };
      if (!this.div) {
        this.div = document.createElement("div"), this.setBoxStyle(), typeof this.content == "string" ? this.div.innerHTML = this.getCloseBoxImg() + this.content : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(this.content));
        var r = this.getPanes();
        if (r !== null && r[this.pane].appendChild(this.div), this.addClickHandler(), this.div.style.width)
          this.fixedWidthSet = !0;
        else if (this.maxWidth !== 0 && this.div.offsetWidth > this.maxWidth)
          this.div.style.width = this.maxWidth + "px", this.fixedWidthSet = !0;
        else {
          var o = this.getBoxWidths();
          this.div.style.width = this.div.offsetWidth - o.left - o.right + "px", this.fixedWidthSet = !1;
        }
        if (this.panBox(this.disableAutoPan), !this.enableEventPropagation) {
          this.eventListeners = [];
          for (var i = ["mousedown", "mouseover", "mouseout", "mouseup", "click", "dblclick", "touchstart", "touchend", "touchmove"], a = 0, s = i; a < s.length; a++) {
            var l = s[a];
            this.eventListeners.push(google.maps.event.addListener(this.div, l, S8));
          }
          this.eventListeners.push(google.maps.event.addListener(this.div, "mouseover", function() {
            t.div && (t.div.style.cursor = "default");
          }));
        }
        this.contextListener = google.maps.event.addListener(this.div, "contextmenu", n), google.maps.event.trigger(this, "domready");
      }
    }, e.prototype.getCloseBoxImg = function() {
      var t = "";
      return this.closeBoxURL !== "" && (t = '<img alt=""', t += ' aria-hidden="true"', t += " src='" + this.closeBoxURL + "'", t += " align=right", t += " style='", t += " position: relative;", t += " cursor: pointer;", t += " margin: " + this.closeBoxMargin + ";", t += "'>"), t;
    }, e.prototype.addClickHandler = function() {
      this.closeListener = this.div && this.div.firstChild && this.closeBoxURL !== "" ? google.maps.event.addListener(this.div.firstChild, "click", this.getCloseClickHandler()) : null;
    }, e.prototype.closeClickHandler = function(t) {
      t.cancelBubble = !0, t.stopPropagation && t.stopPropagation(), google.maps.event.trigger(this, "closeclick"), this.close();
    }, e.prototype.getCloseClickHandler = function() {
      return this.closeClickHandler;
    }, e.prototype.panBox = function(t) {
      if (this.div && !t) {
        var n = this.getMap();
        if (n instanceof google.maps.Map) {
          var r = 0, o = 0, i = n.getBounds();
          i && !i.contains(this.position) && n.setCenter(this.position);
          var a = n.getDiv(), s = a.offsetWidth, l = a.offsetHeight, u = this.pixelOffset.width, c = this.pixelOffset.height, p = this.div.offsetWidth, d = this.div.offsetHeight, g = this.infoBoxClearance.width, f = this.infoBoxClearance.height, m = this.getProjection(), b = m.fromLatLngToContainerPixel(this.position);
          b !== null && (b.x < -u + g ? r = b.x + u - g : b.x + p + u + g > s && (r = b.x + p + u + g - s), this.alignBottom ? b.y < -c + f + d ? o = b.y + c - f - d : b.y + c + f > l && (o = b.y + c + f - l) : b.y < -c + f ? o = b.y + c - f : b.y + d + c + f > l && (o = b.y + d + c + f - l)), r === 0 && o === 0 || n.panBy(r, o);
        }
      }
    }, e.prototype.setBoxStyle = function() {
      if (this.div) {
        this.div.className = this.boxClass, this.div.style.cssText = "";
        var t = this.boxStyle;
        for (var n in t)
          Object.prototype.hasOwnProperty.call(t, n) && (this.div.style[n] = t[n]);
        if (this.div.style.webkitTransform = "translateZ(0)", typeof this.div.style.opacity < "u" && this.div.style.opacity !== "") {
          var r = parseFloat(this.div.style.opacity || "");
          this.div.style.msFilter = '"progid:DXImageTransform.Microsoft.Alpha(Opacity=' + r * 100 + ')"', this.div.style.filter = "alpha(opacity=" + r * 100 + ")";
        }
        this.div.style.position = "absolute", this.div.style.visibility = "hidden", this.zIndex !== null && (this.div.style.zIndex = this.zIndex + ""), this.div.style.overflow || (this.div.style.overflow = "auto");
      }
    }, e.prototype.getBoxWidths = function() {
      var t = {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0
      };
      if (!this.div)
        return t;
      if (document.defaultView) {
        var n = this.div.ownerDocument, r = n && n.defaultView ? n.defaultView.getComputedStyle(this.div, "") : null;
        r && (t.top = parseInt(r.borderTopWidth || "", 10) || 0, t.bottom = parseInt(r.borderBottomWidth || "", 10) || 0, t.left = parseInt(r.borderLeftWidth || "", 10) || 0, t.right = parseInt(r.borderRightWidth || "", 10) || 0);
      } else if (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        document.documentElement.currentStyle
      ) {
        var o = this.div.currentStyle;
        o && (t.top = parseInt(o.borderTopWidth || "", 10) || 0, t.bottom = parseInt(o.borderBottomWidth || "", 10) || 0, t.left = parseInt(o.borderLeftWidth || "", 10) || 0, t.right = parseInt(o.borderRightWidth || "", 10) || 0);
      }
      return t;
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.div.parentNode.removeChild(this.div), this.div = null);
    }, e.prototype.draw = function() {
      if (this.createInfoBoxDiv(), this.div) {
        var t = this.getProjection(), n = t.fromLatLngToDivPixel(this.position);
        n !== null && (this.div.style.left = n.x + this.pixelOffset.width + "px", this.alignBottom ? this.div.style.bottom = -(n.y + this.pixelOffset.height) + "px" : this.div.style.top = n.y + this.pixelOffset.height + "px"), this.isHidden ? this.div.style.visibility = "hidden" : this.div.style.visibility = "visible";
      }
    }, e.prototype.setOptions = function(t) {
      t === void 0 && (t = {}), typeof t.boxClass < "u" && (this.boxClass = t.boxClass, this.setBoxStyle()), typeof t.boxStyle < "u" && (this.boxStyle = t.boxStyle, this.setBoxStyle()), typeof t.content < "u" && this.setContent(t.content), typeof t.disableAutoPan < "u" && (this.disableAutoPan = t.disableAutoPan), typeof t.maxWidth < "u" && (this.maxWidth = t.maxWidth), typeof t.pixelOffset < "u" && (this.pixelOffset = t.pixelOffset), typeof t.alignBottom < "u" && (this.alignBottom = t.alignBottom), typeof t.position < "u" && this.setPosition(t.position), typeof t.zIndex < "u" && this.setZIndex(t.zIndex), typeof t.closeBoxMargin < "u" && (this.closeBoxMargin = t.closeBoxMargin), typeof t.closeBoxURL < "u" && (this.closeBoxURL = t.closeBoxURL), typeof t.infoBoxClearance < "u" && (this.infoBoxClearance = t.infoBoxClearance), typeof t.isHidden < "u" && (this.isHidden = t.isHidden), typeof t.visible < "u" && (this.isHidden = !t.visible), typeof t.enableEventPropagation < "u" && (this.enableEventPropagation = t.enableEventPropagation), this.div && this.draw();
    }, e.prototype.setContent = function(t) {
      this.content = t, this.div && (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.fixedWidthSet || (this.div.style.width = ""), typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t)), this.fixedWidthSet || (this.div.style.width = this.div.offsetWidth + "px", typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t))), this.addClickHandler()), google.maps.event.trigger(this, "content_changed");
    }, e.prototype.setPosition = function(t) {
      this.position = t, this.div && this.draw(), google.maps.event.trigger(this, "position_changed");
    }, e.prototype.setVisible = function(t) {
      this.isHidden = !t, this.div && (this.div.style.visibility = this.isHidden ? "hidden" : "visible");
    }, e.prototype.setZIndex = function(t) {
      this.zIndex = t, this.div && (this.div.style.zIndex = t + ""), google.maps.event.trigger(this, "zindex_changed");
    }, e.prototype.getContent = function() {
      return this.content;
    }, e.prototype.getPosition = function() {
      return this.position;
    }, e.prototype.getZIndex = function() {
      return this.zIndex;
    }, e.prototype.getVisible = function() {
      var t = this.getMap();
      return typeof t > "u" || t === null ? !1 : !this.isHidden;
    }, e.prototype.show = function() {
      this.isHidden = !1, this.div && (this.div.style.visibility = "visible");
    }, e.prototype.hide = function() {
      this.isHidden = !0, this.div && (this.div.style.visibility = "hidden");
    }, e.prototype.open = function(t, n) {
      var r = this;
      n && (this.position = n.getPosition(), this.moveListener = google.maps.event.addListener(n, "position_changed", function() {
        var o = n.getPosition();
        r.setPosition(o);
      }), this.mapListener = google.maps.event.addListener(n, "map_changed", function() {
        r.setMap(n.map);
      })), this.setMap(t), this.div && this.panBox();
    }, e.prototype.close = function() {
      if (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.eventListeners) {
        for (var t = 0, n = this.eventListeners; t < n.length; t++) {
          var r = n[t];
          google.maps.event.removeListener(r);
        }
        this.eventListeners = null;
      }
      this.moveListener && (google.maps.event.removeListener(this.moveListener), this.moveListener = null), this.mapListener && (google.maps.event.removeListener(this.mapListener), this.mapListener = null), this.contextListener && (google.maps.event.removeListener(this.contextListener), this.contextListener = null), this.setMap(null);
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype)
          Object.prototype.hasOwnProperty.call(this, o) || (this.prototype[o] = r.prototype[o]);
        return this;
      }).apply(t, [n]);
    }, e;
  }()
), o5e = ["position"], i5e = ["position"];
function M8(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function jw(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? M8(Object(n), !0).forEach(function(r) {
      De(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : M8(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var D8 = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, T8 = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    t instanceof google.maps.LatLng ? e.setPosition(t) : e.setPosition(new google.maps.LatLng(t.lat, t.lng));
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, s5e = {};
function a5e(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, g = ge(zt), [f, m] = k(null), [b, E] = k(null), [w, M] = k(null), [x, v] = k(null), [C, P] = k(null), [F, L] = k(null), B = dt(null);
  return h(() => {
    g && f !== null && (f.close(), n ? f.open(g, n) : f.getPosition() && f.open(g));
  }, [g, f, n]), h(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), h(() => {
    if (o && f !== null) {
      var N = o instanceof google.maps.LatLng ? o : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        new google.maps.LatLng(o.lat, o.lng)
      );
      f.setPosition(N);
    }
  }, [o]), h(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), h(() => {
    f && a && (b !== null && google.maps.event.removeListener(b), E(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), h(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), M(google.maps.event.addListener(f, "domready", s)));
  }, [s]), h(() => {
    f && l && (x !== null && google.maps.event.removeListener(x), v(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), h(() => {
    f && u && (C !== null && google.maps.event.removeListener(C), P(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), h(() => {
    f && c && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), h(() => {
    if (g) {
      var N = r || s5e, {
        position: $
      } = N, V = qT(N, o5e), H;
      $ && !($ instanceof google.maps.LatLng) && (H = new google.maps.LatLng($.lat, $.lng));
      var Z = new Kre(jw(jw({}, V), H ? {
        position: H
      } : {}));
      B.current = document.createElement("div"), m(Z), a && E(google.maps.event.addListener(Z, "closeclick", a)), s && M(google.maps.event.addListener(Z, "domready", s)), l && v(google.maps.event.addListener(Z, "content_changed", l)), u && P(google.maps.event.addListener(Z, "position_changed", u)), c && L(google.maps.event.addListener(Z, "zindex_changed", c)), Z.setContent(B.current), n ? Z.open(g, n) : Z.getPosition() ? Z.open(g) : Zo(!1, "You must provide either an anchor or a position prop for <InfoBox>."), p && p(Z);
    }
    return () => {
      f !== null && (b && google.maps.event.removeListener(b), x && google.maps.event.removeListener(x), w && google.maps.event.removeListener(w), C && google.maps.event.removeListener(C), F && google.maps.event.removeListener(F), d && d(f), f.close());
    };
  }, []), B.current ? zn(at.only(t), B.current) : null;
}
me(a5e);
class l5e extends pe {
  constructor() {
    super(...arguments), De(this, "registeredEvents", []), De(this, "containerElement", null), De(this, "state", {
      infoBox: null
    }), De(this, "open", (t, n) => {
      n ? this.context !== null && t.open(this.context, n) : t.getPosition() ? this.context !== null && t.open(this.context) : Zo(!1, "You must provide either an anchor or a position prop for <InfoBox>.");
    }), De(this, "setInfoBoxCallback", () => {
      this.state.infoBox !== null && this.containerElement !== null && (this.state.infoBox.setContent(this.containerElement), this.open(this.state.infoBox, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoBox));
    });
  }
  componentDidMount() {
    var t = this.props.options || {}, {
      position: n
    } = t, r = qT(t, i5e), o;
    n && !(n instanceof google.maps.LatLng) && (o = new google.maps.LatLng(n.lat, n.lng));
    var i = new Kre(jw(jw({}, r), o ? {
      position: o
    } : {}));
    this.containerElement = document.createElement("div"), this.registeredEvents = On({
      updaterMap: T8,
      eventMap: D8,
      prevProps: {},
      nextProps: this.props,
      instance: i
    }), this.setState({
      infoBox: i
    }, this.setInfoBoxCallback);
  }
  componentDidUpdate(t) {
    var {
      infoBox: n
    } = this.state;
    n !== null && (Sn(this.registeredEvents), this.registeredEvents = On({
      updaterMap: T8,
      eventMap: D8,
      prevProps: t,
      nextProps: this.props,
      instance: n
    }));
  }
  componentWillUnmount() {
    var {
      onUnmount: t
    } = this.props, {
      infoBox: n
    } = this.state;
    n !== null && (t && t(n), Sn(this.registeredEvents), n.close());
  }
  render() {
    return this.containerElement ? zn(at.only(this.props.children), this.containerElement) : null;
  }
}
De(l5e, "contextType", zt);
var j8, A8;
function u5e() {
  return A8 || (A8 = 1, j8 = function e(t, n) {
    if (t === n) return !0;
    if (t && n && typeof t == "object" && typeof n == "object") {
      if (t.constructor !== n.constructor) return !1;
      var r, o, i;
      if (Array.isArray(t)) {
        if (r = t.length, r != n.length) return !1;
        for (o = r; o-- !== 0; ) if (!e(t[o], n[o])) return !1;
        return !0;
      }
      if (t.constructor === RegExp) return t.source === n.source && t.flags === n.flags;
      if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === n.valueOf();
      if (t.toString !== Object.prototype.toString) return t.toString() === n.toString();
      if (i = Object.keys(t), r = i.length, r !== Object.keys(n).length) return !1;
      for (o = r; o-- !== 0; ) if (!Object.prototype.hasOwnProperty.call(n, i[o])) return !1;
      for (o = r; o-- !== 0; ) {
        var a = i[o];
        if (!e(t[a], n[a])) return !1;
      }
      return !0;
    }
    return t !== t && n !== n;
  }), j8;
}
var c5e = u5e(), R8 = /* @__PURE__ */ Hre(c5e), I8 = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array], oL = 1, jd = 8;
class GT {
  /**
   * Creates an index from raw `ArrayBuffer` data.
   * @param {ArrayBuffer} data
   */
  static from(t) {
    if (!(t instanceof ArrayBuffer))
      throw new Error("Data must be an instance of ArrayBuffer.");
    var [n, r] = new Uint8Array(t, 0, 2);
    if (n !== 219)
      throw new Error("Data does not appear to be in a KDBush format.");
    var o = r >> 4;
    if (o !== oL)
      throw new Error("Got v".concat(o, " data when expected v").concat(oL, "."));
    var i = I8[r & 15];
    if (!i)
      throw new Error("Unrecognized array type.");
    var [a] = new Uint16Array(t, 2, 1), [s] = new Uint32Array(t, 4, 1);
    return new GT(s, a, i, t);
  }
  /**
   * Creates an index that will hold a given number of items.
   * @param {number} numItems
   * @param {number} [nodeSize=64] Size of the KD-tree node (64 by default).
   * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).
   * @param {ArrayBuffer} [data] (For internal use only)
   */
  constructor(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 64, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Float64Array, o = arguments.length > 3 ? arguments[3] : void 0;
    if (isNaN(t) || t < 0) throw new Error("Unpexpected numItems value: ".concat(t, "."));
    this.numItems = +t, this.nodeSize = Math.min(Math.max(+n, 2), 65535), this.ArrayType = r, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
    var i = I8.indexOf(this.ArrayType), a = t * 2 * this.ArrayType.BYTES_PER_ELEMENT, s = t * this.IndexArrayType.BYTES_PER_ELEMENT, l = (8 - s % 8) % 8;
    if (i < 0)
      throw new Error("Unexpected typed array class: ".concat(r, "."));
    o && o instanceof ArrayBuffer ? (this.data = o, this.ids = new this.IndexArrayType(this.data, jd, t), this.coords = new this.ArrayType(this.data, jd + s + l, t * 2), this._pos = t * 2, this._finished = !0) : (this.data = new ArrayBuffer(jd + a + s + l), this.ids = new this.IndexArrayType(this.data, jd, t), this.coords = new this.ArrayType(this.data, jd + s + l, t * 2), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, (oL << 4) + i]), new Uint16Array(this.data, 2, 1)[0] = n, new Uint32Array(this.data, 4, 1)[0] = t);
  }
  /**
   * Add a point to the index.
   * @param {number} x
   * @param {number} y
   * @returns {number} An incremental index associated with the added item (starting from `0`).
   */
  add(t, n) {
    var r = this._pos >> 1;
    return this.ids[r] = r, this.coords[this._pos++] = t, this.coords[this._pos++] = n, r;
  }
  /**
   * Perform indexing of the added points.
   */
  finish() {
    var t = this._pos >> 1;
    if (t !== this.numItems)
      throw new Error("Added ".concat(t, " items when expected ").concat(this.numItems, "."));
    return vP(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
  }
  /**
   * Search the index for items within a given bounding box.
   * @param {number} minX
   * @param {number} minY
   * @param {number} maxX
   * @param {number} maxY
   * @returns {number[]} An array of indices correponding to the found items.
   */
  range(t, n, r, o) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: i,
      coords: a,
      nodeSize: s
    } = this, l = [0, i.length - 1, 0], u = []; l.length; ) {
      var c = l.pop() || 0, p = l.pop() || 0, d = l.pop() || 0;
      if (p - d <= s) {
        for (var g = d; g <= p; g++) {
          var f = a[2 * g], m = a[2 * g + 1];
          f >= t && f <= r && m >= n && m <= o && u.push(i[g]);
        }
        continue;
      }
      var b = d + p >> 1, E = a[2 * b], w = a[2 * b + 1];
      E >= t && E <= r && w >= n && w <= o && u.push(i[b]), (c === 0 ? t <= E : n <= w) && (l.push(d), l.push(b - 1), l.push(1 - c)), (c === 0 ? r >= E : o >= w) && (l.push(b + 1), l.push(p), l.push(1 - c));
    }
    return u;
  }
  /**
   * Search the index for items within a given radius.
   * @param {number} qx
   * @param {number} qy
   * @param {number} r Query radius.
   * @returns {number[]} An array of indices correponding to the found items.
   */
  within(t, n, r) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: o,
      coords: i,
      nodeSize: a
    } = this, s = [0, o.length - 1, 0], l = [], u = r * r; s.length; ) {
      var c = s.pop() || 0, p = s.pop() || 0, d = s.pop() || 0;
      if (p - d <= a) {
        for (var g = d; g <= p; g++)
          N8(i[2 * g], i[2 * g + 1], t, n) <= u && l.push(o[g]);
        continue;
      }
      var f = d + p >> 1, m = i[2 * f], b = i[2 * f + 1];
      N8(m, b, t, n) <= u && l.push(o[f]), (c === 0 ? t - r <= m : n - r <= b) && (s.push(d), s.push(f - 1), s.push(1 - c)), (c === 0 ? t + r >= m : n + r >= b) && (s.push(f + 1), s.push(p), s.push(1 - c));
    }
    return l;
  }
}
function vP(e, t, n, r, o, i) {
  if (!(o - r <= n)) {
    var a = r + o >> 1;
    Xre(e, t, a, r, o, i), vP(e, t, n, r, a - 1, 1 - i), vP(e, t, n, a + 1, o, 1 - i);
  }
}
function Xre(e, t, n, r, o, i) {
  for (; o > r; ) {
    if (o - r > 600) {
      var a = o - r + 1, s = n - r + 1, l = Math.log(a), u = 0.5 * Math.exp(2 * l / 3), c = 0.5 * Math.sqrt(l * u * (a - u) / a) * (s - a / 2 < 0 ? -1 : 1), p = Math.max(r, Math.floor(n - s * u / a + c)), d = Math.min(o, Math.floor(n + (a - s) * u / a + c));
      Xre(e, t, n, p, d, i);
    }
    var g = t[2 * n + i], f = r, m = o;
    for (Ad(e, t, r, n), t[2 * o + i] > g && Ad(e, t, r, o); f < m; ) {
      for (Ad(e, t, f, m), f++, m--; t[2 * f + i] < g; ) f++;
      for (; t[2 * m + i] > g; ) m--;
    }
    t[2 * r + i] === g ? Ad(e, t, r, m) : (m++, Ad(e, t, m, o)), m <= n && (r = m + 1), n <= m && (o = m - 1);
  }
}
function Ad(e, t, n, r) {
  iL(e, n, r), iL(t, 2 * n, 2 * r), iL(t, 2 * n + 1, 2 * r + 1);
}
function iL(e, t, n) {
  var r = e[t];
  e[t] = e[n], e[n] = r;
}
function N8(e, t, n, r) {
  var o = e - n, i = t - r;
  return o * o + i * i;
}
var p5e = {
  minZoom: 0,
  // min zoom to generate clusters on
  maxZoom: 16,
  // max zoom level to cluster the points on
  minPoints: 2,
  // minimum points to form a cluster
  radius: 40,
  // cluster radius in pixels
  extent: 512,
  // tile extent (radius is calculated relative to it)
  nodeSize: 64,
  // size of the KD-tree leaf node, affects performance
  log: !1,
  // whether to log timing info
  // whether to generate numeric ids for input features (in vector tiles)
  generateId: !1,
  // a reduce function for calculating custom cluster properties
  reduce: null,
  // (accumulated, props) => { accumulated.sum += props.sum; }
  // properties to use for individual points when running the reducer
  map: (e) => e
  // props => ({sum: props.my_value})
}, B8 = Math.fround || /* @__PURE__ */ ((e) => (t) => (e[0] = +t, e[0]))(new Float32Array(1)), $u = 2, $l = 3, sL = 4, Il = 5, Yre = 6;
class d5e {
  constructor(t) {
    this.options = Object.assign(Object.create(p5e), t), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
  }
  load(t) {
    var {
      log: n,
      minZoom: r,
      maxZoom: o
    } = this.options;
    n && console.time("total time");
    var i = "prepare ".concat(t.length, " points");
    n && console.time(i), this.points = t;
    for (var a = [], s = 0; s < t.length; s++) {
      var l = t[s];
      if (l.geometry) {
        var [u, c] = l.geometry.coordinates, p = B8(Gv(u)), d = B8(Kv(c));
        a.push(
          p,
          d,
          // projected point coordinates
          1 / 0,
          // the last zoom the point was processed at
          s,
          // index of the source feature in the original input array
          -1,
          // parent cluster id
          1
          // number of points in a cluster
        ), this.options.reduce && a.push(0);
      }
    }
    var g = this.trees[o + 1] = this._createTree(a);
    n && console.timeEnd(i);
    for (var f = o; f >= r; f--) {
      var m = +Date.now();
      g = this.trees[f] = this._createTree(this._cluster(g, f)), n && console.log("z%d: %d clusters in %dms", f, g.numItems, +Date.now() - m);
    }
    return n && console.timeEnd("total time"), this;
  }
  getClusters(t, n) {
    var r = ((t[0] + 180) % 360 + 360) % 360 - 180, o = Math.max(-90, Math.min(90, t[1])), i = t[2] === 180 ? 180 : ((t[2] + 180) % 360 + 360) % 360 - 180, a = Math.max(-90, Math.min(90, t[3]));
    if (t[2] - t[0] >= 360)
      r = -180, i = 180;
    else if (r > i) {
      var s = this.getClusters([r, o, 180, a], n), l = this.getClusters([-180, o, i, a], n);
      return s.concat(l);
    }
    var u = this.trees[this._limitZoom(n)], c = u.range(Gv(r), Kv(a), Gv(i), Kv(o)), p = u.data, d = [];
    for (var g of c) {
      var f = this.stride * g;
      d.push(p[f + Il] > 1 ? F8(p, f, this.clusterProps) : this.points[p[f + $l]]);
    }
    return d;
  }
  getChildren(t) {
    var n = this._getOriginId(t), r = this._getOriginZoom(t), o = "No cluster with the specified id.", i = this.trees[r];
    if (!i) throw new Error(o);
    var a = i.data;
    if (n * this.stride >= a.length) throw new Error(o);
    var s = this.options.radius / (this.options.extent * Math.pow(2, r - 1)), l = a[n * this.stride], u = a[n * this.stride + 1], c = i.within(l, u, s), p = [];
    for (var d of c) {
      var g = d * this.stride;
      a[g + sL] === t && p.push(a[g + Il] > 1 ? F8(a, g, this.clusterProps) : this.points[a[g + $l]]);
    }
    if (p.length === 0) throw new Error(o);
    return p;
  }
  getLeaves(t, n, r) {
    n = n || 10, r = r || 0;
    var o = [];
    return this._appendLeaves(o, t, n, r, 0), o;
  }
  getTile(t, n, r) {
    var o = this.trees[this._limitZoom(t)], i = Math.pow(2, t), {
      extent: a,
      radius: s
    } = this.options, l = s / a, u = (r - l) / i, c = (r + 1 + l) / i, p = {
      features: []
    };
    return this._addTileFeatures(o.range((n - l) / i, u, (n + 1 + l) / i, c), o.data, n, r, i, p), n === 0 && this._addTileFeatures(o.range(1 - l / i, u, 1, c), o.data, i, r, i, p), n === i - 1 && this._addTileFeatures(o.range(0, u, l / i, c), o.data, -1, r, i, p), p.features.length ? p : null;
  }
  getClusterExpansionZoom(t) {
    for (var n = this._getOriginZoom(t) - 1; n <= this.options.maxZoom; ) {
      var r = this.getChildren(t);
      if (n++, r.length !== 1) break;
      t = r[0].properties.cluster_id;
    }
    return n;
  }
  _appendLeaves(t, n, r, o, i) {
    var a = this.getChildren(n);
    for (var s of a) {
      var l = s.properties;
      if (l && l.cluster ? i + l.point_count <= o ? i += l.point_count : i = this._appendLeaves(t, l.cluster_id, r, o, i) : i < o ? i++ : t.push(s), t.length === r) break;
    }
    return i;
  }
  _createTree(t) {
    for (var n = new GT(t.length / this.stride | 0, this.options.nodeSize, Float32Array), r = 0; r < t.length; r += this.stride) n.add(t[r], t[r + 1]);
    return n.finish(), n.data = t, n;
  }
  _addTileFeatures(t, n, r, o, i, a) {
    for (var s of t) {
      var l = s * this.stride, u = n[l + Il] > 1, c = void 0, p = void 0, d = void 0;
      if (u)
        c = Jre(n, l, this.clusterProps), p = n[l], d = n[l + 1];
      else {
        var g = this.points[n[l + $l]];
        c = g.properties;
        var [f, m] = g.geometry.coordinates;
        p = Gv(f), d = Kv(m);
      }
      var b = {
        type: 1,
        geometry: [[Math.round(this.options.extent * (p * i - r)), Math.round(this.options.extent * (d * i - o))]],
        tags: c
      }, E = void 0;
      u || this.options.generateId ? E = n[l + $l] : E = this.points[n[l + $l]].id, E !== void 0 && (b.id = E), a.features.push(b);
    }
  }
  _limitZoom(t) {
    return Math.max(this.options.minZoom, Math.min(Math.floor(+t), this.options.maxZoom + 1));
  }
  _cluster(t, n) {
    for (var {
      radius: r,
      extent: o,
      reduce: i,
      minPoints: a
    } = this.options, s = r / (o * Math.pow(2, n)), l = t.data, u = [], c = this.stride, p = 0; p < l.length; p += c)
      if (!(l[p + $u] <= n)) {
        l[p + $u] = n;
        var d = l[p], g = l[p + 1], f = t.within(l[p], l[p + 1], s), m = l[p + Il], b = m;
        for (var E of f) {
          var w = E * c;
          l[w + $u] > n && (b += l[w + Il]);
        }
        if (b > m && b >= a) {
          var M = d * m, x = g * m, v = void 0, C = -1, P = ((p / c | 0) << 5) + (n + 1) + this.points.length;
          for (var F of f) {
            var L = F * c;
            if (!(l[L + $u] <= n)) {
              l[L + $u] = n;
              var B = l[L + Il];
              M += l[L] * B, x += l[L + 1] * B, l[L + sL] = P, i && (v || (v = this._map(l, p, !0), C = this.clusterProps.length, this.clusterProps.push(v)), i(v, this._map(l, L)));
            }
          }
          l[p + sL] = P, u.push(M / b, x / b, 1 / 0, P, -1, b), i && u.push(C);
        } else {
          for (var N = 0; N < c; N++) u.push(l[p + N]);
          if (b > 1)
            for (var $ of f) {
              var V = $ * c;
              if (!(l[V + $u] <= n)) {
                l[V + $u] = n;
                for (var H = 0; H < c; H++) u.push(l[V + H]);
              }
            }
        }
      }
    return u;
  }
  // get index of the point from which the cluster originated
  _getOriginId(t) {
    return t - this.points.length >> 5;
  }
  // get zoom of the point from which the cluster originated
  _getOriginZoom(t) {
    return (t - this.points.length) % 32;
  }
  _map(t, n, r) {
    if (t[n + Il] > 1) {
      var o = this.clusterProps[t[n + Yre]];
      return r ? Object.assign({}, o) : o;
    }
    var i = this.points[t[n + $l]].properties, a = this.options.map(i);
    return r && a === i ? Object.assign({}, a) : a;
  }
}
function F8(e, t, n) {
  return {
    type: "Feature",
    id: e[t + $l],
    properties: Jre(e, t, n),
    geometry: {
      type: "Point",
      coordinates: [f5e(e[t]), h5e(e[t + 1])]
    }
  };
}
function Jre(e, t, n) {
  var r = e[t + Il], o = r >= 1e4 ? "".concat(Math.round(r / 1e3), "k") : r >= 1e3 ? "".concat(Math.round(r / 100) / 10, "k") : r, i = e[t + Yre], a = i === -1 ? {} : Object.assign({}, n[i]);
  return Object.assign(a, {
    cluster: !0,
    cluster_id: e[t + $l],
    point_count: r,
    point_count_abbreviated: o
  });
}
function Gv(e) {
  return e / 360 + 0.5;
}
function Kv(e) {
  var t = Math.sin(e * Math.PI / 180), n = 0.5 - 0.25 * Math.log((1 + t) / (1 - t)) / Math.PI;
  return n < 0 ? 0 : n > 1 ? 1 : n;
}
function f5e(e) {
  return (e - 0.5) * 360;
}
function h5e(e) {
  var t = (180 - e * 360) * Math.PI / 180;
  return 360 * Math.atan(Math.exp(t)) / Math.PI - 90;
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function g5e(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
    t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
  return n;
}
class gs {
  static isAdvancedMarkerAvailable(t) {
    return google.maps.marker && t.getMapCapabilities().isAdvancedMarkersAvailable === !0;
  }
  static isAdvancedMarker(t) {
    return google.maps.marker && t instanceof google.maps.marker.AdvancedMarkerElement;
  }
  static setMap(t, n) {
    this.isAdvancedMarker(t) ? t.map = n : t.setMap(n);
  }
  static getPosition(t) {
    if (this.isAdvancedMarker(t)) {
      if (t.position) {
        if (t.position instanceof google.maps.LatLng)
          return t.position;
        if (t.position.lat && t.position.lng)
          return new google.maps.LatLng(t.position.lat, t.position.lng);
      }
      return new google.maps.LatLng(null);
    }
    return t.getPosition();
  }
  static getVisible(t) {
    return this.isAdvancedMarker(t) ? !0 : t.getVisible();
  }
}
class yP {
  constructor(t) {
    var {
      markers: n,
      position: r
    } = t;
    this.markers = n, r && (r instanceof google.maps.LatLng ? this._position = r : this._position = new google.maps.LatLng(r));
  }
  get bounds() {
    if (!(this.markers.length === 0 && !this._position)) {
      var t = new google.maps.LatLngBounds(this._position, this._position);
      for (var n of this.markers)
        t.extend(gs.getPosition(n));
      return t;
    }
  }
  get position() {
    return this._position || this.bounds.getCenter();
  }
  /**
   * Get the count of **visible** markers.
   */
  get count() {
    return this.markers.filter((t) => gs.getVisible(t)).length;
  }
  /**
   * Add a marker to the cluster.
   */
  push(t) {
    this.markers.push(t);
  }
  /**
   * Cleanup references and remove marker from map.
   */
  delete() {
    this.marker && (gs.setMap(this.marker, null), this.marker = void 0), this.markers.length = 0;
  }
}
class m5e {
  constructor(t) {
    var {
      maxZoom: n = 16
    } = t;
    this.maxZoom = n;
  }
  /**
   * Helper function to bypass clustering based upon some map state such as
   * zoom, number of markers, etc.
   *
   * ```typescript
   *  cluster({markers, map}: AlgorithmInput): Cluster[] {
   *    if (shouldBypassClustering(map)) {
   *      return this.noop({markers})
   *    }
   * }
   * ```
   */
  noop(t) {
    var {
      markers: n
    } = t;
    return v5e(n);
  }
}
var v5e = (e) => {
  var t = e.map((n) => new yP({
    position: gs.getPosition(n),
    markers: [n]
  }));
  return t;
};
class y5e extends m5e {
  constructor(t) {
    var {
      maxZoom: n,
      radius: r = 60
    } = t, o = g5e(t, ["maxZoom", "radius"]);
    super({
      maxZoom: n
    }), this.state = {
      zoom: -1
    }, this.superCluster = new d5e(Object.assign({
      maxZoom: this.maxZoom,
      radius: r
    }, o));
  }
  calculate(t) {
    var n = !1, r = {
      zoom: t.map.getZoom()
    };
    if (!R8(t.markers, this.markers)) {
      n = !0, this.markers = [...t.markers];
      var o = this.markers.map((i) => {
        var a = gs.getPosition(i), s = [a.lng(), a.lat()];
        return {
          type: "Feature",
          geometry: {
            type: "Point",
            coordinates: s
          },
          properties: {
            marker: i
          }
        };
      });
      this.superCluster.load(o);
    }
    return n || (this.state.zoom <= this.maxZoom || r.zoom <= this.maxZoom) && (n = !R8(this.state, r)), this.state = r, n && (this.clusters = this.cluster(t)), {
      clusters: this.clusters,
      changed: n
    };
  }
  cluster(t) {
    var {
      map: n
    } = t;
    return this.superCluster.getClusters([-180, -90, 180, 90], Math.round(n.getZoom())).map((r) => this.transformCluster(r));
  }
  transformCluster(t) {
    var {
      geometry: {
        coordinates: [n, r]
      },
      properties: o
    } = t;
    if (o.cluster)
      return new yP({
        markers: this.superCluster.getLeaves(o.cluster_id, 1 / 0).map((a) => a.properties.marker),
        position: {
          lat: r,
          lng: n
        }
      });
    var i = o.marker;
    return new yP({
      markers: [i],
      position: gs.getPosition(i)
    });
  }
}
class b5e {
  constructor(t, n) {
    this.markers = {
      sum: t.length
    };
    var r = n.map((i) => i.count), o = r.reduce((i, a) => i + a, 0);
    this.clusters = {
      count: n.length,
      markers: {
        mean: o / n.length,
        sum: o,
        min: Math.min(...r),
        max: Math.max(...r)
      }
    };
  }
}
class w5e {
  /**
   * The default render function for the library used by {@link MarkerClusterer}.
   *
   * Currently set to use the following:
   *
   * ```typescript
   * // change color if this cluster has more markers than the mean cluster
   * const color =
   *   count > Math.max(10, stats.clusters.markers.mean)
   *     ? "#ff0000"
   *     : "#0000ff";
   *
   * // create svg url with fill color
   * const svg = window.btoa(`
   * <svg fill="${color}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240">
   *   <circle cx="120" cy="120" opacity=".6" r="70" />
   *   <circle cx="120" cy="120" opacity=".3" r="90" />
   *   <circle cx="120" cy="120" opacity=".2" r="110" />
   *   <circle cx="120" cy="120" opacity=".1" r="130" />
   * </svg>`);
   *
   * // create marker using svg icon
   * return new google.maps.Marker({
   *   position,
   *   icon: {
   *     url: `data:image/svg+xml;base64,${svg}`,
   *     scaledSize: new google.maps.Size(45, 45),
   *   },
   *   label: {
   *     text: String(count),
   *     color: "rgba(255,255,255,0.9)",
   *     fontSize: "12px",
   *   },
   *   // adjust zIndex to be above other markers
   *   zIndex: 1000 + count,
   * });
   * ```
   */
  render(t, n, r) {
    var {
      count: o,
      position: i
    } = t, a = o > Math.max(10, n.clusters.markers.mean) ? "#ff0000" : "#0000ff", s = '<svg fill="'.concat(a, `" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" width="50" height="50">
<circle cx="120" cy="120" opacity=".6" r="70" />
<circle cx="120" cy="120" opacity=".3" r="90" />
<circle cx="120" cy="120" opacity=".2" r="110" />
<text x="50%" y="50%" style="fill:#fff" text-anchor="middle" font-size="50" dominant-baseline="middle" font-family="roboto,arial,sans-serif">`).concat(o, `</text>
</svg>`), l = "Cluster of ".concat(o, " markers"), u = Number(google.maps.Marker.MAX_ZINDEX) + o;
    if (gs.isAdvancedMarkerAvailable(r)) {
      var c = new DOMParser(), p = c.parseFromString(s, "image/svg+xml").documentElement;
      p.setAttribute("transform", "translate(0 25)");
      var d = {
        map: r,
        position: i,
        zIndex: u,
        title: l,
        content: p
      };
      return new google.maps.marker.AdvancedMarkerElement(d);
    }
    var g = {
      position: i,
      zIndex: u,
      title: l,
      icon: {
        url: "data:image/svg+xml;base64,".concat(btoa(s)),
        anchor: new google.maps.Point(25, 25)
      }
    };
    return new google.maps.Marker(g);
  }
}
function C5e(e, t) {
  for (var n in t.prototype)
    e.prototype[n] = t.prototype[n];
}
class KT {
  constructor() {
    C5e(KT, google.maps.OverlayView);
  }
}
var jf;
(function(e) {
  e.CLUSTERING_BEGIN = "clusteringbegin", e.CLUSTERING_END = "clusteringend", e.CLUSTER_CLICK = "click";
})(jf || (jf = {}));
var O5e = (e, t, n) => {
  n.fitBounds(t.bounds);
};
class x5e extends KT {
  constructor(t) {
    var {
      map: n,
      markers: r = [],
      algorithmOptions: o = {},
      algorithm: i = new y5e(o),
      renderer: a = new w5e(),
      onClusterClick: s = O5e
    } = t;
    super(), this.markers = [...r], this.clusters = [], this.algorithm = i, this.renderer = a, this.onClusterClick = s, n && this.setMap(n);
  }
  addMarker(t, n) {
    this.markers.includes(t) || (this.markers.push(t), n || this.render());
  }
  addMarkers(t, n) {
    t.forEach((r) => {
      this.addMarker(r, !0);
    }), n || this.render();
  }
  removeMarker(t, n) {
    var r = this.markers.indexOf(t);
    return r === -1 ? !1 : (gs.setMap(t, null), this.markers.splice(r, 1), n || this.render(), !0);
  }
  removeMarkers(t, n) {
    var r = !1;
    return t.forEach((o) => {
      r = this.removeMarker(o, !0) || r;
    }), r && !n && this.render(), r;
  }
  clearMarkers(t) {
    this.markers.length = 0, t || this.render();
  }
  /**
   * Recalculates and draws all the marker clusters.
   */
  render() {
    var t = this.getMap();
    if (t instanceof google.maps.Map && t.getProjection()) {
      google.maps.event.trigger(this, jf.CLUSTERING_BEGIN, this);
      var {
        clusters: n,
        changed: r
      } = this.algorithm.calculate({
        markers: this.markers,
        map: t,
        mapCanvasProjection: this.getProjection()
      });
      if (r || r == null) {
        var o = /* @__PURE__ */ new Set();
        for (var i of n)
          i.markers.length == 1 && o.add(i.markers[0]);
        var a = [];
        for (var s of this.clusters)
          s.marker != null && (s.markers.length == 1 ? o.has(s.marker) || gs.setMap(s.marker, null) : a.push(s.marker));
        this.clusters = n, this.renderClusters(), requestAnimationFrame(() => a.forEach((l) => gs.setMap(l, null)));
      }
      google.maps.event.trigger(this, jf.CLUSTERING_END, this);
    }
  }
  onAdd() {
    this.idleListener = this.getMap().addListener("idle", this.render.bind(this)), this.render();
  }
  onRemove() {
    google.maps.event.removeListener(this.idleListener), this.reset();
  }
  reset() {
    this.markers.forEach((t) => gs.setMap(t, null)), this.clusters.forEach((t) => t.delete()), this.clusters = [];
  }
  renderClusters() {
    var t = new b5e(this.markers, this.clusters), n = this.getMap();
    this.clusters.forEach((r) => {
      r.markers.length === 1 ? r.marker = r.markers[0] : (r.marker = this.renderer.render(r, t, n), r.markers.forEach((o) => gs.setMap(o, null)), this.onClusterClick && r.marker.addListener(
        "click",
        /* istanbul ignore next */
        (o) => {
          google.maps.event.trigger(this, jf.CLUSTER_CLICK, r), this.onClusterClick(o, r, n);
        }
      )), gs.setMap(r.marker, n);
    });
  }
}
function z8(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function U8(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? z8(Object(n), !0).forEach(function(r) {
      De(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : z8(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function E5e(e) {
  var t = O8e(), [n, r] = k(null);
  return h(() => {
    if (t && n === null) {
      var o = new x5e(U8(U8({}, e), {}, {
        map: t
      }));
      r(o);
    }
  }, [t]), n;
}
function k5e(e) {
  var {
    children: t,
    options: n
  } = e, r = E5e(n);
  return r !== null ? t(r) : null;
}
me(k5e);
var H8 = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, W8 = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
function L5e(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, g = ge(zt), [f, m] = k(null), [b, E] = k(null), [w, M] = k(null), [x, v] = k(null), [C, P] = k(null), [F, L] = k(null), B = dt(null);
  return h(() => {
    f !== null && (f.close(), n ? f.open(g, n) : f.getPosition() && f.open(g));
  }, [g, f, n]), h(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), h(() => {
    o && f !== null && f.setPosition(o);
  }, [o]), h(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), h(() => {
    f && a && (b !== null && google.maps.event.removeListener(b), E(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), h(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), M(google.maps.event.addListener(f, "domready", s)));
  }, [s]), h(() => {
    f && l && (x !== null && google.maps.event.removeListener(x), v(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), h(() => {
    f && u && (C !== null && google.maps.event.removeListener(C), P(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), h(() => {
    f && c && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), h(() => {
    var N = new google.maps.InfoWindow(r);
    return m(N), B.current = document.createElement("div"), a && E(google.maps.event.addListener(N, "closeclick", a)), s && M(google.maps.event.addListener(N, "domready", s)), l && v(google.maps.event.addListener(N, "content_changed", l)), u && P(google.maps.event.addListener(N, "position_changed", u)), c && L(google.maps.event.addListener(N, "zindex_changed", c)), N.setContent(B.current), o && N.setPosition(o), i && N.setZIndex(i), n ? N.open(g, n) : N.getPosition() ? N.open(g) : Zo(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>."), p && p(N), () => {
      b && google.maps.event.removeListener(b), x && google.maps.event.removeListener(x), w && google.maps.event.removeListener(w), C && google.maps.event.removeListener(C), F && google.maps.event.removeListener(F), d && d(N), N.close();
    };
  }, []), B.current ? zn(at.only(t), B.current) : null;
}
me(L5e);
class _5e extends pe {
  constructor() {
    super(...arguments), De(this, "registeredEvents", []), De(this, "containerElement", null), De(this, "state", {
      infoWindow: null
    }), De(this, "open", (t, n) => {
      n ? t.open(this.context, n) : t.getPosition() ? t.open(this.context) : Zo(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>.");
    }), De(this, "setInfoWindowCallback", () => {
      this.state.infoWindow !== null && this.containerElement !== null && (this.state.infoWindow.setContent(this.containerElement), this.open(this.state.infoWindow, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoWindow));
    });
  }
  componentDidMount() {
    var t = new google.maps.InfoWindow(this.props.options);
    this.containerElement = document.createElement("div"), this.registeredEvents = On({
      updaterMap: W8,
      eventMap: H8,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(() => ({
      infoWindow: t
    }), this.setInfoWindowCallback);
  }
  componentDidUpdate(t) {
    this.state.infoWindow !== null && (Sn(this.registeredEvents), this.registeredEvents = On({
      updaterMap: W8,
      eventMap: H8,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.infoWindow
    }));
  }
  componentWillUnmount() {
    this.state.infoWindow !== null && (Sn(this.registeredEvents), this.props.onUnmount && this.props.onUnmount(this.state.infoWindow), this.state.infoWindow.close());
  }
  render() {
    return this.containerElement ? zn(at.only(this.props.children), this.containerElement) : null;
  }
}
De(_5e, "contextType", zt);
function $8(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Aw(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? $8(Object(n), !0).forEach(function(r) {
      De(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : $8(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var V8 = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, Z8 = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, P5e = {};
function S5e(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: g,
    onRightClick: f,
    onClick: m,
    onDrag: b,
    onLoad: E,
    onUnmount: w
  } = e, M = ge(zt), [x, v] = k(null), [C, P] = k(null), [F, L] = k(null), [B, N] = k(null), [$, V] = k(null), [H, Z] = k(null), [K, Y] = k(null), [Q, J] = k(null), [_, D] = k(null), [z, S] = k(null), [W, O] = k(null), [j, U] = k(null);
  return h(() => {
    x !== null && x.setMap(M);
  }, [M]), h(() => {
    typeof t < "u" && x !== null && x.setOptions(t);
  }, [x, t]), h(() => {
    typeof n < "u" && x !== null && x.setDraggable(n);
  }, [x, n]), h(() => {
    typeof r < "u" && x !== null && x.setEditable(r);
  }, [x, r]), h(() => {
    typeof o < "u" && x !== null && x.setVisible(o);
  }, [x, o]), h(() => {
    typeof i < "u" && x !== null && x.setPath(i);
  }, [x, i]), h(() => {
    x && a && (C !== null && google.maps.event.removeListener(C), P(google.maps.event.addListener(x, "dblclick", a)));
  }, [a]), h(() => {
    x && s && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(x, "dragend", s)));
  }, [s]), h(() => {
    x && l && (B !== null && google.maps.event.removeListener(B), N(google.maps.event.addListener(x, "dragstart", l)));
  }, [l]), h(() => {
    x && u && ($ !== null && google.maps.event.removeListener($), V(google.maps.event.addListener(x, "mousedown", u)));
  }, [u]), h(() => {
    x && c && (H !== null && google.maps.event.removeListener(H), Z(google.maps.event.addListener(x, "mousemove", c)));
  }, [c]), h(() => {
    x && p && (K !== null && google.maps.event.removeListener(K), Y(google.maps.event.addListener(x, "mouseout", p)));
  }, [p]), h(() => {
    x && d && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(x, "mouseover", d)));
  }, [d]), h(() => {
    x && g && (_ !== null && google.maps.event.removeListener(_), D(google.maps.event.addListener(x, "mouseup", g)));
  }, [g]), h(() => {
    x && f && (z !== null && google.maps.event.removeListener(z), S(google.maps.event.addListener(x, "rightclick", f)));
  }, [f]), h(() => {
    x && m && (W !== null && google.maps.event.removeListener(W), O(google.maps.event.addListener(x, "click", m)));
  }, [m]), h(() => {
    x && b && (j !== null && google.maps.event.removeListener(j), U(google.maps.event.addListener(x, "drag", b)));
  }, [b]), h(() => {
    var T = new google.maps.Polyline(Aw(Aw({}, t || P5e), {}, {
      map: M
    }));
    return i && T.setPath(i), typeof o < "u" && T.setVisible(o), typeof r < "u" && T.setEditable(r), typeof n < "u" && T.setDraggable(n), a && P(google.maps.event.addListener(T, "dblclick", a)), s && L(google.maps.event.addListener(T, "dragend", s)), l && N(google.maps.event.addListener(T, "dragstart", l)), u && V(google.maps.event.addListener(T, "mousedown", u)), c && Z(google.maps.event.addListener(T, "mousemove", c)), p && Y(google.maps.event.addListener(T, "mouseout", p)), d && J(google.maps.event.addListener(T, "mouseover", d)), g && D(google.maps.event.addListener(T, "mouseup", g)), f && S(google.maps.event.addListener(T, "rightclick", f)), m && O(google.maps.event.addListener(T, "click", m)), b && U(google.maps.event.addListener(T, "drag", b)), v(T), E && E(T), () => {
      C !== null && google.maps.event.removeListener(C), F !== null && google.maps.event.removeListener(F), B !== null && google.maps.event.removeListener(B), $ !== null && google.maps.event.removeListener($), H !== null && google.maps.event.removeListener(H), K !== null && google.maps.event.removeListener(K), Q !== null && google.maps.event.removeListener(Q), _ !== null && google.maps.event.removeListener(_), z !== null && google.maps.event.removeListener(z), W !== null && google.maps.event.removeListener(W), w && w(T), T.setMap(null);
    };
  }, []), null;
}
me(S5e);
class M5e extends pe {
  constructor() {
    super(...arguments), De(this, "registeredEvents", []), De(this, "state", {
      polyline: null
    }), De(this, "setPolylineCallback", () => {
      this.state.polyline !== null && this.props.onLoad && this.props.onLoad(this.state.polyline);
    });
  }
  componentDidMount() {
    var t = new google.maps.Polyline(Aw(Aw({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = On({
      updaterMap: Z8,
      eventMap: V8,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        polyline: t
      };
    }, this.setPolylineCallback);
  }
  componentDidUpdate(t) {
    this.state.polyline !== null && (Sn(this.registeredEvents), this.registeredEvents = On({
      updaterMap: Z8,
      eventMap: V8,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.polyline
    }));
  }
  componentWillUnmount() {
    this.state.polyline !== null && (this.props.onUnmount && this.props.onUnmount(this.state.polyline), Sn(this.registeredEvents), this.state.polyline.setMap(null));
  }
  render() {
    return null;
  }
}
De(M5e, "contextType", zt);
function q8(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function G8(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? q8(Object(n), !0).forEach(function(r) {
      De(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : q8(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var K8 = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, X8 = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  paths(e, t) {
    e.setPaths(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function D5e(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    paths: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: g,
    onMouseUp: f,
    onRightClick: m,
    onClick: b,
    onDrag: E,
    onLoad: w,
    onUnmount: M,
    onEdit: x
  } = e, v = ge(zt), [C, P] = k(null), [F, L] = k(null), [B, N] = k(null), [$, V] = k(null), [H, Z] = k(null), [K, Y] = k(null), [Q, J] = k(null), [_, D] = k(null), [z, S] = k(null), [W, O] = k(null), [j, U] = k(null), [T, q] = k(null);
  return h(() => {
    C !== null && C.setMap(v);
  }, [v]), h(() => {
    typeof t < "u" && C !== null && C.setOptions(t);
  }, [C, t]), h(() => {
    typeof n < "u" && C !== null && C.setDraggable(n);
  }, [C, n]), h(() => {
    typeof r < "u" && C !== null && C.setEditable(r);
  }, [C, r]), h(() => {
    typeof o < "u" && C !== null && C.setVisible(o);
  }, [C, o]), h(() => {
    typeof i < "u" && C !== null && C.setPath(i);
  }, [C, i]), h(() => {
    typeof a < "u" && C !== null && C.setPaths(a);
  }, [C, a]), h(() => {
    C && typeof s == "function" && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(C, "dblclick", s)));
  }, [s]), h(() => {
    C && (google.maps.event.addListener(C.getPath(), "insert_at", () => {
      x == null || x(C);
    }), google.maps.event.addListener(C.getPath(), "set_at", () => {
      x == null || x(C);
    }), google.maps.event.addListener(C.getPath(), "remove_at", () => {
      x == null || x(C);
    }));
  }, [C, x]), h(() => {
    C && typeof l == "function" && (B !== null && google.maps.event.removeListener(B), N(google.maps.event.addListener(C, "dragend", l)));
  }, [l]), h(() => {
    C && typeof u == "function" && ($ !== null && google.maps.event.removeListener($), V(google.maps.event.addListener(C, "dragstart", u)));
  }, [u]), h(() => {
    C && typeof c == "function" && (H !== null && google.maps.event.removeListener(H), Z(google.maps.event.addListener(C, "mousedown", c)));
  }, [c]), h(() => {
    C && typeof p == "function" && (K !== null && google.maps.event.removeListener(K), Y(google.maps.event.addListener(C, "mousemove", p)));
  }, [p]), h(() => {
    C && typeof d == "function" && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(C, "mouseout", d)));
  }, [d]), h(() => {
    C && typeof g == "function" && (_ !== null && google.maps.event.removeListener(_), D(google.maps.event.addListener(C, "mouseover", g)));
  }, [g]), h(() => {
    C && typeof f == "function" && (z !== null && google.maps.event.removeListener(z), S(google.maps.event.addListener(C, "mouseup", f)));
  }, [f]), h(() => {
    C && typeof m == "function" && (W !== null && google.maps.event.removeListener(W), O(google.maps.event.addListener(C, "rightclick", m)));
  }, [m]), h(() => {
    C && typeof b == "function" && (j !== null && google.maps.event.removeListener(j), U(google.maps.event.addListener(C, "click", b)));
  }, [b]), h(() => {
    C && typeof E == "function" && (T !== null && google.maps.event.removeListener(T), q(google.maps.event.addListener(C, "drag", E)));
  }, [E]), h(() => {
    var A = new google.maps.Polygon(G8(G8({}, t), {}, {
      map: v
    }));
    return i && A.setPath(i), a && A.setPaths(a), typeof o < "u" && A.setVisible(o), typeof r < "u" && A.setEditable(r), typeof n < "u" && A.setDraggable(n), s && L(google.maps.event.addListener(A, "dblclick", s)), l && N(google.maps.event.addListener(A, "dragend", l)), u && V(google.maps.event.addListener(A, "dragstart", u)), c && Z(google.maps.event.addListener(A, "mousedown", c)), p && Y(google.maps.event.addListener(A, "mousemove", p)), d && J(google.maps.event.addListener(A, "mouseout", d)), g && D(google.maps.event.addListener(A, "mouseover", g)), f && S(google.maps.event.addListener(A, "mouseup", f)), m && O(google.maps.event.addListener(A, "rightclick", m)), b && U(google.maps.event.addListener(A, "click", b)), E && q(google.maps.event.addListener(A, "drag", E)), P(A), w && w(A), () => {
      F !== null && google.maps.event.removeListener(F), B !== null && google.maps.event.removeListener(B), $ !== null && google.maps.event.removeListener($), H !== null && google.maps.event.removeListener(H), K !== null && google.maps.event.removeListener(K), Q !== null && google.maps.event.removeListener(Q), _ !== null && google.maps.event.removeListener(_), z !== null && google.maps.event.removeListener(z), W !== null && google.maps.event.removeListener(W), j !== null && google.maps.event.removeListener(j), M && M(A), A.setMap(null);
    };
  }, []), null;
}
me(D5e);
class T5e extends pe {
  constructor() {
    super(...arguments), De(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this.props.options || {};
    this.polygon = new google.maps.Polygon(t), this.polygon.setMap(this.context), this.registeredEvents = On({
      updaterMap: X8,
      eventMap: K8,
      prevProps: {},
      nextProps: this.props,
      instance: this.polygon
    }), this.props.onLoad && this.props.onLoad(this.polygon);
  }
  componentDidUpdate(t) {
    this.polygon && (Sn(this.registeredEvents), this.registeredEvents = On({
      updaterMap: X8,
      eventMap: K8,
      prevProps: t,
      nextProps: this.props,
      instance: this.polygon
    }));
  }
  componentWillUnmount() {
    this.polygon && (this.props.onUnmount && this.props.onUnmount(this.polygon), Sn(this.registeredEvents), this.polygon && this.polygon.setMap(null));
  }
  render() {
    return null;
  }
}
De(T5e, "contextType", zt);
function Y8(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Rw(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Y8(Object(n), !0).forEach(function(r) {
      De(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Y8(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var J8 = {
  onBoundsChanged: "bounds_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, Q8 = {
  bounds(e, t) {
    e.setBounds(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function j5e(e) {
  var {
    options: t,
    bounds: n,
    draggable: r,
    editable: o,
    visible: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: g,
    onRightClick: f,
    onClick: m,
    onDrag: b,
    onBoundsChanged: E,
    onLoad: w,
    onUnmount: M
  } = e, x = ge(zt), [v, C] = k(null), [P, F] = k(null), [L, B] = k(null), [N, $] = k(null), [V, H] = k(null), [Z, K] = k(null), [Y, Q] = k(null), [J, _] = k(null), [D, z] = k(null), [S, W] = k(null), [O, j] = k(null), [U, T] = k(null), [q, A] = k(null);
  return h(() => {
    v !== null && v.setMap(x);
  }, [x]), h(() => {
    typeof t < "u" && v !== null && v.setOptions(t);
  }, [v, t]), h(() => {
    typeof r < "u" && v !== null && v.setDraggable(r);
  }, [v, r]), h(() => {
    typeof o < "u" && v !== null && v.setEditable(o);
  }, [v, o]), h(() => {
    typeof i < "u" && v !== null && v.setVisible(i);
  }, [v, i]), h(() => {
    typeof n < "u" && v !== null && v.setBounds(n);
  }, [v, n]), h(() => {
    v && a && (P !== null && google.maps.event.removeListener(P), F(google.maps.event.addListener(v, "dblclick", a)));
  }, [a]), h(() => {
    v && s && (L !== null && google.maps.event.removeListener(L), B(google.maps.event.addListener(v, "dragend", s)));
  }, [s]), h(() => {
    v && l && (N !== null && google.maps.event.removeListener(N), $(google.maps.event.addListener(v, "dragstart", l)));
  }, [l]), h(() => {
    v && u && (V !== null && google.maps.event.removeListener(V), H(google.maps.event.addListener(v, "mousedown", u)));
  }, [u]), h(() => {
    v && c && (Z !== null && google.maps.event.removeListener(Z), K(google.maps.event.addListener(v, "mousemove", c)));
  }, [c]), h(() => {
    v && p && (Y !== null && google.maps.event.removeListener(Y), Q(google.maps.event.addListener(v, "mouseout", p)));
  }, [p]), h(() => {
    v && d && (J !== null && google.maps.event.removeListener(J), _(google.maps.event.addListener(v, "mouseover", d)));
  }, [d]), h(() => {
    v && g && (D !== null && google.maps.event.removeListener(D), z(google.maps.event.addListener(v, "mouseup", g)));
  }, [g]), h(() => {
    v && f && (S !== null && google.maps.event.removeListener(S), W(google.maps.event.addListener(v, "rightclick", f)));
  }, [f]), h(() => {
    v && m && (O !== null && google.maps.event.removeListener(O), j(google.maps.event.addListener(v, "click", m)));
  }, [m]), h(() => {
    v && b && (U !== null && google.maps.event.removeListener(U), T(google.maps.event.addListener(v, "drag", b)));
  }, [b]), h(() => {
    v && E && (q !== null && google.maps.event.removeListener(q), A(google.maps.event.addListener(v, "bounds_changed", E)));
  }, [E]), h(() => {
    var X = new google.maps.Rectangle(Rw(Rw({}, t), {}, {
      map: x
    }));
    return typeof i < "u" && X.setVisible(i), typeof o < "u" && X.setEditable(o), typeof r < "u" && X.setDraggable(r), typeof n < "u" && X.setBounds(n), a && F(google.maps.event.addListener(X, "dblclick", a)), s && B(google.maps.event.addListener(X, "dragend", s)), l && $(google.maps.event.addListener(X, "dragstart", l)), u && H(google.maps.event.addListener(X, "mousedown", u)), c && K(google.maps.event.addListener(X, "mousemove", c)), p && Q(google.maps.event.addListener(X, "mouseout", p)), d && _(google.maps.event.addListener(X, "mouseover", d)), g && z(google.maps.event.addListener(X, "mouseup", g)), f && W(google.maps.event.addListener(X, "rightclick", f)), m && j(google.maps.event.addListener(X, "click", m)), b && T(google.maps.event.addListener(X, "drag", b)), E && A(google.maps.event.addListener(X, "bounds_changed", E)), C(X), w && w(X), () => {
      P !== null && google.maps.event.removeListener(P), L !== null && google.maps.event.removeListener(L), N !== null && google.maps.event.removeListener(N), V !== null && google.maps.event.removeListener(V), Z !== null && google.maps.event.removeListener(Z), Y !== null && google.maps.event.removeListener(Y), J !== null && google.maps.event.removeListener(J), D !== null && google.maps.event.removeListener(D), S !== null && google.maps.event.removeListener(S), O !== null && google.maps.event.removeListener(O), U !== null && google.maps.event.removeListener(U), q !== null && google.maps.event.removeListener(q), M && M(X), X.setMap(null);
    };
  }, []), null;
}
me(j5e);
class A5e extends pe {
  constructor() {
    super(...arguments), De(this, "registeredEvents", []), De(this, "state", {
      rectangle: null
    }), De(this, "setRectangleCallback", () => {
      this.state.rectangle !== null && this.props.onLoad && this.props.onLoad(this.state.rectangle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Rectangle(Rw(Rw({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = On({
      updaterMap: Q8,
      eventMap: J8,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        rectangle: t
      };
    }, this.setRectangleCallback);
  }
  componentDidUpdate(t) {
    this.state.rectangle !== null && (Sn(this.registeredEvents), this.registeredEvents = On({
      updaterMap: Q8,
      eventMap: J8,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.rectangle
    }));
  }
  componentWillUnmount() {
    this.state.rectangle !== null && (this.props.onUnmount && this.props.onUnmount(this.state.rectangle), Sn(this.registeredEvents), this.state.rectangle.setMap(null));
  }
  render() {
    return null;
  }
}
De(A5e, "contextType", zt);
function e5(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Iw(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? e5(Object(n), !0).forEach(function(r) {
      De(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : e5(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var t5 = {
  onCenterChanged: "center_changed",
  onRadiusChanged: "radius_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, n5 = {
  center(e, t) {
    e.setCenter(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  radius(e, t) {
    e.setRadius(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, R5e = {};
function I5e(e) {
  var {
    options: t,
    center: n,
    radius: r,
    draggable: o,
    editable: i,
    visible: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: g,
    onMouseUp: f,
    onRightClick: m,
    onClick: b,
    onDrag: E,
    onCenterChanged: w,
    onRadiusChanged: M,
    onLoad: x,
    onUnmount: v
  } = e, C = ge(zt), [P, F] = k(null), [L, B] = k(null), [N, $] = k(null), [V, H] = k(null), [Z, K] = k(null), [Y, Q] = k(null), [J, _] = k(null), [D, z] = k(null), [S, W] = k(null), [O, j] = k(null), [U, T] = k(null), [q, A] = k(null), [X, I] = k(null), [le, he] = k(null);
  return h(() => {
    P !== null && P.setMap(C);
  }, [C]), h(() => {
    typeof t < "u" && P !== null && P.setOptions(t);
  }, [P, t]), h(() => {
    typeof o < "u" && P !== null && P.setDraggable(o);
  }, [P, o]), h(() => {
    typeof i < "u" && P !== null && P.setEditable(i);
  }, [P, i]), h(() => {
    typeof a < "u" && P !== null && P.setVisible(a);
  }, [P, a]), h(() => {
    typeof r == "number" && P !== null && P.setRadius(r);
  }, [P, r]), h(() => {
    typeof n < "u" && P !== null && P.setCenter(n);
  }, [P, n]), h(() => {
    P && s && (L !== null && google.maps.event.removeListener(L), B(google.maps.event.addListener(P, "dblclick", s)));
  }, [s]), h(() => {
    P && l && (N !== null && google.maps.event.removeListener(N), $(google.maps.event.addListener(P, "dragend", l)));
  }, [l]), h(() => {
    P && u && (V !== null && google.maps.event.removeListener(V), H(google.maps.event.addListener(P, "dragstart", u)));
  }, [u]), h(() => {
    P && c && (Z !== null && google.maps.event.removeListener(Z), K(google.maps.event.addListener(P, "mousedown", c)));
  }, [c]), h(() => {
    P && p && (Y !== null && google.maps.event.removeListener(Y), Q(google.maps.event.addListener(P, "mousemove", p)));
  }, [p]), h(() => {
    P && d && (J !== null && google.maps.event.removeListener(J), _(google.maps.event.addListener(P, "mouseout", d)));
  }, [d]), h(() => {
    P && g && (D !== null && google.maps.event.removeListener(D), z(google.maps.event.addListener(P, "mouseover", g)));
  }, [g]), h(() => {
    P && f && (S !== null && google.maps.event.removeListener(S), W(google.maps.event.addListener(P, "mouseup", f)));
  }, [f]), h(() => {
    P && m && (O !== null && google.maps.event.removeListener(O), j(google.maps.event.addListener(P, "rightclick", m)));
  }, [m]), h(() => {
    P && b && (U !== null && google.maps.event.removeListener(U), T(google.maps.event.addListener(P, "click", b)));
  }, [b]), h(() => {
    P && E && (q !== null && google.maps.event.removeListener(q), A(google.maps.event.addListener(P, "drag", E)));
  }, [E]), h(() => {
    P && w && (X !== null && google.maps.event.removeListener(X), I(google.maps.event.addListener(P, "center_changed", w)));
  }, [b]), h(() => {
    P && M && (le !== null && google.maps.event.removeListener(le), he(google.maps.event.addListener(P, "radius_changed", M)));
  }, [M]), h(() => {
    var oe = new google.maps.Circle(Iw(Iw({}, t || R5e), {}, {
      map: C
    }));
    return typeof r == "number" && oe.setRadius(r), typeof n < "u" && oe.setCenter(n), typeof r == "number" && oe.setRadius(r), typeof a < "u" && oe.setVisible(a), typeof i < "u" && oe.setEditable(i), typeof o < "u" && oe.setDraggable(o), s && B(google.maps.event.addListener(oe, "dblclick", s)), l && $(google.maps.event.addListener(oe, "dragend", l)), u && H(google.maps.event.addListener(oe, "dragstart", u)), c && K(google.maps.event.addListener(oe, "mousedown", c)), p && Q(google.maps.event.addListener(oe, "mousemove", p)), d && _(google.maps.event.addListener(oe, "mouseout", d)), g && z(google.maps.event.addListener(oe, "mouseover", g)), f && W(google.maps.event.addListener(oe, "mouseup", f)), m && j(google.maps.event.addListener(oe, "rightclick", m)), b && T(google.maps.event.addListener(oe, "click", b)), E && A(google.maps.event.addListener(oe, "drag", E)), w && I(google.maps.event.addListener(oe, "center_changed", w)), M && he(google.maps.event.addListener(oe, "radius_changed", M)), F(oe), x && x(oe), () => {
      L !== null && google.maps.event.removeListener(L), N !== null && google.maps.event.removeListener(N), V !== null && google.maps.event.removeListener(V), Z !== null && google.maps.event.removeListener(Z), Y !== null && google.maps.event.removeListener(Y), J !== null && google.maps.event.removeListener(J), D !== null && google.maps.event.removeListener(D), S !== null && google.maps.event.removeListener(S), O !== null && google.maps.event.removeListener(O), U !== null && google.maps.event.removeListener(U), X !== null && google.maps.event.removeListener(X), le !== null && google.maps.event.removeListener(le), v && v(oe), oe.setMap(null);
    };
  }, []), null;
}
me(I5e);
class N5e extends pe {
  constructor() {
    super(...arguments), De(this, "registeredEvents", []), De(this, "state", {
      circle: null
    }), De(this, "setCircleCallback", () => {
      this.state.circle !== null && this.props.onLoad && this.props.onLoad(this.state.circle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Circle(Iw(Iw({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = On({
      updaterMap: n5,
      eventMap: t5,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        circle: t
      };
    }, this.setCircleCallback);
  }
  componentDidUpdate(t) {
    this.state.circle !== null && (Sn(this.registeredEvents), this.registeredEvents = On({
      updaterMap: n5,
      eventMap: t5,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.circle
    }));
  }
  componentWillUnmount() {
    if (this.state.circle !== null) {
      var t;
      this.props.onUnmount && this.props.onUnmount(this.state.circle), Sn(this.registeredEvents), (t = this.state.circle) === null || t === void 0 || t.setMap(null);
    }
  }
  render() {
    return null;
  }
}
De(N5e, "contextType", zt);
function r5(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Nw(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? r5(Object(n), !0).forEach(function(r) {
      De(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : r5(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var o5 = {
  onClick: "click",
  onDblClick: "dblclick",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onAddFeature: "addfeature",
  onRemoveFeature: "removefeature",
  onRemoveProperty: "removeproperty",
  onSetGeometry: "setgeometry",
  onSetProperty: "setproperty"
}, i5 = {
  add(e, t) {
    e.add(t);
  },
  addgeojson(e, t, n) {
    e.addGeoJson(t, n);
  },
  contains(e, t) {
    e.contains(t);
  },
  foreach(e, t) {
    e.forEach(t);
  },
  loadgeojson(e, t, n, r) {
    e.loadGeoJson(t, n, r);
  },
  overridestyle(e, t, n) {
    e.overrideStyle(t, n);
  },
  remove(e, t) {
    e.remove(t);
  },
  revertstyle(e, t) {
    e.revertStyle(t);
  },
  controlposition(e, t) {
    e.setControlPosition(t);
  },
  controls(e, t) {
    e.setControls(t);
  },
  drawingmode(e, t) {
    e.setDrawingMode(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  style(e, t) {
    e.setStyle(t);
  },
  togeojson(e, t) {
    e.toGeoJson(t);
  }
};
function B5e(e) {
  var {
    options: t,
    onClick: n,
    onDblClick: r,
    onMouseDown: o,
    onMouseMove: i,
    onMouseOut: a,
    onMouseOver: s,
    onMouseUp: l,
    onRightClick: u,
    onAddFeature: c,
    onRemoveFeature: p,
    onRemoveProperty: d,
    onSetGeometry: g,
    onSetProperty: f,
    onLoad: m,
    onUnmount: b
  } = e, E = ge(zt), [w, M] = k(null), [x, v] = k(null), [C, P] = k(null), [F, L] = k(null), [B, N] = k(null), [$, V] = k(null), [H, Z] = k(null), [K, Y] = k(null), [Q, J] = k(null), [_, D] = k(null), [z, S] = k(null), [W, O] = k(null), [j, U] = k(null), [T, q] = k(null);
  return h(() => {
    w !== null && w.setMap(E);
  }, [E]), h(() => {
    w && r && (x !== null && google.maps.event.removeListener(x), v(google.maps.event.addListener(w, "dblclick", r)));
  }, [r]), h(() => {
    w && o && (C !== null && google.maps.event.removeListener(C), P(google.maps.event.addListener(w, "mousedown", o)));
  }, [o]), h(() => {
    w && i && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(w, "mousemove", i)));
  }, [i]), h(() => {
    w && a && (B !== null && google.maps.event.removeListener(B), N(google.maps.event.addListener(w, "mouseout", a)));
  }, [a]), h(() => {
    w && s && ($ !== null && google.maps.event.removeListener($), V(google.maps.event.addListener(w, "mouseover", s)));
  }, [s]), h(() => {
    w && l && (H !== null && google.maps.event.removeListener(H), Z(google.maps.event.addListener(w, "mouseup", l)));
  }, [l]), h(() => {
    w && u && (K !== null && google.maps.event.removeListener(K), Y(google.maps.event.addListener(w, "rightclick", u)));
  }, [u]), h(() => {
    w && n && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(w, "click", n)));
  }, [n]), h(() => {
    w && c && (_ !== null && google.maps.event.removeListener(_), D(google.maps.event.addListener(w, "addfeature", c)));
  }, [c]), h(() => {
    w && p && (z !== null && google.maps.event.removeListener(z), S(google.maps.event.addListener(w, "removefeature", p)));
  }, [p]), h(() => {
    w && d && (W !== null && google.maps.event.removeListener(W), O(google.maps.event.addListener(w, "removeproperty", d)));
  }, [d]), h(() => {
    w && g && (j !== null && google.maps.event.removeListener(j), U(google.maps.event.addListener(w, "setgeometry", g)));
  }, [g]), h(() => {
    w && f && (T !== null && google.maps.event.removeListener(T), q(google.maps.event.addListener(w, "setproperty", f)));
  }, [f]), h(() => {
    if (E !== null) {
      var A = new google.maps.Data(Nw(Nw({}, t), {}, {
        map: E
      }));
      r && v(google.maps.event.addListener(A, "dblclick", r)), o && P(google.maps.event.addListener(A, "mousedown", o)), i && L(google.maps.event.addListener(A, "mousemove", i)), a && N(google.maps.event.addListener(A, "mouseout", a)), s && V(google.maps.event.addListener(A, "mouseover", s)), l && Z(google.maps.event.addListener(A, "mouseup", l)), u && Y(google.maps.event.addListener(A, "rightclick", u)), n && J(google.maps.event.addListener(A, "click", n)), c && D(google.maps.event.addListener(A, "addfeature", c)), p && S(google.maps.event.addListener(A, "removefeature", p)), d && O(google.maps.event.addListener(A, "removeproperty", d)), g && U(google.maps.event.addListener(A, "setgeometry", g)), f && q(google.maps.event.addListener(A, "setproperty", f)), M(A), m && m(A);
    }
    return () => {
      w && (x !== null && google.maps.event.removeListener(x), C !== null && google.maps.event.removeListener(C), F !== null && google.maps.event.removeListener(F), B !== null && google.maps.event.removeListener(B), $ !== null && google.maps.event.removeListener($), H !== null && google.maps.event.removeListener(H), K !== null && google.maps.event.removeListener(K), Q !== null && google.maps.event.removeListener(Q), _ !== null && google.maps.event.removeListener(_), z !== null && google.maps.event.removeListener(z), W !== null && google.maps.event.removeListener(W), j !== null && google.maps.event.removeListener(j), T !== null && google.maps.event.removeListener(T), b && b(w), w.setMap(null));
    };
  }, []), null;
}
me(B5e);
class F5e extends pe {
  constructor() {
    super(...arguments), De(this, "registeredEvents", []), De(this, "state", {
      data: null
    }), De(this, "setDataCallback", () => {
      this.state.data !== null && this.props.onLoad && this.props.onLoad(this.state.data);
    });
  }
  componentDidMount() {
    if (this.context !== null) {
      var t = new google.maps.Data(Nw(Nw({}, this.props.options), {}, {
        map: this.context
      }));
      this.registeredEvents = On({
        updaterMap: i5,
        eventMap: o5,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        data: t
      }), this.setDataCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.data !== null && (Sn(this.registeredEvents), this.registeredEvents = On({
      updaterMap: i5,
      eventMap: o5,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.data
    }));
  }
  componentWillUnmount() {
    this.state.data !== null && (this.props.onUnmount && this.props.onUnmount(this.state.data), Sn(this.registeredEvents), this.state.data && this.state.data.setMap(null));
  }
  render() {
    return null;
  }
}
De(F5e, "contextType", zt);
function s5(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function a5(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? s5(Object(n), !0).forEach(function(r) {
      De(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : s5(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var l5 = {
  onClick: "click",
  onDefaultViewportChanged: "defaultviewport_changed",
  onStatusChanged: "status_changed"
}, u5 = {
  options(e, t) {
    e.setOptions(t);
  },
  url(e, t) {
    e.setUrl(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
class z5e extends pe {
  constructor() {
    super(...arguments), De(this, "registeredEvents", []), De(this, "state", {
      kmlLayer: null
    }), De(this, "setKmlLayerCallback", () => {
      this.state.kmlLayer !== null && this.props.onLoad && this.props.onLoad(this.state.kmlLayer);
    });
  }
  componentDidMount() {
    var t = new google.maps.KmlLayer(a5(a5({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = On({
      updaterMap: u5,
      eventMap: l5,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        kmlLayer: t
      };
    }, this.setKmlLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.kmlLayer !== null && (Sn(this.registeredEvents), this.registeredEvents = On({
      updaterMap: u5,
      eventMap: l5,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.kmlLayer
    }));
  }
  componentWillUnmount() {
    this.state.kmlLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.kmlLayer), Sn(this.registeredEvents), this.state.kmlLayer.setMap(null));
  }
  render() {
    return null;
  }
}
De(z5e, "contextType", zt);
function Qre(e, t) {
  return typeof t == "function" ? t(e.offsetWidth, e.offsetHeight) : {
    x: 0,
    y: 0
  };
}
function U5e(e, t) {
  return new t(e.lat, e.lng);
}
function H5e(e, t) {
  return new t(new google.maps.LatLng(e.ne.lat, e.ne.lng), new google.maps.LatLng(e.sw.lat, e.sw.lng));
}
function W5e(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function $5e(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function V5e(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n.getNorthEast()), o = e && e.fromLatLngToDivPixel(n.getSouthWest());
  return r && o ? {
    left: "".concat(o.x + t.x, "px"),
    top: "".concat(r.y + t.y, "px"),
    width: "".concat(r.x - o.x - t.x, "px"),
    height: "".concat(o.y - r.y - t.y, "px")
  } : {
    left: "-9999px",
    top: "-9999px"
  };
}
function Z5e(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n);
  if (r) {
    var {
      x: o,
      y: i
    } = r;
    return {
      left: "".concat(o + t.x, "px"),
      top: "".concat(i + t.y, "px")
    };
  }
  return {
    left: "-9999px",
    top: "-9999px"
  };
}
function eoe(e, t, n, r) {
  return n !== void 0 ? V5e(e, t, $5e(n, google.maps.LatLngBounds, H5e)) : Z5e(e, t, W5e(r, google.maps.LatLng, U5e));
}
function q5e(e, t) {
  return e.left === t.left && e.top === t.top && e.width === t.height && e.height === t.height;
}
function c5(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function G5e(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? c5(Object(n), !0).forEach(function(r) {
      De(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : c5(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function K5e(e, t, n, r, o) {
  class i extends google.maps.OverlayView {
    constructor(s, l, u, c) {
      super(), this.container = s, this.pane = l, this.position = u, this.bounds = c;
    }
    onAdd() {
      var s, l = (s = this.getPanes()) === null || s === void 0 ? void 0 : s[this.pane];
      l == null || l.appendChild(this.container);
    }
    draw() {
      var s = this.getProjection(), l = G5e({}, this.container ? Qre(this.container, o) : {
        x: 0,
        y: 0
      }), u = eoe(s, l, this.bounds, this.position);
      for (var [c, p] of Object.entries(u))
        this.container.style[c] = p;
    }
    onRemove() {
      this.container.parentNode !== null && this.container.parentNode.removeChild(this.container);
    }
  }
  return new i(e, t, n, r);
}
function p5(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function X5e(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? p5(Object(n), !0).forEach(function(r) {
      De(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : p5(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function d5(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLng ? e : new google.maps.LatLng(e.lat, e.lng);
  return t + "";
}
function f5(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLngBounds ? e : new google.maps.LatLngBounds(new google.maps.LatLng(e.south, e.east), new google.maps.LatLng(e.north, e.west));
  return t + "";
}
function Y5e(e) {
  var {
    position: t,
    bounds: n,
    mapPaneName: r,
    zIndex: o,
    onLoad: i,
    onUnmount: a,
    getPixelPositionOffset: s,
    children: l
  } = e, u = ge(zt), c = ln(() => {
    var d = document.createElement("div");
    return d.style.position = "absolute", d;
  }, []), p = ln(() => K5e(c, r, t, n, s), [c, r, t, n]);
  return h(() => (i == null || i(p), p == null || p.setMap(u), () => {
    a == null || a(p), p == null || p.setMap(null);
  }), [u, p]), h(() => {
    c.style.zIndex = "".concat(o);
  }, [o, c]), wi.createPortal(l, c);
}
me(Y5e);
class Kp extends pe {
  constructor(t) {
    super(t), De(this, "state", {
      paneEl: null,
      containerStyle: {
        // set initial position
        position: "absolute"
      }
    }), De(this, "updatePane", () => {
      var r = this.props.mapPaneName, o = this.overlayView.getPanes();
      Zo(!!r, "OverlayView requires props.mapPaneName but got %s", r), o ? this.setState({
        paneEl: o[r]
      }) : this.setState({
        paneEl: null
      });
    }), De(this, "onAdd", () => {
      var r, o;
      this.updatePane(), (r = (o = this.props).onLoad) === null || r === void 0 || r.call(o, this.overlayView);
    }), De(this, "onPositionElement", () => {
      var r = this.overlayView.getProjection(), o = X5e({
        x: 0,
        y: 0
      }, this.containerRef.current ? Qre(this.containerRef.current, this.props.getPixelPositionOffset) : {}), i = eoe(r, o, this.props.bounds, this.props.position);
      if (!q5e(i, {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        left: this.state.containerStyle.left,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        top: this.state.containerStyle.top,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        width: this.state.containerStyle.width,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        height: this.state.containerStyle.height
      })) {
        var a, s, l, u;
        this.setState({
          containerStyle: {
            top: (a = i.top) !== null && a !== void 0 ? a : 0,
            left: (s = i.left) !== null && s !== void 0 ? s : 0,
            width: (l = i.width) !== null && l !== void 0 ? l : 0,
            height: (u = i.height) !== null && u !== void 0 ? u : 0,
            position: "absolute"
          }
        });
      }
    }), De(this, "draw", () => {
      this.onPositionElement();
    }), De(this, "onRemove", () => {
      var r, o;
      this.setState(() => ({
        paneEl: null
      })), (r = (o = this.props).onUnmount) === null || r === void 0 || r.call(o, this.overlayView);
    }), this.containerRef = so();
    var n = new google.maps.OverlayView();
    n.onAdd = this.onAdd, n.draw = this.draw, n.onRemove = this.onRemove, this.overlayView = n;
  }
  componentDidMount() {
    this.overlayView.setMap(this.context);
  }
  componentDidUpdate(t) {
    var n = d5(t.position), r = d5(this.props.position), o = f5(t.bounds), i = f5(this.props.bounds);
    (n !== r || o !== i) && this.overlayView.draw(), t.mapPaneName !== this.props.mapPaneName && this.updatePane();
  }
  componentWillUnmount() {
    this.overlayView.setMap(null);
  }
  render() {
    var t = this.state.paneEl;
    return t ? wi.createPortal(Yo.jsx("div", {
      ref: this.containerRef,
      style: this.state.containerStyle,
      children: at.only(this.props.children)
    }), t) : null;
  }
}
De(Kp, "FLOAT_PANE", "floatPane");
De(Kp, "MAP_PANE", "mapPane");
De(Kp, "MARKER_LAYER", "markerLayer");
De(Kp, "OVERLAY_LAYER", "overlayLayer");
De(Kp, "OVERLAY_MOUSE_TARGET", "overlayMouseTarget");
De(Kp, "contextType", zt);
function J5e() {
}
function h5(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function g5(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? h5(Object(n), !0).forEach(function(r) {
      De(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : h5(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var m5 = {
  onDblClick: "dblclick",
  onClick: "click"
}, v5 = {
  opacity(e, t) {
    e.setOpacity(t);
  }
};
function Q5e(e) {
  var {
    url: t,
    bounds: n,
    options: r,
    visible: o
  } = e, i = ge(zt), a = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east)), s = ln(() => new google.maps.GroundOverlay(t, a, r), []);
  return h(() => {
    s !== null && s.setMap(i);
  }, [i]), h(() => {
    typeof t < "u" && s !== null && (s.set("url", t), s.setMap(i));
  }, [s, t]), h(() => {
    typeof o < "u" && s !== null && s.setOpacity(o ? 1 : 0);
  }, [s, o]), h(() => {
    var l = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east));
    typeof n < "u" && s !== null && (s.set("bounds", l), s.setMap(i));
  }, [s, n]), null;
}
me(Q5e);
class toe extends pe {
  constructor() {
    super(...arguments), De(this, "registeredEvents", []), De(this, "state", {
      groundOverlay: null
    }), De(this, "setGroundOverlayCallback", () => {
      this.state.groundOverlay !== null && this.props.onLoad && this.props.onLoad(this.state.groundOverlay);
    });
  }
  componentDidMount() {
    Zo(!!this.props.url || !!this.props.bounds, "For GroundOverlay, url and bounds are passed in to constructor and are immutable after instantiated. This is the behavior of Google Maps JavaScript API v3 ( See https://developers.google.com/maps/documentation/javascript/reference#GroundOverlay) Hence, use the corresponding two props provided by `react-google-maps-api`, url and bounds. In some cases, you'll need the GroundOverlay component to reflect the changes of url and bounds. You can leverage the React's key property to remount the component. Typically, just `key={url}` would serve your need. See https://github.com/tomchentw/react-google-maps/issues/655");
    var t = new google.maps.GroundOverlay(this.props.url, this.props.bounds, g5(g5({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = On({
      updaterMap: v5,
      eventMap: m5,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        groundOverlay: t
      };
    }, this.setGroundOverlayCallback);
  }
  componentDidUpdate(t) {
    this.state.groundOverlay !== null && (Sn(this.registeredEvents), this.registeredEvents = On({
      updaterMap: v5,
      eventMap: m5,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.groundOverlay
    }));
  }
  componentWillUnmount() {
    this.state.groundOverlay && (this.props.onUnmount && this.props.onUnmount(this.state.groundOverlay), this.state.groundOverlay.setMap(null));
  }
  render() {
    return null;
  }
}
De(toe, "defaultProps", {
  onLoad: J5e
});
De(toe, "contextType", zt);
function y5(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Bw(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? y5(Object(n), !0).forEach(function(r) {
      De(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : y5(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var b5 = {}, w5 = {
  data(e, t) {
    e.setData(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function e4e(e) {
  var {
    data: t,
    onLoad: n,
    onUnmount: r,
    options: o
  } = e, i = ge(zt), [a, s] = k(null);
  return h(() => {
    google.maps.visualization || Zo(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} in useJsApiScript? %s', google.maps.visualization);
  }, []), h(() => {
    Zo(!!t, "data property is required in HeatmapLayer %s", t);
  }, [t]), h(() => {
    a !== null && a.setMap(i);
  }, [i]), h(() => {
    o && a !== null && a.setOptions(o);
  }, [a, o]), h(() => {
    var l = new google.maps.visualization.HeatmapLayer(Bw(Bw({}, o), {}, {
      data: t,
      map: i
    }));
    return s(l), n && n(l), () => {
      a !== null && (r && r(a), a.setMap(null));
    };
  }, []), null;
}
me(e4e);
class t4e extends pe {
  constructor() {
    super(...arguments), De(this, "registeredEvents", []), De(this, "state", {
      heatmapLayer: null
    }), De(this, "setHeatmapLayerCallback", () => {
      this.state.heatmapLayer !== null && this.props.onLoad && this.props.onLoad(this.state.heatmapLayer);
    });
  }
  componentDidMount() {
    Zo(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} to <LoadScript />? %s', google.maps.visualization), Zo(!!this.props.data, "data property is required in HeatmapLayer %s", this.props.data);
    var t = new google.maps.visualization.HeatmapLayer(Bw(Bw({}, this.props.options), {}, {
      data: this.props.data,
      map: this.context
    }));
    this.registeredEvents = On({
      updaterMap: w5,
      eventMap: b5,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        heatmapLayer: t
      };
    }, this.setHeatmapLayerCallback);
  }
  componentDidUpdate(t) {
    Sn(this.registeredEvents), this.registeredEvents = On({
      updaterMap: w5,
      eventMap: b5,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.heatmapLayer
    });
  }
  componentWillUnmount() {
    this.state.heatmapLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.heatmapLayer), Sn(this.registeredEvents), this.state.heatmapLayer.setMap(null));
  }
  render() {
    return null;
  }
}
De(t4e, "contextType", zt);
var C5 = {
  onCloseClick: "closeclick",
  onPanoChanged: "pano_changed",
  onPositionChanged: "position_changed",
  onPovChanged: "pov_changed",
  onResize: "resize",
  onStatusChanged: "status_changed",
  onVisibleChanged: "visible_changed",
  onZoomChanged: "zoom_changed"
}, O5 = {
  register(e, t, n) {
    e.registerPanoProvider(t, n);
  },
  links(e, t) {
    e.setLinks(t);
  },
  motionTracking(e, t) {
    e.setMotionTracking(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  pano(e, t) {
    e.setPano(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  pov(e, t) {
    e.setPov(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zoom(e, t) {
    e.setZoom(t);
  }
};
class n4e extends pe {
  constructor() {
    super(...arguments), De(this, "registeredEvents", []), De(this, "state", {
      streetViewPanorama: null
    }), De(this, "setStreetViewPanoramaCallback", () => {
      this.state.streetViewPanorama !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewPanorama);
    });
  }
  componentDidMount() {
    var t, n, r = (t = (n = this.context) === null || n === void 0 ? void 0 : n.getStreetView()) !== null && t !== void 0 ? t : null;
    this.registeredEvents = On({
      updaterMap: O5,
      eventMap: C5,
      prevProps: {},
      nextProps: this.props,
      instance: r
    }), this.setState(() => ({
      streetViewPanorama: r
    }), this.setStreetViewPanoramaCallback);
  }
  componentDidUpdate(t) {
    this.state.streetViewPanorama !== null && (Sn(this.registeredEvents), this.registeredEvents = On({
      updaterMap: O5,
      eventMap: C5,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.streetViewPanorama
    }));
  }
  componentWillUnmount() {
    this.state.streetViewPanorama !== null && (this.props.onUnmount && this.props.onUnmount(this.state.streetViewPanorama), Sn(this.registeredEvents), this.state.streetViewPanorama.setVisible(!1));
  }
  render() {
    return null;
  }
}
De(n4e, "contextType", zt);
class r4e extends pe {
  constructor() {
    super(...arguments), De(this, "state", {
      streetViewService: null
    }), De(this, "setStreetViewServiceCallback", () => {
      this.state.streetViewService !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewService);
    });
  }
  componentDidMount() {
    var t = new google.maps.StreetViewService();
    this.setState(function() {
      return {
        streetViewService: t
      };
    }, this.setStreetViewServiceCallback);
  }
  componentWillUnmount() {
    this.state.streetViewService !== null && this.props.onUnmount && this.props.onUnmount(this.state.streetViewService);
  }
  render() {
    return null;
  }
}
De(r4e, "contextType", zt);
var x5 = {
  onDirectionsChanged: "directions_changed"
}, E5 = {
  directions(e, t) {
    e.setDirections(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  panel(e, t) {
    e.setPanel(t);
  },
  routeIndex(e, t) {
    e.setRouteIndex(t);
  }
};
class o4e extends pe {
  constructor() {
    super(...arguments), De(this, "registeredEvents", []), De(this, "state", {
      directionsRenderer: null
    }), De(this, "setDirectionsRendererCallback", () => {
      this.state.directionsRenderer !== null && (this.state.directionsRenderer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.directionsRenderer));
    });
  }
  componentDidMount() {
    var t = new google.maps.DirectionsRenderer(this.props.options);
    this.registeredEvents = On({
      updaterMap: E5,
      eventMap: x5,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        directionsRenderer: t
      };
    }, this.setDirectionsRendererCallback);
  }
  componentDidUpdate(t) {
    this.state.directionsRenderer !== null && (Sn(this.registeredEvents), this.registeredEvents = On({
      updaterMap: E5,
      eventMap: x5,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.directionsRenderer
    }));
  }
  componentWillUnmount() {
    this.state.directionsRenderer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.directionsRenderer), Sn(this.registeredEvents), this.state.directionsRenderer && this.state.directionsRenderer.setMap(null));
  }
  render() {
    return null;
  }
}
De(o4e, "contextType", zt);
var k5 = {
  onPlacesChanged: "places_changed"
}, L5 = {
  bounds(e, t) {
    e.setBounds(t);
  }
};
class i4e extends pe {
  constructor() {
    super(...arguments), De(this, "registeredEvents", []), De(this, "containerElement", so()), De(this, "state", {
      searchBox: null
    }), De(this, "setSearchBoxCallback", () => {
      this.state.searchBox !== null && this.props.onLoad && this.props.onLoad(this.state.searchBox);
    });
  }
  componentDidMount() {
    if (Zo(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places), this.containerElement !== null && this.containerElement.current !== null) {
      var t = this.containerElement.current.querySelector("input");
      if (t !== null) {
        var n = new google.maps.places.SearchBox(t, this.props.options);
        this.registeredEvents = On({
          updaterMap: L5,
          eventMap: k5,
          prevProps: {},
          nextProps: this.props,
          instance: n
        }), this.setState(function() {
          return {
            searchBox: n
          };
        }, this.setSearchBoxCallback);
      }
    }
  }
  componentDidUpdate(t) {
    this.state.searchBox !== null && (Sn(this.registeredEvents), this.registeredEvents = On({
      updaterMap: L5,
      eventMap: k5,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.searchBox
    }));
  }
  componentWillUnmount() {
    this.state.searchBox !== null && (this.props.onUnmount && this.props.onUnmount(this.state.searchBox), Sn(this.registeredEvents));
  }
  render() {
    return Yo.jsx("div", {
      ref: this.containerElement,
      children: at.only(this.props.children)
    });
  }
}
De(i4e, "contextType", zt);
var _5 = {
  onPlaceChanged: "place_changed"
}, P5 = {
  bounds(e, t) {
    e.setBounds(t);
  },
  restrictions(e, t) {
    e.setComponentRestrictions(t);
  },
  fields(e, t) {
    e.setFields(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  types(e, t) {
    e.setTypes(t);
  }
};
class noe extends pe {
  constructor() {
    super(...arguments), De(this, "registeredEvents", []), De(this, "containerElement", so()), De(this, "state", {
      autocomplete: null
    }), De(this, "setAutocompleteCallback", () => {
      this.state.autocomplete !== null && this.props.onLoad && this.props.onLoad(this.state.autocomplete);
    });
  }
  componentDidMount() {
    var t;
    Zo(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places);
    var n = (t = this.containerElement.current) === null || t === void 0 ? void 0 : t.querySelector("input");
    if (n) {
      var r = new google.maps.places.Autocomplete(n, this.props.options);
      this.registeredEvents = On({
        updaterMap: P5,
        eventMap: _5,
        prevProps: {},
        nextProps: this.props,
        instance: r
      }), this.setState(() => ({
        autocomplete: r
      }), this.setAutocompleteCallback);
    }
  }
  componentDidUpdate(t) {
    Sn(this.registeredEvents), this.registeredEvents = On({
      updaterMap: P5,
      eventMap: _5,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.autocomplete
    });
  }
  componentWillUnmount() {
    this.state.autocomplete !== null && Sn(this.registeredEvents);
  }
  render() {
    return Yo.jsx("div", {
      ref: this.containerElement,
      className: this.props.className,
      children: at.only(this.props.children)
    });
  }
}
De(noe, "defaultProps", {
  className: ""
});
De(noe, "contextType", zt);
let s4e = { data: "" }, a4e = (e) => typeof window == "object" ? ((e ? e.querySelector("#_goober") : window._goober) || Object.assign((e || document.head).appendChild(document.createElement("style")), { innerHTML: " ", id: "_goober" })).firstChild : e || s4e, l4e = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g, u4e = /\/\*[^]*?\*\/|  +/g, S5 = /\n+/g, eu = (e, t) => {
  let n = "", r = "", o = "";
  for (let i in e) {
    let a = e[i];
    i[0] == "@" ? i[1] == "i" ? n = i + " " + a + ";" : r += i[1] == "f" ? eu(a, i) : i + "{" + eu(a, i[1] == "k" ? "" : t) + "}" : typeof a == "object" ? r += eu(a, t ? t.replace(/([^,])+/g, (s) => i.replace(/([^,]*:\S+\([^)]*\))|([^,])+/g, (l) => /&/.test(l) ? l.replace(/&/g, s) : s ? s + " " + l : l)) : i) : a != null && (i = /^--/.test(i) ? i : i.replace(/[A-Z]/g, "-$&").toLowerCase(), o += eu.p ? eu.p(i, a) : i + ":" + a + ";");
  }
  return n + (t && o ? t + "{" + o + "}" : o) + r;
}, Ba = {}, roe = (e) => {
  if (typeof e == "object") {
    let t = "";
    for (let n in e) t += n + roe(e[n]);
    return t;
  }
  return e;
}, c4e = (e, t, n, r, o) => {
  let i = roe(e), a = Ba[i] || (Ba[i] = ((l) => {
    let u = 0, c = 11;
    for (; u < l.length; ) c = 101 * c + l.charCodeAt(u++) >>> 0;
    return "go" + c;
  })(i));
  if (!Ba[a]) {
    let l = i !== e ? e : ((u) => {
      let c, p, d = [{}];
      for (; c = l4e.exec(u.replace(u4e, "")); ) c[4] ? d.shift() : c[3] ? (p = c[3].replace(S5, " ").trim(), d.unshift(d[0][p] = d[0][p] || {})) : d[0][c[1]] = c[2].replace(S5, " ").trim();
      return d[0];
    })(e);
    Ba[a] = eu(o ? { ["@keyframes " + a]: l } : l, n ? "" : "." + a);
  }
  let s = n && Ba.g ? Ba.g : null;
  return n && (Ba.g = Ba[a]), ((l, u, c, p) => {
    p ? u.data = u.data.replace(p, l) : u.data.indexOf(l) === -1 && (u.data = c ? l + u.data : u.data + l);
  })(Ba[a], t, r, s), a;
}, p4e = (e, t, n) => e.reduce((r, o, i) => {
  let a = t[i];
  if (a && a.call) {
    let s = a(n), l = s && s.props && s.props.className || /^go/.test(s) && s;
    a = l ? "." + l : s && typeof s == "object" ? s.props ? "" : eu(s, "") : s === !1 ? "" : s;
  }
  return r + o + (a ?? "");
}, "");
function WO(e) {
  let t = this || {}, n = e.call ? e(t.p) : e;
  return c4e(n.unshift ? n.raw ? p4e(n, [].slice.call(arguments, 1), t.p) : n.reduce((r, o) => Object.assign(r, o && o.call ? o(t.p) : o), {}) : n, a4e(t.target), t.g, t.o, t.k);
}
let ooe, bP, wP;
WO.bind({ g: 1 });
let tl = WO.bind({ k: 1 });
function d4e(e, t, n, r) {
  eu.p = t, ooe = e, bP = n, wP = r;
}
function Su(e, t) {
  let n = this || {};
  return function() {
    let r = arguments;
    function o(i, a) {
      let s = Object.assign({}, i), l = s.className || o.className;
      n.p = Object.assign({ theme: bP && bP() }, s), n.o = / *go\d+/.test(l), s.className = WO.apply(n, r) + (l ? " " + l : "");
      let u = e;
      return e[0] && (u = s.as || e, delete s.as), wP && u[0] && wP(s), ooe(u, s);
    }
    return o;
  };
}
var f4e = (e) => typeof e == "function", h4e = (e, t) => f4e(e) ? e(t) : e, g4e = /* @__PURE__ */ (() => {
  let e;
  return () => {
    if (e === void 0 && typeof window < "u") {
      let t = matchMedia("(prefers-reduced-motion: reduce)");
      e = !t || t.matches;
    }
    return e;
  };
})(), m4e = tl`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`, v4e = tl`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`, y4e = tl`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`, b4e = Su("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${m4e} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${v4e} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${(e) => e.secondary || "#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${y4e} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`, w4e = tl`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, C4e = Su("div")`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${(e) => e.secondary || "#e0e0e0"};
  border-right-color: ${(e) => e.primary || "#616161"};
  animation: ${w4e} 1s linear infinite;
`, O4e = tl`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`, x4e = tl`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`, E4e = Su("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${O4e} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${x4e} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${(e) => e.secondary || "#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`, k4e = Su("div")`
  position: absolute;
`, L4e = Su("div")`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`, _4e = tl`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`, P4e = Su("div")`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${_4e} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`, S4e = ({ toast: e }) => {
  let { icon: t, type: n, iconTheme: r } = e;
  return t !== void 0 ? typeof t == "string" ? Ne.createElement(P4e, null, t) : t : n === "blank" ? null : Ne.createElement(L4e, null, Ne.createElement(C4e, { ...r }), n !== "loading" && Ne.createElement(k4e, null, n === "error" ? Ne.createElement(b4e, { ...r }) : Ne.createElement(E4e, { ...r })));
}, M4e = (e) => `
0% {transform: translate3d(0,${e * -200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`, D4e = (e) => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${e * -150}%,-1px) scale(.6); opacity:0;}
`, T4e = "0%{opacity:0;} 100%{opacity:1;}", j4e = "0%{opacity:1;} 100%{opacity:0;}", A4e = Su("div")`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`, R4e = Su("div")`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`, I4e = (e, t) => {
  let n = e.includes("top") ? 1 : -1, [r, o] = g4e() ? [T4e, j4e] : [M4e(n), D4e(n)];
  return { animation: t ? `${tl(r)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards` : `${tl(o)} 0.4s forwards cubic-bezier(.06,.71,.55,1)` };
};
Ne.memo(({ toast: e, position: t, style: n, children: r }) => {
  let o = e.height ? I4e(e.position || t || "top-center", e.visible) : { opacity: 0 }, i = Ne.createElement(S4e, { toast: e }), a = Ne.createElement(R4e, { ...e.ariaProps }, h4e(e.message, e));
  return Ne.createElement(A4e, { className: e.className, style: { ...o, ...n, ...e.style } }, typeof r == "function" ? r({ icon: i, message: a }) : Ne.createElement(Ne.Fragment, null, i, a));
});
d4e(Ne.createElement);
WO`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`;
function XT(e) {
  const {
    isLoading: t = !1,
    scheme: n = "primary",
    variant: r = "solid",
    loadingText: o,
    size: i = "md",
    leftIcon: a,
    rightIcon: s,
    disabled: l,
    className: u = "",
    children: c,
    ...p
  } = e, d = { xs: 12, sm: 16, md: 20, lg: 24 }[i], g = `arkynButton ${t ? "loadingTrue" : "loadingFalse"} ${r} ${n} ${i} ${o ? "loadingTextTrue" : "loadingTextFalse"} ${u}`;
  return /* @__PURE__ */ Fn.jsxs("button", { className: g, disabled: l || t, ...p, children: [
    /* @__PURE__ */ Fn.jsxs("div", { className: "arkynButtonSpinner", children: [
      /* @__PURE__ */ Fn.jsx(ma, { size: d, strokeWidth: 2.5 }),
      o && o
    ] }),
    /* @__PURE__ */ Fn.jsxs("div", { className: "arkynButtonContent", children: [
      $A(d, a),
      c,
      $A(d, s)
    ] })
  ] });
}
function N4e() {
  const e = XP(), t = xG(), n = YP(), [r, o] = k(null);
  function i(u, c) {
    return JSON.stringify(u) === JSON.stringify(c);
  }
  function a() {
    r && o(null);
  }
  h(() => {
    var u, c;
    let p = ((c = (u = n[0]) == null ? void 0 : u.data) == null ? void 0 : c.fieldErrors) || {};
    i(r, p) || Object.entries(p).length !== 0 && o(p);
  }, [n, e]), h(() => {
    var u;
    ((u = n[0]) == null ? void 0 : u.state) === "submitting" && a();
  }, [n, t]);
  const s = (e == null ? void 0 : e.fieldErrors) || r;
  let l = {};
  return Object.entries(s || {}).forEach(([u, c]) => {
    typeof c == "string" && typeof u == "string" && (l[u] = c);
  }), l;
}
$e({});
function B4e(e) {
  const {
    isLoading: t = !1,
    scheme: n = "primary",
    variant: r = "solid",
    size: o = "md",
    icon: i,
    disabled: a,
    className: s = "",
    ...l
  } = e, u = { xs: 12, sm: 16, md: 20, lg: 24 }, c = `arkynIconButton ${r} ${n} ${o} ${t ? "loadingTrue" : "loadingFalse"} ${s}`;
  return /* @__PURE__ */ Fn.jsxs(
    "button",
    {
      disabled: a || t,
      className: c.trim(),
      ...l,
      children: [
        /* @__PURE__ */ Fn.jsx("div", { className: "arkynIconButtonSpinner", children: /* @__PURE__ */ Fn.jsx(ma, { size: u[o], strokeWidth: 2.5 }) }),
        /* @__PURE__ */ Fn.jsx("div", { className: "arkynIconButtonContent", children: /* @__PURE__ */ Fn.jsx(i, { size: u[o], strokeWidth: 2.5 }) })
      ]
    }
  );
}
function F4e(e) {
  const {
    text: t,
    size: n = "lg",
    children: r,
    orientation: o = "top",
    className: i = "",
    ...a
  } = e, s = `arkynTooltip ${n} ${o} ${i}`;
  return /* @__PURE__ */ Fn.jsxs("div", { className: s.trim(), ...a, children: [
    r,
    /* @__PURE__ */ Fn.jsx("div", { className: "arkynTooltipText", children: t })
  ] });
}
function z4e(e) {
  return e && e.replace(/[^0-9]/g, "");
}
const U4e = {
  CNPJ: "99.999.999/9999-99"
};
z4e(U4e.CNPJ).length;
Cr((e, t) => /* @__PURE__ */ Fn.jsx("input", { ref: t, ...e }));
function ioe(e) {
  return e && e.replace(/[^0-9]/g, "");
}
const soe = {
  EIGTH: "(99) 9999-9999",
  NINE: "(99) 99999-9999"
};
function H4e(e, t) {
  let n = "", r = 0;
  for (let o = 0; o < t.length; o++)
    if (t[o] === "9")
      if (r < e.length)
        n += e[r], r++;
      else
        break;
    else if (r < e.length)
      n += t[o];
    else
      break;
  return n;
}
function W4e(e) {
  return e.length > 10 ? "NINE" : "EIGTH";
}
const $4e = ioe(soe.NINE).length, V4e = Cr((e, t) => /* @__PURE__ */ Fn.jsx("input", { ref: t, ...e }));
Cr(
  (e, t) => {
    const { onFocus: n, onBlur: r, size: o, onChange: i, value: a, currentCountry: s, disabled: l } = e, [u, c] = k(!1);
    h(() => {
      u ? i(s.mask) : c(!0);
    }, [s]);
    const p = `phoneInputMask ${o}`;
    function d(g) {
      let f = ioe(g.target.value);
      const m = W4e(f);
      f.length > $4e || (f = H4e(f, soe[m]), g.target.value = f, i(f));
    }
    return s.code === "+55" ? /* @__PURE__ */ Fn.jsx(
      "input",
      {
        value: a,
        onChange: d,
        className: p,
        onFocus: n,
        onBlur: r,
        disabled: l,
        ref: t
      }
    ) : /* @__PURE__ */ Fn.jsx(
      ol,
      {
        value: a,
        onChange: (g) => i(g.target.value),
        className: p,
        component: V4e,
        onFocus: n,
        onBlur: r,
        disabled: l,
        mask: s.mask,
        showMask: !0,
        replacement: { _: /\d/ },
        ref: t
      }
    );
  }
);
$e({});
var dl = {};
Object.defineProperty(dl, "__esModule", {
  value: !0
});
var Z4e = typeof window < "u" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform), aL = {
  alt: "altKey",
  control: "ctrlKey",
  meta: "metaKey",
  shift: "shiftKey"
}, aoe = {
  add: "+",
  break: "pause",
  cmd: "meta",
  command: "meta",
  ctl: "control",
  ctrl: "control",
  del: "delete",
  down: "arrowdown",
  esc: "escape",
  ins: "insert",
  left: "arrowleft",
  mod: Z4e ? "meta" : "control",
  opt: "alt",
  option: "alt",
  return: "enter",
  right: "arrowright",
  space: " ",
  spacebar: " ",
  up: "arrowup",
  win: "meta",
  windows: "meta"
}, YT = {
  backspace: 8,
  tab: 9,
  enter: 13,
  shift: 16,
  control: 17,
  alt: 18,
  pause: 19,
  capslock: 20,
  escape: 27,
  " ": 32,
  pageup: 33,
  pagedown: 34,
  end: 35,
  home: 36,
  arrowleft: 37,
  arrowup: 38,
  arrowright: 39,
  arrowdown: 40,
  insert: 45,
  delete: 46,
  meta: 91,
  numlock: 144,
  scrolllock: 145,
  ";": 186,
  "=": 187,
  ",": 188,
  "-": 189,
  ".": 190,
  "/": 191,
  "`": 192,
  "[": 219,
  "\\": 220,
  "]": 221,
  "'": 222
};
for (var Xv = 1; Xv < 20; Xv++)
  YT["f" + Xv] = 111 + Xv;
function $O(e, t, n) {
  t && !("byKey" in t) && (n = t, t = null), Array.isArray(e) || (e = [e]);
  var r = e.map(function(a) {
    return loe(a, t);
  }), o = function(a) {
    return r.some(function(s) {
      return uoe(s, a);
    });
  }, i = n == null ? o : o(n);
  return i;
}
function q4e(e, t) {
  return $O(e, t);
}
function G4e(e, t) {
  return $O(e, { byKey: !0 }, t);
}
function loe(e, t) {
  var n = t && t.byKey, r = {};
  e = e.replace("++", "+add");
  var o = e.split("+"), i = o.length;
  for (var a in aL)
    r[aL[a]] = !1;
  var s = !0, l = !1, u = void 0;
  try {
    for (var c = o[Symbol.iterator](), p; !(s = (p = c.next()).done); s = !0) {
      var d = p.value, g = d.endsWith("?") && d.length > 1;
      g && (d = d.slice(0, -1));
      var f = JT(d), m = aL[f];
      if (d.length > 1 && !m && !aoe[d] && !YT[f])
        throw new TypeError('Unknown modifier: "' + d + '"');
      (i === 1 || !m) && (n ? r.key = f : r.which = coe(d)), m && (r[m] = g ? null : !0);
    }
  } catch (b) {
    l = !0, u = b;
  } finally {
    try {
      !s && c.return && c.return();
    } finally {
      if (l)
        throw u;
    }
  }
  return r;
}
function uoe(e, t) {
  for (var n in e) {
    var r = e[n], o = void 0;
    if (r != null && (n === "key" && t.key != null ? o = t.key.toLowerCase() : n === "which" ? o = r === 91 && t.which === 93 ? 91 : t.which : o = t[n], !(o == null && r === !1) && o !== r))
      return !1;
  }
  return !0;
}
function coe(e) {
  e = JT(e);
  var t = YT[e] || e.toUpperCase().charCodeAt(0);
  return t;
}
function JT(e) {
  return e = e.toLowerCase(), e = aoe[e] || e, e;
}
dl.default = $O;
var lL = dl.isHotkey = $O;
dl.isCodeHotkey = q4e;
dl.isKeyHotkey = G4e;
dl.parseHotkey = loe;
dl.compareHotkey = uoe;
dl.toKeyCode = coe;
dl.toKeyName = JT;
var K4e = typeof hr == "object" && hr && hr.Object === Object && hr, X4e = K4e, Y4e = X4e, J4e = typeof self == "object" && self && self.Object === Object && self, Q4e = Y4e || J4e || Function("return this")(), eZe = Q4e, tZe = eZe, nZe = tZe.Symbol, poe = nZe, M5 = poe;
M5 && M5.toStringTag;
var D5 = poe;
D5 && D5.toStringTag;
var T5;
(function(e) {
  e.BORDER_BOX = "border-box", e.CONTENT_BOX = "content-box", e.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(T5 || (T5 = {}));
var QT = function(e) {
  return Object.freeze(e);
}, rZe = /* @__PURE__ */ function() {
  function e(t, n) {
    this.inlineSize = t, this.blockSize = n, QT(this);
  }
  return e;
}(), oZe = function() {
  function e(t, n, r, o) {
    return this.x = t, this.y = n, this.width = r, this.height = o, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, QT(this);
  }
  return e.prototype.toJSON = function() {
    var t = this, n = t.x, r = t.y, o = t.top, i = t.right, a = t.bottom, s = t.left, l = t.width, u = t.height;
    return { x: n, y: r, top: o, right: i, bottom: a, left: s, width: l, height: u };
  }, e.fromRect = function(t) {
    return new e(t.x, t.y, t.width, t.height);
  }, e;
}(), j5 = typeof window < "u" ? window : {};
/msie|trident/i.test(j5.navigator && j5.navigator.userAgent);
var uL = function(e, t, n) {
  return e === void 0 && (e = 0), t === void 0 && (t = 0), n === void 0 && (n = !1), new rZe((n ? t : e) || 0, (n ? e : t) || 0);
};
QT({
  devicePixelContentBoxSize: uL(),
  borderBoxSize: uL(),
  contentBoxSize: uL(),
  contentRect: new oZe(0, 0, 0, 0)
});
function Fh(e) {
  "@babel/helpers - typeof";
  return Fh = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Fh(e);
}
function iZe(e, t) {
  if (Fh(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (Fh(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function sZe(e) {
  var t = iZe(e, "string");
  return Fh(t) === "symbol" ? t : String(t);
}
function Af(e, t, n) {
  return t = sZe(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
var aZe = /* @__PURE__ */ $e(null), cL, pL;
parseInt(be.version.split(".")[0], 10);
var A5 = typeof navigator < "u" && /Mac OS X/.test(navigator.userAgent), dL = typeof navigator < "u" && /Android/.test(navigator.userAgent), Yv = typeof navigator < "u" && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent), lZe = typeof navigator < "u" && /Chrome/i.test(navigator.userAgent);
typeof navigator < "u" && /Safari/.test(navigator.userAgent) && /Version\/(\d+)/.test(navigator.userAgent) && (cL = navigator.userAgent.match(/Version\/(\d+)/)) !== null && cL !== void 0 && cL[1] && parseInt((pL = navigator.userAgent.match(/Version\/(\d+)/)) === null || pL === void 0 ? void 0 : pL[1], 10) < 17;
var uZe = /* @__PURE__ */ new WeakMap(), cZe = /* @__PURE__ */ new WeakMap(), pZe = /* @__PURE__ */ new WeakMap(), dZe = /* @__PURE__ */ new WeakMap(), fZe = /* @__PURE__ */ new WeakMap(), R5 = /* @__PURE__ */ new WeakMap(), hZe = /* @__PURE__ */ new WeakMap(), I5 = /* @__PURE__ */ new WeakMap(), Jv = /* @__PURE__ */ new WeakMap(), gZe = /* @__PURE__ */ new WeakMap(), mZe = /* @__PURE__ */ new WeakMap(), vZe = /* @__PURE__ */ new WeakMap(), doe = globalThis.Node, yZe = globalThis.Text, foe = (e) => e && e.ownerDocument && e.ownerDocument.defaultView || null, bZe = (e) => Fw(e) && e.nodeType === 8, ga = (e) => Fw(e) && e.nodeType === 1, Fw = (e) => {
  var t = foe(e);
  return !!t && e instanceof t.Node;
}, N5 = (e) => {
  var t = e && e.anchorNode && foe(e.anchorNode);
  return !!t && e instanceof t.Selection;
}, wZe = (e) => {
  var [t, n] = e;
  if (ga(t) && t.childNodes.length) {
    var r = n === t.childNodes.length, o = r ? n - 1 : n;
    for ([t, o] = hoe(t, o, r ? "backward" : "forward"), r = o < n; ga(t) && t.childNodes.length; ) {
      var i = r ? t.childNodes.length - 1 : 0;
      t = OZe(t, i, r ? "backward" : "forward");
    }
    n = r && t.textContent != null ? t.textContent.length : 0;
  }
  return [t, n];
}, CZe = (e) => {
  for (var t = e && e.parentNode; t; ) {
    if (t.toString() === "[object ShadowRoot]")
      return !0;
    t = t.parentNode;
  }
  return !1;
}, hoe = (e, t, n) => {
  for (var {
    childNodes: r
  } = e, o = r[t], i = t, a = !1, s = !1; (bZe(o) || ga(o) && o.childNodes.length === 0 || ga(o) && o.getAttribute("contenteditable") === "false") && !(a && s); ) {
    if (i >= r.length) {
      a = !0, i = t - 1, n = "backward";
      continue;
    }
    if (i < 0) {
      s = !0, i = t + 1, n = "forward";
      continue;
    }
    o = r[i], t = i, i += n === "forward" ? 1 : -1;
  }
  return [o, t];
}, OZe = (e, t, n) => {
  var [r] = hoe(e, t, n);
  return r;
}, B5 = (e) => e.getSelection != null ? e.getSelection() : document.getSelection(), goe = (e, t, n) => {
  var {
    target: r
  } = t;
  if (ga(r) && r.matches('[contentEditable="false"]'))
    return !1;
  var {
    document: o
  } = mn.getWindow(e);
  if (o.contains(r))
    return mn.hasDOMNode(e, r, {
      editable: !0
    });
  var i = n.find((a) => {
    var {
      addedNodes: s,
      removedNodes: l
    } = a;
    for (var u of s)
      if (u === r || u.contains(r))
        return !0;
    for (var c of l)
      if (c === r || c.contains(r))
        return !0;
  });
  return !i || i === t ? !1 : goe(e, i, n);
}, F5 = (e, t) => !!(e.compareDocumentPosition(t) & doe.DOCUMENT_POSITION_PRECEDING), xZe = (e, t) => !!(e.compareDocumentPosition(t) & doe.DOCUMENT_POSITION_FOLLOWING), EZe = 0;
class kZe {
  constructor() {
    Af(this, "id", void 0), this.id = "".concat(EZe++);
  }
}
var mn = {
  androidPendingDiffs: (e) => vZe.get(e),
  androidScheduleFlush: (e) => {
    var t;
    (t = mZe.get(e)) === null || t === void 0 || t();
  },
  blur: (e) => {
    var t = mn.toDOMNode(e, e), n = mn.findDocumentOrShadowRoot(e);
    Jv.set(e, !1), n.activeElement === t && t.blur();
  },
  deselect: (e) => {
    var {
      selection: t
    } = e, n = mn.findDocumentOrShadowRoot(e), r = B5(n);
    r && r.rangeCount > 0 && r.removeAllRanges(), t && Ky.deselect(e);
  },
  findDocumentOrShadowRoot: (e) => {
    var t = mn.toDOMNode(e, e), n = t.getRootNode();
    return n instanceof Document || n instanceof ShadowRoot ? n : t.ownerDocument;
  },
  findEventRange: (e, t) => {
    "nativeEvent" in t && (t = t.nativeEvent);
    var {
      clientX: n,
      clientY: r,
      target: o
    } = t;
    if (n == null || r == null)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var i = mn.toSlateNode(e, t.target), a = mn.findPath(e, i);
    if (Ua.isElement(i) && sr.isVoid(e, i)) {
      var s = o.getBoundingClientRect(), l = e.isInline(i) ? n - s.left < s.left + s.width - n : r - s.top < s.top + s.height - r, u = sr.point(e, a, {
        edge: l ? "start" : "end"
      }), c = l ? sr.before(e, u) : sr.after(e, u);
      if (c) {
        var p = sr.range(e, c);
        return p;
      }
    }
    var d, {
      document: g
    } = mn.getWindow(e);
    if (g.caretRangeFromPoint)
      d = g.caretRangeFromPoint(n, r);
    else {
      var f = g.caretPositionFromPoint(n, r);
      f && (d = g.createRange(), d.setStart(f.offsetNode, f.offset), d.setEnd(f.offsetNode, f.offset));
    }
    if (!d)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var m = mn.toSlateRange(e, d, {
      exactMatch: !1,
      suppressThrow: !1
    });
    return m;
  },
  findKey: (e, t) => {
    var n = R5.get(t);
    return n || (n = new kZe(), R5.set(t, n)), n;
  },
  findPath: (e, t) => {
    for (var n = [], r = t; ; ) {
      var o = cZe.get(r);
      if (o == null) {
        if (sr.isEditor(r))
          return n;
        break;
      }
      var i = uZe.get(r);
      if (i == null)
        break;
      n.unshift(i), r = o;
    }
    throw new Error("Unable to find the path for Slate node: ".concat(rs.stringify(t)));
  },
  focus: function(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      retries: 5
    };
    if (!Jv.get(e)) {
      if (t.retries <= 0)
        throw new Error("Could not set focus, editor seems stuck with pending operations");
      if (e.operations.length > 0) {
        setTimeout(() => {
          mn.focus(e, {
            retries: t.retries - 1
          });
        }, 10);
        return;
      }
      var n = mn.toDOMNode(e, e), r = mn.findDocumentOrShadowRoot(e);
      if (r.activeElement !== n) {
        if (e.selection && r instanceof Document) {
          var o = B5(r), i = mn.toDOMRange(e, e.selection);
          o == null || o.removeAllRanges(), o == null || o.addRange(i);
        }
        e.selection || Ky.select(e, sr.start(e, [])), Jv.set(e, !0), n.focus({
          preventScroll: !0
        });
      }
    }
  },
  getWindow: (e) => {
    var t = pZe.get(e);
    if (!t)
      throw new Error("Unable to find a host window element for this editor");
    return t;
  },
  hasDOMNode: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      editable: r = !1
    } = n, o = mn.toDOMNode(e, e), i;
    try {
      i = ga(t) ? t : t.parentElement;
    } catch (a) {
      if (a instanceof Error && !a.message.includes('Permission denied to access property "nodeType"'))
        throw a;
    }
    return i ? i.closest("[data-slate-editor]") === o && (!r || i.isContentEditable ? !0 : typeof i.isContentEditable == "boolean" && // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined
    // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable="false"(readOnly)
    i.closest('[contenteditable="false"]') === o || !!i.getAttribute("data-slate-zero-width")) : !1;
  },
  hasEditableTarget: (e, t) => Fw(t) && mn.hasDOMNode(e, t, {
    editable: !0
  }),
  hasRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t;
    return sr.hasPath(e, n.path) && sr.hasPath(e, r.path);
  },
  hasSelectableTarget: (e, t) => mn.hasEditableTarget(e, t) || mn.isTargetInsideNonReadonlyVoid(e, t),
  hasTarget: (e, t) => Fw(t) && mn.hasDOMNode(e, t),
  insertData: (e, t) => {
    e.insertData(t);
  },
  insertFragmentData: (e, t) => e.insertFragmentData(t),
  insertTextData: (e, t) => e.insertTextData(t),
  isComposing: (e) => !!gZe.get(e),
  isFocused: (e) => !!Jv.get(e),
  isReadOnly: (e) => !!I5.get(e),
  isTargetInsideNonReadonlyVoid: (e, t) => {
    if (I5.get(e)) return !1;
    var n = mn.hasTarget(e, t) && mn.toSlateNode(e, t);
    return Ua.isElement(n) && sr.isVoid(e, n);
  },
  setFragmentData: (e, t, n) => e.setFragmentData(t, n),
  toDOMNode: (e, t) => {
    var n = hZe.get(e), r = sr.isEditor(t) ? dZe.get(e) : n == null ? void 0 : n.get(mn.findKey(e, t));
    if (!r)
      throw new Error("Cannot resolve a DOM node from Slate node: ".concat(rs.stringify(t)));
    return r;
  },
  toDOMPoint: (e, t) => {
    var [n] = sr.node(e, t.path), r = mn.toDOMNode(e, n), o;
    sr.void(e, {
      at: t
    }) && (t = {
      path: t.path,
      offset: 0
    });
    for (var i = "[data-slate-string], [data-slate-zero-width]", a = Array.from(r.querySelectorAll(i)), s = 0, l = 0; l < a.length; l++) {
      var u = a[l], c = u.childNodes[0];
      if (!(c == null || c.textContent == null)) {
        var {
          length: p
        } = c.textContent, d = u.getAttribute("data-slate-length"), g = d == null ? p : parseInt(d, 10), f = s + g, m = a[l + 1];
        if (t.offset === f && m !== null && m !== void 0 && m.hasAttribute("data-slate-mark-placeholder")) {
          var b, E = m.childNodes[0];
          o = [
            // COMPAT: If we don't explicity set the dom point to be on the actual
            // dom text element, chrome will put the selection behind the actual dom
            // text element, causing domRange.getBoundingClientRect() calls on a collapsed
            // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)
            // which will cause issues when scrolling to it.
            E instanceof yZe ? E : m,
            (b = m.textContent) !== null && b !== void 0 && b.startsWith("\uFEFF") ? 1 : 0
          ];
          break;
        }
        if (t.offset <= f) {
          var w = Math.min(p, Math.max(0, t.offset - s));
          o = [c, w];
          break;
        }
        s = f;
      }
    }
    if (!o)
      throw new Error("Cannot resolve a DOM point from Slate point: ".concat(rs.stringify(t)));
    return o;
  },
  toDOMRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t, o = Vt.isBackward(t), i = mn.toDOMPoint(e, n), a = Vt.isCollapsed(t) ? i : mn.toDOMPoint(e, r), s = mn.getWindow(e), l = s.document.createRange(), [u, c] = o ? a : i, [p, d] = o ? i : a, g = ga(u) ? u : u.parentElement, f = !!g.getAttribute("data-slate-zero-width"), m = ga(p) ? p : p.parentElement, b = !!m.getAttribute("data-slate-zero-width");
    return l.setStart(u, f ? 1 : c), l.setEnd(p, b ? 1 : d), l;
  },
  toSlateNode: (e, t) => {
    var n = ga(t) ? t : t.parentElement;
    n && !n.hasAttribute("data-slate-node") && (n = n.closest("[data-slate-node]"));
    var r = n ? fZe.get(n) : null;
    if (!r)
      throw new Error("Cannot resolve a Slate node from DOM node: ".concat(n));
    return r;
  },
  toSlatePoint: (e, t, n) => {
    var {
      exactMatch: r,
      suppressThrow: o,
      searchDirection: i = "backward"
    } = n, [a, s] = r ? t : wZe(t), l = a.parentNode, u = null, c = 0;
    if (l) {
      var p, d, g = mn.toDOMNode(e, e), f = l.closest('[data-slate-void="true"]'), m = f && g.contains(f) ? f : null, b = l.closest('[contenteditable="false"]'), E = b && g.contains(b) ? b : null, w = l.closest("[data-slate-leaf]"), M = null;
      if (w) {
        if (u = w.closest('[data-slate-node="text"]'), u) {
          var x = mn.getWindow(e), v = x.document.createRange();
          v.setStart(u, 0), v.setEnd(a, s);
          var C = v.cloneContents(), P = [...Array.prototype.slice.call(C.querySelectorAll("[data-slate-zero-width]")), ...Array.prototype.slice.call(C.querySelectorAll("[contenteditable=false]"))];
          P.forEach((S) => {
            if (dL && !r && S.hasAttribute("data-slate-zero-width") && S.textContent.length > 0 && S.textContext !== "\uFEFF") {
              S.textContent.startsWith("\uFEFF") && (S.textContent = S.textContent.slice(1));
              return;
            }
            S.parentNode.removeChild(S);
          }), c = C.textContent.length, M = u;
        }
      } else if (m) {
        for (var F = m.querySelectorAll("[data-slate-leaf]"), L = 0; L < F.length; L++) {
          var B = F[L];
          if (mn.hasDOMNode(e, B)) {
            w = B;
            break;
          }
        }
        w ? (u = w.closest('[data-slate-node="text"]'), M = w, c = M.textContent.length, M.querySelectorAll("[data-slate-zero-width]").forEach((S) => {
          c -= S.textContent.length;
        })) : c = 1;
      } else if (E) {
        var N = (S) => S ? S.querySelectorAll(
          // Exclude leaf nodes in nested editors
          "[data-slate-leaf]:not(:scope [data-slate-editor] [data-slate-leaf])"
        ) : [], $ = E.closest('[data-slate-node="element"]');
        if (i === "forward") {
          var V, H = [...N($), ...N($ == null ? void 0 : $.nextElementSibling)];
          w = (V = H.find((S) => xZe(E, S))) !== null && V !== void 0 ? V : null;
        } else {
          var Z, K = [...N($ == null ? void 0 : $.previousElementSibling), ...N($)];
          w = (Z = K.findLast((S) => F5(E, S))) !== null && Z !== void 0 ? Z : null;
        }
        w && (u = w.closest('[data-slate-node="text"]'), M = w, i === "forward" ? c = 0 : (c = M.textContent.length, M.querySelectorAll("[data-slate-zero-width]").forEach((S) => {
          c -= S.textContent.length;
        })));
      }
      M && c === M.textContent.length && // COMPAT: Android IMEs might remove the zero width space while composing,
      // and we don't add it for line-breaks.
      dL && M.getAttribute("data-slate-zero-width") === "z" && (p = M.textContent) !== null && p !== void 0 && p.startsWith("\uFEFF") && // COMPAT: If the parent node is a Slate zero-width space, editor is
      // because the text node should have no characters. However, during IME
      // composition the ASCII characters will be prepended to the zero-width
      // space, so subtract 1 from the offset to account for the zero-width
      // space character.
      (l.hasAttribute("data-slate-zero-width") || // COMPAT: In Firefox, `range.cloneContents()` returns an extra trailing '\n'
      // when the document ends with a new-line character. This results in the offset
      // length being off by one, so we need to subtract one to account for this.
      Yv && (d = M.textContent) !== null && d !== void 0 && d.endsWith(`

`)) && c--;
    }
    if (dL && !u && !r) {
      var Y = l.hasAttribute("data-slate-node") ? l : l.closest("[data-slate-node]");
      if (Y && mn.hasDOMNode(e, Y, {
        editable: !0
      })) {
        var Q = mn.toSlateNode(e, Y), {
          path: J,
          offset: _
        } = sr.start(e, mn.findPath(e, Q));
        return Y.querySelector("[data-slate-leaf]") || (_ = s), {
          path: J,
          offset: _
        };
      }
    }
    if (!u) {
      if (o)
        return null;
      throw new Error("Cannot resolve a Slate point from DOM point: ".concat(t));
    }
    var D = mn.toSlateNode(e, u), z = mn.findPath(e, D);
    return {
      path: z,
      offset: c
    };
  },
  toSlateRange: (e, t, n) => {
    var r, {
      exactMatch: o,
      suppressThrow: i
    } = n, a = N5(t) ? t.anchorNode : t.startContainer, s, l, u, c, p;
    if (a)
      if (N5(t)) {
        if (Yv && t.rangeCount > 1) {
          u = t.focusNode;
          var d = t.getRangeAt(0), g = t.getRangeAt(t.rangeCount - 1);
          if (u instanceof HTMLTableRowElement && d.startContainer instanceof HTMLTableRowElement && g.startContainer instanceof HTMLTableRowElement) {
            let C = function(P) {
              return P.childElementCount > 0 ? C(P.children[0]) : P;
            };
            var f = d.startContainer, m = g.startContainer, b = C(f.children[d.startOffset]), E = C(m.children[g.startOffset]);
            c = 0, E.childNodes.length > 0 ? s = E.childNodes[0] : s = E, b.childNodes.length > 0 ? u = b.childNodes[0] : u = b, E instanceof HTMLElement ? l = E.innerHTML.length : l = 0;
          } else
            d.startContainer === u ? (s = g.endContainer, l = g.endOffset, c = d.startOffset) : (s = d.startContainer, l = d.endOffset, c = g.startOffset);
        } else
          s = t.anchorNode, l = t.anchorOffset, u = t.focusNode, c = t.focusOffset;
        lZe && CZe(s) || Yv ? p = t.anchorNode === t.focusNode && t.anchorOffset === t.focusOffset : p = t.isCollapsed;
      } else
        s = t.startContainer, l = t.startOffset, u = t.endContainer, c = t.endOffset, p = t.collapsed;
    if (s == null || u == null || l == null || c == null)
      throw new Error("Cannot resolve a Slate range from DOM range: ".concat(t));
    Yv && (r = u.textContent) !== null && r !== void 0 && r.endsWith(`

`) && c === u.textContent.length && c--;
    var w = mn.toSlatePoint(e, [s, l], {
      exactMatch: o,
      suppressThrow: i
    });
    if (!w)
      return null;
    var M = F5(s, u) || s === u && c < l, x = p ? w : mn.toSlatePoint(e, [u, c], {
      exactMatch: o,
      suppressThrow: i,
      searchDirection: M ? "forward" : "backward"
    });
    if (!x)
      return null;
    var v = {
      anchor: w,
      focus: x
    };
    return Vt.isExpanded(v) && Vt.isForward(v) && ga(u) && sr.void(e, {
      at: v.focus,
      mode: "highest"
    }) && (v = sr.unhangRange(e, v, {
      voids: !0
    })), v;
  }
}, LZe = {
  bold: "mod+b",
  compose: ["down", "left", "right", "up", "backspace", "enter"],
  moveBackward: "left",
  moveForward: "right",
  moveWordBackward: "ctrl+left",
  moveWordForward: "ctrl+right",
  deleteBackward: "shift?+backspace",
  deleteForward: "shift?+delete",
  extendBackward: "shift+left",
  extendForward: "shift+right",
  italic: "mod+i",
  insertSoftBreak: "shift+enter",
  splitBlock: "enter",
  undo: "mod+z"
}, _Ze = {
  moveLineBackward: "opt+up",
  moveLineForward: "opt+down",
  moveWordBackward: "opt+left",
  moveWordForward: "opt+right",
  deleteBackward: ["ctrl+backspace", "ctrl+h"],
  deleteForward: ["ctrl+delete", "ctrl+d"],
  deleteLineBackward: "cmd+shift?+backspace",
  deleteLineForward: ["cmd+shift?+delete", "ctrl+k"],
  deleteWordBackward: "opt+shift?+backspace",
  deleteWordForward: "opt+shift?+delete",
  extendLineBackward: "opt+shift+up",
  extendLineForward: "opt+shift+down",
  redo: "cmd+shift+z",
  transposeCharacter: "ctrl+t"
}, PZe = {
  deleteWordBackward: "ctrl+shift?+backspace",
  deleteWordForward: "ctrl+shift?+delete",
  redo: ["ctrl+y", "ctrl+shift+z"]
}, no = (e) => {
  var t = LZe[e], n = _Ze[e], r = PZe[e], o = t && lL(t), i = n && lL(n), a = r && lL(r);
  return (s) => !!(o && o(s) || A5 && i && i(s) || !A5 && a && a(s));
};
no("bold"), no("compose"), no("moveBackward"), no("moveForward"), no("deleteBackward"), no("deleteForward"), no("deleteLineBackward"), no("deleteLineForward"), no("deleteWordBackward"), no("deleteWordForward"), no("extendBackward"), no("extendForward"), no("extendLineBackward"), no("extendLineForward"), no("italic"), no("moveLineBackward"), no("moveLineForward"), no("moveWordBackward"), no("moveWordForward"), no("redo"), no("insertSoftBreak"), no("splitBlock"), no("transposeCharacter"), no("undo");
var SZe = (e, t) => {
  var n = [], r = () => {
    n = [];
  }, o = (a) => {
    if (t.current) {
      var s = a.filter((l) => goe(e, l, a));
      n.push(...s);
    }
  };
  function i() {
    n.length > 0 && (n.reverse().forEach((a) => {
      a.type !== "characterData" && (a.removedNodes.forEach((s) => {
        a.target.insertBefore(s, a.nextSibling);
      }), a.addedNodes.forEach((s) => {
        a.target.removeChild(s);
      }));
    }), r());
  }
  return {
    registerMutations: o,
    restoreDOM: i,
    clear: r
  };
}, MZe = {
  subtree: !0,
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0
};
class DZe extends au {
  constructor() {
    super(...arguments), Af(this, "context", null), Af(this, "manager", null), Af(this, "mutationObserver", null);
  }
  observe() {
    var t, {
      node: n
    } = this.props;
    if (!n.current)
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    (t = this.mutationObserver) === null || t === void 0 || t.observe(n.current, MZe);
  }
  componentDidMount() {
    var {
      receivedUserInput: t
    } = this.props, n = this.context;
    this.manager = SZe(n, t), this.mutationObserver = new MutationObserver(this.manager.registerMutations), this.observe();
  }
  getSnapshotBeforeUpdate() {
    var t, n, r, o = (t = this.mutationObserver) === null || t === void 0 ? void 0 : t.takeRecords();
    if (o != null && o.length) {
      var i;
      (i = this.manager) === null || i === void 0 || i.registerMutations(o);
    }
    return (n = this.mutationObserver) === null || n === void 0 || n.disconnect(), (r = this.manager) === null || r === void 0 || r.restoreDOM(), null;
  }
  componentDidUpdate() {
    var t;
    (t = this.manager) === null || t === void 0 || t.clear(), this.observe();
  }
  componentWillUnmount() {
    var t;
    (t = this.mutationObserver) === null || t === void 0 || t.disconnect();
  }
  render() {
    return this.props.children;
  }
}
Af(DZe, "contextType", aZe);
$e({});
$e({});
$e({});
var Fo = {}, ej = {}, Rg = {}, Ig = {}, moe = "Expected a function", z5 = NaN, TZe = "[object Symbol]", jZe = /^\s+|\s+$/g, AZe = /^[-+]0x[0-9a-f]+$/i, RZe = /^0b[01]+$/i, IZe = /^0o[0-7]+$/i, NZe = parseInt, BZe = typeof hr == "object" && hr && hr.Object === Object && hr, FZe = typeof self == "object" && self && self.Object === Object && self, zZe = BZe || FZe || Function("return this")(), UZe = Object.prototype, HZe = UZe.toString, WZe = Math.max, $Ze = Math.min, fL = function() {
  return zZe.Date.now();
};
function VZe(e, t, n) {
  var r, o, i, a, s, l, u = 0, c = !1, p = !1, d = !0;
  if (typeof e != "function")
    throw new TypeError(moe);
  t = U5(t) || 0, zw(n) && (c = !!n.leading, p = "maxWait" in n, i = p ? WZe(U5(n.maxWait) || 0, t) : i, d = "trailing" in n ? !!n.trailing : d);
  function g(C) {
    var P = r, F = o;
    return r = o = void 0, u = C, a = e.apply(F, P), a;
  }
  function f(C) {
    return u = C, s = setTimeout(E, t), c ? g(C) : a;
  }
  function m(C) {
    var P = C - l, F = C - u, L = t - P;
    return p ? $Ze(L, i - F) : L;
  }
  function b(C) {
    var P = C - l, F = C - u;
    return l === void 0 || P >= t || P < 0 || p && F >= i;
  }
  function E() {
    var C = fL();
    if (b(C))
      return w(C);
    s = setTimeout(E, m(C));
  }
  function w(C) {
    return s = void 0, d && r ? g(C) : (r = o = void 0, a);
  }
  function M() {
    s !== void 0 && clearTimeout(s), u = 0, r = l = o = s = void 0;
  }
  function x() {
    return s === void 0 ? a : w(fL());
  }
  function v() {
    var C = fL(), P = b(C);
    if (r = arguments, o = this, l = C, P) {
      if (s === void 0)
        return f(l);
      if (p)
        return s = setTimeout(E, t), g(l);
    }
    return s === void 0 && (s = setTimeout(E, t)), a;
  }
  return v.cancel = M, v.flush = x, v;
}
function ZZe(e, t, n) {
  var r = !0, o = !0;
  if (typeof e != "function")
    throw new TypeError(moe);
  return zw(n) && (r = "leading" in n ? !!n.leading : r, o = "trailing" in n ? !!n.trailing : o), VZe(e, t, {
    leading: r,
    maxWait: t,
    trailing: o
  });
}
function zw(e) {
  var t = typeof e;
  return !!e && (t == "object" || t == "function");
}
function qZe(e) {
  return !!e && typeof e == "object";
}
function GZe(e) {
  return typeof e == "symbol" || qZe(e) && HZe.call(e) == TZe;
}
function U5(e) {
  if (typeof e == "number")
    return e;
  if (GZe(e))
    return z5;
  if (zw(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = zw(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = e.replace(jZe, "");
  var n = RZe.test(e);
  return n || IZe.test(e) ? NZe(e.slice(2), n ? 2 : 8) : AZe.test(e) ? z5 : +e;
}
var KZe = ZZe, Ng = {};
Object.defineProperty(Ng, "__esModule", {
  value: !0
});
Ng.addPassiveEventListener = function(e, t, n) {
  var r = n.name;
  r || (r = t, console.warn("Listener must be a named function.")), Ty.has(t) || Ty.set(t, /* @__PURE__ */ new Set());
  var o = Ty.get(t);
  if (!o.has(r)) {
    var i = function() {
      var a = !1;
      try {
        var s = Object.defineProperty({}, "passive", {
          get: function() {
            a = !0;
          }
        });
        window.addEventListener("test", null, s);
      } catch {
      }
      return a;
    }();
    e.addEventListener(t, n, i ? { passive: !0 } : !1), o.add(r);
  }
};
Ng.removePassiveEventListener = function(e, t, n) {
  e.removeEventListener(t, n), Ty.get(t).delete(n.name || t);
};
var Ty = /* @__PURE__ */ new Map();
Object.defineProperty(Ig, "__esModule", {
  value: !0
});
var XZe = KZe, YZe = JZe(XZe), H5 = Ng;
function JZe(e) {
  return e && e.__esModule ? e : { default: e };
}
var QZe = function(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 66;
  return (0, YZe.default)(e, t);
}, mo = {
  spyCallbacks: [],
  spySetState: [],
  scrollSpyContainers: [],
  mount: function(e, t) {
    if (e) {
      var n = QZe(function(r) {
        mo.scrollHandler(e);
      }, t);
      return mo.scrollSpyContainers.push(e), (0, H5.addPassiveEventListener)(e, "scroll", n), function() {
        (0, H5.removePassiveEventListener)(e, "scroll", n), mo.scrollSpyContainers.splice(mo.scrollSpyContainers.indexOf(e), 1);
      };
    }
    return function() {
    };
  },
  isMounted: function(e) {
    return mo.scrollSpyContainers.indexOf(e) !== -1;
  },
  currentPositionX: function(e) {
    if (e === document) {
      var t = window.scrollY !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.scrollX : n ? document.documentElement.scrollLeft : document.body.scrollLeft;
    } else
      return e.scrollLeft;
  },
  currentPositionY: function(e) {
    if (e === document) {
      var t = window.scrollX !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.scrollY : n ? document.documentElement.scrollTop : document.body.scrollTop;
    } else
      return e.scrollTop;
  },
  scrollHandler: function(e) {
    var t = mo.scrollSpyContainers[mo.scrollSpyContainers.indexOf(e)].spyCallbacks || [];
    t.forEach(function(n) {
      return n(mo.currentPositionX(e), mo.currentPositionY(e));
    });
  },
  addStateHandler: function(e) {
    mo.spySetState.push(e);
  },
  addSpyHandler: function(e, t) {
    var n = mo.scrollSpyContainers[mo.scrollSpyContainers.indexOf(t)];
    n.spyCallbacks || (n.spyCallbacks = []), n.spyCallbacks.push(e);
  },
  updateStates: function() {
    mo.spySetState.forEach(function(e) {
      return e();
    });
  },
  unmount: function(e, t) {
    mo.scrollSpyContainers.forEach(function(n) {
      return n.spyCallbacks && n.spyCallbacks.length && n.spyCallbacks.indexOf(t) > -1 && n.spyCallbacks.splice(n.spyCallbacks.indexOf(t), 1);
    }), mo.spySetState && mo.spySetState.length && mo.spySetState.indexOf(e) > -1 && mo.spySetState.splice(mo.spySetState.indexOf(e), 1), document.removeEventListener("scroll", mo.scrollHandler);
  },
  update: function() {
    return mo.scrollSpyContainers.forEach(function(e) {
      return mo.scrollHandler(e);
    });
  }
};
Ig.default = mo;
var Xp = {}, Bg = {};
Object.defineProperty(Bg, "__esModule", {
  value: !0
});
var e7e = function(e, t) {
  var n = e.indexOf("#") === 0 ? e.substring(1) : e, r = n ? "#" + n : "", o = window && window.location, i = r ? o.pathname + o.search + r : o.pathname + o.search;
  t ? history.pushState(history.state, "", i) : history.replaceState(history.state, "", i);
}, t7e = function() {
  return window.location.hash.replace(/^#/, "");
}, n7e = function(e) {
  return function(t) {
    return e.contains ? e != t && e.contains(t) : !!(e.compareDocumentPosition(t) & 16);
  };
}, r7e = function(e) {
  return getComputedStyle(e).position !== "static";
}, hL = function(e, t) {
  for (var n = e.offsetTop, r = e.offsetParent; r && !t(r); )
    n += r.offsetTop, r = r.offsetParent;
  return { offsetTop: n, offsetParent: r };
}, o7e = function(e, t, n) {
  if (n)
    return e === document ? t.getBoundingClientRect().left + (window.scrollX || window.pageXOffset) : getComputedStyle(e).position !== "static" ? t.offsetLeft : t.offsetLeft - e.offsetLeft;
  if (e === document)
    return t.getBoundingClientRect().top + (window.scrollY || window.pageYOffset);
  if (r7e(e)) {
    if (t.offsetParent !== e) {
      var r = function(l) {
        return l === e || l === document;
      }, o = hL(t, r), i = o.offsetTop, a = o.offsetParent;
      if (a !== e)
        throw new Error("Seems containerElement is not an ancestor of the Element");
      return i;
    }
    return t.offsetTop;
  }
  if (t.offsetParent === e.offsetParent)
    return t.offsetTop - e.offsetTop;
  var s = function(l) {
    return l === document;
  };
  return hL(t, s).offsetTop - hL(e, s).offsetTop;
};
Bg.default = {
  updateHash: e7e,
  getHash: t7e,
  filterElementInContainer: n7e,
  scrollOffset: o7e
};
var VO = {}, tj = {};
Object.defineProperty(tj, "__esModule", {
  value: !0
});
tj.default = {
  /*
   * https://github.com/oblador/angular-scroll (duScrollDefaultEasing)
   */
  defaultEasing: function(e) {
    return e < 0.5 ? Math.pow(e * 2, 2) / 2 : 1 - Math.pow((1 - e) * 2, 2) / 2;
  },
  /*
   * https://gist.github.com/gre/1650294
   */
  // no easing, no acceleration
  linear: function(e) {
    return e;
  },
  // accelerating from zero velocity
  easeInQuad: function(e) {
    return e * e;
  },
  // decelerating to zero velocity
  easeOutQuad: function(e) {
    return e * (2 - e);
  },
  // acceleration until halfway, then deceleration
  easeInOutQuad: function(e) {
    return e < 0.5 ? 2 * e * e : -1 + (4 - 2 * e) * e;
  },
  // accelerating from zero velocity 
  easeInCubic: function(e) {
    return e * e * e;
  },
  // decelerating to zero velocity π
  easeOutCubic: function(e) {
    return --e * e * e + 1;
  },
  // acceleration until halfway, then deceleration 
  easeInOutCubic: function(e) {
    return e < 0.5 ? 4 * e * e * e : (e - 1) * (2 * e - 2) * (2 * e - 2) + 1;
  },
  // accelerating from zero velocity 
  easeInQuart: function(e) {
    return e * e * e * e;
  },
  // decelerating to zero velocity 
  easeOutQuart: function(e) {
    return 1 - --e * e * e * e;
  },
  // acceleration until halfway, then deceleration
  easeInOutQuart: function(e) {
    return e < 0.5 ? 8 * e * e * e * e : 1 - 8 * --e * e * e * e;
  },
  // accelerating from zero velocity
  easeInQuint: function(e) {
    return e * e * e * e * e;
  },
  // decelerating to zero velocity
  easeOutQuint: function(e) {
    return 1 + --e * e * e * e * e;
  },
  // acceleration until halfway, then deceleration 
  easeInOutQuint: function(e) {
    return e < 0.5 ? 16 * e * e * e * e * e : 1 + 16 * --e * e * e * e * e;
  }
};
var nj = {};
Object.defineProperty(nj, "__esModule", {
  value: !0
});
var i7e = Ng, s7e = ["mousedown", "wheel", "touchmove", "keydown"];
nj.default = {
  subscribe: function(e) {
    return typeof document < "u" && s7e.forEach(function(t) {
      return (0, i7e.addPassiveEventListener)(document, t, e);
    });
  }
};
var Fg = {};
Object.defineProperty(Fg, "__esModule", {
  value: !0
});
var CP = {
  registered: {},
  scrollEvent: {
    register: function(e, t) {
      CP.registered[e] = t;
    },
    remove: function(e) {
      CP.registered[e] = null;
    }
  }
};
Fg.default = CP;
Object.defineProperty(VO, "__esModule", {
  value: !0
});
var a7e = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, l7e = Bg;
ZO(l7e);
var u7e = tj, W5 = ZO(u7e), c7e = nj, p7e = ZO(c7e), d7e = Fg, aa = ZO(d7e);
function ZO(e) {
  return e && e.__esModule ? e : { default: e };
}
var voe = function(e) {
  return W5.default[e.smooth] || W5.default.defaultEasing;
}, f7e = function(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}, h7e = function() {
  if (typeof window < "u")
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame;
}, OP = function() {
  return h7e() || function(e, t, n) {
    window.setTimeout(e, n || 1e3 / 60, (/* @__PURE__ */ new Date()).getTime());
  };
}(), yoe = function() {
  return {
    currentPosition: 0,
    startPosition: 0,
    targetPosition: 0,
    progress: 0,
    duration: 0,
    cancel: !1,
    target: null,
    containerElement: null,
    to: null,
    start: null,
    delta: null,
    percent: null,
    delayTimeout: null
  };
}, boe = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollLeft;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageXOffset : r ? document.documentElement.scrollLeft : document.body.scrollLeft;
}, woe = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollTop;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageYOffset : r ? document.documentElement.scrollTop : document.body.scrollTop;
}, g7e = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollWidth - t.offsetWidth;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollWidth, n.offsetWidth, r.clientWidth, r.scrollWidth, r.offsetWidth);
}, m7e = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollHeight - t.offsetHeight;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollHeight, n.offsetHeight, r.clientHeight, r.scrollHeight, r.offsetHeight);
}, v7e = function e(t, n, r) {
  var o = n.data;
  if (!n.ignoreCancelEvents && o.cancel) {
    aa.default.registered.end && aa.default.registered.end(o.to, o.target, o.currentPositionY);
    return;
  }
  if (o.delta = Math.round(o.targetPosition - o.startPosition), o.start === null && (o.start = r), o.progress = r - o.start, o.percent = o.progress >= o.duration ? 1 : t(o.progress / o.duration), o.currentPosition = o.startPosition + Math.ceil(o.delta * o.percent), o.containerElement && o.containerElement !== document && o.containerElement !== document.body ? n.horizontal ? o.containerElement.scrollLeft = o.currentPosition : o.containerElement.scrollTop = o.currentPosition : n.horizontal ? window.scrollTo(o.currentPosition, 0) : window.scrollTo(0, o.currentPosition), o.percent < 1) {
    var i = e.bind(null, t, n);
    OP.call(window, i);
    return;
  }
  aa.default.registered.end && aa.default.registered.end(o.to, o.target, o.currentPosition);
}, rj = function(e) {
  e.data.containerElement = e ? e.containerId ? document.getElementById(e.containerId) : e.container && e.container.nodeType ? e.container : document : null;
}, zg = function(e, t, n, r) {
  t.data = t.data || yoe(), window.clearTimeout(t.data.delayTimeout);
  var o = function() {
    t.data.cancel = !0;
  };
  if (p7e.default.subscribe(o), rj(t), t.data.start = null, t.data.cancel = !1, t.data.startPosition = t.horizontal ? boe(t) : woe(t), t.data.targetPosition = t.absolute ? e : e + t.data.startPosition, t.data.startPosition === t.data.targetPosition) {
    aa.default.registered.end && aa.default.registered.end(t.data.to, t.data.target, t.data.currentPosition);
    return;
  }
  t.data.delta = Math.round(t.data.targetPosition - t.data.startPosition), t.data.duration = f7e(t.duration)(t.data.delta), t.data.duration = isNaN(parseFloat(t.data.duration)) ? 1e3 : parseFloat(t.data.duration), t.data.to = n, t.data.target = r;
  var i = voe(t), a = v7e.bind(null, i, t);
  if (t && t.delay > 0) {
    t.data.delayTimeout = window.setTimeout(function() {
      aa.default.registered.begin && aa.default.registered.begin(t.data.to, t.data.target), OP.call(window, a);
    }, t.delay);
    return;
  }
  aa.default.registered.begin && aa.default.registered.begin(t.data.to, t.data.target), OP.call(window, a);
}, qO = function(e) {
  return e = a7e({}, e), e.data = e.data || yoe(), e.absolute = !0, e;
}, y7e = function(e) {
  zg(0, qO(e));
}, b7e = function(e, t) {
  zg(e, qO(t));
}, w7e = function(e) {
  e = qO(e), rj(e), zg(e.horizontal ? g7e(e) : m7e(e), e);
}, C7e = function(e, t) {
  t = qO(t), rj(t);
  var n = t.horizontal ? boe(t) : woe(t);
  zg(e + n, t);
};
VO.default = {
  animateTopScroll: zg,
  getAnimationType: voe,
  scrollToTop: y7e,
  scrollToBottom: w7e,
  scrollTo: b7e,
  scrollMore: C7e
};
Object.defineProperty(Xp, "__esModule", {
  value: !0
});
var O7e = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, x7e = Bg, E7e = oj(x7e), k7e = VO, L7e = oj(k7e), _7e = Fg, Qv = oj(_7e);
function oj(e) {
  return e && e.__esModule ? e : { default: e };
}
var ey = {}, $5 = void 0;
Xp.default = {
  unmount: function() {
    ey = {};
  },
  register: function(e, t) {
    ey[e] = t;
  },
  unregister: function(e) {
    delete ey[e];
  },
  get: function(e) {
    return ey[e] || document.getElementById(e) || document.getElementsByName(e)[0] || document.getElementsByClassName(e)[0];
  },
  setActiveLink: function(e) {
    return $5 = e;
  },
  getActiveLink: function() {
    return $5;
  },
  scrollTo: function(e, t) {
    var n = this.get(e);
    if (!n) {
      console.warn("target Element not found");
      return;
    }
    t = O7e({}, t, { absolute: !1 });
    var r = t.containerId, o = t.container, i = void 0;
    r ? i = document.getElementById(r) : o && o.nodeType ? i = o : i = document, t.absolute = !0;
    var a = t.horizontal, s = E7e.default.scrollOffset(i, n, a) + (t.offset || 0);
    if (!t.smooth) {
      Qv.default.registered.begin && Qv.default.registered.begin(e, n), i === document ? t.horizontal ? window.scrollTo(s, 0) : window.scrollTo(0, s) : i.scrollTop = s, Qv.default.registered.end && Qv.default.registered.end(e, n);
      return;
    }
    L7e.default.animateTopScroll(s, t, e, n);
  }
};
var xP = { exports: {} }, gL = { exports: {} }, Kn = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var V5;
function P7e() {
  if (V5) return Kn;
  V5 = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, g = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, m = e ? Symbol.for("react.block") : 60121, b = e ? Symbol.for("react.fundamental") : 60117, E = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
  function M(v) {
    if (typeof v == "object" && v !== null) {
      var C = v.$$typeof;
      switch (C) {
        case t:
          switch (v = v.type, v) {
            case l:
            case u:
            case r:
            case i:
            case o:
            case p:
              return v;
            default:
              switch (v = v && v.$$typeof, v) {
                case s:
                case c:
                case f:
                case g:
                case a:
                  return v;
                default:
                  return C;
              }
          }
        case n:
          return C;
      }
    }
  }
  function x(v) {
    return M(v) === u;
  }
  return Kn.AsyncMode = l, Kn.ConcurrentMode = u, Kn.ContextConsumer = s, Kn.ContextProvider = a, Kn.Element = t, Kn.ForwardRef = c, Kn.Fragment = r, Kn.Lazy = f, Kn.Memo = g, Kn.Portal = n, Kn.Profiler = i, Kn.StrictMode = o, Kn.Suspense = p, Kn.isAsyncMode = function(v) {
    return x(v) || M(v) === l;
  }, Kn.isConcurrentMode = x, Kn.isContextConsumer = function(v) {
    return M(v) === s;
  }, Kn.isContextProvider = function(v) {
    return M(v) === a;
  }, Kn.isElement = function(v) {
    return typeof v == "object" && v !== null && v.$$typeof === t;
  }, Kn.isForwardRef = function(v) {
    return M(v) === c;
  }, Kn.isFragment = function(v) {
    return M(v) === r;
  }, Kn.isLazy = function(v) {
    return M(v) === f;
  }, Kn.isMemo = function(v) {
    return M(v) === g;
  }, Kn.isPortal = function(v) {
    return M(v) === n;
  }, Kn.isProfiler = function(v) {
    return M(v) === i;
  }, Kn.isStrictMode = function(v) {
    return M(v) === o;
  }, Kn.isSuspense = function(v) {
    return M(v) === p;
  }, Kn.isValidElementType = function(v) {
    return typeof v == "string" || typeof v == "function" || v === r || v === u || v === i || v === o || v === p || v === d || typeof v == "object" && v !== null && (v.$$typeof === f || v.$$typeof === g || v.$$typeof === a || v.$$typeof === s || v.$$typeof === c || v.$$typeof === b || v.$$typeof === E || v.$$typeof === w || v.$$typeof === m);
  }, Kn.typeOf = M, Kn;
}
var ir = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Z5;
function S7e() {
  return Z5 || (Z5 = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, g = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, m = e ? Symbol.for("react.block") : 60121, b = e ? Symbol.for("react.fundamental") : 60117, E = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
    function M(I) {
      return typeof I == "string" || typeof I == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      I === r || I === u || I === i || I === o || I === p || I === d || typeof I == "object" && I !== null && (I.$$typeof === f || I.$$typeof === g || I.$$typeof === a || I.$$typeof === s || I.$$typeof === c || I.$$typeof === b || I.$$typeof === E || I.$$typeof === w || I.$$typeof === m);
    }
    function x(I) {
      if (typeof I == "object" && I !== null) {
        var le = I.$$typeof;
        switch (le) {
          case t:
            var he = I.type;
            switch (he) {
              case l:
              case u:
              case r:
              case i:
              case o:
              case p:
                return he;
              default:
                var oe = he && he.$$typeof;
                switch (oe) {
                  case s:
                  case c:
                  case f:
                  case g:
                  case a:
                    return oe;
                  default:
                    return le;
                }
            }
          case n:
            return le;
        }
      }
    }
    var v = l, C = u, P = s, F = a, L = t, B = c, N = r, $ = f, V = g, H = n, Z = i, K = o, Y = p, Q = !1;
    function J(I) {
      return Q || (Q = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), _(I) || x(I) === l;
    }
    function _(I) {
      return x(I) === u;
    }
    function D(I) {
      return x(I) === s;
    }
    function z(I) {
      return x(I) === a;
    }
    function S(I) {
      return typeof I == "object" && I !== null && I.$$typeof === t;
    }
    function W(I) {
      return x(I) === c;
    }
    function O(I) {
      return x(I) === r;
    }
    function j(I) {
      return x(I) === f;
    }
    function U(I) {
      return x(I) === g;
    }
    function T(I) {
      return x(I) === n;
    }
    function q(I) {
      return x(I) === i;
    }
    function A(I) {
      return x(I) === o;
    }
    function X(I) {
      return x(I) === p;
    }
    ir.AsyncMode = v, ir.ConcurrentMode = C, ir.ContextConsumer = P, ir.ContextProvider = F, ir.Element = L, ir.ForwardRef = B, ir.Fragment = N, ir.Lazy = $, ir.Memo = V, ir.Portal = H, ir.Profiler = Z, ir.StrictMode = K, ir.Suspense = Y, ir.isAsyncMode = J, ir.isConcurrentMode = _, ir.isContextConsumer = D, ir.isContextProvider = z, ir.isElement = S, ir.isForwardRef = W, ir.isFragment = O, ir.isLazy = j, ir.isMemo = U, ir.isPortal = T, ir.isProfiler = q, ir.isStrictMode = A, ir.isSuspense = X, ir.isValidElementType = M, ir.typeOf = x;
  }()), ir;
}
var q5;
function Coe() {
  return q5 || (q5 = 1, process.env.NODE_ENV === "production" ? gL.exports = P7e() : gL.exports = S7e()), gL.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var mL, G5;
function M7e() {
  if (G5) return mL;
  G5 = 1;
  var e = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, n = Object.prototype.propertyIsEnumerable;
  function r(i) {
    if (i == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(i);
  }
  function o() {
    try {
      if (!Object.assign)
        return !1;
      var i = new String("abc");
      if (i[5] = "de", Object.getOwnPropertyNames(i)[0] === "5")
        return !1;
      for (var a = {}, s = 0; s < 10; s++)
        a["_" + String.fromCharCode(s)] = s;
      var l = Object.getOwnPropertyNames(a).map(function(c) {
        return a[c];
      });
      if (l.join("") !== "0123456789")
        return !1;
      var u = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(c) {
        u[c] = c;
      }), Object.keys(Object.assign({}, u)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return mL = o() ? Object.assign : function(i, a) {
    for (var s, l = r(i), u, c = 1; c < arguments.length; c++) {
      s = Object(arguments[c]);
      for (var p in s)
        t.call(s, p) && (l[p] = s[p]);
      if (e) {
        u = e(s);
        for (var d = 0; d < u.length; d++)
          n.call(s, u[d]) && (l[u[d]] = s[u[d]]);
      }
    }
    return l;
  }, mL;
}
var vL, K5;
function ij() {
  if (K5) return vL;
  K5 = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return vL = e, vL;
}
var X5, Y5;
function Ooe() {
  return Y5 || (Y5 = 1, X5 = Function.call.bind(Object.prototype.hasOwnProperty)), X5;
}
var yL, J5;
function D7e() {
  if (J5) return yL;
  J5 = 1;
  var e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = ij(), n = {}, r = Ooe();
    e = function(i) {
      var a = "Warning: " + i;
      typeof console < "u" && console.error(a);
      try {
        throw new Error(a);
      } catch {
      }
    };
  }
  function o(i, a, s, l, u) {
    if (process.env.NODE_ENV !== "production") {
      for (var c in i)
        if (r(i, c)) {
          var p;
          try {
            if (typeof i[c] != "function") {
              var d = Error(
                (l || "React class") + ": " + s + " type `" + c + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof i[c] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw d.name = "Invariant Violation", d;
            }
            p = i[c](a, c, l, s, null, t);
          } catch (f) {
            p = f;
          }
          if (p && !(p instanceof Error) && e(
            (l || "React class") + ": type specification of " + s + " `" + c + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof p + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), p instanceof Error && !(p.message in n)) {
            n[p.message] = !0;
            var g = u ? u() : "";
            e(
              "Failed " + s + " type: " + p.message + (g ?? "")
            );
          }
        }
    }
  }
  return o.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (n = {});
  }, yL = o, yL;
}
var bL, Q5;
function T7e() {
  if (Q5) return bL;
  Q5 = 1;
  var e = Coe(), t = M7e(), n = ij(), r = Ooe(), o = D7e(), i = function() {
  };
  process.env.NODE_ENV !== "production" && (i = function(s) {
    var l = "Warning: " + s;
    typeof console < "u" && console.error(l);
    try {
      throw new Error(l);
    } catch {
    }
  });
  function a() {
    return null;
  }
  return bL = function(s, l) {
    var u = typeof Symbol == "function" && Symbol.iterator, c = "@@iterator";
    function p(_) {
      var D = _ && (u && _[u] || _[c]);
      if (typeof D == "function")
        return D;
    }
    var d = "<<anonymous>>", g = {
      array: E("array"),
      bigint: E("bigint"),
      bool: E("boolean"),
      func: E("function"),
      number: E("number"),
      object: E("object"),
      string: E("string"),
      symbol: E("symbol"),
      any: w(),
      arrayOf: M,
      element: x(),
      elementType: v(),
      instanceOf: C,
      node: B(),
      objectOf: F,
      oneOf: P,
      oneOfType: L,
      shape: $,
      exact: V
    };
    function f(_, D) {
      return _ === D ? _ !== 0 || 1 / _ === 1 / D : _ !== _ && D !== D;
    }
    function m(_, D) {
      this.message = _, this.data = D && typeof D == "object" ? D : {}, this.stack = "";
    }
    m.prototype = Error.prototype;
    function b(_) {
      if (process.env.NODE_ENV !== "production")
        var D = {}, z = 0;
      function S(O, j, U, T, q, A, X) {
        if (T = T || d, A = A || U, X !== n) {
          if (l) {
            var I = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw I.name = "Invariant Violation", I;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var le = T + ":" + U;
            !D[le] && // Avoid spamming the console because they are often not actionable except for lib authors
            z < 3 && (i(
              "You are manually calling a React.PropTypes validation function for the `" + A + "` prop on `" + T + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), D[le] = !0, z++);
          }
        }
        return j[U] == null ? O ? j[U] === null ? new m("The " + q + " `" + A + "` is marked as required " + ("in `" + T + "`, but its value is `null`.")) : new m("The " + q + " `" + A + "` is marked as required in " + ("`" + T + "`, but its value is `undefined`.")) : null : _(j, U, T, q, A);
      }
      var W = S.bind(null, !1);
      return W.isRequired = S.bind(null, !0), W;
    }
    function E(_) {
      function D(z, S, W, O, j, U) {
        var T = z[S], q = K(T);
        if (q !== _) {
          var A = Y(T);
          return new m(
            "Invalid " + O + " `" + j + "` of type " + ("`" + A + "` supplied to `" + W + "`, expected ") + ("`" + _ + "`."),
            { expectedType: _ }
          );
        }
        return null;
      }
      return b(D);
    }
    function w() {
      return b(a);
    }
    function M(_) {
      function D(z, S, W, O, j) {
        if (typeof _ != "function")
          return new m("Property `" + j + "` of component `" + W + "` has invalid PropType notation inside arrayOf.");
        var U = z[S];
        if (!Array.isArray(U)) {
          var T = K(U);
          return new m("Invalid " + O + " `" + j + "` of type " + ("`" + T + "` supplied to `" + W + "`, expected an array."));
        }
        for (var q = 0; q < U.length; q++) {
          var A = _(U, q, W, O, j + "[" + q + "]", n);
          if (A instanceof Error)
            return A;
        }
        return null;
      }
      return b(D);
    }
    function x() {
      function _(D, z, S, W, O) {
        var j = D[z];
        if (!s(j)) {
          var U = K(j);
          return new m("Invalid " + W + " `" + O + "` of type " + ("`" + U + "` supplied to `" + S + "`, expected a single ReactElement."));
        }
        return null;
      }
      return b(_);
    }
    function v() {
      function _(D, z, S, W, O) {
        var j = D[z];
        if (!e.isValidElementType(j)) {
          var U = K(j);
          return new m("Invalid " + W + " `" + O + "` of type " + ("`" + U + "` supplied to `" + S + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return b(_);
    }
    function C(_) {
      function D(z, S, W, O, j) {
        if (!(z[S] instanceof _)) {
          var U = _.name || d, T = J(z[S]);
          return new m("Invalid " + O + " `" + j + "` of type " + ("`" + T + "` supplied to `" + W + "`, expected ") + ("instance of `" + U + "`."));
        }
        return null;
      }
      return b(D);
    }
    function P(_) {
      if (!Array.isArray(_))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? i(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : i("Invalid argument supplied to oneOf, expected an array.")), a;
      function D(z, S, W, O, j) {
        for (var U = z[S], T = 0; T < _.length; T++)
          if (f(U, _[T]))
            return null;
        var q = JSON.stringify(_, function(A, X) {
          var I = Y(X);
          return I === "symbol" ? String(X) : X;
        });
        return new m("Invalid " + O + " `" + j + "` of value `" + String(U) + "` " + ("supplied to `" + W + "`, expected one of " + q + "."));
      }
      return b(D);
    }
    function F(_) {
      function D(z, S, W, O, j) {
        if (typeof _ != "function")
          return new m("Property `" + j + "` of component `" + W + "` has invalid PropType notation inside objectOf.");
        var U = z[S], T = K(U);
        if (T !== "object")
          return new m("Invalid " + O + " `" + j + "` of type " + ("`" + T + "` supplied to `" + W + "`, expected an object."));
        for (var q in U)
          if (r(U, q)) {
            var A = _(U, q, W, O, j + "." + q, n);
            if (A instanceof Error)
              return A;
          }
        return null;
      }
      return b(D);
    }
    function L(_) {
      if (!Array.isArray(_))
        return process.env.NODE_ENV !== "production" && i("Invalid argument supplied to oneOfType, expected an instance of array."), a;
      for (var D = 0; D < _.length; D++) {
        var z = _[D];
        if (typeof z != "function")
          return i(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + Q(z) + " at index " + D + "."
          ), a;
      }
      function S(W, O, j, U, T) {
        for (var q = [], A = 0; A < _.length; A++) {
          var X = _[A], I = X(W, O, j, U, T, n);
          if (I == null)
            return null;
          I.data && r(I.data, "expectedType") && q.push(I.data.expectedType);
        }
        var le = q.length > 0 ? ", expected one of type [" + q.join(", ") + "]" : "";
        return new m("Invalid " + U + " `" + T + "` supplied to " + ("`" + j + "`" + le + "."));
      }
      return b(S);
    }
    function B() {
      function _(D, z, S, W, O) {
        return H(D[z]) ? null : new m("Invalid " + W + " `" + O + "` supplied to " + ("`" + S + "`, expected a ReactNode."));
      }
      return b(_);
    }
    function N(_, D, z, S, W) {
      return new m(
        (_ || "React class") + ": " + D + " type `" + z + "." + S + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + W + "`."
      );
    }
    function $(_) {
      function D(z, S, W, O, j) {
        var U = z[S], T = K(U);
        if (T !== "object")
          return new m("Invalid " + O + " `" + j + "` of type `" + T + "` " + ("supplied to `" + W + "`, expected `object`."));
        for (var q in _) {
          var A = _[q];
          if (typeof A != "function")
            return N(W, O, j, q, Y(A));
          var X = A(U, q, W, O, j + "." + q, n);
          if (X)
            return X;
        }
        return null;
      }
      return b(D);
    }
    function V(_) {
      function D(z, S, W, O, j) {
        var U = z[S], T = K(U);
        if (T !== "object")
          return new m("Invalid " + O + " `" + j + "` of type `" + T + "` " + ("supplied to `" + W + "`, expected `object`."));
        var q = t({}, z[S], _);
        for (var A in q) {
          var X = _[A];
          if (r(_, A) && typeof X != "function")
            return N(W, O, j, A, Y(X));
          if (!X)
            return new m(
              "Invalid " + O + " `" + j + "` key `" + A + "` supplied to `" + W + "`.\nBad object: " + JSON.stringify(z[S], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(_), null, "  ")
            );
          var I = X(U, A, W, O, j + "." + A, n);
          if (I)
            return I;
        }
        return null;
      }
      return b(D);
    }
    function H(_) {
      switch (typeof _) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !_;
        case "object":
          if (Array.isArray(_))
            return _.every(H);
          if (_ === null || s(_))
            return !0;
          var D = p(_);
          if (D) {
            var z = D.call(_), S;
            if (D !== _.entries) {
              for (; !(S = z.next()).done; )
                if (!H(S.value))
                  return !1;
            } else
              for (; !(S = z.next()).done; ) {
                var W = S.value;
                if (W && !H(W[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function Z(_, D) {
      return _ === "symbol" ? !0 : D ? D["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && D instanceof Symbol : !1;
    }
    function K(_) {
      var D = typeof _;
      return Array.isArray(_) ? "array" : _ instanceof RegExp ? "object" : Z(D, _) ? "symbol" : D;
    }
    function Y(_) {
      if (typeof _ > "u" || _ === null)
        return "" + _;
      var D = K(_);
      if (D === "object") {
        if (_ instanceof Date)
          return "date";
        if (_ instanceof RegExp)
          return "regexp";
      }
      return D;
    }
    function Q(_) {
      var D = Y(_);
      switch (D) {
        case "array":
        case "object":
          return "an " + D;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + D;
        default:
          return D;
      }
    }
    function J(_) {
      return !_.constructor || !_.constructor.name ? d : _.constructor.name;
    }
    return g.checkPropTypes = o, g.resetWarningCache = o.resetWarningCache, g.PropTypes = g, g;
  }, bL;
}
var wL, e4;
function j7e() {
  if (e4) return wL;
  e4 = 1;
  var e = ij();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, wL = function() {
    function r(a, s, l, u, c, p) {
      if (p !== e) {
        var d = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw d.name = "Invariant Violation", d;
      }
    }
    r.isRequired = r;
    function o() {
      return r;
    }
    var i = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: o,
      element: r,
      elementType: r,
      instanceOf: o,
      node: r,
      objectOf: o,
      oneOf: o,
      oneOfType: o,
      shape: o,
      exact: o,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return i.PropTypes = i, i;
  }, wL;
}
if (process.env.NODE_ENV !== "production") {
  var A7e = Coe(), R7e = !0;
  xP.exports = T7e()(A7e.isElement, R7e);
} else
  xP.exports = j7e()();
var GO = xP.exports, KO = {};
Object.defineProperty(KO, "__esModule", {
  value: !0
});
var I7e = Bg, CL = N7e(I7e);
function N7e(e) {
  return e && e.__esModule ? e : { default: e };
}
var B7e = {
  mountFlag: !1,
  initialized: !1,
  scroller: null,
  containers: {},
  mount: function(e) {
    this.scroller = e, this.handleHashChange = this.handleHashChange.bind(this), window.addEventListener("hashchange", this.handleHashChange), this.initStateFromHash(), this.mountFlag = !0;
  },
  mapContainer: function(e, t) {
    this.containers[e] = t;
  },
  isMounted: function() {
    return this.mountFlag;
  },
  isInitialized: function() {
    return this.initialized;
  },
  initStateFromHash: function() {
    var e = this, t = this.getHash();
    t ? window.setTimeout(function() {
      e.scrollTo(t, !0), e.initialized = !0;
    }, 10) : this.initialized = !0;
  },
  scrollTo: function(e, t) {
    var n = this.scroller, r = n.get(e);
    if (r && (t || e !== n.getActiveLink())) {
      var o = this.containers[e] || document;
      n.scrollTo(e, { container: o });
    }
  },
  getHash: function() {
    return CL.default.getHash();
  },
  changeHash: function(e, t) {
    this.isInitialized() && CL.default.getHash() !== e && CL.default.updateHash(e, t);
  },
  handleHashChange: function() {
    this.scrollTo(this.getHash());
  },
  unmount: function() {
    this.scroller = null, this.containers = null, window.removeEventListener("hashchange", this.handleHashChange);
  }
};
KO.default = B7e;
Object.defineProperty(Rg, "__esModule", {
  value: !0
});
var ty = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, F7e = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), z7e = be, t4 = Ug(z7e), U7e = Ig, ny = Ug(U7e), H7e = Xp, W7e = Ug(H7e), $7e = GO, ro = Ug($7e), V7e = KO, Ll = Ug(V7e);
function Ug(e) {
  return e && e.__esModule ? e : { default: e };
}
function Z7e(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function q7e(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function G7e(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var n4 = {
  to: ro.default.string.isRequired,
  containerId: ro.default.string,
  container: ro.default.object,
  activeClass: ro.default.string,
  activeStyle: ro.default.object,
  spy: ro.default.bool,
  horizontal: ro.default.bool,
  smooth: ro.default.oneOfType([ro.default.bool, ro.default.string]),
  offset: ro.default.number,
  delay: ro.default.number,
  isDynamic: ro.default.bool,
  onClick: ro.default.func,
  duration: ro.default.oneOfType([ro.default.number, ro.default.func]),
  absolute: ro.default.bool,
  onSetActive: ro.default.func,
  onSetInactive: ro.default.func,
  ignoreCancelEvents: ro.default.bool,
  hashSpy: ro.default.bool,
  saveHashHistory: ro.default.bool,
  spyThrottle: ro.default.number
};
Rg.default = function(e, t) {
  var n = t || W7e.default, r = function(i) {
    G7e(a, i);
    function a(s) {
      Z7e(this, a);
      var l = q7e(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
      return o.call(l), l.state = {
        active: !1
      }, l.beforeUnmountCallbacks = [], l;
    }
    return F7e(a, [{
      key: "getScrollSpyContainer",
      value: function() {
        var s = this.props.containerId, l = this.props.container;
        return s && !l ? document.getElementById(s) : l && l.nodeType ? l : document;
      }
    }, {
      key: "componentDidMount",
      value: function() {
        if (this.props.spy || this.props.hashSpy) {
          var s = this.getScrollSpyContainer();
          if (!ny.default.isMounted(s)) {
            var l = ny.default.mount(s, this.props.spyThrottle);
            this.beforeUnmountCallbacks.push(l);
          }
          this.props.hashSpy && (Ll.default.isMounted() || Ll.default.mount(n), Ll.default.mapContainer(this.props.to, s)), ny.default.addSpyHandler(this.spyHandler, s), this.setState({
            container: s
          });
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        ny.default.unmount(this.stateHandler, this.spyHandler), this.beforeUnmountCallbacks.forEach(function(s) {
          return s();
        });
      }
    }, {
      key: "render",
      value: function() {
        var s = "";
        this.state && this.state.active ? s = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : s = this.props.className;
        var l = {};
        this.state && this.state.active ? l = ty({}, this.props.style, this.props.activeStyle) : l = ty({}, this.props.style);
        var u = ty({}, this.props);
        for (var c in n4)
          u.hasOwnProperty(c) && delete u[c];
        return u.className = s, u.style = l, u.onClick = this.handleClick, t4.default.createElement(e, u);
      }
    }]), a;
  }(t4.default.PureComponent), o = function() {
    var i = this;
    this.scrollTo = function(a, s) {
      n.scrollTo(a, ty({}, i.state, s));
    }, this.handleClick = function(a) {
      i.props.onClick && i.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), i.scrollTo(i.props.to, i.props);
    }, this.spyHandler = function(a, s) {
      var l = i.getScrollSpyContainer();
      if (!(Ll.default.isMounted() && !Ll.default.isInitialized())) {
        var u = i.props.horizontal, c = i.props.to, p = null, d = void 0, g = void 0;
        if (u) {
          var f = 0, m = 0, b = 0;
          if (l.getBoundingClientRect) {
            var E = l.getBoundingClientRect();
            b = E.left;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var w = p.getBoundingClientRect();
            f = w.left - b + a, m = f + w.width;
          }
          var M = a - i.props.offset;
          d = M >= Math.floor(f) && M < Math.floor(m), g = M < Math.floor(f) || M >= Math.floor(m);
        } else {
          var x = 0, v = 0, C = 0;
          if (l.getBoundingClientRect) {
            var P = l.getBoundingClientRect();
            C = P.top;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var F = p.getBoundingClientRect();
            x = F.top - C + s, v = x + F.height;
          }
          var L = s - i.props.offset;
          d = L >= Math.floor(x) && L < Math.floor(v), g = L < Math.floor(x) || L >= Math.floor(v);
        }
        var B = n.getActiveLink();
        if (g) {
          if (c === B && n.setActiveLink(void 0), i.props.hashSpy && Ll.default.getHash() === c) {
            var N = i.props.saveHashHistory, $ = N === void 0 ? !1 : N;
            Ll.default.changeHash("", $);
          }
          i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive(c, p));
        }
        if (d && (B !== c || i.state.active === !1)) {
          n.setActiveLink(c);
          var V = i.props.saveHashHistory, H = V === void 0 ? !1 : V;
          i.props.hashSpy && Ll.default.changeHash(c, H), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(c, p));
        }
      }
    };
  };
  return r.propTypes = n4, r.defaultProps = { offset: 0 }, r;
};
Object.defineProperty(ej, "__esModule", {
  value: !0
});
var K7e = be, r4 = xoe(K7e), X7e = Rg, Y7e = xoe(X7e);
function xoe(e) {
  return e && e.__esModule ? e : { default: e };
}
function J7e(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function o4(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function Q7e(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var eqe = function(e) {
  Q7e(t, e);
  function t() {
    var n, r, o, i;
    J7e(this, t);
    for (var a = arguments.length, s = Array(a), l = 0; l < a; l++)
      s[l] = arguments[l];
    return i = (r = (o = o4(this, (n = t.__proto__ || Object.getPrototypeOf(t)).call.apply(n, [this].concat(s))), o), o.render = function() {
      return r4.default.createElement(
        "a",
        o.props,
        o.props.children
      );
    }, r), o4(o, i);
  }
  return t;
}(r4.default.Component);
ej.default = (0, Y7e.default)(eqe);
var sj = {};
Object.defineProperty(sj, "__esModule", {
  value: !0
});
var tqe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), nqe = be, i4 = Eoe(nqe), rqe = Rg, oqe = Eoe(rqe);
function Eoe(e) {
  return e && e.__esModule ? e : { default: e };
}
function iqe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function sqe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function aqe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var lqe = function(e) {
  aqe(t, e);
  function t() {
    return iqe(this, t), sqe(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return tqe(t, [{
    key: "render",
    value: function() {
      return i4.default.createElement(
        "button",
        this.props,
        this.props.children
      );
    }
  }]), t;
}(i4.default.Component);
sj.default = (0, oqe.default)(lqe);
var aj = {}, XO = {};
Object.defineProperty(XO, "__esModule", {
  value: !0
});
var uqe = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, cqe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), pqe = be, s4 = YO(pqe), dqe = il;
YO(dqe);
var fqe = Xp, a4 = YO(fqe), hqe = GO, l4 = YO(hqe);
function YO(e) {
  return e && e.__esModule ? e : { default: e };
}
function gqe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function mqe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function vqe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
XO.default = function(e) {
  var t = function(n) {
    vqe(r, n);
    function r(o) {
      gqe(this, r);
      var i = mqe(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
      return i.childBindings = {
        domNode: null
      }, i;
    }
    return cqe(r, [{
      key: "componentDidMount",
      value: function() {
        if (typeof window > "u")
          return !1;
        this.registerElems(this.props.name);
      }
    }, {
      key: "componentDidUpdate",
      value: function(o) {
        this.props.name !== o.name && this.registerElems(this.props.name);
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        if (typeof window > "u")
          return !1;
        a4.default.unregister(this.props.name);
      }
    }, {
      key: "registerElems",
      value: function(o) {
        a4.default.register(o, this.childBindings.domNode);
      }
    }, {
      key: "render",
      value: function() {
        return s4.default.createElement(e, uqe({}, this.props, { parentBindings: this.childBindings }));
      }
    }]), r;
  }(s4.default.Component);
  return t.propTypes = {
    name: l4.default.string,
    id: l4.default.string
  }, t;
};
Object.defineProperty(aj, "__esModule", {
  value: !0
});
var u4 = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, yqe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), bqe = be, c4 = lj(bqe), wqe = XO, Cqe = lj(wqe), Oqe = GO, p4 = lj(Oqe);
function lj(e) {
  return e && e.__esModule ? e : { default: e };
}
function xqe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Eqe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function kqe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var koe = function(e) {
  kqe(t, e);
  function t() {
    return xqe(this, t), Eqe(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return yqe(t, [{
    key: "render",
    value: function() {
      var n = this, r = u4({}, this.props);
      return delete r.name, r.parentBindings && delete r.parentBindings, c4.default.createElement(
        "div",
        u4({}, r, { ref: function(o) {
          n.props.parentBindings.domNode = o;
        } }),
        this.props.children
      );
    }
  }]), t;
}(c4.default.Component);
koe.propTypes = {
  name: p4.default.string,
  id: p4.default.string
};
aj.default = (0, Cqe.default)(koe);
var OL = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, d4 = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}();
function f4(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function h4(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function g4(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var ry = be, Vu = Ig, xL = Xp, Eo = GO, _l = KO, m4 = {
  to: Eo.string.isRequired,
  containerId: Eo.string,
  container: Eo.object,
  activeClass: Eo.string,
  spy: Eo.bool,
  smooth: Eo.oneOfType([Eo.bool, Eo.string]),
  offset: Eo.number,
  delay: Eo.number,
  isDynamic: Eo.bool,
  onClick: Eo.func,
  duration: Eo.oneOfType([Eo.number, Eo.func]),
  absolute: Eo.bool,
  onSetActive: Eo.func,
  onSetInactive: Eo.func,
  ignoreCancelEvents: Eo.bool,
  hashSpy: Eo.bool,
  spyThrottle: Eo.number
}, Lqe = {
  Scroll: function(e, t) {
    console.warn("Helpers.Scroll is deprecated since v1.7.0");
    var n = t || xL, r = function(i) {
      g4(a, i);
      function a(s) {
        f4(this, a);
        var l = h4(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
        return o.call(l), l.state = {
          active: !1
        }, l;
      }
      return d4(a, [{
        key: "getScrollSpyContainer",
        value: function() {
          var s = this.props.containerId, l = this.props.container;
          return s ? document.getElementById(s) : l && l.nodeType ? l : document;
        }
      }, {
        key: "componentDidMount",
        value: function() {
          if (this.props.spy || this.props.hashSpy) {
            var s = this.getScrollSpyContainer();
            Vu.isMounted(s) || Vu.mount(s, this.props.spyThrottle), this.props.hashSpy && (_l.isMounted() || _l.mount(n), _l.mapContainer(this.props.to, s)), this.props.spy && Vu.addStateHandler(this.stateHandler), Vu.addSpyHandler(this.spyHandler, s), this.setState({
              container: s
            });
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          Vu.unmount(this.stateHandler, this.spyHandler);
        }
      }, {
        key: "render",
        value: function() {
          var s = "";
          this.state && this.state.active ? s = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : s = this.props.className;
          var l = OL({}, this.props);
          for (var u in m4)
            l.hasOwnProperty(u) && delete l[u];
          return l.className = s, l.onClick = this.handleClick, ry.createElement(e, l);
        }
      }]), a;
    }(ry.Component), o = function() {
      var i = this;
      this.scrollTo = function(a, s) {
        n.scrollTo(a, OL({}, i.state, s));
      }, this.handleClick = function(a) {
        i.props.onClick && i.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), i.scrollTo(i.props.to, i.props);
      }, this.stateHandler = function() {
        n.getActiveLink() !== i.props.to && (i.state !== null && i.state.active && i.props.onSetInactive && i.props.onSetInactive(), i.setState({ active: !1 }));
      }, this.spyHandler = function(a) {
        var s = i.getScrollSpyContainer();
        if (!(_l.isMounted() && !_l.isInitialized())) {
          var l = i.props.to, u = null, c = 0, p = 0, d = 0;
          if (s.getBoundingClientRect) {
            var g = s.getBoundingClientRect();
            d = g.top;
          }
          if (!u || i.props.isDynamic) {
            if (u = n.get(l), !u)
              return;
            var f = u.getBoundingClientRect();
            c = f.top - d + a, p = c + f.height;
          }
          var m = a - i.props.offset, b = m >= Math.floor(c) && m < Math.floor(p), E = m < Math.floor(c) || m >= Math.floor(p), w = n.getActiveLink();
          if (E)
            return l === w && n.setActiveLink(void 0), i.props.hashSpy && _l.getHash() === l && _l.changeHash(), i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive()), Vu.updateStates();
          if (b && w !== l)
            return n.setActiveLink(l), i.props.hashSpy && _l.changeHash(l), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(l)), Vu.updateStates();
        }
      };
    };
    return r.propTypes = m4, r.defaultProps = { offset: 0 }, r;
  },
  Element: function(e) {
    console.warn("Helpers.Element is deprecated since v1.7.0");
    var t = function(n) {
      g4(r, n);
      function r(o) {
        f4(this, r);
        var i = h4(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
        return i.childBindings = {
          domNode: null
        }, i;
      }
      return d4(r, [{
        key: "componentDidMount",
        value: function() {
          if (typeof window > "u")
            return !1;
          this.registerElems(this.props.name);
        }
      }, {
        key: "componentDidUpdate",
        value: function(o) {
          this.props.name !== o.name && this.registerElems(this.props.name);
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          if (typeof window > "u")
            return !1;
          xL.unregister(this.props.name);
        }
      }, {
        key: "registerElems",
        value: function(o) {
          xL.register(o, this.childBindings.domNode);
        }
      }, {
        key: "render",
        value: function() {
          return ry.createElement(e, OL({}, this.props, { parentBindings: this.childBindings }));
        }
      }]), r;
    }(ry.Component);
    return t.propTypes = {
      name: Eo.string,
      id: Eo.string
    }, t;
  }
}, _qe = Lqe;
Object.defineProperty(Fo, "__esModule", {
  value: !0
});
Fo.Helpers = Fo.ScrollElement = Fo.ScrollLink = Fo.animateScroll = Fo.scrollSpy = Fo.Events = Fo.scroller = Fo.Element = Fo.Button = Fo.Link = void 0;
var Pqe = ej, Loe = xa(Pqe), Sqe = sj, _oe = xa(Sqe), Mqe = aj, Poe = xa(Mqe), Dqe = Xp, Soe = xa(Dqe), Tqe = Fg, Moe = xa(Tqe), jqe = Ig, Doe = xa(jqe), Aqe = VO, Toe = xa(Aqe), Rqe = Rg, joe = xa(Rqe), Iqe = XO, Aoe = xa(Iqe), Nqe = _qe, Roe = xa(Nqe);
function xa(e) {
  return e && e.__esModule ? e : { default: e };
}
Fo.Link = Loe.default;
Fo.Button = _oe.default;
Fo.Element = Poe.default;
Fo.scroller = Soe.default;
Fo.Events = Moe.default;
Fo.scrollSpy = Doe.default;
Fo.animateScroll = Toe.default;
Fo.ScrollLink = joe.default;
Fo.ScrollElement = Aoe.default;
Fo.Helpers = Roe.default;
Fo.default = { Link: Loe.default, Button: _oe.default, Element: Poe.default, scroller: Soe.default, Events: Moe.default, scrollSpy: Doe.default, animateScroll: Toe.default, ScrollLink: joe.default, ScrollElement: Aoe.default, Helpers: Roe.default };
$e({});
$e({});
$e({});
function zh(e) {
  "@babel/helpers - typeof";
  return zh = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, zh(e);
}
function Bqe(e, t) {
  if (zh(e) != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (zh(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function Fqe(e) {
  var t = Bqe(e, "string");
  return zh(t) == "symbol" ? t : t + "";
}
function Te(e, t, n) {
  return (t = Fqe(t)) in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function Ioe(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var EL, v4;
function zqe() {
  if (v4) return EL;
  v4 = 1;
  var e = process.env.NODE_ENV, t = function(n, r, o, i, a, s, l, u) {
    if (e !== "production" && r === void 0)
      throw new Error("invariant requires an error message argument");
    if (!n) {
      var c;
      if (r === void 0)
        c = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
      else {
        var p = [o, i, a, s, l, u], d = 0;
        c = new Error(r.replace(/%s/g, function() {
          return p[d++];
        })), c.name = "Invariant Violation";
      }
      throw c.framesToPop = 1, c;
    }
  };
  return EL = t, EL;
}
var Uqe = zqe(), qo = /* @__PURE__ */ Ioe(Uqe), Ut = $e(null);
function Hqe() {
  qo(!!ge, "useGoogleMap is React hook and requires React version 16.8+");
  var e = ge(Ut);
  return qo(!!e, "useGoogleMap needs a GoogleMap available up in the tree"), e;
}
function Wqe(e, t, n) {
  return Object.keys(e).reduce(function(r, o) {
    return t(r, e[o], o);
  }, n);
}
function $qe(e, t) {
  Object.keys(e).forEach((n) => t(e[n], n));
}
function Vqe(e, t, n, r) {
  var o = {}, i = (a, s) => {
    var l = n[s];
    l !== t[s] && (o[s] = l, a(r, l));
  };
  return $qe(e, i), o;
}
function Zqe(e, t, n) {
  var r = Wqe(n, function(o, i, a) {
    return typeof e[a] == "function" && o.push(google.maps.event.addListener(t, i, e[a])), o;
  }, []);
  return r;
}
function qqe(e) {
  google.maps.event.removeListener(e);
}
function Mn() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  e.forEach(qqe);
}
function xn(e) {
  var {
    updaterMap: t,
    eventMap: n,
    prevProps: r,
    nextProps: o,
    instance: i
  } = e, a = Zqe(o, i, n);
  return Vqe(t, r, o, i), a;
}
function Gqe(e) {
  var {
    children: t,
    options: n,
    id: r,
    mapContainerStyle: o,
    mapContainerClassName: i,
    center: a,
    // clickableIcons,
    // extraMapTypes,
    // heading,
    // mapTypeId,
    onClick: s,
    onDblClick: l,
    onDrag: u,
    onDragEnd: c,
    onDragStart: p,
    onMouseMove: d,
    onMouseOut: g,
    onMouseOver: f,
    onMouseDown: m,
    onMouseUp: b,
    onRightClick: E,
    // onMapTypeIdChanged,
    // onTilesLoaded,
    // onBoundsChanged,
    onCenterChanged: w,
    // onHeadingChanged,
    // onIdle,
    // onProjectionChanged,
    // onResize,
    // onTiltChanged,
    // onZoomChanged,
    onLoad: M,
    onUnmount: x
  } = e, [v, C] = k(null), P = dt(null), [F, L] = k(null), [B, N] = k(null), [$, V] = k(null), [H, Z] = k(null), [K, Y] = k(null), [Q, J] = k(null), [_, D] = k(null), [z, S] = k(null), [W, O] = k(null), [j, U] = k(null), [T, q] = k(null), [A, X] = k(null);
  return h(() => {
    n && v !== null && v.setOptions(n);
  }, [v, n]), h(() => {
    v !== null && typeof a < "u" && v.setCenter(a);
  }, [v, a]), h(() => {
    v && l && (B !== null && google.maps.event.removeListener(B), N(google.maps.event.addListener(v, "dblclick", l)));
  }, [l]), h(() => {
    v && c && ($ !== null && google.maps.event.removeListener($), V(google.maps.event.addListener(v, "dragend", c)));
  }, [c]), h(() => {
    v && p && (H !== null && google.maps.event.removeListener(H), Z(google.maps.event.addListener(v, "dragstart", p)));
  }, [p]), h(() => {
    v && m && (K !== null && google.maps.event.removeListener(K), Y(google.maps.event.addListener(v, "mousedown", m)));
  }, [m]), h(() => {
    v && d && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(v, "mousemove", d)));
  }, [d]), h(() => {
    v && g && (_ !== null && google.maps.event.removeListener(_), D(google.maps.event.addListener(v, "mouseout", g)));
  }, [g]), h(() => {
    v && f && (z !== null && google.maps.event.removeListener(z), S(google.maps.event.addListener(v, "mouseover", f)));
  }, [f]), h(() => {
    v && b && (W !== null && google.maps.event.removeListener(W), O(google.maps.event.addListener(v, "mouseup", b)));
  }, [b]), h(() => {
    v && E && (j !== null && google.maps.event.removeListener(j), U(google.maps.event.addListener(v, "rightclick", E)));
  }, [E]), h(() => {
    v && s && (T !== null && google.maps.event.removeListener(T), q(google.maps.event.addListener(v, "click", s)));
  }, [s]), h(() => {
    v && u && (A !== null && google.maps.event.removeListener(A), X(google.maps.event.addListener(v, "drag", u)));
  }, [u]), h(() => {
    v && w && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(v, "center_changed", w)));
  }, [s]), h(() => {
    var I = P.current === null ? null : new google.maps.Map(P.current, n);
    return C(I), I !== null && M && M(I), () => {
      I !== null && x && x(I);
    };
  }, []), Fn.jsx("div", {
    id: r,
    ref: P,
    style: o,
    className: i,
    children: Fn.jsx(Ut.Provider, {
      value: v,
      children: v !== null ? t : null
    })
  });
}
me(Gqe);
function y4(e, t, n, r, o, i, a) {
  try {
    var s = e[i](a), l = s.value;
  } catch (u) {
    return void n(u);
  }
  s.done ? t(l) : Promise.resolve(l).then(r, o);
}
function Noe(e) {
  return function() {
    var t = this, n = arguments;
    return new Promise(function(r, o) {
      var i = e.apply(t, n);
      function a(l) {
        y4(i, r, o, a, s, "next", l);
      }
      function s(l) {
        y4(i, r, o, a, s, "throw", l);
      }
      a(void 0);
    });
  };
}
function Boe(e) {
  var {
    googleMapsApiKey: t,
    googleMapsClientId: n,
    version: r = "weekly",
    language: o,
    region: i,
    libraries: a,
    channel: s,
    mapIds: l,
    authReferrerPolicy: u
  } = e, c = [];
  return qo(t && n || !(t && n), "You need to specify either googleMapsApiKey or googleMapsClientId for @react-google-maps/api load script to work. You cannot use both at the same time."), t ? c.push("key=".concat(t)) : n && c.push("client=".concat(n)), r && c.push("v=".concat(r)), o && c.push("language=".concat(o)), i && c.push("region=".concat(i)), a && a.length && c.push("libraries=".concat(a.sort().join(","))), s && c.push("channel=".concat(s)), l && l.length && c.push("map_ids=".concat(l.join(","))), u && c.push("auth_referrer_policy=".concat(u)), c.push("loading=async"), c.push("callback=initMap"), "https://maps.googleapis.com/maps/api/js?".concat(c.join("&"));
}
var bc = typeof document < "u";
function Foe(e) {
  var {
    url: t,
    id: n,
    nonce: r
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } = e;
  return bc ? new Promise(function(o, i) {
    var a = document.getElementById(n), s = window;
    if (a) {
      var l = a.getAttribute("data-state");
      if (a.src === t && l !== "error") {
        if (l === "ready")
          return o(n);
        var u = s.initMap, c = a.onerror;
        s.initMap = function() {
          u && u(), o(n);
        }, a.onerror = function(d) {
          c && c(d), i(d);
        };
        return;
      } else
        a.remove();
    }
    var p = document.createElement("script");
    p.type = "text/javascript", p.src = t, p.id = n, p.async = !0, p.nonce = r || "", p.onerror = function(d) {
      p.setAttribute("data-state", "error"), i(d);
    }, s.initMap = function() {
      p.setAttribute("data-state", "ready"), o(n);
    }, document.head.appendChild(p);
  }).catch((o) => {
    throw console.error("injectScript error: ", o), o;
  }) : Promise.reject(new Error("document is undefined"));
}
function b4(e) {
  var t = e.href;
  return t && (t.indexOf("https://fonts.googleapis.com/css?family=Roboto") === 0 || t.indexOf("https://fonts.googleapis.com/css?family=Google+Sans+Text") === 0) ? !0 : (
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.styleSheet.cssText = "", !0) : (
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.innerHTML = "", !0) : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.innerHTML
      )
    )
  );
}
function zoe() {
  var e = document.getElementsByTagName("head")[0];
  if (e) {
    var t = e.insertBefore.bind(e);
    e.insertBefore = function(r, o) {
      return b4(r) || Reflect.apply(t, e, [r, o]), r;
    };
    var n = e.appendChild.bind(e);
    e.appendChild = function(r) {
      return b4(r) || Reflect.apply(n, e, [r]), r;
    };
  }
}
var Rd = !1;
function Uoe() {
  return Fn.jsx("div", {
    children: "Loading..."
  });
}
var EP = {
  id: "script-loader",
  version: "weekly"
};
class Kqe extends pe {
  constructor() {
    super(...arguments), Te(this, "check", null), Te(this, "state", {
      loaded: !1
    }), Te(this, "cleanupCallback", () => {
      delete window.google.maps, this.injectScript();
    }), Te(this, "isCleaningUp", /* @__PURE__ */ Noe(function* () {
      function t(n) {
        if (!Rd)
          n();
        else if (bc)
          var r = window.setInterval(function() {
            Rd || (window.clearInterval(r), n());
          }, 1);
      }
      return new Promise(t);
    })), Te(this, "cleanup", () => {
      Rd = !0;
      var t = document.getElementById(this.props.id);
      t && t.parentNode && t.parentNode.removeChild(t), Array.prototype.slice.call(document.getElementsByTagName("script")).filter(function(n) {
        return typeof n.src == "string" && n.src.includes("maps.googleapis");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("link")).filter(function(n) {
        return n.href === "https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Google+Sans";
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("style")).filter(function(n) {
        return n.innerText !== void 0 && n.innerText.length > 0 && n.innerText.includes(".gm-");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      });
    }), Te(this, "injectScript", () => {
      this.props.preventGoogleFontsLoading && zoe(), qo(!!this.props.id, 'LoadScript requires "id" prop to be a string: %s', this.props.id);
      var t = {
        id: this.props.id,
        nonce: this.props.nonce,
        url: Boe(this.props)
      };
      Foe(t).then(() => {
        this.props.onLoad && this.props.onLoad(), this.setState(function() {
          return {
            loaded: !0
          };
        });
      }).catch((n) => {
        this.props.onError && this.props.onError(n), console.error(`
          There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(this.props.googleMapsApiKey || "-", ") or Client ID (").concat(this.props.googleMapsClientId || "-", `) to <LoadScript />
          Otherwise it is a Network issue.
        `));
      });
    }), Te(this, "getRef", (t) => {
      this.check = t;
    });
  }
  componentDidMount() {
    if (bc) {
      if (window.google && window.google.maps && !Rd) {
        console.error("google api is already presented");
        return;
      }
      this.isCleaningUp().then(this.injectScript).catch(function(t) {
        console.error("Error at injecting script after cleaning up: ", t);
      });
    }
  }
  componentDidUpdate(t) {
    this.props.libraries !== t.libraries && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), bc && t.language !== this.props.language && (this.cleanup(), this.setState(function() {
      return {
        loaded: !1
      };
    }, this.cleanupCallback));
  }
  componentWillUnmount() {
    if (bc) {
      this.cleanup();
      var t = () => {
        this.check || (delete window.google, Rd = !1);
      };
      window.setTimeout(t, 1), this.props.onUnmount && this.props.onUnmount();
    }
  }
  render() {
    return Fn.jsxs(Fn.Fragment, {
      children: [Fn.jsx("div", {
        ref: this.getRef
      }), this.state.loaded ? this.props.children : this.props.loadingElement || Fn.jsx(Uoe, {})]
    });
  }
}
Te(Kqe, "defaultProps", EP);
function Xqe(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.includes(r)) continue;
    n[r] = e[r];
  }
  return n;
}
function uj(e, t) {
  if (e == null) return {};
  var n, r, o = Xqe(e, t);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (r = 0; r < i.length; r++) n = i[r], t.includes(n) || {}.propertyIsEnumerable.call(e, n) && (o[n] = e[n]);
  }
  return o;
}
var w4;
function Yqe(e) {
  var {
    id: t = EP.id,
    version: n = EP.version,
    nonce: r,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    preventGoogleFontsLoading: u,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  } = e, g = dt(!1), [f, m] = k(!1), [b, E] = k(void 0);
  h(function() {
    return g.current = !0, () => {
      g.current = !1;
    };
  }, []), h(function() {
    bc && u && zoe();
  }, [u]), h(function() {
    f && qo(!!window.google, "useLoadScript was marked as loaded, but window.google is not present. Something went wrong.");
  }, [f]);
  var w = Boe({
    version: n,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  });
  h(function() {
    if (!bc)
      return;
    function x() {
      g.current && (m(!0), w4 = w);
    }
    if (window.google && window.google.maps && w4 === w) {
      x();
      return;
    }
    Foe({
      id: t,
      url: w,
      nonce: r
    }).then(x).catch(function(v) {
      g.current && E(v), console.warn(`
        There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(o || "-", ") or Client ID (").concat(i || "-", `)
        Otherwise it is a Network issue.
      `)), console.error(v);
    });
  }, [t, w, r]);
  var M = dt(void 0);
  return h(function() {
    M.current && l !== M.current && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), M.current = l;
  }, [l]), {
    isLoaded: f,
    loadError: b,
    url: w
  };
}
var Jqe = ["loadingElement", "onLoad", "onError", "onUnmount", "children"], Qqe = Fn.jsx(Uoe, {});
function eGe(e) {
  var {
    loadingElement: t,
    onLoad: n,
    onError: r,
    onUnmount: o,
    children: i
  } = e, a = uj(e, Jqe), {
    isLoaded: s,
    loadError: l
  } = Yqe(a);
  return h(function() {
    s && typeof n == "function" && n();
  }, [s, n]), h(function() {
    l && typeof r == "function" && r(l);
  }, [l, r]), h(function() {
    return () => {
      o && o();
    };
  }, [o]), s ? i : t || Qqe;
}
me(eGe);
var C4;
(function(e) {
  e[e.INITIALIZED = 0] = "INITIALIZED", e[e.LOADING = 1] = "LOADING", e[e.SUCCESS = 2] = "SUCCESS", e[e.FAILURE = 3] = "FAILURE";
})(C4 || (C4 = {}));
function O4(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Uw(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? O4(Object(n), !0).forEach(function(r) {
      Te(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : O4(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var x4 = {}, E4 = {
  options(e, t) {
    e.setOptions(t);
  }
};
function tGe(e) {
  var {
    options: t,
    onLoad: n,
    onUnmount: r
  } = e, o = ge(Ut), [i, a] = k(null);
  return h(() => {
    i !== null && i.setMap(o);
  }, [o]), h(() => {
    t && i !== null && i.setOptions(t);
  }, [i, t]), h(() => {
    var s = new google.maps.TrafficLayer(Uw(Uw({}, t), {}, {
      map: o
    }));
    return a(s), n && n(s), () => {
      i !== null && (r && r(i), i.setMap(null));
    };
  }, []), null;
}
me(tGe);
class nGe extends pe {
  constructor() {
    super(...arguments), Te(this, "state", {
      trafficLayer: null
    }), Te(this, "setTrafficLayerCallback", () => {
      this.state.trafficLayer !== null && this.props.onLoad && this.props.onLoad(this.state.trafficLayer);
    }), Te(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = new google.maps.TrafficLayer(Uw(Uw({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = xn({
      updaterMap: E4,
      eventMap: x4,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        trafficLayer: t
      };
    }, this.setTrafficLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.trafficLayer !== null && (Mn(this.registeredEvents), this.registeredEvents = xn({
      updaterMap: E4,
      eventMap: x4,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.trafficLayer
    }));
  }
  componentWillUnmount() {
    this.state.trafficLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.trafficLayer), Mn(this.registeredEvents), this.state.trafficLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Te(nGe, "contextType", Ut);
function rGe(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = ge(Ut), [o, i] = k(null);
  return h(() => {
    o !== null && o.setMap(r);
  }, [r]), h(() => {
    var a = new google.maps.BicyclingLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      a !== null && (n && n(a), a.setMap(null));
    };
  }, []), null;
}
me(rGe);
class oGe extends pe {
  constructor() {
    super(...arguments), Te(this, "state", {
      bicyclingLayer: null
    }), Te(this, "setBicyclingLayerCallback", () => {
      this.state.bicyclingLayer !== null && (this.state.bicyclingLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.bicyclingLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.BicyclingLayer();
    this.setState(() => ({
      bicyclingLayer: t
    }), this.setBicyclingLayerCallback);
  }
  componentWillUnmount() {
    this.state.bicyclingLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.bicyclingLayer), this.state.bicyclingLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Te(oGe, "contextType", Ut);
function iGe(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = ge(Ut), [o, i] = k(null);
  return h(() => {
    o !== null && o.setMap(r);
  }, [r]), h(() => {
    var a = new google.maps.TransitLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      o !== null && (n && n(o), o.setMap(null));
    };
  }, []), null;
}
me(iGe);
class sGe extends pe {
  constructor() {
    super(...arguments), Te(this, "state", {
      transitLayer: null
    }), Te(this, "setTransitLayerCallback", () => {
      this.state.transitLayer !== null && (this.state.transitLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.transitLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.TransitLayer();
    this.setState(function() {
      return {
        transitLayer: t
      };
    }, this.setTransitLayerCallback);
  }
  componentWillUnmount() {
    this.state.transitLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.transitLayer), this.state.transitLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Te(sGe, "contextType", Ut);
function k4(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Hw(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? k4(Object(n), !0).forEach(function(r) {
      Te(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : k4(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var L4 = {
  onCircleComplete: "circlecomplete",
  onMarkerComplete: "markercomplete",
  onOverlayComplete: "overlaycomplete",
  onPolygonComplete: "polygoncomplete",
  onPolylineComplete: "polylinecomplete",
  onRectangleComplete: "rectanglecomplete"
}, _4 = {
  drawingMode(e, t) {
    e.setDrawingMode(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function aGe(e) {
  var {
    options: t,
    drawingMode: n,
    onCircleComplete: r,
    onMarkerComplete: o,
    onOverlayComplete: i,
    onPolygonComplete: a,
    onPolylineComplete: s,
    onRectangleComplete: l,
    onLoad: u,
    onUnmount: c
  } = e, p = ge(Ut), [d, g] = k(null), [f, m] = k(null), [b, E] = k(null), [w, M] = k(null), [x, v] = k(null), [C, P] = k(null), [F, L] = k(null);
  return h(() => {
    d !== null && d.setMap(p);
  }, [p]), h(() => {
    t && d !== null && d.setOptions(t);
  }, [d, t]), h(() => {
    d !== null && d.setDrawingMode(n ?? null);
  }, [d, n]), h(() => {
    d && r && (f !== null && google.maps.event.removeListener(f), m(google.maps.event.addListener(d, "circlecomplete", r)));
  }, [d, r]), h(() => {
    d && o && (b !== null && google.maps.event.removeListener(b), E(google.maps.event.addListener(d, "markercomplete", o)));
  }, [d, o]), h(() => {
    d && i && (w !== null && google.maps.event.removeListener(w), M(google.maps.event.addListener(d, "overlaycomplete", i)));
  }, [d, i]), h(() => {
    d && a && (x !== null && google.maps.event.removeListener(x), v(google.maps.event.addListener(d, "polygoncomplete", a)));
  }, [d, a]), h(() => {
    d && s && (C !== null && google.maps.event.removeListener(C), P(google.maps.event.addListener(d, "polylinecomplete", s)));
  }, [d, s]), h(() => {
    d && l && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(d, "rectanglecomplete", l)));
  }, [d, l]), h(() => {
    qo(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
    var B = new google.maps.drawing.DrawingManager(Hw(Hw({}, t), {}, {
      map: p
    }));
    return n && B.setDrawingMode(n), r && m(google.maps.event.addListener(B, "circlecomplete", r)), o && E(google.maps.event.addListener(B, "markercomplete", o)), i && M(google.maps.event.addListener(B, "overlaycomplete", i)), a && v(google.maps.event.addListener(B, "polygoncomplete", a)), s && P(google.maps.event.addListener(B, "polylinecomplete", s)), l && L(google.maps.event.addListener(B, "rectanglecomplete", l)), g(B), u && u(B), () => {
      d !== null && (f && google.maps.event.removeListener(f), b && google.maps.event.removeListener(b), w && google.maps.event.removeListener(w), x && google.maps.event.removeListener(x), C && google.maps.event.removeListener(C), F && google.maps.event.removeListener(F), c && c(d), d.setMap(null));
    };
  }, []), null;
}
me(aGe);
class lGe extends pe {
  constructor(t) {
    super(t), Te(this, "registeredEvents", []), Te(this, "state", {
      drawingManager: null
    }), Te(this, "setDrawingManagerCallback", () => {
      this.state.drawingManager !== null && this.props.onLoad && this.props.onLoad(this.state.drawingManager);
    }), qo(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
  }
  componentDidMount() {
    var t = new google.maps.drawing.DrawingManager(Hw(Hw({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = xn({
      updaterMap: _4,
      eventMap: L4,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        drawingManager: t
      };
    }, this.setDrawingManagerCallback);
  }
  componentDidUpdate(t) {
    this.state.drawingManager !== null && (Mn(this.registeredEvents), this.registeredEvents = xn({
      updaterMap: _4,
      eventMap: L4,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.drawingManager
    }));
  }
  componentWillUnmount() {
    this.state.drawingManager !== null && (this.props.onUnmount && this.props.onUnmount(this.state.drawingManager), Mn(this.registeredEvents), this.state.drawingManager.setMap(null));
  }
  render() {
    return null;
  }
}
Te(lGe, "contextType", Ut);
function P4(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function mp(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? P4(Object(n), !0).forEach(function(r) {
      Te(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : P4(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var S4 = {
  onAnimationChanged: "animation_changed",
  onClick: "click",
  onClickableChanged: "clickable_changed",
  onCursorChanged: "cursor_changed",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDraggableChanged: "draggable_changed",
  onDragStart: "dragstart",
  onFlatChanged: "flat_changed",
  onIconChanged: "icon_changed",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onPositionChanged: "position_changed",
  onRightClick: "rightclick",
  onShapeChanged: "shape_changed",
  onTitleChanged: "title_changed",
  onVisibleChanged: "visible_changed",
  onZindexChanged: "zindex_changed"
}, M4 = {
  animation(e, t) {
    e.setAnimation(t);
  },
  clickable(e, t) {
    e.setClickable(t);
  },
  cursor(e, t) {
    e.setCursor(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  icon(e, t) {
    e.setIcon(t);
  },
  label(e, t) {
    e.setLabel(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  opacity(e, t) {
    e.setOpacity(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  shape(e, t) {
    e.setShape(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, Ww = {};
function uGe(e) {
  var {
    position: t,
    options: n,
    clusterer: r,
    noClustererRedraw: o,
    children: i,
    draggable: a,
    visible: s,
    animation: l,
    clickable: u,
    cursor: c,
    icon: p,
    label: d,
    opacity: g,
    shape: f,
    title: m,
    zIndex: b,
    onClick: E,
    onDblClick: w,
    onDrag: M,
    onDragEnd: x,
    onDragStart: v,
    onMouseOut: C,
    onMouseOver: P,
    onMouseUp: F,
    onMouseDown: L,
    onRightClick: B,
    onClickableChanged: N,
    onCursorChanged: $,
    onAnimationChanged: V,
    onDraggableChanged: H,
    onFlatChanged: Z,
    onIconChanged: K,
    onPositionChanged: Y,
    onShapeChanged: Q,
    onTitleChanged: J,
    onVisibleChanged: _,
    onZindexChanged: D,
    onLoad: z,
    onUnmount: S
  } = e, W = ge(Ut), [O, j] = k(null), [U, T] = k(null), [q, A] = k(null), [X, I] = k(null), [le, he] = k(null), [oe, Ae] = k(null), [Ue, He] = k(null), [Re, nt] = k(null), [Ve, we] = k(null), [et, lt] = k(null), [ye, ke] = k(null), [Qe, Fe] = k(null), [Ie, ot] = k(null), [Ee, wt] = k(null), [it, st] = k(null), [ut, Ct] = k(null), [ct, pt] = k(null), [rt, We] = k(null), [Ot, xt] = k(null), [gt, Ht] = k(null), [mt, Wt] = k(null), [vt, kt] = k(null);
  h(() => {
    O !== null && O.setMap(W);
  }, [W]), h(() => {
    typeof n < "u" && O !== null && O.setOptions(n);
  }, [O, n]), h(() => {
    typeof a < "u" && O !== null && O.setDraggable(a);
  }, [O, a]), h(() => {
    t && O !== null && O.setPosition(t);
  }, [O, t]), h(() => {
    typeof s < "u" && O !== null && O.setVisible(s);
  }, [O, s]), h(() => {
    O == null || O.setAnimation(l);
  }, [O, l]), h(() => {
    O && u !== void 0 && O.setClickable(u);
  }, [O, u]), h(() => {
    O && c !== void 0 && O.setCursor(c);
  }, [O, c]), h(() => {
    O && p !== void 0 && O.setIcon(p);
  }, [O, p]), h(() => {
    O && d !== void 0 && O.setLabel(d);
  }, [O, d]), h(() => {
    O && g !== void 0 && O.setOpacity(g);
  }, [O, g]), h(() => {
    O && f !== void 0 && O.setShape(f);
  }, [O, f]), h(() => {
    O && m !== void 0 && O.setTitle(m);
  }, [O, m]), h(() => {
    O && b !== void 0 && O.setZIndex(b);
  }, [O, b]), h(() => {
    O && w && (U !== null && google.maps.event.removeListener(U), T(google.maps.event.addListener(O, "dblclick", w)));
  }, [w]), h(() => {
    O && x && (q !== null && google.maps.event.removeListener(q), A(google.maps.event.addListener(O, "dragend", x)));
  }, [x]), h(() => {
    O && v && (X !== null && google.maps.event.removeListener(X), I(google.maps.event.addListener(O, "dragstart", v)));
  }, [v]), h(() => {
    O && L && (le !== null && google.maps.event.removeListener(le), he(google.maps.event.addListener(O, "mousedown", L)));
  }, [L]), h(() => {
    O && C && (oe !== null && google.maps.event.removeListener(oe), Ae(google.maps.event.addListener(O, "mouseout", C)));
  }, [C]), h(() => {
    O && P && (Ue !== null && google.maps.event.removeListener(Ue), He(google.maps.event.addListener(O, "mouseover", P)));
  }, [P]), h(() => {
    O && F && (Re !== null && google.maps.event.removeListener(Re), nt(google.maps.event.addListener(O, "mouseup", F)));
  }, [F]), h(() => {
    O && B && (Ve !== null && google.maps.event.removeListener(Ve), we(google.maps.event.addListener(O, "rightclick", B)));
  }, [B]), h(() => {
    O && E && (et !== null && google.maps.event.removeListener(et), lt(google.maps.event.addListener(O, "click", E)));
  }, [E]), h(() => {
    O && M && (ye !== null && google.maps.event.removeListener(ye), ke(google.maps.event.addListener(O, "drag", M)));
  }, [M]), h(() => {
    O && N && (Qe !== null && google.maps.event.removeListener(Qe), Fe(google.maps.event.addListener(O, "clickable_changed", N)));
  }, [N]), h(() => {
    O && $ && (Ie !== null && google.maps.event.removeListener(Ie), ot(google.maps.event.addListener(O, "cursor_changed", $)));
  }, [$]), h(() => {
    O && V && (Ee !== null && google.maps.event.removeListener(Ee), wt(google.maps.event.addListener(O, "animation_changed", V)));
  }, [V]), h(() => {
    O && H && (it !== null && google.maps.event.removeListener(it), st(google.maps.event.addListener(O, "draggable_changed", H)));
  }, [H]), h(() => {
    O && Z && (ut !== null && google.maps.event.removeListener(ut), Ct(google.maps.event.addListener(O, "flat_changed", Z)));
  }, [Z]), h(() => {
    O && K && (ct !== null && google.maps.event.removeListener(ct), pt(google.maps.event.addListener(O, "icon_changed", K)));
  }, [K]), h(() => {
    O && Y && (rt !== null && google.maps.event.removeListener(rt), We(google.maps.event.addListener(O, "position_changed", Y)));
  }, [Y]), h(() => {
    O && Q && (Ot !== null && google.maps.event.removeListener(Ot), xt(google.maps.event.addListener(O, "shape_changed", Q)));
  }, [Q]), h(() => {
    O && J && (gt !== null && google.maps.event.removeListener(gt), Ht(google.maps.event.addListener(O, "title_changed", J)));
  }, [J]), h(() => {
    O && _ && (mt !== null && google.maps.event.removeListener(mt), Wt(google.maps.event.addListener(O, "visible_changed", _)));
  }, [_]), h(() => {
    O && D && (vt !== null && google.maps.event.removeListener(vt), kt(google.maps.event.addListener(O, "zindex_changed", D)));
  }, [D]), h(() => {
    var yt = mp(mp(mp({}, n || Ww), r ? Ww : {
      map: W
    }), {}, {
      position: t
    }), re = new google.maps.Marker(yt);
    return r ? r.addMarker(re, !!o) : re.setMap(W), t && re.setPosition(t), typeof s < "u" && re.setVisible(s), typeof a < "u" && re.setDraggable(a), typeof u < "u" && re.setClickable(u), typeof c == "string" && re.setCursor(c), p && re.setIcon(p), typeof d < "u" && re.setLabel(d), typeof g < "u" && re.setOpacity(g), f && re.setShape(f), typeof m == "string" && re.setTitle(m), typeof b == "number" && re.setZIndex(b), w && T(google.maps.event.addListener(re, "dblclick", w)), x && A(google.maps.event.addListener(re, "dragend", x)), v && I(google.maps.event.addListener(re, "dragstart", v)), L && he(google.maps.event.addListener(re, "mousedown", L)), C && Ae(google.maps.event.addListener(re, "mouseout", C)), P && He(google.maps.event.addListener(re, "mouseover", P)), F && nt(google.maps.event.addListener(re, "mouseup", F)), B && we(google.maps.event.addListener(re, "rightclick", B)), E && lt(google.maps.event.addListener(re, "click", E)), M && ke(google.maps.event.addListener(re, "drag", M)), N && Fe(google.maps.event.addListener(re, "clickable_changed", N)), $ && ot(google.maps.event.addListener(re, "cursor_changed", $)), V && wt(google.maps.event.addListener(re, "animation_changed", V)), H && st(google.maps.event.addListener(re, "draggable_changed", H)), Z && Ct(google.maps.event.addListener(re, "flat_changed", Z)), K && pt(google.maps.event.addListener(re, "icon_changed", K)), Y && We(google.maps.event.addListener(re, "position_changed", Y)), Q && xt(google.maps.event.addListener(re, "shape_changed", Q)), J && Ht(google.maps.event.addListener(re, "title_changed", J)), _ && Wt(google.maps.event.addListener(re, "visible_changed", _)), D && kt(google.maps.event.addListener(re, "zindex_changed", D)), j(re), z && z(re), () => {
      U !== null && google.maps.event.removeListener(U), q !== null && google.maps.event.removeListener(q), X !== null && google.maps.event.removeListener(X), le !== null && google.maps.event.removeListener(le), oe !== null && google.maps.event.removeListener(oe), Ue !== null && google.maps.event.removeListener(Ue), Re !== null && google.maps.event.removeListener(Re), Ve !== null && google.maps.event.removeListener(Ve), et !== null && google.maps.event.removeListener(et), Qe !== null && google.maps.event.removeListener(Qe), Ie !== null && google.maps.event.removeListener(Ie), Ee !== null && google.maps.event.removeListener(Ee), it !== null && google.maps.event.removeListener(it), ut !== null && google.maps.event.removeListener(ut), ct !== null && google.maps.event.removeListener(ct), rt !== null && google.maps.event.removeListener(rt), gt !== null && google.maps.event.removeListener(gt), mt !== null && google.maps.event.removeListener(mt), vt !== null && google.maps.event.removeListener(vt), S && S(re), r ? r.removeMarker(re, !!o) : re && re.setMap(null);
    };
  }, []);
  var Un = ln(() => i ? at.map(i, (yt) => {
    if (!yi(yt))
      return yt;
    var re = yt;
    return bi(re, {
      anchor: O
    });
  }) : null, [i, O]);
  return Fn.jsx(Fn.Fragment, {
    children: Un
  }) || null;
}
me(uGe);
class cGe extends pe {
  constructor() {
    super(...arguments), Te(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this;
    return Noe(function* () {
      var n = mp(mp(mp({}, t.props.options || Ww), t.props.clusterer ? Ww : {
        map: t.context
      }), {}, {
        position: t.props.position
      });
      t.marker = new google.maps.Marker(n), t.props.clusterer ? t.props.clusterer.addMarker(t.marker, !!t.props.noClustererRedraw) : t.marker.setMap(t.context), t.registeredEvents = xn({
        updaterMap: M4,
        eventMap: S4,
        prevProps: {},
        nextProps: t.props,
        instance: t.marker
      }), t.props.onLoad && t.props.onLoad(t.marker);
    })();
  }
  componentDidUpdate(t) {
    this.marker && (Mn(this.registeredEvents), this.registeredEvents = xn({
      updaterMap: M4,
      eventMap: S4,
      prevProps: t,
      nextProps: this.props,
      instance: this.marker
    }));
  }
  componentWillUnmount() {
    this.marker && (this.props.onUnmount && this.props.onUnmount(this.marker), Mn(this.registeredEvents), this.props.clusterer ? this.props.clusterer.removeMarker(this.marker, !!this.props.noClustererRedraw) : this.marker && this.marker.setMap(null));
  }
  render() {
    var t = this.props.children ? at.map(this.props.children, (n) => {
      if (!yi(n))
        return n;
      var r = n;
      return bi(r, {
        anchor: this.marker
      });
    }) : null;
    return t || null;
  }
}
Te(cGe, "contextType", Ut);
var pGe = (
  /** @class */
  function() {
    function e(t, n) {
      t.getClusterer().extend(e, google.maps.OverlayView), this.cluster = t, this.clusterClassName = this.cluster.getClusterer().getClusterClass(), this.className = this.clusterClassName, this.styles = n, this.center = void 0, this.div = null, this.sums = null, this.visible = !1, this.boundsChangedListener = null, this.url = "", this.height = 0, this.width = 0, this.anchorText = [0, 0], this.anchorIcon = [0, 0], this.textColor = "black", this.textSize = 11, this.textDecoration = "none", this.fontWeight = "bold", this.fontStyle = "normal", this.fontFamily = "Arial,sans-serif", this.backgroundPosition = "0 0", this.cMouseDownInCluster = null, this.cDraggingMapByCluster = null, this.timeOut = null, this.setMap(t.getMap()), this.onBoundsChanged = this.onBoundsChanged.bind(this), this.onMouseDown = this.onMouseDown.bind(this), this.onClick = this.onClick.bind(this), this.onMouseOver = this.onMouseOver.bind(this), this.onMouseOut = this.onMouseOut.bind(this), this.onAdd = this.onAdd.bind(this), this.onRemove = this.onRemove.bind(this), this.draw = this.draw.bind(this), this.hide = this.hide.bind(this), this.show = this.show.bind(this), this.useStyle = this.useStyle.bind(this), this.setCenter = this.setCenter.bind(this), this.getPosFromLatLng = this.getPosFromLatLng.bind(this);
    }
    return e.prototype.onBoundsChanged = function() {
      this.cDraggingMapByCluster = this.cMouseDownInCluster;
    }, e.prototype.onMouseDown = function() {
      this.cMouseDownInCluster = !0, this.cDraggingMapByCluster = !1;
    }, e.prototype.onClick = function(t) {
      if (this.cMouseDownInCluster = !1, !this.cDraggingMapByCluster) {
        var n = this.cluster.getClusterer();
        if (google.maps.event.trigger(n, "click", this.cluster), google.maps.event.trigger(n, "clusterclick", this.cluster), n.getZoomOnClick()) {
          var r = n.getMaxZoom(), o = this.cluster.getBounds(), i = n.getMap();
          i !== null && "fitBounds" in i && i.fitBounds(o), this.timeOut = window.setTimeout(function() {
            var a = n.getMap();
            if (a !== null) {
              "fitBounds" in a && a.fitBounds(o);
              var s = a.getZoom() || 0;
              r !== null && s > r && a.setZoom(r + 1);
            }
          }, 100);
        }
        t.cancelBubble = !0, t.stopPropagation && t.stopPropagation();
      }
    }, e.prototype.onMouseOver = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseover", this.cluster);
    }, e.prototype.onMouseOut = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseout", this.cluster);
    }, e.prototype.onAdd = function() {
      var t;
      this.div = document.createElement("div"), this.div.className = this.className, this.visible && this.show(), (t = this.getPanes()) === null || t === void 0 || t.overlayMouseTarget.appendChild(this.div);
      var n = this.getMap();
      n !== null && (this.boundsChangedListener = google.maps.event.addListener(n, "bounds_changed", this.onBoundsChanged), this.div.addEventListener("mousedown", this.onMouseDown), this.div.addEventListener("click", this.onClick), this.div.addEventListener("mouseover", this.onMouseOver), this.div.addEventListener("mouseout", this.onMouseOut));
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.hide(), this.boundsChangedListener !== null && google.maps.event.removeListener(this.boundsChangedListener), this.div.removeEventListener("mousedown", this.onMouseDown), this.div.removeEventListener("click", this.onClick), this.div.removeEventListener("mouseover", this.onMouseOver), this.div.removeEventListener("mouseout", this.onMouseOut), this.div.parentNode.removeChild(this.div), this.timeOut !== null && (window.clearTimeout(this.timeOut), this.timeOut = null), this.div = null);
    }, e.prototype.draw = function() {
      if (this.visible && this.div !== null && this.center) {
        var t = this.getPosFromLatLng(this.center);
        this.div.style.top = t !== null ? "".concat(t.y, "px") : "0", this.div.style.left = t !== null ? "".concat(t.x, "px") : "0";
      }
    }, e.prototype.hide = function() {
      this.div && (this.div.style.display = "none"), this.visible = !1;
    }, e.prototype.show = function() {
      var t, n, r, o, i, a;
      if (this.div && this.center) {
        var s = this.sums === null || typeof this.sums.title > "u" || this.sums.title === "" ? this.cluster.getClusterer().getTitle() : this.sums.title, l = this.backgroundPosition.split(" "), u = parseInt(((t = l[0]) === null || t === void 0 ? void 0 : t.replace(/^\s+|\s+$/g, "")) || "0", 10), c = parseInt(((n = l[1]) === null || n === void 0 ? void 0 : n.replace(/^\s+|\s+$/g, "")) || "0", 10), p = this.getPosFromLatLng(this.center);
        this.div.className = this.className, this.div.setAttribute("style", "cursor: pointer; position: absolute; top: ".concat(p !== null ? "".concat(p.y, "px") : "0", "; left: ").concat(p !== null ? "".concat(p.x, "px") : "0", "; width: ").concat(this.width, "px; height: ").concat(this.height, "px; "));
        var d = document.createElement("img");
        d.alt = s, d.src = this.url, d.width = this.width, d.height = this.height, d.setAttribute("style", "position: absolute; top: ".concat(c, "px; left: ").concat(u, "px")), this.cluster.getClusterer().enableRetinaIcons || (d.style.clip = "rect(-".concat(c, "px, -").concat(u + this.width, "px, -").concat(c + this.height, ", -").concat(u, ")"));
        var g = document.createElement("div");
        g.setAttribute("style", "position: absolute; top: ".concat(this.anchorText[0], "px; left: ").concat(this.anchorText[1], "px; color: ").concat(this.textColor, "; font-size: ").concat(this.textSize, "px; font-family: ").concat(this.fontFamily, "; font-weight: ").concat(this.fontWeight, "; fontStyle: ").concat(this.fontStyle, "; text-decoration: ").concat(this.textDecoration, "; text-align: center; width: ").concat(this.width, "px; line-height: ").concat(this.height, "px")), !((r = this.sums) === null || r === void 0) && r.text && (g.innerText = "".concat((o = this.sums) === null || o === void 0 ? void 0 : o.text)), !((i = this.sums) === null || i === void 0) && i.html && (g.innerHTML = "".concat((a = this.sums) === null || a === void 0 ? void 0 : a.html)), this.div.innerHTML = "", this.div.appendChild(d), this.div.appendChild(g), this.div.title = s, this.div.style.display = "";
      }
      this.visible = !0;
    }, e.prototype.useStyle = function(t) {
      this.sums = t;
      var n = this.cluster.getClusterer().getStyles(), r = n[Math.min(n.length - 1, Math.max(0, t.index - 1))];
      r && (this.url = r.url, this.height = r.height, this.width = r.width, r.className && (this.className = "".concat(this.clusterClassName, " ").concat(r.className)), this.anchorText = r.anchorText || [0, 0], this.anchorIcon = r.anchorIcon || [this.height / 2, this.width / 2], this.textColor = r.textColor || "black", this.textSize = r.textSize || 11, this.textDecoration = r.textDecoration || "none", this.fontWeight = r.fontWeight || "bold", this.fontStyle = r.fontStyle || "normal", this.fontFamily = r.fontFamily || "Arial,sans-serif", this.backgroundPosition = r.backgroundPosition || "0 0");
    }, e.prototype.setCenter = function(t) {
      this.center = t;
    }, e.prototype.getPosFromLatLng = function(t) {
      var n = this.getProjection().fromLatLngToDivPixel(t);
      return n !== null && (n.x -= this.anchorIcon[1], n.y -= this.anchorIcon[0]), n;
    }, e;
  }()
), dGe = (
  /** @class */
  function() {
    function e(t) {
      this.markerClusterer = t, this.map = this.markerClusterer.getMap(), this.gridSize = this.markerClusterer.getGridSize(), this.minClusterSize = this.markerClusterer.getMinimumClusterSize(), this.averageCenter = this.markerClusterer.getAverageCenter(), this.markers = [], this.center = void 0, this.bounds = null, this.clusterIcon = new pGe(this, this.markerClusterer.getStyles()), this.getSize = this.getSize.bind(this), this.getMarkers = this.getMarkers.bind(this), this.getCenter = this.getCenter.bind(this), this.getMap = this.getMap.bind(this), this.getClusterer = this.getClusterer.bind(this), this.getBounds = this.getBounds.bind(this), this.remove = this.remove.bind(this), this.addMarker = this.addMarker.bind(this), this.isMarkerInClusterBounds = this.isMarkerInClusterBounds.bind(this), this.calculateBounds = this.calculateBounds.bind(this), this.updateIcon = this.updateIcon.bind(this), this.isMarkerAlreadyAdded = this.isMarkerAlreadyAdded.bind(this);
    }
    return e.prototype.getSize = function() {
      return this.markers.length;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getCenter = function() {
      return this.center;
    }, e.prototype.getMap = function() {
      return this.map;
    }, e.prototype.getClusterer = function() {
      return this.markerClusterer;
    }, e.prototype.getBounds = function() {
      for (var t = new google.maps.LatLngBounds(this.center, this.center), n = this.getMarkers(), r = 0, o = n; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && t.extend(a);
      }
      return t;
    }, e.prototype.remove = function() {
      this.clusterIcon.setMap(null), this.markers = [], delete this.markers;
    }, e.prototype.addMarker = function(t) {
      var n;
      if (this.isMarkerAlreadyAdded(t))
        return !1;
      if (this.center) {
        if (this.averageCenter) {
          var r = t.getPosition();
          if (r) {
            var o = this.markers.length + 1;
            this.center = new google.maps.LatLng((this.center.lat() * (o - 1) + r.lat()) / o, (this.center.lng() * (o - 1) + r.lng()) / o), this.calculateBounds();
          }
        }
      } else {
        var r = t.getPosition();
        r && (this.center = r, this.calculateBounds());
      }
      t.isAdded = !0, this.markers.push(t);
      var i = this.markers.length, a = this.markerClusterer.getMaxZoom(), s = (n = this.map) === null || n === void 0 ? void 0 : n.getZoom();
      if (a !== null && typeof s < "u" && s > a)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i < this.minClusterSize)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i === this.minClusterSize)
        for (var l = 0, u = this.markers; l < u.length; l++) {
          var c = u[l];
          c.setMap(null);
        }
      else
        t.setMap(null);
      return !0;
    }, e.prototype.isMarkerInClusterBounds = function(t) {
      if (this.bounds !== null) {
        var n = t.getPosition();
        if (n)
          return this.bounds.contains(n);
      }
      return !1;
    }, e.prototype.calculateBounds = function() {
      this.bounds = this.markerClusterer.getExtendedBounds(new google.maps.LatLngBounds(this.center, this.center));
    }, e.prototype.updateIcon = function() {
      var t, n = this.markers.length, r = this.markerClusterer.getMaxZoom(), o = (t = this.map) === null || t === void 0 ? void 0 : t.getZoom();
      if (r !== null && typeof o < "u" && o > r) {
        this.clusterIcon.hide();
        return;
      }
      if (n < this.minClusterSize) {
        this.clusterIcon.hide();
        return;
      }
      this.center && this.clusterIcon.setCenter(this.center), this.clusterIcon.useStyle(this.markerClusterer.getCalculator()(this.markers, this.markerClusterer.getStyles().length)), this.clusterIcon.show();
    }, e.prototype.isMarkerAlreadyAdded = function(t) {
      if (this.markers.includes)
        return this.markers.includes(t);
      for (var n = 0; n < this.markers.length; n++)
        if (t === this.markers[n])
          return !0;
      return !1;
    }, e;
  }()
);
function fGe(e, t) {
  var n = e.length, r = n.toString().length, o = Math.min(r, t);
  return {
    text: n.toString(),
    index: o,
    title: ""
  };
}
var hGe = 2e3, gGe = 500, mGe = "https://developers.google.com/maps/documentation/javascript/examples/markerclusterer/m", vGe = "png", yGe = [53, 56, 66, 78, 90], bGe = "cluster", Hoe = (
  /** @class */
  function() {
    function e(t, n, r) {
      n === void 0 && (n = []), r === void 0 && (r = {}), this.getMinimumClusterSize = this.getMinimumClusterSize.bind(this), this.setMinimumClusterSize = this.setMinimumClusterSize.bind(this), this.getEnableRetinaIcons = this.getEnableRetinaIcons.bind(this), this.setEnableRetinaIcons = this.setEnableRetinaIcons.bind(this), this.addToClosestCluster = this.addToClosestCluster.bind(this), this.getImageExtension = this.getImageExtension.bind(this), this.setImageExtension = this.setImageExtension.bind(this), this.getExtendedBounds = this.getExtendedBounds.bind(this), this.getAverageCenter = this.getAverageCenter.bind(this), this.setAverageCenter = this.setAverageCenter.bind(this), this.getTotalClusters = this.getTotalClusters.bind(this), this.fitMapToMarkers = this.fitMapToMarkers.bind(this), this.getIgnoreHidden = this.getIgnoreHidden.bind(this), this.setIgnoreHidden = this.setIgnoreHidden.bind(this), this.getClusterClass = this.getClusterClass.bind(this), this.setClusterClass = this.setClusterClass.bind(this), this.getTotalMarkers = this.getTotalMarkers.bind(this), this.getZoomOnClick = this.getZoomOnClick.bind(this), this.setZoomOnClick = this.setZoomOnClick.bind(this), this.getBatchSizeIE = this.getBatchSizeIE.bind(this), this.setBatchSizeIE = this.setBatchSizeIE.bind(this), this.createClusters = this.createClusters.bind(this), this.onZoomChanged = this.onZoomChanged.bind(this), this.getImageSizes = this.getImageSizes.bind(this), this.setImageSizes = this.setImageSizes.bind(this), this.getCalculator = this.getCalculator.bind(this), this.setCalculator = this.setCalculator.bind(this), this.removeMarkers = this.removeMarkers.bind(this), this.resetViewport = this.resetViewport.bind(this), this.getImagePath = this.getImagePath.bind(this), this.setImagePath = this.setImagePath.bind(this), this.pushMarkerTo = this.pushMarkerTo.bind(this), this.removeMarker = this.removeMarker.bind(this), this.clearMarkers = this.clearMarkers.bind(this), this.setupStyles = this.setupStyles.bind(this), this.getGridSize = this.getGridSize.bind(this), this.setGridSize = this.setGridSize.bind(this), this.getClusters = this.getClusters.bind(this), this.getMaxZoom = this.getMaxZoom.bind(this), this.setMaxZoom = this.setMaxZoom.bind(this), this.getMarkers = this.getMarkers.bind(this), this.addMarkers = this.addMarkers.bind(this), this.getStyles = this.getStyles.bind(this), this.setStyles = this.setStyles.bind(this), this.addMarker = this.addMarker.bind(this), this.onRemove = this.onRemove.bind(this), this.getTitle = this.getTitle.bind(this), this.setTitle = this.setTitle.bind(this), this.repaint = this.repaint.bind(this), this.onIdle = this.onIdle.bind(this), this.redraw = this.redraw.bind(this), this.onAdd = this.onAdd.bind(this), this.draw = this.draw.bind(this), this.extend = this.extend.bind(this), this.extend(e, google.maps.OverlayView), this.markers = [], this.clusters = [], this.listeners = [], this.activeMap = null, this.ready = !1, this.gridSize = r.gridSize || 60, this.minClusterSize = r.minimumClusterSize || 2, this.maxZoom = r.maxZoom || null, this.styles = r.styles || [], this.title = r.title || "", this.zoomOnClick = !0, r.zoomOnClick !== void 0 && (this.zoomOnClick = r.zoomOnClick), this.averageCenter = !1, r.averageCenter !== void 0 && (this.averageCenter = r.averageCenter), this.ignoreHidden = !1, r.ignoreHidden !== void 0 && (this.ignoreHidden = r.ignoreHidden), this.enableRetinaIcons = !1, r.enableRetinaIcons !== void 0 && (this.enableRetinaIcons = r.enableRetinaIcons), this.imagePath = r.imagePath || mGe, this.imageExtension = r.imageExtension || vGe, this.imageSizes = r.imageSizes || yGe, this.calculator = r.calculator || fGe, this.batchSize = r.batchSize || hGe, this.batchSizeIE = r.batchSizeIE || gGe, this.clusterClass = r.clusterClass || bGe, navigator.userAgent.toLowerCase().indexOf("msie") !== -1 && (this.batchSize = this.batchSizeIE), this.timerRefStatic = null, this.setupStyles(), this.addMarkers(n, !0), this.setMap(t);
    }
    return e.prototype.onZoomChanged = function() {
      var t, n;
      this.resetViewport(!1), (((t = this.getMap()) === null || t === void 0 ? void 0 : t.getZoom()) === (this.get("minZoom") || 0) || ((n = this.getMap()) === null || n === void 0 ? void 0 : n.getZoom()) === this.get("maxZoom")) && google.maps.event.trigger(this, "idle");
    }, e.prototype.onIdle = function() {
      this.redraw();
    }, e.prototype.onAdd = function() {
      var t = this.getMap();
      this.activeMap = t, this.ready = !0, this.repaint(), t !== null && (this.listeners = [google.maps.event.addListener(t, "zoom_changed", this.onZoomChanged), google.maps.event.addListener(t, "idle", this.onIdle)]);
    }, e.prototype.onRemove = function() {
      for (var t = 0, n = this.markers; t < n.length; t++) {
        var r = n[t];
        r.getMap() !== this.activeMap && r.setMap(this.activeMap);
      }
      for (var o = 0, i = this.clusters; o < i.length; o++) {
        var a = i[o];
        a.remove();
      }
      this.clusters = [];
      for (var s = 0, l = this.listeners; s < l.length; s++) {
        var u = l[s];
        google.maps.event.removeListener(u);
      }
      this.listeners = [], this.activeMap = null, this.ready = !1;
    }, e.prototype.draw = function() {
    }, e.prototype.getMap = function() {
      return null;
    }, e.prototype.getPanes = function() {
      return null;
    }, e.prototype.getProjection = function() {
      return {
        fromContainerPixelToLatLng: function() {
          return null;
        },
        fromDivPixelToLatLng: function() {
          return null;
        },
        fromLatLngToContainerPixel: function() {
          return null;
        },
        fromLatLngToDivPixel: function() {
          return null;
        },
        getVisibleRegion: function() {
          return null;
        },
        getWorldWidth: function() {
          return 0;
        }
      };
    }, e.prototype.setMap = function() {
    }, e.prototype.addListener = function() {
      return {
        remove: function() {
        }
      };
    }, e.prototype.bindTo = function() {
    }, e.prototype.get = function() {
    }, e.prototype.notify = function() {
    }, e.prototype.set = function() {
    }, e.prototype.setValues = function() {
    }, e.prototype.unbind = function() {
    }, e.prototype.unbindAll = function() {
    }, e.prototype.setupStyles = function() {
      if (!(this.styles.length > 0))
        for (var t = 0; t < this.imageSizes.length; t++)
          this.styles.push({
            url: "".concat(this.imagePath + (t + 1), ".").concat(this.imageExtension),
            height: this.imageSizes[t] || 0,
            width: this.imageSizes[t] || 0
          });
    }, e.prototype.fitMapToMarkers = function() {
      for (var t = this.getMarkers(), n = new google.maps.LatLngBounds(), r = 0, o = t; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && n.extend(a);
      }
      var s = this.getMap();
      s !== null && "fitBounds" in s && s.fitBounds(n);
    }, e.prototype.getGridSize = function() {
      return this.gridSize;
    }, e.prototype.setGridSize = function(t) {
      this.gridSize = t;
    }, e.prototype.getMinimumClusterSize = function() {
      return this.minClusterSize;
    }, e.prototype.setMinimumClusterSize = function(t) {
      this.minClusterSize = t;
    }, e.prototype.getMaxZoom = function() {
      return this.maxZoom;
    }, e.prototype.setMaxZoom = function(t) {
      this.maxZoom = t;
    }, e.prototype.getStyles = function() {
      return this.styles;
    }, e.prototype.setStyles = function(t) {
      this.styles = t;
    }, e.prototype.getTitle = function() {
      return this.title;
    }, e.prototype.setTitle = function(t) {
      this.title = t;
    }, e.prototype.getZoomOnClick = function() {
      return this.zoomOnClick;
    }, e.prototype.setZoomOnClick = function(t) {
      this.zoomOnClick = t;
    }, e.prototype.getAverageCenter = function() {
      return this.averageCenter;
    }, e.prototype.setAverageCenter = function(t) {
      this.averageCenter = t;
    }, e.prototype.getIgnoreHidden = function() {
      return this.ignoreHidden;
    }, e.prototype.setIgnoreHidden = function(t) {
      this.ignoreHidden = t;
    }, e.prototype.getEnableRetinaIcons = function() {
      return this.enableRetinaIcons;
    }, e.prototype.setEnableRetinaIcons = function(t) {
      this.enableRetinaIcons = t;
    }, e.prototype.getImageExtension = function() {
      return this.imageExtension;
    }, e.prototype.setImageExtension = function(t) {
      this.imageExtension = t;
    }, e.prototype.getImagePath = function() {
      return this.imagePath;
    }, e.prototype.setImagePath = function(t) {
      this.imagePath = t;
    }, e.prototype.getImageSizes = function() {
      return this.imageSizes;
    }, e.prototype.setImageSizes = function(t) {
      this.imageSizes = t;
    }, e.prototype.getCalculator = function() {
      return this.calculator;
    }, e.prototype.setCalculator = function(t) {
      this.calculator = t;
    }, e.prototype.getBatchSizeIE = function() {
      return this.batchSizeIE;
    }, e.prototype.setBatchSizeIE = function(t) {
      this.batchSizeIE = t;
    }, e.prototype.getClusterClass = function() {
      return this.clusterClass;
    }, e.prototype.setClusterClass = function(t) {
      this.clusterClass = t;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getTotalMarkers = function() {
      return this.markers.length;
    }, e.prototype.getClusters = function() {
      return this.clusters;
    }, e.prototype.getTotalClusters = function() {
      return this.clusters.length;
    }, e.prototype.addMarker = function(t, n) {
      this.pushMarkerTo(t), n || this.redraw();
    }, e.prototype.addMarkers = function(t, n) {
      for (var r in t)
        if (Object.prototype.hasOwnProperty.call(t, r)) {
          var o = t[r];
          o && this.pushMarkerTo(o);
        }
      n || this.redraw();
    }, e.prototype.pushMarkerTo = function(t) {
      var n = this;
      t.getDraggable() && google.maps.event.addListener(t, "dragend", function() {
        n.ready && (t.isAdded = !1, n.repaint());
      }), t.isAdded = !1, this.markers.push(t);
    }, e.prototype.removeMarker_ = function(t) {
      var n = -1;
      if (this.markers.indexOf)
        n = this.markers.indexOf(t);
      else
        for (var r = 0; r < this.markers.length; r++)
          if (t === this.markers[r]) {
            n = r;
            break;
          }
      return n === -1 ? !1 : (t.setMap(null), this.markers.splice(n, 1), !0);
    }, e.prototype.removeMarker = function(t, n) {
      var r = this.removeMarker_(t);
      return !n && r && this.repaint(), r;
    }, e.prototype.removeMarkers = function(t, n) {
      for (var r = !1, o = 0, i = t; o < i.length; o++) {
        var a = i[o];
        r = r || this.removeMarker_(a);
      }
      return !n && r && this.repaint(), r;
    }, e.prototype.clearMarkers = function() {
      this.resetViewport(!0), this.markers = [];
    }, e.prototype.repaint = function() {
      var t = this.clusters.slice();
      this.clusters = [], this.resetViewport(!1), this.redraw(), setTimeout(function() {
        for (var n = 0, r = t; n < r.length; n++) {
          var o = r[n];
          o.remove();
        }
      }, 0);
    }, e.prototype.getExtendedBounds = function(t) {
      var n = this.getProjection(), r = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getNorthEast().lat(), t.getNorthEast().lng())
      );
      r !== null && (r.x += this.gridSize, r.y -= this.gridSize);
      var o = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getSouthWest().lat(), t.getSouthWest().lng())
      );
      if (o !== null && (o.x -= this.gridSize, o.y += this.gridSize), r !== null) {
        var i = n.fromDivPixelToLatLng(r);
        i !== null && t.extend(i);
      }
      if (o !== null) {
        var a = n.fromDivPixelToLatLng(o);
        a !== null && t.extend(a);
      }
      return t;
    }, e.prototype.redraw = function() {
      this.createClusters(0);
    }, e.prototype.resetViewport = function(t) {
      for (var n = 0, r = this.clusters; n < r.length; n++) {
        var o = r[n];
        o.remove();
      }
      this.clusters = [];
      for (var i = 0, a = this.markers; i < a.length; i++) {
        var s = a[i];
        s.isAdded = !1, t && s.setMap(null);
      }
    }, e.prototype.distanceBetweenPoints = function(t, n) {
      var r = 6371, o = (n.lat() - t.lat()) * Math.PI / 180, i = (n.lng() - t.lng()) * Math.PI / 180, a = Math.sin(o / 2) * Math.sin(o / 2) + Math.cos(t.lat() * Math.PI / 180) * Math.cos(n.lat() * Math.PI / 180) * Math.sin(i / 2) * Math.sin(i / 2);
      return r * (2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)));
    }, e.prototype.isMarkerInBounds = function(t, n) {
      var r = t.getPosition();
      return r ? n.contains(r) : !1;
    }, e.prototype.addToClosestCluster = function(t) {
      for (var n, r = 4e4, o = null, i = 0, a = this.clusters; i < a.length; i++) {
        var s = a[i];
        n = s;
        var l = n.getCenter(), u = t.getPosition();
        if (l && u) {
          var c = this.distanceBetweenPoints(l, u);
          c < r && (r = c, o = n);
        }
      }
      o && o.isMarkerInClusterBounds(t) ? o.addMarker(t) : (n = new dGe(this), n.addMarker(t), this.clusters.push(n));
    }, e.prototype.createClusters = function(t) {
      var n = this;
      if (this.ready) {
        t === 0 && (google.maps.event.trigger(this, "clusteringbegin", this), this.timerRefStatic !== null && (window.clearTimeout(this.timerRefStatic), delete this.timerRefStatic));
        for (var r = this.getMap(), o = r !== null && ("getBounds" in r) ? r.getBounds() : null, i = (r == null ? void 0 : r.getZoom()) || 0, a = i > 3 ? new google.maps.LatLngBounds(o == null ? void 0 : o.getSouthWest(), o == null ? void 0 : o.getNorthEast()) : new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625)), s = this.getExtendedBounds(a), l = Math.min(t + this.batchSize, this.markers.length), u = t; u < l; u++) {
          var c = this.markers[u];
          c && !c.isAdded && this.isMarkerInBounds(c, s) && (!this.ignoreHidden || this.ignoreHidden && c.getVisible()) && this.addToClosestCluster(c);
        }
        if (l < this.markers.length)
          this.timerRefStatic = window.setTimeout(function() {
            n.createClusters(l);
          }, 0);
        else {
          this.timerRefStatic = null, google.maps.event.trigger(this, "clusteringend", this);
          for (var p = 0, d = this.clusters; p < d.length; p++) {
            var g = d[p];
            g.updateIcon();
          }
        }
      }
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype) {
          var i = o;
          this.prototype[i] = r.prototype[i];
        }
        return this;
      }).apply(t, [n]);
    }, e;
  }()
);
function D4(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function wGe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? D4(Object(n), !0).forEach(function(r) {
      Te(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : D4(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var zs = {
  onClick: "click",
  onClusteringBegin: "clusteringbegin",
  onClusteringEnd: "clusteringend",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover"
}, Nn = {
  averageCenter(e, t) {
    e.setAverageCenter(t);
  },
  batchSizeIE(e, t) {
    e.setBatchSizeIE(t);
  },
  calculator(e, t) {
    e.setCalculator(t);
  },
  clusterClass(e, t) {
    e.setClusterClass(t);
  },
  enableRetinaIcons(e, t) {
    e.setEnableRetinaIcons(t);
  },
  gridSize(e, t) {
    e.setGridSize(t);
  },
  ignoreHidden(e, t) {
    e.setIgnoreHidden(t);
  },
  imageExtension(e, t) {
    e.setImageExtension(t);
  },
  imagePath(e, t) {
    e.setImagePath(t);
  },
  imageSizes(e, t) {
    e.setImageSizes(t);
  },
  maxZoom(e, t) {
    e.setMaxZoom(t);
  },
  minimumClusterSize(e, t) {
    e.setMinimumClusterSize(t);
  },
  styles(e, t) {
    e.setStyles(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  zoomOnClick(e, t) {
    e.setZoomOnClick(t);
  }
}, CGe = {};
function OGe(e) {
  var {
    children: t,
    options: n,
    averageCenter: r,
    batchSizeIE: o,
    calculator: i,
    clusterClass: a,
    enableRetinaIcons: s,
    gridSize: l,
    ignoreHidden: u,
    imageExtension: c,
    imagePath: p,
    imageSizes: d,
    maxZoom: g,
    minimumClusterSize: f,
    styles: m,
    title: b,
    zoomOnClick: E,
    onClick: w,
    onClusteringBegin: M,
    onClusteringEnd: x,
    onMouseOver: v,
    onMouseOut: C,
    onLoad: P,
    onUnmount: F
  } = e, [L, B] = k(null), N = ge(Ut), [$, V] = k(null), [H, Z] = k(null), [K, Y] = k(null), [Q, J] = k(null), [_, D] = k(null);
  return h(() => {
    L && C && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(L, zs.onMouseOut, C)));
  }, [C]), h(() => {
    L && v && (_ !== null && google.maps.event.removeListener(_), D(google.maps.event.addListener(L, zs.onMouseOver, v)));
  }, [v]), h(() => {
    L && w && ($ !== null && google.maps.event.removeListener($), V(google.maps.event.addListener(L, zs.onClick, w)));
  }, [w]), h(() => {
    L && M && (H !== null && google.maps.event.removeListener(H), Z(google.maps.event.addListener(L, zs.onClusteringBegin, M)));
  }, [M]), h(() => {
    L && x && (K !== null && google.maps.event.removeListener(K), Z(google.maps.event.addListener(L, zs.onClusteringEnd, x)));
  }, [x]), h(() => {
    typeof r < "u" && L !== null && Nn.averageCenter(L, r);
  }, [L, r]), h(() => {
    typeof o < "u" && L !== null && Nn.batchSizeIE(L, o);
  }, [L, o]), h(() => {
    typeof i < "u" && L !== null && Nn.calculator(L, i);
  }, [L, i]), h(() => {
    typeof a < "u" && L !== null && Nn.clusterClass(L, a);
  }, [L, a]), h(() => {
    typeof s < "u" && L !== null && Nn.enableRetinaIcons(L, s);
  }, [L, s]), h(() => {
    typeof l < "u" && L !== null && Nn.gridSize(L, l);
  }, [L, l]), h(() => {
    typeof u < "u" && L !== null && Nn.ignoreHidden(L, u);
  }, [L, u]), h(() => {
    typeof c < "u" && L !== null && Nn.imageExtension(L, c);
  }, [L, c]), h(() => {
    typeof p < "u" && L !== null && Nn.imagePath(L, p);
  }, [L, p]), h(() => {
    typeof d < "u" && L !== null && Nn.imageSizes(L, d);
  }, [L, d]), h(() => {
    typeof g < "u" && L !== null && Nn.maxZoom(L, g);
  }, [L, g]), h(() => {
    typeof f < "u" && L !== null && Nn.minimumClusterSize(L, f);
  }, [L, f]), h(() => {
    typeof m < "u" && L !== null && Nn.styles(L, m);
  }, [L, m]), h(() => {
    typeof b < "u" && L !== null && Nn.title(L, b);
  }, [L, b]), h(() => {
    typeof E < "u" && L !== null && Nn.zoomOnClick(L, E);
  }, [L, E]), h(() => {
    if (N) {
      var z = wGe({}, n || CGe), S = new Hoe(N, [], z);
      return r && Nn.averageCenter(S, r), o && Nn.batchSizeIE(S, o), i && Nn.calculator(S, i), a && Nn.clusterClass(S, a), s && Nn.enableRetinaIcons(S, s), l && Nn.gridSize(S, l), u && Nn.ignoreHidden(S, u), c && Nn.imageExtension(S, c), p && Nn.imagePath(S, p), d && Nn.imageSizes(S, d), g && Nn.maxZoom(S, g), f && Nn.minimumClusterSize(S, f), m && Nn.styles(S, m), b && Nn.title(S, b), E && Nn.zoomOnClick(S, E), C && J(google.maps.event.addListener(S, zs.onMouseOut, C)), v && D(google.maps.event.addListener(S, zs.onMouseOver, v)), w && V(google.maps.event.addListener(S, zs.onClick, w)), M && Z(google.maps.event.addListener(S, zs.onClusteringBegin, M)), x && Y(google.maps.event.addListener(S, zs.onClusteringEnd, x)), B(S), P && P(S), () => {
        Q !== null && google.maps.event.removeListener(Q), _ !== null && google.maps.event.removeListener(_), $ !== null && google.maps.event.removeListener($), H !== null && google.maps.event.removeListener(H), K !== null && google.maps.event.removeListener(K), F && F(S);
      };
    }
  }, []), L !== null && t(L) || null;
}
me(OGe);
class xGe extends pe {
  constructor() {
    super(...arguments), Te(this, "registeredEvents", []), Te(this, "state", {
      markerClusterer: null
    }), Te(this, "setClustererCallback", () => {
      this.state.markerClusterer !== null && this.props.onLoad && this.props.onLoad(this.state.markerClusterer);
    });
  }
  componentDidMount() {
    if (this.context) {
      var t = new Hoe(this.context, [], this.props.options);
      this.registeredEvents = xn({
        updaterMap: Nn,
        eventMap: zs,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        markerClusterer: t
      }), this.setClustererCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.markerClusterer && (Mn(this.registeredEvents), this.registeredEvents = xn({
      updaterMap: Nn,
      eventMap: zs,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.markerClusterer
    }));
  }
  componentWillUnmount() {
    this.state.markerClusterer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.markerClusterer), Mn(this.registeredEvents), this.state.markerClusterer.setMap(null));
  }
  render() {
    return this.state.markerClusterer !== null ? this.props.children(this.state.markerClusterer) : null;
  }
}
Te(xGe, "contextType", Ut);
function T4(e) {
  e.cancelBubble = !0, e.stopPropagation && e.stopPropagation();
}
var Woe = (
  /** @class */
  function() {
    function e(t) {
      t === void 0 && (t = {}), this.getCloseClickHandler = this.getCloseClickHandler.bind(this), this.closeClickHandler = this.closeClickHandler.bind(this), this.createInfoBoxDiv = this.createInfoBoxDiv.bind(this), this.addClickHandler = this.addClickHandler.bind(this), this.getCloseBoxImg = this.getCloseBoxImg.bind(this), this.getBoxWidths = this.getBoxWidths.bind(this), this.setBoxStyle = this.setBoxStyle.bind(this), this.setPosition = this.setPosition.bind(this), this.getPosition = this.getPosition.bind(this), this.setOptions = this.setOptions.bind(this), this.setContent = this.setContent.bind(this), this.setVisible = this.setVisible.bind(this), this.getContent = this.getContent.bind(this), this.getVisible = this.getVisible.bind(this), this.setZIndex = this.setZIndex.bind(this), this.getZIndex = this.getZIndex.bind(this), this.onRemove = this.onRemove.bind(this), this.panBox = this.panBox.bind(this), this.extend = this.extend.bind(this), this.close = this.close.bind(this), this.draw = this.draw.bind(this), this.show = this.show.bind(this), this.hide = this.hide.bind(this), this.open = this.open.bind(this), this.extend(e, google.maps.OverlayView), this.content = t.content || "", this.disableAutoPan = t.disableAutoPan || !1, this.maxWidth = t.maxWidth || 0, this.pixelOffset = t.pixelOffset || new google.maps.Size(0, 0), this.position = t.position || new google.maps.LatLng(0, 0), this.zIndex = t.zIndex || null, this.boxClass = t.boxClass || "infoBox", this.boxStyle = t.boxStyle || {}, this.closeBoxMargin = t.closeBoxMargin || "2px", this.closeBoxURL = t.closeBoxURL || "http://www.google.com/intl/en_us/mapfiles/close.gif", t.closeBoxURL === "" && (this.closeBoxURL = ""), this.infoBoxClearance = t.infoBoxClearance || new google.maps.Size(1, 1), typeof t.visible > "u" && (typeof t.isHidden > "u" ? t.visible = !0 : t.visible = !t.isHidden), this.isHidden = !t.visible, this.alignBottom = t.alignBottom || !1, this.pane = t.pane || "floatPane", this.enableEventPropagation = t.enableEventPropagation || !1, this.div = null, this.closeListener = null, this.moveListener = null, this.mapListener = null, this.contextListener = null, this.eventListeners = null, this.fixedWidthSet = null;
    }
    return e.prototype.createInfoBoxDiv = function() {
      var t = this, n = function(u) {
        u.returnValue = !1, u.preventDefault && u.preventDefault(), t.enableEventPropagation || T4(u);
      };
      if (!this.div) {
        this.div = document.createElement("div"), this.setBoxStyle(), typeof this.content == "string" ? this.div.innerHTML = this.getCloseBoxImg() + this.content : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(this.content));
        var r = this.getPanes();
        if (r !== null && r[this.pane].appendChild(this.div), this.addClickHandler(), this.div.style.width)
          this.fixedWidthSet = !0;
        else if (this.maxWidth !== 0 && this.div.offsetWidth > this.maxWidth)
          this.div.style.width = this.maxWidth + "px", this.fixedWidthSet = !0;
        else {
          var o = this.getBoxWidths();
          this.div.style.width = this.div.offsetWidth - o.left - o.right + "px", this.fixedWidthSet = !1;
        }
        if (this.panBox(this.disableAutoPan), !this.enableEventPropagation) {
          this.eventListeners = [];
          for (var i = ["mousedown", "mouseover", "mouseout", "mouseup", "click", "dblclick", "touchstart", "touchend", "touchmove"], a = 0, s = i; a < s.length; a++) {
            var l = s[a];
            this.eventListeners.push(google.maps.event.addListener(this.div, l, T4));
          }
          this.eventListeners.push(google.maps.event.addListener(this.div, "mouseover", function() {
            t.div && (t.div.style.cursor = "default");
          }));
        }
        this.contextListener = google.maps.event.addListener(this.div, "contextmenu", n), google.maps.event.trigger(this, "domready");
      }
    }, e.prototype.getCloseBoxImg = function() {
      var t = "";
      return this.closeBoxURL !== "" && (t = '<img alt=""', t += ' aria-hidden="true"', t += " src='" + this.closeBoxURL + "'", t += " align=right", t += " style='", t += " position: relative;", t += " cursor: pointer;", t += " margin: " + this.closeBoxMargin + ";", t += "'>"), t;
    }, e.prototype.addClickHandler = function() {
      this.closeListener = this.div && this.div.firstChild && this.closeBoxURL !== "" ? google.maps.event.addListener(this.div.firstChild, "click", this.getCloseClickHandler()) : null;
    }, e.prototype.closeClickHandler = function(t) {
      t.cancelBubble = !0, t.stopPropagation && t.stopPropagation(), google.maps.event.trigger(this, "closeclick"), this.close();
    }, e.prototype.getCloseClickHandler = function() {
      return this.closeClickHandler;
    }, e.prototype.panBox = function(t) {
      if (this.div && !t) {
        var n = this.getMap();
        if (n instanceof google.maps.Map) {
          var r = 0, o = 0, i = n.getBounds();
          i && !i.contains(this.position) && n.setCenter(this.position);
          var a = n.getDiv(), s = a.offsetWidth, l = a.offsetHeight, u = this.pixelOffset.width, c = this.pixelOffset.height, p = this.div.offsetWidth, d = this.div.offsetHeight, g = this.infoBoxClearance.width, f = this.infoBoxClearance.height, m = this.getProjection(), b = m.fromLatLngToContainerPixel(this.position);
          b !== null && (b.x < -u + g ? r = b.x + u - g : b.x + p + u + g > s && (r = b.x + p + u + g - s), this.alignBottom ? b.y < -c + f + d ? o = b.y + c - f - d : b.y + c + f > l && (o = b.y + c + f - l) : b.y < -c + f ? o = b.y + c - f : b.y + d + c + f > l && (o = b.y + d + c + f - l)), r === 0 && o === 0 || n.panBy(r, o);
        }
      }
    }, e.prototype.setBoxStyle = function() {
      if (this.div) {
        this.div.className = this.boxClass, this.div.style.cssText = "";
        var t = this.boxStyle;
        for (var n in t)
          Object.prototype.hasOwnProperty.call(t, n) && (this.div.style[n] = t[n]);
        if (this.div.style.webkitTransform = "translateZ(0)", typeof this.div.style.opacity < "u" && this.div.style.opacity !== "") {
          var r = parseFloat(this.div.style.opacity || "");
          this.div.style.msFilter = '"progid:DXImageTransform.Microsoft.Alpha(Opacity=' + r * 100 + ')"', this.div.style.filter = "alpha(opacity=" + r * 100 + ")";
        }
        this.div.style.position = "absolute", this.div.style.visibility = "hidden", this.zIndex !== null && (this.div.style.zIndex = this.zIndex + ""), this.div.style.overflow || (this.div.style.overflow = "auto");
      }
    }, e.prototype.getBoxWidths = function() {
      var t = {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0
      };
      if (!this.div)
        return t;
      if (document.defaultView) {
        var n = this.div.ownerDocument, r = n && n.defaultView ? n.defaultView.getComputedStyle(this.div, "") : null;
        r && (t.top = parseInt(r.borderTopWidth || "", 10) || 0, t.bottom = parseInt(r.borderBottomWidth || "", 10) || 0, t.left = parseInt(r.borderLeftWidth || "", 10) || 0, t.right = parseInt(r.borderRightWidth || "", 10) || 0);
      } else if (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        document.documentElement.currentStyle
      ) {
        var o = this.div.currentStyle;
        o && (t.top = parseInt(o.borderTopWidth || "", 10) || 0, t.bottom = parseInt(o.borderBottomWidth || "", 10) || 0, t.left = parseInt(o.borderLeftWidth || "", 10) || 0, t.right = parseInt(o.borderRightWidth || "", 10) || 0);
      }
      return t;
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.div.parentNode.removeChild(this.div), this.div = null);
    }, e.prototype.draw = function() {
      if (this.createInfoBoxDiv(), this.div) {
        var t = this.getProjection(), n = t.fromLatLngToDivPixel(this.position);
        n !== null && (this.div.style.left = n.x + this.pixelOffset.width + "px", this.alignBottom ? this.div.style.bottom = -(n.y + this.pixelOffset.height) + "px" : this.div.style.top = n.y + this.pixelOffset.height + "px"), this.isHidden ? this.div.style.visibility = "hidden" : this.div.style.visibility = "visible";
      }
    }, e.prototype.setOptions = function(t) {
      t === void 0 && (t = {}), typeof t.boxClass < "u" && (this.boxClass = t.boxClass, this.setBoxStyle()), typeof t.boxStyle < "u" && (this.boxStyle = t.boxStyle, this.setBoxStyle()), typeof t.content < "u" && this.setContent(t.content), typeof t.disableAutoPan < "u" && (this.disableAutoPan = t.disableAutoPan), typeof t.maxWidth < "u" && (this.maxWidth = t.maxWidth), typeof t.pixelOffset < "u" && (this.pixelOffset = t.pixelOffset), typeof t.alignBottom < "u" && (this.alignBottom = t.alignBottom), typeof t.position < "u" && this.setPosition(t.position), typeof t.zIndex < "u" && this.setZIndex(t.zIndex), typeof t.closeBoxMargin < "u" && (this.closeBoxMargin = t.closeBoxMargin), typeof t.closeBoxURL < "u" && (this.closeBoxURL = t.closeBoxURL), typeof t.infoBoxClearance < "u" && (this.infoBoxClearance = t.infoBoxClearance), typeof t.isHidden < "u" && (this.isHidden = t.isHidden), typeof t.visible < "u" && (this.isHidden = !t.visible), typeof t.enableEventPropagation < "u" && (this.enableEventPropagation = t.enableEventPropagation), this.div && this.draw();
    }, e.prototype.setContent = function(t) {
      this.content = t, this.div && (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.fixedWidthSet || (this.div.style.width = ""), typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t)), this.fixedWidthSet || (this.div.style.width = this.div.offsetWidth + "px", typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t))), this.addClickHandler()), google.maps.event.trigger(this, "content_changed");
    }, e.prototype.setPosition = function(t) {
      this.position = t, this.div && this.draw(), google.maps.event.trigger(this, "position_changed");
    }, e.prototype.setVisible = function(t) {
      this.isHidden = !t, this.div && (this.div.style.visibility = this.isHidden ? "hidden" : "visible");
    }, e.prototype.setZIndex = function(t) {
      this.zIndex = t, this.div && (this.div.style.zIndex = t + ""), google.maps.event.trigger(this, "zindex_changed");
    }, e.prototype.getContent = function() {
      return this.content;
    }, e.prototype.getPosition = function() {
      return this.position;
    }, e.prototype.getZIndex = function() {
      return this.zIndex;
    }, e.prototype.getVisible = function() {
      var t = this.getMap();
      return typeof t > "u" || t === null ? !1 : !this.isHidden;
    }, e.prototype.show = function() {
      this.isHidden = !1, this.div && (this.div.style.visibility = "visible");
    }, e.prototype.hide = function() {
      this.isHidden = !0, this.div && (this.div.style.visibility = "hidden");
    }, e.prototype.open = function(t, n) {
      var r = this;
      n && (this.position = n.getPosition(), this.moveListener = google.maps.event.addListener(n, "position_changed", function() {
        var o = n.getPosition();
        r.setPosition(o);
      }), this.mapListener = google.maps.event.addListener(n, "map_changed", function() {
        r.setMap(n.map);
      })), this.setMap(t), this.div && this.panBox();
    }, e.prototype.close = function() {
      if (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.eventListeners) {
        for (var t = 0, n = this.eventListeners; t < n.length; t++) {
          var r = n[t];
          google.maps.event.removeListener(r);
        }
        this.eventListeners = null;
      }
      this.moveListener && (google.maps.event.removeListener(this.moveListener), this.moveListener = null), this.mapListener && (google.maps.event.removeListener(this.mapListener), this.mapListener = null), this.contextListener && (google.maps.event.removeListener(this.contextListener), this.contextListener = null), this.setMap(null);
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype)
          Object.prototype.hasOwnProperty.call(this, o) || (this.prototype[o] = r.prototype[o]);
        return this;
      }).apply(t, [n]);
    }, e;
  }()
), EGe = ["position"], kGe = ["position"];
function j4(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function $w(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? j4(Object(n), !0).forEach(function(r) {
      Te(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : j4(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var A4 = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, R4 = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    t instanceof google.maps.LatLng ? e.setPosition(t) : e.setPosition(new google.maps.LatLng(t.lat, t.lng));
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, LGe = {};
function _Ge(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, g = ge(Ut), [f, m] = k(null), [b, E] = k(null), [w, M] = k(null), [x, v] = k(null), [C, P] = k(null), [F, L] = k(null), B = dt(null);
  return h(() => {
    g && f !== null && (f.close(), n ? f.open(g, n) : f.getPosition() && f.open(g));
  }, [g, f, n]), h(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), h(() => {
    if (o && f !== null) {
      var N = o instanceof google.maps.LatLng ? o : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        new google.maps.LatLng(o.lat, o.lng)
      );
      f.setPosition(N);
    }
  }, [o]), h(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), h(() => {
    f && a && (b !== null && google.maps.event.removeListener(b), E(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), h(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), M(google.maps.event.addListener(f, "domready", s)));
  }, [s]), h(() => {
    f && l && (x !== null && google.maps.event.removeListener(x), v(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), h(() => {
    f && u && (C !== null && google.maps.event.removeListener(C), P(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), h(() => {
    f && c && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), h(() => {
    if (g) {
      var N = r || LGe, {
        position: $
      } = N, V = uj(N, EGe), H;
      $ && !($ instanceof google.maps.LatLng) && (H = new google.maps.LatLng($.lat, $.lng));
      var Z = new Woe($w($w({}, V), H ? {
        position: H
      } : {}));
      B.current = document.createElement("div"), m(Z), a && E(google.maps.event.addListener(Z, "closeclick", a)), s && M(google.maps.event.addListener(Z, "domready", s)), l && v(google.maps.event.addListener(Z, "content_changed", l)), u && P(google.maps.event.addListener(Z, "position_changed", u)), c && L(google.maps.event.addListener(Z, "zindex_changed", c)), Z.setContent(B.current), n ? Z.open(g, n) : Z.getPosition() ? Z.open(g) : qo(!1, "You must provide either an anchor or a position prop for <InfoBox>."), p && p(Z);
    }
    return () => {
      f !== null && (b && google.maps.event.removeListener(b), x && google.maps.event.removeListener(x), w && google.maps.event.removeListener(w), C && google.maps.event.removeListener(C), F && google.maps.event.removeListener(F), d && d(f), f.close());
    };
  }, []), B.current ? zn(at.only(t), B.current) : null;
}
me(_Ge);
class PGe extends pe {
  constructor() {
    super(...arguments), Te(this, "registeredEvents", []), Te(this, "containerElement", null), Te(this, "state", {
      infoBox: null
    }), Te(this, "open", (t, n) => {
      n ? this.context !== null && t.open(this.context, n) : t.getPosition() ? this.context !== null && t.open(this.context) : qo(!1, "You must provide either an anchor or a position prop for <InfoBox>.");
    }), Te(this, "setInfoBoxCallback", () => {
      this.state.infoBox !== null && this.containerElement !== null && (this.state.infoBox.setContent(this.containerElement), this.open(this.state.infoBox, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoBox));
    });
  }
  componentDidMount() {
    var t = this.props.options || {}, {
      position: n
    } = t, r = uj(t, kGe), o;
    n && !(n instanceof google.maps.LatLng) && (o = new google.maps.LatLng(n.lat, n.lng));
    var i = new Woe($w($w({}, r), o ? {
      position: o
    } : {}));
    this.containerElement = document.createElement("div"), this.registeredEvents = xn({
      updaterMap: R4,
      eventMap: A4,
      prevProps: {},
      nextProps: this.props,
      instance: i
    }), this.setState({
      infoBox: i
    }, this.setInfoBoxCallback);
  }
  componentDidUpdate(t) {
    var {
      infoBox: n
    } = this.state;
    n !== null && (Mn(this.registeredEvents), this.registeredEvents = xn({
      updaterMap: R4,
      eventMap: A4,
      prevProps: t,
      nextProps: this.props,
      instance: n
    }));
  }
  componentWillUnmount() {
    var {
      onUnmount: t
    } = this.props, {
      infoBox: n
    } = this.state;
    n !== null && (t && t(n), Mn(this.registeredEvents), n.close());
  }
  render() {
    return this.containerElement ? zn(at.only(this.props.children), this.containerElement) : null;
  }
}
Te(PGe, "contextType", Ut);
var I4, N4;
function SGe() {
  return N4 || (N4 = 1, I4 = function e(t, n) {
    if (t === n) return !0;
    if (t && n && typeof t == "object" && typeof n == "object") {
      if (t.constructor !== n.constructor) return !1;
      var r, o, i;
      if (Array.isArray(t)) {
        if (r = t.length, r != n.length) return !1;
        for (o = r; o-- !== 0; ) if (!e(t[o], n[o])) return !1;
        return !0;
      }
      if (t.constructor === RegExp) return t.source === n.source && t.flags === n.flags;
      if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === n.valueOf();
      if (t.toString !== Object.prototype.toString) return t.toString() === n.toString();
      if (i = Object.keys(t), r = i.length, r !== Object.keys(n).length) return !1;
      for (o = r; o-- !== 0; ) if (!Object.prototype.hasOwnProperty.call(n, i[o])) return !1;
      for (o = r; o-- !== 0; ) {
        var a = i[o];
        if (!e(t[a], n[a])) return !1;
      }
      return !0;
    }
    return t !== t && n !== n;
  }), I4;
}
var MGe = SGe(), B4 = /* @__PURE__ */ Ioe(MGe), F4 = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array], kL = 1, Id = 8;
class cj {
  /**
   * Creates an index from raw `ArrayBuffer` data.
   * @param {ArrayBuffer} data
   */
  static from(t) {
    if (!(t instanceof ArrayBuffer))
      throw new Error("Data must be an instance of ArrayBuffer.");
    var [n, r] = new Uint8Array(t, 0, 2);
    if (n !== 219)
      throw new Error("Data does not appear to be in a KDBush format.");
    var o = r >> 4;
    if (o !== kL)
      throw new Error("Got v".concat(o, " data when expected v").concat(kL, "."));
    var i = F4[r & 15];
    if (!i)
      throw new Error("Unrecognized array type.");
    var [a] = new Uint16Array(t, 2, 1), [s] = new Uint32Array(t, 4, 1);
    return new cj(s, a, i, t);
  }
  /**
   * Creates an index that will hold a given number of items.
   * @param {number} numItems
   * @param {number} [nodeSize=64] Size of the KD-tree node (64 by default).
   * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).
   * @param {ArrayBuffer} [data] (For internal use only)
   */
  constructor(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 64, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Float64Array, o = arguments.length > 3 ? arguments[3] : void 0;
    if (isNaN(t) || t < 0) throw new Error("Unpexpected numItems value: ".concat(t, "."));
    this.numItems = +t, this.nodeSize = Math.min(Math.max(+n, 2), 65535), this.ArrayType = r, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
    var i = F4.indexOf(this.ArrayType), a = t * 2 * this.ArrayType.BYTES_PER_ELEMENT, s = t * this.IndexArrayType.BYTES_PER_ELEMENT, l = (8 - s % 8) % 8;
    if (i < 0)
      throw new Error("Unexpected typed array class: ".concat(r, "."));
    o && o instanceof ArrayBuffer ? (this.data = o, this.ids = new this.IndexArrayType(this.data, Id, t), this.coords = new this.ArrayType(this.data, Id + s + l, t * 2), this._pos = t * 2, this._finished = !0) : (this.data = new ArrayBuffer(Id + a + s + l), this.ids = new this.IndexArrayType(this.data, Id, t), this.coords = new this.ArrayType(this.data, Id + s + l, t * 2), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, (kL << 4) + i]), new Uint16Array(this.data, 2, 1)[0] = n, new Uint32Array(this.data, 4, 1)[0] = t);
  }
  /**
   * Add a point to the index.
   * @param {number} x
   * @param {number} y
   * @returns {number} An incremental index associated with the added item (starting from `0`).
   */
  add(t, n) {
    var r = this._pos >> 1;
    return this.ids[r] = r, this.coords[this._pos++] = t, this.coords[this._pos++] = n, r;
  }
  /**
   * Perform indexing of the added points.
   */
  finish() {
    var t = this._pos >> 1;
    if (t !== this.numItems)
      throw new Error("Added ".concat(t, " items when expected ").concat(this.numItems, "."));
    return kP(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
  }
  /**
   * Search the index for items within a given bounding box.
   * @param {number} minX
   * @param {number} minY
   * @param {number} maxX
   * @param {number} maxY
   * @returns {number[]} An array of indices correponding to the found items.
   */
  range(t, n, r, o) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: i,
      coords: a,
      nodeSize: s
    } = this, l = [0, i.length - 1, 0], u = []; l.length; ) {
      var c = l.pop() || 0, p = l.pop() || 0, d = l.pop() || 0;
      if (p - d <= s) {
        for (var g = d; g <= p; g++) {
          var f = a[2 * g], m = a[2 * g + 1];
          f >= t && f <= r && m >= n && m <= o && u.push(i[g]);
        }
        continue;
      }
      var b = d + p >> 1, E = a[2 * b], w = a[2 * b + 1];
      E >= t && E <= r && w >= n && w <= o && u.push(i[b]), (c === 0 ? t <= E : n <= w) && (l.push(d), l.push(b - 1), l.push(1 - c)), (c === 0 ? r >= E : o >= w) && (l.push(b + 1), l.push(p), l.push(1 - c));
    }
    return u;
  }
  /**
   * Search the index for items within a given radius.
   * @param {number} qx
   * @param {number} qy
   * @param {number} r Query radius.
   * @returns {number[]} An array of indices correponding to the found items.
   */
  within(t, n, r) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: o,
      coords: i,
      nodeSize: a
    } = this, s = [0, o.length - 1, 0], l = [], u = r * r; s.length; ) {
      var c = s.pop() || 0, p = s.pop() || 0, d = s.pop() || 0;
      if (p - d <= a) {
        for (var g = d; g <= p; g++)
          z4(i[2 * g], i[2 * g + 1], t, n) <= u && l.push(o[g]);
        continue;
      }
      var f = d + p >> 1, m = i[2 * f], b = i[2 * f + 1];
      z4(m, b, t, n) <= u && l.push(o[f]), (c === 0 ? t - r <= m : n - r <= b) && (s.push(d), s.push(f - 1), s.push(1 - c)), (c === 0 ? t + r >= m : n + r >= b) && (s.push(f + 1), s.push(p), s.push(1 - c));
    }
    return l;
  }
}
function kP(e, t, n, r, o, i) {
  if (!(o - r <= n)) {
    var a = r + o >> 1;
    $oe(e, t, a, r, o, i), kP(e, t, n, r, a - 1, 1 - i), kP(e, t, n, a + 1, o, 1 - i);
  }
}
function $oe(e, t, n, r, o, i) {
  for (; o > r; ) {
    if (o - r > 600) {
      var a = o - r + 1, s = n - r + 1, l = Math.log(a), u = 0.5 * Math.exp(2 * l / 3), c = 0.5 * Math.sqrt(l * u * (a - u) / a) * (s - a / 2 < 0 ? -1 : 1), p = Math.max(r, Math.floor(n - s * u / a + c)), d = Math.min(o, Math.floor(n + (a - s) * u / a + c));
      $oe(e, t, n, p, d, i);
    }
    var g = t[2 * n + i], f = r, m = o;
    for (Nd(e, t, r, n), t[2 * o + i] > g && Nd(e, t, r, o); f < m; ) {
      for (Nd(e, t, f, m), f++, m--; t[2 * f + i] < g; ) f++;
      for (; t[2 * m + i] > g; ) m--;
    }
    t[2 * r + i] === g ? Nd(e, t, r, m) : (m++, Nd(e, t, m, o)), m <= n && (r = m + 1), n <= m && (o = m - 1);
  }
}
function Nd(e, t, n, r) {
  LL(e, n, r), LL(t, 2 * n, 2 * r), LL(t, 2 * n + 1, 2 * r + 1);
}
function LL(e, t, n) {
  var r = e[t];
  e[t] = e[n], e[n] = r;
}
function z4(e, t, n, r) {
  var o = e - n, i = t - r;
  return o * o + i * i;
}
var DGe = {
  minZoom: 0,
  // min zoom to generate clusters on
  maxZoom: 16,
  // max zoom level to cluster the points on
  minPoints: 2,
  // minimum points to form a cluster
  radius: 40,
  // cluster radius in pixels
  extent: 512,
  // tile extent (radius is calculated relative to it)
  nodeSize: 64,
  // size of the KD-tree leaf node, affects performance
  log: !1,
  // whether to log timing info
  // whether to generate numeric ids for input features (in vector tiles)
  generateId: !1,
  // a reduce function for calculating custom cluster properties
  reduce: null,
  // (accumulated, props) => { accumulated.sum += props.sum; }
  // properties to use for individual points when running the reducer
  map: (e) => e
  // props => ({sum: props.my_value})
}, U4 = Math.fround || /* @__PURE__ */ ((e) => (t) => (e[0] = +t, e[0]))(new Float32Array(1)), Zu = 2, Vl = 3, _L = 4, Nl = 5, Voe = 6;
class TGe {
  constructor(t) {
    this.options = Object.assign(Object.create(DGe), t), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
  }
  load(t) {
    var {
      log: n,
      minZoom: r,
      maxZoom: o
    } = this.options;
    n && console.time("total time");
    var i = "prepare ".concat(t.length, " points");
    n && console.time(i), this.points = t;
    for (var a = [], s = 0; s < t.length; s++) {
      var l = t[s];
      if (l.geometry) {
        var [u, c] = l.geometry.coordinates, p = U4(oy(u)), d = U4(iy(c));
        a.push(
          p,
          d,
          // projected point coordinates
          1 / 0,
          // the last zoom the point was processed at
          s,
          // index of the source feature in the original input array
          -1,
          // parent cluster id
          1
          // number of points in a cluster
        ), this.options.reduce && a.push(0);
      }
    }
    var g = this.trees[o + 1] = this._createTree(a);
    n && console.timeEnd(i);
    for (var f = o; f >= r; f--) {
      var m = +Date.now();
      g = this.trees[f] = this._createTree(this._cluster(g, f)), n && console.log("z%d: %d clusters in %dms", f, g.numItems, +Date.now() - m);
    }
    return n && console.timeEnd("total time"), this;
  }
  getClusters(t, n) {
    var r = ((t[0] + 180) % 360 + 360) % 360 - 180, o = Math.max(-90, Math.min(90, t[1])), i = t[2] === 180 ? 180 : ((t[2] + 180) % 360 + 360) % 360 - 180, a = Math.max(-90, Math.min(90, t[3]));
    if (t[2] - t[0] >= 360)
      r = -180, i = 180;
    else if (r > i) {
      var s = this.getClusters([r, o, 180, a], n), l = this.getClusters([-180, o, i, a], n);
      return s.concat(l);
    }
    var u = this.trees[this._limitZoom(n)], c = u.range(oy(r), iy(a), oy(i), iy(o)), p = u.data, d = [];
    for (var g of c) {
      var f = this.stride * g;
      d.push(p[f + Nl] > 1 ? H4(p, f, this.clusterProps) : this.points[p[f + Vl]]);
    }
    return d;
  }
  getChildren(t) {
    var n = this._getOriginId(t), r = this._getOriginZoom(t), o = "No cluster with the specified id.", i = this.trees[r];
    if (!i) throw new Error(o);
    var a = i.data;
    if (n * this.stride >= a.length) throw new Error(o);
    var s = this.options.radius / (this.options.extent * Math.pow(2, r - 1)), l = a[n * this.stride], u = a[n * this.stride + 1], c = i.within(l, u, s), p = [];
    for (var d of c) {
      var g = d * this.stride;
      a[g + _L] === t && p.push(a[g + Nl] > 1 ? H4(a, g, this.clusterProps) : this.points[a[g + Vl]]);
    }
    if (p.length === 0) throw new Error(o);
    return p;
  }
  getLeaves(t, n, r) {
    n = n || 10, r = r || 0;
    var o = [];
    return this._appendLeaves(o, t, n, r, 0), o;
  }
  getTile(t, n, r) {
    var o = this.trees[this._limitZoom(t)], i = Math.pow(2, t), {
      extent: a,
      radius: s
    } = this.options, l = s / a, u = (r - l) / i, c = (r + 1 + l) / i, p = {
      features: []
    };
    return this._addTileFeatures(o.range((n - l) / i, u, (n + 1 + l) / i, c), o.data, n, r, i, p), n === 0 && this._addTileFeatures(o.range(1 - l / i, u, 1, c), o.data, i, r, i, p), n === i - 1 && this._addTileFeatures(o.range(0, u, l / i, c), o.data, -1, r, i, p), p.features.length ? p : null;
  }
  getClusterExpansionZoom(t) {
    for (var n = this._getOriginZoom(t) - 1; n <= this.options.maxZoom; ) {
      var r = this.getChildren(t);
      if (n++, r.length !== 1) break;
      t = r[0].properties.cluster_id;
    }
    return n;
  }
  _appendLeaves(t, n, r, o, i) {
    var a = this.getChildren(n);
    for (var s of a) {
      var l = s.properties;
      if (l && l.cluster ? i + l.point_count <= o ? i += l.point_count : i = this._appendLeaves(t, l.cluster_id, r, o, i) : i < o ? i++ : t.push(s), t.length === r) break;
    }
    return i;
  }
  _createTree(t) {
    for (var n = new cj(t.length / this.stride | 0, this.options.nodeSize, Float32Array), r = 0; r < t.length; r += this.stride) n.add(t[r], t[r + 1]);
    return n.finish(), n.data = t, n;
  }
  _addTileFeatures(t, n, r, o, i, a) {
    for (var s of t) {
      var l = s * this.stride, u = n[l + Nl] > 1, c = void 0, p = void 0, d = void 0;
      if (u)
        c = Zoe(n, l, this.clusterProps), p = n[l], d = n[l + 1];
      else {
        var g = this.points[n[l + Vl]];
        c = g.properties;
        var [f, m] = g.geometry.coordinates;
        p = oy(f), d = iy(m);
      }
      var b = {
        type: 1,
        geometry: [[Math.round(this.options.extent * (p * i - r)), Math.round(this.options.extent * (d * i - o))]],
        tags: c
      }, E = void 0;
      u || this.options.generateId ? E = n[l + Vl] : E = this.points[n[l + Vl]].id, E !== void 0 && (b.id = E), a.features.push(b);
    }
  }
  _limitZoom(t) {
    return Math.max(this.options.minZoom, Math.min(Math.floor(+t), this.options.maxZoom + 1));
  }
  _cluster(t, n) {
    for (var {
      radius: r,
      extent: o,
      reduce: i,
      minPoints: a
    } = this.options, s = r / (o * Math.pow(2, n)), l = t.data, u = [], c = this.stride, p = 0; p < l.length; p += c)
      if (!(l[p + Zu] <= n)) {
        l[p + Zu] = n;
        var d = l[p], g = l[p + 1], f = t.within(l[p], l[p + 1], s), m = l[p + Nl], b = m;
        for (var E of f) {
          var w = E * c;
          l[w + Zu] > n && (b += l[w + Nl]);
        }
        if (b > m && b >= a) {
          var M = d * m, x = g * m, v = void 0, C = -1, P = ((p / c | 0) << 5) + (n + 1) + this.points.length;
          for (var F of f) {
            var L = F * c;
            if (!(l[L + Zu] <= n)) {
              l[L + Zu] = n;
              var B = l[L + Nl];
              M += l[L] * B, x += l[L + 1] * B, l[L + _L] = P, i && (v || (v = this._map(l, p, !0), C = this.clusterProps.length, this.clusterProps.push(v)), i(v, this._map(l, L)));
            }
          }
          l[p + _L] = P, u.push(M / b, x / b, 1 / 0, P, -1, b), i && u.push(C);
        } else {
          for (var N = 0; N < c; N++) u.push(l[p + N]);
          if (b > 1)
            for (var $ of f) {
              var V = $ * c;
              if (!(l[V + Zu] <= n)) {
                l[V + Zu] = n;
                for (var H = 0; H < c; H++) u.push(l[V + H]);
              }
            }
        }
      }
    return u;
  }
  // get index of the point from which the cluster originated
  _getOriginId(t) {
    return t - this.points.length >> 5;
  }
  // get zoom of the point from which the cluster originated
  _getOriginZoom(t) {
    return (t - this.points.length) % 32;
  }
  _map(t, n, r) {
    if (t[n + Nl] > 1) {
      var o = this.clusterProps[t[n + Voe]];
      return r ? Object.assign({}, o) : o;
    }
    var i = this.points[t[n + Vl]].properties, a = this.options.map(i);
    return r && a === i ? Object.assign({}, a) : a;
  }
}
function H4(e, t, n) {
  return {
    type: "Feature",
    id: e[t + Vl],
    properties: Zoe(e, t, n),
    geometry: {
      type: "Point",
      coordinates: [jGe(e[t]), AGe(e[t + 1])]
    }
  };
}
function Zoe(e, t, n) {
  var r = e[t + Nl], o = r >= 1e4 ? "".concat(Math.round(r / 1e3), "k") : r >= 1e3 ? "".concat(Math.round(r / 100) / 10, "k") : r, i = e[t + Voe], a = i === -1 ? {} : Object.assign({}, n[i]);
  return Object.assign(a, {
    cluster: !0,
    cluster_id: e[t + Vl],
    point_count: r,
    point_count_abbreviated: o
  });
}
function oy(e) {
  return e / 360 + 0.5;
}
function iy(e) {
  var t = Math.sin(e * Math.PI / 180), n = 0.5 - 0.25 * Math.log((1 + t) / (1 - t)) / Math.PI;
  return n < 0 ? 0 : n > 1 ? 1 : n;
}
function jGe(e) {
  return (e - 0.5) * 360;
}
function AGe(e) {
  var t = (180 - e * 360) * Math.PI / 180;
  return 360 * Math.atan(Math.exp(t)) / Math.PI - 90;
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function RGe(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
    t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
  return n;
}
class ms {
  static isAdvancedMarkerAvailable(t) {
    return google.maps.marker && t.getMapCapabilities().isAdvancedMarkersAvailable === !0;
  }
  static isAdvancedMarker(t) {
    return google.maps.marker && t instanceof google.maps.marker.AdvancedMarkerElement;
  }
  static setMap(t, n) {
    this.isAdvancedMarker(t) ? t.map = n : t.setMap(n);
  }
  static getPosition(t) {
    if (this.isAdvancedMarker(t)) {
      if (t.position) {
        if (t.position instanceof google.maps.LatLng)
          return t.position;
        if (t.position.lat && t.position.lng)
          return new google.maps.LatLng(t.position.lat, t.position.lng);
      }
      return new google.maps.LatLng(null);
    }
    return t.getPosition();
  }
  static getVisible(t) {
    return this.isAdvancedMarker(t) ? !0 : t.getVisible();
  }
}
class LP {
  constructor(t) {
    var {
      markers: n,
      position: r
    } = t;
    this.markers = n, r && (r instanceof google.maps.LatLng ? this._position = r : this._position = new google.maps.LatLng(r));
  }
  get bounds() {
    if (!(this.markers.length === 0 && !this._position)) {
      var t = new google.maps.LatLngBounds(this._position, this._position);
      for (var n of this.markers)
        t.extend(ms.getPosition(n));
      return t;
    }
  }
  get position() {
    return this._position || this.bounds.getCenter();
  }
  /**
   * Get the count of **visible** markers.
   */
  get count() {
    return this.markers.filter((t) => ms.getVisible(t)).length;
  }
  /**
   * Add a marker to the cluster.
   */
  push(t) {
    this.markers.push(t);
  }
  /**
   * Cleanup references and remove marker from map.
   */
  delete() {
    this.marker && (ms.setMap(this.marker, null), this.marker = void 0), this.markers.length = 0;
  }
}
class IGe {
  constructor(t) {
    var {
      maxZoom: n = 16
    } = t;
    this.maxZoom = n;
  }
  /**
   * Helper function to bypass clustering based upon some map state such as
   * zoom, number of markers, etc.
   *
   * ```typescript
   *  cluster({markers, map}: AlgorithmInput): Cluster[] {
   *    if (shouldBypassClustering(map)) {
   *      return this.noop({markers})
   *    }
   * }
   * ```
   */
  noop(t) {
    var {
      markers: n
    } = t;
    return NGe(n);
  }
}
var NGe = (e) => {
  var t = e.map((n) => new LP({
    position: ms.getPosition(n),
    markers: [n]
  }));
  return t;
};
class BGe extends IGe {
  constructor(t) {
    var {
      maxZoom: n,
      radius: r = 60
    } = t, o = RGe(t, ["maxZoom", "radius"]);
    super({
      maxZoom: n
    }), this.state = {
      zoom: -1
    }, this.superCluster = new TGe(Object.assign({
      maxZoom: this.maxZoom,
      radius: r
    }, o));
  }
  calculate(t) {
    var n = !1, r = {
      zoom: t.map.getZoom()
    };
    if (!B4(t.markers, this.markers)) {
      n = !0, this.markers = [...t.markers];
      var o = this.markers.map((i) => {
        var a = ms.getPosition(i), s = [a.lng(), a.lat()];
        return {
          type: "Feature",
          geometry: {
            type: "Point",
            coordinates: s
          },
          properties: {
            marker: i
          }
        };
      });
      this.superCluster.load(o);
    }
    return n || (this.state.zoom <= this.maxZoom || r.zoom <= this.maxZoom) && (n = !B4(this.state, r)), this.state = r, n && (this.clusters = this.cluster(t)), {
      clusters: this.clusters,
      changed: n
    };
  }
  cluster(t) {
    var {
      map: n
    } = t;
    return this.superCluster.getClusters([-180, -90, 180, 90], Math.round(n.getZoom())).map((r) => this.transformCluster(r));
  }
  transformCluster(t) {
    var {
      geometry: {
        coordinates: [n, r]
      },
      properties: o
    } = t;
    if (o.cluster)
      return new LP({
        markers: this.superCluster.getLeaves(o.cluster_id, 1 / 0).map((a) => a.properties.marker),
        position: {
          lat: r,
          lng: n
        }
      });
    var i = o.marker;
    return new LP({
      markers: [i],
      position: ms.getPosition(i)
    });
  }
}
class FGe {
  constructor(t, n) {
    this.markers = {
      sum: t.length
    };
    var r = n.map((i) => i.count), o = r.reduce((i, a) => i + a, 0);
    this.clusters = {
      count: n.length,
      markers: {
        mean: o / n.length,
        sum: o,
        min: Math.min(...r),
        max: Math.max(...r)
      }
    };
  }
}
class zGe {
  /**
   * The default render function for the library used by {@link MarkerClusterer}.
   *
   * Currently set to use the following:
   *
   * ```typescript
   * // change color if this cluster has more markers than the mean cluster
   * const color =
   *   count > Math.max(10, stats.clusters.markers.mean)
   *     ? "#ff0000"
   *     : "#0000ff";
   *
   * // create svg url with fill color
   * const svg = window.btoa(`
   * <svg fill="${color}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240">
   *   <circle cx="120" cy="120" opacity=".6" r="70" />
   *   <circle cx="120" cy="120" opacity=".3" r="90" />
   *   <circle cx="120" cy="120" opacity=".2" r="110" />
   *   <circle cx="120" cy="120" opacity=".1" r="130" />
   * </svg>`);
   *
   * // create marker using svg icon
   * return new google.maps.Marker({
   *   position,
   *   icon: {
   *     url: `data:image/svg+xml;base64,${svg}`,
   *     scaledSize: new google.maps.Size(45, 45),
   *   },
   *   label: {
   *     text: String(count),
   *     color: "rgba(255,255,255,0.9)",
   *     fontSize: "12px",
   *   },
   *   // adjust zIndex to be above other markers
   *   zIndex: 1000 + count,
   * });
   * ```
   */
  render(t, n, r) {
    var {
      count: o,
      position: i
    } = t, a = o > Math.max(10, n.clusters.markers.mean) ? "#ff0000" : "#0000ff", s = '<svg fill="'.concat(a, `" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" width="50" height="50">
<circle cx="120" cy="120" opacity=".6" r="70" />
<circle cx="120" cy="120" opacity=".3" r="90" />
<circle cx="120" cy="120" opacity=".2" r="110" />
<text x="50%" y="50%" style="fill:#fff" text-anchor="middle" font-size="50" dominant-baseline="middle" font-family="roboto,arial,sans-serif">`).concat(o, `</text>
</svg>`), l = "Cluster of ".concat(o, " markers"), u = Number(google.maps.Marker.MAX_ZINDEX) + o;
    if (ms.isAdvancedMarkerAvailable(r)) {
      var c = new DOMParser(), p = c.parseFromString(s, "image/svg+xml").documentElement;
      p.setAttribute("transform", "translate(0 25)");
      var d = {
        map: r,
        position: i,
        zIndex: u,
        title: l,
        content: p
      };
      return new google.maps.marker.AdvancedMarkerElement(d);
    }
    var g = {
      position: i,
      zIndex: u,
      title: l,
      icon: {
        url: "data:image/svg+xml;base64,".concat(btoa(s)),
        anchor: new google.maps.Point(25, 25)
      }
    };
    return new google.maps.Marker(g);
  }
}
function UGe(e, t) {
  for (var n in t.prototype)
    e.prototype[n] = t.prototype[n];
}
class pj {
  constructor() {
    UGe(pj, google.maps.OverlayView);
  }
}
var Rf;
(function(e) {
  e.CLUSTERING_BEGIN = "clusteringbegin", e.CLUSTERING_END = "clusteringend", e.CLUSTER_CLICK = "click";
})(Rf || (Rf = {}));
var HGe = (e, t, n) => {
  n.fitBounds(t.bounds);
};
class WGe extends pj {
  constructor(t) {
    var {
      map: n,
      markers: r = [],
      algorithmOptions: o = {},
      algorithm: i = new BGe(o),
      renderer: a = new zGe(),
      onClusterClick: s = HGe
    } = t;
    super(), this.markers = [...r], this.clusters = [], this.algorithm = i, this.renderer = a, this.onClusterClick = s, n && this.setMap(n);
  }
  addMarker(t, n) {
    this.markers.includes(t) || (this.markers.push(t), n || this.render());
  }
  addMarkers(t, n) {
    t.forEach((r) => {
      this.addMarker(r, !0);
    }), n || this.render();
  }
  removeMarker(t, n) {
    var r = this.markers.indexOf(t);
    return r === -1 ? !1 : (ms.setMap(t, null), this.markers.splice(r, 1), n || this.render(), !0);
  }
  removeMarkers(t, n) {
    var r = !1;
    return t.forEach((o) => {
      r = this.removeMarker(o, !0) || r;
    }), r && !n && this.render(), r;
  }
  clearMarkers(t) {
    this.markers.length = 0, t || this.render();
  }
  /**
   * Recalculates and draws all the marker clusters.
   */
  render() {
    var t = this.getMap();
    if (t instanceof google.maps.Map && t.getProjection()) {
      google.maps.event.trigger(this, Rf.CLUSTERING_BEGIN, this);
      var {
        clusters: n,
        changed: r
      } = this.algorithm.calculate({
        markers: this.markers,
        map: t,
        mapCanvasProjection: this.getProjection()
      });
      if (r || r == null) {
        var o = /* @__PURE__ */ new Set();
        for (var i of n)
          i.markers.length == 1 && o.add(i.markers[0]);
        var a = [];
        for (var s of this.clusters)
          s.marker != null && (s.markers.length == 1 ? o.has(s.marker) || ms.setMap(s.marker, null) : a.push(s.marker));
        this.clusters = n, this.renderClusters(), requestAnimationFrame(() => a.forEach((l) => ms.setMap(l, null)));
      }
      google.maps.event.trigger(this, Rf.CLUSTERING_END, this);
    }
  }
  onAdd() {
    this.idleListener = this.getMap().addListener("idle", this.render.bind(this)), this.render();
  }
  onRemove() {
    google.maps.event.removeListener(this.idleListener), this.reset();
  }
  reset() {
    this.markers.forEach((t) => ms.setMap(t, null)), this.clusters.forEach((t) => t.delete()), this.clusters = [];
  }
  renderClusters() {
    var t = new FGe(this.markers, this.clusters), n = this.getMap();
    this.clusters.forEach((r) => {
      r.markers.length === 1 ? r.marker = r.markers[0] : (r.marker = this.renderer.render(r, t, n), r.markers.forEach((o) => ms.setMap(o, null)), this.onClusterClick && r.marker.addListener(
        "click",
        /* istanbul ignore next */
        (o) => {
          google.maps.event.trigger(this, Rf.CLUSTER_CLICK, r), this.onClusterClick(o, r, n);
        }
      )), ms.setMap(r.marker, n);
    });
  }
}
function W4(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function $4(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? W4(Object(n), !0).forEach(function(r) {
      Te(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : W4(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function $Ge(e) {
  var t = Hqe(), [n, r] = k(null);
  return h(() => {
    if (t && n === null) {
      var o = new WGe($4($4({}, e), {}, {
        map: t
      }));
      r(o);
    }
  }, [t]), n;
}
function VGe(e) {
  var {
    children: t,
    options: n
  } = e, r = $Ge(n);
  return r !== null ? t(r) : null;
}
me(VGe);
var V4 = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, Z4 = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
function ZGe(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, g = ge(Ut), [f, m] = k(null), [b, E] = k(null), [w, M] = k(null), [x, v] = k(null), [C, P] = k(null), [F, L] = k(null), B = dt(null);
  return h(() => {
    f !== null && (f.close(), n ? f.open(g, n) : f.getPosition() && f.open(g));
  }, [g, f, n]), h(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), h(() => {
    o && f !== null && f.setPosition(o);
  }, [o]), h(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), h(() => {
    f && a && (b !== null && google.maps.event.removeListener(b), E(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), h(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), M(google.maps.event.addListener(f, "domready", s)));
  }, [s]), h(() => {
    f && l && (x !== null && google.maps.event.removeListener(x), v(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), h(() => {
    f && u && (C !== null && google.maps.event.removeListener(C), P(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), h(() => {
    f && c && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), h(() => {
    var N = new google.maps.InfoWindow(r);
    return m(N), B.current = document.createElement("div"), a && E(google.maps.event.addListener(N, "closeclick", a)), s && M(google.maps.event.addListener(N, "domready", s)), l && v(google.maps.event.addListener(N, "content_changed", l)), u && P(google.maps.event.addListener(N, "position_changed", u)), c && L(google.maps.event.addListener(N, "zindex_changed", c)), N.setContent(B.current), o && N.setPosition(o), i && N.setZIndex(i), n ? N.open(g, n) : N.getPosition() ? N.open(g) : qo(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>."), p && p(N), () => {
      b && google.maps.event.removeListener(b), x && google.maps.event.removeListener(x), w && google.maps.event.removeListener(w), C && google.maps.event.removeListener(C), F && google.maps.event.removeListener(F), d && d(N), N.close();
    };
  }, []), B.current ? zn(at.only(t), B.current) : null;
}
me(ZGe);
class qGe extends pe {
  constructor() {
    super(...arguments), Te(this, "registeredEvents", []), Te(this, "containerElement", null), Te(this, "state", {
      infoWindow: null
    }), Te(this, "open", (t, n) => {
      n ? t.open(this.context, n) : t.getPosition() ? t.open(this.context) : qo(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>.");
    }), Te(this, "setInfoWindowCallback", () => {
      this.state.infoWindow !== null && this.containerElement !== null && (this.state.infoWindow.setContent(this.containerElement), this.open(this.state.infoWindow, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoWindow));
    });
  }
  componentDidMount() {
    var t = new google.maps.InfoWindow(this.props.options);
    this.containerElement = document.createElement("div"), this.registeredEvents = xn({
      updaterMap: Z4,
      eventMap: V4,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(() => ({
      infoWindow: t
    }), this.setInfoWindowCallback);
  }
  componentDidUpdate(t) {
    this.state.infoWindow !== null && (Mn(this.registeredEvents), this.registeredEvents = xn({
      updaterMap: Z4,
      eventMap: V4,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.infoWindow
    }));
  }
  componentWillUnmount() {
    this.state.infoWindow !== null && (Mn(this.registeredEvents), this.props.onUnmount && this.props.onUnmount(this.state.infoWindow), this.state.infoWindow.close());
  }
  render() {
    return this.containerElement ? zn(at.only(this.props.children), this.containerElement) : null;
  }
}
Te(qGe, "contextType", Ut);
function q4(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Vw(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? q4(Object(n), !0).forEach(function(r) {
      Te(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : q4(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var G4 = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, K4 = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, GGe = {};
function KGe(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: g,
    onRightClick: f,
    onClick: m,
    onDrag: b,
    onLoad: E,
    onUnmount: w
  } = e, M = ge(Ut), [x, v] = k(null), [C, P] = k(null), [F, L] = k(null), [B, N] = k(null), [$, V] = k(null), [H, Z] = k(null), [K, Y] = k(null), [Q, J] = k(null), [_, D] = k(null), [z, S] = k(null), [W, O] = k(null), [j, U] = k(null);
  return h(() => {
    x !== null && x.setMap(M);
  }, [M]), h(() => {
    typeof t < "u" && x !== null && x.setOptions(t);
  }, [x, t]), h(() => {
    typeof n < "u" && x !== null && x.setDraggable(n);
  }, [x, n]), h(() => {
    typeof r < "u" && x !== null && x.setEditable(r);
  }, [x, r]), h(() => {
    typeof o < "u" && x !== null && x.setVisible(o);
  }, [x, o]), h(() => {
    typeof i < "u" && x !== null && x.setPath(i);
  }, [x, i]), h(() => {
    x && a && (C !== null && google.maps.event.removeListener(C), P(google.maps.event.addListener(x, "dblclick", a)));
  }, [a]), h(() => {
    x && s && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(x, "dragend", s)));
  }, [s]), h(() => {
    x && l && (B !== null && google.maps.event.removeListener(B), N(google.maps.event.addListener(x, "dragstart", l)));
  }, [l]), h(() => {
    x && u && ($ !== null && google.maps.event.removeListener($), V(google.maps.event.addListener(x, "mousedown", u)));
  }, [u]), h(() => {
    x && c && (H !== null && google.maps.event.removeListener(H), Z(google.maps.event.addListener(x, "mousemove", c)));
  }, [c]), h(() => {
    x && p && (K !== null && google.maps.event.removeListener(K), Y(google.maps.event.addListener(x, "mouseout", p)));
  }, [p]), h(() => {
    x && d && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(x, "mouseover", d)));
  }, [d]), h(() => {
    x && g && (_ !== null && google.maps.event.removeListener(_), D(google.maps.event.addListener(x, "mouseup", g)));
  }, [g]), h(() => {
    x && f && (z !== null && google.maps.event.removeListener(z), S(google.maps.event.addListener(x, "rightclick", f)));
  }, [f]), h(() => {
    x && m && (W !== null && google.maps.event.removeListener(W), O(google.maps.event.addListener(x, "click", m)));
  }, [m]), h(() => {
    x && b && (j !== null && google.maps.event.removeListener(j), U(google.maps.event.addListener(x, "drag", b)));
  }, [b]), h(() => {
    var T = new google.maps.Polyline(Vw(Vw({}, t || GGe), {}, {
      map: M
    }));
    return i && T.setPath(i), typeof o < "u" && T.setVisible(o), typeof r < "u" && T.setEditable(r), typeof n < "u" && T.setDraggable(n), a && P(google.maps.event.addListener(T, "dblclick", a)), s && L(google.maps.event.addListener(T, "dragend", s)), l && N(google.maps.event.addListener(T, "dragstart", l)), u && V(google.maps.event.addListener(T, "mousedown", u)), c && Z(google.maps.event.addListener(T, "mousemove", c)), p && Y(google.maps.event.addListener(T, "mouseout", p)), d && J(google.maps.event.addListener(T, "mouseover", d)), g && D(google.maps.event.addListener(T, "mouseup", g)), f && S(google.maps.event.addListener(T, "rightclick", f)), m && O(google.maps.event.addListener(T, "click", m)), b && U(google.maps.event.addListener(T, "drag", b)), v(T), E && E(T), () => {
      C !== null && google.maps.event.removeListener(C), F !== null && google.maps.event.removeListener(F), B !== null && google.maps.event.removeListener(B), $ !== null && google.maps.event.removeListener($), H !== null && google.maps.event.removeListener(H), K !== null && google.maps.event.removeListener(K), Q !== null && google.maps.event.removeListener(Q), _ !== null && google.maps.event.removeListener(_), z !== null && google.maps.event.removeListener(z), W !== null && google.maps.event.removeListener(W), w && w(T), T.setMap(null);
    };
  }, []), null;
}
me(KGe);
class XGe extends pe {
  constructor() {
    super(...arguments), Te(this, "registeredEvents", []), Te(this, "state", {
      polyline: null
    }), Te(this, "setPolylineCallback", () => {
      this.state.polyline !== null && this.props.onLoad && this.props.onLoad(this.state.polyline);
    });
  }
  componentDidMount() {
    var t = new google.maps.Polyline(Vw(Vw({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = xn({
      updaterMap: K4,
      eventMap: G4,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        polyline: t
      };
    }, this.setPolylineCallback);
  }
  componentDidUpdate(t) {
    this.state.polyline !== null && (Mn(this.registeredEvents), this.registeredEvents = xn({
      updaterMap: K4,
      eventMap: G4,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.polyline
    }));
  }
  componentWillUnmount() {
    this.state.polyline !== null && (this.props.onUnmount && this.props.onUnmount(this.state.polyline), Mn(this.registeredEvents), this.state.polyline.setMap(null));
  }
  render() {
    return null;
  }
}
Te(XGe, "contextType", Ut);
function X4(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Y4(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? X4(Object(n), !0).forEach(function(r) {
      Te(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : X4(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var J4 = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, Q4 = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  paths(e, t) {
    e.setPaths(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function YGe(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    paths: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: g,
    onMouseUp: f,
    onRightClick: m,
    onClick: b,
    onDrag: E,
    onLoad: w,
    onUnmount: M,
    onEdit: x
  } = e, v = ge(Ut), [C, P] = k(null), [F, L] = k(null), [B, N] = k(null), [$, V] = k(null), [H, Z] = k(null), [K, Y] = k(null), [Q, J] = k(null), [_, D] = k(null), [z, S] = k(null), [W, O] = k(null), [j, U] = k(null), [T, q] = k(null);
  return h(() => {
    C !== null && C.setMap(v);
  }, [v]), h(() => {
    typeof t < "u" && C !== null && C.setOptions(t);
  }, [C, t]), h(() => {
    typeof n < "u" && C !== null && C.setDraggable(n);
  }, [C, n]), h(() => {
    typeof r < "u" && C !== null && C.setEditable(r);
  }, [C, r]), h(() => {
    typeof o < "u" && C !== null && C.setVisible(o);
  }, [C, o]), h(() => {
    typeof i < "u" && C !== null && C.setPath(i);
  }, [C, i]), h(() => {
    typeof a < "u" && C !== null && C.setPaths(a);
  }, [C, a]), h(() => {
    C && typeof s == "function" && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(C, "dblclick", s)));
  }, [s]), h(() => {
    C && (google.maps.event.addListener(C.getPath(), "insert_at", () => {
      x == null || x(C);
    }), google.maps.event.addListener(C.getPath(), "set_at", () => {
      x == null || x(C);
    }), google.maps.event.addListener(C.getPath(), "remove_at", () => {
      x == null || x(C);
    }));
  }, [C, x]), h(() => {
    C && typeof l == "function" && (B !== null && google.maps.event.removeListener(B), N(google.maps.event.addListener(C, "dragend", l)));
  }, [l]), h(() => {
    C && typeof u == "function" && ($ !== null && google.maps.event.removeListener($), V(google.maps.event.addListener(C, "dragstart", u)));
  }, [u]), h(() => {
    C && typeof c == "function" && (H !== null && google.maps.event.removeListener(H), Z(google.maps.event.addListener(C, "mousedown", c)));
  }, [c]), h(() => {
    C && typeof p == "function" && (K !== null && google.maps.event.removeListener(K), Y(google.maps.event.addListener(C, "mousemove", p)));
  }, [p]), h(() => {
    C && typeof d == "function" && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(C, "mouseout", d)));
  }, [d]), h(() => {
    C && typeof g == "function" && (_ !== null && google.maps.event.removeListener(_), D(google.maps.event.addListener(C, "mouseover", g)));
  }, [g]), h(() => {
    C && typeof f == "function" && (z !== null && google.maps.event.removeListener(z), S(google.maps.event.addListener(C, "mouseup", f)));
  }, [f]), h(() => {
    C && typeof m == "function" && (W !== null && google.maps.event.removeListener(W), O(google.maps.event.addListener(C, "rightclick", m)));
  }, [m]), h(() => {
    C && typeof b == "function" && (j !== null && google.maps.event.removeListener(j), U(google.maps.event.addListener(C, "click", b)));
  }, [b]), h(() => {
    C && typeof E == "function" && (T !== null && google.maps.event.removeListener(T), q(google.maps.event.addListener(C, "drag", E)));
  }, [E]), h(() => {
    var A = new google.maps.Polygon(Y4(Y4({}, t), {}, {
      map: v
    }));
    return i && A.setPath(i), a && A.setPaths(a), typeof o < "u" && A.setVisible(o), typeof r < "u" && A.setEditable(r), typeof n < "u" && A.setDraggable(n), s && L(google.maps.event.addListener(A, "dblclick", s)), l && N(google.maps.event.addListener(A, "dragend", l)), u && V(google.maps.event.addListener(A, "dragstart", u)), c && Z(google.maps.event.addListener(A, "mousedown", c)), p && Y(google.maps.event.addListener(A, "mousemove", p)), d && J(google.maps.event.addListener(A, "mouseout", d)), g && D(google.maps.event.addListener(A, "mouseover", g)), f && S(google.maps.event.addListener(A, "mouseup", f)), m && O(google.maps.event.addListener(A, "rightclick", m)), b && U(google.maps.event.addListener(A, "click", b)), E && q(google.maps.event.addListener(A, "drag", E)), P(A), w && w(A), () => {
      F !== null && google.maps.event.removeListener(F), B !== null && google.maps.event.removeListener(B), $ !== null && google.maps.event.removeListener($), H !== null && google.maps.event.removeListener(H), K !== null && google.maps.event.removeListener(K), Q !== null && google.maps.event.removeListener(Q), _ !== null && google.maps.event.removeListener(_), z !== null && google.maps.event.removeListener(z), W !== null && google.maps.event.removeListener(W), j !== null && google.maps.event.removeListener(j), M && M(A), A.setMap(null);
    };
  }, []), null;
}
me(YGe);
class JGe extends pe {
  constructor() {
    super(...arguments), Te(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this.props.options || {};
    this.polygon = new google.maps.Polygon(t), this.polygon.setMap(this.context), this.registeredEvents = xn({
      updaterMap: Q4,
      eventMap: J4,
      prevProps: {},
      nextProps: this.props,
      instance: this.polygon
    }), this.props.onLoad && this.props.onLoad(this.polygon);
  }
  componentDidUpdate(t) {
    this.polygon && (Mn(this.registeredEvents), this.registeredEvents = xn({
      updaterMap: Q4,
      eventMap: J4,
      prevProps: t,
      nextProps: this.props,
      instance: this.polygon
    }));
  }
  componentWillUnmount() {
    this.polygon && (this.props.onUnmount && this.props.onUnmount(this.polygon), Mn(this.registeredEvents), this.polygon && this.polygon.setMap(null));
  }
  render() {
    return null;
  }
}
Te(JGe, "contextType", Ut);
function eZ(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Zw(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? eZ(Object(n), !0).forEach(function(r) {
      Te(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : eZ(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var tZ = {
  onBoundsChanged: "bounds_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, nZ = {
  bounds(e, t) {
    e.setBounds(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function QGe(e) {
  var {
    options: t,
    bounds: n,
    draggable: r,
    editable: o,
    visible: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: g,
    onRightClick: f,
    onClick: m,
    onDrag: b,
    onBoundsChanged: E,
    onLoad: w,
    onUnmount: M
  } = e, x = ge(Ut), [v, C] = k(null), [P, F] = k(null), [L, B] = k(null), [N, $] = k(null), [V, H] = k(null), [Z, K] = k(null), [Y, Q] = k(null), [J, _] = k(null), [D, z] = k(null), [S, W] = k(null), [O, j] = k(null), [U, T] = k(null), [q, A] = k(null);
  return h(() => {
    v !== null && v.setMap(x);
  }, [x]), h(() => {
    typeof t < "u" && v !== null && v.setOptions(t);
  }, [v, t]), h(() => {
    typeof r < "u" && v !== null && v.setDraggable(r);
  }, [v, r]), h(() => {
    typeof o < "u" && v !== null && v.setEditable(o);
  }, [v, o]), h(() => {
    typeof i < "u" && v !== null && v.setVisible(i);
  }, [v, i]), h(() => {
    typeof n < "u" && v !== null && v.setBounds(n);
  }, [v, n]), h(() => {
    v && a && (P !== null && google.maps.event.removeListener(P), F(google.maps.event.addListener(v, "dblclick", a)));
  }, [a]), h(() => {
    v && s && (L !== null && google.maps.event.removeListener(L), B(google.maps.event.addListener(v, "dragend", s)));
  }, [s]), h(() => {
    v && l && (N !== null && google.maps.event.removeListener(N), $(google.maps.event.addListener(v, "dragstart", l)));
  }, [l]), h(() => {
    v && u && (V !== null && google.maps.event.removeListener(V), H(google.maps.event.addListener(v, "mousedown", u)));
  }, [u]), h(() => {
    v && c && (Z !== null && google.maps.event.removeListener(Z), K(google.maps.event.addListener(v, "mousemove", c)));
  }, [c]), h(() => {
    v && p && (Y !== null && google.maps.event.removeListener(Y), Q(google.maps.event.addListener(v, "mouseout", p)));
  }, [p]), h(() => {
    v && d && (J !== null && google.maps.event.removeListener(J), _(google.maps.event.addListener(v, "mouseover", d)));
  }, [d]), h(() => {
    v && g && (D !== null && google.maps.event.removeListener(D), z(google.maps.event.addListener(v, "mouseup", g)));
  }, [g]), h(() => {
    v && f && (S !== null && google.maps.event.removeListener(S), W(google.maps.event.addListener(v, "rightclick", f)));
  }, [f]), h(() => {
    v && m && (O !== null && google.maps.event.removeListener(O), j(google.maps.event.addListener(v, "click", m)));
  }, [m]), h(() => {
    v && b && (U !== null && google.maps.event.removeListener(U), T(google.maps.event.addListener(v, "drag", b)));
  }, [b]), h(() => {
    v && E && (q !== null && google.maps.event.removeListener(q), A(google.maps.event.addListener(v, "bounds_changed", E)));
  }, [E]), h(() => {
    var X = new google.maps.Rectangle(Zw(Zw({}, t), {}, {
      map: x
    }));
    return typeof i < "u" && X.setVisible(i), typeof o < "u" && X.setEditable(o), typeof r < "u" && X.setDraggable(r), typeof n < "u" && X.setBounds(n), a && F(google.maps.event.addListener(X, "dblclick", a)), s && B(google.maps.event.addListener(X, "dragend", s)), l && $(google.maps.event.addListener(X, "dragstart", l)), u && H(google.maps.event.addListener(X, "mousedown", u)), c && K(google.maps.event.addListener(X, "mousemove", c)), p && Q(google.maps.event.addListener(X, "mouseout", p)), d && _(google.maps.event.addListener(X, "mouseover", d)), g && z(google.maps.event.addListener(X, "mouseup", g)), f && W(google.maps.event.addListener(X, "rightclick", f)), m && j(google.maps.event.addListener(X, "click", m)), b && T(google.maps.event.addListener(X, "drag", b)), E && A(google.maps.event.addListener(X, "bounds_changed", E)), C(X), w && w(X), () => {
      P !== null && google.maps.event.removeListener(P), L !== null && google.maps.event.removeListener(L), N !== null && google.maps.event.removeListener(N), V !== null && google.maps.event.removeListener(V), Z !== null && google.maps.event.removeListener(Z), Y !== null && google.maps.event.removeListener(Y), J !== null && google.maps.event.removeListener(J), D !== null && google.maps.event.removeListener(D), S !== null && google.maps.event.removeListener(S), O !== null && google.maps.event.removeListener(O), U !== null && google.maps.event.removeListener(U), q !== null && google.maps.event.removeListener(q), M && M(X), X.setMap(null);
    };
  }, []), null;
}
me(QGe);
class eKe extends pe {
  constructor() {
    super(...arguments), Te(this, "registeredEvents", []), Te(this, "state", {
      rectangle: null
    }), Te(this, "setRectangleCallback", () => {
      this.state.rectangle !== null && this.props.onLoad && this.props.onLoad(this.state.rectangle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Rectangle(Zw(Zw({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = xn({
      updaterMap: nZ,
      eventMap: tZ,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        rectangle: t
      };
    }, this.setRectangleCallback);
  }
  componentDidUpdate(t) {
    this.state.rectangle !== null && (Mn(this.registeredEvents), this.registeredEvents = xn({
      updaterMap: nZ,
      eventMap: tZ,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.rectangle
    }));
  }
  componentWillUnmount() {
    this.state.rectangle !== null && (this.props.onUnmount && this.props.onUnmount(this.state.rectangle), Mn(this.registeredEvents), this.state.rectangle.setMap(null));
  }
  render() {
    return null;
  }
}
Te(eKe, "contextType", Ut);
function rZ(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function qw(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? rZ(Object(n), !0).forEach(function(r) {
      Te(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : rZ(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var oZ = {
  onCenterChanged: "center_changed",
  onRadiusChanged: "radius_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, iZ = {
  center(e, t) {
    e.setCenter(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  radius(e, t) {
    e.setRadius(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, tKe = {};
function nKe(e) {
  var {
    options: t,
    center: n,
    radius: r,
    draggable: o,
    editable: i,
    visible: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: g,
    onMouseUp: f,
    onRightClick: m,
    onClick: b,
    onDrag: E,
    onCenterChanged: w,
    onRadiusChanged: M,
    onLoad: x,
    onUnmount: v
  } = e, C = ge(Ut), [P, F] = k(null), [L, B] = k(null), [N, $] = k(null), [V, H] = k(null), [Z, K] = k(null), [Y, Q] = k(null), [J, _] = k(null), [D, z] = k(null), [S, W] = k(null), [O, j] = k(null), [U, T] = k(null), [q, A] = k(null), [X, I] = k(null), [le, he] = k(null);
  return h(() => {
    P !== null && P.setMap(C);
  }, [C]), h(() => {
    typeof t < "u" && P !== null && P.setOptions(t);
  }, [P, t]), h(() => {
    typeof o < "u" && P !== null && P.setDraggable(o);
  }, [P, o]), h(() => {
    typeof i < "u" && P !== null && P.setEditable(i);
  }, [P, i]), h(() => {
    typeof a < "u" && P !== null && P.setVisible(a);
  }, [P, a]), h(() => {
    typeof r == "number" && P !== null && P.setRadius(r);
  }, [P, r]), h(() => {
    typeof n < "u" && P !== null && P.setCenter(n);
  }, [P, n]), h(() => {
    P && s && (L !== null && google.maps.event.removeListener(L), B(google.maps.event.addListener(P, "dblclick", s)));
  }, [s]), h(() => {
    P && l && (N !== null && google.maps.event.removeListener(N), $(google.maps.event.addListener(P, "dragend", l)));
  }, [l]), h(() => {
    P && u && (V !== null && google.maps.event.removeListener(V), H(google.maps.event.addListener(P, "dragstart", u)));
  }, [u]), h(() => {
    P && c && (Z !== null && google.maps.event.removeListener(Z), K(google.maps.event.addListener(P, "mousedown", c)));
  }, [c]), h(() => {
    P && p && (Y !== null && google.maps.event.removeListener(Y), Q(google.maps.event.addListener(P, "mousemove", p)));
  }, [p]), h(() => {
    P && d && (J !== null && google.maps.event.removeListener(J), _(google.maps.event.addListener(P, "mouseout", d)));
  }, [d]), h(() => {
    P && g && (D !== null && google.maps.event.removeListener(D), z(google.maps.event.addListener(P, "mouseover", g)));
  }, [g]), h(() => {
    P && f && (S !== null && google.maps.event.removeListener(S), W(google.maps.event.addListener(P, "mouseup", f)));
  }, [f]), h(() => {
    P && m && (O !== null && google.maps.event.removeListener(O), j(google.maps.event.addListener(P, "rightclick", m)));
  }, [m]), h(() => {
    P && b && (U !== null && google.maps.event.removeListener(U), T(google.maps.event.addListener(P, "click", b)));
  }, [b]), h(() => {
    P && E && (q !== null && google.maps.event.removeListener(q), A(google.maps.event.addListener(P, "drag", E)));
  }, [E]), h(() => {
    P && w && (X !== null && google.maps.event.removeListener(X), I(google.maps.event.addListener(P, "center_changed", w)));
  }, [b]), h(() => {
    P && M && (le !== null && google.maps.event.removeListener(le), he(google.maps.event.addListener(P, "radius_changed", M)));
  }, [M]), h(() => {
    var oe = new google.maps.Circle(qw(qw({}, t || tKe), {}, {
      map: C
    }));
    return typeof r == "number" && oe.setRadius(r), typeof n < "u" && oe.setCenter(n), typeof r == "number" && oe.setRadius(r), typeof a < "u" && oe.setVisible(a), typeof i < "u" && oe.setEditable(i), typeof o < "u" && oe.setDraggable(o), s && B(google.maps.event.addListener(oe, "dblclick", s)), l && $(google.maps.event.addListener(oe, "dragend", l)), u && H(google.maps.event.addListener(oe, "dragstart", u)), c && K(google.maps.event.addListener(oe, "mousedown", c)), p && Q(google.maps.event.addListener(oe, "mousemove", p)), d && _(google.maps.event.addListener(oe, "mouseout", d)), g && z(google.maps.event.addListener(oe, "mouseover", g)), f && W(google.maps.event.addListener(oe, "mouseup", f)), m && j(google.maps.event.addListener(oe, "rightclick", m)), b && T(google.maps.event.addListener(oe, "click", b)), E && A(google.maps.event.addListener(oe, "drag", E)), w && I(google.maps.event.addListener(oe, "center_changed", w)), M && he(google.maps.event.addListener(oe, "radius_changed", M)), F(oe), x && x(oe), () => {
      L !== null && google.maps.event.removeListener(L), N !== null && google.maps.event.removeListener(N), V !== null && google.maps.event.removeListener(V), Z !== null && google.maps.event.removeListener(Z), Y !== null && google.maps.event.removeListener(Y), J !== null && google.maps.event.removeListener(J), D !== null && google.maps.event.removeListener(D), S !== null && google.maps.event.removeListener(S), O !== null && google.maps.event.removeListener(O), U !== null && google.maps.event.removeListener(U), X !== null && google.maps.event.removeListener(X), le !== null && google.maps.event.removeListener(le), v && v(oe), oe.setMap(null);
    };
  }, []), null;
}
me(nKe);
class rKe extends pe {
  constructor() {
    super(...arguments), Te(this, "registeredEvents", []), Te(this, "state", {
      circle: null
    }), Te(this, "setCircleCallback", () => {
      this.state.circle !== null && this.props.onLoad && this.props.onLoad(this.state.circle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Circle(qw(qw({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = xn({
      updaterMap: iZ,
      eventMap: oZ,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        circle: t
      };
    }, this.setCircleCallback);
  }
  componentDidUpdate(t) {
    this.state.circle !== null && (Mn(this.registeredEvents), this.registeredEvents = xn({
      updaterMap: iZ,
      eventMap: oZ,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.circle
    }));
  }
  componentWillUnmount() {
    if (this.state.circle !== null) {
      var t;
      this.props.onUnmount && this.props.onUnmount(this.state.circle), Mn(this.registeredEvents), (t = this.state.circle) === null || t === void 0 || t.setMap(null);
    }
  }
  render() {
    return null;
  }
}
Te(rKe, "contextType", Ut);
function sZ(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Gw(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? sZ(Object(n), !0).forEach(function(r) {
      Te(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : sZ(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var aZ = {
  onClick: "click",
  onDblClick: "dblclick",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onAddFeature: "addfeature",
  onRemoveFeature: "removefeature",
  onRemoveProperty: "removeproperty",
  onSetGeometry: "setgeometry",
  onSetProperty: "setproperty"
}, lZ = {
  add(e, t) {
    e.add(t);
  },
  addgeojson(e, t, n) {
    e.addGeoJson(t, n);
  },
  contains(e, t) {
    e.contains(t);
  },
  foreach(e, t) {
    e.forEach(t);
  },
  loadgeojson(e, t, n, r) {
    e.loadGeoJson(t, n, r);
  },
  overridestyle(e, t, n) {
    e.overrideStyle(t, n);
  },
  remove(e, t) {
    e.remove(t);
  },
  revertstyle(e, t) {
    e.revertStyle(t);
  },
  controlposition(e, t) {
    e.setControlPosition(t);
  },
  controls(e, t) {
    e.setControls(t);
  },
  drawingmode(e, t) {
    e.setDrawingMode(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  style(e, t) {
    e.setStyle(t);
  },
  togeojson(e, t) {
    e.toGeoJson(t);
  }
};
function oKe(e) {
  var {
    options: t,
    onClick: n,
    onDblClick: r,
    onMouseDown: o,
    onMouseMove: i,
    onMouseOut: a,
    onMouseOver: s,
    onMouseUp: l,
    onRightClick: u,
    onAddFeature: c,
    onRemoveFeature: p,
    onRemoveProperty: d,
    onSetGeometry: g,
    onSetProperty: f,
    onLoad: m,
    onUnmount: b
  } = e, E = ge(Ut), [w, M] = k(null), [x, v] = k(null), [C, P] = k(null), [F, L] = k(null), [B, N] = k(null), [$, V] = k(null), [H, Z] = k(null), [K, Y] = k(null), [Q, J] = k(null), [_, D] = k(null), [z, S] = k(null), [W, O] = k(null), [j, U] = k(null), [T, q] = k(null);
  return h(() => {
    w !== null && w.setMap(E);
  }, [E]), h(() => {
    w && r && (x !== null && google.maps.event.removeListener(x), v(google.maps.event.addListener(w, "dblclick", r)));
  }, [r]), h(() => {
    w && o && (C !== null && google.maps.event.removeListener(C), P(google.maps.event.addListener(w, "mousedown", o)));
  }, [o]), h(() => {
    w && i && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(w, "mousemove", i)));
  }, [i]), h(() => {
    w && a && (B !== null && google.maps.event.removeListener(B), N(google.maps.event.addListener(w, "mouseout", a)));
  }, [a]), h(() => {
    w && s && ($ !== null && google.maps.event.removeListener($), V(google.maps.event.addListener(w, "mouseover", s)));
  }, [s]), h(() => {
    w && l && (H !== null && google.maps.event.removeListener(H), Z(google.maps.event.addListener(w, "mouseup", l)));
  }, [l]), h(() => {
    w && u && (K !== null && google.maps.event.removeListener(K), Y(google.maps.event.addListener(w, "rightclick", u)));
  }, [u]), h(() => {
    w && n && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(w, "click", n)));
  }, [n]), h(() => {
    w && c && (_ !== null && google.maps.event.removeListener(_), D(google.maps.event.addListener(w, "addfeature", c)));
  }, [c]), h(() => {
    w && p && (z !== null && google.maps.event.removeListener(z), S(google.maps.event.addListener(w, "removefeature", p)));
  }, [p]), h(() => {
    w && d && (W !== null && google.maps.event.removeListener(W), O(google.maps.event.addListener(w, "removeproperty", d)));
  }, [d]), h(() => {
    w && g && (j !== null && google.maps.event.removeListener(j), U(google.maps.event.addListener(w, "setgeometry", g)));
  }, [g]), h(() => {
    w && f && (T !== null && google.maps.event.removeListener(T), q(google.maps.event.addListener(w, "setproperty", f)));
  }, [f]), h(() => {
    if (E !== null) {
      var A = new google.maps.Data(Gw(Gw({}, t), {}, {
        map: E
      }));
      r && v(google.maps.event.addListener(A, "dblclick", r)), o && P(google.maps.event.addListener(A, "mousedown", o)), i && L(google.maps.event.addListener(A, "mousemove", i)), a && N(google.maps.event.addListener(A, "mouseout", a)), s && V(google.maps.event.addListener(A, "mouseover", s)), l && Z(google.maps.event.addListener(A, "mouseup", l)), u && Y(google.maps.event.addListener(A, "rightclick", u)), n && J(google.maps.event.addListener(A, "click", n)), c && D(google.maps.event.addListener(A, "addfeature", c)), p && S(google.maps.event.addListener(A, "removefeature", p)), d && O(google.maps.event.addListener(A, "removeproperty", d)), g && U(google.maps.event.addListener(A, "setgeometry", g)), f && q(google.maps.event.addListener(A, "setproperty", f)), M(A), m && m(A);
    }
    return () => {
      w && (x !== null && google.maps.event.removeListener(x), C !== null && google.maps.event.removeListener(C), F !== null && google.maps.event.removeListener(F), B !== null && google.maps.event.removeListener(B), $ !== null && google.maps.event.removeListener($), H !== null && google.maps.event.removeListener(H), K !== null && google.maps.event.removeListener(K), Q !== null && google.maps.event.removeListener(Q), _ !== null && google.maps.event.removeListener(_), z !== null && google.maps.event.removeListener(z), W !== null && google.maps.event.removeListener(W), j !== null && google.maps.event.removeListener(j), T !== null && google.maps.event.removeListener(T), b && b(w), w.setMap(null));
    };
  }, []), null;
}
me(oKe);
class iKe extends pe {
  constructor() {
    super(...arguments), Te(this, "registeredEvents", []), Te(this, "state", {
      data: null
    }), Te(this, "setDataCallback", () => {
      this.state.data !== null && this.props.onLoad && this.props.onLoad(this.state.data);
    });
  }
  componentDidMount() {
    if (this.context !== null) {
      var t = new google.maps.Data(Gw(Gw({}, this.props.options), {}, {
        map: this.context
      }));
      this.registeredEvents = xn({
        updaterMap: lZ,
        eventMap: aZ,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        data: t
      }), this.setDataCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.data !== null && (Mn(this.registeredEvents), this.registeredEvents = xn({
      updaterMap: lZ,
      eventMap: aZ,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.data
    }));
  }
  componentWillUnmount() {
    this.state.data !== null && (this.props.onUnmount && this.props.onUnmount(this.state.data), Mn(this.registeredEvents), this.state.data && this.state.data.setMap(null));
  }
  render() {
    return null;
  }
}
Te(iKe, "contextType", Ut);
function uZ(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function cZ(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? uZ(Object(n), !0).forEach(function(r) {
      Te(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : uZ(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var pZ = {
  onClick: "click",
  onDefaultViewportChanged: "defaultviewport_changed",
  onStatusChanged: "status_changed"
}, dZ = {
  options(e, t) {
    e.setOptions(t);
  },
  url(e, t) {
    e.setUrl(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
class sKe extends pe {
  constructor() {
    super(...arguments), Te(this, "registeredEvents", []), Te(this, "state", {
      kmlLayer: null
    }), Te(this, "setKmlLayerCallback", () => {
      this.state.kmlLayer !== null && this.props.onLoad && this.props.onLoad(this.state.kmlLayer);
    });
  }
  componentDidMount() {
    var t = new google.maps.KmlLayer(cZ(cZ({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = xn({
      updaterMap: dZ,
      eventMap: pZ,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        kmlLayer: t
      };
    }, this.setKmlLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.kmlLayer !== null && (Mn(this.registeredEvents), this.registeredEvents = xn({
      updaterMap: dZ,
      eventMap: pZ,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.kmlLayer
    }));
  }
  componentWillUnmount() {
    this.state.kmlLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.kmlLayer), Mn(this.registeredEvents), this.state.kmlLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Te(sKe, "contextType", Ut);
function qoe(e, t) {
  return typeof t == "function" ? t(e.offsetWidth, e.offsetHeight) : {
    x: 0,
    y: 0
  };
}
function aKe(e, t) {
  return new t(e.lat, e.lng);
}
function lKe(e, t) {
  return new t(new google.maps.LatLng(e.ne.lat, e.ne.lng), new google.maps.LatLng(e.sw.lat, e.sw.lng));
}
function uKe(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function cKe(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function pKe(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n.getNorthEast()), o = e && e.fromLatLngToDivPixel(n.getSouthWest());
  return r && o ? {
    left: "".concat(o.x + t.x, "px"),
    top: "".concat(r.y + t.y, "px"),
    width: "".concat(r.x - o.x - t.x, "px"),
    height: "".concat(o.y - r.y - t.y, "px")
  } : {
    left: "-9999px",
    top: "-9999px"
  };
}
function dKe(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n);
  if (r) {
    var {
      x: o,
      y: i
    } = r;
    return {
      left: "".concat(o + t.x, "px"),
      top: "".concat(i + t.y, "px")
    };
  }
  return {
    left: "-9999px",
    top: "-9999px"
  };
}
function Goe(e, t, n, r) {
  return n !== void 0 ? pKe(e, t, cKe(n, google.maps.LatLngBounds, lKe)) : dKe(e, t, uKe(r, google.maps.LatLng, aKe));
}
function fKe(e, t) {
  return e.left === t.left && e.top === t.top && e.width === t.height && e.height === t.height;
}
function fZ(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function hKe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? fZ(Object(n), !0).forEach(function(r) {
      Te(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : fZ(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function gKe(e, t, n, r, o) {
  class i extends google.maps.OverlayView {
    constructor(s, l, u, c) {
      super(), this.container = s, this.pane = l, this.position = u, this.bounds = c;
    }
    onAdd() {
      var s, l = (s = this.getPanes()) === null || s === void 0 ? void 0 : s[this.pane];
      l == null || l.appendChild(this.container);
    }
    draw() {
      var s = this.getProjection(), l = hKe({}, this.container ? qoe(this.container, o) : {
        x: 0,
        y: 0
      }), u = Goe(s, l, this.bounds, this.position);
      for (var [c, p] of Object.entries(u))
        this.container.style[c] = p;
    }
    onRemove() {
      this.container.parentNode !== null && this.container.parentNode.removeChild(this.container);
    }
  }
  return new i(e, t, n, r);
}
function hZ(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function mKe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? hZ(Object(n), !0).forEach(function(r) {
      Te(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : hZ(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function gZ(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLng ? e : new google.maps.LatLng(e.lat, e.lng);
  return t + "";
}
function mZ(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLngBounds ? e : new google.maps.LatLngBounds(new google.maps.LatLng(e.south, e.east), new google.maps.LatLng(e.north, e.west));
  return t + "";
}
function vKe(e) {
  var {
    position: t,
    bounds: n,
    mapPaneName: r,
    zIndex: o,
    onLoad: i,
    onUnmount: a,
    getPixelPositionOffset: s,
    children: l
  } = e, u = ge(Ut), c = ln(() => {
    var d = document.createElement("div");
    return d.style.position = "absolute", d;
  }, []), p = ln(() => gKe(c, r, t, n, s), [c, r, t, n]);
  return h(() => (i == null || i(p), p == null || p.setMap(u), () => {
    a == null || a(p), p == null || p.setMap(null);
  }), [u, p]), h(() => {
    c.style.zIndex = "".concat(o);
  }, [o, c]), wi.createPortal(l, c);
}
me(vKe);
class Yp extends pe {
  constructor(t) {
    super(t), Te(this, "state", {
      paneEl: null,
      containerStyle: {
        // set initial position
        position: "absolute"
      }
    }), Te(this, "updatePane", () => {
      var r = this.props.mapPaneName, o = this.overlayView.getPanes();
      qo(!!r, "OverlayView requires props.mapPaneName but got %s", r), o ? this.setState({
        paneEl: o[r]
      }) : this.setState({
        paneEl: null
      });
    }), Te(this, "onAdd", () => {
      var r, o;
      this.updatePane(), (r = (o = this.props).onLoad) === null || r === void 0 || r.call(o, this.overlayView);
    }), Te(this, "onPositionElement", () => {
      var r = this.overlayView.getProjection(), o = mKe({
        x: 0,
        y: 0
      }, this.containerRef.current ? qoe(this.containerRef.current, this.props.getPixelPositionOffset) : {}), i = Goe(r, o, this.props.bounds, this.props.position);
      if (!fKe(i, {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        left: this.state.containerStyle.left,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        top: this.state.containerStyle.top,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        width: this.state.containerStyle.width,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        height: this.state.containerStyle.height
      })) {
        var a, s, l, u;
        this.setState({
          containerStyle: {
            top: (a = i.top) !== null && a !== void 0 ? a : 0,
            left: (s = i.left) !== null && s !== void 0 ? s : 0,
            width: (l = i.width) !== null && l !== void 0 ? l : 0,
            height: (u = i.height) !== null && u !== void 0 ? u : 0,
            position: "absolute"
          }
        });
      }
    }), Te(this, "draw", () => {
      this.onPositionElement();
    }), Te(this, "onRemove", () => {
      var r, o;
      this.setState(() => ({
        paneEl: null
      })), (r = (o = this.props).onUnmount) === null || r === void 0 || r.call(o, this.overlayView);
    }), this.containerRef = so();
    var n = new google.maps.OverlayView();
    n.onAdd = this.onAdd, n.draw = this.draw, n.onRemove = this.onRemove, this.overlayView = n;
  }
  componentDidMount() {
    this.overlayView.setMap(this.context);
  }
  componentDidUpdate(t) {
    var n = gZ(t.position), r = gZ(this.props.position), o = mZ(t.bounds), i = mZ(this.props.bounds);
    (n !== r || o !== i) && this.overlayView.draw(), t.mapPaneName !== this.props.mapPaneName && this.updatePane();
  }
  componentWillUnmount() {
    this.overlayView.setMap(null);
  }
  render() {
    var t = this.state.paneEl;
    return t ? wi.createPortal(Fn.jsx("div", {
      ref: this.containerRef,
      style: this.state.containerStyle,
      children: at.only(this.props.children)
    }), t) : null;
  }
}
Te(Yp, "FLOAT_PANE", "floatPane");
Te(Yp, "MAP_PANE", "mapPane");
Te(Yp, "MARKER_LAYER", "markerLayer");
Te(Yp, "OVERLAY_LAYER", "overlayLayer");
Te(Yp, "OVERLAY_MOUSE_TARGET", "overlayMouseTarget");
Te(Yp, "contextType", Ut);
function yKe() {
}
function vZ(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function yZ(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? vZ(Object(n), !0).forEach(function(r) {
      Te(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : vZ(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var bZ = {
  onDblClick: "dblclick",
  onClick: "click"
}, wZ = {
  opacity(e, t) {
    e.setOpacity(t);
  }
};
function bKe(e) {
  var {
    url: t,
    bounds: n,
    options: r,
    visible: o
  } = e, i = ge(Ut), a = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east)), s = ln(() => new google.maps.GroundOverlay(t, a, r), []);
  return h(() => {
    s !== null && s.setMap(i);
  }, [i]), h(() => {
    typeof t < "u" && s !== null && (s.set("url", t), s.setMap(i));
  }, [s, t]), h(() => {
    typeof o < "u" && s !== null && s.setOpacity(o ? 1 : 0);
  }, [s, o]), h(() => {
    var l = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east));
    typeof n < "u" && s !== null && (s.set("bounds", l), s.setMap(i));
  }, [s, n]), null;
}
me(bKe);
class Koe extends pe {
  constructor() {
    super(...arguments), Te(this, "registeredEvents", []), Te(this, "state", {
      groundOverlay: null
    }), Te(this, "setGroundOverlayCallback", () => {
      this.state.groundOverlay !== null && this.props.onLoad && this.props.onLoad(this.state.groundOverlay);
    });
  }
  componentDidMount() {
    qo(!!this.props.url || !!this.props.bounds, "For GroundOverlay, url and bounds are passed in to constructor and are immutable after instantiated. This is the behavior of Google Maps JavaScript API v3 ( See https://developers.google.com/maps/documentation/javascript/reference#GroundOverlay) Hence, use the corresponding two props provided by `react-google-maps-api`, url and bounds. In some cases, you'll need the GroundOverlay component to reflect the changes of url and bounds. You can leverage the React's key property to remount the component. Typically, just `key={url}` would serve your need. See https://github.com/tomchentw/react-google-maps/issues/655");
    var t = new google.maps.GroundOverlay(this.props.url, this.props.bounds, yZ(yZ({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = xn({
      updaterMap: wZ,
      eventMap: bZ,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        groundOverlay: t
      };
    }, this.setGroundOverlayCallback);
  }
  componentDidUpdate(t) {
    this.state.groundOverlay !== null && (Mn(this.registeredEvents), this.registeredEvents = xn({
      updaterMap: wZ,
      eventMap: bZ,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.groundOverlay
    }));
  }
  componentWillUnmount() {
    this.state.groundOverlay && (this.props.onUnmount && this.props.onUnmount(this.state.groundOverlay), this.state.groundOverlay.setMap(null));
  }
  render() {
    return null;
  }
}
Te(Koe, "defaultProps", {
  onLoad: yKe
});
Te(Koe, "contextType", Ut);
function CZ(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Kw(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? CZ(Object(n), !0).forEach(function(r) {
      Te(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : CZ(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var OZ = {}, xZ = {
  data(e, t) {
    e.setData(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function wKe(e) {
  var {
    data: t,
    onLoad: n,
    onUnmount: r,
    options: o
  } = e, i = ge(Ut), [a, s] = k(null);
  return h(() => {
    google.maps.visualization || qo(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} in useJsApiScript? %s', google.maps.visualization);
  }, []), h(() => {
    qo(!!t, "data property is required in HeatmapLayer %s", t);
  }, [t]), h(() => {
    a !== null && a.setMap(i);
  }, [i]), h(() => {
    o && a !== null && a.setOptions(o);
  }, [a, o]), h(() => {
    var l = new google.maps.visualization.HeatmapLayer(Kw(Kw({}, o), {}, {
      data: t,
      map: i
    }));
    return s(l), n && n(l), () => {
      a !== null && (r && r(a), a.setMap(null));
    };
  }, []), null;
}
me(wKe);
class CKe extends pe {
  constructor() {
    super(...arguments), Te(this, "registeredEvents", []), Te(this, "state", {
      heatmapLayer: null
    }), Te(this, "setHeatmapLayerCallback", () => {
      this.state.heatmapLayer !== null && this.props.onLoad && this.props.onLoad(this.state.heatmapLayer);
    });
  }
  componentDidMount() {
    qo(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} to <LoadScript />? %s', google.maps.visualization), qo(!!this.props.data, "data property is required in HeatmapLayer %s", this.props.data);
    var t = new google.maps.visualization.HeatmapLayer(Kw(Kw({}, this.props.options), {}, {
      data: this.props.data,
      map: this.context
    }));
    this.registeredEvents = xn({
      updaterMap: xZ,
      eventMap: OZ,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        heatmapLayer: t
      };
    }, this.setHeatmapLayerCallback);
  }
  componentDidUpdate(t) {
    Mn(this.registeredEvents), this.registeredEvents = xn({
      updaterMap: xZ,
      eventMap: OZ,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.heatmapLayer
    });
  }
  componentWillUnmount() {
    this.state.heatmapLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.heatmapLayer), Mn(this.registeredEvents), this.state.heatmapLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Te(CKe, "contextType", Ut);
var EZ = {
  onCloseClick: "closeclick",
  onPanoChanged: "pano_changed",
  onPositionChanged: "position_changed",
  onPovChanged: "pov_changed",
  onResize: "resize",
  onStatusChanged: "status_changed",
  onVisibleChanged: "visible_changed",
  onZoomChanged: "zoom_changed"
}, kZ = {
  register(e, t, n) {
    e.registerPanoProvider(t, n);
  },
  links(e, t) {
    e.setLinks(t);
  },
  motionTracking(e, t) {
    e.setMotionTracking(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  pano(e, t) {
    e.setPano(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  pov(e, t) {
    e.setPov(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zoom(e, t) {
    e.setZoom(t);
  }
};
class OKe extends pe {
  constructor() {
    super(...arguments), Te(this, "registeredEvents", []), Te(this, "state", {
      streetViewPanorama: null
    }), Te(this, "setStreetViewPanoramaCallback", () => {
      this.state.streetViewPanorama !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewPanorama);
    });
  }
  componentDidMount() {
    var t, n, r = (t = (n = this.context) === null || n === void 0 ? void 0 : n.getStreetView()) !== null && t !== void 0 ? t : null;
    this.registeredEvents = xn({
      updaterMap: kZ,
      eventMap: EZ,
      prevProps: {},
      nextProps: this.props,
      instance: r
    }), this.setState(() => ({
      streetViewPanorama: r
    }), this.setStreetViewPanoramaCallback);
  }
  componentDidUpdate(t) {
    this.state.streetViewPanorama !== null && (Mn(this.registeredEvents), this.registeredEvents = xn({
      updaterMap: kZ,
      eventMap: EZ,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.streetViewPanorama
    }));
  }
  componentWillUnmount() {
    this.state.streetViewPanorama !== null && (this.props.onUnmount && this.props.onUnmount(this.state.streetViewPanorama), Mn(this.registeredEvents), this.state.streetViewPanorama.setVisible(!1));
  }
  render() {
    return null;
  }
}
Te(OKe, "contextType", Ut);
class xKe extends pe {
  constructor() {
    super(...arguments), Te(this, "state", {
      streetViewService: null
    }), Te(this, "setStreetViewServiceCallback", () => {
      this.state.streetViewService !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewService);
    });
  }
  componentDidMount() {
    var t = new google.maps.StreetViewService();
    this.setState(function() {
      return {
        streetViewService: t
      };
    }, this.setStreetViewServiceCallback);
  }
  componentWillUnmount() {
    this.state.streetViewService !== null && this.props.onUnmount && this.props.onUnmount(this.state.streetViewService);
  }
  render() {
    return null;
  }
}
Te(xKe, "contextType", Ut);
var LZ = {
  onDirectionsChanged: "directions_changed"
}, _Z = {
  directions(e, t) {
    e.setDirections(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  panel(e, t) {
    e.setPanel(t);
  },
  routeIndex(e, t) {
    e.setRouteIndex(t);
  }
};
class EKe extends pe {
  constructor() {
    super(...arguments), Te(this, "registeredEvents", []), Te(this, "state", {
      directionsRenderer: null
    }), Te(this, "setDirectionsRendererCallback", () => {
      this.state.directionsRenderer !== null && (this.state.directionsRenderer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.directionsRenderer));
    });
  }
  componentDidMount() {
    var t = new google.maps.DirectionsRenderer(this.props.options);
    this.registeredEvents = xn({
      updaterMap: _Z,
      eventMap: LZ,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        directionsRenderer: t
      };
    }, this.setDirectionsRendererCallback);
  }
  componentDidUpdate(t) {
    this.state.directionsRenderer !== null && (Mn(this.registeredEvents), this.registeredEvents = xn({
      updaterMap: _Z,
      eventMap: LZ,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.directionsRenderer
    }));
  }
  componentWillUnmount() {
    this.state.directionsRenderer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.directionsRenderer), Mn(this.registeredEvents), this.state.directionsRenderer && this.state.directionsRenderer.setMap(null));
  }
  render() {
    return null;
  }
}
Te(EKe, "contextType", Ut);
var PZ = {
  onPlacesChanged: "places_changed"
}, SZ = {
  bounds(e, t) {
    e.setBounds(t);
  }
};
class kKe extends pe {
  constructor() {
    super(...arguments), Te(this, "registeredEvents", []), Te(this, "containerElement", so()), Te(this, "state", {
      searchBox: null
    }), Te(this, "setSearchBoxCallback", () => {
      this.state.searchBox !== null && this.props.onLoad && this.props.onLoad(this.state.searchBox);
    });
  }
  componentDidMount() {
    if (qo(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places), this.containerElement !== null && this.containerElement.current !== null) {
      var t = this.containerElement.current.querySelector("input");
      if (t !== null) {
        var n = new google.maps.places.SearchBox(t, this.props.options);
        this.registeredEvents = xn({
          updaterMap: SZ,
          eventMap: PZ,
          prevProps: {},
          nextProps: this.props,
          instance: n
        }), this.setState(function() {
          return {
            searchBox: n
          };
        }, this.setSearchBoxCallback);
      }
    }
  }
  componentDidUpdate(t) {
    this.state.searchBox !== null && (Mn(this.registeredEvents), this.registeredEvents = xn({
      updaterMap: SZ,
      eventMap: PZ,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.searchBox
    }));
  }
  componentWillUnmount() {
    this.state.searchBox !== null && (this.props.onUnmount && this.props.onUnmount(this.state.searchBox), Mn(this.registeredEvents));
  }
  render() {
    return Fn.jsx("div", {
      ref: this.containerElement,
      children: at.only(this.props.children)
    });
  }
}
Te(kKe, "contextType", Ut);
var MZ = {
  onPlaceChanged: "place_changed"
}, DZ = {
  bounds(e, t) {
    e.setBounds(t);
  },
  restrictions(e, t) {
    e.setComponentRestrictions(t);
  },
  fields(e, t) {
    e.setFields(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  types(e, t) {
    e.setTypes(t);
  }
};
class Xoe extends pe {
  constructor() {
    super(...arguments), Te(this, "registeredEvents", []), Te(this, "containerElement", so()), Te(this, "state", {
      autocomplete: null
    }), Te(this, "setAutocompleteCallback", () => {
      this.state.autocomplete !== null && this.props.onLoad && this.props.onLoad(this.state.autocomplete);
    });
  }
  componentDidMount() {
    var t;
    qo(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places);
    var n = (t = this.containerElement.current) === null || t === void 0 ? void 0 : t.querySelector("input");
    if (n) {
      var r = new google.maps.places.Autocomplete(n, this.props.options);
      this.registeredEvents = xn({
        updaterMap: DZ,
        eventMap: MZ,
        prevProps: {},
        nextProps: this.props,
        instance: r
      }), this.setState(() => ({
        autocomplete: r
      }), this.setAutocompleteCallback);
    }
  }
  componentDidUpdate(t) {
    Mn(this.registeredEvents), this.registeredEvents = xn({
      updaterMap: DZ,
      eventMap: MZ,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.autocomplete
    });
  }
  componentWillUnmount() {
    this.state.autocomplete !== null && Mn(this.registeredEvents);
  }
  render() {
    return Fn.jsx("div", {
      ref: this.containerElement,
      className: this.props.className,
      children: at.only(this.props.children)
    });
  }
}
Te(Xoe, "defaultProps", {
  className: ""
});
Te(Xoe, "contextType", Ut);
let LKe = { data: "" }, _Ke = (e) => typeof window == "object" ? ((e ? e.querySelector("#_goober") : window._goober) || Object.assign((e || document.head).appendChild(document.createElement("style")), { innerHTML: " ", id: "_goober" })).firstChild : e || LKe, PKe = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g, SKe = /\/\*[^]*?\*\/|  +/g, TZ = /\n+/g, tu = (e, t) => {
  let n = "", r = "", o = "";
  for (let i in e) {
    let a = e[i];
    i[0] == "@" ? i[1] == "i" ? n = i + " " + a + ";" : r += i[1] == "f" ? tu(a, i) : i + "{" + tu(a, i[1] == "k" ? "" : t) + "}" : typeof a == "object" ? r += tu(a, t ? t.replace(/([^,])+/g, (s) => i.replace(/([^,]*:\S+\([^)]*\))|([^,])+/g, (l) => /&/.test(l) ? l.replace(/&/g, s) : s ? s + " " + l : l)) : i) : a != null && (i = /^--/.test(i) ? i : i.replace(/[A-Z]/g, "-$&").toLowerCase(), o += tu.p ? tu.p(i, a) : i + ":" + a + ";");
  }
  return n + (t && o ? t + "{" + o + "}" : o) + r;
}, Fa = {}, Yoe = (e) => {
  if (typeof e == "object") {
    let t = "";
    for (let n in e) t += n + Yoe(e[n]);
    return t;
  }
  return e;
}, MKe = (e, t, n, r, o) => {
  let i = Yoe(e), a = Fa[i] || (Fa[i] = ((l) => {
    let u = 0, c = 11;
    for (; u < l.length; ) c = 101 * c + l.charCodeAt(u++) >>> 0;
    return "go" + c;
  })(i));
  if (!Fa[a]) {
    let l = i !== e ? e : ((u) => {
      let c, p, d = [{}];
      for (; c = PKe.exec(u.replace(SKe, "")); ) c[4] ? d.shift() : c[3] ? (p = c[3].replace(TZ, " ").trim(), d.unshift(d[0][p] = d[0][p] || {})) : d[0][c[1]] = c[2].replace(TZ, " ").trim();
      return d[0];
    })(e);
    Fa[a] = tu(o ? { ["@keyframes " + a]: l } : l, n ? "" : "." + a);
  }
  let s = n && Fa.g ? Fa.g : null;
  return n && (Fa.g = Fa[a]), ((l, u, c, p) => {
    p ? u.data = u.data.replace(p, l) : u.data.indexOf(l) === -1 && (u.data = c ? l + u.data : u.data + l);
  })(Fa[a], t, r, s), a;
}, DKe = (e, t, n) => e.reduce((r, o, i) => {
  let a = t[i];
  if (a && a.call) {
    let s = a(n), l = s && s.props && s.props.className || /^go/.test(s) && s;
    a = l ? "." + l : s && typeof s == "object" ? s.props ? "" : tu(s, "") : s === !1 ? "" : s;
  }
  return r + o + (a ?? "");
}, "");
function JO(e) {
  let t = this || {}, n = e.call ? e(t.p) : e;
  return MKe(n.unshift ? n.raw ? DKe(n, [].slice.call(arguments, 1), t.p) : n.reduce((r, o) => Object.assign(r, o && o.call ? o(t.p) : o), {}) : n, _Ke(t.target), t.g, t.o, t.k);
}
let Joe, _P, PP;
JO.bind({ g: 1 });
let nl = JO.bind({ k: 1 });
function TKe(e, t, n, r) {
  tu.p = t, Joe = e, _P = n, PP = r;
}
function Mu(e, t) {
  let n = this || {};
  return function() {
    let r = arguments;
    function o(i, a) {
      let s = Object.assign({}, i), l = s.className || o.className;
      n.p = Object.assign({ theme: _P && _P() }, s), n.o = / *go\d+/.test(l), s.className = JO.apply(n, r) + (l ? " " + l : "");
      let u = e;
      return e[0] && (u = s.as || e, delete s.as), PP && u[0] && PP(s), Joe(u, s);
    }
    return o;
  };
}
var jKe = (e) => typeof e == "function", AKe = (e, t) => jKe(e) ? e(t) : e, RKe = /* @__PURE__ */ (() => {
  let e;
  return () => {
    if (e === void 0 && typeof window < "u") {
      let t = matchMedia("(prefers-reduced-motion: reduce)");
      e = !t || t.matches;
    }
    return e;
  };
})(), IKe = nl`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`, NKe = nl`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`, BKe = nl`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`, FKe = Mu("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${IKe} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${NKe} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${(e) => e.secondary || "#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${BKe} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`, zKe = nl`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, UKe = Mu("div")`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${(e) => e.secondary || "#e0e0e0"};
  border-right-color: ${(e) => e.primary || "#616161"};
  animation: ${zKe} 1s linear infinite;
`, HKe = nl`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`, WKe = nl`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`, $Ke = Mu("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${HKe} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${WKe} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${(e) => e.secondary || "#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`, VKe = Mu("div")`
  position: absolute;
`, ZKe = Mu("div")`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`, qKe = nl`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`, GKe = Mu("div")`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${qKe} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`, KKe = ({ toast: e }) => {
  let { icon: t, type: n, iconTheme: r } = e;
  return t !== void 0 ? typeof t == "string" ? Ne.createElement(GKe, null, t) : t : n === "blank" ? null : Ne.createElement(ZKe, null, Ne.createElement(UKe, { ...r }), n !== "loading" && Ne.createElement(VKe, null, n === "error" ? Ne.createElement(FKe, { ...r }) : Ne.createElement($Ke, { ...r })));
}, XKe = (e) => `
0% {transform: translate3d(0,${e * -200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`, YKe = (e) => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${e * -150}%,-1px) scale(.6); opacity:0;}
`, JKe = "0%{opacity:0;} 100%{opacity:1;}", QKe = "0%{opacity:1;} 100%{opacity:0;}", eXe = Mu("div")`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`, tXe = Mu("div")`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`, nXe = (e, t) => {
  let n = e.includes("top") ? 1 : -1, [r, o] = RKe() ? [JKe, QKe] : [XKe(n), YKe(n)];
  return { animation: t ? `${nl(r)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards` : `${nl(o)} 0.4s forwards cubic-bezier(.06,.71,.55,1)` };
};
Ne.memo(({ toast: e, position: t, style: n, children: r }) => {
  let o = e.height ? nXe(e.position || t || "top-center", e.visible) : { opacity: 0 }, i = Ne.createElement(KKe, { toast: e }), a = Ne.createElement(tXe, { ...e.ariaProps }, AKe(e.message, e));
  return Ne.createElement(eXe, { className: e.className, style: { ...o, ...n, ...e.style } }, typeof r == "function" ? r({ icon: i, message: a }) : Ne.createElement(Ne.Fragment, null, i, a));
});
TKe(Ne.createElement);
JO`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`;
function rXe(e) {
  const { error: t } = e, n = "arkynAudioUploadError";
  return t ? /* @__PURE__ */ ee.jsx("strong", { className: n, children: t }) : /* @__PURE__ */ ee.jsx(ee.Fragment, {});
}
function oXe(e) {
  const { label: t, showAsterisk: n } = e, o = `arkynAudioUploadLabel ${n ? "asteriskTrue" : "asteriskFalse"}`;
  return /* @__PURE__ */ ee.jsx("strong", { className: o.trim(), children: t });
}
function iXe(e) {
  const { onChange: t, value: n, disableDrag: r = !1, onDragging: o } = e, [i, a] = k(!1), s = dt(null), l = () => {
    a(!0);
  }, u = () => {
    a(!1);
  }, c = (f) => {
    if (r || !i || !s.current) return;
    const m = s.current.getBoundingClientRect(), b = f.clientX - m.left, E = Math.min(Math.max(b / m.width * 100, 0), 100);
    t(E);
  }, p = (f) => {
    if (!s.current) return;
    const m = s.current.getBoundingClientRect(), b = f.clientX - m.left, E = Math.min(Math.max(b / m.width * 100, 0), 100);
    t(E);
  };
  h(() => (i ? (o && o(!0), document.addEventListener("mousemove", c), document.addEventListener("mouseup", u)) : (o && o(!1), document.removeEventListener("mousemove", c), document.removeEventListener("mouseup", u)), () => {
    document.removeEventListener("mousemove", c), document.removeEventListener("mouseup", u);
  }), [i]);
  const g = `arkynSliderTrack ${i ? "isDragging" : "isNotDragging"}`;
  return /* @__PURE__ */ ee.jsxs(
    "div",
    {
      className: g,
      ref: s,
      onMouseDown: l,
      onClick: p,
      children: [
        /* @__PURE__ */ ee.jsx("div", { className: "arkynSliderFill", style: { width: `${n}%` } }),
        /* @__PURE__ */ ee.jsx("div", { className: "arkynSliderThumb", style: { left: `${n}%` } })
      ]
    }
  );
}
function sXe(e) {
  var P, F, L, B;
  const {
    filePath: t,
    disabled: n,
    acceptAudio: r,
    handleSelectFile: o,
    isLoading: i,
    reSendAudio: a,
    changeAudioButtonText: s
  } = e, [l, u] = k(0), c = dt(null), [p, d] = k(!1), [g, f] = k(!1);
  h(() => {
    const N = c.current;
    if (!N) return;
    const $ = () => {
      const V = N.duration, Z = N.currentTime / V * 100;
      u(Z);
    };
    return N.addEventListener("timeupdate", $), () => {
      N.removeEventListener("timeupdate", $);
    };
  }, []);
  function m(N) {
    const $ = c.current;
    if (!$) return;
    const V = $.duration, H = N / 100 * V;
    $.currentTime = H;
  }
  function b() {
    var N;
    (N = c.current) == null || N.play(), f(!0);
  }
  function E() {
    var N;
    (N = c.current) == null || N.pause(), f(!1);
  }
  function w() {
    g ? E() : b();
  }
  const M = (P = c.current) == null ? void 0 : P.currentTime, x = (F = c.current) == null ? void 0 : F.duration;
  function v(N) {
    if (!N) return "00:00";
    const $ = Math.floor(N / 60), V = Math.floor(N % 60), H = String($).padStart(2, "0"), Z = String(V).padStart(2, "0");
    return `${H}:${Z}`;
  }
  p || !g ? (L = c.current) == null || L.pause() : g && ((B = c.current) == null || B.play());
  function C() {
    if (n) return;
    const N = document.createElement("input");
    N.type = "file", N.accept = r, N.onchange = ($) => {
      var H;
      const V = (H = $.target.files) == null ? void 0 : H[0];
      V && o(V);
    }, N.click();
  }
  return /* @__PURE__ */ ee.jsxs("div", { className: "arkynAudioUploadHasFileContentContainer", children: [
    /* @__PURE__ */ ee.jsx("audio", { ref: c, src: t, onEnded: E }),
    /* @__PURE__ */ ee.jsxs("div", { className: "arkynAudioUploadAudioPlayer", children: [
      /* @__PURE__ */ ee.jsxs("button", { type: "button", onClick: w, children: [
        g && /* @__PURE__ */ ee.jsx(Jse, {}),
        !g && /* @__PURE__ */ ee.jsx(Qse, {})
      ] }),
      /* @__PURE__ */ ee.jsx("p", { children: v(M) }),
      /* @__PURE__ */ ee.jsx(
        iXe,
        {
          value: l,
          onChange: m,
          onDragging: d
        }
      ),
      /* @__PURE__ */ ee.jsx("p", { children: v(x) })
    ] }),
    /* @__PURE__ */ ee.jsx(Hde, {}),
    /* @__PURE__ */ ee.jsxs("div", { className: "arkynAudioUploadButtonsContainer", children: [
      !!a && /* @__PURE__ */ ee.jsx(F4e, { orientation: "bottom", text: "Reenviar áudio", children: /* @__PURE__ */ ee.jsx(
        B4e,
        {
          type: "button",
          "aria-label": "resend image",
          variant: "outline",
          scheme: "danger",
          size: "sm",
          isLoading: i,
          onClick: a,
          icon: qP,
          disabled: n
        }
      ) }),
      /* @__PURE__ */ ee.jsx(
        XT,
        {
          isLoading: i,
          onClick: C,
          variant: "outline",
          size: "sm",
          type: "button",
          disabled: n,
          children: s
        }
      )
    ] })
  ] });
}
function aXe(e) {
  const {
    dropAudioText: t,
    isLoading: n,
    acceptAudio: r,
    handleSelectFile: o,
    selectAudioButtonText: i,
    disabled: a
  } = e;
  function s(u) {
    if (a) return;
    u.preventDefault();
    const c = u.dataTransfer.files[0];
    c && o(c);
  }
  function l() {
    if (a) return;
    const u = document.createElement("input");
    u.type = "file", u.accept = r, u.onchange = (c) => {
      var d;
      const p = (d = c.target.files) == null ? void 0 : d[0];
      p && o(p);
    }, u.click();
  }
  return /* @__PURE__ */ ee.jsxs("div", { onDrop: s, className: "arkynAudioUploadNoFileContent", children: [
    /* @__PURE__ */ ee.jsx(
      XT,
      {
        isLoading: n,
        onClick: l,
        variant: "ghost",
        size: "sm",
        type: "button",
        disabled: a,
        children: i
      }
    ),
    /* @__PURE__ */ ee.jsx("p", { children: t })
  ] });
}
function jit(e) {
  const {
    name: t,
    label: n,
    fileName: r = "file",
    method: o = "POST",
    onUpload: i,
    fileResponseName: a = "url",
    selectAudioButtonText: s = "Selecionar arquivo de áudio",
    dropAudioText: l = "Ou arraste e solte um arquivo de áudio aqui",
    changeAudioButtonText: u = "Trocar arquivo de áudio",
    acceptAudio: c = "audio/*",
    action: p,
    defaultValue: d = "",
    showAsterisk: g = !1,
    disabled: f = !1
  } = e, b = N4e()[t], [E, w] = k(d), [M, x] = k(""), [v, C] = k(null), [P, F] = k(d), [L, B] = k(!1);
  async function N(Y) {
    if (f) return;
    B(!0), C(Y), x("");
    const Q = new FormData();
    Q.append(r, Y), await fetch(p, { method: o, body: Q }).then(async (J) => await J.json()).then((J) => {
      J != null && J.error ? x(J.error) : w(J == null ? void 0 : J[a]), i && i(J == null ? void 0 : J[a]);
    }).catch((J) => {
      console.error(J), x("Erro ao enviar audio");
    }).finally(() => B(!1));
  }
  function $(Y) {
    if (!f) {
      if (console.log(Y.type), Y.type.indexOf("audio") === -1) {
        x("O arquivo selecionado não é um arquivo de áudio");
        return;
      }
      F(URL.createObjectURL(Y)), N(Y);
    }
  }
  const V = b || M, K = `arkynAudioUpload ${V ? "hasError" : "noHasError"} ${P ? "hasAudio" : "noHasAudio"}`;
  return /* @__PURE__ */ ee.jsxs("div", { className: "arkynAudioUploadContainer", children: [
    n && /* @__PURE__ */ ee.jsx(oXe, { label: n, showAsterisk: g }),
    /* @__PURE__ */ ee.jsxs("div", { className: K, children: [
      /* @__PURE__ */ ee.jsx("input", { type: "hidden", name: t, value: E || "" }),
      !P && /* @__PURE__ */ ee.jsx(
        aXe,
        {
          disabled: f,
          isLoading: L,
          acceptAudio: c,
          dropAudioText: l,
          handleSelectFile: $,
          selectAudioButtonText: s
        }
      ),
      P && /* @__PURE__ */ ee.jsx(
        sXe,
        {
          filePath: P,
          acceptAudio: c,
          changeAudioButtonText: u,
          disabled: f,
          handleSelectFile: $,
          isLoading: L,
          reSendAudio: V && v ? () => N(v) : void 0
        }
      )
    ] }),
    V && /* @__PURE__ */ ee.jsx(rXe, { error: V })
  ] });
}
function Uh(e) {
  const {
    isLoading: t = !1,
    scheme: n = "primary",
    variant: r = "solid",
    loadingText: o,
    size: i = "md",
    leftIcon: a,
    rightIcon: s,
    disabled: l,
    className: u = "",
    children: c,
    ...p
  } = e, g = { xs: 12, sm: 16, md: 20, lg: 24 }[i], b = `arkynButton ${t ? "loadingTrue" : "loadingFalse"} ${r} ${n} ${i} ${o ? "loadingTextTrue" : "loadingTextFalse"} ${u}`;
  return /* @__PURE__ */ ee.jsxs("button", { className: b, disabled: l || t, ...p, children: [
    /* @__PURE__ */ ee.jsxs("div", { className: "arkynButtonSpinner", children: [
      /* @__PURE__ */ ee.jsx(ma, { size: g, strokeWidth: 2.5 }),
      o && o
    ] }),
    /* @__PURE__ */ ee.jsxs("div", { className: "arkynButtonContent", children: [
      Fy(g, a),
      c,
      Fy(g, s)
    ] })
  ] });
}
function dj() {
  const e = XP(), t = xG(), n = YP(), [r, o] = k(null);
  function i(u, c) {
    return JSON.stringify(u) === JSON.stringify(c);
  }
  function a() {
    r && o(null);
  }
  h(() => {
    var c, p;
    let u = ((p = (c = n[0]) == null ? void 0 : c.data) == null ? void 0 : p.fieldErrors) || {};
    i(r, u) || Object.entries(u).length !== 0 && o(u);
  }, [n, e]), h(() => {
    var u;
    ((u = n[0]) == null ? void 0 : u.state) === "submitting" && a();
  }, [n, t]);
  const s = (e == null ? void 0 : e.fieldErrors) || r;
  let l = {};
  return Object.entries(s || {}).forEach(([u, c]) => {
    typeof c == "string" && typeof u == "string" && (l[u] = c);
  }), l;
}
const Qoe = $e({});
function jZ(e) {
  var p;
  const {
    children: t,
    className: n,
    id: r,
    ...o
  } = e, i = dj(), a = dt(null), s = ((p = a.current) == null ? void 0 : p.name) || "", l = (i == null ? void 0 : i[s]) || null, u = qse(), c = `arkynFormController ${n}`;
  return /* @__PURE__ */ ee.jsx(Qoe.Provider, { value: { error: l, id: u, inputRef: a }, children: /* @__PURE__ */ ee.jsx(
    "section",
    {
      id: r || s || void 0,
      className: c.trim(),
      ...o,
      children: t
    }
  ) });
}
function Fi() {
  return ge(Qoe);
}
function Ait(e) {
  const {
    name: t,
    className: n = "",
    size: r = "md",
    isError: o,
    defaultChecked: i = !1,
    checked: a = null,
    onCheck: s,
    value: l,
    ...u
  } = e, { id: c, inputRef: p, error: d } = Fi(), g = o || !!d, [f, m] = k(i || !1), b = typeof a == "boolean" ? a : f, M = `arkynCheckbox ${r} ${g ? "errorTrue" : "errorFalse"} ${b ? "checkedTrue" : "checkedFalse"} ${n}`;
  function x() {
    const v = f;
    m(!v), s && s(v ? "" : l || "checked");
  }
  return /* @__PURE__ */ ee.jsxs(
    "button",
    {
      id: c,
      type: "button",
      className: M,
      onClick: x,
      ...u,
      children: [
        /* @__PURE__ */ ee.jsx(
          "input",
          {
            type: "hidden",
            name: t,
            ref: p,
            value: b ? l || "checked" : ""
          }
        ),
        /* @__PURE__ */ ee.jsx(l0, {})
      ]
    }
  );
}
function lXe(e) {
  const { error: t } = e, n = "arkynFileUploadError";
  return t ? /* @__PURE__ */ ee.jsx("strong", { className: n, children: t }) : /* @__PURE__ */ ee.jsx(ee.Fragment, {});
}
function uXe(e) {
  const { label: t, showAsterisk: n } = e, o = `arkynFileUploadLabel ${n ? "asteriskTrue" : "asteriskFalse"}`;
  return /* @__PURE__ */ ee.jsx("strong", { className: o.trim(), children: t });
}
function eie(e) {
  const {
    isLoading: t = !1,
    scheme: n = "primary",
    variant: r = "solid",
    size: o = "md",
    icon: i,
    disabled: a,
    className: s = "",
    ...l
  } = e, u = { xs: 12, sm: 16, md: 20, lg: 24 }, p = `arkynIconButton ${r} ${n} ${o} ${t ? "loadingTrue" : "loadingFalse"} ${s}`;
  return /* @__PURE__ */ ee.jsxs(
    "button",
    {
      disabled: a || t,
      className: p.trim(),
      ...l,
      children: [
        /* @__PURE__ */ ee.jsx("div", { className: "arkynIconButtonSpinner", children: /* @__PURE__ */ ee.jsx(ma, { size: u[o], strokeWidth: 2.5 }) }),
        /* @__PURE__ */ ee.jsx("div", { className: "arkynIconButtonContent", children: /* @__PURE__ */ ee.jsx(i, { size: u[o], strokeWidth: 2.5 }) })
      ]
    }
  );
}
function tie(e) {
  const {
    text: t,
    size: n = "lg",
    children: r,
    orientation: o = "top",
    className: i = "",
    ...a
  } = e, s = `arkynTooltip ${n} ${o} ${i}`;
  return /* @__PURE__ */ ee.jsxs("div", { className: s.trim(), ...a, children: [
    r,
    /* @__PURE__ */ ee.jsx("div", { className: "arkynTooltipText", children: t })
  ] });
}
function cXe(e) {
  const {
    disabled: t,
    file: n,
    isLoading: r,
    acceptFile: o,
    changeFileButtonText: i,
    handleSelectFile: a,
    reSendFile: s
  } = e;
  function l() {
    if (t) return;
    const c = document.createElement("input");
    c.type = "file", c.accept = o, c.onchange = (p) => {
      var g;
      const d = (g = p.target.files) == null ? void 0 : g[0];
      d && a(d);
    }, c.click();
  }
  function u() {
    return n.type.startsWith("image/") ? /* @__PURE__ */ ee.jsx(eae, {}) : n.type.startsWith("audio/") ? /* @__PURE__ */ ee.jsx(tae, {}) : n.type.startsWith("application/zip") ? /* @__PURE__ */ ee.jsx(nae, {}) : /* @__PURE__ */ ee.jsx(rae, {});
  }
  return /* @__PURE__ */ ee.jsxs("div", { className: "arkynFileUploadHasFileContent", children: [
    /* @__PURE__ */ ee.jsxs("section", { className: "arkynFileUploadFileContainer", children: [
      /* @__PURE__ */ ee.jsx(u, {}),
      /* @__PURE__ */ ee.jsx("p", { children: n.name })
    ] }),
    /* @__PURE__ */ ee.jsx(sK, {}),
    /* @__PURE__ */ ee.jsxs("div", { className: "arkynFileUploadButtonsContainer", children: [
      !!s && /* @__PURE__ */ ee.jsx(tie, { orientation: "bottom", text: "Reenviar arquivo", children: /* @__PURE__ */ ee.jsx(
        eie,
        {
          type: "button",
          "aria-label": "resend file",
          variant: "outline",
          scheme: "danger",
          size: "sm",
          isLoading: r,
          onClick: s,
          icon: qP,
          disabled: t
        }
      ) }),
      /* @__PURE__ */ ee.jsx(
        Uh,
        {
          isLoading: r,
          onClick: l,
          variant: "outline",
          size: "sm",
          type: "button",
          disabled: t,
          children: i
        }
      )
    ] })
  ] });
}
function pXe(e) {
  const {
    dropFileText: t,
    isLoading: n,
    acceptFile: r,
    handleSelectFile: o,
    selectFileButtonText: i,
    disabled: a
  } = e;
  function s(u) {
    if (a) return;
    u.preventDefault();
    const c = u.dataTransfer.files[0];
    c && o(c);
  }
  function l() {
    if (a) return;
    const u = document.createElement("input");
    u.type = "file", u.accept = r, u.onchange = (c) => {
      var d;
      const p = (d = c.target.files) == null ? void 0 : d[0];
      p && o(p);
    }, u.click();
  }
  return /* @__PURE__ */ ee.jsxs("div", { onDrop: s, className: "arkynFileUploadNoFileContent", children: [
    /* @__PURE__ */ ee.jsx(
      XT,
      {
        isLoading: n,
        onClick: l,
        variant: "ghost",
        size: "sm",
        type: "button",
        disabled: a,
        children: i
      }
    ),
    /* @__PURE__ */ ee.jsx("p", { children: t })
  ] });
}
function Rit(e) {
  const {
    name: t,
    label: n,
    showAsterisk: r = !1,
    action: o,
    fileName: i = "file",
    method: a = "POST",
    acceptFile: s = "*",
    fileResponseName: l = "url",
    changeFileButtonText: u = "Alterar arquivo",
    selectFileButtonText: c = "Selecionar arquivo",
    dropFileText: p = "Ou arraste e solte o arquivo aqui",
    onUpload: d,
    disabled: g = !1
  } = e, m = dj()[t], [b, E] = k(""), [w, M] = k(""), [x, v] = k(null), [C, P] = k(!1);
  async function F(H) {
    if (g) return;
    P(!0), v(H), M("");
    const Z = new FormData();
    Z.append(i, H), await fetch(o, { method: a, body: Z }).then(async (K) => await K.json()).then((K) => {
      K != null && K.error ? M(K.error) : E(K == null ? void 0 : K[l]), d && d(K == null ? void 0 : K[l]);
    }).catch((K) => {
      console.error(K), M("Erro ao enviar o arquivo");
    }).finally(() => P(!1));
  }
  function L(H) {
    g || F(H);
  }
  const B = m || w, V = `arkynFileUpload ${B ? "hasError" : "noHasError"} ${x ? "hasFile" : "noHasFile"}`;
  return /* @__PURE__ */ ee.jsxs("div", { className: "arkynFileUploadContainer", children: [
    n && /* @__PURE__ */ ee.jsx(uXe, { label: n, showAsterisk: r }),
    /* @__PURE__ */ ee.jsxs("div", { className: V, children: [
      /* @__PURE__ */ ee.jsx("input", { type: "hidden", name: t, value: b || "" }),
      !x && /* @__PURE__ */ ee.jsx(
        pXe,
        {
          disabled: g,
          isLoading: C,
          acceptFile: s,
          dropFileText: p,
          handleSelectFile: L,
          selectFileButtonText: c
        }
      ),
      x && /* @__PURE__ */ ee.jsx(
        cXe,
        {
          disabled: g,
          isLoading: C,
          acceptFile: s,
          file: x,
          handleSelectFile: L,
          changeFileButtonText: u,
          reSendFile: B && x ? () => F(x) : void 0
        }
      )
    ] }),
    B && /* @__PURE__ */ ee.jsx(lXe, { error: B })
  ] });
}
function Iit(e) {
  const { children: t, className: n, ...r } = e, o = `arkynFormError ${n}`, { error: i } = Fi();
  return t ? /* @__PURE__ */ ee.jsx("strong", { className: o.trim(), ...r, children: t }) : i ? /* @__PURE__ */ ee.jsx("strong", { className: o.trim(), ...r, children: i }) : /* @__PURE__ */ ee.jsx(ee.Fragment, {});
}
function AZ(e) {
  const {
    showAsterisk: t = !1,
    className: n = "",
    ...r
  } = e, { id: o } = Fi(), a = `arkynFormLabel ${t ? "asteriskTrue" : "asteriskFalse"} ${n}`;
  return /* @__PURE__ */ ee.jsx("label", { className: a.trim(), htmlFor: o, ...r });
}
function dXe(e) {
  const {
    disabled: t,
    filePath: n,
    isLoading: r,
    acceptImage: o,
    changeImageButtonText: i,
    handleSelectFile: a,
    reSendImage: s
  } = e;
  function l() {
    if (t) return;
    const u = document.createElement("input");
    u.type = "file", u.accept = o, u.onchange = (c) => {
      var d;
      const p = (d = c.target.files) == null ? void 0 : d[0];
      p && a(p);
    }, u.click();
  }
  return /* @__PURE__ */ ee.jsxs(
    "div",
    {
      className: "arkynImageUploadHasFileContent",
      style: { backgroundImage: `url("${n}")` },
      children: [
        s && /* @__PURE__ */ ee.jsx(tie, { orientation: "bottom", text: "Reenviar imagem", children: /* @__PURE__ */ ee.jsx(
          eie,
          {
            type: "button",
            "aria-label": "resend image",
            variant: "outline",
            scheme: "danger",
            size: "sm",
            isLoading: r,
            onClick: s,
            icon: qP,
            disabled: t
          }
        ) }),
        /* @__PURE__ */ ee.jsx(
          Uh,
          {
            isLoading: r,
            onClick: l,
            variant: "outline",
            size: "sm",
            type: "button",
            disabled: t,
            children: i
          }
        )
      ]
    }
  );
}
function fXe(e) {
  const { error: t } = e, n = "arkynImageUploadError";
  return t ? /* @__PURE__ */ ee.jsx("strong", { className: n, children: t }) : /* @__PURE__ */ ee.jsx(ee.Fragment, {});
}
function hXe(e) {
  const { label: t, showAsterisk: n } = e, o = `arkynImageUploadLabel ${n ? "asteriskTrue" : "asteriskFalse"}`;
  return /* @__PURE__ */ ee.jsx("strong", { className: o.trim(), children: t });
}
function gXe(e) {
  const {
    dropImageText: t,
    isLoading: n,
    acceptImage: r,
    handleSelectFile: o,
    selectImageButtonText: i,
    disabled: a
  } = e;
  function s(u) {
    if (a) return;
    u.preventDefault();
    const c = u.dataTransfer.files[0];
    c && o(c);
  }
  function l() {
    if (a) return;
    const u = document.createElement("input");
    u.type = "file", u.accept = r, u.onchange = (c) => {
      var d;
      const p = (d = c.target.files) == null ? void 0 : d[0];
      p && o(p);
    }, u.click();
  }
  return /* @__PURE__ */ ee.jsxs("div", { onDrop: s, className: "arkynImageUploadNoFileContent", children: [
    /* @__PURE__ */ ee.jsx(
      Uh,
      {
        isLoading: n,
        onClick: l,
        variant: "ghost",
        size: "sm",
        type: "button",
        disabled: a,
        children: i
      }
    ),
    /* @__PURE__ */ ee.jsx("p", { children: t })
  ] });
}
function mXe(e) {
  const {
    name: t,
    defaultValue: n = "",
    label: r,
    showAsterisk: o = !1,
    action: i,
    fileName: a = "file",
    method: s = "POST",
    acceptImage: l = "image/*",
    fileResponseName: u = "url",
    changeImageButtonText: c = "Alterar imagem",
    selectImageButtonText: p = "Selecionar imagem",
    dropImageText: d = "Ou arraste e solte a imagem aqui",
    onUpload: g,
    disabled: f = !1
  } = e, b = dj()[t], [E, w] = k(n), [M, x] = k(""), [v, C] = k(null), [P, F] = k(n), [L, B] = k(!1);
  async function N(Y) {
    if (f) return;
    B(!0), C(Y), x("");
    const Q = new FormData();
    Q.append(a, Y), await fetch(i, { method: s, body: Q }).then(async (J) => await J.json()).then((J) => {
      J != null && J.error ? x(J.error) : w(J == null ? void 0 : J[u]), g && g(J == null ? void 0 : J[u]);
    }).catch((J) => {
      console.error(J), x("Erro ao enviar imagem");
    }).finally(() => B(!1));
  }
  function $(Y) {
    f || (F(URL.createObjectURL(Y)), N(Y));
  }
  const V = b || M, K = `arkynImageUpload ${V ? "hasError" : "noHasError"} ${P ? "hasImage" : "noHasImage"}`;
  return /* @__PURE__ */ ee.jsxs("div", { className: "arkynImageUploadContainer", children: [
    r && /* @__PURE__ */ ee.jsx(hXe, { label: r, showAsterisk: o }),
    /* @__PURE__ */ ee.jsxs("div", { className: K, children: [
      /* @__PURE__ */ ee.jsx("input", { type: "hidden", name: t, value: E || "" }),
      !P && /* @__PURE__ */ ee.jsx(
        gXe,
        {
          disabled: f,
          isLoading: L,
          acceptImage: l,
          dropImageText: d,
          handleSelectFile: $,
          selectImageButtonText: p
        }
      ),
      P && /* @__PURE__ */ ee.jsx(
        dXe,
        {
          disabled: f,
          isLoading: L,
          acceptImage: l,
          filePath: P,
          handleSelectFile: $,
          changeImageButtonText: c,
          reSendImage: V && v ? () => N(v) : void 0
        }
      )
    ] }),
    V && /* @__PURE__ */ ee.jsx(fXe, { error: V })
  ] });
}
function iu(e, t, n) {
  if (!e) return /* @__PURE__ */ ee.jsx(ee.Fragment, {});
  if (typeof e == "string") return /* @__PURE__ */ ee.jsx("p", { className: n, children: e });
  const r = e;
  return /* @__PURE__ */ ee.jsx("p", { className: n, children: /* @__PURE__ */ ee.jsx(r, { color: "var(--secondary-600)", size: t, strokeWidth: 2.5 }) });
}
function fj(e) {
  return e && e.replace(/[^0-9]/g, "");
}
function nie(e, t) {
  let n = "", r = 0;
  return Array.from(e).forEach((o, i) => {
    t[i + r].match(/[0-9]/) || (n += t[i + r], r++), n += o;
  }), n;
}
function rie(e) {
  return e.length > 11 ? "CNPJ" : "CPF";
}
const hj = {
  CPF: "999.999.999-999",
  CNPJ: "99.999.999/9999-99"
}, oie = fj(hj.CNPJ).length;
function vXe(e, t) {
  const {
    isLoading: n,
    isError: r,
    size: o = "md",
    className: i = "",
    variant: a = "solid",
    prefix: s,
    sufix: l,
    leftIcon: u,
    rightIcon: c,
    disabled: p,
    defaultValue: d,
    readOnly: g,
    onFocus: f,
    onBlur: m,
    title: b,
    style: E,
    onChange: w,
    ...M
  } = e;
  function x(H) {
    let Z = fj(H);
    const K = rie(Z);
    if (!(Z.length > oie))
      return Z = nie(Z, hj[K]), Z;
  }
  const v = c ? "right" : "left", N = `arkyn_input ${s ? "hasPrefix" : ""} ${l ? "hasSufix" : ""} ${a} ${o} ${p || g || n ? "opacity" : ""} ${r ? "errored" : ""} ${t ? "focused" : ""} ${i}`, V = { md: 20, lg: 20 }[o];
  return {
    isLoading: n,
    className: N,
    prefix: iu(s, V, "prefix"),
    sufix: iu(l, V, "sufix"),
    LeftIcon: u,
    RightIcon: c,
    defaultValue: x(d || ""),
    disabled: p,
    readOnly: g,
    onFocus: f,
    onBlur: m,
    title: b,
    style: E,
    onChange: w,
    loadingPosition: v,
    iconSize: V,
    Spinner: /* @__PURE__ */ ee.jsx(ma, { className: "spinner", size: V, strokeWidth: 2.5 }),
    ...M
  };
}
function yXe(e) {
  const [t, n] = k(!1), r = dt(null), { inputRef: o, id: i, error: a } = Fi(), s = o || r, l = e.isError || !!a, {
    disabled: u,
    title: c,
    style: p,
    className: d,
    prefix: g,
    sufix: f,
    iconSize: m,
    loadingPosition: b,
    isLoading: E,
    LeftIcon: w,
    readOnly: M,
    onFocus: x,
    onBlur: v,
    RightIcon: C,
    Spinner: P,
    onChange: F,
    value: L,
    defaultValue: B,
    ...N
  } = vXe({ ...e, id: i, isError: l }, t), [$, V] = k(B), H = w && !E, Z = C && !E, K = b === "left" && E, Y = b === "right" && E;
  function Q() {
    u || !(s != null && s.current) || (n(!0), s.current.focus());
  }
  function J(z) {
    let S = fj(z.target.value);
    const W = rie(S);
    S.length > oie || (S = nie(S, hj[W]), z.target.value = S, V(S), F && F(z));
  }
  function _(z) {
    n(!0), x && x(z);
  }
  function D(z) {
    n(!1), v && v(z);
  }
  return /* @__PURE__ */ ee.jsxs(
    "section",
    {
      title: c,
      style: p,
      onClick: Q,
      className: d,
      children: [
        g,
        K && P,
        H && /* @__PURE__ */ ee.jsx(w, { size: m, strokeWidth: 2.5 }),
        /* @__PURE__ */ ee.jsx(
          "input",
          {
            disabled: u || E,
            readOnly: M,
            ref: s,
            value: L || $,
            onFocus: _,
            onChange: J,
            onBlur: D,
            ...N
          }
        ),
        Z && /* @__PURE__ */ ee.jsx(C, { size: m, strokeWidth: 2.5 }),
        Y && P,
        f
      ]
    }
  );
}
const bXe = 3, wXe = (e = "pt-BR", t, n = "BRL", r = !0) => new Intl.NumberFormat(e, {
  style: "currency",
  currency: n,
  currencyDisplay: "symbol",
  minimumFractionDigits: 2,
  maximumFractionDigits: 2
}).format(t).slice(r ? bXe : 0), sy = 2, RZ = (e) => typeof e == "number" ? e : Number(e.toString().replace(/[^0-9-]/g, "")), SP = (e) => {
  let t = e;
  return typeof e == "string" ? (t = RZ(e), t % 1 !== 0 && (t = t.toFixed(sy))) : t = Number.isInteger(e) ? Number(e) * 10 ** sy : e.toFixed(sy), RZ(t) / 10 ** sy;
}, IZ = (e, t, n) => {
  if (!t) return [0, ""];
  const r = SP(t), o = wXe(e, r, n);
  return [r, o];
};
function CXe(e, t) {
  const {
    isLoading: n,
    isError: r,
    size: o = "md",
    className: i = "",
    variant: a = "solid",
    prefix: s,
    sufix: l,
    leftIcon: u,
    rightIcon: c,
    disabled: p,
    readOnly: d,
    onFocus: g,
    onBlur: f,
    title: m,
    style: b,
    // showCents = false,
    max: E = 1e9,
    locale: w = "pt-BR",
    currency: M = "BRL",
    ...x
  } = e, v = c ? "right" : "left", N = `arkyn_input ${s ? "hasPrefix" : ""} ${l ? "hasSufix" : ""} ${a} ${o} ${p || d || n ? "opacity" : ""} ${r ? "errored" : ""} ${t ? "focused" : ""} ${i}`, V = { md: 20, lg: 20 }[o];
  return {
    isLoading: n,
    className: N,
    prefix: iu(s, V, "prefix"),
    sufix: iu(l, V, "sufix"),
    LeftIcon: u,
    RightIcon: c,
    disabled: p,
    locale: w,
    currency: M,
    readOnly: d,
    onFocus: g,
    onBlur: f,
    title: m,
    style: b,
    max: E,
    // showCents,
    loadingPosition: v,
    iconSize: V,
    Spinner: /* @__PURE__ */ ee.jsx(ma, { className: "spinner", size: V, strokeWidth: 2.5 }),
    ...x
  };
}
function OXe(e) {
  const [t, n] = k(!1), [r, o] = k("0"), i = dt(null), { inputRef: a, id: s, error: l } = Fi(), u = a || i, c = e.isError || !!l, {
    disabled: p,
    title: d,
    style: g,
    className: f,
    prefix: m,
    sufix: b,
    iconSize: E,
    loadingPosition: w,
    isLoading: M,
    LeftIcon: x,
    readOnly: v,
    onFocus: C,
    onBlur: P,
    RightIcon: F,
    Spinner: L,
    value: B,
    max: N,
    onChangeValue: $,
    onKeyPress: V,
    currency: H,
    locale: Z,
    name: K,
    defaultValue: Y,
    ...Q
  } = CXe({ ...e, id: s, isError: c }, t), J = x && !M, _ = F && !M, D = w === "left" && M, z = w === "right" && M;
  function S() {
    p || !(u != null && u.current) || (n(!0), u.current.focus());
  }
  function W(q) {
    n(!0), C && C(q);
  }
  function O(q) {
    n(!1), P && P(q);
  }
  const j = (q) => {
    const [A, X] = IZ(
      Z,
      q,
      H
    );
    return !N || A <= N ? (o(X), [A, X]) : [SP(r), r];
  }, U = (q) => {
    q.preventDefault();
    const [A, X] = j(q.target.value);
    $ && $(q, String(A), String(X));
  }, T = (q) => V && V(q, q.key, q.key);
  return h(() => {
    const q = B || +Y || void 0, [, A] = IZ(Z, q, H);
    o(A);
  }, [H, Y, B]), /* @__PURE__ */ ee.jsxs(
    "section",
    {
      title: d,
      style: g,
      onClick: S,
      className: f,
      children: [
        m,
        D && L,
        J && /* @__PURE__ */ ee.jsx(x, { size: E, strokeWidth: 2.5 }),
        /* @__PURE__ */ ee.jsx(
          "input",
          {
            value: r,
            onChange: U,
            onBlur: O,
            onFocus: W,
            onKeyUp: T,
            disabled: p || M,
            readOnly: v,
            ...Q
          }
        ),
        /* @__PURE__ */ ee.jsx(
          "input",
          {
            type: "hidden",
            ref: u,
            name: K,
            value: SP(r)
          }
        ),
        z && L,
        _ && /* @__PURE__ */ ee.jsx(F, { size: E, strokeWidth: 2.5 }),
        b
      ]
    }
  );
}
function xXe(e, t) {
  const {
    isLoading: n,
    isError: r,
    size: o = "md",
    className: i = "",
    variant: a = "solid",
    prefix: s,
    sufix: l,
    leftIcon: u,
    rightIcon: c,
    disabled: p,
    readOnly: d,
    onFocus: g,
    onBlur: f,
    title: m,
    style: b,
    onChange: E,
    showMask: w = !1,
    type: M,
    ...x
  } = e, v = c ? "right" : "left", N = `arkyn_input ${s ? "hasPrefix" : ""} ${l ? "hasSufix" : ""} ${a} ${o} ${p || d || n ? "opacity" : ""} ${r ? "errored" : ""} ${t ? "focused" : ""} ${i}`, V = { md: 20, lg: 20 }[o];
  return {
    isLoading: n,
    className: N,
    prefix: iu(s, V, "prefix"),
    sufix: iu(l, V, "sufix"),
    LeftIcon: u,
    RightIcon: c,
    disabled: p,
    readOnly: d,
    onFocus: g,
    onBlur: f,
    title: m,
    style: b,
    onChange: E,
    loadingPosition: v,
    iconSize: V,
    showMask: w,
    Spinner: /* @__PURE__ */ ee.jsx(ma, { className: "spinner", size: V, strokeWidth: 2.5 }),
    ...x
  };
}
const EXe = Cr((e, t) => /* @__PURE__ */ ee.jsx("input", { ref: t, ...e }));
function kXe(e) {
  const [t, n] = k(!1), r = dt(null), { inputRef: o, id: i, error: a } = Fi(), s = o || r, l = e.isError || !!a, {
    disabled: u,
    title: c,
    style: p,
    className: d,
    prefix: g,
    sufix: f,
    iconSize: m,
    loadingPosition: b,
    isLoading: E,
    LeftIcon: w,
    readOnly: M,
    onFocus: x,
    onBlur: v,
    RightIcon: C,
    Spinner: P,
    ...F
  } = xXe({ ...e, id: i, isError: l }, t), L = w && !E, B = C && !E, N = b === "left" && E, $ = b === "right" && E;
  function V() {
    u || !(s != null && s.current) || (n(!0), s.current.focus());
  }
  function H(K) {
    n(!0), x && x(K);
  }
  function Z(K) {
    n(!1), v && v(K);
  }
  return /* @__PURE__ */ ee.jsxs(
    "section",
    {
      title: c,
      style: p,
      onClick: V,
      className: d,
      children: [
        g,
        N && P,
        L && /* @__PURE__ */ ee.jsx(w, { size: m, strokeWidth: 2.5 }),
        /* @__PURE__ */ ee.jsx(
          ol,
          {
            component: EXe,
            ref: s,
            onFocus: H,
            onBlur: Z,
            disabled: u,
            ...F
          }
        ),
        B && /* @__PURE__ */ ee.jsx(C, { size: m, strokeWidth: 2.5 }),
        $ && P,
        f
      ]
    }
  );
}
function LXe(e, t) {
  const {
    isLoading: n,
    isError: r,
    size: o = "md",
    className: i = "",
    variant: a = "solid",
    prefix: s,
    sufix: l,
    leftIcon: u,
    rightIcon: c,
    disabled: p,
    readOnly: d,
    onFocus: g,
    onBlur: f,
    title: m,
    style: b,
    onChange: E,
    ...w
  } = e, M = c ? "right" : "left", L = `arkyn_input ${s ? "hasPrefix" : ""} ${l ? "hasSufix" : ""} ${a} ${o} ${p || d || n ? "opacity" : ""} ${r ? "errored" : ""} ${t ? "focused" : ""} ${i}`, N = { md: 20, lg: 20 }[o];
  return {
    isLoading: n,
    className: L,
    prefix: iu(s, N, "prefix"),
    sufix: iu(l, N, "sufix"),
    LeftIcon: u,
    RightIcon: c,
    disabled: p,
    readOnly: d,
    onFocus: g,
    onBlur: f,
    title: m,
    style: b,
    onChange: E,
    loadingPosition: M,
    iconSize: N,
    Spinner: /* @__PURE__ */ ee.jsx(ma, { className: "spinner", size: N, strokeWidth: 2.5 }),
    ...w
  };
}
function _Xe(e) {
  const [t, n] = k(!1), r = dt(null), { inputRef: o, id: i, error: a } = Fi(), s = o || r, l = e.isError || !!a, {
    disabled: u,
    title: c,
    style: p,
    className: d,
    prefix: g,
    sufix: f,
    iconSize: m,
    loadingPosition: b,
    isLoading: E,
    LeftIcon: w,
    readOnly: M,
    onFocus: x,
    onBlur: v,
    RightIcon: C,
    type: P,
    Spinner: F,
    ...L
  } = LXe({ ...e, id: i, isError: l }, t), B = w && !E, N = C && !E, $ = b === "left" && E, V = b === "right" && E;
  function H() {
    u || !(s != null && s.current) || (n(!0), s.current.focus());
  }
  function Z(Y) {
    n(!0), x && x(Y);
  }
  function K(Y) {
    n(!1), v && v(Y);
  }
  return P === "hidden" ? /* @__PURE__ */ ee.jsx(
    "input",
    {
      style: { display: "none" },
      readOnly: !0,
      type: "text",
      ref: s,
      ...L
    }
  ) : /* @__PURE__ */ ee.jsxs(
    "section",
    {
      title: c,
      style: p,
      onClick: H,
      className: d,
      children: [
        g,
        $ && F,
        B && /* @__PURE__ */ ee.jsx(w, { size: m, strokeWidth: 2.5 }),
        /* @__PURE__ */ ee.jsx(
          "input",
          {
            disabled: u || E,
            readOnly: M,
            ref: s,
            onFocus: Z,
            onBlur: K,
            type: P,
            ...L
          }
        ),
        N && /* @__PURE__ */ ee.jsx(C, { size: m, strokeWidth: 2.5 }),
        V && F,
        f
      ]
    }
  );
}
function QO(e) {
  return e.type === "currency" ? /* @__PURE__ */ ee.jsx(OXe, { ...e }) : e.type === "masked" ? /* @__PURE__ */ ee.jsx(kXe, { ...e }) : e.type === "cpf-cnpj" ? /* @__PURE__ */ ee.jsx(yXe, { ...e }) : /* @__PURE__ */ ee.jsx(_Xe, { ...e });
}
function PXe(e) {
  const { iconSize: t, isLoading: n, disabled: r, readOnly: o, isFocused: i } = e, l = `arkynMultiSelectChevron ${r || o ? "notAnimate" : ""} ${i ? "focused" : ""}`;
  return n ? /* @__PURE__ */ ee.jsx(ee.Fragment, {}) : /* @__PURE__ */ ee.jsx(GP, { className: l, size: t, strokeWidth: 2.5 });
}
function SXe(e) {
  const {
    children: t,
    handleContainerFocus: n,
    disabled: r,
    isError: o,
    isLoading: i,
    isFocused: a,
    className: s,
    readOnly: l,
    variant: u,
    size: c,
    id: p,
    prefixExists: d
  } = e, g = d ? "hasPrefix" : "", f = o ? "errored" : "", m = r || l || i ? "opacity" : "", b = a ? "focused" : "";
  return /* @__PURE__ */ ee.jsx(
    "section",
    {
      id: p,
      className: `arkynMultiSelectContainer ${g} ${u} ${c} ${m} ${f} ${b} ${s}`,
      onClick: n,
      children: t
    }
  );
}
function MXe(e) {
  const { children: t, size: n } = e, r = `arkynMultiSelectContent ${n}`;
  return /* @__PURE__ */ ee.jsx("div", { className: r, children: t });
}
function DXe(e) {
  const { label: t, value: n, handleChangeValue: r } = e;
  return /* @__PURE__ */ ee.jsxs("div", { className: "arkynMultiSelectMark", children: [
    t,
    /* @__PURE__ */ ee.jsx(
      "button",
      {
        type: "button",
        onClick: (o) => {
          o.stopPropagation(), r(n);
        },
        children: /* @__PURE__ */ ee.jsx(KP, {})
      }
    )
  ] });
}
function TXe(e) {
  const { label: t, optionHasSelected: n, handleChangeValue: r, value: o, size: i } = e, a = n(o) ? "active" : "", s = `arkynMultiSelectOption ${i} ${a}`;
  return /* @__PURE__ */ ee.jsxs("div", { onClick: () => r(o), className: s, children: [
    t,
    " ",
    /* @__PURE__ */ ee.jsx(l0, {})
  ] });
}
function jXe(e) {
  const { children: t, isFocused: n, isSearchable: r, onSearch: o } = e;
  function i(a) {
    r && o(a.target.value);
  }
  return n ? /* @__PURE__ */ ee.jsxs("div", { className: "arkynMultiSelectOptionsContainer", children: [
    r && /* @__PURE__ */ ee.jsx(
      QO,
      {
        type: "search",
        name: "search-select",
        variant: "underline",
        leftIcon: OG,
        onChange: i
      }
    ),
    t
  ] }) : /* @__PURE__ */ ee.jsx(ee.Fragment, {});
}
function AXe(e) {
  const { isFocused: t, handleBlur: n } = e;
  return t ? /* @__PURE__ */ ee.jsx("aside", { className: "arkynMultiSelectOverlay", onClick: n }) : /* @__PURE__ */ ee.jsx(ee.Fragment, {});
}
function RXe(e) {
  const { iconSize: t, isLoading: n } = e;
  return n ? /* @__PURE__ */ ee.jsx(
    ma,
    {
      className: "arkynMultiSelectSpinner",
      size: t,
      strokeWidth: 2.5
    }
  ) : /* @__PURE__ */ ee.jsx(ee.Fragment, {});
}
function Nit(e) {
  const {
    name: t,
    options: n,
    className: r = "",
    placeholder: o = "Selecione...",
    closeOnSelect: i = !1,
    defaultValue: a = [],
    isError: s,
    isLoading: l = !1,
    readOnly: u = !1,
    isSearchable: c = !1,
    leftIcon: p,
    onSearch: d,
    onSelect: g,
    onBlur: f,
    notFoundText: m = "Sem opções disponíveis",
    onFocus: b,
    disabled: E = !1,
    prefix: w,
    size: M = "md",
    value: x,
    variant: v = "solid"
  } = e, C = Fi(), P = dt(null), F = C.inputRef || P, L = C.id, B = s || !!C.error, $ = { md: 20, lg: 20 }[M], V = iK(w, $, "prefix"), [H, Z] = k(""), [K, Y] = k(!1), [Q, J] = k(a), _ = x || Q;
  function D(T) {
    return _.includes(T);
  }
  function z(T) {
    const q = n.find((A) => A.value === T);
    return (q == null ? void 0 : q.label) || "";
  }
  function S() {
    E || !(F != null && F.current) || K || (Y(!0), F.current.focus(), b && b());
  }
  function W() {
    Y(!1), f && F.current && F.current.blur();
  }
  function O(T) {
    Z(T), d && d(T);
  }
  function j(T) {
    D(T) ? J(Q.filter((q) => q !== T)) : J([...Q, T]), g && g(Q), i && W();
  }
  const U = n.filter((T) => !!(e.onSearch || !e.isSearchable || T.label.toLowerCase().includes(H.toLowerCase())));
  return /* @__PURE__ */ ee.jsxs(
    SXe,
    {
      handleContainerFocus: S,
      disabled: E,
      isError: B,
      isFocused: K,
      isLoading: l,
      readOnly: u,
      size: M,
      variant: v,
      className: r,
      prefixExists: !!w,
      id: L,
      children: [
        /* @__PURE__ */ ee.jsx(
          "input",
          {
            ref: F,
            name: t,
            value: JSON.stringify(_),
            type: "hidden"
          }
        ),
        V,
        p && /* @__PURE__ */ ee.jsx(p, { size: $, strokeWidth: 2.5 }),
        /* @__PURE__ */ ee.jsxs(MXe, { size: M, children: [
          _.map((T) => /* @__PURE__ */ ee.jsx(
            DXe,
            {
              label: z(T),
              value: T,
              handleChangeValue: j
            },
            T
          )),
          _.length <= 0 && /* @__PURE__ */ ee.jsx("p", { children: o })
        ] }),
        /* @__PURE__ */ ee.jsxs(
          jXe,
          {
            isFocused: K,
            isSearchable: c,
            onSearch: O,
            children: [
              U.map(({ label: T, value: q }) => /* @__PURE__ */ ee.jsx(
                TXe,
                {
                  label: T,
                  value: q,
                  size: M,
                  handleChangeValue: j,
                  optionHasSelected: D
                },
                q
              )),
              U.length <= 0 && /* @__PURE__ */ ee.jsx("p", { children: m })
            ]
          }
        ),
        /* @__PURE__ */ ee.jsx(
          PXe,
          {
            disabled: E,
            isFocused: K,
            readOnly: u,
            iconSize: $,
            isLoading: l
          }
        ),
        /* @__PURE__ */ ee.jsx(RXe, { iconSize: $, isLoading: l }),
        /* @__PURE__ */ ee.jsx(AXe, { handleBlur: W, isFocused: K })
      ]
    }
  );
}
const lp = [
  {
    name: "Afghanistan",
    code: "+93",
    prefix: null,
    iso: "AF",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/af.svg",
    mask: "__-___-____"
  },
  {
    name: "Aland Islands",
    code: "+358",
    prefix: null,
    iso: "AX",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ax.svg",
    mask: "(___)___-__-__"
  },
  {
    name: "Albania",
    code: "+355",
    prefix: null,
    iso: "AL",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/al.svg",
    mask: "(___)___-___"
  },
  {
    name: "Algeria",
    code: "+213",
    prefix: null,
    iso: "DZ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/dz.svg",
    mask: "__-___-____"
  },
  {
    name: "American Samoa",
    code: "+1",
    prefix: "684",
    iso: "AS",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/as.svg",
    mask: "(684)___-____"
  },
  {
    name: "Andorra",
    code: "+376",
    prefix: null,
    iso: "AD",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ad.svg",
    mask: "___-___"
  },
  {
    name: "Angola",
    code: "+244",
    prefix: null,
    iso: "AO",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ao.svg",
    mask: "(___)___-___"
  },
  {
    name: "Anguilla",
    code: "+1",
    prefix: "264",
    iso: "AI",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ai.svg",
    mask: "(264)___-____"
  },
  {
    name: "Antarctica",
    code: "+672",
    prefix: "1",
    iso: "AQ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/aq.svg",
    mask: "1__-___"
  },
  {
    name: "Antigua and Barbuda",
    code: "+1",
    prefix: "268",
    iso: "AG",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ag.svg",
    mask: "(268)___-____"
  },
  {
    name: "Argentina",
    code: "+54",
    prefix: null,
    iso: "AR",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ar.svg",
    mask: "(___)___-____"
  },
  {
    name: "Armenia",
    code: "+374",
    prefix: null,
    iso: "AM",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/am.svg",
    mask: "__-___-___"
  },
  {
    name: "Aruba",
    code: "+297",
    prefix: null,
    iso: "AW",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/aw.svg",
    mask: "___-____"
  },
  {
    name: "Ascension Island",
    code: "+247",
    prefix: null,
    iso: "AC",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/sh.svg",
    mask: "____"
  },
  {
    name: "Australia",
    code: "+61",
    prefix: null,
    iso: "AU",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/au.svg",
    mask: "_-____-____"
  },
  {
    name: "Austria",
    code: "+43",
    prefix: null,
    iso: "AT",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/at.svg",
    mask: "(___)___-____"
  },
  {
    name: "Azerbaijan",
    code: "+994",
    prefix: null,
    iso: "AZ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/az.svg",
    mask: "__-___-__-__"
  },
  {
    name: "Bahamas",
    code: "+1",
    prefix: "242",
    iso: "BS",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/bs.svg",
    mask: "(242)___-____"
  },
  {
    name: "Bahrain",
    code: "+973",
    prefix: null,
    iso: "BH",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/bh.svg",
    mask: "____-____"
  },
  {
    name: "Bangladesh",
    code: "+880",
    prefix: "1",
    iso: "BD",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/bd.svg",
    mask: "1___-______"
  },
  {
    name: "Barbados",
    code: "+1",
    prefix: "246",
    iso: "BB",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/bb.svg",
    mask: "(246)___-____"
  },
  {
    name: "Belarus",
    code: "+375",
    prefix: null,
    iso: "BY",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/by.svg",
    mask: "(__)___-__-__"
  },
  {
    name: "Belgium",
    code: "+32",
    prefix: null,
    iso: "BE",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/be.svg",
    mask: "(___)___-___"
  },
  {
    name: "Belize",
    code: "+501",
    prefix: null,
    iso: "BZ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/bz.svg",
    mask: "___-____"
  },
  {
    name: "Benin",
    code: "+229",
    prefix: null,
    iso: "BJ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/bj.svg",
    mask: "__-__-____"
  },
  {
    name: "Bermuda",
    code: "+1",
    prefix: "441",
    iso: "BM",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/bm.svg",
    mask: "(441)___-____"
  },
  {
    name: "Bhutan",
    code: "+975",
    prefix: null,
    iso: "BT",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/bt.svg",
    mask: "_-___-___"
  },
  {
    name: "Bolivia",
    code: "+591",
    prefix: null,
    iso: "BO",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/bo.svg",
    mask: "_-___-____"
  },
  {
    name: "Bosnia and Herzegovina",
    code: "+387",
    prefix: null,
    iso: "BA",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ba.svg",
    mask: "__-_____"
  },
  {
    name: "Botswana",
    code: "+267",
    prefix: null,
    iso: "BW",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/bw.svg",
    mask: "__-___-___"
  },
  {
    name: "Brasil",
    code: "+55",
    prefix: null,
    iso: "BR",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/br.svg",
    mask: "(__) _____-____"
  },
  {
    name: "British Indian Ocean Territory",
    code: "+246",
    prefix: null,
    iso: "IO",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/io.svg",
    mask: "___-____"
  },
  {
    name: "Brunei Darussalam",
    code: "+673",
    prefix: null,
    iso: "BN",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/bn.svg",
    mask: "___-____"
  },
  {
    name: "Bulgaria",
    code: "+359",
    prefix: null,
    iso: "BG",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/bg.svg",
    mask: "(___)___-___"
  },
  {
    name: "Burkina Faso",
    code: "+226",
    prefix: null,
    iso: "BF",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/bf.svg",
    mask: "__-__-____"
  },
  {
    name: "Burundi",
    code: "+257",
    prefix: null,
    iso: "BI",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/bi.svg",
    mask: "__-__-____"
  },
  {
    name: "Cambodia",
    code: "+855",
    prefix: null,
    iso: "KH",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/kh.svg",
    mask: "__-___-___"
  },
  {
    name: "Cameroon",
    code: "+237",
    prefix: null,
    iso: "CM",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/cm.svg",
    mask: "____-____"
  },
  {
    name: "Canada",
    code: "+1",
    prefix: null,
    iso: "CA",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ca.svg",
    mask: "(___)___-____"
  },
  {
    name: "Cape Verde",
    code: "+238",
    prefix: null,
    iso: "CV",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/cv.svg",
    mask: "(___)__-__"
  },
  {
    name: "Cayman Islands",
    code: "+1",
    prefix: "345",
    iso: "KY",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ky.svg",
    mask: "(345)___-____"
  },
  {
    name: "Central African Republic",
    code: "+236",
    prefix: null,
    iso: "CF",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/cf.svg",
    mask: "__-__-____"
  },
  {
    name: "Chad",
    code: "+235",
    prefix: null,
    iso: "TD",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/td.svg",
    mask: "__-__-__-__"
  },
  {
    name: "Chile",
    code: "+56",
    prefix: null,
    iso: "CL",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/cl.svg",
    mask: "_-____-____"
  },
  {
    name: "China",
    code: "+86",
    prefix: null,
    iso: "CN",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/cn.svg",
    mask: "__-_____-_____"
  },
  {
    name: "Christmas Island",
    code: "+61",
    prefix: null,
    iso: "CX",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/cx.svg",
    mask: "_-____-____"
  },
  {
    name: "Cocos (Keeling) Islands",
    code: "+61",
    prefix: null,
    iso: "CC",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/cc.svg",
    mask: "_-____-____"
  },
  {
    name: "Colombia",
    code: "+57",
    prefix: null,
    iso: "CO",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/co.svg",
    mask: "(___)___-____"
  },
  {
    name: "Comoros",
    code: "+269",
    prefix: null,
    iso: "KM",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/km.svg",
    mask: "__-_____"
  },
  {
    name: "Congo",
    code: "+242",
    prefix: null,
    iso: "CG",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/cg.svg",
    mask: "__-_____"
  },
  {
    name: "Cook Islands",
    code: "+682",
    prefix: null,
    iso: "CK",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ck.svg",
    mask: "__-___"
  },
  {
    name: "Costa Rica",
    code: "+506",
    prefix: null,
    iso: "CR",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/cr.svg",
    mask: "____-____"
  },
  {
    name: "Croatia",
    code: "+385",
    prefix: null,
    iso: "HR",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/hr.svg",
    mask: "__-___-___"
  },
  {
    name: "Cuba",
    code: "+53",
    prefix: null,
    iso: "CU",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/cu.svg",
    mask: "_-___-____"
  },
  {
    name: "Cyprus",
    code: "+357",
    prefix: null,
    iso: "CY",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/cy.svg",
    mask: "__-___-___"
  },
  {
    name: "Czech Republic",
    code: "+420",
    prefix: null,
    iso: "CZ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/cz.svg",
    mask: "(___)___-___"
  },
  {
    name: "Democratic Republic of the Congo",
    code: "+243",
    prefix: null,
    iso: "CD",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/cd.svg",
    mask: "(___)___-___"
  },
  {
    name: "Denmark",
    code: "+45",
    prefix: null,
    iso: "DK",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/dk.svg",
    mask: "__-__-__-__"
  },
  {
    name: "Djibouti",
    code: "+253",
    prefix: null,
    iso: "DJ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/dj.svg",
    mask: "__-__-__-__"
  },
  {
    name: "Dominica",
    code: "+1",
    prefix: "767",
    iso: "DM",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/dm.svg",
    mask: "(767)___-____"
  },
  {
    name: "Dominican Republic",
    code: "+1",
    prefix: "849",
    iso: "DO",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/do.svg",
    mask: "(894)___-____"
  },
  {
    name: "Ecuador",
    code: "+593",
    prefix: null,
    iso: "EC",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ec.svg",
    mask: "__-___-____"
  },
  {
    name: "Egypt",
    code: "+20",
    prefix: null,
    iso: "EG",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/eg.svg",
    mask: "(___)___-____"
  },
  {
    name: "El Salvador",
    code: "+503",
    prefix: null,
    iso: "SV",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/sv.svg",
    mask: "__-__-____"
  },
  {
    name: "Equatorial Guinea",
    code: "+240",
    prefix: null,
    iso: "GQ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/gq.svg",
    mask: "__-___-____"
  },
  {
    name: "Eritrea",
    code: "+291",
    prefix: null,
    iso: "ER",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/er.svg",
    mask: "_-___-___"
  },
  {
    name: "Estonia",
    code: "+372",
    prefix: null,
    iso: "EE",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ee.svg",
    mask: "____-____"
  },
  {
    name: "Eswatini",
    code: "+268",
    prefix: null,
    iso: "SZ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/sz.svg",
    mask: "__-__-____"
  },
  {
    name: "Ethiopia",
    code: "+251",
    prefix: null,
    iso: "ET",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/et.svg",
    mask: "__-___-____"
  },
  {
    name: "Falkland Islands (Malvinas)",
    code: "+500",
    prefix: null,
    iso: "FK",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/fk.svg",
    mask: "_____"
  },
  {
    name: "Faroe Islands",
    code: "+298",
    prefix: null,
    iso: "FO",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/fo.svg",
    mask: "__ __ __"
  },
  {
    name: "Fiji",
    code: "+679",
    prefix: null,
    iso: "FJ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/fj.svg",
    mask: "__-_____"
  },
  {
    name: "Finland",
    code: "+358",
    prefix: null,
    iso: "FI",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/fi.svg",
    mask: "__ ___ ____"
  },
  {
    name: "France",
    code: "+33",
    prefix: null,
    iso: "FR",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/fr.svg",
    mask: "_ __ __ __ __"
  },
  {
    name: "French Guiana",
    code: "+594",
    prefix: null,
    iso: "GF",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/gf.svg",
    mask: "___ __ __ __"
  },
  {
    name: "French Polynesia",
    code: "+689",
    prefix: null,
    iso: "PF",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/pf.svg",
    mask: "__ __ __ __"
  },
  {
    name: "Gabon",
    code: "+241",
    prefix: null,
    iso: "GA",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ga.svg",
    mask: "_ __ __ __"
  },
  {
    name: "Gambia",
    code: "+220",
    prefix: null,
    iso: "GM",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/gm.svg",
    mask: "___ ____"
  },
  {
    name: "Georgia",
    code: "+995",
    prefix: null,
    iso: "GE",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ge.svg",
    mask: "(___)___-___"
  },
  {
    name: "Germany",
    code: "+49",
    prefix: "3",
    iso: "DE",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/de.svg",
    mask: "(3____) __-____"
  },
  {
    name: "Ghana",
    code: "+233",
    prefix: "03",
    iso: "GH",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/gh.svg",
    mask: "03_ ___ ____"
  },
  {
    name: "Gibraltar",
    code: "+350",
    prefix: null,
    iso: "GI",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/gi.svg",
    mask: "___-_____"
  },
  {
    name: "Greece",
    code: "+30",
    prefix: null,
    iso: "GR",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/gr.svg",
    mask: "(___)___-____"
  },
  {
    name: "Greenland",
    code: "+299",
    prefix: null,
    iso: "GL",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/gl.svg",
    mask: "__-__-__"
  },
  {
    name: "Grenada",
    code: "+1",
    prefix: "473",
    iso: "GD",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/gd.svg",
    mask: "(473)___-____"
  },
  {
    name: "Guadeloupe",
    code: "+590",
    prefix: null,
    iso: "GP",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/gp.svg",
    mask: "___ __ __ __"
  },
  {
    name: "Guam",
    code: "+1",
    prefix: "671",
    iso: "GU",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/gu.svg",
    mask: "671 ___ ____"
  },
  {
    name: "Guatemala",
    code: "+502",
    prefix: null,
    iso: "GT",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/gt.svg",
    mask: "_-___-____"
  },
  {
    name: "Guernsey",
    code: "+44",
    prefix: null,
    iso: "GG",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/gg.svg",
    mask: "(____)______"
  },
  {
    name: "Guinea",
    code: "+224",
    prefix: null,
    iso: "GN",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/gn.svg",
    mask: "__-___-___"
  },
  {
    name: "Guinea-Bissau",
    code: "+245",
    prefix: null,
    iso: "GW",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/gw.svg",
    mask: "_-______"
  },
  {
    name: "Guyana",
    code: "+592",
    prefix: null,
    iso: "GY",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/gy.svg",
    mask: "___-____"
  },
  {
    name: "Haiti",
    code: "+509",
    prefix: null,
    iso: "HT",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ht.svg",
    mask: "__-__-____"
  },
  {
    name: "Holy See (Vatican City State)",
    code: "+39",
    prefix: "06698",
    iso: "VA",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/va.svg",
    mask: "06 698_____"
  },
  {
    name: "Honduras",
    code: "+504",
    prefix: null,
    iso: "HN",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/hn.svg",
    mask: "____-____"
  },
  {
    name: "Hong Kong",
    code: "+852",
    prefix: null,
    iso: "HK",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/hk.svg",
    mask: "____-____"
  },
  {
    name: "Hungary",
    code: "+36",
    prefix: null,
    iso: "HU",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/hu.svg",
    mask: "__ ___ ____"
  },
  {
    name: "Iceland",
    code: "+354",
    prefix: null,
    iso: "IS",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/is.svg",
    mask: "___-____"
  },
  {
    name: "India",
    code: "+91",
    prefix: null,
    iso: "IN",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/in.svg",
    mask: "(____)___-___"
  },
  {
    name: "Indonesia",
    code: "+62",
    prefix: "8",
    iso: "ID",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/id.svg",
    mask: "(8__)___-__-___"
  },
  {
    name: "Iran",
    code: "+98",
    prefix: null,
    iso: "IR",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ir.svg",
    mask: "(___)___-____"
  },
  {
    name: "Iraq",
    code: "+964",
    prefix: null,
    iso: "IQ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/iq.svg",
    mask: "(___)___-____"
  },
  {
    name: "Ireland",
    code: "+353",
    prefix: null,
    iso: "IE",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ie.svg",
    mask: "(___)___-___"
  },
  {
    name: "Isle of Man",
    code: "+44",
    prefix: null,
    iso: "IM",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/im.svg",
    mask: "(____)______"
  },
  {
    name: "Israel",
    code: "+972",
    prefix: "5",
    iso: "IL",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/il.svg",
    mask: "__-___-____"
  },
  {
    name: "Italy",
    code: "+39",
    prefix: null,
    iso: "IT",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/it.svg",
    mask: "(___)____-___"
  },
  {
    name: "Ivory Coast / Cote d'Ivoire",
    code: "+225",
    prefix: null,
    iso: "CI",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ci.svg",
    mask: "__-___-___"
  },
  {
    name: "Jamaica",
    code: "+1",
    prefix: "876",
    iso: "JM",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/jm.svg",
    mask: "(876)___-____"
  },
  {
    name: "Japan",
    code: "+81",
    prefix: null,
    iso: "JP",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/jp.svg",
    mask: "__-____-____"
  },
  {
    name: "Jersey",
    code: "+44",
    prefix: null,
    iso: "JE",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/je.svg",
    mask: "(____)____-______"
  },
  {
    name: "Jordan",
    code: "+962",
    prefix: null,
    iso: "JO",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/jo.svg",
    mask: "_-____-____"
  },
  {
    name: "Kazakhstan",
    code: "+77",
    prefix: null,
    iso: "KZ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/kz.svg",
    mask: "(_____) _ __ __"
  },
  {
    name: "Kenya",
    code: "+254",
    prefix: null,
    iso: "KE",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ke.svg",
    mask: "___-______"
  },
  {
    name: "Kiribati",
    code: "+686",
    prefix: null,
    iso: "KI",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ki.svg",
    mask: "__-___"
  },
  {
    name: "Korea, Democratic People's Republic of Korea",
    code: "+850",
    prefix: null,
    iso: "KP",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/kp.svg",
    mask: "____-_____________"
  },
  {
    name: "Korea, Republic of South Korea",
    code: "+82",
    prefix: null,
    iso: "KR",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/kr.svg",
    mask: "__-___-____"
  },
  {
    name: "Kosovo",
    code: "+383",
    prefix: null,
    iso: "XK",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/xk.svg",
    mask: "___-___-___"
  },
  {
    name: "Kuwait",
    code: "+965",
    prefix: null,
    iso: "KW",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/kw.svg",
    mask: "____-____"
  },
  {
    name: "Kyrgyzstan",
    code: "+996",
    prefix: null,
    iso: "KG",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/kg.svg",
    mask: "(___)___-___"
  },
  {
    name: "Laos",
    code: "+856",
    prefix: "20",
    iso: "LA",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/la.svg",
    mask: "(20__)___-___"
  },
  {
    name: "Latvia",
    code: "+371",
    prefix: null,
    iso: "LV",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/lv.svg",
    mask: "__-___-___"
  },
  {
    name: "Lebanon",
    code: "+961",
    prefix: null,
    iso: "LB",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/lb.svg",
    mask: "__-___-___"
  },
  {
    name: "Lesotho",
    code: "+266",
    prefix: null,
    iso: "LS",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ls.svg",
    mask: "_-___-____"
  },
  {
    name: "Liberia",
    code: "+231",
    prefix: null,
    iso: "LR",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/lr.svg",
    mask: "__-___-___"
  },
  {
    name: "Libya",
    code: "+218",
    prefix: "21",
    iso: "LY",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ly.svg",
    mask: "21-___-____"
  },
  {
    name: "Liechtenstein",
    code: "+423",
    prefix: null,
    iso: "LI",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/li.svg",
    mask: "(___)___-____"
  },
  {
    name: "Lithuania",
    code: "+370",
    prefix: null,
    iso: "LT",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/lt.svg",
    mask: "(___)__-___"
  },
  {
    name: "Luxembourg",
    code: "+352",
    prefix: null,
    iso: "LU",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/lu.svg",
    mask: "(___)___-___"
  },
  {
    name: "Macau",
    code: "+853",
    prefix: null,
    iso: "MO",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/mo.svg",
    mask: "____-____"
  },
  {
    name: "Madagascar",
    code: "+261",
    prefix: null,
    iso: "MG",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/mg.svg",
    mask: "__-__-_____"
  },
  {
    name: "Malawi",
    code: "+265",
    prefix: null,
    iso: "MW",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/mw.svg",
    mask: "_-____-____"
  },
  {
    name: "Malaysia",
    code: "+60",
    prefix: null,
    iso: "MY",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/my.svg",
    mask: "__-___-____"
  },
  {
    name: "Maldives",
    code: "+960",
    prefix: null,
    iso: "MV",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/mv.svg",
    mask: "___-____"
  },
  {
    name: "Mali",
    code: "+223",
    prefix: null,
    iso: "ML",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ml.svg",
    mask: "__-__-____"
  },
  {
    name: "Malta",
    code: "+356",
    prefix: null,
    iso: "MT",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/mt.svg",
    mask: "____-____"
  },
  {
    name: "Marshall Islands",
    code: "+692",
    prefix: null,
    iso: "MH",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/mh.svg",
    mask: "___-____"
  },
  {
    name: "Martinique",
    code: "+596",
    prefix: null,
    iso: "MQ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/mq.svg",
    mask: "(___)__-__-__"
  },
  {
    name: "Mauritania",
    code: "+222",
    prefix: null,
    iso: "MR",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/mr.svg",
    mask: "__-__-____"
  },
  {
    name: "Mauritius",
    code: "+230",
    prefix: null,
    iso: "MU",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/mu.svg",
    mask: "___-____"
  },
  {
    name: "Mayotte",
    code: "+262",
    prefix: null,
    iso: "YT",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/yt.svg",
    mask: "_____-____"
  },
  {
    name: "Mexico",
    code: "+52",
    prefix: null,
    iso: "MX",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/mx.svg",
    mask: "(___)___-____"
  },
  {
    name: "Micronesia, Federated States of Micronesia",
    code: "+691",
    prefix: null,
    iso: "FM",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/fm.svg",
    mask: "___-____"
  },
  {
    name: "Moldova",
    code: "+373",
    prefix: null,
    iso: "MD",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/md.svg",
    mask: "____-____"
  },
  {
    name: "Monaco",
    code: "+377",
    prefix: null,
    iso: "MC",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/mc.svg",
    mask: "(___)___-___"
  },
  {
    name: "Mongolia",
    code: "+976",
    prefix: null,
    iso: "MN",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/mn.svg",
    mask: "__-__-____"
  },
  {
    name: "Montenegro",
    code: "+382",
    prefix: null,
    iso: "ME",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/me.svg",
    mask: "__-___-___"
  },
  {
    name: "Montserrat",
    code: "+1",
    prefix: "664",
    iso: "MS",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ms.svg",
    mask: "(664)___-____"
  },
  {
    name: "Morocco",
    code: "+212",
    prefix: null,
    iso: "MA",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ma.svg",
    mask: "__-____-___"
  },
  {
    name: "Mozambique",
    code: "+258",
    prefix: null,
    iso: "MZ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/mz.svg",
    mask: "__-___-___"
  },
  {
    name: "Myanmar",
    code: "+95",
    prefix: null,
    iso: "MM",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/mm.svg",
    mask: "__-___-___"
  },
  {
    name: "Namibia",
    code: "+264",
    prefix: null,
    iso: "NA",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/na.svg",
    mask: "__-___-____"
  },
  {
    name: "Nauru",
    code: "+674",
    prefix: null,
    iso: "NR",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/nr.svg",
    mask: "___-____"
  },
  {
    name: "Nepal",
    code: "+977",
    prefix: null,
    iso: "NP",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/np.svg",
    mask: "__-___-___"
  },
  {
    name: "Netherlands",
    code: "+31",
    prefix: null,
    iso: "NL",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/nl.svg",
    mask: "__-___-____"
  },
  {
    name: "New Caledonia",
    code: "+687",
    prefix: null,
    iso: "NC",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/nc.svg",
    mask: "__-____"
  },
  {
    name: "New Zealand",
    code: "+64",
    prefix: null,
    iso: "NZ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/nz.svg",
    mask: "(___)___-____"
  },
  {
    name: "Nicaragua",
    code: "+505",
    prefix: null,
    iso: "NI",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ni.svg",
    mask: "____-____"
  },
  {
    name: "Niger",
    code: "+227",
    prefix: null,
    iso: "NE",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ne.svg",
    mask: "__-__-____"
  },
  {
    name: "Nigeria",
    code: "+234",
    prefix: null,
    iso: "NG",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ng.svg",
    mask: "(___)___-____"
  },
  {
    name: "Niue",
    code: "+683",
    prefix: null,
    iso: "NU",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/nu.svg",
    mask: "____"
  },
  {
    name: "Norfolk Island",
    code: "+672",
    prefix: "3",
    iso: "NF",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/nf.svg",
    mask: "3__-___"
  },
  {
    name: "North Macedonia",
    code: "+389",
    prefix: null,
    iso: "MK",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/mk.svg",
    mask: "__-___-___"
  },
  {
    name: "Northern Mariana Islands",
    code: "+1",
    prefix: "670",
    iso: "MP",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/mp.svg",
    mask: "(670)___-____"
  },
  {
    name: "Norway",
    code: "+47",
    prefix: null,
    iso: "NO",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/no.svg",
    mask: "(___)__-___"
  },
  {
    name: "Oman",
    code: "+968",
    prefix: null,
    iso: "OM",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/om.svg",
    mask: "__-___-___"
  },
  {
    name: "Pakistan",
    code: "+92",
    prefix: null,
    iso: "PK",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/pk.svg",
    mask: "(___)___-____"
  },
  {
    name: "Palau",
    code: "+680",
    prefix: null,
    iso: "PW",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/pw.svg",
    mask: "___-____"
  },
  {
    name: "Palestine",
    code: "+970",
    prefix: null,
    iso: "PS",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ps.svg",
    mask: "__-___-____"
  },
  {
    name: "Panama",
    code: "+507",
    prefix: null,
    iso: "PA",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/pa.svg",
    mask: "___-____"
  },
  {
    name: "Papua New Guinea",
    code: "+675",
    prefix: null,
    iso: "PG",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/pg.svg",
    mask: "(___)__-___"
  },
  {
    name: "Paraguay",
    code: "+595",
    prefix: null,
    iso: "PY",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/py.svg",
    mask: "(___)___-___"
  },
  {
    name: "Peru",
    code: "+51",
    prefix: null,
    iso: "PE",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/pe.svg",
    mask: "(___)___-___"
  },
  {
    name: "Philippines",
    code: "+63",
    prefix: null,
    iso: "PH",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ph.svg",
    mask: "(___)___-____"
  },
  {
    name: "Pitcairn",
    code: "+870",
    prefix: null,
    iso: "PN",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/pn.svg",
    mask: "___-___-___"
  },
  {
    name: "Poland",
    code: "+48",
    prefix: null,
    iso: "PL",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/pl.svg",
    mask: "(___)___-___"
  },
  {
    name: "Portugal",
    code: "+351",
    prefix: null,
    iso: "PT",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/pt.svg",
    mask: "__-___-____"
  },
  {
    name: "Puerto Rico",
    code: "+1",
    prefix: null,
    iso: "PR",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/pr.svg",
    mask: "(___) ___ ____"
  },
  {
    name: "Qatar",
    code: "+974",
    prefix: null,
    iso: "QA",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/qa.svg",
    mask: "____-____"
  },
  {
    name: "Reunion",
    code: "+262",
    prefix: null,
    iso: "RE",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/re.svg",
    mask: "_____-____"
  },
  {
    name: "Romania",
    code: "+40",
    prefix: null,
    iso: "RO",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ro.svg",
    mask: "__-___-____"
  },
  {
    name: "Russia",
    code: "+7",
    prefix: null,
    iso: "RU",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ru.svg",
    mask: "(___)___-__-__"
  },
  {
    name: "Rwanda",
    code: "+250",
    prefix: null,
    iso: "RW",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/rw.svg",
    mask: "(___)___-___"
  },
  {
    name: "Saint Barthelemy",
    code: "+590",
    prefix: null,
    iso: "BL",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/bl.svg",
    mask: "___-__-__-__"
  },
  {
    name: "Saint Helena, Ascension and Tristan Da Cunha",
    code: "+290",
    prefix: null,
    iso: "SH",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/sh.svg",
    mask: "____"
  },
  {
    name: "Saint Kitts and Nevis",
    code: "+1",
    prefix: null,
    iso: "KN",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/kn.svg",
    mask: "(869)___-____"
  },
  {
    name: "Saint Lucia",
    code: "+1",
    prefix: "758",
    iso: "LC",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/lc.svg",
    mask: "(758)___-____"
  },
  {
    name: "Saint Martin",
    code: "+590",
    prefix: null,
    iso: "MF",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/mf.svg",
    mask: "(___)___-___"
  },
  {
    name: "Saint Pierre and Miquelon",
    code: "+508",
    prefix: null,
    iso: "PM",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/pm.svg",
    mask: "__-____"
  },
  {
    name: "Saint Vincent and the Grenadines",
    code: "+1",
    prefix: "784",
    iso: "VC",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/vc.svg",
    mask: "(784)___-____"
  },
  {
    name: "Samoa",
    code: "+685",
    prefix: null,
    iso: "WS",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ws.svg",
    mask: "__-____"
  },
  {
    name: "San Marino",
    code: "+378",
    prefix: null,
    iso: "SM",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/sm.svg",
    mask: "____-______"
  },
  {
    name: "Sao Tome and Principe",
    code: "+239",
    prefix: null,
    iso: "ST",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/st.svg",
    mask: "__-_____"
  },
  {
    name: "Saudi Arabia",
    code: "+966",
    prefix: null,
    iso: "SA",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/sa.svg",
    mask: "_-____-____"
  },
  {
    name: "Senegal",
    code: "+221",
    prefix: null,
    iso: "SN",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/sn.svg",
    mask: "__-___-____"
  },
  {
    name: "Serbia",
    code: "+381",
    prefix: null,
    iso: "RS",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/rs.svg",
    mask: "__-___-____"
  },
  {
    name: "Seychelles",
    code: "+248",
    prefix: null,
    iso: "SC",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/sc.svg",
    mask: "_-___-___"
  },
  {
    name: "Sierra Leone",
    code: "+232",
    prefix: null,
    iso: "SL",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/sl.svg",
    mask: "__-______"
  },
  {
    name: "Singapore",
    code: "+65",
    prefix: null,
    iso: "SG",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/sg.svg",
    mask: "____-____"
  },
  {
    name: "Sint Maarten",
    code: "+1",
    prefix: "721",
    iso: "SX",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/sx.svg",
    mask: "(721)___-____"
  },
  {
    name: "Slovakia",
    code: "+421",
    prefix: null,
    iso: "SK",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/sk.svg",
    mask: "(___)___-___"
  },
  {
    name: "Slovenia",
    code: "+386",
    prefix: null,
    iso: "SI",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/si.svg",
    mask: "__-___-___"
  },
  {
    name: "Solomon Islands",
    code: "+677",
    prefix: null,
    iso: "SB",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/sb.svg",
    mask: "___-____"
  },
  {
    name: "Somalia",
    code: "+252",
    prefix: null,
    iso: "SO",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/so.svg",
    mask: "__-___-___"
  },
  {
    name: "South Africa",
    code: "+27",
    prefix: null,
    iso: "ZA",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/za.svg",
    mask: "__-___-____"
  },
  {
    name: "South Georgia and the South Sandwich Islands",
    code: "+500",
    prefix: null,
    iso: "GS",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/gs.svg",
    mask: "_____"
  },
  {
    name: "South Sudan",
    code: "+211",
    prefix: null,
    iso: "SS",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ss.svg",
    mask: "__-___-____"
  },
  {
    name: "Spain",
    code: "+34",
    prefix: null,
    iso: "ES",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/es.svg",
    mask: "(___)___-___"
  },
  {
    name: "Sri Lanka",
    code: "+94",
    prefix: null,
    iso: "LK",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/lk.svg",
    mask: "__-___-____"
  },
  {
    name: "Sudan",
    code: "+249",
    prefix: null,
    iso: "SD",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/sd.svg",
    mask: "__-___-____"
  },
  {
    name: "Suriname",
    code: "+597",
    prefix: null,
    iso: "SR",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/sr.svg",
    mask: "___-____"
  },
  {
    name: "Svalbard and Jan Mayen",
    code: "+47",
    prefix: null,
    iso: "SJ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/sj.svg",
    mask: "(___)__-___"
  },
  {
    name: "Sweden",
    code: "+46",
    prefix: null,
    iso: "SE",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/se.svg",
    mask: "__-___-____"
  },
  {
    name: "Switzerland",
    code: "+41",
    prefix: null,
    iso: "CH",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ch.svg",
    mask: "__-___-____"
  },
  {
    name: "Syrian Arab Republic",
    code: "+963",
    prefix: null,
    iso: "SY",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/sy.svg",
    mask: "__-____-___"
  },
  {
    name: "Taiwan",
    code: "+886",
    prefix: null,
    iso: "TW",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/tw.svg",
    mask: "_-____-____"
  },
  {
    name: "Tajikistan",
    code: "+992",
    prefix: null,
    iso: "TJ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/tj.svg",
    mask: "__-___-____"
  },
  {
    name: "United Republic of Tanzania",
    code: "+255",
    prefix: null,
    iso: "TZ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/tz.svg",
    mask: "__-___-____"
  },
  {
    name: "Thailand",
    code: "+66",
    prefix: null,
    iso: "TH",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/th.svg",
    mask: "__-___-____"
  },
  {
    name: "Timor-Leste",
    code: "+670",
    prefix: null,
    iso: "TL",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/tl.svg",
    mask: "___-_____"
  },
  {
    name: "Togo",
    code: "+228",
    prefix: null,
    iso: "TG",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/tg.svg",
    mask: "__-___-___"
  },
  {
    name: "Tokelau",
    code: "+690",
    prefix: null,
    iso: "TK",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/tk.svg",
    mask: "____"
  },
  {
    name: "Tonga",
    code: "+676",
    prefix: null,
    iso: "TO",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/to.svg",
    mask: "_____"
  },
  {
    name: "Trinidad and Tobago",
    code: "+1",
    prefix: "868",
    iso: "TT",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/tt.svg",
    mask: "(868)___-____"
  },
  {
    name: "Tunisia",
    code: "+216",
    prefix: null,
    iso: "TN",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/tn.svg",
    mask: "__-___-___"
  },
  {
    name: "Turkey",
    code: "+90",
    prefix: null,
    iso: "TR",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/tr.svg",
    mask: "(___)___-____"
  },
  {
    name: "Turkmenistan",
    code: "+993",
    prefix: null,
    iso: "TM",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/tm.svg",
    mask: "_-___-____"
  },
  {
    name: "Turks and Caicos Islands",
    code: "+1",
    prefix: "249",
    iso: "TC",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/tc.svg",
    mask: "(249)___-___"
  },
  {
    name: "Tuvalu",
    code: "+688",
    prefix: null,
    iso: "TV",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/tv.svg",
    mask: "______"
  },
  {
    name: "Uganda",
    code: "+256",
    prefix: null,
    iso: "UG",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ug.svg",
    mask: "(___)___-___"
  },
  {
    name: "Ukraine",
    code: "+380",
    prefix: null,
    iso: "UA",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ua.svg",
    mask: "(__)___-__-__"
  },
  {
    name: "United Arab Emirates",
    code: "+971",
    prefix: null,
    iso: "AE",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ae.svg",
    mask: "_-___-____"
  },
  {
    name: "United Kingdom",
    code: "+44",
    prefix: null,
    iso: "GB",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/gb.svg",
    mask: "__-____-____"
  },
  {
    name: "United States",
    code: "+1",
    prefix: "408",
    iso: "US",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/us.svg",
    mask: "(408)___-____"
  },
  {
    name: "Uruguay",
    code: "+598",
    prefix: null,
    iso: "UY",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/uy.svg",
    mask: "_-___-__-__"
  },
  {
    name: "Uzbekistan",
    code: "+998",
    prefix: null,
    iso: "UZ",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/uz.svg",
    mask: "__-___-____"
  },
  {
    name: "Vanuatu",
    code: "+678",
    prefix: null,
    iso: "VU",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/vu.svg",
    mask: "__-_____"
  },
  {
    name: "Venezuela, Bolivarian Republic of Venezuela",
    code: "+58",
    prefix: null,
    iso: "VE",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ve.svg",
    mask: "(___)___-____"
  },
  {
    name: "Vietnam",
    code: "+84",
    prefix: null,
    iso: "VN",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/vn.svg",
    mask: "(___)____-___"
  },
  {
    name: "Virgin Islands, British",
    code: "+1",
    prefix: "284",
    iso: "VG",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/vg.svg",
    mask: "(284)___-____"
  },
  {
    name: "Virgin Islands, U.S.",
    code: "+1",
    prefix: "340",
    iso: "VI",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/vi.svg",
    mask: "(340)___-____"
  },
  {
    name: "Wallis and Futuna",
    code: "+681",
    prefix: null,
    iso: "WF",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/wf.svg",
    mask: "__-____"
  },
  {
    name: "Yemen",
    code: "+967",
    prefix: null,
    iso: "YE",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/ye.svg",
    mask: "___-___-___"
  },
  {
    name: "Zambia",
    code: "+260",
    prefix: null,
    iso: "ZM",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/zm.svg",
    mask: "__-___-____"
  },
  {
    name: "Zimbabwe",
    code: "+263",
    prefix: null,
    iso: "ZW",
    flag: "https://cdn.kcak11.com/CountryFlags/countries/zw.svg",
    mask: "_-______"
  }
];
function IXe(e) {
  const {
    children: t,
    onFocus: n,
    disabled: r,
    isError: o,
    isLoading: i,
    isFocused: a,
    className: s = "",
    readOnly: l,
    variant: u,
    size: c,
    id: p
  } = e, m = `arkynPhoneInputContainer ${u} ${c} ${r || l || i ? "opacity" : ""} ${o ? "errored" : ""} ${a ? "focused" : ""} ${s}`;
  return /* @__PURE__ */ ee.jsx("section", { id: p, className: m.trim(), onClick: n, children: t });
}
function NXe(e) {
  const { isOpen: t, onClick: n } = e;
  return t ? /* @__PURE__ */ ee.jsx("aside", { className: "arkynPhoneInputCountriesOverlay", onClick: n }) : /* @__PURE__ */ ee.jsx(ee.Fragment, {});
}
function BXe(e) {
  const { country: t, isActive: n, handleChangeValue: r, size: o } = e, a = `arkynPhoneInputCountryOption ${o} ${n ? "active" : ""}`;
  return /* @__PURE__ */ ee.jsxs("div", { onClick: () => r(t), className: a, children: [
    /* @__PURE__ */ ee.jsx("img", { src: t.flag, alt: t.name, className: "flag" }),
    t.name,
    " ",
    /* @__PURE__ */ ee.jsx("span", { children: t.code }),
    /* @__PURE__ */ ee.jsx(l0, { className: "check" })
  ] });
}
function FXe(e) {
  const { children: t, isOpen: n, onSearch: r, search: o, placeholder: i } = e;
  function a(s) {
    r(s.target.value);
  }
  return n ? /* @__PURE__ */ ee.jsxs("div", { className: "arkynPhoneInputCountryOptionsContainer", children: [
    /* @__PURE__ */ ee.jsx(
      "input",
      {
        type: "search",
        name: "search-select",
        className: "arkynPhoneInputCountryOptionsContainerSearchSelect",
        value: o,
        id: "input-search",
        placeholder: i,
        onChange: a
      }
    ),
    t
  ] }) : /* @__PURE__ */ ee.jsx(ee.Fragment, {});
}
function zXe(e) {
  const { currentCountry: t, onClick: n } = e;
  return /* @__PURE__ */ ee.jsxs("div", { className: "phoneInputSelectCountry", onClick: n, children: [
    /* @__PURE__ */ ee.jsx(
      "img",
      {
        className: "flag",
        src: t.flag,
        alt: t.name
      }
    ),
    /* @__PURE__ */ ee.jsx(GP, { className: "chevronDown", strokeWidth: 2.5 }),
    /* @__PURE__ */ ee.jsx(sK, { orientation: "vertical" })
  ] });
}
function gj(e) {
  return e && e.replace(/[^0-9]/g, "");
}
const mj = {
  EIGTH: "(99) 9999-9999",
  NINE: "(99) 99999-9999"
};
function iie(e, t) {
  let n = "", r = 0;
  for (let o = 0; o < t.length; o++)
    if (t[o] === "9")
      if (r < e.length)
        n += e[r], r++;
      else
        break;
    else if (r < e.length)
      n += t[o];
    else
      break;
  return n;
}
function sie(e) {
  return e.length > 10 ? "NINE" : "EIGTH";
}
const aie = gj(mj.NINE).length, UXe = Cr((e, t) => /* @__PURE__ */ ee.jsx("input", { ref: t, ...e })), HXe = Cr(
  (e, t) => {
    const { onFocus: n, onBlur: r, size: o, onChange: i, value: a, currentCountry: s, disabled: l } = e, [u, c] = k(!1);
    h(() => {
      u ? i(s.mask) : c(!0);
    }, [s]);
    const p = `phoneInputMask ${o}`;
    function d(g) {
      let f = gj(g.target.value);
      const m = sie(f);
      f.length > aie || (f = iie(f, mj[m]), g.target.value = f, i(f));
    }
    return s.code === "+55" ? /* @__PURE__ */ ee.jsx(
      "input",
      {
        value: a,
        onChange: d,
        className: p,
        onFocus: n,
        onBlur: r,
        disabled: l,
        ref: t
      }
    ) : /* @__PURE__ */ ee.jsx(
      ol,
      {
        value: a,
        onChange: (g) => i(g.target.value),
        className: p,
        component: UXe,
        onFocus: n,
        onBlur: r,
        disabled: l,
        mask: s.mask,
        showMask: !0,
        replacement: { _: /\d/ },
        ref: t
      }
    );
  }
);
function NZ(e, t) {
  if (t.code === "+55") {
    let o = gj(e);
    const i = sie(o);
    return o.length > aie ? void 0 : (o = iie(o, mj[i]), o);
  }
  let r = t.mask;
  if (t.prefix) {
    const o = /\$+/g;
    r = r.replace(o, t.prefix);
  }
  for (let o = 0, i = 0; o < r.length && i < e.length; o++)
    r[o] === "_" && (r = r.substring(0, o) + e[i] + r.substring(o + 1), i++);
  return r;
}
function WXe(e, t) {
  const n = lp.find(
    (r) => r.code === e && r.prefix === t
  );
  return n || null;
}
function $Xe(e) {
  const t = lp.find((n) => n.code === e);
  return t || null;
}
function VXe(e) {
  const t = e.split(" ")[0].split("-")[0], n = e.split(" ")[0].split("-")[1], r = e.split(" ")[1];
  if (!t || !r)
    return { country: null, formattedNumber: "" };
  if (n) {
    const s = WXe(t, n);
    if (!s) return { country: null, formattedNumber: "" };
    const l = NZ(r, s);
    return { country: s, formattedNumber: l };
  }
  const o = $Xe(t);
  if (!o) return { country: null, formattedNumber: "" };
  const i = NZ(r, o);
  return { country: o, formattedNumber: i };
}
function Bit(e) {
  const {
    defaultCountry: t,
    className: n = "",
    disabled: r = !1,
    isError: o = !1,
    isLoading: i = !1,
    readOnly: a = !1,
    size: s = "md",
    defaultValue: l = "",
    variant: u = "solid",
    name: c,
    onChange: p,
    searchCountryPlaceholder: d = "Pesquisar país",
    notFoundCountryText: g = "Nenhum país encontrado",
    ...f
  } = e, m = VXe(l), [b, E] = k(!1), [w, M] = k(""), [x, v] = k(!1), [C, P] = k(m.formattedNumber || ""), [F, L] = k(() => {
    if (m.country) return m.country;
    const S = lp.find((W) => W.iso === t);
    return S || lp[30];
  }), { id: B, inputRef: N, error: $ } = Fi(), V = o || !!$, H = dt(null);
  function Z() {
    b || x || (E(!0), H.current && H.current.focus());
  }
  function K() {
    v(!0), E(!0);
  }
  function Y() {
    v(!1), E(!1);
  }
  function Q() {
    E(!0);
  }
  function J() {
    E(!1);
  }
  function _(S) {
    return S.name.toLowerCase().includes(w.toLowerCase());
  }
  function D(S) {
    return F.prefix ? S.replace(F.prefix, "").replaceAll(" ", "").replaceAll("-", "").replaceAll("(", "").replaceAll(")", "").trim() : S.replaceAll(" ", "").replaceAll("-", "").replaceAll("(", "").replaceAll(")", "").trim();
  }
  function z(S) {
    let W = F.code;
    return F.prefix && (W += `-${F.prefix}`), W += " ", W += D(S || C), W;
  }
  return /* @__PURE__ */ ee.jsxs(
    IXe,
    {
      id: B,
      disabled: r,
      isError: V,
      isLoading: i,
      isFocused: b,
      readOnly: a,
      size: s,
      variant: u,
      className: n,
      onFocus: Z,
      children: [
        /* @__PURE__ */ ee.jsx(
          zXe,
          {
            currentCountry: F,
            onClick: K,
            size: s
          }
        ),
        /* @__PURE__ */ ee.jsxs(
          FXe,
          {
            isOpen: x,
            search: w,
            placeholder: d,
            onSearch: M,
            children: [
              lp.filter((S) => _(S)).map((S) => /* @__PURE__ */ ee.jsx(
                BXe,
                {
                  country: S,
                  handleChangeValue: () => {
                    L(S), v(!1), P(S.mask);
                  },
                  isActive: S.iso === F.iso,
                  size: s
                },
                S.iso
              )),
              lp.filter((S) => _(S)).length === 0 && /* @__PURE__ */ ee.jsx("p", { children: g })
            ]
          }
        ),
        /* @__PURE__ */ ee.jsx(
          NXe,
          {
            isOpen: x,
            onClick: Y
          }
        ),
        /* @__PURE__ */ ee.jsx(
          HXe,
          {
            ref: H,
            currentCountry: F,
            value: C,
            onChange: (S) => {
              P(S), p && p(z(S));
            },
            disabled: r,
            onBlur: J,
            onFocus: Q,
            size: s
          }
        ),
        /* @__PURE__ */ ee.jsx("input", { ref: N, type: "hidden", name: c, value: z() })
      ]
    }
  );
}
const lie = $e({});
function ZXe() {
  return ge(lie);
}
function Fit(e) {
  const {
    defaultValue: t,
    name: n,
    value: r,
    onChange: o,
    size: i = "md",
    className: a = "",
    ...s
  } = e, [l, u] = k(t || ""), { inputRef: c, id: p } = Fi();
  function d(f) {
    u(f), o && o(f);
  }
  const g = `arkynRadioGroup ${i} ${a}`;
  return /* @__PURE__ */ ee.jsxs(
    lie.Provider,
    {
      value: { onChange: d, value: r || l, size: i },
      children: [
        /* @__PURE__ */ ee.jsx(
          "input",
          {
            style: { display: "none" },
            type: "text",
            id: p,
            readOnly: !0,
            name: n,
            ref: c,
            value: r || l
          }
        ),
        /* @__PURE__ */ ee.jsx("div", { className: g.trim(), ...s })
      ]
    }
  );
}
function zit(e) {
  const {
    value: t,
    size: n,
    disabled: r,
    children: o,
    className: i = "",
    ...a
  } = e, { onChange: s, size: l, value: u } = ZXe(), { error: c } = Fi(), m = `arkynRadioBox ${n || l} ${u === t ? "checkedTrue" : "checkedFalse"} ${c ? "errorTrue" : "errorFalse"} ${r ? "disabledTrue" : "disabledFalse"} ${i}`;
  return /* @__PURE__ */ ee.jsxs("label", { className: m.trim(), children: [
    /* @__PURE__ */ ee.jsx(
      "button",
      {
        type: "button",
        disabled: r,
        onClick: () => s(t),
        onFocus: () => s(t),
        ...a
      }
    ),
    o
  ] });
}
var fl = {};
Object.defineProperty(fl, "__esModule", {
  value: !0
});
var qXe = typeof window < "u" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform), PL = {
  alt: "altKey",
  control: "ctrlKey",
  meta: "metaKey",
  shift: "shiftKey"
}, uie = {
  add: "+",
  break: "pause",
  cmd: "meta",
  command: "meta",
  ctl: "control",
  ctrl: "control",
  del: "delete",
  down: "arrowdown",
  esc: "escape",
  ins: "insert",
  left: "arrowleft",
  mod: qXe ? "meta" : "control",
  opt: "alt",
  option: "alt",
  return: "enter",
  right: "arrowright",
  space: " ",
  spacebar: " ",
  up: "arrowup",
  win: "meta",
  windows: "meta"
}, vj = {
  backspace: 8,
  tab: 9,
  enter: 13,
  shift: 16,
  control: 17,
  alt: 18,
  pause: 19,
  capslock: 20,
  escape: 27,
  " ": 32,
  pageup: 33,
  pagedown: 34,
  end: 35,
  home: 36,
  arrowleft: 37,
  arrowup: 38,
  arrowright: 39,
  arrowdown: 40,
  insert: 45,
  delete: 46,
  meta: 91,
  numlock: 144,
  scrolllock: 145,
  ";": 186,
  "=": 187,
  ",": 188,
  "-": 189,
  ".": 190,
  "/": 191,
  "`": 192,
  "[": 219,
  "\\": 220,
  "]": 221,
  "'": 222
};
for (var ay = 1; ay < 20; ay++)
  vj["f" + ay] = 111 + ay;
function ex(e, t, n) {
  t && !("byKey" in t) && (n = t, t = null), Array.isArray(e) || (e = [e]);
  var r = e.map(function(a) {
    return cie(a, t);
  }), o = function(s) {
    return r.some(function(l) {
      return pie(l, s);
    });
  }, i = n == null ? o : o(n);
  return i;
}
function GXe(e, t) {
  return ex(e, t);
}
function KXe(e, t) {
  return ex(e, { byKey: !0 }, t);
}
function cie(e, t) {
  var n = t && t.byKey, r = {};
  e = e.replace("++", "+add");
  var o = e.split("+"), i = o.length;
  for (var a in PL)
    r[PL[a]] = !1;
  var s = !0, l = !1, u = void 0;
  try {
    for (var c = o[Symbol.iterator](), p; !(s = (p = c.next()).done); s = !0) {
      var d = p.value, g = d.endsWith("?") && d.length > 1;
      g && (d = d.slice(0, -1));
      var f = yj(d), m = PL[f];
      if (d.length > 1 && !m && !uie[d] && !vj[f])
        throw new TypeError('Unknown modifier: "' + d + '"');
      (i === 1 || !m) && (n ? r.key = f : r.which = die(d)), m && (r[m] = g ? null : !0);
    }
  } catch (b) {
    l = !0, u = b;
  } finally {
    try {
      !s && c.return && c.return();
    } finally {
      if (l)
        throw u;
    }
  }
  return r;
}
function pie(e, t) {
  for (var n in e) {
    var r = e[n], o = void 0;
    if (r != null && (n === "key" && t.key != null ? o = t.key.toLowerCase() : n === "which" ? o = r === 91 && t.which === 93 ? 91 : t.which : o = t[n], !(o == null && r === !1) && o !== r))
      return !1;
  }
  return !0;
}
function die(e) {
  e = yj(e);
  var t = vj[e] || e.toUpperCase().charCodeAt(0);
  return t;
}
function yj(e) {
  return e = e.toLowerCase(), e = uie[e] || e, e;
}
var XXe = fl.default = ex, SL = fl.isHotkey = ex;
fl.isCodeHotkey = GXe;
fl.isKeyHotkey = KXe;
fl.parseHotkey = cie;
fl.compareHotkey = pie;
fl.toKeyCode = die;
fl.toKeyName = yj;
var YXe = {
  /**
   * Check if a value is a `History` object.
   */
  isHistory(e) {
    return Xo(e) && Array.isArray(e.redos) && Array.isArray(e.undos) && (e.redos.length === 0 || ru.isOperationList(e.redos[0].operations)) && (e.undos.length === 0 || ru.isOperationList(e.undos[0].operations));
  }
}, ML = /* @__PURE__ */ new WeakMap(), Bd = /* @__PURE__ */ new WeakMap(), wc = {
  /**
   * Check if a value is a `HistoryEditor` object.
   */
  isHistoryEditor(e) {
    return YXe.isHistory(e.history) && te.isEditor(e);
  },
  /**
   * Get the merge flag's current value.
   */
  isMerging(e) {
    return Bd.get(e);
  },
  /**
   * Get the saving flag's current value.
   */
  isSaving(e) {
    return ML.get(e);
  },
  /**
   * Redo to the previous saved state.
   */
  redo(e) {
    e.redo();
  },
  /**
   * Undo to the previous saved state.
   */
  undo(e) {
    e.undo();
  },
  /**
   * Apply a series of changes inside a synchronous `fn`, These operations will
   * be merged into the previous history.
   */
  withMerging(e, t) {
    var n = wc.isMerging(e);
    Bd.set(e, !0), t(), Bd.set(e, n);
  },
  /**
   * Apply a series of changes inside a synchronous `fn`, without merging any of
   * the new operations into previous save point in the history.
   */
  withoutMerging(e, t) {
    var n = wc.isMerging(e);
    Bd.set(e, !1), t(), Bd.set(e, n);
  },
  /**
   * Apply a series of changes inside a synchronous `fn`, without saving any of
   * their operations into the history.
   */
  withoutSaving(e, t) {
    var n = wc.isSaving(e);
    ML.set(e, !1), t(), ML.set(e, n);
  }
}, JXe = (e) => {
  var t = e, {
    apply: n
  } = t;
  return t.history = {
    undos: [],
    redos: []
  }, t.redo = () => {
    var {
      history: r
    } = t, {
      redos: o
    } = r;
    if (o.length > 0) {
      var i = o[o.length - 1];
      i.selectionBefore && Be.setSelection(t, i.selectionBefore), wc.withoutSaving(t, () => {
        te.withoutNormalizing(t, () => {
          for (var a of i.operations)
            t.apply(a);
        });
      }), r.redos.pop(), t.writeHistory("undos", i);
    }
  }, t.undo = () => {
    var {
      history: r
    } = t, {
      undos: o
    } = r;
    if (o.length > 0) {
      var i = o[o.length - 1];
      wc.withoutSaving(t, () => {
        te.withoutNormalizing(t, () => {
          var a = i.operations.map(ru.inverse).reverse();
          for (var s of a)
            t.apply(s);
          i.selectionBefore && Be.setSelection(t, i.selectionBefore);
        });
      }), t.writeHistory("redos", i), r.undos.pop();
    }
  }, t.apply = (r) => {
    var {
      operations: o,
      history: i
    } = t, {
      undos: a
    } = i, s = a[a.length - 1], l = s && s.operations[s.operations.length - 1], u = wc.isSaving(t), c = wc.isMerging(t);
    if (u == null && (u = eYe(r)), u) {
      if (c == null && (s == null ? c = !1 : o.length !== 0 ? c = !0 : c = QXe(r, l)), s && c)
        s.operations.push(r);
      else {
        var p = {
          operations: [r],
          selectionBefore: t.selection
        };
        t.writeHistory("undos", p);
      }
      for (; a.length > 100; )
        a.shift();
      i.redos = [];
    }
    n(r);
  }, t.writeHistory = (r, o) => {
    t.history[r].push(o);
  }, t;
}, QXe = (e, t) => !!(t && e.type === "insert_text" && t.type === "insert_text" && e.offset === t.offset + t.text.length && ce.equals(e.path, t.path) || t && e.type === "remove_text" && t.type === "remove_text" && e.offset + e.text.length === t.offset && ce.equals(e.path, t.path)), eYe = (e, t) => e.type !== "set_selection", tYe = oYe, fie = "֑-߿יִ-﷽ﹰ-ﻼ", hie = "A-Za-zÀ-ÖØ-öø-ʸ̀-֐ࠀ-῿‎Ⰰ-﬜︀-﹯﻽-￿", nYe = new RegExp("^[^" + hie + "]*[" + fie + "]"), rYe = new RegExp("^[^" + fie + "]*[" + hie + "]");
function oYe(e) {
  return e = String(e || ""), nYe.test(e) ? "rtl" : rYe.test(e) ? "ltr" : "neutral";
}
const gie = /* @__PURE__ */ u0(tYe);
function iYe(e) {
  var t = typeof e;
  return e != null && (t == "object" || t == "function");
}
var bj = iYe, sYe = typeof fr == "object" && fr && fr.Object === Object && fr, aYe = sYe, lYe = aYe, uYe = typeof self == "object" && self && self.Object === Object && self, cYe = lYe || uYe || Function("return this")(), mie = cYe, pYe = mie, dYe = function() {
  return pYe.Date.now();
}, fYe = dYe, hYe = /\s/;
function gYe(e) {
  for (var t = e.length; t-- && hYe.test(e.charAt(t)); )
    ;
  return t;
}
var mYe = gYe, vYe = mYe, yYe = /^\s+/;
function bYe(e) {
  return e && e.slice(0, vYe(e) + 1).replace(yYe, "");
}
var wYe = bYe, CYe = mie, OYe = CYe.Symbol, vie = OYe, BZ = vie, yie = Object.prototype, xYe = yie.hasOwnProperty, EYe = yie.toString, Fd = BZ ? BZ.toStringTag : void 0;
function kYe(e) {
  var t = xYe.call(e, Fd), n = e[Fd];
  try {
    e[Fd] = void 0;
    var r = !0;
  } catch {
  }
  var o = EYe.call(e);
  return r && (t ? e[Fd] = n : delete e[Fd]), o;
}
var LYe = kYe, _Ye = Object.prototype, PYe = _Ye.toString;
function SYe(e) {
  return PYe.call(e);
}
var MYe = SYe, FZ = vie, DYe = LYe, TYe = MYe, jYe = "[object Null]", AYe = "[object Undefined]", zZ = FZ ? FZ.toStringTag : void 0;
function RYe(e) {
  return e == null ? e === void 0 ? AYe : jYe : zZ && zZ in Object(e) ? DYe(e) : TYe(e);
}
var IYe = RYe;
function NYe(e) {
  return e != null && typeof e == "object";
}
var BYe = NYe, FYe = IYe, zYe = BYe, UYe = "[object Symbol]";
function HYe(e) {
  return typeof e == "symbol" || zYe(e) && FYe(e) == UYe;
}
var WYe = HYe, $Ye = wYe, UZ = bj, VYe = WYe, HZ = NaN, ZYe = /^[-+]0x[0-9a-f]+$/i, qYe = /^0b[01]+$/i, GYe = /^0o[0-7]+$/i, KYe = parseInt;
function XYe(e) {
  if (typeof e == "number")
    return e;
  if (VYe(e))
    return HZ;
  if (UZ(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = UZ(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = $Ye(e);
  var n = qYe.test(e);
  return n || GYe.test(e) ? KYe(e.slice(2), n ? 2 : 8) : ZYe.test(e) ? HZ : +e;
}
var YYe = XYe, JYe = bj, DL = fYe, WZ = YYe, QYe = "Expected a function", eJe = Math.max, tJe = Math.min;
function nJe(e, t, n) {
  var r, o, i, a, s, l, u = 0, c = !1, p = !1, d = !0;
  if (typeof e != "function")
    throw new TypeError(QYe);
  t = WZ(t) || 0, JYe(n) && (c = !!n.leading, p = "maxWait" in n, i = p ? eJe(WZ(n.maxWait) || 0, t) : i, d = "trailing" in n ? !!n.trailing : d);
  function g(C) {
    var P = r, F = o;
    return r = o = void 0, u = C, a = e.apply(F, P), a;
  }
  function f(C) {
    return u = C, s = setTimeout(E, t), c ? g(C) : a;
  }
  function m(C) {
    var P = C - l, F = C - u, L = t - P;
    return p ? tJe(L, i - F) : L;
  }
  function b(C) {
    var P = C - l, F = C - u;
    return l === void 0 || P >= t || P < 0 || p && F >= i;
  }
  function E() {
    var C = DL();
    if (b(C))
      return w(C);
    s = setTimeout(E, m(C));
  }
  function w(C) {
    return s = void 0, d && r ? g(C) : (r = o = void 0, a);
  }
  function M() {
    s !== void 0 && clearTimeout(s), u = 0, r = l = o = s = void 0;
  }
  function x() {
    return s === void 0 ? a : w(DL());
  }
  function v() {
    var C = DL(), P = b(C);
    if (r = arguments, o = this, l = C, P) {
      if (s === void 0)
        return f(l);
      if (p)
        return clearTimeout(s), s = setTimeout(E, t), g(l);
    }
    return s === void 0 && (s = setTimeout(E, t)), a;
  }
  return v.cancel = M, v.flush = x, v;
}
var bie = nJe;
const rJe = /* @__PURE__ */ u0(bie);
var oJe = bie, iJe = bj, sJe = "Expected a function";
function aJe(e, t, n) {
  var r = !0, o = !0;
  if (typeof e != "function")
    throw new TypeError(sJe);
  return iJe(n) && (r = "leading" in n ? !!n.leading : r, o = "trailing" in n ? !!n.trailing : o), oJe(e, t, {
    leading: r,
    maxWait: t,
    trailing: o
  });
}
var lJe = aJe;
const uJe = /* @__PURE__ */ u0(lJe), $Z = (e) => typeof e == "object" && e != null && e.nodeType === 1, VZ = (e, t) => (!t || e !== "hidden") && e !== "visible" && e !== "clip", ly = (e, t) => {
  if (e.clientHeight < e.scrollHeight || e.clientWidth < e.scrollWidth) {
    const n = getComputedStyle(e, null);
    return VZ(n.overflowY, t) || VZ(n.overflowX, t) || ((r) => {
      const o = ((i) => {
        if (!i.ownerDocument || !i.ownerDocument.defaultView) return null;
        try {
          return i.ownerDocument.defaultView.frameElement;
        } catch {
          return null;
        }
      })(r);
      return !!o && (o.clientHeight < r.scrollHeight || o.clientWidth < r.scrollWidth);
    })(e);
  }
  return !1;
}, uy = (e, t, n, r, o, i, a, s) => i < e && a > t || i > e && a < t ? 0 : i <= e && s <= n || a >= t && s >= n ? i - e - r : a > t && s < n || i < e && s > n ? a - t + o : 0, cJe = (e) => {
  const t = e.parentElement;
  return t ?? (e.getRootNode().host || null);
}, ZZ = (e, t) => {
  var n, r, o, i;
  if (typeof document > "u") return [];
  const { scrollMode: a, block: s, inline: l, boundary: u, skipOverflowHiddenElements: c } = t, p = typeof u == "function" ? u : (K) => K !== u;
  if (!$Z(e)) throw new TypeError("Invalid target");
  const d = document.scrollingElement || document.documentElement, g = [];
  let f = e;
  for (; $Z(f) && p(f); ) {
    if (f = cJe(f), f === d) {
      g.push(f);
      break;
    }
    f != null && f === document.body && ly(f) && !ly(document.documentElement) || f != null && ly(f, c) && g.push(f);
  }
  const m = (r = (n = window.visualViewport) == null ? void 0 : n.width) != null ? r : innerWidth, b = (i = (o = window.visualViewport) == null ? void 0 : o.height) != null ? i : innerHeight, { scrollX: E, scrollY: w } = window, { height: M, width: x, top: v, right: C, bottom: P, left: F } = e.getBoundingClientRect(), { top: L, right: B, bottom: N, left: $ } = ((K) => {
    const Y = window.getComputedStyle(K);
    return { top: parseFloat(Y.scrollMarginTop) || 0, right: parseFloat(Y.scrollMarginRight) || 0, bottom: parseFloat(Y.scrollMarginBottom) || 0, left: parseFloat(Y.scrollMarginLeft) || 0 };
  })(e);
  let V = s === "start" || s === "nearest" ? v - L : s === "end" ? P + N : v + M / 2 - L + N, H = l === "center" ? F + x / 2 - $ + B : l === "end" ? C + B : F - $;
  const Z = [];
  for (let K = 0; K < g.length; K++) {
    const Y = g[K], { height: Q, width: J, top: _, right: D, bottom: z, left: S } = Y.getBoundingClientRect();
    if (a === "if-needed" && v >= 0 && F >= 0 && P <= b && C <= m && (Y === d && !ly(Y) || v >= _ && P <= z && F >= S && C <= D)) return Z;
    const W = getComputedStyle(Y), O = parseInt(W.borderLeftWidth, 10), j = parseInt(W.borderTopWidth, 10), U = parseInt(W.borderRightWidth, 10), T = parseInt(W.borderBottomWidth, 10);
    let q = 0, A = 0;
    const X = "offsetWidth" in Y ? Y.offsetWidth - Y.clientWidth - O - U : 0, I = "offsetHeight" in Y ? Y.offsetHeight - Y.clientHeight - j - T : 0, le = "offsetWidth" in Y ? Y.offsetWidth === 0 ? 0 : J / Y.offsetWidth : 0, he = "offsetHeight" in Y ? Y.offsetHeight === 0 ? 0 : Q / Y.offsetHeight : 0;
    if (d === Y) q = s === "start" ? V : s === "end" ? V - b : s === "nearest" ? uy(w, w + b, b, j, T, w + V, w + V + M, M) : V - b / 2, A = l === "start" ? H : l === "center" ? H - m / 2 : l === "end" ? H - m : uy(E, E + m, m, O, U, E + H, E + H + x, x), q = Math.max(0, q + w), A = Math.max(0, A + E);
    else {
      q = s === "start" ? V - _ - j : s === "end" ? V - z + T + I : s === "nearest" ? uy(_, z, Q, j, T + I, V, V + M, M) : V - (_ + Q / 2) + I / 2, A = l === "start" ? H - S - O : l === "center" ? H - (S + J / 2) + X / 2 : l === "end" ? H - D + U + X : uy(S, D, J, O, U + X, H, H + x, x);
      const { scrollLeft: oe, scrollTop: Ae } = Y;
      q = he === 0 ? 0 : Math.max(0, Math.min(Ae + q / he, Y.scrollHeight - Q / he + I)), A = le === 0 ? 0 : Math.max(0, Math.min(oe + A / le, Y.scrollWidth - J / le + X)), V += Ae - q, H += oe - A;
    }
    Z.push({ el: Y, top: q, left: A });
  }
  return Z;
}, pJe = (e) => e === !1 ? { block: "end", inline: "nearest" } : ((t) => t === Object(t) && Object.keys(t).length !== 0)(e) ? e : { block: "start", inline: "nearest" };
function dJe(e, t) {
  if (!e.isConnected || !((o) => {
    let i = o;
    for (; i && i.parentNode; ) {
      if (i.parentNode === document) return !0;
      i = i.parentNode instanceof ShadowRoot ? i.parentNode.host : i.parentNode;
    }
    return !1;
  })(e)) return;
  const n = ((o) => {
    const i = window.getComputedStyle(o);
    return { top: parseFloat(i.scrollMarginTop) || 0, right: parseFloat(i.scrollMarginRight) || 0, bottom: parseFloat(i.scrollMarginBottom) || 0, left: parseFloat(i.scrollMarginLeft) || 0 };
  })(e);
  if (((o) => typeof o == "object" && typeof o.behavior == "function")(t)) return t.behavior(ZZ(e, t));
  const r = typeof t == "boolean" || t == null ? void 0 : t.behavior;
  for (const { el: o, top: i, left: a } of ZZ(e, pJe(t))) {
    const s = i - n.top + n.bottom, l = a - n.left + n.right;
    o.scroll({ top: s, left: l, behavior: r });
  }
}
var Ec = [], fJe = function() {
  return Ec.some(function(e) {
    return e.activeTargets.length > 0;
  });
}, hJe = function() {
  return Ec.some(function(e) {
    return e.skippedTargets.length > 0;
  });
}, qZ = "ResizeObserver loop completed with undelivered notifications.", gJe = function() {
  var e;
  typeof ErrorEvent == "function" ? e = new ErrorEvent("error", {
    message: qZ
  }) : (e = document.createEvent("Event"), e.initEvent("error", !1, !1), e.message = qZ), window.dispatchEvent(e);
}, Hh;
(function(e) {
  e.BORDER_BOX = "border-box", e.CONTENT_BOX = "content-box", e.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(Hh || (Hh = {}));
var kc = function(e) {
  return Object.freeze(e);
}, mJe = /* @__PURE__ */ function() {
  function e(t, n) {
    this.inlineSize = t, this.blockSize = n, kc(this);
  }
  return e;
}(), wie = function() {
  function e(t, n, r, o) {
    return this.x = t, this.y = n, this.width = r, this.height = o, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, kc(this);
  }
  return e.prototype.toJSON = function() {
    var t = this, n = t.x, r = t.y, o = t.top, i = t.right, a = t.bottom, s = t.left, l = t.width, u = t.height;
    return { x: n, y: r, top: o, right: i, bottom: a, left: s, width: l, height: u };
  }, e.fromRect = function(t) {
    return new e(t.x, t.y, t.width, t.height);
  }, e;
}(), wj = function(e) {
  return e instanceof SVGElement && "getBBox" in e;
}, Cie = function(e) {
  if (wj(e)) {
    var t = e.getBBox(), n = t.width, r = t.height;
    return !n && !r;
  }
  var o = e, i = o.offsetWidth, a = o.offsetHeight;
  return !(i || a || e.getClientRects().length);
}, GZ = function(e) {
  var t;
  if (e instanceof Element)
    return !0;
  var n = (t = e == null ? void 0 : e.ownerDocument) === null || t === void 0 ? void 0 : t.defaultView;
  return !!(n && e instanceof n.Element);
}, vJe = function(e) {
  switch (e.tagName) {
    case "INPUT":
      if (e.type !== "image")
        break;
    case "VIDEO":
    case "AUDIO":
    case "EMBED":
    case "OBJECT":
    case "CANVAS":
    case "IFRAME":
    case "IMG":
      return !0;
  }
  return !1;
}, If = typeof window < "u" ? window : {}, cy = /* @__PURE__ */ new WeakMap(), KZ = /auto|scroll/, yJe = /^tb|vertical/, bJe = /msie|trident/i.test(If.navigator && If.navigator.userAgent), Qs = function(e) {
  return parseFloat(e || "0");
}, vp = function(e, t, n) {
  return e === void 0 && (e = 0), t === void 0 && (t = 0), n === void 0 && (n = !1), new mJe((n ? t : e) || 0, (n ? e : t) || 0);
}, XZ = kc({
  devicePixelContentBoxSize: vp(),
  borderBoxSize: vp(),
  contentBoxSize: vp(),
  contentRect: new wie(0, 0, 0, 0)
}), Oie = function(e, t) {
  if (t === void 0 && (t = !1), cy.has(e) && !t)
    return cy.get(e);
  if (Cie(e))
    return cy.set(e, XZ), XZ;
  var n = getComputedStyle(e), r = wj(e) && e.ownerSVGElement && e.getBBox(), o = !bJe && n.boxSizing === "border-box", i = yJe.test(n.writingMode || ""), a = !r && KZ.test(n.overflowY || ""), s = !r && KZ.test(n.overflowX || ""), l = r ? 0 : Qs(n.paddingTop), u = r ? 0 : Qs(n.paddingRight), c = r ? 0 : Qs(n.paddingBottom), p = r ? 0 : Qs(n.paddingLeft), d = r ? 0 : Qs(n.borderTopWidth), g = r ? 0 : Qs(n.borderRightWidth), f = r ? 0 : Qs(n.borderBottomWidth), m = r ? 0 : Qs(n.borderLeftWidth), b = p + u, E = l + c, w = m + g, M = d + f, x = s ? e.offsetHeight - M - e.clientHeight : 0, v = a ? e.offsetWidth - w - e.clientWidth : 0, C = o ? b + w : 0, P = o ? E + M : 0, F = r ? r.width : Qs(n.width) - C - v, L = r ? r.height : Qs(n.height) - P - x, B = F + b + v + w, N = L + E + x + M, $ = kc({
    devicePixelContentBoxSize: vp(Math.round(F * devicePixelRatio), Math.round(L * devicePixelRatio), i),
    borderBoxSize: vp(B, N, i),
    contentBoxSize: vp(F, L, i),
    contentRect: new wie(p, l, F, L)
  });
  return cy.set(e, $), $;
}, xie = function(e, t, n) {
  var r = Oie(e, n), o = r.borderBoxSize, i = r.contentBoxSize, a = r.devicePixelContentBoxSize;
  switch (t) {
    case Hh.DEVICE_PIXEL_CONTENT_BOX:
      return a;
    case Hh.BORDER_BOX:
      return o;
    default:
      return i;
  }
}, wJe = /* @__PURE__ */ function() {
  function e(t) {
    var n = Oie(t);
    this.target = t, this.contentRect = n.contentRect, this.borderBoxSize = kc([n.borderBoxSize]), this.contentBoxSize = kc([n.contentBoxSize]), this.devicePixelContentBoxSize = kc([n.devicePixelContentBoxSize]);
  }
  return e;
}(), Eie = function(e) {
  if (Cie(e))
    return 1 / 0;
  for (var t = 0, n = e.parentNode; n; )
    t += 1, n = n.parentNode;
  return t;
}, CJe = function() {
  var e = 1 / 0, t = [];
  Ec.forEach(function(a) {
    if (a.activeTargets.length !== 0) {
      var s = [];
      a.activeTargets.forEach(function(u) {
        var c = new wJe(u.target), p = Eie(u.target);
        s.push(c), u.lastReportedSize = xie(u.target, u.observedBox), p < e && (e = p);
      }), t.push(function() {
        a.callback.call(a.observer, s, a.observer);
      }), a.activeTargets.splice(0, a.activeTargets.length);
    }
  });
  for (var n = 0, r = t; n < r.length; n++) {
    var o = r[n];
    o();
  }
  return e;
}, YZ = function(e) {
  Ec.forEach(function(n) {
    n.activeTargets.splice(0, n.activeTargets.length), n.skippedTargets.splice(0, n.skippedTargets.length), n.observationTargets.forEach(function(o) {
      o.isActive() && (Eie(o.target) > e ? n.activeTargets.push(o) : n.skippedTargets.push(o));
    });
  });
}, OJe = function() {
  var e = 0;
  for (YZ(e); fJe(); )
    e = CJe(), YZ(e);
  return hJe() && gJe(), e > 0;
}, TL, kie = [], xJe = function() {
  return kie.splice(0).forEach(function(e) {
    return e();
  });
}, EJe = function(e) {
  if (!TL) {
    var t = 0, n = document.createTextNode(""), r = { characterData: !0 };
    new MutationObserver(function() {
      return xJe();
    }).observe(n, r), TL = function() {
      n.textContent = "".concat(t ? t-- : t++);
    };
  }
  kie.push(e), TL();
}, kJe = function(e) {
  EJe(function() {
    requestAnimationFrame(e);
  });
}, jy = 0, LJe = function() {
  return !!jy;
}, _Je = 250, PJe = { attributes: !0, characterData: !0, childList: !0, subtree: !0 }, JZ = [
  "resize",
  "load",
  "transitionend",
  "animationend",
  "animationstart",
  "animationiteration",
  "keyup",
  "keydown",
  "mouseup",
  "mousedown",
  "mouseover",
  "mouseout",
  "blur",
  "focus"
], QZ = function(e) {
  return e === void 0 && (e = 0), Date.now() + e;
}, jL = !1, SJe = function() {
  function e() {
    var t = this;
    this.stopped = !0, this.listener = function() {
      return t.schedule();
    };
  }
  return e.prototype.run = function(t) {
    var n = this;
    if (t === void 0 && (t = _Je), !jL) {
      jL = !0;
      var r = QZ(t);
      kJe(function() {
        var o = !1;
        try {
          o = OJe();
        } finally {
          if (jL = !1, t = r - QZ(), !LJe())
            return;
          o ? n.run(1e3) : t > 0 ? n.run(t) : n.start();
        }
      });
    }
  }, e.prototype.schedule = function() {
    this.stop(), this.run();
  }, e.prototype.observe = function() {
    var t = this, n = function() {
      return t.observer && t.observer.observe(document.body, PJe);
    };
    document.body ? n() : If.addEventListener("DOMContentLoaded", n);
  }, e.prototype.start = function() {
    var t = this;
    this.stopped && (this.stopped = !1, this.observer = new MutationObserver(this.listener), this.observe(), JZ.forEach(function(n) {
      return If.addEventListener(n, t.listener, !0);
    }));
  }, e.prototype.stop = function() {
    var t = this;
    this.stopped || (this.observer && this.observer.disconnect(), JZ.forEach(function(n) {
      return If.removeEventListener(n, t.listener, !0);
    }), this.stopped = !0);
  }, e;
}(), MP = new SJe(), e7 = function(e) {
  !jy && e > 0 && MP.start(), jy += e, !jy && MP.stop();
}, MJe = function(e) {
  return !wj(e) && !vJe(e) && getComputedStyle(e).display === "inline";
}, DJe = function() {
  function e(t, n) {
    this.target = t, this.observedBox = n || Hh.CONTENT_BOX, this.lastReportedSize = {
      inlineSize: 0,
      blockSize: 0
    };
  }
  return e.prototype.isActive = function() {
    var t = xie(this.target, this.observedBox, !0);
    return MJe(this.target) && (this.lastReportedSize = t), this.lastReportedSize.inlineSize !== t.inlineSize || this.lastReportedSize.blockSize !== t.blockSize;
  }, e;
}(), TJe = /* @__PURE__ */ function() {
  function e(t, n) {
    this.activeTargets = [], this.skippedTargets = [], this.observationTargets = [], this.observer = t, this.callback = n;
  }
  return e;
}(), py = /* @__PURE__ */ new WeakMap(), t7 = function(e, t) {
  for (var n = 0; n < e.length; n += 1)
    if (e[n].target === t)
      return n;
  return -1;
}, dy = function() {
  function e() {
  }
  return e.connect = function(t, n) {
    var r = new TJe(t, n);
    py.set(t, r);
  }, e.observe = function(t, n, r) {
    var o = py.get(t), i = o.observationTargets.length === 0;
    t7(o.observationTargets, n) < 0 && (i && Ec.push(o), o.observationTargets.push(new DJe(n, r && r.box)), e7(1), MP.schedule());
  }, e.unobserve = function(t, n) {
    var r = py.get(t), o = t7(r.observationTargets, n), i = r.observationTargets.length === 1;
    o >= 0 && (i && Ec.splice(Ec.indexOf(r), 1), r.observationTargets.splice(o, 1), e7(-1));
  }, e.disconnect = function(t) {
    var n = this, r = py.get(t);
    r.observationTargets.slice().forEach(function(o) {
      return n.unobserve(t, o.target);
    }), r.activeTargets.splice(0, r.activeTargets.length);
  }, e;
}(), jJe = function() {
  function e(t) {
    if (arguments.length === 0)
      throw new TypeError("Failed to construct 'ResizeObserver': 1 argument required, but only 0 present.");
    if (typeof t != "function")
      throw new TypeError("Failed to construct 'ResizeObserver': The callback provided as parameter 1 is not a function.");
    dy.connect(this, t);
  }
  return e.prototype.observe = function(t, n) {
    if (arguments.length === 0)
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': 1 argument required, but only 0 present.");
    if (!GZ(t))
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': parameter 1 is not of type 'Element");
    dy.observe(this, t, n);
  }, e.prototype.unobserve = function(t) {
    if (arguments.length === 0)
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': 1 argument required, but only 0 present.");
    if (!GZ(t))
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': parameter 1 is not of type 'Element");
    dy.unobserve(this, t);
  }, e.prototype.disconnect = function() {
    dy.disconnect(this);
  }, e.toString = function() {
    return "function ResizeObserver () { [polyfill code] }";
  }, e;
}();
function AJe(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), o, i;
  for (i = 0; i < r.length; i++)
    o = r[i], !(t.indexOf(o) >= 0) && (n[o] = e[o]);
  return n;
}
function Pp(e, t) {
  if (e == null) return {};
  var n = AJe(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (o = 0; o < i.length; o++)
      r = i[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
function Wh(e) {
  "@babel/helpers - typeof";
  return Wh = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Wh(e);
}
function RJe(e, t) {
  if (Wh(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (Wh(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function IJe(e) {
  var t = RJe(e, "string");
  return Wh(t) === "symbol" ? t : String(t);
}
function Ws(e, t, n) {
  return t = IJe(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
var Cj = /* @__PURE__ */ $e(null), Du = () => {
  var e = ge(Cj);
  if (!e)
    throw new Error("The `useSlateStatic` hook must be used inside the <Slate> component's context.");
  return e;
}, AL, RL, Lie = parseInt(be.version.split(".")[0], 10), _ie = typeof navigator < "u" && typeof window < "u" && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream, n7 = typeof navigator < "u" && /Mac OS X/.test(navigator.userAgent), Si = typeof navigator < "u" && /Android/.test(navigator.userAgent), up = typeof navigator < "u" && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent), oc = typeof navigator < "u" && /AppleWebKit(?!.*Chrome)/i.test(navigator.userAgent), NJe = typeof navigator < "u" && /Edge?\/(?:[0-6][0-9]|[0-7][0-8])(?:\.)/i.test(navigator.userAgent), Pie = typeof navigator < "u" && /Chrome/i.test(navigator.userAgent), BJe = typeof navigator < "u" && /Chrome?\/(?:[0-7][0-5]|[0-6][0-9])(?:\.)/i.test(navigator.userAgent), FJe = Si && typeof navigator < "u" && /Chrome?\/(?:[0-5]?\d)(?:\.)/i.test(navigator.userAgent), zJe = typeof navigator < "u" && /^(?!.*Seamonkey)(?=.*Firefox\/(?:[0-7][0-9]|[0-8][0-6])(?:\.)).*/i.test(navigator.userAgent), UJe = typeof navigator < "u" && /.*UCBrowser/.test(navigator.userAgent), HJe = typeof navigator < "u" && /.*Wechat/.test(navigator.userAgent) && !/.*MacWechat/.test(navigator.userAgent), Ay = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u";
typeof navigator < "u" && /Safari/.test(navigator.userAgent) && /Version\/(\d+)/.test(navigator.userAgent) && ((AL = navigator.userAgent.match(/Version\/(\d+)/)) !== null && AL !== void 0 && AL[1] && parseInt((RL = navigator.userAgent.match(/Version\/(\d+)/)) === null || RL === void 0 ? void 0 : RL[1], 10) < 17);
var Pl = (!BJe || !FJe) && !NJe && // globalThis is undefined in older browsers
typeof globalThis < "u" && globalThis.InputEvent && // @ts-ignore The `getTargetRanges` property isn't recognized.
typeof globalThis.InputEvent.prototype.getTargetRanges == "function", yp = /* @__PURE__ */ new WeakMap(), Oj = /* @__PURE__ */ new WeakMap(), xj = /* @__PURE__ */ new WeakMap(), Sie = /* @__PURE__ */ new WeakMap(), Ry = /* @__PURE__ */ new WeakMap(), DP = /* @__PURE__ */ new WeakMap(), $h = /* @__PURE__ */ new WeakMap(), Lc = /* @__PURE__ */ new WeakMap(), Xw = /* @__PURE__ */ new WeakMap(), tx = /* @__PURE__ */ new WeakMap(), TP = /* @__PURE__ */ new WeakMap(), ou = /* @__PURE__ */ new WeakMap(), Cc = /* @__PURE__ */ new WeakMap(), Nf = /* @__PURE__ */ new WeakMap(), jP = /* @__PURE__ */ new WeakMap(), Ej = /* @__PURE__ */ new WeakMap(), $s = /* @__PURE__ */ new WeakMap(), Ga = /* @__PURE__ */ new WeakMap(), zi = /* @__PURE__ */ new WeakMap(), Zl = /* @__PURE__ */ new WeakMap(), ql = /* @__PURE__ */ new WeakMap(), Mie = /* @__PURE__ */ new WeakMap(), Sp = Symbol("placeholder"), Die = Symbol("mark-placeholder"), Tie = globalThis.Node, WJe = globalThis.Text, kj = (e) => e && e.ownerDocument && e.ownerDocument.defaultView || null, $Je = (e) => su(e) && e.nodeType === 8, Hs = (e) => su(e) && e.nodeType === 1, su = (e) => {
  var t = kj(e);
  return !!t && e instanceof t.Node;
}, AP = (e) => {
  var t = e && e.anchorNode && kj(e.anchorNode);
  return !!t && e instanceof t.Selection;
}, jie = (e) => su(e) && e.nodeType === 3, VJe = (e) => e.clipboardData && e.clipboardData.getData("text/plain") !== "" && e.clipboardData.types.length === 1, ZJe = (e) => {
  var [t, n] = e;
  if (Hs(t) && t.childNodes.length) {
    var r = n === t.childNodes.length, o = r ? n - 1 : n;
    for ([t, o] = Aie(t, o, r ? "backward" : "forward"), r = o < n; Hs(t) && t.childNodes.length; ) {
      var i = r ? t.childNodes.length - 1 : 0;
      t = GJe(t, i, r ? "backward" : "forward");
    }
    n = r && t.textContent != null ? t.textContent.length : 0;
  }
  return [t, n];
}, qJe = (e) => {
  for (var t = e && e.parentNode; t; ) {
    if (t.toString() === "[object ShadowRoot]")
      return !0;
    t = t.parentNode;
  }
  return !1;
}, Aie = (e, t, n) => {
  for (var {
    childNodes: r
  } = e, o = r[t], i = t, a = !1, s = !1; ($Je(o) || Hs(o) && o.childNodes.length === 0 || Hs(o) && o.getAttribute("contenteditable") === "false") && !(a && s); ) {
    if (i >= r.length) {
      a = !0, i = t - 1, n = "backward";
      continue;
    }
    if (i < 0) {
      s = !0, i = t + 1, n = "forward";
      continue;
    }
    o = r[i], t = i, i += n === "forward" ? 1 : -1;
  }
  return [o, t];
}, GJe = (e, t, n) => {
  var [r] = Aie(e, t, n);
  return r;
}, Rie = (e) => {
  var t = "";
  if (jie(e) && e.nodeValue)
    return e.nodeValue;
  if (Hs(e)) {
    for (var n of Array.from(e.childNodes))
      t += Rie(n);
    var r = getComputedStyle(e).getPropertyValue("display");
    (r === "block" || r === "list" || e.tagName === "BR") && (t += `
`);
  }
  return t;
}, KJe = /data-slate-fragment="(.+?)"/m, XJe = (e) => {
  var t = e.getData("text/html"), [, n] = t.match(KJe) || [];
  return n;
}, Bf = (e) => e.getSelection != null ? e.getSelection() : document.getSelection(), Lj = (e, t, n) => {
  var {
    target: r
  } = t;
  if (Hs(r) && r.matches('[contentEditable="false"]'))
    return !1;
  var {
    document: o
  } = xe.getWindow(e);
  if (o.contains(r))
    return xe.hasDOMNode(e, r, {
      editable: !0
    });
  var i = n.find((a) => {
    var {
      addedNodes: s,
      removedNodes: l
    } = a;
    for (var u of s)
      if (u === r || u.contains(r))
        return !0;
    for (var c of l)
      if (c === r || c.contains(r))
        return !0;
  });
  return !i || i === t ? !1 : Lj(e, i, n);
}, YJe = () => {
  for (var e = document.activeElement; (t = e) !== null && t !== void 0 && t.shadowRoot && (n = e.shadowRoot) !== null && n !== void 0 && n.activeElement; ) {
    var t, n, r;
    e = (r = e) === null || r === void 0 || (r = r.shadowRoot) === null || r === void 0 ? void 0 : r.activeElement;
  }
  return e;
}, r7 = (e, t) => !!(e.compareDocumentPosition(t) & Tie.DOCUMENT_POSITION_PRECEDING), JJe = (e, t) => !!(e.compareDocumentPosition(t) & Tie.DOCUMENT_POSITION_FOLLOWING), QJe = 0;
class eQe {
  constructor() {
    Ws(this, "id", void 0), this.id = "".concat(QJe++);
  }
}
var xe = {
  androidPendingDiffs: (e) => zi.get(e),
  androidScheduleFlush: (e) => {
    var t;
    (t = Ej.get(e)) === null || t === void 0 || t();
  },
  blur: (e) => {
    var t = xe.toDOMNode(e, e), n = xe.findDocumentOrShadowRoot(e);
    ou.set(e, !1), n.activeElement === t && t.blur();
  },
  deselect: (e) => {
    var {
      selection: t
    } = e, n = xe.findDocumentOrShadowRoot(e), r = Bf(n);
    r && r.rangeCount > 0 && r.removeAllRanges(), t && Be.deselect(e);
  },
  findDocumentOrShadowRoot: (e) => {
    var t = xe.toDOMNode(e, e), n = t.getRootNode();
    return n instanceof Document || n instanceof ShadowRoot ? n : t.ownerDocument;
  },
  findEventRange: (e, t) => {
    "nativeEvent" in t && (t = t.nativeEvent);
    var {
      clientX: n,
      clientY: r,
      target: o
    } = t;
    if (n == null || r == null)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var i = xe.toSlateNode(e, t.target), a = xe.findPath(e, i);
    if (ft.isElement(i) && te.isVoid(e, i)) {
      var s = o.getBoundingClientRect(), l = e.isInline(i) ? n - s.left < s.left + s.width - n : r - s.top < s.top + s.height - r, u = te.point(e, a, {
        edge: l ? "start" : "end"
      }), c = l ? te.before(e, u) : te.after(e, u);
      if (c) {
        var p = te.range(e, c);
        return p;
      }
    }
    var d, {
      document: g
    } = xe.getWindow(e);
    if (g.caretRangeFromPoint)
      d = g.caretRangeFromPoint(n, r);
    else {
      var f = g.caretPositionFromPoint(n, r);
      f && (d = g.createRange(), d.setStart(f.offsetNode, f.offset), d.setEnd(f.offsetNode, f.offset));
    }
    if (!d)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var m = xe.toSlateRange(e, d, {
      exactMatch: !1,
      suppressThrow: !1
    });
    return m;
  },
  findKey: (e, t) => {
    var n = Xw.get(t);
    return n || (n = new eQe(), Xw.set(t, n)), n;
  },
  findPath: (e, t) => {
    for (var n = [], r = t; ; ) {
      var o = xj.get(r);
      if (o == null) {
        if (te.isEditor(r))
          return n;
        break;
      }
      var i = Oj.get(r);
      if (i == null)
        break;
      n.unshift(i), r = o;
    }
    throw new Error("Unable to find the path for Slate node: ".concat(Ko.stringify(t)));
  },
  focus: function(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      retries: 5
    };
    if (!ou.get(t)) {
      if (n.retries <= 0)
        throw new Error("Could not set focus, editor seems stuck with pending operations");
      if (t.operations.length > 0) {
        setTimeout(() => {
          xe.focus(t, {
            retries: n.retries - 1
          });
        }, 10);
        return;
      }
      var r = xe.toDOMNode(t, t), o = xe.findDocumentOrShadowRoot(t);
      if (o.activeElement !== r) {
        if (t.selection && o instanceof Document) {
          var i = Bf(o), a = xe.toDOMRange(t, t.selection);
          i == null || i.removeAllRanges(), i == null || i.addRange(a);
        }
        t.selection || Be.select(t, te.start(t, [])), ou.set(t, !0), r.focus({
          preventScroll: !0
        });
      }
    }
  },
  getWindow: (e) => {
    var t = Sie.get(e);
    if (!t)
      throw new Error("Unable to find a host window element for this editor");
    return t;
  },
  hasDOMNode: function(t, n) {
    var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      editable: o = !1
    } = r, i = xe.toDOMNode(t, t), a;
    try {
      a = Hs(n) ? n : n.parentElement;
    } catch (s) {
      if (s instanceof Error && !s.message.includes('Permission denied to access property "nodeType"'))
        throw s;
    }
    return a ? a.closest("[data-slate-editor]") === i && (!o || a.isContentEditable ? !0 : typeof a.isContentEditable == "boolean" && // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined
    // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable="false"(readOnly)
    a.closest('[contenteditable="false"]') === i || !!a.getAttribute("data-slate-zero-width")) : !1;
  },
  hasEditableTarget: (e, t) => su(t) && xe.hasDOMNode(e, t, {
    editable: !0
  }),
  hasRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t;
    return te.hasPath(e, n.path) && te.hasPath(e, r.path);
  },
  hasSelectableTarget: (e, t) => xe.hasEditableTarget(e, t) || xe.isTargetInsideNonReadonlyVoid(e, t),
  hasTarget: (e, t) => su(t) && xe.hasDOMNode(e, t),
  insertData: (e, t) => {
    e.insertData(t);
  },
  insertFragmentData: (e, t) => e.insertFragmentData(t),
  insertTextData: (e, t) => e.insertTextData(t),
  isComposing: (e) => !!Cc.get(e),
  isFocused: (e) => !!ou.get(e),
  isReadOnly: (e) => !!TP.get(e),
  isTargetInsideNonReadonlyVoid: (e, t) => {
    if (TP.get(e)) return !1;
    var n = xe.hasTarget(e, t) && xe.toSlateNode(e, t);
    return ft.isElement(n) && te.isVoid(e, n);
  },
  setFragmentData: (e, t, n) => e.setFragmentData(t, n),
  toDOMNode: (e, t) => {
    var n = tx.get(e), r = te.isEditor(t) ? Ry.get(e) : n == null ? void 0 : n.get(xe.findKey(e, t));
    if (!r)
      throw new Error("Cannot resolve a DOM node from Slate node: ".concat(Ko.stringify(t)));
    return r;
  },
  toDOMPoint: (e, t) => {
    var [n] = te.node(e, t.path), r = xe.toDOMNode(e, n), o;
    te.void(e, {
      at: t
    }) && (t = {
      path: t.path,
      offset: 0
    });
    for (var i = "[data-slate-string], [data-slate-zero-width]", a = Array.from(r.querySelectorAll(i)), s = 0, l = 0; l < a.length; l++) {
      var u = a[l], c = u.childNodes[0];
      if (!(c == null || c.textContent == null)) {
        var {
          length: p
        } = c.textContent, d = u.getAttribute("data-slate-length"), g = d == null ? p : parseInt(d, 10), f = s + g, m = a[l + 1];
        if (t.offset === f && m !== null && m !== void 0 && m.hasAttribute("data-slate-mark-placeholder")) {
          var b, E = m.childNodes[0];
          o = [
            // COMPAT: If we don't explicity set the dom point to be on the actual
            // dom text element, chrome will put the selection behind the actual dom
            // text element, causing domRange.getBoundingClientRect() calls on a collapsed
            // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)
            // which will cause issues when scrolling to it.
            E instanceof WJe ? E : m,
            (b = m.textContent) !== null && b !== void 0 && b.startsWith("\uFEFF") ? 1 : 0
          ];
          break;
        }
        if (t.offset <= f) {
          var w = Math.min(p, Math.max(0, t.offset - s));
          o = [c, w];
          break;
        }
        s = f;
      }
    }
    if (!o)
      throw new Error("Cannot resolve a DOM point from Slate point: ".concat(Ko.stringify(t)));
    return o;
  },
  toDOMRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t, o = ve.isBackward(t), i = xe.toDOMPoint(e, n), a = ve.isCollapsed(t) ? i : xe.toDOMPoint(e, r), s = xe.getWindow(e), l = s.document.createRange(), [u, c] = o ? a : i, [p, d] = o ? i : a, g = Hs(u) ? u : u.parentElement, f = !!g.getAttribute("data-slate-zero-width"), m = Hs(p) ? p : p.parentElement, b = !!m.getAttribute("data-slate-zero-width");
    return l.setStart(u, f ? 1 : c), l.setEnd(p, b ? 1 : d), l;
  },
  toSlateNode: (e, t) => {
    var n = Hs(t) ? t : t.parentElement;
    n && !n.hasAttribute("data-slate-node") && (n = n.closest("[data-slate-node]"));
    var r = n ? $h.get(n) : null;
    if (!r)
      throw new Error("Cannot resolve a Slate node from DOM node: ".concat(n));
    return r;
  },
  toSlatePoint: (e, t, n) => {
    var {
      exactMatch: r,
      suppressThrow: o,
      searchDirection: i = "backward"
    } = n, [a, s] = r ? t : ZJe(t), l = a.parentNode, u = null, c = 0;
    if (l) {
      var p, d, g = xe.toDOMNode(e, e), f = l.closest('[data-slate-void="true"]'), m = f && g.contains(f) ? f : null, b = l.closest('[contenteditable="false"]'), E = b && g.contains(b) ? b : null, w = l.closest("[data-slate-leaf]"), M = null;
      if (w) {
        if (u = w.closest('[data-slate-node="text"]'), u) {
          var x = xe.getWindow(e), v = x.document.createRange();
          v.setStart(u, 0), v.setEnd(a, s);
          var C = v.cloneContents(), P = [...Array.prototype.slice.call(C.querySelectorAll("[data-slate-zero-width]")), ...Array.prototype.slice.call(C.querySelectorAll("[contenteditable=false]"))];
          P.forEach((S) => {
            if (Si && !r && S.hasAttribute("data-slate-zero-width") && S.textContent.length > 0 && S.textContext !== "\uFEFF") {
              S.textContent.startsWith("\uFEFF") && (S.textContent = S.textContent.slice(1));
              return;
            }
            S.parentNode.removeChild(S);
          }), c = C.textContent.length, M = u;
        }
      } else if (m) {
        for (var F = m.querySelectorAll("[data-slate-leaf]"), L = 0; L < F.length; L++) {
          var B = F[L];
          if (xe.hasDOMNode(e, B)) {
            w = B;
            break;
          }
        }
        w ? (u = w.closest('[data-slate-node="text"]'), M = w, c = M.textContent.length, M.querySelectorAll("[data-slate-zero-width]").forEach((S) => {
          c -= S.textContent.length;
        })) : c = 1;
      } else if (E) {
        var N = (S) => S ? S.querySelectorAll(
          // Exclude leaf nodes in nested editors
          "[data-slate-leaf]:not(:scope [data-slate-editor] [data-slate-leaf])"
        ) : [], $ = E.closest('[data-slate-node="element"]');
        if (i === "forward") {
          var V, H = [...N($), ...N($ == null ? void 0 : $.nextElementSibling)];
          w = (V = H.find((S) => JJe(E, S))) !== null && V !== void 0 ? V : null;
        } else {
          var Z, K = [...N($ == null ? void 0 : $.previousElementSibling), ...N($)];
          w = (Z = K.findLast((S) => r7(E, S))) !== null && Z !== void 0 ? Z : null;
        }
        w && (u = w.closest('[data-slate-node="text"]'), M = w, i === "forward" ? c = 0 : (c = M.textContent.length, M.querySelectorAll("[data-slate-zero-width]").forEach((S) => {
          c -= S.textContent.length;
        })));
      }
      M && c === M.textContent.length && // COMPAT: Android IMEs might remove the zero width space while composing,
      // and we don't add it for line-breaks.
      Si && M.getAttribute("data-slate-zero-width") === "z" && (p = M.textContent) !== null && p !== void 0 && p.startsWith("\uFEFF") && // COMPAT: If the parent node is a Slate zero-width space, editor is
      // because the text node should have no characters. However, during IME
      // composition the ASCII characters will be prepended to the zero-width
      // space, so subtract 1 from the offset to account for the zero-width
      // space character.
      (l.hasAttribute("data-slate-zero-width") || // COMPAT: In Firefox, `range.cloneContents()` returns an extra trailing '\n'
      // when the document ends with a new-line character. This results in the offset
      // length being off by one, so we need to subtract one to account for this.
      up && (d = M.textContent) !== null && d !== void 0 && d.endsWith(`

`)) && c--;
    }
    if (Si && !u && !r) {
      var Y = l.hasAttribute("data-slate-node") ? l : l.closest("[data-slate-node]");
      if (Y && xe.hasDOMNode(e, Y, {
        editable: !0
      })) {
        var Q = xe.toSlateNode(e, Y), {
          path: J,
          offset: _
        } = te.start(e, xe.findPath(e, Q));
        return Y.querySelector("[data-slate-leaf]") || (_ = s), {
          path: J,
          offset: _
        };
      }
    }
    if (!u) {
      if (o)
        return null;
      throw new Error("Cannot resolve a Slate point from DOM point: ".concat(t));
    }
    var D = xe.toSlateNode(e, u), z = xe.findPath(e, D);
    return {
      path: z,
      offset: c
    };
  },
  toSlateRange: (e, t, n) => {
    var r, {
      exactMatch: o,
      suppressThrow: i
    } = n, a = AP(t) ? t.anchorNode : t.startContainer, s, l, u, c, p;
    if (a)
      if (AP(t)) {
        if (up && t.rangeCount > 1) {
          u = t.focusNode;
          var d = t.getRangeAt(0), g = t.getRangeAt(t.rangeCount - 1);
          if (u instanceof HTMLTableRowElement && d.startContainer instanceof HTMLTableRowElement && g.startContainer instanceof HTMLTableRowElement) {
            let C = function(P) {
              return P.childElementCount > 0 ? C(P.children[0]) : P;
            };
            var f = d.startContainer, m = g.startContainer, b = C(f.children[d.startOffset]), E = C(m.children[g.startOffset]);
            c = 0, E.childNodes.length > 0 ? s = E.childNodes[0] : s = E, b.childNodes.length > 0 ? u = b.childNodes[0] : u = b, E instanceof HTMLElement ? l = E.innerHTML.length : l = 0;
          } else
            d.startContainer === u ? (s = g.endContainer, l = g.endOffset, c = d.startOffset) : (s = d.startContainer, l = d.endOffset, c = g.startOffset);
        } else
          s = t.anchorNode, l = t.anchorOffset, u = t.focusNode, c = t.focusOffset;
        Pie && qJe(s) || up ? p = t.anchorNode === t.focusNode && t.anchorOffset === t.focusOffset : p = t.isCollapsed;
      } else
        s = t.startContainer, l = t.startOffset, u = t.endContainer, c = t.endOffset, p = t.collapsed;
    if (s == null || u == null || l == null || c == null)
      throw new Error("Cannot resolve a Slate range from DOM range: ".concat(t));
    up && (r = u.textContent) !== null && r !== void 0 && r.endsWith(`

`) && c === u.textContent.length && c--;
    var w = xe.toSlatePoint(e, [s, l], {
      exactMatch: o,
      suppressThrow: i
    });
    if (!w)
      return null;
    var M = r7(s, u) || s === u && c < l, x = p ? w : xe.toSlatePoint(e, [u, c], {
      exactMatch: o,
      suppressThrow: i,
      searchDirection: M ? "forward" : "backward"
    });
    if (!x)
      return null;
    var v = {
      anchor: w,
      focus: x
    };
    return ve.isExpanded(v) && ve.isForward(v) && Hs(u) && te.void(e, {
      at: v.focus,
      mode: "highest"
    }) && (v = te.unhangRange(e, v, {
      voids: !0
    })), v;
  }
};
function tQe(e, t) {
  var {
    path: n,
    diff: r
  } = t;
  if (!te.hasPath(e, n))
    return !1;
  var o = tt.get(e, n);
  if (!ht.isText(o))
    return !1;
  if (r.start !== o.text.length || r.text.length === 0)
    return o.text.slice(r.start, r.start + r.text.length) === r.text;
  var i = ce.next(n);
  if (!te.hasPath(e, i))
    return !1;
  var a = tt.get(e, i);
  return ht.isText(a) && a.text.startsWith(r.text);
}
function Iie(e) {
  for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)
    n[r - 1] = arguments[r];
  return n.reduce((o, i) => o.slice(0, i.start) + i.text + o.slice(i.end), e);
}
function nQe(e, t) {
  for (var n = Math.min(e.length, t.length), r = 0; r < n; r++)
    if (e.charAt(r) !== t.charAt(r))
      return r;
  return n;
}
function rQe(e, t, n) {
  for (var r = Math.min(e.length, t.length, n), o = 0; o < r; o++)
    if (e.charAt(e.length - o - 1) !== t.charAt(t.length - o - 1))
      return o;
  return r;
}
function Nie(e, t) {
  var {
    start: n,
    end: r,
    text: o
  } = t, i = e.slice(n, r), a = nQe(i, o), s = Math.min(i.length - a, o.length - a), l = rQe(i, o, s), u = {
    start: n + a,
    end: r - l,
    text: o.slice(a, o.length - l)
  };
  return u.start === u.end && u.text.length === 0 ? null : u;
}
function oQe(e, t, n) {
  var r = Math.min(t.start, n.start), o = Math.max(0, Math.min(t.start + t.text.length, n.end) - n.start), i = Iie(e, t, n), a = Math.max(n.start + n.text.length, t.start + t.text.length + (t.start + t.text.length > n.start ? n.text.length : 0) - o), s = i.slice(r, a), l = Math.max(t.end, n.end - t.text.length + (t.end - t.start));
  return Nie(e, {
    start: r,
    end: l,
    text: s
  });
}
function iQe(e) {
  var {
    path: t,
    diff: n
  } = e;
  return {
    anchor: {
      path: t,
      offset: n.start
    },
    focus: {
      path: t,
      offset: n.end
    }
  };
}
function RP(e, t) {
  var {
    path: n,
    offset: r
  } = t;
  if (!te.hasPath(e, n))
    return null;
  var o = tt.get(e, n);
  if (!ht.isText(o))
    return null;
  var i = te.above(e, {
    match: (s) => ft.isElement(s) && te.isBlock(e, s),
    at: n
  });
  if (!i)
    return null;
  for (; r > o.text.length; ) {
    var a = te.next(e, {
      at: n,
      match: ht.isText
    });
    if (!a || !ce.isDescendant(a[1], i[1]))
      return null;
    r -= o.text.length, o = a[0], n = a[1];
  }
  return {
    path: n,
    offset: r
  };
}
function o7(e, t) {
  var n = RP(e, t.anchor);
  if (!n)
    return null;
  if (ve.isCollapsed(t))
    return {
      anchor: n,
      focus: n
    };
  var r = RP(e, t.focus);
  return r ? {
    anchor: n,
    focus: r
  } : null;
}
function IP(e, t, n) {
  var r = zi.get(e), o = r == null ? void 0 : r.find((c) => {
    var {
      path: p
    } = c;
    return ce.equals(p, t.path);
  });
  if (!o || t.offset <= o.diff.start)
    return $t.transform(t, n, {
      affinity: "backward"
    });
  var {
    diff: i
  } = o;
  if (t.offset <= i.start + i.text.length) {
    var a = {
      path: t.path,
      offset: i.start
    }, s = $t.transform(a, n, {
      affinity: "backward"
    });
    return s ? {
      path: s.path,
      offset: s.offset + t.offset - i.start
    } : null;
  }
  var l = {
    path: t.path,
    offset: t.offset - i.text.length + i.end - i.start
  }, u = $t.transform(l, n, {
    affinity: "backward"
  });
  return u ? n.type === "split_node" && ce.equals(n.path, t.path) && l.offset < n.position && i.start < n.position ? u : {
    path: u.path,
    offset: u.offset + i.text.length - i.end + i.start
  } : null;
}
function i7(e, t, n) {
  var r = IP(e, t.anchor, n);
  if (!r)
    return null;
  if (ve.isCollapsed(t))
    return {
      anchor: r,
      focus: r
    };
  var o = IP(e, t.focus, n);
  return o ? {
    anchor: r,
    focus: o
  } : null;
}
function sQe(e, t) {
  var {
    path: n,
    diff: r,
    id: o
  } = e;
  switch (t.type) {
    case "insert_text":
      return !ce.equals(t.path, n) || t.offset >= r.end ? e : t.offset <= r.start ? {
        diff: {
          start: t.text.length + r.start,
          end: t.text.length + r.end,
          text: r.text
        },
        id: o,
        path: n
      } : {
        diff: {
          start: r.start,
          end: r.end + t.text.length,
          text: r.text
        },
        id: o,
        path: n
      };
    case "remove_text":
      return !ce.equals(t.path, n) || t.offset >= r.end ? e : t.offset + t.text.length <= r.start ? {
        diff: {
          start: r.start - t.text.length,
          end: r.end - t.text.length,
          text: r.text
        },
        id: o,
        path: n
      } : {
        diff: {
          start: r.start,
          end: r.end - t.text.length,
          text: r.text
        },
        id: o,
        path: n
      };
    case "split_node":
      return !ce.equals(t.path, n) || t.position >= r.end ? {
        diff: r,
        id: o,
        path: ce.transform(n, t, {
          affinity: "backward"
        })
      } : t.position > r.start ? {
        diff: {
          start: r.start,
          end: Math.min(t.position, r.end),
          text: r.text
        },
        id: o,
        path: n
      } : {
        diff: {
          start: r.start - t.position,
          end: r.end - t.position,
          text: r.text
        },
        id: o,
        path: ce.transform(n, t, {
          affinity: "forward"
        })
      };
    case "merge_node":
      return ce.equals(t.path, n) ? {
        diff: {
          start: r.start + t.position,
          end: r.end + t.position,
          text: r.text
        },
        id: o,
        path: ce.transform(n, t)
      } : {
        diff: r,
        id: o,
        path: ce.transform(n, t)
      };
  }
  var i = ce.transform(n, t);
  return i ? {
    diff: r,
    path: i,
    id: o
  } : null;
}
function s7(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function fy(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? s7(Object(n), !0).forEach(function(r) {
      Ws(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : s7(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var aQe = 25, lQe = 200, uQe = function() {
}, cQe = (e) => (e == null ? void 0 : e.constructor.name) === "DataTransfer";
function pQe(e) {
  var {
    editor: t,
    scheduleOnDOMSelectionChange: n,
    onDOMSelectionChange: r
  } = e, o = !1, i = null, a = null, s = null, l = 0, u = !1, c = () => {
    var $ = ql.get(t);
    if (ql.delete(t), $) {
      var {
        selection: V
      } = t, H = o7(t, $);
      H && (!V || !ve.equals(H, V)) && Be.select(t, H);
    }
  }, p = () => {
    var $ = Zl.get(t);
    if (Zl.delete(t), !!$) {
      if ($.at) {
        var V = $t.isPoint($.at) ? RP(t, $.at) : o7(t, $.at);
        if (!V)
          return;
        var H = te.range(t, V);
        (!t.selection || !ve.equals(t.selection, H)) && Be.select(t, V);
      }
      $.run();
    }
  }, d = () => {
    if (a && (clearTimeout(a), a = null), s && (clearTimeout(s), s = null), !x() && !M()) {
      c();
      return;
    }
    o || (o = !0, setTimeout(() => o = !1)), M() && (o = "action");
    var $ = t.selection && te.rangeRef(t, t.selection, {
      affinity: "forward"
    });
    Ga.set(t, t.marks), uQe("flush", Zl.get(t), zi.get(t));
    for (var V = x(), H; H = (Z = zi.get(t)) === null || Z === void 0 ? void 0 : Z[0]; ) {
      var Z, K, Y = $s.get(t);
      Y !== void 0 && ($s.delete(t), t.marks = Y), Y && u === !1 && (u = null);
      var Q = iQe(H);
      (!t.selection || !ve.equals(t.selection, Q)) && Be.select(t, Q), H.diff.text ? te.insertText(t, H.diff.text) : te.deleteFragment(t), zi.set(t, (K = zi.get(t)) === null || K === void 0 ? void 0 : K.filter((D) => {
        var {
          id: z
        } = D;
        return z !== H.id;
      })), tQe(t, H) || (V = !1, Zl.delete(t), Ga.delete(t), o = "action", ql.delete(t), n.cancel(), r.cancel(), $ == null || $.unref());
    }
    var J = $ == null ? void 0 : $.unref();
    if (J && !ql.get(t) && (!t.selection || !ve.equals(J, t.selection)) && Be.select(t, J), M()) {
      p();
      return;
    }
    V && n(), n.flush(), r.flush(), c();
    var _ = Ga.get(t);
    Ga.delete(t), _ !== void 0 && (t.marks = _, t.onChange());
  }, g = ($) => {
    i && clearTimeout(i), i = setTimeout(() => {
      Cc.set(t, !1), d();
    }, aQe);
  }, f = ($) => {
    Cc.set(t, !0), i && (clearTimeout(i), i = null);
  }, m = function() {
    var V = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1, H = DP.get(t);
    if (H) {
      if (x() || V) {
        H.style.display = "none";
        return;
      }
      H.style.removeProperty("display");
    }
  }, b = ($, V) => {
    var H, Z = (H = zi.get(t)) !== null && H !== void 0 ? H : [];
    zi.set(t, Z);
    var K = tt.leaf(t, $), Y = Z.findIndex((_) => ce.equals(_.path, $));
    if (Y < 0) {
      var Q = Nie(K.text, V);
      Q && Z.push({
        path: $,
        diff: V,
        id: l++
      }), m();
      return;
    }
    var J = oQe(K.text, Z[Y].diff, V);
    if (!J) {
      Z.splice(Y, 1), m();
      return;
    }
    Z[Y] = fy(fy({}, Z[Y]), {}, {
      diff: J
    });
  }, E = function(V) {
    var {
      at: H
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    u = !1, ql.delete(t), n.cancel(), r.cancel(), M() && d(), Zl.set(t, {
      at: H,
      run: V
    }), s = setTimeout(d);
  }, w = ($) => {
    var V;
    if (a && (clearTimeout(a), a = null), !yp.get(t)) {
      var {
        inputType: H
      } = $, Z = null, K = $.dataTransfer || $.data || void 0;
      u !== !1 && H !== "insertText" && H !== "insertCompositionText" && (u = !1);
      var [Y] = $.getTargetRanges();
      Y && (Z = xe.toSlateRange(t, Y, {
        exactMatch: !1,
        suppressThrow: !0
      }));
      var Q = xe.getWindow(t), J = Q.getSelection();
      if (!Z && J && (Y = J, Z = xe.toSlateRange(t, J, {
        exactMatch: !1,
        suppressThrow: !0
      })), Z = (V = Z) !== null && V !== void 0 ? V : t.selection, !!Z) {
        var _ = !0;
        if (H.startsWith("delete")) {
          if (ve.isExpanded(Z)) {
            var [D, z] = ve.edges(Z), S = tt.leaf(t, D.path);
            if (S.text.length === D.offset && z.offset === 0) {
              var W = te.next(t, {
                at: D.path,
                match: ht.isText
              });
              W && ce.equals(W[1], z.path) && (Z = {
                anchor: z,
                focus: z
              });
            }
          }
          var O = H.endsWith("Backward") ? "backward" : "forward", [j, U] = ve.edges(Z), [T, q] = te.leaf(t, j.path), A = {
            text: "",
            start: j.offset,
            end: U.offset
          }, X = zi.get(t), I = X == null ? void 0 : X.find((Fe) => ce.equals(Fe.path, q)), le = I ? [I.diff, A] : [A], he = Iie(T.text, ...le);
          if (he.length === 0 && (_ = !1), ve.isExpanded(Z)) {
            if (_ && ce.equals(Z.anchor.path, Z.focus.path)) {
              var oe = {
                path: Z.anchor.path,
                offset: j.offset
              }, Ae = te.range(t, oe, oe);
              return P(Ae), b(Z.anchor.path, {
                text: "",
                end: U.offset,
                start: j.offset
              });
            }
            return E(() => te.deleteFragment(t, {
              direction: O
            }), {
              at: Z
            });
          }
        }
        switch (H) {
          case "deleteByComposition":
          case "deleteByCut":
          case "deleteByDrag":
            return E(() => te.deleteFragment(t), {
              at: Z
            });
          case "deleteContent":
          case "deleteContentForward": {
            var {
              anchor: Ue
            } = Z;
            if (_ && ve.isCollapsed(Z)) {
              var He = tt.leaf(t, Ue.path);
              if (Ue.offset < He.text.length)
                return b(Ue.path, {
                  text: "",
                  start: Ue.offset,
                  end: Ue.offset + 1
                });
            }
            return E(() => te.deleteForward(t), {
              at: Z
            });
          }
          case "deleteContentBackward": {
            var Re, {
              anchor: nt
            } = Z, Ve = AP(Y) ? Y.isCollapsed : !!((Re = Y) !== null && Re !== void 0 && Re.collapsed);
            return _ && Ve && ve.isCollapsed(Z) && nt.offset > 0 ? b(nt.path, {
              text: "",
              start: nt.offset - 1,
              end: nt.offset
            }) : E(() => te.deleteBackward(t), {
              at: Z
            });
          }
          case "deleteEntireSoftLine":
            return E(() => {
              te.deleteBackward(t, {
                unit: "line"
              }), te.deleteForward(t, {
                unit: "line"
              });
            }, {
              at: Z
            });
          case "deleteHardLineBackward":
            return E(() => te.deleteBackward(t, {
              unit: "block"
            }), {
              at: Z
            });
          case "deleteSoftLineBackward":
            return E(() => te.deleteBackward(t, {
              unit: "line"
            }), {
              at: Z
            });
          case "deleteHardLineForward":
            return E(() => te.deleteForward(t, {
              unit: "block"
            }), {
              at: Z
            });
          case "deleteSoftLineForward":
            return E(() => te.deleteForward(t, {
              unit: "line"
            }), {
              at: Z
            });
          case "deleteWordBackward":
            return E(() => te.deleteBackward(t, {
              unit: "word"
            }), {
              at: Z
            });
          case "deleteWordForward":
            return E(() => te.deleteForward(t, {
              unit: "word"
            }), {
              at: Z
            });
          case "insertLineBreak":
            return E(() => te.insertSoftBreak(t), {
              at: Z
            });
          case "insertParagraph":
            return E(() => te.insertBreak(t), {
              at: Z
            });
          case "insertCompositionText":
          case "deleteCompositionText":
          case "insertFromComposition":
          case "insertFromDrop":
          case "insertFromPaste":
          case "insertFromYank":
          case "insertReplacementText":
          case "insertText": {
            if (cQe(K))
              return E(() => xe.insertData(t, K), {
                at: Z
              });
            var we = K ?? "";
            if ($s.get(t) && (we = we.replace("\uFEFF", "")), H === "insertText" && /.*\n.*\n$/.test(we) && (we = we.slice(0, -1)), we.includes(`
`))
              return E(() => {
                var Fe = we.split(`
`);
                Fe.forEach((Ie, ot) => {
                  Ie && te.insertText(t, Ie), ot !== Fe.length - 1 && te.insertSoftBreak(t);
                });
              }, {
                at: Z
              });
            if (ce.equals(Z.anchor.path, Z.focus.path)) {
              var [et, lt] = ve.edges(Z), ye = {
                start: et.offset,
                end: lt.offset,
                text: we
              };
              if (we && u && H === "insertCompositionText") {
                var ke = u.start + u.text.search(/\S|$/), Qe = ye.start + ye.text.search(/\S|$/);
                Qe === ke + 1 && ye.end === u.start + u.text.length ? (ye.start -= 1, u = null, B()) : u = !1;
              } else H === "insertText" ? u === null ? u = ye : u && ve.isCollapsed(Z) && u.end + u.text.length === et.offset ? u = fy(fy({}, u), {}, {
                text: u.text + we
              }) : u = !1 : u = !1;
              if (_) {
                b(et.path, ye);
                return;
              }
            }
            return E(() => te.insertText(t, we), {
              at: Z
            });
          }
        }
      }
    }
  }, M = () => !!Zl.get(t), x = () => {
    var $;
    return !!(($ = zi.get(t)) !== null && $ !== void 0 && $.length);
  }, v = () => M() || x(), C = () => o, P = ($) => {
    ql.set(t, $), a && (clearTimeout(a), a = null);
    var {
      selection: V
    } = t;
    if ($) {
      var H = !V || !ce.equals(V.anchor.path, $.anchor.path), Z = !V || !ce.equals(V.anchor.path.slice(0, -1), $.anchor.path.slice(0, -1));
      (H && u || Z) && (u = !1), (H || x()) && (a = setTimeout(d, lQe));
    }
  }, F = () => {
    (M() || !x()) && d();
  }, L = ($) => {
    x() || (m(!0), setTimeout(m));
  }, B = () => {
    M() || (s = setTimeout(d));
  }, N = ($) => {
    if (!(x() || M()) && $.some((H) => Lj(t, H, $))) {
      var V;
      (V = Mie.get(t)) === null || V === void 0 || V();
    }
  };
  return {
    flush: d,
    scheduleFlush: B,
    hasPendingDiffs: x,
    hasPendingAction: M,
    hasPendingChanges: v,
    isFlushing: C,
    handleUserSelect: P,
    handleCompositionEnd: g,
    handleCompositionStart: f,
    handleDOMBeforeInput: w,
    handleKeyDown: L,
    handleDomMutations: N,
    handleInput: F
  };
}
function dQe() {
  var e = dt(!1);
  return h(() => (e.current = !0, () => {
    e.current = !1;
  }), []), e.current;
}
var Vh = Ay ? Gse : h;
function fQe(e, t, n) {
  var [r] = k(() => new MutationObserver(t));
  Vh(() => {
    r.takeRecords();
  }), h(() => {
    if (!e.current)
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    return r.observe(e.current, n), () => r.disconnect();
  }, [r, e, n]);
}
var hQe = ["node"];
function a7(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function gQe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? a7(Object(n), !0).forEach(function(r) {
      Ws(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : a7(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var mQe = {
  subtree: !0,
  childList: !0,
  characterData: !0
}, vQe = Si ? (e) => {
  var {
    node: t
  } = e, n = Pp(e, hQe);
  if (!Si)
    return null;
  var r = Du(), o = dQe(), [i] = k(() => pQe(gQe({
    editor: r
  }, n)));
  return fQe(t, i.handleDomMutations, mQe), Ej.set(r, i.scheduleFlush), o && i.flush(), i;
} : () => null, yQe = ["anchor", "focus"], bQe = ["anchor", "focus"], wQe = (e, t) => Object.keys(e).length === Object.keys(t).length && Object.keys(e).every((n) => t.hasOwnProperty(n) && e[n] === t[n]), Bie = (e, t) => {
  var n = Pp(e, yQe), r = Pp(t, bQe);
  return e[Sp] === t[Sp] && wQe(n, r);
}, CQe = (e, t) => {
  if (e.length !== t.length)
    return !1;
  for (var n = 0; n < e.length; n++) {
    var r = e[n], o = t[n];
    if (!ve.equals(r, o) || !Bie(r, o))
      return !1;
  }
  return !0;
}, OQe = (e, t) => {
  if (e.length !== t.length)
    return !1;
  for (var n = 0; n < e.length; n++) {
    var r = e[n], o = t[n];
    if (r.anchor.offset !== o.anchor.offset || r.focus.offset !== o.focus.offset || !Bie(r, o))
      return !1;
  }
  return !0;
};
function l7(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function xQe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? l7(Object(n), !0).forEach(function(r) {
      Ws(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : l7(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var EQe = (e) => {
  var {
    isLast: t,
    leaf: n,
    parent: r,
    text: o
  } = e, i = Du(), a = xe.findPath(i, o), s = ce.parent(a), l = !!n[Die];
  return i.isVoid(r) ? /* @__PURE__ */ be.createElement(IL, {
    length: tt.string(r).length
  }) : n.text === "" && r.children[r.children.length - 1] === o && !i.isInline(r) && te.string(i, s) === "" ? /* @__PURE__ */ be.createElement(IL, {
    isLineBreak: !0,
    isMarkPlaceholder: l
  }) : n.text === "" ? /* @__PURE__ */ be.createElement(IL, {
    isMarkPlaceholder: l
  }) : t && n.text.slice(-1) === `
` ? /* @__PURE__ */ be.createElement(u7, {
    isTrailing: !0,
    text: n.text
  }) : /* @__PURE__ */ be.createElement(u7, {
    text: n.text
  });
}, u7 = (e) => {
  var {
    text: t,
    isTrailing: n = !1
  } = e, r = dt(null), o = () => "".concat(t ?? "").concat(n ? `
` : ""), [i] = k(o);
  return Vh(() => {
    var a = o();
    r.current && r.current.textContent !== a && (r.current.textContent = a);
  }), /* @__PURE__ */ be.createElement(kQe, {
    ref: r
  }, i);
}, kQe = /* @__PURE__ */ me(/* @__PURE__ */ Cr((e, t) => /* @__PURE__ */ be.createElement("span", {
  "data-slate-string": !0,
  ref: t
}, e.children))), IL = (e) => {
  var {
    length: t = 0,
    isLineBreak: n = !1,
    isMarkPlaceholder: r = !1
  } = e, o = {
    "data-slate-zero-width": n ? "n" : "z",
    "data-slate-length": t
  };
  return r && (o["data-slate-mark-placeholder"] = !0), /* @__PURE__ */ be.createElement("span", xQe({}, o), !(Si || _ie) || !n ? "\uFEFF" : null, n ? /* @__PURE__ */ be.createElement("br", null) : null);
};
function c7(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Fie(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? c7(Object(n), !0).forEach(function(r) {
      Ws(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : c7(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var LQe = Si ? 300 : 0;
function _Qe(e, t) {
  e.current && (e.current.disconnect(), t && (e.current = null));
}
function p7(e) {
  e.current && (clearTimeout(e.current), e.current = null);
}
var PQe = (e) => {
  var {
    leaf: t,
    isLast: n,
    text: r,
    parent: o,
    renderPlaceholder: i,
    renderLeaf: a = (w) => /* @__PURE__ */ be.createElement(MQe, Fie({}, w))
  } = e, s = Du(), l = dt(null), u = dt(null), [c, p] = k(!1), d = dt(null), g = Jn((w) => {
    if (_Qe(l, w == null), w == null) {
      var M;
      DP.delete(s), (M = t.onPlaceholderResize) === null || M === void 0 || M.call(t, null);
    } else {
      if (DP.set(s, w), !l.current) {
        var x = window.ResizeObserver || jJe;
        l.current = new x(() => {
          var v;
          (v = t.onPlaceholderResize) === null || v === void 0 || v.call(t, w);
        });
      }
      l.current.observe(w), u.current = w;
    }
  }, [u, t, s]), f = /* @__PURE__ */ be.createElement(EQe, {
    isLast: n,
    leaf: t,
    parent: o,
    text: r
  }), m = !!t[Sp];
  if (h(() => (m ? d.current || (d.current = setTimeout(() => {
    p(!0), d.current = null;
  }, LQe)) : (p7(d), p(!1)), () => p7(d)), [m, p]), m && c) {
    var b = {
      children: t.placeholder,
      attributes: {
        "data-slate-placeholder": !0,
        style: {
          position: "absolute",
          top: 0,
          pointerEvents: "none",
          width: "100%",
          maxWidth: "100%",
          display: "block",
          opacity: "0.333",
          userSelect: "none",
          textDecoration: "none",
          // Fixes https://github.com/udecode/plate/issues/2315
          WebkitUserModify: oc ? "inherit" : void 0
        },
        contentEditable: !1,
        ref: g
      }
    };
    f = /* @__PURE__ */ be.createElement(be.Fragment, null, i(b), f);
  }
  var E = {
    "data-slate-leaf": !0
  };
  return a({
    attributes: E,
    children: f,
    leaf: t,
    text: r
  });
}, SQe = /* @__PURE__ */ be.memo(PQe, (e, t) => t.parent === e.parent && t.isLast === e.isLast && t.renderLeaf === e.renderLeaf && t.renderPlaceholder === e.renderPlaceholder && t.text === e.text && ht.equals(t.leaf, e.leaf) && t.leaf[Sp] === e.leaf[Sp]), MQe = (e) => {
  var {
    attributes: t,
    children: n
  } = e;
  return /* @__PURE__ */ be.createElement("span", Fie({}, t), n);
}, DQe = (e) => {
  for (var {
    decorations: t,
    isLast: n,
    parent: r,
    renderPlaceholder: o,
    renderLeaf: i,
    text: a
  } = e, s = Du(), l = dt(null), u = ht.decorations(a, t), c = xe.findKey(s, a), p = [], d = 0; d < u.length; d++) {
    var g = u[d];
    p.push(/* @__PURE__ */ be.createElement(SQe, {
      isLast: n && d === u.length - 1,
      key: "".concat(c.id, "-").concat(d),
      renderPlaceholder: o,
      leaf: g,
      text: a,
      parent: r,
      renderLeaf: i
    }));
  }
  var f = Jn((m) => {
    var b = tx.get(s);
    m ? (b == null || b.set(c, m), Lc.set(a, m), $h.set(m, a)) : (b == null || b.delete(c), Lc.delete(a), l.current && $h.delete(l.current)), l.current = m;
  }, [l, s, c, a]);
  return /* @__PURE__ */ be.createElement("span", {
    "data-slate-node": "text",
    ref: f
  }, p);
}, zie = /* @__PURE__ */ be.memo(DQe, (e, t) => t.parent === e.parent && t.isLast === e.isLast && t.renderLeaf === e.renderLeaf && t.renderPlaceholder === e.renderPlaceholder && t.text === e.text && OQe(t.decorations, e.decorations));
function d7(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function NP(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? d7(Object(n), !0).forEach(function(r) {
      Ws(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : d7(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var TQe = (e) => {
  var {
    decorations: t,
    element: n,
    renderElement: r = (w) => /* @__PURE__ */ be.createElement(AQe, NP({}, w)),
    renderPlaceholder: o,
    renderLeaf: i,
    selection: a
  } = e, s = Du(), l = NQe(), u = s.isInline(n), c = xe.findKey(s, n), p = Jn((w) => {
    var M = tx.get(s);
    w ? (M == null || M.set(c, w), Lc.set(n, w), $h.set(w, n)) : (M == null || M.delete(c), Lc.delete(n));
  }, [s, c, n]), d = Hie({
    decorations: t,
    node: n,
    renderElement: r,
    renderPlaceholder: o,
    renderLeaf: i,
    selection: a
  }), g = {
    "data-slate-node": "element",
    ref: p
  };
  if (u && (g["data-slate-inline"] = !0), !u && te.hasInlines(s, n)) {
    var f = tt.string(n), m = gie(f);
    m === "rtl" && (g.dir = m);
  }
  if (te.isVoid(s, n)) {
    g["data-slate-void"] = !0, !l && u && (g.contentEditable = !1);
    var b = u ? "span" : "div", [[E]] = tt.texts(n);
    d = /* @__PURE__ */ be.createElement(b, {
      "data-slate-spacer": !0,
      style: {
        height: "0",
        color: "transparent",
        outline: "none",
        position: "absolute"
      }
    }, /* @__PURE__ */ be.createElement(zie, {
      renderPlaceholder: o,
      decorations: [],
      isLast: !1,
      parent: n,
      text: E
    })), Oj.set(E, 0), xj.set(E, n);
  }
  return r({
    attributes: g,
    children: d,
    element: n
  });
}, jQe = /* @__PURE__ */ be.memo(TQe, (e, t) => e.element === t.element && e.renderElement === t.renderElement && e.renderLeaf === t.renderLeaf && e.renderPlaceholder === t.renderPlaceholder && CQe(e.decorations, t.decorations) && (e.selection === t.selection || !!e.selection && !!t.selection && ve.equals(e.selection, t.selection))), AQe = (e) => {
  var {
    attributes: t,
    children: n,
    element: r
  } = e, o = Du(), i = o.isInline(r) ? "span" : "div";
  return /* @__PURE__ */ be.createElement(i, NP(NP({}, t), {}, {
    style: {
      position: "relative"
    }
  }), n);
}, Uie = /* @__PURE__ */ $e(() => []), RQe = () => ge(Uie), IQe = /* @__PURE__ */ $e(!1), Hie = (e) => {
  var {
    decorations: t,
    node: n,
    renderElement: r,
    renderPlaceholder: o,
    renderLeaf: i,
    selection: a
  } = e, s = RQe(), l = Du();
  yp.set(l, !1);
  for (var u = xe.findPath(l, n), c = [], p = ft.isElement(n) && !l.isInline(n) && te.hasInlines(l, n), d = 0; d < n.children.length; d++) {
    var g = u.concat(d), f = n.children[d], m = xe.findKey(l, f), b = te.range(l, g), E = a && ve.intersection(b, a), w = s([f, g]);
    for (var M of t) {
      var x = ve.intersection(M, b);
      x && w.push(x);
    }
    ft.isElement(f) ? c.push(/* @__PURE__ */ be.createElement(IQe.Provider, {
      key: "provider-".concat(m.id),
      value: !!E
    }, /* @__PURE__ */ be.createElement(jQe, {
      decorations: w,
      element: f,
      key: m.id,
      renderElement: r,
      renderPlaceholder: o,
      renderLeaf: i,
      selection: E
    }))) : c.push(/* @__PURE__ */ be.createElement(zie, {
      decorations: w,
      key: m.id,
      isLast: p && d === n.children.length - 1,
      parent: n,
      renderPlaceholder: o,
      renderLeaf: i,
      text: f
    })), Oj.set(f, d), xj.set(f, n);
  }
  return c;
}, Wie = /* @__PURE__ */ $e(!1), NQe = () => ge(Wie), $ie = /* @__PURE__ */ $e(null), nx = () => {
  var e = ge($ie);
  if (!e)
    throw new Error("The `useSlate` hook must be used inside the <Slate> component's context.");
  var {
    editor: t
  } = e;
  return t;
};
function BQe() {
  var e = Du(), t = dt(!1), n = dt(0), r = Jn(() => {
    if (!t.current) {
      t.current = !0;
      var o = xe.getWindow(e);
      o.cancelAnimationFrame(n.current), n.current = o.requestAnimationFrame(() => {
        t.current = !1;
      });
    }
  }, [e]);
  return h(() => () => cancelAnimationFrame(n.current), []), {
    receivedUserInput: t,
    onUserInput: r
  };
}
var FQe = 3, zQe = {
  bold: "mod+b",
  compose: ["down", "left", "right", "up", "backspace", "enter"],
  moveBackward: "left",
  moveForward: "right",
  moveWordBackward: "ctrl+left",
  moveWordForward: "ctrl+right",
  deleteBackward: "shift?+backspace",
  deleteForward: "shift?+delete",
  extendBackward: "shift+left",
  extendForward: "shift+right",
  italic: "mod+i",
  insertSoftBreak: "shift+enter",
  splitBlock: "enter",
  undo: "mod+z"
}, UQe = {
  moveLineBackward: "opt+up",
  moveLineForward: "opt+down",
  moveWordBackward: "opt+left",
  moveWordForward: "opt+right",
  deleteBackward: ["ctrl+backspace", "ctrl+h"],
  deleteForward: ["ctrl+delete", "ctrl+d"],
  deleteLineBackward: "cmd+shift?+backspace",
  deleteLineForward: ["cmd+shift?+delete", "ctrl+k"],
  deleteWordBackward: "opt+shift?+backspace",
  deleteWordForward: "opt+shift?+delete",
  extendLineBackward: "opt+shift+up",
  extendLineForward: "opt+shift+down",
  redo: "cmd+shift+z",
  transposeCharacter: "ctrl+t"
}, HQe = {
  deleteWordBackward: "ctrl+shift?+backspace",
  deleteWordForward: "ctrl+shift?+delete",
  redo: ["ctrl+y", "ctrl+shift+z"]
}, oo = (e) => {
  var t = zQe[e], n = UQe[e], r = HQe[e], o = t && SL(t), i = n && SL(n), a = r && SL(r);
  return (s) => !!(o && o(s) || n7 && i && i(s) || !n7 && a && a(s));
}, lo = {
  isBold: oo("bold"),
  isCompose: oo("compose"),
  isMoveBackward: oo("moveBackward"),
  isMoveForward: oo("moveForward"),
  isDeleteBackward: oo("deleteBackward"),
  isDeleteForward: oo("deleteForward"),
  isDeleteLineBackward: oo("deleteLineBackward"),
  isDeleteLineForward: oo("deleteLineForward"),
  isDeleteWordBackward: oo("deleteWordBackward"),
  isDeleteWordForward: oo("deleteWordForward"),
  isExtendBackward: oo("extendBackward"),
  isExtendForward: oo("extendForward"),
  isExtendLineBackward: oo("extendLineBackward"),
  isExtendLineForward: oo("extendLineForward"),
  isItalic: oo("italic"),
  isMoveLineBackward: oo("moveLineBackward"),
  isMoveLineForward: oo("moveLineForward"),
  isMoveWordBackward: oo("moveWordBackward"),
  isMoveWordForward: oo("moveWordForward"),
  isRedo: oo("redo"),
  isSoftBreak: oo("insertSoftBreak"),
  isSplitBlock: oo("splitBlock"),
  isTransposeCharacter: oo("transposeCharacter"),
  isUndo: oo("undo")
}, WQe = (e, t) => {
  var n = [], r = () => {
    n = [];
  }, o = (a) => {
    if (t.current) {
      var s = a.filter((l) => Lj(e, l, a));
      n.push(...s);
    }
  };
  function i() {
    n.length > 0 && (n.reverse().forEach((a) => {
      a.type !== "characterData" && (a.removedNodes.forEach((s) => {
        a.target.insertBefore(s, a.nextSibling);
      }), a.addedNodes.forEach((s) => {
        a.target.removeChild(s);
      }));
    }), r());
  }
  return {
    registerMutations: o,
    restoreDOM: i,
    clear: r
  };
}, $Qe = {
  subtree: !0,
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0
};
class Vie extends au {
  constructor() {
    super(...arguments), Ws(this, "context", null), Ws(this, "manager", null), Ws(this, "mutationObserver", null);
  }
  observe() {
    var t, {
      node: n
    } = this.props;
    if (!n.current)
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    (t = this.mutationObserver) === null || t === void 0 || t.observe(n.current, $Qe);
  }
  componentDidMount() {
    var {
      receivedUserInput: t
    } = this.props, n = this.context;
    this.manager = WQe(n, t), this.mutationObserver = new MutationObserver(this.manager.registerMutations), this.observe();
  }
  getSnapshotBeforeUpdate() {
    var t, n, r, o = (t = this.mutationObserver) === null || t === void 0 ? void 0 : t.takeRecords();
    if (o != null && o.length) {
      var i;
      (i = this.manager) === null || i === void 0 || i.registerMutations(o);
    }
    return (n = this.mutationObserver) === null || n === void 0 || n.disconnect(), (r = this.manager) === null || r === void 0 || r.restoreDOM(), null;
  }
  componentDidUpdate() {
    var t;
    (t = this.manager) === null || t === void 0 || t.clear(), this.observe();
  }
  componentWillUnmount() {
    var t;
    (t = this.mutationObserver) === null || t === void 0 || t.disconnect();
  }
  render() {
    return this.props.children;
  }
}
Ws(Vie, "contextType", Cj);
var VQe = Si ? Vie : (e) => {
  var {
    children: t
  } = e;
  return /* @__PURE__ */ be.createElement(be.Fragment, null, t);
}, ZQe = /* @__PURE__ */ $e(!1), qQe = ["autoFocus", "decorate", "onDOMBeforeInput", "placeholder", "readOnly", "renderElement", "renderLeaf", "renderPlaceholder", "scrollSelectionIntoView", "style", "as", "disableDefaultStyles"], GQe = ["text"];
function f7(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ea(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? f7(Object(n), !0).forEach(function(r) {
      Ws(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : f7(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var KQe = (e) => /* @__PURE__ */ be.createElement(be.Fragment, null, Hie(e)), XQe = /* @__PURE__ */ Cr((e, t) => {
  var n = Jn((j) => /* @__PURE__ */ be.createElement(YQe, ea({}, j)), []), {
    autoFocus: r,
    decorate: o = JQe,
    onDOMBeforeInput: i,
    placeholder: a,
    readOnly: s = !1,
    renderElement: l,
    renderLeaf: u,
    renderPlaceholder: c = n,
    scrollSelectionIntoView: p = QQe,
    style: d = {},
    as: g = "div",
    disableDefaultStyles: f = !1
  } = e, m = Pp(e, qQe), b = nx(), [E, w] = k(!1), M = dt(null), x = dt([]), [v, C] = k(), P = dt(!1), {
    onUserInput: F,
    receivedUserInput: L
  } = BQe(), [, B] = Kse((j) => j + 1, 0);
  Mie.set(b, B), TP.set(b, s);
  var N = ln(() => ({
    isDraggingInternally: !1,
    isUpdatingSelection: !1,
    latestElement: null,
    hasMarkPlaceholder: !1
  }), []);
  h(() => {
    M.current && r && M.current.focus();
  }, [r]);
  var $ = dt(), V = ln(() => uJe(() => {
    if (yp.get(b)) {
      V();
      return;
    }
    var j = xe.toDOMNode(b, b), U = j.getRootNode();
    if (!P.current && oc && U instanceof ShadowRoot) {
      P.current = !0;
      var T = YJe();
      T ? document.execCommand("indent") : Be.deselect(b), P.current = !1;
      return;
    }
    var q = $.current;
    if ((Si || !xe.isComposing(b)) && (!N.isUpdatingSelection || q != null && q.isFlushing()) && !N.isDraggingInternally) {
      var A = xe.findDocumentOrShadowRoot(b), {
        activeElement: X
      } = A, I = xe.toDOMNode(b, b), le = Bf(A);
      if (X === I ? (N.latestElement = X, ou.set(b, !0)) : ou.delete(b), !le)
        return Be.deselect(b);
      var {
        anchorNode: he,
        focusNode: oe
      } = le, Ae = xe.hasEditableTarget(b, he) || xe.isTargetInsideNonReadonlyVoid(b, he), Ue = xe.hasTarget(b, oe);
      if (Ae && Ue) {
        var He = xe.toSlateRange(b, le, {
          exactMatch: !1,
          suppressThrow: !0
        });
        He && (!xe.isComposing(b) && !(q != null && q.hasPendingChanges()) && !(q != null && q.isFlushing()) ? Be.select(b, He) : q == null || q.handleUserSelect(He));
      }
      s && (!Ae || !Ue) && Be.deselect(b);
    }
  }, 100), [b, s, N]), H = ln(() => rJe(V, 0), [V]);
  $.current = vQe({
    node: M,
    onDOMSelectionChange: V,
    scheduleOnDOMSelectionChange: H
  }), Vh(() => {
    var j, U, T;
    M.current && (T = kj(M.current)) ? (Sie.set(b, T), Ry.set(b, M.current), Lc.set(b, M.current), $h.set(M.current, b)) : Lc.delete(b);
    var {
      selection: q
    } = b, A = xe.findDocumentOrShadowRoot(b), X = Bf(A);
    if (!(!X || !xe.isFocused(b) || (j = $.current) !== null && j !== void 0 && j.hasPendingAction())) {
      var I = (Ae) => {
        var Ue = X.type !== "None";
        if (!(!q && !Ue)) {
          var He = X.focusNode, Re;
          if (up && X.rangeCount > 1) {
            var nt = X.getRangeAt(0), Ve = X.getRangeAt(X.rangeCount - 1);
            nt.startContainer === He ? Re = Ve.endContainer : Re = nt.startContainer;
          } else
            Re = X.anchorNode;
          var we = Ry.get(b), et = !1;
          if (we.contains(Re) && we.contains(He) && (et = !0), Ue && et && q && !Ae) {
            var lt = xe.toSlateRange(b, X, {
              exactMatch: !0,
              // domSelection is not necessarily a valid Slate range
              // (e.g. when clicking on contentEditable:false element)
              suppressThrow: !0
            });
            if (lt && ve.equals(lt, q)) {
              var ye;
              if (!N.hasMarkPlaceholder || (ye = Re) !== null && ye !== void 0 && (ye = ye.parentElement) !== null && ye !== void 0 && ye.hasAttribute("data-slate-mark-placeholder"))
                return;
            }
          }
          if (q && !xe.hasRange(b, q)) {
            b.selection = xe.toSlateRange(b, X, {
              exactMatch: !1,
              suppressThrow: !0
            });
            return;
          }
          N.isUpdatingSelection = !0;
          var ke = q && xe.toDOMRange(b, q);
          return ke ? (xe.isComposing(b) && !Si ? X.collapseToEnd() : ve.isBackward(q) ? X.setBaseAndExtent(ke.endContainer, ke.endOffset, ke.startContainer, ke.startOffset) : X.setBaseAndExtent(ke.startContainer, ke.startOffset, ke.endContainer, ke.endOffset), p(b, ke)) : X.removeAllRanges(), ke;
        }
      };
      X.rangeCount <= 1 && I();
      var le = ((U = $.current) === null || U === void 0 ? void 0 : U.isFlushing()) === "action";
      if (!Si || !le) {
        setTimeout(() => {
          N.isUpdatingSelection = !1;
        });
        return;
      }
      var he = null, oe = requestAnimationFrame(() => {
        if (le) {
          var Ae = (Ue) => {
            try {
              var He = xe.toDOMNode(b, b);
              He.focus(), I(Ue);
            } catch {
            }
          };
          Ae(), he = setTimeout(() => {
            Ae(!0), N.isUpdatingSelection = !1;
          });
        }
      });
      return () => {
        cancelAnimationFrame(oe), he && clearTimeout(he);
      };
    }
  });
  var Z = Jn((j) => {
    var U = xe.toDOMNode(b, b), T = U.getRootNode();
    if (P != null && P.current && oc && T instanceof ShadowRoot) {
      var q = j.getTargetRanges(), A = q[0], X = new window.Range();
      X.setStart(A.startContainer, A.startOffset), X.setEnd(A.endContainer, A.endOffset);
      var I = xe.toSlateRange(b, X, {
        exactMatch: !1,
        suppressThrow: !1
      });
      Be.select(b, I), j.preventDefault(), j.stopImmediatePropagation();
      return;
    }
    if (F(), !s && xe.hasEditableTarget(b, j.target) && !eet(j, i)) {
      var le;
      if ($.current)
        return $.current.handleDOMBeforeInput(j);
      H.flush(), V.flush();
      var {
        selection: he
      } = b, {
        inputType: oe
      } = j, Ae = j.dataTransfer || j.data || void 0, Ue = oe === "insertCompositionText" || oe === "deleteCompositionText";
      if (Ue && xe.isComposing(b))
        return;
      var He = !1;
      if (oe === "insertText" && he && ve.isCollapsed(he) && // Only use native character insertion for single characters a-z or space for now.
      // Long-press events (hold a + press 4 = ä) to choose a special character otherwise
      // causes duplicate inserts.
      j.data && j.data.length === 1 && /[a-z ]/i.test(j.data) && // Chrome has issues correctly editing the start of nodes: https://bugs.chromium.org/p/chromium/issues/detail?id=1249405
      // When there is an inline element, e.g. a link, and you select
      // right after it (the start of the next node).
      he.anchor.offset !== 0 && (He = !0, b.marks && (He = !1), !yp.get(b))) {
        var Re, nt, {
          anchor: Ve
        } = he, [we, et] = xe.toDOMPoint(b, Ve), lt = (Re = we.parentElement) === null || Re === void 0 ? void 0 : Re.closest("a"), ye = xe.getWindow(b);
        if (He && lt && xe.hasDOMNode(b, lt)) {
          var ke, Qe = ye == null ? void 0 : ye.document.createTreeWalker(lt, NodeFilter.SHOW_TEXT).lastChild();
          Qe === we && ((ke = Qe.textContent) === null || ke === void 0 ? void 0 : ke.length) === et && (He = !1);
        }
        if (He && we.parentElement && (ye == null || (nt = ye.getComputedStyle(we.parentElement)) === null || nt === void 0 ? void 0 : nt.whiteSpace) === "pre") {
          var Fe = te.above(b, {
            at: Ve.path,
            match: (st) => ft.isElement(st) && te.isBlock(b, st)
          });
          Fe && tt.string(Fe[0]).includes("	") && (He = !1);
        }
      }
      if ((!oe.startsWith("delete") || oe.startsWith("deleteBy")) && !yp.get(b)) {
        var [Ie] = j.getTargetRanges();
        if (Ie) {
          var ot = xe.toSlateRange(b, Ie, {
            exactMatch: !1,
            suppressThrow: !1
          });
          if (!he || !ve.equals(he, ot)) {
            He = !1;
            var Ee = !Ue && b.selection && te.rangeRef(b, b.selection);
            Be.select(b, ot), Ee && Nf.set(b, Ee);
          }
        }
      }
      if (Ue)
        return;
      if (He || j.preventDefault(), he && ve.isExpanded(he) && oe.startsWith("delete")) {
        var wt = oe.endsWith("Backward") ? "backward" : "forward";
        te.deleteFragment(b, {
          direction: wt
        });
        return;
      }
      switch (oe) {
        case "deleteByComposition":
        case "deleteByCut":
        case "deleteByDrag": {
          te.deleteFragment(b);
          break;
        }
        case "deleteContent":
        case "deleteContentForward": {
          te.deleteForward(b);
          break;
        }
        case "deleteContentBackward": {
          te.deleteBackward(b);
          break;
        }
        case "deleteEntireSoftLine": {
          te.deleteBackward(b, {
            unit: "line"
          }), te.deleteForward(b, {
            unit: "line"
          });
          break;
        }
        case "deleteHardLineBackward": {
          te.deleteBackward(b, {
            unit: "block"
          });
          break;
        }
        case "deleteSoftLineBackward": {
          te.deleteBackward(b, {
            unit: "line"
          });
          break;
        }
        case "deleteHardLineForward": {
          te.deleteForward(b, {
            unit: "block"
          });
          break;
        }
        case "deleteSoftLineForward": {
          te.deleteForward(b, {
            unit: "line"
          });
          break;
        }
        case "deleteWordBackward": {
          te.deleteBackward(b, {
            unit: "word"
          });
          break;
        }
        case "deleteWordForward": {
          te.deleteForward(b, {
            unit: "word"
          });
          break;
        }
        case "insertLineBreak":
          te.insertSoftBreak(b);
          break;
        case "insertParagraph": {
          te.insertBreak(b);
          break;
        }
        case "insertFromComposition":
        case "insertFromDrop":
        case "insertFromPaste":
        case "insertFromYank":
        case "insertReplacementText":
        case "insertText": {
          oe === "insertFromComposition" && xe.isComposing(b) && (w(!1), Cc.set(b, !1)), (Ae == null ? void 0 : Ae.constructor.name) === "DataTransfer" ? xe.insertData(b, Ae) : typeof Ae == "string" && (He ? x.current.push(() => te.insertText(b, Ae)) : te.insertText(b, Ae));
          break;
        }
      }
      var it = (le = Nf.get(b)) === null || le === void 0 ? void 0 : le.unref();
      Nf.delete(b), it && (!b.selection || !ve.equals(b.selection, it)) && Be.select(b, it);
    }
  }, [b, V, F, i, s, H]), K = Jn((j) => {
    j == null ? (V.cancel(), H.cancel(), Ry.delete(b), Lc.delete(b), M.current && Pl && M.current.removeEventListener("beforeinput", Z)) : Pl && j.addEventListener("beforeinput", Z), M.current = j, typeof t == "function" ? t(j) : t && (t.current = j);
  }, [V, H, b, Z, t]);
  Vh(() => {
    var j = xe.getWindow(b);
    j.document.addEventListener("selectionchange", H);
    var U = () => {
      N.isDraggingInternally = !1;
    };
    return j.document.addEventListener("dragend", U), j.document.addEventListener("drop", U), () => {
      j.document.removeEventListener("selectionchange", H), j.document.removeEventListener("dragend", U), j.document.removeEventListener("drop", U);
    };
  }, [H, N]);
  var Y = o([b, []]), Q = a && b.children.length === 1 && Array.from(tt.texts(b)).length === 1 && tt.string(b) === "" && !E, J = Jn((j) => {
    if (j && Q) {
      var U;
      C((U = j.getBoundingClientRect()) === null || U === void 0 ? void 0 : U.height);
    } else
      C(void 0);
  }, [Q]);
  if (Q) {
    var _ = te.start(b, []);
    Y.push({
      [Sp]: !0,
      placeholder: a,
      onPlaceholderResize: J,
      anchor: _,
      focus: _
    });
  }
  var {
    marks: D
  } = b;
  if (N.hasMarkPlaceholder = !1, b.selection && ve.isCollapsed(b.selection) && D) {
    var {
      anchor: z
    } = b.selection, S = tt.leaf(b, z.path), W = Pp(S, GQe);
    if (!ht.equals(S, D, {
      loose: !0
    })) {
      N.hasMarkPlaceholder = !0;
      var O = Object.fromEntries(Object.keys(W).map((j) => [j, null]));
      Y.push(ea(ea(ea({
        [Die]: !0
      }, O), D), {}, {
        anchor: z,
        focus: z
      }));
    }
  }
  return h(() => {
    setTimeout(() => {
      var {
        selection: j
      } = b;
      if (j) {
        var {
          anchor: U
        } = j, T = tt.leaf(b, U.path);
        if (D && !ht.equals(T, D, {
          loose: !0
        })) {
          $s.set(b, D);
          return;
        }
      }
      $s.delete(b);
    });
  }), /* @__PURE__ */ be.createElement(Wie.Provider, {
    value: s
  }, /* @__PURE__ */ be.createElement(ZQe.Provider, {
    value: E
  }, /* @__PURE__ */ be.createElement(Uie.Provider, {
    value: o
  }, /* @__PURE__ */ be.createElement(VQe, {
    node: M,
    receivedUserInput: L
  }, /* @__PURE__ */ be.createElement(g, ea(ea({
    role: s ? void 0 : "textbox",
    "aria-multiline": s ? void 0 : !0
  }, m), {}, {
    // COMPAT: Certain browsers don't support the `beforeinput` event, so we'd
    // have to use hacks to make these replacement-based features work.
    // For SSR situations HAS_BEFORE_INPUT_SUPPORT is false and results in prop
    // mismatch warning app moves to browser. Pass-through consumer props when
    // not CAN_USE_DOM (SSR) and default to falsy value
    spellCheck: Pl || !Ay ? m.spellCheck : !1,
    autoCorrect: Pl || !Ay ? m.autoCorrect : "false",
    autoCapitalize: Pl || !Ay ? m.autoCapitalize : "false",
    "data-slate-editor": !0,
    "data-slate-node": "value",
    // explicitly set this
    contentEditable: !s,
    // in some cases, a decoration needs access to the range / selection to decorate a text node,
    // then you will select the whole text node when you select part the of text
    // this magic zIndex="-1" will fix it
    zindex: -1,
    suppressContentEditableWarning: !0,
    ref: K,
    style: ea(ea({}, f ? {} : ea({
      // Allow positioning relative to the editable element.
      position: "relative",
      // Preserve adjacent whitespace and new lines.
      whiteSpace: "pre-wrap",
      // Allow words to break if they are too long.
      wordWrap: "break-word"
    }, v ? {
      minHeight: v
    } : {})), d),
    onBeforeInput: Jn((j) => {
      if (!Pl && !s && !_i(j, m.onBeforeInput) && xe.hasSelectableTarget(b, j.target) && (j.preventDefault(), !xe.isComposing(b))) {
        var U = j.data;
        te.insertText(b, U);
      }
    }, [m.onBeforeInput, b, s]),
    onInput: Jn((j) => {
      if (!_i(j, m.onInput)) {
        if ($.current) {
          $.current.handleInput();
          return;
        }
        for (var U of x.current)
          U();
        if (x.current = [], !xe.isFocused(b)) {
          var T = j.nativeEvent, q = b;
          if (T.inputType === "historyUndo" && typeof q.undo == "function") {
            q.undo();
            return;
          }
          if (T.inputType === "historyRedo" && typeof q.redo == "function") {
            q.redo();
            return;
          }
        }
      }
    }, [m.onInput, b]),
    onBlur: Jn((j) => {
      if (!(s || N.isUpdatingSelection || !xe.hasSelectableTarget(b, j.target) || _i(j, m.onBlur))) {
        var U = xe.findDocumentOrShadowRoot(b);
        if (N.latestElement !== U.activeElement) {
          var {
            relatedTarget: T
          } = j, q = xe.toDOMNode(b, b);
          if (T !== q && !(Hs(T) && T.hasAttribute("data-slate-spacer"))) {
            if (T != null && su(T) && xe.hasDOMNode(b, T)) {
              var A = xe.toSlateNode(b, T);
              if (ft.isElement(A) && !b.isVoid(A))
                return;
            }
            if (oc) {
              var X = Bf(U);
              X == null || X.removeAllRanges();
            }
            ou.delete(b);
          }
        }
      }
    }, [s, N.isUpdatingSelection, N.latestElement, b, m.onBlur]),
    onClick: Jn((j) => {
      if (xe.hasTarget(b, j.target) && !_i(j, m.onClick) && su(j.target)) {
        var U = xe.toSlateNode(b, j.target), T = xe.findPath(b, U);
        if (!te.hasPath(b, T) || tt.get(b, T) !== U)
          return;
        if (j.detail === FQe && T.length >= 1) {
          var q = T;
          if (!(ft.isElement(U) && te.isBlock(b, U))) {
            var A, X = te.above(b, {
              match: (He) => ft.isElement(He) && te.isBlock(b, He),
              at: T
            });
            q = (A = X == null ? void 0 : X[1]) !== null && A !== void 0 ? A : T.slice(0, 1);
          }
          var I = te.range(b, q);
          Be.select(b, I);
          return;
        }
        if (s)
          return;
        var le = te.start(b, T), he = te.end(b, T), oe = te.void(b, {
          at: le
        }), Ae = te.void(b, {
          at: he
        });
        if (oe && Ae && ce.equals(oe[1], Ae[1])) {
          var Ue = te.range(b, le);
          Be.select(b, Ue);
        }
      }
    }, [b, m.onClick, s]),
    onCompositionEnd: Jn((j) => {
      if (xe.hasSelectableTarget(b, j.target)) {
        var U;
        if (xe.isComposing(b) && Promise.resolve().then(() => {
          w(!1), Cc.set(b, !1);
        }), (U = $.current) === null || U === void 0 || U.handleCompositionEnd(j), _i(j, m.onCompositionEnd) || Si)
          return;
        if (!oc && !zJe && !_ie && !HJe && !UJe && j.data) {
          var T = $s.get(b);
          $s.delete(b), T !== void 0 && (Ga.set(b, b.marks), b.marks = T), te.insertText(b, j.data);
          var q = Ga.get(b);
          Ga.delete(b), q !== void 0 && (b.marks = q);
        }
      }
    }, [m.onCompositionEnd, b]),
    onCompositionUpdate: Jn((j) => {
      xe.hasSelectableTarget(b, j.target) && !_i(j, m.onCompositionUpdate) && (xe.isComposing(b) || (w(!0), Cc.set(b, !0)));
    }, [m.onCompositionUpdate, b]),
    onCompositionStart: Jn((j) => {
      if (xe.hasSelectableTarget(b, j.target)) {
        var U;
        if ((U = $.current) === null || U === void 0 || U.handleCompositionStart(j), _i(j, m.onCompositionStart) || Si)
          return;
        w(!0);
        var {
          selection: T
        } = b;
        if (T && ve.isExpanded(T)) {
          te.deleteFragment(b);
          return;
        }
      }
    }, [m.onCompositionStart, b]),
    onCopy: Jn((j) => {
      xe.hasSelectableTarget(b, j.target) && !_i(j, m.onCopy) && !h7(j) && (j.preventDefault(), xe.setFragmentData(b, j.clipboardData, "copy"));
    }, [m.onCopy, b]),
    onCut: Jn((j) => {
      if (!s && xe.hasSelectableTarget(b, j.target) && !_i(j, m.onCut) && !h7(j)) {
        j.preventDefault(), xe.setFragmentData(b, j.clipboardData, "cut");
        var {
          selection: U
        } = b;
        if (U)
          if (ve.isExpanded(U))
            te.deleteFragment(b);
          else {
            var T = tt.parent(b, U.anchor.path);
            te.isVoid(b, T) && Be.delete(b);
          }
      }
    }, [s, b, m.onCut]),
    onDragOver: Jn((j) => {
      if (xe.hasTarget(b, j.target) && !_i(j, m.onDragOver)) {
        var U = xe.toSlateNode(b, j.target);
        ft.isElement(U) && te.isVoid(b, U) && j.preventDefault();
      }
    }, [m.onDragOver, b]),
    onDragStart: Jn((j) => {
      if (!s && xe.hasTarget(b, j.target) && !_i(j, m.onDragStart)) {
        var U = xe.toSlateNode(b, j.target), T = xe.findPath(b, U), q = ft.isElement(U) && te.isVoid(b, U) || te.void(b, {
          at: T,
          voids: !0
        });
        if (q) {
          var A = te.range(b, T);
          Be.select(b, A);
        }
        N.isDraggingInternally = !0, xe.setFragmentData(b, j.dataTransfer, "drag");
      }
    }, [s, b, m.onDragStart, N]),
    onDrop: Jn((j) => {
      if (!s && xe.hasTarget(b, j.target) && !_i(j, m.onDrop)) {
        j.preventDefault();
        var U = b.selection, T = xe.findEventRange(b, j), q = j.dataTransfer;
        Be.select(b, T), N.isDraggingInternally && U && !ve.equals(U, T) && !te.void(b, {
          at: T,
          voids: !0
        }) && Be.delete(b, {
          at: U
        }), xe.insertData(b, q), xe.isFocused(b) || xe.focus(b);
      }
    }, [s, b, m.onDrop, N]),
    onDragEnd: Jn((j) => {
      !s && N.isDraggingInternally && m.onDragEnd && xe.hasTarget(b, j.target) && m.onDragEnd(j);
    }, [s, N, m, b]),
    onFocus: Jn((j) => {
      if (!s && !N.isUpdatingSelection && xe.hasEditableTarget(b, j.target) && !_i(j, m.onFocus)) {
        var U = xe.toDOMNode(b, b), T = xe.findDocumentOrShadowRoot(b);
        if (N.latestElement = T.activeElement, up && j.target !== U) {
          U.focus();
          return;
        }
        ou.set(b, !0);
      }
    }, [s, N, b, m.onFocus]),
    onKeyDown: Jn((j) => {
      if (!s && xe.hasEditableTarget(b, j.target)) {
        var U;
        (U = $.current) === null || U === void 0 || U.handleKeyDown(j);
        var {
          nativeEvent: T
        } = j;
        if (xe.isComposing(b) && T.isComposing === !1 && (Cc.set(b, !1), w(!1)), _i(j, m.onKeyDown) || xe.isComposing(b))
          return;
        var {
          selection: q
        } = b, A = b.children[q !== null ? q.focus.path[0] : 0], X = gie(tt.string(A)) === "rtl";
        if (lo.isRedo(T)) {
          j.preventDefault();
          var I = b;
          typeof I.redo == "function" && I.redo();
          return;
        }
        if (lo.isUndo(T)) {
          j.preventDefault();
          var le = b;
          typeof le.undo == "function" && le.undo();
          return;
        }
        if (lo.isMoveLineBackward(T)) {
          j.preventDefault(), Be.move(b, {
            unit: "line",
            reverse: !0
          });
          return;
        }
        if (lo.isMoveLineForward(T)) {
          j.preventDefault(), Be.move(b, {
            unit: "line"
          });
          return;
        }
        if (lo.isExtendLineBackward(T)) {
          j.preventDefault(), Be.move(b, {
            unit: "line",
            edge: "focus",
            reverse: !0
          });
          return;
        }
        if (lo.isExtendLineForward(T)) {
          j.preventDefault(), Be.move(b, {
            unit: "line",
            edge: "focus"
          });
          return;
        }
        if (lo.isMoveBackward(T)) {
          j.preventDefault(), q && ve.isCollapsed(q) ? Be.move(b, {
            reverse: !X
          }) : Be.collapse(b, {
            edge: X ? "end" : "start"
          });
          return;
        }
        if (lo.isMoveForward(T)) {
          j.preventDefault(), q && ve.isCollapsed(q) ? Be.move(b, {
            reverse: X
          }) : Be.collapse(b, {
            edge: X ? "start" : "end"
          });
          return;
        }
        if (lo.isMoveWordBackward(T)) {
          j.preventDefault(), q && ve.isExpanded(q) && Be.collapse(b, {
            edge: "focus"
          }), Be.move(b, {
            unit: "word",
            reverse: !X
          });
          return;
        }
        if (lo.isMoveWordForward(T)) {
          j.preventDefault(), q && ve.isExpanded(q) && Be.collapse(b, {
            edge: "focus"
          }), Be.move(b, {
            unit: "word",
            reverse: X
          });
          return;
        }
        if (Pl) {
          if ((Pie || oc) && q && (lo.isDeleteBackward(T) || lo.isDeleteForward(T)) && ve.isCollapsed(q)) {
            var he = tt.parent(b, q.anchor.path);
            if (ft.isElement(he) && te.isVoid(b, he) && (te.isInline(b, he) || te.isBlock(b, he))) {
              j.preventDefault(), te.deleteBackward(b, {
                unit: "block"
              });
              return;
            }
          }
        } else {
          if (lo.isBold(T) || lo.isItalic(T) || lo.isTransposeCharacter(T)) {
            j.preventDefault();
            return;
          }
          if (lo.isSoftBreak(T)) {
            j.preventDefault(), te.insertSoftBreak(b);
            return;
          }
          if (lo.isSplitBlock(T)) {
            j.preventDefault(), te.insertBreak(b);
            return;
          }
          if (lo.isDeleteBackward(T)) {
            j.preventDefault(), q && ve.isExpanded(q) ? te.deleteFragment(b, {
              direction: "backward"
            }) : te.deleteBackward(b);
            return;
          }
          if (lo.isDeleteForward(T)) {
            j.preventDefault(), q && ve.isExpanded(q) ? te.deleteFragment(b, {
              direction: "forward"
            }) : te.deleteForward(b);
            return;
          }
          if (lo.isDeleteLineBackward(T)) {
            j.preventDefault(), q && ve.isExpanded(q) ? te.deleteFragment(b, {
              direction: "backward"
            }) : te.deleteBackward(b, {
              unit: "line"
            });
            return;
          }
          if (lo.isDeleteLineForward(T)) {
            j.preventDefault(), q && ve.isExpanded(q) ? te.deleteFragment(b, {
              direction: "forward"
            }) : te.deleteForward(b, {
              unit: "line"
            });
            return;
          }
          if (lo.isDeleteWordBackward(T)) {
            j.preventDefault(), q && ve.isExpanded(q) ? te.deleteFragment(b, {
              direction: "backward"
            }) : te.deleteBackward(b, {
              unit: "word"
            });
            return;
          }
          if (lo.isDeleteWordForward(T)) {
            j.preventDefault(), q && ve.isExpanded(q) ? te.deleteFragment(b, {
              direction: "forward"
            }) : te.deleteForward(b, {
              unit: "word"
            });
            return;
          }
        }
      }
    }, [s, b, m.onKeyDown]),
    onPaste: Jn((j) => {
      !s && xe.hasEditableTarget(b, j.target) && !_i(j, m.onPaste) && (!Pl || VJe(j.nativeEvent) || oc) && (j.preventDefault(), xe.insertData(b, j.clipboardData));
    }, [s, b, m.onPaste])
  }), /* @__PURE__ */ be.createElement(KQe, {
    decorations: Y,
    node: b,
    renderElement: l,
    renderPlaceholder: c,
    renderLeaf: u,
    selection: b.selection
  }))))));
}), YQe = (e) => {
  var {
    attributes: t,
    children: n
  } = e;
  return (
    // COMPAT: Artificially add a line-break to the end on the placeholder element
    // to prevent Android IMEs to pick up its content in autocorrect and to auto-capitalize the first letter
    /* @__PURE__ */ be.createElement("span", ea({}, t), n, Si && /* @__PURE__ */ be.createElement("br", null))
  );
}, JQe = () => [], QQe = (e, t) => {
  if (t.getBoundingClientRect && (!e.selection || e.selection && ve.isCollapsed(e.selection))) {
    var n = t.startContainer.parentElement;
    n.getBoundingClientRect = t.getBoundingClientRect.bind(t), dJe(n, {
      scrollMode: "if-needed"
    }), delete n.getBoundingClientRect;
  }
}, _i = (e, t) => {
  if (!t)
    return !1;
  var n = t(e);
  return n ?? (e.isDefaultPrevented() || e.isPropagationStopped());
}, h7 = (e) => su(e.target) && (e.target instanceof HTMLInputElement || e.target instanceof HTMLTextAreaElement), eet = (e, t) => {
  if (!t)
    return !1;
  var n = t(e);
  return n ?? e.defaultPrevented;
}, tet = /* @__PURE__ */ $e(!1), net = /* @__PURE__ */ $e({});
function ret(e) {
  var t = dt([]).current, n = dt({
    editor: e
  }).current, r = Jn((i) => {
    n.editor = i, t.forEach((a) => a(i));
  }, [t, n]), o = ln(() => ({
    getSlate: () => n.editor,
    addEventListener: (i) => (t.push(i), () => {
      t.splice(t.indexOf(i), 1);
    })
  }), [t, n]);
  return {
    selectorContext: o,
    onChange: r
  };
}
var oet = ["editor", "children", "onChange", "onSelectionChange", "onValueChange", "initialValue"], iet = (e) => {
  var {
    editor: t,
    children: n,
    onChange: r,
    onSelectionChange: o,
    onValueChange: i,
    initialValue: a
  } = e, s = Pp(e, oet), [l, u] = be.useState(() => {
    if (!tt.isNodeList(a))
      throw new Error("[Slate] initialValue is invalid! Expected a list of elements but got: ".concat(Ko.stringify(a)));
    if (!te.isEditor(t))
      throw new Error("[Slate] editor is invalid! You passed: ".concat(Ko.stringify(t)));
    return t.children = a, Object.assign(t, s), {
      v: 0,
      editor: t
    };
  }), {
    selectorContext: c,
    onChange: p
  } = ret(t), d = Jn((m) => {
    var b;
    switch (r && r(t.children), m == null || (b = m.operation) === null || b === void 0 ? void 0 : b.type) {
      case "set_selection":
        o == null || o(t.selection);
        break;
      default:
        i == null || i(t.children);
    }
    u((E) => ({
      v: E.v + 1,
      editor: t
    })), p(t);
  }, [t, p, r, o, i]);
  h(() => (jP.set(t, d), () => {
    jP.set(t, () => {
    });
  }), [t, d]);
  var [g, f] = k(xe.isFocused(t));
  return h(() => {
    f(xe.isFocused(t));
  }, [t]), Vh(() => {
    var m = () => f(xe.isFocused(t));
    return Lie >= 17 ? (document.addEventListener("focusin", m), document.addEventListener("focusout", m), () => {
      document.removeEventListener("focusin", m), document.removeEventListener("focusout", m);
    }) : (document.addEventListener("focus", m, !0), document.addEventListener("blur", m, !0), () => {
      document.removeEventListener("focus", m, !0), document.removeEventListener("blur", m, !0);
    });
  }, []), /* @__PURE__ */ be.createElement(net.Provider, {
    value: c
  }, /* @__PURE__ */ be.createElement($ie.Provider, {
    value: l
  }, /* @__PURE__ */ be.createElement(Cj.Provider, {
    value: l.editor
  }, /* @__PURE__ */ be.createElement(tet.Provider, {
    value: g
  }, n))));
}, g7 = (e, t) => {
  var n = (t.top + t.bottom) / 2;
  return e.top <= n && e.bottom >= n;
}, m7 = (e, t, n) => {
  var r = xe.toDOMRange(e, t).getBoundingClientRect(), o = xe.toDOMRange(e, n).getBoundingClientRect();
  return g7(r, o) && g7(o, r);
}, set = (e, t) => {
  var n = te.range(e, ve.end(t)), r = Array.from(te.positions(e, {
    at: t
  })), o = 0, i = r.length, a = Math.floor(i / 2);
  if (m7(e, te.range(e, r[o]), n))
    return te.range(e, r[o], n);
  if (r.length < 2)
    return te.range(e, r[r.length - 1], n);
  for (; a !== r.length && a !== o; )
    m7(e, te.range(e, r[a]), n) ? i = a : o = a, a = Math.floor((o + i) / 2);
  return te.range(e, r[i], n);
};
function v7(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function y7(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? v7(Object(n), !0).forEach(function(r) {
      Ws(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : v7(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var aet = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "x-slate-fragment", r = t, {
    apply: o,
    onChange: i,
    deleteBackward: a,
    addMark: s,
    removeMark: l
  } = r;
  return tx.set(r, /* @__PURE__ */ new WeakMap()), r.addMark = (u, c) => {
    var p, d;
    (p = Ej.get(r)) === null || p === void 0 || p(), !$s.get(r) && (d = zi.get(r)) !== null && d !== void 0 && d.length && $s.set(r, null), Ga.delete(r), s(u, c);
  }, r.removeMark = (u) => {
    var c;
    !$s.get(r) && (c = zi.get(r)) !== null && c !== void 0 && c.length && $s.set(r, null), Ga.delete(r), l(u);
  }, r.deleteBackward = (u) => {
    if (u !== "line")
      return a(u);
    if (r.selection && ve.isCollapsed(r.selection)) {
      var c = te.above(r, {
        match: (f) => ft.isElement(f) && te.isBlock(r, f),
        at: r.selection
      });
      if (c) {
        var [, p] = c, d = te.range(r, p, r.selection.anchor), g = set(r, d);
        ve.isCollapsed(g) || Be.delete(r, {
          at: g
        });
      }
    }
  }, r.apply = (u) => {
    var c = [], p = [], d = zi.get(r);
    if (d != null && d.length) {
      var g = d.map((H) => sQe(H, u)).filter(Boolean);
      zi.set(r, g);
    }
    var f = ql.get(r);
    f && ql.set(r, i7(r, f, u));
    var m = Zl.get(r);
    if (m != null && m.at) {
      var b = $t.isPoint(m == null ? void 0 : m.at) ? IP(r, m.at, u) : i7(r, m.at, u);
      Zl.set(r, b ? y7(y7({}, m), {}, {
        at: b
      }) : null);
    }
    switch (u.type) {
      case "insert_text":
      case "remove_text":
      case "set_node":
      case "split_node": {
        c.push(...sp(r, u.path));
        break;
      }
      case "set_selection": {
        var E;
        (E = Nf.get(r)) === null || E === void 0 || E.unref(), Nf.delete(r);
        break;
      }
      case "insert_node":
      case "remove_node": {
        c.push(...sp(r, ce.parent(u.path)));
        break;
      }
      case "merge_node": {
        var w = ce.previous(u.path);
        c.push(...sp(r, w));
        break;
      }
      case "move_node": {
        var M = ce.common(ce.parent(u.path), ce.parent(u.newPath));
        c.push(...sp(r, M));
        var x;
        ce.isBefore(u.path, u.newPath) ? (c.push(...sp(r, ce.parent(u.path))), x = u.newPath) : (c.push(...sp(r, ce.parent(u.newPath))), x = u.path);
        var v = tt.get(t, ce.parent(x)), C = xe.findKey(r, v), P = te.pathRef(r, ce.parent(x));
        p.push([P, C]);
        break;
      }
    }
    switch (o(u), u.type) {
      case "insert_node":
      case "remove_node":
      case "merge_node":
      case "move_node":
      case "split_node":
        yp.set(r, !0);
    }
    for (var [F, L] of c) {
      var [B] = te.node(r, F);
      Xw.set(B, L);
    }
    for (var [N, $] of p) {
      if (N.current) {
        var [V] = te.node(r, N.current);
        Xw.set(V, $);
      }
      N.unref();
    }
  }, r.setFragmentData = (u) => {
    var {
      selection: c
    } = r;
    if (c) {
      var [p, d] = ve.edges(c), g = te.void(r, {
        at: p.path
      }), f = te.void(r, {
        at: d.path
      });
      if (!(ve.isCollapsed(c) && !g)) {
        var m = xe.toDOMRange(r, c), b = m.cloneContents(), E = b.childNodes[0];
        if (b.childNodes.forEach((B) => {
          B.textContent && B.textContent.trim() !== "" && (E = B);
        }), f) {
          var [w] = f, M = m.cloneRange(), x = xe.toDOMNode(r, w);
          M.setEndAfter(x), b = M.cloneContents();
        }
        if (g && (E = b.querySelector("[data-slate-spacer]")), Array.from(b.querySelectorAll("[data-slate-zero-width]")).forEach((B) => {
          var N = B.getAttribute("data-slate-zero-width") === "n";
          B.textContent = N ? `
` : "";
        }), jie(E)) {
          var v = E.ownerDocument.createElement("span");
          v.style.whiteSpace = "pre", v.appendChild(E), b.appendChild(v), E = v;
        }
        var C = r.getFragment(), P = JSON.stringify(C), F = window.btoa(encodeURIComponent(P));
        E.setAttribute("data-slate-fragment", F), u.setData("application/".concat(n), F);
        var L = b.ownerDocument.createElement("div");
        return L.appendChild(b), L.setAttribute("hidden", "true"), b.ownerDocument.body.appendChild(L), u.setData("text/html", L.innerHTML), u.setData("text/plain", Rie(L)), b.ownerDocument.body.removeChild(L), u;
      }
    }
  }, r.insertData = (u) => {
    r.insertFragmentData(u) || r.insertTextData(u);
  }, r.insertFragmentData = (u) => {
    var c = u.getData("application/".concat(n)) || XJe(u);
    if (c) {
      var p = decodeURIComponent(window.atob(c)), d = JSON.parse(p);
      return r.insertFragment(d), !0;
    }
    return !1;
  }, r.insertTextData = (u) => {
    var c = u.getData("text/plain");
    if (c) {
      var p = c.split(/\r\n|\r|\n/), d = !1;
      for (var g of p)
        d && Be.splitNodes(r, {
          always: !0
        }), r.insertText(g), d = !0;
      return !0;
    }
    return !1;
  }, r.onChange = (u) => {
    var c = Lie < 18 ? il.unstable_batchedUpdates : (p) => p();
    c(() => {
      var p = jP.get(r);
      p && p(u), i(u);
    });
  }, r;
}, sp = (e, t) => {
  var n = [];
  for (var [r, o] of te.levels(e, {
    at: t
  })) {
    var i = xe.findKey(e, r);
    n.push([o, i]);
  }
  return n;
};
function Zie(e, t, n = "type") {
  const { selection: r } = e;
  if (!r) return !1;
  const [o] = Array.from(
    te.nodes(e, {
      at: te.unhangRange(e, r),
      match: (i) => !te.isEditor(i) && ft.isElement(i) && i[n] === t
    })
  );
  return !!o;
}
const b7 = ["listItem", "numberedList"], Iy = ["left", "center", "right", "justify"];
function uet(e, t) {
  const n = Iy.includes(t) ? "align" : "type", r = Zie(e, t, n), o = b7.includes(t);
  Be.unwrapNodes(e, {
    match: (a) => !te.isEditor(a) && ft.isElement(a) && b7.includes(a.type) && !Iy.includes(t),
    split: !0
  });
  let i;
  if (Iy.includes(t) ? i = { align: r ? void 0 : t } : i = {
    type: r ? "paragraph" : o ? "listItem" : t
  }, Be.setNodes(e, i), !r && o) {
    const a = { type: t, children: [] };
    Be.wrapNodes(e, a);
  }
}
function qu({ format: e, icon: t }) {
  const n = nx(), r = Iy.includes(e) ? "align" : "type", i = Zie(n, e, r) ? "activeTrue" : "activeFalse";
  function a(s) {
    s.preventDefault(), uet(n, e);
  }
  return /* @__PURE__ */ ee.jsx(
    "button",
    {
      type: "button",
      className: "arkynRichTextBlockButton " + i,
      onMouseDown: a,
      children: /* @__PURE__ */ ee.jsx(t, {})
    }
  );
}
function cet({ attributes: e, children: t, element: n }) {
  const r = { textAlign: n.align };
  switch (n.type) {
    case "blockQuote":
      return /* @__PURE__ */ ee.jsx(
        "blockquote",
        {
          className: "arkynElementBlockquote",
          style: r,
          ...e,
          children: t
        }
      );
    case "bulletedList":
      return /* @__PURE__ */ ee.jsx("ul", { className: "arkynElementBulletList", style: r, ...e, children: t });
    case "headingOne":
      return /* @__PURE__ */ ee.jsx("h1", { className: "arkynElementHeadingOne", style: r, ...e, children: t });
    case "headingTwo":
      return /* @__PURE__ */ ee.jsx("h2", { className: "arkynElementHeadingTwo", style: r, ...e, children: t });
    case "listItem":
      return /* @__PURE__ */ ee.jsx("li", { className: "arkynElementListItem", style: r, ...e, children: t });
    case "numberedList":
      return /* @__PURE__ */ ee.jsx("ol", { className: "arkynElementNumberedList", style: r, ...e, children: t });
    case "image":
      return /* @__PURE__ */ ee.jsxs("div", { style: r, ...e, children: [
        /* @__PURE__ */ ee.jsx(
          "img",
          {
            className: "arkynElementImage",
            alt: "arkynElementImage",
            src: (n == null ? void 0 : n.src) || ""
          }
        ),
        t
      ] });
    default:
      return /* @__PURE__ */ ee.jsx("p", { className: "arkynElementParagraph", style: r, ...e, children: t });
  }
}
const qie = $e({});
function pet(e) {
  const {
    isVisibled: t,
    makeInvisible: n,
    children: r,
    className: o = "",
    ...i
  } = e, s = `arkynModalContainer ${t ? "visibleTrue" : "visibleFalse"} ${o}`;
  return /* @__PURE__ */ ee.jsx(qie.Provider, { value: { makeInvisible: n }, children: /* @__PURE__ */ ee.jsx(kG, { children: t && /* @__PURE__ */ ee.jsxs("aside", { className: s.trim(), ...i, children: [
    /* @__PURE__ */ ee.jsx(
      Uf.div,
      {
        className: "arkynModalContainerOverlay",
        transition: { duration: 0.15, ease: "easeOut" },
        initial: { opacity: 0 },
        animate: { opacity: 1 },
        exit: { opacity: 0 },
        onClick: n
      }
    ),
    /* @__PURE__ */ ee.jsx(
      Uf.div,
      {
        className: "arkynModalContainerContent",
        transition: { duration: 0.15, ease: "easeOut" },
        initial: { opacity: 0, scale: 0.75 },
        animate: { opacity: 1, scale: 1 },
        exit: { opacity: 0, scale: 0 },
        children: r
      }
    )
  ] }) }) });
}
function det(e) {
  const { alignment: t = "right", className: n, ...r } = e, o = `arkynModalFooter ${t} ${n}`;
  return /* @__PURE__ */ ee.jsx("footer", { className: o.trim(), ...r });
}
function fet(e) {
  const {
    showCloseButton: t = !0,
    className: n,
    children: r,
    ...o
  } = e, { makeInvisible: i } = ge(qie), a = `arkynModalHeader ${n}`;
  return /* @__PURE__ */ ee.jsxs("header", { className: a.trim(), ...o, children: [
    r,
    t && /* @__PURE__ */ ee.jsx(
      "button",
      {
        type: "button",
        onClick: i,
        "aria-label": "Close modal button",
        className: "arkynModalHeaderCloseButton",
        children: /* @__PURE__ */ ee.jsx(KP, { size: 24 })
      }
    )
  ] });
}
const BP = $e({});
function het() {
  if (!BP)
    throw new Error("useTabContext must be used within a TabProvider");
  return ge(BP);
}
function get(e) {
  const {
    children: t,
    onClick: n,
    defaultActive: r,
    className: o,
    ...i
  } = e, [a, s] = k(r || ""), [l, u] = k(!0), c = dt(null), p = `arkynTabContainer ${o || ""}`, [d, g] = k({
    width: "0px",
    left: "0px",
    transition: "none"
  }), f = (b, E) => {
    const w = b.getBoundingClientRect(), M = c.current.getBoundingClientRect(), x = E ? void 0 : "none";
    u(!1), g({
      transition: x,
      width: `${w.width}px`,
      left: `${w.left - M.left}px`
    });
  };
  h(() => {
    const b = c.current;
    if (!b) return;
    let E = null;
    E = b.querySelector("button.activeTrue"), E && f(E);
  }, []);
  const m = (b) => {
    const E = b.target;
    E && (s(E.value), E.classList.add("activeTrue"), f(E, !0), n && n(E.value));
  };
  return /* @__PURE__ */ ee.jsxs("nav", { ref: c, className: p.trim(), ...i, children: [
    /* @__PURE__ */ ee.jsx(BP.Provider, { value: { handleTabClick: m, showInitialTab: l, value: a }, children: t }),
    /* @__PURE__ */ ee.jsx("div", { className: "activeLine", style: d })
  ] });
}
function w7(e) {
  const { children: t, className: n = "", onClick: r, ...o } = e, { value: i, showInitialTab: a, handleTabClick: s } = het(), l = i === o.value && i ? "activeTrue" : "activeFalse", c = `arkynTabButton ${i === o.value && a ? "showBorderBottom" : ""} ${l} ${n}`;
  function p(d) {
    s(d), r && r(d);
  }
  return /* @__PURE__ */ ee.jsx(
    "button",
    {
      onClick: p,
      className: c.trim(),
      ...o,
      type: "button",
      children: t
    }
  );
}
function met(e) {
  const {
    action: t,
    tabLabels: n = ["Adicionar URL", "Upload de arquivo"],
    modalCancelButton: r = "Cancelar",
    modalConfirmButton: o = "Confirmar",
    modalInputImageLabel: i = "Imagem:",
    modalInputUrlLabel: a = "URL da imagem:",
    modalTitle: s = "Inserir imagem"
  } = e, l = nx(), [u, c] = k(!1), [p, d] = k(""), [g, f] = k("url");
  function m(b) {
    b.preventDefault(), !(!p || p === "") && (l.insertNodes([
      { type: "paragraph", children: [{ text: "" }] },
      { type: "image", src: p, children: [{ text: "" }] },
      { type: "paragraph", children: [{ text: "" }] }
    ]), c(!1));
  }
  return /* @__PURE__ */ ee.jsxs(ee.Fragment, { children: [
    /* @__PURE__ */ ee.jsx(
      "button",
      {
        type: "button",
        className: "arkynRichTextInsertImage",
        onMouseDown: () => c(!0),
        children: /* @__PURE__ */ ee.jsx(oae, {})
      }
    ),
    /* @__PURE__ */ ee.jsxs(
      pet,
      {
        isVisibled: u,
        makeInvisible: () => c(!1),
        children: [
          /* @__PURE__ */ ee.jsx(fet, { children: s }),
          /* @__PURE__ */ ee.jsxs("div", { className: "arkynRichTextInsertImageModalContent", children: [
            /* @__PURE__ */ ee.jsxs(get, { defaultActive: g, onClick: f, children: [
              /* @__PURE__ */ ee.jsx(w7, { value: "url", children: n[0] }),
              /* @__PURE__ */ ee.jsx(w7, { value: "file", children: n[1] })
            ] }),
            g === "url" && /* @__PURE__ */ ee.jsxs(ee.Fragment, { children: [
              /* @__PURE__ */ ee.jsxs(jZ, { children: [
                /* @__PURE__ */ ee.jsx(AZ, { children: a }),
                /* @__PURE__ */ ee.jsx(
                  QO,
                  {
                    type: "text",
                    name: "richTextimageURL",
                    defaultValue: p,
                    onChange: (b) => d(b.target.value)
                  }
                )
              ] }),
              p && /* @__PURE__ */ ee.jsx(
                "img",
                {
                  className: "arkynRichTextInsertImageModalPreviewImage",
                  src: p,
                  alt: "preview"
                }
              )
            ] }),
            g === "file" && /* @__PURE__ */ ee.jsxs(jZ, { children: [
              /* @__PURE__ */ ee.jsx(AZ, { children: i }),
              /* @__PURE__ */ ee.jsx(
                mXe,
                {
                  name: "richTextimageURL",
                  action: t,
                  defaultValue: p,
                  onUpload: (b) => d(b || "")
                }
              )
            ] })
          ] }),
          /* @__PURE__ */ ee.jsxs(det, { children: [
            /* @__PURE__ */ ee.jsx(
              Uh,
              {
                type: "button",
                scheme: "danger",
                variant: "outline",
                onClick: () => c(!1),
                children: r
              }
            ),
            /* @__PURE__ */ ee.jsx(Uh, { type: "button", onClick: m, children: o })
          ] })
        ]
      }
    )
  ] });
}
function vet({ attributes: e, children: t, leaf: n }) {
  return n.bold && (t = /* @__PURE__ */ ee.jsx("strong", { children: t })), n.code && (t = /* @__PURE__ */ ee.jsx("code", { children: t })), n.italic && (t = /* @__PURE__ */ ee.jsx("em", { children: t })), n.underline && (t = /* @__PURE__ */ ee.jsx("u", { children: t })), /* @__PURE__ */ ee.jsx("span", { ...e, children: t });
}
function Gie(e, t) {
  const n = te.marks(e);
  return n ? n[t] === !0 : !1;
}
function Kie(e, t) {
  Gie(e, t) ? te.removeMark(e, t) : te.addMark(e, t, !0);
}
function hy({ format: e, icon: t }) {
  const n = nx(), o = Gie(n, e) ? "activeTrue" : "activeFalse";
  function i(a) {
    a.preventDefault(), Kie(n, e);
  }
  return /* @__PURE__ */ ee.jsx(
    "button",
    {
      type: "button",
      className: "arkynRichTextMarkButton " + o,
      onMouseDown: i,
      children: /* @__PURE__ */ ee.jsx(t, {})
    }
  );
}
function yet({ children: e }) {
  return /* @__PURE__ */ ee.jsx("div", { className: "arkynRichTextToolbar", children: e });
}
function C7(e) {
  return e.map((t) => tt.string(t)).join("");
}
const O7 = {
  "mod+b": "bold",
  "mod+i": "italic",
  "mod+u": "underline",
  "mod+`": "code"
}, gy = [
  {
    type: "paragraph",
    children: [{ text: "" }]
  }
];
function Uit(e) {
  const {
    name: t,
    hiddenButtons: n,
    imageConfig: r,
    defaultValue: o = "[]",
    enforceCharacterLimit: i = !1,
    onChangeCharactersCount: a,
    maxLimit: s = 2e3,
    onChange: l,
    isError: u
  } = e, c = ln(() => JXe(aet(ece())), []), { id: p, inputRef: d, error: g } = Fi(), f = dt(null);
  function m() {
    try {
      const Y = JSON.parse(o);
      return !Array.isArray(Y) || Y.length <= 0 ? gy : Y.every(
        (J) => typeof J == "object" && J !== null && "type" in J && "children" in J
      ) ? Y : gy;
    } catch {
      return gy;
    }
  }
  const b = C7(m()), [E, w] = k(b.length), [M, x] = k(
    JSON.stringify(m()) || "[]"
  ), [v, C] = k(!1), P = d || f, F = u || !!g, L = Jn(vet, []), B = Jn(cet, []);
  function N(Y) {
    const Q = C7(Y);
    w(Q.length), a && a(Q.length), !(i && Q.length >= s) && (x(JSON.stringify(Y)), l && l(Y), c.children = Y, Be.setNodes(c, { children: Y }));
  }
  const $ = v ? "focusTrue" : "focusFalse", H = `arkynRichText ${F || s < E ? "errorTrue" : "errorFalse"} ${$}`, Z = s - E;
  function K(Y) {
    return !(n != null && n.includes(Y));
  }
  return /* @__PURE__ */ ee.jsxs(
    iet,
    {
      editor: c,
      initialValue: m(),
      onChange: N,
      onValueChange: N,
      children: [
        /* @__PURE__ */ ee.jsxs("div", { className: H, children: [
          /* @__PURE__ */ ee.jsxs(yet, { children: [
            K("headingOne") && /* @__PURE__ */ ee.jsx(qu, { format: "headingOne", icon: iae }),
            K("headingTwo") && /* @__PURE__ */ ee.jsx(qu, { format: "headingTwo", icon: sae }),
            K("blockQuote") && /* @__PURE__ */ ee.jsx(qu, { format: "blockQuote", icon: aae }),
            K("bold") && /* @__PURE__ */ ee.jsx(hy, { format: "bold", icon: lae }),
            K("italic") && /* @__PURE__ */ ee.jsx(hy, { format: "italic", icon: uae }),
            K("underline") && /* @__PURE__ */ ee.jsx(hy, { format: "underline", icon: cae }),
            K("code") && /* @__PURE__ */ ee.jsx(hy, { format: "code", icon: pae }),
            K("left") && /* @__PURE__ */ ee.jsx(qu, { format: "left", icon: dae }),
            K("right") && /* @__PURE__ */ ee.jsx(qu, { format: "right", icon: fae }),
            K("center") && /* @__PURE__ */ ee.jsx(qu, { format: "center", icon: hae }),
            K("justify") && /* @__PURE__ */ ee.jsx(qu, { format: "justify", icon: gae }),
            r && K("image") && /* @__PURE__ */ ee.jsx(met, { ...r })
          ] }),
          /* @__PURE__ */ ee.jsx(
            XQe,
            {
              className: "editorContainer",
              renderElement: B,
              renderLeaf: L,
              spellCheck: !0,
              id: p,
              onFocus: () => C(!0),
              onBlur: () => C(!1),
              onKeyDown: (Y) => {
                for (const Q in O7)
                  if (XXe(Q, Y)) {
                    Y.preventDefault();
                    const J = O7[Q];
                    Kie(c, J);
                  }
              }
            }
          ),
          Z < 0 && /* @__PURE__ */ ee.jsx("div", { className: "restatesCharacters", children: Z })
        ] }),
        /* @__PURE__ */ ee.jsx("input", { type: "hidden", ref: P, name: t, value: M }),
        /* @__PURE__ */ ee.jsx("input", { type: "hidden", name: `${t}Count`, value: E })
      ]
    }
  );
}
function bet(e, t) {
  const {
    isLoading: n,
    isError: r,
    size: o = "md",
    className: i = "",
    variant: a = "solid",
    prefix: s,
    leftIcon: l,
    disabled: u,
    readOnly: c,
    onFocus: p,
    onBlur: d,
    title: g,
    style: f,
    closeOnSelect: m = !0,
    ...b
  } = e, v = `arkyn_select ${s ? "hasPrefix" : ""} ${a} ${o} ${u || c || n ? "opacity" : ""} ${r ? "errored" : ""} ${t ? "focused" : ""} ${i}`, P = { md: 20, lg: 20 }[o];
  return {
    isLoading: n,
    className: v,
    prefix: iK(s, P, "prefix"),
    LeftIcon: l,
    disabled: u || n || c,
    onFocus: p,
    onBlur: d,
    title: g,
    closeOnSelect: m,
    style: f,
    iconSize: P,
    Spinner: /* @__PURE__ */ ee.jsx(ma, { className: "spinner", size: P, strokeWidth: 2.5 }),
    ...b
  };
}
function Hit(e) {
  var U;
  const [t, n] = k(""), [r, o] = k(!1), { inputRef: i, id: a, error: s } = Fi(), l = dt(null), u = i || l, c = e.isError || !!s, {
    disabled: p,
    title: d,
    style: g,
    className: f,
    prefix: m,
    iconSize: b,
    isLoading: E,
    LeftIcon: w,
    value: M = null,
    defaultValue: x = "",
    onFocus: v,
    onBlur: C,
    Spinner: P,
    name: F,
    placeholder: L,
    onSelect: B,
    options: N,
    optionMaxHeight: $,
    closeOnSelect: V,
    isSearchable: H,
    onSearch: Z,
    ...K
  } = bet({ ...e, id: a, isError: c }, r), [Y, Q] = k(x);
  function J() {
    p || !(u != null && u.current) || r || (o(!0), u.current.focus());
  }
  function _(T) {
    Z && (n(""), Z(T.target.value)), Z || n(T.target.value);
  }
  function D(T) {
    r || (o(!0), v && v(T));
  }
  function z() {
    o(!1), C && u.current && u.current.blur();
  }
  function S(T) {
    const { label: q, value: A } = T;
    Q(Y !== A ? A : ""), B && B({ label: q, value: A }), V && z();
  }
  const W = typeof M == "string" ? M : Y, O = ((U = N.find((T) => T.value === W)) == null ? void 0 : U.label) || "", j = () => {
    if (!r && O) return !0;
    if (!r && !O) return !1;
    if (r && O) return !0;
    if (r && !O) return !1;
  };
  return /* @__PURE__ */ ee.jsxs(ee.Fragment, { children: [
    /* @__PURE__ */ ee.jsxs(
      "section",
      {
        title: d,
        style: g,
        onClick: J,
        className: `${f} placeholder_dark_${j()}`,
        children: [
          m,
          w && /* @__PURE__ */ ee.jsx(w, { size: b, strokeWidth: 2.5 }),
          /* @__PURE__ */ ee.jsx(
            "input",
            {
              disabled: p,
              readOnly: !0,
              placeholder: O || L,
              onFocus: D,
              ...K
            }
          ),
          /* @__PURE__ */ ee.jsx(
            "input",
            {
              type: "hidden",
              ref: u,
              name: F,
              value: W || "",
              readOnly: !0
            }
          ),
          r && /* @__PURE__ */ ee.jsxs(
            "div",
            {
              className: "arkyn_select_content",
              style: { overflow: "auto", maxHeight: $ },
              children: [
                H && /* @__PURE__ */ ee.jsx(
                  QO,
                  {
                    type: "search",
                    name: "search-select",
                    variant: "underline",
                    leftIcon: OG,
                    onChange: _
                  }
                ),
                N.filter((T) => !!(e.onSearch || !e.isSearchable || T.label.toLowerCase().includes(t.toLowerCase()))).map(({ label: T, value: q }) => /* @__PURE__ */ ee.jsxs(
                  "div",
                  {
                    onClick: () => S({ label: T, value: q }),
                    className: W === q ? "arkyn_select_option active" : "arkyn_select_option",
                    children: [
                      T,
                      " ",
                      /* @__PURE__ */ ee.jsx(l0, {})
                    ]
                  },
                  q
                )),
                N.length <= 0 && /* @__PURE__ */ ee.jsx("p", { children: "Sem opções disponíveis" })
              ]
            }
          ),
          !E && /* @__PURE__ */ ee.jsx(
            GP,
            {
              className: "arkyn_select_arrow",
              size: b,
              strokeWidth: 2.5
            }
          ),
          E && P
        ]
      }
    ),
    r && /* @__PURE__ */ ee.jsx("aside", { className: "arkyn_select_overlay", onClick: z })
  ] });
}
function Wit(e) {
  const {
    size: t = "lg",
    defaultChecked: n = !1,
    checked: r = null,
    value: o,
    unCheckedValue: i = "",
    name: a,
    className: s = "",
    onCheck: l,
    ...u
  } = e, [c, p] = k(n), { id: d, inputRef: g } = Fi(), f = typeof r == "boolean" ? r : c;
  function m() {
    p(!c), l && l(f ? i : o || "checked");
  }
  const E = `arkynSwitch ${f ? "checkedTrue" : "checkedFalse"} ${t} ${s}`;
  return /* @__PURE__ */ ee.jsx("button", { type: "button", onClick: m, className: E, ...u, children: /* @__PURE__ */ ee.jsx(
    "input",
    {
      id: d,
      type: "hidden",
      name: a,
      ref: g,
      onClick: m,
      value: f ? o || "checked" : i
    }
  ) });
}
function $it(e) {
  const {
    variant: t = "solid",
    size: n = "md",
    className: r,
    disabled: o = !1,
    readOnly: i = !1,
    onFocus: a,
    onBlur: s,
    title: l,
    style: u,
    ...c
  } = e, [p, d] = k(!1), { inputRef: g, id: f, error: m } = Fi(), b = dt(null), E = g || b, M = e.isError || !!m ? "errorTrue" : "errorFalse", C = `arkynTextarea ${t} ${n} ${o || i ? "opacityTrue" : "opacityFalse"} ${M} ${p ? "focusedTrue" : "focusedFalse"} ${r}`;
  function P() {
    o || !(E != null && E.current) || (d(!0), E.current.focus());
  }
  function F(B) {
    d(!0), a && a(B);
  }
  function L(B) {
    d(!1), s && s(B);
  }
  return /* @__PURE__ */ ee.jsx(
    "section",
    {
      title: l,
      style: u,
      onClick: P,
      className: C,
      children: /* @__PURE__ */ ee.jsx(
        "textarea",
        {
          id: f,
          disabled: o,
          readOnly: i,
          ref: E,
          onFocus: F,
          onBlur: L,
          ...c
        }
      )
    }
  );
}
function Vit(e) {
  const { className: t = "", ...n } = e, r = `arkynBreadcrumbContainer ${t}`;
  return /* @__PURE__ */ ee.jsx("nav", { className: r, ...n });
}
function Zit(e) {
  const { pathname: t } = JP(), {
    className: n = "",
    disabled: r = !1,
    children: o,
    to: i,
    ...a
  } = e, l = `arkynBreadcrumbLink ${t === i ? "active" : "inactive"} ${n}`;
  return r ? /* @__PURE__ */ ee.jsxs("p", { className: l, children: [
    /* @__PURE__ */ ee.jsx(QL, { size: 14, strokeWidth: 2.5 }),
    o
  ] }) : /* @__PURE__ */ ee.jsxs(yae, { to: i, className: l, ...a, children: [
    /* @__PURE__ */ ee.jsx(QL, { size: 14, strokeWidth: 2.5 }),
    o
  ] });
}
function Xie(e = "") {
  const t = JP(), n = new URLSearchParams(t.search), r = e ? `${e}:` : "", o = (i) => {
    Object.entries(i).forEach(([a, s]) => {
      s === void 0 ? n.delete(`${r}${a}`) : n.set(`${r}${a}`, String(s));
    });
  };
  return {
    getParam: (i) => n.get(`${r}${i}`),
    getScopedSearch: (i) => {
      o(i);
      let a = n.toString();
      return a && (a = "?" + a), a;
    }
  };
}
function x7(e, t) {
  return [...new Array(t - e)].map((n, r) => e + r + 1).filter((n) => n > 0);
}
function qit(e) {
  const {
    scope: t,
    totalCountRegisters: n,
    perPageKey: r = "per_page",
    pageKey: o = "page",
    siblingsCount: i = 2,
    currentPage: a = 1,
    registerPerPage: s = 20,
    ...l
  } = e, u = EG(), { getParam: c, getScopedSearch: p } = Xie(t), d = Number(c("page")) || a, g = Number(c("per_page")) || s, f = Math.ceil(n / g), m = d > 1 ? x7(d - 1 - i, d - 1) : [], b = d < f ? x7(
    d,
    Math.min(d + i, f)
  ) : [];
  function E(w) {
    u(p({ page: w }));
  }
  return /* @__PURE__ */ ee.jsxs("div", { className: "arkynPagination", ...l, children: [
    /* @__PURE__ */ ee.jsx(
      "button",
      {
        className: "arkynPaginationIconButton",
        disabled: d <= 1,
        onClick: () => E(d - 1),
        children: /* @__PURE__ */ ee.jsx(mae, {})
      }
    ),
    d > 1 + i && /* @__PURE__ */ ee.jsxs(ee.Fragment, { children: [
      /* @__PURE__ */ ee.jsx(
        "button",
        {
          className: "arkynPaginationPageButton",
          onClick: () => E(1),
          children: "1"
        }
      ),
      d > 2 + i && /* @__PURE__ */ ee.jsx("button", { disabled: !0, className: "arkynPaginationSpread", children: /* @__PURE__ */ ee.jsx(zj, {}) })
    ] }),
    m.length > 0 && m.map((w, M) => /* @__PURE__ */ ee.jsx(
      "button",
      {
        onClick: () => E(w),
        className: "arkynPaginationPageButton",
        children: w
      },
      M
    )),
    /* @__PURE__ */ ee.jsx("button", { className: "arkynPaginationCurrent", disabled: !0, children: d }),
    b.length > 0 && b.map((w, M) => /* @__PURE__ */ ee.jsx(
      "button",
      {
        onClick: () => E(w),
        className: "arkynPaginationPageButton",
        children: w
      },
      M
    )),
    d + i < f && /* @__PURE__ */ ee.jsxs(ee.Fragment, { children: [
      d + 1 + i < f && /* @__PURE__ */ ee.jsx("button", { disabled: !0, className: "arkynPaginationSpread", children: /* @__PURE__ */ ee.jsx(zj, {}) }),
      /* @__PURE__ */ ee.jsx(
        "button",
        {
          className: "arkynPaginationPageButton",
          onClick: () => E(f),
          children: f
        }
      )
    ] }),
    /* @__PURE__ */ ee.jsx(
      "button",
      {
        className: "arkynPaginationIconButton",
        disabled: d >= f,
        onClick: () => E(d + 1),
        children: /* @__PURE__ */ ee.jsx(QL, {})
      }
    )
  ] });
}
const Yie = $e({});
function Git(e) {
  const {
    isVisibled: t,
    makeInvisible: n,
    orientation: r = "left",
    children: o,
    className: i,
    ...a
  } = e, s = r === "left" ? "-100%" : "100%", u = `arkynDrawerContainer ${r} ${t ? "visibleTrue" : "visibleFalse"} ${i}`;
  return /* @__PURE__ */ ee.jsx(Yie.Provider, { value: { makeInvisible: n }, children: /* @__PURE__ */ ee.jsx(kG, { children: t && /* @__PURE__ */ ee.jsxs("aside", { className: u.trim(), ...a, children: [
    /* @__PURE__ */ ee.jsx(
      Uf.div,
      {
        className: "arkynDrawerContainerOverlay",
        transition: { duration: 0.15, ease: "easeOut" },
        initial: { opacity: 0 },
        animate: { opacity: 1 },
        exit: { opacity: 0 },
        onClick: n
      }
    ),
    /* @__PURE__ */ ee.jsx(
      Uf.div,
      {
        className: "arkynDrawerContainerContent",
        transition: { ease: "easeOut", duration: 0.15 },
        initial: { transform: `translateX(${s})` },
        animate: { transform: "translateX(0px)" },
        exit: { transform: `translateX(${s})` },
        children: o
      }
    )
  ] }) }) });
}
function Kit(e) {
  const {
    showCloseButton: t = !0,
    className: n,
    children: r,
    ...o
  } = e, { makeInvisible: i } = ge(Yie), a = `arkynDrawerHeader ${n}`;
  return /* @__PURE__ */ ee.jsxs("header", { className: a.trim(), ...o, children: [
    r,
    t && /* @__PURE__ */ ee.jsx(
      "button",
      {
        className: "arkynDrawerHeaderCloseButton",
        type: "button",
        onClick: i,
        "aria-label": "Close drawer",
        children: /* @__PURE__ */ ee.jsx(KP, { size: 24 })
      }
    )
  ] });
}
function Xit(e) {
  const {
    children: t,
    button: n,
    closeOnClick: r,
    className: o = "",
    orientation: i = "bottomLeft"
  } = e, [a, s] = k(!1), u = `arkynPopover ${i} ${a ? "visibleTrue" : "visibleFalse"} ${o}`;
  function c() {
    a || s(!0);
  }
  return /* @__PURE__ */ ee.jsxs("div", { className: u, onClick: c, children: [
    n,
    /* @__PURE__ */ ee.jsx(
      Uf.div,
      {
        style: { visibility: a ? "visible" : "hidden" },
        transition: { ease: "easeOut", duration: 0 },
        initial: { opacity: 0 },
        animate: { opacity: a ? 1 : 0 },
        exit: { opacity: 0 },
        onClick: () => r && s(!1),
        className: "arkynPopoverContent",
        children: t
      }
    ),
    a && /* @__PURE__ */ ee.jsx("div", { onClick: () => s(!1), className: "arkynPopoverOverlay" })
  ] });
}
function Yit(e) {
  const { message: t, type: n } = e, r = `arkynToast ${n}}`;
  function o() {
    switch (n) {
      case "success":
        return /* @__PURE__ */ ee.jsx(CG, {});
      case "danger":
        return /* @__PURE__ */ ee.jsx(wG, {});
      default:
        return /* @__PURE__ */ ee.jsx(bG, {});
    }
  }
  return /* @__PURE__ */ ee.jsxs("div", { className: r, children: [
    /* @__PURE__ */ ee.jsxs("div", { children: [
      /* @__PURE__ */ ee.jsx("div", { className: "bg" }),
      /* @__PURE__ */ ee.jsx(o, {})
    ] }),
    /* @__PURE__ */ ee.jsx("p", { children: /* @__PURE__ */ ee.jsx("span", { children: t }) })
  ] });
}
var zo = {}, _j = {}, Hg = {}, Wg = {}, Jie = "Expected a function", E7 = NaN, wet = "[object Symbol]", Cet = /^\s+|\s+$/g, Oet = /^[-+]0x[0-9a-f]+$/i, xet = /^0b[01]+$/i, Eet = /^0o[0-7]+$/i, ket = parseInt, Let = typeof fr == "object" && fr && fr.Object === Object && fr, _et = typeof self == "object" && self && self.Object === Object && self, Pet = Let || _et || Function("return this")(), Met = Object.prototype, Det = Met.toString, Tet = Math.max, jet = Math.min, NL = function() {
  return Pet.Date.now();
};
function Aet(e, t, n) {
  var r, o, i, a, s, l, u = 0, c = !1, p = !1, d = !0;
  if (typeof e != "function")
    throw new TypeError(Jie);
  t = k7(t) || 0, Yw(n) && (c = !!n.leading, p = "maxWait" in n, i = p ? Tet(k7(n.maxWait) || 0, t) : i, d = "trailing" in n ? !!n.trailing : d);
  function g(C) {
    var P = r, F = o;
    return r = o = void 0, u = C, a = e.apply(F, P), a;
  }
  function f(C) {
    return u = C, s = setTimeout(E, t), c ? g(C) : a;
  }
  function m(C) {
    var P = C - l, F = C - u, L = t - P;
    return p ? jet(L, i - F) : L;
  }
  function b(C) {
    var P = C - l, F = C - u;
    return l === void 0 || P >= t || P < 0 || p && F >= i;
  }
  function E() {
    var C = NL();
    if (b(C))
      return w(C);
    s = setTimeout(E, m(C));
  }
  function w(C) {
    return s = void 0, d && r ? g(C) : (r = o = void 0, a);
  }
  function M() {
    s !== void 0 && clearTimeout(s), u = 0, r = l = o = s = void 0;
  }
  function x() {
    return s === void 0 ? a : w(NL());
  }
  function v() {
    var C = NL(), P = b(C);
    if (r = arguments, o = this, l = C, P) {
      if (s === void 0)
        return f(l);
      if (p)
        return s = setTimeout(E, t), g(l);
    }
    return s === void 0 && (s = setTimeout(E, t)), a;
  }
  return v.cancel = M, v.flush = x, v;
}
function Ret(e, t, n) {
  var r = !0, o = !0;
  if (typeof e != "function")
    throw new TypeError(Jie);
  return Yw(n) && (r = "leading" in n ? !!n.leading : r, o = "trailing" in n ? !!n.trailing : o), Aet(e, t, {
    leading: r,
    maxWait: t,
    trailing: o
  });
}
function Yw(e) {
  var t = typeof e;
  return !!e && (t == "object" || t == "function");
}
function Iet(e) {
  return !!e && typeof e == "object";
}
function Net(e) {
  return typeof e == "symbol" || Iet(e) && Det.call(e) == wet;
}
function k7(e) {
  if (typeof e == "number")
    return e;
  if (Net(e))
    return E7;
  if (Yw(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = Yw(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = e.replace(Cet, "");
  var n = xet.test(e);
  return n || Eet.test(e) ? ket(e.slice(2), n ? 2 : 8) : Oet.test(e) ? E7 : +e;
}
var Bet = Ret, $g = {};
Object.defineProperty($g, "__esModule", {
  value: !0
});
$g.addPassiveEventListener = function(t, n, r) {
  var o = r.name;
  o || (o = n, console.warn("Listener must be a named function.")), Ny.has(n) || Ny.set(n, /* @__PURE__ */ new Set());
  var i = Ny.get(n);
  if (!i.has(o)) {
    var a = function() {
      var s = !1;
      try {
        var l = Object.defineProperty({}, "passive", {
          get: function() {
            s = !0;
          }
        });
        window.addEventListener("test", null, l);
      } catch {
      }
      return s;
    }();
    t.addEventListener(n, r, a ? { passive: !0 } : !1), i.add(o);
  }
};
$g.removePassiveEventListener = function(t, n, r) {
  t.removeEventListener(n, r), Ny.get(n).delete(r.name || n);
};
var Ny = /* @__PURE__ */ new Map();
Object.defineProperty(Wg, "__esModule", {
  value: !0
});
var Fet = Bet, zet = Uet(Fet), L7 = $g;
function Uet(e) {
  return e && e.__esModule ? e : { default: e };
}
var Het = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 66;
  return (0, zet.default)(t, n);
}, vo = {
  spyCallbacks: [],
  spySetState: [],
  scrollSpyContainers: [],
  mount: function(t, n) {
    if (t) {
      var r = Het(function(o) {
        vo.scrollHandler(t);
      }, n);
      return vo.scrollSpyContainers.push(t), (0, L7.addPassiveEventListener)(t, "scroll", r), function() {
        (0, L7.removePassiveEventListener)(t, "scroll", r), vo.scrollSpyContainers.splice(vo.scrollSpyContainers.indexOf(t), 1);
      };
    }
    return function() {
    };
  },
  isMounted: function(t) {
    return vo.scrollSpyContainers.indexOf(t) !== -1;
  },
  currentPositionX: function(t) {
    if (t === document) {
      var n = window.scrollY !== void 0, r = (document.compatMode || "") === "CSS1Compat";
      return n ? window.scrollX : r ? document.documentElement.scrollLeft : document.body.scrollLeft;
    } else
      return t.scrollLeft;
  },
  currentPositionY: function(t) {
    if (t === document) {
      var n = window.scrollX !== void 0, r = (document.compatMode || "") === "CSS1Compat";
      return n ? window.scrollY : r ? document.documentElement.scrollTop : document.body.scrollTop;
    } else
      return t.scrollTop;
  },
  scrollHandler: function(t) {
    var n = vo.scrollSpyContainers[vo.scrollSpyContainers.indexOf(t)].spyCallbacks || [];
    n.forEach(function(r) {
      return r(vo.currentPositionX(t), vo.currentPositionY(t));
    });
  },
  addStateHandler: function(t) {
    vo.spySetState.push(t);
  },
  addSpyHandler: function(t, n) {
    var r = vo.scrollSpyContainers[vo.scrollSpyContainers.indexOf(n)];
    r.spyCallbacks || (r.spyCallbacks = []), r.spyCallbacks.push(t);
  },
  updateStates: function() {
    vo.spySetState.forEach(function(t) {
      return t();
    });
  },
  unmount: function(t, n) {
    vo.scrollSpyContainers.forEach(function(r) {
      return r.spyCallbacks && r.spyCallbacks.length && r.spyCallbacks.indexOf(n) > -1 && r.spyCallbacks.splice(r.spyCallbacks.indexOf(n), 1);
    }), vo.spySetState && vo.spySetState.length && vo.spySetState.indexOf(t) > -1 && vo.spySetState.splice(vo.spySetState.indexOf(t), 1), document.removeEventListener("scroll", vo.scrollHandler);
  },
  update: function() {
    return vo.scrollSpyContainers.forEach(function(t) {
      return vo.scrollHandler(t);
    });
  }
};
Wg.default = vo;
var Jp = {}, Vg = {};
Object.defineProperty(Vg, "__esModule", {
  value: !0
});
var Wet = function(t, n) {
  var r = t.indexOf("#") === 0 ? t.substring(1) : t, o = r ? "#" + r : "", i = window && window.location, a = o ? i.pathname + i.search + o : i.pathname + i.search;
  n ? history.pushState(history.state, "", a) : history.replaceState(history.state, "", a);
}, $et = function() {
  return window.location.hash.replace(/^#/, "");
}, Vet = function(t) {
  return function(n) {
    return t.contains ? t != n && t.contains(n) : !!(t.compareDocumentPosition(n) & 16);
  };
}, Zet = function(t) {
  return getComputedStyle(t).position !== "static";
}, BL = function(t, n) {
  for (var r = t.offsetTop, o = t.offsetParent; o && !n(o); )
    r += o.offsetTop, o = o.offsetParent;
  return { offsetTop: r, offsetParent: o };
}, qet = function(t, n, r) {
  if (r)
    return t === document ? n.getBoundingClientRect().left + (window.scrollX || window.pageXOffset) : getComputedStyle(t).position !== "static" ? n.offsetLeft : n.offsetLeft - t.offsetLeft;
  if (t === document)
    return n.getBoundingClientRect().top + (window.scrollY || window.pageYOffset);
  if (Zet(t)) {
    if (n.offsetParent !== t) {
      var o = function(c) {
        return c === t || c === document;
      }, i = BL(n, o), a = i.offsetTop, s = i.offsetParent;
      if (s !== t)
        throw new Error("Seems containerElement is not an ancestor of the Element");
      return a;
    }
    return n.offsetTop;
  }
  if (n.offsetParent === t.offsetParent)
    return n.offsetTop - t.offsetTop;
  var l = function(c) {
    return c === document;
  };
  return BL(n, l).offsetTop - BL(t, l).offsetTop;
};
Vg.default = {
  updateHash: Wet,
  getHash: $et,
  filterElementInContainer: Vet,
  scrollOffset: qet
};
var rx = {}, Pj = {};
Object.defineProperty(Pj, "__esModule", {
  value: !0
});
Pj.default = {
  /*
   * https://github.com/oblador/angular-scroll (duScrollDefaultEasing)
   */
  defaultEasing: function(t) {
    return t < 0.5 ? Math.pow(t * 2, 2) / 2 : 1 - Math.pow((1 - t) * 2, 2) / 2;
  },
  /*
   * https://gist.github.com/gre/1650294
   */
  // no easing, no acceleration
  linear: function(t) {
    return t;
  },
  // accelerating from zero velocity
  easeInQuad: function(t) {
    return t * t;
  },
  // decelerating to zero velocity
  easeOutQuad: function(t) {
    return t * (2 - t);
  },
  // acceleration until halfway, then deceleration
  easeInOutQuad: function(t) {
    return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
  },
  // accelerating from zero velocity 
  easeInCubic: function(t) {
    return t * t * t;
  },
  // decelerating to zero velocity π
  easeOutCubic: function(t) {
    return --t * t * t + 1;
  },
  // acceleration until halfway, then deceleration 
  easeInOutCubic: function(t) {
    return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
  },
  // accelerating from zero velocity 
  easeInQuart: function(t) {
    return t * t * t * t;
  },
  // decelerating to zero velocity 
  easeOutQuart: function(t) {
    return 1 - --t * t * t * t;
  },
  // acceleration until halfway, then deceleration
  easeInOutQuart: function(t) {
    return t < 0.5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t;
  },
  // accelerating from zero velocity
  easeInQuint: function(t) {
    return t * t * t * t * t;
  },
  // decelerating to zero velocity
  easeOutQuint: function(t) {
    return 1 + --t * t * t * t * t;
  },
  // acceleration until halfway, then deceleration 
  easeInOutQuint: function(t) {
    return t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t;
  }
};
var Sj = {};
Object.defineProperty(Sj, "__esModule", {
  value: !0
});
var Get = $g, Ket = ["mousedown", "wheel", "touchmove", "keydown"];
Sj.default = {
  subscribe: function(t) {
    return typeof document < "u" && Ket.forEach(function(n) {
      return (0, Get.addPassiveEventListener)(document, n, t);
    });
  }
};
var Zg = {};
Object.defineProperty(Zg, "__esModule", {
  value: !0
});
var FP = {
  registered: {},
  scrollEvent: {
    register: function(t, n) {
      FP.registered[t] = n;
    },
    remove: function(t) {
      FP.registered[t] = null;
    }
  }
};
Zg.default = FP;
Object.defineProperty(rx, "__esModule", {
  value: !0
});
var Xet = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, Yet = Vg;
ox(Yet);
var Jet = Pj, _7 = ox(Jet), Qet = Sj, ett = ox(Qet), ttt = Zg, la = ox(ttt);
function ox(e) {
  return e && e.__esModule ? e : { default: e };
}
var Qie = function(t) {
  return _7.default[t.smooth] || _7.default.defaultEasing;
}, ntt = function(t) {
  return typeof t == "function" ? t : function() {
    return t;
  };
}, rtt = function() {
  if (typeof window < "u")
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame;
}, zP = function() {
  return rtt() || function(e, t, n) {
    window.setTimeout(e, n || 1e3 / 60, (/* @__PURE__ */ new Date()).getTime());
  };
}(), ese = function() {
  return {
    currentPosition: 0,
    startPosition: 0,
    targetPosition: 0,
    progress: 0,
    duration: 0,
    cancel: !1,
    target: null,
    containerElement: null,
    to: null,
    start: null,
    delta: null,
    percent: null,
    delayTimeout: null
  };
}, tse = function(t) {
  var n = t.data.containerElement;
  if (n && n !== document && n !== document.body)
    return n.scrollLeft;
  var r = window.pageXOffset !== void 0, o = (document.compatMode || "") === "CSS1Compat";
  return r ? window.pageXOffset : o ? document.documentElement.scrollLeft : document.body.scrollLeft;
}, nse = function(t) {
  var n = t.data.containerElement;
  if (n && n !== document && n !== document.body)
    return n.scrollTop;
  var r = window.pageXOffset !== void 0, o = (document.compatMode || "") === "CSS1Compat";
  return r ? window.pageYOffset : o ? document.documentElement.scrollTop : document.body.scrollTop;
}, ott = function(t) {
  var n = t.data.containerElement;
  if (n && n !== document && n !== document.body)
    return n.scrollWidth - n.offsetWidth;
  var r = document.body, o = document.documentElement;
  return Math.max(r.scrollWidth, r.offsetWidth, o.clientWidth, o.scrollWidth, o.offsetWidth);
}, itt = function(t) {
  var n = t.data.containerElement;
  if (n && n !== document && n !== document.body)
    return n.scrollHeight - n.offsetHeight;
  var r = document.body, o = document.documentElement;
  return Math.max(r.scrollHeight, r.offsetHeight, o.clientHeight, o.scrollHeight, o.offsetHeight);
}, stt = function e(t, n, r) {
  var o = n.data;
  if (!n.ignoreCancelEvents && o.cancel) {
    la.default.registered.end && la.default.registered.end(o.to, o.target, o.currentPositionY);
    return;
  }
  if (o.delta = Math.round(o.targetPosition - o.startPosition), o.start === null && (o.start = r), o.progress = r - o.start, o.percent = o.progress >= o.duration ? 1 : t(o.progress / o.duration), o.currentPosition = o.startPosition + Math.ceil(o.delta * o.percent), o.containerElement && o.containerElement !== document && o.containerElement !== document.body ? n.horizontal ? o.containerElement.scrollLeft = o.currentPosition : o.containerElement.scrollTop = o.currentPosition : n.horizontal ? window.scrollTo(o.currentPosition, 0) : window.scrollTo(0, o.currentPosition), o.percent < 1) {
    var i = e.bind(null, t, n);
    zP.call(window, i);
    return;
  }
  la.default.registered.end && la.default.registered.end(o.to, o.target, o.currentPosition);
}, Mj = function(t) {
  t.data.containerElement = t ? t.containerId ? document.getElementById(t.containerId) : t.container && t.container.nodeType ? t.container : document : null;
}, qg = function(t, n, r, o) {
  n.data = n.data || ese(), window.clearTimeout(n.data.delayTimeout);
  var i = function() {
    n.data.cancel = !0;
  };
  if (ett.default.subscribe(i), Mj(n), n.data.start = null, n.data.cancel = !1, n.data.startPosition = n.horizontal ? tse(n) : nse(n), n.data.targetPosition = n.absolute ? t : t + n.data.startPosition, n.data.startPosition === n.data.targetPosition) {
    la.default.registered.end && la.default.registered.end(n.data.to, n.data.target, n.data.currentPosition);
    return;
  }
  n.data.delta = Math.round(n.data.targetPosition - n.data.startPosition), n.data.duration = ntt(n.duration)(n.data.delta), n.data.duration = isNaN(parseFloat(n.data.duration)) ? 1e3 : parseFloat(n.data.duration), n.data.to = r, n.data.target = o;
  var a = Qie(n), s = stt.bind(null, a, n);
  if (n && n.delay > 0) {
    n.data.delayTimeout = window.setTimeout(function() {
      la.default.registered.begin && la.default.registered.begin(n.data.to, n.data.target), zP.call(window, s);
    }, n.delay);
    return;
  }
  la.default.registered.begin && la.default.registered.begin(n.data.to, n.data.target), zP.call(window, s);
}, ix = function(t) {
  return t = Xet({}, t), t.data = t.data || ese(), t.absolute = !0, t;
}, att = function(t) {
  qg(0, ix(t));
}, ltt = function(t, n) {
  qg(t, ix(n));
}, utt = function(t) {
  t = ix(t), Mj(t), qg(t.horizontal ? ott(t) : itt(t), t);
}, ctt = function(t, n) {
  n = ix(n), Mj(n);
  var r = n.horizontal ? tse(n) : nse(n);
  qg(t + r, n);
};
rx.default = {
  animateTopScroll: qg,
  getAnimationType: Qie,
  scrollToTop: att,
  scrollToBottom: utt,
  scrollTo: ltt,
  scrollMore: ctt
};
Object.defineProperty(Jp, "__esModule", {
  value: !0
});
var ptt = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, dtt = Vg, ftt = Dj(dtt), htt = rx, gtt = Dj(htt), mtt = Zg, my = Dj(mtt);
function Dj(e) {
  return e && e.__esModule ? e : { default: e };
}
var vy = {}, P7 = void 0;
Jp.default = {
  unmount: function() {
    vy = {};
  },
  register: function(t, n) {
    vy[t] = n;
  },
  unregister: function(t) {
    delete vy[t];
  },
  get: function(t) {
    return vy[t] || document.getElementById(t) || document.getElementsByName(t)[0] || document.getElementsByClassName(t)[0];
  },
  setActiveLink: function(t) {
    return P7 = t;
  },
  getActiveLink: function() {
    return P7;
  },
  scrollTo: function(t, n) {
    var r = this.get(t);
    if (!r) {
      console.warn("target Element not found");
      return;
    }
    n = ptt({}, n, { absolute: !1 });
    var o = n.containerId, i = n.container, a = void 0;
    o ? a = document.getElementById(o) : i && i.nodeType ? a = i : a = document, n.absolute = !0;
    var s = n.horizontal, l = ftt.default.scrollOffset(a, r, s) + (n.offset || 0);
    if (!n.smooth) {
      my.default.registered.begin && my.default.registered.begin(t, r), a === document ? n.horizontal ? window.scrollTo(l, 0) : window.scrollTo(0, l) : a.scrollTop = l, my.default.registered.end && my.default.registered.end(t, r);
      return;
    }
    gtt.default.animateTopScroll(l, n, t, r);
  }
};
var UP = { exports: {} }, yy = { exports: {} }, Xn = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var S7;
function vtt() {
  if (S7) return Xn;
  S7 = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, g = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, m = e ? Symbol.for("react.block") : 60121, b = e ? Symbol.for("react.fundamental") : 60117, E = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
  function M(v) {
    if (typeof v == "object" && v !== null) {
      var C = v.$$typeof;
      switch (C) {
        case t:
          switch (v = v.type, v) {
            case l:
            case u:
            case r:
            case i:
            case o:
            case p:
              return v;
            default:
              switch (v = v && v.$$typeof, v) {
                case s:
                case c:
                case f:
                case g:
                case a:
                  return v;
                default:
                  return C;
              }
          }
        case n:
          return C;
      }
    }
  }
  function x(v) {
    return M(v) === u;
  }
  return Xn.AsyncMode = l, Xn.ConcurrentMode = u, Xn.ContextConsumer = s, Xn.ContextProvider = a, Xn.Element = t, Xn.ForwardRef = c, Xn.Fragment = r, Xn.Lazy = f, Xn.Memo = g, Xn.Portal = n, Xn.Profiler = i, Xn.StrictMode = o, Xn.Suspense = p, Xn.isAsyncMode = function(v) {
    return x(v) || M(v) === l;
  }, Xn.isConcurrentMode = x, Xn.isContextConsumer = function(v) {
    return M(v) === s;
  }, Xn.isContextProvider = function(v) {
    return M(v) === a;
  }, Xn.isElement = function(v) {
    return typeof v == "object" && v !== null && v.$$typeof === t;
  }, Xn.isForwardRef = function(v) {
    return M(v) === c;
  }, Xn.isFragment = function(v) {
    return M(v) === r;
  }, Xn.isLazy = function(v) {
    return M(v) === f;
  }, Xn.isMemo = function(v) {
    return M(v) === g;
  }, Xn.isPortal = function(v) {
    return M(v) === n;
  }, Xn.isProfiler = function(v) {
    return M(v) === i;
  }, Xn.isStrictMode = function(v) {
    return M(v) === o;
  }, Xn.isSuspense = function(v) {
    return M(v) === p;
  }, Xn.isValidElementType = function(v) {
    return typeof v == "string" || typeof v == "function" || v === r || v === u || v === i || v === o || v === p || v === d || typeof v == "object" && v !== null && (v.$$typeof === f || v.$$typeof === g || v.$$typeof === a || v.$$typeof === s || v.$$typeof === c || v.$$typeof === b || v.$$typeof === E || v.$$typeof === w || v.$$typeof === m);
  }, Xn.typeOf = M, Xn;
}
var Yn = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var M7;
function ytt() {
  return M7 || (M7 = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, g = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, m = e ? Symbol.for("react.block") : 60121, b = e ? Symbol.for("react.fundamental") : 60117, E = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
    function M(I) {
      return typeof I == "string" || typeof I == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      I === r || I === u || I === i || I === o || I === p || I === d || typeof I == "object" && I !== null && (I.$$typeof === f || I.$$typeof === g || I.$$typeof === a || I.$$typeof === s || I.$$typeof === c || I.$$typeof === b || I.$$typeof === E || I.$$typeof === w || I.$$typeof === m);
    }
    function x(I) {
      if (typeof I == "object" && I !== null) {
        var le = I.$$typeof;
        switch (le) {
          case t:
            var he = I.type;
            switch (he) {
              case l:
              case u:
              case r:
              case i:
              case o:
              case p:
                return he;
              default:
                var oe = he && he.$$typeof;
                switch (oe) {
                  case s:
                  case c:
                  case f:
                  case g:
                  case a:
                    return oe;
                  default:
                    return le;
                }
            }
          case n:
            return le;
        }
      }
    }
    var v = l, C = u, P = s, F = a, L = t, B = c, N = r, $ = f, V = g, H = n, Z = i, K = o, Y = p, Q = !1;
    function J(I) {
      return Q || (Q = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), _(I) || x(I) === l;
    }
    function _(I) {
      return x(I) === u;
    }
    function D(I) {
      return x(I) === s;
    }
    function z(I) {
      return x(I) === a;
    }
    function S(I) {
      return typeof I == "object" && I !== null && I.$$typeof === t;
    }
    function W(I) {
      return x(I) === c;
    }
    function O(I) {
      return x(I) === r;
    }
    function j(I) {
      return x(I) === f;
    }
    function U(I) {
      return x(I) === g;
    }
    function T(I) {
      return x(I) === n;
    }
    function q(I) {
      return x(I) === i;
    }
    function A(I) {
      return x(I) === o;
    }
    function X(I) {
      return x(I) === p;
    }
    Yn.AsyncMode = v, Yn.ConcurrentMode = C, Yn.ContextConsumer = P, Yn.ContextProvider = F, Yn.Element = L, Yn.ForwardRef = B, Yn.Fragment = N, Yn.Lazy = $, Yn.Memo = V, Yn.Portal = H, Yn.Profiler = Z, Yn.StrictMode = K, Yn.Suspense = Y, Yn.isAsyncMode = J, Yn.isConcurrentMode = _, Yn.isContextConsumer = D, Yn.isContextProvider = z, Yn.isElement = S, Yn.isForwardRef = W, Yn.isFragment = O, Yn.isLazy = j, Yn.isMemo = U, Yn.isPortal = T, Yn.isProfiler = q, Yn.isStrictMode = A, Yn.isSuspense = X, Yn.isValidElementType = M, Yn.typeOf = x;
  }()), Yn;
}
var D7;
function rse() {
  return D7 || (D7 = 1, process.env.NODE_ENV === "production" ? yy.exports = vtt() : yy.exports = ytt()), yy.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var FL, T7;
function btt() {
  if (T7) return FL;
  T7 = 1;
  var e = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, n = Object.prototype.propertyIsEnumerable;
  function r(i) {
    if (i == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(i);
  }
  function o() {
    try {
      if (!Object.assign)
        return !1;
      var i = new String("abc");
      if (i[5] = "de", Object.getOwnPropertyNames(i)[0] === "5")
        return !1;
      for (var a = {}, s = 0; s < 10; s++)
        a["_" + String.fromCharCode(s)] = s;
      var l = Object.getOwnPropertyNames(a).map(function(c) {
        return a[c];
      });
      if (l.join("") !== "0123456789")
        return !1;
      var u = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(c) {
        u[c] = c;
      }), Object.keys(Object.assign({}, u)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return FL = o() ? Object.assign : function(i, a) {
    for (var s, l = r(i), u, c = 1; c < arguments.length; c++) {
      s = Object(arguments[c]);
      for (var p in s)
        t.call(s, p) && (l[p] = s[p]);
      if (e) {
        u = e(s);
        for (var d = 0; d < u.length; d++)
          n.call(s, u[d]) && (l[u[d]] = s[u[d]]);
      }
    }
    return l;
  }, FL;
}
var zL, j7;
function Tj() {
  if (j7) return zL;
  j7 = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return zL = e, zL;
}
var UL, A7;
function ose() {
  return A7 || (A7 = 1, UL = Function.call.bind(Object.prototype.hasOwnProperty)), UL;
}
var HL, R7;
function wtt() {
  if (R7) return HL;
  R7 = 1;
  var e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = Tj(), n = {}, r = ose();
    e = function(i) {
      var a = "Warning: " + i;
      typeof console < "u" && console.error(a);
      try {
        throw new Error(a);
      } catch {
      }
    };
  }
  function o(i, a, s, l, u) {
    if (process.env.NODE_ENV !== "production") {
      for (var c in i)
        if (r(i, c)) {
          var p;
          try {
            if (typeof i[c] != "function") {
              var d = Error(
                (l || "React class") + ": " + s + " type `" + c + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof i[c] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw d.name = "Invariant Violation", d;
            }
            p = i[c](a, c, l, s, null, t);
          } catch (f) {
            p = f;
          }
          if (p && !(p instanceof Error) && e(
            (l || "React class") + ": type specification of " + s + " `" + c + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof p + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), p instanceof Error && !(p.message in n)) {
            n[p.message] = !0;
            var g = u ? u() : "";
            e(
              "Failed " + s + " type: " + p.message + (g ?? "")
            );
          }
        }
    }
  }
  return o.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (n = {});
  }, HL = o, HL;
}
var WL, I7;
function Ctt() {
  if (I7) return WL;
  I7 = 1;
  var e = rse(), t = btt(), n = Tj(), r = ose(), o = wtt(), i = function() {
  };
  process.env.NODE_ENV !== "production" && (i = function(s) {
    var l = "Warning: " + s;
    typeof console < "u" && console.error(l);
    try {
      throw new Error(l);
    } catch {
    }
  });
  function a() {
    return null;
  }
  return WL = function(s, l) {
    var u = typeof Symbol == "function" && Symbol.iterator, c = "@@iterator";
    function p(_) {
      var D = _ && (u && _[u] || _[c]);
      if (typeof D == "function")
        return D;
    }
    var d = "<<anonymous>>", g = {
      array: E("array"),
      bigint: E("bigint"),
      bool: E("boolean"),
      func: E("function"),
      number: E("number"),
      object: E("object"),
      string: E("string"),
      symbol: E("symbol"),
      any: w(),
      arrayOf: M,
      element: x(),
      elementType: v(),
      instanceOf: C,
      node: B(),
      objectOf: F,
      oneOf: P,
      oneOfType: L,
      shape: $,
      exact: V
    };
    function f(_, D) {
      return _ === D ? _ !== 0 || 1 / _ === 1 / D : _ !== _ && D !== D;
    }
    function m(_, D) {
      this.message = _, this.data = D && typeof D == "object" ? D : {}, this.stack = "";
    }
    m.prototype = Error.prototype;
    function b(_) {
      if (process.env.NODE_ENV !== "production")
        var D = {}, z = 0;
      function S(O, j, U, T, q, A, X) {
        if (T = T || d, A = A || U, X !== n) {
          if (l) {
            var I = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw I.name = "Invariant Violation", I;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var le = T + ":" + U;
            !D[le] && // Avoid spamming the console because they are often not actionable except for lib authors
            z < 3 && (i(
              "You are manually calling a React.PropTypes validation function for the `" + A + "` prop on `" + T + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), D[le] = !0, z++);
          }
        }
        return j[U] == null ? O ? j[U] === null ? new m("The " + q + " `" + A + "` is marked as required " + ("in `" + T + "`, but its value is `null`.")) : new m("The " + q + " `" + A + "` is marked as required in " + ("`" + T + "`, but its value is `undefined`.")) : null : _(j, U, T, q, A);
      }
      var W = S.bind(null, !1);
      return W.isRequired = S.bind(null, !0), W;
    }
    function E(_) {
      function D(z, S, W, O, j, U) {
        var T = z[S], q = K(T);
        if (q !== _) {
          var A = Y(T);
          return new m(
            "Invalid " + O + " `" + j + "` of type " + ("`" + A + "` supplied to `" + W + "`, expected ") + ("`" + _ + "`."),
            { expectedType: _ }
          );
        }
        return null;
      }
      return b(D);
    }
    function w() {
      return b(a);
    }
    function M(_) {
      function D(z, S, W, O, j) {
        if (typeof _ != "function")
          return new m("Property `" + j + "` of component `" + W + "` has invalid PropType notation inside arrayOf.");
        var U = z[S];
        if (!Array.isArray(U)) {
          var T = K(U);
          return new m("Invalid " + O + " `" + j + "` of type " + ("`" + T + "` supplied to `" + W + "`, expected an array."));
        }
        for (var q = 0; q < U.length; q++) {
          var A = _(U, q, W, O, j + "[" + q + "]", n);
          if (A instanceof Error)
            return A;
        }
        return null;
      }
      return b(D);
    }
    function x() {
      function _(D, z, S, W, O) {
        var j = D[z];
        if (!s(j)) {
          var U = K(j);
          return new m("Invalid " + W + " `" + O + "` of type " + ("`" + U + "` supplied to `" + S + "`, expected a single ReactElement."));
        }
        return null;
      }
      return b(_);
    }
    function v() {
      function _(D, z, S, W, O) {
        var j = D[z];
        if (!e.isValidElementType(j)) {
          var U = K(j);
          return new m("Invalid " + W + " `" + O + "` of type " + ("`" + U + "` supplied to `" + S + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return b(_);
    }
    function C(_) {
      function D(z, S, W, O, j) {
        if (!(z[S] instanceof _)) {
          var U = _.name || d, T = J(z[S]);
          return new m("Invalid " + O + " `" + j + "` of type " + ("`" + T + "` supplied to `" + W + "`, expected ") + ("instance of `" + U + "`."));
        }
        return null;
      }
      return b(D);
    }
    function P(_) {
      if (!Array.isArray(_))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? i(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : i("Invalid argument supplied to oneOf, expected an array.")), a;
      function D(z, S, W, O, j) {
        for (var U = z[S], T = 0; T < _.length; T++)
          if (f(U, _[T]))
            return null;
        var q = JSON.stringify(_, function(X, I) {
          var le = Y(I);
          return le === "symbol" ? String(I) : I;
        });
        return new m("Invalid " + O + " `" + j + "` of value `" + String(U) + "` " + ("supplied to `" + W + "`, expected one of " + q + "."));
      }
      return b(D);
    }
    function F(_) {
      function D(z, S, W, O, j) {
        if (typeof _ != "function")
          return new m("Property `" + j + "` of component `" + W + "` has invalid PropType notation inside objectOf.");
        var U = z[S], T = K(U);
        if (T !== "object")
          return new m("Invalid " + O + " `" + j + "` of type " + ("`" + T + "` supplied to `" + W + "`, expected an object."));
        for (var q in U)
          if (r(U, q)) {
            var A = _(U, q, W, O, j + "." + q, n);
            if (A instanceof Error)
              return A;
          }
        return null;
      }
      return b(D);
    }
    function L(_) {
      if (!Array.isArray(_))
        return process.env.NODE_ENV !== "production" && i("Invalid argument supplied to oneOfType, expected an instance of array."), a;
      for (var D = 0; D < _.length; D++) {
        var z = _[D];
        if (typeof z != "function")
          return i(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + Q(z) + " at index " + D + "."
          ), a;
      }
      function S(W, O, j, U, T) {
        for (var q = [], A = 0; A < _.length; A++) {
          var X = _[A], I = X(W, O, j, U, T, n);
          if (I == null)
            return null;
          I.data && r(I.data, "expectedType") && q.push(I.data.expectedType);
        }
        var le = q.length > 0 ? ", expected one of type [" + q.join(", ") + "]" : "";
        return new m("Invalid " + U + " `" + T + "` supplied to " + ("`" + j + "`" + le + "."));
      }
      return b(S);
    }
    function B() {
      function _(D, z, S, W, O) {
        return H(D[z]) ? null : new m("Invalid " + W + " `" + O + "` supplied to " + ("`" + S + "`, expected a ReactNode."));
      }
      return b(_);
    }
    function N(_, D, z, S, W) {
      return new m(
        (_ || "React class") + ": " + D + " type `" + z + "." + S + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + W + "`."
      );
    }
    function $(_) {
      function D(z, S, W, O, j) {
        var U = z[S], T = K(U);
        if (T !== "object")
          return new m("Invalid " + O + " `" + j + "` of type `" + T + "` " + ("supplied to `" + W + "`, expected `object`."));
        for (var q in _) {
          var A = _[q];
          if (typeof A != "function")
            return N(W, O, j, q, Y(A));
          var X = A(U, q, W, O, j + "." + q, n);
          if (X)
            return X;
        }
        return null;
      }
      return b(D);
    }
    function V(_) {
      function D(z, S, W, O, j) {
        var U = z[S], T = K(U);
        if (T !== "object")
          return new m("Invalid " + O + " `" + j + "` of type `" + T + "` " + ("supplied to `" + W + "`, expected `object`."));
        var q = t({}, z[S], _);
        for (var A in q) {
          var X = _[A];
          if (r(_, A) && typeof X != "function")
            return N(W, O, j, A, Y(X));
          if (!X)
            return new m(
              "Invalid " + O + " `" + j + "` key `" + A + "` supplied to `" + W + "`.\nBad object: " + JSON.stringify(z[S], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(_), null, "  ")
            );
          var I = X(U, A, W, O, j + "." + A, n);
          if (I)
            return I;
        }
        return null;
      }
      return b(D);
    }
    function H(_) {
      switch (typeof _) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !_;
        case "object":
          if (Array.isArray(_))
            return _.every(H);
          if (_ === null || s(_))
            return !0;
          var D = p(_);
          if (D) {
            var z = D.call(_), S;
            if (D !== _.entries) {
              for (; !(S = z.next()).done; )
                if (!H(S.value))
                  return !1;
            } else
              for (; !(S = z.next()).done; ) {
                var W = S.value;
                if (W && !H(W[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function Z(_, D) {
      return _ === "symbol" ? !0 : D ? D["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && D instanceof Symbol : !1;
    }
    function K(_) {
      var D = typeof _;
      return Array.isArray(_) ? "array" : _ instanceof RegExp ? "object" : Z(D, _) ? "symbol" : D;
    }
    function Y(_) {
      if (typeof _ > "u" || _ === null)
        return "" + _;
      var D = K(_);
      if (D === "object") {
        if (_ instanceof Date)
          return "date";
        if (_ instanceof RegExp)
          return "regexp";
      }
      return D;
    }
    function Q(_) {
      var D = Y(_);
      switch (D) {
        case "array":
        case "object":
          return "an " + D;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + D;
        default:
          return D;
      }
    }
    function J(_) {
      return !_.constructor || !_.constructor.name ? d : _.constructor.name;
    }
    return g.checkPropTypes = o, g.resetWarningCache = o.resetWarningCache, g.PropTypes = g, g;
  }, WL;
}
var $L, N7;
function Ott() {
  if (N7) return $L;
  N7 = 1;
  var e = Tj();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, $L = function() {
    function r(a, s, l, u, c, p) {
      if (p !== e) {
        var d = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw d.name = "Invariant Violation", d;
      }
    }
    r.isRequired = r;
    function o() {
      return r;
    }
    var i = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: o,
      element: r,
      elementType: r,
      instanceOf: o,
      node: r,
      objectOf: o,
      oneOf: o,
      oneOfType: o,
      shape: o,
      exact: o,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return i.PropTypes = i, i;
  }, $L;
}
if (process.env.NODE_ENV !== "production") {
  var xtt = rse(), Ett = !0;
  UP.exports = Ctt()(xtt.isElement, Ett);
} else
  UP.exports = Ott()();
var sx = UP.exports, ax = {};
Object.defineProperty(ax, "__esModule", {
  value: !0
});
var ktt = Vg, VL = Ltt(ktt);
function Ltt(e) {
  return e && e.__esModule ? e : { default: e };
}
var _tt = {
  mountFlag: !1,
  initialized: !1,
  scroller: null,
  containers: {},
  mount: function(t) {
    this.scroller = t, this.handleHashChange = this.handleHashChange.bind(this), window.addEventListener("hashchange", this.handleHashChange), this.initStateFromHash(), this.mountFlag = !0;
  },
  mapContainer: function(t, n) {
    this.containers[t] = n;
  },
  isMounted: function() {
    return this.mountFlag;
  },
  isInitialized: function() {
    return this.initialized;
  },
  initStateFromHash: function() {
    var t = this, n = this.getHash();
    n ? window.setTimeout(function() {
      t.scrollTo(n, !0), t.initialized = !0;
    }, 10) : this.initialized = !0;
  },
  scrollTo: function(t, n) {
    var r = this.scroller, o = r.get(t);
    if (o && (n || t !== r.getActiveLink())) {
      var i = this.containers[t] || document;
      r.scrollTo(t, { container: i });
    }
  },
  getHash: function() {
    return VL.default.getHash();
  },
  changeHash: function(t, n) {
    this.isInitialized() && VL.default.getHash() !== t && VL.default.updateHash(t, n);
  },
  handleHashChange: function() {
    this.scrollTo(this.getHash());
  },
  unmount: function() {
    this.scroller = null, this.containers = null, window.removeEventListener("hashchange", this.handleHashChange);
  }
};
ax.default = _tt;
Object.defineProperty(Hg, "__esModule", {
  value: !0
});
var by = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, Ptt = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), Stt = be, B7 = Gg(Stt), Mtt = Wg, wy = Gg(Mtt), Dtt = Jp, Ttt = Gg(Dtt), jtt = sx, io = Gg(jtt), Att = ax, Sl = Gg(Att);
function Gg(e) {
  return e && e.__esModule ? e : { default: e };
}
function Rtt(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Itt(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function Ntt(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var F7 = {
  to: io.default.string.isRequired,
  containerId: io.default.string,
  container: io.default.object,
  activeClass: io.default.string,
  activeStyle: io.default.object,
  spy: io.default.bool,
  horizontal: io.default.bool,
  smooth: io.default.oneOfType([io.default.bool, io.default.string]),
  offset: io.default.number,
  delay: io.default.number,
  isDynamic: io.default.bool,
  onClick: io.default.func,
  duration: io.default.oneOfType([io.default.number, io.default.func]),
  absolute: io.default.bool,
  onSetActive: io.default.func,
  onSetInactive: io.default.func,
  ignoreCancelEvents: io.default.bool,
  hashSpy: io.default.bool,
  saveHashHistory: io.default.bool,
  spyThrottle: io.default.number
};
Hg.default = function(e, t) {
  var n = t || Ttt.default, r = function(i) {
    Ntt(a, i);
    function a(s) {
      Rtt(this, a);
      var l = Itt(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
      return o.call(l), l.state = {
        active: !1
      }, l.beforeUnmountCallbacks = [], l;
    }
    return Ptt(a, [{
      key: "getScrollSpyContainer",
      value: function() {
        var l = this.props.containerId, u = this.props.container;
        return l && !u ? document.getElementById(l) : u && u.nodeType ? u : document;
      }
    }, {
      key: "componentDidMount",
      value: function() {
        if (this.props.spy || this.props.hashSpy) {
          var l = this.getScrollSpyContainer();
          if (!wy.default.isMounted(l)) {
            var u = wy.default.mount(l, this.props.spyThrottle);
            this.beforeUnmountCallbacks.push(u);
          }
          this.props.hashSpy && (Sl.default.isMounted() || Sl.default.mount(n), Sl.default.mapContainer(this.props.to, l)), wy.default.addSpyHandler(this.spyHandler, l), this.setState({
            container: l
          });
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        wy.default.unmount(this.stateHandler, this.spyHandler), this.beforeUnmountCallbacks.forEach(function(l) {
          return l();
        });
      }
    }, {
      key: "render",
      value: function() {
        var l = "";
        this.state && this.state.active ? l = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : l = this.props.className;
        var u = {};
        this.state && this.state.active ? u = by({}, this.props.style, this.props.activeStyle) : u = by({}, this.props.style);
        var c = by({}, this.props);
        for (var p in F7)
          c.hasOwnProperty(p) && delete c[p];
        return c.className = l, c.style = u, c.onClick = this.handleClick, B7.default.createElement(e, c);
      }
    }]), a;
  }(B7.default.PureComponent), o = function() {
    var a = this;
    this.scrollTo = function(s, l) {
      n.scrollTo(s, by({}, a.state, l));
    }, this.handleClick = function(s) {
      a.props.onClick && a.props.onClick(s), s.stopPropagation && s.stopPropagation(), s.preventDefault && s.preventDefault(), a.scrollTo(a.props.to, a.props);
    }, this.spyHandler = function(s, l) {
      var u = a.getScrollSpyContainer();
      if (!(Sl.default.isMounted() && !Sl.default.isInitialized())) {
        var c = a.props.horizontal, p = a.props.to, d = null, g = void 0, f = void 0;
        if (c) {
          var m = 0, b = 0, E = 0;
          if (u.getBoundingClientRect) {
            var w = u.getBoundingClientRect();
            E = w.left;
          }
          if (!d || a.props.isDynamic) {
            if (d = n.get(p), !d)
              return;
            var M = d.getBoundingClientRect();
            m = M.left - E + s, b = m + M.width;
          }
          var x = s - a.props.offset;
          g = x >= Math.floor(m) && x < Math.floor(b), f = x < Math.floor(m) || x >= Math.floor(b);
        } else {
          var v = 0, C = 0, P = 0;
          if (u.getBoundingClientRect) {
            var F = u.getBoundingClientRect();
            P = F.top;
          }
          if (!d || a.props.isDynamic) {
            if (d = n.get(p), !d)
              return;
            var L = d.getBoundingClientRect();
            v = L.top - P + l, C = v + L.height;
          }
          var B = l - a.props.offset;
          g = B >= Math.floor(v) && B < Math.floor(C), f = B < Math.floor(v) || B >= Math.floor(C);
        }
        var N = n.getActiveLink();
        if (f) {
          if (p === N && n.setActiveLink(void 0), a.props.hashSpy && Sl.default.getHash() === p) {
            var $ = a.props.saveHashHistory, V = $ === void 0 ? !1 : $;
            Sl.default.changeHash("", V);
          }
          a.props.spy && a.state.active && (a.setState({ active: !1 }), a.props.onSetInactive && a.props.onSetInactive(p, d));
        }
        if (g && (N !== p || a.state.active === !1)) {
          n.setActiveLink(p);
          var H = a.props.saveHashHistory, Z = H === void 0 ? !1 : H;
          a.props.hashSpy && Sl.default.changeHash(p, Z), a.props.spy && (a.setState({ active: !0 }), a.props.onSetActive && a.props.onSetActive(p, d));
        }
      }
    };
  };
  return r.propTypes = F7, r.defaultProps = { offset: 0 }, r;
};
Object.defineProperty(_j, "__esModule", {
  value: !0
});
var Btt = be, z7 = ise(Btt), Ftt = Hg, ztt = ise(Ftt);
function ise(e) {
  return e && e.__esModule ? e : { default: e };
}
function Utt(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function U7(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function Htt(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var Wtt = function(e) {
  Htt(t, e);
  function t() {
    var n, r, o, i;
    Utt(this, t);
    for (var a = arguments.length, s = Array(a), l = 0; l < a; l++)
      s[l] = arguments[l];
    return i = (r = (o = U7(this, (n = t.__proto__ || Object.getPrototypeOf(t)).call.apply(n, [this].concat(s))), o), o.render = function() {
      return z7.default.createElement(
        "a",
        o.props,
        o.props.children
      );
    }, r), U7(o, i);
  }
  return t;
}(z7.default.Component);
_j.default = (0, ztt.default)(Wtt);
var jj = {};
Object.defineProperty(jj, "__esModule", {
  value: !0
});
var $tt = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), Vtt = be, H7 = sse(Vtt), Ztt = Hg, qtt = sse(Ztt);
function sse(e) {
  return e && e.__esModule ? e : { default: e };
}
function Gtt(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Ktt(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function Xtt(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var Ytt = function(e) {
  Xtt(t, e);
  function t() {
    return Gtt(this, t), Ktt(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return $tt(t, [{
    key: "render",
    value: function() {
      return H7.default.createElement(
        "button",
        this.props,
        this.props.children
      );
    }
  }]), t;
}(H7.default.Component);
jj.default = (0, qtt.default)(Ytt);
var Aj = {}, lx = {};
Object.defineProperty(lx, "__esModule", {
  value: !0
});
var Jtt = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, Qtt = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), ent = be, W7 = ux(ent), tnt = il;
ux(tnt);
var nnt = Jp, $7 = ux(nnt), rnt = sx, V7 = ux(rnt);
function ux(e) {
  return e && e.__esModule ? e : { default: e };
}
function ont(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function int(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function snt(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
lx.default = function(e) {
  var t = function(n) {
    snt(r, n);
    function r(o) {
      ont(this, r);
      var i = int(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
      return i.childBindings = {
        domNode: null
      }, i;
    }
    return Qtt(r, [{
      key: "componentDidMount",
      value: function() {
        if (typeof window > "u")
          return !1;
        this.registerElems(this.props.name);
      }
    }, {
      key: "componentDidUpdate",
      value: function(i) {
        this.props.name !== i.name && this.registerElems(this.props.name);
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        if (typeof window > "u")
          return !1;
        $7.default.unregister(this.props.name);
      }
    }, {
      key: "registerElems",
      value: function(i) {
        $7.default.register(i, this.childBindings.domNode);
      }
    }, {
      key: "render",
      value: function() {
        return W7.default.createElement(e, Jtt({}, this.props, { parentBindings: this.childBindings }));
      }
    }]), r;
  }(W7.default.Component);
  return t.propTypes = {
    name: V7.default.string,
    id: V7.default.string
  }, t;
};
Object.defineProperty(Aj, "__esModule", {
  value: !0
});
var Z7 = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, ant = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), lnt = be, q7 = Rj(lnt), unt = lx, cnt = Rj(unt), pnt = sx, G7 = Rj(pnt);
function Rj(e) {
  return e && e.__esModule ? e : { default: e };
}
function dnt(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function fnt(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function hnt(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var ase = function(e) {
  hnt(t, e);
  function t() {
    return dnt(this, t), fnt(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return ant(t, [{
    key: "render",
    value: function() {
      var r = this, o = Z7({}, this.props);
      return delete o.name, o.parentBindings && delete o.parentBindings, q7.default.createElement(
        "div",
        Z7({}, o, { ref: function(a) {
          r.props.parentBindings.domNode = a;
        } }),
        this.props.children
      );
    }
  }]), t;
}(q7.default.Component);
ase.propTypes = {
  name: G7.default.string,
  id: G7.default.string
};
Aj.default = (0, cnt.default)(ase);
var ZL = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, K7 = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}();
function X7(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Y7(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function J7(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var Cy = be, Gu = Wg, qL = Jp, ko = sx, Ml = ax, Q7 = {
  to: ko.string.isRequired,
  containerId: ko.string,
  container: ko.object,
  activeClass: ko.string,
  spy: ko.bool,
  smooth: ko.oneOfType([ko.bool, ko.string]),
  offset: ko.number,
  delay: ko.number,
  isDynamic: ko.bool,
  onClick: ko.func,
  duration: ko.oneOfType([ko.number, ko.func]),
  absolute: ko.bool,
  onSetActive: ko.func,
  onSetInactive: ko.func,
  ignoreCancelEvents: ko.bool,
  hashSpy: ko.bool,
  spyThrottle: ko.number
}, gnt = {
  Scroll: function(t, n) {
    console.warn("Helpers.Scroll is deprecated since v1.7.0");
    var r = n || qL, o = function(a) {
      J7(s, a);
      function s(l) {
        X7(this, s);
        var u = Y7(this, (s.__proto__ || Object.getPrototypeOf(s)).call(this, l));
        return i.call(u), u.state = {
          active: !1
        }, u;
      }
      return K7(s, [{
        key: "getScrollSpyContainer",
        value: function() {
          var u = this.props.containerId, c = this.props.container;
          return u ? document.getElementById(u) : c && c.nodeType ? c : document;
        }
      }, {
        key: "componentDidMount",
        value: function() {
          if (this.props.spy || this.props.hashSpy) {
            var u = this.getScrollSpyContainer();
            Gu.isMounted(u) || Gu.mount(u, this.props.spyThrottle), this.props.hashSpy && (Ml.isMounted() || Ml.mount(r), Ml.mapContainer(this.props.to, u)), this.props.spy && Gu.addStateHandler(this.stateHandler), Gu.addSpyHandler(this.spyHandler, u), this.setState({
              container: u
            });
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          Gu.unmount(this.stateHandler, this.spyHandler);
        }
      }, {
        key: "render",
        value: function() {
          var u = "";
          this.state && this.state.active ? u = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : u = this.props.className;
          var c = ZL({}, this.props);
          for (var p in Q7)
            c.hasOwnProperty(p) && delete c[p];
          return c.className = u, c.onClick = this.handleClick, Cy.createElement(t, c);
        }
      }]), s;
    }(Cy.Component), i = function() {
      var s = this;
      this.scrollTo = function(l, u) {
        r.scrollTo(l, ZL({}, s.state, u));
      }, this.handleClick = function(l) {
        s.props.onClick && s.props.onClick(l), l.stopPropagation && l.stopPropagation(), l.preventDefault && l.preventDefault(), s.scrollTo(s.props.to, s.props);
      }, this.stateHandler = function() {
        r.getActiveLink() !== s.props.to && (s.state !== null && s.state.active && s.props.onSetInactive && s.props.onSetInactive(), s.setState({ active: !1 }));
      }, this.spyHandler = function(l) {
        var u = s.getScrollSpyContainer();
        if (!(Ml.isMounted() && !Ml.isInitialized())) {
          var c = s.props.to, p = null, d = 0, g = 0, f = 0;
          if (u.getBoundingClientRect) {
            var m = u.getBoundingClientRect();
            f = m.top;
          }
          if (!p || s.props.isDynamic) {
            if (p = r.get(c), !p)
              return;
            var b = p.getBoundingClientRect();
            d = b.top - f + l, g = d + b.height;
          }
          var E = l - s.props.offset, w = E >= Math.floor(d) && E < Math.floor(g), M = E < Math.floor(d) || E >= Math.floor(g), x = r.getActiveLink();
          if (M)
            return c === x && r.setActiveLink(void 0), s.props.hashSpy && Ml.getHash() === c && Ml.changeHash(), s.props.spy && s.state.active && (s.setState({ active: !1 }), s.props.onSetInactive && s.props.onSetInactive()), Gu.updateStates();
          if (w && x !== c)
            return r.setActiveLink(c), s.props.hashSpy && Ml.changeHash(c), s.props.spy && (s.setState({ active: !0 }), s.props.onSetActive && s.props.onSetActive(c)), Gu.updateStates();
        }
      };
    };
    return o.propTypes = Q7, o.defaultProps = { offset: 0 }, o;
  },
  Element: function(t) {
    console.warn("Helpers.Element is deprecated since v1.7.0");
    var n = function(r) {
      J7(o, r);
      function o(i) {
        X7(this, o);
        var a = Y7(this, (o.__proto__ || Object.getPrototypeOf(o)).call(this, i));
        return a.childBindings = {
          domNode: null
        }, a;
      }
      return K7(o, [{
        key: "componentDidMount",
        value: function() {
          if (typeof window > "u")
            return !1;
          this.registerElems(this.props.name);
        }
      }, {
        key: "componentDidUpdate",
        value: function(a) {
          this.props.name !== a.name && this.registerElems(this.props.name);
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          if (typeof window > "u")
            return !1;
          qL.unregister(this.props.name);
        }
      }, {
        key: "registerElems",
        value: function(a) {
          qL.register(a, this.childBindings.domNode);
        }
      }, {
        key: "render",
        value: function() {
          return Cy.createElement(t, ZL({}, this.props, { parentBindings: this.childBindings }));
        }
      }]), o;
    }(Cy.Component);
    return n.propTypes = {
      name: ko.string,
      id: ko.string
    }, n;
  }
}, mnt = gnt;
Object.defineProperty(zo, "__esModule", {
  value: !0
});
zo.Helpers = zo.ScrollElement = zo.ScrollLink = yse = zo.animateScroll = zo.scrollSpy = zo.Events = zo.scroller = zo.Element = zo.Button = zo.Link = void 0;
var vnt = _j, lse = Ea(vnt), ynt = jj, use = Ea(ynt), bnt = Aj, cse = Ea(bnt), wnt = Jp, pse = Ea(wnt), Cnt = Zg, dse = Ea(Cnt), Ont = Wg, fse = Ea(Ont), xnt = rx, hse = Ea(xnt), Ent = Hg, gse = Ea(Ent), knt = lx, mse = Ea(knt), Lnt = mnt, vse = Ea(Lnt);
function Ea(e) {
  return e && e.__esModule ? e : { default: e };
}
zo.Link = lse.default;
zo.Button = use.default;
zo.Element = cse.default;
zo.scroller = pse.default;
zo.Events = dse.default;
zo.scrollSpy = fse.default;
var yse = zo.animateScroll = hse.default;
zo.ScrollLink = gse.default;
zo.ScrollElement = mse.default;
zo.Helpers = vse.default;
zo.default = { Link: lse.default, Button: use.default, Element: cse.default, scroller: pse.default, Events: dse.default, scrollSpy: fse.default, animateScroll: hse.default, ScrollLink: gse.default, ScrollElement: mse.default, Helpers: vse.default };
const Ij = $e({}), bse = $e({});
function _nt() {
  const e = ge(bse);
  if (Object.entries(e).length === 0)
    throw new Error("useToast must be used within a Provider");
  return e;
}
function eq(e) {
  return e && typeof e.title == "string" && typeof e.message == "string" && (e.size === void 0 || e.size === "md" || e.size === "lg") && (e.type === "success" || e.type === "danger");
}
function Jit() {
  const e = XP(), { closeModal: t, closeAll: n, modalIsOpen: r } = ge(Ij), { showToast: o } = _nt(), { getParam: i } = Xie(), { pathname: a } = JP(), s = EG(), l = i("closeAllModals"), u = YP();
  h(() => {
    var d, g;
    const c = ((g = (d = u[0]) == null ? void 0 : d.data) == null ? void 0 : g.closeModalKey) || "", p = r(c);
    c && p && t(c);
  }, [u]), h(() => {
    l === "true" && (n(), s(a));
  }, [l]), h(() => {
    const c = e == null ? void 0 : e.closeModalKey;
    c && t(c);
  }, [e]), h(() => {
    const c = e == null ? void 0 : e.closeAllModals;
    typeof c == "boolean" && c && n();
  }, [e]), h(() => {
    const c = e == null ? void 0 : e.toast, p = e == null ? void 0 : e.message;
    eq(c) && o(c), !eq(c) && p && o({ message: p, type: "danger" });
  }, [e]), h(() => {
    var c, p;
    if (typeof ((c = e == null ? void 0 : e.data) == null ? void 0 : c.scrollTo) == "string") {
      const d = document.getElementById((p = e == null ? void 0 : e.data) == null ? void 0 : p.scrollTo);
      d && yse.scrollTo(d.offsetTop - 200);
    }
  }, [e]);
}
const wse = $e({});
function Qit(e) {
  const t = ge(wse);
  if (Object.entries(t).length === 0)
    throw new Error("useDrawer must be used within a Provider");
  if (e) {
    const {
      drawerData: n,
      drawerIsOpen: r,
      openDrawer: o,
      closeDrawer: i
    } = t, a = r(e), s = n(e);
    return { drawerIsOpen: a, drawerData: s, openDrawer: (c) => o(e, c), closeDrawer: () => i(e) };
  } else
    return t;
}
function Pnt() {
  return () => {
  };
}
function Snt() {
  return Xse(
    Pnt,
    () => !0,
    () => !1
  );
}
function est(e) {
  const t = ge(Ij);
  if (Object.entries(t).length === 0)
    throw new Error("useModal must be used within a Provider");
  if (e) {
    const {
      modalData: n,
      modalIsOpen: r,
      openModal: o,
      closeModal: i
    } = t, a = r(e), s = n(e);
    return { modalIsOpen: a, modalData: s, openModal: (c) => o(e, c), closeModal: () => i(e) };
  } else
    return t;
}
function tst(e) {
  const { children: t = !1 } = e, [n, r] = k([]);
  function o(l) {
    return !!n.some((u) => u.key === l);
  }
  function i(l) {
    var u;
    return (u = n.find((c) => c.key === l)) == null ? void 0 : u.data;
  }
  function a(l, u) {
    const c = o(l);
    r(c ? (p) => [...p.filter((g) => g.key !== l), { key: l, data: u }] : [...n, { key: l, data: u }]);
  }
  function s(l) {
    r(n.filter((u) => u.key !== l));
  }
  return /* @__PURE__ */ ee.jsx(
    wse.Provider,
    {
      value: { drawerIsOpen: o, drawerData: i, openDrawer: a, closeDrawer: s },
      children: t
    }
  );
}
function Zh(e) {
  "@babel/helpers - typeof";
  return Zh = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Zh(e);
}
function Mnt(e, t) {
  if (Zh(e) != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (Zh(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function Dnt(e) {
  var t = Mnt(e, "string");
  return Zh(t) == "symbol" ? t : t + "";
}
function Ce(e, t, n) {
  return (t = Dnt(t)) in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function Cse(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var GL, tq;
function Tnt() {
  if (tq) return GL;
  tq = 1;
  var e = process.env.NODE_ENV, t = function(r, o, i, a, s, l, u, c) {
    if (e !== "production" && o === void 0)
      throw new Error("invariant requires an error message argument");
    if (!r) {
      var p;
      if (o === void 0)
        p = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
      else {
        var d = [i, a, s, l, u, c], g = 0;
        p = new Error(o.replace(/%s/g, function() {
          return d[g++];
        })), p.name = "Invariant Violation";
      }
      throw p.framesToPop = 1, p;
    }
  };
  return GL = t, GL;
}
var jnt = Tnt(), Go = /* @__PURE__ */ Cse(jnt), At = $e(null);
function Ant() {
  Go(!!ge, "useGoogleMap is React hook and requires React version 16.8+");
  var e = ge(At);
  return Go(!!e, "useGoogleMap needs a GoogleMap available up in the tree"), e;
}
function Rnt(e, t, n) {
  return Object.keys(e).reduce(function(o, i) {
    return t(o, e[i], i);
  }, n);
}
function Int(e, t) {
  Object.keys(e).forEach((n) => t(e[n], n));
}
function Nnt(e, t, n, r) {
  var o = {}, i = (a, s) => {
    var l = n[s];
    l !== t[s] && (o[s] = l, a(r, l));
  };
  return Int(e, i), o;
}
function Bnt(e, t, n) {
  var r = Rnt(n, function(i, a, s) {
    return typeof e[s] == "function" && i.push(google.maps.event.addListener(t, a, e[s])), i;
  }, []);
  return r;
}
function Fnt(e) {
  google.maps.event.removeListener(e);
}
function un() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  e.forEach(Fnt);
}
function Jt(e) {
  var {
    updaterMap: t,
    eventMap: n,
    prevProps: r,
    nextProps: o,
    instance: i
  } = e, a = Bnt(o, i, n);
  return Nnt(t, r, o, i), a;
}
var nq = {
  onDblClick: "dblclick",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMapTypeIdChanged: "maptypeid_changed",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseDown: "mousedown",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onTilesLoaded: "tilesloaded",
  onBoundsChanged: "bounds_changed",
  onCenterChanged: "center_changed",
  onClick: "click",
  onDrag: "drag",
  onHeadingChanged: "heading_changed",
  onIdle: "idle",
  onProjectionChanged: "projection_changed",
  onResize: "resize",
  onTiltChanged: "tilt_changed",
  onZoomChanged: "zoom_changed"
}, rq = {
  extraMapTypes(e, t) {
    t.forEach(function(r, o) {
      e.mapTypes.set(String(o), r);
    });
  },
  center(e, t) {
    e.setCenter(t);
  },
  clickableIcons(e, t) {
    e.setClickableIcons(t);
  },
  heading(e, t) {
    e.setHeading(t);
  },
  mapTypeId(e, t) {
    e.setMapTypeId(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  streetView(e, t) {
    e.setStreetView(t);
  },
  tilt(e, t) {
    e.setTilt(t);
  },
  zoom(e, t) {
    e.setZoom(t);
  }
};
function znt(e) {
  var {
    children: t,
    options: n,
    id: r,
    mapContainerStyle: o,
    mapContainerClassName: i,
    center: a,
    // clickableIcons,
    // extraMapTypes,
    // heading,
    // mapTypeId,
    onClick: s,
    onDblClick: l,
    onDrag: u,
    onDragEnd: c,
    onDragStart: p,
    onMouseMove: d,
    onMouseOut: g,
    onMouseOver: f,
    onMouseDown: m,
    onMouseUp: b,
    onRightClick: E,
    // onMapTypeIdChanged,
    // onTilesLoaded,
    // onBoundsChanged,
    onCenterChanged: w,
    // onHeadingChanged,
    // onIdle,
    // onProjectionChanged,
    // onResize,
    // onTiltChanged,
    // onZoomChanged,
    onLoad: M,
    onUnmount: x
  } = e, [v, C] = k(null), P = dt(null), [F, L] = k(null), [B, N] = k(null), [$, V] = k(null), [H, Z] = k(null), [K, Y] = k(null), [Q, J] = k(null), [_, D] = k(null), [z, S] = k(null), [W, O] = k(null), [j, U] = k(null), [T, q] = k(null), [A, X] = k(null);
  return h(() => {
    n && v !== null && v.setOptions(n);
  }, [v, n]), h(() => {
    v !== null && typeof a < "u" && v.setCenter(a);
  }, [v, a]), h(() => {
    v && l && (B !== null && google.maps.event.removeListener(B), N(google.maps.event.addListener(v, "dblclick", l)));
  }, [l]), h(() => {
    v && c && ($ !== null && google.maps.event.removeListener($), V(google.maps.event.addListener(v, "dragend", c)));
  }, [c]), h(() => {
    v && p && (H !== null && google.maps.event.removeListener(H), Z(google.maps.event.addListener(v, "dragstart", p)));
  }, [p]), h(() => {
    v && m && (K !== null && google.maps.event.removeListener(K), Y(google.maps.event.addListener(v, "mousedown", m)));
  }, [m]), h(() => {
    v && d && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(v, "mousemove", d)));
  }, [d]), h(() => {
    v && g && (_ !== null && google.maps.event.removeListener(_), D(google.maps.event.addListener(v, "mouseout", g)));
  }, [g]), h(() => {
    v && f && (z !== null && google.maps.event.removeListener(z), S(google.maps.event.addListener(v, "mouseover", f)));
  }, [f]), h(() => {
    v && b && (W !== null && google.maps.event.removeListener(W), O(google.maps.event.addListener(v, "mouseup", b)));
  }, [b]), h(() => {
    v && E && (j !== null && google.maps.event.removeListener(j), U(google.maps.event.addListener(v, "rightclick", E)));
  }, [E]), h(() => {
    v && s && (T !== null && google.maps.event.removeListener(T), q(google.maps.event.addListener(v, "click", s)));
  }, [s]), h(() => {
    v && u && (A !== null && google.maps.event.removeListener(A), X(google.maps.event.addListener(v, "drag", u)));
  }, [u]), h(() => {
    v && w && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(v, "center_changed", w)));
  }, [s]), h(() => {
    var I = P.current === null ? null : new google.maps.Map(P.current, n);
    return C(I), I !== null && M && M(I), () => {
      I !== null && x && x(I);
    };
  }, []), ee.jsx("div", {
    id: r,
    ref: P,
    style: o,
    className: i,
    children: ee.jsx(At.Provider, {
      value: v,
      children: v !== null ? t : null
    })
  });
}
me(znt);
let Unt = class extends pe {
  constructor() {
    super(...arguments), Ce(this, "state", {
      map: null
    }), Ce(this, "registeredEvents", []), Ce(this, "mapRef", null), Ce(this, "getInstance", () => this.mapRef === null ? null : new google.maps.Map(this.mapRef, this.props.options)), Ce(this, "panTo", (t) => {
      var n = this.getInstance();
      n && n.panTo(t);
    }), Ce(this, "setMapCallback", () => {
      this.state.map !== null && this.props.onLoad && this.props.onLoad(this.state.map);
    }), Ce(this, "getRef", (t) => {
      this.mapRef = t;
    });
  }
  componentDidMount() {
    var t = this.getInstance();
    this.registeredEvents = Jt({
      updaterMap: rq,
      eventMap: nq,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        map: t
      };
    }, this.setMapCallback);
  }
  componentDidUpdate(t) {
    this.state.map !== null && (un(this.registeredEvents), this.registeredEvents = Jt({
      updaterMap: rq,
      eventMap: nq,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.map
    }));
  }
  componentWillUnmount() {
    this.state.map !== null && (this.props.onUnmount && this.props.onUnmount(this.state.map), un(this.registeredEvents));
  }
  render() {
    return ee.jsx("div", {
      id: this.props.id,
      ref: this.getRef,
      style: this.props.mapContainerStyle,
      className: this.props.mapContainerClassName,
      children: ee.jsx(At.Provider, {
        value: this.state.map,
        children: this.state.map !== null ? this.props.children : null
      })
    });
  }
};
function oq(e, t, n, r, o, i, a) {
  try {
    var s = e[i](a), l = s.value;
  } catch (u) {
    return void n(u);
  }
  s.done ? t(l) : Promise.resolve(l).then(r, o);
}
function Ose(e) {
  return function() {
    var t = this, n = arguments;
    return new Promise(function(r, o) {
      var i = e.apply(t, n);
      function a(l) {
        oq(i, r, o, a, s, "next", l);
      }
      function s(l) {
        oq(i, r, o, a, s, "throw", l);
      }
      a(void 0);
    });
  };
}
function xse(e) {
  var {
    googleMapsApiKey: t,
    googleMapsClientId: n,
    version: r = "weekly",
    language: o,
    region: i,
    libraries: a,
    channel: s,
    mapIds: l,
    authReferrerPolicy: u
  } = e, c = [];
  return Go(t && n || !(t && n), "You need to specify either googleMapsApiKey or googleMapsClientId for @react-google-maps/api load script to work. You cannot use both at the same time."), t ? c.push("key=".concat(t)) : n && c.push("client=".concat(n)), r && c.push("v=".concat(r)), o && c.push("language=".concat(o)), i && c.push("region=".concat(i)), a && a.length && c.push("libraries=".concat(a.sort().join(","))), s && c.push("channel=".concat(s)), l && l.length && c.push("map_ids=".concat(l.join(","))), u && c.push("auth_referrer_policy=".concat(u)), c.push("loading=async"), c.push("callback=initMap"), "https://maps.googleapis.com/maps/api/js?".concat(c.join("&"));
}
var Oc = typeof document < "u";
function Ese(e) {
  var {
    url: t,
    id: n,
    nonce: r
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } = e;
  return Oc ? new Promise(function(i, a) {
    var s = document.getElementById(n), l = window;
    if (s) {
      var u = s.getAttribute("data-state");
      if (s.src === t && u !== "error") {
        if (u === "ready")
          return i(n);
        var c = l.initMap, p = s.onerror;
        l.initMap = function() {
          c && c(), i(n);
        }, s.onerror = function(g) {
          p && p(g), a(g);
        };
        return;
      } else
        s.remove();
    }
    var d = document.createElement("script");
    d.type = "text/javascript", d.src = t, d.id = n, d.async = !0, d.nonce = r || "", d.onerror = function(f) {
      d.setAttribute("data-state", "error"), a(f);
    }, l.initMap = function() {
      d.setAttribute("data-state", "ready"), i(n);
    }, document.head.appendChild(d);
  }).catch((o) => {
    throw console.error("injectScript error: ", o), o;
  }) : Promise.reject(new Error("document is undefined"));
}
function iq(e) {
  var t = e.href;
  return t && (t.indexOf("https://fonts.googleapis.com/css?family=Roboto") === 0 || t.indexOf("https://fonts.googleapis.com/css?family=Google+Sans+Text") === 0) ? !0 : (
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.styleSheet.cssText = "", !0) : (
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.innerHTML = "", !0) : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.innerHTML
      )
    )
  );
}
function kse() {
  var e = document.getElementsByTagName("head")[0];
  if (e) {
    var t = e.insertBefore.bind(e);
    e.insertBefore = function(o, i) {
      return iq(o) || Reflect.apply(t, e, [o, i]), o;
    };
    var n = e.appendChild.bind(e);
    e.appendChild = function(o) {
      return iq(o) || Reflect.apply(n, e, [o]), o;
    };
  }
}
var zd = !1;
function Lse() {
  return ee.jsx("div", {
    children: "Loading..."
  });
}
var HP = {
  id: "script-loader",
  version: "weekly"
};
class _se extends pe {
  constructor() {
    super(...arguments), Ce(this, "check", null), Ce(this, "state", {
      loaded: !1
    }), Ce(this, "cleanupCallback", () => {
      delete window.google.maps, this.injectScript();
    }), Ce(this, "isCleaningUp", /* @__PURE__ */ Ose(function* () {
      function t(n) {
        if (!zd)
          n();
        else if (Oc)
          var r = window.setInterval(function() {
            zd || (window.clearInterval(r), n());
          }, 1);
      }
      return new Promise(t);
    })), Ce(this, "cleanup", () => {
      zd = !0;
      var t = document.getElementById(this.props.id);
      t && t.parentNode && t.parentNode.removeChild(t), Array.prototype.slice.call(document.getElementsByTagName("script")).filter(function(r) {
        return typeof r.src == "string" && r.src.includes("maps.googleapis");
      }).forEach(function(r) {
        r.parentNode && r.parentNode.removeChild(r);
      }), Array.prototype.slice.call(document.getElementsByTagName("link")).filter(function(r) {
        return r.href === "https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Google+Sans";
      }).forEach(function(r) {
        r.parentNode && r.parentNode.removeChild(r);
      }), Array.prototype.slice.call(document.getElementsByTagName("style")).filter(function(r) {
        return r.innerText !== void 0 && r.innerText.length > 0 && r.innerText.includes(".gm-");
      }).forEach(function(r) {
        r.parentNode && r.parentNode.removeChild(r);
      });
    }), Ce(this, "injectScript", () => {
      this.props.preventGoogleFontsLoading && kse(), Go(!!this.props.id, 'LoadScript requires "id" prop to be a string: %s', this.props.id);
      var t = {
        id: this.props.id,
        nonce: this.props.nonce,
        url: xse(this.props)
      };
      Ese(t).then(() => {
        this.props.onLoad && this.props.onLoad(), this.setState(function() {
          return {
            loaded: !0
          };
        });
      }).catch((n) => {
        this.props.onError && this.props.onError(n), console.error(`
          There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(this.props.googleMapsApiKey || "-", ") or Client ID (").concat(this.props.googleMapsClientId || "-", `) to <LoadScript />
          Otherwise it is a Network issue.
        `));
      });
    }), Ce(this, "getRef", (t) => {
      this.check = t;
    });
  }
  componentDidMount() {
    if (Oc) {
      if (window.google && window.google.maps && !zd) {
        console.error("google api is already presented");
        return;
      }
      this.isCleaningUp().then(this.injectScript).catch(function(n) {
        console.error("Error at injecting script after cleaning up: ", n);
      });
    }
  }
  componentDidUpdate(t) {
    this.props.libraries !== t.libraries && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), Oc && t.language !== this.props.language && (this.cleanup(), this.setState(function() {
      return {
        loaded: !1
      };
    }, this.cleanupCallback));
  }
  componentWillUnmount() {
    if (Oc) {
      this.cleanup();
      var t = () => {
        this.check || (delete window.google, zd = !1);
      };
      window.setTimeout(t, 1), this.props.onUnmount && this.props.onUnmount();
    }
  }
  render() {
    return ee.jsxs(ee.Fragment, {
      children: [ee.jsx("div", {
        ref: this.getRef
      }), this.state.loaded ? this.props.children : this.props.loadingElement || ee.jsx(Lse, {})]
    });
  }
}
Ce(_se, "defaultProps", HP);
function Hnt(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.includes(r)) continue;
    n[r] = e[r];
  }
  return n;
}
function Nj(e, t) {
  if (e == null) return {};
  var n, r, o = Hnt(e, t);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (r = 0; r < i.length; r++) n = i[r], t.includes(n) || {}.propertyIsEnumerable.call(e, n) && (o[n] = e[n]);
  }
  return o;
}
var sq;
function Wnt(e) {
  var {
    id: t = HP.id,
    version: n = HP.version,
    nonce: r,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    preventGoogleFontsLoading: u,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  } = e, g = dt(!1), [f, m] = k(!1), [b, E] = k(void 0);
  h(function() {
    return g.current = !0, () => {
      g.current = !1;
    };
  }, []), h(function() {
    Oc && u && kse();
  }, [u]), h(function() {
    f && Go(!!window.google, "useLoadScript was marked as loaded, but window.google is not present. Something went wrong.");
  }, [f]);
  var w = xse({
    version: n,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  });
  h(function() {
    if (!Oc)
      return;
    function v() {
      g.current && (m(!0), sq = w);
    }
    if (window.google && window.google.maps && sq === w) {
      v();
      return;
    }
    Ese({
      id: t,
      url: w,
      nonce: r
    }).then(v).catch(function(P) {
      g.current && E(P), console.warn(`
        There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(o || "-", ") or Client ID (").concat(i || "-", `)
        Otherwise it is a Network issue.
      `)), console.error(P);
    });
  }, [t, w, r]);
  var M = dt(void 0);
  return h(function() {
    M.current && l !== M.current && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), M.current = l;
  }, [l]), {
    isLoaded: f,
    loadError: b,
    url: w
  };
}
var $nt = ["loadingElement", "onLoad", "onError", "onUnmount", "children"], Vnt = ee.jsx(Lse, {});
function Znt(e) {
  var {
    loadingElement: t,
    onLoad: n,
    onError: r,
    onUnmount: o,
    children: i
  } = e, a = Nj(e, $nt), {
    isLoaded: s,
    loadError: l
  } = Wnt(a);
  return h(function() {
    s && typeof n == "function" && n();
  }, [s, n]), h(function() {
    l && typeof r == "function" && r(l);
  }, [l, r]), h(function() {
    return () => {
      o && o();
    };
  }, [o]), s ? i : t || Vnt;
}
me(Znt);
var aq;
(function(e) {
  e[e.INITIALIZED = 0] = "INITIALIZED", e[e.LOADING = 1] = "LOADING", e[e.SUCCESS = 2] = "SUCCESS", e[e.FAILURE = 3] = "FAILURE";
})(aq || (aq = {}));
function lq(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Jw(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? lq(Object(n), !0).forEach(function(r) {
      Ce(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : lq(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var uq = {}, cq = {
  options(e, t) {
    e.setOptions(t);
  }
};
function qnt(e) {
  var {
    options: t,
    onLoad: n,
    onUnmount: r
  } = e, o = ge(At), [i, a] = k(null);
  return h(() => {
    i !== null && i.setMap(o);
  }, [o]), h(() => {
    t && i !== null && i.setOptions(t);
  }, [i, t]), h(() => {
    var s = new google.maps.TrafficLayer(Jw(Jw({}, t), {}, {
      map: o
    }));
    return a(s), n && n(s), () => {
      i !== null && (r && r(i), i.setMap(null));
    };
  }, []), null;
}
me(qnt);
class Gnt extends pe {
  constructor() {
    super(...arguments), Ce(this, "state", {
      trafficLayer: null
    }), Ce(this, "setTrafficLayerCallback", () => {
      this.state.trafficLayer !== null && this.props.onLoad && this.props.onLoad(this.state.trafficLayer);
    }), Ce(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = new google.maps.TrafficLayer(Jw(Jw({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Jt({
      updaterMap: cq,
      eventMap: uq,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        trafficLayer: t
      };
    }, this.setTrafficLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.trafficLayer !== null && (un(this.registeredEvents), this.registeredEvents = Jt({
      updaterMap: cq,
      eventMap: uq,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.trafficLayer
    }));
  }
  componentWillUnmount() {
    this.state.trafficLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.trafficLayer), un(this.registeredEvents), this.state.trafficLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Ce(Gnt, "contextType", At);
function Knt(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = ge(At), [o, i] = k(null);
  return h(() => {
    o !== null && o.setMap(r);
  }, [r]), h(() => {
    var a = new google.maps.BicyclingLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      a !== null && (n && n(a), a.setMap(null));
    };
  }, []), null;
}
me(Knt);
class Xnt extends pe {
  constructor() {
    super(...arguments), Ce(this, "state", {
      bicyclingLayer: null
    }), Ce(this, "setBicyclingLayerCallback", () => {
      this.state.bicyclingLayer !== null && (this.state.bicyclingLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.bicyclingLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.BicyclingLayer();
    this.setState(() => ({
      bicyclingLayer: t
    }), this.setBicyclingLayerCallback);
  }
  componentWillUnmount() {
    this.state.bicyclingLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.bicyclingLayer), this.state.bicyclingLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Ce(Xnt, "contextType", At);
function Ynt(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = ge(At), [o, i] = k(null);
  return h(() => {
    o !== null && o.setMap(r);
  }, [r]), h(() => {
    var a = new google.maps.TransitLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      o !== null && (n && n(o), o.setMap(null));
    };
  }, []), null;
}
me(Ynt);
class Jnt extends pe {
  constructor() {
    super(...arguments), Ce(this, "state", {
      transitLayer: null
    }), Ce(this, "setTransitLayerCallback", () => {
      this.state.transitLayer !== null && (this.state.transitLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.transitLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.TransitLayer();
    this.setState(function() {
      return {
        transitLayer: t
      };
    }, this.setTransitLayerCallback);
  }
  componentWillUnmount() {
    this.state.transitLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.transitLayer), this.state.transitLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Ce(Jnt, "contextType", At);
function pq(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Qw(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? pq(Object(n), !0).forEach(function(r) {
      Ce(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : pq(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var dq = {
  onCircleComplete: "circlecomplete",
  onMarkerComplete: "markercomplete",
  onOverlayComplete: "overlaycomplete",
  onPolygonComplete: "polygoncomplete",
  onPolylineComplete: "polylinecomplete",
  onRectangleComplete: "rectanglecomplete"
}, fq = {
  drawingMode(e, t) {
    e.setDrawingMode(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function Qnt(e) {
  var {
    options: t,
    drawingMode: n,
    onCircleComplete: r,
    onMarkerComplete: o,
    onOverlayComplete: i,
    onPolygonComplete: a,
    onPolylineComplete: s,
    onRectangleComplete: l,
    onLoad: u,
    onUnmount: c
  } = e, p = ge(At), [d, g] = k(null), [f, m] = k(null), [b, E] = k(null), [w, M] = k(null), [x, v] = k(null), [C, P] = k(null), [F, L] = k(null);
  return h(() => {
    d !== null && d.setMap(p);
  }, [p]), h(() => {
    t && d !== null && d.setOptions(t);
  }, [d, t]), h(() => {
    d !== null && d.setDrawingMode(n ?? null);
  }, [d, n]), h(() => {
    d && r && (f !== null && google.maps.event.removeListener(f), m(google.maps.event.addListener(d, "circlecomplete", r)));
  }, [d, r]), h(() => {
    d && o && (b !== null && google.maps.event.removeListener(b), E(google.maps.event.addListener(d, "markercomplete", o)));
  }, [d, o]), h(() => {
    d && i && (w !== null && google.maps.event.removeListener(w), M(google.maps.event.addListener(d, "overlaycomplete", i)));
  }, [d, i]), h(() => {
    d && a && (x !== null && google.maps.event.removeListener(x), v(google.maps.event.addListener(d, "polygoncomplete", a)));
  }, [d, a]), h(() => {
    d && s && (C !== null && google.maps.event.removeListener(C), P(google.maps.event.addListener(d, "polylinecomplete", s)));
  }, [d, s]), h(() => {
    d && l && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(d, "rectanglecomplete", l)));
  }, [d, l]), h(() => {
    Go(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
    var B = new google.maps.drawing.DrawingManager(Qw(Qw({}, t), {}, {
      map: p
    }));
    return n && B.setDrawingMode(n), r && m(google.maps.event.addListener(B, "circlecomplete", r)), o && E(google.maps.event.addListener(B, "markercomplete", o)), i && M(google.maps.event.addListener(B, "overlaycomplete", i)), a && v(google.maps.event.addListener(B, "polygoncomplete", a)), s && P(google.maps.event.addListener(B, "polylinecomplete", s)), l && L(google.maps.event.addListener(B, "rectanglecomplete", l)), g(B), u && u(B), () => {
      d !== null && (f && google.maps.event.removeListener(f), b && google.maps.event.removeListener(b), w && google.maps.event.removeListener(w), x && google.maps.event.removeListener(x), C && google.maps.event.removeListener(C), F && google.maps.event.removeListener(F), c && c(d), d.setMap(null));
    };
  }, []), null;
}
me(Qnt);
class ert extends pe {
  constructor(t) {
    super(t), Ce(this, "registeredEvents", []), Ce(this, "state", {
      drawingManager: null
    }), Ce(this, "setDrawingManagerCallback", () => {
      this.state.drawingManager !== null && this.props.onLoad && this.props.onLoad(this.state.drawingManager);
    }), Go(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
  }
  componentDidMount() {
    var t = new google.maps.drawing.DrawingManager(Qw(Qw({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Jt({
      updaterMap: fq,
      eventMap: dq,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        drawingManager: t
      };
    }, this.setDrawingManagerCallback);
  }
  componentDidUpdate(t) {
    this.state.drawingManager !== null && (un(this.registeredEvents), this.registeredEvents = Jt({
      updaterMap: fq,
      eventMap: dq,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.drawingManager
    }));
  }
  componentWillUnmount() {
    this.state.drawingManager !== null && (this.props.onUnmount && this.props.onUnmount(this.state.drawingManager), un(this.registeredEvents), this.state.drawingManager.setMap(null));
  }
  render() {
    return null;
  }
}
Ce(ert, "contextType", At);
function hq(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function bp(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? hq(Object(n), !0).forEach(function(r) {
      Ce(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : hq(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var gq = {
  onAnimationChanged: "animation_changed",
  onClick: "click",
  onClickableChanged: "clickable_changed",
  onCursorChanged: "cursor_changed",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDraggableChanged: "draggable_changed",
  onDragStart: "dragstart",
  onFlatChanged: "flat_changed",
  onIconChanged: "icon_changed",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onPositionChanged: "position_changed",
  onRightClick: "rightclick",
  onShapeChanged: "shape_changed",
  onTitleChanged: "title_changed",
  onVisibleChanged: "visible_changed",
  onZindexChanged: "zindex_changed"
}, mq = {
  animation(e, t) {
    e.setAnimation(t);
  },
  clickable(e, t) {
    e.setClickable(t);
  },
  cursor(e, t) {
    e.setCursor(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  icon(e, t) {
    e.setIcon(t);
  },
  label(e, t) {
    e.setLabel(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  opacity(e, t) {
    e.setOpacity(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  shape(e, t) {
    e.setShape(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, e0 = {};
function trt(e) {
  var {
    position: t,
    options: n,
    clusterer: r,
    noClustererRedraw: o,
    children: i,
    draggable: a,
    visible: s,
    animation: l,
    clickable: u,
    cursor: c,
    icon: p,
    label: d,
    opacity: g,
    shape: f,
    title: m,
    zIndex: b,
    onClick: E,
    onDblClick: w,
    onDrag: M,
    onDragEnd: x,
    onDragStart: v,
    onMouseOut: C,
    onMouseOver: P,
    onMouseUp: F,
    onMouseDown: L,
    onRightClick: B,
    onClickableChanged: N,
    onCursorChanged: $,
    onAnimationChanged: V,
    onDraggableChanged: H,
    onFlatChanged: Z,
    onIconChanged: K,
    onPositionChanged: Y,
    onShapeChanged: Q,
    onTitleChanged: J,
    onVisibleChanged: _,
    onZindexChanged: D,
    onLoad: z,
    onUnmount: S
  } = e, W = ge(At), [O, j] = k(null), [U, T] = k(null), [q, A] = k(null), [X, I] = k(null), [le, he] = k(null), [oe, Ae] = k(null), [Ue, He] = k(null), [Re, nt] = k(null), [Ve, we] = k(null), [et, lt] = k(null), [ye, ke] = k(null), [Qe, Fe] = k(null), [Ie, ot] = k(null), [Ee, wt] = k(null), [it, st] = k(null), [ut, Ct] = k(null), [ct, pt] = k(null), [rt, We] = k(null), [Ot, xt] = k(null), [gt, Ht] = k(null), [mt, Wt] = k(null), [vt, kt] = k(null);
  h(() => {
    O !== null && O.setMap(W);
  }, [W]), h(() => {
    typeof n < "u" && O !== null && O.setOptions(n);
  }, [O, n]), h(() => {
    typeof a < "u" && O !== null && O.setDraggable(a);
  }, [O, a]), h(() => {
    t && O !== null && O.setPosition(t);
  }, [O, t]), h(() => {
    typeof s < "u" && O !== null && O.setVisible(s);
  }, [O, s]), h(() => {
    O == null || O.setAnimation(l);
  }, [O, l]), h(() => {
    O && u !== void 0 && O.setClickable(u);
  }, [O, u]), h(() => {
    O && c !== void 0 && O.setCursor(c);
  }, [O, c]), h(() => {
    O && p !== void 0 && O.setIcon(p);
  }, [O, p]), h(() => {
    O && d !== void 0 && O.setLabel(d);
  }, [O, d]), h(() => {
    O && g !== void 0 && O.setOpacity(g);
  }, [O, g]), h(() => {
    O && f !== void 0 && O.setShape(f);
  }, [O, f]), h(() => {
    O && m !== void 0 && O.setTitle(m);
  }, [O, m]), h(() => {
    O && b !== void 0 && O.setZIndex(b);
  }, [O, b]), h(() => {
    O && w && (U !== null && google.maps.event.removeListener(U), T(google.maps.event.addListener(O, "dblclick", w)));
  }, [w]), h(() => {
    O && x && (q !== null && google.maps.event.removeListener(q), A(google.maps.event.addListener(O, "dragend", x)));
  }, [x]), h(() => {
    O && v && (X !== null && google.maps.event.removeListener(X), I(google.maps.event.addListener(O, "dragstart", v)));
  }, [v]), h(() => {
    O && L && (le !== null && google.maps.event.removeListener(le), he(google.maps.event.addListener(O, "mousedown", L)));
  }, [L]), h(() => {
    O && C && (oe !== null && google.maps.event.removeListener(oe), Ae(google.maps.event.addListener(O, "mouseout", C)));
  }, [C]), h(() => {
    O && P && (Ue !== null && google.maps.event.removeListener(Ue), He(google.maps.event.addListener(O, "mouseover", P)));
  }, [P]), h(() => {
    O && F && (Re !== null && google.maps.event.removeListener(Re), nt(google.maps.event.addListener(O, "mouseup", F)));
  }, [F]), h(() => {
    O && B && (Ve !== null && google.maps.event.removeListener(Ve), we(google.maps.event.addListener(O, "rightclick", B)));
  }, [B]), h(() => {
    O && E && (et !== null && google.maps.event.removeListener(et), lt(google.maps.event.addListener(O, "click", E)));
  }, [E]), h(() => {
    O && M && (ye !== null && google.maps.event.removeListener(ye), ke(google.maps.event.addListener(O, "drag", M)));
  }, [M]), h(() => {
    O && N && (Qe !== null && google.maps.event.removeListener(Qe), Fe(google.maps.event.addListener(O, "clickable_changed", N)));
  }, [N]), h(() => {
    O && $ && (Ie !== null && google.maps.event.removeListener(Ie), ot(google.maps.event.addListener(O, "cursor_changed", $)));
  }, [$]), h(() => {
    O && V && (Ee !== null && google.maps.event.removeListener(Ee), wt(google.maps.event.addListener(O, "animation_changed", V)));
  }, [V]), h(() => {
    O && H && (it !== null && google.maps.event.removeListener(it), st(google.maps.event.addListener(O, "draggable_changed", H)));
  }, [H]), h(() => {
    O && Z && (ut !== null && google.maps.event.removeListener(ut), Ct(google.maps.event.addListener(O, "flat_changed", Z)));
  }, [Z]), h(() => {
    O && K && (ct !== null && google.maps.event.removeListener(ct), pt(google.maps.event.addListener(O, "icon_changed", K)));
  }, [K]), h(() => {
    O && Y && (rt !== null && google.maps.event.removeListener(rt), We(google.maps.event.addListener(O, "position_changed", Y)));
  }, [Y]), h(() => {
    O && Q && (Ot !== null && google.maps.event.removeListener(Ot), xt(google.maps.event.addListener(O, "shape_changed", Q)));
  }, [Q]), h(() => {
    O && J && (gt !== null && google.maps.event.removeListener(gt), Ht(google.maps.event.addListener(O, "title_changed", J)));
  }, [J]), h(() => {
    O && _ && (mt !== null && google.maps.event.removeListener(mt), Wt(google.maps.event.addListener(O, "visible_changed", _)));
  }, [_]), h(() => {
    O && D && (vt !== null && google.maps.event.removeListener(vt), kt(google.maps.event.addListener(O, "zindex_changed", D)));
  }, [D]), h(() => {
    var yt = bp(bp(bp({}, n || e0), r ? e0 : {
      map: W
    }), {}, {
      position: t
    }), re = new google.maps.Marker(yt);
    return r ? r.addMarker(re, !!o) : re.setMap(W), t && re.setPosition(t), typeof s < "u" && re.setVisible(s), typeof a < "u" && re.setDraggable(a), typeof u < "u" && re.setClickable(u), typeof c == "string" && re.setCursor(c), p && re.setIcon(p), typeof d < "u" && re.setLabel(d), typeof g < "u" && re.setOpacity(g), f && re.setShape(f), typeof m == "string" && re.setTitle(m), typeof b == "number" && re.setZIndex(b), w && T(google.maps.event.addListener(re, "dblclick", w)), x && A(google.maps.event.addListener(re, "dragend", x)), v && I(google.maps.event.addListener(re, "dragstart", v)), L && he(google.maps.event.addListener(re, "mousedown", L)), C && Ae(google.maps.event.addListener(re, "mouseout", C)), P && He(google.maps.event.addListener(re, "mouseover", P)), F && nt(google.maps.event.addListener(re, "mouseup", F)), B && we(google.maps.event.addListener(re, "rightclick", B)), E && lt(google.maps.event.addListener(re, "click", E)), M && ke(google.maps.event.addListener(re, "drag", M)), N && Fe(google.maps.event.addListener(re, "clickable_changed", N)), $ && ot(google.maps.event.addListener(re, "cursor_changed", $)), V && wt(google.maps.event.addListener(re, "animation_changed", V)), H && st(google.maps.event.addListener(re, "draggable_changed", H)), Z && Ct(google.maps.event.addListener(re, "flat_changed", Z)), K && pt(google.maps.event.addListener(re, "icon_changed", K)), Y && We(google.maps.event.addListener(re, "position_changed", Y)), Q && xt(google.maps.event.addListener(re, "shape_changed", Q)), J && Ht(google.maps.event.addListener(re, "title_changed", J)), _ && Wt(google.maps.event.addListener(re, "visible_changed", _)), D && kt(google.maps.event.addListener(re, "zindex_changed", D)), j(re), z && z(re), () => {
      U !== null && google.maps.event.removeListener(U), q !== null && google.maps.event.removeListener(q), X !== null && google.maps.event.removeListener(X), le !== null && google.maps.event.removeListener(le), oe !== null && google.maps.event.removeListener(oe), Ue !== null && google.maps.event.removeListener(Ue), Re !== null && google.maps.event.removeListener(Re), Ve !== null && google.maps.event.removeListener(Ve), et !== null && google.maps.event.removeListener(et), Qe !== null && google.maps.event.removeListener(Qe), Ie !== null && google.maps.event.removeListener(Ie), Ee !== null && google.maps.event.removeListener(Ee), it !== null && google.maps.event.removeListener(it), ut !== null && google.maps.event.removeListener(ut), ct !== null && google.maps.event.removeListener(ct), rt !== null && google.maps.event.removeListener(rt), gt !== null && google.maps.event.removeListener(gt), mt !== null && google.maps.event.removeListener(mt), vt !== null && google.maps.event.removeListener(vt), S && S(re), r ? r.removeMarker(re, !!o) : re && re.setMap(null);
    };
  }, []);
  var Un = ln(() => i ? at.map(i, (yt) => {
    if (!yi(yt))
      return yt;
    var re = yt;
    return bi(re, {
      anchor: O
    });
  }) : null, [i, O]);
  return ee.jsx(ee.Fragment, {
    children: Un
  }) || null;
}
me(trt);
class Pse extends pe {
  constructor() {
    super(...arguments), Ce(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this;
    return Ose(function* () {
      var n = bp(bp(bp({}, t.props.options || e0), t.props.clusterer ? e0 : {
        map: t.context
      }), {}, {
        position: t.props.position
      });
      t.marker = new google.maps.Marker(n), t.props.clusterer ? t.props.clusterer.addMarker(t.marker, !!t.props.noClustererRedraw) : t.marker.setMap(t.context), t.registeredEvents = Jt({
        updaterMap: mq,
        eventMap: gq,
        prevProps: {},
        nextProps: t.props,
        instance: t.marker
      }), t.props.onLoad && t.props.onLoad(t.marker);
    })();
  }
  componentDidUpdate(t) {
    this.marker && (un(this.registeredEvents), this.registeredEvents = Jt({
      updaterMap: mq,
      eventMap: gq,
      prevProps: t,
      nextProps: this.props,
      instance: this.marker
    }));
  }
  componentWillUnmount() {
    this.marker && (this.props.onUnmount && this.props.onUnmount(this.marker), un(this.registeredEvents), this.props.clusterer ? this.props.clusterer.removeMarker(this.marker, !!this.props.noClustererRedraw) : this.marker && this.marker.setMap(null));
  }
  render() {
    var t = this.props.children ? at.map(this.props.children, (n) => {
      if (!yi(n))
        return n;
      var r = n;
      return bi(r, {
        anchor: this.marker
      });
    }) : null;
    return t || null;
  }
}
Ce(Pse, "contextType", At);
var nrt = (
  /** @class */
  function() {
    function e(t, n) {
      t.getClusterer().extend(e, google.maps.OverlayView), this.cluster = t, this.clusterClassName = this.cluster.getClusterer().getClusterClass(), this.className = this.clusterClassName, this.styles = n, this.center = void 0, this.div = null, this.sums = null, this.visible = !1, this.boundsChangedListener = null, this.url = "", this.height = 0, this.width = 0, this.anchorText = [0, 0], this.anchorIcon = [0, 0], this.textColor = "black", this.textSize = 11, this.textDecoration = "none", this.fontWeight = "bold", this.fontStyle = "normal", this.fontFamily = "Arial,sans-serif", this.backgroundPosition = "0 0", this.cMouseDownInCluster = null, this.cDraggingMapByCluster = null, this.timeOut = null, this.setMap(t.getMap()), this.onBoundsChanged = this.onBoundsChanged.bind(this), this.onMouseDown = this.onMouseDown.bind(this), this.onClick = this.onClick.bind(this), this.onMouseOver = this.onMouseOver.bind(this), this.onMouseOut = this.onMouseOut.bind(this), this.onAdd = this.onAdd.bind(this), this.onRemove = this.onRemove.bind(this), this.draw = this.draw.bind(this), this.hide = this.hide.bind(this), this.show = this.show.bind(this), this.useStyle = this.useStyle.bind(this), this.setCenter = this.setCenter.bind(this), this.getPosFromLatLng = this.getPosFromLatLng.bind(this);
    }
    return e.prototype.onBoundsChanged = function() {
      this.cDraggingMapByCluster = this.cMouseDownInCluster;
    }, e.prototype.onMouseDown = function() {
      this.cMouseDownInCluster = !0, this.cDraggingMapByCluster = !1;
    }, e.prototype.onClick = function(t) {
      if (this.cMouseDownInCluster = !1, !this.cDraggingMapByCluster) {
        var n = this.cluster.getClusterer();
        if (google.maps.event.trigger(n, "click", this.cluster), google.maps.event.trigger(n, "clusterclick", this.cluster), n.getZoomOnClick()) {
          var r = n.getMaxZoom(), o = this.cluster.getBounds(), i = n.getMap();
          i !== null && "fitBounds" in i && i.fitBounds(o), this.timeOut = window.setTimeout(function() {
            var a = n.getMap();
            if (a !== null) {
              "fitBounds" in a && a.fitBounds(o);
              var s = a.getZoom() || 0;
              r !== null && s > r && a.setZoom(r + 1);
            }
          }, 100);
        }
        t.cancelBubble = !0, t.stopPropagation && t.stopPropagation();
      }
    }, e.prototype.onMouseOver = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseover", this.cluster);
    }, e.prototype.onMouseOut = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseout", this.cluster);
    }, e.prototype.onAdd = function() {
      var t;
      this.div = document.createElement("div"), this.div.className = this.className, this.visible && this.show(), (t = this.getPanes()) === null || t === void 0 || t.overlayMouseTarget.appendChild(this.div);
      var n = this.getMap();
      n !== null && (this.boundsChangedListener = google.maps.event.addListener(n, "bounds_changed", this.onBoundsChanged), this.div.addEventListener("mousedown", this.onMouseDown), this.div.addEventListener("click", this.onClick), this.div.addEventListener("mouseover", this.onMouseOver), this.div.addEventListener("mouseout", this.onMouseOut));
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.hide(), this.boundsChangedListener !== null && google.maps.event.removeListener(this.boundsChangedListener), this.div.removeEventListener("mousedown", this.onMouseDown), this.div.removeEventListener("click", this.onClick), this.div.removeEventListener("mouseover", this.onMouseOver), this.div.removeEventListener("mouseout", this.onMouseOut), this.div.parentNode.removeChild(this.div), this.timeOut !== null && (window.clearTimeout(this.timeOut), this.timeOut = null), this.div = null);
    }, e.prototype.draw = function() {
      if (this.visible && this.div !== null && this.center) {
        var t = this.getPosFromLatLng(this.center);
        this.div.style.top = t !== null ? "".concat(t.y, "px") : "0", this.div.style.left = t !== null ? "".concat(t.x, "px") : "0";
      }
    }, e.prototype.hide = function() {
      this.div && (this.div.style.display = "none"), this.visible = !1;
    }, e.prototype.show = function() {
      var t, n, r, o, i, a;
      if (this.div && this.center) {
        var s = this.sums === null || typeof this.sums.title > "u" || this.sums.title === "" ? this.cluster.getClusterer().getTitle() : this.sums.title, l = this.backgroundPosition.split(" "), u = parseInt(((t = l[0]) === null || t === void 0 ? void 0 : t.replace(/^\s+|\s+$/g, "")) || "0", 10), c = parseInt(((n = l[1]) === null || n === void 0 ? void 0 : n.replace(/^\s+|\s+$/g, "")) || "0", 10), p = this.getPosFromLatLng(this.center);
        this.div.className = this.className, this.div.setAttribute("style", "cursor: pointer; position: absolute; top: ".concat(p !== null ? "".concat(p.y, "px") : "0", "; left: ").concat(p !== null ? "".concat(p.x, "px") : "0", "; width: ").concat(this.width, "px; height: ").concat(this.height, "px; "));
        var d = document.createElement("img");
        d.alt = s, d.src = this.url, d.width = this.width, d.height = this.height, d.setAttribute("style", "position: absolute; top: ".concat(c, "px; left: ").concat(u, "px")), this.cluster.getClusterer().enableRetinaIcons || (d.style.clip = "rect(-".concat(c, "px, -").concat(u + this.width, "px, -").concat(c + this.height, ", -").concat(u, ")"));
        var g = document.createElement("div");
        g.setAttribute("style", "position: absolute; top: ".concat(this.anchorText[0], "px; left: ").concat(this.anchorText[1], "px; color: ").concat(this.textColor, "; font-size: ").concat(this.textSize, "px; font-family: ").concat(this.fontFamily, "; font-weight: ").concat(this.fontWeight, "; fontStyle: ").concat(this.fontStyle, "; text-decoration: ").concat(this.textDecoration, "; text-align: center; width: ").concat(this.width, "px; line-height: ").concat(this.height, "px")), !((r = this.sums) === null || r === void 0) && r.text && (g.innerText = "".concat((o = this.sums) === null || o === void 0 ? void 0 : o.text)), !((i = this.sums) === null || i === void 0) && i.html && (g.innerHTML = "".concat((a = this.sums) === null || a === void 0 ? void 0 : a.html)), this.div.innerHTML = "", this.div.appendChild(d), this.div.appendChild(g), this.div.title = s, this.div.style.display = "";
      }
      this.visible = !0;
    }, e.prototype.useStyle = function(t) {
      this.sums = t;
      var n = this.cluster.getClusterer().getStyles(), r = n[Math.min(n.length - 1, Math.max(0, t.index - 1))];
      r && (this.url = r.url, this.height = r.height, this.width = r.width, r.className && (this.className = "".concat(this.clusterClassName, " ").concat(r.className)), this.anchorText = r.anchorText || [0, 0], this.anchorIcon = r.anchorIcon || [this.height / 2, this.width / 2], this.textColor = r.textColor || "black", this.textSize = r.textSize || 11, this.textDecoration = r.textDecoration || "none", this.fontWeight = r.fontWeight || "bold", this.fontStyle = r.fontStyle || "normal", this.fontFamily = r.fontFamily || "Arial,sans-serif", this.backgroundPosition = r.backgroundPosition || "0 0");
    }, e.prototype.setCenter = function(t) {
      this.center = t;
    }, e.prototype.getPosFromLatLng = function(t) {
      var n = this.getProjection().fromLatLngToDivPixel(t);
      return n !== null && (n.x -= this.anchorIcon[1], n.y -= this.anchorIcon[0]), n;
    }, e;
  }()
), rrt = (
  /** @class */
  function() {
    function e(t) {
      this.markerClusterer = t, this.map = this.markerClusterer.getMap(), this.gridSize = this.markerClusterer.getGridSize(), this.minClusterSize = this.markerClusterer.getMinimumClusterSize(), this.averageCenter = this.markerClusterer.getAverageCenter(), this.markers = [], this.center = void 0, this.bounds = null, this.clusterIcon = new nrt(this, this.markerClusterer.getStyles()), this.getSize = this.getSize.bind(this), this.getMarkers = this.getMarkers.bind(this), this.getCenter = this.getCenter.bind(this), this.getMap = this.getMap.bind(this), this.getClusterer = this.getClusterer.bind(this), this.getBounds = this.getBounds.bind(this), this.remove = this.remove.bind(this), this.addMarker = this.addMarker.bind(this), this.isMarkerInClusterBounds = this.isMarkerInClusterBounds.bind(this), this.calculateBounds = this.calculateBounds.bind(this), this.updateIcon = this.updateIcon.bind(this), this.isMarkerAlreadyAdded = this.isMarkerAlreadyAdded.bind(this);
    }
    return e.prototype.getSize = function() {
      return this.markers.length;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getCenter = function() {
      return this.center;
    }, e.prototype.getMap = function() {
      return this.map;
    }, e.prototype.getClusterer = function() {
      return this.markerClusterer;
    }, e.prototype.getBounds = function() {
      for (var t = new google.maps.LatLngBounds(this.center, this.center), n = this.getMarkers(), r = 0, o = n; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && t.extend(a);
      }
      return t;
    }, e.prototype.remove = function() {
      this.clusterIcon.setMap(null), this.markers = [], delete this.markers;
    }, e.prototype.addMarker = function(t) {
      var n;
      if (this.isMarkerAlreadyAdded(t))
        return !1;
      if (this.center) {
        if (this.averageCenter) {
          var r = t.getPosition();
          if (r) {
            var o = this.markers.length + 1;
            this.center = new google.maps.LatLng((this.center.lat() * (o - 1) + r.lat()) / o, (this.center.lng() * (o - 1) + r.lng()) / o), this.calculateBounds();
          }
        }
      } else {
        var r = t.getPosition();
        r && (this.center = r, this.calculateBounds());
      }
      t.isAdded = !0, this.markers.push(t);
      var i = this.markers.length, a = this.markerClusterer.getMaxZoom(), s = (n = this.map) === null || n === void 0 ? void 0 : n.getZoom();
      if (a !== null && typeof s < "u" && s > a)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i < this.minClusterSize)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i === this.minClusterSize)
        for (var l = 0, u = this.markers; l < u.length; l++) {
          var c = u[l];
          c.setMap(null);
        }
      else
        t.setMap(null);
      return !0;
    }, e.prototype.isMarkerInClusterBounds = function(t) {
      if (this.bounds !== null) {
        var n = t.getPosition();
        if (n)
          return this.bounds.contains(n);
      }
      return !1;
    }, e.prototype.calculateBounds = function() {
      this.bounds = this.markerClusterer.getExtendedBounds(new google.maps.LatLngBounds(this.center, this.center));
    }, e.prototype.updateIcon = function() {
      var t, n = this.markers.length, r = this.markerClusterer.getMaxZoom(), o = (t = this.map) === null || t === void 0 ? void 0 : t.getZoom();
      if (r !== null && typeof o < "u" && o > r) {
        this.clusterIcon.hide();
        return;
      }
      if (n < this.minClusterSize) {
        this.clusterIcon.hide();
        return;
      }
      this.center && this.clusterIcon.setCenter(this.center), this.clusterIcon.useStyle(this.markerClusterer.getCalculator()(this.markers, this.markerClusterer.getStyles().length)), this.clusterIcon.show();
    }, e.prototype.isMarkerAlreadyAdded = function(t) {
      if (this.markers.includes)
        return this.markers.includes(t);
      for (var n = 0; n < this.markers.length; n++)
        if (t === this.markers[n])
          return !0;
      return !1;
    }, e;
  }()
);
function ort(e, t) {
  var n = e.length, r = n.toString().length, o = Math.min(r, t);
  return {
    text: n.toString(),
    index: o,
    title: ""
  };
}
var irt = 2e3, srt = 500, art = "https://developers.google.com/maps/documentation/javascript/examples/markerclusterer/m", lrt = "png", urt = [53, 56, 66, 78, 90], crt = "cluster", Sse = (
  /** @class */
  function() {
    function e(t, n, r) {
      n === void 0 && (n = []), r === void 0 && (r = {}), this.getMinimumClusterSize = this.getMinimumClusterSize.bind(this), this.setMinimumClusterSize = this.setMinimumClusterSize.bind(this), this.getEnableRetinaIcons = this.getEnableRetinaIcons.bind(this), this.setEnableRetinaIcons = this.setEnableRetinaIcons.bind(this), this.addToClosestCluster = this.addToClosestCluster.bind(this), this.getImageExtension = this.getImageExtension.bind(this), this.setImageExtension = this.setImageExtension.bind(this), this.getExtendedBounds = this.getExtendedBounds.bind(this), this.getAverageCenter = this.getAverageCenter.bind(this), this.setAverageCenter = this.setAverageCenter.bind(this), this.getTotalClusters = this.getTotalClusters.bind(this), this.fitMapToMarkers = this.fitMapToMarkers.bind(this), this.getIgnoreHidden = this.getIgnoreHidden.bind(this), this.setIgnoreHidden = this.setIgnoreHidden.bind(this), this.getClusterClass = this.getClusterClass.bind(this), this.setClusterClass = this.setClusterClass.bind(this), this.getTotalMarkers = this.getTotalMarkers.bind(this), this.getZoomOnClick = this.getZoomOnClick.bind(this), this.setZoomOnClick = this.setZoomOnClick.bind(this), this.getBatchSizeIE = this.getBatchSizeIE.bind(this), this.setBatchSizeIE = this.setBatchSizeIE.bind(this), this.createClusters = this.createClusters.bind(this), this.onZoomChanged = this.onZoomChanged.bind(this), this.getImageSizes = this.getImageSizes.bind(this), this.setImageSizes = this.setImageSizes.bind(this), this.getCalculator = this.getCalculator.bind(this), this.setCalculator = this.setCalculator.bind(this), this.removeMarkers = this.removeMarkers.bind(this), this.resetViewport = this.resetViewport.bind(this), this.getImagePath = this.getImagePath.bind(this), this.setImagePath = this.setImagePath.bind(this), this.pushMarkerTo = this.pushMarkerTo.bind(this), this.removeMarker = this.removeMarker.bind(this), this.clearMarkers = this.clearMarkers.bind(this), this.setupStyles = this.setupStyles.bind(this), this.getGridSize = this.getGridSize.bind(this), this.setGridSize = this.setGridSize.bind(this), this.getClusters = this.getClusters.bind(this), this.getMaxZoom = this.getMaxZoom.bind(this), this.setMaxZoom = this.setMaxZoom.bind(this), this.getMarkers = this.getMarkers.bind(this), this.addMarkers = this.addMarkers.bind(this), this.getStyles = this.getStyles.bind(this), this.setStyles = this.setStyles.bind(this), this.addMarker = this.addMarker.bind(this), this.onRemove = this.onRemove.bind(this), this.getTitle = this.getTitle.bind(this), this.setTitle = this.setTitle.bind(this), this.repaint = this.repaint.bind(this), this.onIdle = this.onIdle.bind(this), this.redraw = this.redraw.bind(this), this.onAdd = this.onAdd.bind(this), this.draw = this.draw.bind(this), this.extend = this.extend.bind(this), this.extend(e, google.maps.OverlayView), this.markers = [], this.clusters = [], this.listeners = [], this.activeMap = null, this.ready = !1, this.gridSize = r.gridSize || 60, this.minClusterSize = r.minimumClusterSize || 2, this.maxZoom = r.maxZoom || null, this.styles = r.styles || [], this.title = r.title || "", this.zoomOnClick = !0, r.zoomOnClick !== void 0 && (this.zoomOnClick = r.zoomOnClick), this.averageCenter = !1, r.averageCenter !== void 0 && (this.averageCenter = r.averageCenter), this.ignoreHidden = !1, r.ignoreHidden !== void 0 && (this.ignoreHidden = r.ignoreHidden), this.enableRetinaIcons = !1, r.enableRetinaIcons !== void 0 && (this.enableRetinaIcons = r.enableRetinaIcons), this.imagePath = r.imagePath || art, this.imageExtension = r.imageExtension || lrt, this.imageSizes = r.imageSizes || urt, this.calculator = r.calculator || ort, this.batchSize = r.batchSize || irt, this.batchSizeIE = r.batchSizeIE || srt, this.clusterClass = r.clusterClass || crt, navigator.userAgent.toLowerCase().indexOf("msie") !== -1 && (this.batchSize = this.batchSizeIE), this.timerRefStatic = null, this.setupStyles(), this.addMarkers(n, !0), this.setMap(t);
    }
    return e.prototype.onZoomChanged = function() {
      var t, n;
      this.resetViewport(!1), (((t = this.getMap()) === null || t === void 0 ? void 0 : t.getZoom()) === (this.get("minZoom") || 0) || ((n = this.getMap()) === null || n === void 0 ? void 0 : n.getZoom()) === this.get("maxZoom")) && google.maps.event.trigger(this, "idle");
    }, e.prototype.onIdle = function() {
      this.redraw();
    }, e.prototype.onAdd = function() {
      var t = this.getMap();
      this.activeMap = t, this.ready = !0, this.repaint(), t !== null && (this.listeners = [google.maps.event.addListener(t, "zoom_changed", this.onZoomChanged), google.maps.event.addListener(t, "idle", this.onIdle)]);
    }, e.prototype.onRemove = function() {
      for (var t = 0, n = this.markers; t < n.length; t++) {
        var r = n[t];
        r.getMap() !== this.activeMap && r.setMap(this.activeMap);
      }
      for (var o = 0, i = this.clusters; o < i.length; o++) {
        var a = i[o];
        a.remove();
      }
      this.clusters = [];
      for (var s = 0, l = this.listeners; s < l.length; s++) {
        var u = l[s];
        google.maps.event.removeListener(u);
      }
      this.listeners = [], this.activeMap = null, this.ready = !1;
    }, e.prototype.draw = function() {
    }, e.prototype.getMap = function() {
      return null;
    }, e.prototype.getPanes = function() {
      return null;
    }, e.prototype.getProjection = function() {
      return {
        fromContainerPixelToLatLng: function() {
          return null;
        },
        fromDivPixelToLatLng: function() {
          return null;
        },
        fromLatLngToContainerPixel: function() {
          return null;
        },
        fromLatLngToDivPixel: function() {
          return null;
        },
        getVisibleRegion: function() {
          return null;
        },
        getWorldWidth: function() {
          return 0;
        }
      };
    }, e.prototype.setMap = function() {
    }, e.prototype.addListener = function() {
      return {
        remove: function() {
        }
      };
    }, e.prototype.bindTo = function() {
    }, e.prototype.get = function() {
    }, e.prototype.notify = function() {
    }, e.prototype.set = function() {
    }, e.prototype.setValues = function() {
    }, e.prototype.unbind = function() {
    }, e.prototype.unbindAll = function() {
    }, e.prototype.setupStyles = function() {
      if (!(this.styles.length > 0))
        for (var t = 0; t < this.imageSizes.length; t++)
          this.styles.push({
            url: "".concat(this.imagePath + (t + 1), ".").concat(this.imageExtension),
            height: this.imageSizes[t] || 0,
            width: this.imageSizes[t] || 0
          });
    }, e.prototype.fitMapToMarkers = function() {
      for (var t = this.getMarkers(), n = new google.maps.LatLngBounds(), r = 0, o = t; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && n.extend(a);
      }
      var s = this.getMap();
      s !== null && "fitBounds" in s && s.fitBounds(n);
    }, e.prototype.getGridSize = function() {
      return this.gridSize;
    }, e.prototype.setGridSize = function(t) {
      this.gridSize = t;
    }, e.prototype.getMinimumClusterSize = function() {
      return this.minClusterSize;
    }, e.prototype.setMinimumClusterSize = function(t) {
      this.minClusterSize = t;
    }, e.prototype.getMaxZoom = function() {
      return this.maxZoom;
    }, e.prototype.setMaxZoom = function(t) {
      this.maxZoom = t;
    }, e.prototype.getStyles = function() {
      return this.styles;
    }, e.prototype.setStyles = function(t) {
      this.styles = t;
    }, e.prototype.getTitle = function() {
      return this.title;
    }, e.prototype.setTitle = function(t) {
      this.title = t;
    }, e.prototype.getZoomOnClick = function() {
      return this.zoomOnClick;
    }, e.prototype.setZoomOnClick = function(t) {
      this.zoomOnClick = t;
    }, e.prototype.getAverageCenter = function() {
      return this.averageCenter;
    }, e.prototype.setAverageCenter = function(t) {
      this.averageCenter = t;
    }, e.prototype.getIgnoreHidden = function() {
      return this.ignoreHidden;
    }, e.prototype.setIgnoreHidden = function(t) {
      this.ignoreHidden = t;
    }, e.prototype.getEnableRetinaIcons = function() {
      return this.enableRetinaIcons;
    }, e.prototype.setEnableRetinaIcons = function(t) {
      this.enableRetinaIcons = t;
    }, e.prototype.getImageExtension = function() {
      return this.imageExtension;
    }, e.prototype.setImageExtension = function(t) {
      this.imageExtension = t;
    }, e.prototype.getImagePath = function() {
      return this.imagePath;
    }, e.prototype.setImagePath = function(t) {
      this.imagePath = t;
    }, e.prototype.getImageSizes = function() {
      return this.imageSizes;
    }, e.prototype.setImageSizes = function(t) {
      this.imageSizes = t;
    }, e.prototype.getCalculator = function() {
      return this.calculator;
    }, e.prototype.setCalculator = function(t) {
      this.calculator = t;
    }, e.prototype.getBatchSizeIE = function() {
      return this.batchSizeIE;
    }, e.prototype.setBatchSizeIE = function(t) {
      this.batchSizeIE = t;
    }, e.prototype.getClusterClass = function() {
      return this.clusterClass;
    }, e.prototype.setClusterClass = function(t) {
      this.clusterClass = t;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getTotalMarkers = function() {
      return this.markers.length;
    }, e.prototype.getClusters = function() {
      return this.clusters;
    }, e.prototype.getTotalClusters = function() {
      return this.clusters.length;
    }, e.prototype.addMarker = function(t, n) {
      this.pushMarkerTo(t), n || this.redraw();
    }, e.prototype.addMarkers = function(t, n) {
      for (var r in t)
        if (Object.prototype.hasOwnProperty.call(t, r)) {
          var o = t[r];
          o && this.pushMarkerTo(o);
        }
      n || this.redraw();
    }, e.prototype.pushMarkerTo = function(t) {
      var n = this;
      t.getDraggable() && google.maps.event.addListener(t, "dragend", function() {
        n.ready && (t.isAdded = !1, n.repaint());
      }), t.isAdded = !1, this.markers.push(t);
    }, e.prototype.removeMarker_ = function(t) {
      var n = -1;
      if (this.markers.indexOf)
        n = this.markers.indexOf(t);
      else
        for (var r = 0; r < this.markers.length; r++)
          if (t === this.markers[r]) {
            n = r;
            break;
          }
      return n === -1 ? !1 : (t.setMap(null), this.markers.splice(n, 1), !0);
    }, e.prototype.removeMarker = function(t, n) {
      var r = this.removeMarker_(t);
      return !n && r && this.repaint(), r;
    }, e.prototype.removeMarkers = function(t, n) {
      for (var r = !1, o = 0, i = t; o < i.length; o++) {
        var a = i[o];
        r = r || this.removeMarker_(a);
      }
      return !n && r && this.repaint(), r;
    }, e.prototype.clearMarkers = function() {
      this.resetViewport(!0), this.markers = [];
    }, e.prototype.repaint = function() {
      var t = this.clusters.slice();
      this.clusters = [], this.resetViewport(!1), this.redraw(), setTimeout(function() {
        for (var r = 0, o = t; r < o.length; r++) {
          var i = o[r];
          i.remove();
        }
      }, 0);
    }, e.prototype.getExtendedBounds = function(t) {
      var n = this.getProjection(), r = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getNorthEast().lat(), t.getNorthEast().lng())
      );
      r !== null && (r.x += this.gridSize, r.y -= this.gridSize);
      var o = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getSouthWest().lat(), t.getSouthWest().lng())
      );
      if (o !== null && (o.x -= this.gridSize, o.y += this.gridSize), r !== null) {
        var i = n.fromDivPixelToLatLng(r);
        i !== null && t.extend(i);
      }
      if (o !== null) {
        var a = n.fromDivPixelToLatLng(o);
        a !== null && t.extend(a);
      }
      return t;
    }, e.prototype.redraw = function() {
      this.createClusters(0);
    }, e.prototype.resetViewport = function(t) {
      for (var n = 0, r = this.clusters; n < r.length; n++) {
        var o = r[n];
        o.remove();
      }
      this.clusters = [];
      for (var i = 0, a = this.markers; i < a.length; i++) {
        var s = a[i];
        s.isAdded = !1, t && s.setMap(null);
      }
    }, e.prototype.distanceBetweenPoints = function(t, n) {
      var r = 6371, o = (n.lat() - t.lat()) * Math.PI / 180, i = (n.lng() - t.lng()) * Math.PI / 180, a = Math.sin(o / 2) * Math.sin(o / 2) + Math.cos(t.lat() * Math.PI / 180) * Math.cos(n.lat() * Math.PI / 180) * Math.sin(i / 2) * Math.sin(i / 2);
      return r * (2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)));
    }, e.prototype.isMarkerInBounds = function(t, n) {
      var r = t.getPosition();
      return r ? n.contains(r) : !1;
    }, e.prototype.addToClosestCluster = function(t) {
      for (var n, r = 4e4, o = null, i = 0, a = this.clusters; i < a.length; i++) {
        var s = a[i];
        n = s;
        var l = n.getCenter(), u = t.getPosition();
        if (l && u) {
          var c = this.distanceBetweenPoints(l, u);
          c < r && (r = c, o = n);
        }
      }
      o && o.isMarkerInClusterBounds(t) ? o.addMarker(t) : (n = new rrt(this), n.addMarker(t), this.clusters.push(n));
    }, e.prototype.createClusters = function(t) {
      var n = this;
      if (this.ready) {
        t === 0 && (google.maps.event.trigger(this, "clusteringbegin", this), this.timerRefStatic !== null && (window.clearTimeout(this.timerRefStatic), delete this.timerRefStatic));
        for (var r = this.getMap(), o = r !== null && ("getBounds" in r) ? r.getBounds() : null, i = (r == null ? void 0 : r.getZoom()) || 0, a = i > 3 ? new google.maps.LatLngBounds(o == null ? void 0 : o.getSouthWest(), o == null ? void 0 : o.getNorthEast()) : new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625)), s = this.getExtendedBounds(a), l = Math.min(t + this.batchSize, this.markers.length), u = t; u < l; u++) {
          var c = this.markers[u];
          c && !c.isAdded && this.isMarkerInBounds(c, s) && (!this.ignoreHidden || this.ignoreHidden && c.getVisible()) && this.addToClosestCluster(c);
        }
        if (l < this.markers.length)
          this.timerRefStatic = window.setTimeout(function() {
            n.createClusters(l);
          }, 0);
        else {
          this.timerRefStatic = null, google.maps.event.trigger(this, "clusteringend", this);
          for (var p = 0, d = this.clusters; p < d.length; p++) {
            var g = d[p];
            g.updateIcon();
          }
        }
      }
    }, e.prototype.extend = function(t, n) {
      return (function(o) {
        for (var i in o.prototype) {
          var a = i;
          this.prototype[a] = o.prototype[a];
        }
        return this;
      }).apply(t, [n]);
    }, e;
  }()
);
function vq(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function prt(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? vq(Object(n), !0).forEach(function(r) {
      Ce(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : vq(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Us = {
  onClick: "click",
  onClusteringBegin: "clusteringbegin",
  onClusteringEnd: "clusteringend",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover"
}, Bn = {
  averageCenter(e, t) {
    e.setAverageCenter(t);
  },
  batchSizeIE(e, t) {
    e.setBatchSizeIE(t);
  },
  calculator(e, t) {
    e.setCalculator(t);
  },
  clusterClass(e, t) {
    e.setClusterClass(t);
  },
  enableRetinaIcons(e, t) {
    e.setEnableRetinaIcons(t);
  },
  gridSize(e, t) {
    e.setGridSize(t);
  },
  ignoreHidden(e, t) {
    e.setIgnoreHidden(t);
  },
  imageExtension(e, t) {
    e.setImageExtension(t);
  },
  imagePath(e, t) {
    e.setImagePath(t);
  },
  imageSizes(e, t) {
    e.setImageSizes(t);
  },
  maxZoom(e, t) {
    e.setMaxZoom(t);
  },
  minimumClusterSize(e, t) {
    e.setMinimumClusterSize(t);
  },
  styles(e, t) {
    e.setStyles(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  zoomOnClick(e, t) {
    e.setZoomOnClick(t);
  }
}, drt = {};
function frt(e) {
  var {
    children: t,
    options: n,
    averageCenter: r,
    batchSizeIE: o,
    calculator: i,
    clusterClass: a,
    enableRetinaIcons: s,
    gridSize: l,
    ignoreHidden: u,
    imageExtension: c,
    imagePath: p,
    imageSizes: d,
    maxZoom: g,
    minimumClusterSize: f,
    styles: m,
    title: b,
    zoomOnClick: E,
    onClick: w,
    onClusteringBegin: M,
    onClusteringEnd: x,
    onMouseOver: v,
    onMouseOut: C,
    onLoad: P,
    onUnmount: F
  } = e, [L, B] = k(null), N = ge(At), [$, V] = k(null), [H, Z] = k(null), [K, Y] = k(null), [Q, J] = k(null), [_, D] = k(null);
  return h(() => {
    L && C && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(L, Us.onMouseOut, C)));
  }, [C]), h(() => {
    L && v && (_ !== null && google.maps.event.removeListener(_), D(google.maps.event.addListener(L, Us.onMouseOver, v)));
  }, [v]), h(() => {
    L && w && ($ !== null && google.maps.event.removeListener($), V(google.maps.event.addListener(L, Us.onClick, w)));
  }, [w]), h(() => {
    L && M && (H !== null && google.maps.event.removeListener(H), Z(google.maps.event.addListener(L, Us.onClusteringBegin, M)));
  }, [M]), h(() => {
    L && x && (K !== null && google.maps.event.removeListener(K), Z(google.maps.event.addListener(L, Us.onClusteringEnd, x)));
  }, [x]), h(() => {
    typeof r < "u" && L !== null && Bn.averageCenter(L, r);
  }, [L, r]), h(() => {
    typeof o < "u" && L !== null && Bn.batchSizeIE(L, o);
  }, [L, o]), h(() => {
    typeof i < "u" && L !== null && Bn.calculator(L, i);
  }, [L, i]), h(() => {
    typeof a < "u" && L !== null && Bn.clusterClass(L, a);
  }, [L, a]), h(() => {
    typeof s < "u" && L !== null && Bn.enableRetinaIcons(L, s);
  }, [L, s]), h(() => {
    typeof l < "u" && L !== null && Bn.gridSize(L, l);
  }, [L, l]), h(() => {
    typeof u < "u" && L !== null && Bn.ignoreHidden(L, u);
  }, [L, u]), h(() => {
    typeof c < "u" && L !== null && Bn.imageExtension(L, c);
  }, [L, c]), h(() => {
    typeof p < "u" && L !== null && Bn.imagePath(L, p);
  }, [L, p]), h(() => {
    typeof d < "u" && L !== null && Bn.imageSizes(L, d);
  }, [L, d]), h(() => {
    typeof g < "u" && L !== null && Bn.maxZoom(L, g);
  }, [L, g]), h(() => {
    typeof f < "u" && L !== null && Bn.minimumClusterSize(L, f);
  }, [L, f]), h(() => {
    typeof m < "u" && L !== null && Bn.styles(L, m);
  }, [L, m]), h(() => {
    typeof b < "u" && L !== null && Bn.title(L, b);
  }, [L, b]), h(() => {
    typeof E < "u" && L !== null && Bn.zoomOnClick(L, E);
  }, [L, E]), h(() => {
    if (N) {
      var z = prt({}, n || drt), S = new Sse(N, [], z);
      return r && Bn.averageCenter(S, r), o && Bn.batchSizeIE(S, o), i && Bn.calculator(S, i), a && Bn.clusterClass(S, a), s && Bn.enableRetinaIcons(S, s), l && Bn.gridSize(S, l), u && Bn.ignoreHidden(S, u), c && Bn.imageExtension(S, c), p && Bn.imagePath(S, p), d && Bn.imageSizes(S, d), g && Bn.maxZoom(S, g), f && Bn.minimumClusterSize(S, f), m && Bn.styles(S, m), b && Bn.title(S, b), E && Bn.zoomOnClick(S, E), C && J(google.maps.event.addListener(S, Us.onMouseOut, C)), v && D(google.maps.event.addListener(S, Us.onMouseOver, v)), w && V(google.maps.event.addListener(S, Us.onClick, w)), M && Z(google.maps.event.addListener(S, Us.onClusteringBegin, M)), x && Y(google.maps.event.addListener(S, Us.onClusteringEnd, x)), B(S), P && P(S), () => {
        Q !== null && google.maps.event.removeListener(Q), _ !== null && google.maps.event.removeListener(_), $ !== null && google.maps.event.removeListener($), H !== null && google.maps.event.removeListener(H), K !== null && google.maps.event.removeListener(K), F && F(S);
      };
    }
  }, []), L !== null && t(L) || null;
}
me(frt);
class hrt extends pe {
  constructor() {
    super(...arguments), Ce(this, "registeredEvents", []), Ce(this, "state", {
      markerClusterer: null
    }), Ce(this, "setClustererCallback", () => {
      this.state.markerClusterer !== null && this.props.onLoad && this.props.onLoad(this.state.markerClusterer);
    });
  }
  componentDidMount() {
    if (this.context) {
      var t = new Sse(this.context, [], this.props.options);
      this.registeredEvents = Jt({
        updaterMap: Bn,
        eventMap: Us,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        markerClusterer: t
      }), this.setClustererCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.markerClusterer && (un(this.registeredEvents), this.registeredEvents = Jt({
      updaterMap: Bn,
      eventMap: Us,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.markerClusterer
    }));
  }
  componentWillUnmount() {
    this.state.markerClusterer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.markerClusterer), un(this.registeredEvents), this.state.markerClusterer.setMap(null));
  }
  render() {
    return this.state.markerClusterer !== null ? this.props.children(this.state.markerClusterer) : null;
  }
}
Ce(hrt, "contextType", At);
function yq(e) {
  e.cancelBubble = !0, e.stopPropagation && e.stopPropagation();
}
var Mse = (
  /** @class */
  function() {
    function e(t) {
      t === void 0 && (t = {}), this.getCloseClickHandler = this.getCloseClickHandler.bind(this), this.closeClickHandler = this.closeClickHandler.bind(this), this.createInfoBoxDiv = this.createInfoBoxDiv.bind(this), this.addClickHandler = this.addClickHandler.bind(this), this.getCloseBoxImg = this.getCloseBoxImg.bind(this), this.getBoxWidths = this.getBoxWidths.bind(this), this.setBoxStyle = this.setBoxStyle.bind(this), this.setPosition = this.setPosition.bind(this), this.getPosition = this.getPosition.bind(this), this.setOptions = this.setOptions.bind(this), this.setContent = this.setContent.bind(this), this.setVisible = this.setVisible.bind(this), this.getContent = this.getContent.bind(this), this.getVisible = this.getVisible.bind(this), this.setZIndex = this.setZIndex.bind(this), this.getZIndex = this.getZIndex.bind(this), this.onRemove = this.onRemove.bind(this), this.panBox = this.panBox.bind(this), this.extend = this.extend.bind(this), this.close = this.close.bind(this), this.draw = this.draw.bind(this), this.show = this.show.bind(this), this.hide = this.hide.bind(this), this.open = this.open.bind(this), this.extend(e, google.maps.OverlayView), this.content = t.content || "", this.disableAutoPan = t.disableAutoPan || !1, this.maxWidth = t.maxWidth || 0, this.pixelOffset = t.pixelOffset || new google.maps.Size(0, 0), this.position = t.position || new google.maps.LatLng(0, 0), this.zIndex = t.zIndex || null, this.boxClass = t.boxClass || "infoBox", this.boxStyle = t.boxStyle || {}, this.closeBoxMargin = t.closeBoxMargin || "2px", this.closeBoxURL = t.closeBoxURL || "http://www.google.com/intl/en_us/mapfiles/close.gif", t.closeBoxURL === "" && (this.closeBoxURL = ""), this.infoBoxClearance = t.infoBoxClearance || new google.maps.Size(1, 1), typeof t.visible > "u" && (typeof t.isHidden > "u" ? t.visible = !0 : t.visible = !t.isHidden), this.isHidden = !t.visible, this.alignBottom = t.alignBottom || !1, this.pane = t.pane || "floatPane", this.enableEventPropagation = t.enableEventPropagation || !1, this.div = null, this.closeListener = null, this.moveListener = null, this.mapListener = null, this.contextListener = null, this.eventListeners = null, this.fixedWidthSet = null;
    }
    return e.prototype.createInfoBoxDiv = function() {
      var t = this, n = function(c) {
        c.returnValue = !1, c.preventDefault && c.preventDefault(), t.enableEventPropagation || yq(c);
      };
      if (!this.div) {
        this.div = document.createElement("div"), this.setBoxStyle(), typeof this.content == "string" ? this.div.innerHTML = this.getCloseBoxImg() + this.content : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(this.content));
        var r = this.getPanes();
        if (r !== null && r[this.pane].appendChild(this.div), this.addClickHandler(), this.div.style.width)
          this.fixedWidthSet = !0;
        else if (this.maxWidth !== 0 && this.div.offsetWidth > this.maxWidth)
          this.div.style.width = this.maxWidth + "px", this.fixedWidthSet = !0;
        else {
          var o = this.getBoxWidths();
          this.div.style.width = this.div.offsetWidth - o.left - o.right + "px", this.fixedWidthSet = !1;
        }
        if (this.panBox(this.disableAutoPan), !this.enableEventPropagation) {
          this.eventListeners = [];
          for (var i = ["mousedown", "mouseover", "mouseout", "mouseup", "click", "dblclick", "touchstart", "touchend", "touchmove"], a = 0, s = i; a < s.length; a++) {
            var l = s[a];
            this.eventListeners.push(google.maps.event.addListener(this.div, l, yq));
          }
          this.eventListeners.push(google.maps.event.addListener(this.div, "mouseover", function() {
            t.div && (t.div.style.cursor = "default");
          }));
        }
        this.contextListener = google.maps.event.addListener(this.div, "contextmenu", n), google.maps.event.trigger(this, "domready");
      }
    }, e.prototype.getCloseBoxImg = function() {
      var t = "";
      return this.closeBoxURL !== "" && (t = '<img alt=""', t += ' aria-hidden="true"', t += " src='" + this.closeBoxURL + "'", t += " align=right", t += " style='", t += " position: relative;", t += " cursor: pointer;", t += " margin: " + this.closeBoxMargin + ";", t += "'>"), t;
    }, e.prototype.addClickHandler = function() {
      this.closeListener = this.div && this.div.firstChild && this.closeBoxURL !== "" ? google.maps.event.addListener(this.div.firstChild, "click", this.getCloseClickHandler()) : null;
    }, e.prototype.closeClickHandler = function(t) {
      t.cancelBubble = !0, t.stopPropagation && t.stopPropagation(), google.maps.event.trigger(this, "closeclick"), this.close();
    }, e.prototype.getCloseClickHandler = function() {
      return this.closeClickHandler;
    }, e.prototype.panBox = function(t) {
      if (this.div && !t) {
        var n = this.getMap();
        if (n instanceof google.maps.Map) {
          var r = 0, o = 0, i = n.getBounds();
          i && !i.contains(this.position) && n.setCenter(this.position);
          var a = n.getDiv(), s = a.offsetWidth, l = a.offsetHeight, u = this.pixelOffset.width, c = this.pixelOffset.height, p = this.div.offsetWidth, d = this.div.offsetHeight, g = this.infoBoxClearance.width, f = this.infoBoxClearance.height, m = this.getProjection(), b = m.fromLatLngToContainerPixel(this.position);
          b !== null && (b.x < -u + g ? r = b.x + u - g : b.x + p + u + g > s && (r = b.x + p + u + g - s), this.alignBottom ? b.y < -c + f + d ? o = b.y + c - f - d : b.y + c + f > l && (o = b.y + c + f - l) : b.y < -c + f ? o = b.y + c - f : b.y + d + c + f > l && (o = b.y + d + c + f - l)), r === 0 && o === 0 || n.panBy(r, o);
        }
      }
    }, e.prototype.setBoxStyle = function() {
      if (this.div) {
        this.div.className = this.boxClass, this.div.style.cssText = "";
        var t = this.boxStyle;
        for (var n in t)
          Object.prototype.hasOwnProperty.call(t, n) && (this.div.style[n] = t[n]);
        if (this.div.style.webkitTransform = "translateZ(0)", typeof this.div.style.opacity < "u" && this.div.style.opacity !== "") {
          var r = parseFloat(this.div.style.opacity || "");
          this.div.style.msFilter = '"progid:DXImageTransform.Microsoft.Alpha(Opacity=' + r * 100 + ')"', this.div.style.filter = "alpha(opacity=" + r * 100 + ")";
        }
        this.div.style.position = "absolute", this.div.style.visibility = "hidden", this.zIndex !== null && (this.div.style.zIndex = this.zIndex + ""), this.div.style.overflow || (this.div.style.overflow = "auto");
      }
    }, e.prototype.getBoxWidths = function() {
      var t = {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0
      };
      if (!this.div)
        return t;
      if (document.defaultView) {
        var n = this.div.ownerDocument, r = n && n.defaultView ? n.defaultView.getComputedStyle(this.div, "") : null;
        r && (t.top = parseInt(r.borderTopWidth || "", 10) || 0, t.bottom = parseInt(r.borderBottomWidth || "", 10) || 0, t.left = parseInt(r.borderLeftWidth || "", 10) || 0, t.right = parseInt(r.borderRightWidth || "", 10) || 0);
      } else if (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        document.documentElement.currentStyle
      ) {
        var o = this.div.currentStyle;
        o && (t.top = parseInt(o.borderTopWidth || "", 10) || 0, t.bottom = parseInt(o.borderBottomWidth || "", 10) || 0, t.left = parseInt(o.borderLeftWidth || "", 10) || 0, t.right = parseInt(o.borderRightWidth || "", 10) || 0);
      }
      return t;
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.div.parentNode.removeChild(this.div), this.div = null);
    }, e.prototype.draw = function() {
      if (this.createInfoBoxDiv(), this.div) {
        var t = this.getProjection(), n = t.fromLatLngToDivPixel(this.position);
        n !== null && (this.div.style.left = n.x + this.pixelOffset.width + "px", this.alignBottom ? this.div.style.bottom = -(n.y + this.pixelOffset.height) + "px" : this.div.style.top = n.y + this.pixelOffset.height + "px"), this.isHidden ? this.div.style.visibility = "hidden" : this.div.style.visibility = "visible";
      }
    }, e.prototype.setOptions = function(t) {
      t === void 0 && (t = {}), typeof t.boxClass < "u" && (this.boxClass = t.boxClass, this.setBoxStyle()), typeof t.boxStyle < "u" && (this.boxStyle = t.boxStyle, this.setBoxStyle()), typeof t.content < "u" && this.setContent(t.content), typeof t.disableAutoPan < "u" && (this.disableAutoPan = t.disableAutoPan), typeof t.maxWidth < "u" && (this.maxWidth = t.maxWidth), typeof t.pixelOffset < "u" && (this.pixelOffset = t.pixelOffset), typeof t.alignBottom < "u" && (this.alignBottom = t.alignBottom), typeof t.position < "u" && this.setPosition(t.position), typeof t.zIndex < "u" && this.setZIndex(t.zIndex), typeof t.closeBoxMargin < "u" && (this.closeBoxMargin = t.closeBoxMargin), typeof t.closeBoxURL < "u" && (this.closeBoxURL = t.closeBoxURL), typeof t.infoBoxClearance < "u" && (this.infoBoxClearance = t.infoBoxClearance), typeof t.isHidden < "u" && (this.isHidden = t.isHidden), typeof t.visible < "u" && (this.isHidden = !t.visible), typeof t.enableEventPropagation < "u" && (this.enableEventPropagation = t.enableEventPropagation), this.div && this.draw();
    }, e.prototype.setContent = function(t) {
      this.content = t, this.div && (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.fixedWidthSet || (this.div.style.width = ""), typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t)), this.fixedWidthSet || (this.div.style.width = this.div.offsetWidth + "px", typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t))), this.addClickHandler()), google.maps.event.trigger(this, "content_changed");
    }, e.prototype.setPosition = function(t) {
      this.position = t, this.div && this.draw(), google.maps.event.trigger(this, "position_changed");
    }, e.prototype.setVisible = function(t) {
      this.isHidden = !t, this.div && (this.div.style.visibility = this.isHidden ? "hidden" : "visible");
    }, e.prototype.setZIndex = function(t) {
      this.zIndex = t, this.div && (this.div.style.zIndex = t + ""), google.maps.event.trigger(this, "zindex_changed");
    }, e.prototype.getContent = function() {
      return this.content;
    }, e.prototype.getPosition = function() {
      return this.position;
    }, e.prototype.getZIndex = function() {
      return this.zIndex;
    }, e.prototype.getVisible = function() {
      var t = this.getMap();
      return typeof t > "u" || t === null ? !1 : !this.isHidden;
    }, e.prototype.show = function() {
      this.isHidden = !1, this.div && (this.div.style.visibility = "visible");
    }, e.prototype.hide = function() {
      this.isHidden = !0, this.div && (this.div.style.visibility = "hidden");
    }, e.prototype.open = function(t, n) {
      var r = this;
      n && (this.position = n.getPosition(), this.moveListener = google.maps.event.addListener(n, "position_changed", function() {
        var o = n.getPosition();
        r.setPosition(o);
      }), this.mapListener = google.maps.event.addListener(n, "map_changed", function() {
        r.setMap(n.map);
      })), this.setMap(t), this.div && this.panBox();
    }, e.prototype.close = function() {
      if (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.eventListeners) {
        for (var t = 0, n = this.eventListeners; t < n.length; t++) {
          var r = n[t];
          google.maps.event.removeListener(r);
        }
        this.eventListeners = null;
      }
      this.moveListener && (google.maps.event.removeListener(this.moveListener), this.moveListener = null), this.mapListener && (google.maps.event.removeListener(this.mapListener), this.mapListener = null), this.contextListener && (google.maps.event.removeListener(this.contextListener), this.contextListener = null), this.setMap(null);
    }, e.prototype.extend = function(t, n) {
      return (function(o) {
        for (var i in o.prototype)
          Object.prototype.hasOwnProperty.call(this, i) || (this.prototype[i] = o.prototype[i]);
        return this;
      }).apply(t, [n]);
    }, e;
  }()
), grt = ["position"], mrt = ["position"];
function bq(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function t0(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? bq(Object(n), !0).forEach(function(r) {
      Ce(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : bq(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var wq = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, Cq = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    t instanceof google.maps.LatLng ? e.setPosition(t) : e.setPosition(new google.maps.LatLng(t.lat, t.lng));
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, vrt = {};
function yrt(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, g = ge(At), [f, m] = k(null), [b, E] = k(null), [w, M] = k(null), [x, v] = k(null), [C, P] = k(null), [F, L] = k(null), B = dt(null);
  return h(() => {
    g && f !== null && (f.close(), n ? f.open(g, n) : f.getPosition() && f.open(g));
  }, [g, f, n]), h(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), h(() => {
    if (o && f !== null) {
      var N = o instanceof google.maps.LatLng ? o : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        new google.maps.LatLng(o.lat, o.lng)
      );
      f.setPosition(N);
    }
  }, [o]), h(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), h(() => {
    f && a && (b !== null && google.maps.event.removeListener(b), E(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), h(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), M(google.maps.event.addListener(f, "domready", s)));
  }, [s]), h(() => {
    f && l && (x !== null && google.maps.event.removeListener(x), v(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), h(() => {
    f && u && (C !== null && google.maps.event.removeListener(C), P(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), h(() => {
    f && c && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), h(() => {
    if (g) {
      var N = r || vrt, {
        position: $
      } = N, V = Nj(N, grt), H;
      $ && !($ instanceof google.maps.LatLng) && (H = new google.maps.LatLng($.lat, $.lng));
      var Z = new Mse(t0(t0({}, V), H ? {
        position: H
      } : {}));
      B.current = document.createElement("div"), m(Z), a && E(google.maps.event.addListener(Z, "closeclick", a)), s && M(google.maps.event.addListener(Z, "domready", s)), l && v(google.maps.event.addListener(Z, "content_changed", l)), u && P(google.maps.event.addListener(Z, "position_changed", u)), c && L(google.maps.event.addListener(Z, "zindex_changed", c)), Z.setContent(B.current), n ? Z.open(g, n) : Z.getPosition() ? Z.open(g) : Go(!1, "You must provide either an anchor or a position prop for <InfoBox>."), p && p(Z);
    }
    return () => {
      f !== null && (b && google.maps.event.removeListener(b), x && google.maps.event.removeListener(x), w && google.maps.event.removeListener(w), C && google.maps.event.removeListener(C), F && google.maps.event.removeListener(F), d && d(f), f.close());
    };
  }, []), B.current ? zn(at.only(t), B.current) : null;
}
me(yrt);
class brt extends pe {
  constructor() {
    super(...arguments), Ce(this, "registeredEvents", []), Ce(this, "containerElement", null), Ce(this, "state", {
      infoBox: null
    }), Ce(this, "open", (t, n) => {
      n ? this.context !== null && t.open(this.context, n) : t.getPosition() ? this.context !== null && t.open(this.context) : Go(!1, "You must provide either an anchor or a position prop for <InfoBox>.");
    }), Ce(this, "setInfoBoxCallback", () => {
      this.state.infoBox !== null && this.containerElement !== null && (this.state.infoBox.setContent(this.containerElement), this.open(this.state.infoBox, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoBox));
    });
  }
  componentDidMount() {
    var t = this.props.options || {}, {
      position: n
    } = t, r = Nj(t, mrt), o;
    n && !(n instanceof google.maps.LatLng) && (o = new google.maps.LatLng(n.lat, n.lng));
    var i = new Mse(t0(t0({}, r), o ? {
      position: o
    } : {}));
    this.containerElement = document.createElement("div"), this.registeredEvents = Jt({
      updaterMap: Cq,
      eventMap: wq,
      prevProps: {},
      nextProps: this.props,
      instance: i
    }), this.setState({
      infoBox: i
    }, this.setInfoBoxCallback);
  }
  componentDidUpdate(t) {
    var {
      infoBox: n
    } = this.state;
    n !== null && (un(this.registeredEvents), this.registeredEvents = Jt({
      updaterMap: Cq,
      eventMap: wq,
      prevProps: t,
      nextProps: this.props,
      instance: n
    }));
  }
  componentWillUnmount() {
    var {
      onUnmount: t
    } = this.props, {
      infoBox: n
    } = this.state;
    n !== null && (t && t(n), un(this.registeredEvents), n.close());
  }
  render() {
    return this.containerElement ? zn(at.only(this.props.children), this.containerElement) : null;
  }
}
Ce(brt, "contextType", At);
var KL, Oq;
function wrt() {
  return Oq || (Oq = 1, KL = function e(t, n) {
    if (t === n) return !0;
    if (t && n && typeof t == "object" && typeof n == "object") {
      if (t.constructor !== n.constructor) return !1;
      var r, o, i;
      if (Array.isArray(t)) {
        if (r = t.length, r != n.length) return !1;
        for (o = r; o-- !== 0; ) if (!e(t[o], n[o])) return !1;
        return !0;
      }
      if (t.constructor === RegExp) return t.source === n.source && t.flags === n.flags;
      if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === n.valueOf();
      if (t.toString !== Object.prototype.toString) return t.toString() === n.toString();
      if (i = Object.keys(t), r = i.length, r !== Object.keys(n).length) return !1;
      for (o = r; o-- !== 0; ) if (!Object.prototype.hasOwnProperty.call(n, i[o])) return !1;
      for (o = r; o-- !== 0; ) {
        var a = i[o];
        if (!e(t[a], n[a])) return !1;
      }
      return !0;
    }
    return t !== t && n !== n;
  }), KL;
}
var Crt = wrt(), xq = /* @__PURE__ */ Cse(Crt), Eq = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array], XL = 1, Ud = 8;
class Bj {
  /**
   * Creates an index from raw `ArrayBuffer` data.
   * @param {ArrayBuffer} data
   */
  static from(t) {
    if (!(t instanceof ArrayBuffer))
      throw new Error("Data must be an instance of ArrayBuffer.");
    var [n, r] = new Uint8Array(t, 0, 2);
    if (n !== 219)
      throw new Error("Data does not appear to be in a KDBush format.");
    var o = r >> 4;
    if (o !== XL)
      throw new Error("Got v".concat(o, " data when expected v").concat(XL, "."));
    var i = Eq[r & 15];
    if (!i)
      throw new Error("Unrecognized array type.");
    var [a] = new Uint16Array(t, 2, 1), [s] = new Uint32Array(t, 4, 1);
    return new Bj(s, a, i, t);
  }
  /**
   * Creates an index that will hold a given number of items.
   * @param {number} numItems
   * @param {number} [nodeSize=64] Size of the KD-tree node (64 by default).
   * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).
   * @param {ArrayBuffer} [data] (For internal use only)
   */
  constructor(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 64, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Float64Array, o = arguments.length > 3 ? arguments[3] : void 0;
    if (isNaN(t) || t < 0) throw new Error("Unpexpected numItems value: ".concat(t, "."));
    this.numItems = +t, this.nodeSize = Math.min(Math.max(+n, 2), 65535), this.ArrayType = r, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
    var i = Eq.indexOf(this.ArrayType), a = t * 2 * this.ArrayType.BYTES_PER_ELEMENT, s = t * this.IndexArrayType.BYTES_PER_ELEMENT, l = (8 - s % 8) % 8;
    if (i < 0)
      throw new Error("Unexpected typed array class: ".concat(r, "."));
    o && o instanceof ArrayBuffer ? (this.data = o, this.ids = new this.IndexArrayType(this.data, Ud, t), this.coords = new this.ArrayType(this.data, Ud + s + l, t * 2), this._pos = t * 2, this._finished = !0) : (this.data = new ArrayBuffer(Ud + a + s + l), this.ids = new this.IndexArrayType(this.data, Ud, t), this.coords = new this.ArrayType(this.data, Ud + s + l, t * 2), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, (XL << 4) + i]), new Uint16Array(this.data, 2, 1)[0] = n, new Uint32Array(this.data, 4, 1)[0] = t);
  }
  /**
   * Add a point to the index.
   * @param {number} x
   * @param {number} y
   * @returns {number} An incremental index associated with the added item (starting from `0`).
   */
  add(t, n) {
    var r = this._pos >> 1;
    return this.ids[r] = r, this.coords[this._pos++] = t, this.coords[this._pos++] = n, r;
  }
  /**
   * Perform indexing of the added points.
   */
  finish() {
    var t = this._pos >> 1;
    if (t !== this.numItems)
      throw new Error("Added ".concat(t, " items when expected ").concat(this.numItems, "."));
    return WP(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
  }
  /**
   * Search the index for items within a given bounding box.
   * @param {number} minX
   * @param {number} minY
   * @param {number} maxX
   * @param {number} maxY
   * @returns {number[]} An array of indices correponding to the found items.
   */
  range(t, n, r, o) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: i,
      coords: a,
      nodeSize: s
    } = this, l = [0, i.length - 1, 0], u = []; l.length; ) {
      var c = l.pop() || 0, p = l.pop() || 0, d = l.pop() || 0;
      if (p - d <= s) {
        for (var g = d; g <= p; g++) {
          var f = a[2 * g], m = a[2 * g + 1];
          f >= t && f <= r && m >= n && m <= o && u.push(i[g]);
        }
        continue;
      }
      var b = d + p >> 1, E = a[2 * b], w = a[2 * b + 1];
      E >= t && E <= r && w >= n && w <= o && u.push(i[b]), (c === 0 ? t <= E : n <= w) && (l.push(d), l.push(b - 1), l.push(1 - c)), (c === 0 ? r >= E : o >= w) && (l.push(b + 1), l.push(p), l.push(1 - c));
    }
    return u;
  }
  /**
   * Search the index for items within a given radius.
   * @param {number} qx
   * @param {number} qy
   * @param {number} r Query radius.
   * @returns {number[]} An array of indices correponding to the found items.
   */
  within(t, n, r) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: o,
      coords: i,
      nodeSize: a
    } = this, s = [0, o.length - 1, 0], l = [], u = r * r; s.length; ) {
      var c = s.pop() || 0, p = s.pop() || 0, d = s.pop() || 0;
      if (p - d <= a) {
        for (var g = d; g <= p; g++)
          kq(i[2 * g], i[2 * g + 1], t, n) <= u && l.push(o[g]);
        continue;
      }
      var f = d + p >> 1, m = i[2 * f], b = i[2 * f + 1];
      kq(m, b, t, n) <= u && l.push(o[f]), (c === 0 ? t - r <= m : n - r <= b) && (s.push(d), s.push(f - 1), s.push(1 - c)), (c === 0 ? t + r >= m : n + r >= b) && (s.push(f + 1), s.push(p), s.push(1 - c));
    }
    return l;
  }
}
function WP(e, t, n, r, o, i) {
  if (!(o - r <= n)) {
    var a = r + o >> 1;
    Dse(e, t, a, r, o, i), WP(e, t, n, r, a - 1, 1 - i), WP(e, t, n, a + 1, o, 1 - i);
  }
}
function Dse(e, t, n, r, o, i) {
  for (; o > r; ) {
    if (o - r > 600) {
      var a = o - r + 1, s = n - r + 1, l = Math.log(a), u = 0.5 * Math.exp(2 * l / 3), c = 0.5 * Math.sqrt(l * u * (a - u) / a) * (s - a / 2 < 0 ? -1 : 1), p = Math.max(r, Math.floor(n - s * u / a + c)), d = Math.min(o, Math.floor(n + (a - s) * u / a + c));
      Dse(e, t, n, p, d, i);
    }
    var g = t[2 * n + i], f = r, m = o;
    for (Hd(e, t, r, n), t[2 * o + i] > g && Hd(e, t, r, o); f < m; ) {
      for (Hd(e, t, f, m), f++, m--; t[2 * f + i] < g; ) f++;
      for (; t[2 * m + i] > g; ) m--;
    }
    t[2 * r + i] === g ? Hd(e, t, r, m) : (m++, Hd(e, t, m, o)), m <= n && (r = m + 1), n <= m && (o = m - 1);
  }
}
function Hd(e, t, n, r) {
  YL(e, n, r), YL(t, 2 * n, 2 * r), YL(t, 2 * n + 1, 2 * r + 1);
}
function YL(e, t, n) {
  var r = e[t];
  e[t] = e[n], e[n] = r;
}
function kq(e, t, n, r) {
  var o = e - n, i = t - r;
  return o * o + i * i;
}
var Ort = {
  minZoom: 0,
  // min zoom to generate clusters on
  maxZoom: 16,
  // max zoom level to cluster the points on
  minPoints: 2,
  // minimum points to form a cluster
  radius: 40,
  // cluster radius in pixels
  extent: 512,
  // tile extent (radius is calculated relative to it)
  nodeSize: 64,
  // size of the KD-tree leaf node, affects performance
  log: !1,
  // whether to log timing info
  // whether to generate numeric ids for input features (in vector tiles)
  generateId: !1,
  // a reduce function for calculating custom cluster properties
  reduce: null,
  // (accumulated, props) => { accumulated.sum += props.sum; }
  // properties to use for individual points when running the reducer
  map: (e) => e
  // props => ({sum: props.my_value})
}, Lq = Math.fround || /* @__PURE__ */ ((e) => (t) => (e[0] = +t, e[0]))(new Float32Array(1)), Ku = 2, Gl = 3, JL = 4, Bl = 5, Tse = 6;
class xrt {
  constructor(t) {
    this.options = Object.assign(Object.create(Ort), t), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
  }
  load(t) {
    var {
      log: n,
      minZoom: r,
      maxZoom: o
    } = this.options;
    n && console.time("total time");
    var i = "prepare ".concat(t.length, " points");
    n && console.time(i), this.points = t;
    for (var a = [], s = 0; s < t.length; s++) {
      var l = t[s];
      if (l.geometry) {
        var [u, c] = l.geometry.coordinates, p = Lq(Oy(u)), d = Lq(xy(c));
        a.push(
          p,
          d,
          // projected point coordinates
          1 / 0,
          // the last zoom the point was processed at
          s,
          // index of the source feature in the original input array
          -1,
          // parent cluster id
          1
          // number of points in a cluster
        ), this.options.reduce && a.push(0);
      }
    }
    var g = this.trees[o + 1] = this._createTree(a);
    n && console.timeEnd(i);
    for (var f = o; f >= r; f--) {
      var m = +Date.now();
      g = this.trees[f] = this._createTree(this._cluster(g, f)), n && console.log("z%d: %d clusters in %dms", f, g.numItems, +Date.now() - m);
    }
    return n && console.timeEnd("total time"), this;
  }
  getClusters(t, n) {
    var r = ((t[0] + 180) % 360 + 360) % 360 - 180, o = Math.max(-90, Math.min(90, t[1])), i = t[2] === 180 ? 180 : ((t[2] + 180) % 360 + 360) % 360 - 180, a = Math.max(-90, Math.min(90, t[3]));
    if (t[2] - t[0] >= 360)
      r = -180, i = 180;
    else if (r > i) {
      var s = this.getClusters([r, o, 180, a], n), l = this.getClusters([-180, o, i, a], n);
      return s.concat(l);
    }
    var u = this.trees[this._limitZoom(n)], c = u.range(Oy(r), xy(a), Oy(i), xy(o)), p = u.data, d = [];
    for (var g of c) {
      var f = this.stride * g;
      d.push(p[f + Bl] > 1 ? _q(p, f, this.clusterProps) : this.points[p[f + Gl]]);
    }
    return d;
  }
  getChildren(t) {
    var n = this._getOriginId(t), r = this._getOriginZoom(t), o = "No cluster with the specified id.", i = this.trees[r];
    if (!i) throw new Error(o);
    var a = i.data;
    if (n * this.stride >= a.length) throw new Error(o);
    var s = this.options.radius / (this.options.extent * Math.pow(2, r - 1)), l = a[n * this.stride], u = a[n * this.stride + 1], c = i.within(l, u, s), p = [];
    for (var d of c) {
      var g = d * this.stride;
      a[g + JL] === t && p.push(a[g + Bl] > 1 ? _q(a, g, this.clusterProps) : this.points[a[g + Gl]]);
    }
    if (p.length === 0) throw new Error(o);
    return p;
  }
  getLeaves(t, n, r) {
    n = n || 10, r = r || 0;
    var o = [];
    return this._appendLeaves(o, t, n, r, 0), o;
  }
  getTile(t, n, r) {
    var o = this.trees[this._limitZoom(t)], i = Math.pow(2, t), {
      extent: a,
      radius: s
    } = this.options, l = s / a, u = (r - l) / i, c = (r + 1 + l) / i, p = {
      features: []
    };
    return this._addTileFeatures(o.range((n - l) / i, u, (n + 1 + l) / i, c), o.data, n, r, i, p), n === 0 && this._addTileFeatures(o.range(1 - l / i, u, 1, c), o.data, i, r, i, p), n === i - 1 && this._addTileFeatures(o.range(0, u, l / i, c), o.data, -1, r, i, p), p.features.length ? p : null;
  }
  getClusterExpansionZoom(t) {
    for (var n = this._getOriginZoom(t) - 1; n <= this.options.maxZoom; ) {
      var r = this.getChildren(t);
      if (n++, r.length !== 1) break;
      t = r[0].properties.cluster_id;
    }
    return n;
  }
  _appendLeaves(t, n, r, o, i) {
    var a = this.getChildren(n);
    for (var s of a) {
      var l = s.properties;
      if (l && l.cluster ? i + l.point_count <= o ? i += l.point_count : i = this._appendLeaves(t, l.cluster_id, r, o, i) : i < o ? i++ : t.push(s), t.length === r) break;
    }
    return i;
  }
  _createTree(t) {
    for (var n = new Bj(t.length / this.stride | 0, this.options.nodeSize, Float32Array), r = 0; r < t.length; r += this.stride) n.add(t[r], t[r + 1]);
    return n.finish(), n.data = t, n;
  }
  _addTileFeatures(t, n, r, o, i, a) {
    for (var s of t) {
      var l = s * this.stride, u = n[l + Bl] > 1, c = void 0, p = void 0, d = void 0;
      if (u)
        c = jse(n, l, this.clusterProps), p = n[l], d = n[l + 1];
      else {
        var g = this.points[n[l + Gl]];
        c = g.properties;
        var [f, m] = g.geometry.coordinates;
        p = Oy(f), d = xy(m);
      }
      var b = {
        type: 1,
        geometry: [[Math.round(this.options.extent * (p * i - r)), Math.round(this.options.extent * (d * i - o))]],
        tags: c
      }, E = void 0;
      u || this.options.generateId ? E = n[l + Gl] : E = this.points[n[l + Gl]].id, E !== void 0 && (b.id = E), a.features.push(b);
    }
  }
  _limitZoom(t) {
    return Math.max(this.options.minZoom, Math.min(Math.floor(+t), this.options.maxZoom + 1));
  }
  _cluster(t, n) {
    for (var {
      radius: r,
      extent: o,
      reduce: i,
      minPoints: a
    } = this.options, s = r / (o * Math.pow(2, n)), l = t.data, u = [], c = this.stride, p = 0; p < l.length; p += c)
      if (!(l[p + Ku] <= n)) {
        l[p + Ku] = n;
        var d = l[p], g = l[p + 1], f = t.within(l[p], l[p + 1], s), m = l[p + Bl], b = m;
        for (var E of f) {
          var w = E * c;
          l[w + Ku] > n && (b += l[w + Bl]);
        }
        if (b > m && b >= a) {
          var M = d * m, x = g * m, v = void 0, C = -1, P = ((p / c | 0) << 5) + (n + 1) + this.points.length;
          for (var F of f) {
            var L = F * c;
            if (!(l[L + Ku] <= n)) {
              l[L + Ku] = n;
              var B = l[L + Bl];
              M += l[L] * B, x += l[L + 1] * B, l[L + JL] = P, i && (v || (v = this._map(l, p, !0), C = this.clusterProps.length, this.clusterProps.push(v)), i(v, this._map(l, L)));
            }
          }
          l[p + JL] = P, u.push(M / b, x / b, 1 / 0, P, -1, b), i && u.push(C);
        } else {
          for (var N = 0; N < c; N++) u.push(l[p + N]);
          if (b > 1)
            for (var $ of f) {
              var V = $ * c;
              if (!(l[V + Ku] <= n)) {
                l[V + Ku] = n;
                for (var H = 0; H < c; H++) u.push(l[V + H]);
              }
            }
        }
      }
    return u;
  }
  // get index of the point from which the cluster originated
  _getOriginId(t) {
    return t - this.points.length >> 5;
  }
  // get zoom of the point from which the cluster originated
  _getOriginZoom(t) {
    return (t - this.points.length) % 32;
  }
  _map(t, n, r) {
    if (t[n + Bl] > 1) {
      var o = this.clusterProps[t[n + Tse]];
      return r ? Object.assign({}, o) : o;
    }
    var i = this.points[t[n + Gl]].properties, a = this.options.map(i);
    return r && a === i ? Object.assign({}, a) : a;
  }
}
function _q(e, t, n) {
  return {
    type: "Feature",
    id: e[t + Gl],
    properties: jse(e, t, n),
    geometry: {
      type: "Point",
      coordinates: [Ert(e[t]), krt(e[t + 1])]
    }
  };
}
function jse(e, t, n) {
  var r = e[t + Bl], o = r >= 1e4 ? "".concat(Math.round(r / 1e3), "k") : r >= 1e3 ? "".concat(Math.round(r / 100) / 10, "k") : r, i = e[t + Tse], a = i === -1 ? {} : Object.assign({}, n[i]);
  return Object.assign(a, {
    cluster: !0,
    cluster_id: e[t + Gl],
    point_count: r,
    point_count_abbreviated: o
  });
}
function Oy(e) {
  return e / 360 + 0.5;
}
function xy(e) {
  var t = Math.sin(e * Math.PI / 180), n = 0.5 - 0.25 * Math.log((1 + t) / (1 - t)) / Math.PI;
  return n < 0 ? 0 : n > 1 ? 1 : n;
}
function Ert(e) {
  return (e - 0.5) * 360;
}
function krt(e) {
  var t = (180 - e * 360) * Math.PI / 180;
  return 360 * Math.atan(Math.exp(t)) / Math.PI - 90;
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function Lrt(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
    t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
  return n;
}
class vs {
  static isAdvancedMarkerAvailable(t) {
    return google.maps.marker && t.getMapCapabilities().isAdvancedMarkersAvailable === !0;
  }
  static isAdvancedMarker(t) {
    return google.maps.marker && t instanceof google.maps.marker.AdvancedMarkerElement;
  }
  static setMap(t, n) {
    this.isAdvancedMarker(t) ? t.map = n : t.setMap(n);
  }
  static getPosition(t) {
    if (this.isAdvancedMarker(t)) {
      if (t.position) {
        if (t.position instanceof google.maps.LatLng)
          return t.position;
        if (t.position.lat && t.position.lng)
          return new google.maps.LatLng(t.position.lat, t.position.lng);
      }
      return new google.maps.LatLng(null);
    }
    return t.getPosition();
  }
  static getVisible(t) {
    return this.isAdvancedMarker(t) ? !0 : t.getVisible();
  }
}
class $P {
  constructor(t) {
    var {
      markers: n,
      position: r
    } = t;
    this.markers = n, r && (r instanceof google.maps.LatLng ? this._position = r : this._position = new google.maps.LatLng(r));
  }
  get bounds() {
    if (!(this.markers.length === 0 && !this._position)) {
      var t = new google.maps.LatLngBounds(this._position, this._position);
      for (var n of this.markers)
        t.extend(vs.getPosition(n));
      return t;
    }
  }
  get position() {
    return this._position || this.bounds.getCenter();
  }
  /**
   * Get the count of **visible** markers.
   */
  get count() {
    return this.markers.filter((t) => vs.getVisible(t)).length;
  }
  /**
   * Add a marker to the cluster.
   */
  push(t) {
    this.markers.push(t);
  }
  /**
   * Cleanup references and remove marker from map.
   */
  delete() {
    this.marker && (vs.setMap(this.marker, null), this.marker = void 0), this.markers.length = 0;
  }
}
class _rt {
  constructor(t) {
    var {
      maxZoom: n = 16
    } = t;
    this.maxZoom = n;
  }
  /**
   * Helper function to bypass clustering based upon some map state such as
   * zoom, number of markers, etc.
   *
   * ```typescript
   *  cluster({markers, map}: AlgorithmInput): Cluster[] {
   *    if (shouldBypassClustering(map)) {
   *      return this.noop({markers})
   *    }
   * }
   * ```
   */
  noop(t) {
    var {
      markers: n
    } = t;
    return Prt(n);
  }
}
var Prt = (e) => {
  var t = e.map((n) => new $P({
    position: vs.getPosition(n),
    markers: [n]
  }));
  return t;
};
class Srt extends _rt {
  constructor(t) {
    var {
      maxZoom: n,
      radius: r = 60
    } = t, o = Lrt(t, ["maxZoom", "radius"]);
    super({
      maxZoom: n
    }), this.state = {
      zoom: -1
    }, this.superCluster = new xrt(Object.assign({
      maxZoom: this.maxZoom,
      radius: r
    }, o));
  }
  calculate(t) {
    var n = !1, r = {
      zoom: t.map.getZoom()
    };
    if (!xq(t.markers, this.markers)) {
      n = !0, this.markers = [...t.markers];
      var o = this.markers.map((i) => {
        var a = vs.getPosition(i), s = [a.lng(), a.lat()];
        return {
          type: "Feature",
          geometry: {
            type: "Point",
            coordinates: s
          },
          properties: {
            marker: i
          }
        };
      });
      this.superCluster.load(o);
    }
    return n || (this.state.zoom <= this.maxZoom || r.zoom <= this.maxZoom) && (n = !xq(this.state, r)), this.state = r, n && (this.clusters = this.cluster(t)), {
      clusters: this.clusters,
      changed: n
    };
  }
  cluster(t) {
    var {
      map: n
    } = t;
    return this.superCluster.getClusters([-180, -90, 180, 90], Math.round(n.getZoom())).map((r) => this.transformCluster(r));
  }
  transformCluster(t) {
    var {
      geometry: {
        coordinates: [n, r]
      },
      properties: o
    } = t;
    if (o.cluster)
      return new $P({
        markers: this.superCluster.getLeaves(o.cluster_id, 1 / 0).map((a) => a.properties.marker),
        position: {
          lat: r,
          lng: n
        }
      });
    var i = o.marker;
    return new $P({
      markers: [i],
      position: vs.getPosition(i)
    });
  }
}
class Mrt {
  constructor(t, n) {
    this.markers = {
      sum: t.length
    };
    var r = n.map((i) => i.count), o = r.reduce((i, a) => i + a, 0);
    this.clusters = {
      count: n.length,
      markers: {
        mean: o / n.length,
        sum: o,
        min: Math.min(...r),
        max: Math.max(...r)
      }
    };
  }
}
class Drt {
  /**
   * The default render function for the library used by {@link MarkerClusterer}.
   *
   * Currently set to use the following:
   *
   * ```typescript
   * // change color if this cluster has more markers than the mean cluster
   * const color =
   *   count > Math.max(10, stats.clusters.markers.mean)
   *     ? "#ff0000"
   *     : "#0000ff";
   *
   * // create svg url with fill color
   * const svg = window.btoa(`
   * <svg fill="${color}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240">
   *   <circle cx="120" cy="120" opacity=".6" r="70" />
   *   <circle cx="120" cy="120" opacity=".3" r="90" />
   *   <circle cx="120" cy="120" opacity=".2" r="110" />
   *   <circle cx="120" cy="120" opacity=".1" r="130" />
   * </svg>`);
   *
   * // create marker using svg icon
   * return new google.maps.Marker({
   *   position,
   *   icon: {
   *     url: `data:image/svg+xml;base64,${svg}`,
   *     scaledSize: new google.maps.Size(45, 45),
   *   },
   *   label: {
   *     text: String(count),
   *     color: "rgba(255,255,255,0.9)",
   *     fontSize: "12px",
   *   },
   *   // adjust zIndex to be above other markers
   *   zIndex: 1000 + count,
   * });
   * ```
   */
  render(t, n, r) {
    var {
      count: o,
      position: i
    } = t, a = o > Math.max(10, n.clusters.markers.mean) ? "#ff0000" : "#0000ff", s = '<svg fill="'.concat(a, `" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" width="50" height="50">
<circle cx="120" cy="120" opacity=".6" r="70" />
<circle cx="120" cy="120" opacity=".3" r="90" />
<circle cx="120" cy="120" opacity=".2" r="110" />
<text x="50%" y="50%" style="fill:#fff" text-anchor="middle" font-size="50" dominant-baseline="middle" font-family="roboto,arial,sans-serif">`).concat(o, `</text>
</svg>`), l = "Cluster of ".concat(o, " markers"), u = Number(google.maps.Marker.MAX_ZINDEX) + o;
    if (vs.isAdvancedMarkerAvailable(r)) {
      var c = new DOMParser(), p = c.parseFromString(s, "image/svg+xml").documentElement;
      p.setAttribute("transform", "translate(0 25)");
      var d = {
        map: r,
        position: i,
        zIndex: u,
        title: l,
        content: p
      };
      return new google.maps.marker.AdvancedMarkerElement(d);
    }
    var g = {
      position: i,
      zIndex: u,
      title: l,
      icon: {
        url: "data:image/svg+xml;base64,".concat(btoa(s)),
        anchor: new google.maps.Point(25, 25)
      }
    };
    return new google.maps.Marker(g);
  }
}
function Trt(e, t) {
  for (var n in t.prototype)
    e.prototype[n] = t.prototype[n];
}
class Fj {
  constructor() {
    Trt(Fj, google.maps.OverlayView);
  }
}
var Ff;
(function(e) {
  e.CLUSTERING_BEGIN = "clusteringbegin", e.CLUSTERING_END = "clusteringend", e.CLUSTER_CLICK = "click";
})(Ff || (Ff = {}));
var jrt = (e, t, n) => {
  n.fitBounds(t.bounds);
};
class Art extends Fj {
  constructor(t) {
    var {
      map: n,
      markers: r = [],
      algorithmOptions: o = {},
      algorithm: i = new Srt(o),
      renderer: a = new Drt(),
      onClusterClick: s = jrt
    } = t;
    super(), this.markers = [...r], this.clusters = [], this.algorithm = i, this.renderer = a, this.onClusterClick = s, n && this.setMap(n);
  }
  addMarker(t, n) {
    this.markers.includes(t) || (this.markers.push(t), n || this.render());
  }
  addMarkers(t, n) {
    t.forEach((r) => {
      this.addMarker(r, !0);
    }), n || this.render();
  }
  removeMarker(t, n) {
    var r = this.markers.indexOf(t);
    return r === -1 ? !1 : (vs.setMap(t, null), this.markers.splice(r, 1), n || this.render(), !0);
  }
  removeMarkers(t, n) {
    var r = !1;
    return t.forEach((o) => {
      r = this.removeMarker(o, !0) || r;
    }), r && !n && this.render(), r;
  }
  clearMarkers(t) {
    this.markers.length = 0, t || this.render();
  }
  /**
   * Recalculates and draws all the marker clusters.
   */
  render() {
    var t = this.getMap();
    if (t instanceof google.maps.Map && t.getProjection()) {
      google.maps.event.trigger(this, Ff.CLUSTERING_BEGIN, this);
      var {
        clusters: n,
        changed: r
      } = this.algorithm.calculate({
        markers: this.markers,
        map: t,
        mapCanvasProjection: this.getProjection()
      });
      if (r || r == null) {
        var o = /* @__PURE__ */ new Set();
        for (var i of n)
          i.markers.length == 1 && o.add(i.markers[0]);
        var a = [];
        for (var s of this.clusters)
          s.marker != null && (s.markers.length == 1 ? o.has(s.marker) || vs.setMap(s.marker, null) : a.push(s.marker));
        this.clusters = n, this.renderClusters(), requestAnimationFrame(() => a.forEach((l) => vs.setMap(l, null)));
      }
      google.maps.event.trigger(this, Ff.CLUSTERING_END, this);
    }
  }
  onAdd() {
    this.idleListener = this.getMap().addListener("idle", this.render.bind(this)), this.render();
  }
  onRemove() {
    google.maps.event.removeListener(this.idleListener), this.reset();
  }
  reset() {
    this.markers.forEach((t) => vs.setMap(t, null)), this.clusters.forEach((t) => t.delete()), this.clusters = [];
  }
  renderClusters() {
    var t = new Mrt(this.markers, this.clusters), n = this.getMap();
    this.clusters.forEach((r) => {
      r.markers.length === 1 ? r.marker = r.markers[0] : (r.marker = this.renderer.render(r, t, n), r.markers.forEach((o) => vs.setMap(o, null)), this.onClusterClick && r.marker.addListener(
        "click",
        /* istanbul ignore next */
        (o) => {
          google.maps.event.trigger(this, Ff.CLUSTER_CLICK, r), this.onClusterClick(o, r, n);
        }
      )), vs.setMap(r.marker, n);
    });
  }
}
function Pq(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Sq(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Pq(Object(n), !0).forEach(function(r) {
      Ce(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Pq(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function Rrt(e) {
  var t = Ant(), [n, r] = k(null);
  return h(() => {
    if (t && n === null) {
      var o = new Art(Sq(Sq({}, e), {}, {
        map: t
      }));
      r(o);
    }
  }, [t]), n;
}
function Irt(e) {
  var {
    children: t,
    options: n
  } = e, r = Rrt(n);
  return r !== null ? t(r) : null;
}
me(Irt);
var Mq = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, Dq = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
function Nrt(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, g = ge(At), [f, m] = k(null), [b, E] = k(null), [w, M] = k(null), [x, v] = k(null), [C, P] = k(null), [F, L] = k(null), B = dt(null);
  return h(() => {
    f !== null && (f.close(), n ? f.open(g, n) : f.getPosition() && f.open(g));
  }, [g, f, n]), h(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), h(() => {
    o && f !== null && f.setPosition(o);
  }, [o]), h(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), h(() => {
    f && a && (b !== null && google.maps.event.removeListener(b), E(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), h(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), M(google.maps.event.addListener(f, "domready", s)));
  }, [s]), h(() => {
    f && l && (x !== null && google.maps.event.removeListener(x), v(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), h(() => {
    f && u && (C !== null && google.maps.event.removeListener(C), P(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), h(() => {
    f && c && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), h(() => {
    var N = new google.maps.InfoWindow(r);
    return m(N), B.current = document.createElement("div"), a && E(google.maps.event.addListener(N, "closeclick", a)), s && M(google.maps.event.addListener(N, "domready", s)), l && v(google.maps.event.addListener(N, "content_changed", l)), u && P(google.maps.event.addListener(N, "position_changed", u)), c && L(google.maps.event.addListener(N, "zindex_changed", c)), N.setContent(B.current), o && N.setPosition(o), i && N.setZIndex(i), n ? N.open(g, n) : N.getPosition() ? N.open(g) : Go(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>."), p && p(N), () => {
      b && google.maps.event.removeListener(b), x && google.maps.event.removeListener(x), w && google.maps.event.removeListener(w), C && google.maps.event.removeListener(C), F && google.maps.event.removeListener(F), d && d(N), N.close();
    };
  }, []), B.current ? zn(at.only(t), B.current) : null;
}
me(Nrt);
class Brt extends pe {
  constructor() {
    super(...arguments), Ce(this, "registeredEvents", []), Ce(this, "containerElement", null), Ce(this, "state", {
      infoWindow: null
    }), Ce(this, "open", (t, n) => {
      n ? t.open(this.context, n) : t.getPosition() ? t.open(this.context) : Go(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>.");
    }), Ce(this, "setInfoWindowCallback", () => {
      this.state.infoWindow !== null && this.containerElement !== null && (this.state.infoWindow.setContent(this.containerElement), this.open(this.state.infoWindow, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoWindow));
    });
  }
  componentDidMount() {
    var t = new google.maps.InfoWindow(this.props.options);
    this.containerElement = document.createElement("div"), this.registeredEvents = Jt({
      updaterMap: Dq,
      eventMap: Mq,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(() => ({
      infoWindow: t
    }), this.setInfoWindowCallback);
  }
  componentDidUpdate(t) {
    this.state.infoWindow !== null && (un(this.registeredEvents), this.registeredEvents = Jt({
      updaterMap: Dq,
      eventMap: Mq,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.infoWindow
    }));
  }
  componentWillUnmount() {
    this.state.infoWindow !== null && (un(this.registeredEvents), this.props.onUnmount && this.props.onUnmount(this.state.infoWindow), this.state.infoWindow.close());
  }
  render() {
    return this.containerElement ? zn(at.only(this.props.children), this.containerElement) : null;
  }
}
Ce(Brt, "contextType", At);
function Tq(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function n0(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Tq(Object(n), !0).forEach(function(r) {
      Ce(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Tq(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var jq = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, Aq = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, Frt = {};
function zrt(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: g,
    onRightClick: f,
    onClick: m,
    onDrag: b,
    onLoad: E,
    onUnmount: w
  } = e, M = ge(At), [x, v] = k(null), [C, P] = k(null), [F, L] = k(null), [B, N] = k(null), [$, V] = k(null), [H, Z] = k(null), [K, Y] = k(null), [Q, J] = k(null), [_, D] = k(null), [z, S] = k(null), [W, O] = k(null), [j, U] = k(null);
  return h(() => {
    x !== null && x.setMap(M);
  }, [M]), h(() => {
    typeof t < "u" && x !== null && x.setOptions(t);
  }, [x, t]), h(() => {
    typeof n < "u" && x !== null && x.setDraggable(n);
  }, [x, n]), h(() => {
    typeof r < "u" && x !== null && x.setEditable(r);
  }, [x, r]), h(() => {
    typeof o < "u" && x !== null && x.setVisible(o);
  }, [x, o]), h(() => {
    typeof i < "u" && x !== null && x.setPath(i);
  }, [x, i]), h(() => {
    x && a && (C !== null && google.maps.event.removeListener(C), P(google.maps.event.addListener(x, "dblclick", a)));
  }, [a]), h(() => {
    x && s && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(x, "dragend", s)));
  }, [s]), h(() => {
    x && l && (B !== null && google.maps.event.removeListener(B), N(google.maps.event.addListener(x, "dragstart", l)));
  }, [l]), h(() => {
    x && u && ($ !== null && google.maps.event.removeListener($), V(google.maps.event.addListener(x, "mousedown", u)));
  }, [u]), h(() => {
    x && c && (H !== null && google.maps.event.removeListener(H), Z(google.maps.event.addListener(x, "mousemove", c)));
  }, [c]), h(() => {
    x && p && (K !== null && google.maps.event.removeListener(K), Y(google.maps.event.addListener(x, "mouseout", p)));
  }, [p]), h(() => {
    x && d && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(x, "mouseover", d)));
  }, [d]), h(() => {
    x && g && (_ !== null && google.maps.event.removeListener(_), D(google.maps.event.addListener(x, "mouseup", g)));
  }, [g]), h(() => {
    x && f && (z !== null && google.maps.event.removeListener(z), S(google.maps.event.addListener(x, "rightclick", f)));
  }, [f]), h(() => {
    x && m && (W !== null && google.maps.event.removeListener(W), O(google.maps.event.addListener(x, "click", m)));
  }, [m]), h(() => {
    x && b && (j !== null && google.maps.event.removeListener(j), U(google.maps.event.addListener(x, "drag", b)));
  }, [b]), h(() => {
    var T = new google.maps.Polyline(n0(n0({}, t || Frt), {}, {
      map: M
    }));
    return i && T.setPath(i), typeof o < "u" && T.setVisible(o), typeof r < "u" && T.setEditable(r), typeof n < "u" && T.setDraggable(n), a && P(google.maps.event.addListener(T, "dblclick", a)), s && L(google.maps.event.addListener(T, "dragend", s)), l && N(google.maps.event.addListener(T, "dragstart", l)), u && V(google.maps.event.addListener(T, "mousedown", u)), c && Z(google.maps.event.addListener(T, "mousemove", c)), p && Y(google.maps.event.addListener(T, "mouseout", p)), d && J(google.maps.event.addListener(T, "mouseover", d)), g && D(google.maps.event.addListener(T, "mouseup", g)), f && S(google.maps.event.addListener(T, "rightclick", f)), m && O(google.maps.event.addListener(T, "click", m)), b && U(google.maps.event.addListener(T, "drag", b)), v(T), E && E(T), () => {
      C !== null && google.maps.event.removeListener(C), F !== null && google.maps.event.removeListener(F), B !== null && google.maps.event.removeListener(B), $ !== null && google.maps.event.removeListener($), H !== null && google.maps.event.removeListener(H), K !== null && google.maps.event.removeListener(K), Q !== null && google.maps.event.removeListener(Q), _ !== null && google.maps.event.removeListener(_), z !== null && google.maps.event.removeListener(z), W !== null && google.maps.event.removeListener(W), w && w(T), T.setMap(null);
    };
  }, []), null;
}
me(zrt);
class Urt extends pe {
  constructor() {
    super(...arguments), Ce(this, "registeredEvents", []), Ce(this, "state", {
      polyline: null
    }), Ce(this, "setPolylineCallback", () => {
      this.state.polyline !== null && this.props.onLoad && this.props.onLoad(this.state.polyline);
    });
  }
  componentDidMount() {
    var t = new google.maps.Polyline(n0(n0({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Jt({
      updaterMap: Aq,
      eventMap: jq,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        polyline: t
      };
    }, this.setPolylineCallback);
  }
  componentDidUpdate(t) {
    this.state.polyline !== null && (un(this.registeredEvents), this.registeredEvents = Jt({
      updaterMap: Aq,
      eventMap: jq,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.polyline
    }));
  }
  componentWillUnmount() {
    this.state.polyline !== null && (this.props.onUnmount && this.props.onUnmount(this.state.polyline), un(this.registeredEvents), this.state.polyline.setMap(null));
  }
  render() {
    return null;
  }
}
Ce(Urt, "contextType", At);
function Rq(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Iq(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Rq(Object(n), !0).forEach(function(r) {
      Ce(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Rq(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Nq = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, Bq = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  paths(e, t) {
    e.setPaths(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function Hrt(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    paths: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: g,
    onMouseUp: f,
    onRightClick: m,
    onClick: b,
    onDrag: E,
    onLoad: w,
    onUnmount: M,
    onEdit: x
  } = e, v = ge(At), [C, P] = k(null), [F, L] = k(null), [B, N] = k(null), [$, V] = k(null), [H, Z] = k(null), [K, Y] = k(null), [Q, J] = k(null), [_, D] = k(null), [z, S] = k(null), [W, O] = k(null), [j, U] = k(null), [T, q] = k(null);
  return h(() => {
    C !== null && C.setMap(v);
  }, [v]), h(() => {
    typeof t < "u" && C !== null && C.setOptions(t);
  }, [C, t]), h(() => {
    typeof n < "u" && C !== null && C.setDraggable(n);
  }, [C, n]), h(() => {
    typeof r < "u" && C !== null && C.setEditable(r);
  }, [C, r]), h(() => {
    typeof o < "u" && C !== null && C.setVisible(o);
  }, [C, o]), h(() => {
    typeof i < "u" && C !== null && C.setPath(i);
  }, [C, i]), h(() => {
    typeof a < "u" && C !== null && C.setPaths(a);
  }, [C, a]), h(() => {
    C && typeof s == "function" && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(C, "dblclick", s)));
  }, [s]), h(() => {
    C && (google.maps.event.addListener(C.getPath(), "insert_at", () => {
      x == null || x(C);
    }), google.maps.event.addListener(C.getPath(), "set_at", () => {
      x == null || x(C);
    }), google.maps.event.addListener(C.getPath(), "remove_at", () => {
      x == null || x(C);
    }));
  }, [C, x]), h(() => {
    C && typeof l == "function" && (B !== null && google.maps.event.removeListener(B), N(google.maps.event.addListener(C, "dragend", l)));
  }, [l]), h(() => {
    C && typeof u == "function" && ($ !== null && google.maps.event.removeListener($), V(google.maps.event.addListener(C, "dragstart", u)));
  }, [u]), h(() => {
    C && typeof c == "function" && (H !== null && google.maps.event.removeListener(H), Z(google.maps.event.addListener(C, "mousedown", c)));
  }, [c]), h(() => {
    C && typeof p == "function" && (K !== null && google.maps.event.removeListener(K), Y(google.maps.event.addListener(C, "mousemove", p)));
  }, [p]), h(() => {
    C && typeof d == "function" && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(C, "mouseout", d)));
  }, [d]), h(() => {
    C && typeof g == "function" && (_ !== null && google.maps.event.removeListener(_), D(google.maps.event.addListener(C, "mouseover", g)));
  }, [g]), h(() => {
    C && typeof f == "function" && (z !== null && google.maps.event.removeListener(z), S(google.maps.event.addListener(C, "mouseup", f)));
  }, [f]), h(() => {
    C && typeof m == "function" && (W !== null && google.maps.event.removeListener(W), O(google.maps.event.addListener(C, "rightclick", m)));
  }, [m]), h(() => {
    C && typeof b == "function" && (j !== null && google.maps.event.removeListener(j), U(google.maps.event.addListener(C, "click", b)));
  }, [b]), h(() => {
    C && typeof E == "function" && (T !== null && google.maps.event.removeListener(T), q(google.maps.event.addListener(C, "drag", E)));
  }, [E]), h(() => {
    var A = new google.maps.Polygon(Iq(Iq({}, t), {}, {
      map: v
    }));
    return i && A.setPath(i), a && A.setPaths(a), typeof o < "u" && A.setVisible(o), typeof r < "u" && A.setEditable(r), typeof n < "u" && A.setDraggable(n), s && L(google.maps.event.addListener(A, "dblclick", s)), l && N(google.maps.event.addListener(A, "dragend", l)), u && V(google.maps.event.addListener(A, "dragstart", u)), c && Z(google.maps.event.addListener(A, "mousedown", c)), p && Y(google.maps.event.addListener(A, "mousemove", p)), d && J(google.maps.event.addListener(A, "mouseout", d)), g && D(google.maps.event.addListener(A, "mouseover", g)), f && S(google.maps.event.addListener(A, "mouseup", f)), m && O(google.maps.event.addListener(A, "rightclick", m)), b && U(google.maps.event.addListener(A, "click", b)), E && q(google.maps.event.addListener(A, "drag", E)), P(A), w && w(A), () => {
      F !== null && google.maps.event.removeListener(F), B !== null && google.maps.event.removeListener(B), $ !== null && google.maps.event.removeListener($), H !== null && google.maps.event.removeListener(H), K !== null && google.maps.event.removeListener(K), Q !== null && google.maps.event.removeListener(Q), _ !== null && google.maps.event.removeListener(_), z !== null && google.maps.event.removeListener(z), W !== null && google.maps.event.removeListener(W), j !== null && google.maps.event.removeListener(j), M && M(A), A.setMap(null);
    };
  }, []), null;
}
me(Hrt);
class Wrt extends pe {
  constructor() {
    super(...arguments), Ce(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this.props.options || {};
    this.polygon = new google.maps.Polygon(t), this.polygon.setMap(this.context), this.registeredEvents = Jt({
      updaterMap: Bq,
      eventMap: Nq,
      prevProps: {},
      nextProps: this.props,
      instance: this.polygon
    }), this.props.onLoad && this.props.onLoad(this.polygon);
  }
  componentDidUpdate(t) {
    this.polygon && (un(this.registeredEvents), this.registeredEvents = Jt({
      updaterMap: Bq,
      eventMap: Nq,
      prevProps: t,
      nextProps: this.props,
      instance: this.polygon
    }));
  }
  componentWillUnmount() {
    this.polygon && (this.props.onUnmount && this.props.onUnmount(this.polygon), un(this.registeredEvents), this.polygon && this.polygon.setMap(null));
  }
  render() {
    return null;
  }
}
Ce(Wrt, "contextType", At);
function Fq(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function r0(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Fq(Object(n), !0).forEach(function(r) {
      Ce(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Fq(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var zq = {
  onBoundsChanged: "bounds_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, Uq = {
  bounds(e, t) {
    e.setBounds(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function $rt(e) {
  var {
    options: t,
    bounds: n,
    draggable: r,
    editable: o,
    visible: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: g,
    onRightClick: f,
    onClick: m,
    onDrag: b,
    onBoundsChanged: E,
    onLoad: w,
    onUnmount: M
  } = e, x = ge(At), [v, C] = k(null), [P, F] = k(null), [L, B] = k(null), [N, $] = k(null), [V, H] = k(null), [Z, K] = k(null), [Y, Q] = k(null), [J, _] = k(null), [D, z] = k(null), [S, W] = k(null), [O, j] = k(null), [U, T] = k(null), [q, A] = k(null);
  return h(() => {
    v !== null && v.setMap(x);
  }, [x]), h(() => {
    typeof t < "u" && v !== null && v.setOptions(t);
  }, [v, t]), h(() => {
    typeof r < "u" && v !== null && v.setDraggable(r);
  }, [v, r]), h(() => {
    typeof o < "u" && v !== null && v.setEditable(o);
  }, [v, o]), h(() => {
    typeof i < "u" && v !== null && v.setVisible(i);
  }, [v, i]), h(() => {
    typeof n < "u" && v !== null && v.setBounds(n);
  }, [v, n]), h(() => {
    v && a && (P !== null && google.maps.event.removeListener(P), F(google.maps.event.addListener(v, "dblclick", a)));
  }, [a]), h(() => {
    v && s && (L !== null && google.maps.event.removeListener(L), B(google.maps.event.addListener(v, "dragend", s)));
  }, [s]), h(() => {
    v && l && (N !== null && google.maps.event.removeListener(N), $(google.maps.event.addListener(v, "dragstart", l)));
  }, [l]), h(() => {
    v && u && (V !== null && google.maps.event.removeListener(V), H(google.maps.event.addListener(v, "mousedown", u)));
  }, [u]), h(() => {
    v && c && (Z !== null && google.maps.event.removeListener(Z), K(google.maps.event.addListener(v, "mousemove", c)));
  }, [c]), h(() => {
    v && p && (Y !== null && google.maps.event.removeListener(Y), Q(google.maps.event.addListener(v, "mouseout", p)));
  }, [p]), h(() => {
    v && d && (J !== null && google.maps.event.removeListener(J), _(google.maps.event.addListener(v, "mouseover", d)));
  }, [d]), h(() => {
    v && g && (D !== null && google.maps.event.removeListener(D), z(google.maps.event.addListener(v, "mouseup", g)));
  }, [g]), h(() => {
    v && f && (S !== null && google.maps.event.removeListener(S), W(google.maps.event.addListener(v, "rightclick", f)));
  }, [f]), h(() => {
    v && m && (O !== null && google.maps.event.removeListener(O), j(google.maps.event.addListener(v, "click", m)));
  }, [m]), h(() => {
    v && b && (U !== null && google.maps.event.removeListener(U), T(google.maps.event.addListener(v, "drag", b)));
  }, [b]), h(() => {
    v && E && (q !== null && google.maps.event.removeListener(q), A(google.maps.event.addListener(v, "bounds_changed", E)));
  }, [E]), h(() => {
    var X = new google.maps.Rectangle(r0(r0({}, t), {}, {
      map: x
    }));
    return typeof i < "u" && X.setVisible(i), typeof o < "u" && X.setEditable(o), typeof r < "u" && X.setDraggable(r), typeof n < "u" && X.setBounds(n), a && F(google.maps.event.addListener(X, "dblclick", a)), s && B(google.maps.event.addListener(X, "dragend", s)), l && $(google.maps.event.addListener(X, "dragstart", l)), u && H(google.maps.event.addListener(X, "mousedown", u)), c && K(google.maps.event.addListener(X, "mousemove", c)), p && Q(google.maps.event.addListener(X, "mouseout", p)), d && _(google.maps.event.addListener(X, "mouseover", d)), g && z(google.maps.event.addListener(X, "mouseup", g)), f && W(google.maps.event.addListener(X, "rightclick", f)), m && j(google.maps.event.addListener(X, "click", m)), b && T(google.maps.event.addListener(X, "drag", b)), E && A(google.maps.event.addListener(X, "bounds_changed", E)), C(X), w && w(X), () => {
      P !== null && google.maps.event.removeListener(P), L !== null && google.maps.event.removeListener(L), N !== null && google.maps.event.removeListener(N), V !== null && google.maps.event.removeListener(V), Z !== null && google.maps.event.removeListener(Z), Y !== null && google.maps.event.removeListener(Y), J !== null && google.maps.event.removeListener(J), D !== null && google.maps.event.removeListener(D), S !== null && google.maps.event.removeListener(S), O !== null && google.maps.event.removeListener(O), U !== null && google.maps.event.removeListener(U), q !== null && google.maps.event.removeListener(q), M && M(X), X.setMap(null);
    };
  }, []), null;
}
me($rt);
class Vrt extends pe {
  constructor() {
    super(...arguments), Ce(this, "registeredEvents", []), Ce(this, "state", {
      rectangle: null
    }), Ce(this, "setRectangleCallback", () => {
      this.state.rectangle !== null && this.props.onLoad && this.props.onLoad(this.state.rectangle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Rectangle(r0(r0({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Jt({
      updaterMap: Uq,
      eventMap: zq,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        rectangle: t
      };
    }, this.setRectangleCallback);
  }
  componentDidUpdate(t) {
    this.state.rectangle !== null && (un(this.registeredEvents), this.registeredEvents = Jt({
      updaterMap: Uq,
      eventMap: zq,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.rectangle
    }));
  }
  componentWillUnmount() {
    this.state.rectangle !== null && (this.props.onUnmount && this.props.onUnmount(this.state.rectangle), un(this.registeredEvents), this.state.rectangle.setMap(null));
  }
  render() {
    return null;
  }
}
Ce(Vrt, "contextType", At);
function Hq(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function o0(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Hq(Object(n), !0).forEach(function(r) {
      Ce(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Hq(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Wq = {
  onCenterChanged: "center_changed",
  onRadiusChanged: "radius_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, $q = {
  center(e, t) {
    e.setCenter(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  radius(e, t) {
    e.setRadius(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, Zrt = {};
function qrt(e) {
  var {
    options: t,
    center: n,
    radius: r,
    draggable: o,
    editable: i,
    visible: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: g,
    onMouseUp: f,
    onRightClick: m,
    onClick: b,
    onDrag: E,
    onCenterChanged: w,
    onRadiusChanged: M,
    onLoad: x,
    onUnmount: v
  } = e, C = ge(At), [P, F] = k(null), [L, B] = k(null), [N, $] = k(null), [V, H] = k(null), [Z, K] = k(null), [Y, Q] = k(null), [J, _] = k(null), [D, z] = k(null), [S, W] = k(null), [O, j] = k(null), [U, T] = k(null), [q, A] = k(null), [X, I] = k(null), [le, he] = k(null);
  return h(() => {
    P !== null && P.setMap(C);
  }, [C]), h(() => {
    typeof t < "u" && P !== null && P.setOptions(t);
  }, [P, t]), h(() => {
    typeof o < "u" && P !== null && P.setDraggable(o);
  }, [P, o]), h(() => {
    typeof i < "u" && P !== null && P.setEditable(i);
  }, [P, i]), h(() => {
    typeof a < "u" && P !== null && P.setVisible(a);
  }, [P, a]), h(() => {
    typeof r == "number" && P !== null && P.setRadius(r);
  }, [P, r]), h(() => {
    typeof n < "u" && P !== null && P.setCenter(n);
  }, [P, n]), h(() => {
    P && s && (L !== null && google.maps.event.removeListener(L), B(google.maps.event.addListener(P, "dblclick", s)));
  }, [s]), h(() => {
    P && l && (N !== null && google.maps.event.removeListener(N), $(google.maps.event.addListener(P, "dragend", l)));
  }, [l]), h(() => {
    P && u && (V !== null && google.maps.event.removeListener(V), H(google.maps.event.addListener(P, "dragstart", u)));
  }, [u]), h(() => {
    P && c && (Z !== null && google.maps.event.removeListener(Z), K(google.maps.event.addListener(P, "mousedown", c)));
  }, [c]), h(() => {
    P && p && (Y !== null && google.maps.event.removeListener(Y), Q(google.maps.event.addListener(P, "mousemove", p)));
  }, [p]), h(() => {
    P && d && (J !== null && google.maps.event.removeListener(J), _(google.maps.event.addListener(P, "mouseout", d)));
  }, [d]), h(() => {
    P && g && (D !== null && google.maps.event.removeListener(D), z(google.maps.event.addListener(P, "mouseover", g)));
  }, [g]), h(() => {
    P && f && (S !== null && google.maps.event.removeListener(S), W(google.maps.event.addListener(P, "mouseup", f)));
  }, [f]), h(() => {
    P && m && (O !== null && google.maps.event.removeListener(O), j(google.maps.event.addListener(P, "rightclick", m)));
  }, [m]), h(() => {
    P && b && (U !== null && google.maps.event.removeListener(U), T(google.maps.event.addListener(P, "click", b)));
  }, [b]), h(() => {
    P && E && (q !== null && google.maps.event.removeListener(q), A(google.maps.event.addListener(P, "drag", E)));
  }, [E]), h(() => {
    P && w && (X !== null && google.maps.event.removeListener(X), I(google.maps.event.addListener(P, "center_changed", w)));
  }, [b]), h(() => {
    P && M && (le !== null && google.maps.event.removeListener(le), he(google.maps.event.addListener(P, "radius_changed", M)));
  }, [M]), h(() => {
    var oe = new google.maps.Circle(o0(o0({}, t || Zrt), {}, {
      map: C
    }));
    return typeof r == "number" && oe.setRadius(r), typeof n < "u" && oe.setCenter(n), typeof r == "number" && oe.setRadius(r), typeof a < "u" && oe.setVisible(a), typeof i < "u" && oe.setEditable(i), typeof o < "u" && oe.setDraggable(o), s && B(google.maps.event.addListener(oe, "dblclick", s)), l && $(google.maps.event.addListener(oe, "dragend", l)), u && H(google.maps.event.addListener(oe, "dragstart", u)), c && K(google.maps.event.addListener(oe, "mousedown", c)), p && Q(google.maps.event.addListener(oe, "mousemove", p)), d && _(google.maps.event.addListener(oe, "mouseout", d)), g && z(google.maps.event.addListener(oe, "mouseover", g)), f && W(google.maps.event.addListener(oe, "mouseup", f)), m && j(google.maps.event.addListener(oe, "rightclick", m)), b && T(google.maps.event.addListener(oe, "click", b)), E && A(google.maps.event.addListener(oe, "drag", E)), w && I(google.maps.event.addListener(oe, "center_changed", w)), M && he(google.maps.event.addListener(oe, "radius_changed", M)), F(oe), x && x(oe), () => {
      L !== null && google.maps.event.removeListener(L), N !== null && google.maps.event.removeListener(N), V !== null && google.maps.event.removeListener(V), Z !== null && google.maps.event.removeListener(Z), Y !== null && google.maps.event.removeListener(Y), J !== null && google.maps.event.removeListener(J), D !== null && google.maps.event.removeListener(D), S !== null && google.maps.event.removeListener(S), O !== null && google.maps.event.removeListener(O), U !== null && google.maps.event.removeListener(U), X !== null && google.maps.event.removeListener(X), le !== null && google.maps.event.removeListener(le), v && v(oe), oe.setMap(null);
    };
  }, []), null;
}
me(qrt);
class Grt extends pe {
  constructor() {
    super(...arguments), Ce(this, "registeredEvents", []), Ce(this, "state", {
      circle: null
    }), Ce(this, "setCircleCallback", () => {
      this.state.circle !== null && this.props.onLoad && this.props.onLoad(this.state.circle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Circle(o0(o0({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Jt({
      updaterMap: $q,
      eventMap: Wq,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        circle: t
      };
    }, this.setCircleCallback);
  }
  componentDidUpdate(t) {
    this.state.circle !== null && (un(this.registeredEvents), this.registeredEvents = Jt({
      updaterMap: $q,
      eventMap: Wq,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.circle
    }));
  }
  componentWillUnmount() {
    if (this.state.circle !== null) {
      var t;
      this.props.onUnmount && this.props.onUnmount(this.state.circle), un(this.registeredEvents), (t = this.state.circle) === null || t === void 0 || t.setMap(null);
    }
  }
  render() {
    return null;
  }
}
Ce(Grt, "contextType", At);
function Vq(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function i0(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Vq(Object(n), !0).forEach(function(r) {
      Ce(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Vq(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Zq = {
  onClick: "click",
  onDblClick: "dblclick",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onAddFeature: "addfeature",
  onRemoveFeature: "removefeature",
  onRemoveProperty: "removeproperty",
  onSetGeometry: "setgeometry",
  onSetProperty: "setproperty"
}, qq = {
  add(e, t) {
    e.add(t);
  },
  addgeojson(e, t, n) {
    e.addGeoJson(t, n);
  },
  contains(e, t) {
    e.contains(t);
  },
  foreach(e, t) {
    e.forEach(t);
  },
  loadgeojson(e, t, n, r) {
    e.loadGeoJson(t, n, r);
  },
  overridestyle(e, t, n) {
    e.overrideStyle(t, n);
  },
  remove(e, t) {
    e.remove(t);
  },
  revertstyle(e, t) {
    e.revertStyle(t);
  },
  controlposition(e, t) {
    e.setControlPosition(t);
  },
  controls(e, t) {
    e.setControls(t);
  },
  drawingmode(e, t) {
    e.setDrawingMode(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  style(e, t) {
    e.setStyle(t);
  },
  togeojson(e, t) {
    e.toGeoJson(t);
  }
};
function Krt(e) {
  var {
    options: t,
    onClick: n,
    onDblClick: r,
    onMouseDown: o,
    onMouseMove: i,
    onMouseOut: a,
    onMouseOver: s,
    onMouseUp: l,
    onRightClick: u,
    onAddFeature: c,
    onRemoveFeature: p,
    onRemoveProperty: d,
    onSetGeometry: g,
    onSetProperty: f,
    onLoad: m,
    onUnmount: b
  } = e, E = ge(At), [w, M] = k(null), [x, v] = k(null), [C, P] = k(null), [F, L] = k(null), [B, N] = k(null), [$, V] = k(null), [H, Z] = k(null), [K, Y] = k(null), [Q, J] = k(null), [_, D] = k(null), [z, S] = k(null), [W, O] = k(null), [j, U] = k(null), [T, q] = k(null);
  return h(() => {
    w !== null && w.setMap(E);
  }, [E]), h(() => {
    w && r && (x !== null && google.maps.event.removeListener(x), v(google.maps.event.addListener(w, "dblclick", r)));
  }, [r]), h(() => {
    w && o && (C !== null && google.maps.event.removeListener(C), P(google.maps.event.addListener(w, "mousedown", o)));
  }, [o]), h(() => {
    w && i && (F !== null && google.maps.event.removeListener(F), L(google.maps.event.addListener(w, "mousemove", i)));
  }, [i]), h(() => {
    w && a && (B !== null && google.maps.event.removeListener(B), N(google.maps.event.addListener(w, "mouseout", a)));
  }, [a]), h(() => {
    w && s && ($ !== null && google.maps.event.removeListener($), V(google.maps.event.addListener(w, "mouseover", s)));
  }, [s]), h(() => {
    w && l && (H !== null && google.maps.event.removeListener(H), Z(google.maps.event.addListener(w, "mouseup", l)));
  }, [l]), h(() => {
    w && u && (K !== null && google.maps.event.removeListener(K), Y(google.maps.event.addListener(w, "rightclick", u)));
  }, [u]), h(() => {
    w && n && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(w, "click", n)));
  }, [n]), h(() => {
    w && c && (_ !== null && google.maps.event.removeListener(_), D(google.maps.event.addListener(w, "addfeature", c)));
  }, [c]), h(() => {
    w && p && (z !== null && google.maps.event.removeListener(z), S(google.maps.event.addListener(w, "removefeature", p)));
  }, [p]), h(() => {
    w && d && (W !== null && google.maps.event.removeListener(W), O(google.maps.event.addListener(w, "removeproperty", d)));
  }, [d]), h(() => {
    w && g && (j !== null && google.maps.event.removeListener(j), U(google.maps.event.addListener(w, "setgeometry", g)));
  }, [g]), h(() => {
    w && f && (T !== null && google.maps.event.removeListener(T), q(google.maps.event.addListener(w, "setproperty", f)));
  }, [f]), h(() => {
    if (E !== null) {
      var A = new google.maps.Data(i0(i0({}, t), {}, {
        map: E
      }));
      r && v(google.maps.event.addListener(A, "dblclick", r)), o && P(google.maps.event.addListener(A, "mousedown", o)), i && L(google.maps.event.addListener(A, "mousemove", i)), a && N(google.maps.event.addListener(A, "mouseout", a)), s && V(google.maps.event.addListener(A, "mouseover", s)), l && Z(google.maps.event.addListener(A, "mouseup", l)), u && Y(google.maps.event.addListener(A, "rightclick", u)), n && J(google.maps.event.addListener(A, "click", n)), c && D(google.maps.event.addListener(A, "addfeature", c)), p && S(google.maps.event.addListener(A, "removefeature", p)), d && O(google.maps.event.addListener(A, "removeproperty", d)), g && U(google.maps.event.addListener(A, "setgeometry", g)), f && q(google.maps.event.addListener(A, "setproperty", f)), M(A), m && m(A);
    }
    return () => {
      w && (x !== null && google.maps.event.removeListener(x), C !== null && google.maps.event.removeListener(C), F !== null && google.maps.event.removeListener(F), B !== null && google.maps.event.removeListener(B), $ !== null && google.maps.event.removeListener($), H !== null && google.maps.event.removeListener(H), K !== null && google.maps.event.removeListener(K), Q !== null && google.maps.event.removeListener(Q), _ !== null && google.maps.event.removeListener(_), z !== null && google.maps.event.removeListener(z), W !== null && google.maps.event.removeListener(W), j !== null && google.maps.event.removeListener(j), T !== null && google.maps.event.removeListener(T), b && b(w), w.setMap(null));
    };
  }, []), null;
}
me(Krt);
class Xrt extends pe {
  constructor() {
    super(...arguments), Ce(this, "registeredEvents", []), Ce(this, "state", {
      data: null
    }), Ce(this, "setDataCallback", () => {
      this.state.data !== null && this.props.onLoad && this.props.onLoad(this.state.data);
    });
  }
  componentDidMount() {
    if (this.context !== null) {
      var t = new google.maps.Data(i0(i0({}, this.props.options), {}, {
        map: this.context
      }));
      this.registeredEvents = Jt({
        updaterMap: qq,
        eventMap: Zq,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        data: t
      }), this.setDataCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.data !== null && (un(this.registeredEvents), this.registeredEvents = Jt({
      updaterMap: qq,
      eventMap: Zq,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.data
    }));
  }
  componentWillUnmount() {
    this.state.data !== null && (this.props.onUnmount && this.props.onUnmount(this.state.data), un(this.registeredEvents), this.state.data && this.state.data.setMap(null));
  }
  render() {
    return null;
  }
}
Ce(Xrt, "contextType", At);
function Gq(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Kq(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Gq(Object(n), !0).forEach(function(r) {
      Ce(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Gq(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Xq = {
  onClick: "click",
  onDefaultViewportChanged: "defaultviewport_changed",
  onStatusChanged: "status_changed"
}, Yq = {
  options(e, t) {
    e.setOptions(t);
  },
  url(e, t) {
    e.setUrl(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
class Yrt extends pe {
  constructor() {
    super(...arguments), Ce(this, "registeredEvents", []), Ce(this, "state", {
      kmlLayer: null
    }), Ce(this, "setKmlLayerCallback", () => {
      this.state.kmlLayer !== null && this.props.onLoad && this.props.onLoad(this.state.kmlLayer);
    });
  }
  componentDidMount() {
    var t = new google.maps.KmlLayer(Kq(Kq({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Jt({
      updaterMap: Yq,
      eventMap: Xq,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        kmlLayer: t
      };
    }, this.setKmlLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.kmlLayer !== null && (un(this.registeredEvents), this.registeredEvents = Jt({
      updaterMap: Yq,
      eventMap: Xq,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.kmlLayer
    }));
  }
  componentWillUnmount() {
    this.state.kmlLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.kmlLayer), un(this.registeredEvents), this.state.kmlLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Ce(Yrt, "contextType", At);
function Ase(e, t) {
  return typeof t == "function" ? t(e.offsetWidth, e.offsetHeight) : {
    x: 0,
    y: 0
  };
}
function Jrt(e, t) {
  return new t(e.lat, e.lng);
}
function Qrt(e, t) {
  return new t(new google.maps.LatLng(e.ne.lat, e.ne.lng), new google.maps.LatLng(e.sw.lat, e.sw.lng));
}
function eot(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function tot(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function not(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n.getNorthEast()), o = e && e.fromLatLngToDivPixel(n.getSouthWest());
  return r && o ? {
    left: "".concat(o.x + t.x, "px"),
    top: "".concat(r.y + t.y, "px"),
    width: "".concat(r.x - o.x - t.x, "px"),
    height: "".concat(o.y - r.y - t.y, "px")
  } : {
    left: "-9999px",
    top: "-9999px"
  };
}
function rot(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n);
  if (r) {
    var {
      x: o,
      y: i
    } = r;
    return {
      left: "".concat(o + t.x, "px"),
      top: "".concat(i + t.y, "px")
    };
  }
  return {
    left: "-9999px",
    top: "-9999px"
  };
}
function Rse(e, t, n, r) {
  return n !== void 0 ? not(e, t, tot(n, google.maps.LatLngBounds, Qrt)) : rot(e, t, eot(r, google.maps.LatLng, Jrt));
}
function oot(e, t) {
  return e.left === t.left && e.top === t.top && e.width === t.height && e.height === t.height;
}
function Jq(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function iot(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Jq(Object(n), !0).forEach(function(r) {
      Ce(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Jq(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function sot(e, t, n, r, o) {
  class i extends google.maps.OverlayView {
    constructor(s, l, u, c) {
      super(), this.container = s, this.pane = l, this.position = u, this.bounds = c;
    }
    onAdd() {
      var s, l = (s = this.getPanes()) === null || s === void 0 ? void 0 : s[this.pane];
      l == null || l.appendChild(this.container);
    }
    draw() {
      var s = this.getProjection(), l = iot({}, this.container ? Ase(this.container, o) : {
        x: 0,
        y: 0
      }), u = Rse(s, l, this.bounds, this.position);
      for (var [c, p] of Object.entries(u))
        this.container.style[c] = p;
    }
    onRemove() {
      this.container.parentNode !== null && this.container.parentNode.removeChild(this.container);
    }
  }
  return new i(e, t, n, r);
}
function Qq(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function aot(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Qq(Object(n), !0).forEach(function(r) {
      Ce(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Qq(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function eG(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLng ? e : new google.maps.LatLng(e.lat, e.lng);
  return t + "";
}
function tG(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLngBounds ? e : new google.maps.LatLngBounds(new google.maps.LatLng(e.south, e.east), new google.maps.LatLng(e.north, e.west));
  return t + "";
}
function lot(e) {
  var {
    position: t,
    bounds: n,
    mapPaneName: r,
    zIndex: o,
    onLoad: i,
    onUnmount: a,
    getPixelPositionOffset: s,
    children: l
  } = e, u = ge(At), c = ln(() => {
    var d = document.createElement("div");
    return d.style.position = "absolute", d;
  }, []), p = ln(() => sot(c, r, t, n, s), [c, r, t, n]);
  return h(() => (i == null || i(p), p == null || p.setMap(u), () => {
    a == null || a(p), p == null || p.setMap(null);
  }), [u, p]), h(() => {
    c.style.zIndex = "".concat(o);
  }, [o, c]), wi.createPortal(l, c);
}
me(lot);
class Qp extends pe {
  constructor(t) {
    super(t), Ce(this, "state", {
      paneEl: null,
      containerStyle: {
        // set initial position
        position: "absolute"
      }
    }), Ce(this, "updatePane", () => {
      var r = this.props.mapPaneName, o = this.overlayView.getPanes();
      Go(!!r, "OverlayView requires props.mapPaneName but got %s", r), o ? this.setState({
        paneEl: o[r]
      }) : this.setState({
        paneEl: null
      });
    }), Ce(this, "onAdd", () => {
      var r, o;
      this.updatePane(), (r = (o = this.props).onLoad) === null || r === void 0 || r.call(o, this.overlayView);
    }), Ce(this, "onPositionElement", () => {
      var r = this.overlayView.getProjection(), o = aot({
        x: 0,
        y: 0
      }, this.containerRef.current ? Ase(this.containerRef.current, this.props.getPixelPositionOffset) : {}), i = Rse(r, o, this.props.bounds, this.props.position);
      if (!oot(i, {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        left: this.state.containerStyle.left,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        top: this.state.containerStyle.top,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        width: this.state.containerStyle.width,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        height: this.state.containerStyle.height
      })) {
        var a, s, l, u;
        this.setState({
          containerStyle: {
            top: (a = i.top) !== null && a !== void 0 ? a : 0,
            left: (s = i.left) !== null && s !== void 0 ? s : 0,
            width: (l = i.width) !== null && l !== void 0 ? l : 0,
            height: (u = i.height) !== null && u !== void 0 ? u : 0,
            position: "absolute"
          }
        });
      }
    }), Ce(this, "draw", () => {
      this.onPositionElement();
    }), Ce(this, "onRemove", () => {
      var r, o;
      this.setState(() => ({
        paneEl: null
      })), (r = (o = this.props).onUnmount) === null || r === void 0 || r.call(o, this.overlayView);
    }), this.containerRef = so();
    var n = new google.maps.OverlayView();
    n.onAdd = this.onAdd, n.draw = this.draw, n.onRemove = this.onRemove, this.overlayView = n;
  }
  componentDidMount() {
    this.overlayView.setMap(this.context);
  }
  componentDidUpdate(t) {
    var n = eG(t.position), r = eG(this.props.position), o = tG(t.bounds), i = tG(this.props.bounds);
    (n !== r || o !== i) && this.overlayView.draw(), t.mapPaneName !== this.props.mapPaneName && this.updatePane();
  }
  componentWillUnmount() {
    this.overlayView.setMap(null);
  }
  render() {
    var t = this.state.paneEl;
    return t ? wi.createPortal(ee.jsx("div", {
      ref: this.containerRef,
      style: this.state.containerStyle,
      children: at.only(this.props.children)
    }), t) : null;
  }
}
Ce(Qp, "FLOAT_PANE", "floatPane");
Ce(Qp, "MAP_PANE", "mapPane");
Ce(Qp, "MARKER_LAYER", "markerLayer");
Ce(Qp, "OVERLAY_LAYER", "overlayLayer");
Ce(Qp, "OVERLAY_MOUSE_TARGET", "overlayMouseTarget");
Ce(Qp, "contextType", At);
function uot() {
}
function nG(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function rG(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? nG(Object(n), !0).forEach(function(r) {
      Ce(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : nG(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var oG = {
  onDblClick: "dblclick",
  onClick: "click"
}, iG = {
  opacity(e, t) {
    e.setOpacity(t);
  }
};
function cot(e) {
  var {
    url: t,
    bounds: n,
    options: r,
    visible: o
  } = e, i = ge(At), a = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east)), s = ln(() => new google.maps.GroundOverlay(t, a, r), []);
  return h(() => {
    s !== null && s.setMap(i);
  }, [i]), h(() => {
    typeof t < "u" && s !== null && (s.set("url", t), s.setMap(i));
  }, [s, t]), h(() => {
    typeof o < "u" && s !== null && s.setOpacity(o ? 1 : 0);
  }, [s, o]), h(() => {
    var l = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east));
    typeof n < "u" && s !== null && (s.set("bounds", l), s.setMap(i));
  }, [s, n]), null;
}
me(cot);
class Ise extends pe {
  constructor() {
    super(...arguments), Ce(this, "registeredEvents", []), Ce(this, "state", {
      groundOverlay: null
    }), Ce(this, "setGroundOverlayCallback", () => {
      this.state.groundOverlay !== null && this.props.onLoad && this.props.onLoad(this.state.groundOverlay);
    });
  }
  componentDidMount() {
    Go(!!this.props.url || !!this.props.bounds, "For GroundOverlay, url and bounds are passed in to constructor and are immutable after instantiated. This is the behavior of Google Maps JavaScript API v3 ( See https://developers.google.com/maps/documentation/javascript/reference#GroundOverlay) Hence, use the corresponding two props provided by `react-google-maps-api`, url and bounds. In some cases, you'll need the GroundOverlay component to reflect the changes of url and bounds. You can leverage the React's key property to remount the component. Typically, just `key={url}` would serve your need. See https://github.com/tomchentw/react-google-maps/issues/655");
    var t = new google.maps.GroundOverlay(this.props.url, this.props.bounds, rG(rG({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Jt({
      updaterMap: iG,
      eventMap: oG,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        groundOverlay: t
      };
    }, this.setGroundOverlayCallback);
  }
  componentDidUpdate(t) {
    this.state.groundOverlay !== null && (un(this.registeredEvents), this.registeredEvents = Jt({
      updaterMap: iG,
      eventMap: oG,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.groundOverlay
    }));
  }
  componentWillUnmount() {
    this.state.groundOverlay && (this.props.onUnmount && this.props.onUnmount(this.state.groundOverlay), this.state.groundOverlay.setMap(null));
  }
  render() {
    return null;
  }
}
Ce(Ise, "defaultProps", {
  onLoad: uot
});
Ce(Ise, "contextType", At);
function sG(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function s0(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? sG(Object(n), !0).forEach(function(r) {
      Ce(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : sG(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var aG = {}, lG = {
  data(e, t) {
    e.setData(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function pot(e) {
  var {
    data: t,
    onLoad: n,
    onUnmount: r,
    options: o
  } = e, i = ge(At), [a, s] = k(null);
  return h(() => {
    google.maps.visualization || Go(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} in useJsApiScript? %s', google.maps.visualization);
  }, []), h(() => {
    Go(!!t, "data property is required in HeatmapLayer %s", t);
  }, [t]), h(() => {
    a !== null && a.setMap(i);
  }, [i]), h(() => {
    o && a !== null && a.setOptions(o);
  }, [a, o]), h(() => {
    var l = new google.maps.visualization.HeatmapLayer(s0(s0({}, o), {}, {
      data: t,
      map: i
    }));
    return s(l), n && n(l), () => {
      a !== null && (r && r(a), a.setMap(null));
    };
  }, []), null;
}
me(pot);
class dot extends pe {
  constructor() {
    super(...arguments), Ce(this, "registeredEvents", []), Ce(this, "state", {
      heatmapLayer: null
    }), Ce(this, "setHeatmapLayerCallback", () => {
      this.state.heatmapLayer !== null && this.props.onLoad && this.props.onLoad(this.state.heatmapLayer);
    });
  }
  componentDidMount() {
    Go(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} to <LoadScript />? %s', google.maps.visualization), Go(!!this.props.data, "data property is required in HeatmapLayer %s", this.props.data);
    var t = new google.maps.visualization.HeatmapLayer(s0(s0({}, this.props.options), {}, {
      data: this.props.data,
      map: this.context
    }));
    this.registeredEvents = Jt({
      updaterMap: lG,
      eventMap: aG,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        heatmapLayer: t
      };
    }, this.setHeatmapLayerCallback);
  }
  componentDidUpdate(t) {
    un(this.registeredEvents), this.registeredEvents = Jt({
      updaterMap: lG,
      eventMap: aG,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.heatmapLayer
    });
  }
  componentWillUnmount() {
    this.state.heatmapLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.heatmapLayer), un(this.registeredEvents), this.state.heatmapLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Ce(dot, "contextType", At);
var uG = {
  onCloseClick: "closeclick",
  onPanoChanged: "pano_changed",
  onPositionChanged: "position_changed",
  onPovChanged: "pov_changed",
  onResize: "resize",
  onStatusChanged: "status_changed",
  onVisibleChanged: "visible_changed",
  onZoomChanged: "zoom_changed"
}, cG = {
  register(e, t, n) {
    e.registerPanoProvider(t, n);
  },
  links(e, t) {
    e.setLinks(t);
  },
  motionTracking(e, t) {
    e.setMotionTracking(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  pano(e, t) {
    e.setPano(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  pov(e, t) {
    e.setPov(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zoom(e, t) {
    e.setZoom(t);
  }
};
class fot extends pe {
  constructor() {
    super(...arguments), Ce(this, "registeredEvents", []), Ce(this, "state", {
      streetViewPanorama: null
    }), Ce(this, "setStreetViewPanoramaCallback", () => {
      this.state.streetViewPanorama !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewPanorama);
    });
  }
  componentDidMount() {
    var t, n, r = (t = (n = this.context) === null || n === void 0 ? void 0 : n.getStreetView()) !== null && t !== void 0 ? t : null;
    this.registeredEvents = Jt({
      updaterMap: cG,
      eventMap: uG,
      prevProps: {},
      nextProps: this.props,
      instance: r
    }), this.setState(() => ({
      streetViewPanorama: r
    }), this.setStreetViewPanoramaCallback);
  }
  componentDidUpdate(t) {
    this.state.streetViewPanorama !== null && (un(this.registeredEvents), this.registeredEvents = Jt({
      updaterMap: cG,
      eventMap: uG,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.streetViewPanorama
    }));
  }
  componentWillUnmount() {
    this.state.streetViewPanorama !== null && (this.props.onUnmount && this.props.onUnmount(this.state.streetViewPanorama), un(this.registeredEvents), this.state.streetViewPanorama.setVisible(!1));
  }
  render() {
    return null;
  }
}
Ce(fot, "contextType", At);
class hot extends pe {
  constructor() {
    super(...arguments), Ce(this, "state", {
      streetViewService: null
    }), Ce(this, "setStreetViewServiceCallback", () => {
      this.state.streetViewService !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewService);
    });
  }
  componentDidMount() {
    var t = new google.maps.StreetViewService();
    this.setState(function() {
      return {
        streetViewService: t
      };
    }, this.setStreetViewServiceCallback);
  }
  componentWillUnmount() {
    this.state.streetViewService !== null && this.props.onUnmount && this.props.onUnmount(this.state.streetViewService);
  }
  render() {
    return null;
  }
}
Ce(hot, "contextType", At);
var pG = {
  onDirectionsChanged: "directions_changed"
}, dG = {
  directions(e, t) {
    e.setDirections(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  panel(e, t) {
    e.setPanel(t);
  },
  routeIndex(e, t) {
    e.setRouteIndex(t);
  }
};
class got extends pe {
  constructor() {
    super(...arguments), Ce(this, "registeredEvents", []), Ce(this, "state", {
      directionsRenderer: null
    }), Ce(this, "setDirectionsRendererCallback", () => {
      this.state.directionsRenderer !== null && (this.state.directionsRenderer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.directionsRenderer));
    });
  }
  componentDidMount() {
    var t = new google.maps.DirectionsRenderer(this.props.options);
    this.registeredEvents = Jt({
      updaterMap: dG,
      eventMap: pG,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        directionsRenderer: t
      };
    }, this.setDirectionsRendererCallback);
  }
  componentDidUpdate(t) {
    this.state.directionsRenderer !== null && (un(this.registeredEvents), this.registeredEvents = Jt({
      updaterMap: dG,
      eventMap: pG,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.directionsRenderer
    }));
  }
  componentWillUnmount() {
    this.state.directionsRenderer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.directionsRenderer), un(this.registeredEvents), this.state.directionsRenderer && this.state.directionsRenderer.setMap(null));
  }
  render() {
    return null;
  }
}
Ce(got, "contextType", At);
var fG = {
  onPlacesChanged: "places_changed"
}, hG = {
  bounds(e, t) {
    e.setBounds(t);
  }
};
class Nse extends pe {
  constructor() {
    super(...arguments), Ce(this, "registeredEvents", []), Ce(this, "containerElement", so()), Ce(this, "state", {
      searchBox: null
    }), Ce(this, "setSearchBoxCallback", () => {
      this.state.searchBox !== null && this.props.onLoad && this.props.onLoad(this.state.searchBox);
    });
  }
  componentDidMount() {
    if (Go(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places), this.containerElement !== null && this.containerElement.current !== null) {
      var t = this.containerElement.current.querySelector("input");
      if (t !== null) {
        var n = new google.maps.places.SearchBox(t, this.props.options);
        this.registeredEvents = Jt({
          updaterMap: hG,
          eventMap: fG,
          prevProps: {},
          nextProps: this.props,
          instance: n
        }), this.setState(function() {
          return {
            searchBox: n
          };
        }, this.setSearchBoxCallback);
      }
    }
  }
  componentDidUpdate(t) {
    this.state.searchBox !== null && (un(this.registeredEvents), this.registeredEvents = Jt({
      updaterMap: hG,
      eventMap: fG,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.searchBox
    }));
  }
  componentWillUnmount() {
    this.state.searchBox !== null && (this.props.onUnmount && this.props.onUnmount(this.state.searchBox), un(this.registeredEvents));
  }
  render() {
    return ee.jsx("div", {
      ref: this.containerElement,
      children: at.only(this.props.children)
    });
  }
}
Ce(Nse, "contextType", At);
var gG = {
  onPlaceChanged: "place_changed"
}, mG = {
  bounds(e, t) {
    e.setBounds(t);
  },
  restrictions(e, t) {
    e.setComponentRestrictions(t);
  },
  fields(e, t) {
    e.setFields(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  types(e, t) {
    e.setTypes(t);
  }
};
class Bse extends pe {
  constructor() {
    super(...arguments), Ce(this, "registeredEvents", []), Ce(this, "containerElement", so()), Ce(this, "state", {
      autocomplete: null
    }), Ce(this, "setAutocompleteCallback", () => {
      this.state.autocomplete !== null && this.props.onLoad && this.props.onLoad(this.state.autocomplete);
    });
  }
  componentDidMount() {
    var t;
    Go(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places);
    var n = (t = this.containerElement.current) === null || t === void 0 ? void 0 : t.querySelector("input");
    if (n) {
      var r = new google.maps.places.Autocomplete(n, this.props.options);
      this.registeredEvents = Jt({
        updaterMap: mG,
        eventMap: gG,
        prevProps: {},
        nextProps: this.props,
        instance: r
      }), this.setState(() => ({
        autocomplete: r
      }), this.setAutocompleteCallback);
    }
  }
  componentDidUpdate(t) {
    un(this.registeredEvents), this.registeredEvents = Jt({
      updaterMap: mG,
      eventMap: gG,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.autocomplete
    });
  }
  componentWillUnmount() {
    this.state.autocomplete !== null && un(this.registeredEvents);
  }
  render() {
    return ee.jsx("div", {
      ref: this.containerElement,
      className: this.props.className,
      children: at.only(this.props.children)
    });
  }
}
Ce(Bse, "defaultProps", {
  className: ""
});
Ce(Bse, "contextType", At);
function rst({
  googleMapsApiKey: e,
  children: t,
  ...n
}) {
  return /* @__PURE__ */ ee.jsx(
    _se,
    {
      libraries: ["places", "marker", "maps"],
      googleMapsApiKey: e,
      ...n,
      children: t
    }
  );
}
function ost(e) {
  const { children: t = !1 } = e, [n, r] = k([]);
  function o(u) {
    return !!n.some((c) => c.key === u);
  }
  function i(u) {
    var c;
    return (c = n.find((p) => p.key === u)) == null ? void 0 : c.data;
  }
  function a(u, c) {
    const p = o(u);
    r(p ? (d) => [...d.filter((f) => f.key !== u), { key: u, data: c }] : [...n, { key: u, data: c }]);
  }
  function s(u) {
    r(n.filter((c) => c.key !== u));
  }
  function l() {
    r([]);
  }
  return /* @__PURE__ */ ee.jsx(
    Ij.Provider,
    {
      value: { modalIsOpen: o, modalData: i, openModal: a, closeModal: s, closeAll: l },
      children: t
    }
  );
}
let mot = { data: "" }, vot = (e) => typeof window == "object" ? ((e ? e.querySelector("#_goober") : window._goober) || Object.assign((e || document.head).appendChild(document.createElement("style")), { innerHTML: " ", id: "_goober" })).firstChild : e || mot, yot = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g, bot = /\/\*[^]*?\*\/|  +/g, vG = /\n+/g, nu = (e, t) => {
  let n = "", r = "", o = "";
  for (let i in e) {
    let a = e[i];
    i[0] == "@" ? i[1] == "i" ? n = i + " " + a + ";" : r += i[1] == "f" ? nu(a, i) : i + "{" + nu(a, i[1] == "k" ? "" : t) + "}" : typeof a == "object" ? r += nu(a, t ? t.replace(/([^,])+/g, (s) => i.replace(/([^,]*:\S+\([^)]*\))|([^,])+/g, (l) => /&/.test(l) ? l.replace(/&/g, s) : s ? s + " " + l : l)) : i) : a != null && (i = /^--/.test(i) ? i : i.replace(/[A-Z]/g, "-$&").toLowerCase(), o += nu.p ? nu.p(i, a) : i + ":" + a + ";");
  }
  return n + (t && o ? t + "{" + o + "}" : o) + r;
}, za = {}, Fse = (e) => {
  if (typeof e == "object") {
    let t = "";
    for (let n in e) t += n + Fse(e[n]);
    return t;
  }
  return e;
}, wot = (e, t, n, r, o) => {
  let i = Fse(e), a = za[i] || (za[i] = ((l) => {
    let u = 0, c = 11;
    for (; u < l.length; ) c = 101 * c + l.charCodeAt(u++) >>> 0;
    return "go" + c;
  })(i));
  if (!za[a]) {
    let l = i !== e ? e : ((u) => {
      let c, p, d = [{}];
      for (; c = yot.exec(u.replace(bot, "")); ) c[4] ? d.shift() : c[3] ? (p = c[3].replace(vG, " ").trim(), d.unshift(d[0][p] = d[0][p] || {})) : d[0][c[1]] = c[2].replace(vG, " ").trim();
      return d[0];
    })(e);
    za[a] = nu(o ? { ["@keyframes " + a]: l } : l, n ? "" : "." + a);
  }
  let s = n && za.g ? za.g : null;
  return n && (za.g = za[a]), ((l, u, c, p) => {
    p ? u.data = u.data.replace(p, l) : u.data.indexOf(l) === -1 && (u.data = c ? l + u.data : u.data + l);
  })(za[a], t, r, s), a;
}, Cot = (e, t, n) => e.reduce((r, o, i) => {
  let a = t[i];
  if (a && a.call) {
    let s = a(n), l = s && s.props && s.props.className || /^go/.test(s) && s;
    a = l ? "." + l : s && typeof s == "object" ? s.props ? "" : nu(s, "") : s === !1 ? "" : s;
  }
  return r + o + (a ?? "");
}, "");
function cx(e) {
  let t = this || {}, n = e.call ? e(t.p) : e;
  return wot(n.unshift ? n.raw ? Cot(n, [].slice.call(arguments, 1), t.p) : n.reduce((r, o) => Object.assign(r, o && o.call ? o(t.p) : o), {}) : n, vot(t.target), t.g, t.o, t.k);
}
let zse, VP, ZP;
cx.bind({ g: 1 });
let rl = cx.bind({ k: 1 });
function Oot(e, t, n, r) {
  nu.p = t, zse = e, VP = n, ZP = r;
}
function Tu(e, t) {
  let n = this || {};
  return function() {
    let r = arguments;
    function o(i, a) {
      let s = Object.assign({}, i), l = s.className || o.className;
      n.p = Object.assign({ theme: VP && VP() }, s), n.o = / *go\d+/.test(l), s.className = cx.apply(n, r) + (l ? " " + l : "");
      let u = e;
      return e[0] && (u = s.as || e, delete s.as), ZP && u[0] && ZP(s), zse(u, s);
    }
    return o;
  };
}
var xot = (e) => typeof e == "function", a0 = (e, t) => xot(e) ? e(t) : e, Eot = /* @__PURE__ */ (() => {
  let e = 0;
  return () => (++e).toString();
})(), Use = /* @__PURE__ */ (() => {
  let e;
  return () => {
    if (e === void 0 && typeof window < "u") {
      let t = matchMedia("(prefers-reduced-motion: reduce)");
      e = !t || t.matches;
    }
    return e;
  };
})(), kot = 20, Hse = (e, t) => {
  switch (t.type) {
    case 0:
      return { ...e, toasts: [t.toast, ...e.toasts].slice(0, kot) };
    case 1:
      return { ...e, toasts: e.toasts.map((i) => i.id === t.toast.id ? { ...i, ...t.toast } : i) };
    case 2:
      let { toast: n } = t;
      return Hse(e, { type: e.toasts.find((i) => i.id === n.id) ? 1 : 0, toast: n });
    case 3:
      let { toastId: r } = t;
      return { ...e, toasts: e.toasts.map((i) => i.id === r || r === void 0 ? { ...i, dismissed: !0, visible: !1 } : i) };
    case 4:
      return t.toastId === void 0 ? { ...e, toasts: [] } : { ...e, toasts: e.toasts.filter((i) => i.id !== t.toastId) };
    case 5:
      return { ...e, pausedAt: t.time };
    case 6:
      let o = t.time - (e.pausedAt || 0);
      return { ...e, pausedAt: void 0, toasts: e.toasts.map((i) => ({ ...i, pauseDuration: i.pauseDuration + o })) };
  }
}, By = [], xc = { toasts: [], pausedAt: void 0 }, ip = (e) => {
  xc = Hse(xc, e), By.forEach((t) => {
    t(xc);
  });
}, Lot = { blank: 4e3, error: 4e3, success: 2e3, loading: 1 / 0, custom: 4e3 }, _ot = (e = {}) => {
  let [t, n] = k(xc), r = dt(xc);
  h(() => (r.current !== xc && n(xc), By.push(n), () => {
    let i = By.indexOf(n);
    i > -1 && By.splice(i, 1);
  }), []);
  let o = t.toasts.map((i) => {
    var a, s, l;
    return { ...e, ...e[i.type], ...i, removeDelay: i.removeDelay || ((a = e[i.type]) == null ? void 0 : a.removeDelay) || (e == null ? void 0 : e.removeDelay), duration: i.duration || ((s = e[i.type]) == null ? void 0 : s.duration) || (e == null ? void 0 : e.duration) || Lot[i.type], style: { ...e.style, ...(l = e[i.type]) == null ? void 0 : l.style, ...i.style } };
  });
  return { ...t, toasts: o };
}, Pot = (e, t = "blank", n) => ({ createdAt: Date.now(), visible: !0, dismissed: !1, type: t, ariaProps: { role: "status", "aria-live": "polite" }, message: e, pauseDuration: 0, ...n, id: (n == null ? void 0 : n.id) || Eot() }), Kg = (e) => (t, n) => {
  let r = Pot(t, e, n);
  return ip({ type: 2, toast: r }), r.id;
}, Pi = (e, t) => Kg("blank")(e, t);
Pi.error = Kg("error");
Pi.success = Kg("success");
Pi.loading = Kg("loading");
Pi.custom = Kg("custom");
Pi.dismiss = (e) => {
  ip({ type: 3, toastId: e });
};
Pi.remove = (e) => ip({ type: 4, toastId: e });
Pi.promise = (e, t, n) => {
  let r = Pi.loading(t.loading, { ...n, ...n == null ? void 0 : n.loading });
  return typeof e == "function" && (e = e()), e.then((o) => {
    let i = t.success ? a0(t.success, o) : void 0;
    return i ? Pi.success(i, { id: r, ...n, ...n == null ? void 0 : n.success }) : Pi.dismiss(r), o;
  }).catch((o) => {
    let i = t.error ? a0(t.error, o) : void 0;
    i ? Pi.error(i, { id: r, ...n, ...n == null ? void 0 : n.error }) : Pi.dismiss(r);
  }), e;
};
var Sot = (e, t) => {
  ip({ type: 1, toast: { id: e, height: t } });
}, Mot = () => {
  ip({ type: 5, time: Date.now() });
}, zf = /* @__PURE__ */ new Map(), Dot = 1e3, Tot = (e, t = Dot) => {
  if (zf.has(e)) return;
  let n = setTimeout(() => {
    zf.delete(e), ip({ type: 4, toastId: e });
  }, t);
  zf.set(e, n);
}, jot = (e) => {
  let { toasts: t, pausedAt: n } = _ot(e);
  h(() => {
    if (n) return;
    let i = Date.now(), a = t.map((s) => {
      if (s.duration === 1 / 0) return;
      let l = (s.duration || 0) + s.pauseDuration - (i - s.createdAt);
      if (l < 0) {
        s.visible && Pi.dismiss(s.id);
        return;
      }
      return setTimeout(() => Pi.dismiss(s.id), l);
    });
    return () => {
      a.forEach((s) => s && clearTimeout(s));
    };
  }, [t, n]);
  let r = Jn(() => {
    n && ip({ type: 6, time: Date.now() });
  }, [n]), o = Jn((i, a) => {
    let { reverseOrder: s = !1, gutter: l = 8, defaultPosition: u } = a || {}, c = t.filter((g) => (g.position || u) === (i.position || u) && g.height), p = c.findIndex((g) => g.id === i.id), d = c.filter((g, f) => f < p && g.visible).length;
    return c.filter((g) => g.visible).slice(...s ? [d + 1] : [0, d]).reduce((g, f) => g + (f.height || 0) + l, 0);
  }, [t]);
  return h(() => {
    t.forEach((i) => {
      if (i.dismissed) Tot(i.id, i.removeDelay);
      else {
        let a = zf.get(i.id);
        a && (clearTimeout(a), zf.delete(i.id));
      }
    });
  }, [t]), { toasts: t, handlers: { updateHeight: Sot, startPause: Mot, endPause: r, calculateOffset: o } };
}, Aot = rl`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`, Rot = rl`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`, Iot = rl`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`, Not = Tu("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${Aot} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${Rot} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${(e) => e.secondary || "#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${Iot} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`, Bot = rl`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, Fot = Tu("div")`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${(e) => e.secondary || "#e0e0e0"};
  border-right-color: ${(e) => e.primary || "#616161"};
  animation: ${Bot} 1s linear infinite;
`, zot = rl`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`, Uot = rl`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`, Hot = Tu("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${zot} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${Uot} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${(e) => e.secondary || "#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`, Wot = Tu("div")`
  position: absolute;
`, $ot = Tu("div")`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`, Vot = rl`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`, Zot = Tu("div")`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${Vot} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`, qot = ({ toast: e }) => {
  let { icon: t, type: n, iconTheme: r } = e;
  return t !== void 0 ? typeof t == "string" ? Ne.createElement(Zot, null, t) : t : n === "blank" ? null : Ne.createElement($ot, null, Ne.createElement(Fot, { ...r }), n !== "loading" && Ne.createElement(Wot, null, n === "error" ? Ne.createElement(Not, { ...r }) : Ne.createElement(Hot, { ...r })));
}, Got = (e) => `
0% {transform: translate3d(0,${e * -200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`, Kot = (e) => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${e * -150}%,-1px) scale(.6); opacity:0;}
`, Xot = "0%{opacity:0;} 100%{opacity:1;}", Yot = "0%{opacity:1;} 100%{opacity:0;}", Jot = Tu("div")`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`, Qot = Tu("div")`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`, eit = (e, t) => {
  let n = e.includes("top") ? 1 : -1, [r, o] = Use() ? [Xot, Yot] : [Got(n), Kot(n)];
  return { animation: t ? `${rl(r)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards` : `${rl(o)} 0.4s forwards cubic-bezier(.06,.71,.55,1)` };
}, tit = Ne.memo(({ toast: e, position: t, style: n, children: r }) => {
  let o = e.height ? eit(e.position || t || "top-center", e.visible) : { opacity: 0 }, i = Ne.createElement(qot, { toast: e }), a = Ne.createElement(Qot, { ...e.ariaProps }, a0(e.message, e));
  return Ne.createElement(Jot, { className: e.className, style: { ...o, ...n, ...e.style } }, typeof r == "function" ? r({ icon: i, message: a }) : Ne.createElement(Ne.Fragment, null, i, a));
});
Oot(Ne.createElement);
var nit = ({ id: e, className: t, style: n, onHeightUpdate: r, children: o }) => {
  let i = Ne.useCallback((a) => {
    if (a) {
      let s = () => {
        let l = a.getBoundingClientRect().height;
        r(e, l);
      };
      s(), new MutationObserver(s).observe(a, { subtree: !0, childList: !0, characterData: !0 });
    }
  }, [e, r]);
  return Ne.createElement("div", { ref: i, className: t, style: n }, o);
}, rit = (e, t) => {
  let n = e.includes("top"), r = n ? { top: 0 } : { bottom: 0 }, o = e.includes("center") ? { justifyContent: "center" } : e.includes("right") ? { justifyContent: "flex-end" } : {};
  return { left: 0, right: 0, display: "flex", position: "absolute", transition: Use() ? void 0 : "all 230ms cubic-bezier(.21,1.02,.73,1)", transform: `translateY(${t * (n ? 1 : -1)}px)`, ...r, ...o };
}, oit = cx`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`, Ey = 16, iit = ({ reverseOrder: e, position: t = "top-center", toastOptions: n, gutter: r, children: o, containerStyle: i, containerClassName: a }) => {
  let { toasts: s, handlers: l } = jot(n);
  return Ne.createElement("div", { id: "_rht_toaster", style: { position: "fixed", zIndex: 9999, top: Ey, left: Ey, right: Ey, bottom: Ey, pointerEvents: "none", ...i }, className: a, onMouseEnter: l.startPause, onMouseLeave: l.endPause }, s.map((u) => {
    let c = u.position || t, p = l.calculateOffset(u, { reverseOrder: e, gutter: r, defaultPosition: t }), d = rit(c, p);
    return Ne.createElement(nit, { id: u.id, key: u.id, onHeightUpdate: l.updateHeight, className: u.visible ? oit : "", style: d }, u.type === "custom" ? a0(u.message, u) : o ? o(u) : Ne.createElement(tit, { toast: u, position: c }));
  }));
}, yG = Pi;
function ist({ children: e }) {
  function t(n) {
    switch (n.type) {
      case "success":
        return yG.success(n.message, {
          style: {
            background: "#10B981",
            color: "#ffffff",
            padding: "12px 16px",
            fontSize: "14px",
            fontWeight: 600
          },
          iconTheme: {
            primary: "#059669",
            secondary: "#ffffff"
          }
        });
      case "danger":
        return yG.error(n.message, {
          style: {
            background: "#E11D48",
            color: "#ffffff",
            padding: "12px 16px",
            fontSize: "14px",
            fontWeight: 600
          },
          iconTheme: {
            primary: "#BE123C",
            secondary: "#ffffff"
          }
        });
    }
  }
  return /* @__PURE__ */ ee.jsxs(bse.Provider, { value: { showToast: t }, children: [
    /* @__PURE__ */ ee.jsx(
      iit,
      {
        position: "top-right",
        containerStyle: { zIndex: 999999999999999 }
      }
    ),
    e
  ] });
}
function Wse({ children: e, fallback: t = null }) {
  return Snt() ? /* @__PURE__ */ ee.jsx(ee.Fragment, { children: e() }) : /* @__PURE__ */ ee.jsx(ee.Fragment, { children: t });
}
let sit = class {
  constructor(t, n) {
    Xg(this, "pixelId");
    Xg(this, "autoConfig");
    Xg(this, "initialized");
    this.pixelId = t, this.autoConfig = (n == null ? void 0 : n.autoConfig) || !0, this.initialized = !1;
  }
  loadFacebookPixel() {
    if (window.fbq) return;
    const t = function(...o) {
      t.callMethod ? t.callMethod.apply(t, o) : t.queue.push(o);
    };
    window._fbq || (window._fbq = t), t.push = t, t.loaded = !0, t.version = "2.0", t.queue = [];
    const n = document.createElement("script");
    n.async = !0, n.src = "https://connect.facebook.net/en_US/fbevents.js";
    const r = document.getElementsByTagName("script")[0];
    if (!r.parentNode)
      throw new Error("No script tag found in the document");
    r.parentNode.insertBefore(n, r), window.fbq = t;
  }
  init(t = {}) {
    if (this.initialized = typeof window < "u" && !!window.fbq, this.loadFacebookPixel(), !window.fbq)
      throw new Error("window.fbq is not defined");
    this.autoConfig === !1 ? window.fbq("set", "autoConfig", !1, this.pixelId) : window.fbq("init", this.pixelId, t), this.initialized = !0;
  }
  pageView() {
    this.initialized && window.fbq && window.fbq("track", "PageView");
  }
  track(t, n) {
    this.initialized && window.fbq && window.fbq("track", t, n);
  }
  trackSingle(t, n, r) {
    this.initialized && window.fbq && window.fbq("trackSingle", t, n, r);
  }
  trackCustom(t, n) {
    this.initialized && window.fbq && window.fbq("trackCustom", t, n);
  }
  trackSingleCustom(t, n, r) {
    this.initialized && window.fbq && window.fbq("trackSingle", t, n, r);
  }
  grantConsent() {
    this.initialized && window.fbq && window.fbq("consent", "grant");
  }
  revokeConsent() {
    this.initialized && window.fbq && window.fbq("consent", "revoke");
  }
};
function ait(e) {
  const {
    pixelId: t,
    options: n,
    pageView: r,
    track: o,
    trackCustom: i,
    trackSingle: a,
    trackSingleCustom: s,
    grantConsent: l,
    revokeConsent: u
  } = e, c = new sit(t, n);
  return c.init(), r && c.pageView(), l && c.grantConsent(), u && c.revokeConsent(), o && c.track(...o), i && c.trackCustom(...i), a && c.trackSingle(t, ...a), s && c.trackSingleCustom(t, ...s), /* @__PURE__ */ ee.jsx(ee.Fragment, {});
}
function ast(e) {
  return process.env.NODE_ENV !== "production" && !e.showInDevMode ? /* @__PURE__ */ ee.jsx(ee.Fragment, {}) : /* @__PURE__ */ ee.jsx(Wse, { children: () => /* @__PURE__ */ ee.jsx(ait, { ...e }) });
}
function lst({
  coordinates: e,
  zoom: t = 18,
  draggable: n = !1,
  className: r,
  ...o
}) {
  return e ? /* @__PURE__ */ ee.jsx("div", { className: "arkynGoogleMapPinned " + r, ...o, children: /* @__PURE__ */ ee.jsx(
    Unt,
    {
      zoom: t,
      center: e,
      mapContainerStyle: {
        borderRadius: "var(--rounded-cards)",
        width: "100%",
        height: "100%"
      },
      children: /* @__PURE__ */ ee.jsx(Pse, { draggable: n, position: e })
    }
  ) }) : /* @__PURE__ */ ee.jsx("div", { className: "arkynGoogleMapPinnedEmpty " + r, ...o, children: /* @__PURE__ */ ee.jsx(vae, {}) });
}
function ust({
  onChange: e,
  onPlaceChanged: t,
  options: n,
  ...r
}) {
  const [o, i] = k(null), a = (l) => i(l), s = () => {
    var g, f, m, b;
    const u = o.getPlaces()[0], c = u == null ? void 0 : u.address_components;
    function p(E) {
      const w = c.find((M) => M.types[0] === E);
      return w ? w.long_name : "";
    }
    function d(E) {
      const w = c.find((M) => M.types[0] === E);
      return w ? w.short_name : "";
    }
    if (u) {
      const E = p("route"), w = p("street_number"), M = p("sublocality_level_1"), x = p("administrative_area_level_2"), v = p("administrative_area_level_1"), C = d("administrative_area_level_1"), P = p("postal_code"), F = (f = (g = u.geometry) == null ? void 0 : g.location) == null ? void 0 : f.lat(), L = (b = (m = u.geometry) == null ? void 0 : m.location) == null ? void 0 : b.lng();
      t && t({
        street: E,
        city: x,
        state: v,
        district: M,
        cep: P,
        streetNumber: w,
        stateShortName: C,
        coordinates: { lat: F, lng: L }
      });
    }
  };
  return /* @__PURE__ */ ee.jsx(
    Nse,
    {
      onLoad: a,
      onPlacesChanged: s,
      options: n,
      children: /* @__PURE__ */ ee.jsx(QO, { type: "text", onChange: (l) => e(l.target.value), ...r })
    }
  );
}
function $se(e) {
  const { dataLayer: t, dataLayerName: n } = e;
  return `
  window.${n} = window.${n} || [];
  window.${n}.push(${JSON.stringify(t)})`;
}
function lit(e) {
  const { id: t, events: n, dataLayer: r, dataLayerName: o, preview: i, auth: a } = e, s = `&gtm_auth=${a}`, l = `&gtm_preview=${i}`;
  t || console.warn("GTM Id is required");
  const u = `
    <iframe src="https://www.googletagmanager.com/ns.html?id=${t}${s}${l}&gtm_cookies_win=x"
      height="0" width="0" style="display:none;visibility:hidden" id="tag-manager"></iframe>`, c = `
    (function(w,d,s,l,i){w[l]=w[l]||[];
      w[l].push({'gtm.start': new Date().getTime(),event:'gtm.js', ${JSON.stringify(
    n
  ).slice(1, -1)}});
      var f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';
      j.async=true;j.src='https://www.googletagmanager.com/gtm.js?id='+i+dl+'${s}${l}&gtm_cookies_win=x';
      f.parentNode.insertBefore(j,f);
    })(window,document,'script','${o}','${t}');`, p = $se({ dataLayer: r, dataLayerName: o });
  return {
    iframe: u,
    script: c,
    dataLayerVar: p
  };
}
let uit = class {
  initializeDataScript(t) {
    const n = document.createElement("script");
    return n.innerHTML = t, n;
  }
  initializeGTMElements(t) {
    const n = lit(t), r = () => {
      const a = document.createElement("noscript");
      return a.innerHTML = n.iframe, a;
    }, o = () => {
      const a = document.createElement("script");
      return a.innerHTML = n.script, a;
    }, i = this.initializeDataScript(n.dataLayerVar);
    return {
      noScript: r,
      script: o,
      dataScript: i
    };
  }
  initializeDataLayer(t) {
    const { dataLayer: n, dataLayerName: r } = t;
    if (window[r]) return window[r].push(n);
    const o = $se({ dataLayer: n, dataLayerName: r }), i = this.initializeDataScript(o);
    document.head.insertBefore(i, document.head.childNodes[0]);
  }
  initialize(t) {
    const {
      events: n,
      gtmId: r,
      dataLayer: o,
      auth: i = "",
      preview: a = "",
      dataLayerName: s = "dataLayer"
    } = t, l = this.initializeGTMElements({
      id: r,
      events: n,
      dataLayer: o || void 0,
      dataLayerName: s,
      auth: i,
      preview: a
    });
    o && document.head.appendChild(l.dataScript), document.head.insertBefore(l.script(), document.head.childNodes[0]), document.body.insertBefore(l.noScript(), document.body.childNodes[0]);
  }
};
function cit(e) {
  return new uit().initialize(e), /* @__PURE__ */ ee.jsx(ee.Fragment, {});
}
function pst(e) {
  const {
    gtmId: t,
    auth: n = "",
    preview: r = "",
    dataLayerName: o = "dataLayer",
    events: i = {},
    dataLayer: a = {},
    showInDevMode: s = !1
  } = e;
  return process.env.NODE_ENV !== "production" && !s ? /* @__PURE__ */ ee.jsx(ee.Fragment, {}) : /* @__PURE__ */ ee.jsx(Wse, { children: () => /* @__PURE__ */ ee.jsx(
    cit,
    {
      auth: n,
      dataLayer: a,
      dataLayerName: o,
      events: i,
      gtmId: t,
      preview: r
    }
  ) });
}
export {
  yit as AlertContainer,
  bit as AlertContent,
  wit as AlertDescription,
  Cit as AlertIcon,
  Cae as AlertTitle,
  jit as AudioUpload,
  kit as Badge,
  Vit as BreadcrumbContainer,
  Zit as BreadcrumbLink,
  Uh as Button,
  Lit as Card,
  Ait as Checkbox,
  Wse as ClientOnly,
  sK as Divider,
  Git as DrawerContainer,
  Kit as DrawerHeader,
  tst as DrawerProvider,
  ast as FacebookPixel,
  Rit as FileUpload,
  jZ as FormController,
  Iit as FormError,
  AZ as FormLabel,
  lst as GoogleMap,
  rst as GoogleProvider,
  ust as GoogleSearchPlaces,
  pst as GoogleTagManager,
  eie as IconButton,
  mXe as ImageUpload,
  QO as Input,
  pet as ModalContainer,
  det as ModalFooter,
  fet as ModalHeader,
  ost as ModalProvider,
  Nit as MultiSelect,
  qit as Pagination,
  Bit as PhoneInput,
  Xit as Popover,
  zit as RadioBox,
  Fit as RadioGroup,
  Uit as RichText,
  Hit as Select,
  _it as Skeleton,
  iXe as Slider,
  Wit as Switch,
  w7 as TabButton,
  get as TabContainer,
  Pit as TableBody,
  Sit as TableCaption,
  Mit as TableContainer,
  Dit as TableFooter,
  Tit as TableHeader,
  $it as Textarea,
  Yit as Toast,
  ist as ToastProvider,
  tie as Tooltip,
  Oit as getHtmlFromRichTextValue,
  xit as getRichTextValueFromHtml,
  Eit as isHtml,
  iK as morpheme,
  Jit as useAutomation,
  Qit as useDrawer,
  dj as useFieldErrors,
  Fi as useFormController,
  Snt as useHydrated,
  est as useModal,
  Xie as useScopedParams,
  _nt as useToast
};
